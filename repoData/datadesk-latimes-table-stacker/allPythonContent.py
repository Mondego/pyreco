__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# latimes-table-stacker documentation build configuration file, created by
# sphinx-quickstart on Sat Mar 29 22:17:11 2014.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'latimes-table-stacker'
copyright = u'2014, Los Angeles Times Data Desk'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.3'
# The full version, including alpha/beta/rc tags.
release = '0.3'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'latimes-table-stackerdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'latimes-table-stacker.tex', u'latimes-table-stacker Documentation',
   u'Los Angeles Times Data Desk', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'latimes-table-stacker', u'latimes-table-stacker Documentation',
     [u'Los Angeles Times Data Desk'], 1)
]

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings")
    from django.core.management import execute_from_command_line
    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = settings
import os
import yaml

AWS_BUCKET_NAME = 'table-stacker'
ROOT_PATH = os.path.dirname(__file__)
TEMPLATE_DIRS = (
    os.path.join(ROOT_PATH, 'templates'),
)
YAML_DIR = os.path.join(ROOT_PATH, 'yaml')
CSV_DIR = os.path.join(ROOT_PATH, 'csv')
BUILD_DIR = os.path.join(ROOT_PATH, 'build')
BAKERY_VIEWS = [
    'table_stacker.views.TableDetailView',
    'table_stacker.views.TableListView',
    'table_stacker.sitemaps.SitemapView',
    'table_stacker.feeds.LatestTablesFeed',
    'table_stacker.api.TableDetailCSVView',
    'table_stacker.api.TableDetailXLSView',
    'table_stacker.api.TableDetailJSONView',
    'bakery.views.Buildable404View',
]
SITE_NAME = 'TableStacker Demonstration'
FACEBOOK_ADMINS = ['foo','bar']

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'database.db',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Los_Angeles'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = os.path.join(ROOT_PATH, 'media')

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = '/media/'

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = os.path.join(ROOT_PATH, 'static')

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# URL prefix for admin static files -- CSS, JavaScript and images.
# Make sure to use a trailing slash.
# Examples: "http://foo.com/static/admin/", "/static/admin/".
ADMIN_MEDIA_PREFIX = '/static/admin/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    # os.path.join(ROOT_PATH, 'templates', 'static'),
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'vmzcl*j1a(itb0o^g+5mxgct=hbj#h4z7j)f%ufbl#dtf66$-@'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'urls'

TEMPLATE_DIRS = (
    #os.path.join(ROOT_PATH, 'templates'),
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.contrib.auth.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media",
    "django.core.context_processors.static",
    "django.contrib.messages.context_processors.messages",
    'toolbox.context_processors.metadata',
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'toolbox',
    'bakery',
    'table_stacker',
    'south',
)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

########NEW FILE########
__FILENAME__ = compress
#!/usr/bin/env python
import os
import optparse
import subprocess
import sys

here = os.path.dirname(__file__)

def main():
    usage = "usage: %prog [file1..fileN]"
    description = """With no file paths given this script will automatically
compress all jQuery-based files of the admin app. Requires the Google Closure
Compiler library and Java version 6 or later."""
    parser = optparse.OptionParser(usage, description=description)
    parser.add_option("-c", dest="compiler", default="~/bin/compiler.jar",
                      help="path to Closure Compiler jar file")
    parser.add_option("-v", "--verbose",
                      action="store_true", dest="verbose")
    parser.add_option("-q", "--quiet",
                      action="store_false", dest="verbose")
    (options, args) = parser.parse_args()

    compiler = os.path.expanduser(options.compiler)
    if not os.path.exists(compiler):
        sys.exit("Google Closure compiler jar file %s not found. Please use the -c option to specify the path." % compiler)

    if not args:
        if options.verbose:
            sys.stdout.write("No filenames given; defaulting to admin scripts\n")
        args = [os.path.join(here, f) for f in [
            "actions.js", "collapse.js", "inlines.js", "prepopulate.js"]]

    for arg in args:
        if not arg.endswith(".js"):
            arg = arg + ".js"
        to_compress = os.path.expanduser(arg)
        if os.path.exists(to_compress):
            to_compress_min = "%s.min.js" % "".join(arg.rsplit(".js"))
            cmd = "java -jar %s --js %s --js_output_file %s" % (compiler, to_compress, to_compress_min)
            if options.verbose:
                sys.stdout.write("Running: %s\n" % cmd)
            subprocess.call(cmd.split())
        else:
            sys.stdout.write("File %s not found. Sure it exists?\n" % to_compress)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = api
import os
import csv
from models import Table
import json as simplejson
from django.conf import settings
from django.shortcuts import render
from django.http import HttpResponse
from bakery.views import BuildableDetailView


class TableBaseAPIView(BuildableDetailView):
    """
    The basics necessary to publish a table outside of HTML.
    """
    queryset = Table.live.all()

    def get_csv_data(self, obj):
        path = os.path.join(settings.CSV_DIR, obj.csv_name)
        return open(path, 'r')

    def get_html(self):
        return self.get(self.request).content

    def get_build_path(self, obj):
        api_dir = os.path.join(
            settings.BUILD_DIR,
            'api',
        )
        os.path.exists(api_dir) or os.mkdir(api_dir)
        return os.path.join(settings.BUILD_DIR, self.get_url(obj)[1:])


class TableDetailCSVView(TableBaseAPIView):
    """
    Publish a table as CSV.
    """
    def get_url(self, obj):
        return obj.get_csv_url()

    def render_to_response(self, context):
        data = self.get_csv_data(context['object']).read()
        response = HttpResponse(unicode(data), content_type='text/csv')
        response['Content-Disposition'] = 'attachment; filename=%s.csv' % (
            context['object'].slug
        )
        return response


class TableDetailXLSView(TableBaseAPIView):
    """
    Publish a table as XLS.
    """
    def get_url(self, obj):
        return obj.get_xls_url()

    def render_to_response(self, context):
        data = self.get_csv_data(context['object'])
        context['csv'] = csv.reader(data)
        response = render(self.request, "table.xls.txt", context)
        response['Content-Disposition'] = 'attachment; filename=%s.xls' % (
            context['object'].slug
        )
        response['Content-Type'] = 'application/vnd.ms-excel; charset=utf-8'
        return response


class TableDetailJSONView(TableBaseAPIView):
    """
    Publish a table as JSON.
    """
    def get_url(self, obj):
        return obj.get_json_url()

    def render_to_response(self, context):
        data = self.get_csv_data(context['object'])
        data = list(csv.reader(data))
        headers = data.pop(0)
        dict_list = []
        for row in data:
            col_dict = {}
            for i, h in enumerate(headers):
                col_dict[h] = row[i]
            dict_list.append(col_dict)
        return HttpResponse(
            simplejson.dumps(dict_list),
            content_type="text/javascript"
        )

########NEW FILE########
__FILENAME__ = feeds
from models import Table
from bakery.views import BuildableListView


class LatestTablesFeed(BuildableListView):
    build_path = 'feeds/latest.xml'
    template_name = 'table_stacker/feeds/latest.xml'
    queryset = Table.live.all()[:10]

    def render_to_response(self, context):
        return super(LatestTablesFeed, self).render_to_response(
            context,
            content_type='text/xml'
        )

########NEW FILE########
__FILENAME__ = build
import os
import yaml
from django.conf import settings
from table_stacker.models import Table
from toolbox.FileIterator import FileIterator
from bakery.management.commands.build import Command as BaseCommand


class Command(BaseCommand):

    def handle(self, *args, **options):
        # Load all YAML files into the local database
        self.stdout.write("Building database\n")
        [Table.objects.update_or_create(i) for i in self.get_all_yaml()]
        super(Command, self).handle(*args, **options)

    def get_yaml(self, yaml_name):
        """
        Retrieves the yaml file with the provided name as a Python object.
        """
        yaml_path = os.path.join(settings.YAML_DIR, yaml_name)
        try:
            yaml_data = open(yaml_path)
        except:
            raise YAMLDoesNotExistError(
                "YAML file could not be opened: %s" % yaml_name
            )
        try:
            yaml_obj = yaml.load(yaml_data)['table']
            yaml_obj['yaml_name'] = yaml_name
        except:
            raise InvalidYAMLError("YAML file is improperly formatted.")
        yaml_data.close()
        return yaml_obj

    def get_all_yaml(self):
        """
        Returns a list of all the tables configured in the YAML_DIR
        in dictionary form.
        """
        file_list = FileIterator(settings.YAML_DIR)
        yaml_list = [i for i in file_list if i.endswith('.yaml')]
        return [self.get_yaml(i) for i in yaml_list]


class YAMLDoesNotExistError(Exception):
    """
    Called when you try to open a YAML that doesn't exist.
    """
    def __init__(self, value):
        self.parameter = value

    def __str__(self):
        return repr(self.parameter)


class InvalidYAMLError(Exception):
    """
    Called when your YAML doesn't get with the program.
    """
    def __init__(self, value):
        self.parameter = value

    def __str__(self):
        return repr(self.parameter)

########NEW FILE########
__FILENAME__ = managers
from django.db import models


class TableManager(models.Manager):
    """
    A few tricks we'll use with our tables.
    """
    def live(self):
        """
        Returns only Tables that are ready to publish.
        """
        return self.filter(is_published=True, show_in_feeds=True)

    def update_or_create(self, yaml_data):
        """
        If the Table outlined by the provided YAML file exists, it's updated.

        If it doesn't, it's created.

        Returns a tuple with the object first, and then a boolean that is True
        when the object was created.
        """
        try:
            obj = self.get(slug=yaml_data.get("slug", yaml_data['yaml_name']))
        except self.model.DoesNotExist:
            obj = None

        if obj:
            obj.csv_name = yaml_data['file']
            obj.yaml_name = yaml_data['yaml_name']
            obj.yaml_data = str(yaml_data)
            obj.title = yaml_data['title']
            obj.slug = yaml_data.get("slug", yaml_data['yaml_name'])
            obj.kicker = yaml_data.get('kicker', '')
            obj.byline = yaml_data.get("byline", '')
            obj.publication_date = yaml_data['publication_date']
            obj.publication_time = yaml_data.get("publication_time", None)
            obj.legend = yaml_data.get('legend', '')
            obj.description = yaml_data.get('description', '')
            obj.footer = yaml_data.get('footer', '')
            obj.sources = yaml_data.get('sources', '')
            obj.credits = yaml_data.get('credits', '')
            obj.is_published = yaml_data.get('is_published', False)
            obj.show_download_links = yaml_data.get(
                "show_download_links", True
            )
            obj.show_search_field = yaml_data.get("show_search_field", True)
            obj.show_in_feeds = yaml_data.get("show_in_feeds", True)
            created = False
        else:
            obj = self.create(
                csv_name=yaml_data['file'],
                yaml_name=yaml_data['yaml_name'],
                yaml_data=str(yaml_data),
                title=yaml_data['title'],
                slug=yaml_data.get("slug", yaml_data['yaml_name']),
                kicker=yaml_data.get("kicker", ""),
                byline=yaml_data.get("byline", ""),
                publication_date=yaml_data['publication_date'],
                publication_time=yaml_data.get("publication_time", None),
                legend=yaml_data.get('legend', ''),
                description=yaml_data.get('description', ''),
                footer=yaml_data.get('footer', ''),
                sources=yaml_data.get('sources', ''),
                credits=yaml_data.get('credits', ''),
                is_published=yaml_data.get('is_published', False),
                show_download_links=yaml_data.get("show_download_links", True),
                show_search_field=yaml_data.get("show_search_field", True),
                show_in_feeds=yaml_data.get("show_in_feeds", True),
            )
            created = True
        obj.save()
        return obj, created


class TableLiveManager(models.Manager):
    """
    Returns only Tables that are ready to publish.
    """
    def get_query_set(self):
        qs = super(TableLiveManager, self).get_query_set()
        return qs.filter(is_published=True, show_in_feeds=True)

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'Table'
        db.create_table('table_stacker_table', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('csv_name', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('yaml_name', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('yaml_data', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=500)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=50)),
            ('kicker', self.gf('django.db.models.fields.CharField')(max_length=500, blank=True)),
            ('byline', self.gf('django.db.models.fields.CharField')(max_length=500, blank=True)),
            ('publication_date', self.gf('django.db.models.fields.DateField')()),
            ('description', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('legend', self.gf('django.db.models.fields.CharField')(max_length=500, blank=True)),
            ('footer', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('sources', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('credits', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('show_download_links', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('is_published', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('show_in_feeds', self.gf('django.db.models.fields.BooleanField')(default=True)),
        ))
        db.send_create_signal('table_stacker', ['Table'])


    def backwards(self, orm):
        # Deleting model 'Table'
        db.delete_table('table_stacker_table')


    models = {
        'table_stacker.table': {
            'Meta': {'ordering': "('-publication_date',)", 'object_name': 'Table'},
            'byline': ('django.db.models.fields.CharField', [], {'max_length': '500', 'blank': 'True'}),
            'credits': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'csv_name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'footer': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_published': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'kicker': ('django.db.models.fields.CharField', [], {'max_length': '500', 'blank': 'True'}),
            'legend': ('django.db.models.fields.CharField', [], {'max_length': '500', 'blank': 'True'}),
            'publication_date': ('django.db.models.fields.DateField', [], {}),
            'show_download_links': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'show_in_feeds': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50'}),
            'sources': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '500'}),
            'yaml_data': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'yaml_name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['table_stacker']
########NEW FILE########
__FILENAME__ = 0002_auto__add_field_table_show_search_field
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'Table.show_search_field'
        db.add_column('table_stacker_table', 'show_search_field',
                      self.gf('django.db.models.fields.BooleanField')(default=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'Table.show_search_field'
        db.delete_column('table_stacker_table', 'show_search_field')


    models = {
        'table_stacker.table': {
            'Meta': {'ordering': "('-publication_date',)", 'object_name': 'Table'},
            'byline': ('django.db.models.fields.CharField', [], {'max_length': '500', 'blank': 'True'}),
            'credits': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'csv_name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'footer': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_published': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'kicker': ('django.db.models.fields.CharField', [], {'max_length': '500', 'blank': 'True'}),
            'legend': ('django.db.models.fields.CharField', [], {'max_length': '500', 'blank': 'True'}),
            'publication_date': ('django.db.models.fields.DateField', [], {}),
            'show_download_links': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'show_in_feeds': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'show_search_field': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50'}),
            'sources': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '500'}),
            'yaml_data': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'yaml_name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['table_stacker']
########NEW FILE########
__FILENAME__ = 0003_auto__add_field_table_publication_time
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'Table.publication_time'
        db.add_column('table_stacker_table', 'publication_time',
                      self.gf('django.db.models.fields.TimeField')(null=True, blank=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'Table.publication_time'
        db.delete_column('table_stacker_table', 'publication_time')


    models = {
        'table_stacker.table': {
            'Meta': {'ordering': "('-publication_date',)", 'object_name': 'Table'},
            'byline': ('django.db.models.fields.CharField', [], {'max_length': '500', 'blank': 'True'}),
            'credits': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'csv_name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'footer': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_published': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'kicker': ('django.db.models.fields.CharField', [], {'max_length': '500', 'blank': 'True'}),
            'legend': ('django.db.models.fields.CharField', [], {'max_length': '500', 'blank': 'True'}),
            'publication_date': ('django.db.models.fields.DateField', [], {}),
            'publication_time': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'show_download_links': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'show_in_feeds': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'show_search_field': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50'}),
            'sources': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '500'}),
            'yaml_data': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'yaml_name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['table_stacker']
########NEW FILE########
__FILENAME__ = models
import os
import yaml
from table_fu import TableFu
from django.db import models
from datetime import datetime
from django.conf import settings
from django.contrib.sites.models import Site
from managers import TableLiveManager, TableManager


class Table(models.Model):
    """
    Ready-to-serve CSV data.
    """
    # The source
    csv_name = models.CharField(max_length=100)
    # The config
    yaml_name = models.CharField(max_length=100)
    yaml_data = models.TextField(blank=True)
    # The goodies
    title = models.CharField(max_length=500)
    slug = models.SlugField()
    kicker = models.CharField(max_length=500, blank=True)
    byline = models.CharField(max_length=500, blank=True)
    publication_date = models.DateField()
    publication_time = models.TimeField(blank=True, null=True)
    description = models.TextField(blank=True)
    legend = models.CharField(max_length=500, blank=True)
    footer = models.TextField(blank=True)
    sources = models.TextField(blank=True)
    credits = models.TextField(blank=True)
    show_download_links = models.BooleanField(default=True)
    show_search_field = models.BooleanField(default=True)
    # The meta
    is_published = models.BooleanField()
    show_in_feeds = models.BooleanField(default=True)
    objects = TableManager()
    live = TableLiveManager()

    class Meta:
        ordering = ("-publication_date", "-publication_time")

    def __unicode__(self):
        return self.title

    @models.permalink
    def get_absolute_url(self):
        return ('table-detail', [self.slug])

    @models.permalink
    def get_csv_url(self):
        return ('table-csv', [self.slug])

    @models.permalink
    def get_xls_url(self):
        return ('table-xls', [self.slug])

    @models.permalink
    def get_json_url(self):
        return ('table-json', [self.slug])

    def get_share_url(self):
        """
        The link we can use for share buttons.
        """
        site = Site.objects.get_current()
        return 'http://%s%s' % (site.domain, self.get_absolute_url())

    def get_tablefu_opts(self):
        return yaml.load(self.yaml_data).get('column_options', {})

    def get_tablefu(self):
        """
        Trick the data out with TableFu.
        """
        path = os.path.join(settings.CSV_DIR, self.csv_name)
        data = open(path, 'r')
        return TableFu(data, **self.get_tablefu_opts())
    tablefu = property(get_tablefu)

    def get_publication_datetime(self):
        """
        Combine publication date and time where possible.
        """
        if not self.publication_time:
            return datetime(
                self.publication_date.year,
                self.publication_date.month,
                self.publication_date.day,
                0, 0, 0
            )
        else:
            return datetime.combine(
                self.publication_date,
                self.publication_time
            )
    publication_datetime = property(get_publication_datetime)

########NEW FILE########
__FILENAME__ = sitemaps
from models import Table
from bakery.views import BuildableListView


class SitemapView(BuildableListView):
    """
    A list of all tables in a Sitemap ready for Google.
    """
    build_path = 'sitemap.xml'
    template_name = 'sitemap.xml'
    queryset = Table.live.all()

    def render_to_response(self, context):
        return super(SitemapView, self).render_to_response(
            context,
            content_type='text/xml'
        )

########NEW FILE########
__FILENAME__ = formatting
"""
Utilities to format values into more meaningful strings.
Inspired by James Bennett's template_utils and Django's
template filters.
"""
import re
from datetime import datetime
from toolbox import statestyle
from toolbox.dateutil.parser import parse as dateparse
from django.template.defaultfilters import date as dateformater
from django.template.defaultfilters import capfirst as djcapfirst


def _saferound(value, decimal_places):
    """
    Rounds a float value off to the desired precision
    """
    try:
        f = float(value)
    except ValueError:
        return ''
    format = '%%.%df' % decimal_places
    return format % f


def ap_state(value):
    """
    Converts a state's name or postal abbreviation to .A.P. style.

    Example usage:

        >> ap_state("California")
        'Calif.'

    """
    try:
        return statestyle.get(value.lower()).ap
    except:
        return value


def bubble(
        value,
        yes_icon='/static/img/bubble_yes.png',
        no_icon="/static/img/bubble_no.png", empty="&mdash;"
        ):
    """
    Returns one of two "Consumer Reports" style bubbles that indicate:

        - Yes (Filled bubble)
        - No (Empty bubble)

    The first letter of each type is what should be provided, i.e. Y, N.
    """
    img = "<img alt='%(name)s' title='%(name)s' class='bubble' src='%(icon)s'>"
    if value.lower() == 'y':
        return img % dict(name='Yes', icon=yes_icon)
    elif value.lower() == 'n':
        return img % dict(name='No', icon=no_icon)
    else:
        return empty


def capfirst(value):
    try:
        return djcapfirst(value.lower())
    except:
        return 'N/A'


def checkbox(
        value,
        yes_icon='/static/img/checkbox_yes.png',
        no_icon='/static/img/checkbox_no.png',
        ):
    """
    Returns one of two icons:

        - Yes (checked box)
        - No (empty box)

    Or, if a match can't be made, an empty string.

    The first letter of each type is what should be provided, i.e. Y, N,
    anything else.
    """
    img = "<img alt='%(name)s' title='%(name)s' class='vote' src='%(icon)s'>"
    if value.lower() == 'y':
        return img % dict(name='Yes', icon=yes_icon)
    elif value.lower() == 'n':
        return img % dict(name='No', icon=no_icon)
    else:
        return ''


def date_and_time(value, formatting="N j, Y, h:i a"):
    """
    Reformats a date string in a humanized format, AP style by default.
    """
    try:
        dt = dateparse(value)
    except ValueError:
        return value
    return dateformater(dt, formatting)


def dollar_signs(value):
    """
    Converts an integer into the corresponding number of dollar sign symbols.

    Meant to emulate the illustration of price range on Yelp.
    """
    try:
        count = int(value)
    except ValueError:
        return 'N/A'
    string = ''
    for i in range(0, count):
        string += '$'
    return string


def dollars(value, decimal_places=2):
    """
    Converts a number in a dollar figure, with commas after ever three digits.

    The number of decimal places can be configured via the keyword argument.
    The default is 2.
    """
    if not value:
        value = 0
    safevalue = _saferound(value, decimal_places)
    if not safevalue:
        return 'N/A'
    if float(value) < 0:
        safevalue = safevalue.replace("-", "")
        format = u'($%s)'
    else:
        format = u'$%s'
    return format % intcomma(safevalue)


def email_address(title, address):
    """
    Wrap the email address in mailto: tag, if the link exists.
    """
    if not address:
        return title
    return '<a target="_blank" href="mailto:%(address)s" \
        title="%(title)s">%(title)s</a>' % {'address': address, 'title': title}


def intcomma(value):
    """
    Borrowed from django.contrib.humanize

    Converts an integer to a string containing commas every three digits.
    For example, 3000 becomes '3,000' and 45000 becomes '45,000'.
    """
    orig = str(value)
    new = re.sub("^(-?\d+)(\d{3})", '\g<1>,\g<2>', orig)
    if orig == new:
        return new
    else:
        return intcomma(new)


def image(value, width='', height=''):
    """
    Accepts a URL and returns an HTML image tag ready to be displayed.

    Optionally, you can set the height and width with keyword arguments.
    """
    style = ""
    if width:
        style += "width:%s" % width
    if height:
        style += "height:%s" % height
    data_dict = dict(src=value, style=style)
    return '<img src="%(src)s" style="%(style)s">' % data_dict


def link(title, url):
    """
    Wrap the text in a hyperlink, if the link exists.
    """
    if not url:
        return title
    return '<a target="_blank" href="%(url)s" \
        title="%(title)s">%(title)s</a>' % {'url': url, 'title': title}


def percentage(value, decimal_places=1, multiply=True):
    """
    Converts a floating point value into a percentage value.

    Number of decimal places set by the `decimal_places` kwarg. Default is one.

    By default the number is multiplied by 100. You can prevent it from doing
    that by setting the `multiply` keyword argument to False.
    """
    value = float(value)
    if multiply:
        value = value * 100
    return _saferound(value, decimal_places) + '%'


def percent_change(value, decimal_places=1, multiply=True):
    """
    Converts a floating point value into a percentage change value.

    Number of decimal places set by the `decimal_places` kwarg. Default is one.

    By default the number is multiplied by 100. You can prevent it from doing
    that by setting the `multiply` keyword argument to False.

    Non-floats are assumed to be zero division errors and are presented as
    'N/A' in the output.
    """
    try:
        f = float(value)
        if multiply:
            f = f * 100
    except ValueError:
        return 'N/A'
    s = _saferound(f, decimal_places)
    if f > 0:
        return '+' + s + '%'
    else:
        return s + '%'


def short_ap_date(value, date_format=None):
    """
    Reformats a date string as in an abbreviated AP format.

        Example:

             >> short_ap_date('2010-04-03')
            'Apr. 2, 2011'

    If the date format cannot be automatically detected, you can specify it
    with the keyword argument.
    """
    # Split any date ranges and create a list
    value = value.replace("&ndash;", "-")
    date_parts = value.split(" - ")
    date_list = []
    for date_string in date_parts:
        try:
            if date_format:
                dt = datetime.strptime(date_string, date_format)
            else:
                dt = dateparse(date_string)
        except ValueError:
            return value
        # Check if this date is a "month-only" date
        # that needs to be specially formatted.
        if re.match('^\w{3,}\.?\s\d{4}$', date_string):
            dt = dateformater(dt, "M Y")
        # Otherwise just use the standard format
        else:
            dt = dateformater(dt, "M j, Y")
        # All months except May are abbreviated
        # and need a period added.
        if not dt.startswith("May"):
            dt = dt[:3] + "." + dt[3:]
        date_list.append(dt)
    return " &ndash; ".join(date_list)


def simple_bullet_graph(actual, target, width='95%', max=None):
    """
    Renders a simple bullet graph that compares a target line against
    an actual value.

    Unlike a conventional bullet graph, it does not shade the background
    into groups. Instead, it's all one solid color.
    """
    html = """
<div class="bullet-graph-wrap" style="width:%(width)s; margin: 6px auto;">
    <div class="bullet-graph-box2" style="left:0; width:%(width)s;"></div>
    <div data="%(sort)s" class="bullet-graph-sort" style="display:none;"></div>
    <div class="bullet-graph-target" style="left: %(target)s%%;"></div>
    <div class="bullet-graph-actual" style="width: %(actual)s%%"></div>
</div>
    """
    if not max:
        raise ValueError("Max keyword argument must be provided.")
    try:
        target_percent = (float(target) / max) * 100
        actual_percent = (float(actual) / max) * 100
    except ValueError:
        return ""
    try:
        sort = actual_percent / target_percent
    except:
        sort = 0.0
    config = dict(
        width=width,
        target=target_percent,
        actual=actual_percent,
        sort=sort,
    )
    return html % config


def title(value):
    """
    Converts a string into titlecase. Lifted from Django.
    """
    value = value.lower()
    t = re.sub("([a-z])'([A-Z])", lambda m: m.group(0).lower(), value.title())
    return re.sub("\d([A-Z])", lambda m: m.group(0).lower(), t)


def tribubble(
        value,
        yes_icon='/static/img/tribubble_yes.png',
        partly_icon='/static/img/tribubble_partly.png',
        no_icon="/static/img/tribubble_no.png", empty="&mdash;"
        ):
    """
    Returns one of three "Consumer Reports" style bubbles that indicate:

        - Yes (Filled bubble)
        - Partly (Half-filled bubble)
        - No (Empty bubble)

    The first letter of each type is what should be provided, i.e. Y, P, N.
    """
    img = "<img alt='%(name)s' title='%(name)s' class='bubble' src='%(icon)s'>"
    if value.lower() == 'y':
        return img % dict(name='Yes', icon=yes_icon)
    elif value.lower() == 'p':
        return img % dict(name='Partly', icon=partly_icon)
    elif value.lower() == 'n':
        return img % dict(name='No', icon=no_icon)
    else:
        return empty


def vote(
        value,
        yes_vote='/static/img/thumb_up.png',
        no_vote='/static/img/thumb_down.png',
        did_not_vote="<b style='font-size:130%;'>&mdash;</b>"
        ):
    """
    Returns one of three icons:

        - Yes (Thumbs up)
        - Partly (Thumbs down)
        - No (Bolded em dash)

    The first letter of each type is what should be provided, i.e. Y, N,
    anything else.
    """
    img = "<img alt='%(name)s' title='%(name)s' class='vote' src='%(icon)s'>"
    if value.lower() == 'y':
        return img % dict(name='Yes', icon=yes_vote)
    elif value.lower() == 'n':
        return img % dict(name='No', icon=no_vote)
    else:
        return did_not_vote


DEFAULT_FORMATTERS = {
    'ap_state': ap_state,
    'bubble': bubble,
    'capfirst': capfirst,
    'checkbox': checkbox,
    'date_and_time': date_and_time,
    'dollar_signs': dollar_signs,
    'dollars': dollars,
    'email_address': email_address,
    'link': link,
    'image': image,
    'intcomma': intcomma,
    'percentage': percentage,
    'percent_change': percent_change,
    'short_ap_date': short_ap_date,
    'simple_bullet_graph': simple_bullet_graph,
    'title': title,
    'tribubble': tribubble,
    'vote': vote,
}


class Formatter(object):
    """
    A formatter is a function (or any callable, really)
    that takes a value and returns a nicer-looking value,
    most likely a sting.

    Formatter stores and calls those functions, keeping
    the namespace uncluttered.

    Formatting functions should take a value as the first
    argument--usually the value of the Datum on which the
    function is called--followed by any number of positional
    arguments.

    In the context of TableFu, those arguments may refer to
    other columns in the same row.

    >>> formatter = Formatter()
    >>> formatter(1200, 'intcomma')
    '1,200'
    >>> formatter(1200, 'dollars')
    '$1,200'
    """

    def __init__(self):
        self._filters = {}
        for name, func in DEFAULT_FORMATTERS.items():
            self.register(name, func)

    def __call__(self, value, func, *args, **kwargs):
        if not callable(func):
            func = self._filters[func]
        return func(value, *args, **kwargs)

    def register(self, name=None, func=None):
        if not func and not name:
            return

        if callable(name) and not func:
            func = name
            name = func.__name__
        elif func and not name:
            name = func.__name__

        self._filters[name] = func

    def unregister(self, name=None, func=None):
        if not func and not name:
            return
        if not name:
            name = func.__name__

        if name not in self._filters:
            return

        del self._filters[name]


# Unless you need to subclass or keep formatting functions
# isolated, you can just import this instance.
format = Formatter()

########NEW FILE########
__FILENAME__ = tests
from django.test import TestCase


class TableStackerTest(TestCase):

    def test_foo(self):
        pass

########NEW FILE########
__FILENAME__ = views
from table_stacker.models import Table
from bakery.views import BuildableDetailView, BuildableListView


class TableListView(BuildableListView):
    """
    A list of all tables.
    """
    queryset = Table.live.all()


class TableDetailView(BuildableDetailView):
    """
    All about one table.
    """
    queryset = Table.live.all()

    def get_context_data(self, **kwargs):
        context = super(TableDetailView, self).get_context_data(**kwargs)
        context.update({
            'size_choices': [1, 2, 3, 4],
            'table': context['object'].get_tablefu(),
        })
        return context

########NEW FILE########
__FILENAME__ = easter
"""
Copyright (c) 2003-2007  Gustavo Niemeyer <gustavo@niemeyer.net>

This module offers extensions to the standard python 2.3+
datetime module.
"""
__author__ = "Gustavo Niemeyer <gustavo@niemeyer.net>"
__license__ = "PSF License"

import datetime

__all__ = ["easter", "EASTER_JULIAN", "EASTER_ORTHODOX", "EASTER_WESTERN"]

EASTER_JULIAN   = 1
EASTER_ORTHODOX = 2
EASTER_WESTERN  = 3

def easter(year, method=EASTER_WESTERN):
    """
    This method was ported from the work done by GM Arts,
    on top of the algorithm by Claus Tondering, which was
    based in part on the algorithm of Ouding (1940), as
    quoted in "Explanatory Supplement to the Astronomical
    Almanac", P.  Kenneth Seidelmann, editor.

    This algorithm implements three different easter
    calculation methods:
    
    1 - Original calculation in Julian calendar, valid in
        dates after 326 AD
    2 - Original method, with date converted to Gregorian
        calendar, valid in years 1583 to 4099
    3 - Revised method, in Gregorian calendar, valid in
        years 1583 to 4099 as well

    These methods are represented by the constants:

    EASTER_JULIAN   = 1
    EASTER_ORTHODOX = 2
    EASTER_WESTERN  = 3

    The default method is method 3.
    
    More about the algorithm may be found at:

    http://users.chariot.net.au/~gmarts/eastalg.htm

    and

    http://www.tondering.dk/claus/calendar.html

    """

    if not (1 <= method <= 3):
        raise ValueError, "invalid method"

    # g - Golden year - 1
    # c - Century
    # h - (23 - Epact) mod 30
    # i - Number of days from March 21 to Paschal Full Moon
    # j - Weekday for PFM (0=Sunday, etc)
    # p - Number of days from March 21 to Sunday on or before PFM
    #     (-6 to 28 methods 1 & 3, to 56 for method 2)
    # e - Extra days to add for method 2 (converting Julian
    #     date to Gregorian date)

    y = year
    g = y % 19
    e = 0
    if method < 3:
        # Old method
        i = (19*g+15)%30
        j = (y+y//4+i)%7
        if method == 2:
            # Extra dates to convert Julian to Gregorian date
            e = 10
            if y > 1600:
                e = e+y//100-16-(y//100-16)//4
    else:
        # New method
        c = y//100
        h = (c-c//4-(8*c+13)//25+19*g+15)%30
        i = h-(h//28)*(1-(h//28)*(29//(h+1))*((21-g)//11))
        j = (y+y//4+i+2-c+c//4)%7

    # p can be from -6 to 56 corresponding to dates 22 March to 23 May
    # (later dates apply to method 2, although 23 May never actually occurs)
    p = i-j+e
    d = 1+(p+27+(p+6)//40)%31
    m = 3+(p+26)//30
    return datetime.date(int(y),int(m),int(d))


########NEW FILE########
__FILENAME__ = parser
# -*- coding:iso-8859-1 -*-
"""
Copyright (c) 2003-2007  Gustavo Niemeyer <gustavo@niemeyer.net>

This module offers extensions to the standard python 2.3+
datetime module.
"""
__author__ = "Gustavo Niemeyer <gustavo@niemeyer.net>"
__license__ = "PSF License"

import datetime
import string
import time
import sys
import os

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

import relativedelta
import tz


__all__ = ["parse", "parserinfo"]


# Some pointers:
#
# http://www.cl.cam.ac.uk/~mgk25/iso-time.html
# http://www.iso.ch/iso/en/prods-services/popstds/datesandtime.html
# http://www.w3.org/TR/NOTE-datetime
# http://ringmaster.arc.nasa.gov/tools/time_formats.html
# http://search.cpan.org/author/MUIR/Time-modules-2003.0211/lib/Time/ParseDate.pm
# http://stein.cshl.org/jade/distrib/docs/java.text.SimpleDateFormat.html


class _timelex(object):

    def __init__(self, instream):
        if isinstance(instream, basestring):
            instream = StringIO(instream)
        self.instream = instream
        self.wordchars = ('abcdfeghijklmnopqrstuvwxyz'
                          'ABCDEFGHIJKLMNOPQRSTUVWXYZ_'
                          ''
                          '')
        self.numchars = '0123456789'
        self.whitespace = ' \t\r\n'
        self.charstack = []
        self.tokenstack = []
        self.eof = False

    def get_token(self):
        if self.tokenstack:
            return self.tokenstack.pop(0)
        seenletters = False
        token = None
        state = None
        wordchars = self.wordchars
        numchars = self.numchars
        whitespace = self.whitespace
        while not self.eof:
            if self.charstack:
                nextchar = self.charstack.pop(0)
            else:
                nextchar = self.instream.read(1)
                while nextchar == '\x00':
                    nextchar = self.instream.read(1)
            if not nextchar:
                self.eof = True
                break
            elif not state:
                token = nextchar
                if nextchar in wordchars:
                    state = 'a'
                elif nextchar in numchars:
                    state = '0'
                elif nextchar in whitespace:
                    token = ' '
                    break # emit token
                else:
                    break # emit token
            elif state == 'a':
                seenletters = True
                if nextchar in wordchars:
                    token += nextchar
                elif nextchar == '.':
                    token += nextchar
                    state = 'a.'
                else:
                    self.charstack.append(nextchar)
                    break # emit token
            elif state == '0':
                if nextchar in numchars:
                    token += nextchar
                elif nextchar == '.':
                    token += nextchar
                    state = '0.'
                else:
                    self.charstack.append(nextchar)
                    break # emit token
            elif state == 'a.':
                seenletters = True
                if nextchar == '.' or nextchar in wordchars:
                    token += nextchar
                elif nextchar in numchars and token[-1] == '.':
                    token += nextchar
                    state = '0.'
                else:
                    self.charstack.append(nextchar)
                    break # emit token
            elif state == '0.':
                if nextchar == '.' or nextchar in numchars:
                    token += nextchar
                elif nextchar in wordchars and token[-1] == '.':
                    token += nextchar
                    state = 'a.'
                else:
                    self.charstack.append(nextchar)
                    break # emit token
        if (state in ('a.', '0.') and
            (seenletters or token.count('.') > 1 or token[-1] == '.')):
            l = token.split('.')
            token = l[0]
            for tok in l[1:]:
                self.tokenstack.append('.')
                if tok:
                    self.tokenstack.append(tok)
        return token

    def __iter__(self):
        return self

    def next(self):
        token = self.get_token()
        if token is None:
            raise StopIteration
        return token

    def split(cls, s):
        return list(cls(s))
    split = classmethod(split)


class _resultbase(object):

    def __init__(self):
        for attr in self.__slots__:
            setattr(self, attr, None)

    def _repr(self, classname):
        l = []
        for attr in self.__slots__:
            value = getattr(self, attr)
            if value is not None:
                l.append("%s=%s" % (attr, `value`))
        return "%s(%s)" % (classname, ", ".join(l))

    def __repr__(self):
        return self._repr(self.__class__.__name__)


class parserinfo(object):

    # m from a.m/p.m, t from ISO T separator
    JUMP = [" ", ".", ",", ";", "-", "/", "'",
            "at", "on", "and", "ad", "m", "t", "of",
            "st", "nd", "rd", "th"] 

    WEEKDAYS = [("Mon", "Monday"),
                ("Tue", "Tuesday"),
                ("Wed", "Wednesday"),
                ("Thu", "Thursday"),
                ("Fri", "Friday"),
                ("Sat", "Saturday"),
                ("Sun", "Sunday")]
    MONTHS   = [("Jan", "January"),
                ("Feb", "February"),
                ("Mar", "March"),
                ("Apr", "April"),
                ("May", "May"),
                ("Jun", "June"),
                ("Jul", "July"),
                ("Aug", "August"),
                ("Sep", "September"),
                ("Oct", "October"),
                ("Nov", "November"),
                ("Dec", "December")]
    HMS = [("h", "hour", "hours"),
           ("m", "minute", "minutes"),
           ("s", "second", "seconds")]
    AMPM = [("am", "a"),
            ("pm", "p")]
    UTCZONE = ["UTC", "GMT", "Z"]
    PERTAIN = ["of"]
    TZOFFSET = {}

    def __init__(self, dayfirst=False, yearfirst=False):
        self._jump = self._convert(self.JUMP)
        self._weekdays = self._convert(self.WEEKDAYS)
        self._months = self._convert(self.MONTHS)
        self._hms = self._convert(self.HMS)
        self._ampm = self._convert(self.AMPM)
        self._utczone = self._convert(self.UTCZONE)
        self._pertain = self._convert(self.PERTAIN)

        self.dayfirst = dayfirst
        self.yearfirst = yearfirst

        self._year = time.localtime().tm_year
        self._century = self._year//100*100

    def _convert(self, lst):
        dct = {}
        for i in range(len(lst)):
            v = lst[i]
            if isinstance(v, tuple):
                for v in v:
                    dct[v.lower()] = i
            else:
                dct[v.lower()] = i
        return dct

    def jump(self, name):
        return name.lower() in self._jump

    def weekday(self, name):
        if len(name) >= 3:
            try:
                return self._weekdays[name.lower()]
            except KeyError:
                pass
        return None

    def month(self, name):
        if len(name) >= 3:
            try:
                return self._months[name.lower()]+1
            except KeyError:
                pass
        return None

    def hms(self, name):
        try:
            return self._hms[name.lower()]
        except KeyError:
            return None

    def ampm(self, name):
        try:
            return self._ampm[name.lower()]
        except KeyError:
            return None

    def pertain(self, name):
        return name.lower() in self._pertain

    def utczone(self, name):
        return name.lower() in self._utczone

    def tzoffset(self, name):
        if name in self._utczone:
            return 0
        return self.TZOFFSET.get(name)

    def convertyear(self, year):
        if year < 100:
            year += self._century
            if abs(year-self._year) >= 50:
                if year < self._year:
                    year += 100
                else:
                    year -= 100
        return year

    def validate(self, res):
        # move to info
        if res.year is not None:
            res.year = self.convertyear(res.year)
        if res.tzoffset == 0 and not res.tzname or res.tzname == 'Z':
            res.tzname = "UTC"
            res.tzoffset = 0
        elif res.tzoffset != 0 and res.tzname and self.utczone(res.tzname):
            res.tzoffset = 0
        return True


class parser(object):

    def __init__(self, info=None):
        self.info = info or parserinfo()

    def parse(self, timestr, default=None,
                    ignoretz=False, tzinfos=None,
                    **kwargs):
        if not default:
            default = datetime.datetime.now().replace(hour=0, minute=0,
                                                      second=0, microsecond=0)
        res = self._parse(timestr, **kwargs)
        if res is None:
            raise ValueError, "unknown string format"
        repl = {}
        for attr in ["year", "month", "day", "hour",
                     "minute", "second", "microsecond"]:
            value = getattr(res, attr)
            if value is not None:
                repl[attr] = value
        ret = default.replace(**repl)
        if res.weekday is not None and not res.day:
            ret = ret+relativedelta.relativedelta(weekday=res.weekday)
        if not ignoretz:
            if callable(tzinfos) or tzinfos and res.tzname in tzinfos:
                if callable(tzinfos):
                    tzdata = tzinfos(res.tzname, res.tzoffset)
                else:
                    tzdata = tzinfos.get(res.tzname)
                if isinstance(tzdata, datetime.tzinfo):
                    tzinfo = tzdata
                elif isinstance(tzdata, basestring):
                    tzinfo = tz.tzstr(tzdata)
                elif isinstance(tzdata, int):
                    tzinfo = tz.tzoffset(res.tzname, tzdata)
                else:
                    raise ValueError, "offset must be tzinfo subclass, " \
                                      "tz string, or int offset"
                ret = ret.replace(tzinfo=tzinfo)
            elif res.tzname and res.tzname in time.tzname:
                ret = ret.replace(tzinfo=tz.tzlocal())
            elif res.tzoffset == 0:
                ret = ret.replace(tzinfo=tz.tzutc())
            elif res.tzoffset:
                ret = ret.replace(tzinfo=tz.tzoffset(res.tzname, res.tzoffset))
        return ret

    class _result(_resultbase):
        __slots__ = ["year", "month", "day", "weekday",
                     "hour", "minute", "second", "microsecond",
                     "tzname", "tzoffset"]

    def _parse(self, timestr, dayfirst=None, yearfirst=None, fuzzy=False):
        info = self.info
        if dayfirst is None:
            dayfirst = info.dayfirst
        if yearfirst is None:
            yearfirst = info.yearfirst
        res = self._result()
        l = _timelex.split(timestr)
        try:

            # year/month/day list
            ymd = []

            # Index of the month string in ymd
            mstridx = -1

            len_l = len(l)
            i = 0
            while i < len_l:

                # Check if it's a number
                try:
                    value_repr = l[i]
                    value = float(value_repr)
                except ValueError:
                    value = None

                if value is not None:
                    # Token is a number
                    len_li = len(l[i])
                    i += 1
                    if (len(ymd) == 3 and len_li in (2, 4)
                        and (i >= len_l or (l[i] != ':' and
                                            info.hms(l[i]) is None))):
                        # 19990101T23[59]
                        s = l[i-1]
                        res.hour = int(s[:2])
                        if len_li == 4:
                            res.minute = int(s[2:])
                    elif len_li == 6 or (len_li > 6 and l[i-1].find('.') == 6):
                        # YYMMDD or HHMMSS[.ss]
                        s = l[i-1] 
                        if not ymd and l[i-1].find('.') == -1:
                            ymd.append(info.convertyear(int(s[:2])))
                            ymd.append(int(s[2:4]))
                            ymd.append(int(s[4:]))
                        else:
                            # 19990101T235959[.59]
                            res.hour = int(s[:2])
                            res.minute = int(s[2:4])
                            res.second, res.microsecond = _parsems(s[4:])
                    elif len_li == 8:
                        # YYYYMMDD
                        s = l[i-1]
                        ymd.append(int(s[:4]))
                        ymd.append(int(s[4:6]))
                        ymd.append(int(s[6:]))
                    elif len_li in (12, 14):
                        # YYYYMMDDhhmm[ss]
                        s = l[i-1]
                        ymd.append(int(s[:4]))
                        ymd.append(int(s[4:6]))
                        ymd.append(int(s[6:8]))
                        res.hour = int(s[8:10])
                        res.minute = int(s[10:12])
                        if len_li == 14:
                            res.second = int(s[12:])
                    elif ((i < len_l and info.hms(l[i]) is not None) or
                          (i+1 < len_l and l[i] == ' ' and
                           info.hms(l[i+1]) is not None)):
                        # HH[ ]h or MM[ ]m or SS[.ss][ ]s
                        if l[i] == ' ':
                            i += 1
                        idx = info.hms(l[i])
                        while True:
                            if idx == 0:
                                res.hour = int(value)
                                if value%1:
                                    res.minute = int(60*(value%1))
                            elif idx == 1:
                                res.minute = int(value)
                                if value%1:
                                    res.second = int(60*(value%1))
                            elif idx == 2:
                                res.second, res.microsecond = \
                                    _parsems(value_repr)
                            i += 1
                            if i >= len_l or idx == 2:
                                break
                            # 12h00
                            try:
                                value_repr = l[i]
                                value = float(value_repr)
                            except ValueError:
                                break
                            else:
                                i += 1
                                idx += 1
                                if i < len_l:
                                    newidx = info.hms(l[i])
                                    if newidx is not None:
                                        idx = newidx
                    elif i+1 < len_l and l[i] == ':':
                        # HH:MM[:SS[.ss]]
                        res.hour = int(value)
                        i += 1
                        value = float(l[i])
                        res.minute = int(value)
                        if value%1:
                            res.second = int(60*(value%1))
                        i += 1
                        if i < len_l and l[i] == ':':
                            res.second, res.microsecond = _parsems(l[i+1])
                            i += 2
                    elif i < len_l and l[i] in ('-', '/', '.'):
                        sep = l[i]
                        ymd.append(int(value))
                        i += 1
                        if i < len_l and not info.jump(l[i]):
                            try:
                                # 01-01[-01]
                                ymd.append(int(l[i]))
                            except ValueError:
                                # 01-Jan[-01]
                                value = info.month(l[i])
                                if value is not None:
                                    ymd.append(value)
                                    assert mstridx == -1
                                    mstridx = len(ymd)-1
                                else:
                                    return None
                            i += 1
                            if i < len_l and l[i] == sep:
                                # We have three members
                                i += 1
                                value = info.month(l[i])
                                if value is not None:
                                    ymd.append(value)
                                    mstridx = len(ymd)-1
                                    assert mstridx == -1
                                else:
                                    ymd.append(int(l[i]))
                                i += 1
                    elif i >= len_l or info.jump(l[i]):
                        if i+1 < len_l and info.ampm(l[i+1]) is not None:
                            # 12 am
                            res.hour = int(value)
                            if res.hour < 12 and info.ampm(l[i+1]) == 1:
                                res.hour += 12
                            elif res.hour == 12 and info.ampm(l[i+1]) == 0:
                                res.hour = 0
                            i += 1
                        else:
                            # Year, month or day
                            ymd.append(int(value))
                        i += 1
                    elif info.ampm(l[i]) is not None:
                        # 12am
                        res.hour = int(value)
                        if res.hour < 12 and info.ampm(l[i]) == 1:
                            res.hour += 12
                        elif res.hour == 12 and info.ampm(l[i]) == 0:
                            res.hour = 0
                        i += 1
                    elif not fuzzy:
                        return None
                    else:
                        i += 1
                    continue

                # Check weekday
                value = info.weekday(l[i])
                if value is not None:
                    res.weekday = value
                    i += 1
                    continue

                # Check month name
                value = info.month(l[i])
                if value is not None:
                    ymd.append(value)
                    assert mstridx == -1
                    mstridx = len(ymd)-1
                    i += 1
                    if i < len_l:
                        if l[i] in ('-', '/'):
                            # Jan-01[-99]
                            sep = l[i]
                            i += 1
                            ymd.append(int(l[i]))
                            i += 1
                            if i < len_l and l[i] == sep:
                                # Jan-01-99
                                i += 1
                                ymd.append(int(l[i]))
                                i += 1
                        elif (i+3 < len_l and l[i] == l[i+2] == ' '
                              and info.pertain(l[i+1])):
                            # Jan of 01
                            # In this case, 01 is clearly year
                            try:
                                value = int(l[i+3])
                            except ValueError:
                                # Wrong guess
                                pass
                            else:
                                # Convert it here to become unambiguous
                                ymd.append(info.convertyear(value))
                            i += 4
                    continue

                # Check am/pm
                value = info.ampm(l[i])
                if value is not None:
                    if value == 1 and res.hour < 12:
                        res.hour += 12
                    elif value == 0 and res.hour == 12:
                        res.hour = 0
                    i += 1
                    continue

                # Check for a timezone name
                if (res.hour is not None and len(l[i]) <= 5 and
                    res.tzname is None and res.tzoffset is None and
                    not [x for x in l[i] if x not in string.ascii_uppercase]):
                    res.tzname = l[i]
                    res.tzoffset = info.tzoffset(res.tzname)
                    i += 1

                    # Check for something like GMT+3, or BRST+3. Notice
                    # that it doesn't mean "I am 3 hours after GMT", but
                    # "my time +3 is GMT". If found, we reverse the
                    # logic so that timezone parsing code will get it
                    # right.
                    if i < len_l and l[i] in ('+', '-'):
                        l[i] = ('+', '-')[l[i] == '+']
                        res.tzoffset = None
                        if info.utczone(res.tzname):
                            # With something like GMT+3, the timezone
                            # is *not* GMT.
                            res.tzname = None

                    continue

                # Check for a numbered timezone
                if res.hour is not None and l[i] in ('+', '-'):
                    signal = (-1,1)[l[i] == '+']
                    i += 1
                    len_li = len(l[i])
                    if len_li == 4:
                        # -0300
                        res.tzoffset = int(l[i][:2])*3600+int(l[i][2:])*60
                    elif i+1 < len_l and l[i+1] == ':':
                        # -03:00
                        res.tzoffset = int(l[i])*3600+int(l[i+2])*60
                        i += 2
                    elif len_li <= 2:
                        # -[0]3
                        res.tzoffset = int(l[i][:2])*3600
                    else:
                        return None
                    i += 1
                    res.tzoffset *= signal

                    # Look for a timezone name between parenthesis
                    if (i+3 < len_l and
                        info.jump(l[i]) and l[i+1] == '(' and l[i+3] == ')' and
                        3 <= len(l[i+2]) <= 5 and
                        not [x for x in l[i+2]
                                if x not in string.ascii_uppercase]):
                        # -0300 (BRST)
                        res.tzname = l[i+2]
                        i += 4
                    continue

                # Check jumps
                if not (info.jump(l[i]) or fuzzy):
                    return None

                i += 1

            # Process year/month/day
            len_ymd = len(ymd)
            if len_ymd > 3:
                # More than three members!?
                return None
            elif len_ymd == 1 or (mstridx != -1 and len_ymd == 2):
                # One member, or two members with a month string
                if mstridx != -1:
                    res.month = ymd[mstridx]
                    del ymd[mstridx]
                if len_ymd > 1 or mstridx == -1:
                    if ymd[0] > 31:
                        res.year = ymd[0]
                    else:
                        res.day = ymd[0]
            elif len_ymd == 2:
                # Two members with numbers
                if ymd[0] > 31:
                    # 99-01
                    res.year, res.month = ymd
                elif ymd[1] > 31:
                    # 01-99
                    res.month, res.year = ymd
                elif dayfirst and ymd[1] <= 12:
                    # 13-01
                    res.day, res.month = ymd
                else:
                    # 01-13
                    res.month, res.day = ymd
            if len_ymd == 3:
                # Three members
                if mstridx == 0:
                    res.month, res.day, res.year = ymd
                elif mstridx == 1:
                    if ymd[0] > 31 or (yearfirst and ymd[2] <= 31):
                        # 99-Jan-01
                        res.year, res.month, res.day = ymd
                    else:
                        # 01-Jan-01
                        # Give precendence to day-first, since
                        # two-digit years is usually hand-written.
                        res.day, res.month, res.year = ymd
                elif mstridx == 2:
                    # WTF!?
                    if ymd[1] > 31:
                        # 01-99-Jan
                        res.day, res.year, res.month = ymd
                    else:
                        # 99-01-Jan
                        res.year, res.day, res.month = ymd
                else:
                    if ymd[0] > 31 or \
                       (yearfirst and ymd[1] <= 12 and ymd[2] <= 31):
                        # 99-01-01
                        res.year, res.month, res.day = ymd
                    elif ymd[0] > 12 or (dayfirst and ymd[1] <= 12):
                        # 13-01-01
                        res.day, res.month, res.year = ymd
                    else:
                        # 01-13-01
                        res.month, res.day, res.year = ymd

        except (IndexError, ValueError, AssertionError):
            return None

        if not info.validate(res):
            return None
        return res

DEFAULTPARSER = parser()
def parse(timestr, parserinfo=None, **kwargs):
    if parserinfo:
        return parser(parserinfo).parse(timestr, **kwargs)
    else:
        return DEFAULTPARSER.parse(timestr, **kwargs)


class _tzparser(object):

    class _result(_resultbase):

        __slots__ = ["stdabbr", "stdoffset", "dstabbr", "dstoffset",
                     "start", "end"]

        class _attr(_resultbase):
            __slots__ = ["month", "week", "weekday",
                         "yday", "jyday", "day", "time"]

        def __repr__(self):
            return self._repr("")

        def __init__(self):
            _resultbase.__init__(self)
            self.start = self._attr()
            self.end = self._attr()

    def parse(self, tzstr):
        res = self._result()
        l = _timelex.split(tzstr)
        try:

            len_l = len(l)

            i = 0
            while i < len_l:
                # BRST+3[BRDT[+2]]
                j = i
                while j < len_l and not [x for x in l[j]
                                            if x in "0123456789:,-+"]:
                    j += 1
                if j != i:
                    if not res.stdabbr:
                        offattr = "stdoffset"
                        res.stdabbr = "".join(l[i:j])
                    else:
                        offattr = "dstoffset"
                        res.dstabbr = "".join(l[i:j])
                    i = j
                    if (i < len_l and
                        (l[i] in ('+', '-') or l[i][0] in "0123456789")):
                        if l[i] in ('+', '-'):
                            # Yes, that's right.  See the TZ variable
                            # documentation.
                            signal = (1,-1)[l[i] == '+']
                            i += 1
                        else:
                            signal = -1
                        len_li = len(l[i])
                        if len_li == 4:
                            # -0300
                            setattr(res, offattr,
                                    (int(l[i][:2])*3600+int(l[i][2:])*60)*signal)
                        elif i+1 < len_l and l[i+1] == ':':
                            # -03:00
                            setattr(res, offattr,
                                    (int(l[i])*3600+int(l[i+2])*60)*signal)
                            i += 2
                        elif len_li <= 2:
                            # -[0]3
                            setattr(res, offattr,
                                    int(l[i][:2])*3600*signal)
                        else:
                            return None
                        i += 1
                    if res.dstabbr:
                        break
                else:
                    break

            if i < len_l:
                for j in range(i, len_l):
                    if l[j] == ';': l[j] = ','

                assert l[i] == ','

                i += 1

            if i >= len_l:
                pass
            elif (8 <= l.count(',') <= 9 and
                not [y for x in l[i:] if x != ','
                       for y in x if y not in "0123456789"]):
                # GMT0BST,3,0,30,3600,10,0,26,7200[,3600]
                for x in (res.start, res.end):
                    x.month = int(l[i])
                    i += 2
                    if l[i] == '-':
                        value = int(l[i+1])*-1
                        i += 1
                    else:
                        value = int(l[i])
                    i += 2
                    if value:
                        x.week = value
                        x.weekday = (int(l[i])-1)%7
                    else:
                        x.day = int(l[i])
                    i += 2
                    x.time = int(l[i])
                    i += 2
                if i < len_l:
                    if l[i] in ('-','+'):
                        signal = (-1,1)[l[i] == "+"]
                        i += 1
                    else:
                        signal = 1
                    res.dstoffset = (res.stdoffset+int(l[i]))*signal
            elif (l.count(',') == 2 and l[i:].count('/') <= 2 and
                  not [y for x in l[i:] if x not in (',','/','J','M',
                                                     '.','-',':')
                         for y in x if y not in "0123456789"]):
                for x in (res.start, res.end):
                    if l[i] == 'J':
                        # non-leap year day (1 based)
                        i += 1
                        x.jyday = int(l[i])
                    elif l[i] == 'M':
                        # month[-.]week[-.]weekday
                        i += 1
                        x.month = int(l[i])
                        i += 1
                        assert l[i] in ('-', '.')
                        i += 1
                        x.week = int(l[i])
                        if x.week == 5:
                            x.week = -1
                        i += 1
                        assert l[i] in ('-', '.')
                        i += 1
                        x.weekday = (int(l[i])-1)%7
                    else:
                        # year day (zero based)
                        x.yday = int(l[i])+1

                    i += 1

                    if i < len_l and l[i] == '/':
                        i += 1
                        # start time
                        len_li = len(l[i])
                        if len_li == 4:
                            # -0300
                            x.time = (int(l[i][:2])*3600+int(l[i][2:])*60)
                        elif i+1 < len_l and l[i+1] == ':':
                            # -03:00
                            x.time = int(l[i])*3600+int(l[i+2])*60
                            i += 2
                            if i+1 < len_l and l[i+1] == ':':
                                i += 2
                                x.time += int(l[i])
                        elif len_li <= 2:
                            # -[0]3
                            x.time = (int(l[i][:2])*3600)
                        else:
                            return None
                        i += 1

                    assert i == len_l or l[i] == ','

                    i += 1

                assert i >= len_l

        except (IndexError, ValueError, AssertionError):
            return None
        
        return res


DEFAULTTZPARSER = _tzparser()
def _parsetz(tzstr):
    return DEFAULTTZPARSER.parse(tzstr)


def _parsems(value):
    """Parse a I[.F] seconds value into (seconds, microseconds)."""
    if "." not in value:
        return int(value), 0
    else:
        i, f = value.split(".")
        return int(i), int(f.ljust(6, "0")[:6])


# vim:ts=4:sw=4:et

########NEW FILE########
__FILENAME__ = relativedelta
"""
Copyright (c) 2003-2010  Gustavo Niemeyer <gustavo@niemeyer.net>

This module offers extensions to the standard python 2.3+
datetime module.
"""
__author__ = "Gustavo Niemeyer <gustavo@niemeyer.net>"
__license__ = "PSF License"

import datetime
import calendar

__all__ = ["relativedelta", "MO", "TU", "WE", "TH", "FR", "SA", "SU"]

class weekday(object):
    __slots__ = ["weekday", "n"]

    def __init__(self, weekday, n=None):
        self.weekday = weekday
        self.n = n

    def __call__(self, n):
        if n == self.n:
            return self
        else:
            return self.__class__(self.weekday, n)

    def __eq__(self, other):
        try:
            if self.weekday != other.weekday or self.n != other.n:
                return False
        except AttributeError:
            return False
        return True

    def __repr__(self):
        s = ("MO", "TU", "WE", "TH", "FR", "SA", "SU")[self.weekday]
        if not self.n:
            return s
        else:
            return "%s(%+d)" % (s, self.n)

MO, TU, WE, TH, FR, SA, SU = weekdays = tuple([weekday(x) for x in range(7)])

class relativedelta:
    """
The relativedelta type is based on the specification of the excelent
work done by M.-A. Lemburg in his mx.DateTime extension. However,
notice that this type does *NOT* implement the same algorithm as
his work. Do *NOT* expect it to behave like mx.DateTime's counterpart.

There's two different ways to build a relativedelta instance. The
first one is passing it two date/datetime classes:

    relativedelta(datetime1, datetime2)

And the other way is to use the following keyword arguments:

    year, month, day, hour, minute, second, microsecond:
        Absolute information.

    years, months, weeks, days, hours, minutes, seconds, microseconds:
        Relative information, may be negative.

    weekday:
        One of the weekday instances (MO, TU, etc). These instances may
        receive a parameter N, specifying the Nth weekday, which could
        be positive or negative (like MO(+1) or MO(-2). Not specifying
        it is the same as specifying +1. You can also use an integer,
        where 0=MO.

    leapdays:
        Will add given days to the date found, if year is a leap
        year, and the date found is post 28 of february.

    yearday, nlyearday:
        Set the yearday or the non-leap year day (jump leap days).
        These are converted to day/month/leapdays information.

Here is the behavior of operations with relativedelta:

1) Calculate the absolute year, using the 'year' argument, or the
   original datetime year, if the argument is not present.

2) Add the relative 'years' argument to the absolute year.

3) Do steps 1 and 2 for month/months.

4) Calculate the absolute day, using the 'day' argument, or the
   original datetime day, if the argument is not present. Then,
   subtract from the day until it fits in the year and month
   found after their operations.

5) Add the relative 'days' argument to the absolute day. Notice
   that the 'weeks' argument is multiplied by 7 and added to
   'days'.

6) Do steps 1 and 2 for hour/hours, minute/minutes, second/seconds,
   microsecond/microseconds.

7) If the 'weekday' argument is present, calculate the weekday,
   with the given (wday, nth) tuple. wday is the index of the
   weekday (0-6, 0=Mon), and nth is the number of weeks to add
   forward or backward, depending on its signal. Notice that if
   the calculated date is already Monday, for example, using
   (0, 1) or (0, -1) won't change the day.
    """

    def __init__(self, dt1=None, dt2=None,
                 years=0, months=0, days=0, leapdays=0, weeks=0,
                 hours=0, minutes=0, seconds=0, microseconds=0,
                 year=None, month=None, day=None, weekday=None,
                 yearday=None, nlyearday=None,
                 hour=None, minute=None, second=None, microsecond=None):
        if dt1 and dt2:
            if not isinstance(dt1, datetime.date) or \
               not isinstance(dt2, datetime.date):
                raise TypeError, "relativedelta only diffs datetime/date"
            if type(dt1) is not type(dt2):
                if not isinstance(dt1, datetime.datetime):
                    dt1 = datetime.datetime.fromordinal(dt1.toordinal())
                elif not isinstance(dt2, datetime.datetime):
                    dt2 = datetime.datetime.fromordinal(dt2.toordinal())
            self.years = 0
            self.months = 0
            self.days = 0
            self.leapdays = 0
            self.hours = 0
            self.minutes = 0
            self.seconds = 0
            self.microseconds = 0
            self.year = None
            self.month = None
            self.day = None
            self.weekday = None
            self.hour = None
            self.minute = None
            self.second = None
            self.microsecond = None
            self._has_time = 0

            months = (dt1.year*12+dt1.month)-(dt2.year*12+dt2.month)
            self._set_months(months)
            dtm = self.__radd__(dt2)
            if dt1 < dt2:
                while dt1 > dtm:
                    months += 1
                    self._set_months(months)
                    dtm = self.__radd__(dt2)
            else:
                while dt1 < dtm:
                    months -= 1
                    self._set_months(months)
                    dtm = self.__radd__(dt2)
            delta = dt1 - dtm
            self.seconds = delta.seconds+delta.days*86400
            self.microseconds = delta.microseconds
        else:
            self.years = years
            self.months = months
            self.days = days+weeks*7
            self.leapdays = leapdays
            self.hours = hours
            self.minutes = minutes
            self.seconds = seconds
            self.microseconds = microseconds
            self.year = year
            self.month = month
            self.day = day
            self.hour = hour
            self.minute = minute
            self.second = second
            self.microsecond = microsecond

            if type(weekday) is int:
                self.weekday = weekdays[weekday]
            else:
                self.weekday = weekday

            yday = 0
            if nlyearday:
                yday = nlyearday
            elif yearday:
                yday = yearday
                if yearday > 59:
                    self.leapdays = -1
            if yday:
                ydayidx = [31,59,90,120,151,181,212,243,273,304,334,366]
                for idx, ydays in enumerate(ydayidx):
                    if yday <= ydays:
                        self.month = idx+1
                        if idx == 0:
                            self.day = yday
                        else:
                            self.day = yday-ydayidx[idx-1]
                        break
                else:
                    raise ValueError, "invalid year day (%d)" % yday

        self._fix()

    def _fix(self):
        if abs(self.microseconds) > 999999:
            s = self.microseconds//abs(self.microseconds)
            div, mod = divmod(self.microseconds*s, 1000000)
            self.microseconds = mod*s
            self.seconds += div*s
        if abs(self.seconds) > 59:
            s = self.seconds//abs(self.seconds)
            div, mod = divmod(self.seconds*s, 60)
            self.seconds = mod*s
            self.minutes += div*s
        if abs(self.minutes) > 59:
            s = self.minutes//abs(self.minutes)
            div, mod = divmod(self.minutes*s, 60)
            self.minutes = mod*s
            self.hours += div*s
        if abs(self.hours) > 23:
            s = self.hours//abs(self.hours)
            div, mod = divmod(self.hours*s, 24)
            self.hours = mod*s
            self.days += div*s
        if abs(self.months) > 11:
            s = self.months//abs(self.months)
            div, mod = divmod(self.months*s, 12)
            self.months = mod*s
            self.years += div*s
        if (self.hours or self.minutes or self.seconds or self.microseconds or
            self.hour is not None or self.minute is not None or
            self.second is not None or self.microsecond is not None):
            self._has_time = 1
        else:
            self._has_time = 0

    def _set_months(self, months):
        self.months = months
        if abs(self.months) > 11:
            s = self.months//abs(self.months)
            div, mod = divmod(self.months*s, 12)
            self.months = mod*s
            self.years = div*s
        else:
            self.years = 0

    def __radd__(self, other):
        if not isinstance(other, datetime.date):
            raise TypeError, "unsupported type for add operation"
        elif self._has_time and not isinstance(other, datetime.datetime):
            other = datetime.datetime.fromordinal(other.toordinal())
        year = (self.year or other.year)+self.years
        month = self.month or other.month
        if self.months:
            assert 1 <= abs(self.months) <= 12
            month += self.months
            if month > 12:
                year += 1
                month -= 12
            elif month < 1:
                year -= 1
                month += 12
        day = min(calendar.monthrange(year, month)[1],
                  self.day or other.day)
        repl = {"year": year, "month": month, "day": day}
        for attr in ["hour", "minute", "second", "microsecond"]:
            value = getattr(self, attr)
            if value is not None:
                repl[attr] = value
        days = self.days
        if self.leapdays and month > 2 and calendar.isleap(year):
            days += self.leapdays
        ret = (other.replace(**repl)
               + datetime.timedelta(days=days,
                                    hours=self.hours,
                                    minutes=self.minutes,
                                    seconds=self.seconds,
                                    microseconds=self.microseconds))
        if self.weekday:
            weekday, nth = self.weekday.weekday, self.weekday.n or 1
            jumpdays = (abs(nth)-1)*7
            if nth > 0:
                jumpdays += (7-ret.weekday()+weekday)%7
            else:
                jumpdays += (ret.weekday()-weekday)%7
                jumpdays *= -1
            ret += datetime.timedelta(days=jumpdays)
        return ret

    def __rsub__(self, other):
        return self.__neg__().__radd__(other)

    def __add__(self, other):
        if not isinstance(other, relativedelta):
            raise TypeError, "unsupported type for add operation"
        return relativedelta(years=other.years+self.years,
                             months=other.months+self.months,
                             days=other.days+self.days,
                             hours=other.hours+self.hours,
                             minutes=other.minutes+self.minutes,
                             seconds=other.seconds+self.seconds,
                             microseconds=other.microseconds+self.microseconds,
                             leapdays=other.leapdays or self.leapdays,
                             year=other.year or self.year,
                             month=other.month or self.month,
                             day=other.day or self.day,
                             weekday=other.weekday or self.weekday,
                             hour=other.hour or self.hour,
                             minute=other.minute or self.minute,
                             second=other.second or self.second,
                             microsecond=other.second or self.microsecond)

    def __sub__(self, other):
        if not isinstance(other, relativedelta):
            raise TypeError, "unsupported type for sub operation"
        return relativedelta(years=other.years-self.years,
                             months=other.months-self.months,
                             days=other.days-self.days,
                             hours=other.hours-self.hours,
                             minutes=other.minutes-self.minutes,
                             seconds=other.seconds-self.seconds,
                             microseconds=other.microseconds-self.microseconds,
                             leapdays=other.leapdays or self.leapdays,
                             year=other.year or self.year,
                             month=other.month or self.month,
                             day=other.day or self.day,
                             weekday=other.weekday or self.weekday,
                             hour=other.hour or self.hour,
                             minute=other.minute or self.minute,
                             second=other.second or self.second,
                             microsecond=other.second or self.microsecond)

    def __neg__(self):
        return relativedelta(years=-self.years,
                             months=-self.months,
                             days=-self.days,
                             hours=-self.hours,
                             minutes=-self.minutes,
                             seconds=-self.seconds,
                             microseconds=-self.microseconds,
                             leapdays=self.leapdays,
                             year=self.year,
                             month=self.month,
                             day=self.day,
                             weekday=self.weekday,
                             hour=self.hour,
                             minute=self.minute,
                             second=self.second,
                             microsecond=self.microsecond)

    def __nonzero__(self):
        return not (not self.years and
                    not self.months and
                    not self.days and
                    not self.hours and
                    not self.minutes and
                    not self.seconds and
                    not self.microseconds and
                    not self.leapdays and
                    self.year is None and
                    self.month is None and
                    self.day is None and
                    self.weekday is None and
                    self.hour is None and
                    self.minute is None and
                    self.second is None and
                    self.microsecond is None)

    def __mul__(self, other):
        f = float(other)
        return relativedelta(years=self.years*f,
                             months=self.months*f,
                             days=self.days*f,
                             hours=self.hours*f,
                             minutes=self.minutes*f,
                             seconds=self.seconds*f,
                             microseconds=self.microseconds*f,
                             leapdays=self.leapdays,
                             year=self.year,
                             month=self.month,
                             day=self.day,
                             weekday=self.weekday,
                             hour=self.hour,
                             minute=self.minute,
                             second=self.second,
                             microsecond=self.microsecond)

    def __eq__(self, other):
        if not isinstance(other, relativedelta):
            return False
        if self.weekday or other.weekday:
            if not self.weekday or not other.weekday:
                return False
            if self.weekday.weekday != other.weekday.weekday:
                return False
            n1, n2 = self.weekday.n, other.weekday.n
            if n1 != n2 and not ((not n1 or n1 == 1) and (not n2 or n2 == 1)):
                return False
        return (self.years == other.years and
                self.months == other.months and
                self.days == other.days and
                self.hours == other.hours and
                self.minutes == other.minutes and
                self.seconds == other.seconds and
                self.leapdays == other.leapdays and
                self.year == other.year and
                self.month == other.month and
                self.day == other.day and
                self.hour == other.hour and
                self.minute == other.minute and
                self.second == other.second and
                self.microsecond == other.microsecond)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __div__(self, other):
        return self.__mul__(1/float(other))

    def __repr__(self):
        l = []
        for attr in ["years", "months", "days", "leapdays",
                     "hours", "minutes", "seconds", "microseconds"]:
            value = getattr(self, attr)
            if value:
                l.append("%s=%+d" % (attr, value))
        for attr in ["year", "month", "day", "weekday",
                     "hour", "minute", "second", "microsecond"]:
            value = getattr(self, attr)
            if value is not None:
                l.append("%s=%s" % (attr, `value`))
        return "%s(%s)" % (self.__class__.__name__, ", ".join(l))

# vim:ts=4:sw=4:et

########NEW FILE########
__FILENAME__ = rrule
"""
Copyright (c) 2003-2010  Gustavo Niemeyer <gustavo@niemeyer.net>

This module offers extensions to the standard python 2.3+
datetime module.
"""
__author__ = "Gustavo Niemeyer <gustavo@niemeyer.net>"
__license__ = "PSF License"

import itertools
import datetime
import calendar
import thread
import sys

__all__ = ["rrule", "rruleset", "rrulestr",
           "YEARLY", "MONTHLY", "WEEKLY", "DAILY",
           "HOURLY", "MINUTELY", "SECONDLY",
           "MO", "TU", "WE", "TH", "FR", "SA", "SU"]

# Every mask is 7 days longer to handle cross-year weekly periods.
M366MASK = tuple([1]*31+[2]*29+[3]*31+[4]*30+[5]*31+[6]*30+
                 [7]*31+[8]*31+[9]*30+[10]*31+[11]*30+[12]*31+[1]*7)
M365MASK = list(M366MASK)
M29, M30, M31 = range(1,30), range(1,31), range(1,32)
MDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])
MDAY365MASK = list(MDAY366MASK)
M29, M30, M31 = range(-29,0), range(-30,0), range(-31,0)
NMDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])
NMDAY365MASK = list(NMDAY366MASK)
M366RANGE = (0,31,60,91,121,152,182,213,244,274,305,335,366)
M365RANGE = (0,31,59,90,120,151,181,212,243,273,304,334,365)
WDAYMASK = [0,1,2,3,4,5,6]*55
del M29, M30, M31, M365MASK[59], MDAY365MASK[59], NMDAY365MASK[31]
MDAY365MASK = tuple(MDAY365MASK)
M365MASK = tuple(M365MASK)

(YEARLY,
 MONTHLY,
 WEEKLY,
 DAILY,
 HOURLY,
 MINUTELY,
 SECONDLY) = range(7)

# Imported on demand.
easter = None
parser = None

class weekday(object):
    __slots__ = ["weekday", "n"]

    def __init__(self, weekday, n=None):
        if n == 0:
            raise ValueError, "Can't create weekday with n == 0"
        self.weekday = weekday
        self.n = n

    def __call__(self, n):
        if n == self.n:
            return self
        else:
            return self.__class__(self.weekday, n)

    def __eq__(self, other):
        try:
            if self.weekday != other.weekday or self.n != other.n:
                return False
        except AttributeError:
            return False
        return True

    def __repr__(self):
        s = ("MO", "TU", "WE", "TH", "FR", "SA", "SU")[self.weekday]
        if not self.n:
            return s
        else:
            return "%s(%+d)" % (s, self.n)

MO, TU, WE, TH, FR, SA, SU = weekdays = tuple([weekday(x) for x in range(7)])

class rrulebase:
    def __init__(self, cache=False):
        if cache:
            self._cache = []
            self._cache_lock = thread.allocate_lock()
            self._cache_gen  = self._iter()
            self._cache_complete = False
        else:
            self._cache = None
            self._cache_complete = False
        self._len = None

    def __iter__(self):
        if self._cache_complete:
            return iter(self._cache)
        elif self._cache is None:
            return self._iter()
        else:
            return self._iter_cached()

    def _iter_cached(self):
        i = 0
        gen = self._cache_gen
        cache = self._cache
        acquire = self._cache_lock.acquire
        release = self._cache_lock.release
        while gen:
            if i == len(cache):
                acquire()
                if self._cache_complete:
                    break
                try:
                    for j in range(10):
                        cache.append(gen.next())
                except StopIteration:
                    self._cache_gen = gen = None
                    self._cache_complete = True
                    break
                release()
            yield cache[i]
            i += 1
        while i < self._len:
            yield cache[i]
            i += 1

    def __getitem__(self, item):
        if self._cache_complete:
            return self._cache[item]
        elif isinstance(item, slice):
            if item.step and item.step < 0:
                return list(iter(self))[item]
            else:
                return list(itertools.islice(self,
                                             item.start or 0,
                                             item.stop or sys.maxint,
                                             item.step or 1))
        elif item >= 0:
            gen = iter(self)
            try:
                for i in range(item+1):
                    res = gen.next()
            except StopIteration:
                raise IndexError
            return res
        else:
            return list(iter(self))[item]

    def __contains__(self, item):
        if self._cache_complete:
            return item in self._cache
        else:
            for i in self:
                if i == item:
                    return True
                elif i > item:
                    return False
        return False

    # __len__() introduces a large performance penality.
    def count(self):
        if self._len is None:
            for x in self: pass
        return self._len

    def before(self, dt, inc=False):
        if self._cache_complete:
            gen = self._cache
        else:
            gen = self
        last = None
        if inc:
            for i in gen:
                if i > dt:
                    break
                last = i
        else:
            for i in gen:
                if i >= dt:
                    break
                last = i
        return last

    def after(self, dt, inc=False):
        if self._cache_complete:
            gen = self._cache
        else:
            gen = self
        if inc:
            for i in gen:
                if i >= dt:
                    return i
        else:
            for i in gen:
                if i > dt:
                    return i
        return None

    def between(self, after, before, inc=False):
        if self._cache_complete:
            gen = self._cache
        else:
            gen = self
        started = False
        l = []
        if inc:
            for i in gen:
                if i > before:
                    break
                elif not started:
                    if i >= after:
                        started = True
                        l.append(i)
                else:
                    l.append(i)
        else:
            for i in gen:
                if i >= before:
                    break
                elif not started:
                    if i > after:
                        started = True
                        l.append(i)
                else:
                    l.append(i)
        return l

class rrule(rrulebase):
    def __init__(self, freq, dtstart=None,
                 interval=1, wkst=None, count=None, until=None, bysetpos=None,
                 bymonth=None, bymonthday=None, byyearday=None, byeaster=None,
                 byweekno=None, byweekday=None,
                 byhour=None, byminute=None, bysecond=None,
                 cache=False):
        rrulebase.__init__(self, cache)
        global easter
        if not dtstart:
            dtstart = datetime.datetime.now().replace(microsecond=0)
        elif not isinstance(dtstart, datetime.datetime):
            dtstart = datetime.datetime.fromordinal(dtstart.toordinal())
        else:
            dtstart = dtstart.replace(microsecond=0)
        self._dtstart = dtstart
        self._tzinfo = dtstart.tzinfo
        self._freq = freq
        self._interval = interval
        self._count = count
        if until and not isinstance(until, datetime.datetime):
            until = datetime.datetime.fromordinal(until.toordinal())
        self._until = until
        if wkst is None:
            self._wkst = calendar.firstweekday()
        elif type(wkst) is int:
            self._wkst = wkst
        else:
            self._wkst = wkst.weekday
        if bysetpos is None:
            self._bysetpos = None
        elif type(bysetpos) is int:
            if bysetpos == 0 or not (-366 <= bysetpos <= 366):
                raise ValueError("bysetpos must be between 1 and 366, "
                                 "or between -366 and -1")
            self._bysetpos = (bysetpos,)
        else:
            self._bysetpos = tuple(bysetpos)
            for pos in self._bysetpos:
                if pos == 0 or not (-366 <= pos <= 366):
                    raise ValueError("bysetpos must be between 1 and 366, "
                                     "or between -366 and -1")
        if not (byweekno or byyearday or bymonthday or
                byweekday is not None or byeaster is not None):
            if freq == YEARLY:
                if not bymonth:
                    bymonth = dtstart.month
                bymonthday = dtstart.day
            elif freq == MONTHLY:
                bymonthday = dtstart.day
            elif freq == WEEKLY:
                byweekday = dtstart.weekday()
        # bymonth
        if not bymonth:
            self._bymonth = None
        elif type(bymonth) is int:
            self._bymonth = (bymonth,)
        else:
            self._bymonth = tuple(bymonth)
        # byyearday
        if not byyearday:
            self._byyearday = None
        elif type(byyearday) is int:
            self._byyearday = (byyearday,)
        else:
            self._byyearday = tuple(byyearday)
        # byeaster
        if byeaster is not None:
            if not easter:
                from dateutil import easter
            if type(byeaster) is int:
                self._byeaster = (byeaster,)
            else:
                self._byeaster = tuple(byeaster)
        else:
            self._byeaster = None
        # bymonthay
        if not bymonthday:
            self._bymonthday = ()
            self._bynmonthday = ()
        elif type(bymonthday) is int:
            if bymonthday < 0:
                self._bynmonthday = (bymonthday,)
                self._bymonthday = ()
            else:
                self._bymonthday = (bymonthday,)
                self._bynmonthday = ()
        else:
            self._bymonthday = tuple([x for x in bymonthday if x > 0])
            self._bynmonthday = tuple([x for x in bymonthday if x < 0])
        # byweekno
        if byweekno is None:
            self._byweekno = None
        elif type(byweekno) is int:
            self._byweekno = (byweekno,)
        else:
            self._byweekno = tuple(byweekno)
        # byweekday / bynweekday
        if byweekday is None:
            self._byweekday = None
            self._bynweekday = None
        elif type(byweekday) is int:
            self._byweekday = (byweekday,)
            self._bynweekday = None
        elif hasattr(byweekday, "n"):
            if not byweekday.n or freq > MONTHLY:
                self._byweekday = (byweekday.weekday,)
                self._bynweekday = None
            else:
                self._bynweekday = ((byweekday.weekday, byweekday.n),)
                self._byweekday = None
        else:
            self._byweekday = []
            self._bynweekday = []
            for wday in byweekday:
                if type(wday) is int:
                    self._byweekday.append(wday)
                elif not wday.n or freq > MONTHLY:
                    self._byweekday.append(wday.weekday)
                else:
                    self._bynweekday.append((wday.weekday, wday.n))
            self._byweekday = tuple(self._byweekday)
            self._bynweekday = tuple(self._bynweekday)
            if not self._byweekday:
                self._byweekday = None
            elif not self._bynweekday:
                self._bynweekday = None
        # byhour
        if byhour is None:
            if freq < HOURLY:
                self._byhour = (dtstart.hour,)
            else:
                self._byhour = None
        elif type(byhour) is int:
            self._byhour = (byhour,)
        else:
            self._byhour = tuple(byhour)
        # byminute
        if byminute is None:
            if freq < MINUTELY:
                self._byminute = (dtstart.minute,)
            else:
                self._byminute = None
        elif type(byminute) is int:
            self._byminute = (byminute,)
        else:
            self._byminute = tuple(byminute)
        # bysecond
        if bysecond is None:
            if freq < SECONDLY:
                self._bysecond = (dtstart.second,)
            else:
                self._bysecond = None
        elif type(bysecond) is int:
            self._bysecond = (bysecond,)
        else:
            self._bysecond = tuple(bysecond)

        if self._freq >= HOURLY:
            self._timeset = None
        else:
            self._timeset = []
            for hour in self._byhour:
                for minute in self._byminute:
                    for second in self._bysecond:
                        self._timeset.append(
                                datetime.time(hour, minute, second,
                                                    tzinfo=self._tzinfo))
            self._timeset.sort()
            self._timeset = tuple(self._timeset)

    def _iter(self):
        year, month, day, hour, minute, second, weekday, yearday, _ = \
            self._dtstart.timetuple()

        # Some local variables to speed things up a bit
        freq = self._freq
        interval = self._interval
        wkst = self._wkst
        until = self._until
        bymonth = self._bymonth
        byweekno = self._byweekno
        byyearday = self._byyearday
        byweekday = self._byweekday
        byeaster = self._byeaster
        bymonthday = self._bymonthday
        bynmonthday = self._bynmonthday
        bysetpos = self._bysetpos
        byhour = self._byhour
        byminute = self._byminute
        bysecond = self._bysecond

        ii = _iterinfo(self)
        ii.rebuild(year, month)

        getdayset = {YEARLY:ii.ydayset,
                     MONTHLY:ii.mdayset,
                     WEEKLY:ii.wdayset,
                     DAILY:ii.ddayset,
                     HOURLY:ii.ddayset,
                     MINUTELY:ii.ddayset,
                     SECONDLY:ii.ddayset}[freq]
        
        if freq < HOURLY:
            timeset = self._timeset
        else:
            gettimeset = {HOURLY:ii.htimeset,
                          MINUTELY:ii.mtimeset,
                          SECONDLY:ii.stimeset}[freq]
            if ((freq >= HOURLY and
                 self._byhour and hour not in self._byhour) or
                (freq >= MINUTELY and
                 self._byminute and minute not in self._byminute) or
                (freq >= SECONDLY and
                 self._bysecond and second not in self._bysecond)):
                timeset = ()
            else:
                timeset = gettimeset(hour, minute, second)

        total = 0
        count = self._count
        while True:
            # Get dayset with the right frequency
            dayset, start, end = getdayset(year, month, day)

            # Do the "hard" work ;-)
            filtered = False
            for i in dayset[start:end]:
                if ((bymonth and ii.mmask[i] not in bymonth) or
                    (byweekno and not ii.wnomask[i]) or
                    (byweekday and ii.wdaymask[i] not in byweekday) or
                    (ii.nwdaymask and not ii.nwdaymask[i]) or
                    (byeaster and not ii.eastermask[i]) or
                    ((bymonthday or bynmonthday) and
                     ii.mdaymask[i] not in bymonthday and
                     ii.nmdaymask[i] not in bynmonthday) or
                    (byyearday and
                     ((i < ii.yearlen and i+1 not in byyearday
                                      and -ii.yearlen+i not in byyearday) or
                      (i >= ii.yearlen and i+1-ii.yearlen not in byyearday
                                       and -ii.nextyearlen+i-ii.yearlen
                                           not in byyearday)))):
                    dayset[i] = None
                    filtered = True

            # Output results
            if bysetpos and timeset:
                poslist = []
                for pos in bysetpos:
                    if pos < 0:
                        daypos, timepos = divmod(pos, len(timeset))
                    else:
                        daypos, timepos = divmod(pos-1, len(timeset))
                    try:
                        i = [x for x in dayset[start:end]
                                if x is not None][daypos]
                        time = timeset[timepos]
                    except IndexError:
                        pass
                    else:
                        date = datetime.date.fromordinal(ii.yearordinal+i)
                        res = datetime.datetime.combine(date, time)
                        if res not in poslist:
                            poslist.append(res)
                poslist.sort()
                for res in poslist:
                    if until and res > until:
                        self._len = total
                        return
                    elif res >= self._dtstart:
                        total += 1
                        yield res
                        if count:
                            count -= 1
                            if not count:
                                self._len = total
                                return
            else:
                for i in dayset[start:end]:
                    if i is not None:
                        date = datetime.date.fromordinal(ii.yearordinal+i)
                        for time in timeset:
                            res = datetime.datetime.combine(date, time)
                            if until and res > until:
                                self._len = total
                                return
                            elif res >= self._dtstart:
                                total += 1
                                yield res
                                if count:
                                    count -= 1
                                    if not count:
                                        self._len = total
                                        return

            # Handle frequency and interval
            fixday = False
            if freq == YEARLY:
                year += interval
                if year > datetime.MAXYEAR:
                    self._len = total
                    return
                ii.rebuild(year, month)
            elif freq == MONTHLY:
                month += interval
                if month > 12:
                    div, mod = divmod(month, 12)
                    month = mod
                    year += div
                    if month == 0:
                        month = 12
                        year -= 1
                    if year > datetime.MAXYEAR:
                        self._len = total
                        return
                ii.rebuild(year, month)
            elif freq == WEEKLY:
                if wkst > weekday:
                    day += -(weekday+1+(6-wkst))+self._interval*7
                else:
                    day += -(weekday-wkst)+self._interval*7
                weekday = wkst
                fixday = True
            elif freq == DAILY:
                day += interval
                fixday = True
            elif freq == HOURLY:
                if filtered:
                    # Jump to one iteration before next day
                    hour += ((23-hour)//interval)*interval
                while True:
                    hour += interval
                    div, mod = divmod(hour, 24)
                    if div:
                        hour = mod
                        day += div
                        fixday = True
                    if not byhour or hour in byhour:
                        break
                timeset = gettimeset(hour, minute, second)
            elif freq == MINUTELY:
                if filtered:
                    # Jump to one iteration before next day
                    minute += ((1439-(hour*60+minute))//interval)*interval
                while True:
                    minute += interval
                    div, mod = divmod(minute, 60)
                    if div:
                        minute = mod
                        hour += div
                        div, mod = divmod(hour, 24)
                        if div:
                            hour = mod
                            day += div
                            fixday = True
                            filtered = False
                    if ((not byhour or hour in byhour) and
                        (not byminute or minute in byminute)):
                        break
                timeset = gettimeset(hour, minute, second)
            elif freq == SECONDLY:
                if filtered:
                    # Jump to one iteration before next day
                    second += (((86399-(hour*3600+minute*60+second))
                                //interval)*interval)
                while True:
                    second += self._interval
                    div, mod = divmod(second, 60)
                    if div:
                        second = mod
                        minute += div
                        div, mod = divmod(minute, 60)
                        if div:
                            minute = mod
                            hour += div
                            div, mod = divmod(hour, 24)
                            if div:
                                hour = mod
                                day += div
                                fixday = True
                    if ((not byhour or hour in byhour) and
                        (not byminute or minute in byminute) and
                        (not bysecond or second in bysecond)):
                        break
                timeset = gettimeset(hour, minute, second)

            if fixday and day > 28:
                daysinmonth = calendar.monthrange(year, month)[1]
                if day > daysinmonth:
                    while day > daysinmonth:
                        day -= daysinmonth
                        month += 1
                        if month == 13:
                            month = 1
                            year += 1
                            if year > datetime.MAXYEAR:
                                self._len = total
                                return
                        daysinmonth = calendar.monthrange(year, month)[1]
                    ii.rebuild(year, month)

class _iterinfo(object):
    __slots__ = ["rrule", "lastyear", "lastmonth",
                 "yearlen", "nextyearlen", "yearordinal", "yearweekday",
                 "mmask", "mrange", "mdaymask", "nmdaymask",
                 "wdaymask", "wnomask", "nwdaymask", "eastermask"]

    def __init__(self, rrule):
        for attr in self.__slots__:
            setattr(self, attr, None)
        self.rrule = rrule

    def rebuild(self, year, month):
        # Every mask is 7 days longer to handle cross-year weekly periods.
        rr = self.rrule
        if year != self.lastyear:
            self.yearlen = 365+calendar.isleap(year)
            self.nextyearlen = 365+calendar.isleap(year+1)
            firstyday = datetime.date(year, 1, 1)
            self.yearordinal = firstyday.toordinal()
            self.yearweekday = firstyday.weekday()

            wday = datetime.date(year, 1, 1).weekday()
            if self.yearlen == 365:
                self.mmask = M365MASK
                self.mdaymask = MDAY365MASK
                self.nmdaymask = NMDAY365MASK
                self.wdaymask = WDAYMASK[wday:]
                self.mrange = M365RANGE
            else:
                self.mmask = M366MASK
                self.mdaymask = MDAY366MASK
                self.nmdaymask = NMDAY366MASK
                self.wdaymask = WDAYMASK[wday:]
                self.mrange = M366RANGE

            if not rr._byweekno:
                self.wnomask = None
            else:
                self.wnomask = [0]*(self.yearlen+7)
                #no1wkst = firstwkst = self.wdaymask.index(rr._wkst)
                no1wkst = firstwkst = (7-self.yearweekday+rr._wkst)%7
                if no1wkst >= 4:
                    no1wkst = 0
                    # Number of days in the year, plus the days we got
                    # from last year.
                    wyearlen = self.yearlen+(self.yearweekday-rr._wkst)%7
                else:
                    # Number of days in the year, minus the days we
                    # left in last year.
                    wyearlen = self.yearlen-no1wkst
                div, mod = divmod(wyearlen, 7)
                numweeks = div+mod//4
                for n in rr._byweekno:
                    if n < 0:
                        n += numweeks+1
                    if not (0 < n <= numweeks):
                        continue
                    if n > 1:
                        i = no1wkst+(n-1)*7
                        if no1wkst != firstwkst:
                            i -= 7-firstwkst
                    else:
                        i = no1wkst
                    for j in range(7):
                        self.wnomask[i] = 1
                        i += 1
                        if self.wdaymask[i] == rr._wkst:
                            break
                if 1 in rr._byweekno:
                    # Check week number 1 of next year as well
                    # TODO: Check -numweeks for next year.
                    i = no1wkst+numweeks*7
                    if no1wkst != firstwkst:
                        i -= 7-firstwkst
                    if i < self.yearlen:
                        # If week starts in next year, we
                        # don't care about it.
                        for j in range(7):
                            self.wnomask[i] = 1
                            i += 1
                            if self.wdaymask[i] == rr._wkst:
                                break
                if no1wkst:
                    # Check last week number of last year as
                    # well. If no1wkst is 0, either the year
                    # started on week start, or week number 1
                    # got days from last year, so there are no
                    # days from last year's last week number in
                    # this year.
                    if -1 not in rr._byweekno:
                        lyearweekday = datetime.date(year-1,1,1).weekday()
                        lno1wkst = (7-lyearweekday+rr._wkst)%7
                        lyearlen = 365+calendar.isleap(year-1)
                        if lno1wkst >= 4:
                            lno1wkst = 0
                            lnumweeks = 52+(lyearlen+
                                           (lyearweekday-rr._wkst)%7)%7//4
                        else:
                            lnumweeks = 52+(self.yearlen-no1wkst)%7//4
                    else:
                        lnumweeks = -1
                    if lnumweeks in rr._byweekno:
                        for i in range(no1wkst):
                            self.wnomask[i] = 1

        if (rr._bynweekday and
            (month != self.lastmonth or year != self.lastyear)):
            ranges = []
            if rr._freq == YEARLY:
                if rr._bymonth:
                    for month in rr._bymonth:
                        ranges.append(self.mrange[month-1:month+1])
                else:
                    ranges = [(0, self.yearlen)]
            elif rr._freq == MONTHLY:
                ranges = [self.mrange[month-1:month+1]]
            if ranges:
                # Weekly frequency won't get here, so we may not
                # care about cross-year weekly periods.
                self.nwdaymask = [0]*self.yearlen
                for first, last in ranges:
                    last -= 1
                    for wday, n in rr._bynweekday:
                        if n < 0:
                            i = last+(n+1)*7
                            i -= (self.wdaymask[i]-wday)%7
                        else:
                            i = first+(n-1)*7
                            i += (7-self.wdaymask[i]+wday)%7
                        if first <= i <= last:
                            self.nwdaymask[i] = 1

        if rr._byeaster:
            self.eastermask = [0]*(self.yearlen+7)
            eyday = easter.easter(year).toordinal()-self.yearordinal
            for offset in rr._byeaster:
                self.eastermask[eyday+offset] = 1

        self.lastyear = year
        self.lastmonth = month

    def ydayset(self, year, month, day):
        return range(self.yearlen), 0, self.yearlen

    def mdayset(self, year, month, day):
        set = [None]*self.yearlen
        start, end = self.mrange[month-1:month+1]
        for i in range(start, end):
            set[i] = i
        return set, start, end

    def wdayset(self, year, month, day):
        # We need to handle cross-year weeks here.
        set = [None]*(self.yearlen+7)
        i = datetime.date(year, month, day).toordinal()-self.yearordinal
        start = i
        for j in range(7):
            set[i] = i
            i += 1
            #if (not (0 <= i < self.yearlen) or
            #    self.wdaymask[i] == self.rrule._wkst):
            # This will cross the year boundary, if necessary.
            if self.wdaymask[i] == self.rrule._wkst:
                break
        return set, start, i

    def ddayset(self, year, month, day):
        set = [None]*self.yearlen
        i = datetime.date(year, month, day).toordinal()-self.yearordinal
        set[i] = i
        return set, i, i+1

    def htimeset(self, hour, minute, second):
        set = []
        rr = self.rrule
        for minute in rr._byminute:
            for second in rr._bysecond:
                set.append(datetime.time(hour, minute, second,
                                         tzinfo=rr._tzinfo))
        set.sort()
        return set

    def mtimeset(self, hour, minute, second):
        set = []
        rr = self.rrule
        for second in rr._bysecond:
            set.append(datetime.time(hour, minute, second, tzinfo=rr._tzinfo))
        set.sort()
        return set

    def stimeset(self, hour, minute, second):
        return (datetime.time(hour, minute, second,
                tzinfo=self.rrule._tzinfo),)


class rruleset(rrulebase):

    class _genitem:
        def __init__(self, genlist, gen):
            try:
                self.dt = gen()
                genlist.append(self)
            except StopIteration:
                pass
            self.genlist = genlist
            self.gen = gen

        def next(self):
            try:
                self.dt = self.gen()
            except StopIteration:
                self.genlist.remove(self)

        def __cmp__(self, other):
            return cmp(self.dt, other.dt)

    def __init__(self, cache=False):
        rrulebase.__init__(self, cache)
        self._rrule = []
        self._rdate = []
        self._exrule = []
        self._exdate = []

    def rrule(self, rrule):
        self._rrule.append(rrule)
    
    def rdate(self, rdate):
        self._rdate.append(rdate)

    def exrule(self, exrule):
        self._exrule.append(exrule)

    def exdate(self, exdate):
        self._exdate.append(exdate)

    def _iter(self):
        rlist = []
        self._rdate.sort()
        self._genitem(rlist, iter(self._rdate).next)
        for gen in [iter(x).next for x in self._rrule]:
            self._genitem(rlist, gen)
        rlist.sort()
        exlist = []
        self._exdate.sort()
        self._genitem(exlist, iter(self._exdate).next)
        for gen in [iter(x).next for x in self._exrule]:
            self._genitem(exlist, gen)
        exlist.sort()
        lastdt = None
        total = 0
        while rlist:
            ritem = rlist[0]
            if not lastdt or lastdt != ritem.dt:
                while exlist and exlist[0] < ritem:
                    exlist[0].next()
                    exlist.sort()
                if not exlist or ritem != exlist[0]:
                    total += 1
                    yield ritem.dt
                lastdt = ritem.dt
            ritem.next()
            rlist.sort()
        self._len = total

class _rrulestr:

    _freq_map = {"YEARLY": YEARLY,
                 "MONTHLY": MONTHLY,
                 "WEEKLY": WEEKLY,
                 "DAILY": DAILY,
                 "HOURLY": HOURLY,
                 "MINUTELY": MINUTELY,
                 "SECONDLY": SECONDLY}

    _weekday_map = {"MO":0,"TU":1,"WE":2,"TH":3,"FR":4,"SA":5,"SU":6}

    def _handle_int(self, rrkwargs, name, value, **kwargs):
        rrkwargs[name.lower()] = int(value)

    def _handle_int_list(self, rrkwargs, name, value, **kwargs):
        rrkwargs[name.lower()] = [int(x) for x in value.split(',')]

    _handle_INTERVAL   = _handle_int
    _handle_COUNT      = _handle_int
    _handle_BYSETPOS   = _handle_int_list
    _handle_BYMONTH    = _handle_int_list
    _handle_BYMONTHDAY = _handle_int_list
    _handle_BYYEARDAY  = _handle_int_list
    _handle_BYEASTER   = _handle_int_list
    _handle_BYWEEKNO   = _handle_int_list
    _handle_BYHOUR     = _handle_int_list
    _handle_BYMINUTE   = _handle_int_list
    _handle_BYSECOND   = _handle_int_list

    def _handle_FREQ(self, rrkwargs, name, value, **kwargs):
        rrkwargs["freq"] = self._freq_map[value]

    def _handle_UNTIL(self, rrkwargs, name, value, **kwargs):
        global parser
        if not parser:
            from dateutil import parser
        try:
            rrkwargs["until"] = parser.parse(value,
                                           ignoretz=kwargs.get("ignoretz"),
                                           tzinfos=kwargs.get("tzinfos"))
        except ValueError:
            raise ValueError, "invalid until date"

    def _handle_WKST(self, rrkwargs, name, value, **kwargs):
        rrkwargs["wkst"] = self._weekday_map[value]

    def _handle_BYWEEKDAY(self, rrkwargs, name, value, **kwarsg):
        l = []
        for wday in value.split(','):
            for i in range(len(wday)):
                if wday[i] not in '+-0123456789':
                    break
            n = wday[:i] or None
            w = wday[i:]
            if n: n = int(n)
            l.append(weekdays[self._weekday_map[w]](n))
        rrkwargs["byweekday"] = l

    _handle_BYDAY = _handle_BYWEEKDAY

    def _parse_rfc_rrule(self, line,
                         dtstart=None,
                         cache=False,
                         ignoretz=False,
                         tzinfos=None):
        if line.find(':') != -1:
            name, value = line.split(':')
            if name != "RRULE":
                raise ValueError, "unknown parameter name"
        else:
            value = line
        rrkwargs = {}
        for pair in value.split(';'):
            name, value = pair.split('=')
            name = name.upper()
            value = value.upper()
            try:
                getattr(self, "_handle_"+name)(rrkwargs, name, value,
                                               ignoretz=ignoretz,
                                               tzinfos=tzinfos)
            except AttributeError:
                raise ValueError, "unknown parameter '%s'" % name
            except (KeyError, ValueError):
                raise ValueError, "invalid '%s': %s" % (name, value)
        return rrule(dtstart=dtstart, cache=cache, **rrkwargs)

    def _parse_rfc(self, s,
                   dtstart=None,
                   cache=False,
                   unfold=False,
                   forceset=False,
                   compatible=False,
                   ignoretz=False,
                   tzinfos=None):
        global parser
        if compatible:
            forceset = True
            unfold = True
        s = s.upper()
        if not s.strip():
            raise ValueError, "empty string"
        if unfold:
            lines = s.splitlines()
            i = 0
            while i < len(lines):
                line = lines[i].rstrip()
                if not line:
                    del lines[i]
                elif i > 0 and line[0] == " ":
                    lines[i-1] += line[1:]
                    del lines[i]
                else:
                    i += 1
        else:
            lines = s.split()
        if (not forceset and len(lines) == 1 and
            (s.find(':') == -1 or s.startswith('RRULE:'))):
            return self._parse_rfc_rrule(lines[0], cache=cache,
                                         dtstart=dtstart, ignoretz=ignoretz,
                                         tzinfos=tzinfos)
        else:
            rrulevals = []
            rdatevals = []
            exrulevals = []
            exdatevals = []
            for line in lines:
                if not line:
                    continue
                if line.find(':') == -1:
                    name = "RRULE"
                    value = line
                else:
                    name, value = line.split(':', 1)
                parms = name.split(';')
                if not parms:
                    raise ValueError, "empty property name"
                name = parms[0]
                parms = parms[1:]
                if name == "RRULE":
                    for parm in parms:
                        raise ValueError, "unsupported RRULE parm: "+parm
                    rrulevals.append(value)
                elif name == "RDATE":
                    for parm in parms:
                        if parm != "VALUE=DATE-TIME":
                            raise ValueError, "unsupported RDATE parm: "+parm
                    rdatevals.append(value)
                elif name == "EXRULE":
                    for parm in parms:
                        raise ValueError, "unsupported EXRULE parm: "+parm
                    exrulevals.append(value)
                elif name == "EXDATE":
                    for parm in parms:
                        if parm != "VALUE=DATE-TIME":
                            raise ValueError, "unsupported RDATE parm: "+parm
                    exdatevals.append(value)
                elif name == "DTSTART":
                    for parm in parms:
                        raise ValueError, "unsupported DTSTART parm: "+parm
                    if not parser:
                        from dateutil import parser
                    dtstart = parser.parse(value, ignoretz=ignoretz,
                                           tzinfos=tzinfos)
                else:
                    raise ValueError, "unsupported property: "+name
            if (forceset or len(rrulevals) > 1 or
                rdatevals or exrulevals or exdatevals):
                if not parser and (rdatevals or exdatevals):
                    from dateutil import parser
                set = rruleset(cache=cache)
                for value in rrulevals:
                    set.rrule(self._parse_rfc_rrule(value, dtstart=dtstart,
                                                    ignoretz=ignoretz,
                                                    tzinfos=tzinfos))
                for value in rdatevals:
                    for datestr in value.split(','):
                        set.rdate(parser.parse(datestr,
                                               ignoretz=ignoretz,
                                               tzinfos=tzinfos))
                for value in exrulevals:
                    set.exrule(self._parse_rfc_rrule(value, dtstart=dtstart,
                                                     ignoretz=ignoretz,
                                                     tzinfos=tzinfos))
                for value in exdatevals:
                    for datestr in value.split(','):
                        set.exdate(parser.parse(datestr,
                                                ignoretz=ignoretz,
                                                tzinfos=tzinfos))
                if compatible and dtstart:
                    set.rdate(dtstart)
                return set
            else:
                return self._parse_rfc_rrule(rrulevals[0],
                                             dtstart=dtstart,
                                             cache=cache,
                                             ignoretz=ignoretz,
                                             tzinfos=tzinfos)

    def __call__(self, s, **kwargs):
        return self._parse_rfc(s, **kwargs)

rrulestr = _rrulestr()

# vim:ts=4:sw=4:et

########NEW FILE########
__FILENAME__ = tz
"""
Copyright (c) 2003-2007  Gustavo Niemeyer <gustavo@niemeyer.net>

This module offers extensions to the standard python 2.3+
datetime module.
"""
__author__ = "Gustavo Niemeyer <gustavo@niemeyer.net>"
__license__ = "PSF License"

import datetime
import struct
import time
import sys
import os

relativedelta = None
parser = None
rrule = None

__all__ = ["tzutc", "tzoffset", "tzlocal", "tzfile", "tzrange",
           "tzstr", "tzical", "tzwin", "tzwinlocal", "gettz"]

try:
    from dateutil.tzwin import tzwin, tzwinlocal
except (ImportError, OSError):
    tzwin, tzwinlocal = None, None

ZERO = datetime.timedelta(0)
EPOCHORDINAL = datetime.datetime.utcfromtimestamp(0).toordinal()

class tzutc(datetime.tzinfo):

    def utcoffset(self, dt):
        return ZERO
     
    def dst(self, dt):
        return ZERO

    def tzname(self, dt):
        return "UTC"

    def __eq__(self, other):
        return (isinstance(other, tzutc) or
                (isinstance(other, tzoffset) and other._offset == ZERO))

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return "%s()" % self.__class__.__name__

    __reduce__ = object.__reduce__

class tzoffset(datetime.tzinfo):

    def __init__(self, name, offset):
        self._name = name
        self._offset = datetime.timedelta(seconds=offset)

    def utcoffset(self, dt):
        return self._offset

    def dst(self, dt):
        return ZERO

    def tzname(self, dt):
        return self._name

    def __eq__(self, other):
        return (isinstance(other, tzoffset) and
                self._offset == other._offset)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return "%s(%s, %s)" % (self.__class__.__name__,
                               `self._name`,
                               self._offset.days*86400+self._offset.seconds)

    __reduce__ = object.__reduce__

class tzlocal(datetime.tzinfo):

    _std_offset = datetime.timedelta(seconds=-time.timezone)
    if time.daylight:
        _dst_offset = datetime.timedelta(seconds=-time.altzone)
    else:
        _dst_offset = _std_offset

    def utcoffset(self, dt):
        if self._isdst(dt):
            return self._dst_offset
        else:
            return self._std_offset

    def dst(self, dt):
        if self._isdst(dt):
            return self._dst_offset-self._std_offset
        else:
            return ZERO

    def tzname(self, dt):
        return time.tzname[self._isdst(dt)]

    def _isdst(self, dt):
        # We can't use mktime here. It is unstable when deciding if
        # the hour near to a change is DST or not.
        # 
        # timestamp = time.mktime((dt.year, dt.month, dt.day, dt.hour,
        #                         dt.minute, dt.second, dt.weekday(), 0, -1))
        # return time.localtime(timestamp).tm_isdst
        #
        # The code above yields the following result:
        #
        #>>> import tz, datetime
        #>>> t = tz.tzlocal()
        #>>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
        #'BRDT'
        #>>> datetime.datetime(2003,2,16,0,tzinfo=t).tzname()
        #'BRST'
        #>>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
        #'BRST'
        #>>> datetime.datetime(2003,2,15,22,tzinfo=t).tzname()
        #'BRDT'
        #>>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
        #'BRDT'
        #
        # Here is a more stable implementation:
        #
        timestamp = ((dt.toordinal() - EPOCHORDINAL) * 86400
                     + dt.hour * 3600
                     + dt.minute * 60
                     + dt.second)
        return time.localtime(timestamp+time.timezone).tm_isdst

    def __eq__(self, other):
        if not isinstance(other, tzlocal):
            return False
        return (self._std_offset == other._std_offset and
                self._dst_offset == other._dst_offset)
        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return "%s()" % self.__class__.__name__

    __reduce__ = object.__reduce__

class _ttinfo(object):
    __slots__ = ["offset", "delta", "isdst", "abbr", "isstd", "isgmt"]

    def __init__(self):
        for attr in self.__slots__:
            setattr(self, attr, None)

    def __repr__(self):
        l = []
        for attr in self.__slots__:
            value = getattr(self, attr)
            if value is not None:
                l.append("%s=%s" % (attr, `value`))
        return "%s(%s)" % (self.__class__.__name__, ", ".join(l))

    def __eq__(self, other):
        if not isinstance(other, _ttinfo):
            return False
        return (self.offset == other.offset and
                self.delta == other.delta and
                self.isdst == other.isdst and
                self.abbr == other.abbr and
                self.isstd == other.isstd and
                self.isgmt == other.isgmt)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __getstate__(self):
        state = {}
        for name in self.__slots__:
            state[name] = getattr(self, name, None)
        return state

    def __setstate__(self, state):
        for name in self.__slots__:
            if name in state:
                setattr(self, name, state[name])

class tzfile(datetime.tzinfo):

    # http://www.twinsun.com/tz/tz-link.htm
    # ftp://elsie.nci.nih.gov/pub/tz*.tar.gz
    
    def __init__(self, fileobj):
        if isinstance(fileobj, basestring):
            self._filename = fileobj
            fileobj = open(fileobj)
        elif hasattr(fileobj, "name"):
            self._filename = fileobj.name
        else:
            self._filename = `fileobj`

        # From tzfile(5):
        #
        # The time zone information files used by tzset(3)
        # begin with the magic characters "TZif" to identify
        # them as time zone information files, followed by
        # sixteen bytes reserved for future use, followed by
        # six four-byte values of type long, written in a
        # ``standard'' byte order (the high-order  byte
        # of the value is written first).

        if fileobj.read(4) != "TZif":
            raise ValueError, "magic not found"

        fileobj.read(16)

        (
         # The number of UTC/local indicators stored in the file.
         ttisgmtcnt,

         # The number of standard/wall indicators stored in the file.
         ttisstdcnt,
         
         # The number of leap seconds for which data is
         # stored in the file.
         leapcnt,

         # The number of "transition times" for which data
         # is stored in the file.
         timecnt,

         # The number of "local time types" for which data
         # is stored in the file (must not be zero).
         typecnt,

         # The  number  of  characters  of "time zone
         # abbreviation strings" stored in the file.
         charcnt,

        ) = struct.unpack(">6l", fileobj.read(24))

        # The above header is followed by tzh_timecnt four-byte
        # values  of  type long,  sorted  in ascending order.
        # These values are written in ``standard'' byte order.
        # Each is used as a transition time (as  returned  by
        # time(2)) at which the rules for computing local time
        # change.

        if timecnt:
            self._trans_list = struct.unpack(">%dl" % timecnt,
                                             fileobj.read(timecnt*4))
        else:
            self._trans_list = []

        # Next come tzh_timecnt one-byte values of type unsigned
        # char; each one tells which of the different types of
        # ``local time'' types described in the file is associated
        # with the same-indexed transition time. These values
        # serve as indices into an array of ttinfo structures that
        # appears next in the file.
        
        if timecnt:
            self._trans_idx = struct.unpack(">%dB" % timecnt,
                                            fileobj.read(timecnt))
        else:
            self._trans_idx = []
        
        # Each ttinfo structure is written as a four-byte value
        # for tt_gmtoff  of  type long,  in  a  standard  byte
        # order, followed  by a one-byte value for tt_isdst
        # and a one-byte  value  for  tt_abbrind.   In  each
        # structure, tt_gmtoff  gives  the  number  of
        # seconds to be added to UTC, tt_isdst tells whether
        # tm_isdst should be set by  localtime(3),  and
        # tt_abbrind serves  as an index into the array of
        # time zone abbreviation characters that follow the
        # ttinfo structure(s) in the file.

        ttinfo = []

        for i in range(typecnt):
            ttinfo.append(struct.unpack(">lbb", fileobj.read(6)))

        abbr = fileobj.read(charcnt)

        # Then there are tzh_leapcnt pairs of four-byte
        # values, written in  standard byte  order;  the
        # first  value  of  each pair gives the time (as
        # returned by time(2)) at which a leap second
        # occurs;  the  second  gives the  total  number of
        # leap seconds to be applied after the given time.
        # The pairs of values are sorted in ascending order
        # by time.

        # Not used, for now
        if leapcnt:
            leap = struct.unpack(">%dl" % (leapcnt*2),
                                 fileobj.read(leapcnt*8))

        # Then there are tzh_ttisstdcnt standard/wall
        # indicators, each stored as a one-byte value;
        # they tell whether the transition times associated
        # with local time types were specified as standard
        # time or wall clock time, and are used when
        # a time zone file is used in handling POSIX-style
        # time zone environment variables.

        if ttisstdcnt:
            isstd = struct.unpack(">%db" % ttisstdcnt,
                                  fileobj.read(ttisstdcnt))

        # Finally, there are tzh_ttisgmtcnt UTC/local
        # indicators, each stored as a one-byte value;
        # they tell whether the transition times associated
        # with local time types were specified as UTC or
        # local time, and are used when a time zone file
        # is used in handling POSIX-style time zone envi-
        # ronment variables.

        if ttisgmtcnt:
            isgmt = struct.unpack(">%db" % ttisgmtcnt,
                                  fileobj.read(ttisgmtcnt))

        # ** Everything has been read **

        # Build ttinfo list
        self._ttinfo_list = []
        for i in range(typecnt):
            gmtoff, isdst, abbrind =  ttinfo[i]
            # Round to full-minutes if that's not the case. Python's
            # datetime doesn't accept sub-minute timezones. Check
            # http://python.org/sf/1447945 for some information.
            gmtoff = (gmtoff+30)//60*60
            tti = _ttinfo()
            tti.offset = gmtoff
            tti.delta = datetime.timedelta(seconds=gmtoff)
            tti.isdst = isdst
            tti.abbr = abbr[abbrind:abbr.find('\x00', abbrind)]
            tti.isstd = (ttisstdcnt > i and isstd[i] != 0)
            tti.isgmt = (ttisgmtcnt > i and isgmt[i] != 0)
            self._ttinfo_list.append(tti)

        # Replace ttinfo indexes for ttinfo objects.
        trans_idx = []
        for idx in self._trans_idx:
            trans_idx.append(self._ttinfo_list[idx])
        self._trans_idx = tuple(trans_idx)

        # Set standard, dst, and before ttinfos. before will be
        # used when a given time is before any transitions,
        # and will be set to the first non-dst ttinfo, or to
        # the first dst, if all of them are dst.
        self._ttinfo_std = None
        self._ttinfo_dst = None
        self._ttinfo_before = None
        if self._ttinfo_list:
            if not self._trans_list:
                self._ttinfo_std = self._ttinfo_first = self._ttinfo_list[0]
            else:
                for i in range(timecnt-1,-1,-1):
                    tti = self._trans_idx[i]
                    if not self._ttinfo_std and not tti.isdst:
                        self._ttinfo_std = tti
                    elif not self._ttinfo_dst and tti.isdst:
                        self._ttinfo_dst = tti
                    if self._ttinfo_std and self._ttinfo_dst:
                        break
                else:
                    if self._ttinfo_dst and not self._ttinfo_std:
                        self._ttinfo_std = self._ttinfo_dst

                for tti in self._ttinfo_list:
                    if not tti.isdst:
                        self._ttinfo_before = tti
                        break
                else:
                    self._ttinfo_before = self._ttinfo_list[0]

        # Now fix transition times to become relative to wall time.
        #
        # I'm not sure about this. In my tests, the tz source file
        # is setup to wall time, and in the binary file isstd and
        # isgmt are off, so it should be in wall time. OTOH, it's
        # always in gmt time. Let me know if you have comments
        # about this.
        laststdoffset = 0
        self._trans_list = list(self._trans_list)
        for i in range(len(self._trans_list)):
            tti = self._trans_idx[i]
            if not tti.isdst:
                # This is std time.
                self._trans_list[i] += tti.offset
                laststdoffset = tti.offset
            else:
                # This is dst time. Convert to std.
                self._trans_list[i] += laststdoffset
        self._trans_list = tuple(self._trans_list)

    def _find_ttinfo(self, dt, laststd=0):
        timestamp = ((dt.toordinal() - EPOCHORDINAL) * 86400
                     + dt.hour * 3600
                     + dt.minute * 60
                     + dt.second)
        idx = 0
        for trans in self._trans_list:
            if timestamp < trans:
                break
            idx += 1
        else:
            return self._ttinfo_std
        if idx == 0:
            return self._ttinfo_before
        if laststd:
            while idx > 0:
                tti = self._trans_idx[idx-1]
                if not tti.isdst:
                    return tti
                idx -= 1
            else:
                return self._ttinfo_std
        else:
            return self._trans_idx[idx-1]

    def utcoffset(self, dt):
        if not self._ttinfo_std:
            return ZERO
        return self._find_ttinfo(dt).delta

    def dst(self, dt):
        if not self._ttinfo_dst:
            return ZERO
        tti = self._find_ttinfo(dt)
        if not tti.isdst:
            return ZERO

        # The documentation says that utcoffset()-dst() must
        # be constant for every dt.
        return tti.delta-self._find_ttinfo(dt, laststd=1).delta

        # An alternative for that would be:
        #
        # return self._ttinfo_dst.offset-self._ttinfo_std.offset
        #
        # However, this class stores historical changes in the
        # dst offset, so I belive that this wouldn't be the right
        # way to implement this.
        
    def tzname(self, dt):
        if not self._ttinfo_std:
            return None
        return self._find_ttinfo(dt).abbr

    def __eq__(self, other):
        if not isinstance(other, tzfile):
            return False
        return (self._trans_list == other._trans_list and
                self._trans_idx == other._trans_idx and
                self._ttinfo_list == other._ttinfo_list)

    def __ne__(self, other):
        return not self.__eq__(other)


    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, `self._filename`)

    def __reduce__(self):
        if not os.path.isfile(self._filename):
            raise ValueError, "Unpickable %s class" % self.__class__.__name__
        return (self.__class__, (self._filename,))

class tzrange(datetime.tzinfo):

    def __init__(self, stdabbr, stdoffset=None,
                 dstabbr=None, dstoffset=None,
                 start=None, end=None):
        global relativedelta
        if not relativedelta:
            from dateutil import relativedelta
        self._std_abbr = stdabbr
        self._dst_abbr = dstabbr
        if stdoffset is not None:
            self._std_offset = datetime.timedelta(seconds=stdoffset)
        else:
            self._std_offset = ZERO
        if dstoffset is not None:
            self._dst_offset = datetime.timedelta(seconds=dstoffset)
        elif dstabbr and stdoffset is not None:
            self._dst_offset = self._std_offset+datetime.timedelta(hours=+1)
        else:
            self._dst_offset = ZERO
        if dstabbr and start is None:
            self._start_delta = relativedelta.relativedelta(
                    hours=+2, month=4, day=1, weekday=relativedelta.SU(+1))
        else:
            self._start_delta = start
        if dstabbr and end is None:
            self._end_delta = relativedelta.relativedelta(
                    hours=+1, month=10, day=31, weekday=relativedelta.SU(-1))
        else:
            self._end_delta = end

    def utcoffset(self, dt):
        if self._isdst(dt):
            return self._dst_offset
        else:
            return self._std_offset

    def dst(self, dt):
        if self._isdst(dt):
            return self._dst_offset-self._std_offset
        else:
            return ZERO

    def tzname(self, dt):
        if self._isdst(dt):
            return self._dst_abbr
        else:
            return self._std_abbr

    def _isdst(self, dt):
        if not self._start_delta:
            return False
        year = datetime.datetime(dt.year,1,1)
        start = year+self._start_delta
        end = year+self._end_delta
        dt = dt.replace(tzinfo=None)
        if start < end:
            return dt >= start and dt < end
        else:
            return dt >= start or dt < end

    def __eq__(self, other):
        if not isinstance(other, tzrange):
            return False
        return (self._std_abbr == other._std_abbr and
                self._dst_abbr == other._dst_abbr and
                self._std_offset == other._std_offset and
                self._dst_offset == other._dst_offset and
                self._start_delta == other._start_delta and
                self._end_delta == other._end_delta)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return "%s(...)" % self.__class__.__name__

    __reduce__ = object.__reduce__

class tzstr(tzrange):
    
    def __init__(self, s):
        global parser
        if not parser:
            from dateutil import parser
        self._s = s

        res = parser._parsetz(s)
        if res is None:
            raise ValueError, "unknown string format"

        # Here we break the compatibility with the TZ variable handling.
        # GMT-3 actually *means* the timezone -3.
        if res.stdabbr in ("GMT", "UTC"):
            res.stdoffset *= -1

        # We must initialize it first, since _delta() needs
        # _std_offset and _dst_offset set. Use False in start/end
        # to avoid building it two times.
        tzrange.__init__(self, res.stdabbr, res.stdoffset,
                         res.dstabbr, res.dstoffset,
                         start=False, end=False)

        if not res.dstabbr:
            self._start_delta = None
            self._end_delta = None
        else:
            self._start_delta = self._delta(res.start)
            if self._start_delta:
                self._end_delta = self._delta(res.end, isend=1)

    def _delta(self, x, isend=0):
        kwargs = {}
        if x.month is not None:
            kwargs["month"] = x.month
            if x.weekday is not None:
                kwargs["weekday"] = relativedelta.weekday(x.weekday, x.week)
                if x.week > 0:
                    kwargs["day"] = 1
                else:
                    kwargs["day"] = 31
            elif x.day:
                kwargs["day"] = x.day
        elif x.yday is not None:
            kwargs["yearday"] = x.yday
        elif x.jyday is not None:
            kwargs["nlyearday"] = x.jyday
        if not kwargs:
            # Default is to start on first sunday of april, and end
            # on last sunday of october.
            if not isend:
                kwargs["month"] = 4
                kwargs["day"] = 1
                kwargs["weekday"] = relativedelta.SU(+1)
            else:
                kwargs["month"] = 10
                kwargs["day"] = 31
                kwargs["weekday"] = relativedelta.SU(-1)
        if x.time is not None:
            kwargs["seconds"] = x.time
        else:
            # Default is 2AM.
            kwargs["seconds"] = 7200
        if isend:
            # Convert to standard time, to follow the documented way
            # of working with the extra hour. See the documentation
            # of the tzinfo class.
            delta = self._dst_offset-self._std_offset
            kwargs["seconds"] -= delta.seconds+delta.days*86400
        return relativedelta.relativedelta(**kwargs)

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, `self._s`)

class _tzicalvtzcomp:
    def __init__(self, tzoffsetfrom, tzoffsetto, isdst,
                       tzname=None, rrule=None):
        self.tzoffsetfrom = datetime.timedelta(seconds=tzoffsetfrom)
        self.tzoffsetto = datetime.timedelta(seconds=tzoffsetto)
        self.tzoffsetdiff = self.tzoffsetto-self.tzoffsetfrom
        self.isdst = isdst
        self.tzname = tzname
        self.rrule = rrule

class _tzicalvtz(datetime.tzinfo):
    def __init__(self, tzid, comps=[]):
        self._tzid = tzid
        self._comps = comps
        self._cachedate = []
        self._cachecomp = []

    def _find_comp(self, dt):
        if len(self._comps) == 1:
            return self._comps[0]
        dt = dt.replace(tzinfo=None)
        try:
            return self._cachecomp[self._cachedate.index(dt)]
        except ValueError:
            pass
        lastcomp = None
        lastcompdt = None
        for comp in self._comps:
            if not comp.isdst:
                # Handle the extra hour in DST -> STD
                compdt = comp.rrule.before(dt-comp.tzoffsetdiff, inc=True)
            else:
                compdt = comp.rrule.before(dt, inc=True)
            if compdt and (not lastcompdt or lastcompdt < compdt):
                lastcompdt = compdt
                lastcomp = comp
        if not lastcomp:
            # RFC says nothing about what to do when a given
            # time is before the first onset date. We'll look for the
            # first standard component, or the first component, if
            # none is found.
            for comp in self._comps:
                if not comp.isdst:
                    lastcomp = comp
                    break
            else:
                lastcomp = comp[0]
        self._cachedate.insert(0, dt)
        self._cachecomp.insert(0, lastcomp)
        if len(self._cachedate) > 10:
            self._cachedate.pop()
            self._cachecomp.pop()
        return lastcomp

    def utcoffset(self, dt):
        return self._find_comp(dt).tzoffsetto

    def dst(self, dt):
        comp = self._find_comp(dt)
        if comp.isdst:
            return comp.tzoffsetdiff
        else:
            return ZERO

    def tzname(self, dt):
        return self._find_comp(dt).tzname

    def __repr__(self):
        return "<tzicalvtz %s>" % `self._tzid`

    __reduce__ = object.__reduce__

class tzical:
    def __init__(self, fileobj):
        global rrule
        if not rrule:
            from dateutil import rrule

        if isinstance(fileobj, basestring):
            self._s = fileobj
            fileobj = open(fileobj)
        elif hasattr(fileobj, "name"):
            self._s = fileobj.name
        else:
            self._s = `fileobj`

        self._vtz = {}

        self._parse_rfc(fileobj.read())

    def keys(self):
        return self._vtz.keys()

    def get(self, tzid=None):
        if tzid is None:
            keys = self._vtz.keys()
            if len(keys) == 0:
                raise ValueError, "no timezones defined"
            elif len(keys) > 1:
                raise ValueError, "more than one timezone available"
            tzid = keys[0]
        return self._vtz.get(tzid)

    def _parse_offset(self, s):
        s = s.strip()
        if not s:
            raise ValueError, "empty offset"
        if s[0] in ('+', '-'):
            signal = (-1,+1)[s[0]=='+']
            s = s[1:]
        else:
            signal = +1
        if len(s) == 4:
            return (int(s[:2])*3600+int(s[2:])*60)*signal
        elif len(s) == 6:
            return (int(s[:2])*3600+int(s[2:4])*60+int(s[4:]))*signal
        else:
            raise ValueError, "invalid offset: "+s

    def _parse_rfc(self, s):
        lines = s.splitlines()
        if not lines:
            raise ValueError, "empty string"

        # Unfold
        i = 0
        while i < len(lines):
            line = lines[i].rstrip()
            if not line:
                del lines[i]
            elif i > 0 and line[0] == " ":
                lines[i-1] += line[1:]
                del lines[i]
            else:
                i += 1

        tzid = None
        comps = []
        invtz = False
        comptype = None
        for line in lines:
            if not line:
                continue
            name, value = line.split(':', 1)
            parms = name.split(';')
            if not parms:
                raise ValueError, "empty property name"
            name = parms[0].upper()
            parms = parms[1:]
            if invtz:
                if name == "BEGIN":
                    if value in ("STANDARD", "DAYLIGHT"):
                        # Process component
                        pass
                    else:
                        raise ValueError, "unknown component: "+value
                    comptype = value
                    founddtstart = False
                    tzoffsetfrom = None
                    tzoffsetto = None
                    rrulelines = []
                    tzname = None
                elif name == "END":
                    if value == "VTIMEZONE":
                        if comptype:
                            raise ValueError, \
                                  "component not closed: "+comptype
                        if not tzid:
                            raise ValueError, \
                                  "mandatory TZID not found"
                        if not comps:
                            raise ValueError, \
                                  "at least one component is needed"
                        # Process vtimezone
                        self._vtz[tzid] = _tzicalvtz(tzid, comps)
                        invtz = False
                    elif value == comptype:
                        if not founddtstart:
                            raise ValueError, \
                                  "mandatory DTSTART not found"
                        if tzoffsetfrom is None:
                            raise ValueError, \
                                  "mandatory TZOFFSETFROM not found"
                        if tzoffsetto is None:
                            raise ValueError, \
                                  "mandatory TZOFFSETFROM not found"
                        # Process component
                        rr = None
                        if rrulelines:
                            rr = rrule.rrulestr("\n".join(rrulelines),
                                                compatible=True,
                                                ignoretz=True,
                                                cache=True)
                        comp = _tzicalvtzcomp(tzoffsetfrom, tzoffsetto,
                                              (comptype == "DAYLIGHT"),
                                              tzname, rr)
                        comps.append(comp)
                        comptype = None
                    else:
                        raise ValueError, \
                              "invalid component end: "+value
                elif comptype:
                    if name == "DTSTART":
                        rrulelines.append(line)
                        founddtstart = True
                    elif name in ("RRULE", "RDATE", "EXRULE", "EXDATE"):
                        rrulelines.append(line)
                    elif name == "TZOFFSETFROM":
                        if parms:
                            raise ValueError, \
                                  "unsupported %s parm: %s "%(name, parms[0])
                        tzoffsetfrom = self._parse_offset(value)
                    elif name == "TZOFFSETTO":
                        if parms:
                            raise ValueError, \
                                  "unsupported TZOFFSETTO parm: "+parms[0]
                        tzoffsetto = self._parse_offset(value)
                    elif name == "TZNAME":
                        if parms:
                            raise ValueError, \
                                  "unsupported TZNAME parm: "+parms[0]
                        tzname = value
                    elif name == "COMMENT":
                        pass
                    else:
                        raise ValueError, "unsupported property: "+name
                else:
                    if name == "TZID":
                        if parms:
                            raise ValueError, \
                                  "unsupported TZID parm: "+parms[0]
                        tzid = value
                    elif name in ("TZURL", "LAST-MODIFIED", "COMMENT"):
                        pass
                    else:
                        raise ValueError, "unsupported property: "+name
            elif name == "BEGIN" and value == "VTIMEZONE":
                tzid = None
                comps = []
                invtz = True

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, `self._s`)

if sys.platform != "win32":
    TZFILES = ["/etc/localtime", "localtime"]
    TZPATHS = ["/usr/share/zoneinfo", "/usr/lib/zoneinfo", "/etc/zoneinfo"]
else:
    TZFILES = []
    TZPATHS = []

def gettz(name=None):
    tz = None
    if not name:
        try:
            name = os.environ["TZ"]
        except KeyError:
            pass
    if name is None or name == ":":
        for filepath in TZFILES:
            if not os.path.isabs(filepath):
                filename = filepath
                for path in TZPATHS:
                    filepath = os.path.join(path, filename)
                    if os.path.isfile(filepath):
                        break
                else:
                    continue
            if os.path.isfile(filepath):
                try:
                    tz = tzfile(filepath)
                    break
                except (IOError, OSError, ValueError):
                    pass
        else:
            tz = tzlocal()
    else:
        if name.startswith(":"):
            name = name[:-1]
        if os.path.isabs(name):
            if os.path.isfile(name):
                tz = tzfile(name)
            else:
                tz = None
        else:
            for path in TZPATHS:
                filepath = os.path.join(path, name)
                if not os.path.isfile(filepath):
                    filepath = filepath.replace(' ','_')
                    if not os.path.isfile(filepath):
                        continue
                try:
                    tz = tzfile(filepath)
                    break
                except (IOError, OSError, ValueError):
                    pass
            else:
                tz = None
                if tzwin:
                    try:
                        tz = tzwin(name)
                    except OSError:
                        pass
                if not tz:
                    from dateutil.zoneinfo import gettz
                    tz = gettz(name)
                if not tz:
                    for c in name:
                        # name must have at least one offset to be a tzstr
                        if c in "0123456789":
                            try:
                                tz = tzstr(name)
                            except ValueError:
                                pass
                            break
                    else:
                        if name in ("GMT", "UTC"):
                            tz = tzutc()
                        elif name in time.tzname:
                            tz = tzlocal()
    return tz

# vim:ts=4:sw=4:et

########NEW FILE########
__FILENAME__ = tzwin
# This code was originally contributed by Jeffrey Harris.
import datetime
import struct
import _winreg

__author__ = "Jeffrey Harris & Gustavo Niemeyer <gustavo@niemeyer.net>"

__all__ = ["tzwin", "tzwinlocal"]

ONEWEEK = datetime.timedelta(7)

TZKEYNAMENT = r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones"
TZKEYNAME9X = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Time Zones"
TZLOCALKEYNAME = r"SYSTEM\CurrentControlSet\Control\TimeZoneInformation"

def _settzkeyname():
    global TZKEYNAME
    handle = _winreg.ConnectRegistry(None, _winreg.HKEY_LOCAL_MACHINE)
    try:
        _winreg.OpenKey(handle, TZKEYNAMENT).Close()
        TZKEYNAME = TZKEYNAMENT
    except WindowsError:
        TZKEYNAME = TZKEYNAME9X
    handle.Close()

_settzkeyname()

class tzwinbase(datetime.tzinfo):
    """tzinfo class based on win32's timezones available in the registry."""

    def utcoffset(self, dt):
        if self._isdst(dt):
            return datetime.timedelta(minutes=self._dstoffset)
        else:
            return datetime.timedelta(minutes=self._stdoffset)

    def dst(self, dt):
        if self._isdst(dt):
            minutes = self._dstoffset - self._stdoffset
            return datetime.timedelta(minutes=minutes)
        else:
            return datetime.timedelta(0)
        
    def tzname(self, dt):
        if self._isdst(dt):
            return self._dstname
        else:
            return self._stdname

    def list():
        """Return a list of all time zones known to the system."""
        handle = _winreg.ConnectRegistry(None, _winreg.HKEY_LOCAL_MACHINE)
        tzkey = _winreg.OpenKey(handle, TZKEYNAME)
        result = [_winreg.EnumKey(tzkey, i)
                  for i in range(_winreg.QueryInfoKey(tzkey)[0])]
        tzkey.Close()
        handle.Close()
        return result
    list = staticmethod(list)

    def display(self):
        return self._display
    
    def _isdst(self, dt):
        dston = picknthweekday(dt.year, self._dstmonth, self._dstdayofweek,
                               self._dsthour, self._dstminute,
                               self._dstweeknumber)
        dstoff = picknthweekday(dt.year, self._stdmonth, self._stddayofweek,
                                self._stdhour, self._stdminute,
                                self._stdweeknumber)
        if dston < dstoff:
            return dston <= dt.replace(tzinfo=None) < dstoff
        else:
            return not dstoff <= dt.replace(tzinfo=None) < dston


class tzwin(tzwinbase):

    def __init__(self, name):
        self._name = name

        handle = _winreg.ConnectRegistry(None, _winreg.HKEY_LOCAL_MACHINE)
        tzkey = _winreg.OpenKey(handle, "%s\%s" % (TZKEYNAME, name))
        keydict = valuestodict(tzkey)
        tzkey.Close()
        handle.Close()

        self._stdname = keydict["Std"].encode("iso-8859-1")
        self._dstname = keydict["Dlt"].encode("iso-8859-1")

        self._display = keydict["Display"]
        
        # See http://ww_winreg.jsiinc.com/SUBA/tip0300/rh0398.htm
        tup = struct.unpack("=3l16h", keydict["TZI"])
        self._stdoffset = -tup[0]-tup[1]         # Bias + StandardBias * -1
        self._dstoffset = self._stdoffset-tup[2] # + DaylightBias * -1
        
        (self._stdmonth,
         self._stddayofweek,  # Sunday = 0
         self._stdweeknumber, # Last = 5
         self._stdhour,
         self._stdminute) = tup[4:9]

        (self._dstmonth,
         self._dstdayofweek,  # Sunday = 0
         self._dstweeknumber, # Last = 5
         self._dsthour,
         self._dstminute) = tup[12:17]

    def __repr__(self):
        return "tzwin(%s)" % repr(self._name)

    def __reduce__(self):
        return (self.__class__, (self._name,))


class tzwinlocal(tzwinbase):
    
    def __init__(self):

        handle = _winreg.ConnectRegistry(None, _winreg.HKEY_LOCAL_MACHINE)

        tzlocalkey = _winreg.OpenKey(handle, TZLOCALKEYNAME)
        keydict = valuestodict(tzlocalkey)
        tzlocalkey.Close()

        self._stdname = keydict["StandardName"].encode("iso-8859-1")
        self._dstname = keydict["DaylightName"].encode("iso-8859-1")

        try:
            tzkey = _winreg.OpenKey(handle, "%s\%s"%(TZKEYNAME, self._stdname))
            _keydict = valuestodict(tzkey)
            self._display = _keydict["Display"]
            tzkey.Close()
        except OSError:
            self._display = None

        handle.Close()
        
        self._stdoffset = -keydict["Bias"]-keydict["StandardBias"]
        self._dstoffset = self._stdoffset-keydict["DaylightBias"]


        # See http://ww_winreg.jsiinc.com/SUBA/tip0300/rh0398.htm
        tup = struct.unpack("=8h", keydict["StandardStart"])

        (self._stdmonth,
         self._stddayofweek,  # Sunday = 0
         self._stdweeknumber, # Last = 5
         self._stdhour,
         self._stdminute) = tup[1:6]

        tup = struct.unpack("=8h", keydict["DaylightStart"])

        (self._dstmonth,
         self._dstdayofweek,  # Sunday = 0
         self._dstweeknumber, # Last = 5
         self._dsthour,
         self._dstminute) = tup[1:6]

    def __reduce__(self):
        return (self.__class__, ())

def picknthweekday(year, month, dayofweek, hour, minute, whichweek):
    """dayofweek == 0 means Sunday, whichweek 5 means last instance"""
    first = datetime.datetime(year, month, 1, hour, minute)
    weekdayone = first.replace(day=((dayofweek-first.isoweekday())%7+1))
    for n in xrange(whichweek):
        dt = weekdayone+(whichweek-n)*ONEWEEK
        if dt.month == month:
            return dt

def valuestodict(key):
    """Convert a registry key's values to a dictionary."""
    dict = {}
    size = _winreg.QueryInfoKey(key)[1]
    for i in range(size):
        data = _winreg.EnumValue(key, i)
        dict[data[0]] = data[1]
    return dict

########NEW FILE########
__FILENAME__ = FileIterator
import os
import logging

def FileIterator(base, separator=os.path.sep):
  """Walks a directory tree, returning all the files. Follows symlinks.
  
  Args:
    base: The base path to search for files under.
    separator: Path separator used by the running system's platform.
  
  Yields:
    Paths of files found, relative to base.
  
  """
  dirs = ['']
  while dirs:
    current_dir = dirs.pop()
    for entry in os.listdir(os.path.join(base, current_dir)):
      name = os.path.join(current_dir, entry)
      fullname = os.path.join(base, name)
      if separator == '\\':
        name = name.replace('\\', '/')
      if os.path.isfile(fullname):
          yield name
      elif os.path.isdir(fullname):
          dirs.append(name)

########NEW FILE########
__FILENAME__ = data
CROSSWALK = {1: {'ap': 'Ala.',
     'fips': '1',
     'name': 'Alabama',
     'postal': 'AL',
     'type': 'state'},
 2: {'ap': 'Alaska',
     'fips': '2',
     'name': 'Alaska',
     'postal': 'AK',
     'type': 'state'},
 4: {'ap': 'Ariz.',
     'fips': '4',
     'name': 'Arizona',
     'postal': 'AZ',
     'type': 'state'},
 5: {'ap': 'Ark.',
     'fips': '5',
     'name': 'Arkansas',
     'postal': 'AR',
     'type': 'state'},
 6: {'ap': 'Calif.',
     'fips': '6',
     'name': 'California',
     'postal': 'CA',
     'type': 'state'},
 8: {'ap': 'Colo.',
     'fips': '8',
     'name': 'Colorado',
     'postal': 'CO',
     'type': 'state'},
 9: {'ap': 'Conn.',
     'fips': '9',
     'name': 'Connecticut',
     'postal': 'CT',
     'type': 'state'},
 10: {'ap': 'Del.',
      'fips': '10',
      'name': 'Delaware',
      'postal': 'DE',
      'type': 'state'},
 11: {'ap': 'D.C.',
      'fips': '11',
      'name': 'District of Columbia',
      'postal': 'DC',
      'type': ''},
 12: {'ap': 'Fla.',
      'fips': '12',
      'name': 'Florida',
      'postal': 'FL',
      'type': 'state'},
 13: {'ap': 'Ga.',
      'fips': '13',
      'name': 'Georgia',
      'postal': 'GA',
      'type': 'state'},
 15: {'ap': 'Hawaii',
      'fips': '15',
      'name': 'Hawaii',
      'postal': 'HI',
      'type': 'state'},
 16: {'ap': 'Idaho',
      'fips': '16',
      'name': 'Idaho',
      'postal': 'ID',
      'type': 'state'},
 17: {'ap': 'Ill.',
      'fips': '17',
      'name': 'Illinois',
      'postal': 'IL',
      'type': 'state'},
 18: {'ap': 'Ind.',
      'fips': '18',
      'name': 'Indiana',
      'postal': 'IN',
      'type': 'state'},
 19: {'ap': 'Iowa',
      'fips': '19',
      'name': 'Iowa',
      'postal': 'IA',
      'type': 'state'},
 20: {'ap': 'Kan.',
      'fips': '20',
      'name': 'Kansas',
      'postal': 'KS',
      'type': 'state'},
 21: {'ap': 'Ky.',
      'fips': '21',
      'name': 'Kentucky',
      'postal': 'KY',
      'type': 'state'},
 22: {'ap': 'La.',
      'fips': '22',
      'name': 'Louisiana',
      'postal': 'LA',
      'type': 'state'},
 23: {'ap': 'Maine',
      'fips': '23',
      'name': 'Maine',
      'postal': 'ME',
      'type': 'state'},
 24: {'ap': 'Md.',
      'fips': '24',
      'name': 'Maryland',
      'postal': 'MD',
      'type': 'state'},
 25: {'ap': 'Mass.',
      'fips': '25',
      'name': 'Massachusetts',
      'postal': 'MA',
      'type': 'state'},
 26: {'ap': 'Mich.',
      'fips': '26',
      'name': 'Michigan',
      'postal': 'MI',
      'type': 'state'},
 27: {'ap': 'Minn.',
      'fips': '27',
      'name': 'Minnesota',
      'postal': 'MN',
      'type': 'state'},
 28: {'ap': 'Miss.',
      'fips': '28',
      'name': 'Mississippi',
      'postal': 'MS',
      'type': 'state'},
 29: {'ap': 'Mo.',
      'fips': '29',
      'name': 'Missouri',
      'postal': 'MO',
      'type': 'state'},
 30: {'ap': 'Mont.',
      'fips': '30',
      'name': 'Montana',
      'postal': 'MT',
      'type': 'state'},
 31: {'ap': 'Neb.',
      'fips': '31',
      'name': 'Nebraska',
      'postal': 'NE',
      'type': 'state'},
 32: {'ap': 'Nev.',
      'fips': '32',
      'name': 'Nevada',
      'postal': 'NV',
      'type': 'state'},
 33: {'ap': 'N.H.',
      'fips': '33',
      'name': 'New Hampshire',
      'postal': 'NH',
      'type': 'state'},
 34: {'ap': 'N.J.',
      'fips': '34',
      'name': 'New Jersey',
      'postal': 'NJ',
      'type': 'state'},
 35: {'ap': 'N.M.',
      'fips': '35',
      'name': 'New Mexico',
      'postal': 'NM',
      'type': 'state'},
 36: {'ap': 'N.Y.',
      'fips': '36',
      'name': 'New York',
      'postal': 'NY',
      'type': 'state'},
 37: {'ap': 'N.C.',
      'fips': '37',
      'name': 'North Carolina',
      'postal': 'NC',
      'type': 'state'},
 38: {'ap': 'N.D.',
      'fips': '38',
      'name': 'North Dakota',
      'postal': 'ND',
      'type': 'state'},
 39: {'ap': 'Ohio',
      'fips': '39',
      'name': 'Ohio',
      'postal': 'OH',
      'type': 'state'},
 40: {'ap': 'Okla.',
      'fips': '40',
      'name': 'Oklahoma',
      'postal': 'OK',
      'type': 'state'},
 41: {'ap': 'Ore.',
      'fips': '41',
      'name': 'Oregon',
      'postal': 'OR',
      'type': 'state'},
 42: {'ap': 'Pa.',
      'fips': '42',
      'name': 'Pennsylvania',
      'postal': 'PA',
      'type': 'state'},
 44: {'ap': 'R.I.',
      'fips': '44',
      'name': 'Rhode Island',
      'postal': 'RI',
      'type': 'state'},
 45: {'ap': 'S.C.',
      'fips': '45',
      'name': 'South Carolina',
      'postal': 'SC',
      'type': 'state'},
 46: {'ap': 'S.D.',
      'fips': '46',
      'name': 'South Dakota',
      'postal': 'SD',
      'type': 'state'},
 47: {'ap': 'Tenn.',
      'fips': '47',
      'name': 'Tennessee',
      'postal': 'TN',
      'type': 'state'},
 48: {'ap': 'Texas',
      'fips': '48',
      'name': 'Texas',
      'postal': 'TX',
      'type': 'state'},
 49: {'ap': 'Utah',
      'fips': '49',
      'name': 'Utah',
      'postal': 'UT',
      'type': 'state'},
 50: {'ap': 'Vt.',
      'fips': '50',
      'name': 'Vermont',
      'postal': 'VT',
      'type': 'state'},
 51: {'ap': 'Va.',
      'fips': '51',
      'name': 'Virginia',
      'postal': 'VA',
      'type': 'state'},
 53: {'ap': 'Wash.',
      'fips': '53',
      'name': 'Washington',
      'postal': 'WA',
      'type': 'state'},
 54: {'ap': 'W.Va.',
      'fips': '54',
      'name': 'West Virginia',
      'postal': 'WV',
      'type': 'state'},
 55: {'ap': 'Wis.',
      'fips': '55',
      'name': 'Wisconsin',
      'postal': 'WI',
      'type': 'state'},
 56: {'ap': 'Wyo.',
      'fips': '56',
      'name': 'Wyoming',
      'postal': 'WY',
      'type': 'state'},
 60: {'ap': '',
      'fips': '60',
      'name': 'American Samoa',
      'postal': 'AS',
      'type': ''},
 64: {'ap': '',
      'fips': '64',
      'name': 'Federated States of Micronesia',
      'postal': 'FM',
      'type': ''},
 66: {'ap': '', 'fips': '66', 'name': 'Guam', 'postal': 'GU', 'type': ''},
 68: {'ap': '',
      'fips': '68',
      'name': 'Marshall Islands',
      'postal': 'MH',
      'type': ''},
 69: {'ap': '',
      'fips': '69',
      'name': 'Northern Mariana Islands',
      'postal': 'MP',
      'type': ''},
 70: {'ap': '', 'fips': '70', 'name': 'Palau', 'postal': 'PW', 'type': ''},
 72: {'ap': '',
      'fips': '72',
      'name': 'Puerto Rico',
      'postal': 'PR',
      'type': ''},
 78: {'ap': '',
      'fips': '78',
      'name': 'Virgin Islands',
      'postal': 'VI',
      'type': ''},
 '1': {'ap': 'Ala.',
       'fips': '1',
       'name': 'Alabama',
       'postal': 'AL',
       'type': 'state'},
 '10': {'ap': 'Del.',
        'fips': '10',
        'name': 'Delaware',
        'postal': 'DE',
        'type': 'state'},
 '11': {'ap': 'D.C.',
        'fips': '11',
        'name': 'District of Columbia',
        'postal': 'DC',
        'type': ''},
 '12': {'ap': 'Fla.',
        'fips': '12',
        'name': 'Florida',
        'postal': 'FL',
        'type': 'state'},
 '13': {'ap': 'Ga.',
        'fips': '13',
        'name': 'Georgia',
        'postal': 'GA',
        'type': 'state'},
 '15': {'ap': 'Hawaii',
        'fips': '15',
        'name': 'Hawaii',
        'postal': 'HI',
        'type': 'state'},
 '16': {'ap': 'Idaho',
        'fips': '16',
        'name': 'Idaho',
        'postal': 'ID',
        'type': 'state'},
 '17': {'ap': 'Ill.',
        'fips': '17',
        'name': 'Illinois',
        'postal': 'IL',
        'type': 'state'},
 '18': {'ap': 'Ind.',
        'fips': '18',
        'name': 'Indiana',
        'postal': 'IN',
        'type': 'state'},
 '19': {'ap': 'Iowa',
        'fips': '19',
        'name': 'Iowa',
        'postal': 'IA',
        'type': 'state'},
 '2': {'ap': 'Alaska',
       'fips': '2',
       'name': 'Alaska',
       'postal': 'AK',
       'type': 'state'},
 '20': {'ap': 'Kan.',
        'fips': '20',
        'name': 'Kansas',
        'postal': 'KS',
        'type': 'state'},
 '21': {'ap': 'Ky.',
        'fips': '21',
        'name': 'Kentucky',
        'postal': 'KY',
        'type': 'state'},
 '22': {'ap': 'La.',
        'fips': '22',
        'name': 'Louisiana',
        'postal': 'LA',
        'type': 'state'},
 '23': {'ap': 'Maine',
        'fips': '23',
        'name': 'Maine',
        'postal': 'ME',
        'type': 'state'},
 '24': {'ap': 'Md.',
        'fips': '24',
        'name': 'Maryland',
        'postal': 'MD',
        'type': 'state'},
 '25': {'ap': 'Mass.',
        'fips': '25',
        'name': 'Massachusetts',
        'postal': 'MA',
        'type': 'state'},
 '26': {'ap': 'Mich.',
        'fips': '26',
        'name': 'Michigan',
        'postal': 'MI',
        'type': 'state'},
 '27': {'ap': 'Minn.',
        'fips': '27',
        'name': 'Minnesota',
        'postal': 'MN',
        'type': 'state'},
 '28': {'ap': 'Miss.',
        'fips': '28',
        'name': 'Mississippi',
        'postal': 'MS',
        'type': 'state'},
 '29': {'ap': 'Mo.',
        'fips': '29',
        'name': 'Missouri',
        'postal': 'MO',
        'type': 'state'},
 '30': {'ap': 'Mont.',
        'fips': '30',
        'name': 'Montana',
        'postal': 'MT',
        'type': 'state'},
 '31': {'ap': 'Neb.',
        'fips': '31',
        'name': 'Nebraska',
        'postal': 'NE',
        'type': 'state'},
 '32': {'ap': 'Nev.',
        'fips': '32',
        'name': 'Nevada',
        'postal': 'NV',
        'type': 'state'},
 '33': {'ap': 'N.H.',
        'fips': '33',
        'name': 'New Hampshire',
        'postal': 'NH',
        'type': 'state'},
 '34': {'ap': 'N.J.',
        'fips': '34',
        'name': 'New Jersey',
        'postal': 'NJ',
        'type': 'state'},
 '35': {'ap': 'N.M.',
        'fips': '35',
        'name': 'New Mexico',
        'postal': 'NM',
        'type': 'state'},
 '36': {'ap': 'N.Y.',
        'fips': '36',
        'name': 'New York',
        'postal': 'NY',
        'type': 'state'},
 '37': {'ap': 'N.C.',
        'fips': '37',
        'name': 'North Carolina',
        'postal': 'NC',
        'type': 'state'},
 '38': {'ap': 'N.D.',
        'fips': '38',
        'name': 'North Dakota',
        'postal': 'ND',
        'type': 'state'},
 '39': {'ap': 'Ohio',
        'fips': '39',
        'name': 'Ohio',
        'postal': 'OH',
        'type': 'state'},
 '4': {'ap': 'Ariz.',
       'fips': '4',
       'name': 'Arizona',
       'postal': 'AZ',
       'type': 'state'},
 '40': {'ap': 'Okla.',
        'fips': '40',
        'name': 'Oklahoma',
        'postal': 'OK',
        'type': 'state'},
 '41': {'ap': 'Ore.',
        'fips': '41',
        'name': 'Oregon',
        'postal': 'OR',
        'type': 'state'},
 '42': {'ap': 'Pa.',
        'fips': '42',
        'name': 'Pennsylvania',
        'postal': 'PA',
        'type': 'state'},
 '44': {'ap': 'R.I.',
        'fips': '44',
        'name': 'Rhode Island',
        'postal': 'RI',
        'type': 'state'},
 '45': {'ap': 'S.C.',
        'fips': '45',
        'name': 'South Carolina',
        'postal': 'SC',
        'type': 'state'},
 '46': {'ap': 'S.D.',
        'fips': '46',
        'name': 'South Dakota',
        'postal': 'SD',
        'type': 'state'},
 '47': {'ap': 'Tenn.',
        'fips': '47',
        'name': 'Tennessee',
        'postal': 'TN',
        'type': 'state'},
 '48': {'ap': 'Texas',
        'fips': '48',
        'name': 'Texas',
        'postal': 'TX',
        'type': 'state'},
 '49': {'ap': 'Utah',
        'fips': '49',
        'name': 'Utah',
        'postal': 'UT',
        'type': 'state'},
 '5': {'ap': 'Ark.',
       'fips': '5',
       'name': 'Arkansas',
       'postal': 'AR',
       'type': 'state'},
 '50': {'ap': 'Vt.',
        'fips': '50',
        'name': 'Vermont',
        'postal': 'VT',
        'type': 'state'},
 '51': {'ap': 'Va.',
        'fips': '51',
        'name': 'Virginia',
        'postal': 'VA',
        'type': 'state'},
 '53': {'ap': 'Wash.',
        'fips': '53',
        'name': 'Washington',
        'postal': 'WA',
        'type': 'state'},
 '54': {'ap': 'W.Va.',
        'fips': '54',
        'name': 'West Virginia',
        'postal': 'WV',
        'type': 'state'},
 '55': {'ap': 'Wis.',
        'fips': '55',
        'name': 'Wisconsin',
        'postal': 'WI',
        'type': 'state'},
 '56': {'ap': 'Wyo.',
        'fips': '56',
        'name': 'Wyoming',
        'postal': 'WY',
        'type': 'state'},
 '6': {'ap': 'Calif.',
       'fips': '6',
       'name': 'California',
       'postal': 'CA',
       'type': 'state'},
 '60': {'ap': '',
        'fips': '60',
        'name': 'American Samoa',
        'postal': 'AS',
        'type': ''},
 '64': {'ap': '',
        'fips': '64',
        'name': 'Federated States of Micronesia',
        'postal': 'FM',
        'type': ''},
 '66': {'ap': '', 'fips': '66', 'name': 'Guam', 'postal': 'GU', 'type': ''},
 '68': {'ap': '',
        'fips': '68',
        'name': 'Marshall Islands',
        'postal': 'MH',
        'type': ''},
 '69': {'ap': '',
        'fips': '69',
        'name': 'Northern Mariana Islands',
        'postal': 'MP',
        'type': ''},
 '70': {'ap': '', 'fips': '70', 'name': 'Palau', 'postal': 'PW', 'type': ''},
 '72': {'ap': '',
        'fips': '72',
        'name': 'Puerto Rico',
        'postal': 'PR',
        'type': ''},
 '78': {'ap': '',
        'fips': '78',
        'name': 'Virgin Islands',
        'postal': 'VI',
        'type': ''},
 '8': {'ap': 'Colo.',
       'fips': '8',
       'name': 'Colorado',
       'postal': 'CO',
       'type': 'state'},
 '9': {'ap': 'Conn.',
       'fips': '9',
       'name': 'Connecticut',
       'postal': 'CT',
       'type': 'state'},
 'AK': {'ap': 'Alaska',
        'fips': '2',
        'name': 'Alaska',
        'postal': 'AK',
        'type': 'state'},
 'AL': {'ap': 'Ala.',
        'fips': '1',
        'name': 'Alabama',
        'postal': 'AL',
        'type': 'state'},
 'AR': {'ap': 'Ark.',
        'fips': '5',
        'name': 'Arkansas',
        'postal': 'AR',
        'type': 'state'},
 'AS': {'ap': '',
        'fips': '60',
        'name': 'American Samoa',
        'postal': 'AS',
        'type': ''},
 'AZ': {'ap': 'Ariz.',
        'fips': '4',
        'name': 'Arizona',
        'postal': 'AZ',
        'type': 'state'},
 'Ala.': {'ap': 'Ala.',
          'fips': '1',
          'name': 'Alabama',
          'postal': 'AL',
          'type': 'state'},
 'Alabama': {'ap': 'Ala.',
             'fips': '1',
             'name': 'Alabama',
             'postal': 'AL',
             'type': 'state'},
 'Alaska': {'ap': 'Alaska',
            'fips': '2',
            'name': 'Alaska',
            'postal': 'AK',
            'type': 'state'},
 'American Samoa': {'ap': '',
                    'fips': '60',
                    'name': 'American Samoa',
                    'postal': 'AS',
                    'type': ''},
 'Ariz.': {'ap': 'Ariz.',
           'fips': '4',
           'name': 'Arizona',
           'postal': 'AZ',
           'type': 'state'},
 'Arizona': {'ap': 'Ariz.',
             'fips': '4',
             'name': 'Arizona',
             'postal': 'AZ',
             'type': 'state'},
 'Ark.': {'ap': 'Ark.',
          'fips': '5',
          'name': 'Arkansas',
          'postal': 'AR',
          'type': 'state'},
 'Arkansas': {'ap': 'Ark.',
              'fips': '5',
              'name': 'Arkansas',
              'postal': 'AR',
              'type': 'state'},
 'CA': {'ap': 'Calif.',
        'fips': '6',
        'name': 'California',
        'postal': 'CA',
        'type': 'state'},
 'CO': {'ap': 'Colo.',
        'fips': '8',
        'name': 'Colorado',
        'postal': 'CO',
        'type': 'state'},
 'CT': {'ap': 'Conn.',
        'fips': '9',
        'name': 'Connecticut',
        'postal': 'CT',
        'type': 'state'},
 'Calif.': {'ap': 'Calif.',
            'fips': '6',
            'name': 'California',
            'postal': 'CA',
            'type': 'state'},
 'California': {'ap': 'Calif.',
                'fips': '6',
                'name': 'California',
                'postal': 'CA',
                'type': 'state'},
 'Colo.': {'ap': 'Colo.',
           'fips': '8',
           'name': 'Colorado',
           'postal': 'CO',
           'type': 'state'},
 'Colorado': {'ap': 'Colo.',
              'fips': '8',
              'name': 'Colorado',
              'postal': 'CO',
              'type': 'state'},
 'Conn.': {'ap': 'Conn.',
           'fips': '9',
           'name': 'Connecticut',
           'postal': 'CT',
           'type': 'state'},
 'Connecticut': {'ap': 'Conn.',
                 'fips': '9',
                 'name': 'Connecticut',
                 'postal': 'CT',
                 'type': 'state'},
 'D.C.': {'ap': 'D.C.',
          'fips': '11',
          'name': 'District of Columbia',
          'postal': 'DC',
          'type': ''},
 'DC': {'ap': 'D.C.',
        'fips': '11',
        'name': 'District of Columbia',
        'postal': 'DC',
        'type': ''},
 'DE': {'ap': 'Del.',
        'fips': '10',
        'name': 'Delaware',
        'postal': 'DE',
        'type': 'state'},
 'Del.': {'ap': 'Del.',
          'fips': '10',
          'name': 'Delaware',
          'postal': 'DE',
          'type': 'state'},
 'Delaware': {'ap': 'Del.',
              'fips': '10',
              'name': 'Delaware',
              'postal': 'DE',
              'type': 'state'},
 'District of Columbia': {'ap': 'D.C.',
                          'fips': '11',
                          'name': 'District of Columbia',
                          'postal': 'DC',
                          'type': ''},
 'FL': {'ap': 'Fla.',
        'fips': '12',
        'name': 'Florida',
        'postal': 'FL',
        'type': 'state'},
 'FM': {'ap': '',
        'fips': '64',
        'name': 'Federated States of Micronesia',
        'postal': 'FM',
        'type': ''},
 'Federated States of Micronesia': {'ap': '',
                                    'fips': '64',
                                    'name': 'Federated States of Micronesia',
                                    'postal': 'FM',
                                    'type': ''},
 'Fla.': {'ap': 'Fla.',
          'fips': '12',
          'name': 'Florida',
          'postal': 'FL',
          'type': 'state'},
 'Florida': {'ap': 'Fla.',
             'fips': '12',
             'name': 'Florida',
             'postal': 'FL',
             'type': 'state'},
 'GA': {'ap': 'Ga.',
        'fips': '13',
        'name': 'Georgia',
        'postal': 'GA',
        'type': 'state'},
 'GU': {'ap': '', 'fips': '66', 'name': 'Guam', 'postal': 'GU', 'type': ''},
 'Ga.': {'ap': 'Ga.',
         'fips': '13',
         'name': 'Georgia',
         'postal': 'GA',
         'type': 'state'},
 'Georgia': {'ap': 'Ga.',
             'fips': '13',
             'name': 'Georgia',
             'postal': 'GA',
             'type': 'state'},
 'Guam': {'ap': '', 'fips': '66', 'name': 'Guam', 'postal': 'GU', 'type': ''},
 'HI': {'ap': 'Hawaii',
        'fips': '15',
        'name': 'Hawaii',
        'postal': 'HI',
        'type': 'state'},
 'Hawaii': {'ap': 'Hawaii',
            'fips': '15',
            'name': 'Hawaii',
            'postal': 'HI',
            'type': 'state'},
 'IA': {'ap': 'Iowa',
        'fips': '19',
        'name': 'Iowa',
        'postal': 'IA',
        'type': 'state'},
 'ID': {'ap': 'Idaho',
        'fips': '16',
        'name': 'Idaho',
        'postal': 'ID',
        'type': 'state'},
 'IL': {'ap': 'Ill.',
        'fips': '17',
        'name': 'Illinois',
        'postal': 'IL',
        'type': 'state'},
 'IN': {'ap': 'Ind.',
        'fips': '18',
        'name': 'Indiana',
        'postal': 'IN',
        'type': 'state'},
 'Idaho': {'ap': 'Idaho',
           'fips': '16',
           'name': 'Idaho',
           'postal': 'ID',
           'type': 'state'},
 'Ill.': {'ap': 'Ill.',
          'fips': '17',
          'name': 'Illinois',
          'postal': 'IL',
          'type': 'state'},
 'Illinois': {'ap': 'Ill.',
              'fips': '17',
              'name': 'Illinois',
              'postal': 'IL',
              'type': 'state'},
 'Ind.': {'ap': 'Ind.',
          'fips': '18',
          'name': 'Indiana',
          'postal': 'IN',
          'type': 'state'},
 'Indiana': {'ap': 'Ind.',
             'fips': '18',
             'name': 'Indiana',
             'postal': 'IN',
             'type': 'state'},
 'Iowa': {'ap': 'Iowa',
          'fips': '19',
          'name': 'Iowa',
          'postal': 'IA',
          'type': 'state'},
 'KS': {'ap': 'Kan.',
        'fips': '20',
        'name': 'Kansas',
        'postal': 'KS',
        'type': 'state'},
 'KY': {'ap': 'Ky.',
        'fips': '21',
        'name': 'Kentucky',
        'postal': 'KY',
        'type': 'state'},
 'Kan.': {'ap': 'Kan.',
          'fips': '20',
          'name': 'Kansas',
          'postal': 'KS',
          'type': 'state'},
 'Kansas': {'ap': 'Kan.',
            'fips': '20',
            'name': 'Kansas',
            'postal': 'KS',
            'type': 'state'},
 'Kentucky': {'ap': 'Ky.',
              'fips': '21',
              'name': 'Kentucky',
              'postal': 'KY',
              'type': 'state'},
 'Ky.': {'ap': 'Ky.',
         'fips': '21',
         'name': 'Kentucky',
         'postal': 'KY',
         'type': 'state'},
 'LA': {'ap': 'La.',
        'fips': '22',
        'name': 'Louisiana',
        'postal': 'LA',
        'type': 'state'},
 'La.': {'ap': 'La.',
         'fips': '22',
         'name': 'Louisiana',
         'postal': 'LA',
         'type': 'state'},
 'Louisiana': {'ap': 'La.',
               'fips': '22',
               'name': 'Louisiana',
               'postal': 'LA',
               'type': 'state'},
 'MA': {'ap': 'Mass.',
        'fips': '25',
        'name': 'Massachusetts',
        'postal': 'MA',
        'type': 'state'},
 'MD': {'ap': 'Md.',
        'fips': '24',
        'name': 'Maryland',
        'postal': 'MD',
        'type': 'state'},
 'ME': {'ap': 'Maine',
        'fips': '23',
        'name': 'Maine',
        'postal': 'ME',
        'type': 'state'},
 'MH': {'ap': '',
        'fips': '68',
        'name': 'Marshall Islands',
        'postal': 'MH',
        'type': ''},
 'MI': {'ap': 'Mich.',
        'fips': '26',
        'name': 'Michigan',
        'postal': 'MI',
        'type': 'state'},
 'MN': {'ap': 'Minn.',
        'fips': '27',
        'name': 'Minnesota',
        'postal': 'MN',
        'type': 'state'},
 'MO': {'ap': 'Mo.',
        'fips': '29',
        'name': 'Missouri',
        'postal': 'MO',
        'type': 'state'},
 'MP': {'ap': '',
        'fips': '69',
        'name': 'Northern Mariana Islands',
        'postal': 'MP',
        'type': ''},
 'MS': {'ap': 'Miss.',
        'fips': '28',
        'name': 'Mississippi',
        'postal': 'MS',
        'type': 'state'},
 'MT': {'ap': 'Mont.',
        'fips': '30',
        'name': 'Montana',
        'postal': 'MT',
        'type': 'state'},
 'Maine': {'ap': 'Maine',
           'fips': '23',
           'name': 'Maine',
           'postal': 'ME',
           'type': 'state'},
 'Marshall Islands': {'ap': '',
                      'fips': '68',
                      'name': 'Marshall Islands',
                      'postal': 'MH',
                      'type': ''},
 'Maryland': {'ap': 'Md.',
              'fips': '24',
              'name': 'Maryland',
              'postal': 'MD',
              'type': 'state'},
 'Mass.': {'ap': 'Mass.',
           'fips': '25',
           'name': 'Massachusetts',
           'postal': 'MA',
           'type': 'state'},
 'Massachusetts': {'ap': 'Mass.',
                   'fips': '25',
                   'name': 'Massachusetts',
                   'postal': 'MA',
                   'type': 'state'},
 'Md.': {'ap': 'Md.',
         'fips': '24',
         'name': 'Maryland',
         'postal': 'MD',
         'type': 'state'},
 'Mich.': {'ap': 'Mich.',
           'fips': '26',
           'name': 'Michigan',
           'postal': 'MI',
           'type': 'state'},
 'Michigan': {'ap': 'Mich.',
              'fips': '26',
              'name': 'Michigan',
              'postal': 'MI',
              'type': 'state'},
 'Minn.': {'ap': 'Minn.',
           'fips': '27',
           'name': 'Minnesota',
           'postal': 'MN',
           'type': 'state'},
 'Minnesota': {'ap': 'Minn.',
               'fips': '27',
               'name': 'Minnesota',
               'postal': 'MN',
               'type': 'state'},
 'Miss.': {'ap': 'Miss.',
           'fips': '28',
           'name': 'Mississippi',
           'postal': 'MS',
           'type': 'state'},
 'Mississippi': {'ap': 'Miss.',
                 'fips': '28',
                 'name': 'Mississippi',
                 'postal': 'MS',
                 'type': 'state'},
 'Missouri': {'ap': 'Mo.',
              'fips': '29',
              'name': 'Missouri',
              'postal': 'MO',
              'type': 'state'},
 'Mo.': {'ap': 'Mo.',
         'fips': '29',
         'name': 'Missouri',
         'postal': 'MO',
         'type': 'state'},
 'Mont.': {'ap': 'Mont.',
           'fips': '30',
           'name': 'Montana',
           'postal': 'MT',
           'type': 'state'},
 'Montana': {'ap': 'Mont.',
             'fips': '30',
             'name': 'Montana',
             'postal': 'MT',
             'type': 'state'},
 'N.C.': {'ap': 'N.C.',
          'fips': '37',
          'name': 'North Carolina',
          'postal': 'NC',
          'type': 'state'},
 'N.D.': {'ap': 'N.D.',
          'fips': '38',
          'name': 'North Dakota',
          'postal': 'ND',
          'type': 'state'},
 'N.H.': {'ap': 'N.H.',
          'fips': '33',
          'name': 'New Hampshire',
          'postal': 'NH',
          'type': 'state'},
 'N.J.': {'ap': 'N.J.',
          'fips': '34',
          'name': 'New Jersey',
          'postal': 'NJ',
          'type': 'state'},
 'N.M.': {'ap': 'N.M.',
          'fips': '35',
          'name': 'New Mexico',
          'postal': 'NM',
          'type': 'state'},
 'N.Y.': {'ap': 'N.Y.',
          'fips': '36',
          'name': 'New York',
          'postal': 'NY',
          'type': 'state'},
 'NC': {'ap': 'N.C.',
        'fips': '37',
        'name': 'North Carolina',
        'postal': 'NC',
        'type': 'state'},
 'ND': {'ap': 'N.D.',
        'fips': '38',
        'name': 'North Dakota',
        'postal': 'ND',
        'type': 'state'},
 'NE': {'ap': 'Neb.',
        'fips': '31',
        'name': 'Nebraska',
        'postal': 'NE',
        'type': 'state'},
 'NH': {'ap': 'N.H.',
        'fips': '33',
        'name': 'New Hampshire',
        'postal': 'NH',
        'type': 'state'},
 'NJ': {'ap': 'N.J.',
        'fips': '34',
        'name': 'New Jersey',
        'postal': 'NJ',
        'type': 'state'},
 'NM': {'ap': 'N.M.',
        'fips': '35',
        'name': 'New Mexico',
        'postal': 'NM',
        'type': 'state'},
 'NV': {'ap': 'Nev.',
        'fips': '32',
        'name': 'Nevada',
        'postal': 'NV',
        'type': 'state'},
 'NY': {'ap': 'N.Y.',
        'fips': '36',
        'name': 'New York',
        'postal': 'NY',
        'type': 'state'},
 'Neb.': {'ap': 'Neb.',
          'fips': '31',
          'name': 'Nebraska',
          'postal': 'NE',
          'type': 'state'},
 'Nebraska': {'ap': 'Neb.',
              'fips': '31',
              'name': 'Nebraska',
              'postal': 'NE',
              'type': 'state'},
 'Nev.': {'ap': 'Nev.',
          'fips': '32',
          'name': 'Nevada',
          'postal': 'NV',
          'type': 'state'},
 'Nevada': {'ap': 'Nev.',
            'fips': '32',
            'name': 'Nevada',
            'postal': 'NV',
            'type': 'state'},
 'New Hampshire': {'ap': 'N.H.',
                   'fips': '33',
                   'name': 'New Hampshire',
                   'postal': 'NH',
                   'type': 'state'},
 'New Jersey': {'ap': 'N.J.',
                'fips': '34',
                'name': 'New Jersey',
                'postal': 'NJ',
                'type': 'state'},
 'New Mexico': {'ap': 'N.M.',
                'fips': '35',
                'name': 'New Mexico',
                'postal': 'NM',
                'type': 'state'},
 'New York': {'ap': 'N.Y.',
              'fips': '36',
              'name': 'New York',
              'postal': 'NY',
              'type': 'state'},
 'North Carolina': {'ap': 'N.C.',
                    'fips': '37',
                    'name': 'North Carolina',
                    'postal': 'NC',
                    'type': 'state'},
 'North Dakota': {'ap': 'N.D.',
                  'fips': '38',
                  'name': 'North Dakota',
                  'postal': 'ND',
                  'type': 'state'},
 'Northern Mariana Islands': {'ap': '',
                              'fips': '69',
                              'name': 'Northern Mariana Islands',
                              'postal': 'MP',
                              'type': ''},
 'OH': {'ap': 'Ohio',
        'fips': '39',
        'name': 'Ohio',
        'postal': 'OH',
        'type': 'state'},
 'OK': {'ap': 'Okla.',
        'fips': '40',
        'name': 'Oklahoma',
        'postal': 'OK',
        'type': 'state'},
 'OR': {'ap': 'Ore.',
        'fips': '41',
        'name': 'Oregon',
        'postal': 'OR',
        'type': 'state'},
 'Ohio': {'ap': 'Ohio',
          'fips': '39',
          'name': 'Ohio',
          'postal': 'OH',
          'type': 'state'},
 'Okla.': {'ap': 'Okla.',
           'fips': '40',
           'name': 'Oklahoma',
           'postal': 'OK',
           'type': 'state'},
 'Oklahoma': {'ap': 'Okla.',
              'fips': '40',
              'name': 'Oklahoma',
              'postal': 'OK',
              'type': 'state'},
 'Ore.': {'ap': 'Ore.',
          'fips': '41',
          'name': 'Oregon',
          'postal': 'OR',
          'type': 'state'},
 'Oregon': {'ap': 'Ore.',
            'fips': '41',
            'name': 'Oregon',
            'postal': 'OR',
            'type': 'state'},
 'PA': {'ap': 'Pa.',
        'fips': '42',
        'name': 'Pennsylvania',
        'postal': 'PA',
        'type': 'state'},
 'PR': {'ap': '',
        'fips': '72',
        'name': 'Puerto Rico',
        'postal': 'PR',
        'type': ''},
 'PW': {'ap': '', 'fips': '70', 'name': 'Palau', 'postal': 'PW', 'type': ''},
 'Pa.': {'ap': 'Pa.',
         'fips': '42',
         'name': 'Pennsylvania',
         'postal': 'PA',
         'type': 'state'},
 'Palau': {'ap': '',
           'fips': '70',
           'name': 'Palau',
           'postal': 'PW',
           'type': ''},
 'Pennsylvania': {'ap': 'Pa.',
                  'fips': '42',
                  'name': 'Pennsylvania',
                  'postal': 'PA',
                  'type': 'state'},
 'Puerto Rico': {'ap': '',
                 'fips': '72',
                 'name': 'Puerto Rico',
                 'postal': 'PR',
                 'type': ''},
 'R.I.': {'ap': 'R.I.',
          'fips': '44',
          'name': 'Rhode Island',
          'postal': 'RI',
          'type': 'state'},
 'RI': {'ap': 'R.I.',
        'fips': '44',
        'name': 'Rhode Island',
        'postal': 'RI',
        'type': 'state'},
 'Rhode Island': {'ap': 'R.I.',
                  'fips': '44',
                  'name': 'Rhode Island',
                  'postal': 'RI',
                  'type': 'state'},
 'S.C.': {'ap': 'S.C.',
          'fips': '45',
          'name': 'South Carolina',
          'postal': 'SC',
          'type': 'state'},
 'S.D.': {'ap': 'S.D.',
          'fips': '46',
          'name': 'South Dakota',
          'postal': 'SD',
          'type': 'state'},
 'SC': {'ap': 'S.C.',
        'fips': '45',
        'name': 'South Carolina',
        'postal': 'SC',
        'type': 'state'},
 'SD': {'ap': 'S.D.',
        'fips': '46',
        'name': 'South Dakota',
        'postal': 'SD',
        'type': 'state'},
 'South Carolina': {'ap': 'S.C.',
                    'fips': '45',
                    'name': 'South Carolina',
                    'postal': 'SC',
                    'type': 'state'},
 'South Dakota': {'ap': 'S.D.',
                  'fips': '46',
                  'name': 'South Dakota',
                  'postal': 'SD',
                  'type': 'state'},
 'TN': {'ap': 'Tenn.',
        'fips': '47',
        'name': 'Tennessee',
        'postal': 'TN',
        'type': 'state'},
 'TX': {'ap': 'Texas',
        'fips': '48',
        'name': 'Texas',
        'postal': 'TX',
        'type': 'state'},
 'Tenn.': {'ap': 'Tenn.',
           'fips': '47',
           'name': 'Tennessee',
           'postal': 'TN',
           'type': 'state'},
 'Tennessee': {'ap': 'Tenn.',
               'fips': '47',
               'name': 'Tennessee',
               'postal': 'TN',
               'type': 'state'},
 'Texas': {'ap': 'Texas',
           'fips': '48',
           'name': 'Texas',
           'postal': 'TX',
           'type': 'state'},
 'UT': {'ap': 'Utah',
        'fips': '49',
        'name': 'Utah',
        'postal': 'UT',
        'type': 'state'},
 'Utah': {'ap': 'Utah',
          'fips': '49',
          'name': 'Utah',
          'postal': 'UT',
          'type': 'state'},
 'VA': {'ap': 'Va.',
        'fips': '51',
        'name': 'Virginia',
        'postal': 'VA',
        'type': 'state'},
 'VI': {'ap': '',
        'fips': '78',
        'name': 'Virgin Islands',
        'postal': 'VI',
        'type': ''},
 'VT': {'ap': 'Vt.',
        'fips': '50',
        'name': 'Vermont',
        'postal': 'VT',
        'type': 'state'},
 'Va.': {'ap': 'Va.',
         'fips': '51',
         'name': 'Virginia',
         'postal': 'VA',
         'type': 'state'},
 'Vermont': {'ap': 'Vt.',
             'fips': '50',
             'name': 'Vermont',
             'postal': 'VT',
             'type': 'state'},
 'Virgin Islands': {'ap': '',
                    'fips': '78',
                    'name': 'Virgin Islands',
                    'postal': 'VI',
                    'type': ''},
 'Virginia': {'ap': 'Va.',
              'fips': '51',
              'name': 'Virginia',
              'postal': 'VA',
              'type': 'state'},
 'Vt.': {'ap': 'Vt.',
         'fips': '50',
         'name': 'Vermont',
         'postal': 'VT',
         'type': 'state'},
 'W.Va.': {'ap': 'W.Va.',
           'fips': '54',
           'name': 'West Virginia',
           'postal': 'WV',
           'type': 'state'},
 'WA': {'ap': 'Wash.',
        'fips': '53',
        'name': 'Washington',
        'postal': 'WA',
        'type': 'state'},
 'WI': {'ap': 'Wis.',
        'fips': '55',
        'name': 'Wisconsin',
        'postal': 'WI',
        'type': 'state'},
 'WV': {'ap': 'W.Va.',
        'fips': '54',
        'name': 'West Virginia',
        'postal': 'WV',
        'type': 'state'},
 'WY': {'ap': 'Wyo.',
        'fips': '56',
        'name': 'Wyoming',
        'postal': 'WY',
        'type': 'state'},
 'Wash.': {'ap': 'Wash.',
           'fips': '53',
           'name': 'Washington',
           'postal': 'WA',
           'type': 'state'},
 'Washington': {'ap': 'Wash.',
                'fips': '53',
                'name': 'Washington',
                'postal': 'WA',
                'type': 'state'},
 'West Virginia': {'ap': 'W.Va.',
                   'fips': '54',
                   'name': 'West Virginia',
                   'postal': 'WV',
                   'type': 'state'},
 'Wis.': {'ap': 'Wis.',
          'fips': '55',
          'name': 'Wisconsin',
          'postal': 'WI',
          'type': 'state'},
 'Wisconsin': {'ap': 'Wis.',
               'fips': '55',
               'name': 'Wisconsin',
               'postal': 'WI',
               'type': 'state'},
 'Wyo.': {'ap': 'Wyo.',
          'fips': '56',
          'name': 'Wyoming',
          'postal': 'WY',
          'type': 'state'},
 'Wyoming': {'ap': 'Wyo.',
             'fips': '56',
             'name': 'Wyoming',
             'postal': 'WY',
             'type': 'state'},
 'ak': {'ap': 'Alaska',
        'fips': '2',
        'name': 'Alaska',
        'postal': 'AK',
        'type': 'state'},
 'al': {'ap': 'Ala.',
        'fips': '1',
        'name': 'Alabama',
        'postal': 'AL',
        'type': 'state'},
 'ala.': {'ap': 'Ala.',
          'fips': '1',
          'name': 'Alabama',
          'postal': 'AL',
          'type': 'state'},
 'alabama': {'ap': 'Ala.',
             'fips': '1',
             'name': 'Alabama',
             'postal': 'AL',
             'type': 'state'},
 'alaska': {'ap': 'Alaska',
            'fips': '2',
            'name': 'Alaska',
            'postal': 'AK',
            'type': 'state'},
 'american samoa': {'ap': '',
                    'fips': '60',
                    'name': 'American Samoa',
                    'postal': 'AS',
                    'type': ''},
 'ar': {'ap': 'Ark.',
        'fips': '5',
        'name': 'Arkansas',
        'postal': 'AR',
        'type': 'state'},
 'ariz.': {'ap': 'Ariz.',
           'fips': '4',
           'name': 'Arizona',
           'postal': 'AZ',
           'type': 'state'},
 'arizona': {'ap': 'Ariz.',
             'fips': '4',
             'name': 'Arizona',
             'postal': 'AZ',
             'type': 'state'},
 'ark.': {'ap': 'Ark.',
          'fips': '5',
          'name': 'Arkansas',
          'postal': 'AR',
          'type': 'state'},
 'arkansas': {'ap': 'Ark.',
              'fips': '5',
              'name': 'Arkansas',
              'postal': 'AR',
              'type': 'state'},
 'as': {'ap': '',
        'fips': '60',
        'name': 'American Samoa',
        'postal': 'AS',
        'type': ''},
 'az': {'ap': 'Ariz.',
        'fips': '4',
        'name': 'Arizona',
        'postal': 'AZ',
        'type': 'state'},
 'ca': {'ap': 'Calif.',
        'fips': '6',
        'name': 'California',
        'postal': 'CA',
        'type': 'state'},
 'calif.': {'ap': 'Calif.',
            'fips': '6',
            'name': 'California',
            'postal': 'CA',
            'type': 'state'},
 'california': {'ap': 'Calif.',
                'fips': '6',
                'name': 'California',
                'postal': 'CA',
                'type': 'state'},
 'co': {'ap': 'Colo.',
        'fips': '8',
        'name': 'Colorado',
        'postal': 'CO',
        'type': 'state'},
 'colo.': {'ap': 'Colo.',
           'fips': '8',
           'name': 'Colorado',
           'postal': 'CO',
           'type': 'state'},
 'colorado': {'ap': 'Colo.',
              'fips': '8',
              'name': 'Colorado',
              'postal': 'CO',
              'type': 'state'},
 'conn.': {'ap': 'Conn.',
           'fips': '9',
           'name': 'Connecticut',
           'postal': 'CT',
           'type': 'state'},
 'connecticut': {'ap': 'Conn.',
                 'fips': '9',
                 'name': 'Connecticut',
                 'postal': 'CT',
                 'type': 'state'},
 'ct': {'ap': 'Conn.',
        'fips': '9',
        'name': 'Connecticut',
        'postal': 'CT',
        'type': 'state'},
 'd.c.': {'ap': 'D.C.',
          'fips': '11',
          'name': 'District of Columbia',
          'postal': 'DC',
          'type': ''},
 'dc': {'ap': 'D.C.',
        'fips': '11',
        'name': 'District of Columbia',
        'postal': 'DC',
        'type': ''},
 'de': {'ap': 'Del.',
        'fips': '10',
        'name': 'Delaware',
        'postal': 'DE',
        'type': 'state'},
 'del.': {'ap': 'Del.',
          'fips': '10',
          'name': 'Delaware',
          'postal': 'DE',
          'type': 'state'},
 'delaware': {'ap': 'Del.',
              'fips': '10',
              'name': 'Delaware',
              'postal': 'DE',
              'type': 'state'},
 'district of columbia': {'ap': 'D.C.',
                          'fips': '11',
                          'name': 'District of Columbia',
                          'postal': 'DC',
                          'type': ''},
 'federated states of micronesia': {'ap': '',
                                    'fips': '64',
                                    'name': 'Federated States of Micronesia',
                                    'postal': 'FM',
                                    'type': ''},
 'fl': {'ap': 'Fla.',
        'fips': '12',
        'name': 'Florida',
        'postal': 'FL',
        'type': 'state'},
 'fla.': {'ap': 'Fla.',
          'fips': '12',
          'name': 'Florida',
          'postal': 'FL',
          'type': 'state'},
 'florida': {'ap': 'Fla.',
             'fips': '12',
             'name': 'Florida',
             'postal': 'FL',
             'type': 'state'},
 'fm': {'ap': '',
        'fips': '64',
        'name': 'Federated States of Micronesia',
        'postal': 'FM',
        'type': ''},
 'ga': {'ap': 'Ga.',
        'fips': '13',
        'name': 'Georgia',
        'postal': 'GA',
        'type': 'state'},
 'ga.': {'ap': 'Ga.',
         'fips': '13',
         'name': 'Georgia',
         'postal': 'GA',
         'type': 'state'},
 'georgia': {'ap': 'Ga.',
             'fips': '13',
             'name': 'Georgia',
             'postal': 'GA',
             'type': 'state'},
 'gu': {'ap': '', 'fips': '66', 'name': 'Guam', 'postal': 'GU', 'type': ''},
 'guam': {'ap': '', 'fips': '66', 'name': 'Guam', 'postal': 'GU', 'type': ''},
 'hawaii': {'ap': 'Hawaii',
            'fips': '15',
            'name': 'Hawaii',
            'postal': 'HI',
            'type': 'state'},
 'hi': {'ap': 'Hawaii',
        'fips': '15',
        'name': 'Hawaii',
        'postal': 'HI',
        'type': 'state'},
 'ia': {'ap': 'Iowa',
        'fips': '19',
        'name': 'Iowa',
        'postal': 'IA',
        'type': 'state'},
 'id': {'ap': 'Idaho',
        'fips': '16',
        'name': 'Idaho',
        'postal': 'ID',
        'type': 'state'},
 'idaho': {'ap': 'Idaho',
           'fips': '16',
           'name': 'Idaho',
           'postal': 'ID',
           'type': 'state'},
 'il': {'ap': 'Ill.',
        'fips': '17',
        'name': 'Illinois',
        'postal': 'IL',
        'type': 'state'},
 'ill.': {'ap': 'Ill.',
          'fips': '17',
          'name': 'Illinois',
          'postal': 'IL',
          'type': 'state'},
 'illinois': {'ap': 'Ill.',
              'fips': '17',
              'name': 'Illinois',
              'postal': 'IL',
              'type': 'state'},
 'in': {'ap': 'Ind.',
        'fips': '18',
        'name': 'Indiana',
        'postal': 'IN',
        'type': 'state'},
 'ind.': {'ap': 'Ind.',
          'fips': '18',
          'name': 'Indiana',
          'postal': 'IN',
          'type': 'state'},
 'indiana': {'ap': 'Ind.',
             'fips': '18',
             'name': 'Indiana',
             'postal': 'IN',
             'type': 'state'},
 'iowa': {'ap': 'Iowa',
          'fips': '19',
          'name': 'Iowa',
          'postal': 'IA',
          'type': 'state'},
 'kan.': {'ap': 'Kan.',
          'fips': '20',
          'name': 'Kansas',
          'postal': 'KS',
          'type': 'state'},
 'kansas': {'ap': 'Kan.',
            'fips': '20',
            'name': 'Kansas',
            'postal': 'KS',
            'type': 'state'},
 'kentucky': {'ap': 'Ky.',
              'fips': '21',
              'name': 'Kentucky',
              'postal': 'KY',
              'type': 'state'},
 'ks': {'ap': 'Kan.',
        'fips': '20',
        'name': 'Kansas',
        'postal': 'KS',
        'type': 'state'},
 'ky': {'ap': 'Ky.',
        'fips': '21',
        'name': 'Kentucky',
        'postal': 'KY',
        'type': 'state'},
 'ky.': {'ap': 'Ky.',
         'fips': '21',
         'name': 'Kentucky',
         'postal': 'KY',
         'type': 'state'},
 'la': {'ap': 'La.',
        'fips': '22',
        'name': 'Louisiana',
        'postal': 'LA',
        'type': 'state'},
 'la.': {'ap': 'La.',
         'fips': '22',
         'name': 'Louisiana',
         'postal': 'LA',
         'type': 'state'},
 'louisiana': {'ap': 'La.',
               'fips': '22',
               'name': 'Louisiana',
               'postal': 'LA',
               'type': 'state'},
 'ma': {'ap': 'Mass.',
        'fips': '25',
        'name': 'Massachusetts',
        'postal': 'MA',
        'type': 'state'},
 'maine': {'ap': 'Maine',
           'fips': '23',
           'name': 'Maine',
           'postal': 'ME',
           'type': 'state'},
 'marshall islands': {'ap': '',
                      'fips': '68',
                      'name': 'Marshall Islands',
                      'postal': 'MH',
                      'type': ''},
 'maryland': {'ap': 'Md.',
              'fips': '24',
              'name': 'Maryland',
              'postal': 'MD',
              'type': 'state'},
 'mass.': {'ap': 'Mass.',
           'fips': '25',
           'name': 'Massachusetts',
           'postal': 'MA',
           'type': 'state'},
 'massachusetts': {'ap': 'Mass.',
                   'fips': '25',
                   'name': 'Massachusetts',
                   'postal': 'MA',
                   'type': 'state'},
 'md': {'ap': 'Md.',
        'fips': '24',
        'name': 'Maryland',
        'postal': 'MD',
        'type': 'state'},
 'md.': {'ap': 'Md.',
         'fips': '24',
         'name': 'Maryland',
         'postal': 'MD',
         'type': 'state'},
 'me': {'ap': 'Maine',
        'fips': '23',
        'name': 'Maine',
        'postal': 'ME',
        'type': 'state'},
 'mh': {'ap': '',
        'fips': '68',
        'name': 'Marshall Islands',
        'postal': 'MH',
        'type': ''},
 'mi': {'ap': 'Mich.',
        'fips': '26',
        'name': 'Michigan',
        'postal': 'MI',
        'type': 'state'},
 'mich.': {'ap': 'Mich.',
           'fips': '26',
           'name': 'Michigan',
           'postal': 'MI',
           'type': 'state'},
 'michigan': {'ap': 'Mich.',
              'fips': '26',
              'name': 'Michigan',
              'postal': 'MI',
              'type': 'state'},
 'minn.': {'ap': 'Minn.',
           'fips': '27',
           'name': 'Minnesota',
           'postal': 'MN',
           'type': 'state'},
 'minnesota': {'ap': 'Minn.',
               'fips': '27',
               'name': 'Minnesota',
               'postal': 'MN',
               'type': 'state'},
 'miss.': {'ap': 'Miss.',
           'fips': '28',
           'name': 'Mississippi',
           'postal': 'MS',
           'type': 'state'},
 'mississippi': {'ap': 'Miss.',
                 'fips': '28',
                 'name': 'Mississippi',
                 'postal': 'MS',
                 'type': 'state'},
 'missouri': {'ap': 'Mo.',
              'fips': '29',
              'name': 'Missouri',
              'postal': 'MO',
              'type': 'state'},
 'mn': {'ap': 'Minn.',
        'fips': '27',
        'name': 'Minnesota',
        'postal': 'MN',
        'type': 'state'},
 'mo': {'ap': 'Mo.',
        'fips': '29',
        'name': 'Missouri',
        'postal': 'MO',
        'type': 'state'},
 'mo.': {'ap': 'Mo.',
         'fips': '29',
         'name': 'Missouri',
         'postal': 'MO',
         'type': 'state'},
 'mont.': {'ap': 'Mont.',
           'fips': '30',
           'name': 'Montana',
           'postal': 'MT',
           'type': 'state'},
 'montana': {'ap': 'Mont.',
             'fips': '30',
             'name': 'Montana',
             'postal': 'MT',
             'type': 'state'},
 'mp': {'ap': '',
        'fips': '69',
        'name': 'Northern Mariana Islands',
        'postal': 'MP',
        'type': ''},
 'ms': {'ap': 'Miss.',
        'fips': '28',
        'name': 'Mississippi',
        'postal': 'MS',
        'type': 'state'},
 'mt': {'ap': 'Mont.',
        'fips': '30',
        'name': 'Montana',
        'postal': 'MT',
        'type': 'state'},
 'n.c.': {'ap': 'N.C.',
          'fips': '37',
          'name': 'North Carolina',
          'postal': 'NC',
          'type': 'state'},
 'n.d.': {'ap': 'N.D.',
          'fips': '38',
          'name': 'North Dakota',
          'postal': 'ND',
          'type': 'state'},
 'n.h.': {'ap': 'N.H.',
          'fips': '33',
          'name': 'New Hampshire',
          'postal': 'NH',
          'type': 'state'},
 'n.j.': {'ap': 'N.J.',
          'fips': '34',
          'name': 'New Jersey',
          'postal': 'NJ',
          'type': 'state'},
 'n.m.': {'ap': 'N.M.',
          'fips': '35',
          'name': 'New Mexico',
          'postal': 'NM',
          'type': 'state'},
 'n.y.': {'ap': 'N.Y.',
          'fips': '36',
          'name': 'New York',
          'postal': 'NY',
          'type': 'state'},
 'nc': {'ap': 'N.C.',
        'fips': '37',
        'name': 'North Carolina',
        'postal': 'NC',
        'type': 'state'},
 'nd': {'ap': 'N.D.',
        'fips': '38',
        'name': 'North Dakota',
        'postal': 'ND',
        'type': 'state'},
 'ne': {'ap': 'Neb.',
        'fips': '31',
        'name': 'Nebraska',
        'postal': 'NE',
        'type': 'state'},
 'neb.': {'ap': 'Neb.',
          'fips': '31',
          'name': 'Nebraska',
          'postal': 'NE',
          'type': 'state'},
 'nebraska': {'ap': 'Neb.',
              'fips': '31',
              'name': 'Nebraska',
              'postal': 'NE',
              'type': 'state'},
 'nev.': {'ap': 'Nev.',
          'fips': '32',
          'name': 'Nevada',
          'postal': 'NV',
          'type': 'state'},
 'nevada': {'ap': 'Nev.',
            'fips': '32',
            'name': 'Nevada',
            'postal': 'NV',
            'type': 'state'},
 'new hampshire': {'ap': 'N.H.',
                   'fips': '33',
                   'name': 'New Hampshire',
                   'postal': 'NH',
                   'type': 'state'},
 'new jersey': {'ap': 'N.J.',
                'fips': '34',
                'name': 'New Jersey',
                'postal': 'NJ',
                'type': 'state'},
 'new mexico': {'ap': 'N.M.',
                'fips': '35',
                'name': 'New Mexico',
                'postal': 'NM',
                'type': 'state'},
 'new york': {'ap': 'N.Y.',
              'fips': '36',
              'name': 'New York',
              'postal': 'NY',
              'type': 'state'},
 'nh': {'ap': 'N.H.',
        'fips': '33',
        'name': 'New Hampshire',
        'postal': 'NH',
        'type': 'state'},
 'nj': {'ap': 'N.J.',
        'fips': '34',
        'name': 'New Jersey',
        'postal': 'NJ',
        'type': 'state'},
 'nm': {'ap': 'N.M.',
        'fips': '35',
        'name': 'New Mexico',
        'postal': 'NM',
        'type': 'state'},
 'north carolina': {'ap': 'N.C.',
                    'fips': '37',
                    'name': 'North Carolina',
                    'postal': 'NC',
                    'type': 'state'},
 'north dakota': {'ap': 'N.D.',
                  'fips': '38',
                  'name': 'North Dakota',
                  'postal': 'ND',
                  'type': 'state'},
 'northern mariana islands': {'ap': '',
                              'fips': '69',
                              'name': 'Northern Mariana Islands',
                              'postal': 'MP',
                              'type': ''},
 'nv': {'ap': 'Nev.',
        'fips': '32',
        'name': 'Nevada',
        'postal': 'NV',
        'type': 'state'},
 'ny': {'ap': 'N.Y.',
        'fips': '36',
        'name': 'New York',
        'postal': 'NY',
        'type': 'state'},
 'oh': {'ap': 'Ohio',
        'fips': '39',
        'name': 'Ohio',
        'postal': 'OH',
        'type': 'state'},
 'ohio': {'ap': 'Ohio',
          'fips': '39',
          'name': 'Ohio',
          'postal': 'OH',
          'type': 'state'},
 'ok': {'ap': 'Okla.',
        'fips': '40',
        'name': 'Oklahoma',
        'postal': 'OK',
        'type': 'state'},
 'okla.': {'ap': 'Okla.',
           'fips': '40',
           'name': 'Oklahoma',
           'postal': 'OK',
           'type': 'state'},
 'oklahoma': {'ap': 'Okla.',
              'fips': '40',
              'name': 'Oklahoma',
              'postal': 'OK',
              'type': 'state'},
 'or': {'ap': 'Ore.',
        'fips': '41',
        'name': 'Oregon',
        'postal': 'OR',
        'type': 'state'},
 'ore.': {'ap': 'Ore.',
          'fips': '41',
          'name': 'Oregon',
          'postal': 'OR',
          'type': 'state'},
 'oregon': {'ap': 'Ore.',
            'fips': '41',
            'name': 'Oregon',
            'postal': 'OR',
            'type': 'state'},
 'pa': {'ap': 'Pa.',
        'fips': '42',
        'name': 'Pennsylvania',
        'postal': 'PA',
        'type': 'state'},
 'pa.': {'ap': 'Pa.',
         'fips': '42',
         'name': 'Pennsylvania',
         'postal': 'PA',
         'type': 'state'},
 'palau': {'ap': '',
           'fips': '70',
           'name': 'Palau',
           'postal': 'PW',
           'type': ''},
 'pennsylvania': {'ap': 'Pa.',
                  'fips': '42',
                  'name': 'Pennsylvania',
                  'postal': 'PA',
                  'type': 'state'},
 'pr': {'ap': '',
        'fips': '72',
        'name': 'Puerto Rico',
        'postal': 'PR',
        'type': ''},
 'puerto rico': {'ap': '',
                 'fips': '72',
                 'name': 'Puerto Rico',
                 'postal': 'PR',
                 'type': ''},
 'pw': {'ap': '', 'fips': '70', 'name': 'Palau', 'postal': 'PW', 'type': ''},
 'r.i.': {'ap': 'R.I.',
          'fips': '44',
          'name': 'Rhode Island',
          'postal': 'RI',
          'type': 'state'},
 'rhode island': {'ap': 'R.I.',
                  'fips': '44',
                  'name': 'Rhode Island',
                  'postal': 'RI',
                  'type': 'state'},
 'ri': {'ap': 'R.I.',
        'fips': '44',
        'name': 'Rhode Island',
        'postal': 'RI',
        'type': 'state'},
 's.c.': {'ap': 'S.C.',
          'fips': '45',
          'name': 'South Carolina',
          'postal': 'SC',
          'type': 'state'},
 's.d.': {'ap': 'S.D.',
          'fips': '46',
          'name': 'South Dakota',
          'postal': 'SD',
          'type': 'state'},
 'sc': {'ap': 'S.C.',
        'fips': '45',
        'name': 'South Carolina',
        'postal': 'SC',
        'type': 'state'},
 'sd': {'ap': 'S.D.',
        'fips': '46',
        'name': 'South Dakota',
        'postal': 'SD',
        'type': 'state'},
 'south carolina': {'ap': 'S.C.',
                    'fips': '45',
                    'name': 'South Carolina',
                    'postal': 'SC',
                    'type': 'state'},
 'south dakota': {'ap': 'S.D.',
                  'fips': '46',
                  'name': 'South Dakota',
                  'postal': 'SD',
                  'type': 'state'},
 'tenn.': {'ap': 'Tenn.',
           'fips': '47',
           'name': 'Tennessee',
           'postal': 'TN',
           'type': 'state'},
 'tennessee': {'ap': 'Tenn.',
               'fips': '47',
               'name': 'Tennessee',
               'postal': 'TN',
               'type': 'state'},
 'texas': {'ap': 'Texas',
           'fips': '48',
           'name': 'Texas',
           'postal': 'TX',
           'type': 'state'},
 'tn': {'ap': 'Tenn.',
        'fips': '47',
        'name': 'Tennessee',
        'postal': 'TN',
        'type': 'state'},
 'tx': {'ap': 'Texas',
        'fips': '48',
        'name': 'Texas',
        'postal': 'TX',
        'type': 'state'},
 'ut': {'ap': 'Utah',
        'fips': '49',
        'name': 'Utah',
        'postal': 'UT',
        'type': 'state'},
 'utah': {'ap': 'Utah',
          'fips': '49',
          'name': 'Utah',
          'postal': 'UT',
          'type': 'state'},
 'va': {'ap': 'Va.',
        'fips': '51',
        'name': 'Virginia',
        'postal': 'VA',
        'type': 'state'},
 'va.': {'ap': 'Va.',
         'fips': '51',
         'name': 'Virginia',
         'postal': 'VA',
         'type': 'state'},
 'vermont': {'ap': 'Vt.',
             'fips': '50',
             'name': 'Vermont',
             'postal': 'VT',
             'type': 'state'},
 'vi': {'ap': '',
        'fips': '78',
        'name': 'Virgin Islands',
        'postal': 'VI',
        'type': ''},
 'virgin islands': {'ap': '',
                    'fips': '78',
                    'name': 'Virgin Islands',
                    'postal': 'VI',
                    'type': ''},
 'virginia': {'ap': 'Va.',
              'fips': '51',
              'name': 'Virginia',
              'postal': 'VA',
              'type': 'state'},
 'vt': {'ap': 'Vt.',
        'fips': '50',
        'name': 'Vermont',
        'postal': 'VT',
        'type': 'state'},
 'vt.': {'ap': 'Vt.',
         'fips': '50',
         'name': 'Vermont',
         'postal': 'VT',
         'type': 'state'},
 'w.va.': {'ap': 'W.Va.',
           'fips': '54',
           'name': 'West Virginia',
           'postal': 'WV',
           'type': 'state'},
 'wa': {'ap': 'Wash.',
        'fips': '53',
        'name': 'Washington',
        'postal': 'WA',
        'type': 'state'},
 'wash.': {'ap': 'Wash.',
           'fips': '53',
           'name': 'Washington',
           'postal': 'WA',
           'type': 'state'},
 'washington': {'ap': 'Wash.',
                'fips': '53',
                'name': 'Washington',
                'postal': 'WA',
                'type': 'state'},
 'west virginia': {'ap': 'W.Va.',
                   'fips': '54',
                   'name': 'West Virginia',
                   'postal': 'WV',
                   'type': 'state'},
 'wi': {'ap': 'Wis.',
        'fips': '55',
        'name': 'Wisconsin',
        'postal': 'WI',
        'type': 'state'},
 'wis.': {'ap': 'Wis.',
          'fips': '55',
          'name': 'Wisconsin',
          'postal': 'WI',
          'type': 'state'},
 'wisconsin': {'ap': 'Wis.',
               'fips': '55',
               'name': 'Wisconsin',
               'postal': 'WI',
               'type': 'state'},
 'wv': {'ap': 'W.Va.',
        'fips': '54',
        'name': 'West Virginia',
        'postal': 'WV',
        'type': 'state'},
 'wy': {'ap': 'Wyo.',
        'fips': '56',
        'name': 'Wyoming',
        'postal': 'WY',
        'type': 'state'},
 'wyo.': {'ap': 'Wyo.',
          'fips': '56',
          'name': 'Wyoming',
          'postal': 'WY',
          'type': 'state'},
 'wyoming': {'ap': 'Wyo.',
             'fips': '56',
             'name': 'Wyoming',
             'postal': 'WY',
             'type': 'state'}}

########NEW FILE########
__FILENAME__ = toolbox_tags
"""
A collection of miscellaneous string filters that we use to dress up our data.
"""
# Templatetag helpers
import re
from django import template
from django.utils.safestring import mark_safe, SafeData
from django.template.defaultfilters import stringfilter

# Open up the templatetag registry
register = template.Library()

#
# Replacement filters
#

def truthjs(bool):
    """
    Replaces True with true and False with false, so I can print JavaScript.
    """
    if bool == True:
        return 'true'
    elif bool == False:
        return 'false'
    elif bool == None:
        return 'null'
    else:
        return ''
truthjs.is_safe = True
register.filter(truthjs)


def trim_p(html, count=2):
    """
    Trims a html block to the requested number of paragraphs
    """
    grafs = [i.end() for i in re.finditer("</p>", html)]
    if len(grafs) < count:
        return html
    else:
        end = grafs[count-1]
        return html[:end]
trim_p = stringfilter(trim_p)
register.filter(trim_p)

########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from table_stacker import views, api, feeds, sitemaps
from django.conf.urls import patterns, include, url


urlpatterns = patterns('',
    # Dev static files, like admin media
    url(r'^static/(?P<path>.*)$', 'django.contrib.staticfiles.views.serve'),
    
    # Prod static files, like css and js that power the public-facing pages
    url(r'^media/(?P<path>.*)$', 'django.views.static.serve', {
        'document_root': settings.MEDIA_ROOT,
    }),
    
    # Homepage
    url(r'^$', views.TableListView.as_view(), name='table-list'),
    
    # Serialization
    url(r'^api/(?P<slug>[-\w]+).xls$', api.TableDetailXLSView.as_view(),
        name='table-xls'),
    url(r'^api/(?P<slug>[-\w]+).json$', api.TableDetailJSONView.as_view(),
        name='table-json'),
    url(r'^api/(?P<slug>[-\w]+).csv$', api.TableDetailCSVView.as_view(),
        name='table-csv'),
    
    # Extras
    url(r'^feeds/latest.xml$', feeds.LatestTablesFeed.as_view(),
        name="table-feed"),
    url(r'^sitemap.xml$', sitemaps.SitemapView.as_view(), name='sitemap'),
    
    # Table detail
    url(r'^(?P<slug>[-\w]+)/$', views.TableDetailView.as_view(),
        name='table-detail'),
)


########NEW FILE########
