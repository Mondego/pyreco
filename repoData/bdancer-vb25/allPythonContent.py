__FILENAME__ = dbg
'''

	V-Ray/Blender

	http://vray.cgdo.ru

	Author: Andrey M. Izrantsev (aka bdancer)
	E-Mail: izrantsev@cgdo.ru

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.

	All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''

import os
import bpy
import inspect


# https://gist.github.com/techtonik/2151727
#
def caller_name(skip=2):
    """Get a name of a caller in the format module.class.method
    
       `skip` specifies how many levels of stack to skip while getting caller
       name. skip=1 means "who calls me", skip=2 "who calls my caller" etc.
       
       An empty string is returned if skipped levels exceed stack height
    """
    stack = inspect.stack()
    start = 0 + skip
    if len(stack) < start + 1:
      return ''
    parentframe = stack[start][0]
    name = []
    module = inspect.getmodule(parentframe)
    if module:
        name.append(module.__name__)
    if 'self' in parentframe.f_locals:
        name.append(parentframe.f_locals['self'].__class__.__name__)
    codename = parentframe.f_code.co_name
    if codename != '<module>':
        name.append(codename)
    del parentframe
    return ".".join(name)


def msg(msg=""):
    if bpy.app.debug:
        print("...", caller_name())
        print("......", msg)

########NEW FILE########
__FILENAME__ = events
#
# V-Ray/Blender
#
# http://www.chaosgroup.com
#
# Author: Andrei Izrantcev
# E-Mail: andrei.izrantcev@chaosgroup.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
#

import bpy


def AddEvent(event, func):
    if func not in event:
        event.append(func)

def DelEvent(event, func):
    if func in event:
        event.remove(func)


@bpy.app.handlers.persistent
def dr_nodes_store(e):
    bpy.ops.vray.dr_nodes_save()


@bpy.app.handlers.persistent
def dr_nodes_restore(e):
    bpy.ops.vray.dr_nodes_load()


def register():
    AddEvent(bpy.app.handlers.save_post, dr_nodes_store)
    AddEvent(bpy.app.handlers.load_post, dr_nodes_restore)


def unregister():
    DelEvent(bpy.app.handlers.save_post, dr_nodes_store)
    DelEvent(bpy.app.handlers.load_post, dr_nodes_restore)

########NEW FILE########
__FILENAME__ = AttributeUtils
#
# V-Ray/Blender
#
# http://vray.cgdo.ru
#
# Author: Andrei Izrantcev
# E-Mail: andrei.izrantcev@chaosgroup.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
#

import bpy

from bl_ui.properties_material import active_node_mat


def callback_match_BI_diffuse(self, context):
	if not hasattr(context, 'material'):
		return
	
	material = active_node_mat(context.material)
	
	if not context.material:
		return
	
	if not self.as_viewport_color:
		material.diffuse_color = (0.5, 0.5, 0.5)
		return

	color = self.diffuse if material.vray.type == 'BRDFVRayMtl' else self.color

	material.diffuse_color = color

########NEW FILE########
__FILENAME__ = pyparsing
# module pyparsing.py
#
# Copyright (c) 2003-2013  Paul T. McGuire
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#

__doc__ = \
"""
pyparsing module - Classes and methods to define and execute parsing grammars

The pyparsing module is an alternative approach to creating and executing simple grammars,
vs. the traditional lex/yacc approach, or the use of regular expressions.  With pyparsing, you
don't need to learn a new syntax for defining grammars or matching expressions - the parsing module
provides a library of classes that you use to construct the grammar directly in Python.

Here is a program to parse "Hello, World!" (or any greeting of the form C{"<salutation>, <addressee>!"})::

    from pyparsing import Word, alphas

    # define grammar of a greeting
    greet = Word( alphas ) + "," + Word( alphas ) + "!"

    hello = "Hello, World!"
    print (hello, "->", greet.parseString( hello ))

The program outputs the following::

    Hello, World! -> ['Hello', ',', 'World', '!']

The Python representation of the grammar is quite readable, owing to the self-explanatory
class names, and the use of '+', '|' and '^' operators.

The parsed results returned from C{parseString()} can be accessed as a nested list, a dictionary, or an
object with named attributes.

The pyparsing module handles some of the problems that are typically vexing when writing text parsers:
 - extra or missing whitespace (the above program will also handle "Hello,World!", "Hello  ,  World  !", etc.)
 - quoted strings
 - embedded comments
"""

__version__ = "2.0.1"
__versionTime__ = "16 July 2013 22:22"
__author__ = "Paul McGuire <ptmcg@users.sourceforge.net>"

import string
from weakref import ref as wkref
import copy
import sys
import warnings
import re
import sre_constants
import collections
#~ sys.stderr.write( "testing pyparsing module, version %s, %s\n" % (__version__,__versionTime__ ) )

__all__ = [
'And', 'CaselessKeyword', 'CaselessLiteral', 'CharsNotIn', 'Combine', 'Dict', 'Each', 'Empty',
'FollowedBy', 'Forward', 'GoToColumn', 'Group', 'Keyword', 'LineEnd', 'LineStart', 'Literal',
'MatchFirst', 'NoMatch', 'NotAny', 'OneOrMore', 'OnlyOnce', 'Optional', 'Or',
'ParseBaseException', 'ParseElementEnhance', 'ParseException', 'ParseExpression', 'ParseFatalException',
'ParseResults', 'ParseSyntaxException', 'ParserElement', 'QuotedString', 'RecursiveGrammarException',
'Regex', 'SkipTo', 'StringEnd', 'StringStart', 'Suppress', 'Token', 'TokenConverter', 'Upcase',
'White', 'Word', 'WordEnd', 'WordStart', 'ZeroOrMore',
'alphanums', 'alphas', 'alphas8bit', 'anyCloseTag', 'anyOpenTag', 'cStyleComment', 'col',
'commaSeparatedList', 'commonHTMLEntity', 'countedArray', 'cppStyleComment', 'dblQuotedString',
'dblSlashComment', 'delimitedList', 'dictOf', 'downcaseTokens', 'empty', 'hexnums',
'htmlComment', 'javaStyleComment', 'keepOriginalText', 'line', 'lineEnd', 'lineStart', 'lineno',
'makeHTMLTags', 'makeXMLTags', 'matchOnlyAtCol', 'matchPreviousExpr', 'matchPreviousLiteral',
'nestedExpr', 'nullDebugAction', 'nums', 'oneOf', 'opAssoc', 'operatorPrecedence', 'printables',
'punc8bit', 'pythonStyleComment', 'quotedString', 'removeQuotes', 'replaceHTMLEntity', 
'replaceWith', 'restOfLine', 'sglQuotedString', 'srange', 'stringEnd',
'stringStart', 'traceParseAction', 'unicodeString', 'upcaseTokens', 'withAttribute',
'indentedBlock', 'originalTextFor', 'ungroup', 'infixNotation',
]

PY_3 = sys.version.startswith('3')
if PY_3:
    _MAX_INT = sys.maxsize
    basestring = str
    unichr = chr
    _ustr = str

    # build list of single arg builtins, that can be used as parse actions
    singleArgBuiltins = [sum, len, sorted, reversed, list, tuple, set, any, all, min, max]

else:
    _MAX_INT = sys.maxint
    range = xrange

    def _ustr(obj):
        """Drop-in replacement for str(obj) that tries to be Unicode friendly. It first tries
           str(obj). If that fails with a UnicodeEncodeError, then it tries unicode(obj). It
           then < returns the unicode object | encodes it with the default encoding | ... >.
        """
        if isinstance(obj,unicode):
            return obj

        try:
            # If this works, then _ustr(obj) has the same behaviour as str(obj), so
            # it won't break any existing code.
            return str(obj)

        except UnicodeEncodeError:
            # The Python docs (http://docs.python.org/ref/customization.html#l2h-182)
            # state that "The return value must be a string object". However, does a
            # unicode object (being a subclass of basestring) count as a "string
            # object"?
            # If so, then return a unicode object:
            return unicode(obj)
            # Else encode it... but how? There are many choices... :)
            # Replace unprintables with escape codes?
            #return unicode(obj).encode(sys.getdefaultencoding(), 'backslashreplace_errors')
            # Replace unprintables with question marks?
            #return unicode(obj).encode(sys.getdefaultencoding(), 'replace')
            # ...

    # build list of single arg builtins, tolerant of Python version, that can be used as parse actions
    singleArgBuiltins = []
    import __builtin__
    for fname in "sum len sorted reversed list tuple set any all min max".split():
        try:
            singleArgBuiltins.append(getattr(__builtin__,fname))
        except AttributeError:
            continue


def _xml_escape(data):
    """Escape &, <, >, ", ', etc. in a string of data."""

    # ampersand must be replaced first
    from_symbols = '&><"\''
    to_symbols = ('&'+s+';' for s in "amp gt lt quot apos".split())
    for from_,to_ in zip(from_symbols, to_symbols):
        data = data.replace(from_, to_)
    return data

class _Constants(object):
    pass

alphas = string.ascii_lowercase + string.ascii_uppercase
nums       = "0123456789"
hexnums    = nums + "ABCDEFabcdef"
alphanums  = alphas + nums
_bslash    = chr(92)
printables = "".join(c for c in string.printable if c not in string.whitespace)

class ParseBaseException(Exception):
    """base exception class for all parsing runtime exceptions"""
    # Performance tuning: we construct a *lot* of these, so keep this
    # constructor as small and fast as possible
    def __init__( self, pstr, loc=0, msg=None, elem=None ):
        self.loc = loc
        if msg is None:
            self.msg = pstr
            self.pstr = ""
        else:
            self.msg = msg
            self.pstr = pstr
        self.parserElement = elem

    def __getattr__( self, aname ):
        """supported attributes by name are:
            - lineno - returns the line number of the exception text
            - col - returns the column number of the exception text
            - line - returns the line containing the exception text
        """
        if( aname == "lineno" ):
            return lineno( self.loc, self.pstr )
        elif( aname in ("col", "column") ):
            return col( self.loc, self.pstr )
        elif( aname == "line" ):
            return line( self.loc, self.pstr )
        else:
            raise AttributeError(aname)

    def __str__( self ):
        return "%s (at char %d), (line:%d, col:%d)" % \
                ( self.msg, self.loc, self.lineno, self.column )
    def __repr__( self ):
        return _ustr(self)
    def markInputline( self, markerString = ">!<" ):
        """Extracts the exception line from the input string, and marks
           the location of the exception with a special symbol.
        """
        line_str = self.line
        line_column = self.column - 1
        if markerString:
            line_str = "".join(line_str[:line_column],
                                markerString, line_str[line_column:])
        return line_str.strip()
    def __dir__(self):
        return "loc msg pstr parserElement lineno col line " \
               "markInputline __str__ __repr__".split()

class ParseException(ParseBaseException):
    """exception thrown when parse expressions don't match class;
       supported attributes by name are:
        - lineno - returns the line number of the exception text
        - col - returns the column number of the exception text
        - line - returns the line containing the exception text
    """
    pass

class ParseFatalException(ParseBaseException):
    """user-throwable exception thrown when inconsistent parse content
       is found; stops all parsing immediately"""
    pass

class ParseSyntaxException(ParseFatalException):
    """just like C{L{ParseFatalException}}, but thrown internally when an
       C{L{ErrorStop<And._ErrorStop>}} ('-' operator) indicates that parsing is to stop immediately because
       an unbacktrackable syntax error has been found"""
    def __init__(self, pe):
        super(ParseSyntaxException, self).__init__(
                                    pe.pstr, pe.loc, pe.msg, pe.parserElement)

#~ class ReparseException(ParseBaseException):
    #~ """Experimental class - parse actions can raise this exception to cause
       #~ pyparsing to reparse the input string:
        #~ - with a modified input string, and/or
        #~ - with a modified start location
       #~ Set the values of the ReparseException in the constructor, and raise the
       #~ exception in a parse action to cause pyparsing to use the new string/location.
       #~ Setting the values as None causes no change to be made.
       #~ """
    #~ def __init_( self, newstring, restartLoc ):
        #~ self.newParseText = newstring
        #~ self.reparseLoc = restartLoc

class RecursiveGrammarException(Exception):
    """exception thrown by C{validate()} if the grammar could be improperly recursive"""
    def __init__( self, parseElementList ):
        self.parseElementTrace = parseElementList

    def __str__( self ):
        return "RecursiveGrammarException: %s" % self.parseElementTrace

class _ParseResultsWithOffset(object):
    def __init__(self,p1,p2):
        self.tup = (p1,p2)
    def __getitem__(self,i):
        return self.tup[i]
    def __repr__(self):
        return repr(self.tup)
    def setOffset(self,i):
        self.tup = (self.tup[0],i)

class ParseResults(object):
    """Structured parse results, to provide multiple means of access to the parsed data:
       - as a list (C{len(results)})
       - by list index (C{results[0], results[1]}, etc.)
       - by attribute (C{results.<resultsName>})
       """
    #~ __slots__ = ( "__toklist", "__tokdict", "__doinit", "__name", "__parent", "__accumNames", "__weakref__" )
    def __new__(cls, toklist, name=None, asList=True, modal=True ):
        if isinstance(toklist, cls):
            return toklist
        retobj = object.__new__(cls)
        retobj.__doinit = True
        return retobj

    # Performance tuning: we construct a *lot* of these, so keep this
    # constructor as small and fast as possible
    def __init__( self, toklist, name=None, asList=True, modal=True, isinstance=isinstance ):
        if self.__doinit:
            self.__doinit = False
            self.__name = None
            self.__parent = None
            self.__accumNames = {}
            if isinstance(toklist, list):
                self.__toklist = toklist[:]
            else:
                self.__toklist = [toklist]
            self.__tokdict = dict()

        if name is not None and name:
            if not modal:
                self.__accumNames[name] = 0
            if isinstance(name,int):
                name = _ustr(name) # will always return a str, but use _ustr for consistency
            self.__name = name
            if not toklist in (None,'',[]):
                if isinstance(toklist,basestring):
                    toklist = [ toklist ]
                if asList:
                    if isinstance(toklist,ParseResults):
                        self[name] = _ParseResultsWithOffset(toklist.copy(),0)
                    else:
                        self[name] = _ParseResultsWithOffset(ParseResults(toklist[0]),0)
                    self[name].__name = name
                else:
                    try:
                        self[name] = toklist[0]
                    except (KeyError,TypeError,IndexError):
                        self[name] = toklist

    def __getitem__( self, i ):
        if isinstance( i, (int,slice) ):
            return self.__toklist[i]
        else:
            if i not in self.__accumNames:
                return self.__tokdict[i][-1][0]
            else:
                return ParseResults([ v[0] for v in self.__tokdict[i] ])

    def __setitem__( self, k, v, isinstance=isinstance ):
        if isinstance(v,_ParseResultsWithOffset):
            self.__tokdict[k] = self.__tokdict.get(k,list()) + [v]
            sub = v[0]
        elif isinstance(k,int):
            self.__toklist[k] = v
            sub = v
        else:
            self.__tokdict[k] = self.__tokdict.get(k,list()) + [_ParseResultsWithOffset(v,0)]
            sub = v
        if isinstance(sub,ParseResults):
            sub.__parent = wkref(self)

    def __delitem__( self, i ):
        if isinstance(i,(int,slice)):
            mylen = len( self.__toklist )
            del self.__toklist[i]

            # convert int to slice
            if isinstance(i, int):
                if i < 0:
                    i += mylen
                i = slice(i, i+1)
            # get removed indices
            removed = list(range(*i.indices(mylen)))
            removed.reverse()
            # fixup indices in token dictionary
            for name in self.__tokdict:
                occurrences = self.__tokdict[name]
                for j in removed:
                    for k, (value, position) in enumerate(occurrences):
                        occurrences[k] = _ParseResultsWithOffset(value, position - (position > j))
        else:
            del self.__tokdict[i]

    def __contains__( self, k ):
        return k in self.__tokdict

    def __len__( self ): return len( self.__toklist )
    def __bool__(self): return len( self.__toklist ) > 0
    __nonzero__ = __bool__
    def __iter__( self ): return iter( self.__toklist )
    def __reversed__( self ): return iter( self.__toklist[::-1] )
    def keys( self ):
        """Returns all named result keys."""
        return self.__tokdict.keys()

    def pop( self, index=-1 ):
        """Removes and returns item at specified index (default=last).
           Will work with either numeric indices or dict-key indicies."""
        ret = self[index]
        del self[index]
        return ret

    def get(self, key, defaultValue=None):
        """Returns named result matching the given key, or if there is no
           such name, then returns the given C{defaultValue} or C{None} if no
           C{defaultValue} is specified."""
        if key in self:
            return self[key]
        else:
            return defaultValue

    def insert( self, index, insStr ):
        """Inserts new element at location index in the list of parsed tokens."""
        self.__toklist.insert(index, insStr)
        # fixup indices in token dictionary
        for name in self.__tokdict:
            occurrences = self.__tokdict[name]
            for k, (value, position) in enumerate(occurrences):
                occurrences[k] = _ParseResultsWithOffset(value, position + (position > index))

    def items( self ):
        """Returns all named result keys and values as a list of tuples."""
        return [(k,self[k]) for k in self.__tokdict]

    def values( self ):
        """Returns all named result values."""
        return [ v[-1][0] for v in self.__tokdict.values() ]

    def __getattr__( self, name ):
        if True: #name not in self.__slots__:
            if name in self.__tokdict:
                if name not in self.__accumNames:
                    return self.__tokdict[name][-1][0]
                else:
                    return ParseResults([ v[0] for v in self.__tokdict[name] ])
            else:
                return ""
        return None

    def __add__( self, other ):
        ret = self.copy()
        ret += other
        return ret

    def __iadd__( self, other ):
        if other.__tokdict:
            offset = len(self.__toklist)
            addoffset = ( lambda a: (a<0 and offset) or (a+offset) )
            otheritems = other.__tokdict.items()
            otherdictitems = [(k, _ParseResultsWithOffset(v[0],addoffset(v[1])) )
                                for (k,vlist) in otheritems for v in vlist]
            for k,v in otherdictitems:
                self[k] = v
                if isinstance(v[0],ParseResults):
                    v[0].__parent = wkref(self)
            
        self.__toklist += other.__toklist
        self.__accumNames.update( other.__accumNames )
        return self

    def __radd__(self, other):
        if isinstance(other,int) and other == 0:
            return self.copy()
        
    def __repr__( self ):
        return "(%s, %s)" % ( repr( self.__toklist ), repr( self.__tokdict ) )

    def __str__( self ):
        out = []
        for i in self.__toklist:
            if isinstance(i, ParseResults):
                out.append(_ustr(i))
            else:
                out.append(repr(i))
        return '[' + ', '.join(out) + ']'

    def _asStringList( self, sep='' ):
        out = []
        for item in self.__toklist:
            if out and sep:
                out.append(sep)
            if isinstance( item, ParseResults ):
                out += item._asStringList()
            else:
                out.append( _ustr(item) )
        return out

    def asList( self ):
        """Returns the parse results as a nested list of matching tokens, all converted to strings."""
        out = []
        for res in self.__toklist:
            if isinstance(res,ParseResults):
                out.append( res.asList() )
            else:
                out.append( res )
        return out

    def asDict( self ):
        """Returns the named parse results as dictionary."""
        return dict( self.items() )

    def copy( self ):
        """Returns a new copy of a C{ParseResults} object."""
        ret = ParseResults( self.__toklist )
        ret.__tokdict = self.__tokdict.copy()
        ret.__parent = self.__parent
        ret.__accumNames.update( self.__accumNames )
        ret.__name = self.__name
        return ret

    def asXML( self, doctag=None, namedItemsOnly=False, indent="", formatted=True ):
        """Returns the parse results as XML. Tags are created for tokens and lists that have defined results names."""
        nl = "\n"
        out = []
        namedItems = dict((v[1],k) for (k,vlist) in self.__tokdict.items()
                                                            for v in vlist)
        nextLevelIndent = indent + "  "

        # collapse out indents if formatting is not desired
        if not formatted:
            indent = ""
            nextLevelIndent = ""
            nl = ""

        selfTag = None
        if doctag is not None:
            selfTag = doctag
        else:
            if self.__name:
                selfTag = self.__name

        if not selfTag:
            if namedItemsOnly:
                return ""
            else:
                selfTag = "ITEM"

        out += [ nl, indent, "<", selfTag, ">" ]

        worklist = self.__toklist
        for i,res in enumerate(worklist):
            if isinstance(res,ParseResults):
                if i in namedItems:
                    out += [ res.asXML(namedItems[i],
                                        namedItemsOnly and doctag is None,
                                        nextLevelIndent,
                                        formatted)]
                else:
                    out += [ res.asXML(None,
                                        namedItemsOnly and doctag is None,
                                        nextLevelIndent,
                                        formatted)]
            else:
                # individual token, see if there is a name for it
                resTag = None
                if i in namedItems:
                    resTag = namedItems[i]
                if not resTag:
                    if namedItemsOnly:
                        continue
                    else:
                        resTag = "ITEM"
                xmlBodyText = _xml_escape(_ustr(res))
                out += [ nl, nextLevelIndent, "<", resTag, ">",
                                                xmlBodyText,
                                                "</", resTag, ">" ]

        out += [ nl, indent, "</", selfTag, ">" ]
        return "".join(out)

    def __lookup(self,sub):
        for k,vlist in self.__tokdict.items():
            for v,loc in vlist:
                if sub is v:
                    return k
        return None

    def getName(self):
        """Returns the results name for this token expression."""
        if self.__name:
            return self.__name
        elif self.__parent:
            par = self.__parent()
            if par:
                return par.__lookup(self)
            else:
                return None
        elif (len(self) == 1 and
               len(self.__tokdict) == 1 and
               self.__tokdict.values()[0][0][1] in (0,-1)):
            return self.__tokdict.keys()[0]
        else:
            return None

    def dump(self,indent='',depth=0):
        """Diagnostic method for listing out the contents of a C{ParseResults}.
           Accepts an optional C{indent} argument so that this string can be embedded
           in a nested display of other data."""
        out = []
        out.append( indent+_ustr(self.asList()) )
        keys = self.items()
        keys.sort()
        for k,v in keys:
            if out:
                out.append('\n')
            out.append( "%s%s- %s: " % (indent,('  '*depth), k) )
            if isinstance(v,ParseResults):
                if v.keys():
                    out.append( v.dump(indent,depth+1) )
                else:
                    out.append(_ustr(v))
            else:
                out.append(_ustr(v))
        return "".join(out)

    # add support for pickle protocol
    def __getstate__(self):
        return ( self.__toklist,
                 ( self.__tokdict.copy(),
                   self.__parent is not None and self.__parent() or None,
                   self.__accumNames,
                   self.__name ) )

    def __setstate__(self,state):
        self.__toklist = state[0]
        (self.__tokdict,
         par,
         inAccumNames,
         self.__name) = state[1]
        self.__accumNames = {}
        self.__accumNames.update(inAccumNames)
        if par is not None:
            self.__parent = wkref(par)
        else:
            self.__parent = None

    def __dir__(self):
        return dir(super(ParseResults,self)) + list(self.keys())

collections.MutableMapping.register(ParseResults)

def col (loc,strg):
    """Returns current column within a string, counting newlines as line separators.
   The first column is number 1.

   Note: the default parsing behavior is to expand tabs in the input string
   before starting the parsing process.  See L{I{ParserElement.parseString}<ParserElement.parseString>} for more information
   on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
   consistent view of the parsed string, the parse location, and line and column
   positions within the parsed string.
   """
    return (loc<len(strg) and strg[loc] == '\n') and 1 or loc - strg.rfind("\n", 0, loc)

def lineno(loc,strg):
    """Returns current line number within a string, counting newlines as line separators.
   The first line is number 1.

   Note: the default parsing behavior is to expand tabs in the input string
   before starting the parsing process.  See L{I{ParserElement.parseString}<ParserElement.parseString>} for more information
   on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
   consistent view of the parsed string, the parse location, and line and column
   positions within the parsed string.
   """
    return strg.count("\n",0,loc) + 1

def line( loc, strg ):
    """Returns the line of text containing loc within a string, counting newlines as line separators.
       """
    lastCR = strg.rfind("\n", 0, loc)
    nextCR = strg.find("\n", loc)
    if nextCR >= 0:
        return strg[lastCR+1:nextCR]
    else:
        return strg[lastCR+1:]

def _defaultStartDebugAction( instring, loc, expr ):
    print (("Match " + _ustr(expr) + " at loc " + _ustr(loc) + "(%d,%d)" % ( lineno(loc,instring), col(loc,instring) )))

def _defaultSuccessDebugAction( instring, startloc, endloc, expr, toks ):
    print ("Matched " + _ustr(expr) + " -> " + str(toks.asList()))

def _defaultExceptionDebugAction( instring, loc, expr, exc ):
    print ("Exception raised:" + _ustr(exc))

def nullDebugAction(*args):
    """'Do-nothing' debug action, to suppress debugging output during parsing."""
    pass

# Only works on Python 3.x - nonlocal is toxic to Python 2 installs
#~ 'decorator to trim function calls to match the arity of the target'
#~ def _trim_arity(func, maxargs=3):
    #~ if func in singleArgBuiltins:
        #~ return lambda s,l,t: func(t)
    #~ limit = 0
    #~ foundArity = False
    #~ def wrapper(*args):
        #~ nonlocal limit,foundArity
        #~ while 1:
            #~ try:
                #~ ret = func(*args[limit:])
                #~ foundArity = True
                #~ return ret
            #~ except TypeError:
                #~ if limit == maxargs or foundArity:
                    #~ raise
                #~ limit += 1
                #~ continue
    #~ return wrapper

# this version is Python 2.x-3.x cross-compatible
'decorator to trim function calls to match the arity of the target'
def _trim_arity(func, maxargs=2):
    if func in singleArgBuiltins:
        return lambda s,l,t: func(t)
    limit = [0]
    foundArity = [False]
    def wrapper(*args):
        while 1:
            try:
                ret = func(*args[limit[0]:])
                foundArity[0] = True
                return ret
            except TypeError:
                if limit[0] <= maxargs and not foundArity[0]:
                    limit[0] += 1
                    continue
                raise
    return wrapper
 
class ParserElement(object):
    """Abstract base level parser element class."""
    DEFAULT_WHITE_CHARS = " \n\t\r"
    verbose_stacktrace = False

    def setDefaultWhitespaceChars( chars ):
        """Overrides the default whitespace chars
        """
        ParserElement.DEFAULT_WHITE_CHARS = chars
    setDefaultWhitespaceChars = staticmethod(setDefaultWhitespaceChars)

    def inlineLiteralsUsing(cls):
        """
        Set class to be used for inclusion of string literals into a parser.
        """
        ParserElement.literalStringClass = cls
    inlineLiteralsUsing = staticmethod(inlineLiteralsUsing)

    def __init__( self, savelist=False ):
        self.parseAction = list()
        self.failAction = None
        #~ self.name = "<unknown>"  # don't define self.name, let subclasses try/except upcall
        self.strRepr = None
        self.resultsName = None
        self.saveAsList = savelist
        self.skipWhitespace = True
        self.whiteChars = ParserElement.DEFAULT_WHITE_CHARS
        self.copyDefaultWhiteChars = True
        self.mayReturnEmpty = False # used when checking for left-recursion
        self.keepTabs = False
        self.ignoreExprs = list()
        self.debug = False
        self.streamlined = False
        self.mayIndexError = True # used to optimize exception handling for subclasses that don't advance parse index
        self.errmsg = ""
        self.modalResults = True # used to mark results names as modal (report only last) or cumulative (list all)
        self.debugActions = ( None, None, None ) #custom debug actions
        self.re = None
        self.callPreparse = True # used to avoid redundant calls to preParse
        self.callDuringTry = False

    def copy( self ):
        """Make a copy of this C{ParserElement}.  Useful for defining different parse actions
           for the same parsing pattern, using copies of the original parse element."""
        cpy = copy.copy( self )
        cpy.parseAction = self.parseAction[:]
        cpy.ignoreExprs = self.ignoreExprs[:]
        if self.copyDefaultWhiteChars:
            cpy.whiteChars = ParserElement.DEFAULT_WHITE_CHARS
        return cpy

    def setName( self, name ):
        """Define name for this expression, for use in debugging."""
        self.name = name
        self.errmsg = "Expected " + self.name
        if hasattr(self,"exception"):
            self.exception.msg = self.errmsg
        return self

    def setResultsName( self, name, listAllMatches=False ):
        """Define name for referencing matching tokens as a nested attribute
           of the returned parse results.
           NOTE: this returns a *copy* of the original C{ParserElement} object;
           this is so that the client can define a basic element, such as an
           integer, and reference it in multiple places with different names.
           
           You can also set results names using the abbreviated syntax,
           C{expr("name")} in place of C{expr.setResultsName("name")} - 
           see L{I{__call__}<__call__>}.
        """
        newself = self.copy()
        if name.endswith("*"):
            name = name[:-1]
            listAllMatches=True
        newself.resultsName = name
        newself.modalResults = not listAllMatches
        return newself

    def setBreak(self,breakFlag = True):
        """Method to invoke the Python pdb debugger when this element is
           about to be parsed. Set C{breakFlag} to True to enable, False to
           disable.
        """
        if breakFlag:
            _parseMethod = self._parse
            def breaker(instring, loc, doActions=True, callPreParse=True):
                import pdb
                pdb.set_trace()
                return _parseMethod( instring, loc, doActions, callPreParse )
            breaker._originalParseMethod = _parseMethod
            self._parse = breaker
        else:
            if hasattr(self._parse,"_originalParseMethod"):
                self._parse = self._parse._originalParseMethod
        return self

    def setParseAction( self, *fns, **kwargs ):
        """Define action to perform when successfully matching parse element definition.
           Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
           C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
            - s   = the original string being parsed (see note below)
            - loc = the location of the matching substring
            - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
           If the functions in fns modify the tokens, they can return them as the return
           value from fn, and the modified list of tokens will replace the original.
           Otherwise, fn does not need to return any value.

           Note: the default parsing behavior is to expand tabs in the input string
           before starting the parsing process.  See L{I{parseString}<parseString>} for more information
           on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
           consistent view of the parsed string, the parse location, and line and column
           positions within the parsed string.
           """
        self.parseAction = list(map(_trim_arity, list(fns)))
        self.callDuringTry = ("callDuringTry" in kwargs and kwargs["callDuringTry"])
        return self

    def addParseAction( self, *fns, **kwargs ):
        """Add parse action to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}."""
        self.parseAction += list(map(_trim_arity, list(fns)))
        self.callDuringTry = self.callDuringTry or ("callDuringTry" in kwargs and kwargs["callDuringTry"])
        return self

    def setFailAction( self, fn ):
        """Define action to perform if parsing fails at this expression.
           Fail acton fn is a callable function that takes the arguments
           C{fn(s,loc,expr,err)} where:
            - s = string being parsed
            - loc = location where expression match was attempted and failed
            - expr = the parse expression that failed
            - err = the exception thrown
           The function returns no value.  It may throw C{L{ParseFatalException}}
           if it is desired to stop parsing immediately."""
        self.failAction = fn
        return self

    def _skipIgnorables( self, instring, loc ):
        exprsFound = True
        while exprsFound:
            exprsFound = False
            for e in self.ignoreExprs:
                try:
                    while 1:
                        loc,dummy = e._parse( instring, loc )
                        exprsFound = True
                except ParseException:
                    pass
        return loc

    def preParse( self, instring, loc ):
        if self.ignoreExprs:
            loc = self._skipIgnorables( instring, loc )

        if self.skipWhitespace:
            wt = self.whiteChars
            instrlen = len(instring)
            while loc < instrlen and instring[loc] in wt:
                loc += 1

        return loc

    def parseImpl( self, instring, loc, doActions=True ):
        return loc, []

    def postParse( self, instring, loc, tokenlist ):
        return tokenlist

    #~ @profile
    def _parseNoCache( self, instring, loc, doActions=True, callPreParse=True ):
        debugging = ( self.debug ) #and doActions )

        if debugging or self.failAction:
            #~ print ("Match",self,"at loc",loc,"(%d,%d)" % ( lineno(loc,instring), col(loc,instring) ))
            if (self.debugActions[0] ):
                self.debugActions[0]( instring, loc, self )
            if callPreParse and self.callPreparse:
                preloc = self.preParse( instring, loc )
            else:
                preloc = loc
            tokensStart = preloc
            try:
                try:
                    loc,tokens = self.parseImpl( instring, preloc, doActions )
                except IndexError:
                    raise ParseException( instring, len(instring), self.errmsg, self )
            except ParseBaseException as err:
                #~ print ("Exception raised:", err)
                if self.debugActions[2]:
                    self.debugActions[2]( instring, tokensStart, self, err )
                if self.failAction:
                    self.failAction( instring, tokensStart, self, err )
                raise
        else:
            if callPreParse and self.callPreparse:
                preloc = self.preParse( instring, loc )
            else:
                preloc = loc
            tokensStart = preloc
            if self.mayIndexError or loc >= len(instring):
                try:
                    loc,tokens = self.parseImpl( instring, preloc, doActions )
                except IndexError:
                    raise ParseException( instring, len(instring), self.errmsg, self )
            else:
                loc,tokens = self.parseImpl( instring, preloc, doActions )

        tokens = self.postParse( instring, loc, tokens )

        retTokens = ParseResults( tokens, self.resultsName, asList=self.saveAsList, modal=self.modalResults )
        if self.parseAction and (doActions or self.callDuringTry):
            if debugging:
                try:
                    for fn in self.parseAction:
                        tokens = fn( instring, tokensStart, retTokens )
                        if tokens is not None:
                            retTokens = ParseResults( tokens,
                                                      self.resultsName,
                                                      asList=self.saveAsList and isinstance(tokens,(ParseResults,list)),
                                                      modal=self.modalResults )
                except ParseBaseException as err:
                    #~ print "Exception raised in user parse action:", err
                    if (self.debugActions[2] ):
                        self.debugActions[2]( instring, tokensStart, self, err )
                    raise
            else:
                for fn in self.parseAction:
                    tokens = fn( instring, tokensStart, retTokens )
                    if tokens is not None:
                        retTokens = ParseResults( tokens,
                                                  self.resultsName,
                                                  asList=self.saveAsList and isinstance(tokens,(ParseResults,list)),
                                                  modal=self.modalResults )

        if debugging:
            #~ print ("Matched",self,"->",retTokens.asList())
            if (self.debugActions[1] ):
                self.debugActions[1]( instring, tokensStart, loc, self, retTokens )

        return loc, retTokens

    def tryParse( self, instring, loc ):
        try:
            return self._parse( instring, loc, doActions=False )[0]
        except ParseFatalException:
            raise ParseException( instring, loc, self.errmsg, self)

    # this method gets repeatedly called during backtracking with the same arguments -
    # we can cache these arguments and save ourselves the trouble of re-parsing the contained expression
    def _parseCache( self, instring, loc, doActions=True, callPreParse=True ):
        lookup = (self,instring,loc,callPreParse,doActions)
        if lookup in ParserElement._exprArgCache:
            value = ParserElement._exprArgCache[ lookup ]
            if isinstance(value, Exception):
                raise value
            return (value[0],value[1].copy())
        else:
            try:
                value = self._parseNoCache( instring, loc, doActions, callPreParse )
                ParserElement._exprArgCache[ lookup ] = (value[0],value[1].copy())
                return value
            except ParseBaseException as pe:
                pe.__traceback__ = None
                ParserElement._exprArgCache[ lookup ] = pe
                raise

    _parse = _parseNoCache

    # argument cache for optimizing repeated calls when backtracking through recursive expressions
    _exprArgCache = {}
    def resetCache():
        ParserElement._exprArgCache.clear()
    resetCache = staticmethod(resetCache)

    _packratEnabled = False
    def enablePackrat():
        """Enables "packrat" parsing, which adds memoizing to the parsing logic.
           Repeated parse attempts at the same string location (which happens
           often in many complex grammars) can immediately return a cached value,
           instead of re-executing parsing/validating code.  Memoizing is done of
           both valid results and parsing exceptions.

           This speedup may break existing programs that use parse actions that
           have side-effects.  For this reason, packrat parsing is disabled when
           you first import pyparsing.  To activate the packrat feature, your
           program must call the class method C{ParserElement.enablePackrat()}.  If
           your program uses C{psyco} to "compile as you go", you must call
           C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
           Python will crash.  For best results, call C{enablePackrat()} immediately
           after importing pyparsing.
        """
        if not ParserElement._packratEnabled:
            ParserElement._packratEnabled = True
            ParserElement._parse = ParserElement._parseCache
    enablePackrat = staticmethod(enablePackrat)

    def parseString( self, instring, parseAll=False ):
        """Execute the parse expression with the given string.
           This is the main interface to the client code, once the complete
           expression has been built.

           If you want the grammar to require that the entire input string be
           successfully parsed, then set C{parseAll} to True (equivalent to ending
           the grammar with C{L{StringEnd()}}).

           Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
           in order to report proper column numbers in parse actions.
           If the input string contains tabs and
           the grammar uses parse actions that use the C{loc} argument to index into the
           string being parsed, you can ensure you have a consistent view of the input
           string by:
            - calling C{parseWithTabs} on your grammar before calling C{parseString}
              (see L{I{parseWithTabs}<parseWithTabs>})
            - define your parse action using the full C{(s,loc,toks)} signature, and
              reference the input string using the parse action's C{s} argument
            - explictly expand the tabs in your input string before calling
              C{parseString}
        """
        ParserElement.resetCache()
        if not self.streamlined:
            self.streamline()
            #~ self.saveAsList = True
        for e in self.ignoreExprs:
            e.streamline()
        if not self.keepTabs:
            instring = instring.expandtabs()
        try:
            loc, tokens = self._parse( instring, 0 )
            if parseAll:
                loc = self.preParse( instring, loc )
                se = Empty() + StringEnd()
                se._parse( instring, loc )
        except ParseBaseException as exc:
            if ParserElement.verbose_stacktrace:
                raise
            else:
                # catch and re-raise exception from here, clears out pyparsing internal stack trace
                raise exc
        else:
            return tokens

    def scanString( self, instring, maxMatches=_MAX_INT, overlap=False ):
        """Scan the input string for expression matches.  Each match will return the
           matching tokens, start location, and end location.  May be called with optional
           C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
           C{overlap} is specified, then overlapping matches will be reported.

           Note that the start and end locations are reported relative to the string
           being parsed.  See L{I{parseString}<parseString>} for more information on parsing
           strings with embedded tabs."""
        if not self.streamlined:
            self.streamline()
        for e in self.ignoreExprs:
            e.streamline()

        if not self.keepTabs:
            instring = _ustr(instring).expandtabs()
        instrlen = len(instring)
        loc = 0
        preparseFn = self.preParse
        parseFn = self._parse
        ParserElement.resetCache()
        matches = 0
        try:
            while loc <= instrlen and matches < maxMatches:
                try:
                    preloc = preparseFn( instring, loc )
                    nextLoc,tokens = parseFn( instring, preloc, callPreParse=False )
                except ParseException:
                    loc = preloc+1
                else:
                    if nextLoc > loc:
                        matches += 1
                        yield tokens, preloc, nextLoc
                        if overlap:
                            nextloc = preparseFn( instring, loc )
                            if nextloc > loc:
                                loc = nextLoc
                            else:
                                loc += 1
                        else:
                            loc = nextLoc
                    else:
                        loc = preloc+1
        except ParseBaseException as exc:
            if ParserElement.verbose_stacktrace:
                raise
            else:
                # catch and re-raise exception from here, clears out pyparsing internal stack trace
                raise exc

    def transformString( self, instring ):
        """Extension to C{L{scanString}}, to modify matching text with modified tokens that may
           be returned from a parse action.  To use C{transformString}, define a grammar and
           attach a parse action to it that modifies the returned token list.
           Invoking C{transformString()} on a target string will then scan for matches,
           and replace the matched text patterns according to the logic in the parse
           action.  C{transformString()} returns the resulting transformed string."""
        out = []
        lastE = 0
        # force preservation of <TAB>s, to minimize unwanted transformation of string, and to
        # keep string locs straight between transformString and scanString
        self.keepTabs = True
        try:
            for t,s,e in self.scanString( instring ):
                out.append( instring[lastE:s] )
                if t:
                    if isinstance(t,ParseResults):
                        out += t.asList()
                    elif isinstance(t,list):
                        out += t
                    else:
                        out.append(t)
                lastE = e
            out.append(instring[lastE:])
            out = [o for o in out if o]
            return "".join(map(_ustr,_flatten(out)))
        except ParseBaseException as exc:
            if ParserElement.verbose_stacktrace:
                raise
            else:
                # catch and re-raise exception from here, clears out pyparsing internal stack trace
                raise exc

    def searchString( self, instring, maxMatches=_MAX_INT ):
        """Another extension to C{L{scanString}}, simplifying the access to the tokens found
           to match the given parse expression.  May be called with optional
           C{maxMatches} argument, to clip searching after 'n' matches are found.
        """
        try:
            return ParseResults([ t for t,s,e in self.scanString( instring, maxMatches ) ])
        except ParseBaseException as exc:
            if ParserElement.verbose_stacktrace:
                raise
            else:
                # catch and re-raise exception from here, clears out pyparsing internal stack trace
                raise exc

    def __add__(self, other ):
        """Implementation of + operator - returns C{L{And}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return And( [ self, other ] )

    def __radd__(self, other ):
        """Implementation of + operator when left operand is not a C{L{ParserElement}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return other + self

    def __sub__(self, other):
        """Implementation of - operator, returns C{L{And}} with error stop"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return And( [ self, And._ErrorStop(), other ] )

    def __rsub__(self, other ):
        """Implementation of - operator when left operand is not a C{L{ParserElement}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return other - self

    def __mul__(self,other):
        """Implementation of * operator, allows use of C{expr * 3} in place of
           C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
           tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
           may also include C{None} as in:
            - C{expr*(n,None)} or C{expr*(n,)} is equivalent
              to C{expr*n + L{ZeroOrMore}(expr)}
              (read as "at least n instances of C{expr}")
            - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
              (read as "0 to n instances of C{expr}")
            - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
            - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}

           Note that C{expr*(None,n)} does not raise an exception if
           more than n exprs exist in the input stream; that is,
           C{expr*(None,n)} does not enforce a maximum number of expr
           occurrences.  If this behavior is desired, then write
           C{expr*(None,n) + ~expr}

        """
        if isinstance(other,int):
            minElements, optElements = other,0
        elif isinstance(other,tuple):
            other = (other + (None, None))[:2]
            if other[0] is None:
                other = (0, other[1])
            if isinstance(other[0],int) and other[1] is None:
                if other[0] == 0:
                    return ZeroOrMore(self)
                if other[0] == 1:
                    return OneOrMore(self)
                else:
                    return self*other[0] + ZeroOrMore(self)
            elif isinstance(other[0],int) and isinstance(other[1],int):
                minElements, optElements = other
                optElements -= minElements
            else:
                raise TypeError("cannot multiply 'ParserElement' and ('%s','%s') objects", type(other[0]),type(other[1]))
        else:
            raise TypeError("cannot multiply 'ParserElement' and '%s' objects", type(other))

        if minElements < 0:
            raise ValueError("cannot multiply ParserElement by negative value")
        if optElements < 0:
            raise ValueError("second tuple value must be greater or equal to first tuple value")
        if minElements == optElements == 0:
            raise ValueError("cannot multiply ParserElement by 0 or (0,0)")

        if (optElements):
            def makeOptionalList(n):
                if n>1:
                    return Optional(self + makeOptionalList(n-1))
                else:
                    return Optional(self)
            if minElements:
                if minElements == 1:
                    ret = self + makeOptionalList(optElements)
                else:
                    ret = And([self]*minElements) + makeOptionalList(optElements)
            else:
                ret = makeOptionalList(optElements)
        else:
            if minElements == 1:
                ret = self
            else:
                ret = And([self]*minElements)
        return ret

    def __rmul__(self, other):
        return self.__mul__(other)

    def __or__(self, other ):
        """Implementation of | operator - returns C{L{MatchFirst}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return MatchFirst( [ self, other ] )

    def __ror__(self, other ):
        """Implementation of | operator when left operand is not a C{L{ParserElement}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return other | self

    def __xor__(self, other ):
        """Implementation of ^ operator - returns C{L{Or}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return Or( [ self, other ] )

    def __rxor__(self, other ):
        """Implementation of ^ operator when left operand is not a C{L{ParserElement}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return other ^ self

    def __and__(self, other ):
        """Implementation of & operator - returns C{L{Each}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return Each( [ self, other ] )

    def __rand__(self, other ):
        """Implementation of & operator when left operand is not a C{L{ParserElement}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return other & self

    def __invert__( self ):
        """Implementation of ~ operator - returns C{L{NotAny}}"""
        return NotAny( self )

    def __call__(self, name):
        """Shortcut for C{L{setResultsName}}, with C{listAllMatches=default}::
             userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
           could be written as::
             userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")
             
           If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
           passed as C{True}.
           """
        return self.setResultsName(name)

    def suppress( self ):
        """Suppresses the output of this C{ParserElement}; useful to keep punctuation from
           cluttering up returned output.
        """
        return Suppress( self )

    def leaveWhitespace( self ):
        """Disables the skipping of whitespace before matching the characters in the
           C{ParserElement}'s defined pattern.  This is normally only used internally by
           the pyparsing module, but may be needed in some whitespace-sensitive grammars.
        """
        self.skipWhitespace = False
        return self

    def setWhitespaceChars( self, chars ):
        """Overrides the default whitespace chars
        """
        self.skipWhitespace = True
        self.whiteChars = chars
        self.copyDefaultWhiteChars = False
        return self

    def parseWithTabs( self ):
        """Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
           Must be called before C{parseString} when the input grammar contains elements that
           match C{<TAB>} characters."""
        self.keepTabs = True
        return self

    def ignore( self, other ):
        """Define expression to be ignored (e.g., comments) while doing pattern
           matching; may be called repeatedly, to define multiple comment or other
           ignorable patterns.
        """
        if isinstance( other, Suppress ):
            if other not in self.ignoreExprs:
                self.ignoreExprs.append( other.copy() )
        else:
            self.ignoreExprs.append( Suppress( other.copy() ) )
        return self

    def setDebugActions( self, startAction, successAction, exceptionAction ):
        """Enable display of debugging messages while doing pattern matching."""
        self.debugActions = (startAction or _defaultStartDebugAction,
                             successAction or _defaultSuccessDebugAction,
                             exceptionAction or _defaultExceptionDebugAction)
        self.debug = True
        return self

    def setDebug( self, flag=True ):
        """Enable display of debugging messages while doing pattern matching.
           Set C{flag} to True to enable, False to disable."""
        if flag:
            self.setDebugActions( _defaultStartDebugAction, _defaultSuccessDebugAction, _defaultExceptionDebugAction )
        else:
            self.debug = False
        return self

    def __str__( self ):
        return self.name

    def __repr__( self ):
        return _ustr(self)

    def streamline( self ):
        self.streamlined = True
        self.strRepr = None
        return self

    def checkRecursion( self, parseElementList ):
        pass

    def validate( self, validateTrace=[] ):
        """Check defined expressions for valid structure, check for infinite recursive definitions."""
        self.checkRecursion( [] )

    def parseFile( self, file_or_filename, parseAll=False ):
        """Execute the parse expression on the given file or filename.
           If a filename is specified (instead of a file object),
           the entire file is opened, read, and closed before parsing.
        """
        try:
            file_contents = file_or_filename.read()
        except AttributeError:
            f = open(file_or_filename, "r")
            file_contents = f.read()
            f.close()
        try:
            return self.parseString(file_contents, parseAll)
        except ParseBaseException as exc:
            if ParserElement.verbose_stacktrace:
                raise
            else:
                # catch and re-raise exception from here, clears out pyparsing internal stack trace
                raise exc

    def __eq__(self,other):
        if isinstance(other, ParserElement):
            return self is other or self.__dict__ == other.__dict__
        elif isinstance(other, basestring):
            try:
                self.parseString(_ustr(other), parseAll=True)
                return True
            except ParseBaseException:
                return False
        else:
            return super(ParserElement,self)==other

    def __ne__(self,other):
        return not (self == other)

    def __hash__(self):
        return hash(id(self))

    def __req__(self,other):
        return self == other

    def __rne__(self,other):
        return not (self == other)


class Token(ParserElement):
    """Abstract C{ParserElement} subclass, for defining atomic matching patterns."""
    def __init__( self ):
        super(Token,self).__init__( savelist=False )

    def setName(self, name):
        s = super(Token,self).setName(name)
        self.errmsg = "Expected " + self.name
        return s


class Empty(Token):
    """An empty token, will always match."""
    def __init__( self ):
        super(Empty,self).__init__()
        self.name = "Empty"
        self.mayReturnEmpty = True
        self.mayIndexError = False


class NoMatch(Token):
    """A token that will never match."""
    def __init__( self ):
        super(NoMatch,self).__init__()
        self.name = "NoMatch"
        self.mayReturnEmpty = True
        self.mayIndexError = False
        self.errmsg = "Unmatchable token"

    def parseImpl( self, instring, loc, doActions=True ):
        raise ParseException(instring, loc, self.errmsg, self)


class Literal(Token):
    """Token to exactly match a specified string."""
    def __init__( self, matchString ):
        super(Literal,self).__init__()
        self.match = matchString
        self.matchLen = len(matchString)
        try:
            self.firstMatchChar = matchString[0]
        except IndexError:
            warnings.warn("null string passed to Literal; use Empty() instead",
                            SyntaxWarning, stacklevel=2)
            self.__class__ = Empty
        self.name = '"%s"' % _ustr(self.match)
        self.errmsg = "Expected " + self.name
        self.mayReturnEmpty = False
        self.mayIndexError = False

    # Performance tuning: this routine gets called a *lot*
    # if this is a single character match string  and the first character matches,
    # short-circuit as quickly as possible, and avoid calling startswith
    #~ @profile
    def parseImpl( self, instring, loc, doActions=True ):
        if (instring[loc] == self.firstMatchChar and
            (self.matchLen==1 or instring.startswith(self.match,loc)) ):
            return loc+self.matchLen, self.match
        raise ParseException(instring, loc, self.errmsg, self)
_L = Literal
ParserElement.literalStringClass = Literal

class Keyword(Token):
    """Token to exactly match a specified string as a keyword, that is, it must be
       immediately followed by a non-keyword character.  Compare with C{L{Literal}}::
         Literal("if") will match the leading C{'if'} in C{'ifAndOnlyIf'}.
         Keyword("if") will not; it will only match the leading C{'if'} in C{'if x=1'}, or C{'if(y==2)'}
       Accepts two optional constructor arguments in addition to the keyword string:
       C{identChars} is a string of characters that would be valid identifier characters,
       defaulting to all alphanumerics + "_" and "$"; C{caseless} allows case-insensitive
       matching, default is C{False}.
    """
    DEFAULT_KEYWORD_CHARS = alphanums+"_$"

    def __init__( self, matchString, identChars=DEFAULT_KEYWORD_CHARS, caseless=False ):
        super(Keyword,self).__init__()
        self.match = matchString
        self.matchLen = len(matchString)
        try:
            self.firstMatchChar = matchString[0]
        except IndexError:
            warnings.warn("null string passed to Keyword; use Empty() instead",
                            SyntaxWarning, stacklevel=2)
        self.name = '"%s"' % self.match
        self.errmsg = "Expected " + self.name
        self.mayReturnEmpty = False
        self.mayIndexError = False
        self.caseless = caseless
        if caseless:
            self.caselessmatch = matchString.upper()
            identChars = identChars.upper()
        self.identChars = set(identChars)

    def parseImpl( self, instring, loc, doActions=True ):
        if self.caseless:
            if ( (instring[ loc:loc+self.matchLen ].upper() == self.caselessmatch) and
                 (loc >= len(instring)-self.matchLen or instring[loc+self.matchLen].upper() not in self.identChars) and
                 (loc == 0 or instring[loc-1].upper() not in self.identChars) ):
                return loc+self.matchLen, self.match
        else:
            if (instring[loc] == self.firstMatchChar and
                (self.matchLen==1 or instring.startswith(self.match,loc)) and
                (loc >= len(instring)-self.matchLen or instring[loc+self.matchLen] not in self.identChars) and
                (loc == 0 or instring[loc-1] not in self.identChars) ):
                return loc+self.matchLen, self.match
        raise ParseException(instring, loc, self.errmsg, self)

    def copy(self):
        c = super(Keyword,self).copy()
        c.identChars = Keyword.DEFAULT_KEYWORD_CHARS
        return c

    def setDefaultKeywordChars( chars ):
        """Overrides the default Keyword chars
        """
        Keyword.DEFAULT_KEYWORD_CHARS = chars
    setDefaultKeywordChars = staticmethod(setDefaultKeywordChars)

class CaselessLiteral(Literal):
    """Token to match a specified string, ignoring case of letters.
       Note: the matched results will always be in the case of the given
       match string, NOT the case of the input text.
    """
    def __init__( self, matchString ):
        super(CaselessLiteral,self).__init__( matchString.upper() )
        # Preserve the defining literal.
        self.returnString = matchString
        self.name = "'%s'" % self.returnString
        self.errmsg = "Expected " + self.name

    def parseImpl( self, instring, loc, doActions=True ):
        if instring[ loc:loc+self.matchLen ].upper() == self.match:
            return loc+self.matchLen, self.returnString
        raise ParseException(instring, loc, self.errmsg, self)

class CaselessKeyword(Keyword):
    def __init__( self, matchString, identChars=Keyword.DEFAULT_KEYWORD_CHARS ):
        super(CaselessKeyword,self).__init__( matchString, identChars, caseless=True )

    def parseImpl( self, instring, loc, doActions=True ):
        if ( (instring[ loc:loc+self.matchLen ].upper() == self.caselessmatch) and
             (loc >= len(instring)-self.matchLen or instring[loc+self.matchLen].upper() not in self.identChars) ):
            return loc+self.matchLen, self.match
        raise ParseException(instring, loc, self.errmsg, self)

class Word(Token):
    """Token for matching words composed of allowed character sets.
       Defined with string containing all allowed initial characters,
       an optional string containing allowed body characters (if omitted,
       defaults to the initial character set), and an optional minimum,
       maximum, and/or exact length.  The default value for C{min} is 1 (a
       minimum value < 1 is not valid); the default values for C{max} and C{exact}
       are 0, meaning no maximum or exact length restriction. An optional
       C{exclude} parameter can list characters that might be found in 
       the input C{bodyChars} string; useful to define a word of all printables
       except for one or two characters, for instance.
    """
    def __init__( self, initChars, bodyChars=None, min=1, max=0, exact=0, asKeyword=False, excludeChars=None ):
        super(Word,self).__init__()
        if excludeChars:
            initChars = ''.join(c for c in initChars if c not in excludeChars)
            if bodyChars:
                bodyChars = ''.join(c for c in bodyChars if c not in excludeChars)
        self.initCharsOrig = initChars
        self.initChars = set(initChars)
        if bodyChars :
            self.bodyCharsOrig = bodyChars
            self.bodyChars = set(bodyChars)
        else:
            self.bodyCharsOrig = initChars
            self.bodyChars = set(initChars)

        self.maxSpecified = max > 0

        if min < 1:
            raise ValueError("cannot specify a minimum length < 1; use Optional(Word()) if zero-length word is permitted")

        self.minLen = min

        if max > 0:
            self.maxLen = max
        else:
            self.maxLen = _MAX_INT

        if exact > 0:
            self.maxLen = exact
            self.minLen = exact

        self.name = _ustr(self)
        self.errmsg = "Expected " + self.name
        self.mayIndexError = False
        self.asKeyword = asKeyword

        if ' ' not in self.initCharsOrig+self.bodyCharsOrig and (min==1 and max==0 and exact==0):
            if self.bodyCharsOrig == self.initCharsOrig:
                self.reString = "[%s]+" % _escapeRegexRangeChars(self.initCharsOrig)
            elif len(self.bodyCharsOrig) == 1:
                self.reString = "%s[%s]*" % \
                                      (re.escape(self.initCharsOrig),
                                      _escapeRegexRangeChars(self.bodyCharsOrig),)
            else:
                self.reString = "[%s][%s]*" % \
                                      (_escapeRegexRangeChars(self.initCharsOrig),
                                      _escapeRegexRangeChars(self.bodyCharsOrig),)
            if self.asKeyword:
                self.reString = r"\b"+self.reString+r"\b"
            try:
                self.re = re.compile( self.reString )
            except:
                self.re = None

    def parseImpl( self, instring, loc, doActions=True ):
        if self.re:
            result = self.re.match(instring,loc)
            if not result:
                raise ParseException(instring, loc, self.errmsg, self)

            loc = result.end()
            return loc, result.group()

        if not(instring[ loc ] in self.initChars):
            raise ParseException(instring, loc, self.errmsg, self)

        start = loc
        loc += 1
        instrlen = len(instring)
        bodychars = self.bodyChars
        maxloc = start + self.maxLen
        maxloc = min( maxloc, instrlen )
        while loc < maxloc and instring[loc] in bodychars:
            loc += 1

        throwException = False
        if loc - start < self.minLen:
            throwException = True
        if self.maxSpecified and loc < instrlen and instring[loc] in bodychars:
            throwException = True
        if self.asKeyword:
            if (start>0 and instring[start-1] in bodychars) or (loc<instrlen and instring[loc] in bodychars):
                throwException = True

        if throwException:
            raise ParseException(instring, loc, self.errmsg, self)

        return loc, instring[start:loc]

    def __str__( self ):
        try:
            return super(Word,self).__str__()
        except:
            pass


        if self.strRepr is None:

            def charsAsStr(s):
                if len(s)>4:
                    return s[:4]+"..."
                else:
                    return s

            if ( self.initCharsOrig != self.bodyCharsOrig ):
                self.strRepr = "W:(%s,%s)" % ( charsAsStr(self.initCharsOrig), charsAsStr(self.bodyCharsOrig) )
            else:
                self.strRepr = "W:(%s)" % charsAsStr(self.initCharsOrig)

        return self.strRepr


class Regex(Token):
    """Token for matching strings that match a given regular expression.
       Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module.
    """
    compiledREtype = type(re.compile("[A-Z]"))
    def __init__( self, pattern, flags=0):
        """The parameters C{pattern} and C{flags} are passed to the C{re.compile()} function as-is. See the Python C{re} module for an explanation of the acceptable patterns and flags."""
        super(Regex,self).__init__()

        if isinstance(pattern, basestring):
            if len(pattern) == 0:
                warnings.warn("null string passed to Regex; use Empty() instead",
                        SyntaxWarning, stacklevel=2)

            self.pattern = pattern
            self.flags = flags

            try:
                self.re = re.compile(self.pattern, self.flags)
                self.reString = self.pattern
            except sre_constants.error:
                warnings.warn("invalid pattern (%s) passed to Regex" % pattern,
                    SyntaxWarning, stacklevel=2)
                raise

        elif isinstance(pattern, Regex.compiledREtype):
            self.re = pattern
            self.pattern = \
            self.reString = str(pattern)
            self.flags = flags
            
        else:
            raise ValueError("Regex may only be constructed with a string or a compiled RE object")

        self.name = _ustr(self)
        self.errmsg = "Expected " + self.name
        self.mayIndexError = False
        self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        result = self.re.match(instring,loc)
        if not result:
            raise ParseException(instring, loc, self.errmsg, self)

        loc = result.end()
        d = result.groupdict()
        ret = ParseResults(result.group())
        if d:
            for k in d:
                ret[k] = d[k]
        return loc,ret

    def __str__( self ):
        try:
            return super(Regex,self).__str__()
        except:
            pass

        if self.strRepr is None:
            self.strRepr = "Re:(%s)" % repr(self.pattern)

        return self.strRepr


class QuotedString(Token):
    """Token for matching strings that are delimited by quoting characters.
    """
    def __init__( self, quoteChar, escChar=None, escQuote=None, multiline=False, unquoteResults=True, endQuoteChar=None):
        """
           Defined with the following parameters:
            - quoteChar - string of one or more characters defining the quote delimiting string
            - escChar - character to escape quotes, typically backslash (default=None)
            - escQuote - special quote sequence to escape an embedded quote string (such as SQL's "" to escape an embedded ") (default=None)
            - multiline - boolean indicating whether quotes can span multiple lines (default=C{False})
            - unquoteResults - boolean indicating whether the matched text should be unquoted (default=C{True})
            - endQuoteChar - string of one or more characters defining the end of the quote delimited string (default=C{None} => same as quoteChar)
        """
        super(QuotedString,self).__init__()

        # remove white space from quote chars - wont work anyway
        quoteChar = quoteChar.strip()
        if len(quoteChar) == 0:
            warnings.warn("quoteChar cannot be the empty string",SyntaxWarning,stacklevel=2)
            raise SyntaxError()

        if endQuoteChar is None:
            endQuoteChar = quoteChar
        else:
            endQuoteChar = endQuoteChar.strip()
            if len(endQuoteChar) == 0:
                warnings.warn("endQuoteChar cannot be the empty string",SyntaxWarning,stacklevel=2)
                raise SyntaxError()

        self.quoteChar = quoteChar
        self.quoteCharLen = len(quoteChar)
        self.firstQuoteChar = quoteChar[0]
        self.endQuoteChar = endQuoteChar
        self.endQuoteCharLen = len(endQuoteChar)
        self.escChar = escChar
        self.escQuote = escQuote
        self.unquoteResults = unquoteResults

        if multiline:
            self.flags = re.MULTILINE | re.DOTALL
            self.pattern = r'%s(?:[^%s%s]' % \
                ( re.escape(self.quoteChar),
                  _escapeRegexRangeChars(self.endQuoteChar[0]),
                  (escChar is not None and _escapeRegexRangeChars(escChar) or '') )
        else:
            self.flags = 0
            self.pattern = r'%s(?:[^%s\n\r%s]' % \
                ( re.escape(self.quoteChar),
                  _escapeRegexRangeChars(self.endQuoteChar[0]),
                  (escChar is not None and _escapeRegexRangeChars(escChar) or '') )
        if len(self.endQuoteChar) > 1:
            self.pattern += (
                '|(?:' + ')|(?:'.join("%s[^%s]" % (re.escape(self.endQuoteChar[:i]),
                                               _escapeRegexRangeChars(self.endQuoteChar[i]))
                                    for i in range(len(self.endQuoteChar)-1,0,-1)) + ')'
                )
        if escQuote:
            self.pattern += (r'|(?:%s)' % re.escape(escQuote))
        if escChar:
            self.pattern += (r'|(?:%s.)' % re.escape(escChar))
            charset = ''.join(set(self.quoteChar[0]+self.endQuoteChar[0])).replace('^',r'\^').replace('-',r'\-')
            self.escCharReplacePattern = re.escape(self.escChar)+("([%s])" % charset)
        self.pattern += (r')*%s' % re.escape(self.endQuoteChar))

        try:
            self.re = re.compile(self.pattern, self.flags)
            self.reString = self.pattern
        except sre_constants.error:
            warnings.warn("invalid pattern (%s) passed to Regex" % self.pattern,
                SyntaxWarning, stacklevel=2)
            raise

        self.name = _ustr(self)
        self.errmsg = "Expected " + self.name
        self.mayIndexError = False
        self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        result = instring[loc] == self.firstQuoteChar and self.re.match(instring,loc) or None
        if not result:
            raise ParseException(instring, loc, self.errmsg, self)

        loc = result.end()
        ret = result.group()

        if self.unquoteResults:

            # strip off quotes
            ret = ret[self.quoteCharLen:-self.endQuoteCharLen]

            if isinstance(ret,basestring):
                # replace escaped characters
                if self.escChar:
                    ret = re.sub(self.escCharReplacePattern,"\g<1>",ret)

                # replace escaped quotes
                if self.escQuote:
                    ret = ret.replace(self.escQuote, self.endQuoteChar)

        return loc, ret

    def __str__( self ):
        try:
            return super(QuotedString,self).__str__()
        except:
            pass

        if self.strRepr is None:
            self.strRepr = "quoted string, starting with %s ending with %s" % (self.quoteChar, self.endQuoteChar)

        return self.strRepr


class CharsNotIn(Token):
    """Token for matching words composed of characters *not* in a given set.
       Defined with string containing all disallowed characters, and an optional
       minimum, maximum, and/or exact length.  The default value for C{min} is 1 (a
       minimum value < 1 is not valid); the default values for C{max} and C{exact}
       are 0, meaning no maximum or exact length restriction.
    """
    def __init__( self, notChars, min=1, max=0, exact=0 ):
        super(CharsNotIn,self).__init__()
        self.skipWhitespace = False
        self.notChars = notChars

        if min < 1:
            raise ValueError("cannot specify a minimum length < 1; use Optional(CharsNotIn()) if zero-length char group is permitted")

        self.minLen = min

        if max > 0:
            self.maxLen = max
        else:
            self.maxLen = _MAX_INT

        if exact > 0:
            self.maxLen = exact
            self.minLen = exact

        self.name = _ustr(self)
        self.errmsg = "Expected " + self.name
        self.mayReturnEmpty = ( self.minLen == 0 )
        self.mayIndexError = False

    def parseImpl( self, instring, loc, doActions=True ):
        if instring[loc] in self.notChars:
            raise ParseException(instring, loc, self.errmsg, self)

        start = loc
        loc += 1
        notchars = self.notChars
        maxlen = min( start+self.maxLen, len(instring) )
        while loc < maxlen and \
              (instring[loc] not in notchars):
            loc += 1

        if loc - start < self.minLen:
            raise ParseException(instring, loc, self.errmsg, self)

        return loc, instring[start:loc]

    def __str__( self ):
        try:
            return super(CharsNotIn, self).__str__()
        except:
            pass

        if self.strRepr is None:
            if len(self.notChars) > 4:
                self.strRepr = "!W:(%s...)" % self.notChars[:4]
            else:
                self.strRepr = "!W:(%s)" % self.notChars

        return self.strRepr

class White(Token):
    """Special matching class for matching whitespace.  Normally, whitespace is ignored
       by pyparsing grammars.  This class is included when some whitespace structures
       are significant.  Define with a string containing the whitespace characters to be
       matched; default is C{" \\t\\r\\n"}.  Also takes optional C{min}, C{max}, and C{exact} arguments,
       as defined for the C{L{Word}} class."""
    whiteStrs = {
        " " : "<SPC>",
        "\t": "<TAB>",
        "\n": "<LF>",
        "\r": "<CR>",
        "\f": "<FF>",
        }
    def __init__(self, ws=" \t\r\n", min=1, max=0, exact=0):
        super(White,self).__init__()
        self.matchWhite = ws
        self.setWhitespaceChars( "".join(c for c in self.whiteChars if c not in self.matchWhite) )
        #~ self.leaveWhitespace()
        self.name = ("".join(White.whiteStrs[c] for c in self.matchWhite))
        self.mayReturnEmpty = True
        self.errmsg = "Expected " + self.name

        self.minLen = min

        if max > 0:
            self.maxLen = max
        else:
            self.maxLen = _MAX_INT

        if exact > 0:
            self.maxLen = exact
            self.minLen = exact

    def parseImpl( self, instring, loc, doActions=True ):
        if not(instring[ loc ] in self.matchWhite):
            raise ParseException(instring, loc, self.errmsg, self)
        start = loc
        loc += 1
        maxloc = start + self.maxLen
        maxloc = min( maxloc, len(instring) )
        while loc < maxloc and instring[loc] in self.matchWhite:
            loc += 1

        if loc - start < self.minLen:
            raise ParseException(instring, loc, self.errmsg, self)

        return loc, instring[start:loc]


class _PositionToken(Token):
    def __init__( self ):
        super(_PositionToken,self).__init__()
        self.name=self.__class__.__name__
        self.mayReturnEmpty = True
        self.mayIndexError = False

class GoToColumn(_PositionToken):
    """Token to advance to a specific column of input text; useful for tabular report scraping."""
    def __init__( self, colno ):
        super(GoToColumn,self).__init__()
        self.col = colno

    def preParse( self, instring, loc ):
        if col(loc,instring) != self.col:
            instrlen = len(instring)
            if self.ignoreExprs:
                loc = self._skipIgnorables( instring, loc )
            while loc < instrlen and instring[loc].isspace() and col( loc, instring ) != self.col :
                loc += 1
        return loc

    def parseImpl( self, instring, loc, doActions=True ):
        thiscol = col( loc, instring )
        if thiscol > self.col:
            raise ParseException( instring, loc, "Text not in expected column", self )
        newloc = loc + self.col - thiscol
        ret = instring[ loc: newloc ]
        return newloc, ret

class LineStart(_PositionToken):
    """Matches if current position is at the beginning of a line within the parse string"""
    def __init__( self ):
        super(LineStart,self).__init__()
        self.setWhitespaceChars( ParserElement.DEFAULT_WHITE_CHARS.replace("\n","") )
        self.errmsg = "Expected start of line"

    def preParse( self, instring, loc ):
        preloc = super(LineStart,self).preParse(instring,loc)
        if instring[preloc] == "\n":
            loc += 1
        return loc

    def parseImpl( self, instring, loc, doActions=True ):
        if not( loc==0 or
            (loc == self.preParse( instring, 0 )) or
            (instring[loc-1] == "\n") ): #col(loc, instring) != 1:
            raise ParseException(instring, loc, self.errmsg, self)
        return loc, []

class LineEnd(_PositionToken):
    """Matches if current position is at the end of a line within the parse string"""
    def __init__( self ):
        super(LineEnd,self).__init__()
        self.setWhitespaceChars( ParserElement.DEFAULT_WHITE_CHARS.replace("\n","") )
        self.errmsg = "Expected end of line"

    def parseImpl( self, instring, loc, doActions=True ):
        if loc<len(instring):
            if instring[loc] == "\n":
                return loc+1, "\n"
            else:
                raise ParseException(instring, loc, self.errmsg, self)
        elif loc == len(instring):
            return loc+1, []
        else:
            raise ParseException(instring, loc, self.errmsg, self)

class StringStart(_PositionToken):
    """Matches if current position is at the beginning of the parse string"""
    def __init__( self ):
        super(StringStart,self).__init__()
        self.errmsg = "Expected start of text"

    def parseImpl( self, instring, loc, doActions=True ):
        if loc != 0:
            # see if entire string up to here is just whitespace and ignoreables
            if loc != self.preParse( instring, 0 ):
                raise ParseException(instring, loc, self.errmsg, self)
        return loc, []

class StringEnd(_PositionToken):
    """Matches if current position is at the end of the parse string"""
    def __init__( self ):
        super(StringEnd,self).__init__()
        self.errmsg = "Expected end of text"

    def parseImpl( self, instring, loc, doActions=True ):
        if loc < len(instring):
            raise ParseException(instring, loc, self.errmsg, self)
        elif loc == len(instring):
            return loc+1, []
        elif loc > len(instring):
            return loc, []
        else:
            raise ParseException(instring, loc, self.errmsg, self)

class WordStart(_PositionToken):
    """Matches if the current position is at the beginning of a Word, and
       is not preceded by any character in a given set of C{wordChars}
       (default=C{printables}). To emulate the C{\b} behavior of regular expressions,
       use C{WordStart(alphanums)}. C{WordStart} will also match at the beginning of
       the string being parsed, or at the beginning of a line.
    """
    def __init__(self, wordChars = printables):
        super(WordStart,self).__init__()
        self.wordChars = set(wordChars)
        self.errmsg = "Not at the start of a word"

    def parseImpl(self, instring, loc, doActions=True ):
        if loc != 0:
            if (instring[loc-1] in self.wordChars or
                instring[loc] not in self.wordChars):
                raise ParseException(instring, loc, self.errmsg, self)
        return loc, []

class WordEnd(_PositionToken):
    """Matches if the current position is at the end of a Word, and
       is not followed by any character in a given set of C{wordChars}
       (default=C{printables}). To emulate the C{\b} behavior of regular expressions,
       use C{WordEnd(alphanums)}. C{WordEnd} will also match at the end of
       the string being parsed, or at the end of a line.
    """
    def __init__(self, wordChars = printables):
        super(WordEnd,self).__init__()
        self.wordChars = set(wordChars)
        self.skipWhitespace = False
        self.errmsg = "Not at the end of a word"

    def parseImpl(self, instring, loc, doActions=True ):
        instrlen = len(instring)
        if instrlen>0 and loc<instrlen:
            if (instring[loc] in self.wordChars or
                instring[loc-1] not in self.wordChars):
                raise ParseException(instring, loc, self.errmsg, self)
        return loc, []


class ParseExpression(ParserElement):
    """Abstract subclass of ParserElement, for combining and post-processing parsed tokens."""
    def __init__( self, exprs, savelist = False ):
        super(ParseExpression,self).__init__(savelist)
        if isinstance( exprs, list ):
            self.exprs = exprs
        elif isinstance( exprs, basestring ):
            self.exprs = [ Literal( exprs ) ]
        else:
            try:
                self.exprs = list( exprs )
            except TypeError:
                self.exprs = [ exprs ]
        self.callPreparse = False

    def __getitem__( self, i ):
        return self.exprs[i]

    def append( self, other ):
        self.exprs.append( other )
        self.strRepr = None
        return self

    def leaveWhitespace( self ):
        """Extends C{leaveWhitespace} defined in base class, and also invokes C{leaveWhitespace} on
           all contained expressions."""
        self.skipWhitespace = False
        self.exprs = [ e.copy() for e in self.exprs ]
        for e in self.exprs:
            e.leaveWhitespace()
        return self

    def ignore( self, other ):
        if isinstance( other, Suppress ):
            if other not in self.ignoreExprs:
                super( ParseExpression, self).ignore( other )
                for e in self.exprs:
                    e.ignore( self.ignoreExprs[-1] )
        else:
            super( ParseExpression, self).ignore( other )
            for e in self.exprs:
                e.ignore( self.ignoreExprs[-1] )
        return self

    def __str__( self ):
        try:
            return super(ParseExpression,self).__str__()
        except:
            pass

        if self.strRepr is None:
            self.strRepr = "%s:(%s)" % ( self.__class__.__name__, _ustr(self.exprs) )
        return self.strRepr

    def streamline( self ):
        super(ParseExpression,self).streamline()

        for e in self.exprs:
            e.streamline()

        # collapse nested And's of the form And( And( And( a,b), c), d) to And( a,b,c,d )
        # but only if there are no parse actions or resultsNames on the nested And's
        # (likewise for Or's and MatchFirst's)
        if ( len(self.exprs) == 2 ):
            other = self.exprs[0]
            if ( isinstance( other, self.__class__ ) and
                  not(other.parseAction) and
                  other.resultsName is None and
                  not other.debug ):
                self.exprs = other.exprs[:] + [ self.exprs[1] ]
                self.strRepr = None
                self.mayReturnEmpty |= other.mayReturnEmpty
                self.mayIndexError  |= other.mayIndexError

            other = self.exprs[-1]
            if ( isinstance( other, self.__class__ ) and
                  not(other.parseAction) and
                  other.resultsName is None and
                  not other.debug ):
                self.exprs = self.exprs[:-1] + other.exprs[:]
                self.strRepr = None
                self.mayReturnEmpty |= other.mayReturnEmpty
                self.mayIndexError  |= other.mayIndexError

        return self

    def setResultsName( self, name, listAllMatches=False ):
        ret = super(ParseExpression,self).setResultsName(name,listAllMatches)
        return ret

    def validate( self, validateTrace=[] ):
        tmp = validateTrace[:]+[self]
        for e in self.exprs:
            e.validate(tmp)
        self.checkRecursion( [] )
        
    def copy(self):
        ret = super(ParseExpression,self).copy()
        ret.exprs = [e.copy() for e in self.exprs]
        return ret

class And(ParseExpression):
    """Requires all given C{ParseExpression}s to be found in the given order.
       Expressions may be separated by whitespace.
       May be constructed using the C{'+'} operator.
    """

    class _ErrorStop(Empty):
        def __init__(self, *args, **kwargs):
            super(And._ErrorStop,self).__init__(*args, **kwargs)
            self.name = '-'
            self.leaveWhitespace()

    def __init__( self, exprs, savelist = True ):
        super(And,self).__init__(exprs, savelist)
        self.mayReturnEmpty = True
        for e in self.exprs:
            if not e.mayReturnEmpty:
                self.mayReturnEmpty = False
                break
        self.setWhitespaceChars( exprs[0].whiteChars )
        self.skipWhitespace = exprs[0].skipWhitespace
        self.callPreparse = True

    def parseImpl( self, instring, loc, doActions=True ):
        # pass False as last arg to _parse for first element, since we already
        # pre-parsed the string as part of our And pre-parsing
        loc, resultlist = self.exprs[0]._parse( instring, loc, doActions, callPreParse=False )
        errorStop = False
        for e in self.exprs[1:]:
            if isinstance(e, And._ErrorStop):
                errorStop = True
                continue
            if errorStop:
                try:
                    loc, exprtokens = e._parse( instring, loc, doActions )
                except ParseSyntaxException:
                    raise
                except ParseBaseException as pe:
                    pe.__traceback__ = None
                    raise ParseSyntaxException(pe)
                except IndexError:
                    raise ParseSyntaxException( ParseException(instring, len(instring), self.errmsg, self) )
            else:
                loc, exprtokens = e._parse( instring, loc, doActions )
            if exprtokens or exprtokens.keys():
                resultlist += exprtokens
        return loc, resultlist

    def __iadd__(self, other ):
        if isinstance( other, basestring ):
            other = Literal( other )
        return self.append( other ) #And( [ self, other ] )

    def checkRecursion( self, parseElementList ):
        subRecCheckList = parseElementList[:] + [ self ]
        for e in self.exprs:
            e.checkRecursion( subRecCheckList )
            if not e.mayReturnEmpty:
                break

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "{" + " ".join(_ustr(e) for e in self.exprs) + "}"

        return self.strRepr


class Or(ParseExpression):
    """Requires that at least one C{ParseExpression} is found.
       If two expressions match, the expression that matches the longest string will be used.
       May be constructed using the C{'^'} operator.
    """
    def __init__( self, exprs, savelist = False ):
        super(Or,self).__init__(exprs, savelist)
        self.mayReturnEmpty = False
        for e in self.exprs:
            if e.mayReturnEmpty:
                self.mayReturnEmpty = True
                break

    def parseImpl( self, instring, loc, doActions=True ):
        maxExcLoc = -1
        maxMatchLoc = -1
        maxException = None
        for e in self.exprs:
            try:
                loc2 = e.tryParse( instring, loc )
            except ParseException as err:
                err.__traceback__ = None
                if err.loc > maxExcLoc:
                    maxException = err
                    maxExcLoc = err.loc
            except IndexError:
                if len(instring) > maxExcLoc:
                    maxException = ParseException(instring,len(instring),e.errmsg,self)
                    maxExcLoc = len(instring)
            else:
                if loc2 > maxMatchLoc:
                    maxMatchLoc = loc2
                    maxMatchExp = e

        if maxMatchLoc < 0:
            if maxException is not None:
                raise maxException
            else:
                raise ParseException(instring, loc, "no defined alternatives to match", self)

        return maxMatchExp._parse( instring, loc, doActions )

    def __ixor__(self, other ):
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        return self.append( other ) #Or( [ self, other ] )

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "{" + " ^ ".join(_ustr(e) for e in self.exprs) + "}"

        return self.strRepr

    def checkRecursion( self, parseElementList ):
        subRecCheckList = parseElementList[:] + [ self ]
        for e in self.exprs:
            e.checkRecursion( subRecCheckList )


class MatchFirst(ParseExpression):
    """Requires that at least one C{ParseExpression} is found.
       If two expressions match, the first one listed is the one that will match.
       May be constructed using the C{'|'} operator.
    """
    def __init__( self, exprs, savelist = False ):
        super(MatchFirst,self).__init__(exprs, savelist)
        if exprs:
            self.mayReturnEmpty = False
            for e in self.exprs:
                if e.mayReturnEmpty:
                    self.mayReturnEmpty = True
                    break
        else:
            self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        maxExcLoc = -1
        maxException = None
        for e in self.exprs:
            try:
                ret = e._parse( instring, loc, doActions )
                return ret
            except ParseException as err:
                if err.loc > maxExcLoc:
                    maxException = err
                    maxExcLoc = err.loc
            except IndexError:
                if len(instring) > maxExcLoc:
                    maxException = ParseException(instring,len(instring),e.errmsg,self)
                    maxExcLoc = len(instring)

        # only got here if no expression matched, raise exception for match that made it the furthest
        else:
            if maxException is not None:
                raise maxException
            else:
                raise ParseException(instring, loc, "no defined alternatives to match", self)

    def __ior__(self, other ):
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        return self.append( other ) #MatchFirst( [ self, other ] )

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "{" + " | ".join(_ustr(e) for e in self.exprs) + "}"

        return self.strRepr

    def checkRecursion( self, parseElementList ):
        subRecCheckList = parseElementList[:] + [ self ]
        for e in self.exprs:
            e.checkRecursion( subRecCheckList )


class Each(ParseExpression):
    """Requires all given C{ParseExpression}s to be found, but in any order.
       Expressions may be separated by whitespace.
       May be constructed using the C{'&'} operator.
    """
    def __init__( self, exprs, savelist = True ):
        super(Each,self).__init__(exprs, savelist)
        self.mayReturnEmpty = True
        for e in self.exprs:
            if not e.mayReturnEmpty:
                self.mayReturnEmpty = False
                break
        self.skipWhitespace = True
        self.initExprGroups = True

    def parseImpl( self, instring, loc, doActions=True ):
        if self.initExprGroups:
            opt1 = [ e.expr for e in self.exprs if isinstance(e,Optional) ]
            opt2 = [ e for e in self.exprs if e.mayReturnEmpty and e not in opt1 ]
            self.optionals = opt1 + opt2
            self.multioptionals = [ e.expr for e in self.exprs if isinstance(e,ZeroOrMore) ]
            self.multirequired = [ e.expr for e in self.exprs if isinstance(e,OneOrMore) ]
            self.required = [ e for e in self.exprs if not isinstance(e,(Optional,ZeroOrMore,OneOrMore)) ]
            self.required += self.multirequired
            self.initExprGroups = False
        tmpLoc = loc
        tmpReqd = self.required[:]
        tmpOpt  = self.optionals[:]
        matchOrder = []

        keepMatching = True
        while keepMatching:
            tmpExprs = tmpReqd + tmpOpt + self.multioptionals + self.multirequired
            failed = []
            for e in tmpExprs:
                try:
                    tmpLoc = e.tryParse( instring, tmpLoc )
                except ParseException:
                    failed.append(e)
                else:
                    matchOrder.append(e)
                    if e in tmpReqd:
                        tmpReqd.remove(e)
                    elif e in tmpOpt:
                        tmpOpt.remove(e)
            if len(failed) == len(tmpExprs):
                keepMatching = False

        if tmpReqd:
            missing = ", ".join(_ustr(e) for e in tmpReqd)
            raise ParseException(instring,loc,"Missing one or more required elements (%s)" % missing )

        # add any unmatched Optionals, in case they have default values defined
        matchOrder += [e for e in self.exprs if isinstance(e,Optional) and e.expr in tmpOpt]

        resultlist = []
        for e in matchOrder:
            loc,results = e._parse(instring,loc,doActions)
            resultlist.append(results)

        finalResults = ParseResults([])
        for r in resultlist:
            dups = {}
            for k in r.keys():
                if k in finalResults.keys():
                    tmp = ParseResults(finalResults[k])
                    tmp += ParseResults(r[k])
                    dups[k] = tmp
            finalResults += ParseResults(r)
            for k,v in dups.items():
                finalResults[k] = v
        return loc, finalResults

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "{" + " & ".join(_ustr(e) for e in self.exprs) + "}"

        return self.strRepr

    def checkRecursion( self, parseElementList ):
        subRecCheckList = parseElementList[:] + [ self ]
        for e in self.exprs:
            e.checkRecursion( subRecCheckList )


class ParseElementEnhance(ParserElement):
    """Abstract subclass of C{ParserElement}, for combining and post-processing parsed tokens."""
    def __init__( self, expr, savelist=False ):
        super(ParseElementEnhance,self).__init__(savelist)
        if isinstance( expr, basestring ):
            expr = Literal(expr)
        self.expr = expr
        self.strRepr = None
        if expr is not None:
            self.mayIndexError = expr.mayIndexError
            self.mayReturnEmpty = expr.mayReturnEmpty
            self.setWhitespaceChars( expr.whiteChars )
            self.skipWhitespace = expr.skipWhitespace
            self.saveAsList = expr.saveAsList
            self.callPreparse = expr.callPreparse
            self.ignoreExprs.extend(expr.ignoreExprs)

    def parseImpl( self, instring, loc, doActions=True ):
        if self.expr is not None:
            return self.expr._parse( instring, loc, doActions, callPreParse=False )
        else:
            raise ParseException("",loc,self.errmsg,self)

    def leaveWhitespace( self ):
        self.skipWhitespace = False
        self.expr = self.expr.copy()
        if self.expr is not None:
            self.expr.leaveWhitespace()
        return self

    def ignore( self, other ):
        if isinstance( other, Suppress ):
            if other not in self.ignoreExprs:
                super( ParseElementEnhance, self).ignore( other )
                if self.expr is not None:
                    self.expr.ignore( self.ignoreExprs[-1] )
        else:
            super( ParseElementEnhance, self).ignore( other )
            if self.expr is not None:
                self.expr.ignore( self.ignoreExprs[-1] )
        return self

    def streamline( self ):
        super(ParseElementEnhance,self).streamline()
        if self.expr is not None:
            self.expr.streamline()
        return self

    def checkRecursion( self, parseElementList ):
        if self in parseElementList:
            raise RecursiveGrammarException( parseElementList+[self] )
        subRecCheckList = parseElementList[:] + [ self ]
        if self.expr is not None:
            self.expr.checkRecursion( subRecCheckList )

    def validate( self, validateTrace=[] ):
        tmp = validateTrace[:]+[self]
        if self.expr is not None:
            self.expr.validate(tmp)
        self.checkRecursion( [] )

    def __str__( self ):
        try:
            return super(ParseElementEnhance,self).__str__()
        except:
            pass

        if self.strRepr is None and self.expr is not None:
            self.strRepr = "%s:(%s)" % ( self.__class__.__name__, _ustr(self.expr) )
        return self.strRepr


class FollowedBy(ParseElementEnhance):
    """Lookahead matching of the given parse expression.  C{FollowedBy}
    does *not* advance the parsing position within the input string, it only
    verifies that the specified parse expression matches at the current
    position.  C{FollowedBy} always returns a null token list."""
    def __init__( self, expr ):
        super(FollowedBy,self).__init__(expr)
        self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        self.expr.tryParse( instring, loc )
        return loc, []


class NotAny(ParseElementEnhance):
    """Lookahead to disallow matching with the given parse expression.  C{NotAny}
    does *not* advance the parsing position within the input string, it only
    verifies that the specified parse expression does *not* match at the current
    position.  Also, C{NotAny} does *not* skip over leading whitespace. C{NotAny}
    always returns a null token list.  May be constructed using the '~' operator."""
    def __init__( self, expr ):
        super(NotAny,self).__init__(expr)
        #~ self.leaveWhitespace()
        self.skipWhitespace = False  # do NOT use self.leaveWhitespace(), don't want to propagate to exprs
        self.mayReturnEmpty = True
        self.errmsg = "Found unwanted token, "+_ustr(self.expr)

    def parseImpl( self, instring, loc, doActions=True ):
        try:
            self.expr.tryParse( instring, loc )
        except (ParseException,IndexError):
            pass
        else:
            raise ParseException(instring, loc, self.errmsg, self)
        return loc, []

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "~{" + _ustr(self.expr) + "}"

        return self.strRepr


class ZeroOrMore(ParseElementEnhance):
    """Optional repetition of zero or more of the given expression."""
    def __init__( self, expr ):
        super(ZeroOrMore,self).__init__(expr)
        self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        tokens = []
        try:
            loc, tokens = self.expr._parse( instring, loc, doActions, callPreParse=False )
            hasIgnoreExprs = ( len(self.ignoreExprs) > 0 )
            while 1:
                if hasIgnoreExprs:
                    preloc = self._skipIgnorables( instring, loc )
                else:
                    preloc = loc
                loc, tmptokens = self.expr._parse( instring, preloc, doActions )
                if tmptokens or tmptokens.keys():
                    tokens += tmptokens
        except (ParseException,IndexError):
            pass

        return loc, tokens

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "[" + _ustr(self.expr) + "]..."

        return self.strRepr

    def setResultsName( self, name, listAllMatches=False ):
        ret = super(ZeroOrMore,self).setResultsName(name,listAllMatches)
        ret.saveAsList = True
        return ret


class OneOrMore(ParseElementEnhance):
    """Repetition of one or more of the given expression."""
    def parseImpl( self, instring, loc, doActions=True ):
        # must be at least one
        loc, tokens = self.expr._parse( instring, loc, doActions, callPreParse=False )
        try:
            hasIgnoreExprs = ( len(self.ignoreExprs) > 0 )
            while 1:
                if hasIgnoreExprs:
                    preloc = self._skipIgnorables( instring, loc )
                else:
                    preloc = loc
                loc, tmptokens = self.expr._parse( instring, preloc, doActions )
                if tmptokens or tmptokens.keys():
                    tokens += tmptokens
        except (ParseException,IndexError):
            pass

        return loc, tokens

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "{" + _ustr(self.expr) + "}..."

        return self.strRepr

    def setResultsName( self, name, listAllMatches=False ):
        ret = super(OneOrMore,self).setResultsName(name,listAllMatches)
        ret.saveAsList = True
        return ret

class _NullToken(object):
    def __bool__(self):
        return False
    __nonzero__ = __bool__
    def __str__(self):
        return ""

_optionalNotMatched = _NullToken()
class Optional(ParseElementEnhance):
    """Optional matching of the given expression.
       A default return string can also be specified, if the optional expression
       is not found.
    """
    def __init__( self, exprs, default=_optionalNotMatched ):
        super(Optional,self).__init__( exprs, savelist=False )
        self.defaultValue = default
        self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        try:
            loc, tokens = self.expr._parse( instring, loc, doActions, callPreParse=False )
        except (ParseException,IndexError):
            if self.defaultValue is not _optionalNotMatched:
                if self.expr.resultsName:
                    tokens = ParseResults([ self.defaultValue ])
                    tokens[self.expr.resultsName] = self.defaultValue
                else:
                    tokens = [ self.defaultValue ]
            else:
                tokens = []
        return loc, tokens

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "[" + _ustr(self.expr) + "]"

        return self.strRepr


class SkipTo(ParseElementEnhance):
    """Token for skipping over all undefined text until the matched expression is found.
       If C{include} is set to true, the matched expression is also parsed (the skipped text
       and matched expression are returned as a 2-element list).  The C{ignore}
       argument is used to define grammars (typically quoted strings and comments) that
       might contain false matches.
    """
    def __init__( self, other, include=False, ignore=None, failOn=None ):
        super( SkipTo, self ).__init__( other )
        self.ignoreExpr = ignore
        self.mayReturnEmpty = True
        self.mayIndexError = False
        self.includeMatch = include
        self.asList = False
        if failOn is not None and isinstance(failOn, basestring):
            self.failOn = Literal(failOn)
        else:
            self.failOn = failOn
        self.errmsg = "No match found for "+_ustr(self.expr)

    def parseImpl( self, instring, loc, doActions=True ):
        startLoc = loc
        instrlen = len(instring)
        expr = self.expr
        failParse = False
        while loc <= instrlen:
            try:
                if self.failOn:
                    try:
                        self.failOn.tryParse(instring, loc)
                    except ParseBaseException:
                        pass
                    else:
                        failParse = True
                        raise ParseException(instring, loc, "Found expression " + str(self.failOn))
                    failParse = False
                if self.ignoreExpr is not None:
                    while 1:
                        try:
                            loc = self.ignoreExpr.tryParse(instring,loc)
                            # print("found ignoreExpr, advance to", loc)
                        except ParseBaseException:
                            break
                expr._parse( instring, loc, doActions=False, callPreParse=False )
                skipText = instring[startLoc:loc]
                if self.includeMatch:
                    loc,mat = expr._parse(instring,loc,doActions,callPreParse=False)
                    if mat:
                        skipRes = ParseResults( skipText )
                        skipRes += mat
                        return loc, [ skipRes ]
                    else:
                        return loc, [ skipText ]
                else:
                    return loc, [ skipText ]
            except (ParseException,IndexError):
                if failParse:
                    raise
                else:
                    loc += 1
        raise ParseException(instring, loc, self.errmsg, self)

class Forward(ParseElementEnhance):
    """Forward declaration of an expression to be defined later -
       used for recursive grammars, such as algebraic infix notation.
       When the expression is known, it is assigned to the C{Forward} variable using the '<<' operator.

       Note: take care when assigning to C{Forward} not to overlook precedence of operators.
       Specifically, '|' has a lower precedence than '<<', so that::
          fwdExpr << a | b | c
       will actually be evaluated as::
          (fwdExpr << a) | b | c
       thereby leaving b and c out as parseable alternatives.  It is recommended that you
       explicitly group the values inserted into the C{Forward}::
          fwdExpr << (a | b | c)
       Converting to use the '<<=' operator instead will avoid this problem.
    """
    def __init__( self, other=None ):
        super(Forward,self).__init__( other, savelist=False )

    def __ilshift__( self, other ):
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass(other)
        self.expr = other
        self.mayReturnEmpty = other.mayReturnEmpty
        self.strRepr = None
        self.mayIndexError = self.expr.mayIndexError
        self.mayReturnEmpty = self.expr.mayReturnEmpty
        self.setWhitespaceChars( self.expr.whiteChars )
        self.skipWhitespace = self.expr.skipWhitespace
        self.saveAsList = self.expr.saveAsList
        self.ignoreExprs.extend(self.expr.ignoreExprs)
        return self
        
    def __lshift__(self, other):
        warnings.warn("Operator '<<' is deprecated, use '<<=' instead",
                       DeprecationWarning,stacklevel=2)
        self <<= other
        return None
    
    def leaveWhitespace( self ):
        self.skipWhitespace = False
        return self

    def streamline( self ):
        if not self.streamlined:
            self.streamlined = True
            if self.expr is not None:
                self.expr.streamline()
        return self

    def validate( self, validateTrace=[] ):
        if self not in validateTrace:
            tmp = validateTrace[:]+[self]
            if self.expr is not None:
                self.expr.validate(tmp)
        self.checkRecursion([])

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        self._revertClass = self.__class__
        self.__class__ = _ForwardNoRecurse
        try:
            if self.expr is not None:
                retString = _ustr(self.expr)
            else:
                retString = "None"
        finally:
            self.__class__ = self._revertClass
        return self.__class__.__name__ + ": " + retString

    def copy(self):
        if self.expr is not None:
            return super(Forward,self).copy()
        else:
            ret = Forward()
            ret << self
            return ret

class _ForwardNoRecurse(Forward):
    def __str__( self ):
        return "..."

class TokenConverter(ParseElementEnhance):
    """Abstract subclass of C{ParseExpression}, for converting parsed results."""
    def __init__( self, expr, savelist=False ):
        super(TokenConverter,self).__init__( expr )#, savelist )
        self.saveAsList = False

class Upcase(TokenConverter):
    """Converter to upper case all matching tokens."""
    def __init__(self, *args):
        super(Upcase,self).__init__(*args)
        warnings.warn("Upcase class is deprecated, use upcaseTokens parse action instead",
                       DeprecationWarning,stacklevel=2)

    def postParse( self, instring, loc, tokenlist ):
        return list(map( str.upper, tokenlist ))


class Combine(TokenConverter):
    """Converter to concatenate all matching tokens to a single string.
       By default, the matching patterns must also be contiguous in the input string;
       this can be disabled by specifying C{'adjacent=False'} in the constructor.
    """
    def __init__( self, expr, joinString="", adjacent=True ):
        super(Combine,self).__init__( expr )
        # suppress whitespace-stripping in contained parse expressions, but re-enable it on the Combine itself
        if adjacent:
            self.leaveWhitespace()
        self.adjacent = adjacent
        self.skipWhitespace = True
        self.joinString = joinString
        self.callPreparse = True

    def ignore( self, other ):
        if self.adjacent:
            ParserElement.ignore(self, other)
        else:
            super( Combine, self).ignore( other )
        return self

    def postParse( self, instring, loc, tokenlist ):
        retToks = tokenlist.copy()
        del retToks[:]
        retToks += ParseResults([ "".join(tokenlist._asStringList(self.joinString)) ], modal=self.modalResults)

        if self.resultsName and len(retToks.keys())>0:
            return [ retToks ]
        else:
            return retToks

class Group(TokenConverter):
    """Converter to return the matched tokens as a list - useful for returning tokens of C{L{ZeroOrMore}} and C{L{OneOrMore}} expressions."""
    def __init__( self, expr ):
        super(Group,self).__init__( expr )
        self.saveAsList = True

    def postParse( self, instring, loc, tokenlist ):
        return [ tokenlist ]

class Dict(TokenConverter):
    """Converter to return a repetitive expression as a list, but also as a dictionary.
       Each element can also be referenced using the first token in the expression as its key.
       Useful for tabular report scraping when the first column can be used as a item key.
    """
    def __init__( self, exprs ):
        super(Dict,self).__init__( exprs )
        self.saveAsList = True

    def postParse( self, instring, loc, tokenlist ):
        for i,tok in enumerate(tokenlist):
            if len(tok) == 0:
                continue
            ikey = tok[0]
            if isinstance(ikey,int):
                ikey = _ustr(tok[0]).strip()
            if len(tok)==1:
                tokenlist[ikey] = _ParseResultsWithOffset("",i)
            elif len(tok)==2 and not isinstance(tok[1],ParseResults):
                tokenlist[ikey] = _ParseResultsWithOffset(tok[1],i)
            else:
                dictvalue = tok.copy() #ParseResults(i)
                del dictvalue[0]
                if len(dictvalue)!= 1 or (isinstance(dictvalue,ParseResults) and dictvalue.keys()):
                    tokenlist[ikey] = _ParseResultsWithOffset(dictvalue,i)
                else:
                    tokenlist[ikey] = _ParseResultsWithOffset(dictvalue[0],i)

        if self.resultsName:
            return [ tokenlist ]
        else:
            return tokenlist


class Suppress(TokenConverter):
    """Converter for ignoring the results of a parsed expression."""
    def postParse( self, instring, loc, tokenlist ):
        return []

    def suppress( self ):
        return self


class OnlyOnce(object):
    """Wrapper for parse actions, to ensure they are only called once."""
    def __init__(self, methodCall):
        self.callable = _trim_arity(methodCall)
        self.called = False
    def __call__(self,s,l,t):
        if not self.called:
            results = self.callable(s,l,t)
            self.called = True
            return results
        raise ParseException(s,l,"")
    def reset(self):
        self.called = False

def traceParseAction(f):
    """Decorator for debugging parse actions."""
    f = _trim_arity(f)
    def z(*paArgs):
        thisFunc = f.func_name
        s,l,t = paArgs[-3:]
        if len(paArgs)>3:
            thisFunc = paArgs[0].__class__.__name__ + '.' + thisFunc
        sys.stderr.write( ">>entering %s(line: '%s', %d, %s)\n" % (thisFunc,line(l,s),l,t) )
        try:
            ret = f(*paArgs)
        except Exception as exc:
            sys.stderr.write( "<<leaving %s (exception: %s)\n" % (thisFunc,exc) )
            raise
        sys.stderr.write( "<<leaving %s (ret: %s)\n" % (thisFunc,ret) )
        return ret
    try:
        z.__name__ = f.__name__
    except AttributeError:
        pass
    return z

#
# global helpers
#
def delimitedList( expr, delim=",", combine=False ):
    """Helper to define a delimited list of expressions - the delimiter defaults to ','.
       By default, the list elements and delimiters can have intervening whitespace, and
       comments, but this can be overridden by passing C{combine=True} in the constructor.
       If C{combine} is set to C{True}, the matching tokens are returned as a single token
       string, with the delimiters included; otherwise, the matching tokens are returned
       as a list of tokens, with the delimiters suppressed.
    """
    dlName = _ustr(expr)+" ["+_ustr(delim)+" "+_ustr(expr)+"]..."
    if combine:
        return Combine( expr + ZeroOrMore( delim + expr ) ).setName(dlName)
    else:
        return ( expr + ZeroOrMore( Suppress( delim ) + expr ) ).setName(dlName)

def countedArray( expr, intExpr=None ):
    """Helper to define a counted list of expressions.
       This helper defines a pattern of the form::
           integer expr expr expr...
       where the leading integer tells how many expr expressions follow.
       The matched tokens returns the array of expr tokens as a list - the leading count token is suppressed.
    """
    arrayExpr = Forward()
    def countFieldParseAction(s,l,t):
        n = t[0]
        arrayExpr << (n and Group(And([expr]*n)) or Group(empty))
        return []
    if intExpr is None:
        intExpr = Word(nums).setParseAction(lambda t:int(t[0]))
    else:
        intExpr = intExpr.copy()
    intExpr.setName("arrayLen")
    intExpr.addParseAction(countFieldParseAction, callDuringTry=True)
    return ( intExpr + arrayExpr )

def _flatten(L):
    ret = []
    for i in L:
        if isinstance(i,list):
            ret.extend(_flatten(i))
        else:
            ret.append(i)
    return ret

def matchPreviousLiteral(expr):
    """Helper to define an expression that is indirectly defined from
       the tokens matched in a previous expression, that is, it looks
       for a 'repeat' of a previous expression.  For example::
           first = Word(nums)
           second = matchPreviousLiteral(first)
           matchExpr = first + ":" + second
       will match C{"1:1"}, but not C{"1:2"}.  Because this matches a
       previous literal, will also match the leading C{"1:1"} in C{"1:10"}.
       If this is not desired, use C{matchPreviousExpr}.
       Do *not* use with packrat parsing enabled.
    """
    rep = Forward()
    def copyTokenToRepeater(s,l,t):
        if t:
            if len(t) == 1:
                rep << t[0]
            else:
                # flatten t tokens
                tflat = _flatten(t.asList())
                rep << And( [ Literal(tt) for tt in tflat ] )
        else:
            rep << Empty()
    expr.addParseAction(copyTokenToRepeater, callDuringTry=True)
    return rep

def matchPreviousExpr(expr):
    """Helper to define an expression that is indirectly defined from
       the tokens matched in a previous expression, that is, it looks
       for a 'repeat' of a previous expression.  For example::
           first = Word(nums)
           second = matchPreviousExpr(first)
           matchExpr = first + ":" + second
       will match C{"1:1"}, but not C{"1:2"}.  Because this matches by
       expressions, will *not* match the leading C{"1:1"} in C{"1:10"};
       the expressions are evaluated first, and then compared, so
       C{"1"} is compared with C{"10"}.
       Do *not* use with packrat parsing enabled.
    """
    rep = Forward()
    e2 = expr.copy()
    rep << e2
    def copyTokenToRepeater(s,l,t):
        matchTokens = _flatten(t.asList())
        def mustMatchTheseTokens(s,l,t):
            theseTokens = _flatten(t.asList())
            if  theseTokens != matchTokens:
                raise ParseException("",0,"")
        rep.setParseAction( mustMatchTheseTokens, callDuringTry=True )
    expr.addParseAction(copyTokenToRepeater, callDuringTry=True)
    return rep

def _escapeRegexRangeChars(s):
    #~  escape these chars: ^-]
    for c in r"\^-]":
        s = s.replace(c,_bslash+c)
    s = s.replace("\n",r"\n")
    s = s.replace("\t",r"\t")
    return _ustr(s)

def oneOf( strs, caseless=False, useRegex=True ):
    """Helper to quickly define a set of alternative Literals, and makes sure to do
       longest-first testing when there is a conflict, regardless of the input order,
       but returns a C{L{MatchFirst}} for best performance.

       Parameters:
        - strs - a string of space-delimited literals, or a list of string literals
        - caseless - (default=False) - treat all literals as caseless
        - useRegex - (default=True) - as an optimization, will generate a Regex
          object; otherwise, will generate a C{MatchFirst} object (if C{caseless=True}, or
          if creating a C{Regex} raises an exception)
    """
    if caseless:
        isequal = ( lambda a,b: a.upper() == b.upper() )
        masks = ( lambda a,b: b.upper().startswith(a.upper()) )
        parseElementClass = CaselessLiteral
    else:
        isequal = ( lambda a,b: a == b )
        masks = ( lambda a,b: b.startswith(a) )
        parseElementClass = Literal

    if isinstance(strs,(list,tuple)):
        symbols = list(strs[:])
    elif isinstance(strs,basestring):
        symbols = strs.split()
    else:
        warnings.warn("Invalid argument to oneOf, expected string or list",
                SyntaxWarning, stacklevel=2)

    i = 0
    while i < len(symbols)-1:
        cur = symbols[i]
        for j,other in enumerate(symbols[i+1:]):
            if ( isequal(other, cur) ):
                del symbols[i+j+1]
                break
            elif ( masks(cur, other) ):
                del symbols[i+j+1]
                symbols.insert(i,other)
                cur = other
                break
        else:
            i += 1

    if not caseless and useRegex:
        #~ print (strs,"->", "|".join( [ _escapeRegexChars(sym) for sym in symbols] ))
        try:
            if len(symbols)==len("".join(symbols)):
                return Regex( "[%s]" % "".join(_escapeRegexRangeChars(sym) for sym in symbols) )
            else:
                return Regex( "|".join(re.escape(sym) for sym in symbols) )
        except:
            warnings.warn("Exception creating Regex for oneOf, building MatchFirst",
                    SyntaxWarning, stacklevel=2)


    # last resort, just use MatchFirst
    return MatchFirst( [ parseElementClass(sym) for sym in symbols ] )

def dictOf( key, value ):
    """Helper to easily and clearly define a dictionary by specifying the respective patterns
       for the key and value.  Takes care of defining the C{L{Dict}}, C{L{ZeroOrMore}}, and C{L{Group}} tokens
       in the proper order.  The key pattern can include delimiting markers or punctuation,
       as long as they are suppressed, thereby leaving the significant key text.  The value
       pattern can include named results, so that the C{Dict} results can include named token
       fields.
    """
    return Dict( ZeroOrMore( Group ( key + value ) ) )

def originalTextFor(expr, asString=True):
    """Helper to return the original, untokenized text for a given expression.  Useful to
       restore the parsed fields of an HTML start tag into the raw tag text itself, or to
       revert separate tokens with intervening whitespace back to the original matching
       input text. Simpler to use than the parse action C{L{keepOriginalText}}, and does not
       require the inspect module to chase up the call stack.  By default, returns a 
       string containing the original parsed text.  
       
       If the optional C{asString} argument is passed as C{False}, then the return value is a 
       C{L{ParseResults}} containing any results names that were originally matched, and a 
       single token containing the original matched text from the input string.  So if 
       the expression passed to C{L{originalTextFor}} contains expressions with defined
       results names, you must set C{asString} to C{False} if you want to preserve those
       results name values."""
    locMarker = Empty().setParseAction(lambda s,loc,t: loc)
    endlocMarker = locMarker.copy()
    endlocMarker.callPreparse = False
    matchExpr = locMarker("_original_start") + expr + endlocMarker("_original_end")
    if asString:
        extractText = lambda s,l,t: s[t._original_start:t._original_end]
    else:
        def extractText(s,l,t):
            del t[:]
            t.insert(0, s[t._original_start:t._original_end])
            del t["_original_start"]
            del t["_original_end"]
    matchExpr.setParseAction(extractText)
    return matchExpr

def ungroup(expr): 
    """Helper to undo pyparsing's default grouping of And expressions, even
       if all but one are non-empty."""
    return TokenConverter(expr).setParseAction(lambda t:t[0])

# convenience constants for positional expressions
empty       = Empty().setName("empty")
lineStart   = LineStart().setName("lineStart")
lineEnd     = LineEnd().setName("lineEnd")
stringStart = StringStart().setName("stringStart")
stringEnd   = StringEnd().setName("stringEnd")

_escapedPunc = Word( _bslash, r"\[]-*.$+^?()~ ", exact=2 ).setParseAction(lambda s,l,t:t[0][1])
_escapedHexChar = Regex(r"\\0?[xX][0-9a-fA-F]+").setParseAction(lambda s,l,t:unichr(int(t[0].lstrip(r'\0x'),16)))
_escapedOctChar = Regex(r"\\0[0-7]+").setParseAction(lambda s,l,t:unichr(int(t[0][1:],8)))
_singleChar = _escapedPunc | _escapedHexChar | _escapedOctChar | Word(printables, excludeChars=r'\]', exact=1)
_charRange = Group(_singleChar + Suppress("-") + _singleChar)
_reBracketExpr = Literal("[") + Optional("^").setResultsName("negate") + Group( OneOrMore( _charRange | _singleChar ) ).setResultsName("body") + "]"

_expanded = lambda p: (isinstance(p,ParseResults) and ''.join(unichr(c) for c in range(ord(p[0]),ord(p[1])+1)) or p)

def srange(s):
    r"""Helper to easily define string ranges for use in Word construction.  Borrows
       syntax from regexp '[]' string range definitions::
          srange("[0-9]")   -> "0123456789"
          srange("[a-z]")   -> "abcdefghijklmnopqrstuvwxyz"
          srange("[a-z$_]") -> "abcdefghijklmnopqrstuvwxyz$_"
       The input string must be enclosed in []'s, and the returned string is the expanded
       character set joined into a single string.
       The values enclosed in the []'s may be::
          a single character
          an escaped character with a leading backslash (such as \- or \])
          an escaped hex character with a leading '\x' (\x21, which is a '!' character) 
            (\0x## is also supported for backwards compatibility) 
          an escaped octal character with a leading '\0' (\041, which is a '!' character)
          a range of any of the above, separated by a dash ('a-z', etc.)
          any combination of the above ('aeiouy', 'a-zA-Z0-9_$', etc.)
    """
    try:
        return "".join(_expanded(part) for part in _reBracketExpr.parseString(s).body)
    except:
        return ""

def matchOnlyAtCol(n):
    """Helper method for defining parse actions that require matching at a specific
       column in the input text.
    """
    def verifyCol(strg,locn,toks):
        if col(locn,strg) != n:
            raise ParseException(strg,locn,"matched token not at column %d" % n)
    return verifyCol

def replaceWith(replStr):
    """Helper method for common parse actions that simply return a literal value.  Especially
       useful when used with C{L{transformString<ParserElement.transformString>}()}.
    """
    def _replFunc(*args):
        return [replStr]
    return _replFunc

def removeQuotes(s,l,t):
    """Helper parse action for removing quotation marks from parsed quoted strings.
       To use, add this parse action to quoted string using::
         quotedString.setParseAction( removeQuotes )
    """
    return t[0][1:-1]

def upcaseTokens(s,l,t):
    """Helper parse action to convert tokens to upper case."""
    return [ tt.upper() for tt in map(_ustr,t) ]

def downcaseTokens(s,l,t):
    """Helper parse action to convert tokens to lower case."""
    return [ tt.lower() for tt in map(_ustr,t) ]

def keepOriginalText(s,startLoc,t):
    """DEPRECATED - use new helper method C{L{originalTextFor}}.
       Helper parse action to preserve original parsed text,
       overriding any nested parse actions."""
    try:
        endloc = getTokensEndLoc()
    except ParseException:
        raise ParseFatalException("incorrect usage of keepOriginalText - may only be called as a parse action")
    del t[:]
    t += ParseResults(s[startLoc:endloc])
    return t

def getTokensEndLoc():
    """Method to be called from within a parse action to determine the end
       location of the parsed tokens."""
    import inspect
    fstack = inspect.stack()
    try:
        # search up the stack (through intervening argument normalizers) for correct calling routine
        for f in fstack[2:]:
            if f[3] == "_parseNoCache":
                endloc = f[0].f_locals["loc"]
                return endloc
        else:
            raise ParseFatalException("incorrect usage of getTokensEndLoc - may only be called from within a parse action")
    finally:
        del fstack

def _makeTags(tagStr, xml):
    """Internal helper to construct opening and closing tag expressions, given a tag name"""
    if isinstance(tagStr,basestring):
        resname = tagStr
        tagStr = Keyword(tagStr, caseless=not xml)
    else:
        resname = tagStr.name

    tagAttrName = Word(alphas,alphanums+"_-:")
    if (xml):
        tagAttrValue = dblQuotedString.copy().setParseAction( removeQuotes )
        openTag = Suppress("<") + tagStr("tag") + \
                Dict(ZeroOrMore(Group( tagAttrName + Suppress("=") + tagAttrValue ))) + \
                Optional("/",default=[False]).setResultsName("empty").setParseAction(lambda s,l,t:t[0]=='/') + Suppress(">")
    else:
        printablesLessRAbrack = "".join(c for c in printables if c not in ">")
        tagAttrValue = quotedString.copy().setParseAction( removeQuotes ) | Word(printablesLessRAbrack)
        openTag = Suppress("<") + tagStr("tag") + \
                Dict(ZeroOrMore(Group( tagAttrName.setParseAction(downcaseTokens) + \
                Optional( Suppress("=") + tagAttrValue ) ))) + \
                Optional("/",default=[False]).setResultsName("empty").setParseAction(lambda s,l,t:t[0]=='/') + Suppress(">")
    closeTag = Combine(_L("</") + tagStr + ">")

    openTag = openTag.setResultsName("start"+"".join(resname.replace(":"," ").title().split())).setName("<%s>" % tagStr)
    closeTag = closeTag.setResultsName("end"+"".join(resname.replace(":"," ").title().split())).setName("</%s>" % tagStr)
    openTag.tag = resname
    closeTag.tag = resname
    return openTag, closeTag

def makeHTMLTags(tagStr):
    """Helper to construct opening and closing tag expressions for HTML, given a tag name"""
    return _makeTags( tagStr, False )

def makeXMLTags(tagStr):
    """Helper to construct opening and closing tag expressions for XML, given a tag name"""
    return _makeTags( tagStr, True )

def withAttribute(*args,**attrDict):
    """Helper to create a validating parse action to be used with start tags created
       with C{L{makeXMLTags}} or C{L{makeHTMLTags}}. Use C{withAttribute} to qualify a starting tag
       with a required attribute value, to avoid false matches on common tags such as
       C{<TD>} or C{<DIV>}.

       Call C{withAttribute} with a series of attribute names and values. Specify the list
       of filter attributes names and values as:
        - keyword arguments, as in C{(align="right")}, or
        - as an explicit dict with C{**} operator, when an attribute name is also a Python
          reserved word, as in C{**{"class":"Customer", "align":"right"}}
        - a list of name-value tuples, as in ( ("ns1:class", "Customer"), ("ns2:align","right") )
       For attribute names with a namespace prefix, you must use the second form.  Attribute
       names are matched insensitive to upper/lower case.

       To verify that the attribute exists, but without specifying a value, pass
       C{withAttribute.ANY_VALUE} as the value.
       """
    if args:
        attrs = args[:]
    else:
        attrs = attrDict.items()
    attrs = [(k,v) for k,v in attrs]
    def pa(s,l,tokens):
        for attrName,attrValue in attrs:
            if attrName not in tokens:
                raise ParseException(s,l,"no matching attribute " + attrName)
            if attrValue != withAttribute.ANY_VALUE and tokens[attrName] != attrValue:
                raise ParseException(s,l,"attribute '%s' has value '%s', must be '%s'" %
                                            (attrName, tokens[attrName], attrValue))
    return pa
withAttribute.ANY_VALUE = object()

opAssoc = _Constants()
opAssoc.LEFT = object()
opAssoc.RIGHT = object()

def infixNotation( baseExpr, opList, lpar=Suppress('('), rpar=Suppress(')') ):
    """Helper method for constructing grammars of expressions made up of
       operators working in a precedence hierarchy.  Operators may be unary or
       binary, left- or right-associative.  Parse actions can also be attached
       to operator expressions.

       Parameters:
        - baseExpr - expression representing the most basic element for the nested
        - opList - list of tuples, one for each operator precedence level in the
          expression grammar; each tuple is of the form
          (opExpr, numTerms, rightLeftAssoc, parseAction), where:
           - opExpr is the pyparsing expression for the operator;
              may also be a string, which will be converted to a Literal;
              if numTerms is 3, opExpr is a tuple of two expressions, for the
              two operators separating the 3 terms
           - numTerms is the number of terms for this operator (must
              be 1, 2, or 3)
           - rightLeftAssoc is the indicator whether the operator is
              right or left associative, using the pyparsing-defined
              constants C{opAssoc.RIGHT} and C{opAssoc.LEFT}.
           - parseAction is the parse action to be associated with
              expressions matching this operator expression (the
              parse action tuple member may be omitted)
        - lpar - expression for matching left-parentheses (default=Suppress('('))
        - rpar - expression for matching right-parentheses (default=Suppress(')'))
    """
    ret = Forward()
    lastExpr = baseExpr | ( lpar + ret + rpar )
    for i,operDef in enumerate(opList):
        opExpr,arity,rightLeftAssoc,pa = (operDef + (None,))[:4]
        if arity == 3:
            if opExpr is None or len(opExpr) != 2:
                raise ValueError("if numterms=3, opExpr must be a tuple or list of two expressions")
            opExpr1, opExpr2 = opExpr
        thisExpr = Forward()#.setName("expr%d" % i)
        if rightLeftAssoc == opAssoc.LEFT:
            if arity == 1:
                matchExpr = FollowedBy(lastExpr + opExpr) + Group( lastExpr + OneOrMore( opExpr ) )
            elif arity == 2:
                if opExpr is not None:
                    matchExpr = FollowedBy(lastExpr + opExpr + lastExpr) + Group( lastExpr + OneOrMore( opExpr + lastExpr ) )
                else:
                    matchExpr = FollowedBy(lastExpr+lastExpr) + Group( lastExpr + OneOrMore(lastExpr) )
            elif arity == 3:
                matchExpr = FollowedBy(lastExpr + opExpr1 + lastExpr + opExpr2 + lastExpr) + \
                            Group( lastExpr + opExpr1 + lastExpr + opExpr2 + lastExpr )
            else:
                raise ValueError("operator must be unary (1), binary (2), or ternary (3)")
        elif rightLeftAssoc == opAssoc.RIGHT:
            if arity == 1:
                # try to avoid LR with this extra test
                if not isinstance(opExpr, Optional):
                    opExpr = Optional(opExpr)
                matchExpr = FollowedBy(opExpr.expr + thisExpr) + Group( opExpr + thisExpr )
            elif arity == 2:
                if opExpr is not None:
                    matchExpr = FollowedBy(lastExpr + opExpr + thisExpr) + Group( lastExpr + OneOrMore( opExpr + thisExpr ) )
                else:
                    matchExpr = FollowedBy(lastExpr + thisExpr) + Group( lastExpr + OneOrMore( thisExpr ) )
            elif arity == 3:
                matchExpr = FollowedBy(lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr) + \
                            Group( lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr )
            else:
                raise ValueError("operator must be unary (1), binary (2), or ternary (3)")
        else:
            raise ValueError("operator must indicate right or left associativity")
        if pa:
            matchExpr.setParseAction( pa )
        thisExpr << ( matchExpr | lastExpr )
        lastExpr = thisExpr
    ret << lastExpr
    return ret
operatorPrecedence = infixNotation

dblQuotedString = Regex(r'"(?:[^"\n\r\\]|(?:"")|(?:\\x[0-9a-fA-F]+)|(?:\\.))*"').setName("string enclosed in double quotes")
sglQuotedString = Regex(r"'(?:[^'\n\r\\]|(?:'')|(?:\\x[0-9a-fA-F]+)|(?:\\.))*'").setName("string enclosed in single quotes")
quotedString = Regex(r'''(?:"(?:[^"\n\r\\]|(?:"")|(?:\\x[0-9a-fA-F]+)|(?:\\.))*")|(?:'(?:[^'\n\r\\]|(?:'')|(?:\\x[0-9a-fA-F]+)|(?:\\.))*')''').setName("quotedString using single or double quotes")
unicodeString = Combine(_L('u') + quotedString.copy())

def nestedExpr(opener="(", closer=")", content=None, ignoreExpr=quotedString.copy()):
    """Helper method for defining nested lists enclosed in opening and closing
       delimiters ("(" and ")" are the default).

       Parameters:
        - opener - opening character for a nested list (default="("); can also be a pyparsing expression
        - closer - closing character for a nested list (default=")"); can also be a pyparsing expression
        - content - expression for items within the nested lists (default=None)
        - ignoreExpr - expression for ignoring opening and closing delimiters (default=quotedString)

       If an expression is not provided for the content argument, the nested
       expression will capture all whitespace-delimited content between delimiters
       as a list of separate values.

       Use the C{ignoreExpr} argument to define expressions that may contain
       opening or closing characters that should not be treated as opening
       or closing characters for nesting, such as quotedString or a comment
       expression.  Specify multiple expressions using an C{L{Or}} or C{L{MatchFirst}}.
       The default is L{quotedString}, but if no expressions are to be ignored,
       then pass C{None} for this argument.
    """
    if opener == closer:
        raise ValueError("opening and closing strings cannot be the same")
    if content is None:
        if isinstance(opener,basestring) and isinstance(closer,basestring):
            if len(opener) == 1 and len(closer)==1:
                if ignoreExpr is not None:
                    content = (Combine(OneOrMore(~ignoreExpr +
                                    CharsNotIn(opener+closer+ParserElement.DEFAULT_WHITE_CHARS,exact=1))
                                ).setParseAction(lambda t:t[0].strip()))
                else:
                    content = (empty.copy()+CharsNotIn(opener+closer+ParserElement.DEFAULT_WHITE_CHARS
                                ).setParseAction(lambda t:t[0].strip()))
            else:
                if ignoreExpr is not None:
                    content = (Combine(OneOrMore(~ignoreExpr + 
                                    ~Literal(opener) + ~Literal(closer) +
                                    CharsNotIn(ParserElement.DEFAULT_WHITE_CHARS,exact=1))
                                ).setParseAction(lambda t:t[0].strip()))
                else:
                    content = (Combine(OneOrMore(~Literal(opener) + ~Literal(closer) +
                                    CharsNotIn(ParserElement.DEFAULT_WHITE_CHARS,exact=1))
                                ).setParseAction(lambda t:t[0].strip()))
        else:
            raise ValueError("opening and closing arguments must be strings if no content expression is given")
    ret = Forward()
    if ignoreExpr is not None:
        ret << Group( Suppress(opener) + ZeroOrMore( ignoreExpr | ret | content ) + Suppress(closer) )
    else:
        ret << Group( Suppress(opener) + ZeroOrMore( ret | content )  + Suppress(closer) )
    return ret

def indentedBlock(blockStatementExpr, indentStack, indent=True):
    """Helper method for defining space-delimited indentation blocks, such as
       those used to define block statements in Python source code.

       Parameters:
        - blockStatementExpr - expression defining syntax of statement that
            is repeated within the indented block
        - indentStack - list created by caller to manage indentation stack
            (multiple statementWithIndentedBlock expressions within a single grammar
            should share a common indentStack)
        - indent - boolean indicating whether block must be indented beyond the
            the current level; set to False for block of left-most statements
            (default=True)

       A valid block must contain at least one C{blockStatement}.
    """
    def checkPeerIndent(s,l,t):
        if l >= len(s): return
        curCol = col(l,s)
        if curCol != indentStack[-1]:
            if curCol > indentStack[-1]:
                raise ParseFatalException(s,l,"illegal nesting")
            raise ParseException(s,l,"not a peer entry")

    def checkSubIndent(s,l,t):
        curCol = col(l,s)
        if curCol > indentStack[-1]:
            indentStack.append( curCol )
        else:
            raise ParseException(s,l,"not a subentry")

    def checkUnindent(s,l,t):
        if l >= len(s): return
        curCol = col(l,s)
        if not(indentStack and curCol < indentStack[-1] and curCol <= indentStack[-2]):
            raise ParseException(s,l,"not an unindent")
        indentStack.pop()

    NL = OneOrMore(LineEnd().setWhitespaceChars("\t ").suppress())
    INDENT = Empty() + Empty().setParseAction(checkSubIndent)
    PEER   = Empty().setParseAction(checkPeerIndent)
    UNDENT = Empty().setParseAction(checkUnindent)
    if indent:
        smExpr = Group( Optional(NL) +
            #~ FollowedBy(blockStatementExpr) +
            INDENT + (OneOrMore( PEER + Group(blockStatementExpr) + Optional(NL) )) + UNDENT)
    else:
        smExpr = Group( Optional(NL) +
            (OneOrMore( PEER + Group(blockStatementExpr) + Optional(NL) )) )
    blockStatementExpr.ignore(_bslash + LineEnd())
    return smExpr

alphas8bit = srange(r"[\0xc0-\0xd6\0xd8-\0xf6\0xf8-\0xff]")
punc8bit = srange(r"[\0xa1-\0xbf\0xd7\0xf7]")

anyOpenTag,anyCloseTag = makeHTMLTags(Word(alphas,alphanums+"_:"))
commonHTMLEntity = Combine(_L("&") + oneOf("gt lt amp nbsp quot").setResultsName("entity") +";").streamline()
_htmlEntityMap = dict(zip("gt lt amp nbsp quot".split(),'><& "'))
replaceHTMLEntity = lambda t : t.entity in _htmlEntityMap and _htmlEntityMap[t.entity] or None

# it's easy to get these comment structures wrong - they're very common, so may as well make them available
cStyleComment = Regex(r"/\*(?:[^*]*\*+)+?/").setName("C style comment")

htmlComment = Regex(r"<!--[\s\S]*?-->")
restOfLine = Regex(r".*").leaveWhitespace()
dblSlashComment = Regex(r"\/\/(\\\n|.)*").setName("// comment")
cppStyleComment = Regex(r"/(?:\*(?:[^*]*\*+)+?/|/[^\n]*(?:\n[^\n]*)*?(?:(?<!\\)|\Z))").setName("C++ style comment")

javaStyleComment = cppStyleComment
pythonStyleComment = Regex(r"#.*").setName("Python style comment")
_commasepitem = Combine(OneOrMore(Word(printables, excludeChars=',') +
                                  Optional( Word(" \t") +
                                            ~Literal(",") + ~LineEnd() ) ) ).streamline().setName("commaItem")
commaSeparatedList = delimitedList( Optional( quotedString.copy() | _commasepitem, default="") ).setName("commaSeparatedList")


if __name__ == "__main__":

    def test( teststring ):
        try:
            tokens = simpleSQL.parseString( teststring )
            tokenlist = tokens.asList()
            print (teststring + "->"   + str(tokenlist))
            print ("tokens = "         + str(tokens))
            print ("tokens.columns = " + str(tokens.columns))
            print ("tokens.tables = "  + str(tokens.tables))
            print (tokens.asXML("SQL",True))
        except ParseBaseException as err:
            print (teststring + "->")
            print (err.line)
            print (" "*(err.column-1) + "^")
            print (err)
        print()

    selectToken    = CaselessLiteral( "select" )
    fromToken      = CaselessLiteral( "from" )

    ident          = Word( alphas, alphanums + "_$" )
    columnName     = delimitedList( ident, ".", combine=True ).setParseAction( upcaseTokens )
    columnNameList = Group( delimitedList( columnName ) )#.setName("columns")
    tableName      = delimitedList( ident, ".", combine=True ).setParseAction( upcaseTokens )
    tableNameList  = Group( delimitedList( tableName ) )#.setName("tables")
    simpleSQL      = ( selectToken + \
                     ( '*' | columnNameList ).setResultsName( "columns" ) + \
                     fromToken + \
                     tableNameList.setResultsName( "tables" ) )

    test( "SELECT * from XYZZY, ABC" )
    test( "select * from SYS.XYZZY" )
    test( "Select A from Sys.dual" )
    test( "Select AA,BB,CC from Sys.dual" )
    test( "Select A, B, C from Sys.dual" )
    test( "Select A, B, C from Sys.dual" )
    test( "Xelect A, B, C from Sys.dual" )
    test( "Select A, B, C frox Sys.dual" )
    test( "Select" )
    test( "Select ^^^ frox Sys.dual" )
    test( "Select A, B, C from Sys.dual, Table2   " )

########NEW FILE########
__FILENAME__ = VRayProcess
#
# V-Ray/Blender
#
# http://vray.cgdo.ru
#
# Author: Andrey M. Izrantsev (aka bdancer)
# E-Mail: izrantsev@cgdo.ru
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
#


# Python modules
import os
import re
import struct
import socket
import subprocess
import signal
import sys
import tempfile
import time

# V-Ray/Blender modules
import vb25
from vb25.lib import VRaySocket

if sys.platform != 'win32':
    import fcntl


def Quotes(path):
    if sys.platform != 'win32':
        return '"%s"' % (path)
    return path


class VRayProcess():
    # V-Ray process
    process    = None
    exit_ready = None
    params     = None

    # V-Ray command socket
    socket = None

    # Executable parameters
    sceneFile     = None
    imgFile       = None
    showProgress  = None
    progressUseCR = None
    verboseLevel  = None
    cmdMode       = None

    bus = None
    scene = None

    VRayScene    = None
    VRayExporter = None
    VRayDR       = None


    def __init__(self):
        self.socket = VRaySocket()

        self.params = []

        self.verboseLevel = '1'
        self.showProgress = '2'


    def __del__(self):
        pass


    def set_params(self, bus=None, params=None):
        self.bus = bus

        self.VRayScene    = self.scene.vray
        self.VRayExporter = self.VRayScene.exporter
        self.VRayDR       = self.VRayScene.VRayDR

        self.params = []
        self.params.append(vb25.utils.get_vray_standalone_path(self.scene))

        self.params.append('-sceneFile=')
        self.params.append(self.sceneFile)
        self.params.append('-imgFile=')
        self.params.append(self.imgFile)

        if self.VRayExporter.use_progress:
            # We need only progress info
            self.params.append('-verboseLevel=')
            self.params.append('3')

            # Always show progress
            self.params.append('-showProgress=')
            self.params.append('2')

            # Use log line breaks
            self.params.append('-progressUseCR=')
            self.params.append('0')

        else:
            self.params.append('-verboseLevel=')
            self.params.append(self.verboseLevel)
            self.params.append('-showProgress=')
            self.params.append(self.showProgress)

        if self.VRayDR.on:
            if len(self.VRayDR.nodes):
                self.params.append('-distributed=1')
                self.params.append('-portNumber=%i' % self.VRayDR.port)
                self.params.append('-renderhost=%s' % Quotes(';'.join([n.address for n in self.VRayDR.nodes])))
                self.params.append('-include=%s' % Quotes(self.bus['filenames']['DR']['shared_dir'] + os.sep))

        # Setup command mode
        # Disable VFB
        self.params.append('-display=')
        self.params.append('0')

        # Enable command socket
        self.params.append('-cmdMode=')
        self.params.append('1')

        if not self.VRayExporter.autorun:
            vb25.utils.debug(self.scene, "Enable \"Autorun\" option to start V-Ray automatically after export.")
            vb25.utils.debug(self.scene, "Command: %s" % ' '.join(self.params))


    def run(self):
        if not self.VRayExporter.autorun:
            return

        if self.VRayExporter.use_progress:
            self.process = subprocess.Popen(self.params, bufsize=256, stdout=subprocess.PIPE)

            if vb25.utils.PLATFORM != 'win32':
                fd = self.process.stdout.fileno()
                fl = fcntl.fcntl(fd, fcntl.F_GETFL)
                fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)
        else:
            self.process = subprocess.Popen(self.params)

        self.exit_ready = False

        time.sleep(0.25)
        self.socket.connect()


    def is_running(self):
        if self.process is None:
            return False
        if self.process.poll() is None:
            return True
        return False


    def kill(self):
        self.quit()

        if self.is_running():
            self.process.terminate()

        self.process = None


    def get_progress(self):
        msg  = None
        prog = None

        if not self.exit_ready:
            if self.process and self.is_running():
                stdout_lines = None
                try:
                    self.process.stdout.flush()
                    stdout_lines = self.process.stdout.readlines(256)
                except:
                    pass

                if stdout_lines:
                    for stdout_line in stdout_lines:
                        line = stdout_line.decode('ascii').strip()

                        if self.VRayExporter.debug:
                            print(line)

                        if line.find("Building light cache") != -1:
                            msg = "Light cache"
                        elif line.find("Prepass") != -1:
                            prepass_num = line[line.find("Prepass")+7:line.find("of")].strip()
                            msg = "Irradiance map (prepass %s)" % (prepass_num)
                        elif line.find("Rendering image") != -1:
                            msg = "Rendering"
                        elif line.find("Building caustics") != -1:
                            msg = "Caustics"
                        elif line.find("Frame took") != -1:
                            self.exit_ready = True

                        if msg is None:
                            continue

                        p_start = line.find("...: ") + 5
                        p_end   = line.find("%")

                        if p_start != -1 and p_end != -1 and p_end > p_start:
                            p_str = line[p_start:p_end].strip()
                            if len(p_str):
                                prog = float(p_str) / 100.0
                                break

        return msg, prog


    def load_scene(self):
        if not self.sceneFile:
            vb25.utils.vb25.utils.debug(None, "Scene file is not set", error=True)
            return 'Scene file is not set'

        self.socket.send("load %s" % self.sceneFile)

        return None


    def unload_scene(self):
        self.socket.send("unload")
        return None


    def reload_scene(self):
        self.unload_scene()
        self.load_scene()
        return None


    def render(self):
        self.socket.send("render", result=False)
        return None


    def quit(self):
        self.socket.send("stop")
        self.socket.send("quit")
        self.socket.disconnect()
        return None


    def recieve_image(self, progressFile):
        jpeg_image = None
        jpeg_size  = 0
        buff  = []

        if not self.is_running():
            self.exit_ready = True
            return 'V-Ray is not running'

        # Request image
        self.socket.send("getImage 90 1", result=False)

        # Read image stream size
        jpeg_size_bytes = self.socket.recv(4)

        # Check if 'fail' recieved
        if jpeg_size_bytes == b'fail':
            self.socket.recv(3) # Read 'e', 'd', '\0'
            self.exit_ready = True
            return 'getImage failed'

        try:
            # Get stream size in bytes
            jpeg_size = struct.unpack("<L", jpeg_size_bytes)[0]

            # print("JPEG stream size = %i"%(jpeg_size))

            # Read JPEG stream
            jpeg_image = self.socket.recv(jpeg_size)

            # Write stream to file
            open(progressFile, 'wb').write(jpeg_image)
        except:
            return 'JPEG stream recieve fail'

        return None

########NEW FILE########
__FILENAME__ = VRayProxy
#
# V-Ray Python Tools
#
# http://chaosgroup.com
#
# Author: Andrei Izrantcev
# E-Mail: andrei.izrantcev@chaosgroup.com
#
# This program is free software you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
#

import struct
import os
import sys
import zlib

from math import fmod


# Debug stuff
#
USE_DEBUG = False

# VRayProxy constants
#
MVF_GEOMETRY_VOXEL = 1
MVF_PREVIEW_VOXEL  = 2

VoxelFlags = {
    MVF_GEOMETRY_VOXEL : 'MVF_GEOMETRY_VOXEL',
    MVF_PREVIEW_VOXEL  : 'MVF_PREVIEW_VOXEL',
}

#
# CHANNELS
#
VERT_GEOM_CHANNEL        = 0
FACE_TOPO_CHANNEL        = 1
VOXEL_INFO_CHANNEL       = 3
VERT_NORMAL_CHANNEL      = 4
VERT_NORMAL_TOPO_CHANNEL = 5
FACE_INFO_CHANNEL        = 6
VERT_VELOCITY_CHANNEL    = 7
MAYA_INFO_CHANNEL        = 8
POINTCLOUD_INFO_CHANNEL  = 10
POINTCLOUD_GEOM_CHANNEL  = 100
VERT_TEX_CHANNEL0        = 1000
VERT_TEX_TOPO_CHANNEL0   = 2000

ChannelID = {
    VERT_GEOM_CHANNEL        : 'VERT_GEOM_CHANNEL',
    FACE_TOPO_CHANNEL        : 'FACE_TOPO_CHANNEL',
    VOXEL_INFO_CHANNEL       : 'VOXEL_INFO_CHANNEL',
    VERT_NORMAL_CHANNEL      : 'VERT_NORMAL_CHANNEL',
    VERT_NORMAL_TOPO_CHANNEL : 'VERT_NORMAL_TOPO_CHANNEL',
    FACE_INFO_CHANNEL        : 'FACE_INFO_CHANNEL',
    VERT_VELOCITY_CHANNEL    : 'VERT_VELOCITY_CHANNEL',
    MAYA_INFO_CHANNEL        : 'MAYA_INFO_CHANNEL',
    POINTCLOUD_INFO_CHANNEL  : 'POINTCLOUD_INFO_CHANNEL',
    POINTCLOUD_GEOM_CHANNEL  : 'POINTCLOUD_GEOM_CHANNEL',
    VERT_TEX_CHANNEL0        : 'VERT_TEX_CHANNEL0',
    VERT_TEX_TOPO_CHANNEL0   : 'VERT_TEX_TOPO_CHANNEL0',
}


MF_VERT_CHANNEL            =  1
MF_TOPO_CHANNEL            =  2
MF_INFO_CHANNEL            =  4
MF_FACE_CHANNEL            =  8
MF_COMPRESSED              = 16
MF_MAYA_INFO_CHANNEL       = 32
MF_POINTCLOUD_CHANNEL      = 64
MF_POINTCLOUD_INFO_CHANNEL = 28

ChannelFlags = {
    MF_VERT_CHANNEL            : 'MF_VERT_CHANNEL',
    MF_TOPO_CHANNEL            : 'MF_TOPO_CHANNEL',
    MF_INFO_CHANNEL            : 'MF_INFO_CHANNEL',
    MF_FACE_CHANNEL            : 'MF_FACE_CHANNEL',
    MF_COMPRESSED              : 'MF_COMPRESSED',
    MF_MAYA_INFO_CHANNEL       : 'MF_MAYA_INFO_CHANNEL',
    MF_POINTCLOUD_CHANNEL      : 'MF_POINTCLOUD_CHANNEL',
    MF_POINTCLOUD_INFO_CHANNEL : 'MF_POINTCLOUD_INFO_CHANNEL',
}



class MeshFileReader(object):
    meshFile = None

    def report(self, *args):
        if USE_DEBUG:
            print(*args)

    def binRead(self, format, length):
        rawData = self.meshFile.read(length)
        data    = struct.unpack(format, rawData)
        return data



class VoxelChannel(MeshFileReader):
    elementSize  = None
    numElements  = None
    channelID    = None
    depChannelID = None
    flags        = None

    data         = None

    def __init__(self, meshFile):
        self.meshFile = meshFile

    def loadInfo(self):
        self.elementSize  = self.binRead("I", 4)[0]
        self.numElements  = self.binRead("I", 4)[0]
        self.channelID    = self.binRead("H", 2)[0]
        self.depChannelID = self.binRead("H", 2)[0]
        self.flags        = self.binRead("I", 4)[0]

    def printInfo(self):
        self.report("Channel")
        self.report("  elementSize  = %i" % (self.elementSize))
        self.report("  numElements  = %i" % (self.numElements))
        self.report("  channelID    = %s" % (ChannelID[self.channelID] if self.channelID in ChannelID else str(self.channelID)))
        self.report("  depChannelID = %i" % (self.depChannelID))

        flagsList = []
        for key in sorted(ChannelFlags.keys()):
            if key & self.flags:
                flagsList.append(ChannelFlags[key])
        self.report("  flags        = %s" % (", ".join(flagsList)))

    def loadData(self):        
        self.report("Channel Data")

        elementsSize = self.elementSize * self.numElements

        dataSize = elementsSize
        if self.flags & MF_COMPRESSED:
            self.report("  Data is compressed")
            dataSize = self.binRead("I", 4)[0]

        self.report("  Data size = %i" % (dataSize))

        # Load only channels we need
        if self.channelID in [VERT_GEOM_CHANNEL, FACE_TOPO_CHANNEL]:
            channelRawData = self.meshFile.read(dataSize)

            if self.flags & MF_COMPRESSED:
                self.data = zlib.decompressobj().decompress(channelRawData)

                # self.report("  Compressed data:", channelRawData)
                # self.report("  Uncompressed data:", self.data)
                self.report("  Expected / uncompressed size:", elementsSize, len(self.data))
            else:
                self.data = channelRawData
        else:
            self.meshFile.seek(dataSize, os.SEEK_CUR)

    def loadChechsum(self):
        self.report("Channel Checksums")

        for i in range(self.numElements):
            channelCRC  = self.binRead("I", 4)[0]

            self.report("  %i: checksum = %i" % (i, channelCRC))



class VoxelChannels(MeshFileReader):
    channels = None

    def __init__(self, meshFile):
        self.meshFile = meshFile
        self.channels = []
    
    def loadInfo(self, voxelOffset=None):
        self.channelCount = self.binRead("I", 4)[0]

        for i in range(self.channelCount):
            voxelChannel = VoxelChannel(self.meshFile)
            voxelChannel.loadInfo()

            self.channels.append(voxelChannel)

    def printInfo(self):
        self.report("Voxel")
        self.report("  Channels count = %i" % (len(self.channels)))
        
        for channel in self.channels:
            channel.printInfo()

    def loadData(self):
        for channel in self.channels:
            channel.loadData()

    def getChannelByType(self, channelType=VERT_GEOM_CHANNEL):
        for channel in self.channels:
            if channel.channelID == channelType:
                return channel
        return None

    def getFaceTopoChannel(self):
        return self.getChannelByType(FACE_TOPO_CHANNEL)
    
    def getVertGeomChannel(self):
        return self.getChannelByType(VERT_GEOM_CHANNEL)



class MeshVoxel(MeshFileReader):
    fileOffset = None
    bbox       = None
    flags      = None

    channels = None

    def __init__(self, meshFile):
        self.meshFile = meshFile
        self.channels = VoxelChannels(self.meshFile)

    def printInfo(self):
        self.report("Voxel")
        self.report("  fileOffset = %i" % (self.fileOffset))
        self.report("  bbox       = %s" % ("%.2f,%.2f,%.2f; %.2f,%.2f,%.2f" % (self.bbox)))
        self.report("  flags      = %s" % (VoxelFlags[self.flags]))

    def loadData(self):
        self.meshFile.seek(self.fileOffset)

        self.channels.loadInfo()
        self.channels.printInfo()
        self.channels.loadData()

    def chunk(self, input, size):
        return tuple(zip(*([iter(input)]*size)))

    def getFaces(self):
        faceTopoChannel = self.channels.getFaceTopoChannel()
        
        if faceTopoChannel is None:
            return ()
        
        intArray   = struct.unpack("%ii"%(len(faceTopoChannel.data) / 4), faceTopoChannel.data)
        facesArray = self.chunk(intArray, 3)
        
        return facesArray

    def getVertices(self):
        vertexChannel = self.channels.getVertGeomChannel()
        
        if vertexChannel is None:
            return ()

        floatArray  = struct.unpack("%if"%(len(vertexChannel.data) / 4), vertexChannel.data)
        vertexArray = self.chunk(floatArray, 3)
        
        return vertexArray


class VoxelInfo:
    fileOffset = None
    bbox       = None
    flags      = None


class FrameInfo:
    numVoxels = None
    voxels    = None

    def __init__(self):
        self.voxels = []


class MeshFile(MeshFileReader):
    vrayID       = None
    fileVersion  = None
    lookupOffset = None

    frames = None

    def __init__(self, filepath):
        self.meshFile = open(os.path.expanduser(filepath), "rb")
        self.frames = {}


    def readHeader(self):
        self.vrayID = self.binRead("7s", 7)[0][:-1]

        if self.vrayID == b'vrmesh':
            # New format
            self.fileVersion = self.binRead("I", 4)[0]
        else:
            # Old format
            self.meshFile.seek(0)
            self.vrayID = self.binRead("4s", 4)[0][:-1]
            self.fileVersion = 0

        self.lookupOffset = self.binRead("Q", 8)[0]

        self.report("MeshFile:", self.meshFile.name)
        self.report("  fileID       = %s" % self.vrayID)
        self.report("  fileVersion  = 0x%X" % self.fileVersion)
        self.report("  lookupOffset = %i" % self.lookupOffset)


    def readLookUpTable(self):
        def readVoxelInfo():
            vi = VoxelInfo()

            vi.fileOffset = self.binRead("Q", 8)[0]
            vi.bbox       = self.binRead("6f", 24)
            vi.flags      = self.binRead("I", 4)[0]

            return vi

        def readFrameInfo():
            numVoxels  = self.binRead("I", 4)[0]
            if numVoxels == 0:
                return None

            frameInfo = FrameInfo()
            frameInfo.numVoxels = numVoxels

            for v in range(numVoxels):
                frameInfo.voxels.append(readVoxelInfo())

            return frameInfo

        self.meshFile.seek(self.lookupOffset)

        frameCount = 0
        while True:
            fi = readFrameInfo()
            if not fi:
                break
            self.frames[frameCount] = fi
            frameCount += 1

        for frameNumber in self.frames:
            fi = self.frames[frameNumber]

            self.report("Frame %i:" % frameNumber)
            self.report("  numVoxels = %s" % fi.numVoxels)

            for v,vi in enumerate(fi.voxels):
                self.report("  Voxel %i" % v)
                self.report("    fileOffset = %i" % vi.fileOffset)
                self.report("    bbox       = %s" % ("%.2f,%.2f,%.2f; %.2f,%.2f,%.2f" % (vi.bbox)))
                self.report("    flags      = %s" % VoxelFlags[vi.flags])


    def readFile(self):
        self.readHeader()
        self.readLookUpTable()


    def getFrameByType(self, animType, animOffset, speed, frame):
        def clamp(value, value_min, value_max):
            return max(min(value, value_max), value_min)

        animLength = len(self.frames)
        animStart  = 0

        if animType in {'0', 'LOOP'}:
            frame = fmod(animOffset+(frame-animStart)*speed, animLength)
            if frame < 0:
                frame += animLength
            frame += animStart

        elif animType in {'1', 'ONCE'}:
            frame = clamp(animOffset+(frame-animStart)*speed, 0.0, animLength-1)+animStart

        elif animType in {'2', 'PINGPONG'}:
            frame = fmod(animOffset+(frame-animStart)*speed, animLength*2-2) # subtract 2 to remove the duplicate frames
            if frame < 0:
                frame += 2*animLength-2
            if frame >= animLength:
                frame = 2*animLength-2-frame
            frame += animStart*speed

        elif animType in {'3', 'STILL'}:
            frame = clamp(animOffset+animStart, 0.0, animLength-1.0)

        return int(frame)


    def getPreviewVoxel(self, frameInfo):
        for voxel in frameInfo.voxels:
            if voxel.flags == MVF_PREVIEW_VOXEL:
                return voxel
        return None


    def getPreviewMesh(self, animType, animOffset, speed, frame=0):
        frameIndex = self.getFrameByType(animType, animOffset, speed, frame)
        if frameIndex not in self.frames:
            return None

        voxelInfo = self.getPreviewVoxel(self.frames[frameIndex])
        if not voxelInfo:
            return None

        voxel = MeshVoxel(self.meshFile)
        voxel.fileOffset = voxelInfo.fileOffset
        voxel.bbox       = voxelInfo.bbox
        voxel.flags      = voxelInfo.flags

        voxel.loadData()

        faces    = voxel.getFaces()
        vertices = voxel.getVertices()

        return { 'vertices' : vertices, 'faces' : faces }


def main():
    testFile = "~/devel/vrayblender/test-suite/vrmesh/animated_mesh.vrmesh"

    meshFile = MeshFile(testFile)
    meshFile.readFile()

    mesh = meshFile.getPreviewMesh(0)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = VRaySceneParser
#
# V-Ray Python Tools
#
# http://chaosgroup.com
#
# Author: Andrei Izrantcev
# E-Mail: andrei.izrantcev@chaosgroup.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
#

from .pyparsing import Literal, CaselessLiteral, Word, Keyword
from .pyparsing import OneOrMore, ZeroOrMore, Group, Combine, Optional
from .pyparsing import alphas, nums, alphanums, quotedString, delimitedList, quotedString
from .pyparsing import restOfLine, cStyleComment


# Returns parsed description dict
#
def getPluginDesc(s,loc,toks):
    plType  = toks[0][0]
    plName  = toks[0][1]
    plAttrs = toks[0][2]

    attrs = {}
    for plAttr in plAttrs:
        attrs[plAttr[0]] = plAttr[1]

    return {
        "ID" : plType,
        "Name" : plName,
        "Attributes" : attrs,
    }

# Converters
#
to_int    = lambda s,l,t: int(t[0])
to_float  = lambda s,l,t: float(t[0])
to_vector = lambda s,l,t: tuple(t[0])
no_quotes = lambda s,l,t: t[0][1:-1]

# Generic syntax
#
lparen = Literal("(").suppress()
rparen = Literal(")").suppress()
lbrace = Literal("{").suppress()
rbrace = Literal("}").suppress()
equals = Literal("=").suppress()
semi   = Literal(";").suppress()
dot    = Literal(".")
comma  = Literal(",")

# Keywords
#
Color = Keyword("Color").suppress()
AColor = Keyword("AColor").suppress()

# Values
#
nameType = Word(alphanums+"@_")

real    = Combine(Word(nums+"+-", nums) + dot + Optional(Word(nums)) + Optional(CaselessLiteral("E") + Word(nums+"+-",nums))).setParseAction(to_float)
integer = Word(nums+"+-", nums).setParseAction(to_int)

color  = Color + lparen + Group(delimitedList(real)).setParseAction(to_vector) + rparen
acolor = AColor + lparen + Group(delimitedList(real)).setParseAction(to_vector) + rparen

output = nameType + Optional(Word("::") + Word(alphas+"_"))

# Plugin Attribute
#
attrName  = nameType
attrValue = integer ^ real ^ color ^ acolor ^ nameType ^ output ^ quotedString.setParseAction(no_quotes)

pluginAttr = Group(attrName + equals + attrValue + semi)

# Plugin
#
pluginType = Word(alphanums)
pluginName = Word(alphanums+"@_")

pluginDesc = Group(pluginType + pluginName + lbrace + Group(ZeroOrMore(pluginAttr)) + rbrace).setParseAction(getPluginDesc)
pluginDesc.ignore("//"+restOfLine)
pluginDesc.ignore(cStyleComment)

# Scene
#
sceneDesc = OneOrMore(pluginDesc)
sceneDesc.ignore("//"+restOfLine)
sceneDesc.ignore(cStyleComment)

nameParser = ZeroOrMore(Group(pluginType + pluginName + lbrace))
nameParser.ignore("//"+restOfLine)
nameParser.ignore(cStyleComment)


def ParseVrscene(filepath):
    return sceneDesc.parseString(open(filepath, "r").read())


def GetMaterialsNames(filepath):
    materialPluginNames = []
    with open(filepath, "r") as f:
        for l in f:
            result = nameParser.parseString(l)
            if result:
                res = result[0]
                if res[0].startswith("Mtl"):
                    if res[1] == 'MANOMATERIALISSET':
                        continue
                    materialPluginNames.append(res[1])
    return materialPluginNames


if __name__ == '__main__':
    print(GetMaterialsNames("/home/bdancer/devel/vrayblender/test-suite/animation_export_optimization/vrscene/scene_materials.vrscene"))

########NEW FILE########
__FILENAME__ = VRaySocket
#
# V-Ray/Blender
#
# http://vray.cgdo.ru
#
# Author: Andrey M. Izrantsev (aka bdancer)
# E-Mail: izrantsev@cgdo.ru
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
#

# VRay Standalone communication socket

# Python modules
import socket


class VRaySocket():
    socket  = None
    address = "localhost"
    port    = 4368


    def __init__(self, address):
        self.address = address


    def __init__(self):
        pass


    def __del__(self):
        self.disconnect()


    def connect(self):
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.connect((self.address, self.port))
        except socket.error:
            self.socket = None

        if self.socket is None:
            return False

        return None


    def isconnected(self):
        if self.socket is not None:
            return True
        return False


    def disconnect(self):
        if self.socket is None:
            return
        self.socket.close()
        self.socket = None


    def get_result(self):
        res = b''

        while True:
            r = self.socket.recv(1);
            if r == b'\0':
                break
            if r != b'\n':
                res += r;

        return res


    def send(self, cmd, result=True):
        if self.socket is None:
            res = self.connect()
            if res is not None:
                return

        sent_size = None
        sent_res  = None

        try:
            sent_size = self.socket.send(bytes(cmd+'\0', 'ascii'))
            if result:
                sent_res = self.get_result()
        except:
            return None

        return None


    def recv(self, size):
        if self.socket is None:
            res = self.connect()
            if res is not None:
                return None

        b = None
        try:
            b = self.socket.recv(size)
        except:
            pass
        return b

########NEW FILE########
__FILENAME__ = VrmatParser
#
# V-Ray Python Tools
#
# http://chaosgroup.com
#
# Author: Andrei Izrantcev
# E-Mail: andrei.izrantcev@chaosgroup.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
#

from xml.dom import minidom


def GetXMLMaterialsNames(filepath):
    xmldoc = minidom.parse(filepath)

    materialPluginNames = []

    for item in xmldoc.getElementsByTagName('Asset'):
        if item.attributes['type'].value == 'material':
            url = str(item.attributes['url'].value)
            if url.startswith("/"):
                url = url[1:]
            materialPluginNames.append(url)

    return materialPluginNames


if __name__ == '__main__':
    print(GetXMLMaterialsNames("/home/bdancer/devel/vrayblender/bug-reports/andybot_vrmat/vray_mtl_metal1.vrmat"))

########NEW FILE########
__FILENAME__ = nodes
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
import mathutils
import sys

''' vb modules '''
from vb25.uvwgen  import *
from vb25.texture import *
from vb25.plugins import *
from vb25.utils   import *


'''
  NODES
'''
def write_ShaderNodeInvert(bus, node, node_params):
	ofile= bus['files']['textures']
	scene= bus['scene']

	node_tree= bus['ma_nodes']['node_tree']

	if 'Color' not in node_params:
		return None

	tex_name= "TI%s" % node_params['Color']

	ofile.write("\nTexInvert %s {" % tex_name)
	ofile.write("\n\ttexture= %s;" % node_params['Color'])
	ofile.write("\n}\n")

	return tex_name


def write_BRDFDiffuse(bus, name, node, color):
	ofile= bus['files']['materials']
	scene= bus['scene']

	comp_name= "BRDFDiffuse%s" % (name)

	ofile.write("\nBRDFDiffuse %s {" % comp_name)
	ofile.write("\n\tcolor= %s;" % a(scene, color))
	ofile.write("\n}\n")

	return comp_name


def write_ShaderNodeTexture(bus, node, input_params):
	node_tree= bus['ma_nodes']['node_tree']

	if not node.texture:
		return None

	bus['mtex']= {}
	bus['mtex']['mapto']=   'node'
	bus['mtex']['slot']=     None
	bus['mtex']['texture']=  node.texture
	bus['mtex']['factor']=   1.0
	bus['mtex']['name']=     clean_string("NT%sNO%sTE%s" % (node_tree.name,
														   node.name,
														   node.texture.name))

	return write_texture(bus)


def write_ShaderNodeMaterial(bus, node, input_params):
	ma=    bus['material']['material']

	bus['textures']= {}
	bus['material']['material']= node.material

	if not node.material:
		return None

	# Check Toon
	VRayMaterial= node.material.vray
	if VRayMaterial.VolumeVRayToon.use:
		bus['effects']['toon']['effects'].append(
			PLUGINS['SETTINGS']['SettingsEnvironment'].write_VolumeVRayToon_from_material(bus)
		)
		append_unique(bus['effects']['toon']['objects'], bus['node']['object'])

	# Write material textures
	write_material_textures(bus)

	node_name= PLUGINS['BRDF'][node.material.vray.type].write(bus)

	# Add BRDFBump if needed
	node_name= PLUGINS['BRDF']['BRDFBump'].write(bus, base_brdf= node_name)

	bus['material']['material']= ma

	return node_name


def write_ShaderNodeOutput(bus, node, input_params):
	ofile= bus['files']['materials']
	scene= bus['scene']

	ma=    bus['material']['material']

	params= {
		'Color': "",
		'Alpha': "",
	}

	for key in params:
		# Key is mapped in input_params
		if key in input_params:
			params[key]= input_params[key]

		else:
			if key == 'Color':
				c= node.inputs[key].default_value
				params[key]= write_BRDFDiffuse(bus, key, node,
											   mathutils.Color((c[0],c[1],c[2])))

	node_name= get_name(ma, prefix='MA')

	brdf= params['Color']

	if 'Alpha' in input_params or node.inputs['Alpha'].default_value < 1.0:
		brdfs= brdf
		brdf= "%sWithAlpha" % brdfs
		ofile.write("\nBRDFLayered %s {" % brdf)
		ofile.write("\n\tbrdfs= List(%s);" % brdfs)
		if 'Alpha' in input_params:
			ofile.write("\n\ttransparency_tex= %s;" % params['Alpha'])
		else:
			ofile.write("\n\ttransparency= %s;" % a(scene, mathutils.Color([node.inputs[key].default_value]*3)))
		ofile.write("\n\tweights= List(TEDefaultBlend);")
		ofile.write("\n}\n")

	ofile.write("\nMtlSingleBRDF %s {"  % node_name)
	ofile.write("\n\tbrdf= %s;" % brdf)
	ofile.write("\n}\n")

	return node_name


def write_ShaderNodeMixRGB(bus, node, input_params):
	ofile= bus['files']['materials']
	scene= bus['scene']

	node_tree= bus['ma_nodes']['node_tree']

	params= {
		'Color1': "",
		'Color2': "",
		'Fac':    "",
	}

	for key in params:
		# Key is mapped in input_params
		if key in input_params:
			params[key]= input_params[key]

		else:
			if key == 'Color1':
				c= node.inputs[key].default_value
				params[key]= write_BRDFDiffuse(bus, key, node,
											   mathutils.Color((c[0],c[1],c[2])))
			elif key == 'Color2':
				c= node.inputs[key].default_value
				params[key]= write_BRDFDiffuse(bus, key, node,
											   mathutils.Color((c[0],c[1],c[2])))
			elif key == 'Fac':
				params[key]= write_TexAColor(bus, key, node,
											 mathutils.Color([node.inputs[key].default_value]*3))

	node_name = "%s%s" % (get_name(bus['material']['material'], prefix='MA'), get_node_name(node_tree, node))

	ofile.write("\nBRDFLayered %s {" % node_name)
	ofile.write("\n\tbrdfs= List(%s, %s);" % (params['Color2'], params['Color1']))
	ofile.write("\n\tweights= List(%s, TEDefaultBlend);" % params['Fac'])
	ofile.write("\n}\n")

	return node_name



'''
  MATERIAL
'''
def write_shader_node(bus, node_tree, node):
	ofile= bus['files']['materials']
	scene= bus['scene']

	VRayScene=      scene.vray
	VRayExporter=   VRayScene.exporter

	node_params= {}

	for input_socket in node.inputs:
		input_node= connected_node(node_tree, input_socket)

		if not input_node:
			continue

		value= write_shader_node(bus, node_tree, input_node)

		if value is not None:
			node_params[input_socket.name]= value

	if VRayExporter.debug:
		print_dict(scene, "Node \"%s\"" % (node.name), node_params)

	if node.type == 'MIX_RGB':
		return write_ShaderNodeMixRGB(bus, node, node_params)

	elif node.type == 'OUTPUT':
		return write_ShaderNodeOutput(bus, node, node_params)

	elif node.type in {'MATERIAL','MATERIAL_EXT'}:
		return write_ShaderNodeMaterial(bus, node, node_params)

	elif node.type == 'TEXTURE':
		return write_ShaderNodeTexture(bus, node, node_params)

	elif node.type == 'INVERT':
		return write_ShaderNodeInvert(bus, node, node_params)

	else:
		return None


def write_node_material(bus):
	ofile= bus['files']['materials']
	scene= bus['scene']

	ob=    bus['node']['object']
	base=  bus['node']['base']

	ma=    bus['material']['material']

	VRayScene=    scene.vray
	VRayExporter= VRayScene.exporter

	node_tree= ma.node_tree

	output_node= get_output_node(node_tree)

	if output_node:
		if VRayExporter.debug:
			debug(scene, "Processing node material \"%s\":" % (ma.name))

		bus['ma_nodes']= {}
		bus['ma_nodes']['node_tree']= node_tree

		return write_shader_node(bus, node_tree, output_node)

	return bus['defaults']['material']

########NEW FILE########
__FILENAME__ = BakeView
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *


TYPE= 'SETTINGS'
ID=   'BakeView'

NAME= 'Bake'
DESC= "Bake settings."

PARAMS= (
)


def add_properties(rna_pointer):
	class VRayBake(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(VRayBake)

	rna_pointer.VRayBake= PointerProperty(
		name= "Bake",
		type=  VRayBake,
		description= "Texture baking settings"
	)

	VRayBake.use= BoolProperty(
		name= "Bake",
		description= "Bake to texture",
		default= False
	)

	VRayBake.bake_node= StringProperty(
		name= "Object",
		subtype= 'NONE',
		description= "Object to bake"
	)

	VRayBake.dilation= IntProperty(
		name= "Dilation",
		description= "Number of pixels to expand around geometry",
		min= 0,
		max= 1000,
		soft_min= 0,
		soft_max= 100,
		default= 2,
	)

	VRayBake.uvChannel = IntProperty(
		name        = "UV Channel",
		description = "UV channel to use",
		min         = 0,
		max         = 256,
		soft_min    = 0,
		soft_max    = 8,
		default     = 0,
	)

	VRayBake.flip_derivs= BoolProperty(
		name= "Flip derivatives",
		description= "Flip the texture direction derivatives (reverses bump mapping)",
		default= False
	)

	# Bake Tools
	VRayBake.bake_material = StringProperty(
		name = "Material",
		subtype = 'NONE'
	)



def write(bus):
	ofile=  bus['files']['camera']
	scene=  bus['scene']
	camera= bus['camera']

	VRayScene= scene.vray
	VRayBake=  VRayScene.VRayBake

	if VRayBake.use and VRayBake.bake_node:
		bake_node = get_data_by_name(scene, 'objects', VRayBake.bake_node)
		if bake_node:
			ofile.write("\nUVWGenChannel bakeViewUVW {")
			ofile.write("\n\tuvw_transform=Transform(")
			ofile.write("\n\t\tMatrix(")
			ofile.write("\n\t\tVector(1.0,0.0,0.0),")
			ofile.write("\n\t\tVector(0.0,1.0,0.0),")
			ofile.write("\n\t\tVector(0.0,0.0,1.0)")
			ofile.write("\n\t\t),")
			ofile.write("\n\t\tVector(0.0,0.0,0.0)")
			ofile.write("\n\t);")
			ofile.write("\n\tuvw_channel=%i;" % VRayBake.uvChannel)
			ofile.write("\n}\n")

			ofile.write("\nBakeView bakeView {")
			ofile.write("\n\tbake_node=%s;" % get_name(bake_node, prefix='OB'))
			ofile.write("\n\tbake_uvwgen=bakeViewUVW;")
			ofile.write("\n\tdilation=%i;" % VRayBake.dilation)
			ofile.write("\n\tflip_derivs=%i;" % VRayBake.flip_derivs)
			ofile.write("\n}\n")
		else:
			debug(scene, "Bake object not found.", error=True)

########NEW FILE########
__FILENAME__ = BRDFBlinn
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'BRDF'
ID=   'BRDFBlinn'
PID=   7

NAME= 'BRDFBlinn'
UI=   "Glossy"
DESC= "BRDFBlinn."

PARAMS= (
	'color',
	'color_tex',
	'color_tex_mult',
	'transparency',
	'transparency_tex',
	'transparency_tex_mult',
	'cutoff',
	'back_side',
	'trace_reflections',
	'trace_depth',
	'reflect_exit_color',
	'reflect_dim_distance',
	'reflect_dim_distance_on',
	'reflect_dim_distance_falloff',
	'hilightGlossiness',
	'hilightGlossiness_tex',
	'hilightGlossiness_tex_mult',
	'reflectionGlossiness',
	'reflectionGlossiness_tex',
	'reflectionGlossiness_tex_mult',
	'subdivs',
	'glossyAsGI',
	'soften_edge',
	'interpolation_on',
	'imap_min_rate',
	'imap_max_rate',
	'imap_color_thresh',
	'imap_norm_thresh',
	'imap_samples',
	'anisotropy',
	# 'anisotropy_uvwgen',
	'anisotropy_rotation',
	'fix_dark_edges',
)


def add_properties(rna_pointer):
	class BRDFBlinn(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(BRDFBlinn)
	
	rna_pointer.BRDFBlinn= PointerProperty(
		name= "BRDFBlinn",
		type=  BRDFBlinn,
		description= "V-Ray BRDFBlinn settings"
	)

	BRDFBlinn.brdf_type= EnumProperty(
		name= "BRDF type",
		description= "This determines the type of BRDF (the shape of the hilight)",
		items= (
			('PHONG',"Phong","Phong hilight/reflections."),
			('BLINN',"Blinn","Blinn hilight/reflections."),
			('WARD',"Ward","Ward hilight/reflections.")
		),
		default= 'BLINN'
	)

	# color
	BRDFBlinn.color= FloatVectorProperty(
		name= "Color",
		description= "Reflection color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1,1,1)
	)

	# color_tex
	BRDFBlinn.color_tex= StringProperty(
		name= "Color texture",
		description= "",
		default= ""
	)

	BRDFBlinn.map_color_tex= BoolProperty(
		name= "Color texture",
		description= "",
		default= False
	)

	# color_tex_mult
	BRDFBlinn.color_tex_mult= FloatProperty(
		name= "Color texture multiplier",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# transparency
	# BRDFBlinn.transparency= FloatVectorProperty(
	# 	name= "Transparency",
	# 	description= "",
	# 	subtype= 'COLOR',
	# 	min= 0.0,
	# 	max= 1.0,
	# 	soft_min= 0.0,
	# 	soft_max= 1.0,
	# 	default= (0,0,0)
	# )

	BRDFBlinn.transparency= FloatProperty(
		name= "Transparency",
		description= "BRDF transparency",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 0.0
	)

	# transparency_tex
	BRDFBlinn.transparency_tex= StringProperty(
		name= "Transparency",
		description= "",
		default= ""
	)

	BRDFBlinn.map_transparency_tex= BoolProperty(
		name= "transparency tex",
		description= "",
		default= False
	)

	# transparency_tex_mult
	BRDFBlinn.transparency_tex_mult= FloatProperty(
		name= "transparency tex",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# cutoff
	BRDFBlinn.cutoff= FloatProperty(
		name= "Cutoff",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.01
	)

	# back_side
	BRDFBlinn.back_side= BoolProperty(
		name= "Back side",
		description= "",
		default= False
	)

	# trace_reflections
	BRDFBlinn.trace_reflections= BoolProperty(
		name= "Trace reflections",
		description= "",
		default= True
	)

	# trace_depth
	BRDFBlinn.trace_depth= IntProperty(
		name= "Depth",
		description= "The maximum reflection depth (-1 is controlled by the global options)",
		min= -1,
		max= 100,
		soft_min= -1,
		soft_max= 10,
		default= -1
	)

	# reflect_exit_color
	BRDFBlinn.reflect_exit_color= FloatVectorProperty(
		name= "Exit color",
		description= "The color to use when the maximum depth is reached",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0)
	)

	BRDFBlinn.map_reflect_exit_color= BoolProperty(
		name= "reflect exit color",
		description= "The color to use when the maximum depth is reached",
		default= False
	)

	BRDFBlinn.reflect_exit_color_mult= FloatProperty(
		name= "reflect exit color",
		description= "The color to use when the maximum depth is reached",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# reflect_dim_distance
	BRDFBlinn.reflect_dim_distance= FloatProperty(
		name= "Distance",
		description= "How much to dim reflection as length of rays increases",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1e+18
	)

	# reflect_dim_distance_on
	BRDFBlinn.reflect_dim_distance_on= BoolProperty(
		name= "Dim distance",
		description= "True to enable dim distance",
		default= False
	)

	# reflect_dim_distance_falloff
	BRDFBlinn.reflect_dim_distance_falloff= FloatProperty(
		name= "Falloff",
		description= "Fall off for the dim distance",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	# hilightGlossiness
	BRDFBlinn.hilightGlossiness= FloatProperty(
		name= "Hilight",
		description= "",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 1.0
	)

	# hilightGlossiness_tex
	BRDFBlinn.map_hilightGlossiness_tex= BoolProperty(
		name= "hilightGlossiness tex",
		description= "",
		default= False
	)

	# hilightGlossiness_tex_mult
	BRDFBlinn.hilightGlossiness_tex_mult= FloatProperty(
		name= "hilightGlossiness tex mult",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# reflectionGlossiness
	BRDFBlinn.reflectionGlossiness= FloatProperty(
		name= "Glossiness",
		description= "",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 1.0
	)

	# reflectionGlossiness_tex
	BRDFBlinn.map_reflectionGlossiness_tex= BoolProperty(
		name= "reflectionGlossiness tex",
		description= "",
		default= False
	)

	# reflectionGlossiness_tex_mult
	BRDFBlinn.reflectionGlossiness_tex_mult= FloatProperty(
		name= "reflectionGlossiness tex mult",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# subdivs
	BRDFBlinn.subdivs= IntProperty(
		name= "Subdivs",
		description= "",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 8
	)

	# glossyAsGI
	BRDFBlinn.glossyAsGI= EnumProperty(
		name= "Glossy rays as GI",
		description= "Specifies when to treat GI rays as glossy rays (0 - never; 1 - only for rays that are already GI rays; 2 - always",
		items= (
			('ALWAYS',"Always",""),
			('GI',"Only for GI rays",""),
			('NEVER',"Never","")
		),
		default= 'GI'
	)

	# soften_edge
	BRDFBlinn.soften_edge= FloatProperty(
		name= "Soften edge",
		description= "Soften edge of the BRDF at light/shadow transition",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	# interpolation_on
	BRDFBlinn.interpolation_on= BoolProperty(
		name= "Interpolation",
		description= "",
		default= False
	)

	# imap_min_rate
	BRDFBlinn.imap_min_rate= IntProperty(
		name= "Min rate",
		description= "",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= -1
	)

	# imap_max_rate
	BRDFBlinn.imap_max_rate= IntProperty(
		name= "Max rate",
		description= "",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 1
	)

	# imap_color_thresh
	BRDFBlinn.imap_color_thresh= FloatProperty(
		name= "Color thresh",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.25
	)

	# imap_norm_thresh
	BRDFBlinn.imap_norm_thresh= FloatProperty(
		name= "Normal thresh",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.4
	)

	# imap_samples
	BRDFBlinn.imap_samples= IntProperty(
		name= "Samples",
		description= "",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 20
	)

	# anisotropy
	BRDFBlinn.anisotropy= FloatProperty(
		name= "Anisotropy",
		description= "Reflection anisotropy in the range (-1, 1)",
		min= -1.0,
		max=  1.0,
		soft_min= -1.0,
		soft_max=  1.0,
		precision= 3,
		default= 0.0
	)

	BRDFBlinn.map_anisotropy= BoolProperty(
		name= "Anisotropy",
		description= "Reflection anisotropy in the range (-1, 1)",
		default= False
	)

	BRDFBlinn.anisotropy_mult= FloatProperty(
		name= "anisotropy",
		description= "Reflection anisotropy in the range (-1, 1)",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# anisotropy_uvwgen
	
	# anisotropy_rotation
	BRDFBlinn.anisotropy_rotation= FloatProperty(
		name= "Rotation",
		description= "Anisotropy rotation in the range [0, 1]",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 0.0
	)

	BRDFBlinn.map_anisotropy_rotation= BoolProperty(
		name= "anisotropy rotation",
		description= "Anisotropy rotation in the range [0, 1]",
		default= False
	)

	BRDFBlinn.anisotropy_rotation_mult= FloatProperty(
		name= "anisotropy rotation",
		description= "Anisotropy rotation in the range [0, 1]",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# fix_dark_edges
	BRDFBlinn.fix_dark_edges= BoolProperty(
		name= "Fix dark edges",
		description= "true to fix dark edges with glossy reflections; only set this to false for compatibility with older versions",
		default= True
	)



'''
  OUTPUT
'''
def write(bus, VRayBRDF= None, base_name= None):
	BRDF_TYPE= {
		'PHONG': 'BRDFPhong',
		'BLINN': 'BRDFBlinn',
		'WARD':  'BRDFWard',
	}
	GLOSSY_RAYS= {
		'NEVER':  0,
		'GI':     1,
		'ALWAYS': 2,
	}

	ofile= bus['files']['materials']
	scene= bus['scene']

	BRDFBlinn= getattr(VRayBRDF, ID)

	brdf_type= BRDF_TYPE[BRDFBlinn.brdf_type]

	brdf_name= "%s%s%s" % (brdf_type, ID, clean_string(VRayBRDF.name))

	ofile.write("\n%s %s {" % (brdf_type, brdf_name))
	for param in PARAMS:
		if brdf_type == 'BRDFPhong' and param in ('anisotropy', 'anisotropy_rotation'):
			continue
		elif param.endswith('_tex'):
			continue
		elif param == 'transparency':
			value= mathutils.Color([1.0 - BRDFBlinn.transparency]*3)
		elif param == 'glossyAsGI':
			value= GLOSSY_RAYS[BRDFBlinn.glossyAsGI]
		else:
			value= getattr(BRDFBlinn, param)
		ofile.write("\n\t%s= %s;" % (param, a(scene, value)))
	ofile.write("\n}\n")

	return brdf_name



'''
  GUI
'''
def gui(context, layout, BRDFBlinn):
	wide_ui= context.region.width > ui.narrowui

	split= layout.split()
	col= split.column(align=True)
	col.prop(BRDFBlinn, 'color', text="")
	col.prop_search(BRDFBlinn, 'color_tex',
					bpy.data, 'textures',
					text= "")
	if BRDFBlinn.color_tex:
		col.prop(BRDFBlinn, 'color_tex_mult', text="Mult")
	if wide_ui:
		col= split.column(align=True)
	col.prop(BRDFBlinn, 'transparency', text= "Reflection", slider= True)
	col.prop_search(BRDFBlinn, 'transparency_tex',
					bpy.data, 'textures',
					text= "")
	if BRDFBlinn.transparency_tex:
		col.prop(BRDFBlinn, 'transparency_tex_mult', text="Mult")

	layout.separator()

	split= layout.split()
	col= split.column()
	sub= col.column(align=True)
	sub.prop(BRDFBlinn, 'hilightGlossiness', slider= True)
	# sub.prop(BRDFBlinn, 'hilightGlossiness_tex')
	# sub.prop(BRDFBlinn, 'hilightGlossiness_tex_mult')
	sub.prop(BRDFBlinn, 'reflectionGlossiness', slider= True)
	# sub.prop(BRDFBlinn, 'reflectionGlossiness_tex')
	# sub.prop(BRDFBlinn, 'reflectionGlossiness_tex_mult')
	sub.prop(BRDFBlinn, 'subdivs')
	sub.prop(BRDFBlinn, 'trace_depth')
	if wide_ui:
		col= split.column()
	col.prop(BRDFBlinn, 'brdf_type', text="")
	if not BRDFBlinn.brdf_type == 'PHONG':
		sub= col.column(align=True)
		sub.prop(BRDFBlinn, 'anisotropy', slider= True)
		# sub.prop(BRDFBlinn, 'anisotropy_uvwgen')
		sub.prop(BRDFBlinn, 'anisotropy_rotation', slider= True)

	split= layout.split()
	col= split.column()
	col.prop(BRDFBlinn, 'cutoff')
	col.prop(BRDFBlinn, 'back_side')
	col.prop(BRDFBlinn, 'trace_reflections')
	col.prop(BRDFBlinn, 'reflect_exit_color')
	if wide_ui:
		col= split.column()
	col.prop(BRDFBlinn, 'reflect_dim_distance_on')
	if BRDFBlinn.reflect_dim_distance_on:
		col.prop(BRDFBlinn, 'reflect_dim_distance')
		col.prop(BRDFBlinn, 'reflect_dim_distance_falloff')

	split= layout.split()
	col= split.column()
	col.prop(BRDFBlinn, 'glossyAsGI')
	split= layout.split()
	col= split.column()
	col.prop(BRDFBlinn, 'soften_edge')
	if wide_ui:
		col= split.column()
	col.prop(BRDFBlinn, 'fix_dark_edges')

	split= layout.split()
	col= split.column()
	col.prop(BRDFBlinn, 'interpolation_on')
	if BRDFBlinn.interpolation_on:
		split= layout.split()
		col= split.column()
		col.prop(BRDFBlinn, 'imap_min_rate')
		col.prop(BRDFBlinn, 'imap_max_rate')
		col.prop(BRDFBlinn, 'imap_samples')
		if wide_ui:
			col= split.column()
		col.prop(BRDFBlinn, 'imap_color_thresh')
		col.prop(BRDFBlinn, 'imap_norm_thresh')



########NEW FILE########
__FILENAME__ = BRDFBump
'''

  V-Ray/Blender 2.5

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'BRDF'
ID=   'BRDFBump'

NAME= 'Bump'
DESC= "V-Ray bump shader."

PARAMS= (
)

def add_properties(rna_pointer):
	class BRDFBump(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(BRDFBump)

	rna_pointer.BRDFBump= PointerProperty(
		name= "BRDFBump",
		type=  BRDFBump,
		description= "BRDFBump texture slot settings"
	)

	BRDFBump.map_type= EnumProperty(
		name= "Map type",
		description= "Normal map type",
		items= (
			('EXPLICIT', "Explicit Normal",   "."),
			('FROMBUMP', "From Bump",         "."),
			('WORLD',    "Normal (world)",    "."),
			('CAMERA',   "Normal (camera)",   "."),
			('OBJECT',   "Normal (object)",   "."),
			('TANGENT',  "Normal (tangent)" , "."),
			('BUMP',     "Bump",              "."),
		),
		default= 'BUMP'
	)

	BRDFBump.bump_tex_mult= FloatProperty(
		name= "Amount",
		description= "Bump amount",
		min= -100.0,
		max=  100.0,
		soft_min= -0.2,
		soft_max=  0.2,
		precision= 4,
		default= 0.02
	)

	BRDFBump.bump_shadows= BoolProperty(
		name= "Bump shadows",
		description= "Offset the surface shading point, in addition to the normal",
		default= False
	)

	BRDFBump.compute_bump_for_shadows= BoolProperty(
		name= "Transparent bump shadows",
		description= "True to compute bump mapping for shadow rays in case the material is transparent; false to skip the bump map for shadow rays (faster rendering)",
		default= True
	)



def write(bus, base_brdf = None, use_bump = False):
	MAP_TYPE= {
		'EXPLICIT': 6,
		'FROMBUMP': 5,
		'WORLD':    4,
		'CAMERA':   3,
		'OBJECT':   2,
		'TANGENT':  1,
		'BUMP'   :  0,
	}

	ofile = bus['files']['materials']
	scene = bus['scene']

	textures = bus['textures']
	slot     = bus['material'].get('bump_slot' if use_bump else 'normal_slot')
	uvwgen   = 'bump_uvwgen' if use_bump else 'normal_uvwgen'

	# if uvwgen not in bus['material']:
	# 	return base_brdf

	if base_brdf is None:
		base_brdf = bus['brdf']

	if slot and textures.get('bump' if use_bump else 'normal'):
		VRayTexture = slot.texture.vray
		VRaySlot    = slot.texture.vray_slot

		BRDFBump    = VRaySlot.BRDFBump

		# Check if normal mapping requested
		if BRDFBump.map_type == 'BUMP' and not use_bump:
			return base_brdf

		suffix = 'NO'
		mapto  = 'normal'
		if BRDFBump.map_type == 'BUMP': # Bump
			suffix = 'BUMP'
			mapto  = 'bump'

		brdf_name= "BRDFBump_%s_%s" % (base_brdf, suffix)

		ofile.write("\nBRDFBump %s {" % brdf_name)
		ofile.write("\n\tbase_brdf= %s;" % base_brdf)
		ofile.write("\n\tmap_type= %d;" % MAP_TYPE[BRDFBump.map_type])
		ofile.write("\n\tbump_tex_color= %s;" % textures[mapto])
		ofile.write("\n\tbump_tex_float= %s;" % textures[mapto])
		ofile.write("\n\tbump_tex_mult= %s;" % a(scene,BRDFBump.bump_tex_mult))
		if uvwgen in bus['material']:
		  ofile.write("\n\tnormal_uvwgen= %s;" % bus['material'][uvwgen])
		ofile.write("\n\tbump_shadows= %d;" % BRDFBump.bump_shadows)
		ofile.write("\n\tcompute_bump_for_shadows= %d;" % BRDFBump.compute_bump_for_shadows)
		ofile.write("\n}\n")

		return brdf_name

	return base_brdf



def influence(context, layout, slot):
	wide_ui= context.region.width > ui.narrowui

	VRaySlot= slot.texture.vray_slot
	BRDFBump= VRaySlot.BRDFBump

	layout.separator()

	layout.label(text="Bump / Normal:")

	split= layout.split()
	col= split.column()
	row= col.row(align=True)
	row.prop(VRaySlot, 'map_normal', text="")
	sub= row.row(align=True)
	sub.active= VRaySlot.map_normal
	sub.prop(VRaySlot, 'normal_mult', slider=True, text="Normal")
	sub.prop(VRaySlot, 'map_normal_invert', text="")

	if wide_ui:
		col= split.column()

	col.active= VRaySlot.map_normal
	col.prop(BRDFBump, 'map_type', text= "Type")
	col.prop(BRDFBump, 'bump_tex_mult', slider= True)
	col.prop(BRDFBump, 'bump_shadows')
	col.prop(BRDFBump, 'compute_bump_for_shadows')


def gui():
	pass


def draw():
	pass

########NEW FILE########
__FILENAME__ = BRDFCarPaint
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'BRDF'
ID=   'BRDFCarPaint'
PID=   4
MAIN_BRDF= True

NAME= 'BRDFCarPaint'
UI=   "Car"
DESC= "BRDFCarPaint."


PARAMS= (
	'base_color',
	'base_reflection',
	'base_glossiness',
	'flake_color',
	'flake_glossiness',
	'flake_orientation',
	'flake_density',
	'flake_scale',
	'flake_size',
	'flake_map_size',
	'flake_filtering_mode',
	'flake_seed',
	'flake_uvwgen',
	'coat_color',
	'coat_strength',
	'coat_glossiness',
	# 'coat_bump_float',
	# 'coat_bump_color',
	# 'coat_bump_amount',
	# 'coat_bump_type',
	'traceReflections',
	'doubleSided',
	'subdivs',
	'cutoff_threshold',
	'mapping_type',
	'mapping_channel',
)

def add_properties(rna_pointer):
	class BRDFCarPaint(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(BRDFCarPaint)

	rna_pointer.BRDFCarPaint= PointerProperty(
		name= "BRDFCarPaint",
		type=  BRDFCarPaint,
		description= "V-Ray BRDFCarPaint settings"
	)

	# base_color
	BRDFCarPaint.base_color= FloatVectorProperty(
		name= "Base color",
		description= "",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.3,0.4,0.5)
	)

	BRDFCarPaint.base_color_tex= StringProperty(
		name= "Base color texture",
		description= "Base color texture",
		default= ""
	)

	BRDFCarPaint.map_base_color= BoolProperty(
		name= "Base color texture",
		description= "",
		default= False
	)

	BRDFCarPaint.base_color_mult= FloatProperty(
		name= "Base color texture multiplier",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# base_reflection
	BRDFCarPaint.base_reflection= FloatProperty(
		name= "Base reflection",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.5
	)

	BRDFCarPaint.map_base_reflection= BoolProperty(
		name= "base reflection",
		description= "",
		default= False
	)

	BRDFCarPaint.base_reflection_mult= FloatProperty(
		name= "base reflection",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# base_glossiness
	BRDFCarPaint.base_glossiness= FloatProperty(
		name= "base glossiness",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.6
	)

	BRDFCarPaint.map_base_glossiness= BoolProperty(
		name= "base glossiness",
		description= "",
		default= False
	)

	BRDFCarPaint.base_glossiness_mult= FloatProperty(
		name= "base glossiness",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# flake_color
	BRDFCarPaint.flake_color= FloatVectorProperty(
		name= "flake color",
		description= "",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.3,0.4,0.8)
	)

	BRDFCarPaint.flake_color_tex= StringProperty(
		name= "Flake color texture",
		description= "Base color texture",
		default= ""
	)

	BRDFCarPaint.map_flake_color= BoolProperty(
		name= "flake color",
		description= "",
		default= False
	)

	BRDFCarPaint.flake_color_mult= FloatProperty(
		name= "flake color",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# flake_glossiness
	BRDFCarPaint.flake_glossiness= FloatProperty(
		name= "flake glossiness",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.8
	)

	BRDFCarPaint.map_flake_glossiness= BoolProperty(
		name= "flake glossiness",
		description= "",
		default= False
	)

	BRDFCarPaint.flake_glossiness_mult= FloatProperty(
		name= "flake glossiness",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# flake_orientation
	BRDFCarPaint.flake_orientation= FloatProperty(
		name= "flake orientation",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.3
	)

	BRDFCarPaint.map_flake_orientation= BoolProperty(
		name= "flake orientation",
		description= "",
		default= False
	)

	BRDFCarPaint.flake_orientation_mult= FloatProperty(
		name= "flake orientation",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# flake_density
	BRDFCarPaint.flake_density= FloatProperty(
		name= "flake density",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.5
	)

	# flake_scale
	BRDFCarPaint.flake_scale= FloatProperty(
		name= "flake scale",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.01
	)

	# flake_size
	BRDFCarPaint.flake_size= FloatProperty(
		name= "flake size",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.5
	)

	# flake_map_size
	BRDFCarPaint.flake_map_size= IntProperty(
		name= "flake map size",
		description= "The size of the internal flakes map",
		min= 0,
		max= 10000,
		soft_min= 0,
		soft_max= 10000,
		default= 1024
	)

	# flake_filtering_mode
	BRDFCarPaint.flake_filtering_mode= IntProperty(
		name= "flake filtering mode",
		description= "Flake filtering mode (0 - simple; 1 - directional)",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 1
	)

	# flake_seed
	BRDFCarPaint.flake_seed= IntProperty(
		name= "flake seed",
		description= "The random seed for the flakes",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 1
	)

	# flake_uvwgen

	# coat_color
	BRDFCarPaint.coat_color= FloatVectorProperty(
		name= "coat color",
		description= "",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1,1,1)
	)

	BRDFCarPaint.coat_color_tex= StringProperty(
		name= "Coat color texture",
		description= "Base color texture",
		default= ""
	)

	BRDFCarPaint.map_coat_color= BoolProperty(
		name= "coat color",
		description= "",
		default= False
	)

	BRDFCarPaint.coat_color_mult= FloatProperty(
		name= "coat color",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# coat_strength
	BRDFCarPaint.coat_strength= FloatProperty(
		name= "coat strength",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.05
	)

	BRDFCarPaint.map_coat_strength= BoolProperty(
		name= "coat strength",
		description= "",
		default= False
	)

	BRDFCarPaint.coat_strength_mult= FloatProperty(
		name= "coat strength",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# coat_glossiness
	BRDFCarPaint.coat_glossiness= FloatProperty(
		name= "coat glossiness",
		description= "The glossiness of the coat layer",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	BRDFCarPaint.map_coat_glossiness= BoolProperty(
		name= "coat glossiness",
		description= "The glossiness of the coat layer",
		default= False
	)

	BRDFCarPaint.coat_glossiness_mult= FloatProperty(
		name= "coat glossiness",
		description= "The glossiness of the coat layer",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# coat_bump_float
	BRDFCarPaint.map_coat_bump_float= BoolProperty(
		name= "coat bump float",
		description= "Bump texture for the coat layer",
		default= False
	)

	BRDFCarPaint.coat_bump_float_mult= FloatProperty(
		name= "coat bump float",
		description= "Bump texture for the coat layer",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# coat_bump_color
	BRDFCarPaint.map_coat_bump_color= BoolProperty(
		name= "coat bump color",
		description= "Bump texture for the coat layer (color version)",
		default= False
	)

	BRDFCarPaint.coat_bump_color_mult= FloatProperty(
		name= "coat bump color",
		description= "Bump texture for the coat layer (color version)",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# coat_bump_amount
	BRDFCarPaint.map_coat_bump_amount= BoolProperty(
		name= "coat bump amount",
		description= "Bump amount for the coat layer",
		default= False
	)

	BRDFCarPaint.coat_bump_amount_mult= FloatProperty(
		name= "coat bump amount",
		description= "Bump amount for the coat layer",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# coat_bump_type
	BRDFCarPaint.coat_bump_type= IntProperty(
		name= "coat bump type",
		description= "The type of bump mapping (see BRDFBump for more details)",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 0
	)

	# traceReflections
	BRDFCarPaint.traceReflections= BoolProperty(
		name= "Trace reflections",
		description= "",
		default= True
	)

	# doubleSided
	BRDFCarPaint.doubleSided= BoolProperty(
		name= "Double-sided",
		description= "",
		default= True
	)

	# subdivs
	BRDFCarPaint.subdivs= IntProperty(
		name= "Subdivs",
		description= "",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 8
	)

	# cutoff_threshold
	BRDFCarPaint.cutoff_threshold= FloatProperty(
		name= "Cutoff",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.001
	)

	# mapping_type
	BRDFCarPaint.mapping_type= EnumProperty(
		name= "Mapping type",
		description= "The mapping method for the flakes",
		items= (
			('EXPLICIT',  "Explicit", "Explicit mapping channel"),
			('TRIPLANAR', "Object",   "Triplanar projection in object space"),
		),
		default= 'EXPLICIT'
	)

	# mapping_channel
	BRDFCarPaint.mapping_channel= IntProperty(
		name= "Mapping channel",
		description= "The mapping channel when the mapping_type is 0",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 1
	)



'''
  OUTPUT
'''
def mapto(bus, BRDFLayered= None):
	scene= bus['scene']
	ma=    bus['material']['material']

	VRayMaterial= ma.vray

	BRDFVRayMtl=  BRDFLayered.BRDFCarPaint if BRDFLayered else VRayMaterial.BRDFCarPaint

	defaults= {}

	defaults['bump']         = ("AColor(0.0,0.0,0.0,1.0)", 0, 'NONE')
	defaults['normal']       = ("AColor(0.0,0.0,0.0,1.0)", 0, 'NONE')
	defaults['displacement'] = ("AColor(0.0,0.0,0.0,1.0)", 0, 'NONE')

	return defaults


def write(bus, VRayBRDF= None, base_name= None):
	MAPPING_TYPE= {
		'EXPLICIT':  0,
		'TRIPLANAR': 1,
	}

	ofile= bus['files']['materials']
	scene= bus['scene']
	ma=    bus['material']['material']

	brdf_name= "%s%s%s" % (ID, get_name(ma, prefix='MA'), bus['material']['orco_suffix'])
	if base_name:
		brdf_name= "%s%s%s" % (base_name, ID, bus['material']['orco_suffix'])
	if VRayBRDF:
		brdf_name+= clean_string(VRayBRDF.name)

	BRDFCarPaint= getattr(VRayBRDF, ID) if VRayBRDF else ma.vray.BRDFCarPaint

	# Color values if param is not textured
	mapped_params= mapto(bus, VRayBRDF)
	
	ofile.write("\n%s %s {"%(ID, brdf_name))
	for param in PARAMS:
		if param == 'mapping_type':
			value= MAPPING_TYPE[BRDFCarPaint.mapping_type]
		elif param == 'flake_uvwgen':
			value= bus['defaults']['uvwgen'];
		else:
			value= getattr(BRDFCarPaint, param)
		ofile.write("\n\t%s= %s;" % (param, a(scene, value)))
	ofile.write("\n}\n")

	return brdf_name



'''
  GUI
'''
def influence(context, layout, slot):
	wide_ui= context.region.width > ui.narrowui

	VRaySlot= slot.texture.vray_slot

	split= layout.split()
	col= split.column()
	col.label(text="Diffuse:")
	split= layout.split()
	col= split.column()
	ui.factor_but(col, VRaySlot, 'map_base',  'base_mult',  "Base")
	if wide_ui:
		col= split.column()
	ui.factor_but(col, VRaySlot, 'map_coat',  'coat_mult',  "Coat")
	ui.factor_but(col, VRaySlot, 'map_flake', 'flake_mult', "Flake")


def gui(context, layout, BRDFCarPaint, material= None):
	wide_ui= context.region.width > ui.narrowui

	layout.label(text="Coat:")
	split= layout.split()
	col= split.column()
	sub= col.column(align=True)
	sub.prop(BRDFCarPaint, 'coat_color', text="")
	if not material:
		sub.prop_search(BRDFCarPaint, 'coat_color_tex',
						bpy.data, 'textures',
						text= "")
	if wide_ui:
		col= split.column()
	col.prop(BRDFCarPaint, 'coat_strength', text="Strength")
	col.prop(BRDFCarPaint, 'coat_glossiness', text="Glossiness")
	# col.prop(BRDFCarPaint, 'coat_bump_float')
	# col.prop(BRDFCarPaint, 'coat_bump_color')
	# col.prop(BRDFCarPaint, 'coat_bump_amount')
	# col.prop(BRDFCarPaint, 'coat_bump_type')

	layout.label(text="Flake:")
	split= layout.split()
	col= split.column()
	sub= col.column(align=True)
	sub.prop(BRDFCarPaint, 'flake_color', text="")
	if not material:
		sub.prop_search(BRDFCarPaint, 'flake_color_tex',
						bpy.data, 'textures',
						text= "")
	col.prop(BRDFCarPaint, 'flake_glossiness', text="Glossiness")
	col.prop(BRDFCarPaint, 'flake_orientation', text="Orientation")
	col.prop(BRDFCarPaint, 'flake_density', text="Density")
	col.prop(BRDFCarPaint, 'flake_seed', text="Seed")
	if wide_ui:
		col= split.column()
	col.prop(BRDFCarPaint, 'flake_scale', text="Scale")
	col.prop(BRDFCarPaint, 'flake_size', text="Size")
	col.prop(BRDFCarPaint, 'flake_map_size', text="Map size")
	col.prop(BRDFCarPaint, 'flake_filtering_mode', text="Filtering")
	# col.prop(BRDFCarPaint, 'flake_uvwgen')
	col.prop(BRDFCarPaint, 'mapping_type', text="Type")
	if BRDFCarPaint.mapping_type == 'EXPLICIT':
		col.prop(BRDFCarPaint, 'mapping_channel', text="Channel")

	layout.label(text="Base:")
	split= layout.split()
	col= split.column()
	sub= col.column(align=True)
	sub.prop(BRDFCarPaint, 'base_color', text="")
	if not material:
		sub.prop_search(BRDFCarPaint, 'base_color_tex',
						bpy.data, 'textures',
						text= "")
	if wide_ui:
		col= split.column()
	col.prop(BRDFCarPaint, 'base_reflection', text="Reflection")
	col.prop(BRDFCarPaint, 'base_glossiness', text="Glossiness")

	layout.separator()

	split= layout.split()
	col= split.column()
	col.prop(BRDFCarPaint, 'subdivs')
	col.prop(BRDFCarPaint, 'cutoff_threshold')
	if wide_ui:
		col= split.column()
	col.prop(BRDFCarPaint, 'doubleSided')
	col.prop(BRDFCarPaint, 'traceReflections')


########NEW FILE########
__FILENAME__ = BRDFDiffuse
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
import vb25.texture

from vb25.utils import *
from vb25.ui import ui


TYPE= 'BRDF'
ID=   'BRDFDiffuse'
PID=   5

NAME= 'BRDFDiffuse'
UI=   "Diffuse"
DESC= "BRDFDiffuse."

PARAMS= (
	'color',
	'color_tex',
	'color_tex_mult',
	'transparency',
	'transparency_tex',
	'transparency_tex_mult',
	'roughness',
	'use_irradiance_map',
)


def add_properties(rna_pointer):
	class BRDFDiffuse(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(BRDFDiffuse)
	rna_pointer.BRDFDiffuse= PointerProperty(
		name= "BRDFDiffuse",
		type=  BRDFDiffuse,
		description= "V-Ray BRDFDiffuse settings"
	)

	# color
	BRDFDiffuse.color= FloatVectorProperty(
		name= "Color",
		description= "",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1,1,1)
	)

	# color_tex
	BRDFDiffuse.color_tex= StringProperty(
		name= "Color texture",
		description= "",
		default= ""
	)

	BRDFDiffuse.map_color_tex= BoolProperty(
		name= "color tex",
		description= "",
		default= False
	)

	# color_tex_mult
	BRDFDiffuse.color_tex_mult= FloatProperty(
		name= "color tex mult",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# transparency
	BRDFDiffuse.transparency= FloatVectorProperty(
		name= "Transparency",
		description= "",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0)
	)

	# transparency_tex
	BRDFDiffuse.transparency_tex= StringProperty(
		name= "Transparency",
		description= "",
		default= ""
	)

	BRDFDiffuse.map_transparency_tex= BoolProperty(
		name= "transparency tex",
		description= "",
		default= False
	)

	# transparency_tex_mult
	BRDFDiffuse.transparency_tex_mult= FloatProperty(
		name= "transparency tex mult",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# roughness
	BRDFDiffuse.roughness= FloatProperty(
		name= "Roughness",
		description= "Roughness",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 0.0
	)

	BRDFDiffuse.roughness_tex= StringProperty(
		name= "Roughness texture",
		description= "Roughness texture",
		default= ""
	)

	BRDFDiffuse.map_roughness= BoolProperty(
		name= "Roughness texture",
		description= "Roughness texture",
		default= False
	)

	BRDFDiffuse.roughness_mult= FloatProperty(
		name= "Roughness texture multiplier",
		description= "Roughness texture multiplier",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# use_irradiance_map
	BRDFDiffuse.use_irradiance_map= BoolProperty(
		name= "Use Irradiance map",
		description= "Use irradiance map",
		default= True
	)




'''
  OUTPUT
'''
def write(bus, VRayBRDF= None, base_name= None):
	ofile= bus['files']['materials']
	scene= bus['scene']

	ma=    bus['material']['material']

	brdf_name= "%s%s%s" % (ID, get_name(ma, prefix='MA'), bus['material']['orco_suffix'])
	if base_name:
		brdf_name= "%s%s%s" % (base_name, ID, bus['material']['orco_suffix'])
	if VRayBRDF:
		brdf_name+= clean_string(VRayBRDF.name)

	BRDFDiffuse= getattr(VRayBRDF, ID)

	textures= {}
	for param in PARAMS:
		if param.endswith('_tex'):
			textures[param]= vb25.texture.write_subtexture(bus, getattr(BRDFDiffuse, param))
	
	ofile.write("\n%s %s {"%(ID, brdf_name))
	for param in PARAMS:
		if param.endswith('_tex'):
			if param in textures and textures[param]:
				value= textures[param]
			else:
				continue
		else:
			value= getattr(BRDFDiffuse, param)
		ofile.write("\n\t%s= %s;" % (param, a(scene, value)))
	ofile.write("\n}\n")

	return brdf_name



'''
  GUI
'''
def gui(context, layout, BRDFDiffuse):
	wide_ui= context.region.width > ui.narrowui

	split= layout.split()
	col= split.column(align=True)
	col.prop(BRDFDiffuse, 'color')
	col.prop_search(BRDFDiffuse, 'color_tex',
					bpy.data, 'textures',
					text= "")
	if BRDFDiffuse.color_tex:
		col.prop(BRDFDiffuse, 'color_tex_mult', text="Mult")
	if wide_ui:
		col= split.column(align=True)
	col.prop(BRDFDiffuse, 'transparency', text="Opacity")
	col.prop_search(BRDFDiffuse, 'transparency_tex',
					bpy.data, 'textures',
					text= "")
	if BRDFDiffuse.transparency_tex:
		col.prop(BRDFDiffuse, 'transparency_tex_mult', text="Mult")

	layout.separator()

	split= layout.split()
	col= split.column()
	sub= col.column(align=True)
	sub.prop(BRDFDiffuse, 'roughness')
	# sub.prop_search(BRDFDiffuse, 'roughness_tex',
	# 				bpy.data, 'textures',
	# 				text= "")
	if wide_ui:
		col= split.column()
	col.prop(BRDFDiffuse, 'use_irradiance_map')

########NEW FILE########
__FILENAME__ = BRDFGlass
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'BRDF'
ID=   'BRDFGlass'
PID=   9

NAME= 'BRDFGlass'
UI=   "Glass"
DESC= "BRDFGlass."

PARAMS= (
	'color',
	'color_tex',
	'color_tex_mult',
	'transparency',
	'transparency_tex',
	'transparency_tex_mult',
	'ior',
	'ior_tex',
	'cutoff',
	'affect_shadows',
	'affect_alpha',
	'trace_refractions',
	'trace_depth',
	'exit_color_on',
	'reflect_exit_color',
	'refract_exit_color',
#	'volume',
)



def add_properties(rna_pointer):
	class BRDFGlass(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(BRDFGlass)
	
	rna_pointer.BRDFGlass= PointerProperty(
		name= "BRDFGlass",
		type=  BRDFGlass,
		description= "V-Ray BRDFGlass settings"
	)

	#  color: color = Color(1, 1, 1)
	BRDFGlass.color= FloatVectorProperty(
		name= "Color",
		description= "Reflection color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1,1,1)
	)

	#   color_tex: acolor texture
	BRDFGlass.color_tex= StringProperty(
		name= "Color texture",
		description= "",
		default= ""
	)


	#   color_tex_mult: float = 1
	BRDFGlass.color_tex_mult= FloatProperty(
		name= "Color texture multiplier",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	#  transparency: color = Color(0, 0, 0)
	BRDFGlass.transparency= FloatVectorProperty(
		name= "Transparency",
		description= "Transparency color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0)
	)

	#   transparency_tex: acolor texture
	BRDFGlass.transparency_tex= StringProperty(
		name= "Transparency",
		description= "",
		default= ""
	)

	#   transparency_tex_mult: float = 1
	BRDFGlass.transparency_tex_mult= FloatProperty(
		name= "Transparency Texture",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	#  ior: float = 1.55, IOR for the glass; this is ignored if the surface has a volume shader (the volume IOR is used).
	BRDFGlass.ior= FloatProperty(
		name= "IOR",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.55
	)

	#  ior_tex: float texture
	BRDFGlass.ior_tex= StringProperty(
		name= "IOR Texture",
		description= "IOR Texture",
		default= ""
	)

	#  cutoff: float = 0.01
	BRDFGlass.cutoff= FloatProperty(
		name= "Cutoff",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.01
	)

	#  affect_shadows: bool = false
	BRDFGlass.affect_shadows= BoolProperty(
		name= "Affect Shadows",
		description= "",
		default= False
	)

	#  affect_alpha: integer = 0, Specifies how render channels are propagated through the glass (0 - only the color channel; 1 - color and alpha; 2 - all channels
	BRDFGlass.affect_alpha= EnumProperty(
		name= "Affect Channels",
		description= "Which channels affect",
		items= (
			('COL',  "Color Only",   "The transperency will affect only the RGB channel of the final render."),
			('RERF', "Color+Alpha",  "This will cause the material to transmit the alpha of the refracted objects, instead of displaying an opaque alpha.."),
			('ALL',  "All Channels", "All channels and render elements will be affected by the transperency of the material.")
		),
		default= 'COL'
	)

	#  trace_refractions: bool = true
	BRDFGlass.trace_refractions= BoolProperty(
		name= "Trace Refractions",
		description= "",
		default= True
	)

	#  trace_depth: integer = -1, The maximum refraction bounces (-1 is controlled by the global options)
	BRDFGlass.trace_depth= IntProperty(
		name= "Trace Depth",
		description= "The maximum refraction bounces (-1 is controlled by the global options)",
		min= 0,
		max= 100,
		default= -1
	)

	#  exit_color_on: bool = false
	BRDFGlass.exit_color_on= BoolProperty(
		name= "Exit color on",
		description= "",
		default= False
	)

	#  reflect_exit_color: acolor texture = AColor(0, 0, 0, 0), The color to use when the maximum depth is reached
	BRDFGlass.reflect_exit_color= FloatVectorProperty(
		name= "Reflect exit color",
		description= "",
		size=4,
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0,0)
	)

	BRDFGlass.reflect_exit_color_tex= StringProperty(
		name= "Reflect exit color texture",
		description= "Reflect exit color texture",
		default= ""
	)

	#  refract_exit_color: acolor texture = AColor(0, 0, 0, 0), The color to use when maximum depth is reached when exit_color_on is true
	BRDFGlass.refract_exit_color= FloatVectorProperty(
		name= "Refract Exit Color",
		description= "",
		size=4,
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0,0)
	)

	BRDFGlass.refract_exit_color_tex= StringProperty(
		name= "Refract exit color texture",
		description= "Refract exit color texture",
		default= ""
	)

	#  volume: plugin





'''
  OUTPUT
'''
def write(bus, VRayBRDF= None, base_name= None):

	AFFECT_ALPHA= {
		'COL':  0,
		'RERF': 1,
		'All': 2,
	}

	ofile= bus['files']['materials']
	scene= bus['scene']

	BRDFGlass= getattr(VRayBRDF, ID)

	brdf_name= "%s%s%s" % ('BRDFGlass', ID, clean_string(VRayBRDF.name))

	ofile.write("\n%s %s {" % ('BRDFGlass', brdf_name))
	for param in PARAMS:
		if param.endswith('_tex'):
			continue
		elif (param == 'affect_alpha'):
			value= AFFECT_ALPHA[BRDFGlass.affect_alpha]
		else:
			value= getattr(BRDFGlass, param)
		ofile.write("\n\t%s= %s;" % (param, a(scene, value)))
	ofile.write("\n}\n")

	return brdf_name



'''
  GUI
'''
def gui(context, layout, BRDFGlass):
	wide_ui= context.region.width > ui.narrowui

	layout.label(text="Color:")
	split= layout.split()
	
	row= split.row(align=True)
	
	row.prop(BRDFGlass, 'color', text="")
	row.prop_search(BRDFGlass, 'color_tex',
					bpy.data, 'textures',
					text= "")
	if BRDFGlass.color_tex:
		row.prop(BRDFGlass, 'color_tex_mult', text="Mult")

	layout.label(text="Transparency:")
	split= layout.split()
	if wide_ui:
		row= split.row(align=True)
	row.prop(BRDFGlass, 'transparency', text= "", slider= True)
	row.prop_search(BRDFGlass, 'transparency_tex',
					bpy.data, 'textures',
					text= "")
	if BRDFGlass.transparency_tex:
		row.prop(BRDFGlass, 'transparency_tex_mult', text="Mult")


	split= layout.split()
	col= split.column(align=True)
	col.prop(BRDFGlass, 'ior')
	col.prop_search(BRDFGlass, 'ior_tex',
					bpy.data, 'textures',
					text= "")
	col.prop(BRDFGlass, 'affect_shadows')
	if BRDFGlass.affect_shadows:
		col.prop(BRDFGlass, 'affect_alpha')

	col.prop(BRDFGlass, 'trace_refractions')
	if BRDFGlass.trace_refractions:
		col.prop(BRDFGlass, 'trace_depth')

	col.prop(BRDFGlass, 'exit_color_on')

	if BRDFGlass.exit_color_on:
		col.prop(BRDFGlass, 'reflect_exit_color')
		col.prop_search(BRDFGlass, 'reflect_exit_color_tex',
											bpy.data, 'textures',
											text= "")

		col.prop(BRDFGlass, 'refract_exit_color')
		col.prop_search(BRDFGlass, 'refract_exit_color_tex',
											bpy.data, 'textures',
											text= "")


########NEW FILE########
__FILENAME__ = BRDFGlassGlossy
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'BRDF'
ID=   'BRDFGlassGlossy'
PID=   10

NAME= 'BRDFGlassGlossy'
UI=   "GlassGlossy"
DESC= "BRDFGlassGlossy."

PARAMS= (
	'color',
	'color_tex',
	'color_tex_mult',
	'transparency',
	'transparency_tex',
	'transparency_tex_mult',
	'ior',
	'ior_tex',
	'cutoff',
	'affect_shadows',
	'affect_alpha',
	'trace_refractions',
	'trace_depth',
	'exit_color_on',
	'reflect_exit_color',
	'refract_exit_color',
#	'volume',
	'glossiness'
	'glossiness_tex',
	'glossiness_tex_mult',
	'subdivs',
	'dispersion_on',
	'dispersion',
	'interpolation_on',
	'imap_min_rate',
	'imap_max_rate',
	'imap_color_thresh',
	'imap_norm_thresh',
	'imap_samples',
)



def add_properties(rna_pointer):
	class BRDFGlassGlossy(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(BRDFGlassGlossy)
	
	rna_pointer.BRDFGlassGlossy= PointerProperty(
		name= "BRDFGlassGlossy",
		type=  BRDFGlassGlossy,
		description= "V-Ray BRDFGlassGlossy settings"
	)

	#  color: color = Color(1, 1, 1)
	BRDFGlassGlossy.color= FloatVectorProperty(
		name= "Color",
		description= "Reflection color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1,1,1)
	)

	#   color_tex: acolor texture
	BRDFGlassGlossy.color_tex= StringProperty(
		name= "Color texture",
		description= "",
		default= ""
	)


	#   color_tex_mult: float = 1
	BRDFGlassGlossy.color_tex_mult= FloatProperty(
		name= "Color texture multiplier",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	#  transparency: color = Color(0, 0, 0)
	BRDFGlassGlossy.transparency= FloatVectorProperty(
		name= "Transparency",
		description= "Transparency color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0)
	)

	#   transparency_tex: acolor texture
	BRDFGlassGlossy.transparency_tex= StringProperty(
		name= "Transparency",
		description= "",
		default= ""
	)

	#   transparency_tex_mult: float = 1
	BRDFGlassGlossy.transparency_tex_mult= FloatProperty(
		name= "Transparency Texture",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	#  ior: float = 1.55, IOR for the glass; this is ignored if the surface has a volume shader (the volume IOR is used).
	BRDFGlassGlossy.ior= FloatProperty(
		name= "IOR",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.55
	)

	#  ior_tex: float texture
	BRDFGlassGlossy.ior_tex= StringProperty(
		name= "IOR Texture",
		description= "IOR Texture",
		default= ""
	)

	#  cutoff: float = 0.01
	BRDFGlassGlossy.cutoff= FloatProperty(
		name= "Cutoff",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.01
	)

	#  affect_shadows: bool = false
	BRDFGlassGlossy.affect_shadows= BoolProperty(
		name= "Affect Shadows",
		description= "",
		default= False
	)

	#  affect_alpha: integer = 0, Specifies how render channels are propagated through the glass (0 - only the color channel; 1 - color and alpha; 2 - all channels
	BRDFGlassGlossy.affect_alpha= EnumProperty(
		name= "Affect Channels",
		description= "Which channels affect",
		items= (
			('COL',  "Color Only",   "The transperency will affect only the RGB channel of the final render."),
			('RERF', "Color+Alpha",  "This will cause the material to transmit the alpha of the refracted objects, instead of displaying an opaque alpha.."),
			('ALL',  "All Channels", "All channels and render elements will be affected by the transperency of the material.")
		),
		default= 'COL'
	)

	#  trace_refractions: bool = true
	BRDFGlassGlossy.trace_refractions= BoolProperty(
		name= "Trace Refractions",
		description= "",
		default= True
	)

	#  trace_depth: integer = -1, The maximum refraction bounces (-1 is controlled by the global options)
	BRDFGlassGlossy.trace_depth= IntProperty(
		name= "Trace Depth",
		description= "The maximum refraction bounces (-1 is controlled by the global options)",
		min= 0,
		max= 100,
		default= -1
	)

	#  exit_color_on: bool = false
	BRDFGlassGlossy.exit_color_on= BoolProperty(
		name= "Exit color on",
		description= "",
		default= False
	)

	#  reflect_exit_color: acolor texture = AColor(0, 0, 0, 0), The color to use when the maximum depth is reached
	BRDFGlassGlossy.reflect_exit_color= FloatVectorProperty(
		name= "Reflect exit color",
		description= "",
		size=4,
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0,0)
	)

	BRDFGlassGlossy.reflect_exit_color_tex= StringProperty(
		name= "Reflect exit color texture",
		description= "Reflect exit color texture",
		default= ""
	)

	#  refract_exit_color: acolor texture = AColor(0, 0, 0, 0), The color to use when maximum depth is reached when exit_color_on is true
	BRDFGlassGlossy.refract_exit_color= FloatVectorProperty(
		name= "Refract Exit Color",
		description= "",
		size=4,
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0,0)
	)

	BRDFGlassGlossy.refract_exit_color_tex= StringProperty(
		name= "Refract exit color texture",
		description= "Refract exit color texture",
		default= ""
	)

	#  volume: plugin
	#  TODOO

	#  glossiness: float = 0.8
	BRDFGlassGlossy.glossiness= FloatProperty(
		name= "Glossiness",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.8
	)

	#  glossiness_tex: float texture
	BRDFGlassGlossy.glossiness_tex= FloatProperty(
		name= "Glossiness texture",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.8
	)

	#  glossiness_tex_mult: float = 1
	BRDFGlassGlossy.glossiness_tex_mult= FloatProperty(
		name= "Glossiness texture multiplier",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	#  subdivs: integer = 8
	BRDFGlassGlossy.subdivs= IntProperty(
		name= "Subdivs",
		description= "Subdivs",
		min= 0,
		max= 100,
		default= 8
	)

	#  dispersion_on: integer = 0
	BRDFGlassGlossy.dispersion_on= IntProperty(
		name= "Dispersion on",
		description= "Dispersion on",
		min= 0,
		max= 100,
		default= 0
	)

	#  dispersion: float = 1
	BRDFGlassGlossy.dispersion= FloatProperty(
		name= "Dispersion",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	#  interpolation_on: integer = 0
	BRDFGlassGlossy.interpolation_on= IntProperty(
		name= "Interpolation on",
		description= "Interpolation on",
		min= 0,
		max= 100,
		default= 0
	)

	#  imap_min_rate: integer = -1
	BRDFGlassGlossy.imap_min_rate= IntProperty(
		name= "Imap min rate",
		description= "Imap min rate",
		min= 0,
		max= 100,
		default= -1
	)

	#  imap_max_rate: integer = 1
	BRDFGlassGlossy.imap_max_rate= IntProperty(
		name= "Imap max rate",
		description= "Imap max rate",
		min= 0,
		max= 100,
		default= 1
	)

	#  imap_color_thresh: float = 0.25
	BRDFGlassGlossy.imap_color_thresh= FloatProperty(
		name= "Imap color thresh",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.25
	)

	#  imap_norm_thresh: float = 0.4
	BRDFGlassGlossy.imap_norm_thresh= FloatProperty(
		name= "Imap norm thresh",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.4
	)

	#  imap_samples: integer = 20
	BRDFGlassGlossy.imap_samples= IntProperty(
		name= "Imap samples",
		description= "Imap samples",
		min= 0,
		max= 100,
		default= 20
	)



'''
  OUTPUT
'''
def write(bus, VRayBRDF= None, base_name= None):

	AFFECT_ALPHA= {
		'COL':  0,
		'RERF': 1,
		'All':  2,
	}

	ofile= bus['files']['materials']
	scene= bus['scene']

	BRDFGlassGlossy= getattr(VRayBRDF, ID)

	brdf_name= "%s%s%s" % ('BRDFGlassGlossy', ID, clean_string(VRayBRDF.name))

	ofile.write("\n%s %s {" % ('BRDFGlassGlossy', brdf_name))
	for param in PARAMS:
		if param.endswith('_tex'):
			continue
		elif (param == 'affect_alpha'):
			value= AFFECT_ALPHA[BRDFGlassGlossy.affect_alpha]
		else:
			value= getattr(BRDFGlassGlossy, param)
		ofile.write("\n\t%s= %s;" % (param, a(scene, value)))
	ofile.write("\n}\n")

	return brdf_name



'''
  GUI
'''
def gui(context, layout, BRDFGlassGlossy):
	wide_ui= context.region.width > ui.narrowui

	layout.label(text="Color:")
	split= layout.split()
	
	row= split.row(align=True)
	
	row.prop(BRDFGlassGlossy, 'color', text="")
	row.prop_search(BRDFGlassGlossy, 'color_tex',
					bpy.data, 'textures',
					text= "")
	if BRDFGlassGlossy.color_tex:
		row.prop(BRDFGlassGlossy, 'color_tex_mult', text="Mult")

	layout.label(text="Transparency:")
	split= layout.split()
	if wide_ui:
		row= split.row(align=True)
	row.prop(BRDFGlassGlossy, 'transparency', text= "", slider= True)
	row.prop_search(BRDFGlassGlossy, 'transparency_tex',
					bpy.data, 'textures',
					text= "")
	if BRDFGlassGlossy.transparency_tex:
		row.prop(BRDFGlassGlossy, 'transparency_tex_mult', text="Mult")


	split= layout.split()
	col= split.column(align=True)
	col.prop(BRDFGlassGlossy, 'ior')
	col.prop_search(BRDFGlassGlossy, 'ior_tex',
					bpy.data, 'textures',
					text= "")
	col.prop(BRDFGlassGlossy, 'affect_shadows')
	if BRDFGlassGlossy.affect_shadows:
		col.prop(BRDFGlassGlossy, 'affect_alpha')

	col.prop(BRDFGlassGlossy, 'trace_refractions')
	if BRDFGlassGlossy.trace_refractions:
		col.prop(BRDFGlassGlossy, 'trace_depth')

	col.prop(BRDFGlassGlossy, 'exit_color_on')

	if BRDFGlassGlossy.exit_color_on:
		col.prop(BRDFGlassGlossy, 'reflect_exit_color')
		col.prop_search(BRDFGlassGlossy, 'reflect_exit_color_tex',
											bpy.data, 'textures',
											text= "")

		col.prop(BRDFGlassGlossy, 'refract_exit_color')
		col.prop_search(BRDFGlassGlossy, 'refract_exit_color_tex',
											bpy.data, 'textures',
											text= "")

	split= layout.split()
	col= split.column(align=True)

	col.prop(BRDFGlassGlossy, 'glossiness')
	col.prop_search(BRDFGlassGlossy, 'glossiness_tex',
					bpy.data, 'textures',
					text= "")
	if BRDFGlassGlossy.glossiness_tex:
		col.prop(BRDFGlassGlossy, 'glossiness_tex_mult')

	split= layout.split()
	col= split.column(align=True)

	col.prop(BRDFGlassGlossy, 'subdivs')

	col.prop(BRDFGlassGlossy, 'dispersion_on')
	col.prop(BRDFGlassGlossy, 'dispersion')
	
	col.prop(BRDFGlassGlossy, 'interpolation_on')
	col.prop(BRDFGlassGlossy, 'imap_min_rate')
	col.prop(BRDFGlassGlossy, 'imap_max_rate')
	col.prop(BRDFGlassGlossy, 'imap_color_thresh')
	col.prop(BRDFGlassGlossy, 'imap_norm_thresh')
	col.prop(BRDFGlassGlossy, 'imap_samples')


#  glossiness: float = 0.8
#  glossiness_tex: float texture
#  glossiness_tex_mult: float = 1
#  subdivs: integer = 8
#  dispersion_on: integer = 0
#  dispersion: float = 1
#  interpolation_on: integer = 0
#  imap_min_rate: integer = -1
#  imap_max_rate: integer = 1
#  imap_color_thresh: float = 0.25
#  imap_norm_thresh: float = 0.4
#  imap_samples: integer = 20

########NEW FILE########
__FILENAME__ = BRDFHair3
#
# V-Ray/Blender
#
# http://vray.cgdo.ru
#
# Author: Andrey M. Izrantsev (aka bdancer)
# E-Mail: izrantsev@cgdo.ru
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
#


# Blender modules
import bpy
from bpy.props import *

# V-Ray/Blender modules
import vb25.texture

from vb25.utils import *
from vb25.ui import ui


TYPE      = 'BRDF'
ID        = 'BRDFHair3'
PID       =  8
MAIN_BRDF =  True

NAME   = 'BRDFHair3'
UI     = "Hair"
DESC   = "Hair material"

PARAMS = (
	'overall_color',
	'transparency',
	'diffuse_color',
	'diffuse_amount',
	'primary_specular',
	'primary_specular_amount',
	'primary_glossiness',
	'secondary_specular',
	'secondary_specular_amount',
	'secondary_glossiness',
	'secondary_lock_to_transmission',
	'transmission',
	'transmission_amount',
	'transmission_glossiness_length',
	'transmission_glossiness_width',
	'opaque_for_shadows',
	'opaque_for_gi',
	'simplify_for_gi',
	'use_cached_gi',
)


def add_properties(rna_pointer):
	class BRDFHair3(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(BRDFHair3) 

	rna_pointer.BRDFHair3= PointerProperty(
		name= "BRDFHair3",
		type=  BRDFHair3,
		description= "V-Ray BRDFHair3 settings"
	)

	# overall_color
	BRDFHair3.overall_color= FloatVectorProperty(
		name= "Overall Color",
		description= "Overall color multiplier",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.9,0.9,0.9)
	)

	# transparency
	BRDFHair3.transparency= FloatVectorProperty(
		name= "Transparency",
		description= "Controls the transparency of the material where white is opaque and black is fully transparent",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0)
	)

	# diffuse_color
	BRDFHair3.diffuse_color= FloatVectorProperty(
		name= "Diffuse Color",
		description= "Diffuse hair color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.01,0.01,0.01)
	)

	# diffuse_amount
	BRDFHair3.diffuse_amount= FloatProperty(
		name= "Diffuse Amount",
		description= "Multiplier for the diffuse color",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# primary_specular
	BRDFHair3.primary_specular= FloatVectorProperty(
		name= "Primary Specular",
		description= "Primary specular color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.2,0.2,0.2)
	)

	# primary_specular_amount
	BRDFHair3.primary_specular_amount= FloatProperty(
		name= "Primary Specular Amount",
		description= "Multiplier for the primary specular color",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# primary_glossiness
	BRDFHair3.primary_glossiness= FloatProperty(
		name= "Primary Glossiness",
		description= "Primary glossiness",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.8
	)

	# secondary_specular
	BRDFHair3.secondary_specular= FloatVectorProperty(
		name= "Secondary Specular",
		description= "Secondary specular color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.2,0.2,0.2)
	)

	# secondary_specular_amount
	BRDFHair3.secondary_specular_amount= FloatProperty(
		name= "Secondary Specular Amount",
		description= "Multiplier for the secondary specular color",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# secondary_glossiness
	BRDFHair3.secondary_glossiness= FloatProperty(
		name= "Secondary Glossiness",
		description= "Secondary glossiness",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.5
	)

	# secondary_lock_to_transmission
	BRDFHair3.secondary_lock_to_transmission= BoolProperty(
		name= "Lock To Transmission",
		description= "true to derive the secondary specular color from the transmission color",
		default= True
	)

	# transmission
	BRDFHair3.transmission= FloatVectorProperty(
		name= "Transmission",
		description= "Transmission color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.2,0.2,0.2)
	)

	# transmission_amount
	BRDFHair3.transmission_amount= FloatProperty(
		name= "Transmission Amount",
		description= "Multiplier for the transmission color",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# transmission_glossiness_length
	BRDFHair3.transmission_glossiness_length= FloatProperty(
		name= "Transmission Glossiness Length",
		description= "Transmission glossiness along strand length",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.8
	)

	# transmission_glossiness_width
	BRDFHair3.transmission_glossiness_width= FloatProperty(
		name= "Transmission Glossiness Width",
		description= "Transmission glossiness across strand width",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.8
	)

	# opaque_for_shadows
	BRDFHair3.opaque_for_shadows= BoolProperty(
		name= "Opaque For Shadows",
		description= "true to always compute the material as opaque for shadow rays",
		default= False
	)

	# opaque_for_gi
	BRDFHair3.opaque_for_gi= BoolProperty(
		name= "Opaque For GI",
		description= "true to always compute the material as opaque for GI rays",
		default= False
	)

	# simplify_for_gi
	BRDFHair3.simplify_for_gi= BoolProperty(
		name= "Simplify For GI",
		description= "true to use a simpler and less precise representation of the BRDF for GI rays",
		default= False
	)

	# use_cached_gi
	BRDFHair3.use_cached_gi= BoolProperty(
		name= "Use Cached GI",
		description= "true to use the light cache/irradiance map; false to always use brute force GI for the hair",
		default= True
	)



def mapto(bus, BRDFLayered = None):
	return {}


def write(bus, VRayBRDF = None, base_name = None):
	ofile = bus['files']['materials']
	scene = bus['scene']

	ma    = bus['material']['material']

	brdf_name = "%s%s%s" % (ID, get_name(ma, prefix='MA'), bus['material']['orco_suffix'])
	if base_name:
		brdf_name = "%s%s%s" % (base_name, ID, bus['material']['orco_suffix'])
	if VRayBRDF:
		brdf_name += clean_string(VRayBRDF.name)

	BRDFHair3 = getattr(VRayBRDF, ID) if VRayBRDF else ma.vray.BRDFHair3

	ofile.write("\n%s %s {"%(ID,brdf_name))
	for param in PARAMS:
		if param == 'overall_color' and not VRayBRDF:
			value = ma.diffuse_color
		else:
			value = getattr(BRDFHair3,param)
		ofile.write("\n\t%s=%s;"%(param, a(scene,value)))
	ofile.write("\n}\n")

	return brdf_name


def gui(context, layout, BRDFHair3, material = None):
	wide_ui = context.region.width > ui.narrowui

	split = layout.split()
	col = split.column()
	if material:
		col.prop(material, 'diffuse_color', text = "Overall Color")
	else:
		col.prop(BRDFHair3, 'overall_color')
	if wide_ui:
		col = split.column()
	col.prop(BRDFHair3, 'transparency')

	layout.label(text = "Diffuse:")
	split = layout.split()
	col = split.column()
	col.prop(BRDFHair3, 'diffuse_color', text = "")
	if wide_ui:
		col = split.column()
	col.prop(BRDFHair3, 'diffuse_amount', text = "Amount")

	layout.label(text = "Primary specular:")
	split = layout.split()
	col = split.column()
	col.prop(BRDFHair3, 'primary_specular', text = "")
	if wide_ui:
		col = split.column()
	col.prop(BRDFHair3, 'primary_specular_amount', text = "Amount")
	col.prop(BRDFHair3, 'primary_glossiness', text = "Glossiness")

	layout.label(text = "Secondary specular:")
	split = layout.split()
	col = split.column()
	col.prop(BRDFHair3, 'secondary_specular', text = "")
	col.prop(BRDFHair3, 'secondary_lock_to_transmission')
	if wide_ui:
		col = split.column()
	col.prop(BRDFHair3, 'secondary_specular_amount', text = "Amount")
	col.prop(BRDFHair3, 'secondary_glossiness', text = "Glossiness")

	layout.label(text = "Transmission:")
	split = layout.split()
	col = split.column()
	col.prop(BRDFHair3, 'transmission', text = "")
	col.prop(BRDFHair3, 'transmission_amount', text = "Amount")
	if wide_ui:
		col = split.column()
	col.prop(BRDFHair3, 'transmission_glossiness_length', text = "Length")
	col.prop(BRDFHair3, 'transmission_glossiness_width', text = "Width")

	layout.label(text = "Options:")
	split = layout.split()
	col = split.column()
	col.prop(BRDFHair3, 'opaque_for_shadows')
	col.prop(BRDFHair3, 'opaque_for_gi')
	if wide_ui:
		col = split.column()
	col.prop(BRDFHair3, 'simplify_for_gi')
	col.prop(BRDFHair3, 'use_cached_gi')

########NEW FILE########
__FILENAME__ = BRDFLayered
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
import vb25.texture

from vb25.utils import *
from vb25.ui import ui
from vb25.plugins import *


TYPE= 'BRDF'
ID=   'BRDFLayered'
PID=   200 # BRDFLayered must be last
MAIN_BRDF= True

NAME= "BRDFLayered"
UI=   "Layered"
DESC= "BRDFLayered"

PARAMS= (
	'brdfs',
	'weights',
	'transparency',
	'transparency_tex',
	'transparency_tex_mult',
	'additive_mode',
	'channels',
)


def add_properties(rna_pointer):
	class VRayBRDF(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(VRayBRDF)

	class BRDFLayered(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(BRDFLayered)

	rna_pointer.BRDFLayered= PointerProperty(
		name= "BRDFLayered",
		type=  BRDFLayered,
		description= "V-Ray BRDFLayered settings"
	)

	# brdfs
	BRDFLayered.brdfs= CollectionProperty(
		name= "BRDFs",
		type=  VRayBRDF,
		description= "Material shaders collection"
	)

	BRDFLayered.brdf_selected= IntProperty(
		name= "Selected BRDF",
		description= "Selected BRDF",
		default= -1,
		min= -1,
		max= 100
	)

	brdfs= gen_menu_items(PLUGINS['BRDF'], none_item= False)

	VRayBRDF.type= EnumProperty(
		name= "BRDF Type",
		description= "BRDF type",
		items= (tuple(brdfs)),
		default= brdfs[4][0] # BRDFDiffuse
	)

	VRayBRDF.use= BoolProperty(
		name= "",
		description= "Use BRDF",
		default= True
	)

	# weights List()
	VRayBRDF.weight= FloatVectorProperty(
		name= "Weight",
		description= "Weight",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1.0,1.0,1.0)
	)

	VRayBRDF.weight_tex= StringProperty(
		name= "Weight texture",
		description= "Weight texture",
		default= ""
	)


	# transparency
	BRDFLayered.transparency= FloatVectorProperty(
		name= "Transparency",
		description= "",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0)
	)

	# transparency_tex
	BRDFLayered.transparency_tex= StringProperty(
		name= "Transparency",
		description= "",
		default= ""
	)

	BRDFLayered.map_transparency_tex= BoolProperty(
		name= "transparency tex",
		description= "",
		default= False
	)

	# transparency_tex_mult
	BRDFLayered.transparency_tex_mult= FloatProperty(
		name= "transparency tex mult",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# additive_mode
	BRDFLayered.additive_mode= BoolProperty(
		name= "Additive \"shellac\" mode",
		description= "Additive \"shellac\" blending mode",
		default= False
	)

	# channels List()

	return VRayBRDF



'''
  OUTPUT
'''
def mapto(bus, BRDFPlugin= None):
	scene= bus['scene']
	ma=    bus['material']['material']

	defaults= {}
	defaults['normal']=       ("AColor(0.0,0.0,0.0,1.0)", 0, 'NONE')
	defaults['displacement']= ("AColor(0.0,0.0,0.0,1.0)", 0, 'NONE')

	return defaults


def write(bus, VRayBRDF= None, base_name= None):
	ofile= bus['files']['materials']
	scene= bus['scene']

	material=     bus['material']['material']
	VRayMaterial= material.vray

	brdf_name= "%s%s%s" % (ID, get_name(material, prefix='MA'), bus['material']['orco_suffix'])
	if base_name:
		brdf_name= "%s%s%s" % (base_name, ID, bus['material']['orco_suffix'])
	if VRayBRDF:
		brdf_name+= clean_string(VRayBRDF.name)

	BRDFLayered= getattr(VRayBRDF, 'BRDFLayered') if VRayBRDF else getattr(VRayMaterial, 'BRDFLayered')

	if not BRDFLayered.brdfs:
		return bus['defaults']['brdf']

	brdfs=   []
	weights= []
	for i,brdf in enumerate(BRDFLayered.brdfs):
		brdfs.append(PLUGINS['BRDF'][brdf.type].write(bus, brdf, base_name= "%s%.2i" % (brdf_name,i)))

		weight_param= None
		if brdf.weight_tex:
			weight_param= vb25.texture.write_subtexture(bus, brdf.weight_tex)
		else:
			weight_param= "W%sI%i"%(brdfs[i],i)
			ofile.write("\nTexAColor %s {" % (weight_param))
			ofile.write("\n\ttexture= %s;" % ("AColor(%.3f,%.3f,%.3f,1.0)" % tuple(brdf.weight)))
			ofile.write("\n}\n")

		if weight_param is not None:
			weights.append(weight_param)
		else:
			weights.append("TEDefaultBlend")

	if len(brdfs) == 1:
		return brdfs[0]

	ofile.write("\nBRDFLayered %s {" % brdf_name)
	ofile.write("\n\tbrdfs= List(%s);" % ','.join(brdfs))
	ofile.write("\n\tweights= List(%s);" % ','.join(weights))
	ofile.write("\n\ttransparency= %s;" % p(BRDFLayered.transparency))
	ofile.write("\n\tadditive_mode= %s;" % p(BRDFLayered.additive_mode))
	ofile.write("\n}\n")

	return brdf_name



'''
  GUI
'''
def influence(context, layout, slot):
	wide_ui= context.region.width > ui.narrowui

	VRaySlot= slot.texture.vray_slot

def gui(context, layout, BRDFLayered, material= None):
	wide_ui= context.region.width > ui.narrowui

	row= layout.row()
	row.template_list("VRayListUse", "",
					  BRDFLayered, 'brdfs',
					  BRDFLayered, 'brdf_selected',
					  rows = 3)

	col= row.column()
	sub= col.row()
	subsub= sub.column(align=True)
	subsub.operator('vray.brdf_add',    text="", icon="ZOOMIN")
	subsub.operator('vray.brdf_remove', text="", icon="ZOOMOUT")
	sub= col.row()
	subsub= sub.column(align=True)
	subsub.operator("vray.brdf_up",   icon='MOVE_UP_VEC',   text="")
	subsub.operator("vray.brdf_down", icon='MOVE_DOWN_VEC', text="")

	split= layout.split()
	col= split.column()
	col.prop(BRDFLayered, 'additive_mode')

	layout.label(text="Transparency:")
	split= layout.split()
	row= split.row(align=True)
	row.prop(BRDFLayered, 'transparency', text="")
	if not wide_ui:
		row= split.column()
	row.prop_search(BRDFLayered, 'transparency_tex',
					bpy.data, 'textures',
					text= "")
	if BRDFLayered.transparency_tex:
		row.prop(BRDFLayered, 'transparency_tex_mult', text="Mult")

	# col.prop(BRDFLayered, 'channels')

	if BRDFLayered.brdf_selected >= 0:
		layout.separator()

		brdf= BRDFLayered.brdfs[BRDFLayered.brdf_selected]

		if wide_ui:
			split= layout.split(percentage=0.2)
		else:
			split= layout.split()
		col= split.column()
		col.label(text="Name:")
		if wide_ui:
			col= split.column()
		row= col.row(align=True)
		row.prop(brdf, 'name', text="")

		if wide_ui:
			split= layout.split(percentage=0.2)
		else:
			split= layout.split()
		col= split.column()
		col.label(text="Type:")
		if wide_ui:
			col= split.column()
		col.prop(brdf, 'type', text="")

		if wide_ui:
			split= layout.split(percentage=0.2)
		else:
			split= layout.split()
		col= split.column()
		col.label(text="Weight:")
		if wide_ui:
			col= split.row(align=True)
		else:
			col= col.column(align=True)
		col.prop(brdf, 'weight', text="")
		col.prop_search(brdf, 'weight_tex',
						bpy.data, 'textures',
						text= "")

		layout.separator()

		box = layout.box()
		box.active = brdf.use

		rna_pointer= getattr(brdf, brdf.type)
		if rna_pointer:
			plugin= PLUGINS['BRDF'].get(brdf.type)
			if plugin:
				plugin.gui(context, box, rna_pointer)

########NEW FILE########
__FILENAME__ = BRDFLight
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.texture import *
from vb25.utils   import *
from vb25.ui      import ui
from vb25.lib     import AttributeUtils


TYPE= 'BRDF'
ID=   'BRDFLight'
PID=   3
MAIN_BRDF= True

NAME= 'BRDFLight'
UI=   "Light"
DESC= "V-Ray light shader"

PARAMS= (
)

def add_properties(rna_pointer):
	class BRDFLight(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(BRDFLight)

	rna_pointer.BRDFLight= PointerProperty(
		name= "BRDFLight",
		type=  BRDFLight,
		description= "V-Ray BRDFLight settings"
	)

	BRDFLight.color = FloatVectorProperty(
		name = "Color",
		description = "Color",
		subtype = 'COLOR',
		min = 0.0,
		max = 1.0,
		soft_min = 0.0,
		soft_max = 1.0,
		default = (1.0,1.0,1.0),
		update = AttributeUtils.callback_match_BI_diffuse
	)

	BRDFLight.as_viewport_color = BoolProperty(
		name        = "Use As Viewport Color",
		description = "Use BRDF diffuse color as viewport color",
		default     = True,
		update      = AttributeUtils.callback_match_BI_diffuse
	)

	BRDFLight.color_tex= StringProperty(
		name= "Color texture",
		description= "Color texture",
		default= ""
	)

	BRDFLight.colorMultiplier= FloatProperty(
		name= "Multiplier",
		description= "Color multiplier",
		min= 0.0,
		max= 100000.0,
		soft_min= 0.0,
		soft_max= 100.0,
		default= 5.0
	)

	BRDFLight.doubleSided= BoolProperty(
		name= "Double-sided",
		description= "If false, the light color is black for back-facing surfaces",
		default= False
	)

	BRDFLight.emitOnBackSide= BoolProperty(
		name= "Emit on back side",
		description= '',
		default= False
	)

	BRDFLight.compensateExposure= BoolProperty(
		name= "Compensate camera exposure",
		description= '',
		default= False
	)

	BRDFLight.transparency= FloatProperty(
		name= "Transparency",
		description= "Transparency of the BRDF",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 1.0
	)



def mapto(bus, BRDFLayered= None):
	scene = bus['scene']
	ma    = bus['material']['material']

	defaults = {}

	VRayMaterial = ma.vray
	BRDFLight    = VRayMaterial.BRDFLight

	defaults['diffuse'] = (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)" % tuple(BRDFLight.color)),                  0, 'NONE')
	defaults['opacity'] = (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)" % tuple([1.0 - BRDFLight.transparency]*3)), 0, 'NONE')

	return defaults


def write(bus, VRayBRDF= None, base_name= None):
	scene=    bus['scene']
	ofile=    bus['files']['materials']

	ma=       bus['material']['material']
	textures= bus['textures']

	brdf_name= "%s%s%s" % (ID, get_name(ma, prefix='MA'), bus['material']['orco_suffix'])
	if base_name:
		brdf_name= "%s%s%s" % (base_name, ID, bus['material']['orco_suffix'])
	if VRayBRDF:
		brdf_name+= clean_string(VRayBRDF.name)

	BRDFLight= getattr(VRayBRDF, ID) if VRayBRDF else ma.vray.BRDFLight

	defaults= mapto(bus, VRayBRDF)

	if 'diffuse' in textures:
		color= textures['diffuse']
		# TODO:
		# if 'opacity' in textures:
		# 	alpha= write_TexInvert(ofile, scene, textures['opacity'])
		# 	color= write_TexCompMax(ofile, scene, {'name': "%s_alpha" % brdf_name,
		# 										   'sourceA': alpha,
		# 										   'sourceB': color,
		# 										   'opertor': 'Multiply'})
	else:
		color= defaults['diffuse'][0]

	ofile.write("\n%s %s {" % (ID, brdf_name))
	ofile.write("\n\tcolor= %s;" % color)
	ofile.write("\n\tcolorMultiplier= %s;" % a(scene, BRDFLight.colorMultiplier))
	ofile.write("\n\tcompensateExposure= %s;" % p(BRDFLight.compensateExposure))
	ofile.write("\n\temitOnBackSide= %s;" % p(BRDFLight.emitOnBackSide))
	ofile.write("\n\tdoubleSided= %s;" % p(BRDFLight.doubleSided))
	ofile.write("\n\ttransparency= %s;" % (textures['opacity'] if 'opacity' in textures else defaults['opacity'][0]))
	ofile.write("\n}\n")
	
	bus['brdf']= brdf_name

	return brdf_name



def influence(context, layout, slot):
	wide_ui = context.region.width > ui.narrowui

	VRaySlot = slot.texture.vray_slot

	split = layout.split()
	col = split.column()
	col.label(text="Diffuse:")
	split = layout.split()
	col = split.column()
	ui.factor_but(col, VRaySlot, 'map_diffuse', 'diffuse_mult', "Diffuse")
	if wide_ui:
		col = split.column()
	ui.factor_but(col, VRaySlot, 'map_opacity', 'opacity_mult', "Opacity")


def gui(context, layout, BRDFLight, material= None):
	wide_ui= context.region.width > ui.narrowui

	layout.label(text="Color:")

	split= layout.split()
	col= split.column()
	sub= col.column(align= True)

	sub.prop(BRDFLight, 'color', text="")
	sub.prop_search(BRDFLight, 'color_tex',
					bpy.data, 'textures',
					text= "")

	if wide_ui:
		col= split.column()

	col.prop(BRDFLight, 'transparency', text="Opacity", slider=True)
	col.prop(BRDFLight, 'as_viewport_color')

	layout.separator()

	split= layout.split()
	col= split.column()
	col.prop(BRDFLight, 'colorMultiplier', text="Intensity")
	if wide_ui:
		col= split.column()
	col.prop(BRDFLight, 'emitOnBackSide')
	col.prop(BRDFLight, 'compensateExposure', text="Compensate exposure")
	col.prop(BRDFLight, 'doubleSided')



########NEW FILE########
__FILENAME__ = BRDFMirror
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
import vb25.texture

from vb25.utils import *
from vb25.ui import ui


TYPE= 'BRDF'
ID=   'BRDFMirror'
PID=   6

NAME= 'BRDFMirror'
UI=   "Mirror"
DESC= "BRDFMirror."


PARAMS= (
	'color',
	'color_tex',
	'color_tex_mult',
	'transparency',
	'transparency_tex',
	'transparency_tex_mult',
	'cutoff',
	'back_side',
	'trace_reflections',
	'trace_depth',
	'reflect_exit_color',
	'reflect_dim_distance',
	'reflect_dim_distance_on',
	'reflect_dim_distance_falloff',
)

def add_properties(rna_pointer):
	class BRDFMirror(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(BRDFMirror)

	rna_pointer.BRDFMirror= PointerProperty(
		name= "BRDFMirror",
		type=  BRDFMirror,
		description= "V-Ray BRDFMirror settings"
	)

	# color
	BRDFMirror.color= FloatVectorProperty(
		name= "Color",
		description= "Mirror color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1,1,1)
	)

	# color_tex
	BRDFMirror.color_tex= StringProperty(
		name= "Color texture",
		description= "",
		default= ""
	)

	BRDFMirror.map_color_tex= BoolProperty(
		name= "Color texture",
		description= "",
		default= False
	)

	# color_tex_mult
	BRDFMirror.color_tex_mult= FloatProperty(
		name= "Color texture multiplier",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# transparency
	# BRDFMirror.transparency= FloatVectorProperty(
	# 	name= "Transparency",
	# 	description= "",
	# 	subtype= 'COLOR',
	# 	min= 0.0,
	# 	max= 1.0,
	# 	soft_min= 0.0,
	# 	soft_max= 1.0,
	# 	default= (0,0,0)
	# )

	BRDFMirror.transparency= FloatProperty(
		name= "Transparency",
		description= "BRDF transparency",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 0.0
	)

	# transparency_tex
	BRDFMirror.transparency_tex= StringProperty(
		name= "Transparency texture",
		description= "",
		default= ""
	)

	BRDFMirror.map_transparency_tex= BoolProperty(
		name= "Transparency texture",
		description= "",
		default= False
	)

	# transparency_tex_mult
	BRDFMirror.transparency_tex_mult= FloatProperty(
		name= "Transparency texture multiplier",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# cutoff
	BRDFMirror.cutoff= FloatProperty(
		name= "Cutoff",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.01
	)

	# back_side
	BRDFMirror.back_side= BoolProperty(
		name= "Back side",
		description= "",
		default= False
	)

	# trace_reflections
	BRDFMirror.trace_reflections= BoolProperty(
		name= "Trace reflections",
		description= "",
		default= True
	)

	# trace_depth
	BRDFMirror.trace_depth= IntProperty(
		name= "Depth",
		description= "The maximum reflection depth (-1 is controlled by the global options)",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= -1
	)

	# reflect_exit_color
	BRDFMirror.reflect_exit_color= FloatVectorProperty(
		name= "Exit color",
		description= "The color to use when the maximum depth is reached",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0)
	)

	BRDFMirror.map_reflect_exit_color= BoolProperty(
		name= "Exit color texture",
		description= "The color to use when the maximum depth is reached",
		default= False
	)

	BRDFMirror.reflect_exit_color_mult= FloatProperty(
		name= "Exit color texture multiplier",
		description= "The color to use when the maximum depth is reached",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# reflect_dim_distance
	BRDFMirror.reflect_dim_distance= FloatProperty(
		name= "Distance",
		description= "How much to dim reflection as length of rays increases",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1e+18
	)

	# reflect_dim_distance_on
	BRDFMirror.reflect_dim_distance_on= BoolProperty(
		name= "Dim distance",
		description= "True to enable dim distance",
		default= False
	)

	# reflect_dim_distance_falloff
	BRDFMirror.reflect_dim_distance_falloff= FloatProperty(
		name= "Falloff",
		description= "Fall off for the dim distance",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)



'''
  OUTPUT
'''
def write(bus, VRayBRDF= None, base_name= None):
	ofile= bus['files']['materials']
	scene= bus['scene']

	brdf_name= "%s%s%s" % (base_name, ID, clean_string(VRayBRDF.name))

	BRDFMirror= getattr(VRayBRDF, ID)
	
	textures= {}
	for param in PARAMS:
		if param.endswith('_tex'):
			textures[param]= vb25.texture.write_subtexture(bus, getattr(BRDFMirror, param))
	
	ofile.write("\n%s %s {"%(ID, brdf_name))
	for param in PARAMS:
		if param.endswith('_tex'):
			if param in textures and textures[param]:
				value= textures[param]
			else:
				continue
		elif param == 'transparency':
			value= mathutils.Color([1.0 - BRDFMirror.transparency]*3)
		else:
			value= getattr(BRDFMirror, param)
		ofile.write("\n\t%s= %s;" % (param, a(scene, value)))
	ofile.write("\n}\n")

	return brdf_name



'''
  GUI
'''
def gui(context, layout, BRDFMirror):
	wide_ui= context.region.width > ui.narrowui
	
	split= layout.split()
	col= split.column(align=True)
	col.prop(BRDFMirror, 'color', text="")
	col.prop_search(BRDFMirror, 'color_tex',
					bpy.data, 'textures',
					text= "")
	if BRDFMirror.color_tex:
		col.prop(BRDFMirror, 'color_tex_mult', text="Mult")
	if wide_ui:
		col= split.column(align=True)
	col.prop(BRDFMirror, 'transparency', text="Reflection", slider= True)
	col.prop_search(BRDFMirror, 'transparency_tex',
					bpy.data, 'textures',
					text= "")
	if BRDFMirror.transparency_tex:
		col.prop(BRDFMirror, 'transparency_tex_mult', text="Mult")

	layout.separator()

	split= layout.split()
	col= split.column()
	col.prop(BRDFMirror, 'cutoff')
	col.prop(BRDFMirror, 'back_side')
	col.prop(BRDFMirror, 'trace_reflections')
	col.prop(BRDFMirror, 'reflect_exit_color')
	if wide_ui:
		col= split.column()
	col.prop(BRDFMirror, 'reflect_dim_distance_on')
	if BRDFMirror.reflect_dim_distance_on:
		col.prop(BRDFMirror, 'reflect_dim_distance')
		col.prop(BRDFMirror, 'reflect_dim_distance_falloff')


########NEW FILE########
__FILENAME__ = BRDFSSS2Complex
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'BRDF'
ID=   'BRDFSSS2Complex'
PID=   2
MAIN_BRDF= True

NAME= 'BRDFSSS2Complex'
UI=   "SSS"
DESC= "Fast SSS 2 BRDF settings"

PARAMS= (
	'prepass_rate',
	'interpolation_accuracy',
	'scale',
	'ior',
	#'overall_color',
	#'diffuse_color',
	#'diffuse_amount',
	#'sub_surface_color',
	#'scatter_radius',
	'scatter_radius_mult',
	'phase_function',
	#'specular_color',
	#'specular_amount',
	#'specular_glossiness',
	'specular_subdivs',
	'cutoff_threshold',
	'trace_reflections',
	'reflection_depth',
	'single_scatter',
	'subdivs',
	'refraction_depth',
	'front_scatter',
	'back_scatter',
	'scatter_gi',
	'prepass_blur'
	#'channels'
)


def add_properties(rna_pointer):
	class VRAY_MT_preset_sss(bpy.types.Menu):
		bl_label= "SSS Presets"
		preset_subdir= os.path.join("..", "startup", "vb25", "presets", "sss")
		preset_operator = "script.execute_preset"
		draw = bpy.types.Menu.draw_preset
	bpy.utils.register_class(VRAY_MT_preset_sss)

	class BRDFSSS2Complex(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(BRDFSSS2Complex)

	rna_pointer.BRDFSSS2Complex= PointerProperty(
		name= "BRDFSSS2Complex",
		type=  BRDFSSS2Complex,
		description= "V-Ray BRDFSSS2Complex settings"
	)

	BRDFSSS2Complex.prepass_rate= IntProperty(
		name= "Prepass rate",
		description= "Sampling density for the illumination map",
		min= -10,
		max= 10,
		default= -1
	)

	BRDFSSS2Complex.interpolation_accuracy= FloatProperty(
		name= "Interpolation accuracy",
		description= "Interpolation accuracy for the illumination map; normally 1.0 is fine",
		min= 0.0,
		max= 10.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	BRDFSSS2Complex.scale= FloatProperty(
		name= "Scale",
		description= "Values below 1.0 will make the object look as if it is bigger. Values above 1.0 will make it look as if it is smalle",
		min= 0.0,
		max= 1000.0,
		soft_min= 0.0,
		soft_max= 1000.0,
		precision= 4,
		default= 1
	)

	BRDFSSS2Complex.ior= FloatProperty(
		name= "IOR",
		description= '',
		min= 0.0,
		max= 30.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.5
	)

	BRDFSSS2Complex.diffuse_amount= FloatProperty(
		name= "Diffuse amount",
		description= '',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 0.0
	)

	BRDFSSS2Complex.scatter_radius= FloatVectorProperty(
		name= "Scatter radius",
		description= '',
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.92,0.52,0.175)
	)

	BRDFSSS2Complex.scatter_radius_mult= FloatProperty(
		name= "Scatter radius",
		description= '',
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	BRDFSSS2Complex.overall_color= FloatVectorProperty(
		name= "Overall color",
		description= '',
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1.0,1.0,1.0)
	)

	BRDFSSS2Complex.diffuse_color= FloatVectorProperty(
		name= "Diffuse color",
		description= '',
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.5,0.5,0.5)
	)

	BRDFSSS2Complex.sub_surface_color= FloatVectorProperty(
		name= "Sub surface color",
		description= '',
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.5,0.5,0.5)
	)

	BRDFSSS2Complex.phase_function= FloatProperty(
		name= "Phase function",
		description= '',
		min= -1.0,
		max= 1.0,
		soft_min= -1.0,
		soft_max= 1.0,
		precision= 3,
		default= 0
	)

	BRDFSSS2Complex.specular_color= FloatVectorProperty(
		name= "Specular color",
		description= "Specular color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1.0,1.0,1.0)
	)

	BRDFSSS2Complex.specular_subdivs= IntProperty(
		name= "Specular subdivs",
		description= "Specular subdivs",
		min= 1,
		max= 1024,
		soft_min= 1,
		soft_max= 64,
		default= 8
	)

	BRDFSSS2Complex.specular_amount= FloatProperty(
		name= "Specular amount",
		description= "Specular amount",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 1
	)

	BRDFSSS2Complex.specular_glossiness= FloatProperty(
		name= "Specular glossiness",
		description= '',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 0.6
	)

	BRDFSSS2Complex.cutoff_threshold= FloatProperty(
		name= "Cutoff",
		description= '',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 0.01
	)

	BRDFSSS2Complex.trace_reflections= BoolProperty(
		name= "Trace reflections",
		description= "TODO",
		default= True
	)

	BRDFSSS2Complex.reflection_depth= IntProperty(
		name= "Reflection depth",
		description= '',
		min= 0,
		max= 10,
		default= 5
	)

	BRDFSSS2Complex.single_scatter= EnumProperty(
		name= "Single scatter",
		description= '',
		items= (
			('NONE',"None",""),
			('SIMPLE',"Simple",""),
			('SOLID',"Raytraced (solid)",""),
			('REFR',"Raytraced (refractive)","")
		),
		default= "SIMPLE"
	)

	BRDFSSS2Complex.subdivs= IntProperty(
		name= "Subdivs",
		description= '',
		min= 1,
		max= 1024,
		soft_min= 1,
		soft_max= 32,
		default= 8
	)

	BRDFSSS2Complex.refraction_depth= IntProperty(
		name= "Refraction depth",
		description= '',
		min= 0,
		max= 10,
		default= 5
	)

	BRDFSSS2Complex.front_scatter= BoolProperty(
		name= "Front scatter",
		description= '',
		default= True
	)

	BRDFSSS2Complex.back_scatter= BoolProperty(
		name= "Back scatter",
		description= '',
		default= True
	)

	BRDFSSS2Complex.scatter_gi= BoolProperty(
		name= "Scatter GI",
		description= '',
		default= False
	)

	BRDFSSS2Complex.prepass_blur= FloatProperty(
		name= "Prepass blur",
		description= '',
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.2
	)


def mapto(bus, BRDFLayered= None):
	scene= bus['scene']
	ma=    bus['material']['material']

	defaults= {}

	VRayMaterial=    ma.vray
	BRDFSSS2Complex= BRDFLayered.BRDFSSS2Complex if BRDFLayered else VRayMaterial.BRDFSSS2Complex

	if BRDFLayered:
		defaults['overall_color']=   (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(BRDFSSS2Complex.overall_color)), 0, 'NONE')
	else:
		defaults['overall_color']=   (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(ma.diffuse_color)), 0, 'NONE')

	defaults['sub_surface_color']=   (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(BRDFSSS2Complex.sub_surface_color)),  0, 'NONE')
	defaults['scatter_radius']=      (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(BRDFSSS2Complex.scatter_radius)),     0, 'NONE')
	defaults['diffuse_color']=       (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(BRDFSSS2Complex.diffuse_color)),      0, 'NONE')
	defaults['diffuse_amount']=      (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple([BRDFSSS2Complex.diffuse_amount]*3)), 0, 'NONE')
	defaults['specular_color']=      (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(BRDFSSS2Complex.specular_color)),     0, 'NONE')
	defaults['specular_amount']=     (a(scene,"AColor(0.0,0.0,0.0,1.0)"), 0, 'NONE')
	defaults['specular_glossiness']= (a(scene,"AColor(0.0,0.0,0.0,1.0)"), 0, 'NONE')

	defaults['normal']=       ("AColor(0.0,0.0,0.0,1.0)", 0, 'NONE')
	defaults['bump']=         ("AColor(0.0,0.0,0.0,1.0)", 0, 'NONE')
	defaults['displacement']= ("AColor(0.0,0.0,0.0,1.0)", 0, 'NONE')

	return defaults


def write(bus, VRayBRDF= None, base_name= None):
	SINGLE_SCATTER= {
		'NONE':   0,
		'SIMPLE': 1,
		'SOLID':  2,
		'REFR':   3,
	}

	scene= bus['scene']
	ofile= bus['files']['materials']

	ma=       bus['material']['material']
	textures= bus['textures']

	brdf_name= "%s%s%s" % (ID, get_name(ma, prefix='MA'), bus['material']['orco_suffix'])
	if base_name:
		brdf_name= "%s%s%s" % (base_name, ID, bus['material']['orco_suffix'])
	if VRayBRDF:
		brdf_name+= clean_string(VRayBRDF.name)

	BRDFSSS2Complex= getattr(VRayBRDF, ID) if VRayBRDF else ma.vray.BRDFSSS2Complex

	defaults= mapto(bus, VRayBRDF)

	ofile.write("\nBRDFSSS2Complex %s {" % brdf_name)

	for key in ('overall_color','diffuse_color','sub_surface_color','scatter_radius','specular_color'):
		ofile.write("\n\t%s= %s;" % (key, a(scene,textures[key]) if key in textures else defaults[key][0]))

	for key in ('specular_amount','specular_glossiness','diffuse_amount'):
		ofile.write("\n\t%s= %s;" % (key, "%s::out_intensity" % textures[key] if key in textures else a(scene,getattr(BRDFSSS2Complex,key))))

	for param in PARAMS:
		if param == 'single_scatter':
			value= SINGLE_SCATTER[BRDFSSS2Complex.single_scatter]
		else:
			value= getattr(BRDFSSS2Complex,param)
		ofile.write("\n\t%s= %s;"%(param, a(scene,value)))

	ofile.write("\n}\n")

	return brdf_name



def influence(context, layout, slot):
	wide_ui= context.region.width > ui.narrowui

	VRaySlot= slot.texture.vray_slot

	split= layout.split()
	col= split.column()
	col.label(text="SSS:")
	split= layout.split()
	col= split.column()
	ui.factor_but(col, VRaySlot, 'map_overall_color',     'overall_color_mult',     "Overall")
	ui.factor_but(col, VRaySlot, 'map_sub_surface_color', 'sub_surface_color_mult', "Sub-surface")
	if wide_ui:
		col= split.column()
	ui.factor_but(col, VRaySlot, 'map_scatter_radius',    'scatter_radius_mult',    "Scatter")

	layout.separator()

	split= layout.split()
	col= split.column()
	ui.factor_but(col, VRaySlot, 'map_diffuse_color',  'diffuse_color_mult',  "Diffuse")
	ui.factor_but(col, VRaySlot, 'map_diffuse_amount', 'diffuse_amount_mult', "Amount")
	if wide_ui:
		col= split.column()
	ui.factor_but(col, VRaySlot, 'map_specular_color',      'specular_color_mult',      "Specular")
	ui.factor_but(col, VRaySlot, 'map_specular_amount',     'specular_amount_mult',     "Amount")
	ui.factor_but(col, VRaySlot, 'map_specular_glossiness', 'specular_glossiness_mult', "Glossiness")


def gui(context, layout, BRDFSSS2Complex, material= None):
	wide_ui= context.region.width > ui.narrowui

	split= layout.split()
	col= split.column()
	col.label(text="General:")

	split= layout.split()
	col= split.column()
	col.menu('VRAY_MT_preset_sss', text="Presets")

	split= layout.split()
	col= split.column()
	col.prop(BRDFSSS2Complex, 'prepass_rate')
	col.prop(BRDFSSS2Complex, 'scale')
	if wide_ui:
		col= split.column()
	col.prop(BRDFSSS2Complex, 'ior')
	col.prop(BRDFSSS2Complex, 'interpolation_accuracy', text='Accuracy')

	layout.separator()

	split= layout.split()
	col= split.column()
	if material:
		col.prop(material, 'diffuse_color', text="Overall color")
	else:
		col.prop(BRDFSSS2Complex, 'overall_color')
	if wide_ui:
		col= split.column()
	col.prop(BRDFSSS2Complex, 'diffuse_color')
	split= layout.split()
	col= split.column()
	if wide_ui:
		col= split.column()
	col.prop(BRDFSSS2Complex, 'diffuse_amount', text="Amount")

	split= layout.split()
	col= split.column()
	col.prop(BRDFSSS2Complex, 'sub_surface_color')
	col.prop(BRDFSSS2Complex, 'phase_function')
	if wide_ui:
		col= split.column()
	col.prop(BRDFSSS2Complex, 'scatter_radius', text="Scatter color")
	col.prop(BRDFSSS2Complex, 'scatter_radius_mult', text="Radius")

	split= layout.split()
	col= split.column()
	col.label(text='Specular layer:')
	split= layout.split()
	col= split.column()
	col.prop(BRDFSSS2Complex, 'specular_color', text='')
	col.prop(BRDFSSS2Complex, 'specular_subdivs', text='Subdivs', slider= True)
	if wide_ui:
		col= split.column()
	col.prop(BRDFSSS2Complex, 'specular_amount', text='Amount')
	col.prop(BRDFSSS2Complex, 'specular_glossiness', text='Glossiness')
	col.prop(BRDFSSS2Complex, 'cutoff_threshold')

	split= layout.split()
	col= split.column()
	col.prop(BRDFSSS2Complex, 'trace_reflections')
	if BRDFSSS2Complex.trace_reflections:
		if wide_ui:
			col= split.column()
		col.prop(BRDFSSS2Complex, 'reflection_depth')

	layout.separator()

	split= layout.split()
	col= split.column()
	col.prop(BRDFSSS2Complex, 'single_scatter')

	split= layout.split()
	col= split.column()
	col.prop(BRDFSSS2Complex, 'subdivs', slider= True)
	col.prop(BRDFSSS2Complex, 'refraction_depth')
	col.prop(BRDFSSS2Complex, 'prepass_blur')
	if wide_ui:
		col= split.column()
	col.prop(BRDFSSS2Complex, 'front_scatter')
	col.prop(BRDFSSS2Complex, 'back_scatter')
	col.prop(BRDFSSS2Complex, 'scatter_gi')

########NEW FILE########
__FILENAME__ = BRDFVRayMtl
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui
from vb25.lib   import VRaySocket
from vb25.lib   import AttributeUtils


TYPE= 'BRDF'
ID=   'BRDFVRayMtl'
PID=   1
MAIN_BRDF= True

NAME= "VRayMtl"
UI=   "VRayMtl"
DESC= "BRDFVRayMtl settings."


PARAMS= (
	#'opacity',
	#'iffuse',
	#'roughness',
	##'brdf_type',
	#'reflect',
	#'reflect_glossiness',
	#'hilight_glossiness',
	'hilight_glossiness_lock',
	'fresnel',
	#'fresnel_ior',
	'fresnel_ior_lock',
	'reflect_subdivs',
	'reflect_trace',
	'reflect_depth',
	'reflect_exit_color',
	'hilight_soften',
	'reflect_dim_distance',
	'reflect_dim_distance_on',
	'reflect_dim_distance_falloff',
	'reflect_affect_alpha',
	#anisotropy',
	#anisotropy_rotation',
	'anisotropy_derivation',
	'anisotropy_axis',
	##'anisotropy_uvwgen',
	#'refract',
	#'refract_ior',
	'dispersion_on',
	'dispersion',
	#'refract_glossiness',
	'refract_subdivs',
	'refract_trace',
	'refract_depth',
	'refract_exit_color',
	'refract_exit_color_on',
	'refract_affect_alpha',
	'refract_affect_shadows',
	'fog_color',
	'fog_mult',
	'fog_bias',
	'fog_unit_scale_on',
	'translucency',
	#'translucency_color',
	'translucency_light_mult',
	'translucency_scatter_dir',
	'translucency_scatter_coeff',
	'translucency_thickness',
	'option_double_sided',
	'option_reflect_on_back',
	'option_glossy_rays_as_gi',
	'option_cutoff',
	'option_use_irradiance_map',
	'option_energy_mode',
	#'environment_override',
	'environment_priority',
)


def add_properties(rna_pointer):
	class BRDFVRayMtl(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(BRDFVRayMtl)

	rna_pointer.BRDFVRayMtl= PointerProperty(
		name= "BRDFVRayMtl",
		type=  BRDFVRayMtl,
		description= "V-Ray BRDFVRayMtl settings"
	)

	BRDFVRayMtl.diffuse= FloatVectorProperty(
		name        = "Diffuse",
		description = "Diffuse color",
		subtype     = 'COLOR',
		min         = 0.0,
		max         = 1.0,
		soft_min    = 0.0,
		soft_max    = 1.0,
		default     = (0.75,0.75,0.75),
		update      = AttributeUtils.callback_match_BI_diffuse
	)

	BRDFVRayMtl.as_viewport_color = BoolProperty(
		name        = "Use As Viewport Color",
		description = "Use BRDF diffuse color as viewport color",
		default     = True,
		update      = AttributeUtils.callback_match_BI_diffuse
	)

	BRDFVRayMtl.opacity= FloatProperty(
		name= "Opacity",
		description= "Opacity",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 1.0
	)

	BRDFVRayMtl.fog_color= FloatVectorProperty(
		name= "Fog color",
		description= "Fog color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1.0,1.0,1.0)
	)

	BRDFVRayMtl.refract_color= FloatVectorProperty(
		name= "Refraction color",
		description= "Refraction color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.0,0.0,0.0)
	)

	BRDFVRayMtl.reflect_color= FloatVectorProperty(
		name= "Reflection color",
		description= "Reflection color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.0,0.0,0.0)
	)

	BRDFVRayMtl.reflect_exit_color= FloatVectorProperty(
		name= "Reflection exit color",
		description= "Reflection exit color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.0,0.0,0.0)
	)

	BRDFVRayMtl.fresnel= BoolProperty(
		name= "Fresnel reflections",
		description= "Enable fresnel reflections",
		default= False
	)

	BRDFVRayMtl.fresnel_ior_lock= BoolProperty(
		name= "Fresnel reflections lock",
		description= "",
		default= False
	)

	BRDFVRayMtl.dispersion_on= BoolProperty(
		name= "Dispersion",
		description= "Enable dispersion",
		default= False
	)

	BRDFVRayMtl.dispersion= IntProperty(
		name= "Abbe",
		description= "Dispersion Abbe value",
		min= 1,
		max= 1024,
		soft_min= 1,
		soft_max= 100,
		default= 50
	)

	BRDFVRayMtl.fresnel_ior= FloatProperty(
		name= "Fresnel IOR",
		description= "",
		min= 0.0,
		max= 30.0,
		soft_min= 0.0,
		soft_max= 10.0,
		default= 1.6
	)

	BRDFVRayMtl.refract_ior= FloatProperty(
		name        = "Refractions IOR",
		description = "The IOR for refractions",
		min         = 0.0,
		max         = 30.0,
		soft_min    = 0.0,
		soft_max    = 10.0,
		precision   = 4,
		default     = 1.6
	)

	BRDFVRayMtl.reflect_subdivs= IntProperty(
		name= "Reflection subdivs",
		description= "Subdivs for glossy reflections",
		min= 1,
		max= 1000,
		default= 8
	)

	BRDFVRayMtl.reflect_depth= IntProperty(
		name= "Reflections depth",
		description= "The maximum depth for reflections",
		min= 1,
		max= 1000,
		default= 5
	)

	BRDFVRayMtl.refract_depth= IntProperty(
		name= "Refractions depth",
		description= "The maximum depth for refractions",
		min= 1,
		max= 1000,
		default= 5
	)

	BRDFVRayMtl.refract_subdivs= IntProperty(
		name= "Refraction subdivs",
		description= "Subdivs for glossy refractions",
		min= 1,
		max= 1000,
		default= 8
	)

	BRDFVRayMtl.roughness= FloatProperty(
		name= "Roughness",
		description= "",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 0.0
	)

	BRDFVRayMtl.hilight_glossiness= FloatProperty(
		name= "Hilight glossiness",
		description= "The glossiness of the hilights",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 1.0
	)

	BRDFVRayMtl.reflect_glossiness= FloatProperty(
		name= "Reflection glossiness",
		description= "The glossiness of the reflections",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 1.0
	)

	BRDFVRayMtl.refract_glossiness= FloatProperty(
		name= "Refraction glossiness",
		description= "The glossiness of the refractions",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 1.0
	)

	BRDFVRayMtl.hilight_glossiness_lock= BoolProperty(
		name= "Hilight glossiness lock",
		description= "",
		default= True
	)

	BRDFVRayMtl.hilight_soften= FloatProperty(
		name= "Hilight soften",
		description= "How much to soften hilights and reflections at grazing light angles",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 0.0
	)

	BRDFVRayMtl.reflect_dim_distance_on= BoolProperty(
		name= "Dim distance",
		description= "Dim distance",
		default= False
	)

	BRDFVRayMtl.reflect_dim_distance= FloatProperty(
		name= "Dim distance",
		description= "How much to dim reflection as length of rays increases",
		min= 0.0,
		max= 100000000.0,
		soft_min= 0.0,
		soft_max= 10000.0,
		default= 100.0
	)

	BRDFVRayMtl.reflect_dim_distance_falloff= FloatProperty(
		name= "Dim distance falloff",
		description= "Falloff for the dim distance",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	BRDFVRayMtl.anisotropy_derivation= IntProperty(
		name= "anisotropy derivation",
		description= "What method to use for deriving anisotropy axes (0 - local object axis; 1 - a specified uvw generator)",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 0
	)

	BRDFVRayMtl.anisotropy_axis= IntProperty(
		name= "anisotropy axis",
		description= "Which local object axis to use when anisotropy_derivation is 0",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 2
	)

	BRDFVRayMtl.refract_affect_shadows= BoolProperty(
		name= "Affect shadows",
		description= "",
		default= False
	)

	BRDFVRayMtl.refract_affect_alpha= EnumProperty(
		name= "Affect Channels",
		description= "Which channels refractions affect",
		items= (
			('COL',  "Color Only",   "The transperency will affect only the RGB channel of the final render."),
			('RERF', "Color+Alpha",  "This will cause the material to transmit the alpha of the refracted objects, instead of displaying an opaque alpha.."),
			('ALL',  "All Channels", "All channels and render elements will be affected by the transperency of the material.")
		),
		default= 'COL'
	)

	BRDFVRayMtl.reflect_affect_alpha= EnumProperty(
		name= "Affect Channels",
		description= "Which channels reflections affect",
		items= (
			('COL',  "Color Only",   "The transperency will affect only the RGB channel of the final render."),
			('RERF', "Color+Alpha",  "This will cause the material to transmit the alpha of the refracted objects, instead of displaying an opaque alpha.."),
			('ALL',  "All Channels", "All channels and render elements will be affected by the transperency of the material.")
		),
		default= 'COL'
	)

	BRDFVRayMtl.fog_mult= FloatProperty(
		name= "Fog multiplier",
		description= "Multiplier for the absorption",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 4,
		default= 0.1
	)

	BRDFVRayMtl.fog_unit_scale_on= BoolProperty(
		name= "Fog unit scale",
		description= "Enable unit scale multiplication, when calculating absorption",
		default= True
	)

	BRDFVRayMtl.fog_bias= FloatProperty(
		name= "Fog bias",
		description= "Bias for the absorption",
		min= -100.0,
		max= 100.0,
		soft_min= -1.0,
		soft_max= 1.0,
		precision= 4,
		default= 0.0
	)

	BRDFVRayMtl.anisotropy= FloatProperty(
		name= "Anisotropy",
		description= "The anisotropy for glossy reflections",
		min= -1.0,
		max= 1.0,
		soft_min= -1.0,
		soft_max= 1.0,
		default= 0.0
	)

	BRDFVRayMtl.anisotropy_rotation= FloatProperty(
		name= "Rotation",
		description= "The rotation of the anisotropy axes",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 0.0
	)

	BRDFVRayMtl.brdf_type= EnumProperty(
		name= "BRDF type",
		description= "This determines the type of BRDF (the shape of the hilight)",
		items= (
			('PHONG',"Phong","Phong hilight/reflections."),
			('BLINN',"Blinn","Blinn hilight/reflections."),
			('WARD',"Ward","Ward hilight/reflections.")
		),
		default= 'BLINN'
	)

	BRDFVRayMtl.refract_trace= BoolProperty(
		name= "Trace refractions",
		description= "",
		default= True
	)

	BRDFVRayMtl.refract_exit_color= FloatVectorProperty(
		name= "Refraction exit color",
		description= "The color to use when maximum depth is reached when refract_exit_color_on is true",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0)
	)

	BRDFVRayMtl.refract_exit_color_on= BoolProperty(
		name= "Use refraction exit color",
		description= "If false, when the maximum refraction depth is reached, the material is assumed transparent, instead of terminating the ray",
		default= False
	)

	BRDFVRayMtl.reflect_trace= BoolProperty(
		name= "Trace reflections",
		description= "Trace reflections",
		default= True
	)

	BRDFVRayMtl.option_reflect_on_back= BoolProperty(
		name= "Reflect on back side",
		description= "Reflect on back side",
		default= False
	)

	BRDFVRayMtl.option_double_sided= BoolProperty(
		name= "Double-sided",
		description= "Double-sided",
		default= True
	)

	BRDFVRayMtl.option_glossy_rays_as_gi= EnumProperty(
		name= "Glossy rays as GI",
		description= "Specifies when to treat GI rays as glossy rays (0 - never; 1 - only for rays that are already GI rays; 2 - always",
		items= (
			('ALWAYS',"Always",""),
			('GI',"Only for GI rays",""),
			('NEVER',"Never","")
		),
		default= 'GI'
	)

	BRDFVRayMtl.option_cutoff= FloatProperty(
		name= "Cutoff",
		description= "Specifies a cutoff threshold for tracing reflections/refractions",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 0.001
	)

	BRDFVRayMtl.option_use_irradiance_map= BoolProperty(
		name= "Use Irradiance Map",
		description= "false to perform local brute-force GI calculatons and true to use the current GI engine",
		default= True
	)

	BRDFVRayMtl.option_energy_mode= EnumProperty(
		name= "Energy mode",
		description= "Energy preservation mode for reflections and refractions",
		items= (
			('MONO',"Monochrome",""),
			('COLOR',"Color","")
		),
		default= 'COLOR'
	)

	BRDFVRayMtl.environment_priority= IntProperty(
		name= "Environment priority",
		description= "Environment override priority (used when several materials override it along a ray path)",
		min= 0,
		max= 100,
		default= 0
	)

	BRDFVRayMtl.translucency= EnumProperty(
		name= "Translucency",
		description= "Translucency mode",
		items= (
			('HYBRID',"Hybrid model",""),
			('SOFT',"Soft (water) model",""),
			('HARD',"Hard (wax) model",""),
			('NONE',"None","")
		),
		default= 'NONE'
	)

	BRDFVRayMtl.translucency_color= FloatVectorProperty(
		name= "Translucency_color",
		description= "Filter color for the translucency effect",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1.0,1.0,1.0)
	)

	BRDFVRayMtl.translucency_light_mult= FloatProperty(
		name= "Translucency light mult",
		description= "A multiplier for the calculated lighting for the translucency effect",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 1
	)

	BRDFVRayMtl.translucency_thickness= FloatProperty(
		name= "Translucency thickness",
		description= "Maximum distance to trace inside the object",
		min= 0.0,
		max= 100000.0,
		soft_min= 0.0,
		soft_max= 10000.0,
		precision= 3,
		default= 1000.0
	)

	BRDFVRayMtl.translucency_scatter_dir= FloatProperty(
		name= "Translucency scatter dir",
		description= "Scatter direction (0.0 is backward, 1.0 is forward)",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 0.5
	)

	BRDFVRayMtl.translucency_scatter_coeff= FloatProperty(
		name= "Translucency scatter coeff",
		description= "Scattering cone (0.0 - no scattering, 1.0 - full scattering",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 0
	)



'''
  OUTPUT
'''
def mapto(bus, BRDFLayered= None):
	scene= bus['scene']
	ma=    bus['material']['material']

	VRayMaterial= ma.vray

	BRDFVRayMtl=  BRDFLayered.BRDFVRayMtl if BRDFLayered else VRayMaterial.BRDFVRayMtl

	defaults= {}

	defaults['diffuse']= (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(BRDFVRayMtl.diffuse)),     0, 'NONE')
	if BRDFLayered:
		defaults['opacity']= (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple([BRDFVRayMtl.opacity]*3)), 0, 'NONE')
	else:
		# defaults['diffuse']= (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(ma.diffuse_color)),        0, 'NONE')
		defaults['opacity']= (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple([ma.alpha]*3)),            0, 'NONE')

	defaults['roughness']= (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple([BRDFVRayMtl.roughness]*3)), 0, 'NONE')

	defaults['reflect_glossiness']=  (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple([BRDFVRayMtl.reflect_glossiness]*3)),  0, 'NONE')
	defaults['hilight_glossiness']=  (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple([BRDFVRayMtl.hilight_glossiness]*3)),  0, 'NONE')

	defaults['reflect']=             (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(BRDFVRayMtl.reflect_color)),           0, 'NONE')
	defaults['anisotropy']=          (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple([BRDFVRayMtl.anisotropy]*3)),          0, 'NONE')
	defaults['anisotropy_rotation']= (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple([BRDFVRayMtl.anisotropy_rotation]*3)), 0, 'NONE')
	defaults['refract']=             (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(BRDFVRayMtl.refract_color)),           0, 'NONE')
	defaults['refract_glossiness']=  (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple([BRDFVRayMtl.refract_glossiness]*3)),  0, 'NONE')
	defaults['translucency_color']=  (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(BRDFVRayMtl.translucency_color)),      0, 'NONE')

	defaults['fresnel_ior']=  ("AColor(0.0,0.0,0.0,1.0)", 0, 'NONE')
	defaults['refract_ior']=  ("AColor(0.0,0.0,0.0,1.0)", 0, 'NONE')
	defaults['normal']=       ("AColor(0.0,0.0,0.0,1.0)", 0, 'NONE')
	defaults['bump']=         ("AColor(0.0,0.0,0.0,1.0)", 0, 'NONE')
	defaults['displacement']= ("AColor(0.0,0.0,0.0,1.0)", 0, 'NONE')

	return defaults


def write(bus, VRayBRDF= None, base_name= None):
	BRDF_TYPE= {
		'PHONG': 0,
		'BLINN': 1,
		'WARD':  2,
	}
	TRANSLUCENSY= {
		'NONE':   0,
		'HARD':   1,
		'SOFT':   2,
		'HYBRID': 3,
	}
	GLOSSY_RAYS= {
		'NEVER':  0,
		'GI':     1,
		'ALWAYS': 2,
	}
	ENERGY_MODE= {
		'COLOR': 0,
		'MONO':  1,
	}
	AFFECT_ALPHA= {
		'COL':  0,
		'RERF': 1,
		'ALL':  2
	}

	ofile=    bus['files']['materials']
	scene=    bus['scene']

	ma=       bus['material']['material']
	textures= bus['textures']

	brdf_name= "%s%s%s" % (ID, get_name(ma, prefix='MA'), bus['material']['orco_suffix'])
	if base_name:
		brdf_name= "%s%s%s" % (base_name, ID, bus['material']['orco_suffix'])
	if VRayBRDF:
		brdf_name+= clean_string(VRayBRDF.name)

	BRDFVRayMtl= getattr(VRayBRDF, ID) if VRayBRDF else ma.vray.BRDFVRayMtl

	defaults= mapto(bus, VRayBRDF)

	ofile.write("\nBRDFVRayMtl %s {"%(brdf_name))
	ofile.write("\n\tbrdf_type= %s;"%(a(scene,BRDF_TYPE[BRDFVRayMtl.brdf_type])))

	for key in ('diffuse','reflect','refract','translucency_color'):
		ofile.write("\n\t%s= %s;" % (key, a(scene,textures[key]) if key in textures else defaults[key][0]))

	for key in ('roughness','reflect_glossiness','refract_glossiness','hilight_glossiness','fresnel_ior','refract_ior','anisotropy','anisotropy_rotation'):
		ofile.write("\n\t%s= %s;" % (key, "%s::out_intensity"%(textures[key]) if key in textures else a(scene,getattr(BRDFVRayMtl,key))))

	if 'opacity' in textures:
		ofile.write("\n\topacity= %s::out_intensity;" % textures['opacity'])
	else:
		ofile.write("\n\topacity= %s;" % a(scene, BRDFVRayMtl.opacity))

	for param in PARAMS:
		if param == 'translucency':
			value= TRANSLUCENSY[BRDFVRayMtl.translucency]
		elif param == 'refract_affect_alpha':
			value= AFFECT_ALPHA[BRDFVRayMtl.refract_affect_alpha]
		elif param == 'reflect_affect_alpha':
			value= AFFECT_ALPHA[BRDFVRayMtl.reflect_affect_alpha]
		elif param == 'translucency_thickness':
			value= BRDFVRayMtl.translucency_thickness * 1000000000000
		elif param == 'option_glossy_rays_as_gi':
			value= GLOSSY_RAYS[BRDFVRayMtl.option_glossy_rays_as_gi]
		elif param == 'option_energy_mode':
			value= ENERGY_MODE[BRDFVRayMtl.option_energy_mode]
		elif param == 'fog_mult':
			value= BRDFVRayMtl.fog_mult
		else:
			value= getattr(BRDFVRayMtl,param)
		ofile.write("\n\t%s= %s;"%(param, a(scene,value)))
	ofile.write("\n}\n")

	return brdf_name



'''
  GUI
'''
def influence(context, layout, slot):
	wide_ui= context.region.width > ui.narrowui

	VRaySlot= slot.texture.vray_slot

	split= layout.split()
	col= split.column()
	col.label(text="Diffuse:")
	split= layout.split()
	col= split.column()
	ui.factor_but(col, VRaySlot, 'map_diffuse',             'diffuse_mult',             "Diffuse")
	ui.factor_but(col, VRaySlot, 'map_roughness',           'roughness_mult',           "Roughness")
	if wide_ui:
		col= split.column()
	ui.factor_but(col, VRaySlot, 'map_opacity',             'opacity_mult',             "Opacity")

	split= layout.split()
	col= split.column()
	col.label(text="Reflection:")
	split= layout.split()
	col= split.column()
	ui.factor_but(col, VRaySlot, 'map_reflect',             'reflect_mult',             "Reflect")
	ui.factor_but(col, VRaySlot, 'map_reflect_glossiness',  'reflect_glossiness_mult',  "Glossiness")
	ui.factor_but(col, VRaySlot, 'map_hilight_glossiness',  'hilight_glossiness_mult',  "Hilight")
	if wide_ui:
		col= split.column()
	ui.factor_but(col, VRaySlot, 'map_anisotropy',          'anisotropy_mult',          "Anisotropy")
	ui.factor_but(col, VRaySlot, 'map_anisotropy_rotation', 'anisotropy_rotation_mult', "Rotation")
	ui.factor_but(col, VRaySlot, 'map_fresnel_ior',         'fresnel_ior_mult',         "Fresnel")

	split= layout.split()
	col= split.column()
	col.label(text="Refraction:")
	split= layout.split()
	col= split.column()
	ui.factor_but(col, VRaySlot, 'map_refract',            'refract_mult',            "Refract")
	ui.factor_but(col, VRaySlot, 'map_refract_glossiness', 'refract_glossiness_mult', "Glossiness")
	if wide_ui:
		col= split.column()
	ui.factor_but(col, VRaySlot, 'map_refract_ior',        'refract_ior_mult',        "IOR")
	ui.factor_but(col, VRaySlot, 'map_translucency_color', 'translucency_color_mult', "Translucency")


def gui_options(context, layout, BRDFVRayMtl, material= None):
	wide_ui= context.region.width > ui.narrowui

	split= layout.split()
	col= split.column()
	col.prop(BRDFVRayMtl, 'reflect_trace')
	col.prop(BRDFVRayMtl, 'refract_trace')
	col.prop(BRDFVRayMtl, 'option_cutoff')
	if wide_ui:
		col= split.column()
	col.prop(BRDFVRayMtl, 'option_double_sided')
	col.prop(BRDFVRayMtl, 'option_reflect_on_back')
	col.prop(BRDFVRayMtl, 'option_use_irradiance_map')

	split= layout.split()
	if wide_ui:
		sub= split.column(align=True)
		sub.prop(BRDFVRayMtl, 'reflect_dim_distance_on', text="Dim reflect ray distance")
		sub_r= sub.row()
		sub_r.active= BRDFVRayMtl.reflect_dim_distance_on
		sub_r.prop(BRDFVRayMtl, 'reflect_dim_distance', text="Distance")
		sub_r.prop(BRDFVRayMtl, 'reflect_dim_distance_falloff', text="Falloff")
	else:
		sub= split.column(align=True)
		sub.prop(BRDFVRayMtl, 'reflect_dim_distance_on')
		sub_r= sub.column()
		sub_r.active= BRDFVRayMtl.reflect_dim_distance_on
		sub_r.prop(BRDFVRayMtl, 'reflect_dim_distance', text="Distance")
		sub_r.prop(BRDFVRayMtl, 'reflect_dim_distance_falloff', text="Falloff")

	split= layout.split()
	col= split.column()
	col.prop(BRDFVRayMtl, 'reflect_exit_color')
	if wide_ui:
		col= split.column()
	col.prop(BRDFVRayMtl, 'refract_exit_color')

	layout.separator()

	split= layout.split()
	col= split.column()
	col.prop(BRDFVRayMtl, 'option_glossy_rays_as_gi')
	col.prop(BRDFVRayMtl, 'option_energy_mode')

	split= layout.split()
	col= split.column()
	col.prop(BRDFVRayMtl, 'environment_priority')


def gui(context, layout, BRDFVRayMtl, material=None, node=None):
	contextWidth = node.width if node else context.region.width
	wide_ui = contextWidth > ui.narrowui

	row= layout.row()
	colL= row.column()
	colL.label(text="Diffuse:")

	split= layout.split()
	col= split.column(align= True)
	# if material:
	# 	col.prop(material, 'diffuse_color', text="")
	# else:
	# 	col.prop(BRDFVRayMtl, 'diffuse', text="")
	col.prop(BRDFVRayMtl, 'diffuse', text="")
	col.prop(BRDFVRayMtl, 'opacity', slider=True)
	if wide_ui:
		col= split.column()
	col.prop(BRDFVRayMtl, 'roughness', slider=True)
	col.prop(BRDFVRayMtl, 'as_viewport_color')

	split= layout.split()
	col= split.column()
	col.label(text="Reflections:")

	split= layout.split()
	col= split.column()
	sub= col.column(align=True)
	sub.prop(BRDFVRayMtl, 'reflect_color', text="")
	if not BRDFVRayMtl.hilight_glossiness_lock:
		sub.prop(BRDFVRayMtl, 'hilight_glossiness', slider=True)
	sub.prop(BRDFVRayMtl, 'reflect_glossiness', text="Glossiness", slider=True)
	sub.prop(BRDFVRayMtl, 'reflect_subdivs', text="Subdivs")
	sub.prop(BRDFVRayMtl, 'reflect_depth', text="Depth")
	col.prop(BRDFVRayMtl, 'reflect_affect_alpha', text="Affect")

	if wide_ui:
		col= split.column()

	col.prop(BRDFVRayMtl, 'brdf_type', text="")
	col.prop(BRDFVRayMtl, "hilight_glossiness_lock")
	if not BRDFVRayMtl.brdf_type == 'PHONG':
		sub= col.column(align= True)
		sub.prop(BRDFVRayMtl, 'anisotropy', slider= True)
		sub.prop(BRDFVRayMtl, 'anisotropy_rotation', slider= True)
	col.prop(BRDFVRayMtl, 'fresnel')
	if BRDFVRayMtl.fresnel:
		col.prop(BRDFVRayMtl, 'fresnel_ior')

	split= layout.split()
	col= split.column()
	col.label(text="Refractions:")
	sub= col.column(align=True)
	sub.prop(BRDFVRayMtl, 'refract_color', text="")
	sub.prop(BRDFVRayMtl, 'refract_ior', text="IOR")
	sub.prop(BRDFVRayMtl, 'refract_glossiness', text="Glossiness", slider=True)
	sub.prop(BRDFVRayMtl, 'refract_subdivs', text="Subdivs")
	sub.prop(BRDFVRayMtl, 'refract_depth', text="Depth")
	if wide_ui:
		col= split.column()
	col.label(text="Fog:")
	sub= col.column(align=True)
	sub.prop(BRDFVRayMtl, 'fog_color', text="")
	sub.prop(BRDFVRayMtl, 'fog_mult', text="Mult")
	sub.prop(BRDFVRayMtl, 'fog_bias', slider=True, text="Bias")
	sub.prop(BRDFVRayMtl, 'dispersion_on')
	if BRDFVRayMtl.dispersion_on:
		sub.prop(BRDFVRayMtl, 'dispersion')

	split= layout.split()
	col= split.column()
	col.prop(BRDFVRayMtl, 'refract_affect_alpha', text="Affect")
	if wide_ui:
		col= split.column()
	col.prop(BRDFVRayMtl, 'refract_affect_shadows')

	layout.separator()

	split= layout.split()
	col= split.column()
	col.prop(BRDFVRayMtl, 'translucency')
	if BRDFVRayMtl.translucency != 'NONE':
		split= layout.split()
		col= split.column()
		col.prop(BRDFVRayMtl, 'translucency_color', text="")
		col.prop(BRDFVRayMtl, 'translucency_thickness', text="Thickness")
		if wide_ui:
			col= split.column()
		col.prop(BRDFVRayMtl, 'translucency_scatter_coeff', text="Scatter coeff")
		col.prop(BRDFVRayMtl, 'translucency_scatter_dir', text="Fwd/Bck coeff")
		col.prop(BRDFVRayMtl, 'translucency_light_mult', text="Light multiplier")

	if not material:
		layout.separator()

		gui_options(context, layout, BRDFVRayMtl)

########NEW FILE########
__FILENAME__ = CameraCommon
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'CAMERA'
ID=   'Camera'

NAME= 'Camera'
DESC= "V-Ray camera settings"

PARAMS= (
)


def add_properties(rna_pointer):
	rna_pointer.mode= EnumProperty(
		name= "Mode",
		description= "Camera mode",
		items=(
			('NORMAL',   "Normal",   ""),
			('PHYSICAL', "Physical", "")
		),
		default= 'NORMAL'
	)

	rna_pointer.override_fov= BoolProperty(
		name= "Override FOV",
		description= "Override FOV (if you need FOV > 180)",
		default= False
	)

	rna_pointer.use_camera_loop= BoolProperty(
		name= "Use in \"Camera loop\"",
		description= "Use camera in \"Camera loop\"",
		default= False
	)

	rna_pointer.fov= FloatProperty(
		name= "FOV",
		description= "Field of vision",
		min= 0.0,
		max= math.pi * 2,
		soft_min= 0.0,
		soft_max= math.pi * 2,
		subtype= 'ANGLE',
		precision= 2,
		default= math.pi / 4
	)


	'''
	  Hide From View
	'''
	rna_pointer.hide_from_view= BoolProperty(
		name= "Hide From View",
		description= "Hide objects from current view",
		default= False
	)

	rna_pointer.hf_all= BoolProperty(
		name= "Hide from everything",
		description= "Hide objects completely",
		default= False
	)

	rna_pointer.hf_all_auto= BoolProperty(
		name= "Hide from everything (automatic)",
		description= "Create group with name \"hf_<camera-name>\"",
		default= False
	)

	rna_pointer.hf_all_objects= StringProperty(
		name= "Objects",
		description= "Objects to hide completely: name{;name;etc}",
		default= ""
	)

	rna_pointer.hf_all_groups= StringProperty(
		name= "Groups",
		description= "Groups to hide completely: name{;name;etc}",
		default= ""
	)

	for key in ('camera','gi','reflect','refract','shadows'):
		setattr(rna_pointer, 'hf_%s' % key, bpy.props.BoolProperty(
			name= "Hide from %s" % key,
			description= "Hide objects from %s" % key,
			default= False)
		)

		setattr(rna_pointer, 'hf_%s_auto' % key, bpy.props.BoolProperty(
			name= "Auto",
			description= "Hide objects automaically from %s" % key,
			default= False)
		)

		setattr(rna_pointer, 'hf_%s_objects' % key, bpy.props.StringProperty(
			name= "Objects",
			description= "Objects to hide from %s" % key,
			default= "")
		)

		setattr(rna_pointer, 'hf_%s_groups' % key, bpy.props.StringProperty(
			name= "Groups",
			description= "Groups to hide from %s" % key,
			default= "")
		)

########NEW FILE########
__FILENAME__ = CameraPhysical
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'CAMERA'
ID=   'CameraPhysical'

NAME= 'Physical camera'
DESC= "V-Ray CameraPhysical settings"

PARAMS= (
	'film_width',
	'focal_length',
	'zoom_factor',
	'distortion',
	'distortion_type',
	'f_number',
	'lens_shift',
	'shutter_speed',
	'shutter_angle',
	'shutter_offset',
	'latency',
	'ISO',
	'dof_display_threshold',
	'exposure',
	'vignetting',
	'blades_enable',
	'blades_num',
	'blades_rotation',
	'center_bias',
	'anisotropy',
	'use_dof',
	'use_moblur',
	'subdivs'
	#'lens_file',
	#'horizontal_shift'
)


def add_properties(rna_pointer):
	class CameraPhysical(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(CameraPhysical)

	rna_pointer.CameraPhysical= PointerProperty(
		name= "CameraPhysical",
		type=  CameraPhysical,
		description= "Physical Camera settings"
	)

	CameraPhysical.use= BoolProperty(
		name= "Enable physical camera",
		description= "Enable physical camera",
		default= False
	)

	CameraPhysical.specify_fov= BoolProperty(
		name= "Use FOV",
		description= "Use field of view instead of use the focal length, film width, scale etc",
		default= True
	)

	CameraPhysical.f_number= FloatProperty(
		name= "F-number",
		description= "Determines the width of the camera aperture and, indirectly, exposure",
		min=0.0, max=1000.0,
		soft_min=0.0, soft_max=10.0,
		default= 8.0
	)

	CameraPhysical.white_balance= FloatVectorProperty(
		name= "White balance",
		description= "White balance",
		default= (1.0, 1.0, 1.0),
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		step= 3,
		precision= 3,
		options= {'ANIMATABLE'},
		subtype= 'COLOR',
		size= 3
	)

	CameraPhysical.latency= FloatProperty(
		name="Latency",
		description="CCD matrix latency, in seconds",  # for video camera
		min=0.0, max=100.0,
		soft_min=0.0, soft_max=10.0,
		default=0.0
	)

	CameraPhysical.lens_shift= FloatProperty(
		name="Lens shift",
		description="Shift lenses for 2-point perspective",
		min=-1.0,
		max=1.0,
		soft_min=-1.0,
		soft_max=1.0,
		default=0.0
	)

	CameraPhysical.ISO= FloatProperty(
		name="ISO",
		description="The film power (i.e. sensitivity)",
		min=0.0,
		max=10000.0,
		soft_min=0.0,
		soft_max=100.0,
		default=200.0
	)

	CameraPhysical.shutter_speed= FloatProperty(
		name="Shutter speed",
		description="The shutter speed, in inverse seconds", # for still camera
		min= 1.0,
		max= 10000.0,
		soft_min=0.0,
		soft_max=1000.0,
		default=300.0
	)

	CameraPhysical.focal_length= FloatProperty(
		name="Focal length",
		description="Specifies the equivalen focal length of the camera lens",
		min=0.0,
		max=200.0,
		soft_min=0.0,
		soft_max=10.0,
		default=40.0
	)

	CameraPhysical.dof_display_threshold= FloatProperty(
		name="DOF threshold",
		description="Display threshold for depth-of-field",
		min=0.0,
		max=1.0,
		soft_min=0.0,
		soft_max=1.0,
		default=0.0
	)

	CameraPhysical.distortion= FloatProperty(
		name="Distortion",
		description="Specifies the distortion coefficient for the camera lens",
		min=-1.0,
		max=1.0,
		soft_min=0.0,
		soft_max=1.0,
		default=0.0
	)

	CameraPhysical.distortion_type= IntProperty(
		name="Distortion type",
		description="",
		min=0,
		max=2,
		default=0
	)

	CameraPhysical.zoom_factor= FloatProperty(
		name="Zoom factor",
		description="Zoom factor",
		min=0.0,
		max=10.0,
		soft_min=0.0,
		soft_max=10.0,
		default=1.0
	)

	CameraPhysical.film_width= FloatProperty(
		name="Film width",
		description="Specifies the horizontal size of the film gate in milimeters",
		min=0.0,
		max=200.0,
		soft_min=0.0,
		soft_max=10.0,
		default=36.0
	)

	CameraPhysical.vignetting= FloatProperty(
		name="Vignetting",
		description="The optical vignetting effect of real-world cameras",
		min=0.0,
		max=100.0,
		soft_min=0.0,
		soft_max=2.0,
		default=1.0
	)

	CameraPhysical.shutter_angle= FloatProperty(
		name="Shutter angle",
		description="Shutter angle (in degrees)", # for cinema camera
		min=0.0,
		max=1000.0,
		soft_min=0.0,
		soft_max=10.0,
		default=180.0
	)

	CameraPhysical.shutter_offset= FloatProperty(
		name="Shutter offset",
		description="Shutter offset (in degress)", # for cinema camera
		min=0.0,
		max=1000.0,
		soft_min=0.0,
		soft_max=10.0,
		default=0.0
	)

	CameraPhysical.exposure= BoolProperty(
		name="Exposure",
		description="When this option is on, the f-number, Shutter speed and ISO settings will affect the image brightness",
		default= True
	)

	CameraPhysical.guess_lens_shift= BoolProperty(
		name= "Auto lens shift",
		description= "Calculate lens shift automatically",
		default= False
	)

	CameraPhysical.type= EnumProperty(
		name="Type",
		description="The type of the physical camera",
		items=(
			('STILL',     "Still",     ""),
			('CINEMATIC', "Cinematic", ""),
			('VIDEO',     "Video",     "")
		),
		default= 'STILL'
	)

	CameraPhysical.blades_enable= BoolProperty(
		name="Bokeh effects",
		description="Defines the shape of the camera aperture",
		default= False
	)

	CameraPhysical.blades_num= IntProperty(
		name="Blades number",
		description="Number of blades",
		min=1,
		max=100,
		default=5
	)

	CameraPhysical.blades_rotation= FloatProperty(
		name="Blades rotation",
		description="Defines the rotation of the blades",
		min=0.0,
		max=360.0,
		soft_min=0.0,
		soft_max=10.0,
		default=0.0
	)

	CameraPhysical.center_bias= FloatProperty(
		name="Center bias",
		description="Defines a bias shape for the bokeh effects",
		min=0.0,
		max=100.0,
		soft_min=0.0,
		soft_max=10.0,
		default=0.0
	)

	CameraPhysical.anisotropy= FloatProperty(
		name="Anisotropy",
		description="Allows stretching of the bokeh effect horizontally or vertically to simulate anamorphic lenses",
		min=0.0,
		max=1.0,
		soft_min=0.0,
		soft_max=1.0,
		default=0.0
	)

	CameraPhysical.use_dof= BoolProperty(
		name="Depth of field",
		description="Turns on depth of field sampling",
		default= False
	)

	CameraPhysical.use_moblur= BoolProperty(
		name="Motion blur",
		description="Turns on motion blur sampling",
		default= False
	)

	CameraPhysical.subdivs= IntProperty(
		name="Subdivs",
		description="The number of samples for calculating depth of field and/or motion blur",
		min=1,
		max=100,
		default=6
	)


def get_lens_shift(ob):
	shift= 0.0
	constraint= None
	if len(ob.constraints) > 0:
		for co in ob.constraints:
			if co.type in ('TRACK_TO','DAMPED_TRACK','LOCKED_TRACK'):
				constraint= co
				break
	if constraint:
		constraint_ob= constraint.target
		if constraint_ob:
			z_shift= ob.matrix_world.to_translation()[2] - constraint_ob.matrix_world.to_translation()[2]
			l= get_distance(ob, constraint_ob)
			shift= -1.0 * z_shift / l
	else:
		rx= ob.rotation_euler[0]
		lsx= rx - math.pi / 2
		if math.fabs(lsx) > 0.0001:
			shift= math.tan(lsx)
		if math.fabs(shift) > math.pi:
			shift= 0.0
	return shift


def write(bus):
	TYPE= {
		'STILL':     0,
		'CINEMATIC': 1,
		'VIDEO':     2,
	}

	ofile=  bus['files']['camera']
	scene=  bus['scene']
	camera= bus['camera']

	VRayCamera=     camera.data.vray
	CameraPhysical= VRayCamera.CameraPhysical

	fov= VRayCamera.fov if VRayCamera.override_fov else camera.data.angle

	aspect= scene.render.resolution_x / scene.render.resolution_y

	if aspect < 1.0:
		fov= fov * aspect

	focus_distance= camera.data.dof_distance
	if camera.data.dof_object:
		focus_distance= get_distance(camera, camera.data.dof_object)

	if focus_distance < 0.001:
		focus_distance= 200.0

	if CameraPhysical.use:
		ofile.write("\n// Camera: %s" % (camera.name))
		ofile.write("\nCameraPhysical PhysicalCamera {")
		ofile.write("\n\ttype= %d;" % TYPE[CameraPhysical.type])
		ofile.write("\n\tspecify_focus= 1;")
		ofile.write("\n\tfocus_distance= %s;" % a(scene,focus_distance))
		ofile.write("\n\tspecify_fov= %i;" % CameraPhysical.specify_fov)
		ofile.write("\n\tfov= %s;" % a(scene,fov))
		ofile.write("\n\twhite_balance= %s;" % a(scene, CameraPhysical.white_balance))

		for param in PARAMS:
			if param == 'lens_shift' and CameraPhysical.guess_lens_shift:
				value= get_lens_shift(camera)
			else:
				value= getattr(CameraPhysical,param)
			ofile.write("\n\t%s= %s;"%(param, a(scene,value)))

		ofile.write("\n\thorizontal_offset= %s;" % a(scene, -camera.data.shift_x))
		ofile.write("\n\tvertical_offset= %s;"   % a(scene, -camera.data.shift_y))
		ofile.write("\n}\n")


########NEW FILE########
__FILENAME__ = CameraStereoscopic
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE = 'CAMERA'
ID   = 'CameraStereoscopic'
PLUG = 'CameraStereoscopic'

NAME = 'Stereoscopic camera'
DESC = "V-Ray CameraStereoscopic settings"

PARAMS = (
	'stereo_base',
	'stereo_distance',
	'use_convergence',
)


def stereoRigUpdate(self, context):
	# Dirty hack to update stereo rig drivers
	context.scene.frame_set(context.scene.frame_current)


def add_properties(rna_pointer):
	class CameraStereoscopic(bpy.types.PropertyGroup):
		def CalcAngle(self, cam):
			stereo_base = cam.stereo_base
			focal_dist = cam.stereo_distance
			if(cam.use_convergence):
				cam_angle = math.degrees( math.atan2((stereo_base/2), focal_dist) )
				return cam_angle
			else:
				return 0.0

	bpy.utils.register_class(CameraStereoscopic)

	rna_pointer.CameraStereoscopic = PointerProperty(
		name        = "CameraStereoscopic",
		type        =  CameraStereoscopic,
		description = "Stereoscopic Camera settings"
	)

	CameraStereoscopic.use = BoolProperty(
		name        = "Enable Stereoscopic camera",
		description = "Enable Stereoscopic camera",
		default     = False
	)

	CameraStereoscopic.sucess_create = BoolProperty(
		name        = "flag",
		description = "flag",
		default     = False
	)

	CameraStereoscopic.use_convergence = BoolProperty(
		name        = "Use convergence",
		description = "",
		default     = False,
		update      = stereoRigUpdate
	)

	CameraStereoscopic.stereo_base = FloatProperty(
		name        = "Eye Distance",
		description = "Determines the width of the camera aperture and, indirectly, exposure",
		min         = 0.0,
		max         = 100.0,
		soft_min    = 0.0,
		soft_max    = 1.0,
		precision   = 4,
		default     = 0.065,
		update      = stereoRigUpdate
	)

	CameraStereoscopic.stereo_distance= FloatProperty(
		name        = "Distance",
		description = "Determines the width of the camera aperture and, indirectly, exposure",
		min         = 0.0,
		max         = 100000.0,
		soft_min    = 0.0,
		soft_max    = 100.0,
		default     = 20.0,
		update      = stereoRigUpdate
	)

	CameraStereoscopic.LeftCam = StringProperty(
		name        = "LeftCam",
		description = "",
		default     = ""
	)

	CameraStereoscopic.RightCam = StringProperty(
		name        = "RightCam",
		description = "",
		default     = ""
	)

	CameraStereoscopic.TargetCam = StringProperty(
		name        = "TargetCam",
		description = "",
		default     = ""
	)

	CameraStereoscopic.show_limits = BoolProperty(
		name        = "Show Limits",
		description = "",
		default     = True,
		update      = stereoRigUpdate
	)

	CameraStereoscopic.show_cams = BoolProperty(
		name        = "Show L/R cameras",
		description = "",
		default     = True,
		update      = stereoRigUpdate
	)


def create_stereo_cam(context):
	cam = context.object
	
	# print(cam.name)

	cam_obj = context.camera
	
	bpy.ops.object.add(type='CAMERA')
	left_cam = bpy.context.active_object
	left_cam.name = 'LeftCam'
	left_cam.parent = cam
	left_cam.lock_rotation = [True, True, True]
	left_cam.lock_scale = [True, True, True]
	left_cam.lock_location = [True, True, True]
	left_cam.location = [0,0,0]
	left_cam_obj = left_cam.data
	
	left_cam_obj.show_limits = True
	left_cam_obj.draw_size = cam_obj.draw_size
	cam_obj.vray.CameraStereoscopic.LeftCam = left_cam.name

	bpy.ops.object.add(type='CAMERA')
	right_cam = bpy.context.active_object
	right_cam.name = 'RightCam'
	right_cam.parent = cam
	right_cam.lock_rotation = [True, True, True]
	right_cam.lock_scale = [True, True, True]
	right_cam.lock_location = [True, True, True]
	right_cam.location = [0,0,0]
	right_cam_obj = right_cam.data
	right_cam_obj.show_limits = True
	right_cam_obj.draw_size = cam_obj.draw_size
	cam_obj.vray.CameraStereoscopic.RightCam = right_cam.name
	
	bpy.ops.object.add(type='EMPTY')
	target_cam = bpy.context.active_object
	target_cam.name = 'ZeroParallax'
	target_cam.empty_draw_size = 0.2
	target_cam.parent = cam
	target_cam.lock_rotation = [True, True, True]
	target_cam.lock_scale = [True, True, True]
	target_cam.lock_location = [True, True, True]
	target_cam.location = [0,0,-5]
	cam_obj.vray.CameraStereoscopic.TargetCam = target_cam.name
	
	left_cam_obj.dof_object = target_cam
	right_cam_obj.dof_object = target_cam

	left_cam_driver = left_cam_obj.driver_add('lens').driver
	left_cam_driver.type = 'SCRIPTED'
	left_cam_driver.expression = "bpy.data.cameras['"+cam_obj.name+"'].lens"

	left_cam_driver = left_cam_obj.driver_add('show_limits').driver
	left_cam_driver.type = 'SCRIPTED'
	left_cam_driver.expression = "bpy.data.cameras['"+cam_obj.name+"'].vray.CameraStereoscopic.show_limits"

	left_cam_driver = left_cam.driver_add('rotation_euler',1).driver
	left_cam_driver.type = 'SCRIPTED'
	left_cam_driver.expression = "-radians(bpy.data.cameras['"+cam_obj.name+"'].vray.CameraStereoscopic.CalcAngle(bpy.data.cameras['"+cam_obj.name+"'].vray.CameraStereoscopic))"

	left_cam_driver = left_cam.driver_add('hide').driver
	left_cam_driver.type = 'SCRIPTED'
	left_cam_driver.expression = "not bpy.data.cameras['"+cam_obj.name+"'].vray.CameraStereoscopic.show_cams"

	right_cam_driver = right_cam_obj.driver_add('lens').driver
	right_cam_driver.type = 'SCRIPTED'
	right_cam_driver.expression = "bpy.data.cameras['"+cam_obj.name+"'].lens"

	right_cam_driver = right_cam_obj.driver_add('show_limits').driver
	right_cam_driver.type = 'SCRIPTED'
	right_cam_driver.expression = "bpy.data.cameras['"+cam_obj.name+"'].vray.CameraStereoscopic.show_limits"

	right_cam_driver = right_cam.driver_add('rotation_euler',1).driver
	right_cam_driver.type = 'SCRIPTED'
	right_cam_driver.expression = "radians(bpy.data.cameras['"+cam_obj.name+"'].vray.CameraStereoscopic.CalcAngle(bpy.data.cameras['"+cam_obj.name+"'].vray.CameraStereoscopic))"

	right_cam_driver = right_cam.driver_add('hide').driver
	right_cam_driver.type = 'SCRIPTED'
	right_cam_driver.expression = "not bpy.data.cameras['"+cam_obj.name+"'].vray.CameraStereoscopic.show_cams"
    
	left_cam_driver = left_cam.driver_add('location',0).driver
	left_cam_driver.type = 'SCRIPTED'
	left_cam_driver.expression = "bpy.data.cameras['"+cam_obj.name+"'].vray.CameraStereoscopic.stereo_base/2*-1"

	right_cam_driver = right_cam.driver_add('location',0).driver
	right_cam_driver.type = 'SCRIPTED'
	right_cam_driver.expression = "bpy.data.cameras['"+cam_obj.name+"'].vray.CameraStereoscopic.stereo_base/2"

	target_cam_driver = target_cam.driver_add('location',2).driver
	target_cam_driver.type = 'SCRIPTED'
	target_cam_driver.expression = "-bpy.data.cameras['"+cam_obj.name+"'].vray.CameraStereoscopic.stereo_distance"

	left_cam.hide_select   = True
	left_cam.hide_render   = True
	right_cam.hide_select  = True
	right_cam.hide_render  = True
	target_cam.hide_select = True
	target_cam.hide_render = True

	target_cam.select = False
	cam.select = True
	bpy.context.scene.objects.active = cam   


def write(bus):
	ofile  = bus['files']['camera']
	scene  = bus['scene']
	camera = bus['camera']

	VRayScene      = scene.vray
	StereoSettings = VRayScene.VRayStereoscopicSettings
	
	VRayCamera = camera.data.vray
	CameraStereoscopic = VRayCamera.CameraStereoscopic

	if CameraStereoscopic.use and StereoSettings.use:
		camera_left  = bpy.data.objects.get(CameraStereoscopic.LeftCam)
		camera_right = bpy.data.objects.get(CameraStereoscopic.RightCam)

		ofile.write("\n\n// Camera Left: %s" % (clean_string(camera_left.name)))
		ofile.write("\nRenderView %s {" % (clean_string(camera_left.name)))
		ofile.write("\n\ttransform=%s;" % a(scene, transform(matrix_recalc(bus, camera_left, "left"))))
		ofile.write("\n}\n")

		ofile.write("\n\n// Camera Right: %s" % (clean_string(camera_right.name)))
		ofile.write("\nRenderView %s {" % (clean_string(camera_right.name)))
		ofile.write("\n\ttransform=%s;" % a(scene, transform(matrix_recalc(bus, camera_right, "right"))))
		ofile.write("\n}\n")


def matrix_recalc(bus, cam, pos):
	ofile  = bus['files']['camera']
	scene  = bus['scene']
	camera = bus['camera']

	VRayScene      = scene.vray
	StereoSettings = VRayScene.VRayStereoscopicSettings

	VRayCamera = camera.data.vray
	CameraStereoscopic = VRayCamera.CameraStereoscopic

	if pos == "left":
		shift = mathutils.Matrix.Translation((-CameraStereoscopic.stereo_base, 0, 0))
		mat_world = cam.matrix_world * shift
	else:
		mat_world = cam.matrix_world

	loc_w, rot_w, scale_w = mat_world.decompose()

	mat = cam.matrix_local
	loc, rot, scale = mat.decompose()
	mat_rot = rot_w.to_matrix()
	mat_rot = mat_rot.to_4x4()

	mat_loc = mathutils.Matrix.Translation((loc_w/2))

	if StereoSettings.adjust_resolution and StereoSettings.sm_mode != 'RENDER':
		mat_sca = mathutils.Matrix.Scale(2, 4, (0.0, 1.0, 0.0))
	else:
		mat_sca = mathutils.Matrix.Scale(1, 4)

	mat_out = mat_loc * mat_rot * mat_sca

	return mat_out


def remove_stereo_cam(context):
	cam_obj = context.camera.vray.CameraStereoscopic
	remove_obj(cam_obj.LeftCam)
	remove_obj(cam_obj.RightCam)
	remove_obj(cam_obj.TargetCam)


def remove_obj(name):
	ob = bpy.data.objects.get(name)

	for sce in bpy.data.scenes:
		try:
			sce.objects.unlink(ob)
		except:
			pass

	if ob.type != 'EMPTY':
		bpy.data.objects.remove(ob)


class VRAY_OT_create_stereo_cam(bpy.types.Operator):
	bl_idname      = 'vray.create_stereo_cam'
	bl_label       = "Show Stereo Camera"
	bl_description = "Create Visual model Stereo Camera"

	def execute(self, context):
		VRayCamera = context.camera.vray
		CameraStereoscopic = VRayCamera.CameraStereoscopic

		if not CameraStereoscopic.use:
			CameraStereoscopic.use = True
			# Check use_scripts_auto_execute settings
			#autoexec = context.user_preferences.system.use_scripts_auto_execute
			#if(autoexec):
			#	print(autoexec)
			create_stereo_cam(context)
		else:
			CameraStereoscopic.use = False
			remove_stereo_cam(context)

		return {'FINISHED'}

bpy.utils.register_class(VRAY_OT_create_stereo_cam)

########NEW FILE########
__FILENAME__ = DR
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'SETTINGS'

ID=   'DR'
NAME= 'Distributed render'
DESC= "Distributed render options."

PARAMS= (
)


def add_properties(rna_pointer):
	class VRayDR(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(VRayDR)

	rna_pointer.VRayDR= PointerProperty(
		name= "Distributed rendering",
		type=  VRayDR,
		description= "Distributed rendering settings"
	)

	VRayDR.on= BoolProperty(
		name= "Distributed rendering",
		description= "Distributed rendering",
		default= False
	)

	VRayDR.port= IntProperty(
		name= "Distributed rendering port",
		description= "Distributed rendering port",
		min= 0,
		max= 65535,
		default= 20204
	)

	VRayDR.shared_dir= StringProperty(
		name= "Shared directory",
		subtype= 'DIR_PATH',
		description= "Distributed rendering shader directory"
	)

	VRayDR.share_name= StringProperty(
		name= "Share name",
		default= "VRAYDR",
		description= "Share name"
	)

	VRayDR.transferAssets = EnumProperty(
		name        = "Transfer Assets",
		description = "Transfer assets for distributed rendering",
		items = (
			('0', "Shared Directory", ""),
			('1', "Auto Transfer", ""),
			('2', "Auto Transfer (With Cache Check)", ""),
		),
		default = '0',
	)

	VRayDR.renderOnlyOnNodes= BoolProperty(
		name        = "Render Only On Nodes",
		description = "Use distributed rendering excluding the local machine",
		default     = False
	)

	class VRayRenderNode(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(VRayRenderNode)

	VRayDR.nodes= CollectionProperty(
		name= "Render Nodes",
		type=  VRayRenderNode,
		description= "V-Ray render nodes"
	)

	VRayDR.nodes_selected= IntProperty(
		name= "Render Node Index",
		default= -1,
		min= -1,
		max= 100
	)

	VRayRenderNode.address= StringProperty(
		name= "IP/Hostname",
		description= "Render node IP or hostname"
	)

	VRayRenderNode.use = BoolProperty(
		name = "Use Node",
		description = "Use render node",
		default = True
	)

########NEW FILE########
__FILENAME__ = Exporter
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'SETTINGS'

ID=   'EXPORTER'
NAME= 'Exporter'
DESC= "Exporter options"

PARAMS= (
)


def add_properties(rna_pointer):
	class VRayExporter(bpy.types.PropertyGroup):
		random_material = BoolProperty(
			name        = "Randomize Materials",
			description = "Assing random material from emitter materials to the duplicated objects",
			default     = False
		)

	bpy.utils.register_class(VRayExporter)

	rna_pointer.exporter= PointerProperty(
		name= "Exporter",
		type=  VRayExporter,
		description= "Exporter settings"
	)

	VRayExporter.experimental = BoolProperty(
		name        = "Experimental",
		description = "Enable experimental options",
		default     = False
	)

	VRayExporter.draft= BoolProperty(
		name= "Draft render",
		description= "Render with low settings",
		default= False
	)

	VRayExporter.mesh_active_layers= BoolProperty(
		name= "Export meshes from active layers",
		description= "Export meshes from active layers only",
		default= False
	)

	VRayExporter.use_displace= BoolProperty(
		name= "Displace / subdiv",
		description= "Use displace / subdivisions",
		default= True
	)

	VRayExporter.image_to_blender= BoolProperty(
		name= "Image to Blender",
		description= "Pass image to Blender on render end (EXR file format is used)",
		default= False
	)

	VRayExporter.meshExportThreads = IntProperty(
		name        = "Mesh Export Threads",
		description = "Mesh Export Threads",
		min         = 0,
		max         = 100,
		soft_min    = 0,
		soft_max    = 10,
		default     = 0
	)

	VRayExporter.autoclose= BoolProperty(
		name= "Auto close",
		description= "Stop render and close VFB on Esc",
		default= False
	)

	VRayExporter.log_window= BoolProperty(
		name= "Show log window",
		description= "Show log window (Linux)",
		default= False
	)

	VRayExporter.use_feedback = BoolProperty(
		name        = "Render feedback",
		description = "Catch and show rendering progress",
		default     = False
	)

	VRayExporter.use_progress = BoolProperty(
		name        = "Show progress",
		description = "Catch and show calculations progress",
		default     = False
	)

	VRayExporter.wait = BoolProperty(
		name        = "Wait",
		description = "Wait for V-Ray to complete rendering",
		options     = {'HIDDEN'},
		default     = False
	)

	VRayExporter.log_window_type= EnumProperty(
		name= "Log window type",
		description= "Log window type",
		items= (
			('DEFAULT', "Default",        ""),
			('XTERM',   "XTerm",          ""),
			('GNOME',   "Gnome Terminal", ""),
			('KDE',     "Konsole",        ""),
			('CUSTOM',  "Custom",         "")
		),
		default= 'DEFAULT'
	)

	VRayExporter.log_window_term= StringProperty(
		name= "Log window terminal",
		description= "Log window terminal command",
		default= "x-terminal-emulator"
	)

	VRayExporter.animation= BoolProperty(
		name= "Animation",
		description= "Render animation",
		default= False
	)

	VRayExporter.animation_type = EnumProperty(
		name= "Animation Mode",
		description= "Animation Type",
		items= (
			('FRAMEBYFRAME', "Frame-By-Frame", "Export and render frame by frame"),
			('FULL',         "Full Range",     "Export full animation range then render"),
			('NOTMESHES',    "All But Meshes", "Export full animation range then render (meshes are not animated)")
		),
		default= 'FRAMEBYFRAME'
	)

	VRayExporter.check_animated= BoolProperty(
		name= "Check animated",
		description= "Detect animated meshes",
		default= False
	)

	VRayExporter.use_hair= BoolProperty(
		name= "Hair",
		description= "Render hair",
		default= True
	)

	VRayExporter.use_still_motion_blur = BoolProperty(
		name        = "Still Motion Blur",
		description = "Generate data for still motion blur",
		default     = False
	)

	VRayExporter.use_smoke= BoolProperty(
		name= "Smoke",
		description= "Render smoke",
		default= True
	)

	VRayExporter.use_smoke_hires= BoolProperty(
		name= "Smoke High Resolution",
		description= "Render high resolution smoke",
		default= True
	)

	VRayExporter.use_instances= BoolProperty(
		name= "Instances",
		description= "Use instances (Alt+D meshes will be the same; saves memory and faster export)",
		default= False
	)

	VRayExporter.camera_loop= BoolProperty(
		name= "Camera loop",
		description= "Render views from all cameras",
		default= False
	)

	VRayExporter.activeLayers= EnumProperty(
		name        = "Active layers",
		description = "Render objects from layers",
		items = (
			('ACTIVE', "Active", ""),
			('ALL',    "All",    ""),
			('CUSTOM', "Custom", "")
		),
		default = 'ACTIVE'
	)

	VRayExporter.customRenderLayers = BoolVectorProperty(
		subtype = 'LAYER',
		# default = [True]*20,
		size    = 20
	)

	VRayExporter.auto_meshes= BoolProperty(
		name= "Auto export meshes",
		description= "Export meshes automatically before render",
		default= True
	)

	VRayExporter.autorun= BoolProperty(
		name= "Autorun",
		description= "Start V-Ray automatically after export",
		default= True
	)

	VRayExporter.debug= BoolProperty(
		name= "Debug",
		description= "Enable script\'s debug output",
		default= False
	)

	VRayExporter.mesh_debug= BoolProperty(
		name= "Debug",
		description= "Enable build debug output",
		default= False
	)

	VRayExporter.output= EnumProperty(
		name= "Exporting directory",
		description= "Exporting directory",
		items= (
			('USER',"User-defined directory",""),
			('SCENE',"Scene file directory",""),
			('TMP',"Global TMP directory","")
		),
		default= 'TMP'
	)

	VRayExporter.detect_vray= BoolProperty(
		name= "Detect V-Ray",
		description= "Detect V-Ray binary location",
		default= True
	)

	VRayExporter.display_srgb= BoolProperty(
		name= "Display in sRGB",
		description= "Display colors on Vray Framebuffer in sRGB space",
		default= False
	)

	VRayExporter.vray_binary= StringProperty(
		name= "Path",
		subtype= 'FILE_PATH',
		description= "Path to V-Ray binary. Don\'t use relative path here - use absolute!"
	)

	VRayExporter.output_dir= StringProperty(
		name= "Directory",
		subtype= 'DIR_PATH',
		description= "User-defined output directory"
	)

	VRayExporter.output_unique= BoolProperty(
		name= "Use unique file name",
		description= "Use unique file name",
		default= False
	)

	VRayExporter.auto_save_render= BoolProperty(
		name= "Save render",
		description= "Save render automatically",
		default= False
	)

	VRayExporter.display= BoolProperty(
		name= "Display VFB",
		description= "Display VFB",
		default= True
	)

	VRayExporter.verboseLevel= EnumProperty(
		name= "Log level",
		description= "Specifies the verbose level of information printed to the standard output",
		items= (
			('0', "No information", "No information printed"),
			('1', "Only errors",    "Only errors"),
			('2', "Warnings",       "Errors and warnings"),
			('3', "Progress",       "Errors, warnings and informational messages"),
			('4', "All",            "All output"),
		),
		default= '3'
	)

	VRayExporter.socket_address= StringProperty(
		name        = "Socket address",
		description = "[TODO] V-Ray Standalone socket interface address",
		default     = "localhost"
	)

	VRayExporter.customFrame = IntProperty(
		name        = "Custom Frame",
		description = "Custom frame number",
		options     = {'HIDDEN'},
		min         = 0,
		max         = 1024,
		default     = 0
	)

########NEW FILE########
__FILENAME__ = GeomDisplacedMesh
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'GEOMETRY'
ID=   'GeomDisplacedMesh'

NAME= 'Displace'
DESC= "Displace settings."

PARAMS= (
	'displacement_amount',
	'displacement_shift',
	'water_level',
	'use_globals',
	'view_dep',
	'edge_length',
	'max_subdivs',
	'keep_continuity',
	'map_channel',
	'use_bounds',
	'min_bound',
	'max_bound',
	'resolution',
	'precision',
	'tight_bounds',
	'filter_texture',
	'filter_blur'
)

def add_properties(rna_pointer):
	class GeomDisplacedMesh(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(GeomDisplacedMesh)

	rna_pointer.GeomDisplacedMesh= PointerProperty(
		name= "GeomDisplacedMesh",
		type=  GeomDisplacedMesh,
		description= "GeomDisplacedMesh texture slot settings"
	)

	GeomDisplacedMesh.use= BoolProperty(
		name= "Override displacement settings",
		description= "Override material displacement settings",
		default= False
	)

	GeomDisplacedMesh.type= EnumProperty(
		name= "Type",
		description= "Displacement type",
		items= (
			('2D',  "2D",     "2D displacement."),
			('NOR', "Normal", "Normal displacement."),
			('3D',  "Vector", "Vector displacement.")
		),
		default= 'NOR'
	)

	GeomDisplacedMesh.amount_type= EnumProperty(
		name= "Amount type",
		description= "Displacement amount type",
		items= (
			('MULT', "Multiply", "Multiply material amount."),
			('OVER', "Override", "Override material amount.")
		),
		default= 'OVER'
	)

	GeomDisplacedMesh.displacement_amount= FloatProperty(
		name= "Amount",
		description= "Displacement amount",
		min= -100.0,
		max= 100.0,
		soft_min= -0.1,
		soft_max= 0.1,
		precision= 5,
		default= 0.02
	)

	GeomDisplacedMesh.amount_mult= FloatProperty(
		name= "Mult",
		description= "Displacement amount multiplier",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 2.0,
		precision= 3,
		default= 1.0
	)

	GeomDisplacedMesh.displacement_shift= FloatProperty(
		name="Shift",
		description="",
		min=-100.0,
		max=100.0,
		soft_min=-1.0,
		soft_max=1.0,
		precision=4,
		default=0.0
	)

	GeomDisplacedMesh.water_level= FloatProperty(
		name="Water level",
		description="",
		min=-1000.0, max=1000.0, soft_min=-1.0, soft_max=1.0,
		default=-1.0
	)

	GeomDisplacedMesh.use_globals= BoolProperty(
		name= "Use globals",
		description= "If true, the global displacement quality settings will be used",
		default= True
	)

	GeomDisplacedMesh.view_dep= BoolProperty(
		name= "View dependent",
		description= "Determines if view-dependent tesselation is used",
		default= True
	)

	GeomDisplacedMesh.edge_length= FloatProperty(
		name= "Edge length",
		description= "Determines the approximate edge length for the sub-triangles",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 4
	)

	GeomDisplacedMesh.max_subdivs= IntProperty(
		name= "Max subdivs",
		description= "Determines the maximum subdivisions for a triangle of the original mesh",
		min= 0,
		max= 2048,
		soft_min= 0,
		soft_max= 1024,
		default= 256
	)

	GeomDisplacedMesh.keep_continuity= BoolProperty(
		name= "Keep continuity",
		description= "If true, the plugin will attempt to keep the continuity of the displaced surface",
		default= False
	)

	GeomDisplacedMesh.map_channel= IntProperty(
		name= "Map channel",
		description= "The mapping channel to use for vector and 2d displacement",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 1
	)

	GeomDisplacedMesh.use_bounds= BoolProperty(
		name= "Use bounds",
		description= "If true, the min/max values for the displacement texture are specified by the min_bound and max_bound parameters; if false, these are calculated automatically",
		default= False
	)

	# GeomDisplacedMesh.min_bound= FloatVectorProperty(
	# 	name= "Min bound",
	# 	description= "The lowest value for the displacement texture",
	# 	subtype= 'COLOR',
	# 	min= 0.0,
	# 	max= 1.0,
	# 	soft_min= 0.0,
	# 	soft_max= 1.0,
	# 	default= (0,0,0)
	# )

	# GeomDisplacedMesh.max_bound= FloatVectorProperty(
	# 	name= "Max bound",
	# 	description= "The biggest value for the displacement texture",
	# 	subtype= 'COLOR',
	# 	min= 0.0,
	# 	max= 1.0,
	# 	soft_min= 0.0,
	# 	soft_max= 1.0,
	# 	default= (1,1,1)
	# )

	GeomDisplacedMesh.min_bound= FloatProperty(
		name= "Min bound",
		description= "The lowest value for the displacement texture",
		min= -1.0,
		max=  1.0,
		soft_min= -1.0,
		soft_max=  1.0,
		default= 0.0
	)

	GeomDisplacedMesh.max_bound= FloatProperty(
		name= "Max bound",
		description= "The biggest value for the displacement texture",
		min= -1.0,
		max=  1.0,
		soft_min= -1.0,
		soft_max=  1.0,
		default= 1.0
	)

	GeomDisplacedMesh.resolution= IntProperty(
		name= "Resolution",
		description= "Resolution at which to sample the displacement map for 2d displacement",
		min= 1,
		max= 100000,
		soft_min= 1,
		soft_max= 2048,
		default= 256
	)

	GeomDisplacedMesh.precision= IntProperty(
		name= "Precision",
		description= "Increase for curved surfaces to avoid artifacts",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 8
	)

	GeomDisplacedMesh.tight_bounds= BoolProperty(
		name= "Tight bounds",
		description= "When this is on, initialization will be slower, but tighter bounds will be computed for the displaced triangles making rendering faster",
		default= False
	)

	GeomDisplacedMesh.filter_texture= BoolProperty(
		name= "Filter texture",
		description= "Filter the texture for 2d displacement",
		default= False
	)

	GeomDisplacedMesh.filter_blur= FloatProperty(
		name= "Blur",
		description= "The amount of UV space to average for filtering purposes. A value of 1.0 will average the whole texture",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.001
	)


def write(bus):
	ofile= bus['files']['nodes']
	scene= bus['scene']

	ob=    bus['node']['object']
	me=    bus['node']['geometry']

	VRayScene= scene.vray
	VRayExporter= VRayScene.exporter

	if not (bus['node'].get('displacement_slot') and VRayExporter.use_displace):
		return

	slot= bus['node']['displacement_slot']

	VRaySlot=            slot.texture.vray_slot
	GeomDisplacedMesh=   VRaySlot.GeomDisplacedMesh
	displacement_amount= GeomDisplacedMesh.displacement_amount

	VRayObject=                 ob.vray
	ObjectDisplacementOverride= VRayObject.GeomDisplacedMesh

	displace_name= 'D'+me
	if ObjectDisplacementOverride.use:
		displace_name= get_name(ob, prefix='DOB')
		GeomDisplacedMesh= ObjectDisplacementOverride

	if not append_unique(bus['cache']['displace'], displace_name):
		return displace_name

	ofile.write("\nGeomDisplacedMesh %s {" % displace_name)
	ofile.write("\n\tmesh= %s;" % me)
	ofile.write("\n\tdisplacement_tex_float= %s;" % bus['node']['displacement_texture'])
	ofile.write("\n\tdisplacement_tex_color= %s;" % bus['node']['displacement_texture'])
	if GeomDisplacedMesh.type == '2D':
		ofile.write("\n\tdisplace_2d= 1;")
	elif GeomDisplacedMesh.type == '3D':
		ofile.write("\n\tvector_displacement= 1;")
	else:
		ofile.write("\n\tdisplace_2d= 0;")
		ofile.write("\n\tvector_displacement= 0;")
	for param in PARAMS:
		if param == 'displacement_amount':
			if ob.vray.GeomDisplacedMesh.use:
				if GeomDisplacedMesh.amount_type == 'OVER':
					value= GeomDisplacedMesh.displacement_amount
				else:
					value= GeomDisplacedMesh.amount_mult * displacement_amount
			else:
				value= displacement_amount
		elif param in ('min_bound', 'max_bound'):
			value= "Color(%.3f,%.3f,%.3f)" % (tuple([getattr(GeomDisplacedMesh, param)]*3))
		else:
			value= getattr(GeomDisplacedMesh, param)
		ofile.write("\n\t%s= %s;" % (param, a(scene,value)))
	ofile.write("\n}\n")

	bus['node']['geometry']= displace_name


def influence(context, layout, slot):
	wide_ui= context.region.width > ui.narrowui

	VRaySlot= slot.texture.vray_slot

	GeomDisplacedMesh= VRaySlot.GeomDisplacedMesh

	layout.label(text="Geometry:")

	split= layout.split()
	col= split.column()
	ui.factor_but(col, VRaySlot, 'map_displacement', 'displacement_mult', "Displace")
	if wide_ui:
		col= split.column()
	col.active= VRaySlot.map_displacement
	col.prop(GeomDisplacedMesh, 'type')
	col.prop(GeomDisplacedMesh, 'displacement_amount', slider=True)

########NEW FILE########
__FILENAME__ = GeomMeshFile
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'GEOMETRY'
ID=   'GeomMeshFile'

NAME= 'Proxy'
DESC= "VRayProxy settings"

PARAMS= (
	'filter_blur'
)

def add_properties(rna_pointer):
	class GeomMeshFile(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(GeomMeshFile)

	rna_pointer.GeomMeshFile= PointerProperty(
		name= "V-Ray Proxy",
		type=  GeomMeshFile,
		description= "V-Ray proxy settings"
	)

	GeomMeshFile.use= BoolProperty(
		name= "Use Proxy",
		description= "Use proxy mesh",
		default= False
	)

	GeomMeshFile.file= StringProperty(
		name= "File",
		subtype= 'FILE_PATH',
		description= "Proxy file"
	)

	GeomMeshFile.anim_type= EnumProperty(
		name= "Animation type",
		description= "Proxy animation type",
		items= (
			('LOOP',     "Loop",      ""),
			('ONCE',     "Once",      ""),
			('PINGPONG', "Ping-pong", ""),
			('STILL',    "Still",     "")
		),
		default= 'LOOP'
	)

	GeomMeshFile.mode= EnumProperty(
		name= "Mode",
		description= "Proxy creation mode",
		items= (
			('NONE',    "None",        "Don\'t attach proxy"),
			('NEW',     "New object",  "Attach proxy to new object"),
			('THIS',    "This object", "Attach proxy to this object"),
			('REPLACE', "Replace",     "Replace this object with proxy"),
		),
		default= 'NONE'
	)

	GeomMeshFile.anim_speed= FloatProperty(
		name= "Speed",
		description= "Animated proxy playback speed",
		min= 0.0,
		max= 1000.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 1.0
	)

	GeomMeshFile.anim_offset= FloatProperty(
		name= "Offset",
		description= "Animated proxy initial frame offset",
		min= -1000.0,
		max= 1000.0,
		soft_min= -10.0,
		soft_max= 10.0,
		default= 0.0
	)

	GeomMeshFile.scale= FloatProperty(
		name= "Scale",
		description= "Size scaling factor",
		min= 0.0,
		max= 1000.0,
		soft_min= 0.0,
		soft_max= 2.0,
		default= 1.0
	)

	GeomMeshFile.apply_transforms= BoolProperty(
		name= "Apply transform",
		description= "Apply rotation, location and scale",
		default= False
	)

	GeomMeshFile.add_suffix= BoolProperty(
		name= "Add suffix",
		description= "Add \"_proxy\" suffix to object and mesh names",
		default= True
	)

	GeomMeshFile.dirpath= StringProperty(
		name= "Path",
		subtype= 'DIR_PATH',
		description= "Proxy generation directory",
		default= "//proxy"
	)

	GeomMeshFile.filename= StringProperty(
		name= "Name",
		subtype= 'NONE',
		description= "Proxy file name. If empty object's name is used",
		default= ""
	)

	GeomMeshFile.animation= BoolProperty(
		name= "Animation",
		description= "Animated proxy",
		default= False
	)

	GeomMeshFile.animation_range= EnumProperty(
		name= "Animation range",
		description= "Animation range type",
		items= (
			('MANUAL', "Manual", "Set manually"),
			('SCENE',  "Scene",  "Get from scene")
		),
		default= 'SCENE'
	)

	GeomMeshFile.add_velocity= BoolProperty(
		name= "Add velocity",
		description= "This makes it possible to add motion blur to the final animation. However exporting this extra information takes longer. If you are not going to need motion blur it makes sense to disable this option",
		default= False
	)

	GeomMeshFile.frame_start= IntProperty(
		name= "Start frame",
		description= "Proxy generation start frame",
		min= 1,
		max= 1000,
		soft_min= 1,
		soft_max= 250,
		default= 1
	)

	GeomMeshFile.frame_end= IntProperty(
		name= "End frame",
		description= "Proxy generation end frame",
		min= 1,
		max= 1000,
		soft_min= 1,
		soft_max= 250,
		default= 250
	)


def write(bus):
	ANIM_TYPE= {
		'LOOP'     : 0,
		'ONCE'     : 1,
		'PINGPONG' : 2,
		'STILL'    : 3,
	}

	ofile= bus['files']['nodes']
	scene= bus['scene']
	ob=    bus['node']['object']

	VRayData= ob.data.vray

	if hasattr(VRayData,'GeomMeshFile'):
		GeomMeshFile= VRayData.GeomMeshFile

		if not GeomMeshFile.file:
			debug(scene, "Object: %s => Proxy file is not set!" % (ob.name), error= True)
			return bus['node']['geometry']

		proxy_filepath= os.path.normpath(bpy.path.abspath(GeomMeshFile.file))

		# if PLATFORM == 'linux':
		# 	proxy_filepath= proxy_filepath.replace('\\', '/')

		# TODO: fix '\' on *nix
		# if not os.path.exists(proxy_filepath):
		# 	debug(scene, "Object: %s => Proxy file doesn\'t exist! [%s]" % (ob.name, proxy_filepath), error= True)
			# return bus['node']['geometry']

		proxy_filename= os.path.basename(proxy_filepath)[:-7]
		proxy_name= "PR%s" % clean_string(proxy_filename)

		if GeomMeshFile.anim_type not in ('STILL'):
			proxy_name= "OB%sPR%s" % (clean_string(ob.data.name),
									  clean_string(proxy_filename))

		if not append_unique(bus['cache']['proxy'], proxy_name):
			bus['node']['geometry']= proxy_name
			return proxy_name

		ofile.write("\nGeomMeshFile %s {" % proxy_name)
		# if PLATFORM == 'linux': # This is a hack to allow teams using both Windows and Linux (back-slash problem)
		# 	ofile.write("\n\tfile= \"%s\";" % get_full_filepath(bus, ob, GeomMeshFile.file.replace('\\','/')))
		# else:
		# 	ofile.write("\n\tfile= \"%s\";" % get_full_filepath(bus, ob, GeomMeshFile.file))
		ofile.write("\n\tfile= \"%s\";" % get_full_filepath(bus, ob, GeomMeshFile.file))
		ofile.write("\n\tanim_speed= %i;" % GeomMeshFile.anim_speed)
		ofile.write("\n\tanim_type= %i;" % ANIM_TYPE[GeomMeshFile.anim_type])
		ofile.write("\n\tanim_offset= %i;" % (GeomMeshFile.anim_offset - 1))
		ofile.write("\n}\n")

		bus['node']['geometry']= proxy_name
		return proxy_name

########NEW FILE########
__FILENAME__ = GeomPlane
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'GEOMETRY'
ID=   'GeomPlane'

NAME= 'Infinite place'
DESC= "Procedural infinite plane."

PARAMS= ()


def add_properties(rna_pointer):
	pass


def write(bus):
	ofile=   bus['files']['nodes']
	scene=   bus['scene']

	ofile.write("\nGeomPlane %s {}\n" % bus['node']['geometry'])



	

########NEW FILE########
__FILENAME__ = GeomStaticMesh
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'GEOMETRY'
ID=   'GeomStaticMesh'

NAME= 'Mesh'
DESC= "Mesh settings."

PARAMS= (
	'dynamic_geometry',
)


def add_properties(rna_pointer):
	class GeomStaticMesh(bpy.types.PropertyGroup):
		dynamic_geometry = BoolProperty(
			name        = "Dynamic geometry",
			description = "Instead of copying the mesh many times in the BSP tree, only the bounding box will be present many times and ray intersections will occur in a separate object space BSP tree",
			default     =  False
		)
		use_for_ptex = BoolProperty(
			name        = "Use For PTex",
			description = "Turn this option on if this object will be used with PTex",
			default     =  False
		)
	bpy.utils.register_class(GeomStaticMesh)

	rna_pointer.GeomStaticMesh= PointerProperty(
		name= "V-Ray Satic Mesh",
		type=  GeomStaticMesh,
		description= "V-Ray static mesh settings"
	)


def write_mesh_hex(bus):
	ofile=   bus['files']['geometry'][0]
	scene=   bus['scene']
	ob=      bus['node']['object']
	me=      bus['node']['mesh']
	me_name= bus['node']['mesh_name']

	GeomStaticMesh= ob.data.vray.GeomStaticMesh
	
	face_attr = 'faces' if 'faces' in dir(me) else 'polygons'

	face_tri= (0,1,2,2,3,0)
	
	ofile.write("\nGeomStaticMesh %s {" % me_name)

	ofile.write("\n\tvertices= interpolate((%d, ListVectorHex(\""%(scene.frame_current))
	for v in me.vertices:
		for c in v.co:
			ofile.write(HexFormat(c))
	ofile.write("\")));")

	ofile.write("\n\tfaces= interpolate((%d, ListIntHex(\""%(scene.frame_current))
	for f in getattr(me, face_attr):
		if len(f.vertices) == 4:
			for i in face_tri:
				ofile.write(HexFormat(f.vertices[i]))
		else:
			for v in f.vertices:
				ofile.write(HexFormat(v))
	ofile.write("\")));")

	ofile.write("\n\tface_mtlIDs= ListIntHex(\"")
	for f in getattr(me, face_attr):
		if len(f.vertices) == 4:
			ofile.write(HexFormat(f.material_index + 1))
			ofile.write(HexFormat(f.material_index + 1))
		else:
			ofile.write(HexFormat(f.material_index + 1))
	ofile.write("\");")

	ofile.write("\n\tnormals= interpolate((%d, ListVectorHex(\""%(scene.frame_current))
	for f in getattr(me, face_attr):
		if len(f.vertices) == 4:
			vertices= face_tri
		else:
			vertices= (0,1,2)

		for v in vertices:
			if f.use_smooth:
				for c in me.vertices[f.vertices[v]].normal:
					ofile.write(HexFormat(c))
			else:
				for c in f.normal:
					ofile.write(HexFormat(c))
	ofile.write("\")));")

	ofile.write("\n\tfaceNormals= ListIntHex(\"")
	k= 0
	for f in getattr(me, face_attr):
		if len(f.vertices) == 4:
			vertices= 6
		else:
			vertices= 3

		for v in range(vertices):
			ofile.write(HexFormat(k))
			k+= 1
	ofile.write("\");")


	def edge_visibility(k, ev):
		if k == 9:
			ofile.write(HexFormat(int(ev, 2)))
			return 0, ""
		return k + 1, ev

	ofile.write("\n\tedge_visibility= ListIntHex(\"")

	k= 0
	ev= ""
	if len(getattr(me, face_attr)) < 5:
		for f in getattr(me, face_attr):
			if len(f.vertices) == 4:
				ev+= "011011"
			else:
				ev+= "111"
		edge_visibility(k, ev)
	else:
		k= 0;
		for f in getattr(me, face_attr):
			if len(f.vertices) == 4:
				ev+= "011"
				k, ev = edge_visibility(k, ev)
				ev+= "011"
				k, ev = edge_visibility(k, ev)
			else:
				ev+= "111"
				k, ev = edge_visibility(k, ev)
		if k:
			edge_visibility(k, ev)
	ofile.write("\");")

	uv_textures = me.tessface_uv_textures if 'tessface_uv_textures' in dir(me) else me.uv_textures

	if len(uv_textures):
		ofile.write("\n\tmap_channels= List(")

		for uv_texture_idx,uv_texture in enumerate(uv_textures):
			if uv_texture_idx:
				ofile.write(",")

			uv_layer_index= get_uv_layer_id(bus['uvs'], uv_texture.name)

			ofile.write("\n\t\t// %s"%(uv_texture.name))
			ofile.write("\n\t\tList(%d,ListVectorHex(\""%(uv_layer_index))

			for face in uv_texture.data:
				for uv in face.uv:
					ofile.write(HexFormat(uv[0]))
					ofile.write(HexFormat(uv[1]))
					ofile.write(HexFormat(0.0))

			ofile.write("\"),ListIntHex(\"")

			k= 0
			for face in uv_texture.data:
				if len(face.uv) == 4:
					for i in face_tri:
						ofile.write(HexFormat(k+i))
					k+= 4
				else:
					for i in (0,1,2):
						ofile.write(HexFormat(k+i))
					k+= 3
			ofile.write("\"))")

		ofile.write(");")

	for param in PARAMS:
		value= getattr(GeomStaticMesh, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))

	ofile.write("\n}\n")


def write(bus):
	scene= bus['scene']
	ob=    bus['node']['object']

	VRayScene= scene.vray
	VRayExporter= VRayScene.exporter
	
	debug(scene,
		  "Frame {0}: Mesh: \033[0;32m{1:<32}\033[0m".format(scene.frame_current, color(ob.data.name, 'green')),
		  newline= VRayExporter.debug)

	write_mesh_hex(bus)

########NEW FILE########
__FILENAME__ = GeomStaticSmoothedMesh
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.	If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'GEOMETRY'
ID=	  'GeomStaticSmoothedMesh'

NAME= 'Subdivision'
DESC= "Subdivision surface settings."

PARAMS= (
	'use_globals',
	'view_dep',
	'edge_length',
	'max_subdivs',
	'static_subdiv',
)

def add_properties(rna_pointer):
	class GeomStaticSmoothedMesh(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(GeomStaticSmoothedMesh)

	rna_pointer.GeomStaticSmoothedMesh= PointerProperty(
		name= "GeomStaticSmoothedMesh",
		type=  GeomStaticSmoothedMesh,
		description= "GeomStaticSmoothedMesh texture slot settings"
	)

	GeomStaticSmoothedMesh.use= BoolProperty(
		name= "Override displacement settings",
		description= "Override material displacement settings",
		default= False
	)

	GeomStaticSmoothedMesh.use_globals= BoolProperty(
		name= "Use globals",
		description= "If true, the global displacement quality settings will be used",
		default= True
	)

	GeomStaticSmoothedMesh.view_dep= BoolProperty(
		name= "View dependent",
		description= "Determines if view-dependent tesselation is used",
		default= True
	)

	GeomStaticSmoothedMesh.edge_length= FloatProperty(
		name= "Edge length",
		description= "Determines the approximate edge length for the sub-triangles",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 4
	)

	GeomStaticSmoothedMesh.max_subdivs= IntProperty(
		name= "Max subdivs",
		description= "Determines the maximum subdivisions for a triangle of the original mesh",
		min= 0,
		max= 2048,
		soft_min= 0,
		soft_max= 1024,
		default= 256
	)

	GeomStaticSmoothedMesh.static_subdiv= BoolProperty(
		name= "Static subdivision",
		description= "True if the resulting triangles of the subdivision algorithm will be inserted into the rayserver as static geometry",
		default= False
	)



def write(bus):
	ofile= bus['files']['nodes']
	scene= bus['scene']

	ob=	   bus['node']['object']
	me=	   bus['node']['geometry']
	
	VRayScene= scene.vray
	VRayExporter= VRayScene.exporter

	if not VRayExporter.use_displace:
		return
		
	VRayObject= ob.vray
	GeomStaticSmoothedMesh= VRayObject.GeomStaticSmoothedMesh

	slot= None
	if bus['node'].get('displacement_slot'):
		slot= bus['node']['displacement_slot']
		if slot:
			VRaySlot=	slot.texture.vray_slot
			VRayObject= ob.vray

			GeomDisplacedMesh=	        VRaySlot.GeomDisplacedMesh
			ObjectDisplacementOverride= VRayObject.GeomDisplacedMesh

			# Keep original amount from texture
			displacement_amount= GeomDisplacedMesh.displacement_amount

	if GeomStaticSmoothedMesh.use:
		subdiv_name= 'SBDV'+me
		if slot and ObjectDisplacementOverride.use:
			subdiv_name= get_name(ob, prefix='SBDVDOB')
			GeomDisplacedMesh= ObjectDisplacementOverride

		if not append_unique(bus['cache']['displace'], subdiv_name):
			return subdiv_name

		ofile.write("\nGeomStaticSmoothedMesh %s {" % subdiv_name)
		ofile.write("\n\tmesh= %s;" % me)
		if slot:
			ofile.write("\n\tdisplacement_tex_float= %s;" % bus['node']['displacement_texture'])
			ofile.write("\n\tdisplacement_tex_color= %s;" % bus['node']['displacement_texture'])
			if ObjectDisplacementOverride.use:
				if ObjectDisplacementOverride.amount_type == 'OVER':
					displacement_amount= ObjectDisplacementOverride.displacement_amount
				else:
					displacement_amount*= ObjectDisplacementOverride.amount_mult
			ofile.write("\n\tdisplacement_amount= %s;" % a(scene, displacement_amount))
			for param in ('displacement_shift',
						  'keep_continuity',
						  'water_level',
						  'use_bounds',
						  'min_bound',
						  'max_bound'):
				if param in ('min_bound', 'max_bound'):
					value= "Color(%.3f,%.3f,%.3f)" % (tuple([getattr(GeomDisplacedMesh, param)]*3))
				else:
					value= getattr(GeomDisplacedMesh, param)
				ofile.write("\n\t%s= %s;" % (param, a(scene,value)))

		for param in PARAMS:
			value= getattr(GeomStaticSmoothedMesh, param)
			ofile.write("\n\t%s= %s;" % (param, a(scene,value)))

		ofile.write("\n}\n")

		bus['node']['geometry']= subdiv_name


def influence(context, layout, slot):
	pass

########NEW FILE########
__FILENAME__ = GeomVRayPattern
#
# V-Ray/Blender
#
# http://vray.cgdo.ru
#
# Author: Andrey M. Izrantsev (aka bdancer)
# E-Mail: izrantsev@cgdo.ru
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
#

# Blender modules
import bpy
import mathutils

# V-Ray/Blender modules
import vb25


TYPE = 'OBJECT'
ID   = 'GeomVRayPattern'

NAME = 'VRayPattern'
DESC = "VRayPattern plugin settings"

PARAMS = (
	'use',
	'node_name',
	'base_name',
	'pattern_name',
	'render_pattern_object',
	'render_base_object',

	'geometry_bias',
	'crop_size',
	'height',
	'shift',
	'map_channel',
	'use_real_world',
	'tiling_u',
	'tiling_v',
	'polygon_id_from',
	'polygon_id_to',
	'random_segment_u',
	'random_segment_v',
	'random_segment_seed',
)


def add_properties(rna_pointer):
	class GeomVRayPattern(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(GeomVRayPattern)

	rna_pointer.GeomVRayPattern = bpy.props.PointerProperty(
		name        = ID,
		type        = GeomVRayPattern,
		description = DESC
	)

	GeomVRayPattern.use = bpy.props.BoolProperty(
		name        = "Use",
		description = "Override geometry with VRayPattern plugin",
		default     = False
	)

	GeomVRayPattern.pattern_object = bpy.props.StringProperty(
		name        = "Pattern Object",
		description = "Pattern object",
		default     = ""
	)

	GeomVRayPattern.render_pattern_object = bpy.props.BoolProperty(
		name        = "Render Pattern Object",
		description = "Render original pattern object",
		default     = False
	)

	GeomVRayPattern.render_base_object = bpy.props.BoolProperty(
		name        = "Render Base Object",
		description = "Render base object",
		default     = True
	)

	GeomVRayPattern.geometry_bias = bpy.props.FloatProperty(
		name        = "Geometry Bias",
		description = "Minimum passage distance of the ray after reflection from the geometry, within which all other ray intersections with the geometry are ignored. If this parameter is 0, the object will cast shadows on itself and will get covered with spots",
		min         = 0.0,
		max         = 1.0,
		soft_min    = 0.0,
		soft_max    = 0.1,
		precision   = 4,
		default     = 0.01
	)

	GeomVRayPattern.crop_size = bpy.props.FloatVectorProperty(
		name        = "Crop Size",
		description = "Size of the crop box of propagated geometry. All objects outside of the box  are ignored. Crop box also defines the repeating period of the geometry",
		subtype     = 'TRANSLATION',
		min         = 0.0,
		max         = 1024.0,
		soft_min    = 0.0,
		soft_max    = 10.0,
		precision   = 4,
		default     = (1.0, 1.0, 1.0)
	)

	GeomVRayPattern.height = bpy.props.FloatProperty(
		name        = "Height",
		description = "Height multiplier of the propagated geometry",
		subtype	    = 'PERCENTAGE',
		min         = 0.0,
		max         = 500.0,
		soft_min    = 0.0,
		soft_max    = 200.0,
		precision   = 4,
		default     = 100.0
	)

	GeomVRayPattern.shift = bpy.props.FloatProperty(
		name        = "Shift",
		description = "Displacement of the geometry against surface normal",
		min         = 0.0,
		max         = 1.0,
		soft_min    = 0.0,
		soft_max    = 0.1,
		precision   = 4,
		default     = 0.0
	)

	GeomVRayPattern.map_channel = bpy.props.IntProperty(
		name        = "Mapping Channel",
		description = "Mapping UV channel ID",
		min         = 0,
		max         = 1024,
		default     = 1
	)

	GeomVRayPattern.use_real_world = bpy.props.BoolProperty(
		name        = "Real World Scale",
		description = "Work in real world scale",
		default     = False
	)

	GeomVRayPattern.tiling_u = bpy.props.FloatProperty(
		name        = "Tiling U",
		description = "Mapping multiplier in U axis",
		min         = 0.001,
		soft_max    = 2.0,
		precision   = 4,
		default     = 1.0
	)

	GeomVRayPattern.tiling_v = bpy.props.FloatProperty(
		name        = "Tiling V",
		description = "Mapping multiplier in V axis",
		min         = 0.001,
		soft_max    = 2.0,
		precision   = 4,
		default     = 1.0
	)

	GeomVRayPattern.polygon_id_from = bpy.props.IntProperty(
		name        = "Polygon ID From",
		description = "Polygon ID low value",
		min         = 0,
		max         = 1024,
		default     = 1
	)

	GeomVRayPattern.polygon_id_to = bpy.props.IntProperty(
		name        = "Polygon ID From",
		description = "Polygon ID high value",
		min         = 0,
		max         = 1024,
		default     = 100
	)

	GeomVRayPattern.random_segment_u = bpy.props.IntProperty(
		name        = "Random Segment U",
		description = "Random segment count in U axis",
		min         = 0,
		max         = 1024,
		default     = 1
	)

	GeomVRayPattern.random_segment_v = bpy.props.IntProperty(
		name        = "Random Segment V",
		description = "Random segment count in V axis",
		min         = 0,
		max         = 1024,
		default     = 1
	)

	GeomVRayPattern.random_segment_seed = bpy.props.IntProperty(
		name        = "Seed",
		description = "Random seed",
		min         = 0,
		max         = 1024,
		default     = 42
	)


class VRAY_OT_pattern_fix(bpy.types.Operator):
	bl_idname      = 'vray.pattern_fit'
	bl_label       = "Fit Crop Size"
	bl_description = "Fit Crop Size"

	def execute(self, context):
		ob = context.object
		pattern_ob = None

		VRayObject = ob.vray
		GeomVRayPattern = VRayObject.GeomVRayPattern

		if GeomVRayPattern.pattern_object in context.scene.objects:
			pattern_ob = context.scene.objects[GeomVRayPattern.pattern_object]

		if pattern_ob is None:
			return {'FINISHED'}

		GeomVRayPattern.crop_size = pattern_ob.dimensions

		return {'FINISHED'}

bpy.utils.register_class(VRAY_OT_pattern_fix)


def write(bus):
	# Basically, any file that goes after 'nodes'. Improve this.
	#
	ofile = bus['files']['lights']

	scene = bus['scene']

	ob      = bus['node']['object']
	ob_name = bus['node']['name']
	me      = bus['node']['geometry']

	VRayScene    = scene.vray
	VRayExporter = VRayScene.exporter

	VRayObject = ob.vray
	GeomVRayPattern = VRayObject.GeomVRayPattern

	plug_name = "VRayPattern%s" % (ob_name)
	ofile.write("\nVRayPattern %s {" % (plug_name))
	for param in PARAMS:
		if param == 'node_name':
			value = '"%s"' % ('VRayPattern'+vb25.utils.get_name(ob, prefix='OB'))
		elif param == 'base_name':
			value = '"%s"' % (vb25.utils.get_name(ob, prefix='OB'))
		elif param == 'crop_size':
			crop_size = GeomVRayPattern.crop_size
			value = mathutils.Vector((crop_size.x, crop_size.z, crop_size.y))
		elif param == 'pattern_name':
			pattern_name = GeomVRayPattern.pattern_object
			if pattern_name in scene.objects:
				pattern_object = scene.objects[pattern_name]
				value = '"%s"' % (vb25.utils.get_name(pattern_object, prefix='OB'))
			else:
				value = '""'
		else:
			value = getattr(GeomVRayPattern, param)
		ofile.write("\n\t%s=%s;" % (param, vb25.utils.a(scene, value)))
	ofile.write("\n\tuse_base_map_channel=0;")
	ofile.write("\n}\n")

	return None

########NEW FILE########
__FILENAME__ = Includer
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'SETTINGS'

ID=   'INCLUDER'
NAME= 'Includer'
DESC= "List includes *.vrscene"

PARAMS= (
)

def add_properties(rna_pointer):
	class Includer(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(Includer)

	rna_pointer.Includer= PointerProperty(
		name= "Includes",
		type=  Includer,
		description= "Inclede files *.vrscene"
	)

	Includer.use = BoolProperty(
		name        = "Use Includer",
		description = "Add additional *.vrscene files",
		default     = False
	)

	Includer.setting= BoolProperty(
		name= "",
		description= "Use scene Settings",
		default= True
	)

	Includer.camera= BoolProperty(
		name= "",
		description= "Use camera",
		default= True
	)

	Includer.materials= BoolProperty(
		name= "",
		description= "Use materials",
		default= True
	)

	Includer.environment= BoolProperty(
		name= "",
		description= "Use environment",
		default= True
	)

	Includer.lights= BoolProperty(
		name= "",
		description= "Use lights",
		default= True
	)

	Includer.textures= BoolProperty(
		name= "",
		description= "Use textures",
		default= True
	)

	Includer.colorMapping_standalone= BoolProperty(
		name= "",
		description= "Use Color Mapping standalone",
		default= True
	)

	Includer.geometry= BoolProperty(
		name= "",
		description= "Use scene geometry",
		default= True
	)

	Includer.scene_nodes= BoolProperty(
		name= "",
		description= "Use Vray nodes",
		default= True
	)
	

	class IncluderList(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(IncluderList)

	Includer.nodes= CollectionProperty(
		name= "Scene Name",
		type=  IncluderList,
		description= "Custom name scene"
	)

	Includer.nodes_selected= IntProperty(
		name= "Scene Index",
		default= -1,
		min= -1,
		max= 100
	)

	IncluderList.scene= StringProperty(
		name= "Filepath",
		subtype= 'FILE_PATH',
		description= "Path to a *.vrscene file"
	)

	IncluderList.use= BoolProperty(
		name= "",
		description= "Use scene",
		default= True
	)



########NEW FILE########
__FILENAME__ = LightMesh
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *


TYPE= 'GEOMETRY'
ID=   'LightMesh'

NAME= 'LightMesh'
UI=   "Mesh light"
DESC= "LightMesh settings"

PARAMS= (
	'enabled',
	# 'transform',
	'color',
	# 'color_tex',
	# 'shadows',
	# 'shadowColor',
	# 'shadowColor_tex',
	# 'shadowBias',
	# 'photonSubdivs',
	'causticSubdivs',
	# 'diffuseMult',
	# 'causticMult',
	# 'cutoffThreshold',
	'affectDiffuse',
	'affectSpecular',
	# 'bumped_below_surface_check',
	# 'nsamples',
	# 'diffuse_contribution',
	# 'specular_contribution',
	# 'channels',
	# 'channels_raw',
	# 'channels_diffuse',
	# 'channels_specular',
	'units',
	'intensity',
	# 'intensity_tex',
	'subdivs',
	'storeWithIrradianceMap',
	'invisible',
	'affectReflections',
	'noDecay',
	'doubleSided',
	'lightPortal',
	'geometry',
	# 'ignoreLightNormals',
	# 'tex',
	# 'use_tex',
	# 'tex_resolution',
	# 'cache_tex'
)


def add_properties(rna_pointer):
	class LightMesh(bpy.types.PropertyGroup):
		color= FloatVectorProperty(
			name= "Color",
			description= "Light color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (1.0,1.0,1.0)
		)

		color_type= EnumProperty(
			name= "Color type",
			description= "Color type",
			items= (
				('RGB',    "RGB", ""),
				('KELVIN', "K",   ""),
			),
			default= 'RGB'
		)

		temperature= IntProperty(
			name= "Temperature",
			description= "Kelvin temperature",
			min= 1000,
			max= 40000,
			step= 100,
			default= 5000
		)

		use_include_exclude= BoolProperty(
			name= "Use Include / Exclude",
			description= "Use Include / Exclude",
			default= False
		)

		include_exclude= EnumProperty(
			name= "Type",
			description= "Include or exclude object from lightning",
			items= (
				('EXCLUDE',"Exclude",""),
				('INCLUDE',"Include",""),
			),
			default= 'EXCLUDE'
		)

		include_objects= StringProperty(
			name= "Include objects",
			description= "Include objects: name{;name;etc}"
		)

		include_groups= StringProperty(
			name= "Include groups",
			description= "Include groups: name{;name;etc}"
		)
	bpy.utils.register_class(LightMesh)

	rna_pointer.LightMesh= PointerProperty(
		name= "LightMesh",
		type=  LightMesh,
		description= "Mesh light settings"
	)

	LightMesh.use= BoolProperty(
		name= "Use mesh light",
		description= "Use mesh light",
		default= False
	)

	LightMesh.enabled= BoolProperty(
		name= "Enabled",
		description= "Light\'s on/off state",
		default= True
	)

	LightMesh.lightPortal= EnumProperty(
		name= "Light portal mode",
		description= "Specifies if the light is a portal light",
		items= (
			('NORMAL',"Normal light",""),
			('PORTAL',"Portal",""),
			('SPORTAL',"Simple portal","")
		),
		default= 'NORMAL'
	)

	LightMesh.units= EnumProperty(
		name= "Intensity units",
		description= "Units for the intensity",
		items= (
			('DEFAULT',"Default",""),
			('LUMENS',"Lumens",""),
			('LUMM',"Lm/m/m/sr",""),
			('WATTSM',"Watts",""),
			('WATM',"W/m/m/sr","")
		),
		default= 'DEFAULT'
	)

	LightMesh.intensity= FloatProperty(
		name= "Intensity",
		description= "Light intensity",
		min= 0.0,
		max= 10000000.0,
		soft_min= 0.0,
		soft_max= 100.0,
		precision= 2,
		default= 30
	)

	LightMesh.causticSubdivs= IntProperty(
		name= "Caustic subdivs",
		description= "Caustic subdivs",
		min= 1,
		max= 10000,
		default= 1000
	)

	LightMesh.subdivs= IntProperty(
		name= "Subdivs",
		description= "The number of samples V-Ray takes to compute lighting",
		min= 0,
		max= 256,
		default= 8
	)

	LightMesh.noDecay= BoolProperty(
		name= "No decay",
		description= "TODO",
		default= False
	)

	LightMesh.affectReflections= BoolProperty(
		name= "Affect reflections",
		description= "true if the light appears in reflections and false otherwise",
		default= True
	)

	LightMesh.invisible= BoolProperty(
		name= "Invisible",
		description= "TODO",
		default= False
	)

	LightMesh.storeWithIrradianceMap= BoolProperty(
		name= "Store with Irradiance Map",
		description= "TODO",
		default= False
	)

	LightMesh.affectDiffuse= BoolProperty(
		name= "Affect diffuse",
		description= "true if the light produces diffuse lighting and false otherwise",
		default= True
	)

	LightMesh.affectSpecular= BoolProperty(
		name= "Affect specular",
		description= "true if the light produces specular hilights and false otherwise",
		default= True
	)

	LightMesh.doubleSided= BoolProperty(
		name= "Double-sided",
		description= "TODO",
		default= False
	)



def write(bus):
	LIGHT_PORTAL= {
		'NORMAL':  0,
		'PORTAL':  1,
		'SPORTAL': 2,
	}

	UNITS= {
		'DEFAULT' : 0,
		'LUMENS'  : 1,
		'LUMM'    : 2,
		'WATTSM'  : 3,
		'WATM'    : 4,
	}

	scene= bus['scene']
	ofile= bus['files']['lights']

	ob=    bus['node']['object']

	VRayObject= ob.vray
	LightMesh=  VRayObject.LightMesh

	if not VRayObject.LightMesh.use:
		return False
	
	textures= bus.get('textures', {})

	ofile.write("\nLightMesh %s {" % get_name(ob, prefix='LA'))
	ofile.write("\n\ttransform= %s;" % a(scene,transform(bus['node']['matrix'])))
	for param in PARAMS:
		if param == 'color':
			if LightMesh.color_type == 'RGB':
				color= LightMesh.color
			else:
				color= kelvin_to_rgb(LightMesh.temperature)
			ofile.write("\n\tcolor= %s;" % a(scene, "Color(%.6f,%.6f,%.6f)"%(tuple(color))))
			if 'diffuse' in textures:
				ofile.write("\n\ttex= %s;" % textures['diffuse'])
				ofile.write("\n\tuse_tex= 1;")
		elif param == 'geometry':
			ofile.write("\n\t%s= %s;"%(param, bus['node']['geometry']))
		elif param == 'units':
			ofile.write("\n\t%s= %i;"%(param, UNITS[LightMesh.units]))
		elif param == 'lightPortal':
			ofile.write("\n\t%s= %i;"%(param, LIGHT_PORTAL[LightMesh.lightPortal]))
		else:
			ofile.write("\n\t%s= %s;"%(param, a(scene,getattr(LightMesh,param))))
	ofile.write("\n}\n")

	return True

########NEW FILE########
__FILENAME__ = Mtl2Sided
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *


TYPE= 'MATERIAL'
ID=   'Mtl2Sided'

NAME= 'Mtl2Sided'
UI=   "Two-sided"
DESC= "Mtl2Sided settings."

PARAMS= (
)


def add_properties(rna_pointer):
	class Mtl2Sided(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(Mtl2Sided)

	rna_pointer.Mtl2Sided= PointerProperty(
		name= "Mtl2Sided",
		type=  Mtl2Sided,
		description= "V-Ray Mtl2Sided settings"
	)

	Mtl2Sided.use= BoolProperty(
		name= "Two sided material",
		description= "Simple \"Two sided\" material. Use nodes for advanced control",
		default= False
	)

	Mtl2Sided.back= StringProperty(
		name= "Back material",
		description= "Back material. Same material if nothing is set",
		default= ""
	)

	Mtl2Sided.translucency_tex= StringProperty(
		name= "Back material",
		description= "Back material",
		default= ""
	)

	Mtl2Sided.control= EnumProperty(
		name= "Control",
		description= "Translucency type",
		items= (
			('SLIDER',  "Slider",  "."),
			('COLOR',   "Color",   "."),
			('TEXTURE', "Texture", ".")
		),
		default= 'SLIDER'
	)

	Mtl2Sided.translucency_tex_mult= FloatProperty(
		name= "Translucency texture multiplier",
		description= "Translucency texture multiplier",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 1.0
	)

	Mtl2Sided.translucency_color= FloatVectorProperty(
		name= "Translucency color",
		description= "Translucency between front and back",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.5,0.5,0.5)
	)

	Mtl2Sided.translucency_slider= FloatProperty(
		name= "Translucency",
		description= "Translucency between front and back",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 0.5
	)

	Mtl2Sided.force_1sided= BoolProperty(
		name= "Force one-sided",
		description= "Make the sub-materials one-sided",
		default= True
	)


########NEW FILE########
__FILENAME__ = MtlCommon
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui
from vb25.plugins import *


TYPE= 'MATERIAL'
ID=   'Material'

NAME= 'General material setings'
DESC= "General V-Ray material settings."


PARAMS= (
)


def add_properties(rna_pointer):
	material_types= gen_material_menu_items(PLUGINS['BRDF'])
	
	rna_pointer.type= EnumProperty(
		name= "Type",
		description= "Material type",
		items= (tuple(material_types)),
		default= material_types[0][0]
	)

	rna_pointer.material_id_number= IntProperty(
		name= "Material ID",
		description= "Material ID",
		min= 0,
		max= 1024,
		soft_min= 0,
		soft_max= 10,
		default= 0
	)

	rna_pointer.material_id_color= FloatVectorProperty(
		name= "Color",
		description= "Material ID color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1.0,1.0,1.0)
	)

	rna_pointer.round_edges = BoolProperty(
		name        = "Round edges",
		description = "Round edges",
		default     = False
	)

	rna_pointer.radius = FloatProperty(
		name        = "Rounding radius",
		description = "Rounding radius",
		precision   = 3,
		min         = 0.0,
		max         = 100.0,
		soft_min    = 0.0,
		soft_max    = 1.0,
		default     = 0.0
	)

########NEW FILE########
__FILENAME__ = MtlOverride
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *


TYPE= 'MATERIAL'
ID=   'MtlOverride'
PID=   110

NAME= 'Override'
UI=   "Override"
DESC= "MtlOverride settings."

PARAMS= (
)


def add_properties(rna_pointer):
	class MtlOverride(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(MtlOverride)

	rna_pointer.MtlOverride= PointerProperty(
		name= "MtlOverride",
		type=  MtlOverride,
		description= "V-Ray MtlOverride settings"
	)

	MtlOverride.use= BoolProperty(
		name= "Use override material",
		description= "Use override material",
		default= False
	)

	MtlOverride.gi_mtl= StringProperty(
		name= "GI material",
		description= "The gi material",
		default= ""
	)

	MtlOverride.reflect_mtl= StringProperty(
		name= "Reflection material",
		description= "The reflection material",
		default= ""
	)

	MtlOverride.refract_mtl= StringProperty(
		name= "Refraction material",
		description= "The refraction material",
		default= ""
	)

	MtlOverride.shadow_mtl= StringProperty(
		name= "Shadow material",
		description= "The shadow material",
		default= ""
	)

	MtlOverride.environment_override= StringProperty(
		name= "Environment override",
		description= "Environment override texture",
		default= ""
	)

	MtlOverride.environment_priority= IntProperty(
		name= "Environment priority",
		description= "Environment override priority (used when several materials override it along a ray path)",
		min= 0,
		max= 100,
		default= 0
	)


########NEW FILE########
__FILENAME__ = MtlRenderStats
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *


TYPE= 'MATERIAL'
ID=   'MtlRenderStats'
PID=   130

NAME= 'Render Stats'
UI=   "Render"
DESC= "MtlRenderStats settings."

PARAMS= (
	'camera_visibility',
	'reflections_visibility',
	'refractions_visibility',
	'gi_visibility',
	'shadows_visibility',
	'visibility'
)


def add_properties(rna_pointer):
	class MtlRenderStats(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(MtlRenderStats)

	rna_pointer.MtlRenderStats= PointerProperty(
		name= "MtlRenderStats",
		type=  MtlRenderStats,
		description= "V-Ray MtlRenderStats settings"
	)

	MtlRenderStats.use= BoolProperty(
		name= "Use material render options",
		description= "Use material render options",
		default= False
	)

	MtlRenderStats.camera_visibility= BoolProperty(
		name= "Camera visibility",
		description= "TODO",
		default= True
	)

	MtlRenderStats.reflections_visibility= BoolProperty(
		name= "Reflections visibility",
		description= "TODO",
		default= True
	)

	MtlRenderStats.refractions_visibility= BoolProperty(
		name= "Refractions visibility",
		description= "TODO",
		default= True
	)

	MtlRenderStats.gi_visibility= BoolProperty(
		name= "GI visibility",
		description= "TODO",
		default= True
	)

	MtlRenderStats.shadows_visibility= BoolProperty(
		name= "Shadows visibility",
		description= "TODO",
		default= True
	)

	MtlRenderStats.visibility= BoolProperty(
		name= "Overall visibility",
		description= "TODO",
		default= True
	)


########NEW FILE########
__FILENAME__ = MtlVRmat
#
# V-Ray/Blender
#
# http://chaosgroup.com
#
# Author: Andrei Izrantcev
# E-Mail: andrei.izrantcev@chaosgroup.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
#

import bpy

from vb25 import utils


TYPE      = 'BRDF'
ID        = 'MtlVRmat'
PID       = 100
MAIN_BRDF = True
NAME      = "MtlVRmat"
UI        = "VRmat"
DESC      = "MtlVRmat settings"

PARAMS = (
    'filename',
    'mtlname',
)


class MtlVRmat(bpy.types.PropertyGroup):
    filename = bpy.props.StringProperty(
        name        = "File",
        subtype     = 'FILE_PATH',
        description = "Material file path"
    )

    mtlname = bpy.props.StringProperty(
        name        = "Name",
        description = "Material name in file"
    )


def add_properties(rna_pointer):
    rna_pointer.MtlVRmat = bpy.props.PointerProperty(
        name        = "MtlVRmat",
        type        =  MtlVRmat,
        description = "V-Ray MtlVRmat settings"
    )


def mapto(bus, BRDFLayered=None):
    return {}


def influence(context, layout, slot):
    pass

def gui(context, layout, MtlVRmat, material=None, node=None):
    split = layout.split(percentage=0.2, align=True)
    split.column().label("File:")
    split.column().prop(MtlVRmat, 'filename', text="")

    split = layout.split(percentage=0.2, align=True)
    split.column().label("Name:")
    row = split.column().row(align=True)
    row.prop(MtlVRmat, 'mtlname', text="")
    row.operator("vray.get_vrscene_material_name", text="", icon='IMASEL')


def write(bus, name):
    ofile = bus['files']['materials']
    ma    = bus['material']['material']

    MtlVRmat = ma.vray.MtlVRmat

    ofile.write("\nMtlVRmat %s {" % name)
    ofile.write('\n\tfilename="%s";' % utils.get_full_filepath(bus, None, MtlVRmat.filename))
    ofile.write('\n\tmtlname="%s";'  % MtlVRmat.mtlname)
    ofile.write("\n}\n")


def GetRegClasses():
    return (
        MtlVRmat,
    )


def register():
    for regClass in GetRegClasses():
        bpy.utils.register_class(regClass)


def unregister():
    for regClass in GetRegClasses():
        bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = MtlWrapper
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


TYPE= 'MATERIAL'
ID=   'MtlWrapper'

NAME= 'Wrapper'
UI=   "Wrapper"
DESC= "MtlWrapper settings"

PARAMS= (
	#'base_material',
	'generate_gi',
	'receive_gi',
	'generate_caustics',
	'receive_caustics',
	'alpha_contribution',
	'matte_surface',
	'shadows',
	'affect_alpha',
	'shadow_tint_color',
	'shadow_brightness',
	'reflection_amount',
	'refraction_amount',
	'gi_amount',
	'no_gi_on_other_mattes',
	'matte_for_secondary_rays',
	'gi_surface_id',
	'gi_quality_multiplier',
	#'alpha_contribution_tex',
	#'shadow_brightness_tex',
	#'reflection_filter_tex',
	'generate_render_elements',
	'trace_depth',
	#'channels'
)


''' Blender modules '''
import bpy
from bpy.props import *


def add_properties(rna_pointer):
	class MtlWrapper(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(MtlWrapper)

	rna_pointer.MtlWrapper= PointerProperty(
		name= "MtlWrapper",
		type=  MtlWrapper,
		description= "V-Ray MtlWrapper settings"
	)

	MtlWrapper.use= BoolProperty(
		name= "Use wrapper",
		description= "Use wrapper",
		default= False
	)

	MtlWrapper.generate_gi= FloatProperty(
		name= "Generate GI",
		description= "Controls the GI generated by the material",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	MtlWrapper.receive_gi= FloatProperty(
		name= "Receive GI",
		description= "Controls the GI received by the material",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	MtlWrapper.generate_caustics= FloatProperty(
		name= "Generate caustics",
		description= "Controls the caustics generated by the material",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	MtlWrapper.receive_caustics= FloatProperty(
		name= "Receive caustics",
		description= "Controls the caustics received by the material",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	MtlWrapper.alpha_contribution= FloatProperty(
		name= "Alpha contribution",
		description= "The contribution of the resulting color to the alpha channel",
		min= -1.0,
		max= 1.0,
		soft_min= -1.0,
		soft_max= 1.0,
		precision= 3,
		default= 1
	)

	MtlWrapper.matte_surface= BoolProperty(
		name= "Matte surface",
		description= "Makes the material appear as a matte material, which shows the background, instead of the base material, when viewed directly",
		default= False
	)

	MtlWrapper.shadows= BoolProperty(
		name= "Shadows",
		description= "Turn this on to make shadow visible on the matter surface",
		default= False
	)

	MtlWrapper.affect_alpha= BoolProperty(
		name= "Affect alpha",
		description= "Turn this on to make shadows affect the alpha contribution of the matte surface",
		default= False
	)

	MtlWrapper.generate_render_elements = BoolProperty(
		name = "Generate Render Elements",
		description = "Setting this to false makes objects to not affect the render elements",
		default = True
	)

	MtlWrapper.shadow_tint_color= FloatVectorProperty(
		name= "Shadow tint color",
		description= 'Tint for the shadows on the matte surface',
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.0,0.0,0.0)
	)

	MtlWrapper.shadow_brightness= FloatProperty(
		name= "Shadow brightness",
		description= "An optional brightness parameter for the shadows on the matte surface.A value of 0.0 will make the shadows completely invisible, while a value of 1.0 will show the full shadows",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 1
	)

	MtlWrapper.reflection_amount= FloatProperty(
		name= "Reflection amount",
		description= "Shows the reflections of the base material",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 1
	)

	MtlWrapper.refraction_amount= FloatProperty(
		name= "Refraction amount",
		description= "Shows the refractions of the base material",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 1
	)

	MtlWrapper.gi_amount= FloatProperty(
		name= "GI amount",
		description= "Determines the amount of gi shadows",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 1
	)

	MtlWrapper.no_gi_on_other_mattes= BoolProperty(
		name= "No GI on other mattes",
		description= "This will cause the material to appear as a matte object in reflections, refractions, GI etc for other matte objects",
		default= True
	)

	MtlWrapper.matte_for_secondary_rays= BoolProperty(
		name= "Matte for secondary rays",
		description= "Turn this on to make the material act as matte for all secondary rays (reflections, refractions, etc)",
		default= False
	)

	MtlWrapper.gi_surface_id= IntProperty(
		name= "GI surface ID",
		description= "If two objects have different GI surface ids, the light cache samples of the two objects will not be blended",
		min= 0,
		max= 10,
		default= 0
	)

	MtlWrapper.gi_quality_multiplier= FloatProperty(
		name= "GI quality multiplier",
		description= "A multiplier for GI quality",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 1
	)

	MtlWrapper.reflection_filter_tex= FloatVectorProperty(
		name= "Reflection filter",
		description= 'Reflection filter',
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1.0,1.0,1.0)
	)

	MtlWrapper.trace_depth= IntProperty(
		name= "Trace depth",
		description= "The maximum reflection depth (-1 is controlled by the global options)",
		min= -1,
		max= 1000,
		default= -1
	)


########NEW FILE########
__FILENAME__ = RenderChannelAO
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

TYPE= 'RENDERCHANNEL'
ID=   'AO'
NAME= 'Ambient Occlusion'
PLUG= 'RenderChannelAO'
DESC= ""
PID=  0

PARAMS= (
	'name',
	'consider_for_aa',
	'affect_matte_objects',
	'filtering'
)

PARAMS_AO= (
	'radius',
	'falloff',
	'subdivs',
	'ignore_for_gi'
)


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *


class RenderChannelAO(bpy.types.PropertyGroup):
	pass
bpy.utils.register_class(RenderChannelAO)

def add_properties(parent_struct):
	parent_struct.RenderChannelAO= PointerProperty(
		type= RenderChannelAO,
		name= NAME,
		description= "V-Ray render channel \"%s\" settings" % NAME
	)

	RenderChannelAO.name= StringProperty(
		name= "Name",
		description= "",
		default= NAME
	)

	RenderChannelAO.consider_for_aa= BoolProperty(
		name= "Consider for AA",
		description= "",
		default= True
	)

	RenderChannelAO.affect_matte_objects= BoolProperty(
		name= "Affect matte objects",
		description= "",
		default= True
	)

	RenderChannelAO.filtering= BoolProperty(
		name= "Filtering",
		description= "",
		default= True
	)

	RenderChannelAO.radius= FloatProperty(
		name= "Radius",
		description= "AO radius",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 0.1
	)

	RenderChannelAO.falloff= FloatProperty(
		name= "Falloff",
		description= "The speed of the transition between occluded and unoccluded areas",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 0.0
	)

	RenderChannelAO.subdivs= IntProperty(
		name= "Subdivs",
		description= "",
		min= 1,
		max= 256,
		soft_min= 1,
		soft_max= 32,
		default= 8
	)



'''
  OUTPUT
'''
def write(ofile, render_channel, sce= None, name= None):
	channel_name= clean_string(render_channel.name)
	if name is not None:
		channel_name= name

	ao_tex_name= "TexDirt_%s" % clean_string(channel_name)

	ofile.write("\nTexDirt %s {"%(ao_tex_name))
	ofile.write("\n\twhite_color= AColor(1.0,1.0,1.0, 1.0);")
	ofile.write("\n\tblack_color= AColor(0.0,0.0,0.0, 1.0);")
	ofile.write("\n\tradius= %.3f;" % render_channel.radius)
	ofile.write("\n\tsubdivs= %d;" % render_channel.subdivs)
	ofile.write("\n\tfalloff= %d;" % render_channel.falloff)
	ofile.write("\n}\n")

	ofile.write("\nRenderChannelExtraTex %s {"%(clean_string(channel_name)))
	for param in PARAMS:
		if param == 'name':
			value= "\"%s\"" % channel_name
		else:
			value= getattr(render_channel, param)
		ofile.write("\n\t%s= %s;"%(param, p(value)))
	ofile.write("\n\ttexmap= %s;"%(ao_tex_name))
	ofile.write("\n}\n")



'''
  GUI
'''
def draw(rna_pointer, layout, wide_ui):
	split= layout.split()
	col= split.column()
	col.prop(rna_pointer, 'radius')
	col.prop(rna_pointer, 'subdivs')
	col.prop(rna_pointer, 'falloff')
	if wide_ui:
		col = split.column()
	col.prop(rna_pointer, 'filtering')
	col.prop(rna_pointer, 'consider_for_aa')
	col.prop(rna_pointer, 'affect_matte_objects')


########NEW FILE########
__FILENAME__ = RenderChannelExtraTex
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

TYPE= 'RENDERCHANNEL'
ID=   'EXTRATEX'
NAME= 'ExtraTex'
PLUG= 'RenderChannelExtraTex'
DESC= ""
PID=  1

PARAMS= (
	'name',
	'consider_for_aa',
	'affect_matte_objects',
	'texmap',
	'filtering'
)


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.shaders import *


class RenderChannelExtraTex(bpy.types.PropertyGroup):
	pass
bpy.utils.register_class(RenderChannelExtraTex)

def add_properties(parent_struct):
	parent_struct.RenderChannelExtraTex= PointerProperty(
		name= "ExtraTex",
		type=  RenderChannelExtraTex,
		description= "V-Ray render channel \"ExtraTex\" settings"
	)

	RenderChannelExtraTex.name= StringProperty(
		name= "Name",
		description= "",
		default= "ExtraTex"
	)

	RenderChannelExtraTex.consider_for_aa= BoolProperty(
		name= "Consider for AA",
		description= "",
		default= True
	)

	RenderChannelExtraTex.affect_matte_objects= BoolProperty(
		name= "Affect matte objects",
		description= "",
		default= True
	)

	RenderChannelExtraTex.texmap= StringProperty(
		name= "Texture",
		description= "",
		default= ""
	)

	RenderChannelExtraTex.filtering= BoolProperty(
		name= "Filtering",
		description= "",
		default= True
	)
	


'''
  OUTPUT
'''
def write(bus, render_channel, sce= None, name= None):
	ofile= bus['files']['scene']
	scene= bus['scene']

	channel_name= name if name is not None else render_channel.name

	if render_channel.texmap not in bpy.data.textures:
		return
	
	# Store mtex context
	context_mtex = None
	if 'mtex' in bus:
		context_mtex = bus['mtex']

	bus['mtex']= {}
	bus['mtex']['env']=     True # This is needed!
	bus['mtex']['slot']=    None
	bus['mtex']['texture']= bpy.data.textures[render_channel.texmap]
	bus['mtex']['factor']=  1.0
	bus['mtex']['mapto']=   None
	bus['mtex']['name']=    clean_string("EXTRATE%s" % (render_channel.texmap))

	texmap= write_texture(bus)

	# Restore mtex context
	if context_mtex:
		bus['mtex'] = context_mtex

	ofile.write("\n%s %s {"%(PLUG, clean_string(channel_name)))
	for param in PARAMS:
		if param == 'name':
			value= "\"%s\"" % channel_name
		elif param == 'texmap':
			value= texmap
		else:
			value= getattr(render_channel, param)
		ofile.write("\n\t%s= %s;"%(param, p(value)))
	ofile.write("\n}\n")



'''
  GUI
'''
def draw(rna_pointer, layout, wide_ui):
	split= layout.split()
	col= split.column()
	col.prop_search(rna_pointer, 'texmap', bpy.data, 'textures')

	split= layout.split()
	col= split.column()
	col.prop(rna_pointer, 'filtering')
	if wide_ui:
		col = split.column()
	col.prop(rna_pointer, 'consider_for_aa')
	col.prop(rna_pointer, 'affect_matte_objects')


########NEW FILE########
__FILENAME__ = RenderChannelLightSelect
#
# V-Ray/Blender
#
# http://vray.cgdo.ru
#
# Author: Andrey M. Izrantsev (aka bdancer)
# E-Mail: izrantsev@cgdo.ru
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
#

TYPE = 'RENDERCHANNEL'

ID   = 'LIGHTSELECT'
NAME = 'Light Select'
PLUG = 'RenderChannelLightSelect'
DESC = ""
PID  = 9

PARAMS = (
    'name',
    'lights',
    'type',
    'color_mapping',   # 1
    'consider_for_aa', # 0
)


# Blender modules
import bpy

# V-Ray/Blender modules
import vb25.utils


def add_properties(parent_struct):
    class RenderChannelLightSelect(bpy.types.PropertyGroup):
        pass
    bpy.utils.register_class(RenderChannelLightSelect)

    parent_struct.RenderChannelLightSelect = bpy.props.PointerProperty(
        name        = "Light Select",
        type        =  RenderChannelLightSelect,
        description = "V-Ray \"Light Select\" render element settings"
    )

    RenderChannelLightSelect.lights = bpy.props.StringProperty(
        name        = "Lights",
        description = "Light list to appear in this channel: name{;name;...}",
        default     = ""
    )

    RenderChannelLightSelect.type = bpy.props.EnumProperty(
        name        = "Type",
        description = "Lighting Type",
        items = (
            ('RAW',      "Raw",      ""),
            ('DIFFUSE',  "Diffuse",  ""),
            ('SPECULAR', "Specular", ""),
        ),
        default = 'DIFFUSE'
    )

    RenderChannelLightSelect.consider_for_aa = bpy.props.BoolProperty(
        name        = "Consider for AA",
        description = "",
        default     = False
    )

    RenderChannelLightSelect.color_mapping = bpy.props.BoolProperty(
        name        = "Color mapping",
        description = "Apply color mapping to \"Light Select\" channel",
        default     =  True
    )



'''
  OUTPUT
'''
def write(ofile, render_channel, sce=None, name=None):
    channel_name = render_channel.name
    if name is not None:
        channel_name = name

    ofile.write("\nRenderChannelColor LightSelect_%s {"%(vb25.utils.clean_string(channel_name)))
    ofile.write("\n\tname=\"%s\";"        % channel_name)
    ofile.write("\n\tcolor_mapping=%i;"   % render_channel.color_mapping)
    ofile.write("\n\tconsider_for_aa=%i;" % render_channel.consider_for_aa)
    ofile.write("\n}\n")



'''
  GUI
'''
def draw(rna_pointer, layout, wide_ui):
    split = layout.split()
    col = split.column()

    col.prop_search(rna_pointer, 'lights', bpy.data, 'lamps')
    col.prop(rna_pointer, 'type')
    col.prop(rna_pointer, 'color_mapping')
    col.prop(rna_pointer, 'consider_for_aa')

########NEW FILE########
__FILENAME__ = RenderChannelMainPasses
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

TYPE= 'RENDERCHANNEL'
ID=   'MAINPASSES'
NAME= 'Main Passes'
PLUG= 'RenderChannelMainPasses'
DESC= "TODO"
PID=  2

PARAMS= None

PARAM_MAP= {
	'RGB':                 1,
	'Diffuse':           101,
	'Reflect':           102,
	'Refract':           103,
	'Self Illumination': 104,
	'Shadow':            105,
	'Specular':          106,
	'Lightning':         107,
	'GI':                108,
	'Caustics':          109,
	'Raw GI':            110,
	'Raw Lightning':     111,
	'Raw Shadow':        112,
	'Velocity':          113,

	'Reflection Filter': 118,
	'Raw Reflection':    119,
	'Refraction Filter': 120,
	'Raw Refraction':    121,
	'Real Color':        122,
	
	'Background':          124,
	'Alpha':               125,
	'Wire Color':          127,
	'Matte Shadow':        128,
	'Total Lightning':     129,
	'Raw Total Lightning': 130,
	'Bump Normal':         131,
	'Samplerate':          132,
	'SSS':                 133,
}


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *


class RenderChannelMainPasses(bpy.types.PropertyGroup):
	pass
bpy.utils.register_class(RenderChannelMainPasses)

def add_properties(parent_struct):
	parent_struct.RenderChannelMainPasses= PointerProperty(
		type= RenderChannelMainPasses,
		name= NAME,
		description= "V-Ray main render channels"
	)

	RenderChannelMainPasses.name= StringProperty(
		name= "Name",
		description= "Channel name",
		default= NAME
	)

	for key in PARAM_MAP:
		chan_name= key.replace(' ','_')
		chan_name= chan_name.lower()
		chan_id= PARAM_MAP[key]

		setattr(RenderChannelMainPasses, 'channel_%s' % chan_name, bpy.props.BoolProperty(
			attr= 'channel_%s' % chan_name,
			name= "%s" % key,
			description= "%s channel" % key,
			default= False)
		)

		setattr(RenderChannelMainPasses, '%s_cm' % chan_name, bpy.props.BoolProperty(
			name= "Color mapping",
			description= "Apply color mapping to \"%s\" channel" % key,
			default= False)
		)

		setattr(RenderChannelMainPasses, '%s_aa' % chan_name, bpy.props.BoolProperty(
			name= "Consider for AA",
			description= "Apply AA to \"%s\" channel" % key,
			default= False)
		)

		setattr(RenderChannelMainPasses, '%s_filt' % chan_name, bpy.props.BoolProperty(
			name= "Filtering",
			description= "Apply filtering to \"%s\" channel" % key,
			default= True)
		)
	


'''
  OUTPUT
'''
def write(ofile, render_channel, sce= None, name= None):
	channel_name= render_channel.name
	if name is not None:
		channel_name= name

	for key in PARAM_MAP:
		chan_name= key.replace(' ','_')
		chan_prop= chan_name.lower()

		chan_id= PARAM_MAP[key]
		chan_cm= getattr(render_channel, '%s_cm' % chan_prop)
		chan_filt= getattr(render_channel, '%s_aa' % chan_prop)
		chan_aa= getattr(render_channel, '%s_filt' % chan_prop)
		
		if(getattr(render_channel, 'channel_%s' % chan_prop)):
			ofile.write("\nRenderChannelColor %s {" % (clean_string("%s_%s" % (channel_name,chan_name))))
			ofile.write("\n\tname= \"%s\";" % chan_name)
			ofile.write("\n\talias= %d;" % chan_id)
			ofile.write("\n\tcolor_mapping= %d;"%(chan_cm))
			ofile.write("\n\tconsider_for_aa= %d;"%(chan_aa))
			ofile.write("\n\tfiltering= %d;"%(chan_filt))
			ofile.write("\n}\n")



'''
  GUI
'''
def draw(rna_pointer, layout, wide_ui):
	def channel_but(layout, channel, cm, aa, filt):
		split= layout.split()
		col= split.column()
		col.prop(rna_pointer, channel)
		if wide_ui:
			col= split.row()
		else:
			col= col.row()
		if getattr(rna_pointer, channel):
			col.prop(rna_pointer, cm, text="CM")
			col.prop(rna_pointer, aa, text="AA")
			col.prop(rna_pointer, filt, text="F")

	for key in sorted(PARAM_MAP):
		chan_name= key.replace(' ','_')
		chan_name= chan_name.lower()
		chan_prop= "channel_%s" % chan_name

		chan_id= PARAM_MAP[key]
		chan_cm= '%s_cm' % chan_name
		chan_aa= '%s_aa' % chan_name
		chan_filt= '%s_filt' % chan_name

		channel_but(layout, chan_prop, chan_cm, chan_aa, chan_filt)

########NEW FILE########
__FILENAME__ = RenderChannelMaterialID
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

TYPE= 'RENDERCHANNEL'
ID=   'MATERIALID'
NAME= 'Material ID'
PLUG= 'RenderChannelMaterialID'
DESC= ""
PID=  11

PARAMS= (
	'name'
)


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *


def add_properties(parent_struct):
	class RenderChannelMaterialID(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(RenderChannelMaterialID)
	
	parent_struct.RenderChannelMaterialID= PointerProperty(
		name= "Material ID",
		type=  RenderChannelMaterialID,
		description= "V-Ray render channel \"Material ID\" settings"
	)

	RenderChannelMaterialID.name= StringProperty(
		name= "Name",
		description= "",
		default= "Material ID"
	)



'''
  OUTPUT
'''
def write(ofile, render_channel, sce= None, name= None):
	channel_name= render_channel.name
	if name is not None:
		channel_name= name

	ofile.write("\nRenderChannelColor %s {" % clean_string(channel_name))
	ofile.write("\n\tname=\"%s\";" % clean_string(channel_name))
	ofile.write("\n\talias=115;")
	ofile.write("\n\tconsider_for_aa=0;")
	ofile.write("\n}\n")


def draw(rna_pointer, layout, wide_ui):
	pass

########NEW FILE########
__FILENAME__ = RenderChannelMultiMatte
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

TYPE= 'RENDERCHANNEL'

ID=   'MULTIMATTE'
NAME= 'MultiMatte'
PLUG= 'RenderChannelMultiMatte'
DESC= ""
PID=  3

PARAMS= (
	'name',
	'red_id',
	'green_id',
	'blue_id',
	'use_mtl_id',
	'affect_matte_objects'
)


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *


class RenderChannelMultiMatte(bpy.types.PropertyGroup):
    pass
bpy.utils.register_class(RenderChannelMultiMatte)

def add_properties(parent_struct):
	parent_struct.RenderChannelMultiMatte= PointerProperty(
		name= "MultiMatte",
		type=  RenderChannelMultiMatte,
		description= "V-Ray render channel \"MultiMatte\" settings"
	)

	RenderChannelMultiMatte.name= StringProperty(
		name= "Name",
		description= "Render channel name",
		maxlen= 64,
		default= "MultiMatte"
	)

	RenderChannelMultiMatte.red_id= IntProperty(
		name= "Red ID",
		description= "The object ID that will be written as the red channel (0 to disable the red channel)",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 0
	)

	RenderChannelMultiMatte.green_id= IntProperty(
		name= "Green ID",
		description= "The object ID that will be written as the green channel (0 to disable the green channel)",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 0
	)

	RenderChannelMultiMatte.blue_id= IntProperty(
		name= "Blue ID",
		description= "The object ID that will be written as the blue channel (0 to disable the blue channel)",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 0
	)

	RenderChannelMultiMatte.use_mtl_id= BoolProperty(
		name= "Use material ID",
		description= "Use the material IDs instead of the object IDs",
		default= False
	)

	RenderChannelMultiMatte.affect_matte_objects= BoolProperty(
		name= "Affect matte objects",
		description= "Affect Matte Objects",
		default= True
	)



'''
  OUTPUT
'''
def write(ofile, render_channel, sce= None, name= None):
	channel_name= render_channel.name
	if name is not None:
		channel_name= name

	ofile.write("\n%s %s {"%(PLUG, clean_string(channel_name)))
	for param in PARAMS:
		if param == 'name':
			value= "\"%s\"" % channel_name
		else:
			value= getattr(render_channel, param)
		ofile.write("\n\t%s= %s;"%(param, p(value)))
	ofile.write("\n}\n")



'''
  GUI
'''
def draw(rna_pointer, layout, wide_ui):
	split= layout.split()
	col= split.column()
	col.prop(rna_pointer, 'red_id')
	col.prop(rna_pointer, 'green_id')
	col.prop(rna_pointer, 'blue_id')
	if wide_ui:
		col = split.column()
	col.prop(rna_pointer, 'use_mtl_id')
	col.prop(rna_pointer, 'affect_matte_objects')

########NEW FILE########
__FILENAME__ = RenderChannelNodeID
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

TYPE= 'RENDERCHANNEL'
ID=   'NODEID'
NAME= 'Node ID'
PLUG= 'RenderChannelNodeID'
DESC= ""
PID=  10

PARAMS= (
	'name'
)


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *


def add_properties(parent_struct):
	class RenderChannelNodeID(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(RenderChannelNodeID)
	
	parent_struct.RenderChannelNodeID= PointerProperty(
		name= "RenderID",
		type=  RenderChannelNodeID,
		description= "V-Ray render channel \"RenderID\" settings"
	)

	RenderChannelNodeID.name= StringProperty(
		name= "Name",
		description= "",
		default= "NodeID"
	)



'''
  OUTPUT
'''
def write(ofile, render_channel, sce= None, name= None):
	channel_name= render_channel.name
	if name is not None:
		channel_name= name

	ofile.write("\n%s %s {" % (PLUG, clean_string(channel_name)))
	ofile.write("\n\tname= \"%s\";" % clean_string(channel_name))
	ofile.write("\n}\n")



'''
  GUI
'''
def draw(rna_pointer, layout, wide_ui):
	layout.label(text="The object's \"Pass index\" contributes the pixel value.")

########NEW FILE########
__FILENAME__ = RenderChannelNormals
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

TYPE= 'RENDERCHANNEL'
ID=   'NORMALS'
NAME= 'Normals'
PLUG= 'RenderChannelNormals'
DESC= ""
PID=  4

PARAMS= (
	'name',
	'filtering'
)


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *


class RenderChannelNormals(bpy.types.PropertyGroup):
	pass
bpy.utils.register_class(RenderChannelNormals)

def add_properties(parent_struct):
	parent_struct.RenderChannelNormals= PointerProperty(
		name= "Normals",
		type=  RenderChannelNormals,
		description= "V-Ray render channel \"Normals\" settings"
	)

	RenderChannelNormals.name= StringProperty(
		name= "Name",
		description= "",
		default= "Normals"
	)

	RenderChannelNormals.filtering= BoolProperty(
		name= "Filtering",
		description= "",
		default= True
	)
	


'''
  OUTPUT
'''
def write(ofile, render_channel, sce= None, name= None):
	channel_name= render_channel.name
	if name is not None:
		channel_name= name

	ofile.write("\n%s %s {"%(PLUG, clean_string(channel_name)))
	for param in PARAMS:
		if param == 'name':
			value= "\"%s\"" % channel_name
		else:
			value= getattr(render_channel, param)
	ofile.write("\n\t%s= %s;"%(param, p(value)))
	ofile.write("\n}\n")



'''
  GUI
'''
def draw(rna_pointer, layout, wide_ui):
	split= layout.split()
	col= split.column()
	col.prop(rna_pointer, 'filtering')
	

########NEW FILE########
__FILENAME__ = RenderChannelObjectSelect
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

TYPE= 'RENDERCHANNEL'

ID=   'OBJECTSELECT'
NAME= 'Object Select'
PLUG= 'RenderChannelObjectSelect'
DESC= ""
PID=  5

PARAMS= (
	'name',
	'id',
	'use_mtl_id',
	'affect_matte_objects',
	'consider_for_aa'
)


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *


class RenderChannelObjectSelect(bpy.types.PropertyGroup):
    pass
bpy.utils.register_class(RenderChannelObjectSelect)

def add_properties(parent_struct):
	parent_struct.RenderChannelObjectSelect= PointerProperty(
		name= "Object select",
		type=  RenderChannelObjectSelect,
		description= "V-Ray render channel \"Object select\" settings"
	)

	RenderChannelObjectSelect.name= StringProperty(
		name= "Name",
		description= "Render channel name",
		maxlen= 64,
		default= "ObjectSelect"
	)

	RenderChannelObjectSelect.id= IntProperty(
		name= "ID",
		description= "The object/material ID that will be extracted",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 100,
		default= 0
	)

	RenderChannelObjectSelect.use_mtl_id= BoolProperty(
		name= "Use material ID",
		description= "Use the material IDs instead of the object IDs",
		default= False
	)

	RenderChannelObjectSelect.affect_matte_objects= BoolProperty(
		name= "Affect matte objects",
		description= "False to not affect Matte Objects",
		default= True
	)

	RenderChannelObjectSelect.consider_for_aa= BoolProperty(
		name= "Consider for AA",
		description= "TODO",
		default= False
	)



'''
  OUTPUT
'''
def write(ofile, render_channel, sce= None, name= None):
	channel_name= render_channel.name
	if name is not None:
		channel_name= name

	ofile.write("\n%s %s {"%(PLUG, clean_string(channel_name)))
	for param in PARAMS:
		if param == 'name':
			value= "\"%s\"" % channel_name
		else:
			value= getattr(render_channel, param)
		ofile.write("\n\t%s= %s;"%(param, p(value)))
	ofile.write("\n}\n")



'''
  GUI
'''
def draw(rna_pointer, layout, wide_ui):
	split= layout.split()
	col= split.column()
	col.prop(rna_pointer, 'id')
	col.prop(rna_pointer, 'use_mtl_id')
	if wide_ui:
		col = split.column()
	col.prop(rna_pointer, 'affect_matte_objects')
	col.prop(rna_pointer, 'consider_for_aa')

########NEW FILE########
__FILENAME__ = RenderChannelRenderID
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

TYPE= 'RENDERCHANNEL'
ID=   'RENDERID'
NAME= 'Render ID'
PLUG= 'RenderChannelRenderID'
DESC= ""
PID=  6

PARAMS= (
	'name'
)


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *


def add_properties(parent_struct):
	class RenderChannelRenderID(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(RenderChannelRenderID)
	
	parent_struct.RenderChannelRenderID= PointerProperty(
		name= "RenderID",
		type=  RenderChannelRenderID,
		description= "V-Ray render channel \"RenderID\" settings"
	)

	RenderChannelRenderID.name= StringProperty(
		name= "Name",
		description= "",
		default= "RenderID"
	)



'''
  OUTPUT
'''
def write(ofile, render_channel, sce= None, name= None):
	channel_name= render_channel.name
	if name is not None:
		channel_name= name

	ofile.write("\n%s %s {" % (PLUG, clean_string(channel_name)))
	ofile.write("\n\tname= \"%s\";" % clean_string(channel_name))
	ofile.write("\n}\n")


def draw(rna_pointer, layout, wide_ui):
	pass

########NEW FILE########
__FILENAME__ = RenderChannelVelocity
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

TYPE= 'RENDERCHANNEL'
ID=   'VELOCITY'
NAME= 'Velocity'
PLUG= 'RenderChannelVelocity'
DESC= ""
PID=  7

PARAMS= (
	'name',
	'clamp_velocity',
	'max_velocity',
	'max_velocity_last_frame',
	'ignore_z',
	'filtering'
)


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *


class RenderChannelVelocity(bpy.types.PropertyGroup):
	pass
bpy.utils.register_class(RenderChannelVelocity)

def add_properties(parent_struct):
	parent_struct.RenderChannelVelocity= PointerProperty(
		name= "Velocity",
		type=  RenderChannelVelocity,
		description= "V-Ray render channel \"Velocity\" settings"
	)

	RenderChannelVelocity.name= StringProperty(
		name= "Name",
		description= "",
		default= "Velocity"
	)

	RenderChannelVelocity.clamp_velocity= BoolProperty(
		name= "Clamp",
		description= "",
		default= True
	)

	RenderChannelVelocity.max_velocity= FloatProperty(
		name= "Max velocity",
		description= "Max velocity",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	RenderChannelVelocity.max_velocity_last_frame= FloatProperty(
		name= "Max velocity last frame",
		description= "Max velocity last frame",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	RenderChannelVelocity.ignore_z= BoolProperty(
		name= "Ignore Z",
		description= "",
		default= True
	)

	RenderChannelVelocity.filtering= BoolProperty(
		name= "Filtering",
		description= "",
		default= True
	)
	


'''
  OUTPUT
'''
def write(ofile, render_channel, sce= None, name= None):
	channel_name= render_channel.name
	if name is not None:
		channel_name= name

	ofile.write("\n%s %s {"%(PLUG, clean_string(channel_name)))
	for param in PARAMS:
		if param == 'name':
			value= "\"%s\"" % channel_name
		else:
			value= getattr(render_channel, param)
	ofile.write("\n\t%s= %s;"%(param, p(value)))
	ofile.write("\n}\n")



'''
  GUI
'''
def draw(rna_pointer, layout, wide_ui):
	split= layout.split()
	col= split.column()
	col.prop(rna_pointer, 'max_velocity')
	col.prop(rna_pointer, 'max_velocity_last_frame', text="Max last")
	if wide_ui:
		col = split.column()
	col.prop(rna_pointer, 'clamp_velocity')
	col.prop(rna_pointer, 'ignore_z')
	col.prop(rna_pointer, 'filtering')


########NEW FILE########
__FILENAME__ = RenderChannelZDepth
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

TYPE= 'RENDERCHANNEL'

ID=   'ZDEPTH'
NAME= 'ZDepth'
PLUG= 'RenderChannelZDepth'
DESC= ""
PID=  8

PARAMS= (
	'name',
	'depth_from_camera',
	'depth_black',
	'depth_white',
	'depth_clamp',
	'filtering'
)


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *


def add_properties(parent_struct):
	class RenderChannelZDepth(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(RenderChannelZDepth)
	
	parent_struct.RenderChannelZDepth= PointerProperty(
		name= "Z-Depth",
		type=  RenderChannelZDepth,
		description= "V-Ray render channel \"Z-Depth\" settings"
	)

	RenderChannelZDepth.name= StringProperty(
		name= "Name",
		description= "Render channel name",
		maxlen= 64,
		default= "ZDepth"
	)

	RenderChannelZDepth.depth_from_camera= BoolProperty(
		name= "From camera",
		description= "",
		default= False
	)

	RenderChannelZDepth.depth_black= FloatProperty(
		name= "Black distance",
		description= "",
		min= 0.0,
		max= 100000.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	RenderChannelZDepth.depth_white= FloatProperty(
		name= "White distance",
		description= "",
		min= 0.0,
		max= 100000.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1000
	)

	RenderChannelZDepth.depth_clamp= BoolProperty(
		name= "Clamp",
		description= "",
		default= True
	)

	RenderChannelZDepth.filtering= BoolProperty(
		name= "Filtering",
		description= "",
		default= True
	)



'''
  OUTPUT
'''
def write(ofile, render_channel, sce= None, name= None):
	channel_name= render_channel.name
	if name is not None:
		channel_name= name

	ofile.write("\n%s %s {"%(PLUG, clean_string(channel_name)))
	for param in PARAMS:
		if param == 'name':
			value= "\"%s\"" % channel_name
		else:
			value= getattr(render_channel, param)
		ofile.write("\n\t%s= %s;"%(param, p(value)))
	ofile.write("\n}\n")



'''
  GUI
'''
def draw(rna_pointer, layout, wide_ui):
	split= layout.split()
	col= split.column()
	col.prop(rna_pointer, 'depth_black', text="Black dist")
	col.prop(rna_pointer, 'depth_white', text="White dist")
	if wide_ui:
		col = split.column()
	col.prop(rna_pointer, 'depth_from_camera')
	col.prop(rna_pointer, 'depth_clamp')
	col.prop(rna_pointer, 'filtering')

########NEW FILE########
__FILENAME__ = RenderView
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'SETTINGS'
ID=   'RenderView'

NAME= 'Render view'
DESC= "Render view settings."

PARAMS= (
)


def add_properties(rna_pointer):
	class RenderView(bpy.types.PropertyGroup):
		clip_near = BoolProperty(
			name = "Clip Near",
			description = "Clip near",
			default = False
		)

		clip_far = BoolProperty(
			name = "Clip Far",
			description = "Clip far",
			default = False
		)
	bpy.utils.register_class(RenderView)

	rna_pointer.RenderView= PointerProperty(
		name= "RenderView",
		type=  RenderView,
		description= "V-Ray RenderView settings"
	)


def write(bus):
	ofile  = bus['files']['camera']
	scene  = bus['scene']
	camera = bus['camera']

	VRayScene = scene.vray
	VRayBake  = VRayScene.VRayBake
	RTEngine  = VRayScene.RTEngine

	VRayCamera     = camera.data.vray
	RenderView     = VRayScene.RenderView
	SettingsCamera = VRayCamera.SettingsCamera

	if not VRayBake.use:
		fov = VRayCamera.fov if VRayCamera.override_fov else camera.data.angle

		aspect = float(scene.render.resolution_x) / float(scene.render.resolution_y)
		orthoWidth = camera.data.ortho_scale

		if aspect < 1.0:
			fov        = fov * aspect
			orthoWidth = float(orthoWidth) * aspect

		ofile.write("\n// Camera: %s" % (camera.name))
		ofile.write("\nRenderView CameraView {")
		ofile.write("\n\ttransform=%s;" % a(scene, transform(camera.matrix_world)))
		ofile.write("\n\tfov=%s;" % a(scene, fov))
		if SettingsCamera.type not in ('SPHERIFICAL','BOX'):
			ofile.write("\n\tclipping=%i;" % (RenderView.clip_near or RenderView.clip_far))
			if RenderView.clip_near:
				ofile.write("\n\tclipping_near=%s;" % a(scene, camera.data.clip_start))
			if RenderView.clip_far:
				ofile.write("\n\tclipping_far=%s;" % a(scene, camera.data.clip_end))
		if camera.data.type == 'ORTHO':
			ofile.write("\n\torthographic=1;")
			ofile.write("\n\torthographicWidth=%s;" % a(scene, orthoWidth))
		ofile.write("\n}\n")

########NEW FILE########
__FILENAME__ = RTEngine
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'SETTINGS'
ID=   'RTEngine'

NAME= 'Realtime Engine'
DESC= "V-Ray Realtime Engine"

PARAMS= (
	'enabled',
	'separate_window',
	'trace_depth',
	'use_gi',
	'gi_depth',
	'gi_reflective_caustics',
	'gi_refractive_caustics',
	'bundle_size',
	'samples_per_pixel',
	'coherent_tracing',
	'use_opencl',
	'stereo_mode',
	'stereo_eye_distance',
	'stereo_focus',
	'opencl_texsize',
)

PARAMS_SETTINGS_RT_ENGINE = (
	'trace_depth',
	'use_gi',
	'gi_depth',
	'gi_reflective_caustics',
	'gi_refractive_caustics',
	'bundle_size',
	'samples_per_pixel',
	'coherent_tracing',
	'stereo_mode',
	'stereo_eye_distance',
	'stereo_focus',
	'opencl_texsize',
)


def add_properties(rna_pointer):
	class RTEngine(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(RTEngine)

	rna_pointer.RTEngine= PointerProperty(
		name= NAME,
		type= RTEngine,
		description= "V-Ray Realtime Engine settings"
	)

	# enabled
	RTEngine.enabled= BoolProperty(
		name= "Realtime engine",
		description= "Enable the RT engine",
		default= False
	)

	# separate_window
	RTEngine.separate_window= BoolProperty(
		name= "Separate window",
		description= "True to open a separate window for the RTEngine, and false to use the V-Ray VFB",
		default= False
	)

	# trace_depth
	RTEngine.trace_depth= IntProperty(
		name= "Trace depth",
		description= "Maximum trace depth for reflections/refractions etc",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 5
	)

	# use_gi
	RTEngine.use_gi= BoolProperty(
		name= "Use GI",
		description= "Use global illumination",
		default= True
	)

	# gi_depth
	RTEngine.gi_depth= IntProperty(
		name= "GI depth",
		description= "Maximum trace depth for GI",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 3
	)

	# gi_reflective_caustics
	RTEngine.gi_reflective_caustics= BoolProperty(
		name= "GI reflective caustics",
		description= "Reflective GI caustics",
		default= False
	)

	# gi_refractive_caustics
	RTEngine.gi_refractive_caustics= BoolProperty(
		name= "GI refractive caustics",
		description= "Refractive GI caustics",
		default= True
	)

	# bundle_size
	RTEngine.bundle_size= IntProperty(
		name= "Bundle size",
		description= "Number of samples to transfer over the network",
		min= 0,
		max= 1024,
		soft_min= 0,
		soft_max= 1024,
		default= 128
	)

	# samples_per_pixel
	RTEngine.samples_per_pixel= IntProperty(
		name= "Samples per pixel",
		description= "Number of samples per pixel",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 4
	)

	# coherent_tracing
	RTEngine.coherent_tracing= BoolProperty(
		name= "Coherent tracing",
		description= "Coherent tracing of gi/reflections/refractions etc",
		default= False
	)

	# use_opencl
	RTEngine.use_opencl = EnumProperty(
		name = "Device",
		description = "Computation Device",
		items = (
			('CPU',           "CPU",             ""),
			('CUDA_SINGLE',   "CUDA",            ""),
			('OPENCL_SINGLE', "OpenCL (Single)", ""),
			('OPENCL_MULTI',  "OpenCL (Multi)",  ""),
		),
		default = 'CPU'
	)

	# stereo_mode
	RTEngine.stereo_mode= EnumProperty(
		name= "Stereo mode",
		description= "Enable side-by-side stereo rendering",
		items= (
			('STEREO', "Side-by-side", "Side-by-side stereo rendering"),
			('NONE',   "None",   ""),
		),
		default= 'NONE'
	)

	# stereo_eye_distance
	RTEngine.stereo_eye_distance= FloatProperty(
		name= "Stereo eye distance",
		description= "Distance between the two cameras for stereo mode",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 6.5
	)

	# stereo_focus
	RTEngine.stereo_focus= EnumProperty(
		name= "Stereo focus",
		description= "Focus mode",
		items= (
			('SHEAR', "Shear",    ""),
			('ROT',   "Rotation", ""),
			('NONE',  "None",     ""),
		),
		default= 'NONE'
	)

	# opencl_texsize
	RTEngine.opencl_texsize= IntProperty(
		name= "Texture size",
		description= "OpenCL Single Kernel maximum texture size - bigger textures are scaled to fit this size",
		min= 0,
		max= 100000,
		soft_min= 0,
		soft_max= 2048,
		default= 512
	)

	# Command line options
	RTEngine.rtTimeOut = FloatProperty(
		name        = "Timeout",
		description = "Specifies a timeout in minutes for a frame (0.0 - no limit)",
		unit        = 'TIME',
		min         = 0.0,
		max         = 10000.0,
		soft_min    = 0.0,
		soft_max    = 10.0,
		precision   = 3,
		default     = 0.0
	)

	RTEngine.rtNoise = FloatProperty(
		name        = "Noise",
		description = "Specifies noise threshold for a frame",
		min         = 0.0,
		max         = 1.0,
		soft_min    = 0.0,
		soft_max    = 1.0,
		precision   = 4,
		default     = 0.001
	)

	RTEngine.rtSampleLevel = IntProperty(
		name        = "Sample Level",
		description = "Specifies maximum paths per pixel (0 - no limit)",
		min         = 0,
		default     = 0
	)



def write(bus):
	ofile = bus['files']['scene']
	scene = bus['scene']

	VRayScene = scene.vray
	RTEngine  = VRayScene.RTEngine

	STEREO_MODE = {
		'STEREO': 1,
		'NONE':   0,
	}

	STEREO_FOCUS = {
		'SHEAR': 2,
		'ROT':   1,
		'NONE':  0,
	}

	DEVICE = {
		'CPU'           : 0,
		'OPENCL_SINGLE' : 1,
		'OPENCL_MULTI'  : 2,
		'CUDA_SINGLE'   : 4,
	}

	if RTEngine.enabled:
		# XXX: When exporting this plugin termination params do not work!
		# Write all the params to support previous versions
		# ofile.write("\n%s %s {" % (ID, ID))
		# for param in PARAMS:
		# 	if param == 'stereo_mode':
		# 		value = STEREO_MODE[RTEngine.stereo_mode]
		# 	elif param == 'stereo_focus':
		# 		value = STEREO_FOCUS[RTEngine.stereo_focus]
		# 	elif param == 'use_opencl':
		# 		value = DEVICE[RTEngine.use_opencl]
		# 	else:
		# 		value = getattr(RTEngine, param)
		# 	ofile.write("\n\t%s=%s;"%(param, p(value)))
		# ofile.write("\n}\n")

		ofile.write("\nSettingsRTEngine settingsRT {")
		for param in PARAMS_SETTINGS_RT_ENGINE:
			if param == 'stereo_mode':
				value = STEREO_MODE[RTEngine.stereo_mode]
			elif param == 'stereo_focus':
				value = STEREO_FOCUS[RTEngine.stereo_focus]
			elif param == 'use_opencl':
				# We will set it in command line
				#value = DEVICE[RTEngine.use_opencl]
				continue
			else:
				value = getattr(RTEngine, param)
			ofile.write("\n\t%s=%s;"%(param, p(value)))
		ofile.write("\n}\n")


'''
  GUI
'''
class VRAY_RP_RTEngine(ui.VRayRenderPanel, bpy.types.Panel):
	bl_label       = "Realtime engine"
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		scene= context.scene
		rd=    scene.render
		if not hasattr(scene.vray, ID):
			return False
		use=   scene.vray.RTEngine.enabled
		return (use and ui.engine_poll(__class__, context))

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		VRayScene= context.scene.vray

		RTEngine= getattr(VRayScene, ID)

		split= layout.split()
		col= split.column()
		col.prop(RTEngine, 'use_gi')
		if RTEngine.use_gi:
			col.prop(RTEngine, 'gi_depth', text="Depth")
			col.prop(RTEngine, 'gi_reflective_caustics', text="Reflective caustics")
			col.prop(RTEngine, 'gi_refractive_caustics', text="Refractive caustics")
		if wide_ui:
			col= split.column()
		col.prop(RTEngine, 'coherent_tracing')
		col.prop(RTEngine, 'trace_depth')
		col.prop(RTEngine, 'bundle_size')
		col.prop(RTEngine, 'samples_per_pixel')
		col.prop(RTEngine, 'opencl_texsize')

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(RTEngine, 'stereo_mode')
		if RTEngine.stereo_mode != 'NONE':
			split= layout.split()
			col= split.column()
			col.prop(RTEngine, 'stereo_focus', text="Focus")
			if wide_ui:
				col= split.column()
			col.prop(RTEngine, 'stereo_eye_distance', text="Eye distance")

		layout.separator()

		split = layout.split()
		col = split.column()
		col.prop(RTEngine, 'rtSampleLevel')
		split = layout.split()
		col = split.column()
		col.prop(RTEngine, 'rtNoise')
		if wide_ui:
			col= split.column()
		col.prop(RTEngine, 'rtTimeOut')

		layout.separator()
		layout.prop(RTEngine, 'use_opencl')


def GetRegClasses():
	return (
		VRAY_RP_RTEngine,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = SettingsCamera
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''

''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'CAMERA'
ID=   'SettingsCamera'

NAME= 'Camera'
DESC= "V-Ray SettingsCamera settings"

PARAMS= (
)


def add_properties(rna_pointer):
	class SettingsCamera(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(SettingsCamera)

	rna_pointer.SettingsCamera= PointerProperty(
		name= "SettingsCamera",
		type=  SettingsCamera,
		description= "V-Ray camera settings"
	)

	SettingsCamera.type= EnumProperty(
		name= "Type",
		description= "Camera type",
		items=(
			('DEFAULT',            "Default", ""),
			('SPHERIFICAL',        "Spherifical", ""),
			('CYLINDRICAL_POINT',  "Cylindrical (point)", ""),
			('CYLINDRICAL_ORTHO',  "Cylindrical (ortho)", ""),
			('BOX',                "Box", ""),
			('FISH_EYE',           "Fish-eye", ""),
			('WARPED_SPHERICAL',   "Warped spherical", ""),
			('ORTHOGONAL',         "Orthogonal", ""),
			('PINHOLE',            "Pinhole", ""),
		),
		default= 'DEFAULT'
	)

	SettingsCamera.auto_fit= BoolProperty(
		name= "Auto-fit",
		description= "The auto-fit option of the fish-eye camera",
		default= True
	)

	SettingsCamera.height= FloatProperty(
		name= "Height",
		description= "Height of the cylindrical (ortho) camera",
		min=0.0, max=10000.0,
		soft_min=0.0, soft_max=10.0,
		default=400.0
	)

	SettingsCamera.dist= FloatProperty(
		name="Distance",
		description="Distance to the sphere center",
		min=0.0, max=1000.0,
		soft_min=0.0, soft_max=10.0,
		default=2.0
	)

	SettingsCamera.curve= FloatProperty(
		name="Curve",
		description="Controls the way the rendered images is warped",
		min=0.0, max=10.0,
		soft_min=0.0, soft_max=10.0,
		default=1.0
	)


def write(bus):
	TYPE = {
		'DEFAULT':           0,
		'SPHERIFICAL':       1,
		'CYLINDRICAL_POINT': 2,
		'CYLINDRICAL_ORTHO': 3,
		'BOX':               4,
		'FISH_EYE':          5,
		'WARPED_SPHERICAL':  6,
		'ORTHOGONAL':        7,
		'PINHOLE':           8,
	}

	ofile  = bus['files']['scene']
	scene  = bus['scene']
	camera = bus['camera']

	VRayCamera     = camera.data.vray
	SettingsCamera = VRayCamera.SettingsCamera
	CameraPhysical = VRayCamera.CameraPhysical

	fov = VRayCamera.fov if VRayCamera.override_fov else camera.data.angle

	aspect = scene.render.resolution_x / scene.render.resolution_y
	orthoWidth = camera.data.ortho_scale

	if aspect < 1.0:
		fov = fov * aspect
		orthoWidth = float(orthoWidth) * aspect

	ofile.write("\n// Camera: %s" % (camera.name))
	ofile.write("\nSettingsCamera CA%s {" % clean_string(camera.name))
	if camera.data.type == 'ORTHO':
		ofile.write("\n\ttype=0;")
		ofile.write("\n\theight=%s;" % a(scene, orthoWidth))
	else:
		ofile.write("\n\ttype=%i;" % TYPE[SettingsCamera.type])
	ofile.write("\n\tfov=-1;")
	ofile.write("\n}\n")

########NEW FILE########
__FILENAME__ = SettingsCameraDof
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.shaders import *
from vb25.ui import ui


TYPE= 'CAMERA'
ID=   'SettingsCameraDof'

NAME= 'Depth of field'
DESC= "V-Ray SettingsCameraDof settings."

PARAMS= (
)


def add_properties(rna_pointer):
	class SettingsCameraDof(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(SettingsCameraDof)

	rna_pointer.SettingsCameraDof= PointerProperty(
		name= "SettingsCameraDof",
		type=  SettingsCameraDof,
		description= "Camera's DoF settings"
	)

	SettingsCameraDof.on= BoolProperty(
		name= "DOF",
		description= "Use depth of field",
		default= False
	)

	SettingsCameraDof.sides_on= BoolProperty(
		name="This option allows you to simulate the polygonal shape of the aperture of real-world cameras.",
		description="Enable Bokeh effects",
		default= False
	)

	SettingsCameraDof.sides_num= IntProperty(
		name="Number",
		description="Number of sides",
		min=1, max=100,
		default=5
	)

	SettingsCameraDof.subdivs= IntProperty(
		name="Subdivs",
		description="Controls the quality of the DOF effect",
		min=1, max=100,
		default=8
	)

	SettingsCameraDof.anisotropy= FloatProperty(
		name="Anisotropy",
		description="This allows the stretching of the bokeh effect horizontally or vertically",
		min=0.0, max=1.0,
		soft_min=0.0, soft_max=1.0,
		default=0.0
	)

	SettingsCameraDof.focal_dist= FloatProperty(
		name="Focal distance",
		description="Determines the distance from the camera at which objects will be in perfect focus",
		min=0.0, max=1000.0,
		soft_min=0.0, soft_max=10.0,
		default=200.0
	)

	SettingsCameraDof.aperture= FloatProperty(
		name="Aperture",
		description="The size of the virtual camera aperture, in world units",
		min=0.0, max=100.0,
		soft_min=0.0, soft_max=10.0,
		default=5.0
	)

	SettingsCameraDof.center_bias= FloatProperty(
		name="Center bias",
		description="This determines the uniformity of the DOF effect",
		min=0.0, max=100.0,
		soft_min=0.0, soft_max=10.0,
		default=0.0
	)

	SettingsCameraDof.rotation= FloatProperty(
		name="Rotation",
		description="Specifies the orientation of the aperture shape",
		min=0.0, max=10.0,
		soft_min=0.0, soft_max=10.0,
		default=0.0
	)


########NEW FILE########
__FILENAME__ = SettingsCaustics
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

import os

''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'SETTINGS'
ID=   'SettingsCaustics'

NAME= 'Caustics'
DESC= "Caustics settings."

PARAMS= (
	'on',
	'max_photons',
	'search_distance',
	'max_density',
	'multiplier',
	'mode',
	'file',
	'dont_delete',
	'auto_save',
	'auto_save_file',
	'show_calc_phase'
)


def add_properties(parent_struct):
	class SettingsCaustics(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(SettingsCaustics)
	
	parent_struct.SettingsCaustics= PointerProperty(
		name= "Caustics",
		type=  SettingsCaustics,
		description= "Caustics settings"
	)

	SettingsCaustics.on= BoolProperty(
		name= "On",
		description= "Enable caustics computation",
		default= False
	)

	SettingsCaustics.max_photons= IntProperty(
		name= "Max photons",
		description= "TODO",
		min= 0,
		soft_min= 0,
		soft_max= 10000,
		default= 30
	)

	SettingsCaustics.search_distance= FloatProperty(
		name= "Search distance",
		description= "TODO",
		subtype= 'DISTANCE',
		min= 0.0,
		max= 1000.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 0.1
	)
	
	SettingsCaustics.max_density= FloatProperty(
		name= "Max density",
		description= "TODO",
		min= 0.0,
		max= 1000.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	SettingsCaustics.multiplier= FloatProperty(
		name= "Multiplier",
		description= "TODO",
		min= 0.0,
		max= 1000.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	SettingsCaustics.mode= EnumProperty(
		name= "Mode",
		description= "Caustics computaion mode",
		items= (
			('FILE', "From file", ""),
			('NEW',  "New",       ""),
		),
		default= 'NEW'
	)

	SettingsCaustics.file= StringProperty(
		name= "File",
		subtype= 'FILE_PATH',
		description= "TODO"
	)
	
	SettingsCaustics.auto_save= BoolProperty(
		name= "Auto save",
		description= "TODO",
		default= False
	)

	SettingsCaustics.auto_save_file= StringProperty(
		name= "Auto save file",
		subtype= 'FILE_PATH',
		description= "TODO"
	)

	SettingsCaustics.show_calc_phase= BoolProperty(
		name= "Show calc phase",
		description= "TODO",
		default= False
	)

	SettingsCaustics.dont_delete= BoolProperty(
		name = "Don\'t delete",
		default = False
	)



'''
  OUTPUT
'''
def write(bus):
	MODE= {
		'FILE': 1,
		'NEW':  0
	}

	ofile=  bus['files']['scene']
	scene=  bus['scene']

	VRayScene=        scene.vray
	SettingsCaustics= VRayScene.SettingsCaustics

	ofile.write("\n%s %s {" % (ID,ID))
	for param in PARAMS:
		if param in ('file','auto_save_file'):
			value= "\"%s\"" % path_sep_to_unix(bpy.path.abspath(getattr(SettingsCaustics, param)))
		elif param == 'mode':
			value= MODE[SettingsCaustics.mode]
		else:
			value= getattr(SettingsCaustics, param)
		ofile.write("\n\t%s= %s;"%(param, p(value)))
	ofile.write("\n}\n")



'''
  GUI
'''
class RENDER_PT_SettingsCaustics(ui.VRayRenderPanel, bpy.types.Panel):
	bl_label = NAME

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		scene= context.scene
		rd=    scene.render
		if not hasattr(scene.vray, ID):
			return False
		show= scene.vray.SettingsCaustics.on
		return (show and ui.engine_poll(__class__, context))

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		vsce= context.scene.vray
		vmodule= getattr(vsce, ID)

		layout.prop(vmodule,'mode')

		if vmodule.mode == 'FILE':
			layout.separator()
			layout.prop(vmodule,'file')

			filePath = vmodule.file
			photonMapSize = "0 bytes"
			if os.path.exists(filePath):
				photonMapSize = GetStrSize(os.stat(filePath).st_size)

			layout.label("Photon map takes %s." % photonMapSize)
			layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(vmodule,'multiplier')
		col.prop(vmodule,'search_distance')
		if wide_ui:
			col = split.column()
		col.prop(vmodule,'max_photons')
		col.prop(vmodule,'max_density')

		if not vmodule.mode == 'FILE':
			split = layout.split()
			col = split.column()
			col.prop(vmodule, 'dont_delete')
			col = split.column()
			col.prop(vmodule, 'show_calc_phase')

			split= layout.split()
			split.label(text="Files:")
			split= layout.split(percentage=0.25)
			colL= split.column()
			colR= split.column()
			if wide_ui:
				colL.prop(vmodule,"auto_save", text="Auto save")
			else:
				colL.prop(vmodule,"auto_save", text="")
			colR.active= vmodule.auto_save
			colR.prop(vmodule,"auto_save_file", text="")


def GetRegClasses():
	return (
		RENDER_PT_SettingsCaustics,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = SettingsColorMapping
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE = 'SETTINGS'
ID   = 'SettingsColorMapping'

NAME = 'Color mapping'
DESC = "Color mapping options"

PARAMS = (
	'type',
	'affect_background',
	'dark_mult',
	'bright_mult',
	'gamma',
	'subpixel_mapping',
	'clamp_output',
	'clamp_level',
	'adaptation_only',
	'linearWorkflow',
)


def getColorMappingData(scene):
	TYPE = {
		'LNR'  : 0,
		'EXP'  : 1,
		'HSV'  : 2,
		'INT'  : 3,
		'GCOR' : 4,
		'GINT' : 5,
		'REIN' : 6,
	}

	VRayScene            = scene.vray
	SettingsColorMapping = VRayScene.SettingsColorMapping

	cmData = "\nSettingsColorMapping ColorMapping {"
	for param in PARAMS:
		if param == 'type':
			value = TYPE[SettingsColorMapping.type]
		else:
			value = getattr(SettingsColorMapping, param)
		cmData += "\n\t%s= %s;" % (param, p(value))
	cmData += "\n}\n"

	return cmData


def updatePreviewColorMapping(self, context):
	if bpy.context.scene.render.engine == 'VRAY_RENDER_PREVIEW':
		open(getColorMappingFilepath(), 'w').write(getColorMappingData(context.scene))


def add_properties(rna_pointer):
	class SettingsColorMapping(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(SettingsColorMapping)

	rna_pointer.SettingsColorMapping= PointerProperty(
		name        = "Color Mapping",
		type        =  SettingsColorMapping,
		description = "Color mapping settings"
	)

	SettingsColorMapping.type= EnumProperty(
		name        = "Type",
		description = "Color mapping type",
		items = (
			('LNR',"Linear",""),
			('EXP',"Exponential",""),
			('HSV',"HSV exponential",""),
			('INT',"Intensity exponential",""),
			('GCOR',"Gamma correction",""),
			('GINT',"Intensity gamma",""),
			('REIN',"Reinhard","")
		),
		update  = updatePreviewColorMapping,
		default = "LNR"
	)

	SettingsColorMapping.affect_background= BoolProperty(
		name= "Affect background",
		description= "Affect colors belonging to the background",
		update  = updatePreviewColorMapping,
		default= True
	)

	SettingsColorMapping.dark_mult= FloatProperty(
		name= "Dark multiplier",
		description= "Multiplier for dark colors",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 1.0,
		update  = updatePreviewColorMapping,
		default= 1.0
	)

	SettingsColorMapping.bright_mult= FloatProperty(
		name= "Bright multiplier",
		description= "Multiplier for bright colors",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 1.0,
		update  = updatePreviewColorMapping,
		default= 1.0
	)

	SettingsColorMapping.gamma= FloatProperty(
		name= "Gamma",
		description= "Gamma correction for the output image regardless of the color mapping mode",
		min= 0.0,
		max= 10.0,
		soft_min= 1.0,
		soft_max= 2.2,
		update  = updatePreviewColorMapping,
		default= 1.0
	)

	SettingsColorMapping.input_gamma= FloatProperty(
		name= "Input gamma",
		description= "Input gamma for textures",
		min= 0.0,
		max= 10.0,
		soft_min= 1.0,
		soft_max= 2.2,
		update  = updatePreviewColorMapping,
		default= 1.0
	)

	SettingsColorMapping.clamp_output= BoolProperty(
		name= "Clamp output",
		description= "Clamp colors after color mapping",
		update  = updatePreviewColorMapping,
		default= True
	)

	SettingsColorMapping.clamp_level= FloatProperty(
		name= "Clamp level",
		description= "The level at which colors will be clamped",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 100.0,
		update  = updatePreviewColorMapping,
		default= 1.0
	)

	SettingsColorMapping.subpixel_mapping= BoolProperty(
		name= "Sub-pixel mapping",
		description= "This option controls whether color mapping will be applied to the final image pixels, or to the individual sub-pixel samples",
		update  = updatePreviewColorMapping,
		default= False
	)

	SettingsColorMapping.adaptation_only= BoolProperty(
		name= "Adaptation only",
		description= "When this parameter is on, the color mapping will not be applied to the final image, however V-Ray will proceed with all its calculations as though color mapping is applied (e.g. the noise levels will be corrected accordingly)",
		update  = updatePreviewColorMapping,
		default= False
	)

	SettingsColorMapping.linearWorkflow= BoolProperty(
		name= "Linear workflow",
		description= "When this option is checked V-Ray will automatically apply the inverse of the Gamma correction that you have set in the Gamma field to all materials in scene",
		update  = updatePreviewColorMapping,
		default= False
	)


def write(bus):
	if bus['preview']:
		return

	cmData = getColorMappingData(bus['scene'])

	bus['files']['colorMapping'].write(cmData)
	bus['files']['scene'].write(cmData)

########NEW FILE########
__FILENAME__ = SettingsDefaultDisplacement
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'SETTINGS'

ID=   'SettingsDefaultDisplacement'

NAME= 'Default displacement'
DESC= "Default displacement options."

PARAMS= (
	'override_on',
	'edgeLength',
	'viewDependent',
	'maxSubdivs',
	'tightBounds',
	'amount',
	'relative',
)


def add_properties(rna_pointer):
	class SettingsDefaultDisplacement(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(SettingsDefaultDisplacement)

	rna_pointer.SettingsDefaultDisplacement= PointerProperty(
		name= "Default Displacement",
		type=  SettingsDefaultDisplacement,
		description= "Default displacement settings"
	)

	SettingsDefaultDisplacement.override_on= BoolProperty(
		name= "Override",
		description= "Override settings globally",
		default= False
	)

	SettingsDefaultDisplacement.edgeLength= FloatProperty(
		name= "Edge length",
		description= "Max. height",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 4
	)

	SettingsDefaultDisplacement.viewDependent= BoolProperty(
		name= "View dependent",
		description= "Determines if view-dependent tesselation is used",
		default= True
	)

	SettingsDefaultDisplacement.maxSubdivs= IntProperty(
		name= "Max subdivs",
		description= "Determines the maximum subdivisions for a triangle of the original mesh",
		min= 0,
		max= 2048,
		soft_min= 0,
		soft_max= 1024,
		default= 256
	)

	SettingsDefaultDisplacement.tightBounds= BoolProperty(
		name= "Tight bounds",
		description= "When this is on, initialization will be slower, but tighter bounds will be computed for the displaced triangles making rendering faster",
		default= True
	)

	SettingsDefaultDisplacement.amount= FloatProperty(
		name= "Amount",
		description= "Determines the displacement amount for white areas in the displacement map",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	SettingsDefaultDisplacement.relative= BoolProperty(
		name= "Relative",
		description= "TODO",
		default= False
	)


def write(bus):
	ofile=  bus['files']['scene']
	scene=  bus['scene']

	rna_pointer= getattr(scene.vray, ID)
	ofile.write("\n%s %s {" % (ID,ID))
	for param in PARAMS:
		value= getattr(rna_pointer, param)
		ofile.write("\n\t%s= %s;"%(param, p(value)))
	ofile.write("\n}\n")


########NEW FILE########
__FILENAME__ = SettingsDMCSampler
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'SETTINGS'

ID=   'SettingsDMCSampler'

NAME= 'DMC sampler'
DESC= "DMC sampler options"

PARAMS= (
	'time_dependent',
	'adaptive_amount',
	'adaptive_threshold',
	'adaptive_min_samples',
	'subdivs_mult',
)


def add_properties(rna_pointer):
	class SettingsDMCSampler(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(SettingsDMCSampler)

	rna_pointer.SettingsDMCSampler= PointerProperty(
		name= "DMC Sampler",
		type=  SettingsDMCSampler,
		description= "DMC Sampler settings"
	)

	SettingsDMCSampler.adaptive_threshold= FloatProperty(
		name= "Noise threshold",
		description= "Controls V-Ray's judgement of when a blurry value is \"good enough\" to be used",
		min= 0.0,
		max= 1.0,
		soft_min= 0.001,
		soft_max= 0.1,
		default= 0.01,
		precision= 3
	)

	SettingsDMCSampler.adaptive_min_samples= IntProperty(
		name= "Min samples",
		description= "The minimum number of samples that must be made before the early termination algorithm is used",
		min= 1,
		max= 1000,
		default= 8
	)

	SettingsDMCSampler.adaptive_amount= FloatProperty(
		name= "Adaptive amount",
		description= "A value of 1.0 means full adaptation; a value of 0.0 means no adaptation",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 0.85,
		precision= 2
	)

	SettingsDMCSampler.time_dependent= BoolProperty(
		name= "Time dependent",
		description= "This make the samping pattern change with time",
		default= 0
	)

	SettingsDMCSampler.subdivs_mult= FloatProperty(
		name= "Subdivs mult",
		description= "This will multiply all subdivs values everywhere during rendering",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		default= 1.0
	)



'''
  OUTPUT
'''
def write(bus):
	ofile=  bus['files']['scene']
	scene=  bus['scene']

	rna_pointer= getattr(scene.vray, ID)
	ofile.write("\n%s %s {" % (ID,ID))
	for param in PARAMS:
		value= getattr(rna_pointer, param)
		ofile.write("\n\t%s= %s;"%(param, p(value)))
	ofile.write("\n}\n")


########NEW FILE########
__FILENAME__ = SettingsEnvironment
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
import mathutils
from bpy.props import *

''' vb modules '''
from vb25.ui      import ui
from vb25.plugins import *
from vb25.utils   import *
from vb25.shaders import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'SETTINGS'
ID=   'SettingsEnvironment'

NAME= 'Environment Effects'
DESC= "Environment effects."

PARAMS= {
	'SettingsEnvironment': (
		'num_environment_objects', # integer = 0, Used for implementing image planes
	),

	'EnvironmentFog' : (
		'gizmos',
		'emission',
		'emission_tex',
		'emission_mult',
		'emission_mult_tex',
		'color',
		'color_tex',
		'distance',
		'density',
		'density_tex',
		'use_height',
		'height',
		'subdivs',
		'yup',
		'fade_out_mode',
		'fade_out_radius',
		'per_object_fade_out_radius',
		'use_fade_out_tex',
		'fade_out_tex',
		'edge_fade_out',
		'fade_out_type',
		'scatter_gi',
		'scatter_bounces',
		'simplify_gi',
		'step_size',
		'max_steps',
		'tex_samples',
		'cutoff_threshold',
		'light_mode',
		'lights',
		'use_shade_instance',
		'affect_background',
		'affect_reflections',
		'affect_refractions',
		'affect_shadows',
		'affect_gi',
		'affect_camera',
	),

	'VolumeVRayToon': (
		'lineColor',
		'widthType',
		'lineWidth',
		'opacity',
		'hideInnerEdges',
		'normalThreshold',
		'overlapThreshold',
		'traceBias',
		'doSecondaryRays',
		'excludeType',
		'excludeList',
		# 'lineColor_tex',
		# 'lineWidth_tex',
		# 'opacity_tex',
		# 'distortion_tex',
	),

	'SphereFade': (
		#'gizmos',
		'empty_color',
		'affect_alpha',
		'falloff'
	),
}


def add_properties(rna_pointer):
	class SphereFade(bpy.types.PropertyGroup):
		loc_only = BoolProperty(
			name        = "Use Location Only",
			description = "Use only location (ignore scale and rotation)",
			default     = False
		)
	bpy.utils.register_class(SphereFade)

	class VolumeVRayToon(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(VolumeVRayToon)

	class EnvironmentFog(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(EnvironmentFog)

	class EnvironmentEffect(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(EnvironmentEffect)

	class VRayEffects(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(VRayEffects)

	rna_pointer.EnvironmentFog= PointerProperty(
		name= "EnvironmentFog",
		type=  EnvironmentFog,
		description= "EnvironmentFog settings"
	)

	rna_pointer.SphereFade= PointerProperty(
		name= "SphereFade",
		type=  SphereFade,
		description= "SphereFade settings"
	)

	rna_pointer.VolumeVRayToon= PointerProperty(
		name= "VolumeVRayToon",
		type=  VolumeVRayToon,
		description= "VolumeVRayToon settings"
	)

	rna_pointer.VRayEffects= PointerProperty(
		name= "Environment Effects",
		type=  VRayEffects,
		description= "V-Ray environment effects settings"
	)

	VRayEffects.effects= CollectionProperty(
		name= "Environment Effect",
		type=  EnvironmentEffect,
		description= "V-Ray environment effect"
	)

	VRayEffects.use= BoolProperty(
		name= "Use effects",
		description= "Use effects",
		default= False
	)

	VRayEffects.effects_selected= IntProperty(
		name= "Selected Environment Effect",
		description= "Selected environment effect",
		default= -1,
		min= -1,
		max= 100
	)

	EnvironmentEffect.type= EnumProperty(
		name= "Type",
		description= "Distributed rendering network type",
		items= (
			('TOON', "Toon", "Object outline (toon style)."),
			('FOG',  "Fog",  "Environment / object fog."),
			('SFADE',  "SphereFade",  "Sphere Fade.")
		),
		default= 'FOG'
	)

	EnvironmentEffect.use= BoolProperty(
		name= "",
		description= "Use effect",
		default= True
	)

	EnvironmentEffect.EnvironmentFog= PointerProperty(
		name= "EnvironmentFog",
		type=  EnvironmentFog,
		description= "V-Ray EnvironmentFog settings"
	)

	EnvironmentEffect.VolumeVRayToon= PointerProperty(
		name= "VolumeVRayToon",
		type=  VolumeVRayToon,
		description= "V-Ray VolumeVRayToon settings"
	)

	EnvironmentEffect.SphereFade= PointerProperty(
		name= "SphereFade",
		type=  SphereFade,
		description= "SphereFade settings"
	)

	EnvironmentFog.emission= FloatVectorProperty(
		name= "Emission",
		description= "Fog emission color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0)
	)

	EnvironmentFog.emission_mult= FloatProperty(
		name= "Emission mult",
		description= "Emission mult",
		min= 0.0,
		max= 100000.0,
		soft_min= 0.0,
		soft_max= 100.0,
		precision= 3,
		default= 1.0
	)

	EnvironmentFog.emission_mult_tex= FloatProperty(
		name= "Emission texture mult",
		description= "Emission texture mult",
		min= 0.0,
		max= 100000.0,
		soft_min= 0.0,
		soft_max= 100.0,
		precision= 3,
		default= 1
	)

	EnvironmentFog.color= FloatVectorProperty(
		name= "Color",
		description= "Fog color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1.0,1.0,1.0)
	)

	EnvironmentFog.distance= FloatProperty(
		name= "Distance",
		description= "Distance between fog particles",
		min= 0.0,
		max= 10000.0,
		soft_min= 0.0,
		soft_max= 100.0,
		precision= 3,
		default= 0.2
	)

	EnvironmentFog.density= FloatProperty(
		name= "Density",
		description= "A multiplier for the Fog distance parameter that allows a texture to be used for the density of the fog",
		min= 0.0,
		max= 1000.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	EnvironmentFog.density_tex = StringProperty(
		name        = "Density Texture",
		description = "",
		default     = ""
	)

	EnvironmentFog.emission_tex = StringProperty(
		name        = "Emission Texture",
		description = "",
		default     = ""
	)

	EnvironmentFog.use_height= BoolProperty(
		name= "Use height",
		description= "Whether or not the height should be taken into account",
		default= False
	)

	EnvironmentFog.height= FloatProperty(
		name= "Height",
		description= "Fog starting point along the Z-axis",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 100
	)

	EnvironmentFog.subdivs= IntProperty(
		name= "Subdivs",
		description= "Fog subdivision",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 8
	)

	EnvironmentFog.affect_background= BoolProperty(
		name= "Affect background",
		description= "Affect background",
		default= True
	)

	EnvironmentFog.yup= BoolProperty(
		name= "Y-up",
		description= "If true, y is the up axis, not z",
		default= False
	)

	EnvironmentFog.fade_out_mode= EnumProperty(
		name= "Fade out mode",
		description= "Fade out mode",
		items= (
			('SUBSTRACT', "Substract", ""),
			('MULT',      "Multiply",  ""),
		),
		default= 'MULT'
	)

	EnvironmentFog.fade_out_radius= FloatProperty(
		name= "Fade out radius",
		description= "Fade out effect for the edges",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	EnvironmentFog.per_object_fade_out_radius= BoolProperty(
		name= "Per object fade out radius",
		description= "Fade out effect for the edges per object",
		default= False
	)

	EnvironmentFog.use_fade_out_tex= BoolProperty(
		name= "Use fade out tex",
		description= "True if the fade_out_tex should be used for fade out computation",
		default= False
	)

	EnvironmentFog.edge_fade_out= FloatProperty(
		name= "Edge fade out",
		description= "Used with the fade_out_tex, mimics Maya fluid's edge dropoff attribute",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	EnvironmentFog.fade_out_type= IntProperty(
		name= "Fade out type",
		description= "0 - used for the gradients and the grid falloff(fadeout);1 - used for the sphere, cone and double cone types;2 - used for the cube type, the computations are done in the TexMayaFluidProcedural plug-in;",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 0
	)

	EnvironmentFog.scatter_gi= BoolProperty(
		name= "Scatter GI",
		description= "Scatter global illumination",
		default= True
	)

	EnvironmentFog.scatter_bounces= IntProperty(
		name= "Scatter bounces",
		description= "Number of GI bounces calculated inside the fog",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 8
	)

	EnvironmentFog.simplify_gi= BoolProperty(
		name= "Simplify GI",
		description= "Simplify global illumination",
		default= False
	)

	EnvironmentFog.step_size= FloatProperty(
		name= "Step size",
		description= "Size of one step through the volume",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	EnvironmentFog.max_steps= IntProperty(
		name= "Max steps",
		description= "Maximum number of steps through the volume",
		min= 0,
		max= 10000,
		soft_min= 0,
		soft_max= 10000,
		default= 1000
	)

	EnvironmentFog.tex_samples= IntProperty(
		name= "Texture samples",
		description= "Number of texture samples for each step through the volume",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 4
	)

	EnvironmentFog.cutoff_threshold= FloatProperty(
		name= "Cutoff",
		description= "Controls when the raymarcher will stop traversing the volume",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.001
	)

	EnvironmentFog.light_mode= EnumProperty(
		name= "Light mode",
		description= "Light mode",
		items= (
			('ADDGIZMO',"Add to per-gizmo lights",""),
			('INTERGIZMO',"Intersect with per-gizmo lights",""),
			('OVERGIZMO',"Override per-gizmo lights",""),
			('PERGIZMO',"Use per-gizmo lights",""),
			('NO',"No lights","")
		),
		default= 'PERGIZMO'
	)

	EnvironmentFog.lights= StringProperty(
		name= "Lights",
		description= "",
		default= ""
	)

	EnvironmentFog.use_shade_instance= BoolProperty(
		name= "Use shade instance",
		description= "True if the shade instance should be used when sampling textures",
		default= False
	)

	EnvironmentFog.objects= StringProperty(
		name= "Objects",
		description= "",
		default= ""
	)

	EnvironmentFog.groups= StringProperty(
		name= "Groups",
		description= "",
		default= ""
	)
	# affect_background
	EnvironmentFog.affect_background= BoolProperty(
		name= "Affect background",
		description= "Affect background",
		default= True
	)

	# affect_reflections
	EnvironmentFog.affect_reflections= BoolProperty(
		name= "Affect reflections",
		description= "true if the fog is visible to reflection rays",
		default= True
	)

	# affect_refractions
	EnvironmentFog.affect_refractions= BoolProperty(
		name= "Affect refractions",
		description= "true if the fog is visible to refraction rays",
		default= True
	)

	# affect_shadows
	EnvironmentFog.affect_shadows= BoolProperty(
		name= "Affect shadows",
		description= "true if the fog affects shadow rays",
		default= True
	)

	# affect_gi
	EnvironmentFog.affect_gi= BoolProperty(
		name= "Affect GI",
		description= "true if the fog affects GI rays",
		default= True
	)

	# affect_camera
	EnvironmentFog.affect_camera= BoolProperty(
		name= "Affect camera",
		description= "true if the fog affects primary camera rays",
		default= True
	)

	VolumeVRayToon.use= BoolProperty(
		name= "Use",
		description= "Render outline",
		default= False
	)

	VolumeVRayToon.override_material= BoolProperty(
		name= "Override material",
		description= "Override outline set in materials",
		default= False
	)

	# lineColor
	VolumeVRayToon.lineColor= FloatVectorProperty(
		name= "Color",
		description= "The color of cartoon line",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0)
	)

	# widthType
	VolumeVRayToon.widthType= EnumProperty(
		name= "Type",
		description= "",
		items= (
			('WORLD', "World",  "World units."),
			('PIXEL', "Pixels", "Pixels.")
		),
		default= 'PIXEL'
	)

	# lineWidth
	VolumeVRayToon.lineWidth= FloatProperty(
		name= "Width",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 5,
		default= 1.5
	)

	# opacity
	VolumeVRayToon.opacity= FloatProperty(
		name= "Opacity",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# hideInnerEdges
	VolumeVRayToon.hideInnerEdges= BoolProperty(
		name= "Hide inner edges",
		description= "",
		default= True
	)

	# normalThreshold
	VolumeVRayToon.normalThreshold= FloatProperty(
		name= "Normal thresh",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.7
	)

	# overlapThreshold
	VolumeVRayToon.overlapThreshold= FloatProperty(
		name= "Overlap thresh",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.95
	)

	# traceBias
	VolumeVRayToon.traceBias= FloatProperty(
		name= "Bias",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.2
	)

	# doSecondaryRays
	VolumeVRayToon.doSecondaryRays= BoolProperty(
		name= "Do sec. rays",
		description= "Do reflections / refractons",
		default= False
	)

	# excludeType
	VolumeVRayToon.excludeType= EnumProperty(
		name= "Include / exclude",
		description= "",
		items= (
			('INCLUDE', "Include", "Include objects."),
			('EXCLUDE', "Exclude", "Exclude objects.")
		),
		default= 'EXCLUDE'
	)

	# excludeList
	VolumeVRayToon.excludeList_objects= StringProperty(
		name= "excludeList",
		description= "",
		default= ""
	)

	VolumeVRayToon.excludeList_groups= StringProperty(
		name= "excludeList",
		description= "",
		default= ""
	)

	# lineColor_tex
	VolumeVRayToon.map_lineColor_tex= BoolProperty(
		name= "lineColor tex",
		description= "",
		default= False
	)

	VolumeVRayToon.lineColor_tex_mult= FloatProperty(
		name= "lineColor tex",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# lineWidth_tex
	VolumeVRayToon.map_lineWidth_tex= BoolProperty(
		name= "lineWidth tex",
		description= "",
		default= False
	)

	VolumeVRayToon.lineWidth_tex_mult= FloatProperty(
		name= "lineWidth tex",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# opacity_tex
	VolumeVRayToon.map_opacity_tex= BoolProperty(
		name= "opacity tex",
		description= "",
		default= False
	)

	VolumeVRayToon.opacity_tex_mult= FloatProperty(
		name= "opacity tex",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	# distortion_tex
	VolumeVRayToon.map_distortion_tex= BoolProperty(
		name= "distortion tex",
		description= "",
		default= False
	)

	VolumeVRayToon.distortion_tex_mult= FloatProperty(
		name= "distortion tex",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

	SphereFade.use = BoolProperty(
		name        = "",
		description = "",
		default     = False
	)

	SphereFade.affect_alpha = BoolProperty(
		name        = "Affect Alpha",
		description = "Affect Alpha",
		default     = False
	)

	SphereFade.empty_color= FloatVectorProperty(
		name= "Empty Color",
		description= "",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.5,0.5,0.5)
	)

	SphereFade.falloff= FloatProperty(
		name= "Falloff",
		description= "",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.2
	)

	SphereFade.gizmos_objects= StringProperty(
		name= "Gizmo",
		description= "",
		default= ""
	)

	SphereFade.gizmos_groups= StringProperty(
		name= "Gizmo group",
		description= "",
		default= ""
	)



'''
  Write plugins settings to file
'''
def write_VolumeVRayToon_from_material(bus):
	WIDTHTYPE= {
		'PIXEL': 0,
		'WORLD': 1,
	}

	ofile= bus['files']['environment']
	scene= bus['scene']

	ob= bus['node']['object']
	ma= bus['material']['material']

	VRayMaterial= ma.vray

	VolumeVRayToon= VRayMaterial.VolumeVRayToon

	toon_name= clean_string("MT%s%s" % (ob.name, ma.name))

	ofile.write("\nVolumeVRayToon %s {" % toon_name)
	ofile.write("\n\tcompensateExposure= 1;")
	for param in PARAMS['VolumeVRayToon']:
		if param == 'excludeType':
			value= 1
		elif param == 'excludeList':
			value= "List(%s)" % get_name(ob, prefix='OB')
		elif param == 'widthType':
			value= WIDTHTYPE[VolumeVRayToon.widthType]
		else:
			value= getattr(VolumeVRayToon, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return toon_name


def write_SphereFadeGizmo(bus, SphereFade, ob):
	scene= bus['scene']
	ofile= bus['files']['environment']

	tm = mathutils.Matrix.Translation(ob.matrix_world.translation)

	if not SphereFade.loc_only:
		sca  = ob.matrix_world.to_scale()
		tm[0][0] = sca[0]
		tm[1][1] = sca[1]
		tm[2][2] = sca[2]

	vray = ob.vray
	name= "MG%s" % get_name(ob, prefix='EMPTY')
	ofile.write("\nSphereFadeGizmo %s {" % name)
	ofile.write("\n\ttransform= %s;" % a(scene, transform(tm)))
	if ob.type == 'EMPTY':
		ofile.write("\n\tradius=%s;" % ob.empty_draw_size)
	elif vray.MtlRenderStats.use:
		ofile.write("\n\tradius=%s;" % vray.fade_radius)
	ofile.write("\n\tinvert=0;")
	ofile.write("\n}\n")
	return name


def write_SphereFade(bus, effect, gizmos):
	scene= bus['scene']
	ofile= bus['files']['environment']

	name= "ESF%s" % clean_string(effect.name)

	ofile.write("\nSphereFade %s {" % name)
	ofile.write("\n\tgizmos= List(%s);" % ','.join(gizmos))
	for param in PARAMS['SphereFade']:
		value= getattr(effect.SphereFade, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene,value)))

	ofile.write("\n}\n")


def write(bus):
	ofile= bus['files']['environment']
	scene= bus['scene']

	VRayScene= scene.vray
	VRayExporter= VRayScene.exporter

	def write_EnvFogMeshGizmo(bus, ob):
		name= "MG%s" % get_name(ob, prefix='OB')

		ofile.write("\nEnvFogMeshGizmo %s {" % name)
		ofile.write("\n\tgeometry= %s;" % get_name(ob.data if VRayExporter.use_instances else ob, prefix='ME'))
		ofile.write("\n\ttransform= %s;" % a(scene, transform(ob.matrix_world)))
		#ofile.write("\n\tlights= List(%s);" % )
		#ofile.write("\n\tfade_out_radius= %s;" % )
		ofile.write("\n}\n")

		return name

	def write_EnvironmentFog_from_material(ofile,volume,material):
		LIGHT_MODE= {
			'ADDGIZMO':    4,
			'INTERGIZMO':  3,
			'OVERGIZMO':   2,
			'PERGIZMO':    1,
			'NO':          0
		}

		plugin= 'EnvironmentFog'
		name= "%s_%s" % (plugin,material)

		ofile.write("\n%s %s {"%(plugin,name))
		ofile.write("\n\tgizmos= List(%s);" % ','.join(volume[material]['gizmos']))
		for param in volume[material]['params']:
			if param == 'light_mode':
				value= LIGHT_MODE[volume[material]['params'][param]]
			elif param in ('density_tex','fade_out_tex','emission_mult_tex'):
				value= "%s::out_intensity" % volume[material]['params'][param]
			else:
				value= volume[material]['params'][param]
			ofile.write("\n\t%s= %s;"%(param, a(scene,value)))
		ofile.write("\n}\n")

		return name

	def write_EnvironmentFog(bus, effect, gizmos):
		LIGHT_MODE= {
			'ADDGIZMO':    4,
			'INTERGIZMO':  3,
			'OVERGIZMO':   2,
			'PERGIZMO':    1,
			'NO':          0
		}
		FADE_OUT_MODE= {
			'MULT':      0,
			'SUBSTRACT': 1,
		}

		EnvironmentFog= effect.EnvironmentFog

		density_tex       = None
		density_tex_voxel = False
		if EnvironmentFog.density_tex:
			if EnvironmentFog.density_tex in bpy.data.textures:
				if bpy.data.textures[EnvironmentFog.density_tex].type == 'VOXEL_DATA':
					density_tex_voxel = True
			density_tex = write_subtexture(bus, EnvironmentFog.density_tex)

		emission_tex = None
		if EnvironmentFog.emission_tex:
			emission_tex = write_subtexture(bus, EnvironmentFog.emission_tex)

		if emission_tex:
			emission_tex_mult_name = "%sMult" % emission_tex
			ofile.write("\nTexAColorOp %s {" % emission_tex_mult_name)
			ofile.write("\n\tcolor_a=%s;" % emission_tex)
			ofile.write("\n\tmult_a=%.3f;" % EnvironmentFog.emission_mult)
			ofile.write("\n}\n")
			emission_tex = emission_tex_mult_name

		name= "EEF%s" % clean_string(effect.name)

		ofile.write("\nEnvironmentFog %s {" % name)
		for param in PARAMS['EnvironmentFog']:
			value = None

			if param.endswith('_tex') or param.endswith('_mult'):
				if param == 'density_tex' and density_tex:
					value = "%s"%(density_tex)
					if not density_tex_voxel:
						value += "::out_intensity"
				elif param == 'emission_tex' and emission_tex:
					value = "%s"%(emission_tex)
				else:
					continue
			elif param == 'emission':
				value = "%s * %.3f" % (p(EnvironmentFog.emission), EnvironmentFog.emission_mult)
			elif param == 'fade_out_mode':
				value= FADE_OUT_MODE[EnvironmentFog.fade_out_mode]
			elif param == 'light_mode':
				value= LIGHT_MODE[EnvironmentFog.light_mode]
			elif param == 'gizmos':
				value= "List(%s)" % ','.join(gizmos)
			elif param == 'lights':
				light_object_list= [get_name(ob, prefix='LA') for ob in generate_object_list(EnvironmentFog.lights) if object_visible(bus,ob)]
				if not len(light_object_list):
					continue
				value= "List(%s)" % ','.join(light_object_list)
			else:
				value= getattr(EnvironmentFog, param)

			if value is not None:
				ofile.write("\n\t%s=%s;"%(param, a(scene, value)))
		ofile.write("\n}\n")

		return name

	def write_VolumeVRayToon(bus, effect, objects):
		EXCLUDETYPE= {
			'EXCLUDE': 0,
			'INCLUDE': 1,
		}
		WIDTHTYPE= {
			'PIXEL': 0,
			'WORLD': 1,
		}

		VolumeVRayToon= effect.VolumeVRayToon

		name= "EVT%s" % clean_string(effect.name)

		ofile.write("\nVolumeVRayToon %s {" % name)
		ofile.write("\n\tcompensateExposure= 1;")
		for param in PARAMS['VolumeVRayToon']:
			if param == 'excludeType':
				value= EXCLUDETYPE[VolumeVRayToon.excludeType]
			elif param == 'widthType':
				value= WIDTHTYPE[VolumeVRayToon.widthType]
			elif param == 'excludeList':
				value= "List(%s)" % ','.join(objects)
			else:
				value= getattr(VolumeVRayToon, param)
			ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
		ofile.write("\n}\n")

		return name

	VRayScene=   scene.vray
	VRayEffects= VRayScene.VRayEffects

	# Processing Effects
	volumes= []
	if VRayEffects.use:
		for effect in VRayEffects.effects:
			if effect.use:
				if effect.type == 'FOG':
					EnvironmentFog= effect.EnvironmentFog
					gizmos= [write_EnvFogMeshGizmo(bus, ob) for ob in generate_object_list(EnvironmentFog.objects, EnvironmentFog.groups) if object_visible(bus,ob)]
					# if gizmos:
					# 	volumes.append(write_EnvironmentFog(bus, effect, gizmos))
					volumes.append(write_EnvironmentFog(bus, effect, gizmos))

				elif effect.type == 'TOON':
					VolumeVRayToon= effect.VolumeVRayToon

					excludeList= generate_object_list(VolumeVRayToon.excludeList_objects, VolumeVRayToon.excludeList_groups)
					toon_objects= [get_name(ob, prefix='OB') for ob in excludeList]

					if not VolumeVRayToon.override_material:
						if VolumeVRayToon.excludeType == 'EXCLUDE':
							toon_objects.extend( [ get_name(ob, prefix='OB') for ob in bus['effects']['toon']['objects'] ] )

					volumes.append(write_VolumeVRayToon(bus, effect, toon_objects))

				elif effect.type == 'SFADE':
					SphereFade= effect.SphereFade
					gizmos= [write_SphereFadeGizmo(bus, SphereFade, ob) for ob in generate_object_list(SphereFade.gizmos_objects, SphereFade.gizmos_groups) if object_visible(bus,ob)]
					write_SphereFade(bus, effect, gizmos)

	volumes.reverse()
	volumes.extend(bus['effects']['toon']['effects'])

	world=     scene.world
	VRayWorld= world.vray

	if VRayWorld:
		VRayScene=    scene.vray
		VRayExporter= VRayScene.exporter

		defaults= {
			'env_bg':         (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(VRayWorld.bg_color)),         0, 'NONE'),
			'env_gi':         (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(VRayWorld.gi_color)),         0, 'NONE'),
			'env_reflection': (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(VRayWorld.reflection_color)), 0, 'NONE'),
			'env_refraction': (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(VRayWorld.refraction_color)), 0, 'NONE'),
		}

		bus['env_textures']= {}
		for i,slot in enumerate(world.texture_slots):
			if slot and slot.texture and slot.texture.type in TEX_TYPES:
				VRaySlot= slot.texture.vray_slot

				for key in defaults:
					if getattr(VRaySlot, 'use_map_'+key):
						factor= getattr(VRaySlot, key+'_factor')

						if key not in bus['env_textures']: # First texture
							bus['env_textures'][key]= []
							if factor < 1.0 or VRaySlot.blend_mode != 'NONE' or slot.use_stencil:
								bus['env_textures'][key].append(defaults[key])

						bus['mtex']= {}
						bus['mtex']['env']=     True
						bus['mtex']['mapto']=   key
						bus['mtex']['slot']=    slot
						bus['mtex']['texture']= slot.texture
						bus['mtex']['factor']=  factor
						bus['mtex']['name']=    clean_string("WT%.2iSL%sTE%s" % (i,
																				 slot.name,
																				 slot.texture.name))

						# Write texture
						if write_texture(bus):
							bus['env_textures'][key].append( [stack_write_texture(bus),
															  slot.use_stencil,
															  VRaySlot.blend_mode] )

		if VRayExporter.debug:
			if len(bus['env_textures']):
				print_dict(scene, "World texture stack", bus['env_textures'])

		for key in bus['env_textures']:
			if len(bus['env_textures'][key]):
				bus['env_textures'][key]= write_TexOutput(bus, stack_write_textures(bus, stack_collapse_layers(bus['env_textures'][key])), key)

		if VRayExporter.debug:
			if len(bus['env_textures']):
				print_dict(scene, "World textures", bus['env_textures'])

		ofile.write("\nSettingsEnvironment SettingsEnvironment {")
		if 'env_bg' in bus['env_textures']:
			ofile.write("\n\tbg_tex=%s;" % bus['env_textures']['env_bg'])
		else:
			ofile.write("\n\tbg_tex=%s;"      % a(scene, VRayWorld.bg_color))
			ofile.write("\n\tbg_tex_mult=%s;" % a(scene, VRayWorld.bg_color_mult))

		if 'env_gi' in bus['env_textures']:
			ofile.write("\n\tgi_tex=%s;" % bus['env_textures']['env_gi'])
		elif VRayWorld.gi_override:
			ofile.write("\n\tgi_tex=%s;"      % a(scene, VRayWorld.gi_color))
			ofile.write("\n\tgi_tex_mult=%s;" % a(scene, VRayWorld.gi_color_mult))

		if 'env_reflection' in bus['env_textures']:
			ofile.write("\n\treflect_tex=%s;" % bus['env_textures']['env_reflection'])
		elif VRayWorld.reflection_override:
			ofile.write("\n\treflect_tex=%s;"      % a(scene, VRayWorld.reflection_color))
			ofile.write("\n\treflect_tex_mult=%s;" % a(scene, VRayWorld.reflection_color_mult))

		if 'env_refraction' in bus['env_textures']:
			ofile.write("\n\trefract_tex=%s;" % bus['env_textures']['env_refraction'])
		elif VRayWorld.refraction_override:
			ofile.write("\n\trefract_tex=%s;"      % a(scene, VRayWorld.refraction_color))
			ofile.write("\n\trefract_tex_mult=%s;" % a(scene, VRayWorld.refraction_color_mult))

		ofile.write("\n\tglobal_light_level=%s;" % a(scene, "Color(1.0,1.0,1.0)*%.3f" % (VRayWorld.global_light_level)))

		ofile.write("\n\tenvironment_volume=List(%s);" % (','.join(volumes)))
		ofile.write("\n}\n")


def WriteSphereFade(bus):
	scene = bus['scene']

	VRayScene = scene.vray
	VRayEffects = VRayScene.VRayEffects

	if not VRayEffects.use:
		return

	for effect in VRayEffects.effects:
		if not effect.use:
			continue

		if not effect.type == 'SFADE':
			continue

		SphereFade = effect.SphereFade

		for ob in generate_object_list(SphereFade.gizmos_objects, SphereFade.gizmos_groups):
			if object_visible(bus,ob):
				write_SphereFadeGizmo(bus, SphereFade, ob)

'''
  GUI
'''
def influence(context, layout, slot):
	VRaySlot= slot.texture.vray_slot

	# 	split= layout.split()
	# 	col= split.column()
	# 	col.label(text="Volume:")
	# 	split= layout.split()
	# 	col= split.column()
	# 	ui.factor_but(col, VRaySlot, 'map_color_tex',    'color_tex_mult',    "Color")
	# 	ui.factor_but(col, VRaySlot, 'map_density_tex',  'density_tex_mult',  "Density")
	# 	if wide_ui:
	# 		col= split.column()
	# 	ui.factor_but(col, VRaySlot, 'map_emission_tex', 'emission_tex_mult', "Emission")


def draw_EnvironmentFog(context, layout, rna_pointer):
	wide_ui= context.region.width > ui.narrowui

	EnvironmentFog= rna_pointer.EnvironmentFog

	split= layout.split()
	col= split.column()
	col.prop_search(EnvironmentFog, 'objects',
					context.scene,  'objects',
					text="Objects")
	col.prop_search(EnvironmentFog, 'groups',
					bpy.data,       'groups',
					text="Groups")

	layout.separator()

	layout.prop_search(EnvironmentFog, 'density_tex',  bpy.data, 'textures', text = "Density Texture")
	layout.prop_search(EnvironmentFog, 'emission_tex', bpy.data, 'textures', text = "Emission Texture")

	layout.separator()

	split= layout.split()
	col= split.column()
	col.prop(EnvironmentFog, 'color')
	if wide_ui:
		col= split.column()
	col.prop(EnvironmentFog, 'emission')
	col.prop(EnvironmentFog, 'emission_mult', text = "Mult")

	layout.separator()

	split= layout.split()
	col= split.column()
	col.prop(EnvironmentFog, 'distance')
	col.prop(EnvironmentFog, 'density')
	col.prop(EnvironmentFog, 'subdivs')
	col.prop(EnvironmentFog, 'scatter_gi')
	if EnvironmentFog.scatter_gi:
		col.prop(EnvironmentFog, 'scatter_bounces')
	col.prop(EnvironmentFog, 'use_height')
	if EnvironmentFog.use_height:
		col.prop(EnvironmentFog, 'height')
	if wide_ui:
		col= split.column()
	#col.prop(EnvironmentFog, 'fade_out_type')
	col.prop(EnvironmentFog, 'fade_out_radius')
	col.prop(EnvironmentFog, 'affect_background')
	col.prop(EnvironmentFog, 'use_shade_instance')
	col.prop(EnvironmentFog, 'simplify_gi')

	layout.separator()

	split= layout.split()
	col= split.column()
	col.prop(EnvironmentFog, 'light_mode')
	col.prop(EnvironmentFog, 'fade_out_mode')

	split= layout.split()
	col= split.column()
	col.prop_search(EnvironmentFog, 'lights',
					context.scene,  'objects',
					text="Lights")

	layout.separator()

	split= layout.split()
	col= split.column()
	col.prop(EnvironmentFog, 'step_size')
	col.prop(EnvironmentFog, 'max_steps')
	if wide_ui:
		col= split.column()
	col.prop(EnvironmentFog, 'tex_samples')
	col.prop(EnvironmentFog, 'cutoff_threshold')

	#col.prop(EnvironmentFog, 'per_object_fade_out_radius')
	#col.prop(EnvironmentFog, 'yup')

	layout.separator()

	split= layout.split()
	col= split.column()
	col.prop(EnvironmentFog, 'affect_shadows')
	col.prop(EnvironmentFog, 'affect_gi')
	col.prop(EnvironmentFog, 'affect_camera')
	if wide_ui:
		col= split.column()
	col.prop(EnvironmentFog, 'affect_reflections')
	col.prop(EnvironmentFog, 'affect_refractions')


def draw_VolumeVRayToon(context, layout, rna_pointer):
	wide_ui= context.region.width > ui.narrowui

	VolumeVRayToon= rna_pointer.VolumeVRayToon

	split= layout.split()
	col= split.column()
	col.prop(VolumeVRayToon, 'lineColor', text="")
	col.prop(VolumeVRayToon, 'widthType')
	col.prop(VolumeVRayToon, 'lineWidth')
	col.prop(VolumeVRayToon, 'opacity')
	if wide_ui:
		col= split.column()
	col.prop(VolumeVRayToon, 'normalThreshold')
	col.prop(VolumeVRayToon, 'overlapThreshold')
	col.prop(VolumeVRayToon, 'hideInnerEdges')
	col.prop(VolumeVRayToon, 'doSecondaryRays')
	col.prop(VolumeVRayToon, 'traceBias')

	# col.prop(VolumeVRayToon, 'lineColor_tex')
	# col.prop(VolumeVRayToon, 'lineWidth_tex')
	# col.prop(VolumeVRayToon, 'opacity_tex')
	# col.prop(VolumeVRayToon, 'distortion_tex')

	if not str(type(rna_pointer)) == "<class 'vb25.plugins.VRayMaterial'>": # Very ugly :(
		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(VolumeVRayToon, 'override_material')

		split= layout.split()
		col= split.column()
		col.prop(VolumeVRayToon, 'excludeType', text="")
		col.prop_search(VolumeVRayToon, 'excludeList_objects',
						context.scene,  'objects',
						text="Objects")
		col.prop_search(VolumeVRayToon, 'excludeList_groups',
						bpy.data,       'groups',
						text="Groups")

def draw_SphereFade(context, layout, rna_pointer):
	wide_ui= context.region.width > ui.narrowui

	SphereFade= rna_pointer.SphereFade

	split= layout.split()
	col= split.column()
	col.prop(SphereFade, 'empty_color')
	col.prop(SphereFade, 'affect_alpha')
	col.prop(SphereFade, 'falloff')
	col.prop(SphereFade, 'loc_only')

	#col= split.column()
	col.prop_search(SphereFade, 'gizmos_objects',
					context.scene,  'objects',
					text="Objects")
	col.prop_search(SphereFade, 'gizmos_groups',
					bpy.data,       'groups',
					text="Groups")


def gui(context, layout, VRayEffects):
	wide_ui= context.region.width > ui.narrowui

	split= layout.split()
	row= split.row()
	row.template_list("VRayListUse", "",
					  VRayEffects, 'effects',
					  VRayEffects, 'effects_selected',
					  rows= 3)
	col= row.column(align=True)
	col.operator('vray.effect_add',	   text="", icon="ZOOMIN")
	col.operator('vray.effect_remove', text="", icon="ZOOMOUT")

	if VRayEffects.effects_selected >= 0:
		layout.separator()

		effect= VRayEffects.effects[VRayEffects.effects_selected]

		split= layout.split()
		col= split.column()
		col.prop(effect, 'name')
		col.prop(effect, 'type')

		layout.separator()

		if effect.type == 'FOG':
			draw_EnvironmentFog(context, layout, effect)

		elif effect.type == 'TOON':
			draw_VolumeVRayToon(context, layout, rna_pointer)
		else:
			split= layout.split()
			col= split.column()
			col.label(text="Strange, but this effect type doesn\'t exist...")


# elif VRayMaterial.type == 'VOL':
# 	return {
# 		'color_tex':    (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(ma.diffuse_color)),           0, 'NONE'),
# 		'emission_tex': (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(EnvironmentFog.emission)),    0, 'NONE'),
# 		'density_tex':  (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple([EnvironmentFog.density]*3)), 0, 'NONE'),
# 	}

# elif VRayMaterial.type == 'VOL':
# 	bus['node']['volume']= {}
# 	for param in OBJECT_PARAMS['EnvironmentFog']:
# 		if param == 'color':
# 			value= ma.diffuse_color
# 		else:
# 			value= getattr(VRayMaterial.EnvironmentFog,param)
# 		object_params['volume'][param]= value
# 	for param in ('color_tex','emission_tex','density_tex'):
# 		if param in textures['mapto']:
# 			object_params['volume'][param]= textures['mapto'][param]
# 	return None


# if object_params['volume'] is not None:
# 	if ma_name not in types['volume'].keys():
# 		types['volume'][ma_name]= {}
# 		types['volume'][ma_name]['params']= object_params['volume']
# 		types['volume'][ma_name]['gizmos']= []
# 	if ob not in types['volume'][ma_name]:
# 		types['volume'][ma_name]['gizmos'].append(write_EnvFogMeshGizmo(files['nodes'], node_name, node_geometry, node_matrix))
# 	return

########NEW FILE########
__FILENAME__ = SettingsGI
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *


TYPE= 'SETTINGS'
ID=   'SettingsGI'

NAME= 'Global Illumination'
DESC= "Global illumination settings"

PARAMS= (
)


def add_properties(parent_struct):
	class SettingsGI(bpy.types.PropertyGroup):
		on= BoolProperty(
			name= "Enable GI",
			description= "Enable Global Illumination",
			default= False
		)

		# ray_distance_on
		ray_distance_on= BoolProperty(
			name= "Limit ray distance",
			description= "Limit ray distance",
			default= False
		)

		# ray_distance
		ray_distance= FloatProperty(
			name= "Distance",
			description= "Ray distance limit",
			min= 0.0,
			max= 1000000.0,
			soft_min= 0.0,
			soft_max= 1000000.0,
			precision= 1,
			default= 100000
		)

		# ao_on
		ao_on= BoolProperty(
			name= "AO",
			description= "",
			default= False
		)

		# ao_amount
		ao_amount= FloatProperty(
			name= "Amount",
			description= "",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 2.0,
			precision= 3,
			default= 1.0
		)

		# ao_radius
		ao_radius= FloatProperty(
			name= "Radius",
			description= "",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 1.0,
			precision= 3,
			default= 0.2
		)

		# ao_subdivs
		ao_subdivs= IntProperty(
			name= "Subdivs",
			description= "",
			min= 0,
			max= 100,
			soft_min= 0,
			soft_max= 10,
			default= 8
		)

		primary_engine= EnumProperty(
			name= "Primary engine",
			description= "Primary diffuse bounces engines",
			items= (
				('IM', "Irradiance map",      ""), # 0
				('BF', "Brute force",         ""), # 2
				('LC', "Light cache",         ""), # 3
				('SH', "Spherical harmonics", ""), # 4
			),
			default= 'IM'
		)

		secondary_engine= EnumProperty(
			name= "Secondary engine",
			description= "Secondary diffuse bounces engines",
			items= (
				('NONE', "None",        ""), # 0
				('BF',   "Brute force", ""), # 2
				('LC',   "Light cache", "")  # 3
			),
			default= 'LC'
		)

		primary_multiplier= FloatProperty(
			name= "Primary multiplier",
			description= "This value determines how much primary diffuse bounces contribute to the final image illumination",
			min= 0.0,
			max= 10.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= 1.0
		)

		secondary_multiplier= FloatProperty(
			name= "Secondary multiplier",
			description= "This determines the effect of secondary diffuse bounces on the scene illumination",
			min= 0.0,
			max= 10.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= 1.0
		)

		refract_caustics= BoolProperty(
			name= "Refract caustics",
			description= "This allows indirect lighting to pass through transparent objects (glass etc)",
			default= 1
		)

		reflect_caustics= BoolProperty(
			name= "Reflect caustics",
			description= "This allows indirect light to be reflected from specular objects (mirrors etc)",
			default= 0
		)

		saturation= FloatProperty(
			name= "Saturation",
			description= "Controls the saturation of the GI",
			min= 0.0,
			max= 10.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= 1.0
		)

		contrast= FloatProperty(
			name= "Contrast",
			description= "This parameter works together with Contrast base to boost the contrast of the GI solution",
			min= 0.0,
			max= 10.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= 1.0
		)

		contrast_base= FloatProperty(
			name= "Contrast base",
			description= "This parameter determines the base for the contrast boost",
			min= 0.0,
			max= 10.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= 0.5
		)

		spherical_harmonics= EnumProperty(
			name= "Spherical harmonics",
			description= "Bake or render spherical harmonics",
			items= (
				('BAKE',   "Bake",   ""),
				('RENDER', "Render", ""),
			),
			default= 'BAKE'
		)
	bpy.utils.register_class(SettingsGI)

	parent_struct.SettingsGI= PointerProperty(
		type= SettingsGI,
		name= NAME,
		description= DESC
	)


	class SphericalHarmonicsRenderer(bpy.types.PropertyGroup):
		file_name= StringProperty(
			name= "File",
			description= "This is the name of the *.vrsh file which contains the precomputed SH for this scene",
			subtype= 'FILE_PATH',
			default= "//lightmaps/harmonics.vrsh"
		)

		# precalc_light_per_frame
		precalc_light_per_frame= BoolProperty(
			name= "Precalc light per frame",
			description= "Reasonable when rendering animations. Depending on this option V-Ray calculates the lighting either once at the beginning of the rendering or precalculates it before every frame",
			default= True
		)

		# sample_environment
		sample_environment= BoolProperty(
			name= "Sample environment",
			description= "Turns on the environment sampling to add environment light contribution",
			default= True
		)

		# is_hemispherical
		is_hemispherical= BoolProperty(
			name= "Upper hemisphere only",
			description= "Depending on this option V-Ray samples either the whole sphere or only the upper hemisphere of the environment",
			default= True
		)

		# subdivs
		subdivs= IntProperty(
			name= "Subdivs",
			description= "The square of this parameter is proportional to the number of rays, sampled in the environment",
			min= 1,
			max= 1024,
			soft_min= 1,
			soft_max= 100,
			default= 30
		)

		# apply_filtering
		apply_filtering= BoolProperty(
			name= "Apply filtering",
			description= "Turns on the filtering of the spherical harmonics. This is useful to reduce the ringing artifacts (known as Gibbs phenomena in signal processing) by suppressing the high frequencies. This produces blurred SH which result in a smoother image",
			default= True
		)

		# filter_strength
		filter_strength= FloatProperty(
			name= "Filter strength",
			description= "The strength of high frequencies' suppression. Values near 0.0 slightly change the image while values near 1.0 smooth it a lot",
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			precision= 3,
			default= 0.5
		)
	bpy.utils.register_class(SphericalHarmonicsRenderer)

	SettingsGI.SphericalHarmonicsRenderer= PointerProperty(
		name= "Spherical Harmonics Renderer",
		type=  SphericalHarmonicsRenderer,
		description= "Spherical Harmonics Renderer settings"
	)



	class SphericalHarmonicsExporter(bpy.types.PropertyGroup):
		mode= EnumProperty(
			name= "Mode",
			description= "Allows you to select between four different modes of operation",
			items= (
				('OCC_SEL', "Occlusion (selected)",       ""),
				('OCC_ALL', "Occlusion",                  ""),
				('INT_SEL', "Interreflection (selected)", ""),
				('INT_ALL', "Interreflection",            ""),
			),
			default= 'OCC_ALL'
		)

		# bands
		bands= IntProperty(
			name= "Bands",
			description= "",
			min= 0,
			max= 100,
			soft_min= 0,
			soft_max= 10,
			default= 4
		)

		# subdivs
		subdivs= IntProperty(
			name= "Subdivs",
			description= "Controls the number of samples taken in order to create the spherical harmonics. Higher values produce better results but take longer to render",
			min= 1,
			max= 1024,
			soft_min= 1,
			soft_max= 100,
			default= 50
		)

		# bounces
		bounces= IntProperty(
			name= "Bounces",
			description= "This option is only available when one of the interreflection methods is selected. It controls the number of secondary bounces that are going to be traced",
			min= 1,
			max= 100,
			soft_min= 1,
			soft_max= 10,
			default= 1
		)

		# ray_bias
		ray_bias= FloatProperty(
			name= "Ray bias",
			description= "",
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 0.1,
			precision= 4,
			default= 0.0001
		)

		# file_name
		file_name= StringProperty(
			name= "File",
			subtype= 'FILE_PATH',
			description= "",
			default= "//lightmaps/harmonics.vrsh"
		)

		# file_format
		file_format= EnumProperty(
			name= "Format",
			description= "This is the output file format. It could be *.xml for general purposes, V-Ray internal format *.vrsh designed to be used in \"Spherical Harmoics\" GI engine or both of them",
			items= (
				('XML',  "*.xml",  ""),
				('VRSH', "*.vrsh", ""),
			),
			default= 'VRSH'
		)

		# per_normal
		per_normal= EnumProperty(
			name= "Distribute",
			description= "Spherical harmonics can be created either for each vertex of the geometry or for each normal, this option allows you to choose between those two modes. For round objects it is better to use per Vertex mode while for objects with large flat surfaces the per Normal mode is better and faster",
			items= (
				('NORMAL', "Per normal", ""),
				('VERTEX', "Per vertex", ""),
			),
			default= 'NORMAL'
		)

		# hit_recording
		hit_recording= BoolProperty(
			name= "Use hit recording",
			description= "Enabling it speeds up the calculations by storing a lot of information in the RAM",
			default= False
		)

		# object_space
		object_space= EnumProperty(
			name= "Transform",
			description= "",
			items= (
				('WORLD',  "World Space",  ""),
				('OBJECT', "Object Space", ""),
			),
			default= 'WORLD'
		)

		# node
		node= StringProperty(
			name= "Node",
			description= "Node to bake",
			default= ""
		)
	bpy.utils.register_class(SphericalHarmonicsExporter)

	SettingsGI.SphericalHarmonicsExporter= PointerProperty(
		name= "Spherical Harmonics Exporter",
		type=  SphericalHarmonicsExporter,
		description= "Spherical Harmonics Exporter settings"
	)



	class SettingsDMCGI(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(SettingsDMCGI)

	SettingsGI.SettingsDMCGI= PointerProperty(
		name= "DMC GI",
		type=  SettingsDMCGI,
		description= "DMC GI settings"
	)

	SettingsDMCGI.depth= IntProperty(
		name= "Secondary bounces",
		description= "The number of light bounces that will be computed",
		min= 1,
		max= 100,
		default= 3
	)

	SettingsDMCGI.subdivs= IntProperty(
		name= "Subdivs",
		description= "The number of samples used to approximate GI",
		min= 1,
		max= 500,
		default= 8
	)


	class SettingsIrradianceMap(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(SettingsIrradianceMap)

	SettingsGI.SettingsIrradianceMap= PointerProperty(
		name= "Irradiance Map",
		type=  SettingsIrradianceMap,
		description= "Irradiance Map settings"
	)

	SettingsIrradianceMap.preset= EnumProperty(
		name= "Preset",
		description= "Build-in presets",
		items= (
			('VLOW',"Very low",""),
			('LOW',"Low",""),
			('MEDIUM',"Medium",""),
			('MEDIUM_ANIM',"Medium animation",""),
			('HIGH',"High",""),
			('HIGH_ANIM',"High animation",""),
			('VHIGH',"Very high","")
		),
		default= "HIGH"
	)

	SettingsIrradianceMap.mode= EnumProperty(
		name= "Irradiance map mode",
		description= "Irradiance map mode",
		items= (
			('SINGLE',"Single frame","A new irradiance map is created for each frame."),
			('INC',"Multiframe incremental","At the start of the rendering, the irradiance map is deleted, and then each frame incrementally adds to the irradiance map in memory."),
			('FILE',"From file","The irradiance map is loaded from a file."),
			('ADD',"Add to current map","A new irradiance map is created and added to the one in memory."),
			('INC',"Incremental add to current map","Each frame adds incrementally to the irradiance map in memory; the old map is not deleted."),
			('BUCKET',"Bucket mode","Each render region (bucket) calculates its own irradiance map independently of the rest."),
			('ANIM_PRE',"Animation (prepass)","Separate irradiance map is rendered and saved with a different name for each frame; no final image is rendered."),
			('ANIM_REND',"Animation (rendering)","Final rendering of animation using saved per-frame irradiance maps.")
		),
		default= "SINGLE"
	)

	SettingsIrradianceMap.lookup_mode= EnumProperty(
		name= "Sample lookup",
		description= "Method of choosing suitable points from the irradiance map to be used as basis for the interpolation",
		items= (
			('QUAD',"Quad-balanced",""),
			('NEAREST',"Nearest",""),
			('OVERLAP',"Overlapping",""),
			('DENSITY',"Density-based","")
		),
		default= "OVERLAP"
	)

	SettingsIrradianceMap.interpolation_mode= EnumProperty(
		name= "Interpolation type",
		description= "Method for interpolating the GI value from the samples in the irradiance map",
		items= (
			('VORONOI',"Least squares with Voronoi weights",""),
			('DELONE',"Delone triangulation",""),
			('LEAST',"Least squares fit",""),
			('WEIGHTED',"Weighted average","")
		),
		default= "LEAST"
	)

	SettingsIrradianceMap.detail_scale= EnumProperty(
		name= "Detail enhancement scale",
		description= "Build-in presets",
		items= (
			('SCREEN', "Screen", "Radius in pixels."),
			('WORLD',  "World",  "Radius in Blender Units.")
		),
		default= 'WORLD'
	)

	SettingsIrradianceMap.min_rate= IntProperty(
		name= "Min rate",
		description= "This value determines the resolution for the first GI pass",
		min= -10,
		max= 1,
		default= -3
	)

	SettingsIrradianceMap.max_rate= IntProperty(
		name= "Max rate",
		description= "This value determines the resolution of the last GI pass",
		min= -10,
		max= 1,
		default= 0
	)

	SettingsIrradianceMap.color_threshold= FloatProperty(
		name= "Color threshold",
		description= "This parameter controls how sensitive the irradiance map algorithm is to changes in indirect lighting",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 0.30
	)

	SettingsIrradianceMap.normal_threshold= FloatProperty(
		name= "Normal threshold",
		description= "This parameter controls how sensitive the irradiance map is to changes in surface normals and small surface details",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 0.10
	)

	SettingsIrradianceMap.distance_threshold= FloatProperty(
		name= "Distance threshold",
		description= "This parameter controls how sensitive the irradiance map is to distance between surfaces",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 0.10
	)

	SettingsIrradianceMap.show_calc_phase= BoolProperty(
		name= "Show calc. phase",
		description= "Show irradiance map calculations",
		default= 1
	)

	SettingsIrradianceMap.show_direct_light= BoolProperty(
		name= "Show direct light",
		description= "Show direct light",
		default= 1
	)

	SettingsIrradianceMap.show_samples= BoolProperty(
		name= "Show samples",
		description= "Show irradiance map samples",
		default= 0
	)

	SettingsIrradianceMap.subdivs= IntProperty(
		name= "Hemispheric subdivs",
		description= "This controls the quality of individual GI samples",
		min= 1,
		max= 500,
		default= 50
	)

	SettingsIrradianceMap.interp_samples= IntProperty(
		name= "Interpolation samples",
		description= "The number of GI samples that will be used to interpolate the indirect illumination at a given point",
		min= 1,
		max= 100,
		default= 20
	)

	SettingsIrradianceMap.interp_frames= IntProperty(
		name= "Interpolation frames",
		description= "The number of frames that will be used to interpolate GI when the \"Mode\" is set to \"Animation (rendering)\"",
		min= 1,
		max= 50,
		default= 2
	)

	SettingsIrradianceMap.calc_interp_samples= IntProperty(
		name= "Calc. pass interpolation samples",
		description= "The number of already computed samples that will be used to guide the sampling algorithm",
		min= 1,
		max= 30,
		default= 10
	)

	SettingsIrradianceMap.detail_enhancement= BoolProperty(
		name= "Detail enhancement",
		description= "Detail enhancement is a method for bringing additional detail to the irradiance map in the case where there are small details in the image",
		default= 0
	)

	SettingsIrradianceMap.detail_subdivs_mult= FloatProperty(
		name= "Detail enhancement subdivs mult",
		description= "The number of samples taken for the high-precision sampling as a percentage of the irradiance map Hemispheric subdivs",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 0.30
	)

	SettingsIrradianceMap.detail_radius= FloatProperty(
		name= "Detail enhancement radius",
		description= "This determines the radius for the detail enhancement effect",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 0.2
	)

	SettingsIrradianceMap.multipass= BoolProperty(
		name= "Multipass",
		description= "When checked, this will cause V-Ray to use all irradiance map samples computed so far",
		default= 0
	)

	SettingsIrradianceMap.multiple_views= BoolProperty(
		name= "Use camera path",
		description= "When this option is on, V-Ray will calculate the irradiance map samples for the entire camera path, instead of just the current view",
		default= 0
	)

	SettingsIrradianceMap.randomize_samples= BoolProperty(
		name= "Randomize samples",
		description= "When it is checked, the image samples will be randomly jittered",
		default= 1
	)

	SettingsIrradianceMap.check_sample_visibility= BoolProperty(
		name= "Check sample visibility",
		description= "This will cause V-Ray to use only those samples from the irradiance map, which are directly visible from the interpolated point",
		default= 0
	)

	SettingsIrradianceMap.file= StringProperty(
		name= "Irradiance map file name",
		subtype= 'FILE_PATH',
		description= "Irradiance map file name",
		default= "//lightmaps/im.vrmap"
	)

	SettingsIrradianceMap.auto_save= BoolProperty(
		name= "Auto save irradiance map",
		description= "Automatically save the irradiance map to the specified file at the end of the rendering",
		default= 0
	)

	SettingsIrradianceMap.auto_save_file= StringProperty(
		name= "Irradiance map auto save file",
		subtype= 'FILE_PATH',
		description= "Irradiance map auto save file",
		default= "//lightmaps/im.vrmap"
	)


	class SettingsLightCache(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(SettingsLightCache)

	SettingsGI.SettingsLightCache= PointerProperty(
		name= "Light Cache",
		type=  SettingsLightCache,
		description= "Light Cache settings"
	)

	SettingsLightCache.mode= EnumProperty(
		name= "Light cache mode",
		description= "Light cache mode",
		items= (
			('SINGLE',"Single frame",""),
			('FILE',"From file",""),
			('FLY',"Fly-through",""),
			('PPT',"Progressive path tracing","")
		),
		default= 'SINGLE'
	)

	SettingsLightCache.subdivs= IntProperty(
		name= "Subdivs",
		description= "This determines how many paths are traced from the camera. The actual number of paths is the square of the subdivs",
		min= 1,
		max= 65535,
		default= 1000
	)

	SettingsLightCache.world_scale= EnumProperty(
		name= "Light cache scale mode",
		description= "This parameter determines the units of the \"Sample size\" and the \"Filter size\"",
		items= (
			('SCREEN',  "Screen", ""),
			('WORLD',   "World", ""),
		),
		default= 'SCREEN'
	)

	SettingsLightCache.sample_size= FloatProperty(
		name= "Sample size",
		description= "This determines the spacing of the samples in the light cache",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 4,
		default= 0.02
	)

	SettingsLightCache.num_passes= IntProperty(
		name= "Number of passes",
		description= "The light cache is computed in several passes, which are then combined into the final light cache",
		min= 1,
		max= 1000,
		default= 4
	)

	SettingsLightCache.num_passes_auto= BoolProperty(
		name= "Auto num. passes",
		description= "Set number of passes to threads number",
		default= 1
	)

	SettingsLightCache.retrace_enabled= BoolProperty(
		name= "Retrace",
		description= "Enable retrace of light cache",
		default= False
	)

	SettingsLightCache.retrace_threshold= FloatProperty(
		name= "Retrace treshold",
		description= "Retrace treshold, relative to the light cache sample size",
		min= 0.0,
		max= 10.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 1.0
	)

	SettingsLightCache.depth= IntProperty(
		name= "Depth",
		description= "Light cache depth",
		min= 1,
		max= 1000,
		soft_min= 1,
		soft_max= 100,
		default= 100
	)

	SettingsLightCache.show_calc_phase= BoolProperty(
		name= "Show calc phase",
		description= "Turning this option on will show the paths that are traced",
		default= 1
	)

	SettingsLightCache.store_direct_light= BoolProperty(
		name= "Store direct light",
		description= "With this option, the light cache will also store and interpolate direct light",
		default= 1
	)

	SettingsLightCache.adaptive_sampling= BoolProperty(
		name= "Adaptive sampling",
		description= "When this option is on, V-Ray will store additional information about the incoming light for each light cache sample, and try to put more samples into the directions from which more light coming",
		default= 0
	)

	SettingsLightCache.filter= BoolProperty(
		name= "Filter",
		description= "Enable render-time filter for the light cache",
		default= 1
	)

	SettingsLightCache.filter_type= EnumProperty(
		name= "Filter type",
		description= "The filter determines how irradiance is interpolated from the samples in the light cache",
		items= (
			('NONE',    "None",    ""),
			('NEAREST', "Nearest", ""),
			('FIXED',   "Fixed",   "")
		),
		default= "NEAREST"
	)

	SettingsLightCache.filter_samples= IntProperty(
		name= "Samples",
		description= "How many of the nearest samples to look up from the light cache",
		min= 1,
		max= 1000,
		default= 10
	)

	SettingsLightCache.filter_size= FloatProperty(
		name= "Size",
		description= "The size of the filter",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 0.02
	)

	SettingsLightCache.prefilter= BoolProperty(
		name= "Pre-filter",
		description= "Filter light cache sampler before rendering",
		default= 0
	)

	SettingsLightCache.prefilter_samples= IntProperty(
		name= "Samples",
		description= "Number of samples",
		min= 1,
		max= 1000,
		default= 40
	)

	SettingsLightCache.multiple_views= BoolProperty(
		name= "Use camera path",
		description= "When this option is on, V-Ray will calculate the light cache samples for the entire camera path, instead of just the current view, in the same way as this is done for the Fly-through mode",
		default= 0
	)

	SettingsLightCache.use_for_glossy_rays= BoolProperty(
		name= "Use for glossy rays",
		description= "If this option is on, the light cache will be used to compute lighting for glossy rays as well, in addition to normal GI rays",
		default= 0
	)

	SettingsLightCache.file= StringProperty(
		name= "Light cache file name",
		subtype= 'FILE_PATH',
		description= "Light cache file name",
		default= "//lightmaps/lc.vrmap"
	)

	SettingsLightCache.auto_save= BoolProperty(
		name= "Auto save light cache",
		description= "Light cache file name",
		default= 0
	)

	SettingsLightCache.auto_save_file= StringProperty(
		name= "Light cache auto save file",
		subtype= 'FILE_PATH',
		description= "Light cache auto save file",
		default= "//lightmaps/lc.vrmap"
	)


	class SettingsPhotonMap(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(SettingsPhotonMap)

	SettingsGI.SettingsPhotonMap= PointerProperty(
		name= "Photon Map",
		type=  SettingsPhotonMap,
		description= "Photon Map settings"
	)

	SettingsPhotonMap.convex_hull_estimate= BoolProperty(
		name= "Convex hull estimate",
		description= "TODO",
		default= 0
	)

	SettingsPhotonMap.prefilter= BoolProperty(
		name= "Convert to irradiance map",
		description= "This will cause V-Ray to precompute the irradiance at the photon hit points stored in the photon map",
		default= 0
	)

	SettingsPhotonMap.prefilter_samples= IntProperty(
		name= "Interpolate samples",
		description= "This controls how many irradiance samples will be taken from the photon map once it is converted to an irradiance map",
		min= 1,
		max= 100,
		default= 10
	)

	SettingsPhotonMap.store_direct_light= BoolProperty(
		name= "Store direct light",
		description= "Store direct illumination in the photon map as well",
		default= 1
	)

	SettingsPhotonMap.auto_search_distance= BoolProperty(
		name= "Auto search distance",
		description= "Try to compute a suitable distance within which to search for photons",
		default= 1
	)

	SettingsPhotonMap.search_distance= FloatProperty(
		name= "Search distance",
		description= "Photon search distance",
		min= 0.0,
		max= 1000.0,
		soft_min= 0.0,
		soft_max= 100.0,
		default= 20.0
	)

	SettingsPhotonMap.retrace_corners= FloatProperty(
		name= "Retrace corners",
		description= "When this is greater than 0.0, V-Ray will use brute force GI near corners, instead of the photon map, in order to obtain a more accurate result and to avoid splotches in these areas. ",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 0.0
	)

	SettingsPhotonMap.retrace_bounces= IntProperty(
		name= "Retrace bounces",
		description= "Controls how many bounces will be made when retracing corners",
		min= 1,
		max= 100,
		default= 10
	)

	SettingsPhotonMap.bounces= IntProperty(
		name= "Bounces",
		description= "The number of light bounces approximated by the photon map",
		min= 1,
		max= 1000,
		default= 10
	)

	SettingsPhotonMap.multiplier= FloatProperty(
		name= "Multiplier",
		description= "This allows you to control the brightness of the photon map",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		default= 1.0
	)

	SettingsPhotonMap.max_photons= IntProperty(
		name= "Max photons",
		description= "This option specifies how many photons will be taken into consideration when approximating the irradiance at the shaded point",
		min= 1,
		max= 10000,
		default= 30
	)

	SettingsPhotonMap.max_density= FloatProperty(
		name= "Max density",
		description= "This parameter allows you to limit the resolution (and thus the memory) of the photon map",
		min= 0.0,
		max= 1000.0,
		soft_min= 0.0,
		soft_max= 100.0,
		default= 0.0
	)


def write(bus):
	ofile=  bus['files']['scene']
	scene=  bus['scene']

	VRayScene=             scene.vray
	VRayExporter=          VRayScene.exporter
	SettingsDMCSampler=    VRayScene.SettingsDMCSampler
	SettingsGI=            VRayScene.SettingsGI
	SettingsIrradianceMap= SettingsGI.SettingsIrradianceMap
	SettingsLightCache=    SettingsGI.SettingsLightCache
	SettingsDMCGI=         SettingsGI.SettingsDMCGI

	PRIMARY_ENGINE= {
		'IM':  0,
		'PM':  1,
		'BF':  2,
		'LC':  3,
		'SH':  4,
	}

	SECONDARY_ENGINE= {
		'NONE':  0,
		'PM':    1,
		'BF':    2,
		'LC':    3,
	}

	WORLD_SCALE= {
		'SCREEN':  0,
		'WORLD':   1
	}
	
	IM_MODE= {
		'SINGLE':	 0,
		'INC':		 1,
		'FILE':		 2,
		'ADD':		 3,
		'ADD_INC':	 4,
		'BUCKET':	 5,
		'ANIM_PRE':	 6,
		'ANIM_REND': 7,
	}

	INTERPOLATION_MODE= {
		'VORONOI':	 0,
		'LEAST':	 1,
		'DELONE':	 2,
		'WEIGHTED':	 3,
	}

	LOOKUP_MODE= {
		'QUAD':		0,
		'NEAREST':	1,
		'OVERLAP':	2,
		'DENSITY':	3,
	}

	FILTER_TYPE= {
		'NONE':	   0,
		'NEAREST': 1,
		'FIXED':   2,
	}

	LC_MODE= {
		'SINGLE':  0,
		'FLY':	   1,
		'FILE':	   2,
		'PPT':	   3,
	}

	if SettingsGI.on:
		if SettingsGI.primary_engine == 'SH' and SettingsGI.spherical_harmonics == 'BAKE':
			SH_MODE= {
				'OCC_SEL': 0,
				'OCC_ALL': 1,
				'INT_SEL': 2,
				'INT_ALL': 3,
			}
			FILE_FORMAT= {
				'XML': "xml",
				'VRSH': "vrsh",
			}

			SphericalHarmonicsExporter= SettingsGI.SphericalHarmonicsExporter

			ofile.write("\nSphericalHarmonicsExporter SphericalHarmonicsExporter {")
			ofile.write("\n\tmode= %i;" % SH_MODE[SphericalHarmonicsExporter.mode])
			ofile.write("\n\tbands= %s;" % p(SphericalHarmonicsExporter.bands))
			ofile.write("\n\tsubdivs= %s;" % p(SphericalHarmonicsExporter.subdivs))
			ofile.write("\n\tbounces= %s;" % p(SphericalHarmonicsExporter.bounces))
			ofile.write("\n\tray_bias= %s;" % p(SphericalHarmonicsExporter.ray_bias))
			ofile.write("\n\tfile_name= \"%s\";" % create_dir_from_filepath(bpy.path.abspath(SphericalHarmonicsExporter.file_name)))
			ofile.write("\n\tfile_format= \"%s\";" % FILE_FORMAT[SphericalHarmonicsExporter.file_format])
			ofile.write("\n\tper_normal= %s;" % p(SphericalHarmonicsExporter.per_normal))
			ofile.write("\n\thit_recording= %s;" % p(SphericalHarmonicsExporter.hit_recording))
			ofile.write("\n\tobject_space= %s;" % p(SphericalHarmonicsExporter.object_space))
			if SphericalHarmonicsExporter.node:
				node= get_data_by_name(scene, 'objects', SphericalHarmonicsExporter.node)
				if node:
					ofile.write("\n\tnode= %s;" % get_name(node, prefix='OB'))
			ofile.write("\n}\n")

		else:
			lc_auto_save_path = get_path(SettingsLightCache.auto_save_file)
			if SettingsLightCache.auto_save:
				create_dir_from_filepath(lc_auto_save_path)

			im_auto_save_path = get_path(SettingsIrradianceMap.auto_save_file)
			if SettingsIrradianceMap.auto_save:
				create_dir_from_filepath(im_auto_save_path)

			ofile.write("\nSettingsGI SettingsGI {")
			ofile.write("\n\ton= 1;")
			ofile.write("\n\tprimary_engine= %s;" % PRIMARY_ENGINE[SettingsGI.primary_engine])
			ofile.write("\n\tsecondary_engine= %s;" % SECONDARY_ENGINE[SettingsGI.secondary_engine])
			ofile.write("\n\tprimary_multiplier= %.3f;" % SettingsGI.primary_multiplier)
			ofile.write("\n\tsecondary_multiplier= %.3f;" % SettingsGI.secondary_multiplier)
			ofile.write("\n\treflect_caustics= %i;" % SettingsGI.reflect_caustics)
			ofile.write("\n\trefract_caustics= %i;" % SettingsGI.refract_caustics)
			ofile.write("\n\tsaturation= %.3f;" % SettingsGI.saturation)
			ofile.write("\n\tcontrast= %.3f;" % SettingsGI.contrast)
			ofile.write("\n\tcontrast_base= %.3f;" % SettingsGI.contrast_base)
			ofile.write("\n\tray_distance_on= %s;" % p(SettingsGI.ray_distance_on))
			ofile.write("\n\tray_distance= %s;" % p(SettingsGI.ray_distance))
			ofile.write("\n\tao_on= %s;" % p(SettingsGI.ao_on))
			ofile.write("\n\tao_amount= %s;" % p(SettingsGI.ao_amount))
			ofile.write("\n\tao_radius= %s;" % p(SettingsGI.ao_radius))
			ofile.write("\n\tao_subdivs= %s;" % p(SettingsGI.ao_subdivs))
			ofile.write("\n}\n")

			ofile.write("\nSettingsIrradianceMap SettingsIrradianceMap {")
			ofile.write("\n\tmin_rate= %i;" % SettingsIrradianceMap.min_rate)
			ofile.write("\n\tmax_rate= %i;" % SettingsIrradianceMap.max_rate)
			ofile.write("\n\tsubdivs= %i;" % SettingsIrradianceMap.subdivs)
			ofile.write("\n\tinterp_samples= %i;" % SettingsIrradianceMap.interp_samples)
			ofile.write("\n\tinterp_frames= %i;" % SettingsIrradianceMap.interp_frames)
			ofile.write("\n\tcalc_interp_samples= %i;" % SettingsIrradianceMap.calc_interp_samples)
			ofile.write("\n\tcolor_threshold= %.6f;" % SettingsIrradianceMap.color_threshold)
			ofile.write("\n\tnormal_threshold= %.6f;" % SettingsIrradianceMap.normal_threshold)
			ofile.write("\n\tdistance_threshold= %.6f;" % SettingsIrradianceMap.distance_threshold)
			ofile.write("\n\tdetail_enhancement= %i;" % SettingsIrradianceMap.detail_enhancement)
			ofile.write("\n\tdetail_radius= %.6f;" % SettingsIrradianceMap.detail_radius)
			ofile.write("\n\tdetail_subdivs_mult= %.6f;" % SettingsIrradianceMap.detail_subdivs_mult)
			ofile.write("\n\tdetail_scale= %i;" % WORLD_SCALE[SettingsIrradianceMap.detail_scale])
			ofile.write("\n\tinterpolation_mode= %i;" % INTERPOLATION_MODE[SettingsIrradianceMap.interpolation_mode])
			ofile.write("\n\tlookup_mode= %i;" % LOOKUP_MODE[SettingsIrradianceMap.lookup_mode])
			ofile.write("\n\tshow_calc_phase= %i;" % SettingsIrradianceMap.show_calc_phase)
			ofile.write("\n\tshow_direct_light= %i;" % SettingsIrradianceMap.show_direct_light)
			ofile.write("\n\tshow_samples= %i;" % SettingsIrradianceMap.show_samples)
			ofile.write("\n\tmultipass= %i;" % SettingsIrradianceMap.multipass)
			ofile.write("\n\tcheck_sample_visibility= %i;" % SettingsIrradianceMap.check_sample_visibility)
			ofile.write("\n\trandomize_samples= %i;" % SettingsIrradianceMap.randomize_samples)
			ofile.write("\n\tmode= %d;" % IM_MODE[SettingsIrradianceMap.mode])
			ofile.write("\n\tauto_save= %d;" % SettingsIrradianceMap.auto_save)
			ofile.write("\n\tauto_save_file= \"%s\";" % im_auto_save_path)
			ofile.write("\n\tfile= \"%s\";" % get_full_filepath(bus, None, SettingsIrradianceMap.file))
			ofile.write("\n\tmultiple_views= %d;" % SettingsIrradianceMap.multiple_views)
			ofile.write("\n\tdont_delete= false;")
			ofile.write("\n}\n")

			ofile.write("\nSettingsDMCGI SettingsDMCGI {")
			ofile.write("\n\tsubdivs= %i;" % SettingsDMCGI.subdivs)
			ofile.write("\n\tdepth= %i;" % SettingsDMCGI.depth)
			ofile.write("\n}\n")

			ofile.write("\nSettingsLightCache SettingsLightCache {")
			if VRayExporter.draft:
				ofile.write("\n\tsubdivs= %.0f;" % (SettingsLightCache.subdivs * 0.2))
			else:
				ofile.write("\n\tsubdivs= %.0f;" % (SettingsLightCache.subdivs * SettingsDMCSampler.subdivs_mult))
			ofile.write("\n\tsample_size= %.6f;" % SettingsLightCache.sample_size)
			ofile.write("\n\tnum_passes= %i;"% (scene.render.threads if SettingsLightCache.num_passes_auto else SettingsLightCache.num_passes))
			ofile.write("\n\tdepth= %i;" % SettingsLightCache.depth)
			ofile.write("\n\tfilter_type= %i;" % (FILTER_TYPE[SettingsLightCache.filter_type] if SettingsLightCache.filter else 0))
			ofile.write("\n\tfilter_samples= %i;" % (SettingsLightCache.filter_samples if SettingsLightCache.filter else 1))
			ofile.write("\n\tfilter_size= %.6f;" % SettingsLightCache.filter_size)
			ofile.write("\n\tprefilter= %i;" % SettingsLightCache.prefilter)
			ofile.write("\n\tprefilter_samples= %i;" % SettingsLightCache.prefilter_samples)
			ofile.write("\n\tshow_calc_phase= %i;" % SettingsLightCache.show_calc_phase)
			ofile.write("\n\tstore_direct_light= %i;" % SettingsLightCache.store_direct_light)
			ofile.write("\n\tuse_for_glossy_rays= %i;" % SettingsLightCache.use_for_glossy_rays)
			ofile.write("\n\tworld_scale= %i;" % WORLD_SCALE[SettingsLightCache.world_scale])
			ofile.write("\n\tadaptive_sampling= %i;" % SettingsLightCache.adaptive_sampling)
			ofile.write("\n\tmode= %d;" % LC_MODE[SettingsLightCache.mode])
			ofile.write("\n\tauto_save= %d;" % SettingsLightCache.auto_save)
			ofile.write("\n\tauto_save_file= \"%s\";" % lc_auto_save_path)
			ofile.write("\n\tfile= \"%s\";" % get_full_filepath(bus, None, SettingsLightCache.file))
			ofile.write("\n\tdont_delete= false;")
			ofile.write("\n\tmultiple_views= %d;" % SettingsLightCache.multiple_views)
			ofile.write("\n\tretrace_enabled= %d;" % SettingsLightCache.retrace_enabled)
			ofile.write("\n\tretrace_threshold= %.3f;" % SettingsLightCache.retrace_threshold)			
			ofile.write("\n}\n")

########NEW FILE########
__FILENAME__ = SettingsImageSampler
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'SETTINGS'
ID=   'SettingsImageSampler'

NAME= 'Image sampler'
DESC= "Image sampler options"

PARAMS= (
	'type',
	'fixed_subdivs',
	'dmc_minSubdivs',
	'dmc_maxSubdivs',
	'dmc_threshold',
	'dmc_show_samples',
	'subdivision_minRate',
	'subdivision_maxRate',
	'subdivision_threshold',
	'subdivision_edges',
	'subdivision_normals',
	'subdivision_normals_threshold',
	'subdivision_jitter',
	'subdivision_show_samples',
	'progressive_minSubdivs',
	'progressive_maxSubdivs',
	'progressive_threshold',
	'progressive_maxTime',
	'progressive_bundleSize',
	'progressive_showMask',
)


def add_properties(rna_pointer):
	class SettingsImageSampler(bpy.types.PropertyGroup):
			progressive_minSubdivs = bpy.props.IntProperty(
				name = "Min Subdivs",
				description = "Min. subdivs value for the progressive image sampler",
				min = 0,
				default = 1
			)

			progressive_maxSubdivs = bpy.props.IntProperty(
				name = "Max Subdivs",
				description = "Max. subdivs value for the progressive image sampler",
				min = 0,
				default = 100
			)

			progressive_threshold = bpy.props.FloatProperty(
				name = "Threshold",
				description = "Noise threshold for the progressive image sampler",
				min = 0.0,
				max = 1.0,
				soft_min = 0.0,
				soft_max = 1.0,
				default = 0.01
			)

			progressive_maxTime = bpy.props.FloatProperty(
				name = "Max Time",
				description = "Max. render time for the progressive image sampler",
				min = 0.0,
				max = 1024.0,
				default = 0.0
			)

			progressive_bundleSize = bpy.props.IntProperty(
				name = "Bundle Size",
				description = "The maximum number of samples for a pixel",
				min = 1,
				max = 1024,
				default = 32
			)

			progressive_showMask = bpy.props.BoolProperty(
				name = "Show Mask",
				description  = "Show AA mask",
				default = 0
			)

	bpy.utils.register_class(SettingsImageSampler)

	rna_pointer.SettingsImageSampler= PointerProperty(
		name= "Image Sampler",
		type=  SettingsImageSampler,
		description= "Image Sampler settings"
	)

	SettingsImageSampler.filter_type= EnumProperty(
		name= "Filter type",
		description= "Antialiasing filter",
		items= (
			('NONE',"None",""),
			('GAUSS',"Gaussian",""),
			('SINC',"Sinc",""),
			('CATMULL',"CatmullRom",""),
			('LANC',"Lanczos",""),
			('TRIANGLE',"Triangle",""),
			('BOX',"Box",""),
			('AREA',"Area","")
		),
		default= "NONE"
	)

	SettingsImageSampler.filter_size= FloatProperty(
		name= "Filter size",
		description= "Filter size",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		default= 1.5
	)

	SettingsImageSampler.type= EnumProperty(
		name= "Type",
		description= "Image sampler type",
		items= (
			('FXD',"Fixed",""),
			('DMC',"Adaptive DMC",""),
			('SBD',"Adaptive subdivision",""),
			('PRG',"Progressive",""),
		),
		default= "DMC"
	)

	SettingsImageSampler.dmc_minSubdivs= IntProperty(
		name= "Min subdivs",
		description= "The initial (minimum) number of samples taken for each pixel",
		min= 1,
		max= 100,
		default= 1
	)

	SettingsImageSampler.dmc_maxSubdivs= IntProperty(
		name= "Max subdivs",
		description= "The maximum number of samples for a pixel",
		min= 1,
		max= 100,
		default= 4
	)

	SettingsImageSampler.dmc_treshhold_use_dmc= BoolProperty(
		name= "Use DMC sampler threshold",
		description= "Use threshold specified in the \"DMC sampler\"",
		default= 1
	)

	SettingsImageSampler.dmc_threshold= FloatProperty(
		name= "Color threshold",
		description= "The threshold that will be used to determine if a pixel needs more samples",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 0.01
	)

	SettingsImageSampler.dmc_show_samples= BoolProperty(
		name= "Show samples",
		description= "Show an image where the pixel brightness is directly proportional to the number of samples taken at this pixel",
		default= 0
	)

	SettingsImageSampler.fixed_subdivs= IntProperty(
		name= "Subdivs",
		description= "The number of samples per pixel",
		min= 1,
		max= 100,
		default= 1
	)

	SettingsImageSampler.subdivision_show_samples= BoolProperty(
		name= "Show samples",
		description= "Show an image where the pixel brightness is directly proportional to the number of samples taken at this pixel",
		default= 0
	)

	SettingsImageSampler.subdivision_normals= BoolProperty(
		name= "Normals",
		description= "This will supersample areas with sharply varying normals",
		default= 0
	)

	SettingsImageSampler.subdivision_normals_threshold= FloatProperty(
		name= "Normals threshold",
		description= "Normals threshold",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 0.05
	)

	SettingsImageSampler.subdivision_jitter= BoolProperty(
		name= "Randomize samples",
		description= "Displaces the samples slightly to produce better antialiasing of nearly horizontal or vertical lines",
		default= 1
	)

	SettingsImageSampler.subdivision_threshold= FloatProperty(
		name= "Color threshold",
		description= "Determines the sensitivity of the sampler to changes in pixel intensity",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 0.1
	)

	SettingsImageSampler.subdivision_edges= BoolProperty(
		name= "Object outline",
		description= "This will cause the image sampler to always supersample object edges",
		default= 0
	)

	SettingsImageSampler.subdivision_minRate= IntProperty(
		name= "Min rate",
		description= "Minimum number of samples per pixel",
		min= -10,
		max= 50,
		default= -1
	)

	SettingsImageSampler.subdivision_maxRate= IntProperty(
		name= "Max rate",
		description= "Maximum number of samples per pixel",
		min= -10,
		max= 50,
		default= 2
	)


def write(bus):
	FILTER_TYPE= {
		'AREA'     : "\nFilterArea aaFilter {",
		'BOX'      : "\nFilterBox aaFilter {",
		'TRIANGLE' : "\nFilterTriangle aaFilter {",
		'LANC'     : "\nFilterLanczos aaFilter {",
		'SINC'     : "\nFilterSincv aaFilter {",
		'GAUSS'    : "\nFilterGaussian aaFilter {",
		'CATMULL'  : "\nFilterCatmullRom aaFilter {"
	}

	TYPE= {
		'FXD': 0,
		'DMC': 1,
		'SBD': 2,
		'PRG': 3,
	}

	ofile= bus['files']['scene']
	scene= bus['scene']

	VRayScene= scene.vray
	SettingsImageSampler=       VRayScene.SettingsImageSampler
	SettingsImageSamplerFilter= VRayScene.SettingsImageSampler
	SettingsDMCSampler=         VRayScene.SettingsDMCSampler

	ofile.write("\n%s %s {" % (ID, ID))
	for param in PARAMS:
		if param == 'type':
			value= TYPE[SettingsImageSampler.type]
		elif param == 'dmc_threshold':
			if SettingsImageSampler.dmc_treshhold_use_dmc:
				value = SettingsDMCSampler.adaptive_threshold
			else:
				value = SettingsImageSampler.dmc_threshold
			if VRayScene.exporter.draft:
				value *= 4
		else:
			value= getattr(SettingsImageSampler, param)
		ofile.write("\n\t%s= %s;" % (param, p(value)))
	ofile.write("\n}\n")

	if SettingsImageSamplerFilter.filter_type != 'NONE':
		ofile.write(FILTER_TYPE[SettingsImageSamplerFilter.filter_type])
		if SettingsImageSamplerFilter.filter_type not in {'CATMULL'}:
			ofile.write("\n\tsize= %.3f;" % SettingsImageSamplerFilter.filter_size)
		ofile.write("\n}\n")

########NEW FILE########
__FILENAME__ = SettingsMotionBlur
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''

''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE = 'CAMERA'
ID   = 'SettingsMotionBlur'

NAME = 'Motion Blur'
DESC = "V-Ray SettingsMotionBlur settings."

PARAMS = (
	'on',
	'geom_samples',
	'low_samples',
	'duration',
	'subdivs',
	'bias',
	'shutter_efficiency',
	'interval_center',
	'camera_motion_blur',
)


def add_properties(rna_pointer):
	class SettingsMotionBlur(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(SettingsMotionBlur)

	rna_pointer.SettingsMotionBlur= PointerProperty(
		name= "SettingsMotionBlur",
		type=  SettingsMotionBlur,
		description= "Camera's Motion Blur settings"
	)

	SettingsMotionBlur.on= BoolProperty(
		name="Motion blur",
		description="Turns motion blur on",
		default= False
	)

	SettingsMotionBlur.interval_center= FloatProperty(
		name="Interval center",
		description="Specifies the middle of the motion blur interval with respect to the frame",
		min=0.0, max=1.0,
		soft_min=0.0, soft_max=1.0,
		default=0.5
	)

	SettingsMotionBlur.duration= FloatProperty(
		name="Duration",
		description="Specifies the duration, in frames, during which the camera shutter is open",
		min=1.0, max=100.0,
		soft_min=1.0, soft_max=10.0,
		default=2.0
	)

	SettingsMotionBlur.bias= FloatProperty(
		name="Bias",
		description="This controls the bias of the motion blur effect",
		min=0.0, max=1.0,
		soft_min=0.0, soft_max=1.0,
		default=0.0
	)

	SettingsMotionBlur.shutter_efficiency= FloatProperty(
		name="Shutter Efficiency",
		description="Shutter efficiency",
		min=0.0, max=10.0,
		soft_min=0.0, soft_max=1.0,
		default=1.0
	)

	SettingsMotionBlur.subdivs= IntProperty(
		name="Subdivs",
		description="Determines the quality of the motion blur",
		min=1, max=100,
		default=6
	)

	SettingsMotionBlur.geom_samples= IntProperty(
		name="Geometry Samples",
		description="This determines the number of geometry segments used to approximate motion blur",
		min=1, max=100,
		default=2
	)

	SettingsMotionBlur.low_samples= IntProperty(
		name="Prepass Samples",
		description="This controls how many samples in time will be computed during irradiance map calculations",
		min=1, max=100,
		default=1
	)

	SettingsMotionBlur.camera_motion_blur= BoolProperty(
		name="Camera Motion Blur",
		description="Use camera motion blur",
		default=True
	)


def write(bus):
	ofile  = bus['files']['scene']
	scene  = bus['scene']
	camera = bus['camera']

	VRayCamera         = camera.data.vray
	SettingsMotionBlur = VRayCamera.SettingsMotionBlur

	if SettingsMotionBlur.on:
		ofile.write("\n%s %s {" % (ID,ID))
		for param in PARAMS:
			value = getattr(SettingsMotionBlur, param)
			ofile.write("\n\t%s= %s;"%(param, p(value)))
		ofile.write("\n}\n")

########NEW FILE########
__FILENAME__ = SettingsOptions
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'SETTINGS'

ID=   'SettingsOptions'

NAME= 'Render Options'
DESC= "Render options"

PARAMS= (
	'geom_displacement',
	'geom_doHidden',
	'geom_backfaceCull',
	'ray_bias',
	'gi_dontRenderImage',
	'light_doLights',
	'light_doDefaultLights',
	'light_doHiddenLights',
	'light_doShadows',
	'light_onlyGI',
	'mtl_reflectionRefraction',
	'mtl_limitDepth',
	'mtl_maxDepth',
	'mtl_doMaps',
	'mtl_filterMaps',
	'mtl_filterMapsForSecondaryRays',
	'mtl_transpMaxLevels',
	'mtl_transpCutoff',
	'mtl_override_on',
	'mtl_override',
	'mtl_glossy',
	'misc_lowThreadPriority',

	'misc_abortOnMissingAsset',
	'dr_assetsCacheLimitType',
	'dr_assetsCacheLimitValue',
	'dr_overwriteLocalCacheSettings',

	'ray_max_intensity_on',
	'ray_max_intensity',
)


def add_properties(rna_pointer):
	class SettingsOptions(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(SettingsOptions)

	rna_pointer.SettingsOptions= PointerProperty(
		name= NAME,
		type= SettingsOptions,
		description= DESC
	)
	
	SettingsOptions.geom_displacement= BoolProperty(
		name= "Displacement",
		description= "Render displacement",
		default= True
	)
	
	SettingsOptions.geom_doHidden= BoolProperty(
		name= "Render hidden",
		description= "Render hidden geometry",
		default= False
	)
	
	SettingsOptions.light_doLights= BoolProperty(
		name= "Lights",
		description= "Render lights",
		default= True
	)
	
	SettingsOptions.light_doDefaultLights= BoolProperty(
		name= "Default lights",
		description= "Use default lights (when no lights in a scene)",
		default= False
	)
	
	SettingsOptions.light_doHiddenLights= BoolProperty(
		name= "Hidden lights",
		description= "Render hidden lights",
		default= False
	)
	
	SettingsOptions.light_doShadows= BoolProperty(
		name= "Shadows",
		description= "Render shadows",
		default= True
	)
	
	SettingsOptions.light_onlyGI= BoolProperty(
		name= "Show GI only",
		description= "Show GI only",
		default= False
	)
	
	SettingsOptions.gi_dontRenderImage= BoolProperty(
		name= "Calculate GI only",
		description= "Don't render final image - calculate GI only",
		default= False
	)
	
	SettingsOptions.mtl_reflectionRefraction= BoolProperty(
		name= "Reflection/refraction",
		description= "Render reflection / refraction",
		default= True
	)
	
	SettingsOptions.mtl_limitDepth= BoolProperty(
		name= "Limit depth",
		description= "Limit max depth",
		default= False
	)
	
	SettingsOptions.mtl_maxDepth= IntProperty(
		name= "Max depth",
		description= "Max. ray depth for reflections and refractions",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 5
	)
	
	SettingsOptions.mtl_doMaps= BoolProperty(
		name= "Textures",
		description= "Render textures",
		default= True
	)
	
	SettingsOptions.mtl_filterMaps= BoolProperty(
		name= "Filter textures",
		description= "Filter textures",
		default= True
	)
	
	SettingsOptions.mtl_filterMapsForSecondaryRays= BoolProperty(
		name= "Filter textures for GI",
		description= "False to turn off filtering for glossy and GI rays",
		default= False
	)
	
	SettingsOptions.mtl_transpMaxLevels= IntProperty(
		name= "Max transp. levels",
		description= "Max. transparency levels",
		min= 0,
		soft_min= 0,
		soft_max= 100,
		default= 50
	)
	
	SettingsOptions.mtl_transpCutoff= FloatProperty(
		name= "Transp. cutoff",
		description= "Transparency cutoff",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.001
	)
	
	SettingsOptions.mtl_override_on= BoolProperty(
		name= "Override",
		description= "Override material",
		default= False
	)

	SettingsOptions.mtl_override= StringProperty(
		name= "Override material",
		description= "Override material",
		default= ""
	)
	
	SettingsOptions.mtl_glossy= BoolProperty(
		name= "Glossy effects",
		description= "Glossy effects",
		default= True
	)
	
	SettingsOptions.geom_backfaceCull= BoolProperty(
		name= "Force back face culling",
		description= "If true, back faces will be invisible to camera and shadow rays",
		default= False
	)
	
	SettingsOptions.ray_bias= FloatProperty(
		name= "Secondary rays bias",
		description= "Secondary ray bias",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)
	
	SettingsOptions.misc_lowThreadPriority= BoolProperty(
		name= "Low thread priority",
		description= "Low thread priority",
		default= True
	)

	SettingsOptions.misc_abortOnMissingAsset = BoolProperty(
		name        = "Abort On Missing Asset",
		description = "Abort on missing asset",
		default     = False
	)

	SettingsOptions.dr_overwriteLocalCacheSettings = BoolProperty(
		name        = "Overwrite Cache Settings",
		description = "If is true the client's cache settings will overwrite server settings",
		default     = False
	)

	SettingsOptions.dr_assetsCacheLimitValue = FloatProperty(
		name        = "Cache Limit",
		description = "Value of the assets cache limit",
		min         = 0.0,
		precision   = 1,
		default     = 0
	)

	SettingsOptions.dr_assetsCacheLimitType = EnumProperty(
		name        = "Cache Limit Type",
		description = "Type of the assets cache limit",
		items = (
			('0', "None", "Assets are never deleted from the cache folder"),
			('1', "Age (Hours)", "Assets that have been transferred before the specified period of time are deleted; the specified value is in hours"),
			('2', "Size (GB)", "Assets are deleted from oldest to freshly received until the cache folder is below the specified size in gigabytes"),
		),
		default     = '0'
	)

	SettingsOptions.ray_max_intensity_on = BoolProperty(
		name        = "Clamp Ray Intensity",
		description = "Enable clamping of secondary rays",
		default     = False
	)

	SettingsOptions.ray_max_intensity = FloatProperty(
		name        = "Max Intensity",
		description = "The max secondary ray intensity when \"Clamp Ray Max Itensity\" is enabled",
		min         = 1.0,
		default     = 20.0
	)


def write(bus):
	ofile = bus['files']['scene']
	scene = bus['scene']

	VRayScene       = scene.vray
	VRayExporter    = VRayScene.exporter
	SettingsOptions = VRayScene.SettingsOptions
	VRayDR          = VRayScene.VRayDR

	ofile.write("\nSettingsOptions SettingsOptions {")
	for param in PARAMS:
		if VRayExporter.draft:
			if param in ('mtl_limitDepth','mtl_maxDepth','mtl_transpMaxLevels','mtl_transpCutoff','mtl_glossy'):
				continue
		if param == 'mtl_override':
			# Not implemented in V-Ray plugin:
			# override is done in "Node" export function
			continue
		else:
			value= getattr(SettingsOptions, param)
		ofile.write("\n\t%s= %s;" % (param, p(value)))
	if VRayExporter.draft:
		ofile.write("\n\tmtl_limitDepth= 1;")
		ofile.write("\n\tmtl_maxDepth= 5;")
		ofile.write("\n\tmtl_transpMaxLevels= 10;")
		ofile.write("\n\tmtl_transpCutoff= 0.1;")
		ofile.write("\n\tmtl_glossy= 1;")
	ofile.write("\n}\n")

########NEW FILE########
__FILENAME__ = SettingsOutput
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''

''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'SETTINGS'

ID=   'SettingsOutput'

NAME= 'Output'
DESC= "Output options"

PARAMS= (
)


def add_properties(rna_pointer):
	class SettingsOutput(bpy.types.PropertyGroup):
		img_format = EnumProperty(
			name= "Type",
			description= "Output image format",
			items= (
				('PNG',   "PNG",       "PNG"),
				('JPG',   "JPEG",      "Jpeg"),
				('TIFF',  "Tiff",      "Tiff"),
				('TGA',   "TGA",       "Targa"),
				('SGI',   "SGI",       "SGI"),
				('EXR',   "OpenEXR",   "OpenEXR"),
				('VRIMG', "VRayImage", "V-Ray Image format"),
			),
			default= 'PNG'
		)

		color_depth = EnumProperty(
			name= "Color depth",
			description= "olor depth",
			items= (
				('32', "32", "32 bit"),
				('16', "16", "16 bit"),
				('8',  "8",  "8 bit"),
			),
			default= '32'
		)

		img_noAlpha= BoolProperty(
			name= "No alpha",
			description= "Don't write the alpha channel to the final image",
			default= False
		)

		img_separateAlpha= BoolProperty(
			name= "Separate alpha",
			description= "Write the alpha channel to a separate file",
			default= False
		)

		img_file= StringProperty(
			name= "File name",
			description= "Render file name (Variables: %C - camera name; %S - scene name; %F - blend file name)",
			default= "%F_%C"
		)

		img_dir= StringProperty(
			name= "Path",
			description= "Render file directory (Variables: %C - camera name; %S - scene name; %F - blend file name)",
			subtype= 'DIR_PATH',
			default= "//render_%F/"
		)

		img_file_needFrameNumber= BoolProperty(
			name= "Add frame number",
			description= "Add frame number to the image file name",
			default= True
		)

		relements_separateFolders= BoolProperty(
			name= "Separate folders",
			description= "Save render channels in separate folders",
			default= False
		)

		relements_separateFiles = BoolProperty(
			name = "Separate Files",
			description = "Save render channels in separate files",
			default = True
		)
	bpy.utils.register_class(SettingsOutput)

	rna_pointer.SettingsOutput= PointerProperty(
		name= NAME,
		type= SettingsOutput,
		description= DESC
	)



def write(bus):
	COMPRESSION= {
		'NONE':  1,
		'PXR24': 6,
		'ZIP':   4,
		'PIZ':   5,
		'RLE':   2,
	}

	ofile=  bus['files']['scene']
	scene=  bus['scene']

	VRayScene=      scene.vray
	VRayExporter=   VRayScene.exporter
	VRayDR=         VRayScene.VRayDR
	SettingsOutput= VRayScene.SettingsOutput

	wx= int(scene.render.resolution_x * scene.render.resolution_percentage * 0.01)
	wy= int(scene.render.resolution_y * scene.render.resolution_percentage * 0.01)

	ofile.write("\nSettingsOutput SettingsOutput {")
	if VRayExporter.auto_save_render:
		ofile.write("\n\timg_file= \"%s\";" % bus['filenames']['output_filename'])
		ofile.write("\n\timg_dir= \"%s/\";" % bus['filenames']['output'])

	if SettingsOutput.img_format == 'EXR':
		if not SettingsOutput.relements_separateFiles:
			ofile.write("\n\timg_rawFile=1;")

	ofile.write("\n\timg_noAlpha= %d;" % SettingsOutput.img_noAlpha)
	ofile.write("\n\timg_separateAlpha= %d;" % SettingsOutput.img_separateAlpha)
	ofile.write("\n\timg_width= %s;" % wx)
	ofile.write("\n\timg_height= %s;" % (wx if VRayScene.VRayBake.use else wy))
	ofile.write("\n\timg_file_needFrameNumber= %d;" % SettingsOutput.img_file_needFrameNumber)
	ofile.write("\n\tanim_start= %d;" % scene.frame_start)
	ofile.write("\n\tanim_end= %d;" % scene.frame_end)
	ofile.write("\n\tframe_start= %d;" % scene.frame_start)
	ofile.write("\n\tframes_per_second= %.3f;" % 1.0)
	ofile.write("\n\tframes= %d-%d;" % (scene.frame_start, scene.frame_end))
	ofile.write("\n\tframe_stamp_enabled= %d;" % 0)
	ofile.write("\n\tframe_stamp_text= \"%s\";" % ("V-Ray/Blender 2.0 | V-Ray Standalone %%vraycore | %%rendertime"))
	ofile.write("\n\trelements_separateFolders= %d;" % SettingsOutput.relements_separateFolders)
	ofile.write("\n\trelements_divider= \".\";")
	ofile.write("\n}\n")

	ofile.write("\nSettingsEXR SettingsEXR {")
	ofile.write("\n\tcompression= %i;" % COMPRESSION[scene.render.image_settings.exr_codec])
	ofile.write("\n\tbits_per_channel=%s;" % SettingsOutput.color_depth)
	ofile.write("\n}\n")

	ofile.write("\nSettingsTIFF SettingsTIFF {")
	ofile.write("\n\tbits_per_channel=%s;" % SettingsOutput.color_depth)
	ofile.write("\n}\n")

	ofile.write("\nSettingsSGI SettingsSGI {")
	ofile.write("\n\tbits_per_channel=%s;" % SettingsOutput.color_depth)
	ofile.write("\n}\n")

	ofile.write("\nSettingsJPEG SettingsJPEG {")
	ofile.write("\n\tquality=%d;" % scene.render.image_settings.quality)
	ofile.write("\n}\n")

	ofile.write("\nSettingsPNG SettingsPNG {")
	ofile.write("\n\tcompression=%d;" % (int(scene.render.image_settings.quality / 10) if scene.render.image_settings.quality < 90 else 9))
	ofile.write("\n\tbits_per_channel=%s;" % (SettingsOutput.color_depth if SettingsOutput.color_depth in ['8','16'] else '16'))
	ofile.write("\n}\n")

########NEW FILE########
__FILENAME__ = SettingsRaycaster
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'SETTINGS'

ID=   'SettingsRaycaster'

NAME= 'Raycaster'
DESC= "Raycaster options"

PARAMS= (
	'maxLevels',
	'minLeafSize',
	'faceLevelCoef',
	'dynMemLimit',
	'embreeUse',
	'embreeUseMB',
	'embreeHighPrec',
	'embreeLowMemory',
	'embreeRayPackets',
)


def add_properties(rna_pointer):
	class SettingsRaycaster(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(SettingsRaycaster)

	rna_pointer.SettingsRaycaster= PointerProperty(
		name= "Raycaster",
		type=  SettingsRaycaster,
		description= "Raycaster settings"
	)

	SettingsRaycaster.maxLevels= IntProperty(
		name= "Max. tree depth",
		description= "Maximum BSP tree depth",
		min= 50,
		max= 100,
		default= 80
	)

	SettingsRaycaster.minLeafSize= FloatProperty(
		name= "Min. leaf size",
		description= "Minimum size of a leaf node",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= 0.0
	)

	SettingsRaycaster.faceLevelCoef= FloatProperty(
		name= "Face/level",
		description= "Maximum amount of triangles in a leaf node",
		min= 0.0,
		max= 10.0,
		soft_min= 0.0,
		soft_max= 10.0,
		default= 1.0
	)

	SettingsRaycaster.dynMemLimit= IntProperty(
		name= "Dynamic memory limit",
		description= "RAM limit for the dynamic raycasters (0 = auto)",
		min= 0,
		max= 100000,
		default= 0
	)

	SettingsRaycaster.embreeUse= BoolProperty(
		name="embreeUse",
		description="Enable/Disable using the embree ray caster",
		default=False
	)
	SettingsRaycaster.embreeUseMB= BoolProperty(
		name="embreeUseMB",
		description="Enable/disable using the embree ray caster for motion blur",
		default=False
	)
	SettingsRaycaster.embreeHighPrec= BoolProperty(
		name="embreeHighPrec",
		description="Enable/disable high precision intersection",
		default=False
	)
	SettingsRaycaster.embreeLowMemory= BoolProperty(
		name="embreeLowMemory",
		description="Try to conserve memory, using potentially slower algorithms",
		default=False
	)
	SettingsRaycaster.embreeRayPackets= BoolProperty(
		name="embreeRayPackets",
		description="Turn on the packet ray casting",
		default=False
	)


def write(bus):
	ofile=  bus['files']['scene']
	scene=  bus['scene']

	rna_pointer= getattr(scene.vray, ID)
	ofile.write("\n%s %s {" % (ID,ID))
	for param in PARAMS:
		value= getattr(rna_pointer, param)
		ofile.write("\n\t%s= %s;"%(param, p(value)))
	ofile.write("\n}\n")

########NEW FILE########
__FILENAME__ = SettingsRegionsGenerator
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
import vb25.utils


TYPE= 'SETTINGS'
ID=   'SettingsRegionsGenerator'

NAME= 'Regions Generator'
DESC= "Regions generator settings"


def add_properties(parent_struct):
	class SettingsRegionsGenerator(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(SettingsRegionsGenerator)
	
	parent_struct.SettingsRegionsGenerator= PointerProperty(
		type= SettingsRegionsGenerator,
		name= NAME,
		description= DESC
	)

	SettingsRegionsGenerator.seqtype= EnumProperty(
		name= "Type",
		description= "Determines the order in which the regions are rendered",
		items=(
			('HILBERT',   "Hilbert",       ""),
			('TRIANGLE',  "Triangulation", ""),
			('IOSPIRAL',  "Spiral",        ""),
			('TBCHECKER', "Checker",       ""),
			('LRWIPE',    "Left-right",    ""),
			('TBWIPE',    "Top-bottom",    "") # 0
		),
		default= 'TRIANGLE'
	)

	SettingsRegionsGenerator.xymeans= EnumProperty(
		name= "XY means",
		description="XY means region width/height or region count",
		items=(
			('BUCKETS',  "Region count",  ""),
			('SIZE',     "Bucket W/H",    "") # 0
		),
		default= 'SIZE'
	)

	SettingsRegionsGenerator.reverse= BoolProperty(
		name= "Reverse",
		description= "Reverses the region sequence order",
		default= False
	)

	SettingsRegionsGenerator.lock_size= BoolProperty(
		name= "Lock size",
		description= "Lock bucket size (x = y)",
		default= True
	)

	SettingsRegionsGenerator.xc= IntProperty(
		name= "X",
		description= "Determines the maximum region width in pixels (Bucket W/H is selected) or the number of regions in the horizontal direction (when Region Count is selected)",
		min= 1,
		max= 1024,
		default= 32
	)

	SettingsRegionsGenerator.yc= IntProperty(
		name= "Y",
		description= "Determines the maximum region height in pixels (Bucket W/H is selected) or the number of regions in the vertical direction (when Region Count is selected)",
		min= 1,
		max= 1024,
		default= 32
	)


def write(bus):
	ofile=  bus['files']['scene']
	scene=  bus['scene']

	VRayScene= scene.vray
	SettingsRegionsGenerator= VRayScene.SettingsRegionsGenerator

	SEQTYPE= {
		'HILBERT':   5,
		'TRIANGLE':  4,
		'IOSPIRAL':  3,
		'TBCHECKER': 2,
		'LRWIPE':    1,
		'TBWIPE':    0,
	}

	XYMEANS= {
		'BUCKETS': 1,
		'SIZE':    0,
	}

	ofile.write("\nSettingsRegionsGenerator SettingsRegionsGenerator {")
	ofile.write("\n\txc= %i;" % SettingsRegionsGenerator.xc)
	if SettingsRegionsGenerator.lock_size:
		ofile.write("\n\tyc= %i;" % SettingsRegionsGenerator.xc)
	else:
		ofile.write("\n\tyc= %i;" % SettingsRegionsGenerator.yc)
	ofile.write("\n\treverse= %i;" % SettingsRegionsGenerator.reverse)
	ofile.write("\n\tseqtype= %i;" % SEQTYPE[SettingsRegionsGenerator.seqtype])
	ofile.write("\n\txymeans= %i;" % XYMEANS[SettingsRegionsGenerator.xymeans])
	ofile.write("\n}\n")

########NEW FILE########
__FILENAME__ = SettingsScene
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.ui import ui

TYPE= 'SETTINGS'

ID=   'SETTINGSCENE'
NAME= 'Scene settings'
DESC= "Misc. scene settings"

PARAMS= (
)


def image_aspect_lock(self, context):
	scene= context.scene
	rd=    scene.render
	VRayScene= scene.vray
		
	if VRayScene.image_aspect_lock:
		rd.resolution_y= rd.resolution_x / VRayScene.image_aspect
	
	return None


def add_properties(rna_pointer):
	rna_pointer.image_aspect_lock= BoolProperty(
		name= "Lock aspect",
		description= "Lock image aspect",
		default= False
	)

	rna_pointer.image_aspect= FloatProperty(
		update= image_aspect_lock,
		name= "Image aspect",
		description= "Image aspect",
		min= 0.1,
		max= 100.0,
		soft_min= 0.1,
		soft_max= 10.0,
		precision= 3,
		default= 1.333
	)

	

########NEW FILE########
__FILENAME__ = SettingsUnitsInfo
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'SETTINGS'

ID=   'SettingsUnitsInfo'

NAME= 'Units'
DESC= "Units options"

PARAMS= (
	'meters_scale',
	'photometric_scale',
)


def add_properties(rna_pointer):
	class SettingsUnitsInfo(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(SettingsUnitsInfo)

	rna_pointer.SettingsUnitsInfo= PointerProperty(
		name= "Units",
		type=  SettingsUnitsInfo,
		description="Units settings"
	)

	SettingsUnitsInfo.photometric_scale= FloatProperty(
		name= "Photometric scale",
		description= "Photometric scale",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 4,
		default= 0.001
	)

	SettingsUnitsInfo.meters_scale= FloatProperty(
		name= "Meters scale",
		description= "Meters scale",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.0
	)

def write(bus):
	ofile=  bus['files']['scene']
	scene=  bus['scene']

	VRayScene= scene.vray
	SettingsUnitsInfo= VRayScene.SettingsUnitsInfo
	
	ofile.write("\nSettingsUnitsInfo SettingsUnitsInfo {")
	# ofile.write("\n\tmeters_scale= %i;" % SettingsUnitsInfo.meters_scale)
	ofile.write("\n\tmeters_scale= %.4f;" % scene.unit_settings.scale_length)
	# ofile.write("\n\tphotometric_scale= %.4f;" % SettingsUnitsInfo.photometric_scale)
	ofile.write("\n\tphotometric_scale= 0.01;")
	ofile.write("\n}\n")


########NEW FILE########
__FILENAME__ = SettingsVFB
#
# V-Ray For Blender
#
# http://www.chaosgroup.com
#
# Author: Andrei Izrantcev
# E-Mail: andrei.izrantcev@chaosgroup.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
#

import bpy

from bpy.props import *

from vb25.utils import p


TYPE = 'SETTINGS'
ID   = 'SettingsVFB'
NAME = 'Lens Effects'
DESC = "Lens effects"

PARAMS = (
    'bloom_on',
    'bloom_fill_edges',
    'bloom_weight',
    'bloom_size',
    'bloom_shape',
    'bloom_mode',
    'bloom_mask_intensity_on',
    'bloom_mask_intensity',
    'bloom_mask_objid_on',
    'bloom_mask_objid',
    'bloom_mask_mtlid_on',
    'bloom_mask_mtlid',
    'glare_on',
    'glare_fill_edges',
    'glare_weight',
    'glare_size',
    'glare_type',
    'glare_mode',
    # 'glare_image_path',
    # 'glare_obstacle_image_path',
    'glare_diffraction_on',
    'glare_use_obstacle_image',
    'glare_cam_blades_on',
    'glare_cam_num_blades',
    'glare_cam_rotation',
    'glare_cam_fnumber',
    'glare_mask_intensity_on',
    'glare_mask_intensity',
    'glare_mask_objid_on',
    'glare_mask_objid',
    'glare_mask_mtlid_on',
    'glare_mask_mtlid',
    'interactive',
)


def add_properties(rna_pointer):
    class SettingsVFB(bpy.types.PropertyGroup):
        use = BoolProperty(
            name        = "Use Lens Effects",
            description = "",
            default     = False
        )

        # bloom_on
        bloom_on= BoolProperty(
            name= "bloom on",
            description= "",
            default= False
        )

        # bloom_fill_edges
        bloom_fill_edges= BoolProperty(
            name= "bloom fill edges",
            description= "",
            default= True
        )

        # bloom_weight
        bloom_weight= FloatProperty(
            name= "bloom weight",
            description= "",
            min= 0.0,
            max= 100.0,
            soft_min= 0.0,
            soft_max= 10.0,
            precision= 3,
            default= 20
        )

        # bloom_size
        bloom_size= FloatProperty(
            name= "bloom size",
            description= "",
            min= 0.0,
            max= 100.0,
            soft_min= 0.0,
            soft_max= 10.0,
            precision= 3,
            default= 20
        )

        # bloom_shape
        bloom_shape= FloatProperty(
            name= "bloom shape",
            description= "",
            min= 0.0,
            max= 100.0,
            soft_min= 0.0,
            soft_max= 10.0,
            precision= 3,
            default= 4
        )

        # bloom_mode
        bloom_mode= EnumProperty(
            name= "bloom mode",
            description= "mode",
            items=(
                ('0', "Image", ""),
                ('1', "Image And Buffer", ""),
                ('2', "Buffer", ""),
            ),
            default= '0'
        )

        # bloom_mask_intensity_on
        bloom_mask_intensity_on= BoolProperty(
            name= "bloom mask intensity on",
            description= "",
            default= False
        )

        # bloom_mask_intensity
        bloom_mask_intensity= FloatProperty(
            name= "bloom mask intensity",
            description= "",
            min= 0.0,
            max= 100.0,
            soft_min= 0.0,
            soft_max= 10.0,
            precision= 3,
            default= 3
        )

        # bloom_mask_objid_on
        bloom_mask_objid_on= BoolProperty(
            name= "bloom mask objid on",
            description= "",
            default= False
        )

        # bloom_mask_objid
        bloom_mask_objid= IntProperty(
            name= "bloom mask objid",
            description= "",
            min= 0,
            max= 100,
            soft_min= 0,
            soft_max= 10,
            default= 0
        )

        # bloom_mask_mtlid_on
        bloom_mask_mtlid_on= BoolProperty(
            name= "bloom mask mtlid on",
            description= "",
            default= False
        )

        # bloom_mask_mtlid
        bloom_mask_mtlid= IntProperty(
            name= "bloom mask mtlid",
            description= "",
            min= 0,
            max= 100,
            soft_min= 0,
            soft_max= 10,
            default= 0
        )

        # glare_on
        glare_on= BoolProperty(
            name= "glare on",
            description= "",
            default= False
        )

        # glare_fill_edges
        glare_fill_edges= BoolProperty(
            name= "glare fill edges",
            description= "",
            default= True
        )

        # glare_weight
        glare_weight= FloatProperty(
            name= "glare weight",
            description= "",
            min= 0.0,
            max= 100.0,
            soft_min= 0.0,
            soft_max= 10.0,
            precision= 3,
            default= 50
        )

        # glare_size
        glare_size= FloatProperty(
            name= "glare size",
            description= "",
            min= 0.0,
            max= 100.0,
            soft_min= 0.0,
            soft_max= 10.0,
            precision= 3,
            default= 20
        )

        # glare_type
        glare_type= EnumProperty(
            name= "glare type",
            description= "",
            items=(
                ('0', "From Image", ""),
                ('1', "From Render Camera", ""),
                ('2', "From Camera Params", ""),
            ),
            default= '0'
        )

        # glare_mode
        glare_mode= EnumProperty(
            name= "glare mode",
            description= "mode",
            items=(
                ('0', "Image", ""),
                ('1', "Image And Buffer", ""),
                ('2', "Buffer", ""),
            ),
            default= '0'
        )

        # glare_image_path
        glare_image_path= StringProperty(
            name= "glare image path",
            description= "",
            subtype='FILE_PATH',
            default= ""
        )

        # glare_obstacle_image_path
        glare_obstacle_image_path= StringProperty(
            name= "glare obstacle image path",
            description= "",
            subtype='FILE_PATH',
            default= ""
        )

        # glare_diffraction_on
        glare_diffraction_on= BoolProperty(
            name= "glare diffraction on",
            description= "",
            default= False
        )

        # glare_use_obstacle_image
        glare_use_obstacle_image= BoolProperty(
            name= "glare use obstacle image",
            description= "",
            default= False
        )

        # glare_cam_blades_on
        glare_cam_blades_on= BoolProperty(
            name= "glare cam blades on",
            description= "",
            default= True
        )

        # glare_cam_num_blades
        glare_cam_num_blades= IntProperty(
            name= "glare cam num blades",
            description= "",
            min= 0,
            max= 100,
            soft_min= 0,
            soft_max= 10,
            default= 6
        )

        # glare_cam_rotation
        glare_cam_rotation= FloatProperty(
            name= "glare cam rotation",
            description= "Rotation in degrees from 0.0 - 360.0",
            min= 0.0,
            max= 100.0,
            soft_min= 0.0,
            soft_max= 10.0,
            precision= 3,
            default= 0
        )

        # glare_cam_fnumber
        glare_cam_fnumber= FloatProperty(
            name= "glare cam fnumber",
            description= "",
            min= 0.0,
            max= 100.0,
            soft_min= 0.0,
            soft_max= 10.0,
            precision= 3,
            default= 8
        )

        # glare_mask_intensity_on
        glare_mask_intensity_on= BoolProperty(
            name= "glare mask intensity on",
            description= "",
            default= False
        )

        # glare_mask_intensity
        glare_mask_intensity= FloatProperty(
            name= "glare mask intensity",
            description= "",
            min= 0.0,
            max= 100.0,
            soft_min= 0.0,
            soft_max= 10.0,
            precision= 3,
            default= 3
        )

        # glare_mask_objid_on
        glare_mask_objid_on= BoolProperty(
            name= "glare mask objid on",
            description= "",
            default= False
        )

        # glare_mask_objid
        glare_mask_objid= IntProperty(
            name= "glare mask objid",
            description= "",
            min= 0,
            max= 100,
            soft_min= 0,
            soft_max= 10,
            default= 0
        )

        # glare_mask_mtlid_on
        glare_mask_mtlid_on= BoolProperty(
            name= "glare mask mtlid on",
            description= "",
            default= False
        )

        # glare_mask_mtlid
        glare_mask_mtlid= IntProperty(
            name= "glare mask mtlid",
            description= "",
            min= 0,
            max= 100,
            soft_min= 0,
            soft_max= 10,
            default= 0
        )

        # interactive
        interactive= BoolProperty(
            name= "interactive",
            description= "",
            default= True
        )

    bpy.utils.register_class(SettingsVFB)

    rna_pointer.SettingsVFB = bpy.props.PointerProperty(
        name        = "SettingsVFB",
        type        =  SettingsVFB,
        description = "SettingsVFB"
    )


def write(bus):
    ofile = bus['files']['scene']
    scene = bus['scene']

    rna_pointer = getattr(scene.vray, ID)

    if not rna_pointer.use:
        return

    ofile.write("\n%s %s {" % (ID, ID))
    for param in PARAMS:
        value = getattr(rna_pointer, param)
        ofile.write("\n\t%s=%s;"%(param, p(value)))
    ofile.write("\n}\n")

########NEW FILE########
__FILENAME__ = TexBerconWood
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexBerconWood'
PLUG= 'TexBerconWood'
NAME= 'Bercon Wood'
DESC= "Bercon Wood."
PID=   35

PARAMS= (
	'uvwgen',
	'noise_color1',
	'noise_color2',
	'noise_color3',
	'noise_map1',
	'noise_map2',
	'noise_map3',
	'wood_size',
	'low_tresh',
	'high_tresh',
	'wood_type',
	'trunk_str',
	'trunk_freq',
	'radial_z',
	'angle_str',
	'angle_freq',
	'angle_rad',
	'grain_str',
	'grain_freq',
	'grain_lock',
	'width_var',
	'gain_var',
	'rand_seed',
	'wood_skew',
	'samples',
	'dist_map',
	'dist_map2',
	'dist_str',
	'use_dist',
	'tex_size',
	'tex_low',
	'tex_high',
	'tex_skew',
	'tex_width_var',
	'tex_gain_var',
	'tex_trunk_str',
	'tex_trunk_freq',
	'tex_radial_str',
	'tex_radial_freq',
	'tex_z_str',
	'tex_ang_str',
	'tex_ang_freq',
	'tex_ang_rad',
	'tex_grain_str',
	'tex_grain_freq',
#	'use_curve_input', - TODO
#	'curve_output',    - TODO
#	'curve_input',     - TODO
)





def add_properties(rna_pointer):
	class TexBerconWood(bpy.types.PropertyGroup):

		# use_3d_mapping
		use_3d_mapping  = BoolProperty(
			name        = "use 3d mapping",
			description = "",
			default     = True
		)

		#  noise_color1: color = Color(0, 0, 0), noise color 1
		noise_color1 = FloatVectorProperty(
			name        = "noise color 1",
			description = "noise color 1",
			subtype     = 'COLOR',
			min         = 0.0,
			max         = 1.0,
			soft_min    = 0.0,
			soft_max    = 1.0,
			default     = (0,0,0)
		)

		#  noise_color2: color = Color(0, 0, 0), noise color 2
		noise_color2 = FloatVectorProperty(
			name        = "noise color 2",
			description = "noise color 2",
			subtype     = 'COLOR',
			min         = 0.0,
			max         = 1.0,
			soft_min    = 0.0,
			soft_max    = 1.0,
			default     = (0,0,0)
		)

		#  noise_color3: color = Color(0, 0, 0), noise color 3
		noise_color3 = FloatVectorProperty(
			name        = "noise color 3",
			description = "noise color 3",
			subtype     = 'COLOR',
			min         = 0.0,
			max         = 1.0,
			soft_min    = 0.0,
			soft_max    = 1.0,
			default     = (0,0,0)
		)

		#  noise_map1: acolor texture, unlimited list, noise map 1
		noise_map1 = StringProperty(
			name        = "noise map 1 texture ",
			description = "noise map 1 texture",
			default     = ""
		)

		#  noise_map2: acolor texture, unlimited list, noise map 2
		noise_map2 = StringProperty(
			name        = "noise map 2 texture ",
			description = "noise map 2 texture",
			default     = ""
		)

		#  noise_map3: acolor texture, unlimited list, noise map 3
		noise_map3 = StringProperty(
			name        = "noise map 3 texture ",
			description = "noise map 3 texture",
			default     = ""
		)

		#  wood_size: float = 3, wood size
		wood_size = FloatProperty(
			name        = "Wood Size",
			description = "Wood Size",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 3
		)

		#  low_tresh: float = 0.3, low treshold
		low_tresh = FloatProperty(
			name        = "low treshold",
			description = "low treshold",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0.3
		)

		#  high_tresh: float = 1, high treshold
		high_tresh = FloatProperty(
			name        = "high treshold",
			description = "high treshold",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 1
		)

		#  wood_type: integer = 0, 0:Radial wood, 1:Perlin wood, 2:Simplex wood, 3:Linear wood
		wood_type = EnumProperty(
		name        = "Type",
		description = "Cellular type",
		items       = (
					  ('RADIAL',   "Radial wood",  ""), # 0
					  ('PERLIN',   "Perlin wood",  ""),
					  ('SIMPLEX',  "Simplex wood", ""),
					  ('LINEAR',   "Linear wood",  ""),
		),
		default     = 'RADIAL'
		)

		#  trunk_str: float = 1, trunk strength
		trunk_str = FloatProperty(
			name        = "trunk strength",
			description = "trunk strength",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 1
		)

		#  trunk_freq: float = 0.04, trunk frequency
		trunk_freq = FloatProperty(
			name        = "trunk frequency",
			description = "trunk frequency",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0.04
		)

		#  radial_str: float = 0.25, radial strength
		radial_str = FloatProperty(
			name        = "radial strength",
			description = "radial strength",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0.25
		)

		#  radial_freq: float = 0.1, radial frequency
		radial_freq = FloatProperty(
			name        = "radial frequency",
			description = "radial frequency",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0.1
		)

		#  radial_z: float = 0.01, radial Z frequency
		radial_z = FloatProperty(
			name        = "radial Z frequency",
			description = "radial Z frequency",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0.01
		)

		#  angle_str: float = 0.1, angle strength
		angle_str = FloatProperty(
			name        = "angle strength",
			description = "angle strength",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0.1
		)

		#  angle_freq: float = 1, angle frequency
		angle_freq = FloatProperty(
			name        = "angle frequency",
			description = "angle frequency",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 1
		)

		#  angle_rad: float = 15, angle radius
		angle_rad = FloatProperty(
			name        = "angle radius",
			description = "angle radius",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 15
		)

		#  grain_str: float = 0.2, grain strength
		grain_str = FloatProperty(
			name        = "grain strength",
			description = "grain strength",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0.2
		)

		#  grain_freq: float = 5, grain frequency
		grain_freq = FloatProperty(
			name        = "grain frequency",
			description = "grain frequency",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 5
		)

		#  grain_lock: bool = false, grain lock
		grain_lock = BoolProperty(
			name        = "grain lock",
			description = "",
			default     = False
		)

		#  width_var: float = 0.5, width variation
		width_var = FloatProperty(
			name        = "width variation",
			description = "width variation",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0.5
		)

		#  gain_var: float = 0.75, gain variation
		gain_var = FloatProperty(
			name        = "gain variation",
			description = "gain variation",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0.75
		)

		#  rand_seed: float = 12.345, random seed
		rand_seed = FloatProperty(
			name        = "random seed",
			description = "random seed",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 12.345
		)

		#  wood_skew: float = 0.75, wood skew
		wood_skew = FloatProperty(
			name        = "wood skew",
			description = "wood skew",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0.75
		)

		#  samples: integer = 4, samples
		samples = IntProperty(
            name        = "samples",
            description = "samples",
            min         = 0,
            max         = 100,
            soft_min    = 0,
            soft_max    = 10,
            default     = 4
        )


		#  dist_map: acolor texture, unlimited list, distortion map
		dist_map = StringProperty(
			name        = "distortion map",
			description = "distortion map",
			default     = ""
		)

		#  dist_map2: acolor texture, unlimited list, distortion map 2
		dist_map2 = StringProperty(
			name        = "distortion map 2",
			description = "distortion map 2",
			default     = ""
		)

		#  dist_str: float = 0.1, distortion strength
		dist_str = FloatProperty(
			name        = "distortion strength",
			description = "distortion strength",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0.1
		)

		#  use_dist: bool = false, use distortion
		use_dist = BoolProperty(
			name        = "use distortion",
			description = "",
			default     = False
		)

		#  tex_size: acolor texture, texture for the size
		tex_size = StringProperty(
			name        = "texture for the size",
			description = "texture for the size",
			default     = ""
		)

		#  tex_low: acolor texture, texture for low treshhold
		tex_low = StringProperty(
			name        = "texture for low treshhold",
			description = "texture for low treshhold",
			default     = ""
		)

		#  tex_high: acolor texture, texture for high greshhold
		tex_high = StringProperty(
			name        = "texture for high greshhold",
			description = "texture for high greshhold",
			default     = ""
		)

		#  tex_skew: acolor texture, texture for skew
		tex_skew = StringProperty(
			name        = "texture for skew",
			description = "texture for skew",
			default     = ""
		)

		#  tex_width_var: acolor texture, texture for width variation
		tex_width_var = StringProperty(
			name        = "texture for width variation",
			description = "texture for width variation",
			default     = ""
		)

		#  tex_gain_var: acolor texture, texture for gain variation
		tex_gain_var = StringProperty(
			name        = "texture for gain variation",
			description = "texture for gain variation",
			default     = ""
		)

		#  tex_trunk_str: acolor texture, texture for trunk strength
		tex_trunk_str = StringProperty(
			name        = "texture for trunk strength",
			description = "texture for trunk strength",
			default     = ""
		)

		#  tex_trunk_freq: acolor texture, texture for trunk frequency
		tex_trunk_freq = StringProperty(
			name        = "texture for trunk frequency",
			description = "texture for trunk frequency",
			default     = ""
		)

		#  tex_radial_str: acolor texture, texture for radial strength
		tex_radial_str = StringProperty(
			name        = "texture for radial strength",
			description = "texture for radial strength",
			default     = ""
		)

		#  tex_radial_freq: acolor texture, texture for radial frequency
		tex_radial_freq = StringProperty(
			name        = "texture for radial frequency",
			description = "texture for radial frequency",
			default     = ""
		)

		#  tex_z_str: acolor texture, texture for radial z strength
		tex_z_str = StringProperty(
			name        = "texture for radial z strength",
			description = "texture for radial z strength",
			default     = ""
		)

		#  tex_ang_str: acolor texture, texture for angular strength
		tex_ang_str = StringProperty(
			name        = "texture for angular strength",
			description = "texture for angular strength",
			default     = ""
		)

		#  tex_ang_freq: acolor texture, texture for angular frequency
		tex_ang_freq = StringProperty(
			name        = "texture for angular frequency",
			description = "texture for angular frequency",
			default     = ""
		)

		#  tex_ang_rad: acolor texture, texture for angular radius
		tex_ang_rad = StringProperty(
			name        = "texture for angular radius",
			description = "texture for angular radius",
			default     = ""
		)

		#  tex_grain_str: acolor texture, texture for grain strength
		tex_grain_str = StringProperty(
			name        = "texture for grain strength",
			description = "texture for grain strength",
			default     = ""
		)

		#  tex_grain_freq: acolor texture, texture for grain frequency
		tex_grain_freq = StringProperty(
			name        = "texture for grain frequency",
			description = "texture for grain frequency",
			default     = ""
		)

		#  TODO
		#  use_curve_input: bool = false
		#  curve_output: output float texture, Calculated blend amount to be tranformed by the bezier curve!
		#  curve_input: float texture = 0.5, If curve is used the output value will be taken from this texture
		
	bpy.utils.register_class(TexBerconWood)

	rna_pointer.TexBerconWood = PointerProperty(
		name        = "TexBerconWood",
		type        =  TexBerconWood,
		description = "V-Ray TexBerconWood settings"
	)


def write(bus):


	WOOD_TYPE = {
		'RADIAL':  0,
		'PERLIN':  1,
		'SIMPLEX': 2,
		'LINEAR':  3,
	}

	scene = bus['scene']
	ofile = bus['files']['textures']

	slot     = bus['mtex']['slot']
	texture  = bus['mtex']['texture']
	tex_name = bus['mtex']['name']

	uvwgen = write_uvwgen(bus)

	TexBerconWood = getattr(texture.vray, PLUG)

	mapped = (  'noise_map1',     'noise_map2',     'noise_map3',
				'dist_map',       'dist_map2',      'tex_size',
				'tex_low',        'tex_high',       'tex_skew',
				'tex_width_var',  'tex_gain_var',   'tex_trunk_str',
				'tex_trunk_freq', 'tex_radial_str', 'tex_radial_freq',
				'tex_z_str',      'tex_ang_str',    'tex_ang_freq',
				'tex_ang_rad',    'tex_grain_str',  'tex_grain_freq')

	mapped_params = write_sub_textures(bus,
									   TexBerconWood,
									   mapped)

	print(len(mapped_params))
	
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen

		elif param == 'wood_type':
			value=WOOD_TYPE[TexBerconWood.wood_type]

		elif param in mapped:
			if param in mapped_params:
				value= mapped_params[param]	
			else:
				continue			

		else:
			value= getattr(TexBerconWood, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexBerconWood(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexBerconWood= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexBerconWood, 'wood_type')

		layout.separator()

		layout.label(text="Noise Color:")
		split = layout.split()
		col= split.column(align= True)
		col.prop(TexBerconWood, 'noise_color1', text="Color 1")
		col.prop_search(TexBerconWood, 'noise_map1',
						bpy.data, 'textures',
						text= "")

		if wide_ui:
			col= split.column(align= True)
		col.prop(TexBerconWood, 'noise_color2', text="Color 2")
		col.prop_search(TexBerconWood, 'noise_map2',
						bpy.data, 'textures',
						text= "")

		if wide_ui:
			col= split.column(align= True)
		col.prop(TexBerconWood, 'noise_color3', text="Color 3")
		col.prop_search(TexBerconWood, 'noise_map3',
						bpy.data, 'textures',
						text= "")

		# wood size\width group
		split= layout.split()
		col= split.column(align= True)
		col.prop(TexBerconWood, 'wood_size', text="Wood Size")
		col.prop_search(TexBerconWood, 'tex_size',
						bpy.data, 'textures',
						text= "")

		split= layout.split()

		col= split.column(align= True)
		col.prop(TexBerconWood, 'width_var', text="Width Variation")
		col.prop_search(TexBerconWood, 'tex_width_var',
						bpy.data, 'textures',
						text= "")
		
		split= layout.split()		
		row = split.row()
		
		# tresh group
		split = row.column()
		col= split.column(align= True)
		col.label(text="Treshold:")
		col.prop(TexBerconWood, 'low_tresh', text="Low")
		col.prop_search(TexBerconWood, 'tex_low',
						bpy.data, 'textures',
						text= "")
		col.separator()
		col.prop(TexBerconWood, 'high_tresh', text="High")
		col.prop_search(TexBerconWood, 'tex_high',
						bpy.data, 'textures',
						text= "")
		
		# trunk group
		split = row.column()
		col= split.column(align= True)
		col.label("Trunk:")

		col.prop(TexBerconWood, 'trunk_str', text="Strength")
		col.prop_search(TexBerconWood, 'tex_trunk_str',
						bpy.data, 'textures',
						text= "")

		col.separator()

		col.prop(TexBerconWood, 'trunk_freq', text="Frequency")
		col.prop_search(TexBerconWood, 'tex_trunk_freq',
						bpy.data, 'textures',
						text= "")

		split= layout.split()		
		row = split.row()

		# radial group
		split = row.column()
		col= split.column(align= True)
		col.label("Radial:")

		col.prop(TexBerconWood, 'radial_str', text="Strength")
		col.prop_search(TexBerconWood, 'tex_radial_str',
						bpy.data, 'textures',
						text= "")

		col.separator()

		col.prop(TexBerconWood, 'radial_freq', text="Frequency")
		col.prop_search(TexBerconWood, 'tex_radial_freq',
						bpy.data, 'textures',
						text= "")

		col.separator()

		col.prop(TexBerconWood, 'radial_z', text="Z Strength")
		col.prop_search(TexBerconWood, 'tex_z_str',
						bpy.data, 'textures',
						text= "")

		# angle group
		split = row.column()
		col= split.column(align= True)
		col.label("Angle:")

		col.prop(TexBerconWood, 'angle_str', text="Strength")
		col.prop_search(TexBerconWood, 'tex_ang_str',
						bpy.data, 'textures',
						text= "")

		col.separator()

		col.prop(TexBerconWood, 'angle_freq', text="Frequency")
		col.prop_search(TexBerconWood, 'tex_ang_freq',
						bpy.data, 'textures',
						text= "")

		col.separator()

		col.prop(TexBerconWood, 'angle_rad', text="Radius")
		col.prop_search(TexBerconWood, 'tex_ang_rad',
						bpy.data, 'textures',
						text= "")

		# grain group
		split= layout.split()
		col= split.column(align= True)
		col.prop(TexBerconWood, 'grain_lock')
		split= layout.split()
		col= split.column(align= True)
		if TexBerconWood.grain_lock:
			col.prop(TexBerconWood, 'grain_str')
			col.prop_search(TexBerconWood, 'tex_grain_str',
							bpy.data, 'textures',
							text= "")

			if wide_ui:
				col= split.column(align= True)
			col.prop(TexBerconWood, 'grain_freq')
			col.prop_search(TexBerconWood, 'tex_grain_freq',
							bpy.data, 'textures',
							text= "")

		# gain\skew group
		split= layout.split()
		col= split.column(align= True)
		col.prop(TexBerconWood, 'gain_var')
		col.prop_search(TexBerconWood, 'tex_gain_var',
						bpy.data, 'textures',
						text= "")

		if wide_ui:
			col= split.column(align= True)
		col.prop(TexBerconWood, 'wood_skew')
		col.prop_search(TexBerconWood, 'tex_skew',
						bpy.data, 'textures',
						text= "")

		# dist group
		split= layout.split()
		col= split.column(align= True)
		col.prop(TexBerconWood, 'use_dist')
		split= layout.split()
		col= split.column(align= True)
		if TexBerconWood.use_dist:
			col.prop_search(TexBerconWood, 'dist_map',
							bpy.data, 'textures',
							text= "")
			col.prop_search(TexBerconWood, 'dist_map2',
							bpy.data, 'textures',
							text= "")
			if wide_ui:
				col= split.column(align= True)
			col.prop(TexBerconWood, 'dist_str')

		# other
		split= layout.split()
		col= split.column(align= True)
		col.prop(TexBerconWood, 'samples', text="Samples")
		split= layout.split()
		col= split.column(align= True)
		col.prop(TexBerconWood, 'rand_seed', text="Random Seed")


def GetRegClasses():
	return (
		VRAY_TP_TexBerconWood,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexBitmap
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.shaders import *
from vb25.ui      import ui
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexBitmap'

NAME= 'Bitmap'
DESC= "Image texture"


def add_properties(rna_pointer):
	class VRayImage(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(VRayImage)

	class BitmapBuffer(bpy.types.PropertyGroup):
		filter_type= EnumProperty(
			name= "Filter type",
			description= "Filter type",
			items= (
				('NONE',   "None",        "None"),
				('MIPMAP', "Mip-Map",     "Mip-map filtering"),
				('AREA',   "Area",        "Summed area filtering")
			),
			default= 'NONE'
		)

		color_space= EnumProperty(
			name= "Color space",
			description= "Color space",
			items= (
				('LINEAR', "Linear",          ""), # 0
				('GAMMA',  "Gamma corrected", ""),
				('SRGB',   "sRGB",            "")
			),
			default= 'SRGB'
		)

		interpolation= EnumProperty(
			name= "Interpolation",
			description= "Interpolation",
			items= (
				('BILINEAR', "Bilinear", ""), # 0
				('BICUBIC',  "Bicubic",  ""),
			),
			default= 'BILINEAR'
		)

		filter_blur= FloatProperty(
			name= "Blur",
			description= "Filter blur",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= 1.0
		)

		gamma= FloatProperty(
			name= "Gamma",
			description= "Gamma",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 4,
			default= 1.0
		)

		use_input_gamma= BoolProperty(
			name= "Use \"Input gamma\"",
			description= "Use \"Input gamma\" from \"Color mapping\" settings",
			default= True
		)

		gamma_correct= BoolProperty(
			name= "Invert gamma",
			description= "Correct \"Color mapping\" gamma (set image gamma = 1 / cm_gamma)",
			default= False
		)

		allow_negative_colors= BoolProperty(
			name= "Allow negative colors",
			description= "If false negative colors will be clamped",
			default= False
		)

		use_data_window= BoolProperty(
			name= "Use data window",
			description= "Use the data window information in OpenEXR files",
			default= True
		)
	bpy.utils.register_class(BitmapBuffer)

	bpy.types.Image.vray= PointerProperty(
		name= "V-Ray Image Settings",
		type=  VRayImage,
		description= "V-Ray image settings"
	)

	VRayImage.BitmapBuffer= PointerProperty(
		name= "BitmapBuffer",
		type=  BitmapBuffer,
		description= "BitmapBuffer settings"
	)



'''
  OUTPUT
'''
def write_BitmapBuffer(bus):
	FILTER_TYPE= {
		'NONE':   0,
		'MIPMAP': 1,
		'AREA':   2,
	}
	COLOR_SPACE= {
		'LINEAR': 0,
		'GAMMA':  1,
		'SRGB':   2,
	}
	INTERPOLATION= {
		'BILINEAR': 0,
		'BICUBIC':  1,
	}

	ofile= bus['files']['textures']
	scene= bus['scene']

	slot=    bus['mtex']['slot']
	texture= bus['mtex']['texture']

	VRayScene=    scene.vray
	SettingsColorMapping= VRayScene.SettingsColorMapping

	VRaySlot=     texture.vray_slot
	VRayTexture=  texture.vray
	BitmapBuffer= texture.image.vray.BitmapBuffer

	filename= get_full_filepath(bus, texture.image, texture.image.filepath)

	bitmap_name= 'IM' + clean_string(texture.image.name)

	# Check if already exported
	if not append_unique(bus['cache']['bitmap'], bitmap_name):
		return bitmap_name

	ofile.write("\nBitmapBuffer %s {" % bitmap_name)
	ofile.write("\n\tfile= \"%s\";" % filename)
	ofile.write("\n\tcolor_space= %i;" % COLOR_SPACE[BitmapBuffer.color_space])
	ofile.write("\n\tinterpolation= %i;" % INTERPOLATION[BitmapBuffer.interpolation])
	ofile.write("\n\tallow_negative_colors= %i;" % BitmapBuffer.allow_negative_colors)
	ofile.write("\n\tfilter_type= %d;" % FILTER_TYPE[BitmapBuffer.filter_type])
	ofile.write("\n\tfilter_blur= %.3f;" % BitmapBuffer.filter_blur)
	ofile.write("\n\tuse_data_window= %i;" % BitmapBuffer.use_data_window)

	if BitmapBuffer.use_input_gamma:
		ofile.write("\n\tgamma= %s;" % p(SettingsColorMapping.input_gamma))
	else:
		ofile.write("\n\tgamma= %s;" % a(scene, BitmapBuffer.gamma))

	if texture.image.source == 'SEQUENCE':
		ofile.write("\n\tframe_sequence = 1;")
		sequence_frame = 0  # Init sequence frame to use in animation frame

		# Repeat type check
		if texture.image_user.use_cyclic:
			sequence_frame = (scene.frame_current-texture.image_user.frame_offset+texture.image_user.frame_start)%texture.image_user.frame_duration # movie start + current frame - offset
		else:
			sequence_length   = texture.image_user.frame_duration # Crop the sequence duration
			sequence_duration = sequence_length-texture.image_user.frame_start
			sequence_start    = texture.image_user.frame_start
			sequence_offset   = texture.image_user.frame_offset

			# Before sequence start in animation, it takes the first frame
			if scene.frame_current < sequence_offset:
				sequence_frame = sequence_start

			# After the last sequence frame played, it takes the last frame for the rest of the animation
			if scene.frame_current > sequence_duration+sequence_offset:
				sequence_frame = sequence_length

			# Inside the sequence range it uses the exact sequence frame
			if (scene.frame_current >= sequence_offset and scene.frame_current <= sequence_offset+sequence_duration):
				sequence_frame = sequence_start+scene.frame_current-sequence_offset

		ofile.write("\n\tframe_number= %s;" % a(scene,sequence_frame))
	ofile.write("\n}\n")

	return bitmap_name


def write(bus):
	TILE= {
		'NOTILE': 0,
		'TILEUV': 1,
		'TILEU':  2,
		'TILEV':  3,
	}

	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	VRayTexture= texture.vray
	VRaySlot=    texture.vray_slot

	if not texture.image:
		ob_prefix = "Object: %s => " % bus['node']['object'].name if 'object' in bus['node'] else ""
		debug(scene, "%sTexture: %s => Image file is not set!" % (ob_prefix, texture.name), error= True)
		return None

	bitmap= write_BitmapBuffer(bus)

	uvwgen= write_uvwgen(bus)

	ofile.write("\nTexBitmap %s {" % tex_name)
	ofile.write("\n\tbitmap= %s;" % bitmap)
	ofile.write("\n\tuvwgen= %s;" % uvwgen)
	ofile.write("\n\ttile= %d;" % TILE[VRayTexture.tile])
	PLUGINS['TEXTURE']['TexCommon'].write(bus)
	ofile.write("\n}\n")

	return tex_name

########NEW FILE########
__FILENAME__ = TexBulge
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexBulge'
PLUG= 'TexBulge'
NAME= 'Bulge'
DESC= "TexBulge."
PID=   18

PARAMS= (
	'uvwgen',
	'u_width',
	'v_width'
)


def add_properties(rna_pointer):
	class TexBulge(bpy.types.PropertyGroup):

		# use_3d_mapping
		use_3d_mapping= BoolProperty(
			name= "use 3d mapping",
			description= "",
			default= True
		)
		
		#  u_width: float = 0.1
		u_width= FloatProperty(
			name= "U width",
			description= "U width",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.1
		)

		#  v_width: float = 0.1
		v_width= FloatProperty(
			name= "V width",
			description= "V width",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.1
		)
		

	bpy.utils.register_class(TexBulge)

	rna_pointer.TexBulge= PointerProperty(
		name= "TexBulge",
		type=  TexBulge,
		description= "V-Ray TexBulge settings"
	)


def write(bus):
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexBulge= getattr(texture.vray, PLUG)
	
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen
		else:
			value= getattr(TexBulge, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexBulge(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexBulge= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexBulge, 'u_width')
		col.prop(TexBulge, 'v_width')


def GetRegClasses():
	return (
		VRAY_TP_TexBulge,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexCellular
#
# V-Ray/Blender
#
# http://vray.cgdo.ru
#
# Author: Andrey M. Izrantsev (aka bdancer)
# E-Mail: izrantsev@cgdo.ru
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
#



# Blender module
import bpy
from bpy.props import *

# V-Ray/Blender modules
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE   = 'TEXTURE'
ID     = 'TexCellular'
PLUG   = 'TexCellular'

NAME   = 'Cellular'
DESC   = "TexCellular"

PID    = 16

PARAMS = (
  'uvwgen',
	'center_color',
	'edge_color',
	'bg_color',
	'size',
	'spread',
	'density',
	'type',
	'low',
	'middle',
	'high',
	'fractal',
	'fractal_iterations',
	'fractal_roughness',
#	'components',
)


def add_properties(rna_pointer):
	class TexCellular(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(TexCellular)

	rna_pointer.TexCellular= PointerProperty(
		name= "TexCellular",
		type=  TexCellular,
		description= "V-Ray TexCellular settings"
	)

	# use_3d_mapping
	TexCellular.use_3d_mapping= BoolProperty(
		name= "use 3d mapping",
		description= "",
		default= True
	)

	# center_color: acolor texture
	TexCellular.center_color = FloatVectorProperty(
		name= "Center Color",
		description= "Center Color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1,1,1)
	)

	TexCellular.center_color_tex= StringProperty(
		name= "Center Color texture",
		description= "Center Color texture",
		default= ""
	)

	# edge_color: acolor texture
	TexCellular.edge_color = FloatVectorProperty(
		name= "Edge Color",
		description= "Edge Color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.5,0.5,0.5)
	)

	TexCellular.edge_color_tex= StringProperty(
		name= "Edge Color texture",
		description= "Edge Color texture",
		default= ""
	)

	# bg_color: acolor texture
	TexCellular.bg_color = FloatVectorProperty(
		name= "BG Color",
		description= "BG Color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0)
	)

	TexCellular.bg_color_tex= StringProperty(
		name= "BG Color texture",
		description= "BG Color texture",
		default= ""
	)

	# size: float = 0.2
	TexCellular.size= FloatProperty(
		name= "Cellular Size",
		description= "Cellular Size",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.2
	)

	# spread: float = 0.5
	TexCellular.spread= FloatProperty(
		name= "Spread",
		description= "Spread",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.5
	)

	# density: float = 0.25
	TexCellular.density= FloatProperty(
		name= "Density Amount",
		description= "Density Amount",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.25
	)

	# type: integer = 0, 0 = dots; 1 = chips; 2 = cells; 3 = chess cells; 4 = plasma
	TexCellular.type= EnumProperty(
		name= "Type",
		description= "Cellular type",
		items= (
			('DOTS',        "Dots",  ""), # 0
			('CHIPS',       "Chips", ""),
			('CELLS',       "Cells", ""),
			('CHESS_CELLS', "Chess Cells", ""),
			('PLASMA',      "Plasma", ""),
		),
		default= 'DOTS'
	)

	# low: float = 0, Low threshold (for the bg color)
	TexCellular.low= FloatProperty(
		name= "Low",
		description= "Low threshold (for the bg color)",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	# middle: float = 0.5, Middle threshold (for the edge color)
	TexCellular.middle= FloatProperty(
		name= "Middle",
		description= "Middle threshold (for the edge color)",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.5
	)

	# high: float = 1, High threshold (for the center color)
	TexCellular.high= FloatProperty(
		name= "High",
		description= "High threshold (for the center color)",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# fractal: bool = false
	TexCellular.fractal = BoolProperty(
		name= "Fractal",
		description= "Fractal",
		default= False
	)

	# fractal_iterations: float = 3, The number of fractal iterations
	TexCellular.fractal_iterations= FloatProperty(
		name= "Fractal Iterations",
		description= "Fractal Iterations",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 3
	)

	# fractal_roughness: float = 0, The fractal roughness (0.0f is very rough; 1.0 is smooth - i.e. no fractal)
	TexCellular.fractal_roughness= FloatProperty(
		name= "Fractal Roughness",
		description= "Fractal Roughness",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	# TODOO
	# components: output vector texture, 
	# Outputs (F(1), F(2), F(3)) (the distances to the three closest points in the cellular context)
	# as a Vector


'''
  OUTPUT
'''
def write(bus):

	TYPE= {
		'DOTS':    0,
		'CHIPS':    1,
		'CELLS': 2,
		'CHESS_CELLS': 3,
		'PLASMA': 4,
	}

	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexCellular= getattr(texture.vray, PLUG)

	mapped_keys= ('center_color', 'edge_color', 'bg_color')
	mapped_params= write_sub_textures(bus,
					  TexCellular,
					  [key+'_tex' for key in mapped_keys])

	ofile.write("\n%s %s {"%(PLUG, tex_name))

	PLUGINS['TEXTURE']['TexCommon'].write(bus)

	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen
		elif param == 'type':
			value=TYPE[TexCellular.type]
		elif param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']
		else:
			value= getattr(TexCellular, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))

	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexCellular(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex = context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui = context.region.width > ui.narrowui
		layout  = self.layout

		tex= context.texture
		TexCellular= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexCellular, 'center_color', text="Center Color")
		col.prop_search(TexCellular, 'center_color_tex',
						bpy.data,    'textures',
						text= "")

		if wide_ui:
			col= split.column(align= True)
		col.prop(TexCellular, 'edge_color', text="Edge Color")
		col.prop_search(TexCellular, 'edge_color_tex',
						bpy.data,    'textures',
						text= "")

		if wide_ui:
			col= split.column(align= True)
		col.prop(TexCellular, 'bg_color', text="BG Color")
		col.prop_search(TexCellular, 'bg_color_tex',
						bpy.data,    'textures',
						text= "")


		split= layout.split()
		col= split.column(align=True)
		col.prop(TexCellular, 'size', text="Size")
		col.prop(TexCellular, 'spread', text="Spread")
		col.prop(TexCellular, 'density', text="Density")

		if not wide_ui:
			split= layout.split()
		col= split.column(align=True)
		col.prop(TexCellular, 'type')

		split= layout.split()
		row= split.row(align=True)
		row.prop(TexCellular, 'low')
		row.prop(TexCellular, 'middle')
		row.prop(TexCellular, 'high')

		split= layout.split()
		col = split.column(align=True)
		col.prop(TexCellular, 'fractal', text="Fractal")
		if TexCellular.fractal:
			col.prop(TexCellular, 'fractal_iterations', text="Fractal Iterations")
			col.prop(TexCellular, 'fractal_roughness', text="Fractal Roughness")


def GetRegClasses():
	return (
		VRAY_TP_TexCellular,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexChecker
'''
  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexChecker'
PLUG= 'TexChecker'

NAME= 'Checker'
DESC= "TexChecker."

PID=   14

PARAMS= (
	'uvwgen',
	'white_color',
	'black_color',
	'contrast',
)


def add_properties(rna_pointer):
	class TexChecker(bpy.types.PropertyGroup):
		# white_color
		white_color= FloatVectorProperty(
			name= "White color",
			description= "The white checker color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (1,1,1)
		)

		white_color_tex= StringProperty(
			name= "White color",
			description= "The white checker color",
			default= ""
		)

		# black_color
		black_color= FloatVectorProperty(
			name= "Black color",
			description= "The black checker color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0,0,0)
		)

		black_color_tex= StringProperty(
			name= "Black color",
			description= "The black checker color",
			default= ""
		)

		# contrast
		contrast= FloatProperty(
			name= "Contrast",
			description= "Contrast value",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 2.0,
			precision= 3,
			default= 1.0
		)

		contrast_tex= StringProperty(
			name= "Contrast",
			description= "Contrast value",
			default= ""
		)

	bpy.utils.register_class(TexChecker)

	rna_pointer.TexChecker= PointerProperty(
		name= "TexChecker",
		type=  TexChecker,
		description= "V-Ray TexChecker settings"
	)


'''
  OUTPUT
'''
def write(bus):
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexChecker= getattr(texture.vray, PLUG)

	ofile.write("\n%s %s {"%(PLUG, tex_name))

	PLUGINS['TEXTURE']['TexCommon'].write(bus)

	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen
		else:
			value= getattr(TexChecker, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))

	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexChecker(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexChecker= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column()
		col.prop(TexChecker, 'white_color', text="")
		if wide_ui:
			col= split.column()
		col.prop(TexChecker, 'black_color', text="")

		split= layout.split()
		col= split.column()
		col.prop(TexChecker, 'contrast', slider= True)


def GetRegClasses():
	return (
		VRAY_TP_TexChecker,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexCloth
'''
  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexCloth'
PLUG= 'TexCloth'

NAME= 'Cloth'
DESC= "TexCloth."

PID=   13

PARAMS= (
	'uvwgen',
	'gap_color',
	'u_color',
	'v_color',
	'u_width',
	'v_width',
	'u_wave',
	'v_wave',
	'randomness',
	'width_spread',
	'bright_spread',
)


def add_properties(rna_pointer):
	class TexCloth(bpy.types.PropertyGroup):
		# gap_color
		gap_color= FloatVectorProperty(
			name= "Gap",
			description= "Gap color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0.1,0.1,0.1)
		)

		gap_color_tex= StringProperty(
			name= "gap color",
			description= "",
			default= ""
		)

		# u_color
		u_color= FloatVectorProperty(
			name= "U",
			description= "U color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0.5,0.5,0.5)
		)

		u_color_tex= StringProperty(
			name= "u color",
			description= "",
			default= ""
		)

		# v_color
		v_color= FloatVectorProperty(
			name= "V",
			description= "V color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (1,1,1)
		)

		v_color_tex= StringProperty(
			name= "v color",
			description= "",
			default= ""
		)

		# u_width
		u_width= FloatProperty(
			name= "U width",
			description= "U width",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			default= 1.0
		)

		u_width_tex= StringProperty(
			name= "u width",
			description= "",
			default= ""
		)

		# v_width
		v_width= FloatProperty(
			name= "V width",
			description= "V width",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			default= 1.0
		)

		v_width_tex= StringProperty(
			name= "v width",
			description= "",
			default= ""
		)

		# u_wave
		u_wave= FloatProperty(
			name= "U wave",
			description= "U wave",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			default= 1.0
		)

		u_wave_tex= StringProperty(
			name= "u wave",
			description= "",
			default= ""
		)

		# v_wave
		v_wave= FloatProperty(
			name= "V wave",
			description= "V wave",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 100.0,
			default= 1.0
		)

		v_wave_tex= StringProperty(
			name= "v wave",
			description= "",
			default= ""
		)

		# randomness
		randomness= FloatProperty(
			name= "Randomness",
			description= "Randomness",
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= 0.0
		)

		randomness_tex= StringProperty(
			name= "randomness",
			description= "",
			default= ""
		)

		# width_spread
		width_spread= FloatProperty(
			name= "Width spread",
			description= "Width spread",
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= 1.0
		)

		width_spread_tex= StringProperty(
			name= "width spread",
			description= "",
			default= ""
		)

		# bright_spread
		bright_spread= FloatProperty(
			name= "Bright spread",
			description= "Bright spread",
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= 1.0
		)

		bright_spread_tex= StringProperty(
			name= "bright spread",
			description= "",
			default= ""
		)

	bpy.utils.register_class(TexCloth)

	rna_pointer.TexCloth= PointerProperty(
		name= "TexCloth",
		type=  TexCloth,
		description= "V-Ray TexCloth settings"
	)


'''
  OUTPUT
'''
def write(bus):
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexCloth= getattr(texture.vray, PLUG)

	ofile.write("\n%s %s {"%(PLUG, tex_name))

	PLUGINS['TEXTURE']['TexCommon'].write(bus)

	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen
		else:
			value= getattr(TexCloth, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))

	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexCloth(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexCloth= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column()
		col.prop(TexCloth, 'gap_color', text= "")
		if wide_ui:
			col= split.column()
		col.prop(TexCloth, 'randomness', slider= True)

		split= layout.split()
		col= split.column()
		sub= col.column(align= True)
		sub.prop(TexCloth, 'u_color')
		sub.prop(TexCloth, 'u_width', text="Width")
		sub.prop(TexCloth, 'u_wave', text="Wave")
		if wide_ui:
			col= split.column()
		sub= col.column(align= True)
		sub.prop(TexCloth, 'v_color')
		sub.prop(TexCloth, 'v_width', text="Width")
		sub.prop(TexCloth, 'v_wave', text="Wave")

		split= layout.split()
		col= split.column()
		col.prop(TexCloth, 'width_spread', slider= True)
		if wide_ui:
			col= split.column()
		col.prop(TexCloth, 'bright_spread', slider= True)


def GetRegClasses():
	return (
		VRAY_TP_TexCloth,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexCommon
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE= 'TEXTURE'
ID=   'TexCommon'

NAME= 'Common texture setings'
DESC= "Common V-Ray Texture settings."

PARAMS= (
)


def update_blender_mapping_type(self, context):
	if not hasattr(context, 'texture_slot'):
		return
	if not context.texture_slot:
		return
	if self.texture_coords == 'WORLD':
		return
	context.texture_slot.texture_coords = self.texture_coords


def add_properties(rna_pointer):
	rna_pointer.name= StringProperty(
		name= "V-Ray Texture name",
		description= "V-Ray texture name for internal usage",
		subtype= 'NONE',
		options= {'HIDDEN'},
		default= ""
	)

	rna_pointer.texture_coords= EnumProperty(
		name= "Coords",
		description= "Image texure placement type",
		items= (
			('ORCO',  "Object", "Generated coordinates."),
			('UV',    "UV",     "Mesh UV coordinates."),
			('WORLD', "World",  "World coordinates."),
		),
		default= 'ORCO',
		update= update_blender_mapping_type
	)

	rna_pointer.mapping= EnumProperty(
		name= "Projection",
		description= "Generated projection type",
		items= (
			('FLAT',   "Flat",        "Planar projection."),
			('CUBE',   "Cube",        "Cubic projection."),
			('SPHERE', "Sphere",      "Spherical projection."),
			('TUBE',   "Tube",        "Cylindrical projection."),
			('BALL',   "Ball",        "Ball projection."),
			('TRI',    "Triplanar",   "Triplanar projection."),
			('PERS',   "Perspective", "Perspective projection."),
		),
		default= 'FLAT'
	)

	rna_pointer.environment_mapping= EnumProperty(
		name= "Projection",
		description= "Generated projection type",
		items= (
			('SCREEN',  "Screen",      "Planar projection."),
			('CUBIC',   "Cube",        "Cubic projection."),
			('SPHERE',  "Sphere",      "Spherical projection."),
			('TUBE',    "Tube",        "Cylindrical projection."),
			('ANGULAR', "Angular",     "Angular projection."),
			('MBALL',   "Mirror ball", "Mirror ball projection."),
		),
		default= 'SPHERE'
	)

	rna_pointer.object= StringProperty(
		name= "Mapping Object",
		description= "Object to use for mapping generation",
		subtype= 'NONE',
		options= {'HIDDEN'},
		default= ""
	)

	rna_pointer.tile= EnumProperty(
		name= "Tile",
		description= "Tile type",
		items= (
			('NOTILE', "No tile", "No tiling."),
			('TILEUV', "Tile UV", "Tile in UV."),
			('TILEU',  "Tile U",  "Tile in U."),
			('TILEV',  "Tile V",  "Tile in V."),
		),
		default= 'TILEUV'
	)

	rna_pointer.remove_alpha= BoolProperty(
		name= "Remove alpha",
		description= "Reset alpha channel",
		default= False
	)

	# use_3d_mapping
	rna_pointer.use_3d_mapping= BoolProperty(
		name= "Use 3D mapping",
		description= "Use 3D mapping",
		default= True
	)

	# wrap
	rna_pointer.wrap= BoolProperty(
		name= "Wrap",
		description= "",
		default= True
	)

	# alpha_from_intensity
	rna_pointer.alpha_from_intensity= BoolProperty(
		name= "Alpha from intensity",
		description= "If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha",
		default= False
	)

	# invert
	rna_pointer.invert= BoolProperty(
		name= "Invert",
		description= "If true, the resulting texture color will be inverted",
		default= False
	)

	# invert_alpha
	rna_pointer.invert_alpha= BoolProperty(
		name= "Invert alpha",
		description= "If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted",
		default= True
	)

	# color_mult
	# rna_pointer.color_mult= FloatVectorProperty(
	# 	name= "Color mult",
	# 	description= "A multiplier for the texture color",
	# 	subtype= 'COLOR',
	# 	min= 0.0,
	# 	max= 1.0,
	# 	soft_min= 0.0,
	# 	soft_max= 1.0,
	# 	default= (1,1,1)
	# )
	rna_pointer.color_mult= FloatProperty(
		name= "Color mult",
		description= "A multiplier for the texture color",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 2.0,
		default= 1.0
	)

	# color_offset
	# rna_pointer.color_offset= FloatVectorProperty(
	# 	name= "Color offset",
	# 	description= "An additional offset for the texture color",
	# 	subtype= 'COLOR',
	# 	min= 0.0,
	# 	max= 1.0,
	# 	soft_min= 0.0,
	# 	soft_max= 1.0,
	# 	default= (0,0,0)
	# )
	rna_pointer.color_offset= FloatProperty(
		name= "Color offset",
		description= "An additional offset for the texture color",
		min= -1.0,
		max=  1.0,
		soft_min= -1.0,
		soft_max= 1.0,
		default= 0.0
	)

	# alpha_mult
	rna_pointer.alpha_mult= FloatProperty(
		name= "Alpha mult",
		description= "A multiplier for the texture alpha",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 2.0,
		default= 1.0
	)

	# alpha_offset
	rna_pointer.alpha_offset= FloatProperty(
		name= "Alpha offset",
		description= "An additional offset for the texture alpha",
		min= -1.0,
		max=  1.0,
		soft_min= -1.0,
		soft_max= 1.0,
		default= 0
	)

	# nouvw_color
	rna_pointer.nouvw_color= FloatVectorProperty(
		name= "No UV color",
		description= "The color when there are no valid uvw coordinates",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.5,0.5,0.5)
	)

	# uvwgen
	rna_pointer.uvwgen= StringProperty(
		name= "UVW generator",
		description= "UVW generator",
		default= ""
	)

	# placement_type
	rna_pointer.placement_type= EnumProperty(
		name= "Placement type",
		description= "Image texure placement type",
		items= (
			('FULL', "Full",  "The whole texture is valid."),
			('CROP', "Crop",  "Crop texture."),
			('PLACE',"Place", "Place texture."),
		),
		default= 'FULL'
	)

	# u
	rna_pointer.u= FloatProperty(
		name= "U",
		description= "U coordinate of the valid texture sector",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	# v
	rna_pointer.v= FloatProperty(
		name= "V",
		description= "V coordinate of the valid texture sector",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	# w
	rna_pointer.w= FloatProperty(
		name= "W",
		description= "Width of the valid texture sector",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# h
	rna_pointer.h= FloatProperty(
		name= "H",
		description= "Height of the valid texture sector",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# jitter
	rna_pointer.jitter= FloatProperty(
		name= "Jitter",
		description= "Amount of random placement variation",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	# tile_u
	rna_pointer.tile_u= FloatProperty(
		name        = "Tile U",
		description = "Tile in U",
		min         = 0.0,
		max         = 1000.0,
		soft_min    = 1,
		soft_max    = 20.0,
		default     = 1.0
	)
	rna_pointer.mirror_u= BoolProperty(
		name= "Mirror U",
		description= "Mirror in U",
		default= False
	)

	# tile_v
	rna_pointer.tile_v= FloatProperty(
		name        = "Tile V",
		description = "Tile in V",
		min         = 0.0,
		max         = 1000.0,
		soft_min    = 1.0,
		soft_max    = 20.0,
		default     = 1.0
	)

	rna_pointer.mirror_v= BoolProperty(
		name= "Mirror V",
		description= "Mirror in V",
		default= False
	)

	# uv_noise_on
	rna_pointer.uv_noise_on= BoolProperty(
		name= "Use",
		description= "If true the noise is enabled",
		default= 0
	)

	# uv_noise_animate
	rna_pointer.uv_noise_animate= BoolProperty(
		name= "Animate",
		description= "If true the noise is animated",
		default= False
	)

	# uv_noise_amount
	rna_pointer.uv_noise_amount= FloatProperty(
		name= "Amount",
		description= "UV noise amount",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# uv_noise_levels
	rna_pointer.uv_noise_levels= FloatProperty(
		name= "Levels",
		description= "UV noise iterations",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# uv_noise_size
	rna_pointer.uv_noise_size= FloatProperty(
		name= "Size",
		description= "UV noise size",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# un_noise_phase
	rna_pointer.un_noise_phase= FloatProperty(
		name= "Phase",
		description= "UV noise phase",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)



'''
  OUTPUT
'''
def write(bus):
	PLACEMENT_TYPE= {
		'FULL':  0,
		'CROP':  1,
		'PLACE': 2,
	}
	TILE= {
		'NOTILE': (0,0),
		'TILEUV': (1,1),
		'TILEU':  (1,0),
		'TILEV':  (0,1),
	}

	ofile= bus['files']['textures']
	scene= bus['scene']

	slot=    bus['mtex']['slot']
	texture= bus['mtex']['texture']

	VRayTexture= texture.vray
	VRaySlot=    texture.vray_slot

	if VRayTexture.type not in ('TexFalloff'):
		ofile.write("\n\tplacement_type= %i;" % PLACEMENT_TYPE[VRayTexture.placement_type])
		ofile.write("\n\ttile_u= %d;\n\ttile_v= %d;" % TILE[VRayTexture.tile])
		ofile.write("\n\tu= %s;" % a(scene, VRayTexture.u))
		ofile.write("\n\tv= %s;" % a(scene, VRayTexture.v))
		ofile.write("\n\tw= %s;" % a(scene, VRayTexture.w))
		ofile.write("\n\th= %s;" % a(scene, VRayTexture.h))
		ofile.write("\n\tjitter= %s;" % a(scene, VRayTexture.jitter))
		ofile.write("\n\tuv_noise_on= %s;" % a(scene, VRayTexture.uv_noise_on))
		ofile.write("\n\tuv_noise_animate= %s;" % a(scene, VRayTexture.uv_noise_animate))
		ofile.write("\n\tun_noise_phase= %s;" % a(scene, VRayTexture.un_noise_phase))
		ofile.write("\n\tuv_noise_amount= %s;" % a(scene, VRayTexture.uv_noise_amount))
		ofile.write("\n\tuv_noise_levels= %s;" % a(scene, VRayTexture.uv_noise_levels))
		ofile.write("\n\tuv_noise_size= %s;" % a(scene, VRayTexture.uv_noise_size))

	ofile.write("\n\tinvert= %s;" % a(scene, VRayTexture.invert))
	ofile.write("\n\tcolor_mult= %s;" % a(scene, mathutils.Color([VRayTexture.color_mult]*3)))
	ofile.write("\n\tcolor_offset= %s;" % a(scene, mathutils.Color([VRayTexture.color_offset]*3)))
	ofile.write("\n\tinvert_alpha= %s;" % a(scene, VRayTexture.invert_alpha))
	ofile.write("\n\talpha_mult= %s;" % a(scene, VRayTexture.alpha_mult))
	ofile.write("\n\talpha_offset= %s;" % a(scene, VRayTexture.alpha_offset))
	ofile.write("\n\talpha_from_intensity= %s;" % a(scene, VRayTexture.alpha_from_intensity))
	ofile.write("\n\tnouvw_color= %s;" % a(scene, VRayTexture.nouvw_color))

	if texture.type == 'VRAY':
		if hasattr(VRayTexture, VRayTexture.type):
			TexPlugin= getattr(VRayTexture, VRayTexture.type)

			if hasattr(TexPlugin, 'wrap'):
				ofile.write("\n\twrap= %s;" % a(scene, VRayTexture.wrap))

			if hasattr(TexPlugin, 'use_3d_mapping'):
				ofile.write("\n\tuse_3d_mapping= %s;" % a(scene, VRayTexture.use_3d_mapping))



'''
  GUI
'''
class VRAY_TP_Mapping(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = "Mapping"
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		if not ui.engine_poll(cls, context):
			return False

		tex= context.texture
		if not tex:
			return False

		if tex.type == 'VRAY':
			if tex.vray.type != 'NONE' and tex.vray.type not in PURE_PROCEDURAL:
				return True

		if tex.type == 'IMAGE':
			if tex.image:
				return True

		return False

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		idblock = ui.context_tex_datablock(context)

		ob=   context.object
		sce=  context.scene

		slot= getattr(context, 'texture_slot', None)
		tex=  slot.texture if slot else context.texture

		VRayTexture= tex.vray
		VRaySlot=    tex.vray_slot

		TexPlugin= getattr(VRayTexture, VRayTexture.type) if tex.type == 'VRAY' else None

		if issubclass(type(idblock), bpy.types.Material):
			if wide_ui:
				layout.prop(VRayTexture, 'texture_coords', expand=True)
			else:
				layout.prop(VRayTexture, 'texture_coords')

			if VRayTexture.texture_coords == 'UV':
				if slot:
					split= layout.split(percentage=0.3)
					split.label(text="Layer:")
					if ob and ob.type == 'MESH':
						split.prop_search(slot,    'uv_layer',
										  ob.data, 'uv_textures',
										  text="")
					else:
						split.prop(slot, 'uv_layer', text="")
			elif VRayTexture.texture_coords == 'ORCO':
				split= layout.split(percentage=0.3)
				split.label(text="Projection:")
				split.prop(VRayTexture, 'mapping', text="")
				split= layout.split(percentage=0.3)
				split.label(text="Object:")
				split.prop_search(VRayTexture, 'object',
								  sce,         'objects',
								  text="")

			if slot:
				split= layout.split()
				col= split.column()
				col.label(text="Offset:")
				if wide_ui:
					sub= col.row()
				else:
					sub= col.column()
				sub.prop(slot, 'offset', text="")

				split= layout.split()
				col= split.column()
				col.label(text="Scale:")
				if wide_ui:
					sub= col.row()
				else:
					sub= col.column()
				sub.prop(slot, 'scale', text="")

			layout.separator()

			split= layout.split()
			col= split.column()
			col.prop(VRaySlot, 'texture_rot')
			if wide_ui:
				col= split.column()
			col.prop(VRayTexture, 'jitter')

			layout.separator()

			split= layout.split()
			col= split.column()
			if TexPlugin:
				if hasattr(TexPlugin, 'use_3d_mapping') or hasattr(TexPlugin, 'wrap'):
					layout.separator()
				if hasattr(TexPlugin, 'use_3d_mapping'):
					col.prop(VRayTexture, 'use_3d_mapping')
				if wide_ui:
					col= split.column()
				if hasattr(TexPlugin, 'wrap'):
					col.prop(VRayTexture, 'wrap')

			box= layout.box()
			box.prop(VRayTexture, 'uv_noise_on', text= "UV noise")
			if VRayTexture.uv_noise_on:
				split= box.split()
				split.active= VRayTexture.uv_noise_on
				col= split.column()
				col.prop(VRayTexture, 'uv_noise_animate')
				col.prop(VRayTexture, 'un_noise_phase')
				if wide_ui:
					col= split.column()
				col.prop(VRayTexture, 'uv_noise_amount')
				col.prop(VRayTexture, 'uv_noise_levels')
				col.prop(VRayTexture, 'uv_noise_size')

		elif issubclass(type(idblock), bpy.types.World):
			split= layout.split(percentage=0.3)
			split.label(text="Projection:")
			split.prop(VRayTexture, 'environment_mapping', text="")

			layout.label(text="Rotation:")
			split= layout.split()
			col= split.column()
			col.prop(VRaySlot, 'texture_rotation_h', slider= True, text="Horizontal")
			col.prop(VRaySlot, 'texture_rotation_v', slider= True, text="Vertical")
			#col.prop(VRaySlot, 'texture_rotation_w', slider= True, text="X")

		elif issubclass(type(idblock), bpy.types.Lamp):
			split= layout.split(percentage=0.3)
			split.label(text="Projection:")
			split.prop(VRayTexture, 'environment_mapping', text="")

			layout.label(text="Rotation:")
			split= layout.split()
			col= split.column()
			col.prop(VRaySlot, 'texture_rotation_h', slider= True, text="Horizontal")
			col.prop(VRaySlot, 'texture_rotation_v', slider= True, text="Vertical")
			#col.prop(VRaySlot, 'texture_rotation_w', slider= True, text="X")



class VRAY_TP_Tiling(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = "Tiling"
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		if not ui.engine_poll(cls, context):
			return False

		tex= context.texture
		if not tex:
			return False

		if tex.type == 'VRAY':
			if tex.vray.type != 'NONE' and tex.vray.type not in PURE_PROCEDURAL:
				return True

		if tex.type == 'IMAGE':
			if tex.image:
				return True

		return False

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		idblock = ui.context_tex_datablock(context)

		ob=   context.object
		sce=  context.scene

		slot= getattr(context, 'texture_slot', None)
		tex=  slot.texture if slot else context.texture

		VRayTexture= tex.vray
		VRaySlot=    tex.vray_slot

		TexPlugin= getattr(VRayTexture, VRayTexture.type) if tex.type == 'VRAY' else None

		if wide_ui:
			layout.prop(VRayTexture, 'tile', expand=True)
		else:
			layout.prop(VRayTexture, 'tile')

		if VRayTexture.tile != 'NOTILE':
			split = layout.split()
			col= split.column()
			col.label(text="Tile:")
			sub= col.row(align=True)
			sub_u= sub.row()
			sub_u.active= VRayTexture.tile in ('TILEUV','TILEU')
			sub_u.prop(VRayTexture, 'tile_u', text='U')
			sub_v= sub.row()
			sub_v.active= VRayTexture.tile in ('TILEUV','TILEV')
			sub_v.prop(VRayTexture, 'tile_v', text='V')

			if wide_ui:
				col= split.column()

			col.label(text="Mirror:")
			sub= col.row(align=True)
			sub_u= sub.row()
			sub_u.active= VRayTexture.tile in ('TILEUV','TILEU')
			sub_u.prop(VRayTexture, 'mirror_u', text='U')
			sub_v= sub.row()
			sub_v.active= VRayTexture.tile in ('TILEUV','TILEV')
			sub_v.prop(VRayTexture, 'mirror_v', text='V')

		layout.separator()

		if wide_ui:
			layout.prop(VRayTexture, 'placement_type', expand=True)
		else:
			layout.prop(VRayTexture, 'placement_type')

		if VRayTexture.placement_type not in ('FULL'):
			split = layout.split()
			col= split.column()
			col.label(text="Crop Minimum:")
			sub= col.row(align=True)
			sub.prop(VRayTexture, 'u')
			sub.prop(VRayTexture, 'v')
			if wide_ui:
				col= split.column()
			col.label(text="Crop Maximum:")
			sub= col.row(align=True)
			sub.prop(VRayTexture, 'w')
			sub.prop(VRayTexture, 'h')


class VRAY_TP_Common(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = "Common"
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		if not ui.engine_poll(cls, context):
			return False

		tex= context.texture
		if not tex:
			return False

		if tex.type == 'VRAY':
			if tex.vray.type != 'NONE' and tex.vray.type not in PURE_PROCEDURAL:
				return True

		if tex.type == 'IMAGE':
			if tex.image:
				return True

		return False

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		slot= getattr(context, 'texture_slot', None)
		tex=  slot.texture if slot else context.texture

		VRayTexture= tex.vray

		TexPlugin= getattr(VRayTexture, VRayTexture.type) if tex.type == 'VRAY' else None

		split= layout.split()
		col= split.column()
		col.label(text="Color:")
		sub= col.column(align= True)
		sub.prop(VRayTexture, 'color_mult', text="Mult", slider= True)
		sub.prop(VRayTexture, 'color_offset', text="Offset", slider= True)
		col.prop(VRayTexture, 'invert')
		# col.prop(VRayTexture, 'nouvw_color', text="")
		if wide_ui:
			col= split.column()
		col.label(text="Alpha:")
		sub= col.column(align= True)
		sub.prop(VRayTexture, 'alpha_mult', text="Mult", slider= True)
		sub.prop(VRayTexture, 'alpha_offset', text="Offset", slider= True)
		sub= col.column()
		sub.active= VRayTexture.invert
		sub.prop(VRayTexture, 'invert_alpha')
		# col.prop(VRayTexture, 'remove_alpha')
		col.prop(VRayTexture, 'alpha_from_intensity')

		# layout.separator()
		# layout.operator("vray.bake_procedural", icon= 'TEXTURE')


def GetRegClasses():
	return (
		VRAY_TP_Mapping,
		VRAY_TP_Tiling,
		VRAY_TP_Common,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexCompMax
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexCompMax'
PLUG= 'TexCompMax'
NAME= 'Comp Max'
DESC= "Comp Max."
PID=   32

PARAMS= (
	'sourceA',
	'sourceB',
	'operator',
)


def add_properties(rna_pointer):
	class TexCompMax(bpy.types.PropertyGroup):

		#  sourceA: acolor texture, Left hand side texture.
		sourceA = FloatVectorProperty(
			name        = "Source A",
			description = "Left hand side texture",
			subtype     = 'COLOR',
			size        = 4,
			min         = 0.0,
			max         = 1.0,
			soft_min    = 0.0,
			soft_max    = 1.0,
			default     = (1,1,1,1)
		)

		sourceA_tex = StringProperty(
			name        = "Source A Texture",
			description = "Source A Texture",
			default     = ""
		)

		#  sourceB: acolor texture, Right hand side texture.
		sourceB = FloatVectorProperty(
			name        = "Source B",
			description = "Right hand side texture",
			subtype     = 'COLOR',
			size        = 4,
			min         = 0.0,
			max         = 1.0,
			soft_min    = 0.0,
			soft_max    = 1.0,
			default     = (1, 1, 1, 1)
		)

		sourceB_tex = StringProperty(
			name        = "Source B Texture",
			description = "Source B Texture",
			default     = ""
		)
		
		#  operator: integer = 0, 0:Add, 1:Subtract, 2:Difference, 3:Multiply, 4:Divide, 5:Minimum, 6:Maximum
		operator = EnumProperty(
			name        = "Operator",
			description = "Operator",
			items       = (
						  ('ADD',   "Add",        ""), 
						  ('SUB',   "Subtract",   ""),
						  ('DIFF',  "Difference", ""),
						  ('MULT',  "Multiply",   ""),
						  ('DIV',   "Divide",     ""),
						  ('MIN',   "Minimum",    ""),
						  ('MAX',   "Maximum",    ""),
			),
			default = 'ADD'
		)		

		

	bpy.utils.register_class(TexCompMax)

	rna_pointer.TexCompMax= PointerProperty(
		name        = "TexCompMax",
		type        =  TexCompMax,
		description = "V-Ray TexCompMax settings"
	)


def write(bus):

	OPERATOR = {
		'ADD':  0,
		'SUB':  1,
		'DIFF': 2,
		'MULT': 3,
		'DIV':  4,
		'MIN':  5,
		'MAX':  6,
	}


	scene = bus['scene']
	ofile = bus['files']['textures']

	slot     = bus['mtex']['slot']
	texture  = bus['mtex']['texture']
	tex_name = bus['mtex']['name']

	TexCompMax= getattr(texture.vray, PLUG)

	mapped_keys= ('sourceA', 'sourceB')
	mapped_params= write_sub_textures(bus,
					  TexCompMax,
					  [key+'_tex' for key in mapped_keys])
	
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'operator':
			value=OPERATOR[TexCompMax.operator]
		elif param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']
		else:
			value= getattr(TexCompMax, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name

'''
  GUI
'''
class VRAY_TP_TexCompMax(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexCompMax= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexCompMax, 'sourceA', text="Source A")
		col.prop_search(TexCompMax, 'sourceA_tex',
						bpy.data,    'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexCompMax, 'sourceB', text="Source B")
		col.prop_search(TexCompMax, 'sourceB_tex',
						bpy.data,   'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexCompMax, 'operator', text="Operator")


def GetRegClasses():
	return (
		VRAY_TP_TexCompMax,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexDirt
#
# V-Ray/Blender
#
# http://vray.cgdo.ru
#
# Author: Andrei Izrantcev
# E-Mail: andrei.izrantcev@chaosgroup.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
#

# Blender modules
import bpy
from bpy.props import *

# V-Ray/Blender modules
from vb25.utils import *
from vb25.shaders import *
from vb25.ui import ui


TYPE = 'TEXTURE'

ID   = 'TexDirt'
NAME = 'Dirt'
PLUG = 'TexDirt'
DESC = "TODO."
PID  =  0

PARAMS = (
    'affect_reflection_elements', # false bool // true to add the occlusion to relection render elements when mode>0
    'affect_result_nodes', # list plugin
    'affect_result_nodes_inclusive', # false bool // if true the affect_result_nodes list is inclusive
    'bias_x', # 0 float
    'bias_y', # 0 float
    'bias_z', # 0 float
    'black_color', #  acolor texture
    'consider_same_object_only', # false bool
    'distribution', # 0 float
    'double_sided', # false bool // if true, the occlusion on both sides of the surface will be calculated
    'environment_occlusion', # false bool // true to compute the environment for unoccluded samples
    'falloff', # 0 float
    'glossiness', #  float texture // A texture for the glossiness when mode>0
    'ignore_for_gi', # true bool
    'ignore_self_occlusion', # false bool
    'invert_normal', # false bool
    'mode', # 0 integer // Mode (0 - ambient occlusion; 1 - Phong reflection occlusion; 2 - Blinn reflection occlusion; 3 - Ward reflection occlusion)
    'radius', # 10 float texture
    'render_nodes', # list plugin
    'render_nodes_inclusive', # false bool // if true the render_nodes list is inclusive
    'subdivs', # 8 integer
    'white_color', #  acolor texture
    'work_with_transparency', # false bool
)


class TexDirt(bpy.types.PropertyGroup):
    double_sided = BoolProperty(
        name        = "Double Sided",
        description = "If true, the occlusion on both sides of the surface will be calculated",
        default     = False
    )

    render_nodes = bpy.props.StringProperty(
        name        = "Render nodes",
        description = "Render node list",
        default     = ''
    )

    render_nodes_inclusive = bpy.props.BoolProperty(
        name        = "Inclusive",
        description = "Render node list is inclusive",
        default     = False
    )

    affect_result_nodes = bpy.props.StringProperty(
        name        = "Affect nodes",
        description = "Affect node list",
        default     = ''
    )

    affect_result_nodes_inclusive = bpy.props.BoolProperty(
        name        = "Inclusive",
        description = "Affect node list is inclusive",
        default     = False
    )

    white_color= FloatVectorProperty(
        name= "Unoccluded color",
        description= "Unoccluded color",
        subtype= 'COLOR',
        min= 0.0,
        max= 1.0,
        soft_min= 0.0,
        soft_max= 1.0,
        default= (1.0,1.0,1.0)
    )

    white_color_tex= StringProperty(
        name= "Unoccluded color texture",
        description= "Unoccluded color texture",
        default= ""
    )

    black_color= FloatVectorProperty(
        name= "Occluded color",
        description= "Occluded color",
        subtype= 'COLOR',
        min= 0.0,
        max= 1.0,
        soft_min= 0.0,
        soft_max= 1.0,
        default= (0.0,0.0,0.0)
    )

    black_color_tex= StringProperty(
        name= "Occluded color texture",
        description= "Occluded color texture",
        default= ""
    )

    radius= FloatProperty(
        name= "Radius",
        description= "Radius",
        min= 0.0,
        max= 1000.0,
        soft_min= 0.0,
        soft_max= 100.0,
        precision= 3,
        default= 0.1
    )

    radius_tex= StringProperty(
        name= "Radius Texture",
        description= "Radius Texture",
        default= ""
    )

    distribution= FloatProperty(
        name= "Distribution",
        description= "Distribution",
        min= 0.0,
        max= 100.0,
        soft_min= 0.0,
        soft_max= 10.0,
        precision= 3,
        default= 0
    )

    falloff= FloatProperty(
        name= "Falloff",
        description= "Falloff",
        min= 0.0,
        max= 100.0,
        soft_min= 0.0,
        soft_max= 10.0,
        precision= 3,
        default= 0
    )

    subdivs= IntProperty(
        name= "Subdivs",
        description= "Subdivs",
        min= 0,
        max= 100,
        soft_min= 0,
        soft_max= 10,
        default= 8
    )

    bias_x= FloatProperty(
        name= "Bias X",
        description= "Bias Z",
        min= -100.0,
        max= 100.0,
        soft_min= -10.0,
        soft_max= 10.0,
        precision= 3,
        default= 0
    )

    bias_y= FloatProperty(
        name= "Bias Y",
        description= "Bias Y",
        min= -100.0,
        max= 100.0,
        soft_min= -10.0,
        soft_max= 10.0,
        precision= 3,
        default= 0
    )

    bias_z= FloatProperty(
        name= "Bias Z",
        description= "Bias Z",
        min= -100.0,
        max= 100.0,
        soft_min= -10.0,
        soft_max= 10.0,
        precision= 3,
        default= 0
    )

    ignore_for_gi= BoolProperty(
        name= "Ignore for GI",
        description= "Ignore for GI",
        default= True
    )

    consider_same_object_only= BoolProperty(
        name= "Consider same object only",
        description= "Consider same object only",
        default= False
    )

    invert_normal= BoolProperty(
        name= "Invert normal",
        description= "Invert normal",
        default= False
    )

    work_with_transparency= BoolProperty(
        name= "Work with transparency",
        description= "Work with transparency",
        default= False
    )

    ignore_self_occlusion= BoolProperty(
        name= "Ignore self occlusion",
        description= "Ignore self occlusion",
        default= False
    )

    mode= EnumProperty(
        name= "Mode",
        description= "Mode",
        items= (
            ('AO',"Ambient occlusion",""),
            ('PHONG',"Phong reflection occlusion",""),
            ('BLINN',"Blinn reflection occlusion",""),
            ('WARD',"Ward reflection occlusion","")
        ),
        default= 'AO'
    )

    environment_occlusion= BoolProperty(
        name= "Environment occlusion",
        description= "Compute the environment for unoccluded samples",
        default= False
    )

    affect_reflection_elements= BoolProperty(
        name= "Affect reflection elements",
        description= "Add the occlusion to relection render elements when mode>0",
        default= False
    )

    glossiness= FloatProperty(
        name= "Glossiness",
        description= "The spread of the rays traced for reflection occlusion",
        min= 0.0,
        max= 100.0,
        soft_min= 0.0,
        soft_max= 10.0,
        precision= 3,
        default= 1.0
    )


def add_properties(VRayTexture):
    VRayTexture.TexDirt = PointerProperty(
        name        = "TexDirt",
        type        =  TexDirt,
        description = "V-Ray TexDirt settings"
    )


def write(bus):
    MODE = {
        'AO'    : 0,
        'PHONG' : 1,
        'BLINN' : 2,
        'WARD'  : 3
    }

    scene = bus['scene']
    ofile = bus['files']['textures']

    slot     = bus['mtex']['slot']
    texture  = bus['mtex']['texture']
    tex_name = bus['mtex']['name']

    TexDirt = getattr(texture.vray, PLUG)

    mapped_params = write_sub_textures(bus, TexDirt, ('white_color_tex', 'black_color_tex', 'radius_tex'))

    radiusTexture      = None
    radiusTextureFloat = None
    if 'radius_tex' in mapped_params:
        radiusTexture = tex_name + "Radius"
        radiusTextureFloat = radiusTexture + "::product"

        ofile.write("\nTexFloatOp %s {" % radiusTexture)
        ofile.write("\n\tfloat_a=%s::out_intensity;" % mapped_params['radius_tex'])
        ofile.write("\n\tfloat_b=%s;" % a(scene, TexDirt.radius))
        ofile.write("\n}\n")

    ofile.write("\n%s %s {"%(PLUG, tex_name))
    for param in PARAMS:
        if not hasattr(TexDirt, param):
            debug(scene, "Unimplemented parameter: %s" % (param))
            continue
        
        value = getattr(TexDirt, param)
        
        if param == 'mode':
            value = MODE[TexDirt.mode]
        if param in ('render_nodes', 'affect_result_nodes'):
            nodeGroups = getattr(TexDirt, param)
            if not nodeGroups:
                continue
            value = "List(%s)" % ",".join([get_name(ob, prefix='OB') for ob in generate_object_list(None, nodeGroups)])
            ofile.write("\n\t%s=%s;" % (param, value))
            continue
        elif param == 'radius':
            if radiusTexture:
                ofile.write("\n\tradius=%s;" % radiusTextureFloat)
        elif param in ('white_color','black_color'):
            tex_key = param+'_tex'
            if tex_key in mapped_params:
                ofile.write("\n\t%s=%s;"%(param, mapped_params[tex_key]))
                continue
            else:
                pass
        ofile.write("\n\t%s=%s;"%(param, a(scene, value)))
    ofile.write("\n}\n")

    return tex_name



'''
  GUI
'''
class TEXTURE_PT_TexDirt(ui.VRayTexturePanel, bpy.types.Panel):
    bl_label = NAME

    COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

    @classmethod
    def poll(cls, context):
        tex = context.texture
        if not tex:
            return False
        VRayTexture = tex.vray
        engine = context.scene.render.engine
        return ((tex and tex.type == 'VRAY' and VRayTexture.type == ID) and (ui.engine_poll(__class__, context)))
    
    def draw(self, context):
        tex  = context.texture
        TexDirt = getattr(tex.vray, PLUG)
        
        wide_ui = context.region.width > ui.narrowui

        layout = self.layout

        layout.prop(TexDirt, 'mode')

        split = layout.split()
        col = split.column(align=True)
        col.prop(TexDirt, 'white_color')
        col.prop_search(TexDirt, 'white_color_tex',
                        bpy.data, 'textures',
                        text="")
        if wide_ui:
            col = split.column(align=True)
        col.prop(TexDirt,'black_color')
        col.prop_search(TexDirt, 'black_color_tex',
                        bpy.data, 'textures',
                        text="")

        layout.separator()

        split = layout.split()
        col = split.column()
        sub_radius = col.column(align=True)
        sub_radius.prop(TexDirt,'radius')
        sub_radius.prop_search(TexDirt, 'radius_tex',
                               bpy.data, 'textures',
                               text="")
        col.prop(TexDirt,'distribution')
        if TexDirt.mode != 'AO':
            col.prop(TexDirt, 'glossiness')
        if wide_ui:
            col = split.column()
        col.prop(TexDirt, 'falloff')
        col.prop(TexDirt, 'subdivs')
        if TexDirt.mode != 'AO':
            col.prop(TexDirt, 'affect_reflection_elements')

        layout.separator()

        split = layout.split()
        row = split.row(align=True)
        row.prop(TexDirt, 'bias_x')
        row.prop(TexDirt, 'bias_y')
        row.prop(TexDirt, 'bias_z')

        layout.separator()

        split = layout.split()
        col = split.column()
        col.prop(TexDirt, 'invert_normal')
        col.prop(TexDirt, 'ignore_for_gi')
        col.prop(TexDirt, 'ignore_self_occlusion')
        col.prop(TexDirt, 'consider_same_object_only')
        if wide_ui:
            col = split.column()
        col.prop(TexDirt, 'work_with_transparency')
        col.prop(TexDirt, 'environment_occlusion')
        col.prop(TexDirt, 'double_sided')        

        layout.separator()

        split = layout.split()
        col = split.column()
        col.prop_search(TexDirt,  'render_nodes',
                        bpy.data, 'groups',
                        text="Exclude")
        col.prop(TexDirt, 'render_nodes_inclusive')

        split = layout.split()
        col = split.column()
        col.prop_search(TexDirt,  'affect_result_nodes',
                        bpy.data, 'groups',
                        text="Result Affect")
        col.prop(TexDirt, 'affect_result_nodes_inclusive')


def GetRegClasses():
    return (
        TEXTURE_PT_TexDirt,
        TexDirt,
    )


def register():
    for regClass in GetRegClasses():
        bpy.utils.register_class(regClass)


def unregister():
    for regClass in GetRegClasses():
        bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexEdges
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'

ID=	  'TexEdges'
NAME= 'Edge'
PLUG= 'TexEdges'
DESC= "Wire frame texture."
PID=   4

PARAMS= (
	'edges_tex',		 # acolor texture = AColor(1, 1, 1, 1)
	'bg_tex',			 # acolor texture = AColor(0, 0, 0, 1)
	'show_hidden_edges', # bool = false
	'width_type',		 # integer = 0, 0: World units, 1: Pixels
	# 'world_width',	 # float = 1
	# 'pixel_width',	 # float = 1
)


def add_properties(VRayTexture):
	class TexEdges(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(TexEdges)
	
	VRayTexture.TexEdges= PointerProperty(
		name= "TexEdges",
		type=  TexEdges,
		description= "V-Ray TexEdges settings"
	)

	TexEdges.edges_tex= FloatVectorProperty(
		name= "Edges color",
		description= "Edges color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1,1,1)
	)

	TexEdges.edges_tex_tex= StringProperty(
		name= "Edges texture",
		description= "Edges texture",
		default= ""
	)

	TexEdges.bg_tex= FloatVectorProperty(
		name= "Background color",
		description= "Background color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0)
	)

	TexEdges.bg_tex_tex= StringProperty(
		name= "Background texture",
		description= "Background texture",
		default= ""
	)

	TexEdges.show_hidden_edges= BoolProperty(
		name= "Show hidden edges",
		description= "Show hidden edges",
		default= False
	)
	
	TexEdges.width_type= EnumProperty(
		name= "Width type",
		description= "Width type: world units or pixels",
		items= (
			('WORLD', "World", ""),
			('PIXEL', "Pixel", "")
		),
		default= 'PIXEL'
	)

	TexEdges.width= FloatProperty(
		name= "Width",
		description= "Edge width",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 5,
		default= 1.0
	)


def write(bus):
	WIDTH_TYPE= {
		'PIXEL' : 1,
		'WORLD' : 0
	}

	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	write_uvwgen(bus)

	TexEdges= getattr(texture.vray, PLUG)

	uvwgen= write_uvwgen(bus)

	mapped_params= write_sub_textures(bus,
									  TexEdges,
									  ('edges_tex_tex', 'bg_tex_tex'))

	# Write output
	ofile.write("\n%s %s {" % (PLUG, tex_name))
	for param in PARAMS:
		if param == 'width_type':
			ofile.write("\n\t%s= %s;"%(param, WIDTH_TYPE[TexEdges.width_type]))
			if TexEdges.width_type == 'PIXEL':
				_param= 'pixel_width'
			else:
				_param= 'world_width'
			ofile.write("\n\t%s= %s;"%(_param, a(scene, getattr(TexEdges, 'width'))))

		elif param in ('edges_tex', 'bg_tex'):
			tex_key= param+'_tex'
			if tex_key in mapped_params:
				value= mapped_params[tex_key]
			else:
				value= getattr(TexEdges, param)
			ofile.write("\n\t%s= %s;" % (param, a(scene, value)))

		else:
			ofile.write("\n\t%s= %s;"%(param, a(scene, getattr(TexEdges, param))))
	ofile.write("\n}\n")

	return tex_name



'''
  GUI
'''
class VRAY_TP_TexEdges(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label = NAME

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		if not tex:
			return False
		vtex= tex.vray
		engine= context.scene.render.engine
		return ((tex.type == 'VRAY' and vtex.type == ID) and (engine in __class__.COMPAT_ENGINES))
	
	def draw(self, context):
		tex= context.texture
		TexEdges= getattr(tex.vray, PLUG)
		
		wide_ui= context.region.width > ui.narrowui

		layout= self.layout

		split= layout.split()
		col= split.column()
		sub= col.column(align= True)
		sub.prop(TexEdges, 'edges_tex')
		sub.prop_search(TexEdges, 'edges_tex_tex',
						bpy.data, 'textures',
						text= "")
		if wide_ui:
			col= split.column()
		sub= col.column(align= True)
		sub.prop(TexEdges, 'bg_tex')
		sub.prop_search(TexEdges, 'bg_tex_tex',
						bpy.data, 'textures',
						text= "")

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(TexEdges, 'show_hidden_edges')
		if wide_ui:
			col= split.column()
		col.prop(TexEdges, 'width_type', text="Type")
		col.prop(TexEdges, 'width')


def GetRegClasses():
	return (
		VRAY_TP_TexEdges,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexFalloff
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'

ID=   'TexFalloff'
PLUG= 'TexFalloff'
NAME= 'Falloff'
DESC= "TODO."
PID=  1

PARAMS= (
	'color1',
	'color2',
	'type',
	'direction_type',
	'fresnel_ior',
	'dist_extrapolate',
	'dist_near',
	'dist_far',
	'explicit_dir',
	'use_blend_input'
)


def add_properties(VRayTexture):
	class TexFalloff(bpy.types.PropertyGroup):
		color1= FloatVectorProperty(
			name= "Front color",
			description= "First color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (1,1,1)
		)

		color1_tex= StringProperty(
			name= "Front texture ",
			description= "Front texture",
			default= ""
		)

		color2= FloatVectorProperty(
			name= "Side color",
			description= "Second color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0,0,0)
		)

		color2_tex= StringProperty(
			name= "Side texture ",
			description= "Side texture",
			default= ""
		)

		type= EnumProperty(
			name= "Type",
			description= "Falloff type",
			items= (
				('TA',"Towards / Away",""),
				('PP',"Perpendicular / Parallel",""),
				('FRES',"Fresnel",""),
				('SHAD',"Shadow / Light",""),
				('DIST',"Distance blend","")
			),
			default= 'TA'
		)

		direction_type= EnumProperty(
			name= "Direction type",
			description= "Direction type",
			items= (
				('VIEWZ',   "View Z",           ""),
				('VIEWX',   "View X",           ""),
				('VIEWY',   "View Y",           ""),
				('EXPL',    "Explicit",         ""),
				('LX',      "Local X",          ""),
				('LY',      "Local Y",          ""),
				('LZ',      "Local Z",          ""),
				('WX',      "World X",          ""),
				('WY',      "World Y",          ""),
				('WZ',      "World Z",          ""),
			),
			default= 'VIEWZ'
		)

		fresnel_ior= FloatProperty(
			name= "Fresnel IOR",
			description= "IOR for the Fresnel falloff type",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1.6
		)

		dist_extrapolate= BoolProperty(
			name= "Extrapolate distance",
			description= "Extrapolate for the distance blend falloff type",
			default= False
		)

		dist_near= FloatProperty(
			name= "Near distance",
			description= "Near distance for the distance blend falloff type",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0
		)

		dist_far= FloatProperty(
			name= "Far distance",
			description= "Far distance for the distance blend falloff type",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 100
		)

		explicit_dir= FloatVectorProperty(
			name= "Explicit direction",
			description= "Direction for the explicit direction type",
			subtype= 'DIRECTION',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0,0,1)
		)

		use_blend_input= BoolProperty(
			name= "Use \"blend\" input",
			description= "TODO",
			default= False
		)
	bpy.utils.register_class(TexFalloff)
	
	VRayTexture.TexFalloff= PointerProperty(
		name= "TexFalloff",
		type=  TexFalloff,
		description= "V-Ray TexFalloff settings"
	)



def write(bus):
	TYPE= {
		'TA':   0,
		'PP':   1,
		'FRES': 2,
		'SHAD': 3,
		'DIST': 4
	}

	DIRECTION_TYPE= {
		'VIEWZ': 0,
		'VIEWX': 1,
		'VIEWY': 2,
		'EXPL':  3,
		'LX':    4,
		'LY':    5,
		'LZ':    6,
		'WX':    7,
		'WY':    8,
		'WZ':    9
	}

	ofile= bus['files']['textures']
	scene= bus['scene']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	TexFalloff= getattr(texture.vray, PLUG)

	mapped_params= write_sub_textures(bus,
									  TexFalloff,
									  ('color1_tex', 'color2_tex'))

	ofile.write("\n%s %s {" % (PLUG, tex_name))

	PLUGINS['TEXTURE']['TexCommon'].write(bus)

	for param in PARAMS:
		if param == 'direction_type':
			value= DIRECTION_TYPE[TexFalloff.direction_type]

		elif param == 'type':
			value= TYPE[TexFalloff.type]

		elif param in ('color1','color2') and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']

		else:
			value= getattr(TexFalloff, param)
		
		ofile.write("\n\t%s= %s;" % (param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name



'''
  GUI
'''
class VRAY_TP_TexFalloff(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label = NAME

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		if not tex:
			return False
		vtex= tex.vray
		engine= context.scene.render.engine
		return ((tex.type == 'VRAY' and vtex.type == ID) and (engine in __class__.COMPAT_ENGINES))
	
	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexFalloff= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column()
		sub= col.column(align= True)
		sub.prop(TexFalloff, 'color1')
		sub.prop_search(TexFalloff, 'color1_tex',
						bpy.data, 'textures',
						text= "")
		if wide_ui:
			col= split.column()
		sub= col.column(align= True)
		sub.prop(TexFalloff, 'color2')
		sub.prop_search(TexFalloff, 'color2_tex',
						bpy.data, 'textures',
						text= "")

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(TexFalloff, 'type')
		col.prop(TexFalloff, 'direction_type')

		split= layout.split()
		col= split.column()
		if TexFalloff.type == 'FRES':
			col.prop(TexFalloff, 'fresnel_ior')
		elif TexFalloff.type == 'DIST':
			col.prop(TexFalloff, 'dist_near')
			if wide_ui:
				col= split.column()
			col.prop(TexFalloff, 'dist_far')
			col.prop(TexFalloff, 'dist_extrapolate')


def GetRegClasses():
	return (
		VRAY_TP_TexFalloff,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexFresnel
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'

ID=   'TexFresnel'
NAME= 'Fresnel'
PLUG= 'TexFresnel'
DESC= "TODO."
PID=  2

PARAMS= (
	'fresnel_ior',
	'refract_ior',
	'white_color',
	'black_color'
)


def add_properties(VRayTexture):
	class TexFresnel(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(TexFresnel)

	VRayTexture.TexFresnel= PointerProperty(
		name= "TexFresnel",
		type=  TexFresnel,
		description= "V-Ray TexFresnel settings"
	)

	TexFresnel.fresnel_ior= FloatProperty(
		name= "Fresnel IOR",
		description= "Fresnel ior",
		min= 0.0,
		max= 10.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.55
	)

	TexFresnel.refract_ior= FloatProperty(
		name= "Refract IOR",
		description= "Refraction ior of the underlying surface; this is ignored if the surface has a volume shader (the volume IOR is used)",
		min= 0.0,
		max= 10.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1.55
	)

	TexFresnel.white_color= FloatVectorProperty(
		name= "Front color",
		description= "Refraction (front) color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0.0,0.0,0.0)
	)

	TexFresnel.white_color_tex= StringProperty(
		name= "Front texture",
		description= "Front texture",
		default= ""
	)

	TexFresnel.black_color= FloatVectorProperty(
		name= "Side color",
		description= "Reflection (side) color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1.0,1.0,1.0)
	)

	TexFresnel.black_color_tex= StringProperty(
		name= "Side texture",
		description= "Side texture",
		default= ""
	)



def write(bus):
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	TexFresnel= getattr(texture.vray, PLUG)

	mapped_keys= ('black_color', 'white_color')
	mapped_params= write_sub_textures(bus,
									  TexFresnel,
									  [key+'_tex' for key in mapped_keys])

	ofile.write("\n%s %s {"%(PLUG, tex_name))

	for param in PARAMS:
		if param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']

		else:
			value= getattr(TexFresnel, param)

		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))

	ofile.write("\n}\n")

	return tex_name



'''
  GUI
'''
class VRAY_TP_TexFresnel(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label = NAME

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		if not tex:
			return False
		vtex= tex.vray
		engine= context.scene.render.engine
		return ((tex and tex.type == 'VRAY' and vtex.type == ID) and (engine in __class__.COMPAT_ENGINES))
	
	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout
		
		tex= context.texture
		TexFresnel= tex.vray.TexFresnel
		
		split= layout.split()
		col= split.column(align= True)
		col.prop(TexFresnel, 'white_color')
		col.prop_search(TexFresnel, 'white_color_tex',
						bpy.data, 'textures',
						text= "")
		if wide_ui:
			col= split.column(align= True)
		col.prop(TexFresnel, 'black_color')
		col.prop_search(TexFresnel, 'black_color_tex',
						bpy.data, 'textures',
						text= "")

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(TexFresnel, 'fresnel_ior')
		if wide_ui:
			col= split.column()
		col.prop(TexFresnel, 'refract_ior')


def GetRegClasses():
	return (
		VRAY_TP_TexFresnel,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexGradient
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexGradient'
PLUG= 'TexGradient'
NAME= 'Gradient'
DESC= "TexGradient."
PID=   7

PARAMS= (
	'color1',
	'color2',
	'color3',
	'has_textures',
	'middle',
	'type',
	'noise_amount',
	'noise_size',
	'noise_type',
	'noise_iterations',
	'noise_phase',
	'noise_low',
	'noise_high',
	'noise_smooth',
	'uvwgen',
)


def add_properties(rna_pointer):
	class TexGradient(bpy.types.PropertyGroup):
		# color1
		color1= FloatVectorProperty(
			name= "color1",
			description= "First color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0,0,0)
		)

		color1_tex= StringProperty(
			name= "First color texture",
			description= "First color texture",
			default= ""
		)

		# color2
		color2= FloatVectorProperty(
			name= "color2",
			description= "Middle color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0.5,0.5,0.5)
		)

		color2_tex= StringProperty(
			name= "Second color texture",
			description= "Second color texture",
			default= ""
		)

		# color3
		color3= FloatVectorProperty(
			name= "color3",
			description= "End color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (1,1,1)
		)

		color3_tex= StringProperty(
			name= "Third color texture",
			description= "Third color texture",
			default= ""
		)

		# has_textures
		has_textures= BoolProperty(
			name= "has textures",
			description= "This affects bump mapping, following a peculiarity in the 3ds Max implementation",
			default= False
		)

		# middle
		middle= FloatProperty(
			name= "Middle position",
			description= "Middle color position",
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			precision= 3,
			default= 0.5
		)

		# type
		type= EnumProperty(
			name= "Type",
			description= "Gradient type",
			items= (
				('LINEAR', "Linear", "Linear."),
				('RADIAL', "Radial", "Radial."),
			),
			default= 'LINEAR'
		)

		# noise_amount
		noise_amount= FloatProperty(
			name= "Amount",
			description= "Noise amount",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0
		)

		# noise_size
		noise_size= FloatProperty(
			name= "Size",
			description= "Noise size",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

		# noise_type
		noise_type= EnumProperty(
			name= "Type",
			description= "Noise type",
			items= (
				('REGULAR',    "Regular",    ""), # 0
				('FRACTAL',    "Fractal",    ""),
				('TRUBULENCE', "Turbulence", ""),
			),
			default= 'REGULAR'
		)

		# noise_iterations
		noise_iterations= FloatProperty(
			name= "Iterations",
			description= "Noise iterations",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 4
		)

		# noise_phase
		noise_phase= FloatProperty(
			name= "Phase",
			description= "Noise phase",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0
		)

		# noise_low
		noise_low= FloatProperty(
			name= "Low",
			description= "Noise low threshold",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0
		)

		# noise_high
		noise_high= FloatProperty(
			name= "High",
			description= "Noise high threshold",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

		# noise_smooth
		noise_smooth= FloatProperty(
			name= "Smooth",
			description= "Threshold smoothing",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0
		)

	bpy.utils.register_class(TexGradient)

	rna_pointer.TexGradient= PointerProperty(
		name= "TexGradient",
		type=  TexGradient,
		description= "V-Ray TexGradient settings"
	)


def write(bus):
	TYPE= {
		'LINEAR': 0,
		'RADIAL': 1,
	}

	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexGradient= getattr(texture.vray, PLUG)

	mapped_keys= ('color1', 'color2', 'color3')
	mapped_params= write_sub_textures(bus,
									  TexGradient,
									  [key+'_tex' for key in mapped_keys])

	ofile.write("\n%s %s {"%(PLUG, tex_name))

	PLUGINS['TEXTURE']['TexCommon'].write(bus)

	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen

		elif param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']

		elif param == 'type':
			value= TYPE[TexGradient.type]

		else:
			value= getattr(TexGradient, param)

		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexGradient(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexGradient= getattr(tex.vray, PLUG)

		layout.prop(TexGradient, 'type', expand= True)

		layout.label(text="Colors:")

		split= layout.split()
		row= split.row(align= True)
		row.prop(TexGradient, 'color1', text="")
		row.prop(TexGradient, 'color2', text="")
		row.prop(TexGradient, 'color3', text="")

		layout.label(text="Textures:")

		split= layout.split()
		row= split.row(align= True)
		row.prop_search(TexGradient, 'color1_tex',
						bpy.data,    'textures',
						text= "")
		row.prop_search(TexGradient, 'color2_tex',
						bpy.data,    'textures',
						text= "")
		row.prop_search(TexGradient, 'color3_tex',
						bpy.data,    'textures',
						text= "")

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(TexGradient, 'middle')

		layout.separator()

		box= layout.box()

		split= box.split()
		row= split.row(align= True)
		row.label(text="Noise:")
		row.prop(TexGradient, 'noise_amount')

		split= box.split()
		split.active= TexGradient.noise_amount > 0.0
		col= split.column()
		col.prop(TexGradient, 'noise_type')
		col.prop(TexGradient, 'noise_size')
		if wide_ui:
			col= split.column()
		col.prop(TexGradient, 'noise_iterations')
		col.prop(TexGradient, 'noise_phase')

		split= box.split()
		split.active= TexGradient.noise_amount > 0.0
		row= split.row(align= True)
		row.prop(TexGradient, 'noise_low')
		row.prop(TexGradient, 'noise_high')
		row.prop(TexGradient, 'noise_smooth')

		# col.prop(TexGradient, 'has_textures')


def GetRegClasses():
	return (
		VRAY_TP_TexGradient,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexGradRamp
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *

TYPE= 'TEXTURE'
ID=   'TexGradRamp'
NAME= 'Gradient Ramp'
PLUG= 'TexGradRamp'
DESC= "TexGradRamp"
PID=   6

PARAMS= (
	'positions',
	'colors',
	'texture_map',
	'gradient_type',
	'interpolation',
	'noise_amount',
	'noise_type',
	'noise_size',
	'noise_phase',
	'noise_levels',
	'noise_treshold_low',
	'noise_treshold_high',
	'noise_smooth',
	'uvwgen',
)

def add_properties(rna_pointer):
	class TexGradRamp(bpy.types.PropertyGroup):
		# positions

		# colors

		# texture_map
		texture_map= StringProperty(
			name= "Source texture",
			description= "Texture for \"Mapped\" gradient type",
			default= ""
		)

		# gradient_type
		gradient_type= EnumProperty(
			name= "Gradient type",
			description= "Gradient type",
			items= (
				('FOUR_CORNER', "Four corner", "Four corner"), # 0
				('BOX',         "Box",         "Box"),
				('DIAGONAL',    "Diagonal",    "Diagonal"),
				('LIGHTING',    "Lighting",    "Lighting"),
				('LINEAR',      "Linear",      "Linear"),
				('MAPPED',      "Mapped",      "Mapped"),
				('NORMAL',      "Normal",      "normal"),
				('PONG',        "Pong",        "Pong"),
				('RADIAL',      "Radial",      "Radial"),
				('SPIRAL',      "Spiral",      "Spiral"),
				('SWEEP',       "Sweep",       "Sweep"),
				('TARTAN',      "Tartan",      "Tartan"),
			),
			default= 'FOUR_CORNER'
		)

		# interpolation
		interpolation= EnumProperty(
			name= "Interpolation",
			description= "Interpolation",
			items= (
				('NONE',    "None",          "None"), # 0
				('LINEAR',  "Linear",        "Linear"),
				('EXPUP',   "Exponent Up",   "Exponent Up"),
				('EXPDOWN', "Exponent Down", "Exponent Down"),
				('SMOOTH',  "Smooth",        "Smooth"),
				('BUMP',    "Bump",          "Bump"),
				('SPIKE',   "Spike",         "Spike"),
			),
			default= 'LINEAR'
		)

		# noise_amount
		noise_amount= FloatProperty(
			name= "Amount",
			description= "Distortion noise amount",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0
		)

		# noise_type
		noise_type= EnumProperty(
			name= "Type",
			description= "Noise type",
			items= (
				('REGULAR',    "Regular",    ""), # 0
				('FRACTAL',    "Fractal",    ""),
				('TRUBULENCE', "Turbulence", ""),
			),
			default= 'REGULAR'
		)

		# noise_size
		noise_size= FloatProperty(
			name= "Size",
			description= "default = 1.0",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

		# noise_phase
		noise_phase= FloatProperty(
			name= "Phase",
			description= "default = 0.0",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0
		)

		# noise_levels
		noise_levels= FloatProperty(
			name= "Iterations",
			description= "default = 4.0",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 4
		)

		# noise_treshold_low
		noise_treshold_low= FloatProperty(
			name= "Low",
			description= "default = 0.0f",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0
		)

		# noise_treshold_high
		noise_treshold_high= FloatProperty(
			name= "High",
			description= "default = 1.0f",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0
		)

		# noise_smooth
		noise_smooth= FloatProperty(
			name= "Smooth",
			description= "default = 0.0f",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0
		)

	bpy.utils.register_class(TexGradRamp)

	rna_pointer.TexGradRamp= PointerProperty(
		name= "TexGradRamp",
		type=  TexGradRamp,
		description= "V-Ray TexGradRamp settings"
	)


def write(bus):
	GRADIENT_TYPE= {
		'FOUR_CORNER': 0,
		'BOX':         1,
		'DIAGONAL':    2,
		'LIGHTING':    3,
		'LINEAR':      4,
		'MAPPED':      5,
		'NORMAL':      6,
		'PONG':        7,
		'RADIAL':      8,
		'SPIRAL':      9,
		'SWEEP':      10,
		'TARTAN':     11,
	}
	INTERPOLATION= {
		'NONE':    0,
		'LINEAR':  1,
		'EXPUP':   2,
		'EXPDOWN': 3,
		'SMOOTH':  4,
		'BUMP':    5,
		'SPIKE':   6,
	}
	NOISE_TYPE= {
		'REGULAR':    0,
		'FRACTAL':    1,
		'TRUBULENCE': 2
	}
	
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	if texture.color_ramp:
		ramp_col= []
		for i,element in enumerate(texture.color_ramp.elements):
			tex_acolor= "%sC%i"%(tex_name,i)
			ofile.write("\nTexAColor %s {" % (tex_acolor))
			ofile.write("\n\ttexture= %s;" % ("AColor(%.3f,%.3f,%.3f,%.3f)" % tuple(element.color)))
			ofile.write("\n}\n")
			ramp_col.append(tex_acolor)

	TexGradRamp= getattr(texture.vray, PLUG)
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen
		elif param == 'noise_type':
			value= NOISE_TYPE[TexGradRamp.noise_type]
		elif param == 'gradient_type':
			value= GRADIENT_TYPE[TexGradRamp.gradient_type]
		elif param == 'interpolation':
			value= INTERPOLATION[TexGradRamp.interpolation]
		elif param == 'positions':
			if not texture.color_ramp:
				value= "ListFloat(1.0,0.0)"
			else:
				ramp_pos= []
				for element in texture.color_ramp.elements:
					ramp_pos.append("%.3f"%(element.position))
				value= "ListFloat(%s)" % (",".join(ramp_pos))
		elif param == 'colors':
			if not texture.color_ramp:
				value= "List(Color(1.0,1.0,1.0),Color(0.0,0.0,0.0))"
			else:
				value= "List(%s)" % (",".join(ramp_col))
		elif param == 'texture_map':
			continue
		else:
			value= getattr(TexGradRamp, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))

	PLUGINS['TEXTURE']['TexCommon'].write(bus)

	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexGradRamp(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexGradRamp= getattr(tex.vray, PLUG)

		# layout.template_color_ramp(TexGradRamp, 'ramp_elements')
		
		layout.prop(tex,'use_color_ramp')
		if tex.use_color_ramp:
			layout.template_color_ramp(tex, 'color_ramp')

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(TexGradRamp, 'gradient_type')
		col.prop(TexGradRamp, 'interpolation')

		if TexGradRamp.gradient_type == 'MAPPED':
			layout.separator()
			
			split= layout.split()
			row= split.row(align= True)
			row.label(text="Source map:")
			row.prop_search(TexGradRamp, 'texture_map',
							bpy.data,    'textures',
							text= "")

		layout.separator()

		box= layout.box()

		split= box.split()
		row= split.row(align= True)
		row.label(text="Noise:")
		row.prop(TexGradRamp, 'noise_amount')

		split= box.split()
		split.active= TexGradRamp.noise_amount > 0.0
		col= split.column()
		col.prop(TexGradRamp, 'noise_type')
		col.prop(TexGradRamp, 'noise_size')
		if wide_ui:
			col= split.column()
		col.prop(TexGradRamp, 'noise_levels')
		col.prop(TexGradRamp, 'noise_phase')

		split= box.split()
		split.active= TexGradRamp.noise_amount > 0.0
		row= split.row(align= True)
		row.prop(TexGradRamp, 'noise_treshold_low')
		row.prop(TexGradRamp, 'noise_treshold_high')
		row.prop(TexGradRamp, 'noise_smooth')


def GetRegClasses():
	return (
		VRAY_TP_TexGradRamp,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexGranite
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexGranite'
PLUG= 'TexGranite'
NAME= 'Granite'
DESC= "TexGranite."
PID=   17

PARAMS= (
	'uvwgen',
	'color1_tex',
	'color2_tex',
	'color3_tex',
	'filler_color_tex',
	'cell_size',
	'density',
	'mix_ratio',
	'spottyness',
	'randomness',
	'threshold',
	'creases',
)


def add_properties(rna_pointer):
	class TexGranite(bpy.types.PropertyGroup):

		# use_3d_mapping
		use_3d_mapping= BoolProperty(
			name= "use 3d mapping",
			description= "",
			default= True
		)
		
		#  color1_tex: acolor texture
		color1_tex= FloatVectorProperty(
			name= "Color 1",
			description= "Color 1",
			size=4,
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (1,0.4,0.15,1)
		)

		color1_tex_tex= StringProperty(
			name= "Color 1 texture ",
			description= "Color 1 texture",
			default= ""
		)

		#  color2_tex: acolor texture
		color2_tex= FloatVectorProperty(
			name= "Color 2",
			description= "Color 2",
			size=4,
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0.9,0.9,0.4,1)
		)

		color2_tex_tex= StringProperty(
			name= "Color 2 texture ",
			description= "Color 2 texture",
			default= ""
		)

		#  color3_tex: acolor texture
		color3_tex= FloatVectorProperty(
			name= "Color 3",
			description= "Color 3",
			size=4,
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0.02,0.004,0.004,1)
		)

		color3_tex_tex= StringProperty(
			name= "Color 3 texture ",
			description= "Color 3 texture",
			default= ""
		)

		# filler_color_tex: acolor texture
		filler_color_tex= FloatVectorProperty(
			name= "Filter Color",
			description= "Filter Color",
			size=4,
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0.14,0.05,0.05,1)
		)

		filler_color_tex_tex= StringProperty(
			name= "Filter Color texture ",
			description= "Filter Color texture",
			default= ""
		)

		#  cell_size: float = 0.15
		cell_size= FloatProperty(
			name= "Cell Size",
			description= "Cell Size",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.15
		)

		# density: float = 1
		density= FloatProperty(
			name= "Density",
			description= "Density",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

		#  mix_ratio: float = 0.5
		mix_ratio= FloatProperty(
			name= "Mix Ratio",
			description= "Mix Ratio",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.5
		)

		#  spottyness: float = 0.3
		spottyness= FloatProperty(
			name= "Spottyness",
			description= "Spottyness",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.3
		)

		#  randomness: float = 1
		randomness= FloatProperty(
			name= "Randomness",
			description= "Randomness",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

		#  threshold: float = 0.5
		threshold= FloatProperty(
			name= "Threshold",
			description= "Threshold",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.5
		)

		#  creases: bool = true
		creases = BoolProperty(
			name= "Creases",
			description= "Creases",
			default= True
		)


	bpy.utils.register_class(TexGranite)

	rna_pointer.TexGranite= PointerProperty(
		name= "TexGranite",
		type=  TexGranite,
		description= "V-Ray TexGranite settings"
	)


def write(bus):
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexGranite= getattr(texture.vray, PLUG)

	mapped_params= write_sub_textures(bus,
									  TexGranite,
									  ('color1_tex_tex', 'color2_tex_tex', 'color3_tex_tex', 'filler_color_tex_tex'))
	
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen

		elif param in ('color1_tex','color2_tex','color3_tex', 'filler_color_tex') and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']
		else:
			value= getattr(TexGranite, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexGranite(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexGranite= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexGranite, 'color1_tex')
		col.prop_search(TexGranite, 'color1_tex_tex',
						bpy.data, 'textures',
						text= "")
		if wide_ui:
			col= split.column(align= True)
		col.prop(TexGranite, 'color2_tex')
		col.prop_search(TexGranite, 'color2_tex_tex',
						bpy.data, 'textures',
						text= "")

		if wide_ui:
			col= split.column(align= True)
		col.prop(TexGranite, 'color3_tex')
		col.prop_search(TexGranite, 'color3_tex_tex',
						bpy.data, 'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexGranite, 'filler_color_tex')
		col.prop_search(TexGranite, 'filler_color_tex_tex',
						bpy.data, 'textures',
						text= "")
		
		split= layout.split()
		col= split.column()
		col.prop(TexGranite, 'cell_size')
		if wide_ui:
			col= split.column()
		col.prop(TexGranite, 'density')

		split= layout.split()
		col= split.column()
		col.prop(TexGranite, 'mix_ratio')
		col.prop(TexGranite, 'spottyness')
		col.prop(TexGranite, 'randomness')
		col.prop(TexGranite, 'threshold')
		col.prop(TexGranite, 'creases')


def GetRegClasses():
	return (
		VRAY_TP_TexGranite,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexGrid
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexGrid'
PLUG= 'TexGrid'
NAME= 'Grid'
DESC= "TexGrid."
PID=   19

PARAMS= (
	'uvwgen',
	'line_color',
	'fill_color',
	'u_width',
	'v_width'
)

def add_properties(rna_pointer):
	class TexGrid(bpy.types.PropertyGroup):

		# use_3d_mapping
		use_3d_mapping= BoolProperty(
			name= "use 3d mapping",
			description= "",
			default= True
		)

		#  line_color: acolor texture
		line_color = FloatVectorProperty(
			name= "Line Color",
			description= "Line Color",
			subtype= 'COLOR',
			size=4,
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0,0,0,1)
		)

		line_color_tex= StringProperty(
			name= "Line Color Texture",
			description= "Line Color Texture",
			default= ""
		)

		#  fill_color: acolor texture
		fill_color = FloatVectorProperty(
			name= "Fill Color",
			description= "Fill Color",
			subtype= 'COLOR',
			size=4,
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (1,1,1,1)
		)

		fill_color_tex= StringProperty(
			name= "Fill Color Texture",
			description= "Fill Color Texture",
			default= ""
		)
		
		#  u_width: float = 0.1
		u_width= FloatProperty(
			name= "U width",
			description= "U width",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.1
		)

		#  v_width: float = 0.1
		v_width= FloatProperty(
			name= "V width",
			description= "V width",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.1
		)
		

	bpy.utils.register_class(TexGrid)

	rna_pointer.TexGrid= PointerProperty(
		name= "TexGrid",
		type=  TexGrid,
		description= "V-Ray TexGrid settings"
	)


def write(bus):
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexGrid= getattr(texture.vray, PLUG)

	mapped_keys= ('line_color', 'fill_color')
	mapped_params= write_sub_textures(bus,
					  TexGrid,
					  [key+'_tex' for key in mapped_keys])
	
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen
		elif param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']
		else:
			value= getattr(TexGrid, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexGrid(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexGrid= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexGrid, 'line_color', text="Line Color")
		col.prop_search(TexGrid, 'line_color_tex',
						bpy.data,    'textures',
						text= "")

		if wide_ui:
			col= split.column(align= True)
		col.prop(TexGrid, 'fill_color', text="Fill Color")
		col.prop_search(TexGrid, 'fill_color_tex',
						bpy.data,    'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexGrid, 'u_width')
		col.prop(TexGrid, 'v_width')


def GetRegClasses():
	return (
		VRAY_TP_TexGrid,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexInvert
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE = 'TEXTURE'
ID   = 'TexInvert'
PLUG = 'TexInvert'
NAME = 'Invert'
DESC = "Invert."
PID  =  26

PARAMS= (
	'texture',
	'invert_alpha',
)


def add_properties(rna_pointer):
	class TexInvert(bpy.types.PropertyGroup):

		texture = StringProperty(
			name        = "Invert Texture",
			description = "Invert Texture",
			default     = ""
		)

		invert_alpha = BoolProperty(
			name        = "Invert Alpha",
			description = "",
			default     = True
		)

		

	bpy.utils.register_class(TexInvert)

	rna_pointer.TexInvert = PointerProperty(
		name        = "TexInvert",
		type        =  TexInvert,
		description = "V-Ray TexInvert settings"
	)


def write(bus):
	scene    = bus['scene']
	ofile    = bus['files']['textures']

	slot     = bus['mtex']['slot']
	texture  = bus['mtex']['texture']
	tex_name = bus['mtex']['name']

	TexInvert = getattr(texture.vray, PLUG)

	mapped_keys   = ('texture')
	mapped_params = write_sub_textures(bus,
									  TexInvert,
									  ['texture' for key in mapped_keys])
	
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'uvwgen':
			value = uvwgen
		elif param == 'texture':
			value = mapped_params['texture']
		else:
			value = getattr(TexInvert, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name

'''
  GUI
'''

class VRAY_TP_TexInvert(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui   = context.region.width > ui.narrowui
		layout    = self.layout

		tex       = context.texture
		TexInvert = getattr(tex.vray, PLUG)

		split     = layout.split()
		col       = split.column(align= True)
		col.prop_search(TexInvert, 'texture',
							bpy.data,    'textures',
							text= "")

		col.prop(TexInvert, 'invert_alpha', text="Invert Alpha")


def GetRegClasses():
	return (
		VRAY_TP_TexInvert,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexLeather
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexLeather'
PLUG= 'TexLeather'
NAME= 'Leather'
DESC= "TexLeather."
PID=   23

PARAMS= (
	'uvwgen',
	'cell_color',
	'cell_color_tex',
	'cell_color_tex_mult',
	'creases',
	'crease_color',
	'crease_color_tex',
	'size',
	'density',
	'spottyness',
	'randomness',
	'threshold',
)




def add_properties(rna_pointer):
	class TexLeather(bpy.types.PropertyGroup):

		# use_3d_mapping
		use_3d_mapping= BoolProperty(
			name= "use 3d mapping",
			description= "",
			default= True
		)

		#  cell_color: color = Color(1, 1, 1)
		cell_color = FloatVectorProperty(
			name= "Cell Color",
			description= "Cell Color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (1,1,1)
		)

		#  cell_color_tex: acolor texture
		cell_color_tex = FloatVectorProperty(
			name= "Cell Color",
			description= "Cell Color",
			subtype= 'COLOR',
			size=4,
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0,0,0,1)
		)

		cell_color_tex_tex= StringProperty(
			name= "Cell Texture",
			description= "Cell Color Texture",
			default= ""
		)

		#  cell_color_tex_mult: float = 1
		cell_color_tex_mult= FloatProperty(
			name= "Cell color texture mult",
			description= "Cell color texture mult",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

		#  creases: bool = true
		creases= BoolProperty(
			name= "Creases",
			description= "",
			default= True
		)

		#  crease_color: color = Color(0, 0, 0)
		crease_color = FloatVectorProperty(
			name= "Creases Color",
			description= "Creases Color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0,0,0)
		)

		#  crease_color_tex: acolor texture
		crease_color_tex = FloatVectorProperty(
			name= "Creases Color",
			description= "Creases Color",
			subtype= 'COLOR',
			size=4,
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0,0,0,1)
		)

		crease_color_tex_tex= StringProperty(
			name= "Crease Color Texture",
			description= "Crease Color Texture",
			default= ""
		)
		
		#  crease_color_tex_mult: float = 1
		crease_color_tex_mult= FloatProperty(
			name= "Crease Color Texture mult",
			description= "Crease Color Texture mult",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

		#  size: float = 0.5
		size= FloatProperty(
			name= "Size",
			description= "Size",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.5
		)

		#  density: float = 1
		density= FloatProperty(
			name= "Density",
			description= "Density",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

		#  spottyness: float = 0.1
		spottyness= FloatProperty(
			name= "Spottyness",
			description= "Spottyness",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.1
		)

		#  randomness: float = 0.5
		randomness= FloatProperty(
			name= "Randomness",
			description= "Randomness",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.5
		)

		#  threshold: float = 0.83
		threshold= FloatProperty(
			name= "Threshold",
			description= "Threshold",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.83
		)


	bpy.utils.register_class(TexLeather)

	rna_pointer.TexLeather= PointerProperty(
		name= "TexLeather",
		type=  TexLeather,
		description= "V-Ray TexLeather settings"
	)


def write(bus):
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexLeather= getattr(texture.vray, PLUG)

	mapped_keys= ('cell_color_tex', 'crease_color_tex')
	mapped_params= write_sub_textures(bus,
					  TexLeather,
					  [key+'_tex' for key in mapped_keys])
	
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen
		elif param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']
		else:
			value= getattr(TexLeather, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name

'''
  GUI
'''
class VRAY_TP_TexLeather(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexLeather= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexLeather, 'cell_color', text="Cell Color")
		col.prop(TexLeather, 'cell_color_tex', text="Cell Color")
		col.prop_search(TexLeather, 'cell_color_tex_tex',
						bpy.data,    'textures',
						text= "")
		if TexLeather.cell_color_tex:
			col.prop(TexLeather, 'cell_color_tex_mult')

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexLeather, 'creases')

		split= layout.split()
		col= split.column(align= True)

		if TexLeather.creases:
#			if wide_ui:
#			col= split.column(align= True)
			col.prop(TexLeather, 'crease_color', text="Crease Color")
			col.prop(TexLeather, 'crease_color_tex', text="Crease Color")
			col.prop_search(TexLeather, 'crease_color_tex_tex',
							bpy.data,    'textures',
							text= "")
			if TexLeather.crease_color_tex:
				col.prop(TexLeather, 'crease_color_tex_mult')

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexLeather, 'size', text="Size")
		col.prop(TexLeather, 'density', text="Density")
		col.prop(TexLeather, 'spottyness', text="Spottyness")
		col.prop(TexLeather, 'randomness', text="Randomness")
		col.prop(TexLeather, 'threshold', text="Threshold")
		

#  cell_color: color = Color(1, 1, 1)
#  cell_color_tex: acolor texture
#  cell_color_tex_mult: float = 1

#  creases: bool = true
#  crease_color: color = Color(0, 0, 0)
#  crease_color_tex: acolor texture
#  crease_color_tex_mult: float = 1



#  size: float = 0.5
#  density: float = 1
#  spottyness: float = 0.1
#  randomness: float = 0.5
#  threshold: float = 0.83


def GetRegClasses():
	return (
		VRAY_TP_TexLeather,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexMarbleMax
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexMarbleMax'
PLUG= 'TexMarbleMax'
NAME= 'Marble'
DESC= "TexMarbleMax."
PID=   9

PARAMS= (
	'color1',
	'color2',
	'size',
	'vein_width',
	'uvwgen',
)


def add_properties(rna_pointer):
	class TexMarbleMax(bpy.types.PropertyGroup):
		# color1
		color1= FloatVectorProperty(
			name= "First color",
			description= "First color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (1,1,1)
		)

		color1_tex= StringProperty(
			name= "First texture ",
			description= "First texture",
			default= ""
		)

		# color2
		color2= FloatVectorProperty(
			name= "Second color",
			description= "Second color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0,0,0)
		)

		color2_tex= StringProperty(
			name= "Second texture ",
			description= "Second texture",
			default= ""
		)

		# size
		size= FloatProperty(
			name= "Size",
			description= "Size",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1.0
		)

		# vein_width
		vein_width= FloatProperty(
			name= "Vein width",
			description= "Vein width",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.02
		)

	bpy.utils.register_class(TexMarbleMax)

	rna_pointer.TexMarbleMax= PointerProperty(
		name= "TexMarbleMax",
		type=  TexMarbleMax,
		description= "V-Ray TexMarbleMax settings"
	)


def write(bus):
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexMarbleMax= getattr(texture.vray, PLUG)

	mapped_params= write_sub_textures(bus,
									  TexMarbleMax,
									  ('color1_tex', 'color2_tex'))
	
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen

		elif param in ('color1','color2') and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']

		else:
			value= getattr(TexMarbleMax, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexMarbleMax(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexMarbleMax= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexMarbleMax, 'color1')
		col.prop_search(TexMarbleMax, 'color1_tex',
						bpy.data, 'textures',
						text= "")
		if wide_ui:
			col= split.column(align= True)
		col.prop(TexMarbleMax, 'color2')
		col.prop_search(TexMarbleMax, 'color2_tex',
						bpy.data, 'textures',
						text= "")

		layout.separator()
		
		split= layout.split()
		col= split.column()
		col.prop(TexMarbleMax, 'size')
		if wide_ui:
			col= split.column()
		col.prop(TexMarbleMax, 'vein_width')


def GetRegClasses():
	return (
		VRAY_TP_TexMarbleMax,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexMaskMax
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexMaskMax'
PLUG= 'TexMaskMax'
NAME= 'Mask Max'
DESC= "Mask Max."
PID=   29

PARAMS= (
	'texture',
	'mask',
	'invert_mask',
)


def add_properties(rna_pointer):
	class TexMaskMax(bpy.types.PropertyGroup):

		#  texture: acolor texture = AColor(1, 1, 1, 1), The base texture
		texture = FloatVectorProperty(
			name        = "Value",
			description = "Value",
			subtype     = 'COLOR',
			size        = 4,
			min         = 0.0,
			max         = 1.0,
			soft_min    = 0.0,
			soft_max    = 1.0,
			default     = (1,1,1,1)
		)

		texture_tex = StringProperty(
			name        = "Input Texture",
			description = "Input Texture",
			default     = ""
		)

		#  mask: acolor texture = AColor(1, 1, 1, 1), The mask texture
		mask = FloatVectorProperty(
			name        = "Contrast",
			description = "Contrast",
			subtype     = 'COLOR',
			size        = 4,
			min         = 0.0,
			max         = 1.0,
			soft_min    = 0.0,
			soft_max    = 1.0,
			default     = (1, 1, 1, 1)
		)

		mask_tex = StringProperty(
			name        = "Contrast Texture",
			description = "Contrast Texture",
			default     = ""
		)
		
		#  invert_mask: bool = false, true to invert the mask
		invert_mask  = BoolProperty(
			name        = "Invert mask",
			description = "",
			default     = True
		)

		

	bpy.utils.register_class(TexMaskMax)

	rna_pointer.TexMaskMax= PointerProperty(
		name= "TexMaskMax",
		type=  TexMaskMax,
		description= "V-Ray TexMaskMax settings"
	)


def write(bus):
	scene = bus['scene']
	ofile = bus['files']['textures']

	slot     = bus['mtex']['slot']
	texture  = bus['mtex']['texture']
	tex_name = bus['mtex']['name']

	TexMaskMax= getattr(texture.vray, PLUG)

	mapped_keys= ('texture', 'mask')
	mapped_params= write_sub_textures(bus,
				   TexMaskMax,
				   [key+'_tex' for key in mapped_keys])
	
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen
		elif param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']
		else:
			value= getattr(TexMaskMax, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name

'''
  GUI
'''
class VRAY_TP_TexMaskMax(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexMaskMax= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexMaskMax, 'texture', text="Texture")
		col.prop_search(TexMaskMax, 'texture_tex',
						bpy.data,    'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexMaskMax, 'mask', text="Mask")
		col.prop_search(TexMaskMax, 'mask_tex',
						bpy.data,    'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexMaskMax, 'invert_mask', text="Invert")


def GetRegClasses():
	return (
		VRAY_TP_TexMaskMax,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexMayaContrast
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexMayaContrast'
PLUG= 'TexMayaContrast'
NAME= 'Maya Contrast'
DESC= "Maya Contrast."
PID=   28

PARAMS= (
	'value',
	'contrast',
	'bias',
)

def add_properties(rna_pointer):
	class TexMayaContrast(bpy.types.PropertyGroup):

		#  value: acolor texture = AColor(0, 0, 0, 1)
		value = FloatVectorProperty(
			name        = "Value",
			description = "Value",
			subtype     = 'COLOR',
			size        = 4,
			min         = 0.0,
			max         = 1.0,
			soft_min    = 0.0,
			soft_max    = 1.0,
			default     = (0,0,0,1)
		)

		value_tex = StringProperty(
			name        = "Input Texture",
			description = "Input Texture",
			default     = ""
		)

		#  contrast: acolor texture = AColor(2, 2, 2, 1)
		contrast = FloatVectorProperty(
			name        = "Contrast",
			description = "Contrast",
			subtype     = 'COLOR',
			size        = 4,
			min         = 0.0,
			max         = 1.0,
			soft_min    = 0.0,
			soft_max    = 1.0,
			default     = (2, 2, 2, 1)
		)

		contrast_tex = StringProperty(
			name        = "Contrast Texture",
			description = "Contrast Texture",
			default     = ""
		)
		
		#  bias: acolor texture = AColor(0.5, 0.5, 0.5, 1)
		bias = FloatVectorProperty(
			name        = "Bias",
			description = "Bias",
			subtype     = 'COLOR',
			size        = 4,
			min         = 0.0,
			max         = 1.0,
			soft_min    = 0.0,
			soft_max    = 1.0,
			default     = (0.5, 0.5, 0.5, 1)
		)

		bias_tex = StringProperty(
			name        = "Bias Texture",
			description = "Bias Texture",
			default     = ""
		)
		

	bpy.utils.register_class(TexMayaContrast)

	rna_pointer.TexMayaContrast = PointerProperty(
		name        = "TexMayaContrast",
		type        =  TexMayaContrast,
		description = "V-Ray TexMayaContrast settings"
	)


def write(bus):
	scene = bus['scene']
	ofile = bus['files']['textures']

	slot     = bus['mtex']['slot']
	texture  = bus['mtex']['texture']
	tex_name = bus['mtex']['name']

#	uvwgen= write_uvwgen(bus)

	TexMayaContrast= getattr(texture.vray, PLUG)

	mapped_keys= ('value', 'contrast', 'bias')
	mapped_params= write_sub_textures(bus,
					  TexMayaContrast,
					  [key+'_tex' for key in mapped_keys])
	
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen
		elif param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']
		else:
			value= getattr(TexMayaContrast, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name

'''
  GUI
'''
class VRAY_TP_TexMayaContrast(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexMayaContrast= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexMayaContrast, 'value', text="Value")
		col.prop_search(TexMayaContrast, 'value_tex',
						bpy.data,    'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexMayaContrast, 'contrast', text="Contrast")
		col.prop_search(TexMayaContrast, 'contrast_tex',
						bpy.data,    'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexMayaContrast, 'bias', text="Bias")
		col.prop_search(TexMayaContrast, 'bias_tex',
						bpy.data,    'textures',
						text= "")


def GetRegClasses():
	return (
		VRAY_TP_TexMayaContrast,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexMeshVertexColorChannel
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE = 'TEXTURE'
ID   = 'TexMeshVertexColorChannel'
PLUG = 'TexMeshVertexColorChannel'
NAME = 'Vertex Color'
DESC = "TexMeshVertexColorChannel"
PID  =  25

PARAMS = (
    'channelIndex',
)


def add_properties(rna_pointer):
    class TexMeshVertexColorChannel(bpy.types.PropertyGroup):
        channelIndex = bpy.props.IntProperty(
            name = "hannel Index",
            description = "hannel Index",
            min = 0,
            max = 100,
            soft_min = 0,
            soft_max = 10,
            default = 1
        )

    bpy.utils.register_class(TexMeshVertexColorChannel)

    rna_pointer.TexMeshVertexColorChannel= PointerProperty(
        name= "TexMeshVertexColorChannel",
        type=  TexMeshVertexColorChannel,
        description= "V-Ray TexMeshVertexColorChannel settings"
    )


def write(bus):
    scene = bus['scene']
    ofile = bus['files']['textures']

    slot     = bus['mtex']['slot']
    texture  = bus['mtex']['texture']
    tex_name = bus['mtex']['name']

    TexMeshVertexColorChannel = getattr(texture.vray, PLUG)
    
    ofile.write("\nTexMeshVertexColorChannel %s {"%(tex_name))
    ofile.write("\n\tchannelIndex=%s;" % p(TexMeshVertexColorChannel.channelIndex))
    ofile.write("\n}\n")

    return tex_name


'''
  GUI
'''
class VRAY_TP_TexMeshVertexColorChannel(ui.VRayTexturePanel, bpy.types.Panel):
    bl_label       = NAME

    COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

    @classmethod
    def poll(cls, context):
        tex= context.texture
        return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

    def draw(self, context):
        wide_ui = context.region.width > ui.narrowui
        layout  = self.layout

        tex = context.texture
        TexMeshVertexColorChannel = getattr(tex.vray, PLUG)

        layout.prop(TexMeshVertexColorChannel, 'channelIndex')


def GetRegClasses():
    return (
        VRAY_TP_TexMeshVertexColorChannel,
    )


def register():
    for regClass in GetRegClasses():
        bpy.utils.register_class(regClass)


def unregister():
    for regClass in GetRegClasses():
        bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexMix
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexMix'
PLUG= 'TexMix'
NAME= 'Mix'
DESC= "Mix."
PID=   31

PARAMS= (
	'color1',
	'color2',
	'mix_map',
	'mix_amount',
	'transition_upper',
	'transition_lower',
	'use_curve'
)

def add_properties(rna_pointer):
	class TexMix(bpy.types.PropertyGroup):

		#  color1: acolor texture = AColor(1, 1, 1, 1), First color
		color1 = FloatVectorProperty(
			name        = "First color",
			description = "First color",
			subtype     = 'COLOR',
			size        = 4,
			min         = 0.0,
			max         = 1.0,
			soft_min    = 0.0,
			soft_max    = 1.0,
			default     = (1,1,1,1)
		)

		color1_tex = StringProperty(
			name        = "First color Texture",
			description = "First color Texture",
			default     = ""
		)

		#  color2: acolor texture = AColor(0, 0, 0, 0), Second color
		color2 = FloatVectorProperty(
			name        = "Second color",
			description = "Second color",
			subtype     = 'COLOR',
			size        = 4,
			min         = 0.0,
			max         = 1.0,
			soft_min    = 0.0,
			soft_max    = 1.0,
			default     = (0, 0, 0, 0)
		)

		color2_tex = StringProperty(
			name        = "Second color Texture",
			description = "Second color Texture",
			default     = ""
		)

		#  mix_map: acolor texture = AColor(0.5, 0.5, 0.5, 1), Mix amount texture
		mix_map = FloatVectorProperty(
			name        = "Mix amount texture",
			description = "Mix amount texture",
			subtype     = 'COLOR',
			size        = 4,
			min         = 0.0,
			max         = 1.0,
			soft_min    = 0.0,
			soft_max    = 1.0,
			default     = (0.5, 0.5, 0.5, 1)
		)

		mix_map_tex = StringProperty(
			name        = "Mix amount Texture",
			description = "Mix amount Texture",
			default     = ""
		)
		
		#  mix_amount: float = 0, Mix amount
		mix_amount = FloatProperty(
			name        = "Mix amount",
			description = "Mix amount",
			min         = 0.0,
			max         = 100.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0
		)

		#  transition_upper: float = 0.7, Transition zone - upper
		transition_upper = FloatProperty(
			name        = "Upper",
			description = "Transition zone - upper",
			min         = 0.0,
			max         = 100.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0.7
		)

		#  transition_lower: float = 0.3, Transition zone - lower
		transition_lower = FloatProperty(
			name        = "Lower",
			description = "Transition zone - lower",
			min         = 0.0,
			max         = 100.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0.3
		)

		# use_curve: integer = 0, If true the blend curve is used
		use_curve = IntProperty(
			name        = "Curve",
			description = "If true the blend curve is used",
			min         = 0,
			max         = 100,
			default     = 0
		)

		

	bpy.utils.register_class(TexMix)

	rna_pointer.TexMix = PointerProperty(
		name        = "TexMix",
		type        =  TexMix,
		description = "V-Ray TexMix settings"
	)


def write(bus):
	scene = bus['scene']
	ofile = bus['files']['textures']

	slot     = bus['mtex']['slot']
	texture  = bus['mtex']['texture']
	tex_name = bus['mtex']['name']

	TexMix = getattr(texture.vray, PLUG)

	mapped_keys   = ('color1', 'color2', 'mix_map')
	mapped_params = write_sub_textures(bus,
									  TexMix,
									  [key+'_tex' for key in mapped_keys])
	
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']
		else:
			value= getattr(TexMix, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name

'''
  GUI
'''
class VRAY_TP_TexMix(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexMix= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexMix, 'color1', text="First")
		col.prop_search(TexMix, 'color1_tex',
						bpy.data,    'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexMix, 'color2', text="Second")
		col.prop_search(TexMix, 'color2_tex',
						bpy.data,    'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexMix, 'mix_map', text="Mix")
		col.prop_search(TexMix, 'mix_map_tex',
						bpy.data,    'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexMix, 'mix_amount', text="Mix Amount")
		col.prop(TexMix, 'transition_lower', text="Transition Lower")
		col.prop(TexMix, 'transition_upper', text="Transition Upper")
		col.prop(TexMix, 'use_curve', text="Use Curve")


def GetRegClasses():
	return (
		VRAY_TP_TexMix,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexNoise
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'

ID=   'TexNoiseMax'
NAME= 'Noise'
PLUG= 'TexNoiseMax'
DESC= "3ds max like noise texture."
PID=  5

PARAMS= (
	'color1',
	'color2',
	'size',
	'phase',
	'iterations',
	'low',
	'high',
	'type',
	'uvwgen',
)


def add_properties(rna_pointer):
	class TexNoiseMax(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(TexNoiseMax)

	rna_pointer.TexNoiseMax= PointerProperty(
		name= "TexNoiseMax",
		type=  TexNoiseMax,
		description= "V-Ray TexNoiseMax settings"
	)

	# use_3d_mapping
	TexNoiseMax.use_3d_mapping= BoolProperty(
		name= "use 3d mapping",
		description= "",
		default= True
	)

	# color1
	TexNoiseMax.color1= FloatVectorProperty(
		name= "Color 1",
		description= "First color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1,1,1)
	)

	TexNoiseMax.color1_tex= StringProperty(
		name= "Color 1 texture",
		description= "Color 1 texture",
		default= ""
	)

	# color2
	TexNoiseMax.color2= FloatVectorProperty(
		name= "Color 2",
		description= "Second color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0)
	)

	TexNoiseMax.color2_tex= StringProperty(
		name= "Color 2 texture",
		description= "Color 2 texture",
		default= ""
	)


	# size
	TexNoiseMax.size= FloatProperty(
		name= "Size",
		description= "Size",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# phase
	TexNoiseMax.phase= FloatProperty(
		name= "Phase",
		description= "Phase",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	# iterations
	TexNoiseMax.iterations= FloatProperty(
		name= "Iterations",
		description= "Number of iterations for the fractal generator",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 3
	)

	# low
	TexNoiseMax.low= FloatProperty(
		name= "Low",
		description= "Low threshold",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	# high
	TexNoiseMax.high= FloatProperty(
		name= "High",
		description= "High threshold",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# type
	TexNoiseMax.type= EnumProperty(
		name= "Type",
		description= "Noise type",
		items= (
			('REGULAR',    "Regular",    ""), # 0
			('FRACTAL',    "Fractal",    ""),
			('TRUBULENCE', "Turbulence", ""),
		),
		default= 'REGULAR'
	)


def write(bus):
	TYPE= {
		'REGULAR':    0,
		'FRACTAL':    1,
		'TRUBULENCE': 2,
	}
	PLACEMENT_TYPE= {
		'FULL':  0,
		'CROP':  1,
		'PLACE': 2,
	}

	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexNoiseMax= getattr(texture.vray, PLUG)

	mapped_keys= ('color1', 'color2')
	mapped_params= write_sub_textures(bus,
									  TexNoiseMax,
									  [key+'_tex' for key in mapped_keys])

	ofile.write("\n%s %s {"%(PLUG, tex_name))

	PLUGINS['TEXTURE']['TexCommon'].write(bus)

	for param in PARAMS:
		if param == 'type':
			value= TYPE[TexNoiseMax.type]

		elif param == 'placement_type':
			value= PLACEMENT_TYPE[TexNoiseMax.placement_type]

		elif param == 'uvwgen':
			value= uvwgen

		elif param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']

		else:
			value= getattr(TexNoiseMax, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))

	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexNoiseMax(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		if not tex:
			return False
		engine= context.scene.render.engine
		return ((tex and tex.type == 'VRAY' and tex.vray.type == ID) and (ui.engine_poll(__class__, context)))

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexNoiseMax= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexNoiseMax, 'color1')
		col.prop_search(TexNoiseMax, 'color1_tex',
						bpy.data,    'textures',
						text= "")
		if wide_ui:
			col= split.column(align= True)
		col.prop(TexNoiseMax, 'color2')
		col.prop_search(TexNoiseMax, 'color2_tex',
						bpy.data,    'textures',
						text= "")

		split= layout.split()
		col= split.column()
		col.prop(TexNoiseMax, 'type')
		col.prop(TexNoiseMax, 'size')
		col.prop(TexNoiseMax, 'iterations')
		if wide_ui:
			col= split.column()
		col.prop(TexNoiseMax, 'low')
		col.prop(TexNoiseMax, 'high')
		col.prop(TexNoiseMax, 'phase')


def GetRegClasses():
	return (
		VRAY_TP_TexNoiseMax,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexPtex
#
# V-Ray/Blender
#
# http://vray.cgdo.ru
#
# Author: Andrey M. Izrantsev (aka bdancer)
# E-Mail: izrantsev@cgdo.ru
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
#


# Blender modules
import bpy
from bpy.props import *

# V-Ray/Blender modules
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE = 'TEXTURE'
ID   = 'TexPtex'
PLUG = 'TexPtex'
PID  =  200

NAME = 'Ptex'
DESC = "VRay TexPtex texture"

PARAMS = (
	'ptex_file',
	'use_image_sequence',
	'image_number',
	'image_offset',
	'ifl_start_frame',
	'ifl_playback_rate',
	'ifl_end_condition',
	'filter_type',
	'width',
	'blur',
	'sharpness',
	'lerp',
	'reverse_vertices',
	'cache_size',
	'r_channel',
	'g_channel',
	'b_channel',
	'a_channel',
	'auto_color',
	'auto_alpha',
	'alpha_type',
	'color_space',
	'gamma',
	# 'vertices',
	# 'origFaces',
	# 'faces',
	# 'origFacesDegree',
	'color_gain',
	'color_offset',
)


def add_properties(rna_pointer):
	class TexPtex(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(TexPtex)

	rna_pointer.TexPtex = PointerProperty(
		name        = "TexPtex",
		type        =  TexPtex,
		description = "V-Ray TexPtex settings"
	)

	# ptex_file
	TexPtex.ptex_file = StringProperty(
		name        = "File",
		subtype     = 'FILE_PATH',
		description = "The Ptex texture file",
		default     = ""
	)

	# use_image_sequence
	TexPtex.use_image_sequence= IntProperty(
		name= "use image sequence",
		description= "",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 0
	)

	# image_number
	TexPtex.image_number= IntProperty(
		name= "image number",
		description= "",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 0
	)

	# image_offset
	TexPtex.image_offset= IntProperty(
		name= "image offset",
		description= "",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 0
	)

	# ifl_start_frame
	TexPtex.ifl_start_frame= IntProperty(
		name= "ifl start frame",
		description= "TODO: Tooltip",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 0
	)

	# ifl_playback_rate
	TexPtex.ifl_playback_rate= FloatProperty(
		name= "ifl playback rate",
		description= "TODO: Tooltip",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# ifl_end_condition
	TexPtex.ifl_end_condition= IntProperty(
		name= "ifl end condition",
		description= "Image file list (IFL) end condition: 0 - Loop; 1 - Ping Pong; 2 - Hold;",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 0
	)

	# filter_type
	TexPtex.filter_type = EnumProperty(
		name  = "Filter Type",
		description = "Type of filter used for the texture",
		items = (
			('0', '0', "0"),
			('1', '1', "1")
		),
		default = '0'
	)

	# width
	TexPtex.width= FloatProperty(
		name= "width",
		description= "width parameter used for filtering",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# blur
	TexPtex.blur= FloatProperty(
		name= "blur",
		description= "blur parameter used for filtering",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	# sharpness
	TexPtex.sharpness= FloatProperty(
		name= "sharpness",
		description= "Sharpness parameter for the general bicubic filter",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	# lerp
	TexPtex.lerp= BoolProperty(
		name= "lerp",
		description= "Interpolation between mipmap levels",
		default= False
	)

	# reverse_vertices
	TexPtex.reverse_vertices= BoolProperty(
		name= "reverse vertices",
		description= "Reverses the order of vertices",
		default= False
	)

	# cache_size
	TexPtex.cache_size= IntProperty(
		name= "cache size",
		description= "The size of the texture cache(in MB)",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 1
	)

	# r_channel
	TexPtex.r_channel= IntProperty(
		name= "r channel",
		description= "The index of the channel which will be used as a red channel",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 0
	)

	# g_channel
	TexPtex.g_channel= IntProperty(
		name= "g channel",
		description= "The index of the channel which will be used as a green channel",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 1
	)

	# b_channel
	TexPtex.b_channel= IntProperty(
		name= "b channel",
		description= "The index of the channel which will be used as a blue channel",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 2
	)

	# a_channel
	TexPtex.a_channel= IntProperty(
		name= "a channel",
		description= "The index of the channel which will be used as a alpha channel",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= -1
	)

	# auto_color
	TexPtex.auto_color= BoolProperty(
		name= "auto color",
		description= "Use automatic color channel selection",
		default= True
	)

	# auto_alpha
	TexPtex.auto_alpha= BoolProperty(
		name= "auto alpha",
		description= "Use automatic alpha channel selection",
		default= True
	)

	# alpha_type
	TexPtex.alpha_type= IntProperty(
		name= "alpha type",
		description= "Where to take the alpha from",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= -1
	)

	# color_space
	TexPtex.color_space = EnumProperty(
		name  = "Color Space",
		items = (
			('0', 'Linear',          "Linear"),
			('1', 'Gamma corrected', "Gamma corrected"),
			('2', 'sRGB',            "sRGB")
		),
		default = '1'
	)

	# gamma
	TexPtex.gamma= FloatProperty(
		name= "gamma",
		description= "TODO: Tooltip",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# vertices
	# origFaces
	# faces
	# origFacesDegree

	# color_gain
	TexPtex.color_gain= FloatVectorProperty(
		name= "Gain",
		description= "A multiplier for the texture color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1,1,1)
	)

	# color_offset
	TexPtex.color_offset= FloatVectorProperty(
		name= "Offset",
		description= "An additional offset for the texture color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0)
	)


#
# Output
#
def write(bus):
	return None


#
# User Interface
#
class VRAY_PA_TexPtex(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = "PTex [in progress...]"
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex = context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui = context.region.width > ui.narrowui
		layout  = self.layout

		tex     = context.texture
		TexPtex = getattr(tex.vray, PLUG)

		split = layout.split()
		col = split.column()
		col.prop(TexPtex, 'ptex_file')
		col.prop(TexPtex, 'use_image_sequence')
		col.prop(TexPtex, 'image_number')
		col.prop(TexPtex, 'image_offset')
		col.prop(TexPtex, 'ifl_start_frame')
		col.prop(TexPtex, 'ifl_playback_rate')
		col.prop(TexPtex, 'ifl_end_condition')
		col.prop(TexPtex, 'filter_type')
		col.prop(TexPtex, 'width')
		col.prop(TexPtex, 'blur')
		col.prop(TexPtex, 'sharpness')
		col.prop(TexPtex, 'lerp')
		col.prop(TexPtex, 'reverse_vertices')
		col.prop(TexPtex, 'cache_size')

		split = layout.split()
		col = split.column()
		col.prop(TexPtex, 'r_channel')
		col.prop(TexPtex, 'g_channel')
		col.prop(TexPtex, 'b_channel')
		col.prop(TexPtex, 'a_channel')
		col.prop(TexPtex, 'auto_color')
		col.prop(TexPtex, 'auto_alpha')
		col.prop(TexPtex, 'alpha_type')
		col.prop(TexPtex, 'color_space')
		col.prop(TexPtex, 'gamma')

		split = layout.split()
		col = split.column()
		col.prop(TexPtex, 'color_gain')
		if wide_ui:
			col= split.column()
		col.prop(TexPtex, 'color_offset')


def GetRegClasses():
	return (
		VRAY_PA_TexPtex,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexRock
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexRock'
PLUG= 'TexRock'
NAME= 'Rock'
DESC= "TexRock."
PID=   12

PARAMS= (
	'uvwgen',
	'color1_tex',
	'color2_tex',
	'grain_size',
	'diffusion',
	'mix_ratio',
)


def add_properties(rna_pointer):
	class TexRock(bpy.types.PropertyGroup):
		# use_3d_mapping
		use_3d_mapping= BoolProperty(
			name= "use 3d mapping",
			description= "",
			default= True
		)

		# wrap
		wrap= BoolProperty(
			name= "Wrap",
			description= "",
			default= True
		)

		# color1_tex
		color1_tex= FloatVectorProperty(
			name= "First color",
			description= "First color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (1,1,1)
		)

		color1_tex_tex= StringProperty(
			name= "color1 tex",
			description= "",
			default= ""
		)

		# color2_tex
		color2_tex= FloatVectorProperty(
			name= "Second color",
			description= "Second color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0,0,0)
		)
		color2_tex_tex= StringProperty(
			name= "color2 tex",
			description= "",
			default= ""
		)

		# grain_size
		grain_size= FloatProperty(
			name= "Grain size",
			description= "",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.01
		)

		# diffusion
		diffusion= FloatProperty(
			name= "Diffusion",
			description= "",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

		# mix_ratio
		mix_ratio= FloatProperty(
			name= "Mix ratio",
			description= "",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.5
		)

	bpy.utils.register_class(TexRock)

	rna_pointer.TexRock= PointerProperty(
		name= "TexRock",
		type=  TexRock,
		description= "V-Ray TexRock settings"
	)


'''
  OUTPUT
'''
def write(bus):
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexRock= getattr(texture.vray, PLUG)

	mapped_keys= ('color1_tex', 'color2_tex')
	mapped_params= write_sub_textures(bus,
									  TexRock,
									  [key+'_tex' for key in mapped_keys])

	ofile.write("\n%s %s {"%(PLUG, tex_name))

	PLUGINS['TEXTURE']['TexCommon'].write(bus)

	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen

		elif param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']

		else:
			value= getattr(TexRock, param)

		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))

	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexRock(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexRock= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexRock, 'color1_tex')
		col.prop_search(TexRock,  'color1_tex_tex',
						bpy.data, 'textures',
						text= "")
		if wide_ui:
			col= split.column(align= True)
		col.prop(TexRock, 'color2_tex')
		col.prop_search(TexRock,  'color2_tex_tex',
						bpy.data, 'textures',
						text= "")

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(TexRock, 'grain_size')
		col.prop(TexRock, 'diffusion')
		if wide_ui:
			col= split.column()
		col.prop(TexRock, 'mix_ratio')


def GetRegClasses():
	return (
		VRAY_TP_TexRock,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexSky
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui    import ui


TYPE= 'TEXTURE'

ID=   'TexSky'
NAME= 'Sky'
PLUG= 'TexSky'
DESC= "Sky texture."
PID=  3

PARAMS= (
	#'transform',
	#'target_transform',
	'turbidity',
	'ozone',
	'water_vapour',
	'intensity_multiplier',
	'size_multiplier',
	#'up_vector',
	'invisible',
	'horiz_illum',
	'filter_color',
	'sky_model',
	'sun'
)


def add_properties(VRayTexture):
	class TexSky(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(TexSky)

	VRayTexture.TexSky= PointerProperty(
		name= "TexSky",
		type=  TexSky,
		description= "V-Ray TexSky settings"
	)

	TexSky.auto_sun= BoolProperty(
		name= "Take settings from Sun",
		description= "Take settings from Sun automatically",
		default= True
	)

	TexSky.turbidity= FloatProperty(
		name= "Turbidity",
		description= "TODO",
		min= 2.0,
		max= 100.0,
		soft_min= 2.0,
		soft_max= 10.0,
		precision= 3,
		default= 3.0
	)

	TexSky.ozone= FloatProperty(
		name= "Ozone",
		description= "TODO",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 0.35
	)

	TexSky.water_vapour= FloatProperty(
		name= "Water vapour",
		description= "TODO",
		min= 0.0,
		max= 10.0,
		soft_min= 0.0,
		soft_max= 2.0,
		precision= 3,
		default= 2
	)

	TexSky.intensity_multiplier= FloatProperty(
		name= "Intensity mult.",
		description= "TODO",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 1
	)

	TexSky.size_multiplier= FloatProperty(
		name= "Size mult.",
		description= "TODO",
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		precision= 3,
		default= 1
	)

	TexSky.invisible= BoolProperty(
		name= "Invisible",
		description= "TODO",
		default= False
	)

	TexSky.sun= StringProperty(
		name= "Sun",
		description= "Sun lamp",
		default= ""
	)

	TexSky.horiz_illum= FloatProperty(
		name= "Horiz illumination",
		description= "TODO",
		min= 0.0,
		max= 100000.0,
		soft_min= 0.0,
		soft_max= 10000.0,
		precision= 0,
		default= 25000
	)

	TexSky.sky_model= EnumProperty(
		name= "Sky model",
		description= "Sky model",
		items= (
			('CIEOVER',"CIE Overcast",""),
			('CIECLEAR',"CIE Clear",""),
			('PREETH',"Preetham et al.","")
		),
		default= 'PREETH'
	)


def write(bus):
	SKY_MODEL= {
		'CIEOVER'  : 2,
		'CIECLEAR' : 1,
		'PREETH'   : 0
	}

	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	TexSky= getattr(texture.vray, PLUG)

	# Find Sun lamp
	sun_ob   = None
	sun_light= None
	if TexSky.auto_sun:
		for ob in [ob for ob in scene.objects if ob.type == 'LAMP']:
			if ob.data.type == 'SUN' and ob.data.vray.direct_type == 'SUN':
				sun_ob   = ob
				sun_light= get_name(ob,prefix='LA')
				break
	else:
		if TexSky.sun:
			sub_ob = get_data_by_name(scene, 'objects', TexSky.sun)
			sun_light= get_name(sub_ob, prefix='LA')

	# Write output
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'sky_model':
			ofile.write("\n\t%s= %s;"%(param, SKY_MODEL[TexSky.sky_model]))
		elif param == 'filter_color':
			if sun_ob is None:
				continue
			ofile.write("\n\t%s= %s;"%(param, a(scene, sun_ob.data.color)))
		elif param == 'sun':
			if sun_light is None:
				continue
			ofile.write("\n\t%s= %s;"%(param, sun_light))
		else:
			ofile.write("\n\t%s= %s;"%(param, a(scene, getattr(TexSky, param))))
	ofile.write("\n}\n")

	return tex_name



'''
  GUI
'''
class VRAY_TP_TexSky(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label = NAME

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		if not tex:
			return False
		vtex= tex.vray
		engine= context.scene.render.engine
		return ((tex and tex.type == 'VRAY' and vtex.type == ID) and (engine in __class__.COMPAT_ENGINES))
	
	def draw(self, context):
		tex= context.texture
		TexSky= getattr(tex.vray, PLUG)
		
		wide_ui= context.region.width > ui.narrowui

		layout= self.layout

		split= layout.split()
		col= split.column()
		col.prop(TexSky, 'auto_sun')

		split= layout.split()
		split.active= not TexSky.auto_sun
		col= split.column()
		col.prop(TexSky, 'sky_model')
		if not TexSky.auto_sun:
			col.prop_search(TexSky, 'sun', context.scene, 'objects')

		split= layout.split()
		split.active= not TexSky.auto_sun
		col= split.column()
		col.prop(TexSky, 'turbidity')
		col.prop(TexSky, 'ozone')
		col.prop(TexSky, 'intensity_multiplier')
		col.prop(TexSky, 'size_multiplier')
		if wide_ui:
			col= split.column()
		col.prop(TexSky, 'invisible')
		col.prop(TexSky, 'horiz_illum')
		col.prop(TexSky, 'water_vapour')


def GetRegClasses():
	return (
		VRAY_TP_TexSky,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexSmoke
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexSmoke'
PLUG= 'TexSmoke'
NAME= 'Smoke'
DESC= "TexSmoke."
PID=   22

PARAMS= (
	'uvwgen',
	'color1',
	'color2',
	'size',
	'iterations',
	'phase',
	'exponent'
)




def add_properties(rna_pointer):
	class TexSmoke(bpy.types.PropertyGroup):

		# use_3d_mapping
		use_3d_mapping= BoolProperty(
			name= "use 3d mapping",
			description= "",
			default= True
		)

		#  color1: acolor texture = AColor(1, 1, 1, 1), First color
		color1 = FloatVectorProperty(
			name= "Color 1",
			description= "Color 1",
			subtype= 'COLOR',
			size=4,
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (1,1,1,1)
		)

		color1_tex= StringProperty(
			name= "Color 1 Texture",
			description= "Smoke Texture",
			default= ""
		)

		#  color2: acolor texture = AColor(0, 0, 0, 0), Second color
		color2 = FloatVectorProperty(
			name= "Color 2",
			description= "Color 2",
			subtype= 'COLOR',
			size=4,
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0,0,0,0)
		)

		color2_tex= StringProperty(
			name= "Color 2 Texture",
			description= "Color 2 Texture",
			default= ""
		)
		
		#  size: float = 1, Size
		size= FloatProperty(
			name= "Size",
			description= "Size",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

		#  iterations: integer = 5, Iterations
		iterations= IntProperty(
			name= "Iterations",
			description= "Iterations",
			min= 0,
			max= 100,
			default= 5
		)

		#  phase: float = 0, Phase
		phase= FloatProperty(
			name= "Phase",
			description= "Phase",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0
		)

		#  exponent: float = 1.5, Exponent
		exponent= FloatProperty(
			name= "Exponent",
			description= "Exponent",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1.5
		)


	bpy.utils.register_class(TexSmoke)

	rna_pointer.TexSmoke= PointerProperty(
		name= "TexSmoke",
		type=  TexSmoke,
		description= "V-Ray TexSmoke settings"
	)


def write(bus):
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexSmoke= getattr(texture.vray, PLUG)

	mapped_keys= ('color1', 'color2')
	mapped_params= write_sub_textures(bus,
					  TexSmoke,
					  [key+'_tex' for key in mapped_keys])
	
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen
		elif param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']
		else:
			value= getattr(TexSmoke, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name

'''
  GUI
'''
class VRAY_TP_TexSmoke(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexSmoke= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexSmoke, 'color1', text="Color 1")
		col.prop_search(TexSmoke, 'color1_tex',
						bpy.data,    'textures',
						text= "")

		if wide_ui:
			col= split.column(align= True)
		col.prop(TexSmoke, 'color2', text="Color 2")
		col.prop_search(TexSmoke, 'color2_tex',
						bpy.data,    'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexSmoke, 'size', text="Size")
		col.prop(TexSmoke, 'iterations', text="Iterations")
		col.prop(TexSmoke, 'phase', text="Phase")
		col.prop(TexSmoke, 'exponent', text="Exponent")


#  color1: acolor texture = AColor(1, 1, 1, 1), First color
#  color2: acolor texture = AColor(0, 0, 0, 0), Second color
#  size: float = 1, Size
#  iterations: integer = 5, Iterations
#  phase: float = 0, Phase
#  exponent: float = 1.5, Exponent


def GetRegClasses():
	return (
		VRAY_TP_TexSmoke,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexSnow
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexSnow'
PLUG= 'TexSnow'
NAME= 'Snow'
DESC= "TexSnow."
PID=   24

PARAMS= (
	'uvwgen',
	'snow_tex',
	'surface_tex',
	'threshold',
	'depth_decay',
	'thickness',
)


def add_properties(rna_pointer):
	class TexSnow(bpy.types.PropertyGroup):

		# use_3d_mapping
		use_3d_mapping= BoolProperty(
			name= "use 3d mapping",
			description= "",
			default= True
		)

		#  snow_tex: acolor texture
		snow_tex = FloatVectorProperty(
			name= "Snow",
			description= "Color 1",
			subtype= 'COLOR',
			size=4,
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (1,1,1,1)
		)

		snow_tex_tex= StringProperty(
			name= "Snow Texture",
			description= "Snow Texture",
			default= ""
		)

		#  surface_tex: acolor texture
		surface_tex = FloatVectorProperty(
			name= "Surface",
			description= "Surface",
			subtype= 'COLOR',
			size=4,
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0,0,0,0)
		)

		surface_tex_tex= StringProperty(
			name= "Surface Texture",
			description= "Surface Texture",
			default= ""
		)
		
		#  threshold: float texture
		threshold= FloatProperty(
			name= "Threshold",
			description= "Threshold",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

		threshold_tex= StringProperty(
			name= "Threshold Texture",
			description= "Threshold Texture",
			default= ""
		)

		#  depth_decay: float texture
		depth_decay= FloatProperty(
			name= "Depth Decay",
			description= "Depth Decay",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 4
		)

		depth_decay_tex= StringProperty(
			name= "Depth Decay Texture",
			description= "Depth Decay Texture",
			default= ""
		)

		#  thickness: float texture
		thickness= FloatProperty(
			name= "Thickness",
			description= "Thickness",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.2
		)
		
		thickness_tex= StringProperty(
			name= "Thickness Texture",
			description= "Thickness Texture",
			default= ""
		)

	bpy.utils.register_class(TexSnow)

	rna_pointer.TexSnow= PointerProperty(
		name= "TexSnow",
		type=  TexSnow,
		description= "V-Ray TexSnow settings"
	)


def write(bus):
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexSnow= getattr(texture.vray, PLUG)

	mapped_keys= ('snow_tex', 'surface_tex', 'threshold', 'depth_decay', 'thickness')
	mapped_params= write_sub_textures(bus,
					  TexSnow,
					  [key+'_tex' for key in mapped_keys])
	
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen
		elif param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']
		else:
			value= getattr(TexSnow, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name

'''
  GUI
'''
class VRAY_TP_TexSnow(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexSnow= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexSnow, 'snow_tex', text="Color 1")
		col.prop_search(TexSnow, 'snow_tex_tex',
						bpy.data,    'textures',
						text= "")

		if wide_ui:
			col= split.column(align= True)
		col.prop(TexSnow, 'surface_tex', text="Color 2")
		col.prop_search(TexSnow, 'surface_tex_tex',
						bpy.data,    'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexSnow, 'threshold')
		col.prop_search(TexSnow, 'threshold_tex',
						bpy.data,    'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexSnow, 'depth_decay')
		col.prop_search(TexSnow, 'depth_decay_tex',
						bpy.data,    'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexSnow, 'thickness')
		col.prop_search(TexSnow, 'thickness_tex',
						bpy.data,    'textures',
						text= "")


def GetRegClasses():
	return (
		VRAY_TP_TexSnow,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexSpeckle
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexSpeckle'
PLUG= 'TexSpeckle'
NAME= 'Speckle'
DESC= "TexSpeckle."
PID=   21

PARAMS= (
	'color1',
	'color2',
	'size',
)





def add_properties(rna_pointer):
	class TexSpeckle(bpy.types.PropertyGroup):

		# use_3d_mapping
		use_3d_mapping= BoolProperty(
			name= "use 3d mapping",
			description= "",
			default= True
		)

		#  color1: acolor texture = AColor(1, 1, 1, 1), First color
		color1 = FloatVectorProperty(
			name= "Color 1",
			description= "Color 1",
			subtype= 'COLOR',
			size=4,
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (1,1,1,1)
		)

		color1_tex= StringProperty(
			name= "Color 1 Texture",
			description= "Speckle Texture",
			default= ""
		)

		#  color2: acolor texture = AColor(0, 0, 0, 0), Second color
		color2 = FloatVectorProperty(
			name= "Color 2",
			description= "Color 2",
			subtype= 'COLOR',
			size=4,
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0,0,0,1)
		)

		color2_tex= StringProperty(
			name= "Color 2 Texture",
			description= "Color 2 Texture",
			default= ""
		)
		
		#  size: float = 1, Size
		size= FloatProperty(
			name= "Size",
			description= "Size",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)


	bpy.utils.register_class(TexSpeckle)

	rna_pointer.TexSpeckle= PointerProperty(
		name= "TexSpeckle",
		type=  TexSpeckle,
		description= "V-Ray TexSpeckle settings"
	)


def write(bus):
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexSpeckle= getattr(texture.vray, PLUG)

	mapped_keys= ('color1', 'color2')
	mapped_params= write_sub_textures(bus,
					  TexSpeckle,
					  [key+'_tex' for key in mapped_keys])
	
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen
		elif param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']
		else:
			value= getattr(TexSpeckle, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name

'''
  GUI
'''
class VRAY_TP_TexSpeckle(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexSpeckle= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexSpeckle, 'color1', text="Color 1")
		col.prop_search(TexSpeckle, 'color1_tex',
						bpy.data,    'textures',
						text= "")

		if wide_ui:
			col= split.column(align= True)
		col.prop(TexSpeckle, 'color2', text="Color 2")
		col.prop_search(TexSpeckle, 'color2_tex',
						bpy.data,    'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexSpeckle, 'size', text="Size")


def GetRegClasses():
	return (
		VRAY_TP_TexSpeckle,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexSplat
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexSplat'
PLUG= 'TexSplat'
NAME= 'Splat'
DESC= "TexSplat."
PID=   10

PARAMS= (
	'color1',
	'color2',
	'size',
	'iterations',
	'threshold',
	'smoothing',
	'uvwgen',
)


def add_properties(rna_pointer):
	class TexSplat(bpy.types.PropertyGroup):
		# use_3d_mapping
		use_3d_mapping= BoolProperty(
			name= "use 3d mapping",
			description= "",
			default= True
		)

		# color1
		color1= FloatVectorProperty(
			name= "First color",
			description= "First color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (1,1,1)
		)

		color1_tex= StringProperty(
			name= "Color texture ",
			description= "Color texture",
			default= ""
		)

		# color2
		color2= FloatVectorProperty(
			name= "Second color",
			description= "Second color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0,0,0)
		)

		color2_tex= StringProperty(
			name= "Color texture ",
			description= "Color texture",
			default= ""
		)

		# size
		size= FloatProperty(
			name= "Size",
			description= "Size",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

		# iterations
		iterations= IntProperty(
			name= "Iterations",
			description= "Number of iterations for the fractal generator",
			min= 0,
			max= 100,
			soft_min= 0,
			soft_max= 10,
			default= 4
		)

		# threshold
		threshold= FloatProperty(
			name= "Threshold",
			description= "Threshold",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.2
		)

		# smoothing
		smoothing= FloatProperty(
			name= "Smoothing",
			description= "Transition smoothing",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.02
		)

	bpy.utils.register_class(TexSplat)

	rna_pointer.TexSplat= PointerProperty(
		name= "TexSplat",
		type=  TexSplat,
		description= "V-Ray TexSplat settings"
	)


def write(bus):
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexSplat= getattr(texture.vray, PLUG)

	mapped_params= write_sub_textures(bus,
									  TexSplat,
									  ('color1_tex', 'color2_tex'))

	ofile.write("\n%s %s {"%(PLUG, tex_name))

	PLUGINS['TEXTURE']['TexCommon'].write(bus)

	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen

		elif param in ('color1','color2') and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']

		else:
			value= getattr(TexSplat, param)

		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))

	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexSplat(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexSplat= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexSplat, 'color1')
		col.prop_search(TexSplat, 'color1_tex',
						bpy.data, 'textures',
						text= "")
		if wide_ui:
			col= split.column(align= True)
		col.prop(TexSplat, 'color2')
		col.prop_search(TexSplat, 'color2_tex',
						bpy.data, 'textures',
						text= "")

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(TexSplat, 'size')
		col.prop(TexSplat, 'iterations')
		if wide_ui:
			col= split.column()
		col.prop(TexSplat, 'threshold')
		col.prop(TexSplat, 'smoothing')


def GetRegClasses():
	return (
		VRAY_TP_TexSplat,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexStucco
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexStucco'
PLUG= 'TexStucco'
NAME= 'Stucco'
DESC= "TexStucco"
PID=   20

PARAMS= (
	'uvwgen',
	'color1',
	'color2',
	'size',
	'thickness',
	'threshold'
)


def add_properties(rna_pointer):
	class TexStucco(bpy.types.PropertyGroup):

		# use_3d_mapping
		use_3d_mapping= BoolProperty(
			name= "use 3d mapping",
			description= "",
			default= True
		)

		#  color1: acolor texture = AColor(1, 1, 1, 1), First color
		color1 = FloatVectorProperty(
			name= "Color 1",
			description= "Color 1",
			subtype= 'COLOR',
			size=4,
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (1,1,1,1)
		)

		color1_tex= StringProperty(
			name= "Color 1 Texture",
			description= "Color 1 Texture",
			default= ""
		)

		#  color2: acolor texture = AColor(0, 0, 0, 0), Second color
		color2 = FloatVectorProperty(
			name= "Color 2",
			description= "Color 2",
			subtype= 'COLOR',
			size=4,
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0,0,0,0)
		)

		color2_tex= StringProperty(
			name= "Color 2 Texture",
			description= "Color 2 Texture",
			default= ""
		)
		
		#  size: float = 1, Size
		size= FloatProperty(
			name= "Size",
			description= "Size",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.1
		)

		#  thickness: float = 4, Thickness
		thickness= FloatProperty(
			name= "Thickness",
			description= "Thickness",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.4
		)

		#  threshold: float = 0.2, Threshold
		threshold= FloatProperty(
			name= "Threshold",
			description= "Threshold",
			min= 0.0,
			max= 1000.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.2
		)
		

	bpy.utils.register_class(TexStucco)

	rna_pointer.TexStucco= PointerProperty(
		name= "TexStucco",
		type=  TexStucco,
		description= "V-Ray TexStucco settings"
	)


def write(bus):
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexStucco= getattr(texture.vray, PLUG)

	mapped_keys= ('color1', 'color2')
	mapped_params= write_sub_textures(bus,
					  TexStucco,
					  [key+'_tex' for key in mapped_keys])
	
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen
		elif param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']
		else:
			value= getattr(TexStucco, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexStucco(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexStucco= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexStucco, 'color1', text="Color 1")
		col.prop_search(TexStucco, 'color1_tex',
						bpy.data,    'textures',
						text= "")

		if wide_ui:
			col= split.column(align= True)
		col.prop(TexStucco, 'color2', text="Color 2")
		col.prop_search(TexStucco, 'color2_tex',
						bpy.data,    'textures',
						text= "")

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexStucco, 'size')
		col.prop(TexStucco, 'thickness')
		col.prop(TexStucco, 'threshold')


def GetRegClasses():
	return (
		VRAY_TP_TexStucco,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexSwirl
#
# V-Ray/Blender
#
# http://vray.cgdo.ru
#
# Author: Andrey M. Izrantsev (aka bdancer)
# E-Mail: izrantsev@cgdo.ru
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
#


# Blender module
import bpy
from bpy.props import *

# V-Ray/Blender modules
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE   = 'TEXTURE'
ID     = 'TexSwirl'
PLUG   = 'TexSwirl'

NAME   = 'Swirl'
DESC   = "TexSwirl"

PID    = 15

PARAMS = (
	'uvwgen',
	'color1',
	'color2',
	'swirl_intensity',
	'color_contrast',
	'swirl_amount',
	'constant_detail',
	'center_x',
	'center_y',
	'random_seed',
	'twist',
)

def add_properties(rna_pointer):
	class TexSwirl(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(TexSwirl)

	rna_pointer.TexSwirl= PointerProperty(
		name= "TexSwirl",
		type=  TexSwirl,
		description= "V-Ray TexSwirl settings"
	)

	TexSwirl.color1= FloatVectorProperty(
		name= "Color 1",
		description= "First color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (1,1,1)
	)

	# color2
	TexSwirl.color2= FloatVectorProperty(
		name= "Color 2",
		description= "Second color",
		subtype= 'COLOR',
		min= 0.0,
		max= 1.0,
		soft_min= 0.0,
		soft_max= 1.0,
		default= (0,0,0)
	)

	# swirl_intensity
	TexSwirl.swirl_intensity= FloatProperty(
		name= "Swirl Intensity",
		description= "Swirl Intensity",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 2
	)

	# color_contrast
	TexSwirl.color_contrast= FloatProperty(
		name= "Color Contrast",
		description= "Color Contrast",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.4
	)

	# swirl_amount
	TexSwirl.swirl_amount= FloatProperty(
		name= "Swirl Amount",
		description= "Swirl Amount",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	# constant_detail
	TexSwirl.constant_detail= IntProperty(
		name= "Constant Detail",
		description= "Constant Detail",
		min= 0,
		max= 100,
		soft_min= 0,
		soft_max= 10,
		default= 4
	)

	# center_x
	TexSwirl.center_x= FloatProperty(
		name= "Center X",
		description= "Center Position X",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= -0.5
	)

	# center_y
	TexSwirl.center_y= FloatProperty(
		name= "Center Y",
		description= "Center Position Y",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= -0.5
	)

	# random_seed
	TexSwirl.random_seed= FloatProperty(
		name= "Random Seed",
		description= "Random Seed",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0
	)

	# twist
	TexSwirl.twist= FloatProperty(
		name= "Twist",
		description= "Twist",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)


'''
  OUTPUT
'''
def write(bus):
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexSwirl= getattr(texture.vray, PLUG)

	ofile.write("\n%s %s {"%(PLUG, tex_name))

	PLUGINS['TEXTURE']['TexCommon'].write(bus)

	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen
		else:
			value= getattr(TexSwirl, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))

	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexSwirl(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex = context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui = context.region.width > ui.narrowui
		layout  = self.layout

		tex= context.texture
		TexSwirl= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column()
		col.prop(TexSwirl, 'color1', text="")
		if wide_ui:
			col= split.column()
		col.prop(TexSwirl, 'color2', text="")

		split= layout.split()
		col= split.column(align=True)
		col.prop(TexSwirl, 'swirl_amount', text="Amount")
		col.prop(TexSwirl, 'swirl_intensity', text="Intensity")
		col.prop(TexSwirl, 'color_contrast', text="Color Contrast")
		if not wide_ui:
			split= layout.split()
		col= split.column(align=True)
		col.prop(TexSwirl, 'twist')
		col.prop(TexSwirl, 'constant_detail')

		split= layout.split()
		row= split.row(align=True)
		row.prop(TexSwirl, 'center_x')
		row.prop(TexSwirl, 'center_y')

		split= layout.split()
		col= split.column()
		col.prop(TexSwirl, 'random_seed', text="Seed")


def GetRegClasses():
	return (
		VRAY_TP_TexSwirl,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexTiles
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''

''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *

TYPE= 'TEXTURE'
ID=   'TexTiles'
PLUG= 'TexTiles'
NAME= 'Tiles'
DESC= "TexTiles."
PID=   8

PARAMS= (
	'color_mortar',
	'color_tiles',
	'horizontal_count',
	'vertical_count',
	'color_variance',
	'horizontal_gap',
	'vertical_gap',
	'pattern_type',
	'line_shift',
	'random_shift',
	'edge_roughness',
	'holes',
	'random_seed',
	'fade_variance',
	'row_modify',
	'column_modify',
	'per_row',
	'row_change',
	'per_column',
	'column_change',
	'uvwgen',
)

def add_properties(rna_pointer):
	class TexTiles(bpy.types.PropertyGroup):
		# color_mortar
		color_mortar= FloatVectorProperty(
			name= "Mortar",
			description= "Mortar color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0.7,0.7,0.7)
		)

		color_mortar_tex= StringProperty(
			name= "Mortar texture ",
			description= "Mortar color texture",
			default= ""
		)

		# color_tiles
		color_tiles= FloatVectorProperty(
			name= "Tiles",
			description= "Tiles color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0.6,0.5,0.4)
		)

		color_tiles_tex= StringProperty(
			name= "Tiles texture ",
			description= "Tiles color texture",
			default= ""
		)

		# horizontal_count
		horizontal_count= FloatProperty(
			name= "Horizontal count",
			description= "Tiles horizontal count",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 4
		)

		# vertical_count
		vertical_count= FloatProperty(
			name= "Vertical count",
			description= "Tiles vertical count",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 4
		)

		# color_variance
		color_variance= FloatProperty(
			name= "Color variance",
			description= "Color variance",
			subtype= 'PERCENTAGE',
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 100.0,
			precision= 1,
			default= 0
		)

		# horizontal_gap
		horizontal_gap= FloatProperty(
			name= "Horizontal gap",
			description= "Horizontal gap between tiles",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.5
		)

		# vertical_gap
		vertical_gap= FloatProperty(
			name= "Vertical gap",
			description= "Vertical gap between tiles",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.5
		)

		# pattern_type
		pattern_type= EnumProperty(
			name= "Pattern type",
			description= "Tiles pattern",
			items= (
				('CUSTOM_TILES',    "Custom Tiles",        "Custom Tiles."), # 0
				('RUNNING_BOND',    "Running Bond",        "Running Bond."),
				('FLEMISH_BOND',    "Common Flemish Bond", "Common Flemish Bond."),
				('ENGLISH_BOND',    "English Bond",        "English Bond."),
				('RUNNING BOND',    "1/2 Running Bond",    "1/2 Running Bond."),
				('STACK_BOND',      "Stack Bond",          "Stack Bond."),
				('FINE_BOND',       "Fine Running Bond",   "Fine Running Bond."),
				('FINE_STACK_BOND', "Fine Stack Bond",     "Fine Stack Bond."),
			),
			default= 'STACK_BOND'
		)

		# line_shift
		line_shift= FloatProperty(
			name= "Line shift",
			description= "Line shift",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.5
		)

		# random_shift
		random_shift= FloatProperty(
			name= "Random shift",
			description= "Random shift",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0
		)

		# edge_roughness
		edge_roughness= FloatProperty(
			name= "Edge roughness",
			description= "Edge roughness",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0
		)

		# holes
		holes= IntProperty(
			name= "Holes",
			description= "Holes",
			subtype= 'PERCENTAGE',
			min= 0,
			max= 100,
			soft_min= 0,
			soft_max= 100,
			default= 0
		)

		# random_seed
		random_seed= IntProperty(
			name= "Random seed",
			description= "Random seed",
			min= 0,
			max= 100000,
			soft_min= 0,
			soft_max= 10000,
			default= 0
		)

		# fade_variance
		fade_variance= FloatProperty(
			name= "Fade variance",
			description= "Fade variance",
			subtype= 'PERCENTAGE',
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 100.0,
			precision= 1,
			default= 0.0
		)

		# row_modify
		row_modify= BoolProperty(
			name= "Row modify",
			description= "Custom row parameters",
			default= 0
		)

		# column_modify
		column_modify= BoolProperty(
			name= "Column modify",
			description= "Custom column parameters",
			default= 0
		)

		# per_row
		per_row= IntProperty(
			name= "Per row",
			description= "every per_row row is modified by corresponding change value",
			min= 0,
			max= 100,
			soft_min= 0,
			soft_max= 10,
			default= 2
		)

		# row_change
		row_change= FloatProperty(
			name= "Row change",
			description= "row change value modifying the number of tiles in affected rows",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

		# per_column
		per_column= IntProperty(
			name= "Per column",
			description= "every per_column column is modified by corresponding change value",
			min= 0,
			max= 100,
			soft_min= 0,
			soft_max= 10,
			default= 2
		)

		# column_change
		column_change= FloatProperty(
			name= "Col change",
			description= "column change value modifying the number of tiles in affected columns",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

	bpy.utils.register_class(TexTiles)

	rna_pointer.TexTiles= PointerProperty(
		name= "TexTiles",
		type=  TexTiles,
		description= "V-Ray TexTiles settings"
	)


def write(bus):
	PATTERN_TYPE= {
		'CUSTOM_TILES':    0,
		'RUNNING_BOND':    1,
		'FLEMISH_BOND':    2,
		'ENGLISH_BOND':    3,
		'RUNNING BOND':    4,
		'STACK_BOND':      5,
		'FINE_BOND':       6,
		'FINE_STACK_BOND': 7,
	}

	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexTiles= getattr(texture.vray, PLUG)
	
	mapped_keys= ('color_mortar', 'color_tiles')
	mapped_params= write_sub_textures(bus,
									  TexTiles,
									  [key+'_tex' for key in mapped_keys])

	ofile.write("\n%s %s {"%(PLUG, tex_name))

	PLUGINS['TEXTURE']['TexCommon'].write(bus)

	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen

		elif param =='pattern_type':
			value= PATTERN_TYPE[TexTiles.pattern_type]

		elif param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']

		else:
			value= getattr(TexTiles, param)

		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))

	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexTiles(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexTiles= getattr(tex.vray, PLUG)

		split= layout.split()
		col= split.column(align= True)
		col.prop(TexTiles, 'color_mortar')
		col.prop_search(TexTiles, 'color_mortar_tex',
						bpy.data, 'textures',
						text= "")
		if wide_ui:
			col= split.column(align= True)
		col.prop(TexTiles, 'color_tiles')
		col.prop_search(TexTiles, 'color_tiles_tex',
						bpy.data, 'textures',
						text= "")

		layout.separator()

		layout.prop(TexTiles, 'pattern_type')

		layout.separator()

		box= layout.box()
		box.label(text="Tiles setup:")
		split= box.split()
		col= split.column()
		col.prop(TexTiles, 'horizontal_count', text= "H. count")
		col.prop(TexTiles, 'vertical_count', text= "V. count")
		if wide_ui:
			col= split.column()
		col.prop(TexTiles, 'color_variance', text= "Color var.")
		col.prop(TexTiles, 'fade_variance', text= "Fade var.")

		layout.separator()

		box= layout.box()
		box.label(text="Grout setup:")
		split= box.split()
		col= split.column()
		col.prop(TexTiles, 'horizontal_gap', text= "H. gap")
		col.prop(TexTiles, 'vertical_gap', text= "V. gap")
		if wide_ui:
			col= split.column()
		col.prop(TexTiles, 'holes')
		col.prop(TexTiles, 'edge_roughness', text= "Edge rough.")

		layout.separator()

		box= layout.box()
		box.active= TexTiles.pattern_type == 'CUSTOM_TILES'
		box.label(text="Custom setup:")
		split= box.split()
		col= split.column()
		col.prop(TexTiles, 'column_modify')
		if TexTiles.column_modify:
			col.prop(TexTiles, 'per_column')
			col.prop(TexTiles, 'column_change')
		if wide_ui:
			col= split.column()
		col.prop(TexTiles, 'row_modify')
		if TexTiles.row_modify:
			col.prop(TexTiles, 'per_row')
			col.prop(TexTiles, 'row_change')

		box.separator()

		split= box.split()
		col= split.column()
		col.prop(TexTiles, 'line_shift')
		if wide_ui:
			col= split.column()
		col.prop(TexTiles, 'random_shift')

		box.separator()

		box.prop(TexTiles, 'random_seed')


def GetRegClasses():
	return (
		VRAY_TP_TexTiles,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexWater
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexWater'
PLUG= 'TexWater'
NAME= 'Water'
DESC= "Water."
PID=   27

PARAMS= (
	'uvwgen',
	'height_mult',
	'wind_direction',
	'wind_magnitude',
	'wind_direction_mult',
	'choppy_mult',
	'movement_rate',
	'seed',
	'resolution',
	'patch_size',
)

def add_properties(rna_pointer):
	class TexWater(bpy.types.PropertyGroup):

		# use_3d_mapping
		use_3d_mapping  = BoolProperty(
			name        = "use 3d mapping",
			description = "",
			default     = True
		)

		# height_mult: float = 1, multiplier for the height of the water
		height_mult = FloatProperty(
			name        = "Height Mult",
			description = "multiplier for the height of the water",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 1
		)

		# wind_direction: float = 0, direction of the wind
		wind_direction  = FloatProperty(
			name        = "Wind Direction",
			description = "direction of the wind",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0
		)

		# wind_magnitude: float = 0, magnitude of the wind
		wind_magnitude  = FloatProperty(
			name        = "Wind Magnitude",
			description = "magnitude of the wind",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 800
		)

		#  wind_direction_mult: float = 0
		wind_direction_mult = FloatProperty(
			name        = "Wind Direction Mult",
			description = "Wind Direction Mult",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0
		)

		#  choppy_mult: float = 0
		choppy_mult = FloatProperty(
			name        = "Choppy Mult",
			description = "Choppy Mult",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 0
		)

		#  movement_rate: float = 1
		movement_rate = FloatProperty(
			name        = "Movement rate",
			description = "Movement rate",
			min         = 0.0,
			max         = 1000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 1.0
		)

		# seed: integer = 1, Used to produce different waters
		seed = IntProperty(
			name        = "Seed",
			description = "Used to produce different waters",
			min         = 0,
			max         = 100,
			soft_min    = 0,
			soft_max    = 10,
			default     = 1
		)

		# resolution: integer = 4, Resolution -> real resolution is 2^res
		resolution = IntProperty(
			name        = "Resolution",
			description = "Resolution -> real resolution is 2^res",
			min         = 0,
			max         = 10000,
			soft_min    = 0,
			soft_max    = 10,
			default     = 512
		)

		# patch_size: float = 128, Size of the patch -> real resolution is 2^res
		patch_size = FloatProperty(
			name        = "Size",
			description = "Size of the patch -> real resolution is 2^res",
			min         = 0.0,
			max         = 10000.0,
			soft_min    = 0.0,
			soft_max    = 10.0,
			precision   = 3,
			default     = 128
		)


	bpy.utils.register_class(TexWater)

	rna_pointer.TexWater = PointerProperty(
		name        = "TexWater",
		type        =  TexWater,
		description = "V-Ray TexWater settings"
	)


def write(bus):
	scene    = bus['scene']
	ofile    = bus['files']['textures']

	texture  = bus['mtex']['texture']
	tex_name = bus['mtex']['name']

	uvwgen   = write_uvwgen(bus)

	TexWater = getattr(texture.vray, PLUG)
	
	ofile.write("\n%s %s {"%(PLUG, tex_name))
	for param in PARAMS:
		if param == 'uvwgen':
			value = uvwgen
		else:
			value = getattr(TexWater, param)
		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))
	ofile.write("\n}\n")

	return tex_name

'''
  GUI
'''
class VRAY_TP_TexWater(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexWater= getattr(tex.vray, PLUG)

		layout.prop(TexWater, 'height_mult', text="Height Multiplier")

		split = layout.split()
		col = split.column(align=True)
		col.prop(TexWater, 'wind_direction', text="Wind Direction")
		col.prop(TexWater, 'wind_magnitude', text="Wind Magnitude")
		col.prop(TexWater, 'wind_direction_mult', text="Wind Magnitude Multiplier")

		split = layout.split()
		col = split.column(align=True)
		col.prop(TexWater, 'choppy_mult', text="Choppy Multiplier")
		col.prop(TexWater, 'movement_rate', text="Rate")

		split = layout.split()
		col = split.column(align=True)
		col.prop(TexWater, 'resolution', text="Resolution")
		col.prop(TexWater, 'patch_size', text="Patch size")

		layout.prop(TexWater, 'seed', text="Seed")


def GetRegClasses():
	return (
		VRAY_TP_TexWater,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = TexWood
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils   import *
from vb25.ui      import ui
from vb25.plugins import *
from vb25.texture import *
from vb25.uvwgen  import *


TYPE= 'TEXTURE'
ID=   'TexWood'
PLUG= 'TexWood'
NAME= 'Wood'
DESC= "TexWood."
PID=   11

PARAMS= (
	'uvwgen',
	'filler_color_tex',
	'vein_color_tex',
	'vein_spread',
	'layer_size',
	'randomness',
	'age',
	'grain_color_tex',
	'grain_contr',
	'grain_spacing',
	'center_u',
	'center_v',
	'amplitude_x',
	'amplitude_y',
	'ratio',
	'ripples_x',
	'ripples_y',
	'ripples_z',
	'depth_min',
	'depth_max',
)


def add_properties(rna_pointer):
	class TexWood(bpy.types.PropertyGroup):
		# use_3d_mapping
		use_3d_mapping= BoolProperty(
			name= "use 3d mapping",
			description= "",
			default= True
		)

		# wrap
		wrap= BoolProperty(
			name= "Wrap",
			description= "",
			default= True
		)

		# filler_color_tex
		filler_color_tex= FloatVectorProperty(
			name= "Filler color",
			description= "Filler color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0.564694, 0.488278, 0.304942)
		)
		filler_color_tex_tex= StringProperty(
			name= "Filler texture",
			description= "Filler texture",
			default= ""
		)

		# vein_color_tex
		vein_color_tex= FloatVectorProperty(
			name= "Vein color",
			description= "Vein color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0.123518, 0.071829, 0.043644)
		)
		vein_color_tex_tex= StringProperty(
			name= "Vein texture",
			description= "Vein texture",
			default= ""
		)


		# vein_spread
		vein_spread= FloatProperty(
			name= "Vein spread",
			description= "Vein spread",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.25
		)

		# layer_size
		layer_size= FloatProperty(
			name= "Layer size",
			description= "Layer size",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.05
		)

		# randomness
		randomness= FloatProperty(
			name= "Randomness",
			description= "Randomness",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.5
		)

		# age
		age= FloatProperty(
			name= "Age",
			description= "Age",
			min= 0.0,
			max= 10000.0,
			soft_min= 0.0,
			soft_max= 100.0,
			precision= 3,
			default= 20
		)

		# grain_color_tex
		grain_color_tex= FloatVectorProperty(
			name= "Grain color",
			description= "Grain color",
			subtype= 'COLOR',
			min= 0.0,
			max= 1.0,
			soft_min= 0.0,
			soft_max= 1.0,
			default= (0.035282, 0.020518, 0.012467)
		)
		grain_color_tex_tex= StringProperty(
			name= "Grain texture",
			description= "Grain texture",
			default= ""
		)


		# grain_contr
		grain_contr= FloatProperty(
			name= "Grain contribution",
			description= "Grain contribution",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.5
		)

		# grain_spacing
		grain_spacing= FloatProperty(
			name= "Grain spacing",
			description= "Grain spacing",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.01
		)

		# center_u
		center_u= FloatProperty(
			name= "Center U",
			description= "Center U",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.5
		)

		# center_v
		center_v= FloatProperty(
			name= "Center V",
			description= "Center V",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= -0.5
		)

		# amplitude_x
		amplitude_x= FloatProperty(
			name= "Amplitude X",
			description= "Amplitude X",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0
		)

		# amplitude_y
		amplitude_y= FloatProperty(
			name= "Amplitude Y",
			description= "Amplitude Y",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0
		)

		# ratio
		ratio= FloatProperty(
			name= "Ratio",
			description= "Ratio",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0.35
		)

		# ripples_x
		ripples_x= FloatProperty(
			name= "Ripples X",
			description= "Ripples X",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

		# ripples_y
		ripples_y= FloatProperty(
			name= "Ripples Y",
			description= "Ripples Y",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

		# ripples_z
		ripples_z= FloatProperty(
			name= "Ripples Z",
			description= "Ripples Z",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 1
		)

		# depth_min
		depth_min= FloatProperty(
			name= "Depth min",
			description= "",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 0
		)

		# depth_max
		depth_max= FloatProperty(
			name= "Depth max",
			description= "",
			min= 0.0,
			max= 100.0,
			soft_min= 0.0,
			soft_max= 10.0,
			precision= 3,
			default= 8
		)

	bpy.utils.register_class(TexWood)

	rna_pointer.TexWood= PointerProperty(
		name= "TexWood",
		type=  TexWood,
		description= "V-Ray TexWood settings"
	)


'''
  OUTPUT
'''
def write(bus):
	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvwgen= write_uvwgen(bus)

	TexWood= getattr(texture.vray, PLUG)

	mapped_keys= ('filler_color_tex', 'vein_color_tex', 'grain_color_tex')
	mapped_params= write_sub_textures(bus,
									  TexWood,
									  [key+'_tex' for key in mapped_keys])

	ofile.write("\n%s %s {"%(PLUG, tex_name))

	PLUGINS['TEXTURE']['TexCommon'].write(bus)

	for param in PARAMS:
		if param == 'uvwgen':
			value= uvwgen

		elif param in mapped_keys and param+'_tex' in mapped_params:
			value= mapped_params[param+'_tex']

		else:
			value= getattr(TexWood, param)

		ofile.write("\n\t%s= %s;"%(param, a(scene, value)))

	ofile.write("\n}\n")

	return tex_name


'''
  GUI
'''
class VRAY_TP_TexWood(ui.VRayTexturePanel, bpy.types.Panel):
	bl_label       = NAME
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture
		return tex and tex.type == 'VRAY' and tex.vray.type == ID and ui.engine_poll(cls, context)

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		tex= context.texture
		TexWood= getattr(tex.vray, PLUG)

		layout.label(text="Colors:")

		split= layout.split()
		row= split.row(align= True)
		row.prop(TexWood, 'filler_color_tex', text="")
		row.prop(TexWood, 'vein_color_tex', text="")
		row.prop(TexWood, 'grain_color_tex', text="")

		layout.label(text="Textures:")

		split= layout.split()
		row= split.row(align= True)
		row.prop_search(TexWood,  'filler_color_tex_tex',
						bpy.data, 'textures',
						text= "")
		row.prop_search(TexWood,  'vein_color_tex_tex',
						bpy.data, 'textures',
						text= "")
		row.prop_search(TexWood,  'grain_color_tex_tex',
						bpy.data, 'textures',
						text= "")

		layout.separator()

		layout.label(text="Ripples:")

		split= layout.split()
		row= split.row(align= True)
		row.prop(TexWood, 'ripples_x', text="X")
		row.prop(TexWood, 'ripples_y', text="Y")
		row.prop(TexWood, 'ripples_z', text="Z")

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(TexWood, 'age')
		col.prop(TexWood, 'vein_spread')
		if wide_ui:
			col= split.column()
		col.prop(TexWood, 'grain_contr')
		col.prop(TexWood, 'grain_spacing')

		split= layout.split()
		col= split.column()
		sub= col.column(align= True)
		sub.prop(TexWood, 'center_u')
		sub.prop(TexWood, 'center_v')
		if wide_ui:
			col= split.column()
		sub= col.column(align= True)
		sub.prop(TexWood, 'amplitude_x')
		sub.prop(TexWood, 'amplitude_y')

		split= layout.split()
		col= split.column()
		col.prop(TexWood, 'layer_size')
		col.prop(TexWood, 'ratio')
		if wide_ui:
			col= split.column()
		sub= col.column(align= True)
		sub.prop(TexWood, 'depth_min')
		sub.prop(TexWood, 'depth_max')

		split= layout.split()
		col= split.column()
		col.prop(TexWood, 'randomness')


def GetRegClasses():
	return (
		VRAY_TP_TexWood,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = VRayStereoscopicSettings
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui import ui


TYPE = 'SETTINGS'
ID   = 'VRayStereoscopicSettings'
PLUG = 'VRayStereoscopicSettings'

NAME = 'VRayStereoscopicSettings'
DESC = "VRay Stereoscopic Settings"

PARAMS = (	
)


def add_properties(rna_pointer):
	class VRayStereoscopicSettings(bpy.types.PropertyGroup):
		pass
	bpy.utils.register_class(VRayStereoscopicSettings)

	rna_pointer.VRayStereoscopicSettings= PointerProperty(
		name= "VRayStereoscopicSettings",
		type=  VRayStereoscopicSettings,
		description= "V-Ray VRayStereoscopicSettings settings"
	)

	VRayStereoscopicSettings.use= BoolProperty(
		name= "Stereoscopic",
		description= "Use stereoscopic render",
		default= False
	)

	
	VRayStereoscopicSettings.left_camera= StringProperty(
		name= "Left Camera",
		description= "Left camera",
		default= ""
	)
	
	VRayStereoscopicSettings.right_camera= StringProperty(
		name= "Right Camera",
		description= "Right camera",
		default= ""
	)

	VRayStereoscopicSettings.eye_distance= FloatProperty(
		name= "Eye Distance",
		description= "The eye distance for which the stereoscopic image will be rendered",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 0.065
	)

	VRayStereoscopicSettings.specify_focus= BoolProperty(
		name= "Specify Focus",
		description= "If on then the focus is determined by 'Focus' and 'Focus Distance'",
		default= False
	)

	VRayStereoscopicSettings.focus_distance= FloatProperty(
		name= "Focus Distance",
		description= "Focus distance",
		min= 0.0,
		max= 100000.0,
		soft_min= 0.0,
		soft_max= 1000.0,
		precision= 3,
		default= 200
	)

	VRayStereoscopicSettings.focus_method= EnumProperty(
		name= "Focus Method",
		description= "Specifies the focus method for the two views",
		items= (
			('NONE',  "None",     "Both cameras have their focus points directly in front of them"),
			('ROT',   "Rotation", "The stereoscopy is achieved by rotating the left and right views so that their focus points coincide at the distance from the eyes where the lines of sight for each eye converge called fusion distance"),
			('SHEAR', "Shear",    "The orientation of both views remain the same but each eyes view is sheared along Z so that the two frustums converge at the fusion distance"),
		),
		default= 'NONE'
	)

	VRayStereoscopicSettings.interocular_method= EnumProperty(
		name= "Interocular Method",
		description= "Specifies how the two virtual cameras will be placed in relation to the real camera in the scene",
		items= (		
			('BOTH',  "Shift Both",  "Both virtual cameras will be shifted in opposite directions at a distance equal to half of the eye distance"),
			('LEFT',  "Shift Left",  "The virtual cameras are shifted to the left so that the right camera takes the position of the original camera. The left camera is shifted to the left at a distance equal to the 'Eye Distance'"),
			('RIGHT', "Shift Right", "The virtual cameras are shifted to the right so that the left camera takes the position of the original camera. The right camera is shifted to the right at a distance equal to the 'Eye Distance'")
		),
		default= 'BOTH'
	)

	VRayStereoscopicSettings.view= EnumProperty(
		name= "View",
		description= "Specifies which of the stereoscopic views will be rendered",
		items= (		
			('BOTH',  "Both",  "Both views will be rendered side by side"),
			('LEFT',  "Left",  "Only the left view will be rendered"),
			('RIGHT', "Right", "Only the right view will be rendered")
		),
		default= 'BOTH'
	)

	VRayStereoscopicSettings.adjust_resolution= BoolProperty(
		name= "Adjust Resolution",
		description= "When on this option will automatically adjust the resolution for the final image rendered",
		default= False
	)

	VRayStereoscopicSettings.deep_pixel_mode= BoolProperty(
		name= "Deep Pixel Mode",
		description= "Enable deep pixel shademap mode: save DOF & motion blur, weight, camera Z coordinate",
		default= True
	)


	VRayStereoscopicSettings.reuse_threshold= FloatProperty(
		name= "Reuse Threshold",
		description= "Lower values will make V-Ray use less of the shade map and more real shading",
		min= 0.0,
		max= 100.0,
		soft_min= 0.0,
		soft_max= 10.0,
		precision= 3,
		default= 1
	)

	VRayStereoscopicSettings.sm_mode= EnumProperty(
		name= "Shademap Mode",
		description= "Allows us to specify the mode of operation for the shade map",
		items= (
			('DISABLED', "Disabled",         "No shade map will be used during rendering"),
			('RENDER',   "Render shade map", "In this mode a shade map will be created and saved in the file specified in the Shademap file field"),
			('USE',      "Use shade map",    "In this mode V-Ray will render the image using information from the file specified in the Shademap file field")
		),
		default='DISABLED'
	)

	VRayStereoscopicSettings.shademap_file= StringProperty(
		name= "Shademap File",
		subtype= 'FILE_PATH',
		description= "The name of the file in which the shade map information is stored (*.vrst V-Ray stereoscopic format)",
		default= "//lightmaps/shade.vrst"
	)

	VRayStereoscopicSettings.exclude_list= StringProperty(
		name= "Exclude",
		description= "Allows the user to exclude some of the objects in the scene from being rendered with the shade map [';' separated list of objects and groups]",
		default= ""
	)

	

def write(bus):
	FOCUS = {
		'NONE'  : 0,
		'ROT'   : 1,
		'SHEAR' : 2,
	}

	SM_MODE = {
		'DISABLED' : 0,
		'RENDER'   : 1,
		'USE'      : 2,
	}

	CHANEL = {
		'BOTH'  : 0,
		'LEFT'  : 1,
		'RIGHT' : 2,
	}	

	ofile  = bus['files']['camera']
	scene  = bus['scene']
	camera = bus['camera']

	VRayScene      = scene.vray
	StereoSettings = VRayScene.VRayStereoscopicSettings

	VRayCamera = camera.data.vray
	CameraStereoscopic = VRayCamera.CameraStereoscopic

	if StereoSettings.use:
		ofile.write("\nVRayStereoscopicSettings StereoSettings {")
		
		if(CameraStereoscopic.use):
			if CameraStereoscopic.LeftCam:
				ofile.write("\n\tleft_camera=%s;" % (clean_string(CameraStereoscopic.LeftCam)))
		
			if CameraStereoscopic.RightCam:
				ofile.write("\n\tright_camera=%s;" % (clean_string(CameraStereoscopic.RightCam)))
		else:
			ofile.write("\n\teye_distance=%s;" % p(StereoSettings.eye_distance))
			ofile.write("\n\tspecify_focus=%s;" % p(StereoSettings.specify_focus))
			ofile.write("\n\tfocus_distance=%s;" % p(StereoSettings.focus_distance))
			ofile.write("\n\tfocus_method=%s;" % p(FOCUS[StereoSettings.focus_method]))

		ofile.write("\n\tinterocular_method=%s;" % p(CHANEL[StereoSettings.interocular_method]))
			
		ofile.write("\n\tview=%s;" % p(CHANEL[StereoSettings.view]))	
		ofile.write("\n\tsm_mode=%s;" % p(SM_MODE[StereoSettings.sm_mode]))
		ofile.write("\n\tadjust_resolution=%s;" % p(StereoSettings.adjust_resolution))
		ofile.write("\n\tshademap_file=\"%s\";" % path_sep_to_unix(bpy.path.abspath(StereoSettings.shademap_file)))
		ofile.write("\n\tdeep_pixel_mode=%s;" % p(StereoSettings.deep_pixel_mode))
		ofile.write("\n\treuse_threshold=%s;" % p(StereoSettings.reuse_threshold))
		#ofile.write("\n\texclude_list=%s;" % p(StereoSettings.exclude_list))

		ofile.write("\n\tinterocular_method=0;")
		ofile.write("\n}\n")


class VRAY_RP_VRayStereoscopicSettings(ui.VRayRenderPanel, bpy.types.Panel):
	bl_label       = "Stereoscopic"
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		VRayStereoscopicSettings= context.scene.vray.VRayStereoscopicSettings
		return super().poll(context) and VRayStereoscopicSettings.use

	def draw(self, context):
		wide_ui= context.region.width > ui.narrowui
		layout= self.layout

		VRayScene= context.scene.vray
		VRayStereoscopicSettings= VRayScene.VRayStereoscopicSettings

		split = layout.split()
		col   = split.column()
		col.prop(VRayStereoscopicSettings, 'eye_distance')

		sub = col.row(align=True)
		sub_f = sub.column()
		sub_f.active = VRayStereoscopicSettings.specify_focus
		sub_f.prop(VRayStereoscopicSettings, 'focus_distance')
		sub.prop(VRayStereoscopicSettings, 'specify_focus', text="")

		split = layout.split()
		col   = split.column()
		col.prop(VRayStereoscopicSettings, 'focus_method', text="Focus")
		col.prop(VRayStereoscopicSettings, 'interocular_method', text="Interocular")
		col.prop(VRayStereoscopicSettings, 'view')
		col.prop(VRayStereoscopicSettings, 'adjust_resolution')

		layout.separator()
		layout.prop(VRayStereoscopicSettings, 'shademap_file', text="Shademap")
		layout.prop(VRayStereoscopicSettings, 'sm_mode', text="Mode")
		layout.prop(VRayStereoscopicSettings, 'reuse_threshold')

		#layout.separator()
		#layout.prop(VRayStereoscopicSettings, 'exclude_list')


def GetRegClasses():
	return (
		VRAY_RP_VRayStereoscopicSettings,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = preset
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy

''' vb modules '''
from vb25.utils import *


class VRAY_PRESETS():
	bl_options = {'REGISTER'}

	name= bpy.props.StringProperty(
		name= "Name",
		description= "Name of the preset, used to make the path name",
		maxlen= 64,
		default= "")

	remove_active= bpy.props.BoolProperty(
		default= False,
		options= {'HIDDEN'})

	@staticmethod
	def as_filename(name):
		for char in " !@#$%^&*(){}:\";'[]<>,.\\/?":
			name= name.replace(char, '_')
		return name.lower().strip()

	def execute(self, context):
		import os
		
		if hasattr(self, "pre_cb"):
			self.pre_cb(context)
		
		preset_menu_class = getattr(bpy.types, self.preset_menu)

		if not self.remove_active:		  
			if not self.name:
				return {'FINISHED'}

			filename= self.as_filename(self.name)
			
			target_path= os.path.normpath(os.path.join(get_vray_exporter_path(), "presets", self.preset_subdir))

			filepath= os.path.join(target_path, filename) + ".py"
			
			if hasattr(self, "add"):
				self.add(context, filepath)
			else:
				file_preset = open(filepath, 'w')
				file_preset.write("import bpy\n")

				for rna_path in self.preset_values:
					value = eval(rna_path)
					# convert thin wrapped sequences to simple lists to repr()
					try:
						value = value[:]
					except:
						pass

					file_preset.write("%s = %r\n" % (rna_path, value))

				file_preset.close()

			preset_menu_class.bl_label = bpy.path.display_name(filename)

		else:
			preset_active = preset_menu_class.bl_label

			filepath= os.path.join(get_vray_exporter_path(), "presets", self.preset_subdir, preset_active+".py")

			if not os.path.exists(filepath):
				return {'CANCELLED'}

			if hasattr(self, "remove"):
				self.remove(context, filepath)
			else:
				try:
					os.remove(filepath)
				except:
					import traceback
					traceback.print_exc()

			# XXX, stupid!
			preset_menu_class.bl_label = "Presets"

		if hasattr(self, "post_cb"):
			self.post_cb(context)

		return {'FINISHED'}

	def check(self, context):
		self.name = self.as_filename(self.name)

	def invoke(self, context, event):
		if not self.remove_active:
			wm = context.window_manager
			return wm.invoke_props_dialog(self)
		else:
			return self.execute(context)


class VRAY_PRESET_global_render(VRAY_PRESETS, bpy.types.Operator):
	'''Add a V-Ray global preset'''
	bl_label      = "Add V-Ray Global Preset"

	bl_idname     = "vray.preset_add"
	preset_menu   = "VRAY_MT_preset_global"
	preset_subdir = "render"

	preset_values= [
		"bpy.context.scene.vray.exporter.autorun",
		"bpy.context.scene.vray.exporter.animation",
		"bpy.context.scene.vray.exporter.auto_meshes",
		"bpy.context.scene.vray.exporter.debug",
		"bpy.context.scene.vray.exporter.image_to_blender",
		"bpy.context.scene.vray.exporter.active_layers",
		"bpy.context.scene.vray.exporter.mesh_active_layers",
		"bpy.context.scene.vray.exporter.check_animated",
		"bpy.context.scene.vray.exporter.use_displace",
		"bpy.context.scene.vray.exporter.use_instances",
		"bpy.context.scene.vray.exporter.use_hair",
		"bpy.context.scene.vray.exporter.detect_vray",
		"bpy.context.scene.vray.exporter.vray_binary",
		"bpy.context.scene.vray.exporter.output",
		"bpy.context.scene.vray.exporter.output_dir",
		"bpy.context.scene.vray.exporter.output_unique",

        "bpy.context.scene.vray.SettingsOptions.geom_displacement",
        "bpy.context.scene.vray.SettingsOptions.geom_doHidden",
        "bpy.context.scene.vray.SettingsOptions.light_doLights",
        "bpy.context.scene.vray.SettingsOptions.light_doDefaultLights",
        "bpy.context.scene.vray.SettingsOptions.light_doHiddenLights",
        "bpy.context.scene.vray.SettingsOptions.light_doShadows",
        "bpy.context.scene.vray.SettingsOptions.light_onlyGI",
        "bpy.context.scene.vray.SettingsOptions.gi_dontRenderImage",
        "bpy.context.scene.vray.SettingsOptions.mtl_reflectionRefraction",
        "bpy.context.scene.vray.SettingsOptions.mtl_limitDepth",
        "bpy.context.scene.vray.SettingsOptions.mtl_maxDepth",
        "bpy.context.scene.vray.SettingsOptions.mtl_doMaps",
        "bpy.context.scene.vray.SettingsOptions.mtl_filterMaps",
        "bpy.context.scene.vray.SettingsOptions.mtl_filterMapsForSecondaryRays",
        "bpy.context.scene.vray.SettingsOptions.mtl_transpMaxLevels",
        "bpy.context.scene.vray.SettingsOptions.mtl_transpCutoff",
        "bpy.context.scene.vray.SettingsOptions.mtl_override_on",
        "bpy.context.scene.vray.SettingsOptions.mtl_glossy",
        "bpy.context.scene.vray.SettingsOptions.geom_backfaceCull",
        "bpy.context.scene.vray.SettingsOptions.ray_bias",
        "bpy.context.scene.vray.SettingsOptions.misc_lowThreadPriority",

        "bpy.context.scene.vray.SettingsCaustics.on",
        "bpy.context.scene.vray.SettingsCaustics.max_photons",
        "bpy.context.scene.vray.SettingsCaustics.search_distance",
        "bpy.context.scene.vray.SettingsCaustics.max_density",
        "bpy.context.scene.vray.SettingsCaustics.multiplier",
        "bpy.context.scene.vray.SettingsCaustics.mode",
        "bpy.context.scene.vray.SettingsCaustics.file",
        "bpy.context.scene.vray.SettingsCaustics.auto_save",
        "bpy.context.scene.vray.SettingsCaustics.auto_save_file",
        "bpy.context.scene.vray.SettingsCaustics.show_calc_phase",

		"bpy.context.scene.vray.SettingsGI.on",
        "bpy.context.scene.vray.SettingsGI.refract_caustics",
        "bpy.context.scene.vray.SettingsGI.reflect_caustics",
        "bpy.context.scene.vray.SettingsGI.saturation",
        "bpy.context.scene.vray.SettingsGI.contrast",
        "bpy.context.scene.vray.SettingsGI.contrast_base",
        "bpy.context.scene.vray.SettingsGI.primary_engine",
        "bpy.context.scene.vray.SettingsGI.primary_multiplier",
        "bpy.context.scene.vray.SettingsGI.secondary_engine",
        "bpy.context.scene.vray.SettingsGI.secondary_multiplier",
        "bpy.context.scene.vray.SettingsGI.ray_distance_on",
        "bpy.context.scene.vray.SettingsGI.ray_distance",
        "bpy.context.scene.vray.SettingsGI.ao_on",
        "bpy.context.scene.vray.SettingsGI.ao_amount",
        "bpy.context.scene.vray.SettingsGI.ao_radius",
        "bpy.context.scene.vray.SettingsGI.ao_subdivs",
		
        "bpy.context.scene.vray.SettingsGI.SettingsDMCGI.subdivs",
        "bpy.context.scene.vray.SettingsGI.SettingsDMCGI.depth",

        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.min_rate",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.max_rate",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.subdivs",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.interp_samples",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.calc_interp_samples",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.interp_frames",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.color_threshold",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.normal_threshold",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.distance_threshold",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.detail_enhancement",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.detail_radius",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.detail_subdivs_mult",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.detail_scale",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.randomize_samples",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.interpolation_mode",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.lookup_mode",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.mode",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.file",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.show_samples",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.show_calc_phase",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.show_direct_light",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.multiple_views",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.multipass",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.check_sample_visibility",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.auto_save",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.auto_save_file",

        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.subdivs",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.sample_size",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.filter_type",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.filter_samples",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.filter_size",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.prefilter",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.prefilter_samples",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.depth",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.show_calc_phase",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.store_direct_light",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.world_scale",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.mode",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.file",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.auto_save",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.auto_save_file",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.num_passes",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.use_for_glossy_rays",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.adaptive_sampling",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.multiple_views",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.retrace_enabled",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.retrace_threshold",

		"bpy.context.scene.vray.SettingsDefaultDisplacement.override_on",
		"bpy.context.scene.vray.SettingsDefaultDisplacement.edgeLength",
		"bpy.context.scene.vray.SettingsDefaultDisplacement.viewDependent",
		"bpy.context.scene.vray.SettingsDefaultDisplacement.maxSubdivs",
		"bpy.context.scene.vray.SettingsDefaultDisplacement.tightBounds",
		"bpy.context.scene.vray.SettingsDefaultDisplacement.amount",
		"bpy.context.scene.vray.SettingsDefaultDisplacement.relative",

		"bpy.context.scene.vray.SettingsRegionsGenerator.xc",
		"bpy.context.scene.vray.SettingsRegionsGenerator.yc",
		"bpy.context.scene.vray.SettingsRegionsGenerator.reverse",
		"bpy.context.scene.vray.SettingsRegionsGenerator.seqtype",
		"bpy.context.scene.vray.SettingsRegionsGenerator.xymeans",

		"bpy.context.scene.vray.SettingsImageSampler.type",
		"bpy.context.scene.vray.SettingsImageSampler.fixed_subdivs",
		"bpy.context.scene.vray.SettingsImageSampler.dmc_minSubdivs",
		"bpy.context.scene.vray.SettingsImageSampler.dmc_threshold",
		"bpy.context.scene.vray.SettingsImageSampler.dmc_show_samples",
		"bpy.context.scene.vray.SettingsImageSampler.subdivision_minRate",
		"bpy.context.scene.vray.SettingsImageSampler.subdivision_maxRate",
		"bpy.context.scene.vray.SettingsImageSampler.subdivision_threshold",
		"bpy.context.scene.vray.SettingsImageSampler.subdivision_edges",
		"bpy.context.scene.vray.SettingsImageSampler.subdivision_normals",
		"bpy.context.scene.vray.SettingsImageSampler.subdivision_normals_threshold",
		"bpy.context.scene.vray.SettingsImageSampler.subdivision_jitter",
		"bpy.context.scene.vray.SettingsImageSampler.subdivision_show_samples",

		"bpy.context.scene.vray.SettingsRaycaster.maxLevels",
		"bpy.context.scene.vray.SettingsRaycaster.minLeafSize",
		"bpy.context.scene.vray.SettingsRaycaster.faceLevelCoef",
		"bpy.context.scene.vray.SettingsRaycaster.dynMemLimit",

		"bpy.context.scene.vray.SettingsDMCSampler.time_dependent",
		"bpy.context.scene.vray.SettingsDMCSampler.adaptive_amount",
		"bpy.context.scene.vray.SettingsDMCSampler.adaptive_threshold",
		"bpy.context.scene.vray.SettingsDMCSampler.adaptive_min_samples",
		"bpy.context.scene.vray.SettingsDMCSampler.subdivs_mult",

		"bpy.context.scene.vray.SettingsUnitsInfo.meters_scale",
		"bpy.context.scene.vray.SettingsUnitsInfo.photometric_scale",

		"bpy.context.scene.vray.SettingsColorMapping.affect_background",
		"bpy.context.scene.vray.SettingsColorMapping.dark_mult",
		"bpy.context.scene.vray.SettingsColorMapping.bright_mult",
		"bpy.context.scene.vray.SettingsColorMapping.gamma",
		"bpy.context.scene.vray.SettingsColorMapping.input_gamma",
		"bpy.context.scene.vray.SettingsColorMapping.subpixel_mapping",
		"bpy.context.scene.vray.SettingsColorMapping.clamp_output",
		"bpy.context.scene.vray.SettingsColorMapping.clamp_level",
		"bpy.context.scene.vray.SettingsColorMapping.adaptation_only",
		"bpy.context.scene.vray.SettingsColorMapping.linearWorkflow",

		"bpy.context.scene.vray.VRayDR.on",
		"bpy.context.scene.vray.VRayDR.shared_dir",
		"bpy.context.scene.vray.VRayDR.port",

		"bpy.context.scene.render.threads_mode",
		"bpy.context.scene.render.threads",
	]

bpy.utils.register_class(VRAY_PRESET_global_render)


class VRAY_PRESET_gi(VRAY_PRESETS, bpy.types.Operator):
	'''Add a V-Ray global preset'''
	bl_label      = "Add V-Ray Global Preset"

	bl_idname     = "vray.preset_gi_add"
	preset_menu   = "VRAY_MT_preset_gi"
	preset_subdir = "gi"

	preset_values= [
		"bpy.context.scene.vray.SettingsGI.on",
        "bpy.context.scene.vray.SettingsGI.refract_caustics",
        "bpy.context.scene.vray.SettingsGI.reflect_caustics",
        "bpy.context.scene.vray.SettingsGI.saturation",
        "bpy.context.scene.vray.SettingsGI.contrast",
        "bpy.context.scene.vray.SettingsGI.contrast_base",
        "bpy.context.scene.vray.SettingsGI.primary_engine",
        "bpy.context.scene.vray.SettingsGI.primary_multiplier",
        "bpy.context.scene.vray.SettingsGI.secondary_engine",
        "bpy.context.scene.vray.SettingsGI.secondary_multiplier",
        "bpy.context.scene.vray.SettingsGI.ray_distance_on",
        "bpy.context.scene.vray.SettingsGI.ray_distance",
        "bpy.context.scene.vray.SettingsGI.ao_on",
        "bpy.context.scene.vray.SettingsGI.ao_amount",
        "bpy.context.scene.vray.SettingsGI.ao_radius",
        "bpy.context.scene.vray.SettingsGI.ao_subdivs",
		
        "bpy.context.scene.vray.SettingsGI.SettingsDMCGI.subdivs",
        "bpy.context.scene.vray.SettingsGI.SettingsDMCGI.depth",

        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.min_rate",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.max_rate",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.subdivs",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.interp_samples",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.calc_interp_samples",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.interp_frames",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.color_threshold",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.normal_threshold",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.distance_threshold",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.detail_enhancement",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.detail_radius",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.detail_subdivs_mult",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.detail_scale",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.randomize_samples",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.interpolation_mode",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.lookup_mode",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.mode",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.file",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.show_samples",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.show_calc_phase",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.show_direct_light",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.multiple_views",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.multipass",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.check_sample_visibility",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.auto_save",
        "bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.auto_save_file",

        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.subdivs",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.sample_size",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.filter_type",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.filter_samples",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.filter_size",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.prefilter",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.prefilter_samples",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.depth",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.show_calc_phase",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.store_direct_light",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.world_scale",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.mode",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.file",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.auto_save",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.auto_save_file",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.num_passes",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.use_for_glossy_rays",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.adaptive_sampling",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.multiple_views",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.retrace_enabled",
        "bpy.context.scene.vray.SettingsGI.SettingsLightCache.retrace_threshold",
	]

bpy.utils.register_class(VRAY_PRESET_gi)


# '''
#   BRDFSSS2Complex preset generator
# '''
# import os
# SSS2= {
# 	'Skin_brown': {
# 		'ior':                  1.3,
# 		'diffuse_color':        (169, 123, 92),
# 		'sub_surface_color':    (169, 123, 92),
# 		'scatter_radius':       (155, 94, 66),
# 		'scatter_radius_mult':  1.0,
# 		'phase_function':       0.8,
# 		'specular_amount':      1.0,
# 		'specular_glossiness':  0.5
# 	},
# 	'Skin_pink': {
# 		'ior':                  1.3,
# 		'diffuse_color':        (203, 169, 149),
# 		'sub_surface_color':    (203, 169, 149),
# 		'scatter_radius':       (177, 105, 84),
# 		'scatter_radius_mult':  1.0,
# 		'phase_function':       0.8,
# 		'specular_amount':      1.0,
# 		'specular_glossiness':  0.5
# 	},
# 	'Skin_yellow': {
# 		'ior':                  1.3,
# 		'diffuse_color':        (204, 165, 133),
# 		'sub_surface_color':    (204, 165, 133),
# 		'scatter_radius':       (177, 105, 84),
# 		'scatter_radius_mult':  1.0,
# 		'phase_function':       0.8,
# 		'specular_amount':      1.0,
# 		'specular_glossiness':  0.5
# 	},
# 	'Milk_skimmed': {
# 		'ior':                  1.3,
# 		'diffuse_color':        (230, 230, 210),
# 		'sub_surface_color':    (230, 230, 210),
# 		'scatter_radius':       (245, 184, 107),
# 		'scatter_radius_mult':  2.0,
# 		'phase_function':       0.8,
# 		'specular_amount':      1.0,
# 		'specular_glossiness':  0.8
# 	},
# 	'Milk_whole': {
# 		'ior':                  1.3,
# 		'diffuse_color':        (242, 239, 222),
# 		'sub_surface_color':    (242, 239, 222),
# 		'scatter_radius':       (188, 146,  90),
# 		'scatter_radius_mult':  2.0,
# 		'phase_function':       0.9,
# 		'specular_amount':      1.0,
# 		'specular_glossiness':  0.8
# 	},
# 	'Marble_white': {
# 		'ior':                  1.5,
# 		'diffuse_color':        (238, 233, 228),
# 		'sub_surface_color':    (238, 233, 228),
# 		'scatter_radius':       (235, 190, 160),
# 		'scatter_radius_mult':  1.0,
# 		'phase_function':       -0.25,
# 		'specular_amount':      1.0,
# 		'specular_glossiness':  0.7
# 	},
# 	'Ketchup': {
# 		'ior':                  1.3,
# 		'diffuse_color':        (102, 28,  0),
# 		'sub_surface_color':    (102, 28,  0),
# 		'scatter_radius':       (176, 62, 50),
# 		'scatter_radius_mult':  1.0,
# 		'phase_function':       0.9,
# 		'specular_amount':      1.0,
# 		'specular_glossiness':  0.7
# 	},
# 	'Cream': {
# 		'ior':                  1.3,
# 		'diffuse_color':        (224, 201, 117),
# 		'sub_surface_color':    (224, 201, 117),
# 		'scatter_radius':       (215, 153,  81),
# 		'scatter_radius_mult':  2.0,
# 		'phase_function':       0.8,
# 		'specular_amount':      1.0,
# 		'specular_glossiness':  0.6
# 	},
# 	'Potato': {
# 		'ior':                  1.3,
# 		'diffuse_color':        (224, 201, 117),
# 		'sub_surface_color':    (224, 201, 117),
# 		'scatter_radius':       (215, 153,  81),
# 		'scatter_radius_mult':  2.0,
# 		'phase_function':       0.8,
# 		'specular_amount':      1.0,
# 		'specular_glossiness':  0.8
# 	},
# 	'Spectration': {
# 		'ior':                  1.5,
# 		'diffuse_color':        (255, 255, 255),
# 		'sub_surface_color':    (255, 255, 255),
# 		'scatter_radius':       (  0,   0,   0),
# 		'scatter_radius_mult':  0.0,
# 		'phase_function':       0.0,
# 		'specular_amount':      0.0,
# 		'specular_glossiness':  0.0
# 	},
# 	'Water_clear': {
# 		'ior':                  1.3,
# 		'diffuse_color':        (  0,   0,   0),
# 		'sub_surface_color':    (  0,   0,   0),
# 		'scatter_radius':       (255, 255, 255),
# 		'scatter_radius_mult':  300.0,
# 		'phase_function':       0.95,
# 		'specular_amount':      1.0,
# 		'specular_glossiness':  1.0
# 	}
# }
# def generate_presets():
# 	for preset in SSS2:
# 		ofile= open("/home/bdancer/devel/vrayblender/exporter/vb25/presets/sss/%s.py"%(preset), 'w')
# 		ofile.write("import bpy\n")
# 		for param in SSS2[preset]:
# 			ps= SSS2[preset][param]
# 			if type(ps) == tuple:
# 				pss= ""
# 				for c in ps:
# 					pss+= "%.3f,"%(float(c / 255.0))
# 				ps= pss[:-1]
# 			s= "bpy.context.active_object.active_material.vray.BRDFSSS2Complex.%s = %s\n"%("%s"%(param), ps)
# 			ofile.write(s.replace(')','').replace('(',''))
# 		ofile.write("\n")
# 		ofile.close()
# generate_presets()


########NEW FILE########
__FILENAME__ = universal
import bpy
bpy.context.scene.vray.SettingsGI.on = True
bpy.context.scene.vray.SettingsGI.refract_caustics = True
bpy.context.scene.vray.SettingsGI.reflect_caustics = False
bpy.context.scene.vray.SettingsGI.saturation = 1.0
bpy.context.scene.vray.SettingsGI.contrast = 1.0
bpy.context.scene.vray.SettingsGI.contrast_base = 0.5
bpy.context.scene.vray.SettingsGI.primary_engine = 'BF'
bpy.context.scene.vray.SettingsGI.primary_multiplier = 1.0
bpy.context.scene.vray.SettingsGI.secondary_engine = 'LC'
bpy.context.scene.vray.SettingsGI.secondary_multiplier = 1.0
bpy.context.scene.vray.SettingsGI.ray_distance_on = False
bpy.context.scene.vray.SettingsGI.ray_distance = 100000.0
bpy.context.scene.vray.SettingsGI.ao_on = False
bpy.context.scene.vray.SettingsGI.ao_amount = 1.0
bpy.context.scene.vray.SettingsGI.ao_radius = 0.20000000298023224
bpy.context.scene.vray.SettingsGI.ao_subdivs = 8
bpy.context.scene.vray.SettingsGI.SettingsDMCGI.subdivs = 8
bpy.context.scene.vray.SettingsGI.SettingsDMCGI.depth = 3
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.min_rate = -3
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.max_rate = 0
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.subdivs = 50
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.interp_samples = 20
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.calc_interp_samples = 10
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.interp_frames = 2
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.color_threshold = 0.30000001192092896
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.normal_threshold = 0.10000000149011612
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.distance_threshold = 0.10000000149011612
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.detail_enhancement = False
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.detail_radius = 0.05999999865889549
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.detail_subdivs_mult = 0.30000001192092896
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.detail_scale = 'SCREEN'
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.randomize_samples = True
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.interpolation_mode = 'LEAST'
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.lookup_mode = 'OVERLAP'
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.mode = 'SINGLE'
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.file = '//lightmaps/im.vrim'
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.show_samples = False
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.show_calc_phase = True
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.show_direct_light = True
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.multiple_views = False
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.multipass = False
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.check_sample_visibility = False
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.auto_save = False
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.auto_save_file = '//lightmaps/auto_im.vrim'
bpy.context.scene.vray.SettingsGI.SettingsLightCache.subdivs = 1000
bpy.context.scene.vray.SettingsGI.SettingsLightCache.sample_size = 0.019999999552965164
bpy.context.scene.vray.SettingsGI.SettingsLightCache.filter_type = 'NEAREST'
bpy.context.scene.vray.SettingsGI.SettingsLightCache.filter_samples = 5
bpy.context.scene.vray.SettingsGI.SettingsLightCache.filter_size = 0.019999999552965164
bpy.context.scene.vray.SettingsGI.SettingsLightCache.prefilter = False
bpy.context.scene.vray.SettingsGI.SettingsLightCache.prefilter_samples = 40
bpy.context.scene.vray.SettingsGI.SettingsLightCache.depth = 100
bpy.context.scene.vray.SettingsGI.SettingsLightCache.show_calc_phase = True
bpy.context.scene.vray.SettingsGI.SettingsLightCache.store_direct_light = True
bpy.context.scene.vray.SettingsGI.SettingsLightCache.world_scale = 'SCREEN'
bpy.context.scene.vray.SettingsGI.SettingsLightCache.mode = 'SINGLE'
bpy.context.scene.vray.SettingsGI.SettingsLightCache.file = '//lightmaps/lc.vrlc'
bpy.context.scene.vray.SettingsGI.SettingsLightCache.auto_save = False
bpy.context.scene.vray.SettingsGI.SettingsLightCache.auto_save_file = '//lightmaps/auto.vrlc'
bpy.context.scene.vray.SettingsGI.SettingsLightCache.num_passes = 4
bpy.context.scene.vray.SettingsGI.SettingsLightCache.use_for_glossy_rays = False
bpy.context.scene.vray.SettingsGI.SettingsLightCache.adaptive_sampling = False
bpy.context.scene.vray.SettingsGI.SettingsLightCache.multiple_views = False
bpy.context.scene.vray.SettingsGI.SettingsLightCache.retrace_enabled = False
bpy.context.scene.vray.SettingsGI.SettingsLightCache.retrace_threshold = 1.0

########NEW FILE########
__FILENAME__ = High
import bpy
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.min_rate= -3
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.max_rate= 0
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.subdivs= 50
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.color_threshold= 0.3
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.normal_threshold= 0.1
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.distance_threshold= 0.1


########NEW FILE########
__FILENAME__ = High_Animation
import bpy
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.min_rate= -3
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.max_rate= 0
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.subdivs= 50
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.color_threshold= 0.3
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.normal_threshold= 0.1
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.distance_threshold= 0.5


########NEW FILE########
__FILENAME__ = Low
import bpy
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.min_rate= -3
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.max_rate= -2
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.subdivs= 50
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.color_threshold= 0.4
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.normal_threshold= 0.3
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.distance_threshold= 0.1


########NEW FILE########
__FILENAME__ = Medium
import bpy
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.min_rate= -3
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.max_rate= -1
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.subdivs= 50
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.color_threshold= 0.4
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.normal_threshold= 0.2
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.distance_threshold= 0.1


########NEW FILE########
__FILENAME__ = Medium_Animation
import bpy
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.min_rate= -3
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.max_rate= -1
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.subdivs= 50
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.color_threshold= 0.3
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.normal_threshold= 0.2
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.distance_threshold= 0.5


########NEW FILE########
__FILENAME__ = Very_High
import bpy
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.min_rate= -3
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.max_rate= 1
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.subdivs= 50
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.color_threshold= 0.2
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.normal_threshold= 0.1
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.distance_threshold= 0.3


########NEW FILE########
__FILENAME__ = Very_Low
import bpy
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.min_rate= -4
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.max_rate= -3
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.subdivs= 50
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.color_threshold= 0.4
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.normal_threshold= 0.3
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.distance_threshold= 0.1


########NEW FILE########
__FILENAME__ = Curtain
import bpy

def active_node_material(ma):
	ma_node= ma.active_node_material
	if ma_node:
		return ma_node
	else:
		return ma

ma= active_node_material(bpy.context.active_object.active_material)

VRayMaterial= ma.vray
VRayMaterial.type= 'BRDFVRayMtl'

VRayMaterial.Mtl2Sided.use= True

BRDFVRayMtl= VRayMaterial.BRDFVRayMtl

########NEW FILE########
__FILENAME__ = Glass
import bpy

from bl_ui.properties_material import active_node_mat


ma = active_node_mat(bpy.context.active_object.active_material)

VRayMaterial = ma.vray
VRayMaterial.type = 'BRDFVRayMtl'
VRayMaterial.Mtl2Sided.use = False

BRDFVRayMtl = VRayMaterial.BRDFVRayMtl

BRDFVRayMtl.diffuse = 0.0,0.0,0.0
BRDFVRayMtl.fog_color = 0.78,1.0,0.845
BRDFVRayMtl.refract_color = 1.0,1.0,1.0
BRDFVRayMtl.refract_ior = 1.55
BRDFVRayMtl.refract_affect_shadows = True
BRDFVRayMtl.reflect_color = 0.95,0.95,0.95
BRDFVRayMtl.fresnel = True

########NEW FILE########
__FILENAME__ = Pure_glass
import bpy

from bl_ui.properties_material import active_node_mat


ma = active_node_mat(bpy.context.active_object.active_material)

VRayMaterial = ma.vray
VRayMaterial.type = 'BRDFVRayMtl'
VRayMaterial.Mtl2Sided.use = False

BRDFVRayMtl = VRayMaterial.BRDFVRayMtl

BRDFVRayMtl.diffuse = 0.0,0.0,0.0
BRDFVRayMtl.fog_color = 1.0,1.0,1.0
BRDFVRayMtl.refract_color = 1.0,1.0,1.0
BRDFVRayMtl.refract_ior = 1.55
BRDFVRayMtl.refract_affect_shadows = True
BRDFVRayMtl.reflect_color = 0.95,0.95,0.95
BRDFVRayMtl.fresnel = True

########NEW FILE########
__FILENAME__ = default
import bpy
bpy.context.scene.vray.exporter.autorun = True
bpy.context.scene.vray.exporter.animation = False
bpy.context.scene.vray.exporter.auto_meshes = False
bpy.context.scene.vray.exporter.debug = False
bpy.context.scene.vray.exporter.use_material_nodes = False
bpy.context.scene.vray.exporter.compat_mode = False
bpy.context.scene.vray.exporter.image_to_blender = False
bpy.context.scene.vray.exporter.activeLayers = 'ACTIVE'
bpy.context.scene.vray.exporter.mesh_active_layers = True
bpy.context.scene.vray.exporter.check_animated = False
bpy.context.scene.vray.exporter.use_displace = True
bpy.context.scene.vray.exporter.use_instances = True
bpy.context.scene.vray.exporter.use_hair = True
bpy.context.scene.vray.exporter.detect_vray = True
bpy.context.scene.vray.exporter.vray_binary = ''
bpy.context.scene.vray.exporter.output = 'TMP'
bpy.context.scene.vray.exporter.output_dir = ''
bpy.context.scene.vray.exporter.output_unique = False
bpy.context.scene.vray.SettingsOptions.geom_displacement = True
bpy.context.scene.vray.SettingsOptions.geom_doHidden = False
bpy.context.scene.vray.SettingsOptions.light_doLights = True
bpy.context.scene.vray.SettingsOptions.light_doDefaultLights = False
bpy.context.scene.vray.SettingsOptions.light_doHiddenLights = False
bpy.context.scene.vray.SettingsOptions.light_doShadows = True
bpy.context.scene.vray.SettingsOptions.light_onlyGI = False
bpy.context.scene.vray.SettingsOptions.gi_dontRenderImage = False
bpy.context.scene.vray.SettingsOptions.mtl_reflectionRefraction = True
bpy.context.scene.vray.SettingsOptions.mtl_limitDepth = False
bpy.context.scene.vray.SettingsOptions.mtl_maxDepth = 5
bpy.context.scene.vray.SettingsOptions.mtl_doMaps = True
bpy.context.scene.vray.SettingsOptions.mtl_filterMaps = True
bpy.context.scene.vray.SettingsOptions.mtl_filterMapsForSecondaryRays = False
bpy.context.scene.vray.SettingsOptions.mtl_transpMaxLevels = 50
bpy.context.scene.vray.SettingsOptions.mtl_transpCutoff = 0.0010000000474974513
bpy.context.scene.vray.SettingsOptions.mtl_override_on = False
bpy.context.scene.vray.SettingsOptions.mtl_glossy = True
bpy.context.scene.vray.SettingsOptions.geom_backfaceCull = False
bpy.context.scene.vray.SettingsOptions.ray_bias = 0.0
bpy.context.scene.vray.SettingsOptions.misc_lowThreadPriority = True
bpy.context.scene.vray.SettingsCaustics.on = False
bpy.context.scene.vray.SettingsCaustics.max_photons = 30
bpy.context.scene.vray.SettingsCaustics.search_distance = 0.10000000149011612
bpy.context.scene.vray.SettingsCaustics.max_density = 0.0
bpy.context.scene.vray.SettingsCaustics.multiplier = 1.0
bpy.context.scene.vray.SettingsCaustics.mode = 'NEW'
bpy.context.scene.vray.SettingsCaustics.file = ''
bpy.context.scene.vray.SettingsCaustics.auto_save = False
bpy.context.scene.vray.SettingsCaustics.auto_save_file = ''
bpy.context.scene.vray.SettingsCaustics.show_calc_phase = False
bpy.context.scene.vray.SettingsGI.on = False
bpy.context.scene.vray.SettingsGI.refract_caustics = True
bpy.context.scene.vray.SettingsGI.reflect_caustics = False
bpy.context.scene.vray.SettingsGI.saturation = 1.0
bpy.context.scene.vray.SettingsGI.contrast = 1.0
bpy.context.scene.vray.SettingsGI.contrast_base = 0.5
bpy.context.scene.vray.SettingsGI.primary_engine = 'IM'
bpy.context.scene.vray.SettingsGI.primary_multiplier = 1.0
bpy.context.scene.vray.SettingsGI.secondary_engine = 'LC'
bpy.context.scene.vray.SettingsGI.secondary_multiplier = 1.0
bpy.context.scene.vray.SettingsGI.SettingsDMCGI.subdivs = 8
bpy.context.scene.vray.SettingsGI.SettingsDMCGI.depth = 3
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.min_rate = -3
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.max_rate = 0
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.subdivs = 50
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.interp_samples = 20
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.calc_interp_samples = 10
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.interp_frames = 2
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.color_threshold = 0.30000001192092896
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.normal_threshold = 0.10000000149011612
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.distance_threshold = 0.10000000149011612
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.detail_enhancement = False
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.detail_radius = 0.05999999865889549
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.detail_subdivs_mult = 0.30000001192092896
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.detail_scale = 'SCREEN'
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.randomize_samples = True
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.interpolation_mode = 'LEAST'
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.lookup_mode = 'OVERLAP'
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.mode = 'SINGLE'
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.file = ''
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.show_samples = False
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.show_calc_phase = True
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.show_direct_light = True
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.multiple_views = False
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.multipass = False
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.check_sample_visibility = False
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.auto_save = False
bpy.context.scene.vray.SettingsGI.SettingsIrradianceMap.auto_save_file = ''
bpy.context.scene.vray.SettingsGI.SettingsLightCache.subdivs = 1000
bpy.context.scene.vray.SettingsGI.SettingsLightCache.sample_size = 0.019999999552965164
bpy.context.scene.vray.SettingsGI.SettingsLightCache.filter_type = 'NEAREST'
bpy.context.scene.vray.SettingsGI.SettingsLightCache.filter_samples = 10
bpy.context.scene.vray.SettingsGI.SettingsLightCache.filter_size = 0.019999999552965164
bpy.context.scene.vray.SettingsGI.SettingsLightCache.prefilter = False
bpy.context.scene.vray.SettingsGI.SettingsLightCache.prefilter_samples = 40
bpy.context.scene.vray.SettingsGI.SettingsLightCache.depth = 100
bpy.context.scene.vray.SettingsGI.SettingsLightCache.show_calc_phase = True
bpy.context.scene.vray.SettingsGI.SettingsLightCache.store_direct_light = True
bpy.context.scene.vray.SettingsGI.SettingsLightCache.world_scale = 'SCREEN'
bpy.context.scene.vray.SettingsGI.SettingsLightCache.mode = 'SINGLE'
bpy.context.scene.vray.SettingsGI.SettingsLightCache.file = ''
bpy.context.scene.vray.SettingsGI.SettingsLightCache.auto_save = False
bpy.context.scene.vray.SettingsGI.SettingsLightCache.auto_save_file = ''
bpy.context.scene.vray.SettingsGI.SettingsLightCache.num_passes = 4
bpy.context.scene.vray.SettingsGI.SettingsLightCache.use_for_glossy_rays = False
bpy.context.scene.vray.SettingsGI.SettingsLightCache.adaptive_sampling = False
bpy.context.scene.vray.SettingsGI.SettingsLightCache.multiple_views = False
bpy.context.scene.vray.SettingsDefaultDisplacement.override_on = False
bpy.context.scene.vray.SettingsDefaultDisplacement.edgeLength = 4.0
bpy.context.scene.vray.SettingsDefaultDisplacement.viewDependent = True
bpy.context.scene.vray.SettingsDefaultDisplacement.maxSubdivs = 256
bpy.context.scene.vray.SettingsDefaultDisplacement.tightBounds = True
bpy.context.scene.vray.SettingsDefaultDisplacement.amount = 1.0
bpy.context.scene.vray.SettingsDefaultDisplacement.relative = False
bpy.context.scene.vray.SettingsRegionsGenerator.xc = 32
bpy.context.scene.vray.SettingsRegionsGenerator.yc = 32
bpy.context.scene.vray.SettingsRegionsGenerator.reverse = False
bpy.context.scene.vray.SettingsRegionsGenerator.seqtype = 'TRIANGLE'
bpy.context.scene.vray.SettingsRegionsGenerator.xymeans = 'SIZE'
bpy.context.scene.vray.SettingsImageSampler.type = 'DMC'
bpy.context.scene.vray.SettingsImageSampler.fixed_subdivs = 1
bpy.context.scene.vray.SettingsImageSampler.dmc_minSubdivs = 1
bpy.context.scene.vray.SettingsImageSampler.dmc_threshold = 0.009999999776482582
bpy.context.scene.vray.SettingsImageSampler.dmc_show_samples = False
bpy.context.scene.vray.SettingsImageSampler.subdivision_minRate = -1
bpy.context.scene.vray.SettingsImageSampler.subdivision_maxRate = 2
bpy.context.scene.vray.SettingsImageSampler.subdivision_threshold = 0.10000000149011612
bpy.context.scene.vray.SettingsImageSampler.subdivision_edges = False
bpy.context.scene.vray.SettingsImageSampler.subdivision_normals = False
bpy.context.scene.vray.SettingsImageSampler.subdivision_normals_threshold = 0.05000000074505806
bpy.context.scene.vray.SettingsImageSampler.subdivision_jitter = True
bpy.context.scene.vray.SettingsImageSampler.subdivision_show_samples = False
bpy.context.scene.vray.SettingsRaycaster.maxLevels = 80
bpy.context.scene.vray.SettingsRaycaster.minLeafSize = 0.0
bpy.context.scene.vray.SettingsRaycaster.faceLevelCoef = 1.0
bpy.context.scene.vray.SettingsRaycaster.dynMemLimit = 1024
bpy.context.scene.vray.SettingsDMCSampler.time_dependent = False
bpy.context.scene.vray.SettingsDMCSampler.adaptive_amount = 0.8500000238418579
bpy.context.scene.vray.SettingsDMCSampler.adaptive_threshold = 0.009999999776482582
bpy.context.scene.vray.SettingsDMCSampler.adaptive_min_samples = 8
bpy.context.scene.vray.SettingsDMCSampler.subdivs_mult = 1.0
bpy.context.scene.vray.SettingsUnitsInfo.meters_scale = 1.0
bpy.context.scene.vray.SettingsUnitsInfo.photometric_scale = 0.0020000000949949026
bpy.context.scene.vray.SettingsColorMapping.affect_background = True
bpy.context.scene.vray.SettingsColorMapping.dark_mult = 1.0
bpy.context.scene.vray.SettingsColorMapping.bright_mult = 1.0
bpy.context.scene.vray.SettingsColorMapping.gamma = 1.0
bpy.context.scene.vray.SettingsColorMapping.input_gamma = 1.0
bpy.context.scene.vray.SettingsColorMapping.subpixel_mapping = False
bpy.context.scene.vray.SettingsColorMapping.clamp_output = True
bpy.context.scene.vray.SettingsColorMapping.clamp_level = 1.0
bpy.context.scene.vray.SettingsColorMapping.adaptation_only = False
bpy.context.scene.vray.SettingsColorMapping.linearWorkflow = False
bpy.context.scene.vray.VRayDR.on = False
bpy.context.scene.vray.VRayDR.shared_dir = ''
bpy.context.scene.vray.VRayDR.port = 20204
bpy.context.scene.render.threads_mode = 'AUTO'
bpy.context.scene.render.threads = 4

########NEW FILE########
__FILENAME__ = Cream
import bpy

from bl_ui.properties_material import active_node_mat

material = active_node_mat(bpy.context.active_object.active_material)

VRayMaterial = material.vray
VRayMaterial.type = 'BRDFSSS2Complex'

BRDFSSS2Complex = VRayMaterial.BRDFSSS2Complex

BRDFSSS2Complex.sub_surface_color = 0.878,0.788,0.459
BRDFSSS2Complex.specular_glossiness = 0.6
BRDFSSS2Complex.scatter_radius = 0.843,0.600,0.318
BRDFSSS2Complex.scatter_radius_mult = 2.0
BRDFSSS2Complex.diffuse_color = 0.878,0.788,0.459
BRDFSSS2Complex.ior = 1.3
BRDFSSS2Complex.phase_function = 0.8
BRDFSSS2Complex.specular_amount = 1.0

########NEW FILE########
__FILENAME__ = Ketchup
import bpy

from bl_ui.properties_material import active_node_mat


ma = active_node_mat(bpy.context.active_object.active_material)
ma.diffuse_color = 1.0,1.0,1.0 # This will also trigger the update

VRayMaterial = ma.vray
VRayMaterial.type = 'BRDFSSS2Complex'

BRDFSSS2Complex = VRayMaterial.BRDFSSS2Complex

BRDFSSS2Complex.sub_surface_color = 0.400,0.110,0.000
BRDFSSS2Complex.specular_glossiness = 0.7
BRDFSSS2Complex.scatter_radius = 0.690,0.243,0.196
BRDFSSS2Complex.scatter_radius_mult = 1.0
BRDFSSS2Complex.diffuse_color = 0.400,0.110,0.000
BRDFSSS2Complex.ior = 1.3
BRDFSSS2Complex.phase_function = 0.9
BRDFSSS2Complex.specular_amount = 1.0

########NEW FILE########
__FILENAME__ = Marble_white
import bpy

from bl_ui.properties_material import active_node_mat


ma = active_node_mat(bpy.context.active_object.active_material)
ma.diffuse_color = 1.0,1.0,1.0 # This will also trigger the update

VRayMaterial = ma.vray
VRayMaterial.type = 'BRDFSSS2Complex'

BRDFSSS2Complex = VRayMaterial.BRDFSSS2Complex

BRDFSSS2Complex.sub_surface_color = 0.933,0.914,0.894
BRDFSSS2Complex.specular_glossiness = 0.7
BRDFSSS2Complex.scatter_radius = 0.922,0.745,0.627
BRDFSSS2Complex.scatter_radius_mult = 1.0
BRDFSSS2Complex.diffuse_color = 0.933,0.914,0.894
BRDFSSS2Complex.ior = 1.5
BRDFSSS2Complex.phase_function = -0.25
BRDFSSS2Complex.specular_amount = 1.0

########NEW FILE########
__FILENAME__ = Milk_skimmed
import bpy

from bl_ui.properties_material import active_node_mat


ma = active_node_mat(bpy.context.active_object.active_material)
ma.diffuse_color = 1.0,1.0,1.0 # This will also trigger the update

VRayMaterial = ma.vray
VRayMaterial.type = 'BRDFSSS2Complex'

BRDFSSS2Complex = VRayMaterial.BRDFSSS2Complex

BRDFSSS2Complex.sub_surface_color = 0.902,0.902,0.824
BRDFSSS2Complex.specular_glossiness = 0.8
BRDFSSS2Complex.scatter_radius = 0.961,0.722,0.420
BRDFSSS2Complex.scatter_radius_mult = 2.0
BRDFSSS2Complex.diffuse_color = 0.902,0.902,0.824
BRDFSSS2Complex.ior = 1.3
BRDFSSS2Complex.phase_function = 0.8
BRDFSSS2Complex.specular_amount = 1.0

########NEW FILE########
__FILENAME__ = Milk_whole
import bpy

from bl_ui.properties_material import active_node_mat


ma = active_node_mat(bpy.context.active_object.active_material)
ma.diffuse_color = 1.0,1.0,1.0 # This will also trigger the update

VRayMaterial = ma.vray
VRayMaterial.type = 'BRDFSSS2Complex'

BRDFSSS2Complex = VRayMaterial.BRDFSSS2Complex

BRDFSSS2Complex.sub_surface_color = 0.949,0.937,0.871
BRDFSSS2Complex.specular_glossiness = 0.8
BRDFSSS2Complex.scatter_radius = 0.737,0.573,0.353
BRDFSSS2Complex.scatter_radius_mult = 2.0
BRDFSSS2Complex.diffuse_color = 0.949,0.937,0.871
BRDFSSS2Complex.ior = 1.3
BRDFSSS2Complex.phase_function = 0.9
BRDFSSS2Complex.specular_amount = 1.0

########NEW FILE########
__FILENAME__ = Potato
import bpy

from bl_ui.properties_material import active_node_mat


ma = active_node_mat(bpy.context.active_object.active_material)
ma.diffuse_color = 1.0,1.0,1.0 # This will also trigger the update

VRayMaterial = ma.vray
VRayMaterial.type = 'BRDFSSS2Complex'

BRDFSSS2Complex = VRayMaterial.BRDFSSS2Complex

BRDFSSS2Complex.sub_surface_color = 0.878,0.788,0.459
BRDFSSS2Complex.specular_glossiness = 0.8
BRDFSSS2Complex.scatter_radius = 0.843,0.600,0.318
BRDFSSS2Complex.scatter_radius_mult = 2.0
BRDFSSS2Complex.diffuse_color = 0.878,0.788,0.459
BRDFSSS2Complex.ior = 1.3
BRDFSSS2Complex.phase_function = 0.8
BRDFSSS2Complex.specular_amount = 1.0

########NEW FILE########
__FILENAME__ = Skin_brown
import bpy

from bl_ui.properties_material import active_node_mat


ma = active_node_mat(bpy.context.active_object.active_material)
ma.diffuse_color = 1.0,1.0,1.0 # This will also trigger the update

VRayMaterial = ma.vray
VRayMaterial.type = 'BRDFSSS2Complex'

BRDFSSS2Complex = VRayMaterial.BRDFSSS2Complex

BRDFSSS2Complex.sub_surface_color = 0.663,0.482,0.361
BRDFSSS2Complex.specular_glossiness = 0.5
BRDFSSS2Complex.scatter_radius = 0.608,0.369,0.259
BRDFSSS2Complex.scatter_radius_mult = 1.0
BRDFSSS2Complex.diffuse_color = 0.663,0.482,0.361
BRDFSSS2Complex.ior = 1.3
BRDFSSS2Complex.phase_function = 0.8
BRDFSSS2Complex.specular_amount = 1.0

########NEW FILE########
__FILENAME__ = Skin_pink
import bpy

from bl_ui.properties_material import active_node_mat


ma = active_node_mat(bpy.context.active_object.active_material)
ma.diffuse_color = 1.0,1.0,1.0 # This will also trigger the update

VRayMaterial = ma.vray
VRayMaterial.type = 'BRDFSSS2Complex'

BRDFSSS2Complex = VRayMaterial.BRDFSSS2Complex

BRDFSSS2Complex.sub_surface_color = 0.796,0.663,0.584
BRDFSSS2Complex.specular_glossiness = 0.5
BRDFSSS2Complex.scatter_radius = 0.694,0.412,0.329
BRDFSSS2Complex.scatter_radius_mult = 1.0
BRDFSSS2Complex.diffuse_color = 0.796,0.663,0.584
BRDFSSS2Complex.ior = 1.3
BRDFSSS2Complex.phase_function = 0.8
BRDFSSS2Complex.specular_amount = 1.0

########NEW FILE########
__FILENAME__ = Skin_yellow
import bpy

from bl_ui.properties_material import active_node_mat


ma = active_node_mat(bpy.context.active_object.active_material)
ma.diffuse_color = 1.0,1.0,1.0 # This will also trigger the update

VRayMaterial = ma.vray
VRayMaterial.type = 'BRDFSSS2Complex'

BRDFSSS2Complex = VRayMaterial.BRDFSSS2Complex

BRDFSSS2Complex.sub_surface_color = 0.800,0.647,0.522
BRDFSSS2Complex.specular_glossiness = 0.5
BRDFSSS2Complex.scatter_radius = 0.694,0.412,0.329
BRDFSSS2Complex.scatter_radius_mult = 1.0
BRDFSSS2Complex.diffuse_color = 0.800,0.647,0.522
BRDFSSS2Complex.ior = 1.3
BRDFSSS2Complex.phase_function = 0.8
BRDFSSS2Complex.specular_amount = 1.0

########NEW FILE########
__FILENAME__ = Spectration
import bpy

from bl_ui.properties_material import active_node_mat


ma = active_node_mat(bpy.context.active_object.active_material)
ma.diffuse_color = 1.0,1.0,1.0 # This will also trigger the update

VRayMaterial = ma.vray
VRayMaterial.type = 'BRDFSSS2Complex'

BRDFSSS2Complex = VRayMaterial.BRDFSSS2Complex

BRDFSSS2Complex.sub_surface_color = 1.000,1.000,1.000
BRDFSSS2Complex.specular_glossiness = 0.0
BRDFSSS2Complex.scatter_radius = 0.000,0.000,0.000
BRDFSSS2Complex.scatter_radius_mult = 0.0
BRDFSSS2Complex.diffuse_color = 1.000,1.000,1.000
BRDFSSS2Complex.ior = 1.5
BRDFSSS2Complex.phase_function = 0.0
BRDFSSS2Complex.specular_amount = 0.0

########NEW FILE########
__FILENAME__ = Water_clear
import bpy

from bl_ui.properties_material import active_node_mat


ma = active_node_mat(bpy.context.active_object.active_material)
ma.diffuse_color = 1.0,1.0,1.0 # This will also trigger the update

VRayMaterial = ma.vray
VRayMaterial.type = 'BRDFSSS2Complex'

BRDFSSS2Complex = VRayMaterial.BRDFSSS2Complex

BRDFSSS2Complex.sub_surface_color = 0.000,0.000,0.000
BRDFSSS2Complex.specular_glossiness = 1.0
BRDFSSS2Complex.scatter_radius = 1.000,1.000,1.000
BRDFSSS2Complex.scatter_radius_mult = 300.0
BRDFSSS2Complex.diffuse_color = 0.000,0.000,0.000
BRDFSSS2Complex.ior = 1.3
BRDFSSS2Complex.phase_function = 0.95
BRDFSSS2Complex.specular_amount = 1.0

########NEW FILE########
__FILENAME__ = proxy
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Python modules  '''
import math
import os
import subprocess
import sys
import tempfile
import time

''' Blender modules '''
import bpy

''' vb modules '''
from vb25.utils import *


def write_mesh_hq(ofile, sce, ob):
	timer= time.clock()

	debug(sce, "Generating HQ file (Frame: %i; File: %s)..." % (sce.frame_current,ofile.name))

	GeomMeshFile= ob.data.vray.GeomMeshFile

	me=  ob.to_mesh(sce, True, 'RENDER')
	dme= None

	if GeomMeshFile.animation and GeomMeshFile.add_velocity:
		if sce.frame_current != sce.frame_end:
			sce.frame_set(sce.frame_current+1)
			dme= ob.to_mesh(sce, True, 'RENDER')

	if GeomMeshFile.apply_transforms:
		me.transform(ob.matrix_world)
		if dme:
			dme.transform(ob.matrix_world)

	if dme:
		for v,dv in zip(me.vertices,dme.vertices):
			ofile.write("v=%.6f,%.6f,%.6f\n" % tuple(v.co))
			ofile.write("l=%.6f,%.6f,%.6f\n" % tuple([dc-c for c,dc in zip(v.co,dv.co)]))
	else:
		for vertex in me.vertices:
			ofile.write("v=%.6f,%.6f,%.6f\n" % tuple(vertex.co))
			ofile.write("l=0.0,0.0,0.0\n")

	face_attr = 'faces' if 'faces' in dir(me) else 'polygons'

	k= 0
	for face in getattr(me, face_attr):
		vert_order= (0,1,2,2,3,0)
		if len(face.vertices) == 4:
			ofile.write("f=%d,%d,%d;%d\n" % (face.vertices[0], face.vertices[1], face.vertices[2], face.material_index + 1))
			ofile.write("f=%d,%d,%d;%d\n" % (face.vertices[2], face.vertices[3], face.vertices[0], face.material_index + 1))
			ofile.write("fn=%i,%i,%i\n" % (k,k+1,k+2))
			ofile.write("fn=%i,%i,%i\n" % (k+3,k+4,k+5))
			k+= 6
		else:
			vert_order= (0,1,2)
			ofile.write("f=%d,%d,%d;%d\n" % (face.vertices[0], face.vertices[1], face.vertices[2], face.material_index + 1))
			ofile.write("fn=%i,%i,%i\n" % (k,k+1,k+2))
			k+= 3
		for v in vert_order:
			if face.use_smooth:
				ofile.write("n=%.6f,%.6f,%.6f\n" % tuple(me.vertices[face.vertices[v]].normal))
			else:
				ofile.write("n=%.6f,%.6f,%.6f\n" % tuple(face.normal))

	uv_textures = me.tessface_uv_textures if 'tessface_uv_textures' in dir(me) else me.uv_textures
	if len(uv_textures):
		uv_layer= uv_textures[0]
		k= 0
		for face in uv_layer.data:
			for i in range(len(face.uv)):
				ofile.write("uv=%.6f,%.6f,0.0\n" % (face.uv[i][0], face.uv[i][1]))
			if len(face.uv) == 4:
				ofile.write("uf=%i,%i,%i\n" % (k,k+1,k+2))
				ofile.write("uf=%i,%i,%i\n" % (k+2,k+3,k))
				k+= 4
			else:
				ofile.write("uf=%i,%i,%i\n" % (k,k+1,k+2))
				k+= 3
	ofile.write("\n")
	
	debug(sce, "Generating HQ file done [%.2f]" % (time.clock() - timer))


def generate_proxy(sce, ob, vrmesh, append=False):
	hq_file= tempfile.NamedTemporaryFile(mode='w', suffix=".hq", delete=False)
	write_mesh_hq(hq_file, sce, ob)
	hq_file.close()
	proxy_creator(hq_file.name, vrmesh, append)
	os.remove(hq_file.name)

########NEW FILE########
__FILENAME__ = render
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Python modules  '''
import math
import os
import string
import subprocess
import sys
import tempfile
import time
import random

import threading
from threading import Timer


''' Blender modules '''
import bpy
import mathutils

''' vb modules '''
import vb25
from vb25.lib     import VRayProcess
from vb25.utils   import *
from vb25.plugins import *
from vb25.texture import *
from vb25.nodes   import *


VERSION = '2.5'


LIGHT_PARAMS= { # TEMP! REMOVE!
	'LightOmni': (
		'enabled',
		#'color_tex',
		'shadows',
		'shadowColor',
		#'shadowColor_tex',
		'shadowBias',
		#'photonSubdivs',
		'causticSubdivs',
		#'diffuseMult',
		'causticMult',
		'cutoffThreshold',
		'affectDiffuse',
		'affectSpecular',
		'bumped_below_surface_check',
		'nsamples',
		'diffuse_contribution',
		'specular_contribution',
		#'units',
		'intensity',
		#'intensity_tex',
		'shadowRadius',
		'areaSpeculars',
		'shadowSubdivs',
		'decay'
	),

	'LightAmbient': (
		'enabled',
		#'color',
		'shadowBias',
		'decay',
		'ambientShade',
	),

	'LightSphere': (
		'enabled',
		#'color_tex',
		'shadows',
		'shadowColor',
		#'shadowColor_tex',
		'shadowBias',
		#'photonSubdivs',
		'causticSubdivs',
		#'diffuseMult',
		'causticMult',
		'cutoffThreshold',
		'affectDiffuse',
		'affectSpecular',
		'bumped_below_surface_check',
		'nsamples',
		'diffuse_contribution',
		'specular_contribution',
		#'units',
		'intensity',
		#'intensity_tex',
		'subdivs',
		'storeWithIrradianceMap',
		'invisible',
		'affectReflections',
		'noDecay',
		'radius',
		'sphere_segments'
	),

	'LightRectangle': (
		'enabled',
		#'color_tex',
		'shadows',
		'shadowColor',
		#'shadowColor_tex',
		'shadowBias',
		#'photonSubdivs',
		'causticSubdivs',
		#'diffuseMult',
		'causticMult',
		'cutoffThreshold',
		'affectDiffuse',
		'affectSpecular',
		'bumped_below_surface_check',
		'nsamples',
		'diffuse_contribution',
		'specular_contribution',
		#'units',
		'intensity',
		#'intensity_tex',
		'subdivs',
		'storeWithIrradianceMap',
		'invisible',
		'affectReflections',
		'doubleSided',
		'noDecay',
	),

	'LightDirectMax': (
		'enabled',
		#'color_tex',
		'shadows',
		'shadowColor',
		#'shadowColor_tex',
		'shadowBias',
		#'photonSubdivs',
		'causticSubdivs',
		#'diffuseMult',
		'causticMult',
		'cutoffThreshold',
		'affectDiffuse',
		'affectSpecular',
		'bumped_below_surface_check',
		'nsamples',
		'diffuse_contribution',
		'specular_contribution',
		'intensity',
		#'intensity_tex',
		'shadowRadius',
		'areaSpeculars',
		'shadowSubdivs',
		'fallsize',
	),

	'SunLight': (
		'turbidity',
		'ozone',
		'water_vapour',
		'intensity_multiplier',
		'size_multiplier',
		#'up_vector',
		'invisible',
		'horiz_illum',
		#'sky_model',
		'shadows',
		#'atmos_shadows',
		'shadowBias',
		'shadow_subdivs',
		'shadow_color',
		#'shadow_color_tex',
		#'photon_radius',
		#'photonSubdivs',
		'causticSubdivs',
		#'diffuseMult',
		'causticMult',
		'enabled'
	),

	'LightIESMax': (
		'enabled',
		'intensity',
		#'color_tex',
		'shadows',
		'shadowColor',
		#'shadowColor_tex',
		'shadowBias',
		#'photonSubdivs',
		'causticSubdivs',
		#'diffuseMult',
		'causticMult',
		'cutoffThreshold',
		'affectDiffuse',
		'affectSpecular',
		'bumped_below_surface_check',
		'nsamples',
		'diffuse_contribution',
		'specular_contribution',
		'shadowSubdivs',
		'ies_file',
		#'filter_color',
		'soft_shadows',
		#'area_speculars'
	),

	'LightDome': (
		'enabled',
		#'color_tex',
		'shadows',
		'shadowColor',
		#'shadowColor_tex',
		'shadowBias',
		#'photonSubdivs',
		'causticSubdivs',
		#'diffuseMult',
		'causticMult',
		'cutoffThreshold',
		'affectDiffuse',
		'affectSpecular',
		'bumped_below_surface_check',
		'nsamples',
		'diffuse_contribution',
		'specular_contribution',
		#'channels',
		#'channels_raw',
		#'channels_diffuse',
		#'channels_specular',
		#'units',
		'intensity',
		#'intensity_tex',
		'subdivs',
		#'storeWithIrradianceMap',
		'invisible',
		'affectReflections',
		#'dome_tex',
		#'use_dome_tex',
		#'tex_resolution',
		#'tex_adaptive',
		'dome_targetRadius',
		'dome_emitRadius',
		'dome_spherical',
		'dome_rayDistance',
		'dome_rayDistanceMode',
	),

	'LightSpot': (
		'enabled',
		#'color_tex',
		'shadows',
		'shadowColor',
		#'shadowColor_tex',
		'shadowBias',
		#'photonSubdivs',
		'causticSubdivs',
		#'diffuseMult',
		'causticMult',
		'cutoffThreshold',
		'affectDiffuse',
		'affectSpecular',
		'bumped_below_surface_check',
		'nsamples',
		'diffuse_contribution',
		'specular_contribution',
		#'units',
		'intensity',
		#'intensity_tex',
		'shadowRadius',
		'areaSpeculars',
		'shadowSubdivs',
		#'coneAngle',
		#'penumbraAngle',
		#'dropOff',
		#'falloffType',
		'decay',
		#'barnDoor',
		#'barnDoorLeft',
		#'barnDoorRight',
		#'barnDoorTop',
		#'barnDoorBottom',
		#'useDecayRegions',
		#'startDistance1',
		#'endDistance1',
		#'startDistance2',
		#'endDistance2',
		#'startDistance3',
		#'endDistance3'
	),
}



'''
  MESHES
'''
def write_geometry_python(bus):
	scene= bus['scene']

	VRayScene= scene.vray
	VRayExporter= VRayScene.exporter

	def write_frame(bus):
		# Filters stores already exported data
		bus['filter']= {}
		bus['filter']['mesh']= []

		for ob in scene.objects:
			if ob.type not in GEOM_TYPES:
				continue

			# Skip proxy meshes
			if hasattr(ob.data, 'GeomMeshFile') and ob.data.vray.GeomMeshFile.use:
				continue

			if VRayExporter.mesh_active_layers or bus['preview']:
				if not object_on_visible_layers(scene,ob):
					continue

			try:
				mesh= ob.to_mesh(scene, True, 'RENDER')
			except:
				mesh= ob.create_mesh(scene, True, 'RENDER')
			mesh_name= get_name(ob.data, prefix='ME')

			if VRayExporter.use_instances:
				if mesh_name in bus['filter']['mesh']:
					continue
				bus['filter']['mesh'].append(mesh_name)
			else:
				mesh_name= get_name(ob, prefix='ME')

			bus['node']= {}

			# Currently processes object
			bus['node']['object']= ob
			bus['node']['mesh']= mesh
			bus['node']['mesh_name']= mesh_name

			PLUGINS['GEOMETRY']['GeomStaticMesh'].write(bus)

	# Output files
	bus['files']['geometry']= []
	for thread in range(scene.render.threads):
		bus['files']['geometry'].append(open(bus['filenames']['geometry'][:-11]+"_%.2i.vrscene"%(thread), 'w'))

	for geometry_file in bus['files']['geometry']:
		geometry_file.write("// V-Ray/Blender %s" % VERSION)
		geometry_file.write("\n// Geometry file\n")

	timer= time.clock()
	debug(scene, "Writing meshes...")

	if VRayExporter.animation and VRayExporter.animation_type == 'FULL' and not VRayExporter.camera_loop:
		cur_frame= scene.frame_current
		scene.frame_set(scene.frame_start)
		f= scene.frame_start
		while(f <= scene.frame_end):
			exported_meshes= []
			scene.frame_set(f)
			write_frame(bus)
			f+= scene.frame_step
		scene.frame_set(cur_frame)
	else:
		write_frame(bus)

	for geometry_file in bus['files']['geometry']:
		geometry_file.write("\n// vim: set syntax=on syntax=c:\n\n")
		geometry_file.close()

	del bus['files']['geometry']

	debug(scene, "Writing meshes... done {0:<64}".format("[%.2f]"%(time.clock() - timer)))


def write_geometry(bus):
	scene=        bus['scene']
	VRayScene=    scene.vray
	VRayExporter= VRayScene.exporter

	# if 'export_nodes' in dir(bpy.ops.vray):
	# 	# Call V-Ray/Blender custom node export operator
	# 	bpy.ops.vray.export_nodes(
	# 		scene    = scene.as_pointer(),
	# 		filepath = bus['filenames']['nodes'],
	# 		debug    = VRayExporter.mesh_debug
	# 	)

	if 'export_meshes' in dir(bpy.ops.vray):
		# Call V-Ray/Blender custom mesh export operator
		bpy.ops.vray.export_meshes(
			filepath          = bus['filenames']['geometry'][:-11],
			use_active_layers = VRayExporter.mesh_active_layers,
			use_animation     = VRayExporter.animation and VRayExporter.animation_type == 'FULL',
			use_instances     = VRayExporter.use_instances,
			debug             = VRayExporter.mesh_debug,
			check_animated    = VRayExporter.check_animated,
			scene             = str(scene.as_pointer())
		)
	else:
		# Use python mesh export
		write_geometry_python(bus)


def write_GeomMayaHair(bus, ps, hair_geom_name):
	scene= bus['scene']
	ofile= bus['files']['nodes']
	ob=    bus['node']['object']

	VRayFur= ps.settings.vray.VRayFur

	num_hair_vertices= []
	hair_vertices=     []
	widths=            []

	for p,particle in enumerate(ps.particles):
		sys.stdout.write("%s: Object: %s => Hair: %s\r" % (color("V-Ray/Blender", 'green'), color(ob.name,'yellow'), color(p, 'green')))
		sys.stdout.flush()

		segments= len(particle.hair_keys)
		num_hair_vertices.append( HexFormat(segments) )

		width= VRayFur.width / 2.0
		thin_start= int(VRayFur.thin_start / 100 * segments)
		thin_segments= segments - thin_start
		thin_step= width / (thin_segments + 1)
		for s,segment in enumerate(particle.hair_keys):
			for c in segment.co:
				hair_vertices.append( HexFormat(c) )
			if bus['preview']:
				widths.append( HexFormat(0.01) )
			else:
				if VRayFur.make_thinner:
					if s > thin_start:
						width-= thin_step
				widths.append( HexFormat(width) )

	ofile.write("\nGeomMayaHair %s {" % hair_geom_name)
	ofile.write("\n\tnum_hair_vertices= interpolate((%d,ListIntHex(\"%s\")));"%(scene.frame_current, ''.join(num_hair_vertices)))
	ofile.write("\n\thair_vertices= interpolate((%d,ListVectorHex(\"%s\")));"%(scene.frame_current,  ''.join(hair_vertices)))
	ofile.write("\n\twidths= interpolate((%d,ListFloatHex(\"%s\")));"%(scene.frame_current,          ''.join(widths)))
	ofile.write("\n}\n")


'''
  SETTINGS
'''
def write_settings(bus):
	ofile = bus['files']['scene']
	scene = bus['scene']

	VRayScene = scene.vray
	VRayExporter    = VRayScene.exporter
	VRayDR          = VRayScene.VRayDR
	SettingsOutput  = VRayScene.SettingsOutput
	SettingsOptions = VRayScene.SettingsOptions
	Includer        = VRayScene.Includer

	threadCount = scene.render.threads
	if VRayExporter.meshExportThreads:
		threadCount = VRayExporter.meshExportThreads

	PLUGINS['CAMERA']['SettingsCamera'].write(bus)
	PLUGINS['CAMERA']['SettingsMotionBlur'].write(bus)

	for key in PLUGINS['SETTINGS']:
		if key in ('BakeView', 'RenderView', 'VRayStereoscopicSettings'):
			# Skip some plugins
			continue

		plugin= PLUGINS['SETTINGS'][key]
		if hasattr(plugin, 'write'):
			plugin.write(bus)

	if VRayScene.render_channels_use:
		for render_channel in VRayScene.render_channels:
			if render_channel.use:
				plugin= PLUGINS['RENDERCHANNEL'].get(render_channel.type)
				if plugin:
					try:
						plugin.write(bus, getattr(render_channel,plugin.PLUG), name=render_channel.name)
					except:
						plugin.write(ofile, getattr(render_channel,plugin.PLUG), scene, name=render_channel.name)

	# Preview settings are in different parts of the file,
	# because smth must be set before and smth after.
	if bus['preview']:
		bus['files']['scene'].write("\n// Preview settings")
		bus['files']['scene'].write("\nSettingsDMCSampler {")
		bus['files']['scene'].write("\n\tadaptive_amount= 0.99;")
		bus['files']['scene'].write("\n\tadaptive_threshold= 0.2;")
		bus['files']['scene'].write("\n\tsubdivs_mult= 0.01;")
		bus['files']['scene'].write("\n}\n")
		bus['files']['scene'].write("\nSettingsOptions {")
		bus['files']['scene'].write("\n\tmtl_limitDepth= 1;")
		bus['files']['scene'].write("\n\tmtl_maxDepth= 1;")
		bus['files']['scene'].write("\n\tmtl_transpMaxLevels= 10;")
		bus['files']['scene'].write("\n\tmtl_transpCutoff= 0.1;")
		bus['files']['scene'].write("\n\tmtl_glossy= 1;")
		bus['files']['scene'].write("\n\tmisc_lowThreadPriority= 1;")
		bus['files']['scene'].write("\n}\n")
		bus['files']['scene'].write("\nSettingsImageSampler {")
		bus['files']['scene'].write("\n\ttype= 0;") # Fastest result, but no AA :(
		bus['files']['scene'].write("\n\tfixed_subdivs= 1;")
		bus['files']['scene'].write("\n}\n")

		bus['files']['scene'].write("\nBRDFDiffuse BRDFVRayMtlMAcheckerdark {")
		bus['files']['scene'].write("\n\tcolor=Color(0.1,0.1,0.1);")
		bus['files']['scene'].write("\n}\n")
		bus['files']['scene'].write("\nBRDFDiffuse BRDFVRayMtlMAcheckerlight {")
		bus['files']['scene'].write("\n\tcolor=Color(0.95,0.95,0.95);")
		bus['files']['scene'].write("\n}\n")

	if VRayExporter.draft:
		bus['files']['scene'].write("\n// Draft settings")
		bus['files']['scene'].write("\nSettingsDMCSampler {")
		bus['files']['scene'].write("\n\tadaptive_amount= 0.85;")
		bus['files']['scene'].write("\n\tadaptive_threshold= 0.1;")
		bus['files']['scene'].write("\n\tsubdivs_mult= 0.1;")
		bus['files']['scene'].write("\n}\n")

	for key in bus['filenames']:
		if key in ('output', 'output_filename', 'output_loadfile', 'lightmaps', 'scene', 'DR'):
			# Skip some files
			continue

		if VRayDR.on and VRayDR.transferAssets == '0':
			if key == 'geometry':
				for t in range(threadCount):
					if PLATFORM == 'win32':
						ofile.write("\n#include \"//%s/%s/%s/%s_%.2i.vrscene\"" % (HOSTNAME, VRayDR.share_name, bus['filenames']['DR']['sub_dir'], os.path.basename(bus['filenames']['geometry'][:-11]), t))
					else:
						ofile.write("\n#include \"%s_%.2i.vrscene\"" % (bus['filenames']['DR']['prefix'] + os.sep + os.path.basename(bus['filenames']['geometry'][:-11]), t))
			else:
				if PLATFORM == 'win32':
					ofile.write("\n#include \"//%s/%s/%s/%s\"" % (HOSTNAME, VRayDR.share_name, bus['filenames']['DR']['sub_dir'], os.path.basename(bus['filenames'][key])))
				else:
					ofile.write("\n#include \"%s\"" % (bus['filenames']['DR']['prefix'] + os.sep + os.path.basename(bus['filenames'][key])))
		else:
			if key == 'geometry':
				if bus['preview']:
					ofile.write("\n#include \"%s\"" % os.path.join(get_vray_exporter_path(), "preview", "preview_geometry.vrscene"))
				else:
					for t in range(threadCount):
						ofile.write("\n#include \"%s_%.2i.vrscene\"" % (os.path.basename(bus['filenames']['geometry'][:-11]), t))
			else:
				if bus['preview'] and key == 'colorMapping':
					if os.path.exists(bus['filenames'][key]):
						ofile.write("\n#include \"%s\"" % bus['filenames'][key])
				else:
					ofile.write("\n#include \"%s\"" % os.path.basename(bus['filenames'][key]))
	ofile.write("\n")

	if Includer.use:
		ofile.write("\n// Include additional *.vrscene files")
		for includeNode in Includer.nodes:
			if includeNode.use == True:
				ofile.write("\n#include \"" + bpy.path.abspath(includeNode.scene) + "\"\t\t // " + includeNode.name)


'''
  MATERIALS & TEXTURES
'''
def write_lamp_textures(bus):
	scene= bus['scene']
	ofile= bus['files']['lights']
	ob=    bus['node']['object']

	VRayScene=    scene.vray
	VRayExporter= VRayScene.exporter

	la= ob.data
	VRayLamp= la.vray

	defaults= {
		'color':       (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(la.color)),               0, 'NONE'),
		'intensity':   (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple([VRayLamp.intensity]*3)), 0, 'NONE'),
		'shadowColor': (a(scene,"AColor(%.6f,%.6f,%.6f,1.0)"%tuple(VRayLamp.shadowColor)),   0, 'NONE'),
	}

	bus['lamp_textures']= {}

	for i,slot in enumerate(la.texture_slots):
		if slot and slot.texture and slot.texture.type in TEX_TYPES:
			VRaySlot=    slot.texture.vray_slot
			VRayLight=   VRaySlot.VRayLight

			for key in defaults:
				use_slot= False
				factor=   1.0

				if getattr(VRayLight, 'map_'+key):
					use_slot= True
					factor=   getattr(VRayLight, key+'_mult')

				if use_slot:
					if key not in bus['lamp_textures']: # First texture
						bus['lamp_textures'][key]= []
						if factor < 1.0 or VRaySlot.blend_mode != 'NONE' or slot.use_stencil:
							bus['lamp_textures'][key].append(defaults[key])

					bus['mtex']= {}
					bus['mtex']['dome'] = True if la.type == 'HEMI' else False
					bus['mtex']['mapto']=   key
					bus['mtex']['slot']=    slot
					bus['mtex']['texture']= slot.texture
					bus['mtex']['factor']=  factor
					bus['mtex']['name']=    clean_string("LT%.2iSL%sTE%s" % (i,
																			 slot.name,
																			 slot.texture.name))

					# Write texture
					if write_texture(bus):
						bus['lamp_textures'][key].append( [stack_write_texture(bus),
														   slot.use_stencil,
														   VRaySlot.blend_mode] )

	if VRayExporter.debug:
		if len(bus['lamp_textures']):
			print_dict(scene, "Lamp \"%s\" texture stack" % la.name, bus['lamp_textures'])

	for key in bus['lamp_textures']:
		if len(bus['lamp_textures'][key]):
			bus['lamp_textures'][key]= write_TexOutput(bus, stack_write_textures(bus, stack_collapse_layers(bus['lamp_textures'][key])), key)

	return bus['lamp_textures']


def	write_material(bus):
	scene= bus['scene']
#	Includer = scene.vray.Includer
#	if Includer.materials:
#		return


	ofile= bus['files']['materials']
	

	ob=    bus['node']['object']
	base=  bus['node']['base']

	ma=    bus['material']['material']

	# Linked groups material override feature
	if base.dupli_type == 'GROUP':
		base_material_names= []
		for slot in base.material_slots:
			if slot and slot.material:
				base_material_names.append(slot.material.name)
		for base_ma in base_material_names:
			if base_ma.find(ma.name) != -1:
				slot= base.material_slots.get(base_ma)
				ma=   slot.material
				bus['material']['material']= ma

	VRayMaterial= ma.vray

	ma_name= get_name(ma, prefix='MA')

	# Check Toon before cache
	if VRayMaterial.VolumeVRayToon.use:
		bus['effects']['toon']['effects'].append(
			PLUGINS['SETTINGS']['SettingsEnvironment'].write_VolumeVRayToon_from_material(bus)
		)
		append_unique(bus['effects']['toon']['objects'], bus['node']['object'])

	# Write material textures
	write_material_textures(bus)

	# Check if material uses object mapping
	# In this case material is object dependend
	# because mapping is object dependent
	if bus['material']['orco_suffix']:
		ma_name+= bus['material']['orco_suffix']

	if not append_unique(bus['cache']['materials'], ma_name):
		return ma_name

	# Init wrapper / override / etc
	complex_material= []
	for component in (VRayMaterial.Mtl2Sided.use,
					  VRayMaterial.MtlWrapper.use,
					  VRayMaterial.MtlOverride.use,
					  VRayMaterial.MtlRenderStats.use,
					  VRayMaterial.round_edges,
					  VRayMaterial.material_id_number):
		if component:
			complex_material.append("MC%.2d_%s" % (len(complex_material), ma_name))
	complex_material.append(ma_name)
	complex_material.reverse()

	if VRayMaterial.type == 'MtlVRmat':
		PLUGINS['BRDF']['MtlVRmat'].write(bus, name=complex_material[-1])
	else:
		# Write material BRDF
		brdf= PLUGINS['BRDF'][VRayMaterial.type].write(bus)

		# print_dict(scene, "Bus", bus)

		# Add normal mapping if needed
		brdf= PLUGINS['BRDF']['BRDFBump'].write(bus, base_brdf = brdf)

		# Add bump mapping if needed
		brdf= PLUGINS['BRDF']['BRDFBump'].write(bus, base_brdf = brdf, use_bump = True)

		ofile.write("\nMtlSingleBRDF %s {"%(complex_material[-1]))
		ofile.write("\n\tbrdf=%s;" % a(scene, brdf))
		ofile.write("\n\tallow_negative_colors=1;")
		ofile.write("\n}\n")

	if VRayMaterial.Mtl2Sided.use:
		base_material= complex_material.pop()
		ofile.write("\nMtl2Sided %s {"%(complex_material[-1]))
		ofile.write("\n\tfront= %s;"%(base_material))
		back= base_material
		if VRayMaterial.Mtl2Sided.back:
			if VRayMaterial.Mtl2Sided.back in bpy.data.materials:
				back= get_name(bpy.data.materials[VRayMaterial.Mtl2Sided.back], prefix='MA')
		ofile.write("\n\tback= %s;"%(back))

		if VRayMaterial.Mtl2Sided.control == 'SLIDER':
			ofile.write("\n\ttranslucency= %s;" % a(scene, "Color(1.0,1.0,1.0)*%.3f" % VRayMaterial.Mtl2Sided.translucency_slider))
		elif VRayMaterial.Mtl2Sided.control == 'COLOR':
			ofile.write("\n\ttranslucency= %s;" % a(scene, VRayMaterial.Mtl2Sided.translucency_color))
		else:
			if VRayMaterial.Mtl2Sided.translucency_tex:
				translucency_tex = write_subtexture(bus, VRayMaterial.Mtl2Sided.translucency_tex)
				if translucency_tex:
					ofile.write("\n\ttranslucency_tex= %s;" % (translucency_tex))
					ofile.write("\n\ttranslucency_tex_mult= %s;" % a(scene,VRayMaterial.Mtl2Sided.translucency_tex_mult))
			else:
				ofile.write("\n\ttranslucency= %s;" % a(scene, "Color(1.0,1.0,1.0)*%.3f" % VRayMaterial.Mtl2Sided.translucency_slider))

		ofile.write("\n\tforce_1sided= %d;" % VRayMaterial.Mtl2Sided.force_1sided)
		ofile.write("\n}\n")

	if VRayMaterial.MtlWrapper.use:
		base_material= complex_material.pop()
		ofile.write("\nMtlWrapper %s {"%(complex_material[-1]))
		ofile.write("\n\tbase_material= %s;"%(base_material))
		for param in PLUGINS['MATERIAL']['MtlWrapper'].PARAMS:
			ofile.write("\n\t%s= %s;"%(param, a(scene,getattr(VRayMaterial.MtlWrapper,param))))
		ofile.write("\n}\n")

	if VRayMaterial.MtlOverride.use:
		base_mtl= complex_material.pop()
		ofile.write("\nMtlOverride %s {"%(complex_material[-1]))
		ofile.write("\n\tbase_mtl= %s;"%(base_mtl))

		for param in ('gi_mtl','reflect_mtl','refract_mtl','shadow_mtl'):
			override_material= getattr(VRayMaterial.MtlOverride, param)
			if override_material:
				if override_material in bpy.data.materials:
					ofile.write("\n\t%s= %s;"%(param, get_name(bpy.data.materials[override_material], prefix='MA')))

		environment_override= VRayMaterial.MtlOverride.environment_override
		if environment_override:
			if environment_override in bpy.data.textures:
				ofile.write("\n\tenvironment_override= %s;" % get_name(bpy.data.textures[environment_override], prefix='TE'))

		ofile.write("\n\tenvironment_priority= %i;"%(VRayMaterial.MtlOverride.environment_priority))
		ofile.write("\n}\n")

	if VRayMaterial.MtlRenderStats.use:
		base_mtl= complex_material.pop()
		ofile.write("\nMtlRenderStats %s {"%(complex_material[-1]))
		ofile.write("\n\tbase_mtl= %s;"%(base_mtl))
		for param in PLUGINS['MATERIAL']['MtlRenderStats'].PARAMS:
			ofile.write("\n\t%s= %s;"%(param, a(scene,getattr(VRayMaterial.MtlRenderStats,param))))
		ofile.write("\n}\n")

	if VRayMaterial.round_edges:
		base_mtl= complex_material.pop()
		ofile.write("\nMtlRoundEdges %s {" % complex_material[-1])
		ofile.write("\n\tbase_mtl= %s;" % base_mtl)
		ofile.write("\n\tradius= %.3f;" % VRayMaterial.radius)
		ofile.write("\n}\n")

	if VRayMaterial.material_id_number:
		base_mtl= complex_material.pop()
		ofile.write("\nMtlMaterialID %s {" % complex_material[-1])
		ofile.write("\n\tbase_mtl= %s;" % base_mtl)
		ofile.write("\n\tmaterial_id_number= %i;" % VRayMaterial.material_id_number)
		ofile.write("\n\tmaterial_id_color= %s;" % p(VRayMaterial.material_id_color))
		ofile.write("\n}\n")

	return ma_name


def write_materials(bus):
	ofile= bus['files']['materials']
	scene= bus['scene']

	ob=    bus['node']['object']

	VRayScene= scene.vray
	SettingsOptions= VRayScene.SettingsOptions

	# Multi-material name
	mtl_name = get_name(ob, prefix='OBMA')

	# Reset displacement settings pointers
	bus['node']['displacement_slot']    = None
	bus['node']['displacement_texture'] = None

	# Collecting and exporting object materials
	mtls_list= []
	ids_list=  []
	ma_id= 0 # For cases with empty slots

	if len(ob.material_slots):
		for slot in ob.material_slots:
			ma = slot.material
			if not ma:
				continue

			bus['material'] = {}
			bus['material']['material'] = ma

			if SettingsOptions.mtl_override_on and SettingsOptions.mtl_override:
				if not ma.vray.dontOverride:
					bus['material']['material'] = get_data_by_name(scene, 'materials', SettingsOptions.mtl_override)

			# Normal mapping settings pointer
			bus['material']['normal_slot'] = None

			# Bump mapping settings pointer
			bus['material']['bump_slot']   = None

			# Set if any texture uses object mapping
			bus['material']['orco_suffix'] = ""

			mtls_list.append(write_material(bus))
			ma_id+= 1
			ids_list.append(str(ma_id))

	# No materials assigned - use default material
	if len(mtls_list) == 0:
		bus['node']['material']= bus['defaults']['material']

	# Only one material - no need for Multi-material
	elif len(mtls_list) == 1:
		bus['node']['material']= mtls_list[0]

	# Several materials assigned - need Mutli-material
	else:
		bus['node']['material']= mtl_name
		ofile.write("\nMtlMulti %s {" % mtl_name)
		ofile.write("\n\tmtls_list= List(%s);" % ','.join(mtls_list))
		ofile.write("\n\tids_list= ListInt(%s);" % ','.join(ids_list))
		ofile.write("\n}\n")


def write_lamp(bus):
	LIGHT_PORTAL= {
		'NORMAL':  0,
		'PORTAL':  1,
		'SPORTAL': 2,
	}
	SKY_MODEL= {
		'CIEOVER'  : 2,
		'CIECLEAR' : 1,
		'PREETH'   : 0,
	}
	UNITS= {
		'DEFAULT' : 0,
		'LUMENS'  : 1,
		'LUMM'    : 2,
		'WATTSM'  : 3,
		'WATM'    : 4,
	}

	scene= bus['scene']
	ofile= bus['files']['lights']
	ob=    bus['node']['object']

	lamp= ob.data
	VRayLamp= lamp.vray

	lamp_type= None

	lamp_name=   get_name(ob, prefix='LA')
	lamp_matrix= ob.matrix_world

	if 'dupli' in bus['node'] and 'name' in bus['node']['dupli']:
		lamp_name+=  bus['node']['dupli']['name']
		lamp_matrix= bus['node']['dupli']['matrix']

	if 'particle' in bus['node'] and 'name' in bus['node']['particle']:
		lamp_name+=  bus['node']['particle']['name']
		lamp_matrix= bus['node']['particle']['matrix']

	textures= write_lamp_textures(bus)

	if lamp.type == 'POINT':
		if VRayLamp.omni_type == 'AMBIENT':
			lamp_type= 'LightAmbient'
		else:
			if VRayLamp.radius > 0:
				lamp_type= 'LightSphere'
			else:
				lamp_type= 'LightOmni'
	elif lamp.type == 'SPOT':
		if VRayLamp.spot_type == 'SPOT':
			lamp_type= 'LightSpot'
		else:
			lamp_type= 'LightIESMax'
	elif lamp.type == 'SUN':
		if VRayLamp.direct_type == 'DIRECT':
			lamp_type= 'LightDirectMax'
		else:
			lamp_type= 'SunLight'
	elif lamp.type == 'AREA':
		lamp_type= 'LightRectangle'
	elif lamp.type == 'HEMI':
		lamp_type= 'LightDome'
	else:
		return

	ofile.write("\n%s %s {"%(lamp_type,lamp_name))

	if 'color' in textures:
		if lamp.type == 'SUN' and VRayLamp.direct_type == 'DIRECT':
			ofile.write("\n\tprojector_map= %s;" % textures['color'])

		if lamp.type in {'AREA','HEMI'}:
			ofile.write("\n\ttex_adaptive= %.2f;" % (1.0))
			ofile.write("\n\ttex_resolution= %i;" % (512))

			if lamp.type == 'AREA':
				ofile.write("\n\tuse_rect_tex= 1;")
				ofile.write("\n\trect_tex= %s;" % textures['color'])
			elif lamp.type == 'HEMI':
				ofile.write("\n\tuse_dome_tex= 1;")
				ofile.write("\n\tdome_tex= %s;" % textures['color'])

		if lamp.type not in {'HEMI'}:
			ofile.write("\n\tcolor_tex= %s;" % textures['color'])

	if 'intensity' in textures:
		ofile.write("\n\tintensity_tex= %s;" % a(scene, "%s::out_intensity" % textures['intensity']))

	if 'shadowColor' in textures:
		if lamp.type == 'SUN' and VRayLamp.direct_type == 'DIRECT':
			ofile.write("\n\tshadowColor_tex= %s;" % textures['shadowColor'])
		else:
			ofile.write("\n\tshadow_color_tex= %s;" % textures['shadowColor'])

	if lamp_type == 'SunLight':
		ofile.write("\n\tsky_model= %i;"%(SKY_MODEL[VRayLamp.sky_model]))
		ofile.write("\n\tfilter_color=%s;" % a(scene, "Color(%.6f, %.6f, %.6f)"%(tuple(lamp.color))))
	else:
		if VRayLamp.color_type == 'RGB':
			color= lamp.color
		else:
			color= kelvin_to_rgb(VRayLamp.temperature)
		ofile.write("\n\tcolor= %s;" % a(scene, "Color(%.6f, %.6f, %.6f)"%(tuple(color))))

		if lamp_type not in ('LightIESMax', 'LightAmbient'):
			ofile.write("\n\tunits= %i;"%(UNITS[VRayLamp.units]))

		if lamp_type == 'LightIESMax':
			ofile.write("\n\ties_light_shape= %i;" % (VRayLamp.ies_light_shape if VRayLamp.ies_light_shape else -1))
			ofile.write("\n\ties_light_width= %.3f;" %    (VRayLamp.ies_light_width))
			ofile.write("\n\ties_light_length= %.3f;" %   (VRayLamp.ies_light_width if VRayLamp.ies_light_shape_lock else VRayLamp.ies_light_length))
			ofile.write("\n\ties_light_height= %.3f;" %   (VRayLamp.ies_light_width if VRayLamp.ies_light_shape_lock else VRayLamp.ies_light_height))
			ofile.write("\n\ties_light_diameter= %.3f;" % (VRayLamp.ies_light_diameter))

	if lamp_type == 'LightSpot':
		ofile.write("\n\tconeAngle= %s;" % a(scene,lamp.spot_size))
		ofile.write("\n\tpenumbraAngle= %s;" % a(scene, - lamp.spot_size * lamp.spot_blend))

		ofile.write("\n\tdecay=%s;" % a(scene, VRayLamp.decay))

		ofile.write("\n\tuseDecayRegions=1;")
		ofile.write("\n\tstartDistance1=%s;" % a(scene, 0.0))
		ofile.write("\n\tendDistance1=%s;" % a(scene, lamp.distance-lamp.spot_blend))
		ofile.write("\n\tstartDistance2=%s;" % a(scene, lamp.distance-lamp.spot_blend))
		ofile.write("\n\tendDistance2=%s;" % a(scene, lamp.distance-lamp.spot_blend))
		ofile.write("\n\tstartDistance3=%s;" % a(scene, lamp.distance-lamp.spot_blend))
		ofile.write("\n\tendDistance3=%s;" % a(scene, lamp.distance))

	if lamp_type == 'LightRectangle':
		if lamp.shape == 'RECTANGLE':
			ofile.write("\n\tu_size= %s;"%(a(scene,lamp.size/2)))
			ofile.write("\n\tv_size= %s;"%(a(scene,lamp.size_y/2)))
		else:
			ofile.write("\n\tu_size= %s;"%(a(scene,lamp.size/2)))
			ofile.write("\n\tv_size= %s;"%(a(scene,lamp.size/2)))
		ofile.write("\n\tlightPortal= %i;"%(LIGHT_PORTAL[VRayLamp.lightPortal]))

	for param in LIGHT_PARAMS[lamp_type]:
		if param == 'shadow_subdivs':
			ofile.write("\n\tshadow_subdivs= %s;"%(a(scene,VRayLamp.subdivs)))
		elif param == 'shadowSubdivs':
			ofile.write("\n\tshadowSubdivs= %s;"%(a(scene,VRayLamp.subdivs)))
		elif param == 'shadowRadius' and lamp_type == 'LightDirectMax':
			ofile.write("\n\t%s= %s;" % (param, a(scene,VRayLamp.shadowRadius)))
			ofile.write("\n\tshadowShape=%s;" % VRayLamp.shadowShape)
			ofile.write("\n\tshadowRadius1= %s;" % a(scene,VRayLamp.shadowRadius))
			ofile.write("\n\tshadowRadius2= %s;" % a(scene,VRayLamp.shadowRadius))
		elif param == 'intensity' and lamp_type == 'LightIESMax':
			ofile.write("\n\tpower= %s;"%(a(scene, "%i" % (int(VRayLamp.intensity)))))
		elif param == 'shadow_color':
			ofile.write("\n\tshadow_color= %s;"%(a(scene,VRayLamp.shadowColor)))
		elif param == 'ies_file':
			ofile.write("\n\t%s= \"%s\";"%(param, get_full_filepath(bus,lamp,VRayLamp.ies_file)))
		else:
			ofile.write("\n\t%s= %s;"%(param, a(scene,getattr(VRayLamp,param))))

	ofile.write("\n\ttransform= %s;"%(a(scene,transform(lamp_matrix))))

	# Render Elements
	#
	listRenderElements = {
		'channels_raw'      : [],
		'channels_diffuse'  : [],
		'channels_specular' : [],
	}

	for channel in scene.vray.render_channels:
		if channel.type == 'LIGHTSELECT' and channel.use:
			channelData = channel.RenderChannelLightSelect
			channelName = "LightSelect_%s" % clean_string(channel.name)

			lampList = generateDataList(channelData.lights, 'lamps')

			if lamp in lampList:
				if channelData.type == 'RAW':
					listRenderElements['channels_raw'].append(channelName)
				elif channelData.type == 'DIFFUSE':
					listRenderElements['channels_diffuse'].append(channelName)
				elif channelData.type == 'SPECULAR':
					listRenderElements['channels_specular'].append(channelName)

	for key in listRenderElements:
		renderChannelArray = listRenderElements[key]

		if not len(renderChannelArray):
			continue

		ofile.write("\n\t%s=List(%s);" % (key, ",".join(renderChannelArray)))

	ofile.write("\n}\n")


def write_node(bus):
	scene=      bus['scene']
	ofile=      bus['files']['nodes']
	ob=         bus['node']['object']
	visibility= bus['visibility']

	VRayScene= scene.vray
	SettingsOptions= VRayScene.SettingsOptions

	# Lights struct proposal for support Lamps inside duplis and particles:
	#  [{'name': vray lamp name, 'lamp': lamp_pointer}
	#   {...}]
	lights= []
	for lamp in [o for o in scene.objects if o.type == 'LAMP' or o.vray.LightMesh.use]:
		if lamp.data is None:
			continue

		if lamp.type == 'LAMP':
			VRayLamp= lamp.data.vray
		else:
			VRayLamp= lamp.vray.LightMesh

		lamp_name= get_name(lamp, prefix='LA')

		if not object_on_visible_layers(scene, lamp) or lamp.hide_render:
			if not scene.vray.SettingsOptions.light_doHiddenLights:
				continue

		if VRayLamp.use_include_exclude:
			object_list= generate_object_list(VRayLamp.include_objects, VRayLamp.include_groups)
			if VRayLamp.include_exclude == 'INCLUDE':
				if ob in object_list:
					append_unique(lights, lamp_name)
			else:
				if ob not in object_list:
					append_unique(lights, lamp_name)

		else:
			append_unique(lights, lamp_name)

	node_name= bus['node']['name']
	matrix=    bus['node']['matrix']
	base_mtl=  bus['node']['material']

	if 'dupli' in bus['node'] and 'name' in bus['node']['dupli']:
		node_name= bus['node']['dupli']['name']
		matrix=    bus['node']['dupli']['matrix']

	if 'particle' in bus['node'] and 'name' in bus['node']['particle']:
		node_name= bus['node']['particle']['name']
		matrix=    bus['node']['particle']['matrix']

	if 'hair' in bus['node'] and bus['node']['hair'] == True:
		node_name+= 'HAIR'

	material = base_mtl

	if not VRayScene.RTEngine.enabled and not VRayScene.RTEngine.use_opencl:
		material = "RS%s" % node_name

		ofile.write("\nMtlRenderStats %s {" % material)
		ofile.write("\n\tbase_mtl= %s;" % base_mtl)
		ofile.write("\n\tvisibility= %s;" %             a(scene, (0 if ob in visibility['all'] or bus['node']['visible'] == False else 1)))
		ofile.write("\n\tcamera_visibility= %s;" %      a(scene, (0 if ob in visibility['camera']  else 1)))
		ofile.write("\n\tgi_visibility= %s;" %          a(scene, (0 if ob in visibility['gi']      else 1)))
		ofile.write("\n\treflections_visibility= %s;" % a(scene, (0 if ob in visibility['reflect'] else 1)))
		ofile.write("\n\trefractions_visibility= %s;" % a(scene, (0 if ob in visibility['refract'] else 1)))
		ofile.write("\n\tshadows_visibility= %s;" %     a(scene, (0 if ob in visibility['shadows'] else 1)))
		ofile.write("\n}\n")

	if bus['preview'] and ob.name == 'texture':
		def getPreviewTexture(ob):
			if not len(ob.material_slots):
				return None
			if not ob.material_slots[0].material:
				return None
			ma = ob.material_slots[0].material
			if not len(ma.texture_slots):
				return None
			slot = ma.texture_slots[0]
			if not slot.texture:
				return None
			tex = slot.texture
			tex_name = clean_string("MAtextureMT00TE%s" % tex.name)
			if tex.vray.texture_coords == 'ORCO':
				tex_name += 'ORCOtexture'
			return tex_name

		tex_name = getPreviewTexture(ob)

		if tex_name:
			material = 'MATexPreview'
			ofile.write("\n// Texture preview material")
			ofile.write("\nBRDFLight BRDFTexPreview {")
			ofile.write("\n\tcolor=%s;" % tex_name)
			ofile.write("\n\tcolorMultiplier=3.0;")
			ofile.write("\n}\n")
			ofile.write("\nMtlSingleBRDF %s {" % material)
			ofile.write("\n\tbrdf=BRDFTexPreview;")
			ofile.write("\n}\n")

	ofile.write("\nNode %s {" % node_name)
	ofile.write("\n\tobjectID=%d;" % bus['node'].get('objectID', ob.pass_index))
	ofile.write("\n\tgeometry=%s;" % bus['node']['geometry'])
	ofile.write("\n\tmaterial=%s;" % material)
	if 'particle' in bus['node'] and 'visible' in bus['node']['particle']:
		ofile.write("\n\tvisible=%s;" % a(scene, bus['node']['particle']['visible']))
	ofile.write("\n\ttransform=%s;" % a(scene, transform(matrix)))
	if not bus['preview']:
		ofile.write("\n\tlights=List(%s);" % (','.join(lights)))
	ofile.write("\n}\n")


def write_object(bus):
	files= bus['files']
	ofile= bus['files']['nodes']
	scene= bus['scene']
	ob=    bus['node']['object']

	VRayScene=    scene.vray
	VRayExporter= VRayScene.exporter
	VRayObject=   ob.vray
	VRayData=     ob.data.vray

	bus['node']['name']=      get_name(ob, prefix='OB')
	bus['node']['geometry']=  get_name(ob.data if VRayExporter.use_instances else ob, prefix='ME')
	bus['node']['matrix']=    ob.matrix_world

	# Skip if object is just dupli-group holder
	if ob.dupli_type == 'GROUP':
		return

	# Write object materials
	write_materials(bus)

	# Write particle emitter if needed
	# Need to be after material export
	if len(ob.particle_systems):
		export= True
		for ps in ob.particle_systems:
			if not ps.settings.use_render_emitter:
				export= False
		if not export:
			return

	# Write override mesh
	if VRayData.override:
		if VRayData.override_type == 'VRAYPROXY':
			PLUGINS['GEOMETRY']['GeomMeshFile'].write(bus)

		elif VRayData.override_type == 'VRAYPLANE':
			bus['node']['geometry'] = get_name(ob, prefix='VRayPlane')
			PLUGINS['GEOMETRY']['GeomPlane'].write(bus)

	# Displace or Subdivision
	if ob.vray.GeomStaticSmoothedMesh.use:
		PLUGINS['GEOMETRY']['GeomStaticSmoothedMesh'].write(bus)
	else:
		PLUGINS['GEOMETRY']['GeomDisplacedMesh'].write(bus)

	# Mesh-light
	if PLUGINS['GEOMETRY']['LightMesh'].write(bus):
		return

	if VRayExporter.experimental and VRayObject.GeomVRayPattern.use:
		PLUGINS['OBJECT']['GeomVRayPattern'].write(bus)

	if 'dupli' in bus['node'] and 'material' in bus['node']['dupli']:
		bus['node']['material'] = get_name(bus['node']['dupli']['material'], prefix='MA')
	else:
		complex_material= []
		complex_material.append(bus['node']['material'])
		for component in (VRayObject.MtlWrapper.use,
						  VRayObject.MtlOverride.use,
						  VRayObject.MtlRenderStats.use):
			if component:
				complex_material.append("OC%.2d_%s" % (len(complex_material), bus['node']['material']))
		complex_material.reverse()

		if VRayObject.MtlWrapper.use:
			base_material= complex_material.pop()
			ma_name= complex_material[-1]
			ofile.write("\nMtlWrapper %s {"%(ma_name))
			ofile.write("\n\tbase_material= %s;"%(base_material))
			for param in PLUGINS['MATERIAL']['MtlWrapper'].PARAMS:
				ofile.write("\n\t%s= %s;"%(param, a(scene,getattr(VRayObject.MtlWrapper,param))))
			ofile.write("\n}\n")

			bus['node']['material']= ma_name

		if VRayObject.MtlOverride.use:
			base_mtl= complex_material.pop()
			ma_name= complex_material[-1]
			ofile.write("\nMtlOverride %s {"%(ma_name))
			ofile.write("\n\tbase_mtl= %s;"%(base_mtl))

			for param in ('gi_mtl','reflect_mtl','refract_mtl','shadow_mtl'):
				override_material= getattr(VRayObject.MtlOverride, param)
				if override_material:
					if override_material in bpy.data.materials:
						ofile.write("\n\t%s= %s;"%(param, get_name(bpy.data.materials[override_material],"Material")))

			environment_override= VRayObject.MtlOverride.environment_override
			if environment_override:
				if environment_override in bpy.data.materials:
					ofile.write("\n\tenvironment_override= %s;" % get_name(bpy.data.textures[environment_override],"Texture"))

			ofile.write("\n\tenvironment_priority= %i;"%(VRayObject.MtlOverride.environment_priority))
			ofile.write("\n}\n")

			bus['node']['material']= ma_name

		if VRayObject.MtlRenderStats.use:
			base_mtl= complex_material.pop()
			ma_name= complex_material[-1]
			ofile.write("\nMtlRenderStats %s {"%(ma_name))
			ofile.write("\n\tbase_mtl= %s;"%(base_mtl))
			for param in PLUGINS['MATERIAL']['MtlRenderStats'].PARAMS:
				ofile.write("\n\t%s= %s;"%(param, a(scene,getattr(VRayObject.MtlRenderStats,param))))
			ofile.write("\n}\n")

			bus['node']['material']= ma_name

	write_node(bus)


def _write_object_particles(bus):
	scene= bus['scene']
	ob=    bus['node']['object']

	emitter_node= bus['node']['name']

	VRayScene= scene.vray
	VRayExporter= VRayScene.exporter

	if len(ob.particle_systems):
		for ps in ob.particle_systems:
			# if ps.settings.type == 'HAIR':
			# 	if ps.settings.render_type not in {'OBJECT', 'GROUP', 'PATH'}:
			# 		continue
			# else:
			# 	if ps.settings.render_type not in {'OBJECT', 'GROUP'}:
			# 		continue

			ps_material = "MANOMATERIALISSET"
			ps_material_idx = ps.settings.material
			if len(ob.material_slots) >= ps_material_idx:
				ps_material = get_name(ob.material_slots[ps_material_idx - 1].material, prefix='MA')

			if ps.settings.type == 'HAIR' and ps.settings.render_type == 'PATH':
				if VRayExporter.use_hair:
					hair_geom_name = clean_string("HAIR%s%s" % (ps.name, ps.settings.name))
					hair_node_name = "Node"+hair_geom_name

					if not 'export_meshes' in dir(bpy.ops.vray) or bus['preview']:
						write_GeomMayaHair(bus, ps, hair_geom_name)

					bus['node']['hair']     = True
					bus['node']['name']     = hair_node_name
					bus['node']['geometry'] = hair_geom_name
					bus['node']['material'] = ps_material

					write_node(bus)

					bus['node']['hair'] = False


def _write_object_dupli(bus):
	scene = bus['scene']
	ob    = bus['node']['object']

	VRayScene = scene.vray
	VRayExporter = VRayScene.exporter

	dupli_from_particles = False
	if len(ob.particle_systems):
		for ps in ob.particle_systems:
			if ps.settings.render_type in {'OBJECT', 'GROUP'}:
				dupli_from_particles = True

	nEmitterMaterials = len(ob.material_slots)

	# This will fix "RuntimeError: Error: Object does not have duplis"
	# when particle system is disabled for render
	#
	try:
		if (ob.dupli_type in ('VERTS','FACES','GROUP')) or dupli_from_particles:
			ob.dupli_list_create(bus['scene'])

			for dup_id,dup_ob in enumerate(ob.dupli_list):
				parent_dupli= ""

				bus['node']['object']= dup_ob.object
				bus['node']['base']=   ob

				# Currently processed dupli name
				dup_node_name= clean_string("OB%sDO%sID%i" % (ob.name,
															  dup_ob.object.name,
															  dup_id))
				dup_node_matrix= dup_ob.matrix

				# For case when dupli is inside other dupli
				if 'dupli' in bus['node'] and 'name' in bus['node']['dupli']:
					# Store parent dupli name
					parent_dupli=   bus['node']['dupli']['name']
					dup_node_name+= parent_dupli

				bus['node']['dupli']=  {}
				bus['node']['dupli']['name']=   dup_node_name
				bus['node']['dupli']['matrix']= dup_node_matrix

				if dupli_from_particles:
					if VRayExporter.random_material:
						random.seed(dup_id)
						bus['node']['dupli']['material'] = ob.material_slots[random.randint(0,nEmitterMaterials-1)].material

				_write_object(bus)

				bus['node']['object']= ob
				bus['node']['base']=   ob
				bus['node']['dupli']=  {}
				bus['node']['dupli']['name']=   parent_dupli

			ob.dupli_list_clear()
	except:
		pass


def writeSceneInclude(bus):
	sceneFile = bus['files']['scene']

	ob = bus['node']['object']

	VRayObject = ob.vray

	if VRayObject.overrideWithScene:
		if VRayObject.sceneFilepath == "" and VRayObject.sceneDirpath == "":
			return

		sceneFile.write("\nSceneInclude %s {" % get_name(ob, prefix='SI'))

		vrsceneFilelist = []

		if VRayObject.sceneFilepath:
			vrsceneFilelist.append(bpy.path.abspath(VRayObject.sceneFilepath))

		if VRayObject.sceneDirpath:
			vrsceneDirpath = bpy.path.abspath(VRayObject.sceneDirpath)

			for dirname, dirnames, filenames in os.walk(vrsceneDirpath):
				for filename in filenames:
					if not filename.endswith(".vrscene"):
						continue
					vrsceneFilelist.append(os.path.join(dirname, filename))
		
		sceneFile.write("\n\tfilepath=\"%s\";" % (";").join(vrsceneFilelist))
		sceneFile.write("\n\tprefix=\"%s\";" % get_name(ob, prefix='SI'))

		sceneFile.write("\n\ttransform=%s;" % transform(ob.matrix_world))
		sceneFile.write("\n\tuse_transform=%s;" % p(VRayObject.sceneUseTransform))
		
		sceneFile.write("\n\treplace=%s;" % p(VRayObject.sceneReplace))
		
		sceneFile.write("\n\tadd_nodes=%s;" % p(VRayObject.sceneAddNodes))
		sceneFile.write("\n\tadd_materials=%s;" % p(VRayObject.sceneAddMaterials))
		sceneFile.write("\n\tadd_lights=%s;" % p(VRayObject.sceneAddLights))
		sceneFile.write("\n\tadd_cameras=%s;" % p(VRayObject.sceneAddCameras))
		sceneFile.write("\n\tadd_environment=%s;" % p(VRayObject.sceneAddEnvironment))
		sceneFile.write("\n}\n")


def _write_object(bus):
	ob = bus['node']['object']
#	VRayScene = bus['scene'].vray
#	Includer = VRayScene.Includer

	if ob.type in {'CAMERA','ARMATURE','LATTICE','SPEAKER'}:
		return

	# Export LAMP
	if ob.type == 'LAMP':
#		if Includer.lights:
		write_lamp(bus)
#		else:
#			return

	elif ob.type == 'EMPTY':
		writeSceneInclude(bus)
		_write_object_dupli(bus)

	else:
		write_object(bus)
		_write_object_particles(bus)

		# Parent dupli_list_create() call create all duplicates
		# even for sub duplis, so no need to process dupli again
		if 'dupli' in bus['node'] and 'matrix' not in bus['node']['dupli']:
			_write_object_dupli(bus)


def write_scene(bus):
	scene= bus['scene']

	VRayScene=       scene.vray

	VRayExporter=    VRayScene.exporter
	SettingsOptions= VRayScene.SettingsOptions
#	Includer = VRayScene.Includer

	# Some failsafe defaults
	bus['defaults']= {}
	bus['defaults']['brdf']=     "BRDFNOBRDFISSET"
	bus['defaults']['material']= "MANOMATERIALISSET"
	bus['defaults']['texture']=  "TENOTEXTUREIESSET"
	bus['defaults']['uvwgen']=   "DEFAULTUVWC"
	bus['defaults']['blend']=    "TEDefaultBlend"

	for key in bus['files']:
		bus['files'][key].write("// V-Ray/Blender")

	bus['files']['scene'].write("\n// Settings\n")
	bus['files']['nodes'].write("\n// Nodes\n")
#	if Includer.lights:
	bus['files']['lights'].write("\n// Lights\n")
	bus['files']['camera'].write("\n// Camera\n")
	bus['files']['environment'].write("\n// Environment\n")
	bus['files']['textures'].write("\n// Textures\n")
	bus['files']['materials'].write("\n// Materials\n")

	bus['files']['textures'].write("\n// Useful defaults")
	bus['files']['textures'].write("\nUVWGenChannel %s {" % bus['defaults']['uvwgen'])
	bus['files']['textures'].write("\n\tuvw_channel= 1;")
	bus['files']['textures'].write("\n\tuvw_transform= Transform(Matrix(Vector(1.0,0.0,0.0),Vector(0.0,1.0,0.0),Vector(0.0,0.0,1.0)),Vector(0.0,0.0,0.0));")
	bus['files']['textures'].write("\n}\n")
	bus['files']['textures'].write("\nTexChecker %s {" % bus['defaults']['texture'])
	bus['files']['textures'].write("\n\tuvwgen= %s;" % bus['defaults']['uvwgen'])
	bus['files']['textures'].write("\n}\n")
	bus['files']['textures'].write("\nTexAColor %s {" % bus['defaults']['blend'])
	bus['files']['textures'].write("\n\tuvwgen= %s;" % bus['defaults']['uvwgen'])
	bus['files']['textures'].write("\n\ttexture= AColor(1.0,1.0,1.0,1.0);")
	bus['files']['textures'].write("\n}\n")

	bus['files']['materials'].write("\n// Fail-safe material")
	bus['files']['materials'].write("\nBRDFDiffuse %s {" % bus['defaults']['brdf'])
	bus['files']['materials'].write("\n\tcolor=Color(0.5,0.5,0.5);")
	bus['files']['materials'].write("\n}\n")
	bus['files']['materials'].write("\nMtlSingleBRDF %s {" % bus['defaults']['material'])
	bus['files']['materials'].write("\n\tbrdf= %s;" % bus['defaults']['brdf'])
	bus['files']['materials'].write("\n}\n")

	if bus['preview']:
		bus['files']['lights'].write("\nLightDirectMax LALamp_008 { // PREVIEW")
		bus['files']['lights'].write("\n\tintensity= 1.000000;")
		bus['files']['lights'].write("\n\tcolor= Color(1.000000, 1.000000, 1.000000);")
		bus['files']['lights'].write("\n\tshadows= 0;")
		bus['files']['lights'].write("\n\tcutoffThreshold= 0.01;")
		bus['files']['lights'].write("\n\taffectSpecular= 0;")
		bus['files']['lights'].write("\n\tareaSpeculars= 0;")
		bus['files']['lights'].write("\n\tfallsize= 100.0;")
		bus['files']['lights'].write("\n\ttransform= Transform(")
		bus['files']['lights'].write("\n\t\tMatrix(")
		bus['files']['lights'].write("\n\t\t\tVector(1.000000, 0.000000, -0.000000),")
		bus['files']['lights'].write("\n\t\t\tVector(0.000000, 0.000000, 1.000000),")
		bus['files']['lights'].write("\n\t\t\tVector(0.000000, -1.000000, 0.000000)")
		bus['files']['lights'].write("\n\t\t),")
		bus['files']['lights'].write("\n\t\tVector(1.471056, -14.735638, 3.274598));")
		bus['files']['lights'].write("\n}\n")

		bus['files']['lights'].write("\nLightSpot LALamp_002 { // PREVIEW")
		bus['files']['lights'].write("\n\tintensity= 5.000000;")
		bus['files']['lights'].write("\n\tcolor= Color(1.000000, 1.000000, 1.000000);")
		bus['files']['lights'].write("\n\tconeAngle= 1.3;")
		bus['files']['lights'].write("\n\tpenumbraAngle= -0.4;")
		bus['files']['lights'].write("\n\tshadows= 1;")
		bus['files']['lights'].write("\n\tcutoffThreshold= 0.01;")
		bus['files']['lights'].write("\n\taffectDiffuse= 1;")
		bus['files']['lights'].write("\n\taffectSpecular= 0;")
		bus['files']['lights'].write("\n\tareaSpeculars= 0;")
		bus['files']['lights'].write("\n\tshadowRadius= 0.000000;")
		bus['files']['lights'].write("\n\tshadowSubdivs= 4;")
		bus['files']['lights'].write("\n\tdecay= 1.0;")
		bus['files']['lights'].write("\n\ttransform= Transform(")
		bus['files']['lights'].write("\n\t\tMatrix(")
		bus['files']['lights'].write("\n\t\t\tVector(-0.549843, 0.655945, 0.517116),")
		bus['files']['lights'].write("\n\t\t\tVector(-0.733248, -0.082559, -0.674931),")
		bus['files']['lights'].write("\n\t\t\tVector(-0.400025, -0.750280, 0.526365)")
		bus['files']['lights'].write("\n\t\t),")
		bus['files']['lights'].write("\n\t\tVector(-5.725639, -13.646054, 8.5));")
		bus['files']['lights'].write("\n}\n")

		bus['files']['lights'].write("\nLightOmni LALamp { // PREVIEW")
		bus['files']['lights'].write("\n\tintensity= 50.000000;")
		bus['files']['lights'].write("\n\tcolor= Color(1.000000, 1.000000, 1.000000);")
		bus['files']['lights'].write("\n\tshadows= 0;")
		bus['files']['lights'].write("\n\tcutoffThreshold= 0.01;")
		bus['files']['lights'].write("\n\taffectDiffuse= 1;")
		bus['files']['lights'].write("\n\taffectSpecular= 0;")
		bus['files']['lights'].write("\n\tspecular_contribution= 0.000000;")
		bus['files']['lights'].write("\n\tareaSpeculars= 0;")
		bus['files']['lights'].write("\n\tshadowSubdivs= 4;")
		bus['files']['lights'].write("\n\tdecay= 2.0;")
		bus['files']['lights'].write("\n\ttransform= Transform(")
		bus['files']['lights'].write("\n\t\tMatrix(")
		bus['files']['lights'].write("\n\t\t\tVector(0.499935, 0.789660, 0.355671),")
		bus['files']['lights'].write("\n\t\t\tVector(-0.672205, 0.094855, 0.734263),")
		bus['files']['lights'].write("\n\t\t\tVector(0.546081, -0.606168, 0.578235)")
		bus['files']['lights'].write("\n\t\t),")
		bus['files']['lights'].write("\n\t\tVector(15.685226, -7.460007, 3.0));")
		bus['files']['lights'].write("\n}\n")

		bus['files']['lights'].write("\nLightOmni LALamp_001 { // PREVIEW")
		bus['files']['lights'].write("\n\tintensity= 20.000000;")
		bus['files']['lights'].write("\n\tcolor= Color(1.000000, 1.000000, 1.000000);")
		bus['files']['lights'].write("\n\tshadows= 0;")
		bus['files']['lights'].write("\n\tcutoffThreshold= 0.01;")
		bus['files']['lights'].write("\n\taffectDiffuse= 1;")
		bus['files']['lights'].write("\n\taffectSpecular= 0;")
		bus['files']['lights'].write("\n\tareaSpeculars= 0;")
		bus['files']['lights'].write("\n\tshadowSubdivs= 4;")
		bus['files']['lights'].write("\n\tdecay= 2.0;")
		bus['files']['lights'].write("\n\ttransform= Transform(")
		bus['files']['lights'].write("\n\t\tMatrix(")
		bus['files']['lights'].write("\n\t\t\tVector(0.499935, 0.789660, 0.355671),")
		bus['files']['lights'].write("\n\t\t\tVector(-0.672205, 0.094855, 0.734263),")
		bus['files']['lights'].write("\n\t\t\tVector(0.546081, -0.606168, 0.578235)")
		bus['files']['lights'].write("\n\t\t),")
		bus['files']['lights'].write("\n\t\tVector(-10.500286, -12.464991, 4.0));")
		bus['files']['lights'].write("\n}\n")

	# Processed objects
	bus['objects']= []

	# Effects from material / object settings
	bus['effects']= {}
	bus['effects']['fog']= {}

	bus['effects']['toon']= {}
	bus['effects']['toon']['effects']= []
	bus['effects']['toon']['objects']= []

	# Prepare exclude for effects
	exclude_list= []
	VRayEffects=  VRayScene.VRayEffects
	if VRayEffects.use:
		for effect in VRayEffects.effects:
			if effect.use:
				if effect.type == 'FOG':
					EnvironmentFog= effect.EnvironmentFog
					fog_objects= generate_object_list(EnvironmentFog.objects, EnvironmentFog.groups)
					for ob in fog_objects:
						if not object_visible(bus, ob):
							continue
						if ob not in exclude_list:
							exclude_list.append(ob)

	for ob in scene.objects:
		if ob.type in ('CAMERA','ARMATURE','LATTICE'):
			continue

		if ob not in exclude_list:
			bus['objects'].append(ob)

	del exclude_list

	def write_frame(bus, checkAnimated=False):
		timer= time.clock()
		scene= bus['scene']

		debug(scene, "Writing frame %i..." % scene.frame_current)

		VRayScene=       scene.vray

		VRayExporter=    VRayScene.exporter
		SettingsOptions= VRayScene.SettingsOptions

		# Cache stores already exported data
		bus['cache']= {}
		bus['cache']['textures']=  []
		bus['cache']['materials']= []
		bus['cache']['displace']=  []
		bus['cache']['proxy']=     []
		bus['cache']['bitmap']=    []
		bus['cache']['uvwgen']=    {}

		# Fake frame for "Camera loop"
		if VRayExporter.camera_loop:
			for key in bus['files']:
				if key in ('nodes','camera'):
					# bus['files'][key].write("\n#time %.1f // %s\n" % (bus['camera_index'] + 1, bus['camera'].name))
					pass
		else:
			# Camera
			bus['camera']= scene.camera

		# Visibility list for "Hide from view" and "Camera loop" features
		bus['visibility']= get_visibility_lists(bus['camera'])

		# "Hide from view" debug data
		if VRayExporter.debug:
			print_dict(scene, "Hide from view", bus['visibility'])

		if not checkAnimated:
			write_settings(bus)

		for ob in bus['objects']:
			if not object_visible(bus, ob):
				continue

			# Check if smth on object is animated
			if checkAnimated:
				if not is_animated(ob):
					continue

			debug(scene, "{0}: {1:<32}".format(ob.type, color(ob.name, 'green')), VRayExporter.debug)

			# Node struct
			bus['node']= {}

			# Currently processes object
			bus['node']['object']= ob

			# Object visibility
			bus['node']['visible']= ob

			# We will know if object has displace
			# only after material export
			bus['node']['displace']= {}

			# We will know if object is mesh light
			# only after material export
			bus['node']['meshlight']= {}

			# If object has particles or dupli
			bus['node']['base']= ob
			bus['node']['dupli']= {}
			bus['node']['particle']= {}

			_write_object(bus)

		# TODO: Add camera animation detection
		#
		PLUGINS['CAMERA']['CameraPhysical'].write(bus)
		PLUGINS['SETTINGS']['BakeView'].write(bus)
		PLUGINS['SETTINGS']['RenderView'].write(bus)
		PLUGINS['CAMERA']['CameraStereoscopic'].write(bus)
		if not checkAnimated:
			PLUGINS['SETTINGS']['VRayStereoscopicSettings'].write(bus)

		# SphereFade could be animated
		# We already export SphereFade data in settings export,
		# so skip first frame
		if checkAnimated:
			PLUGINS['SETTINGS']['SettingsEnvironment'].WriteSphereFade(bus)

		if not checkAnimated:
			for key in bus['files']:
				bus['files'][key].write("\n// End of static data\n")

		debug(scene, "Writing frame {0}... done {1:<64}".format(scene.frame_current, "[%.2f]"%(time.clock() - timer)))

	timer= time.clock()

	debug(scene, "Writing scene...")

	if bus['preview']:
		write_frame(bus)
		return False

	if VRayExporter.auto_meshes:
		write_geometry(bus)

	if VRayExporter.animation and VRayExporter.animation_type in {'FULL', 'NOTMESHES'}:
		# Store current frame
		selected_frame = scene.frame_current

		# Export full first frame
		f = scene.frame_start
		scene.frame_set(f)
		write_frame(bus)
		f += scene.frame_step

		# Export the rest of frames checking
		# if stuff is animated
		#
		while(f <= scene.frame_end):
			if bus['engine'] and bus['engine'].test_break():
				return
			scene.frame_set(f)
			write_frame(bus, checkAnimated=VRayExporter.check_animated)
			f += scene.frame_step

		# Restore selected frame
		scene.frame_set(selected_frame)
	else:
		if VRayExporter.camera_loop:
			if bus['cameras']:
				for i,camera in enumerate(bus['cameras']):
					bus['camera'] = camera
					bus['camera_index'] = i
					VRayExporter.customFrame = i+1
					write_frame(bus)
			else:
				debug(scene, "No cameras selected for \"Camera loop\"!", error= True)
				return True # Error

		else:
			write_frame(bus)

	debug(scene, "Writing scene... done {0:<64}".format("[%.2f]"%(time.clock() - timer)))

	return False # No errors


def run(bus):
	scene = bus['scene']

	VRayScene = scene.vray

	VRayExporter    = VRayScene.exporter
	VRayDR          = VRayScene.VRayDR
	RTEngine        = VRayScene.RTEngine
	SettingsOptions = VRayScene.SettingsOptions

	vray_exporter=   get_vray_exporter_path()
	vray_standalone= get_vray_standalone_path(scene)

	resolution_x= int(scene.render.resolution_x * scene.render.resolution_percentage / 100)
	resolution_y= int(scene.render.resolution_y * scene.render.resolution_percentage / 100)

	if vray_standalone is None:
		if bus['engine']:
			bus['engine'].report({'ERROR'}, "V-Ray Standalone not found!")
		return

	params = []
	params.append(vray_standalone)
	params.append('-sceneFile=%s' % Quotes(bus['filenames']['scene']))

	preview_file     = os.path.join(tempfile.gettempdir(), "preview.jpg")
	preview_loadfile = os.path.join(tempfile.gettempdir(), "preview.0000.jpg")
	image_file = os.path.join(bus['filenames']['output'], bus['filenames']['output_filename'])
	load_file  = preview_loadfile if bus['preview'] else os.path.join(bus['filenames']['output'], bus['filenames']['output_loadfile'])

	if not scene.render.threads_mode == 'AUTO':
		params.append('-numThreads=%i' % (scene.render.threads))

	image_to_blender = VRayExporter.auto_save_render and VRayExporter.image_to_blender
	if bus['preview']:
		image_to_blender = False

	if bus['preview']:
		params.append('-imgFile=%s' % Quotes(preview_file))
		params.append('-showProgress=0')
		params.append('-display=0')
		params.append('-autoclose=1')
		params.append('-verboseLevel=0')

	else:
		if RTEngine.enabled:
			DEVICE = {
				'CPU'           : 1,
				'OPENCL_SINGLE' : 3,
				'OPENCL_MULTI'  : 4,
				'CUDA_SINGLE'   : 5,
			}
			params.append('-rtEngine=%i' % DEVICE[RTEngine.use_opencl])
			params.append('-rtTimeOut=%.3f'   % RTEngine.rtTimeOut)
			params.append('-rtNoise=%.3f'     % RTEngine.rtNoise)
			params.append('-rtSampleLevel=%i' % RTEngine.rtSampleLevel)

		params.append('-display=%i' % (VRayExporter.display))
		params.append('-verboseLevel=%s' % (VRayExporter.verboseLevel))

		if scene.render.use_border:
			x0= resolution_x * scene.render.border_min_x
			y0= resolution_y * (1.0 - scene.render.border_max_y)
			x1= resolution_x * scene.render.border_max_x
			y1= resolution_y * (1.0 - scene.render.border_min_y)

			region = 'crop' if scene.render.use_crop_to_border else 'region'
			params.append("-%s=%i;%i;%i;%i" % (region, x0, y0, x1, y1))

		if VRayExporter.use_still_motion_blur:
			params.append("-frames=%d" % scene.frame_end)
		else:
			if VRayExporter.animation:
				params.append("-frames=")
				if VRayExporter.animation_type == 'FRAMEBYFRAME':
					params.append("%d"%(scene.frame_current))
				else:
					params.append("%d-%d,%d"%(scene.frame_start, scene.frame_end, int(scene.frame_step)))
			elif VRayExporter.camera_loop:
				if bus['cameras']:
					params.append("-frames=1-%d,1" % len(bus['cameras']))
			else:
				params.append("-frames=%d" % scene.frame_current)

		if VRayDR.on:
			if len(VRayDR.nodes):
				params.append('-distributed=%s' % ('2' if VRayDR.renderOnlyOnNodes else '1'))
				params.append('-portNumber=%i' % (VRayDR.port))
				params.append('-renderhost=%s' % Quotes(';'.join([n.address for n in VRayDR.nodes if n.use])))
				if VRayDR.transferAssets == '0':
					params.append('-include=%s' % Quotes(bus['filenames']['DR']['shared_dir'] + os.sep))
				else:
					params.append('-transferAssets=%s' % VRayDR.transferAssets)

		if image_to_blender:
			params.append('-imgFile=%s' % Quotes(image_file))
			params.append('-autoclose=1')

	if PLATFORM == "linux":
		if VRayExporter.log_window:
			LOG_TERMINAL = {
				'DEFAULT' : 'xterm',
				'XTERM'   : 'xterm',
				'GNOME'   : 'gnome-terminal',
				'KDE'     : 'konsole',
				'CUSTOM'  : VRayExporter.log_window_term,
			}

			log_window = []
			if VRayExporter.log_window_type in ['DEFAULT', 'XTERM']:
				log_window.append("xterm")
				log_window.append("-T")
				log_window.append("VRAYSTANDALONE")
				log_window.append("-geometry")
				log_window.append("90x10")
				log_window.append("-e")
				log_window.extend(params)
			else:
				log_window.extend(LOG_TERMINAL[VRayExporter.log_window_type].split(" "))
				if VRayExporter.log_window_type == "GNOME":
					log_window.append("-x")
					log_window.append("sh")
					log_window.append("-c")
					log_window.append(" ".join(params))
				else:
					log_window.append("-e")
					log_window.extend(params)
			params = log_window

	if (VRayExporter.autoclose
		or (VRayExporter.animation and VRayExporter.animation_type == 'FRAMEBYFRAME')
		or (VRayExporter.animation and VRayExporter.animation_type == 'FULL' and VRayExporter.use_still_motion_blur)):
		params.append('-autoclose=1')

	engine = bus['engine']

	params.append('-displaySRGB=%i' % (1 if VRayExporter.display_srgb else 2))

	# If this is a background task, wait until render end
	# and no VFB is required
	if bpy.app.background or VRayExporter.wait:
		if bpy.app.background:
			params.append('-display=0')   # Disable VFB
			params.append('-autoclose=1') # Exit on render end
		subprocess.call(params)
		return

	if VRayExporter.use_feedback:
		if scene.render.use_border:
			return

		proc = VRayProcess()
		proc.sceneFile = bus['filenames']['scene']
		proc.imgFile   = image_file
		proc.scene     = scene

		proc.set_params(bus=bus)
		proc.run()

		feedback_image = os.path.join(get_ram_basedir(), "vrayblender_%s_stream.jpg"%(get_username()))

		proc_interrupted = False

		render_result_image = None

		if engine is None:
			return

			# TODO: try finish this
			if RTEngine.enabled:
				render_result_name = "VRay Render"

				if render_result_name not in bpy.data.images:
					bpy.ops.image.new(name=render_result_name, width=resolution_x, height=resolution_y, color=(0.0, 0.0, 0.0, 1.0), alpha=True, generated_type='BLANK', float=False)
					render_result_image.source   = 'FILE'
					render_result_image.filepath = feedback_image

				render_result_image = bpy.data.images[render_result_name]

				def task():
					global proc

					if not proc.is_running():
						return

					err = proc.recieve_image(feedback_image)

					if err is None:
						try:
							render_result_image.reload()

							for window in bpy.context.window_manager.windows:
								for area in window.screen.areas:
									if area.type == 'IMAGE_EDITOR':
										for space in area.spaces:
											if space.type == 'IMAGE_EDITOR':
												if space.image.name == render_result_name:
													area.tag_redraw()
													return
						except:
							return

				def my_timer():
					t = Timer(0.25, my_timer)
					t.start()
					task()

				my_timer()

		else:
			while True:
				time.sleep(0.25)

				if engine.test_break():
					proc_interrupted = True
					debug(None, "Process is interrupted by the user")
					break

				err = proc.recieve_image(feedback_image)
				if VRayExporter.debug:
					debug(None, "Recieve image error: %s"%(err))
				if err is None:
					load_result(engine, resolution_x, resolution_y, feedback_image)

				if proc.exit_ready:
					break

				if VRayExporter.use_progress:
					msg, prog = proc.get_progress()
					if prog is not None and msg is not None:
						engine.update_stats("", "V-Ray: %s %.0f%%"%(msg, prog*100.0))
						engine.update_progress(prog)

				if proc.exit_ready:
					break

			proc.kill()

			# Load final result image to Blender
			if image_to_blender and not proc_interrupted:
				if load_file.endswith('vrimg'):
					# VRayImage (.vrimg) loaing is not supported
					debug(None, "VRayImage loading is not supported. Final image will not be loaded.")
				else:
					debug(None, "Loading final image: %s"%(load_file))
					load_result(engine, resolution_x, resolution_y, load_file)

	else:
		if not VRayExporter.autorun:
			debug(scene, "Command: %s" % ' '.join(params))
			return

		process = subprocess.Popen(params)

		if VRayExporter.animation and (VRayExporter.animation_type == 'FRAMEBYFRAME' or (VRayExporter.animation_type == 'FULL' and VRayExporter.use_still_motion_blur)):
			process.wait()
			return

		if not isinstance(engine, bpy.types.RenderEngine):
			return

		if engine is not None and (bus['preview'] or image_to_blender) and not scene.render.use_border:
			while True:
				if engine.test_break():
					try:
						process.kill()
					except:
						pass
					break

				if process.poll() is not None:
					if not VRayExporter.animation:
						result= engine.begin_result(0, 0, resolution_x, resolution_y)
						layer= result.layers[0]
						layer.load_from_file(load_file)
						engine.end_result(result)
					break

				time.sleep(0.1)


def close_files(bus):
	for key in bus['files']:
		bus['files'][key].write("\n")
		bus['files'][key].flush()
		bus['files'][key].close()


def export_and_run(bus):
	err = write_scene(bus)

	close_files(bus)

	if not err:
		run(bus)


def init_bus(engine, scene, preview = False):
	VRayScene=    scene.vray
	VRayExporter= VRayScene.exporter

	# Settings bus
	bus= {}

	# Plugins
	bus['plugins']= PLUGINS

	# Scene
	bus['scene']=   scene

	# Preview
	bus['preview']= preview

	# V-Ray uses UV indexes, Blender uses UV names
	# Here we store UV name->index map
	bus['uvs']= get_uv_layers_map(scene)

	# Output files
	bus['files']=     {}
	bus['filenames']= {}

	init_files(bus)

	# Camera loop
	bus['cameras'] = []
	if VRayExporter.camera_loop:
		bus['cameras'] = [ob for ob in scene.objects if ob.type == 'CAMERA' and ob.data.vray.use_camera_loop]

	# Render engine
	bus['engine']= engine

	return bus


def render(engine, scene, preview= None):
	VRayScene    = scene.vray
	VRayExporter = VRayScene.exporter

	if preview:
		export_and_run(init_bus(engine, scene, True))
		return None

	if VRayExporter.use_still_motion_blur:
		# Store current settings
		e_anim_state = VRayExporter.animation
		e_anim_type  = VRayExporter.animation_type
		frame_start = scene.frame_start
		frame_end   = scene.frame_end

		# Run export
		if e_anim_state:
			if e_anim_type not in ['FRAMEBYFRAME']:
				return "\"Still Motion Blur\" feature works only in \"Frame-By-Frame\" animation mode!"

			VRayExporter.animation_type = 'FULL'

			f = frame_start
			while(f <= frame_end):
				scene.frame_start = f - 1
				scene.frame_end   = f

				export_and_run(init_bus(engine, scene))

				f += scene.frame_step

		else:
			VRayExporter.animation = True
			VRayExporter.animation_type = 'FULL'

			scene.frame_start = scene.frame_current - 1
			scene.frame_end   = scene.frame_current

			export_and_run(init_bus(engine, scene))

		# Restore settings
		VRayExporter.animation = e_anim_state
		VRayExporter.animation_type = e_anim_type
		scene.frame_start = frame_start
		scene.frame_end   = frame_end

	else:
		if VRayExporter.animation:
			if VRayExporter.animation_type == 'FRAMEBYFRAME':
				selected_frame = scene.frame_current

				f = scene.frame_start
				while(f <= scene.frame_end):
					if engine and engine.test_break():
						return
					scene.frame_set(f)
					export_and_run(init_bus(engine, scene))
					f += scene.frame_step

				scene.frame_set(selected_frame)
			else:
				export_and_run(init_bus(engine, scene))
		else:
			export_and_run(init_bus(engine, scene))

	return None

########NEW FILE########
__FILENAME__ = render_ops
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Python modules  '''
import os
import subprocess
import tempfile
import time
import zipfile
import urllib.request
import sys

''' Blender modules '''
import bpy
import bgl
import bmesh
from bpy.props import *

''' vb modules '''
import vb25.render
import vb25.proxy

from vb25.lib     import VRaySocket
from vb25.utils   import *
from vb25.plugins import *

from vb25.lib                 import VRayProxy
from vb25.lib.VRaySceneParser import GetMaterialsNames
from vb25.lib.VrmatParser     import GetXMLMaterialsNames


VRAYBLENDER_MENU_ITEM= "V-Ray"


'''
  SCRIPT AUTOUPDATE
'''
class VRAY_OT_update(bpy.types.Operator):
	bl_idname      = "vray.update"
	bl_label       = "Update Exporter"
	bl_description = "Update exporter from github"

	def execute(self, context):
		# Check if target dir is writable
		cur_vb25_dirpath = get_vray_exporter_path()

		if not os.access(cur_vb25_dirpath, os.W_OK):
			self.report({'ERROR'}, "Exporter directory is not writable!")
			return {'CANCELLED'}

		# Downloading file
		self.report({'INFO'}, "Downloading 'master' branch archive...")

		GIT_MASTER_URL = "https://github.com/bdancer/vb25/zipball/master"

		# devnote: urllib2 not available, urllib's fancyurlopener returns errors anyways (when connection is not available)
		# so this is a working 'ugly fix' that at leasts works. Sorry the ghetto fix.
		try:
			(filename, headers) = urllib.request.urlretrieve(GIT_MASTER_URL)
		except urllib.error.URLError:
			self.report({'ERROR'}, "Error retrieving the files! Check your connection!")
			return {'CANCELLED'}

		# Extracting archive
		update_dir = create_dir(os.path.join(tempfile.gettempdir(), "vb25_update"))
		try:
			ziparchive = zipfile.ZipFile(filename)
			ziparchive.extractall(update_dir)
			ziparchive.close()
		except:
			self.report({'ERROR'}, "Error unpacking the archive!")
			return {'CANCELLED'}

		new_vb25_dirpath = ""
		dirnames = os.listdir(update_dir)
		for dirname in dirnames:
			if dirname.startswith("bdancer-vb25-"):
				new_vb25_dirpath = os.path.join(update_dir, dirname)
				break
		if not new_vb25_dirpath:
			self.report({'ERROR'}, "Update files not found!")
			return {'CANCELLED'}

		# Copying new files
		debug(context.scene, "Copying new files...")
		if os.path.exists(cur_vb25_dirpath):
			if sys.platform == 'win32':
				for item in os.listdir(cur_vb25_dirpath):
					s = os.path.join(cur_vb25_dirpath, item)
					if os.path.isdir(s):
						os.system("rmdir /Q /S %s" % s)
					else:
						os.system("del /Q /F %s" % s)
			else:
				shutil.rmtree(cur_vb25_dirpath)

		copytree(new_vb25_dirpath, cur_vb25_dirpath)

		if os.path.exists(filename):
			self.report({'INFO'}, "Removing update archive: %s"%(filename))
			os.remove(filename)

		if os.path.exists(update_dir):
			self.report({'INFO'}, "Removing update unpack directory: %s"%(update_dir))
			shutil.rmtree(update_dir)

		self.report({'INFO'}, "V-Ray/Blender updated! Please, restart Blender!")

		return {'FINISHED'}




'''
  Camera operators
'''
class VRAY_OT_lens_shift(bpy.types.Operator):
	bl_idname=      'vray.lens_shift'
	bl_label=       "Get lens shift"
	bl_description= "Calculate lens shift"

	@classmethod
	def poll(cls, context):
		return (context.camera)

	def execute(self, context):
		VRayCamera=     context.camera.vray
		CameraPhysical= VRayCamera.CameraPhysical

		CameraPhysical.lens_shift= PLUGINS['CAMERA']['CameraPhysical'].get_lens_shift(context.object)

		return {'FINISHED'}



'''
  Effects operators
'''
class VRAY_OT_effect_add(bpy.types.Operator):
	bl_idname=      'vray.effect_add'
	bl_label=       "Add Effect"

	bl_description= "Add effect"

	def execute(self, context):
		VRayScene= context.scene.vray

		VRayEffects= VRayScene.VRayEffects
		VRayEffects.effects.add()
		VRayEffects.effects[-1].name= "Effect"

		return {'FINISHED'}



class VRAY_OT_effect_remove(bpy.types.Operator):
	bl_idname=      'vray.effect_remove'
	bl_label=       "Remove Effect"
	bl_description= "Remove effect"

	def execute(self, context):
		VRayScene= context.scene.vray

		VRayEffects= VRayScene.VRayEffects

		if VRayEffects.effects_selected >= 0:
			VRayEffects.effects.remove(VRayEffects.effects_selected)
			VRayEffects.effects_selected-= 1

		return {'FINISHED'}



class VRAY_OT_effect_up(bpy.types.Operator):
	bl_idname=      'vray.effect_up'
	bl_label=       "Move effect up"
	bl_description= "Move effect up"

	def execute(self, context):
		VRayScene= context.scene.vray

		VRayEffects= VRayScene.VRayEffects

		if VRayEffects.effects_selected <= 0:
			return {'CANCELLED'}

		VRayEffects.effects.move(VRayEffects.effects_selected,
								 VRayEffects.effects_selected - 1)
		VRayEffects.effects_selected-= 1

		return {'FINISHED'}



class VRAY_OT_effect_down(bpy.types.Operator):
	bl_idname=      'vray.effect_down'
	bl_label=       "Move effect down"
	bl_description= "Move effect down"

	def execute(self, context):
		VRayScene= context.scene.vray

		VRayEffects= VRayScene.VRayEffects

		if VRayEffects.effects_selected == len(VRayEffects.effects) - 1:
			return {'CANCELLED'}

		VRayEffects.effects.move(VRayEffects.effects_selected,
								 VRayEffects.effects_selected + 1)
		VRayEffects.effects_selected+= 1

		return {'FINISHED'}



'''
  Includer operators
'''

class VRAY_OT_includer_add(bpy.types.Operator):
	bl_idname=      'vray.includer_add'
	bl_label=       "Add Include"
	bl_description= "Add Include *.vrsene"

	def execute(self, context):
		vs= context.scene.vray
		module= vs.Includer

		module.nodes.add()
		module.nodes[-1].name= "Include Scene"

		return {'FINISHED'}




class VRAY_OT_includer_remove(bpy.types.Operator):
	bl_idname=      'vray.includer_remove'
	bl_label=       "Remove Include"
	bl_description= "Remove Include *.vrsene"

	def execute(self, context):
		vs= context.scene.vray
		module= vs.Includer

		if module.nodes_selected >= 0:
		   module.nodes.remove(module.nodes_selected)
		   module.nodes_selected-= 1

		return {'FINISHED'}


class VRAY_OT_includer_up(bpy.types.Operator):
	bl_idname=      'vray.includer_up'
	bl_label=       "Up Include"
	bl_description= "Up Include *.vrsene"

	def execute(self, context):
		vs= context.scene.vray
		module= vs.Includer

		if module.nodes_selected <= 0:
			return {'CANCELLED'}

		module.nodes.move(module.nodes_selected,
								 module.nodes_selected - 1)
		module.nodes_selected-= 1

		return {'FINISHED'}


class VRAY_OT_includer_down(bpy.types.Operator):
	bl_idname=      'vray.includer_down'
	bl_label=       "Down Include"
	bl_description= "Down Include *.vrsene"

	def execute(self, context):
		vs= context.scene.vray
		module= vs.Includer

		if module.nodes_selected <= 0:
			return {'CANCELLED'}

		module.nodes.move(module.nodes_selected,
								 module.nodes_selected + 1)
		module.nodes_selected+= 1

		return {'FINISHED'}



'''
  Material operators
'''
def active_node_mat(mat):
	if mat:
		mat_node= mat.active_node_material
		if mat_node:
			return mat_node
		else:
			return mat
	return None


def find_brdf_pointer(rna_pointer):
	if rna_pointer.brdf_selected >= 0 and rna_pointer.brdfs[rna_pointer.brdf_selected].type == 'BRDFLayered':
		return find_brdf_pointer(getattr(rna_pointer.brdfs[rna_pointer.brdf_selected], 'BRDFLayered'))
	return rna_pointer


class VRAY_OT_brdf_add(bpy.types.Operator):
	bl_idname=      'vray.brdf_add'
	bl_label=       "Add BRDF"
	bl_description= "Add BRDF"

	def execute(self, context):
		ma= active_node_mat(context.material)
		if ma:
			rna_pointer= ma.vray.BRDFLayered
			# rna_pointer= find_brdf_pointer(VRayMaterial)

			rna_pointer.brdfs.add()
			rna_pointer.brdfs[-1].name= "BRDF"

			return {'FINISHED'}

		return {'CANCELLED'}



class VRAY_OT_brdf_remove(bpy.types.Operator):
	bl_idname=      'vray.brdf_remove'
	bl_label=       "Remove BRDF"
	bl_description= "Remove BRDF"

	def execute(self, context):
		ma= active_node_mat(context.material)
		if ma:
			rna_pointer= ma.vray.BRDFLayered
			# rna_pointer= find_brdf_pointer(VRayMaterial)

			if rna_pointer.brdf_selected >= 0:
				rna_pointer.brdfs.remove(rna_pointer.brdf_selected)
				rna_pointer.brdf_selected-= 1

			return {'FINISHED'}

		return {'CANCELLED'}



class VRAY_OT_brdf_up(bpy.types.Operator):
	bl_idname=      'vray.brdf_up'
	bl_label=       "Move BRDF up"
	bl_description= "Move BRDF up"

	def execute(self, context):
		ma= active_node_mat(context.material)
		if ma:
			rna_pointer= ma.vray.BRDFLayered
			# rna_pointer= find_brdf_pointer(VRayMaterial)

			if rna_pointer.brdf_selected <= 0:
				return {'FINISHED'}

			rna_pointer.brdfs.move(rna_pointer.brdf_selected,
								   rna_pointer.brdf_selected - 1)
			rna_pointer.brdf_selected-= 1

			return {'FINISHED'}

		return {'CANCELLED'}



class VRAY_OT_brdf_down(bpy.types.Operator):
	bl_idname=      'vray.brdf_down'
	bl_label=       "Move BRDF down"
	bl_description= "Move BRDF down"

	def execute(self, context):
		ma= active_node_mat(context.material)
		if ma:
			rna_pointer= ma.vray.BRDFLayered
			# rna_pointer= find_brdf_pointer(VRayMaterial)

			if rna_pointer.brdf_selected == len(rna_pointer.brdfs) - 1:
				return {'FINISHED'}

			rna_pointer.brdfs.move(rna_pointer.brdf_selected,
								   rna_pointer.brdf_selected + 1)
			rna_pointer.brdf_selected+= 1

			return {'FINISHED'}



'''
  Render channel operators
'''
class VRAY_OT_channel_add(bpy.types.Operator):
	bl_idname=      'vray.render_channels_add'
	bl_label=       "Add Render Channel"
	bl_description= "Add render channel"

	def execute(self, context):
		sce= context.scene
		vsce= sce.vray

		render_channels= vsce.render_channels

		render_channels.add()
		render_channels[-1].name= "RenderChannel"

		return {'FINISHED'}



class VRAY_OT_channel_del(bpy.types.Operator):
	bl_idname=      'vray.render_channels_remove'
	bl_label=       "Remove Render Channel"
	bl_description= "Remove render channel"

	def execute(self, context):
		sce= context.scene
		vsce= sce.vray

		render_channels= vsce.render_channels

		if vsce.render_channels_index >= 0:
		   render_channels.remove(vsce.render_channels_index)
		   vsce.render_channels_index-= 1

		return {'FINISHED'}



'''
  DR node operators
'''
class VRAY_OT_node_add(bpy.types.Operator):
	bl_idname=      'vray.render_nodes_add'
	bl_label=       "Add Render Node"
	bl_description= "Add render node"

	def execute(self, context):
		vs= context.scene.vray
		module= vs.VRayDR

		module.nodes.add()
		module.nodes[-1].name= "Render Node"

		return {'FINISHED'}



class VRAY_OT_node_del(bpy.types.Operator):
	bl_idname=      'vray.render_nodes_remove'
	bl_label=       "Remove Render Node"
	bl_description= "Remove render node"

	def execute(self, context):
		vs= context.scene.vray
		module= vs.VRayDR

		if module.nodes_selected >= 0:
			module.nodes.remove(module.nodes_selected)
			module.nodes_selected -= 1

		if module.nodes_selected == -1 and len(module.nodes):
			module.nodes_selected = 0

		return {'FINISHED'}



class VRAY_OT_dr_nodes_load(bpy.types.Operator):
	bl_idname      = "vray.dr_nodes_load"
	bl_label       = "Load DR Nodes"
	bl_description = "Load distributed rendering nodes list"

	def execute(self, context):
		VRayScene = context.scene.vray
		VRayDR = VRayScene.VRayDR

		nodesFilepath = os.path.join(GetUserConfigDir(), "vray_render_nodes.txt")

		if not os.path.exists(nodesFilepath):
			return {'CANCELLED'}

		with open(nodesFilepath, 'r') as nodesFile:
			VRayDR.nodes.clear()

			for line in nodesFile.readlines():
				l = line.strip()
				if not l:
					continue

				item = VRayDR.nodes.add()
				item.name, item.address = l.split(":")

		VRayDR.nodes_selected = 0

		return {'FINISHED'}


class VRAY_OT_dr_nodes_save(bpy.types.Operator):
	bl_idname      = "vray.dr_nodes_save"
	bl_label       = "Save DR Nodes"
	bl_description = "Save distributed rendering nodes list"

	def execute(self, context):
		VRayScene = context.scene.vray
		VRayDR = VRayScene.VRayDR

		nodesFilepath = os.path.join(GetUserConfigDir(), "vray_render_nodes.txt")

		with open(nodesFilepath, 'w') as nodesFile:
			for item in VRayDR.nodes:
				nodesFile.write("%s:%s\n" % (item.name, item.address))

		return {'FINISHED'}



'''
  Some usefull utils
'''
class VRAY_OT_convert_scene(bpy.types.Operator):
	bl_idname      = "vray.convert_materials"
	bl_label       = "Convert materials"
	bl_description = "Convert scene materials from Blender Internal to V-Ray"

	CONVERT_BLEND_TYPE= {
		'MIX':          'OVER',
		'SCREEN':       'OVER',
		'DIVIDE':       'OVER',
		'HUE':          'OVER',
		'VALUE':        'OVER',
		'COLOR':        'OVER',
		'SOFT LIGHT':   'OVER',
		'LINEAR LIGHT': 'OVER',
		'OVERLAY':      'OVER',
		'ADD':          'ADD',
		'SUBTRACT':     'SUBTRACT',
		'MULTIPLY':     'MULTIPLY',
		'DIFFERENCE':   'DIFFERENCE',
		'DARKEN':       'DARKEN',
		'LIGHTEN':      'LIGHTEN',
		'SATURATION':   'SATURATE',
	}

	def execute(self, context):
		for ma in bpy.data.materials:
			debug(context.scene, "Converting material: %s" % ma.name)

			rm= ma.raytrace_mirror
			rt= ma.raytrace_transparency

			VRayMaterial= ma.vray
			BRDFVRayMtl=  VRayMaterial.BRDFVRayMtl

			BRDFVRayMtl.diffuse = ma.diffuse_color

			if ma.emit > 0.0:
				VRayMaterial.type= 'BRDFLight'

			if rm.use:
				BRDFVRayMtl.reflect_color= tuple([rm.reflect_factor]*3)
				BRDFVRayMtl.reflect_glossiness= rm.gloss_factor
				BRDFVRayMtl.reflect_subdivs= rm.gloss_samples
				BRDFVRayMtl.reflect_depth= rm.depth
				BRDFVRayMtl.option_cutoff= rm.gloss_threshold
				BRDFVRayMtl.anisotropy= 1.0 - rm.gloss_anisotropic

				if rm.fresnel > 0.0:
					BRDFVRayMtl.fresnel= True
					BRDFVRayMtl.fresnel_ior= rm.fresnel

			for slot in ma.texture_slots:
				if slot and slot.texture and slot.texture.type in TEX_TYPES:
					VRaySlot=    slot.texture.vray_slot
					VRayTexture= slot.texture.vray

					VRaySlot.blend_mode= self.CONVERT_BLEND_TYPE[slot.blend_type]

					if slot.use_map_emit:
						VRayMaterial.type= 'BRDFLight'

						VRaySlot.map_diffuse=  True

					if slot.use_map_normal:
						VRaySlot.map_normal=             True
						VRaySlot.BRDFBump.bump_tex_mult= slot.normal_factor

					if slot.use_map_color_diffuse:
						VRaySlot.map_diffuse=  True
						VRaySlot.diffuse_mult= slot.diffuse_color_factor

					if slot.use_map_raymir:
						VRaySlot.map_reflect=  True
						VRaySlot.reflect_mult= slot.raymir_factor

					if slot.use_map_alpha:
						VRaySlot.map_opacity=  True
						VRaySlot.opacity_mult= slot.alpha_factor

		return {'FINISHED'}




class VRAY_OT_bake_procedural(bpy.types.Operator):
	bl_idname=      'vray.bake_procedural'
	bl_label=       "Bake procedural"
	bl_description= "Render procedural texture to file"

	def execute(self, context):
		debug(context.scene, "Bake procedural: In progress...")
		return {'FINISHED'}




class VRAY_OT_settings_to_text(bpy.types.Operator):
	bl_idname=      'vray.settings_to_text'
	bl_label=       "Settings to Text"
	bl_description= "Export settings to Text"

	bb_code= BoolProperty(
		name= "Use BB-code",
		description= "Use BB-code formatting",
		default= True
	)

	def execute(self, context):

		text= bpy.data.texts.new(name="Settings")

		bus= {}
		bus['scene']= context.scene
		bus['preview']= False
		bus['files']= {}
		bus['files']['scene']= text
		bus['filenames']= {}
		bus['plugins']= PLUGINS
		bus['effects']= {}
		bus['effects']['fog']= {}
		bus['effects']['toon']= {}
		bus['effects']['toon']['effects']= []
		bus['effects']['toon']['objects']= []

		text.write("V-Ray/Blender 2.0 | Scene: %s | %s\n" % (context.scene.name,
															 time.strftime("%d %b %Y %H:%m:%S")))

		for key in PLUGINS['SETTINGS']:
			if key in ('BakeView', 'RenderView', 'SettingsEnvironment'):
				# Skip some plugins
				continue

			plugin= PLUGINS['SETTINGS'][key]
			if hasattr(plugin, 'write'):
				plugin.write(bus)

		return {'FINISHED'}



class VRAY_OT_flip_resolution(bpy.types.Operator):
	bl_idname      = "vray.flip_resolution"
	bl_label       = "Flip resolution"
	bl_description = "Flip render resolution"

	def execute(self, context):
		scene= context.scene
		rd=    scene.render

		VRayScene= scene.vray

		if VRayScene.image_aspect_lock:
			VRayScene.image_aspect= 1.0 / VRayScene.image_aspect

		rd.resolution_x, rd.resolution_y = rd.resolution_y, rd.resolution_x
		rd.pixel_aspect_x, rd.pixel_aspect_y = rd.pixel_aspect_y, rd.pixel_aspect_x

		return {'FINISHED'}


def LoadProxyMeshToObject(ob, filepath, anim_type, anim_offset, anim_speed, anim_frame):
	meshFile = VRayProxy.MeshFile(filepath)

	err = meshFile.readFile()
	if err is not None:
		return "Error parsing VRayProxy file!"

	meshData = meshFile.getPreviewMesh(anim_type, anim_offset, anim_speed, anim_frame)
	if meshData is None:
		return "Can't find preview voxel!"

	meshName = bpy.path.clean_name(os.path.basename(filepath))

	# Add new mesh
	mesh = bpy.data.meshes.new(meshName)
	mesh.from_pydata(meshData['vertices'], [], meshData['faces'])
	mesh.update()

	# Replace object's mesh
	bm = bmesh.new()
	bm.from_mesh(mesh)
	bm.to_mesh(ob.data)
	ob.data.update()

	# Remove temp
	bm.free()
	bpy.data.meshes.remove(mesh)


class VRAY_OT_proxy_load_preview(bpy.types.Operator):
	bl_idname      = "vray.proxy_load_preview"
	bl_label       = "Load Preview"
	bl_description = "Load VRayProxy mesh preview from file"

	def execute(self, context):
		GeomMeshFile = context.object.data.vray.GeomMeshFile

		proxyFilepath = os.path.normpath(path_sep_to_unix(bpy.path.abspath(GeomMeshFile.file)))

		err = LoadProxyMeshToObject(
			context.object,
			proxyFilepath,
			GeomMeshFile.anim_type,
			GeomMeshFile.anim_offset,
			GeomMeshFile.anim_speed,
			context.scene.frame_current-1
		)

		if err is not None:
			self.report({'ERROR'}, err)
			return {'CANCELLED'}

		return {'FINISHED'}


class VRAY_OT_create_proxy(bpy.types.Operator):
	bl_idname      = "vray.create_proxy"
	bl_label       = "Create proxy"
	bl_description = "Creates proxy from selection"

	def execute(self, context):
		sce = context.scene

		VRayScene    = sce.vray
		VRayExporter = VRayScene.exporter

		@TimeIt("Proxy generated in")
		def _create_proxy(ob):
			if ob.type in {'LAMP', 'CAMERA', 'ARMATURE', 'LATTICE', 'EMPTY'}:
				return

			GeomMeshFile= ob.data.vray.GeomMeshFile

			vrmesh_filename= GeomMeshFile.filename if GeomMeshFile.filename else clean_string(ob.name)
			vrmesh_filename+= ".vrmesh"

			vrmesh_dirpath= bpy.path.abspath(GeomMeshFile.dirpath)
			if not os.path.exists(vrmesh_dirpath):
				os.mkdir(vrmesh_dirpath)
			vrmesh_filepath= os.path.join(vrmesh_dirpath,vrmesh_filename)

			if GeomMeshFile.animation:
				selected_frame= sce.frame_current

				frame_start= sce.frame_start
				frame_end= sce.frame_end
				if GeomMeshFile.animation_range == 'MANUAL':
					frame_start= GeomMeshFile.frame_start
					frame_end= GeomMeshFile.frame_end

				# Export first frame to create file
				frame= frame_start
				sce.frame_set(frame)
				vb25.proxy.generate_proxy(sce,ob,vrmesh_filepath)
				frame+= 1
				# Export all other frames
				while(frame <= frame_end):
					sce.frame_set(frame)
					vb25.proxy.generate_proxy(sce,ob,vrmesh_filepath,append=True)
					frame+= 1
				sce.frame_set(selected_frame)

			else:
				if VRayExporter.experimental:
					bpy.ops.vray.generate_vrayproxy(
						filepath = vrmesh_filepath,
					)
				else:
					vb25.proxy.generate_proxy(sce,ob,vrmesh_filepath)

			ob_name= ob.name
			ob_data_name= ob.data.name

			VRayMesh= ob.data.vray

			if GeomMeshFile.mode == 'NONE':
				return
			elif GeomMeshFile.mode in {'THIS', 'REPLACE'}:
				if GeomMeshFile.add_suffix:
					ob.name += '_proxy'

				# Override settings
				VRayMesh.override      = True
				VRayMesh.override_type = 'VRAYPROXY'
				GeomMeshFile.file = RelPath(vrmesh_filepath)

				# Load preview mesh
				if GeomMeshFile.mode == 'REPLACE':
					LoadProxyMeshToObject(
						ob,
						vrmesh_filepath,
						GeomMeshFile.anim_type,
						GeomMeshFile.anim_offset,
						GeomMeshFile.anim_speed,
						context.scene.frame_current-1
					)

					if GeomMeshFile.apply_transforms:
						ob.select= True
						sce.objects.active= ob
						bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)

			elif GeomMeshFile.mode == 'NEW':
				# Create new object and copy materials
				new_ob= bpy.data.objects.new(ob_name+'_proxy', bpy.data.meshes.new(ob_name+'_proxy'))
				sce.objects.link(new_ob)
				new_ob.matrix_world= ob.matrix_world
				bpy.ops.object.select_all(action='DESELECT')
				new_ob.select= True
				sce.objects.active= new_ob

				LoadProxyMeshToObject(
					new_ob,
					vrmesh_filepath,
					GeomMeshFile.anim_type,
					GeomMeshFile.anim_offset,
					GeomMeshFile.anim_speed,
					context.scene.frame_current-1
				)

				for slot in ob.material_slots:
					if slot and slot.material:
						new_ob.data.materials.append(slot.material)

				if GeomMeshFile.apply_transforms:
					ob.select= True
					sce.objects.active= ob
					bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)

				VRayMesh= new_ob.data.vray
				VRayMesh.override= True
				VRayMesh.override_type= 'VRAYPROXY'

				GeomMeshFile= VRayMesh.GeomMeshFile
				GeomMeshFile.file= RelPath(vrmesh_filepath)

		if len(bpy.context.selected_objects):
			for ob in bpy.context.selected_objects:
				_create_proxy(ob)
		else:
			_create_proxy(context.object)

		return {'FINISHED'}



'''
  EXPORT OPERATORS
'''
def init(context):
	scene= context.scene

	# Settings bus
	bus= {}

	# Plugins
	bus['plugins']= PLUGINS

	# Scene
	bus['scene']= scene

	# Preview
	bus['preview']= False

	# V-Ray uses UV indexes, Blender uses UV names
	# Here we store UV name->index map
	bus['uvs']= get_uv_layers_map(scene)

	# Output files
	bus['files']=     {}
	bus['filenames']= {}

	init_files(bus)

	return bus

class VRAY_OT_write_scene(bpy.types.Operator):
	bl_idname      = "vray.write_scene"
	bl_label       = "Export scene"
	bl_description = "Export scene to \"vrscene\" file"

	def execute(self, context):

		vb25.render.write_scene(init(context))

		return {'FINISHED'}



class VRAY_OT_write_geometry(bpy.types.Operator):
	bl_idname      = "vray.write_geometry"
	bl_label       = "Export meshes"
	bl_description = "Export meshes into vrscene file"

	dialog_width = 180

	def draw(self, context):
		layout = self.layout
		split = layout.split()
		col = split.column()
		col.label(text = "Animation mode is active!")
		col.label(text = "Are you sure to export meshes?")

	def invoke(self, context, event):
		wm    = context.window_manager
		scene = context.scene

		VRayScene    = scene.vray
		VRayExporter = VRayScene.exporter

		if not bpy.app.background:
			if VRayExporter.animation and VRayExporter.animation_type == 'FULL':
				return wm.invoke_props_dialog(self, self.dialog_width)

		return self.execute(context)

	def execute(self, context):

		vb25.render.write_geometry(init(context))

		return {'FINISHED'}



class VRAY_OT_write_vrscene(bpy.types.Operator):
	bl_idname      = "vray.write_vrscene"
	bl_label       = "Export Scene"
	bl_description = "Export scene into a *.vrscene files"

	def execute(self, context):
		bpy.ops.vray.export_vrscene()
		return {'FINISHED'}



class VRAY_OT_render(bpy.types.Operator):
	bl_idname      = "vray.render"
	bl_label       = "V-Ray Renderer"
	bl_description = "Render operator"

	def execute(self, context):
		scene = context.scene

		VRayScene    = scene.vray
		VRayExporter = VRayScene.exporter

		vb25.render.render(None, scene)

		return {'FINISHED'}



class VRAY_OT_run(bpy.types.Operator):
	bl_idname      = "vray.run"
	bl_label       = "Run V-Ray"
	bl_description = "Run V-Ray renderer"

	def execute(self, context):

		vb25.render.run(None, context.scene)

		return {'FINISHED'}



class VRAY_OT_terminate(bpy.types.Operator):
	bl_idname      = "vray.terminate"
	bl_label       = "Terminate VRayRT"
	bl_description = "Terminates running VRayRT instance"

	def execute(self, context):
		s = VRaySocket()
		s.connect()
		s.send("stop", result=False)
		s.send("quit", result=False)
		s.disconnect()

		return {'FINISHED'}



class VRAY_OT_set_kelvin_color(bpy.types.Operator):
	bl_idname      = "vray.set_kelvin_color"
	bl_label       = "Kelvin color"
	bl_description = "Set color temperature"

	data_path= StringProperty(
		name= "Data",
		description= "Data path",
		maxlen= 1024,
		default= ""
	)

	d_color= EnumProperty(
		name= "Illuminant series D",
		description= "Illuminant series D",
		items= (
			('D75',  "D75",  "North sky Daylight"),
			('D65',  "D65",  "Noon Daylight"),
			('D55',  "D55",  "Mid-morning / Mid-afternoon Daylight"),
			('D50',  "D50",  "Horizon Light"),
		),
		default= 'D50'
	)

	use_temperature= BoolProperty(
		name= "Use temperature",
		description= "Use temperature",
		default= False
	)

	temperature= IntProperty(
		name= "Temperature",
		description= "Kelvin temperature",
		min= 1000,
		max= 40000,
		step= 100,
		default= 5000
	)

	dialog_width= 150

	def draw(self, context):
		layout= self.layout

		if 0:
			row= layout.split().row(align= True)
			row.prop(self, 'use_temperature', text= "")
			if self.use_temperature:
				row.prop(self, 'temperature', text= "K")
			else:
				row.prop(self, 'd_color', text= "Type")
		else:
			split= layout.split()
			col= split.column()
			col.prop(self, 'd_color', text= "Type")
			sub= col.row(align= True)
			sub.prop(self, 'use_temperature', text= "")
			sub.prop(self, 'temperature', text= "K")

	def invoke(self, context, event):
		wm= context.window_manager
		return wm.invoke_props_dialog(self, self.dialog_width)

	def execute(self, context):
		D_COLOR= {
			'D75': 7500,
			'D65': 6500,
			'D55': 5500,
			'D50': 5000,
		}

		def recursive_attr(data, attrs):
			if not attrs:
				return data
			attr= attrs.pop()
			return recursive_attr(getattr(data, attr), attrs)

		if self.data_path:
			attrs= self.data_path.split('.')
			attr= attrs.pop() # Attribute to set
			attrs.reverse()

			data_pointer= recursive_attr(context, attrs)

			temperature= D_COLOR[self.d_color]

			if self.use_temperature:
				temperature= self.temperature

			setattr(data_pointer, attr, tuple(kelvin_to_rgb(temperature)))

		return {'FINISHED'}



class VRAY_OT_add_sky(bpy.types.Operator):
	bl_idname      = "vray.add_sky"
	bl_label       = "Add Sky texture"
	bl_description = "Add Sky texture to the background"

	def execute(self, context):
		scene= context.scene

		try:
			for i,slot in enumerate(scene.world.texture_slots):
				if not slot:
					tex= bpy.data.textures.new(name= 'VRaySky',
											   type= 'VRAY')
					tex.vray.type= 'TexSky'
					new_slot= scene.world.texture_slots.create(i)
					new_slot.texture= tex
					break
		except:
			debug(scene,
				  "Sky texture only availble in \"%s\"!" % color("Special build",'green'),
				  error= True)

		return {'FINISHED'}




'''
  LINK MATERIAL OVERRIDE
'''
class VRAY_OT_copy_linked_materials(bpy.types.Operator):
	bl_idname      = "vray.copy_linked_materials"
	bl_label       = "Copy linked materials"
	bl_description = "Copy linked materials"

	def execute(self, context):
		scene=  context.scene
		object= context.active_object

		if not object:
			debug(scene, "No object selected!", error= True)
			return {'CANCELLED'}

		if object.type == 'EMPTY':
			debug(scene, "Empty object type is not supported! Use simple mesh instead.", error= True)
			return {'CANCELLED'}

		if object.dupli_type == 'GROUP':
			object.dupli_list_create(scene)

			for dup_ob in object.dupli_list:
				ob= dup_ob.object
				for slot in ob.material_slots:
					ma= slot.material
					if ma:
						materials= [slot.material for slot in object.material_slots]
						if ma not in materials:
							debug(scene, "Adding material: %s" % (ma.name))
							object.data.materials.append(ma)

			object.dupli_list_clear()

			return {'FINISHED'}

		debug(scene, "Object \"%s\" has no dupli-group assigned!" % (object.name), error= True)
		return {'CANCELLED'}



'''
  RENDER ENGINE
'''
class VRayRenderer(bpy.types.RenderEngine):
	bl_idname      = 'VRAY_RENDER'
	bl_label       = "%s" % VRAYBLENDER_MENU_ITEM
	bl_use_preview =  False

	# def view_update(self, context):
	# 	pass

	# def view_draw(self, context):
	# 	w = context.region.width
	# 	h = context.region.height

	# 	bgl.glColor3f(1.0, 0.5, 0.0)
	# 	bgl.glRectf(0, 0, w, h)

	def render(self, scene):
		VRayScene= scene.vray
		VRayExporter= VRayScene.exporter

		err = vb25.render.render(self, scene)

		if err is not None:
			self.report({'ERROR'}, err)



class VRayRendererPreview(bpy.types.RenderEngine):
	bl_idname      = 'VRAY_RENDER_PREVIEW'
	bl_label       = "%s (material preview)" % VRAYBLENDER_MENU_ITEM
	bl_use_preview = True

	def render(self, scene):
		VRayScene    = scene.vray
		VRayExporter = VRayScene.exporter

		if scene.name == "preview":
			if scene.render.resolution_x < 64:
				return
			vb25.render.render(self, scene, preview=True)
		else:
			err = vb25.render.render(self, scene)

			if err is not None:
				self.report({'ERROR'}, err)


class VRayMaterialNameMenu(bpy.types.Menu):
	bl_label = "Select Material Name"
	bl_idname = "VRayMaterialNameMenu"

	ma_list = []

	def draw(self, context):
		row = self.layout.row()
		sub = row.column()
		
		for i,maName in enumerate(self.ma_list):
			if i and i % 15 == 0:
				sub = row.column()
			sub.operator("vray.set_vrscene_material_name", text=maName).name = maName


class VRaySetMaterialName(bpy.types.Operator):
	bl_idname      = "vray.set_vrscene_material_name"
	bl_label       = "Set Material Name"
	bl_description = "Set material name from *.vrscene file"

	name = bpy.props.StringProperty()

	def execute(self, context):
		ma = context.material

		VRayMaterial = ma.vray
		if not VRayMaterial.type == 'MtlVRmat':
			return {'CANCELLED'}

		MtlVRmat = VRayMaterial.MtlVRmat
		MtlVRmat.mtlname = self.name

		return {'FINISHED'}


class VRayGetMaterialName(bpy.types.Operator):
	bl_idname      = "vray.get_vrscene_material_name"
	bl_label       = "Get Material Name"
	bl_description = "Get material name from *.vrscene file"

	def execute(self, context):
		ma = context.material

		VRayMaterial = ma.vray
		if not VRayMaterial.type == 'MtlVRmat':
			return {'CANCELLED'}

		MtlVRmat = VRayMaterial.MtlVRmat
		if not MtlVRmat.filename:
			return {'CANCELLED'}

		filePath = get_path(MtlVRmat.filename)
		if not os.path.exists(filePath):
			return {'CANCELLED'}

		if filePath.endswith(".vrscene"):
			VRayMaterialNameMenu.ma_list = GetMaterialsNames(filePath)
		else:
			VRayMaterialNameMenu.ma_list = GetXMLMaterialsNames(filePath)

		bpy.ops.wm.call_menu(name=VRayMaterialNameMenu.bl_idname)

		return {'FINISHED'}


def GetRegClasses():
	return (
		VRayMaterialNameMenu,
		VRayGetMaterialName,
		VRaySetMaterialName,
		VRAY_OT_update,
		VRAY_OT_lens_shift,
		VRAY_OT_effect_add,
		VRAY_OT_effect_remove,
		VRAY_OT_effect_up,
		VRAY_OT_effect_down,
		VRAY_OT_includer_add,
		VRAY_OT_includer_remove,
		VRAY_OT_includer_up,
		VRAY_OT_includer_down,
		VRAY_OT_brdf_add,
		VRAY_OT_brdf_remove,
		VRAY_OT_brdf_up,
		VRAY_OT_brdf_down,
		VRAY_OT_channel_add,
		VRAY_OT_channel_del,
		VRAY_OT_node_add,
		VRAY_OT_node_del,
		VRAY_OT_dr_nodes_load,
		VRAY_OT_dr_nodes_save,
		VRAY_OT_convert_scene,
		VRAY_OT_bake_procedural,
		VRAY_OT_settings_to_text,
		VRAY_OT_flip_resolution,
		VRAY_OT_proxy_load_preview,
		VRAY_OT_create_proxy,
		VRAY_OT_write_scene,
		VRAY_OT_write_geometry,
		VRAY_OT_write_vrscene,
		VRAY_OT_render,
		VRAY_OT_run,
		VRAY_OT_terminate,
		VRAY_OT_set_kelvin_color,
		VRAY_OT_add_sky,
		VRAY_OT_copy_linked_materials,
		VRayRenderer,
		VRayRendererPreview,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = shaders
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy

''' vb modules '''
from vb25.utils import *
from vb25.plugins import *
from vb25.texture import *


def write_BRDFGlossy(ofile, sce, ma, ma_name, textures):
	BRDFVRayMtl= ma.vray.BRDFVRayMtl

	brdf_name= get_random_string()

	if BRDFVRayMtl.brdf_type == 'PHONG':
		ofile.write("\nBRDFPhong %s {"%(brdf_name))
	elif BRDFVRayMtl.brdf_type == 'WARD':
		ofile.write("\nBRDFWard %s {"%(brdf_name))
	else:
		ofile.write("\nBRDFBlinn %s {"%(brdf_name))

	ofile.write("\n\tcolor= %s;"%(a(sce,"Color(%.6f,%.6f,%.6f)"%(tuple(BRDFVRayMtl.reflect_color)))))
	ofile.write("\n\tsubdivs= %i;"%(BRDFVRayMtl.reflect_subdivs))

	if 'reflect' in textures:
		ofile.write("\n\ttransparency= Color(1.0,1.0,1.0);")
		ofile.write("\n\ttransparency_tex= %s;"%(textures['reflect']))
	else:
		ofile.write("\n\ttransparency= %s;"%(a(sce,"Color(%.6f,%.6f,%.6f)"%(tuple([1.0 - c for c in BRDFVRayMtl.reflect_color])))))

	ofile.write("\n\treflectionGlossiness= %s;"%(a(sce,BRDFVRayMtl.reflect_glossiness)))
	if BRDFVRayMtl.hilight_glossiness_lock:
		ofile.write("\n\thilightGlossiness= %s;"%(a(sce,BRDFVRayMtl.reflect_glossiness)))
	else:
		ofile.write("\n\thilightGlossiness= %s;"%(a(sce,BRDFVRayMtl.hilight_glossiness)))
	if 'reflect_glossiness' in textures:
		ofile.write("\n\treflectionGlossiness_tex= %s;"%("%s::out_intensity"%(textures['reflect_glossiness'])))
	if 'hilight_glossiness' in textures:
		ofile.write("\n\thilightGlossiness_tex= %s;"%("%s::out_intensity"%(textures['hilight_glossiness'])))
	ofile.write("\n\tback_side= %d;"%(BRDFVRayMtl.option_reflect_on_back))
	ofile.write("\n\ttrace_reflections= %s;"%(p(BRDFVRayMtl.reflect_trace)))
	ofile.write("\n\ttrace_depth= %i;"%(BRDFVRayMtl.reflect_depth))
	if BRDFVRayMtl.brdf_type != 'PHONG':
		ofile.write("\n\tanisotropy= %s;"%(a(sce,BRDFVRayMtl.anisotropy)))
		ofile.write("\n\tanisotropy_rotation= %s;"%(a(sce,BRDFVRayMtl.anisotropy_rotation)))
	ofile.write("\n\tcutoff= %.6f;"%(BRDFVRayMtl.option_cutoff))
	ofile.write("\n}\n")

	return brdf_name


def write_BRDFMirror(ofile, sce, ma, ma_name, textures):
	BRDFVRayMtl= ma.vray.BRDFVRayMtl

	brdf_name= get_random_string()

	ofile.write("\nBRDFMirror %s {"%(brdf_name))
	if 'color' in textures:
		ofile.write("\n\tcolor= %s;"%(textures['color']))
	else:
		ofile.write("\n\tcolor= %s;"%(a(sce,"Color(%.6f,%.6f,%.6f)"%(tuple(BRDFVRayMtl.reflect_color)))))
	if 'reflect' in textures:
		ofile.write("\n\ttransparency= Color(1.0, 1.0, 1.0);")
		ofile.write("\n\ttransparency_tex= %s;"%(textures['reflect']))
	else:
		ofile.write("\n\ttransparency= %s;"%(a(sce,"Color(%.6f,%.6f,%.6f)"%(tuple([1.0 - c for c in BRDFVRayMtl.reflect_color])))))
	ofile.write("\n\tback_side= %d;"%(BRDFVRayMtl.option_reflect_on_back))
	ofile.write("\n\ttrace_reflections= %s;"%(p(BRDFVRayMtl.reflect_trace)))
	ofile.write("\n\ttrace_depth= %i;"%(BRDFVRayMtl.reflect_depth))
	ofile.write("\n\tcutoff= %.6f;"%(BRDFVRayMtl.option_cutoff))
	ofile.write("\n}\n")

	return brdf_name


def write_BRDFGlass(ofile, sce, ma, ma_name, textures):
	BRDFVRayMtl= ma.vray.BRDFVRayMtl

	brdf_name= get_random_string()

	ofile.write("\nBRDFGlass %s {"%(brdf_name))
	ofile.write("\n\tcolor= %s;"%(a(sce,"Color(%.6f,%.6f,%.6f)"%(tuple(BRDFVRayMtl.refract_color)))))
	if 'refract' in textures:
		ofile.write("\n\tcolor_tex= %s;"%(textures['refract']))
	ofile.write("\n\tior= %s;"%(a(sce,BRDFVRayMtl.refract_ior)))
	ofile.write("\n\taffect_shadows= %d;"%(BRDFVRayMtl.refract_affect_shadows))
	ofile.write("\n\taffect_alpha= %d;"%(BRDFVRayMtl.refract_affect_alpha))
	ofile.write("\n\ttrace_refractions= %d;"%(BRDFVRayMtl.refract_trace))
	ofile.write("\n\ttrace_depth= %s;"%(BRDFVRayMtl.refract_depth))
	ofile.write("\n\tcutoff= %.6f;"%(BRDFVRayMtl.option_cutoff))
	ofile.write("\n}\n")

	return brdf_name


def write_BRDFGlassGlossy(ofile, sce, ma, ma_name, textures):
	BRDFVRayMtl= ma.vray.BRDFVRayMtl

	brdf_name= get_random_string()

	ofile.write("\nBRDFGlassGlossy %s {"%(brdf_name))
	ofile.write("\n\tcolor= %s;"%(a(sce,"Color(%.6f,%.6f,%.6f)"%(tuple(BRDFVRayMtl.refract_color)))))
	if 'refract' in textures:
		ofile.write("\n\tcolor_tex= %s;"%(textures['refract']))
	ofile.write("\n\tglossiness= %s;"%(a(sce,BRDFVRayMtl.refract_glossiness)))
	ofile.write("\n\tsubdivs= %i;"%(BRDFVRayMtl.refract_subdivs))
	ofile.write("\n\tior= %s;"%(a(sce,BRDFVRayMtl.refract_ior)))
	ofile.write("\n\taffect_shadows= %d;"%(BRDFVRayMtl.refract_affect_shadows))
	ofile.write("\n\taffect_alpha= %d;"%(BRDFVRayMtl.refract_affect_alpha))
	ofile.write("\n\ttrace_refractions= %d;"%(BRDFVRayMtl.refract_trace))
	ofile.write("\n\ttrace_depth= %s;"%(BRDFVRayMtl.refract_depth))
	ofile.write("\n\tcutoff= %.6f;"%(BRDFVRayMtl.option_cutoff))
	ofile.write("\n}\n")

	return brdf_name


def write_BRDFDiffuse(ofile, sce, ma, ma_name, textures):
	BRDFVRayMtl= ma.vray.BRDFVRayMtl
		
	brdf_name= get_random_string()

	ofile.write("\nBRDFDiffuse %s {"%(brdf_name))
	ofile.write("\n\tcolor= %s;"%(a(sce,"Color(%.6f, %.6f, %.6f)"%(tuple(ma.diffuse_color)))))
	ofile.write("\n\troughness= %s;"%(a(sce,"Color(1.0,1.0,1.0)*%.6f"%(BRDFVRayMtl.roughness))))
	if 'diffuse' in textures:
		ofile.write("\n\tcolor_tex= %s;" % textures['diffuse'])
	ofile.write("\n\ttransparency= %s;" % a(sce,"Color(1.0,1.0,1.0)*%.6f"%(1.0 - ma.alpha)))
	if 'opacity' in textures:
		ofile.write("\n\ttransparency_tex= %s;" % textures['opacity'])
	ofile.write("\n}\n")

	return brdf_name


def write_BRDF(ofile, sce, ma, ma_name, textures):
	def bool_color(color):
		for c in color:
			if c > 0.0:
				return True
		return False

	BRDFVRayMtl= ma.vray.BRDFVRayMtl

	brdfs= []

	reflect= None

	if 'reflect' in textures:
		reflect= write_TexInvert(textures['reflect'])

	if reflect or bool_color(BRDFVRayMtl.reflect_color):
		if BRDFVRayMtl.reflect_glossiness < 1.0 or 'reflect_glossiness' in textures:
			brdf_name= write_BRDFGlossy(ofile, sce, ma, ma_name, textures['mapto'])
		else:
			brdf_name= write_BRDFMirror(ofile, sce, ma, ma_name, textures['mapto'])
		brdfs.append(brdf_name)

	if 'refract' in textures or bool_color(BRDFVRayMtl.refract_color):
		if BRDFVRayMtl.refract_glossiness < 1.0 or 'refract_glossiness' in textures:
			brdf_name= write_BRDFGlassGlossy(ofile, sce, ma, ma_name, textures['mapto'])
		else:
			brdf_name= write_BRDFGlass(ofile, sce, ma, ma_name, textures['mapto'])
	else:
		brdf_name= write_BRDFDiffuse(ofile, sce, ma, ma_name, textures['mapto'])
	brdfs.append(brdf_name)

	if len(brdfs) == 1:
		brdf_name= brdfs[0]
	else:
		brdf_name= "BRDFLayered_%s"%(ma_name)
		ofile.write("\nBRDFLayered %s {"%(brdf_name))
		ofile.write("\n\tbrdfs= List(%s);"%(','.join(brdfs)))
		ofile.write("\n\ttransparency= %s;"%(a(sce,"Color(1.0,1.0,1.0)*%.6f"%(1.0 - ma.alpha))))
		if 'opacity' in textures:
			ofile.write("\n\ttransparency_tex= %s;" % textures['opacity'])
		ofile.write("\n}\n")

	return brdf_name


def write_BRDFLight(ofile, sce, ma, ma_name, mapped_params):
	textures= mapped_params['mapto']

	brdf_name= "BRDFLight_%s"%(ma_name)

	light= ma.vray.BRDFLight

	ofile.write("\nBRDFLight %s {"%(brdf_name))

	if 'diffuse' in textures:
		color= textures['diffuse']
		if 'opacity' in textures:
			alpha= write_TexInvert(ofile, sce, textures['opacity'])
			color= write_TexCompMax(ofile, sce, {'name': "%s_alpha" % brdf_name,
												 'sourceA': alpha,
												 'sourceB': color,
												 'opertor': 'Multiply'})
		ofile.write("\n\tcolor= %s;" % color)
	else:
		ofile.write("\n\tcolor= %s;" % a(sce, ma.diffuse_color))

	ofile.write("\n\tcolorMultiplier= %s;" % a(sce, ma.emit * 10))
	ofile.write("\n\tcompensateExposure= %s;" % p(light.compensateExposure))
	ofile.write("\n\temitOnBackSide= %s;" % p(light.emitOnBackSide))
	ofile.write("\n\tdoubleSided= %s;" % p(light.doubleSided))

	if 'opacity' in textures:
		ofile.write("\n\ttransparency= %s;" % textures['opacity'])
	else:
		ofile.write("\n\ttransparency= %s;" % a(sce,"Color(1.0,1.0,1.0)*%.6f" % (1.0 - ma.alpha)))

	ofile.write("\n}\n")

	return brdf_name

########NEW FILE########
__FILENAME__ = texture
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy

''' vb modules '''
from vb25.utils   import *
from vb25.plugins import *


def write_TexAColor(bus, name, node, color_a, mult):
	ofile= bus['files']['textures']
	scene= bus['scene']

	tex_name= "TACOP%sNO%s" % (name, clean_string(node.name))

	ofile.write("\nTexAColorOp %s {" % tex_name)
	ofile.write("\n\tcolor_a= %s;" % color_a)
	ofile.write("\n\tmult_a= %s;" % a(sce,mult))
	ofile.write("\n}\n")

	return tex_name


def write_TexAColor(bus, name, node, color):
	ofile= bus['files']['textures']
	scene= bus['scene']

	tex_name= "TAC%sNO%s" % (name, clean_string(node.name))

	ofile.write("\nTexAColor %s {" % tex_name)
	ofile.write("\n\ttexture= %s;" % a(scene, color))
	ofile.write("\n}\n")

	return tex_name


def write_TexCompMax(ofile, sce, params):
	OPERATOR= {
		'Add':        0,
		'Substract':  1,
		'Difference': 2,
		'Multiply':   3,
		'Divide':     4,
		'Minimum':    5,
		'Maximum':    6
	}

	tex_name= "TexCompMax_%s"%(params['name'])

	ofile.write("\nTexCompMax %s {" % tex_name)
	ofile.write("\n\tsourceA= %s;" % params['sourceA'])
	ofile.write("\n\tsourceB= %s;" % params['sourceB'])
	ofile.write("\n\toperator= %d;" % OPERATOR[params['operator']])
	ofile.write("\n}\n")

	return tex_name


def write_TexFresnel(ofile, sce, ma, ma_name, textures):
	tex_name= "TexFresnel_%s"%(ma_name)

	ofile.write("\nTexFresnel %s {" % tex_name)
	if 'reflect' in textures:
		ofile.write("\n\tblack_color= %s;" % textures['reflect'])
	else:
		ofile.write("\n\tblack_color= %s;" % a(sce,"AColor(%.6f, %.6f, %.6f, 1.0)"%(tuple([1.0 - c for c in ma.vray_reflect_color]))))
	ofile.write("\n\tfresnel_ior= %s;" % a(sce,ma.vray.BRDFVRayMtl.fresnel_ior))
	ofile.write("\n}\n")

	return tex_name


def write_TexInvert(bus):
	ofile= bus['files']['textures']

	tex_name= "TI%s" % bus['mtex']['name']

	ofile.write("\nTexInvert %s {" % tex_name)
	ofile.write("\n\ttexture= %s;" % bus['mtex']['name'])
	ofile.write("\n}\n")

	return tex_name


def write_texture(bus):
	scene   = bus['scene']
	texture = bus['mtex']['texture']

	if not append_unique(bus['cache']['textures'], bus['mtex']['name']):
		if not 'env' in bus['mtex']:
			if 'material' in bus:
				bus['material']['normal_uvwgen'] = bus['cache']['uvwgen'].get(bus['mtex']['name'], bus['defaults']['uvwgen'])
		return bus['mtex']['name']

	if texture.use_nodes:
		return write_node_texture(bus)

	if texture.type == 'IMAGE':
		return PLUGINS['TEXTURE']['TexBitmap'].write(bus)

	elif texture.type == 'VOXEL_DATA':
		return bus['mtex']['name']

	elif texture.type == 'VRAY':
		VRayTexture = texture.vray

		if VRayTexture.type == 'NONE':
			return None

		return PLUGINS['TEXTURE'][VRayTexture.type].write(bus)

	else:
		debug(scene, "Texture \"%s\": \'%s\' type is not supported." % (texture.name, texture.type), error=True)
		return None



'''
  TEXTURE STACK

  Stack naming:
    BAbase_name+TEtexture_name+IDtexture_id_in_stack+PLplugin
  like:
    MAmaterial+TEtexture+IDtexture_id_in_stack
  or:
    LAlamp+TEtexture+IDtexture_id_in_stack
'''
def write_factor(bus):
	ofile=   bus['files']['textures']
	scene=   bus['scene']

	texture= bus['mtex']['texture']
	factor=  bus['mtex']['factor']

	if factor == 1.0:
		return bus['mtex']['name']

	tex_name= "TF%sF%s" % (bus['mtex']['name'], clean_string("%.3f" % factor))

	if factor > 1.0:
		if 0:
			ofile.write("\nTexOutput %s {" % tex_name)
			ofile.write("\n\ttexmap= %s;" % bus['mtex']['name'])
			ofile.write("\n\tcolor_mult= %s;" % a(scene, "AColor(%.3f,%.3f,%.3f,1.0)" % tuple([factor]*3)))
			ofile.write("\n}\n")
		else:
			ofile.write("\nTexAColorOp %s {" % tex_name)
			ofile.write("\n\tcolor_a= %s;" % bus['mtex']['name'])
			ofile.write("\n\tmult_a= %s;" % a(scene, factor))
			ofile.write("\n}\n")
	else:
		ofile.write("\nTexAColorOp %s {" % tex_name)
		ofile.write("\n\tcolor_a= %s;" % bus['mtex']['name'])
		ofile.write("\n\tmult_a= 1.0;")
		ofile.write("\n\tresult_alpha= %s;" % a(scene, factor))
		ofile.write("\n}\n")

	return tex_name


def stack_write_texture(bus):
	slot=    bus['mtex']['slot']
	texture= bus['mtex']['texture']
	mapto=   bus['mtex']['mapto']

	VRayTexture= texture.vray
	VRaySlot=    texture.vray_slot

	bus['mtex']['name']= write_factor(bus)

	# IMPROVE: Bump invert button quick fix
	# There is no invert control for bump
	# so use normal
	if mapto == 'bump':
		mapto = 'normal'

	mapto_invert= 'map_%s_invert' % mapto
	if hasattr(VRaySlot, mapto_invert):
		if getattr(VRaySlot, mapto_invert):
			bus['mtex']['name']= write_TexInvert(bus)

	return bus['mtex']['name']


def remove_alpha(bus):
	ofile=   bus['files']['textures']
	scene=   bus['scene']

	texture= bus['mtex']['texture']

	tex_name= "NOALPHA%s" % (bus['mtex']['name'])

	ofile.write("\nTexAColorOp %s {" % tex_name)
	ofile.write("\n\tcolor_a= %s;" % bus['mtex']['name'])
	ofile.write("\n\tmult_a= 1.0;")
	ofile.write("\n\tresult_alpha= 1.0;")
	ofile.write("\n}\n")

	return tex_name


def write_sub_texture(bus, mtex):
	# Store mtex context
	context_mtex = bus['mtex']

	bus['mtex'] = mtex

	tex_name = write_texture(bus)

	# Restore mtex context
	bus['mtex'] = context_mtex

	return tex_name


def write_sub_textures(bus, rna_pointer, params):
	mapped_params= {}
	for key in params:
		sub_tex_name= getattr(rna_pointer, key)
		if sub_tex_name:
			scene= bus['scene']

			sub_tex= get_data_by_name(scene, 'textures', sub_tex_name)

			if sub_tex:
				texture= bus['mtex']['texture']

				mtex= {}
				mtex['mapto']=   key
				mtex['slot']=    None
				mtex['texture']= sub_tex
				mtex['factor']=  1.0
				mtex['name']=    clean_string("TE%sST%s" % (texture.name,
															sub_tex.name))

				mapped_params[key]= write_sub_texture(bus, mtex)
	return mapped_params


'''
  TEXTURE STACK
'''
def stack_write_TexLayered(bus, layers):
	if len(layers) == 1:
		return layers[0][0]

	ofile= bus['files']['textures']

	BLEND_MODES= {
		'NONE':         '0',
		'STENCIL':      '1',
		'OVER':         '1',
		'IN':           '2',
		'OUT':          '3',
		'ADD':          '4',
		'SUBTRACT':     '5',
		'MULTIPLY':     '6',
		'DIFFERENCE':   '7',
		'LIGHTEN':      '8',
		'DARKEN':       '9',
		'SATURATE':    '10',
		'DESATUREATE': '11',
		'ILLUMINATE':  '12',
	}

	tex_name= 'TL%s' % (''.join([l[0] for l in layers[1:]]))

	if not append_unique(bus['cache']['textures'], tex_name):
		return tex_name

	ofile.write("\nTexLayered %s {" % tex_name)
	ofile.write("\n\ttextures= List(%s);" % (','.join([l[0] for l in layers])))
	ofile.write("\n\tblend_modes= List(%s);" % (','.join([BLEND_MODES[l[1]] for l in layers])))
	ofile.write("\n}\n")

	return tex_name


def stack_write_TexMix(bus, color1, color2, blend_amount):
	ofile= bus['files']['textures']

	tex_name= 'TM%s%s%s' % (color1, color2, blend_amount)

	if not append_unique(bus['cache']['textures'], tex_name):
		return tex_name

	ofile.write("\nTexMix %s {" % tex_name)
	ofile.write("\n\tcolor1= %s;" % color1)
	ofile.write("\n\tcolor2= %s;" % color2)
	ofile.write("\n\tmix_amount= 1.0;")
	ofile.write("\n\tmix_map= %s;" % blend_amount)
	ofile.write("\n}\n")

	return tex_name


def stack_write_textures(bus, layer):
	ofile= bus['files']['textures']
	if type(layer) is dict:
		color_a= stack_write_textures(bus, layer['color_a'])
		color_b= stack_write_textures(bus, layer['color_b'])
		layer_name= stack_write_TexMix(bus, color_a, color_b, layer['blend_amount'])
	elif type(layer) is list:
		layer_name= stack_write_TexLayered(bus, layer)
	return layer_name


def stack_collapse_layers(slots):
	layers= []
	for i,slot in enumerate(slots):
		(texture, stencil, blend_mode)= slot
		if stencil:
			color_a= layers
			color_b= stack_collapse_layers(slots[i+1:])
			if len(color_a) and len(color_b):
				return {'color_a': color_a,
						'color_b': color_b,
						'blend_amount': texture}
		layers.append( (texture, blend_mode) )
	return layers


def write_TexOutput(bus, texmap, mapto):
	ofile = bus['files']['textures']
	scene = bus['scene']

	VRayScene = scene.vray

	if VRayScene.RTEngine.enabled and VRayScene.RTEngine.use_opencl:
		return texmap

	tex_name = "MAPTO%sTE%s" % (mapto, texmap)

	if not append_unique(bus['cache']['textures'], tex_name):
		return tex_name

	ofile.write("\nTexOutput %s {" % tex_name)
	ofile.write("\n\ttexmap=%s;" % texmap)
	ofile.write("\n}\n")

	return tex_name



'''
  NODE TEXTURE
'''
def write_TextureNodeInvert(bus, node, node_params):
	ofile= bus['files']['textures']
	scene= bus['scene']

	node_tree= bus['tex_nodes']['node_tree']

	if 'Color' not in node_params:
		return None

	tex_name= "TI%s" % node_params['Color']

	ofile.write("\nTexInvert %s {" % tex_name)
	ofile.write("\n\ttexture= %s;" % node_params['Color'])
	ofile.write("\n}\n")

	return tex_name


def write_TextureNodeTexture(bus, node, input_params):
	node_tree= bus['tex_nodes']['node_tree']

	mtex = {}
	mtex['mapto']   = 'node'
	mtex['slot']    = None
	mtex['texture'] = node.texture
	mtex['factor']  = 1.0
	mtex['name']    = clean_string("NT%sNO%sTE%s" % (node_tree.name,
													 node.name,
													 node.texture.name))

	tex_name = write_sub_texture(bus, mtex)

	return tex_name


def write_TextureNodeMixRGB(bus, node, input_params):
	ofile= bus['files']['textures']
	scene= bus['scene']

	node_tree= bus['tex_nodes']['node_tree']

	params= {
		'Color1': "",
		'Color2': "",
		'Factor': "",
	}

	for key in params:
		# Key is mapped in input_params
		if key in input_params:
			params[key] = input_params[key]

		# Use node color values
		else:
			if key in ['Color1', 'Color2']:
				c = node.inputs[key].default_value
				params[key] = write_TexAColor(bus, key, node, mathutils.Color((c[0],c[1],c[2])))
			elif key == 'Factor':
				params[key] = write_TexAColor(bus, key, node, mathutils.Color([node.inputs[key].default_value]*3))

	return stack_write_TexMix(bus, params['Color1'], params['Color2'], params['Factor'])


def write_TextureNodeOutput(bus, node, input_params):
	ofile= bus['files']['textures']
	scene= bus['scene']

	params= {
		'Color': "",
	}

	if 'Color' not in input_params:
		c = node.inputs['Color'].default_value
		params['Color'] = write_TexAColor(bus, 'Color', node, mathutils.Color((c[0],c[1],c[2])))
	else:
		params['Color'] = input_params['Color']

	ofile.write("\nTexOutput %s {" % bus['mtex']['name'])
	ofile.write("\n\ttexmap= %s;" % params['Color'])
	ofile.write("\n}\n")

	return bus['mtex']['name']


def write_texture_node(bus, node_tree, node):
	ofile= bus['files']['textures']
	scene= bus['scene']

	VRayScene=      scene.vray
	VRayExporter=   VRayScene.exporter

	node_params= {}

	for input_socket in node.inputs:
		input_node = connected_node(node_tree, input_socket)

		if not input_node:
			continue

		value = write_texture_node(bus, node_tree, input_node)

		if value is not None:
			node_params[input_socket.name]= value

	if VRayExporter.debug:
		print_dict(scene, "Node \"%s\"" % (node.name), node_params)

	if node.type == 'MIX_RGB':
		return write_TextureNodeMixRGB(bus, node, node_params)

	elif node.type == 'OUTPUT':
		return write_TextureNodeOutput(bus, node, node_params)

	elif node.type == 'TEXTURE':
		return write_TextureNodeTexture(bus, node, node_params)

	elif node.type == 'INVERT':
		return write_TextureNodeInvert(bus, node, node_params)

	else:
		return None

	return None


def write_node_texture(bus):
	ofile= bus['files']['textures']
	scene= bus['scene']

	ob=    bus['node']['object']
	base=  bus['node']['base']

	tex=  bus['mtex'].get('texture')
	slot= bus['mtex'].get('slot')

	VRayScene=    scene.vray
	VRayExporter= VRayScene.exporter

	node_tree= tex.node_tree

	output_node_name = None
	if slot and slot.output_node != 'NOT_SPECIFIED':
		output_node_name = slot.output_node

	output_node= get_output_node(node_tree, output_node_name)

	if output_node:
		if VRayExporter.debug:
			debug(scene, "Processing node texture \"%s\":" % (tex.name))

		bus['tex_nodes']= {}
		bus['tex_nodes']['node_tree']= node_tree

		return write_texture_node(bus, node_tree, output_node)

	return None


def write_material_textures(bus):
	ofile= bus['files']['materials']
	scene= bus['scene']
	ma=    bus['material']['material']

	VRayScene=    scene.vray
	VRayExporter= VRayScene.exporter

	VRayMaterial= ma.vray

	mapped_params= PLUGINS['BRDF'][VRayMaterial.type].mapto(bus)

	# Mapped parameters
	bus['textures']= {}

	for i,slot in enumerate(ma.texture_slots):
		if ma.use_textures[i] and slot and slot.texture and (slot.texture.type in TEX_TYPES or slot.texture.use_nodes):
			VRaySlot=    slot.texture.vray_slot
			VRayTexture= slot.texture.vray

			for key in mapped_params:
				if key == 'bump' or getattr(VRaySlot, "map_%s" % (key)):
					factor = getattr(VRaySlot, "%s_mult" % ('normal' if key == 'bump' else key))
					mapto  = key

					if mapto == 'normal' and getattr(VRaySlot, "map_normal") and VRaySlot.BRDFBump.map_type == 'BUMP':
						continue

					if mapto == 'bump' and not (getattr(VRaySlot, "map_normal") and VRaySlot.BRDFBump.map_type == 'BUMP'):
						continue

					if mapto not in bus['textures']: # If texture is first in stack
						bus['textures'][mapto]= []
						# If this texture will be blended over some value
						# we need to add this value
						# (for example, texture blended over diffuse color)
						if factor < 1.0 or VRaySlot.blend_mode != 'NONE' or slot.use_stencil:
							bus['textures'][mapto].append(mapped_params[mapto])

					# Store slot for GeomDisplaceMesh
					if mapto == 'displacement':
						bus['node']['displacement_slot'] = slot
					# Store slot for bump
					elif mapto == 'bump':
						bus['material']['bump_slot'] = slot
					# Store slot for normal
					elif mapto == 'normal':
						bus['material']['normal_slot'] = slot

					bus['mtex']            = {}
					bus['mtex']['slot']    = slot
					bus['mtex']['texture'] = slot.texture
					bus['mtex']['mapto']   = mapto
					bus['mtex']['factor']  = factor

					# Check if we could improve this
					# Better handling of texture blending
					bus['mtex']['name']= clean_string("MA%sMT%.2iTE%s" % (ma.name, i, slot.texture.name))

					if VRayTexture.texture_coords == 'ORCO':
						bus['material']['orco_suffix']= get_name(get_orco_object(scene, bus['node']['object'], VRayTexture),
																 prefix='ORCO')

						bus['mtex']['name']+= bus['material']['orco_suffix']

					if VRayExporter.debug:
						print_dict(scene, "bus['mtex']", bus['mtex'])

					# Write texture
					if write_texture(bus):
						# Append texture to stack and write texture with factor
						bus['textures'][mapto].append( [stack_write_texture(bus),
														slot.use_stencil,
														VRaySlot.blend_mode] )

	if VRayExporter.debug:
		if len(bus['textures']):
			print_dict(scene, "Material \"%s\" texture stack" % ma.name, bus['textures'])

	# Collapsing texture stack
	del_keys= []
	for key in bus['textures']:
		if len(bus['textures'][key]):
			if len(bus['textures'][key]) == 1 and type(bus['textures'][key][0]) is tuple:
				del_keys.append(key)
			else:
				bus['textures'][key]= write_TexOutput(bus, stack_write_textures(bus, stack_collapse_layers(bus['textures'][key])), key)

	for key in del_keys:
		del bus['textures'][key]

	if 'displacement' in bus['textures']:
		bus['node']['displacement_texture']= bus['textures']['displacement']

	if VRayExporter.debug:
		if len(bus['textures']):
			print_dict(scene, "Material \"%s\" textures" % ma.name, bus['textures'])

	return bus['textures']


def write_subtexture(bus, tex_name):
	if not tex_name in bpy.data.textures:
		return None

	context_mtex= None
	if 'mtex' in bus:
		# Store mtex context
		context_mtex= bus['mtex']

	# Prepare data
	bus['mtex']= {}
	bus['mtex']['env']=     True # This is needed!
	bus['mtex']['slot']=    None
	bus['mtex']['texture']= bpy.data.textures[tex_name]
	bus['mtex']['factor']=  1.0
	bus['mtex']['mapto']=   None
	bus['mtex']['name']=    clean_string("TE%s"%(tex_name))

	# Write texture
	texture_name= write_texture(bus)

	# Restore mtex context
	bus['mtex']= context_mtex

	return texture_name

########NEW FILE########
__FILENAME__ = properties_data_camera
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy

''' vb modules '''
from vb25.utils import *
from vb25.ui.ui import *


class VRAY_DP_camera(VRayDataPanel, bpy.types.Panel):
	bl_label = "Parameters"

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		return (context.camera and engine_poll(__class__, context))

	def draw(self, context):
		layout= self.layout

		ca= context.camera

		VRayScene = context.scene.vray

		RenderView = VRayScene.RenderView
		VRayCamera = ca.vray

		SettingsCamera=     VRayCamera.SettingsCamera
		SettingsCameraDof=  VRayCamera.SettingsCameraDof
		SettingsMotionBlur= VRayCamera.SettingsMotionBlur
		CameraPhysical=     VRayCamera.CameraPhysical

		wide_ui= context.region.width > narrowui

		if wide_ui:
			layout.prop(ca, 'type', expand=True)
		else:
			layout.prop(ca, 'type', text="")
		layout.separator()

		split= layout.split()
		col= split.column()
		if ca.type == 'PERSP':
			col.prop(VRayCamera, 'override_fov')
			if wide_ui:
				col= split.column()
			if VRayCamera.override_fov: col.prop(VRayCamera, 'fov')

			split= layout.split()
			split.active= not VRayCamera.override_fov
			col= split.column()
			if ca.lens_unit == 'MILLIMETERS':
				col.prop(ca, 'lens', text="Angle")
			else:
				col.prop(ca, 'angle')
			if wide_ui:
				col= split.column()
			col.prop(ca, 'lens_unit', text="")

		layout.separator()

		if ca.type == 'ORTHO':
			col.prop(ca, 'ortho_scale')
		else:
			split= layout.split()
			col= split.column()
			col.label(text="Type:")
			col= split.column()
			col.prop(SettingsCamera, 'type', text="")

			layout.separator()

		'''
			SettingsCamera
		'''
		# SMTH

		'''
			SettingsCameraDof
		'''
		# split= layout.split()
		# col= split.column()
		# col= split.column()
		
		layout.label(text="Clipping:")
		split = layout.split()
		col = split.column()
		col.prop(RenderView, 'clip_near')
		sub = col.column()
		sub.active = RenderView.clip_near
		sub.prop(ca, 'clip_start', text="Near")
		if wide_ui:
			col = split.column()
		col.prop(RenderView, 'clip_far')
		sub = col.column()
		sub.active = RenderView.clip_far
		sub.prop(ca, 'clip_end', text="Far")

		split= layout.split()
		split.label(text="Depth of Field:")
		split= layout.split()
		col= split.column(align=True)
		col.prop(ca, 'dof_distance', text="Distance")
		if wide_ui:
			col= split.column()
		col.prop(ca, 'dof_object', text="")

		layout.separator()

		'''
			SettingsMotionBlur
		'''
		box = layout.box()
		box.prop(SettingsMotionBlur, 'on')
		if SettingsMotionBlur.on:
			box.prop(SettingsMotionBlur, 'camera_motion_blur')

			col = box.column(align=True)
			col.prop(SettingsMotionBlur, 'duration')
			col.prop(SettingsMotionBlur, 'interval_center')

			row = box.row(align=True)
			row.prop(SettingsMotionBlur, 'bias')
			row.prop(SettingsMotionBlur, 'subdivs')

			row = box.row(align=True)
			row.prop(SettingsMotionBlur, 'shutter_efficiency')

			row = box.row(align=True)
			row.prop(SettingsMotionBlur, 'low_samples')
			row.prop(SettingsMotionBlur, 'geom_samples', text="Geom Samples")

		split= layout.split()
		col= split.column()
		col.prop(VRayCamera, 'use_camera_loop')


class VRAY_DP_physical_camera(VRayDataPanel, bpy.types.Panel):
	bl_label   = "Physical"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		return (context.camera and engine_poll(__class__, context))

	def draw_header(self, context):
		ca= context.camera
		VRayCamera= ca.vray
		CameraPhysical= VRayCamera.CameraPhysical
		self.layout.label(text="", icon='VRAY_LOGO_MONO')
		self.layout.prop(CameraPhysical, 'use', text="")

	def draw(self, context):
		wide_ui= context.region.width > narrowui

		ca= context.camera
		VRayCamera= ca.vray
		CameraPhysical= VRayCamera.CameraPhysical

		layout= self.layout
		layout.active= CameraPhysical.use

		split= layout.split()
		col= split.column()
		col.prop(CameraPhysical, 'type', text="Type")

		split= layout.split()
		col= split.column()
		col.label(text="Parameters:")

		split= layout.split()
		col= split.column()
		sub= col.column(align=True)
		sub.prop(CameraPhysical, 'specify_fov', text="Use FOV")
		if not CameraPhysical.specify_fov:
			sub.prop(CameraPhysical, 'film_width')
			sub.prop(CameraPhysical, 'focal_length')
			sub.prop(CameraPhysical, 'zoom_factor')

		sub= col.column(align=True)
		sub.prop(CameraPhysical, 'distortion')
		if not CameraPhysical.guess_lens_shift:
			sub.prop(CameraPhysical, 'lens_shift')
			sub.operator('vray.lens_shift')
		sub.prop(CameraPhysical, 'guess_lens_shift')

		if wide_ui:
			col= split.column(align=True)

		col.prop(CameraPhysical, 'exposure')
		if CameraPhysical.exposure:
			col.prop(CameraPhysical, 'f_number')
			col.prop(CameraPhysical, 'shutter_speed')
			if CameraPhysical.type == 'CINEMATIC':
				col.prop(CameraPhysical, 'shutter_angle')
				col.prop(CameraPhysical, 'shutter_offset')
			elif CameraPhysical.type == 'VIDEO':
				col.prop(CameraPhysical, 'latency')
			col.prop(CameraPhysical, 'ISO')

		split= layout.split()
		col= split.column()
		col.label(text="White balance:")
		sub= col.row(align= True)
		sub.prop(CameraPhysical, 'white_balance', text="")
		sub.operator('vray.set_kelvin_color', text="", icon= 'COLOR', emboss= False).data_path= "object.data.vray.CameraPhysical.white_balance"

		if wide_ui:
			col= split.column()

		col.prop(CameraPhysical, 'vignetting', slider= True)

		layout.label(text="Offset:")
		split= layout.split()
		sub = split.row(align=True)
		sub.prop(ca, 'shift_x', text="X")
		sub.prop(ca, 'shift_y', text="Y")

		split= layout.split()
		colL= split.column()
		colL.label(text="Sampling:")

		split= layout.split()
		colL= split.column()
		colR= split.column(align=True)

		colL.prop(CameraPhysical, 'use_dof')
		colL.prop(CameraPhysical, 'use_moblur')

		if CameraPhysical.use_dof:
			colR.prop(CameraPhysical, 'blades_enable')

		if CameraPhysical.use_moblur or CameraPhysical.use_dof:
			colL.prop(CameraPhysical, 'subdivs')

			if CameraPhysical.use_dof and CameraPhysical.blades_enable:
				colR.prop(CameraPhysical, 'blades_num')
				colR.prop(CameraPhysical, 'blades_rotation')
				colR.prop(CameraPhysical, 'center_bias')
				colR.prop(CameraPhysical, 'anisotropy')


class VRAY_DP_camera_stereoscopic(VRayDataPanel, bpy.types.Panel):
	bl_label   = "Stereoscopic"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		VRayStereoscopicSettings = context.scene.vray.VRayStereoscopicSettings
		return (context.camera and engine_poll(__class__, context)  and VRayStereoscopicSettings.use)

	def draw_header(self, context):
		ca = context.camera
		VRayCamera = ca.vray
		CameraStereoscopic = VRayCamera.CameraStereoscopic

		# RADIOBUT_OFF RADIOBUT_ON
		if CameraStereoscopic.use:
			icon_name = "CHECKBOX_HLT"
		else:
			icon_name = "CHECKBOX_DEHLT"

		self.layout.label(text="", icon='VRAY_LOGO_MONO')
		self.layout.operator('vray.create_stereo_cam', text="", icon=icon_name, emboss=False)

	def draw(self, context):
		wide_ui = context.region.width > narrowui

		ca = context.camera
		VRayCamera = ca.vray
		CameraStereoscopic = VRayCamera.CameraStereoscopic

		layout = self.layout
		layout.active = CameraStereoscopic.use

		split= layout.split()
		col= split.column()
		sub= col.column(align=True)
		sub.prop(CameraStereoscopic, 'stereo_base', text="Eye Distance")
		sub.prop(CameraStereoscopic, 'stereo_distance', text="Fov Distance")
		sub.prop(CameraStereoscopic, 'use_convergence', text="Use convergence")
		sub.prop(CameraStereoscopic, 'show_cams', text="Show L/R cameras")
		if CameraStereoscopic.show_cams:
			sub.prop(CameraStereoscopic, 'show_limits', text="Show Limits")


class VRAY_DP_hide_from_view(VRayDataPanel, bpy.types.Panel):
	bl_label   = "Hide objects"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		return (context.camera and engine_poll(__class__, context))

	def draw_header(self, context):
		ca= context.camera
		VRayCamera= ca.vray
		self.layout.label(text="", icon='VRAY_LOGO_MONO')
		self.layout.prop(VRayCamera, 'hide_from_view', text="")

	def draw(self, context):
		wide_ui= context.region.width > narrowui

		ca= context.camera
		VRayCamera= ca.vray

		layout= self.layout
		layout.active= VRayCamera.hide_from_view

		split= layout.split()
		col= split.column()
		col.prop(VRayCamera, 'hf_all', text="Completely")
		if VRayCamera.hf_all:
			split= layout.split(percentage=0.2)
			col= split.column()
			col.prop(VRayCamera, 'hf_all_auto', text="Auto")
			sub= split.column()
			sub.active= not VRayCamera.hf_all_auto
			sub.prop_search(VRayCamera, 'hf_all_objects',  context.scene, 'objects')
			sub.prop_search(VRayCamera, 'hf_all_groups',   bpy.data,      'groups')

			layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(VRayCamera, 'hf_camera', text="From camera")
		if VRayCamera.hf_camera:
			split= layout.split(percentage=0.2)
			col= split.column()
			col.prop(VRayCamera, 'hf_camera_auto', text="Auto")
			sub= split.column()
			sub.active= not VRayCamera.hf_camera_auto
			sub.prop_search(VRayCamera, 'hf_camera_objects',  context.scene, 'objects')
			sub.prop_search(VRayCamera, 'hf_camera_groups',   bpy.data,      'groups')

			layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(VRayCamera, 'hf_gi', text="From GI")
		if VRayCamera.hf_gi:
			split= layout.split(percentage=0.2)
			col= split.column()
			col.prop(VRayCamera, 'hf_gi_auto', text="Auto")
			sub= split.column()
			sub.active= not VRayCamera.hf_gi_auto
			sub.prop_search(VRayCamera, 'hf_gi_objects',  context.scene, 'objects')
			sub.prop_search(VRayCamera, 'hf_gi_groups',   bpy.data,      'groups')

			layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(VRayCamera, 'hf_reflect', text="From reflections")
		if VRayCamera.hf_reflect:
			split= layout.split(percentage=0.2)
			col= split.column()
			col.prop(VRayCamera, 'hf_reflect_auto', text="Auto")
			sub= split.column()
			sub.active= not VRayCamera.hf_reflect_auto
			sub.prop_search(VRayCamera, 'hf_reflect_objects',  context.scene, 'objects')
			sub.prop_search(VRayCamera, 'hf_reflect_groups',   bpy.data,      'groups')

			layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(VRayCamera, 'hf_refract', text="From refractions")
		if VRayCamera.hf_refract:
			split= layout.split(percentage=0.2)
			col= split.column()
			col.prop(VRayCamera, 'hf_refract_auto', text="Auto")
			sub= split.column()
			sub.active= not VRayCamera.hf_refract_auto
			sub.prop_search(VRayCamera, 'hf_refract_objects',  context.scene, 'objects')
			sub.prop_search(VRayCamera, 'hf_refract_groups',   bpy.data,      'groups')

			layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(VRayCamera, 'hf_shadows', text="From shadows")
		if VRayCamera.hf_shadows:
			split= layout.split(percentage=0.2)
			col= split.column()
			col.prop(VRayCamera, 'hf_shadows_auto', text="Auto")
			sub= split.column()
			sub.active= not VRayCamera.hf_shadows_auto
			sub.prop_search(VRayCamera, 'hf_shadows_objects',  context.scene, 'objects')
			sub.prop_search(VRayCamera, 'hf_shadows_groups',   bpy.data,      'groups')


def GetRegClasses():
	return (
		VRAY_DP_camera,
		VRAY_DP_physical_camera,
		VRAY_DP_camera_stereoscopic,
		VRAY_DP_hide_from_view,
	)


def register():
	from bl_ui import properties_data_camera
	properties_data_camera.DATA_PT_context_camera.COMPAT_ENGINES.add('VRAY_RENDER')
	properties_data_camera.DATA_PT_context_camera.COMPAT_ENGINES.add('VRAY_RENDER_PREVIEW')
	properties_data_camera.DATA_PT_camera_display.COMPAT_ENGINES.add('VRAY_RENDER')
	properties_data_camera.DATA_PT_camera_display.COMPAT_ENGINES.add('VRAY_RENDER_PREVIEW')
	del properties_data_camera

	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	from bl_ui import properties_data_camera
	try:
		properties_data_camera.DATA_PT_context_camera.COMPAT_ENGINES.remove('VRAY_RENDER')
		properties_data_camera.DATA_PT_context_camera.COMPAT_ENGINES.remove('VRAY_RENDER_PREVIEW')
		properties_data_camera.DATA_PT_camera_display.COMPAT_ENGINES.remove('VRAY_RENDER')
		properties_data_camera.DATA_PT_camera_display.COMPAT_ENGINES.remove('VRAY_RENDER_PREVIEW')
	except:
		pass
	del properties_data_camera

	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = properties_data_empty
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy

''' vb modules '''
from vb25.utils import *
from vb25.ui.ui import *


class VRAY_DP_empty(VRayDataPanel, bpy.types.Panel):
    bl_label   = "Override"
    bl_options = {'DEFAULT_CLOSED'}

    COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

    @classmethod
    def poll(cls, context):
        return (context.object and context.object.type == 'EMPTY' and engine_poll(__class__, context))

    def draw(self, context):
        wide_ui = context.region.width > narrowui
        layout  = self.layout
        
        VRayObject = context.object.vray

        box = layout.box()

        box.prop(VRayObject, 'overrideWithScene')

        if VRayObject.overrideWithScene:
            split = box.split()
            col = split.column()
            col.prop(VRayObject, 'sceneFilepath')
            col.prop(VRayObject, 'sceneDirpath')
            
            split = box.split()
            col = split.column()
            col.prop(VRayObject, 'sceneReplace')
            col.prop(VRayObject, 'sceneUseTransform')
            
            split = box.split()
            col = split.column()
            col.prop(VRayObject, 'sceneAddNodes')
            col.prop(VRayObject, 'sceneAddMaterials')
            col.prop(VRayObject, 'sceneAddLights')
            if wide_ui:
                col = split.column()
            col.prop(VRayObject, 'sceneAddCameras')
            col.prop(VRayObject, 'sceneAddEnvironment')


def GetRegClasses():
    return (
        VRAY_DP_empty,
    )


def register():
    for regClass in GetRegClasses():
        bpy.utils.register_class(regClass)


def unregister():
    for regClass in GetRegClasses():
        bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = properties_data_geometry
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy

''' vb modules '''
from vb25.ui.ui import *


def GetContextData(context):
	if context.active_object.type == 'MESH':
		return context.mesh
	else:
		return context.curve
	return data


class VRAY_DP_override(VRayDataPanel, bpy.types.Panel):
	bl_label   = "Options"
	bl_options = {'DEFAULT_CLOSED'}

	def draw(self, context):
		wide_ui = context.region.width > narrowui
		layout  = self.layout

		data = GetContextData(context)

		VRayMesh = data.vray
		GeomStaticMesh = VRayMesh.GeomStaticMesh

		layout.prop(VRayMesh, 'override')

		if VRayMesh.override:
			split = layout.split()
			row = split.row()
			row.prop(VRayMesh, 'override_type', expand=True)

			if VRayMesh.override_type == 'VRAYPROXY':
				GeomMeshFile = VRayMesh.GeomMeshFile

				split = layout.split()
				col = split.column()
				col.prop(GeomMeshFile, 'file')
				col.prop(GeomMeshFile, 'anim_type')

				split = layout.split()
				col = split.column(align=True)
				col.prop(GeomMeshFile, 'anim_speed')
				if wide_ui:
					col = split.column()
				col.prop(GeomMeshFile, 'anim_offset')

				layout.separator()
				layout.operator('vray.proxy_load_preview', icon='OUTLINER_OB_MESH', text="Load Preview Mesh")

		else:
			layout.prop(GeomStaticMesh, 'dynamic_geometry')


class VRAY_DP_tools(VRayDataPanel, bpy.types.Panel):
	bl_label   = "Tools"
	bl_options = {'DEFAULT_CLOSED'}

	def draw(self, context):
		wide_ui= context.region.width > narrowui

		layout= self.layout

		data = GetContextData(context)

		VRayMesh=     data.vray
		GeomMeshFile= VRayMesh.GeomMeshFile

		layout.label(text="Generate VRayProxy:")

		split= layout.split()
		col= split.column()
		col.prop(GeomMeshFile, 'dirpath')
		col.prop(GeomMeshFile, 'filename')
		col.separator()
		col.prop(GeomMeshFile, 'mode', text="Attach mode")

		split= layout.split()
		col= split.column()
		col.prop(GeomMeshFile, 'animation')
		sub= col.column()
		sub.active= GeomMeshFile.animation
		sub.prop(GeomMeshFile, 'add_velocity')
		sub.prop(GeomMeshFile, 'animation_range', text="Range")
		if GeomMeshFile.animation_range == 'MANUAL':
			sub= sub.column(align=True)
			sub.prop(GeomMeshFile, 'frame_start')
			sub.prop(GeomMeshFile, 'frame_end')
		if wide_ui:
			col= split.column()
		col.prop(GeomMeshFile, 'add_suffix')
		col.prop(GeomMeshFile, 'apply_transforms')

		layout.separator()

		split= layout.split()
		col= split.column()
		col.operator('vray.create_proxy', icon='OUTLINER_OB_MESH')


def GetRegClasses():
	return (
		VRAY_DP_override,
		VRAY_DP_tools,
	)


def register():
	from bl_ui import properties_data_mesh
	for member in dir(properties_data_mesh):
		subclass= getattr(properties_data_mesh, member)
		try:
			subclass.COMPAT_ENGINES.add('VRAY_RENDER')
			subclass.COMPAT_ENGINES.add('VRAY_RENDER_PREVIEW')
		except:
			pass
	del properties_data_mesh

	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	from bl_ui import properties_data_mesh
	for member in dir(properties_data_mesh):
		subclass= getattr(properties_data_mesh, member)
		try:
			subclass.COMPAT_ENGINES.remove('VRAY_RENDER')
			subclass.COMPAT_ENGINES.remove('VRAY_RENDER_PREVIEW')
		except:
			pass
	del properties_data_mesh

	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = properties_data_lamp
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''

''' Blender modules '''
import bpy

''' vb modules '''
from vb25.utils import *
from vb25.ui.ui import *


def LampCouldBeVisible(lamp):
	if lamp.type == 'AREA':
		return True
	if lamp.type == 'POINT':
		if lamp.vray.radius:
			return True
		return False
	if lamp.type == 'HEMI':
		return True
	return False


class VRAY_DP_context_lamp(VRayLampPanel, bpy.types.Panel):
	bl_label       = ""
	bl_options     = {'HIDE_HEADER'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw(self, context):
		layout= self.layout

		ob= context.object
		lamp= context.lamp
		space= context.space_data
		wide_ui= context.region.width > narrowui

		if wide_ui:
			split= layout.split(percentage=0.65)
			if ob:
				split.template_ID(ob, 'data')
				split.separator()
			elif lamp:
				split.template_ID(space, 'pin_id')
				split.separator()
		else:
			if ob:
				layout.template_ID(ob, 'data')
			elif lamp:
				layout.template_ID(space, 'pin_id')

		if wide_ui:
			layout.prop(lamp, 'type', expand=True)
		else:
			layout.prop(lamp, 'type')


class VRAY_DP_light(VRayLampPanel, bpy.types.Panel):
	bl_label       = "Lamp"

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw(self, context):
		wide_ui= context.region.width > narrowui
		layout= self.layout

		ob= context.object
		lamp= context.lamp
		VRayLamp= lamp.vray

		split= layout.split()
		col= split.column()
		if not (lamp.type == 'AREA' and VRayLamp.lightPortal != 'NORMAL'):
			col.row().prop(VRayLamp, 'color_type', expand=True)
			if wide_ui:
				col= split.column()
			if VRayLamp.color_type == 'RGB':
				sub= col.row(align= True)
				sub.prop(lamp, 'color', text="")
				sub.operator('vray.set_kelvin_color', text="", icon= 'COLOR', emboss= False).data_path= "object.data.color"
			else:
				col.prop(VRayLamp, 'temperature', text="K")

			layout.separator()

		split= layout.split()
		col= split.column()
		if lamp.type == 'AREA':
			col.prop(VRayLamp,'lightPortal', text="Mode")
		if not ((lamp.type == 'SUN' and VRayLamp.direct_type == 'SUN') or (lamp.type == 'AREA' and VRayLamp.lightPortal != 'NORMAL')):
			col.prop(VRayLamp,'units', text="Units")
		if not ((lamp.type == 'SUN' and VRayLamp.direct_type == 'SUN') or (lamp.type == 'AREA' and VRayLamp.lightPortal != 'NORMAL')):
			col.prop(VRayLamp,'intensity', text="Intensity")
		col.prop(VRayLamp,'subdivs')
		col.prop(VRayLamp,'causticSubdivs', text="Caustics")
		col.prop(VRayLamp,'causticMult', text="Caustics Mult")

		if wide_ui:
			col= split.column()

		col.prop(VRayLamp,'enabled', text="On")
		if LampCouldBeVisible(lamp):
			col.prop(VRayLamp,'invisible')
		col.prop(VRayLamp,'affectDiffuse')
		col.prop(VRayLamp,'affectSpecular')
		col.prop(VRayLamp,'affectReflections')
		col.prop(VRayLamp,'noDecay')

		if(lamp.type == 'AREA'):
			col.prop(VRayLamp,'doubleSided')

		if((lamp.type == 'AREA') or (lamp.type == 'POINT' and VRayLamp.radius > 0)):
			col.prop(VRayLamp,'storeWithIrradianceMap')


class VRAY_DP_light_shape(VRayLampPanel, bpy.types.Panel):
	bl_label       = "Shape"

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw(self, context):
		wide_ui= context.region.width > narrowui
		layout= self.layout

		ob        = context.object
		lamp      = context.lamp
		vl        = lamp.vray
		VRayLight = lamp.vray
		VRayScene = context.scene.vray

		if lamp.type == 'AREA':
			layout.prop(lamp,'shape', expand=True)
			layout.separator()
			#  use_rect_tex: bool = false
			#  tex_resolution: integer = 512
			#  tex_adaptive: float = 1

		elif lamp.type == 'SUN':
			layout.prop(vl,'direct_type', expand=True)
			layout.separator()

		elif lamp.type == 'SPOT':
			layout.prop(vl,'spot_type', expand=True)
			layout.separator()

		split= layout.split()
		col= split.column()
		if lamp.type == 'AREA':
			if lamp.shape == 'SQUARE':
				col.prop(lamp,'size')
			else:
				col.prop(lamp,'size', text="Size X")
				if wide_ui:
					col= split.column()
				col.prop(lamp,'size_y')

		elif lamp.type == 'POINT':
			col.row().prop(vl, 'omni_type', expand=True)
			col.separator()
			if vl.omni_type == 'OMNI':
				col.prop(vl,'radius')
				if vl.radius > 0:
					col.prop(vl,'sphere_segments')
			else:
				col.prop(vl, 'decay')
				col.prop(vl, 'ambientShade')

		elif lamp.type == 'SUN':
			if vl.direct_type == 'DIRECT':
				col.prop(vl,'fallsize')
			else:
				split= layout.split()
				col= split.column()
				col.prop(vl,'sky_model')

				split= layout.split()
				col= split.column()
				col.prop(vl,'turbidity')
				col.prop(vl,'ozone')
				col.prop(vl,'intensity_multiplier', text= "Intensity")
				col.prop(vl,'size_multiplier', text= "Size")
				if wide_ui:
					col= split.column()
				col.prop(vl,'horiz_illum')
				col.prop(vl,'water_vapour')

				split= layout.split()
				col= split.column()
				col.operator('vray.add_sky', icon='TEXTURE')

		elif lamp.type == 'SPOT':
			if vl.spot_type == 'SPOT':
				col.prop(lamp,'distance')
				col.prop(vl,'decay')
				if wide_ui:
					col= split.column()
				col.prop(lamp,'spot_size', text="Size")
				col.prop(lamp,'spot_blend', text="Blend")
			else:
				col.prop(vl,'ies_file', text="File")
				layout.separator()

			if vl.spot_type == 'IES':
				split= layout.split()
				col= split.column()
				col.prop(vl,'ies_light_shape')
				sub = col.column()
				sub.active = vl.ies_light_shape
				sub.prop(vl,'ies_light_shape_lock', text="Use width")
				if wide_ui:
					col= split.column()
				sub = col.column()
				sub.active = vl.ies_light_shape
				sub.prop(vl,'ies_light_width')
				if not vl.ies_light_shape_lock:
					sub.prop(vl,'ies_light_length')
					sub.prop(vl,'ies_light_height')
				sub.prop(vl,'ies_light_diameter')


		elif lamp.type == 'HEMI':
			split = layout.split()
			col   = split.column()
			col.prop(VRayLight, 'dome_spherical')

			split = layout.split()
			col   = split.column()
			col.prop(VRayLight, 'dome_rayDistanceMode')
			if wide_ui:
				col= split.column()
			if VRayLight.dome_rayDistanceMode:
				col.prop(VRayLight, 'dome_rayDistance')

			layout.separator()

			split = layout.split()
			col   = split.column()
			col.prop(VRayLight, 'tex_resolution')
			if wide_ui:
				col= split.column()
			col.prop(VRayLight, 'tex_adaptive')

			if VRayScene.SettingsCaustics.on:
				split = layout.split()
				col   = split.column()
				col.prop(VRayLight, 'dome_targetRadius')
				if wide_ui:
					col= split.column()
				col.prop(VRayLight, 'dome_emitRadius')


class VRAY_DP_light_shadows(VRayLampPanel, bpy.types.Panel):
	bl_label   = "Shadows"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw_header(self, context):
		vl= context.lamp.vray
		self.layout.prop(vl,'shadows', text="")

	def draw(self, context):
		wide_ui= context.region.width > narrowui
		layout= self.layout

		ob= context.object
		lamp= context.lamp
		vl= lamp.vray

		layout.active = vl.shadows

		split= layout.split()
		col= split.column()
		col.prop(vl,'shadowColor', text="")
		if lamp.type == 'SUN' and vl.direct_type == 'DIRECT':
			col.prop(vl,'shadowShape', text="Shape")
		if wide_ui:
			col= split.column()
		col.prop(vl,'shadowBias', text="Bias")

		if lamp.type == 'SPOT':
			if vl.spot_type == 'IES':
				col.prop(vl,'soft_shadows')
			else:
				col.prop(vl,'shadowRadius', text="Radius")
		else:
			if lamp.type in ('POINT','SUN'):
				col.prop(vl,'shadowRadius', text="Radius")




class VRAY_DP_light_advanced(VRayLampPanel, bpy.types.Panel):
	bl_label   = "Advanced"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw(self, context):
		wide_ui= context.region.width > narrowui
		layout= self.layout

		ob= context.object
		lamp= context.lamp
		vl= lamp.vray

		split= layout.split()
		col= split.column()
		col.prop(vl,'diffuse_contribution', text="Diffuse cont.")
		col.prop(vl,'specular_contribution', text="Specular cont.")
		col.prop(vl,'cutoffThreshold', text="Cutoff")

		if wide_ui:
			col= split.column()
		col.prop(vl,'nsamples')
		col.prop(vl,'bumped_below_surface_check', text="Bumped surface check")
		col.prop(vl,'ignoreLightNormals')
		col.prop(vl,'areaSpeculars')


class VRAY_DP_include_exclude(VRayLampPanel, bpy.types.Panel):
	bl_label   = "Include / Exclude"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw_header(self, context):
		VRayLamp= context.lamp.vray
		self.layout.prop(VRayLamp, 'use_include_exclude', text="")

	def draw(self, context):
		wide_ui= context.region.width > narrowui
		layout= self.layout

		VRayLamp= context.lamp.vray

		layout.active= VRayLamp.use_include_exclude

		split= layout.split()
		col= split.column()
		col.prop(VRayLamp, 'include_exclude', text="")
		col.prop_search(VRayLamp, 'include_objects',  context.scene, 'objects', text="Objects")
		col.prop_search(VRayLamp, 'include_groups',   bpy.data,      'groups',  text="Groups")


def GetRegClasses():
	return (
		VRAY_DP_context_lamp,
		VRAY_DP_light,
		VRAY_DP_light_shape,
		VRAY_DP_light_shadows,
		VRAY_DP_light_advanced,
		VRAY_DP_include_exclude,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = properties_material
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy

''' vb modules '''
from vb25.utils import *
from vb25.ui.ui import *
from vb25.plugins import *


from bl_ui.properties_material import active_node_mat


class VRAY_MT_preview(VRayMaterialPanel, bpy.types.Panel):
	bl_label = "Preview"
	COMPAT_ENGINES = {'VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		material= active_node_mat(context.material)
		if material is None:
			return False
		return engine_poll(__class__, context)

	def draw(self, context):
		self.layout.template_preview(context.material, show_buttons = False)


class VRAY_MT_preset_material(bpy.types.Menu):
	bl_label= "Material Presets"
	preset_subdir= os.path.join("..", "startup", "vb25", "presets", "material")
	preset_operator = "script.execute_preset"
	draw = bpy.types.Menu.draw_preset


class VRAY_MP_context_material(VRayMaterialPanel, bpy.types.Panel):
	bl_label = ""
	bl_options = {'HIDE_HEADER'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		rd= context.scene.render
		return (context.material or context.object) and engine_poll(__class__, context)

	def draw(self, context):
		layout= self.layout

		mat= active_node_mat(context.material)

		ob= context.object
		slot= context.material_slot
		space= context.space_data

		wide_ui= context.region.width > narrowui

		if ob:
			row = layout.row()

			row.template_list("VRayListMaterialSlots", "", ob, "material_slots", ob, "active_material_index", rows=2)

			col = row.column(align=True)
			col.operator("object.material_slot_add", icon='ZOOMIN', text="")
			col.operator("object.material_slot_remove", icon='ZOOMOUT', text="")

			col.menu("MATERIAL_MT_specials", icon='DOWNARROW_HLT', text="")

			if ob.mode == 'EDIT':
				row = layout.row(align=True)
				row.operator("object.material_slot_assign", text="Assign")
				row.operator("object.material_slot_select", text="Select")
				row.operator("object.material_slot_deselect", text="Deselect")

		if wide_ui:
			split = layout.split()

			if ob:
				split.template_ID(ob, "active_material", new="material.new")
			elif mat:
				split.template_ID(space, "pin_id")
				split.separator()
		else:
			if ob:
				layout.template_ID(ob, "active_material", new="material.new")
			elif mat:
				layout.template_ID(space, "pin_id")

		if mat:
			VRayMaterial = mat.vray

			split= layout.split()
			col= split.column()
			col.label(text="Simple materials:")
			if wide_ui:
				col= split.column()
			col.menu('VRAY_MT_preset_material', text="Preset")

			if wide_ui:
				layout.prop(VRayMaterial, 'type', expand=True)
			else:
				layout.prop(VRayMaterial, 'type')


class VRAY_MP_basic(VRayMaterialPanel, bpy.types.Panel):
	bl_label   = "Parameters"

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		material = active_node_mat(context.material)
		if material is None:
			return False
		VRayMaterial = material.vray
		if VRayMaterial.nodetree:
			return False
		return engine_poll(__class__, context)

	def draw(self, context):
		wide_ui= context.region.width > narrowui
		layout= self.layout

		material= active_node_mat(context.material)

		VRayMaterial= material.vray

		PLUGINS['BRDF'][VRayMaterial.type].gui(context, layout,
											   getattr(VRayMaterial, VRayMaterial.type),
											   material)


class VRAY_MP_options(VRayMaterialPanel, bpy.types.Panel):
	bl_label   = "Options"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		material = active_node_mat(context.material)
		if material is None:
			return False
		VRayMaterial = material.vray
		if VRayMaterial.nodetree:
			return False
		return VRayMaterial.type == 'BRDFVRayMtl' and engine_poll(__class__, context)

	def draw(self, context):
		layout= self.layout

		material=     active_node_mat(context.material)
		VRayMaterial= material.vray
		BRDFVRayMtl=  VRayMaterial.BRDFVRayMtl

		PLUGINS['BRDF']['BRDFVRayMtl'].gui_options(context, layout, BRDFVRayMtl, material= None)


class VRAY_MP_two_sided(VRayMaterialPanel, bpy.types.Panel):
	bl_label   = "Two-Sided"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		material = active_node_mat(context.material)
		if material is None:
			return False
		VRayMaterial = material.vray
		if VRayMaterial.nodetree:
			return False
		return active_node_mat(context.material) and engine_poll(__class__, context)

	def draw_header(self, context):
		ma= active_node_mat(context.material)
		Mtl2Sided= ma.vray.Mtl2Sided
		self.layout.prop(Mtl2Sided, 'use', text="")

	def draw(self, context):
		layout= self.layout

		wide_ui= context.region.width > narrowui

		ma= active_node_mat(context.material)

		Mtl2Sided= ma.vray.Mtl2Sided

		layout.active= Mtl2Sided.use

		split= layout.split()
		col= split.column()
		col.prop_search(Mtl2Sided, 'back', bpy.data, 'materials', text= "Back material")

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(Mtl2Sided, 'control')

		if Mtl2Sided.control == 'SLIDER':
			split= layout.split()
			col= split.column()
			col.prop(Mtl2Sided, 'translucency_slider', slider=True)
		elif Mtl2Sided.control == 'COLOR':
			split= layout.split()
			col= split.column()
			col.prop(Mtl2Sided, 'translucency_color', text="")
		else:
			split= layout.split(percentage=0.3)
			col= split.row()
			col.prop(Mtl2Sided, 'translucency_tex_mult', text="Mult")
			col= split.row()
			col.prop_search(Mtl2Sided, 'translucency_tex', bpy.data, 'textures', text= "")

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(Mtl2Sided, 'force_1sided')


class VRAY_MP_override(VRayMaterialPanel, bpy.types.Panel):
	bl_label   = "Override"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		material = active_node_mat(context.material)
		if material is None:
			return False
		VRayMaterial = material.vray
		if VRayMaterial.nodetree:
			return False
		return engine_poll(__class__, context)

	def draw_header(self, context):
		ma= active_node_mat(context.material)
		MtlOverride= ma.vray.MtlOverride
		self.layout.prop(MtlOverride, 'use', text="")

	def draw(self, context):
		wide_ui= context.region.width > narrowui

		ob= context.object
		ma= active_node_mat(context.material)

		MtlOverride= ma.vray.MtlOverride

		layout= self.layout
		layout.active= MtlOverride.use

		split= layout.split()
		col= split.column()
		col.prop_search(MtlOverride, 'gi_mtl',      bpy.data, 'materials', text= "GI")
		col.prop_search(MtlOverride, 'reflect_mtl', bpy.data, 'materials', text= "Reflection")
		col.prop_search(MtlOverride, 'refract_mtl', bpy.data, 'materials', text= "Refraction")
		col.prop_search(MtlOverride, 'shadow_mtl',  bpy.data, 'materials', text= "Shadow")

		layout.separator()
		split= layout.split()
		col= split.column()
		col.prop_search(MtlOverride, 'environment_override',  bpy.data, 'textures', text= "Environment")

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(MtlOverride, 'environment_priority')


class VRAY_MP_wrapper(VRayMaterialPanel, bpy.types.Panel):
	bl_label   = "Wrapper"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		material = active_node_mat(context.material)
		if material is None:
			return False
		VRayMaterial = material.vray
		if VRayMaterial.nodetree:
			return False
		return engine_poll(__class__, context)

	def draw_header(self, context):
		mat= active_node_mat(context.material)
		MtlWrapper= mat.vray.MtlWrapper
		self.layout.prop(MtlWrapper, 'use', text="")

	def draw(self, context):
		wide_ui= context.region.width > narrowui

		ob= context.object
		ma= active_node_mat(context.material)

		MtlWrapper= ma.vray.MtlWrapper

		layout= self.layout
		layout.active= MtlWrapper.use

		split= layout.split()
		col= split.column()
		col.prop(MtlWrapper, 'generate_gi')
		col.prop(MtlWrapper, 'receive_gi')
		if wide_ui:
			col= split.column()
		col.prop(MtlWrapper, 'generate_caustics')
		col.prop(MtlWrapper, 'receive_caustics')

		split= layout.split()
		col= split.column()
		col.prop(MtlWrapper, 'gi_quality_multiplier')

		split= layout.split()
		col= split.column()
		col.label(text="Matte properties")

		split= layout.split()
		colL= split.column()
		colL.prop(MtlWrapper, 'matte_surface')
		if wide_ui:
			colR= split.column()
		else:
			colR= colL
		colR.prop(MtlWrapper, 'alpha_contribution')
		if MtlWrapper.matte_surface:
			colL.prop(MtlWrapper, 'affect_alpha')
			colL.prop(MtlWrapper, 'shadows')
			if MtlWrapper.shadows:
				colL.prop(MtlWrapper, 'shadow_tint_color')
				colL.prop(MtlWrapper, 'shadow_brightness')

			colR.prop(MtlWrapper, 'reflection_amount')
			colR.prop(MtlWrapper, 'refraction_amount')
			colR.prop(MtlWrapper, 'gi_amount')
			colR.prop(MtlWrapper, 'no_gi_on_other_mattes')

		split= layout.split()
		col= split.column()
		col.label(text="Miscellaneous")

		split= layout.split()
		col= split.column()
		col.prop(MtlWrapper, 'gi_surface_id')
		col.prop(MtlWrapper, 'trace_depth')
		if wide_ui:
			col= split.column()
		col.prop(MtlWrapper, 'matte_for_secondary_rays')

		layout.prop(MtlWrapper, 'generate_render_elements')


class VRAY_MP_outline(VRayMaterialPanel, bpy.types.Panel):
	bl_label   = "Outline"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW', 'VRAY_RENDER_RT'}

	@classmethod
	def poll(cls, context):
		material = active_node_mat(context.material)
		if material is None:
			return False
		VRayMaterial = material.vray
		if VRayMaterial.nodetree:
			return False
		return engine_poll(__class__, context)

	def draw_header(self, context):
		ma= active_node_mat(context.material)
		VRayMaterial= ma.vray
		VolumeVRayToon= VRayMaterial.VolumeVRayToon
		self.layout.prop(VolumeVRayToon, 'use', text="")

	def draw(self, context):
		wide_ui= context.region.width > narrowui
		layout= self.layout

		ob= context.object
		ma= active_node_mat(context.material)

		VRayMaterial= ma.vray
		VolumeVRayToon= VRayMaterial.VolumeVRayToon

		layout.active= VolumeVRayToon.use

		PLUGINS['SETTINGS']['SettingsEnvironment'].draw_VolumeVRayToon(context, layout, VRayMaterial)


class VRAY_MP_render(VRayMaterialPanel, bpy.types.Panel):
	bl_label   = "Render"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW', 'VRAY_RENDER_RT'}

	@classmethod
	def poll(cls, context):
		material = active_node_mat(context.material)
		if material is None:
			return False
		VRayMaterial = material.vray
		if VRayMaterial.nodetree:
			return False
		return engine_poll(__class__, context) and not (VRayMaterial.type == 'EMIT' and VRayMaterial.emitter_type == 'MESH') and not VRayMaterial.type == 'VOL'

	def draw(self, context):
		wide_ui= context.region.width > narrowui

		ob= context.object
		ma= active_node_mat(context.material)

		VRayMaterial= ma.vray
		MtlRenderStats= VRayMaterial.MtlRenderStats

		layout= self.layout

		layout.prop(VRayMaterial, 'dontOverride')
		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(VRayMaterial, 'round_edges')
		if wide_ui:
			col= split.column()
		else:
			col= col.column()
		col.active= VRayMaterial.round_edges
		col.prop(VRayMaterial, 'radius', text="Radius")

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(VRayMaterial, 'material_id_number')
		if wide_ui:
			col= split.column()
		else:
			col= col.column()
		col.prop(VRayMaterial, 'material_id_color', text="")

		layout.separator()

		layout.prop(MtlRenderStats, 'use')

		split= layout.split()
		split.active= MtlRenderStats.use
		col= split.column()
		col.prop(MtlRenderStats, 'visibility', text="Visible")

		split= layout.split()
		split.active= MtlRenderStats.use
		col= split.column()
		col.label(text="Visible to:")

		split= layout.split()
		split.active= MtlRenderStats.use
		sub= split.column()
		sub.active= MtlRenderStats.visibility
		sub.prop(MtlRenderStats, 'camera_visibility', text="Camera")
		sub.prop(MtlRenderStats, 'gi_visibility', text="GI")
		sub.prop(MtlRenderStats, 'shadows_visibility', text="Shadows")
		if wide_ui:
			sub= split.column()
			sub.active= MtlRenderStats.visibility
		sub.prop(MtlRenderStats, 'reflections_visibility', text="Reflections")
		sub.prop(MtlRenderStats, 'refractions_visibility', text="Refractions")


def GetRegClasses():
	return (
		VRAY_MT_preview,
		VRAY_MT_preset_material,
		VRAY_MP_context_material,
		VRAY_MP_basic,
		VRAY_MP_options,
		VRAY_MP_two_sided,
		VRAY_MP_override,
		VRAY_MP_wrapper,
		VRAY_MP_outline,
		VRAY_MP_render,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = properties_object
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Python modules '''
import os

''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui.ui import *


def engine_poll(cls, context):
	rd= context.scene.render
	return (context.object and (context.object.type not in ('LAMP','CAMERA','ARMATURE'))) and (rd.engine in cls.COMPAT_ENGINES)


class VRAY_OBP_override(VRayObjectPanel, bpy.types.Panel):
	bl_label   = "Override"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		return engine_poll(__class__, context)

	def draw_header(self, context):
		ob= context.object
		plugin= ob.vray.MtlOverride
		self.layout.label(text="", icon='VRAY_LOGO_MONO')
		self.layout.prop(plugin, 'use', text="")

	def draw(self, context):
		wide_ui= context.region.width > narrowui

		ob= context.object

		MtlOverride= ob.vray.MtlOverride

		layout= self.layout
		layout.active= MtlOverride.use

		split= layout.split()
		col= split.column()
		col.prop_search(MtlOverride, 'gi_mtl',      bpy.data, 'materials', text= "GI")
		col.prop_search(MtlOverride, 'reflect_mtl', bpy.data, 'materials', text= "Reflection")
		col.prop_search(MtlOverride, 'refract_mtl', bpy.data, 'materials', text= "Refraction")
		col.prop_search(MtlOverride, 'shadow_mtl',  bpy.data, 'materials', text= "Shadow")

		layout.separator()
		split= layout.split()
		col= split.column()
		col.prop_search(MtlOverride, 'environment_override',  bpy.data, 'textures', text= "Environment")

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(MtlOverride, 'environment_priority')


class VRAY_OBP_wrapper(VRayObjectPanel, bpy.types.Panel):
	bl_label = "Wrapper"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		return engine_poll(__class__, context)

	def draw_header(self, context):
		ob= context.object
		plugin= ob.vray.MtlWrapper
		self.layout.label(text="", icon='VRAY_LOGO_MONO')
		self.layout.prop(plugin, 'use', text="")

	def draw(self, context):
		wide_ui= context.region.width > narrowui

		ob= context.object
		plugin= ob.vray.MtlWrapper

		layout= self.layout
		layout.active= plugin.use

		split= layout.split()
		col= split.column()
		col.prop(plugin, 'generate_gi')
		col.prop(plugin, 'receive_gi')
		if wide_ui:
			col= split.column()
		col.prop(plugin, 'generate_caustics')
		col.prop(plugin, 'receive_caustics')

		split= layout.split()
		col= split.column()
		col.prop(plugin, 'gi_quality_multiplier')

		split= layout.split()
		col= split.column()
		col.label(text="Matte properties")

		split= layout.split()
		colL= split.column()
		colL.prop(plugin, 'matte_surface')
		if wide_ui:
			colR= split.column()
		else:
			colR= colL
		colR.prop(plugin, 'alpha_contribution')
		if plugin.matte_surface:
			colR.prop(plugin, 'reflection_amount')
			colR.prop(plugin, 'refraction_amount')
			colR.prop(plugin, 'gi_amount')
			colR.prop(plugin, 'no_gi_on_other_mattes')

			colL.prop(plugin, 'affect_alpha')
			colL.prop(plugin, 'shadows')
			if plugin.shadows:
				colL.prop(plugin, 'shadow_tint_color')
				colL.prop(plugin, 'shadow_brightness')

		split= layout.split()
		col= split.column()
		col.label(text="Miscellaneous")

		split= layout.split()
		col= split.column()
		col.prop(plugin, 'gi_surface_id')
		col.prop(plugin, 'trace_depth')
		if wide_ui:
			col= split.column()
		col.prop(plugin, 'matte_for_secondary_rays')

		layout.prop(plugin, 'generate_render_elements')


class VRAY_OBP_render(VRayObjectPanel, bpy.types.Panel):
	bl_label = "Render"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		return engine_poll(__class__, context) and not context.object.vray.LightMesh.use

	def draw_header(self, context):
		ob= context.object
		plugin= ob.vray.MtlRenderStats
		self.layout.label(text="", icon='VRAY_LOGO_MONO')
		self.layout.prop(plugin, 'use', text="")

	def draw(self, context):
		wide_ui= context.region.width > narrowui

		ob= context.object
		VRayObject= ob.vray
		plugin= VRayObject.MtlRenderStats

		layout= self.layout
		layout.active= plugin.use

		layout.prop(VRayObject, 'fade_radius')

		split= layout.split()
		col= split.column()
		col.prop(plugin, 'visibility', text="Visible")

		split= layout.split()
		col= split.column()
		col.label(text="Visible to:")

		split= layout.split()
		sub= split.column()
		sub.active= plugin.visibility
		sub.prop(plugin, 'camera_visibility', text="Camera")
		sub.prop(plugin, 'gi_visibility', text="GI")
		sub.prop(plugin, 'shadows_visibility', text="Shadows")
		if wide_ui:
			sub= split.column()
			sub.active= plugin.visibility
		sub.prop(plugin, 'reflections_visibility', text="Reflections")
		sub.prop(plugin, 'refractions_visibility', text="Refractions")


class VRAY_OBP_displacement(VRayObjectPanel, bpy.types.Panel):
	bl_label = "Displacement"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		return engine_poll(__class__, context)

	def draw_header(self, context):
		ob= context.object
		VRayObject= ob.vray
		GeomDisplacedMesh= VRayObject.GeomDisplacedMesh
		self.layout.label(text="", icon='VRAY_LOGO_MONO')
		self.layout.prop(GeomDisplacedMesh, 'use', text="")

	def draw(self, context):
		wide_ui= context.region.width > narrowui

		ob= context.object
		VRayObject= ob.vray
		GeomDisplacedMesh= VRayObject.GeomDisplacedMesh

		layout= self.layout
		layout.active= GeomDisplacedMesh.use

		split= layout.split()
		col= split.column()
		col.prop(GeomDisplacedMesh, 'amount_type', text="Amount")
		if GeomDisplacedMesh.amount_type == 'OVER':
			col.prop(GeomDisplacedMesh, 'displacement_amount')
		else:
			col.prop(GeomDisplacedMesh, 'amount_mult')
		col.prop(GeomDisplacedMesh, 'displacement_shift', slider=True)
		col.prop(GeomDisplacedMesh, 'water_level', slider=True)
		col.prop(GeomDisplacedMesh, 'resolution')
		col.prop(GeomDisplacedMesh, 'precision')
		if wide_ui:
			col= split.column()
		col.prop(GeomDisplacedMesh, 'type')
		col.prop(GeomDisplacedMesh, 'keep_continuity')
		col.prop(GeomDisplacedMesh, 'filter_texture')
		if GeomDisplacedMesh.filter_texture:
			col.prop(GeomDisplacedMesh, 'filter_blur')
		col.prop(GeomDisplacedMesh, 'use_bounds')
		if GeomDisplacedMesh.use_bounds:
			sub= col.column(align= True)
			sub.prop(GeomDisplacedMesh, 'min_bound', text="Min", slider= True)
			sub.prop(GeomDisplacedMesh, 'max_bound', text="Max", slider= True)

		split= layout.split()
		col= split.column()
		col.prop(GeomDisplacedMesh, 'use_globals')
		if not GeomDisplacedMesh.use_globals:
			split= layout.split()
			col= split.column()
			col.prop(GeomDisplacedMesh, 'edge_length')
			col.prop(GeomDisplacedMesh, 'max_subdivs')
			if wide_ui:
				col= split.column()
			col.prop(GeomDisplacedMesh, 'view_dep')
			col.prop(GeomDisplacedMesh, 'tight_bounds')


class VRAY_OBP_lightmesh(VRayObjectPanel, bpy.types.Panel):
	bl_label = "Light"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		return engine_poll(__class__, context)

	def draw_header(self, context):
		ob= context.object
		VRayObject= ob.vray
		LightMesh= VRayObject.LightMesh
		self.layout.label(text="", icon='VRAY_LOGO_MONO')
		self.layout.prop(LightMesh, 'use', text="")

	def draw(self, context):
		wide_ui= context.region.width > narrowui

		ob= context.object
		VRayObject= ob.vray
		LightMesh= VRayObject.LightMesh

		layout= self.layout
		layout.active= LightMesh.use

		split= layout.split()
		col= split.column()
		col.row().prop(LightMesh, 'color_type', expand=True)
		if wide_ui:
			col= split.column()
		if LightMesh.color_type == 'RGB':
			sub= col.row(align= True)
			sub.prop(LightMesh, 'color', text="")
			sub.operator('vray.set_kelvin_color', text="", icon= 'COLOR', emboss= False).data_path= "object.vray.LightMesh.color"
		else:
			col.prop(LightMesh, 'temperature', text="K")

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(LightMesh, 'lightPortal', text="Mode")
		if LightMesh.lightPortal == 'NORMAL':
			col.prop(LightMesh, 'units', text="Units")
			col.prop(LightMesh, 'intensity', text="Intensity")
		col.prop(LightMesh, 'subdivs')
		col.prop(LightMesh, 'causticSubdivs', text="Caustics")
		if wide_ui:
			col= split.column()
		col.prop(LightMesh, 'enabled', text="On")
		col.prop(LightMesh, 'invisible')
		col.prop(LightMesh, 'affectDiffuse')
		col.prop(LightMesh, 'affectSpecular')
		col.prop(LightMesh, 'affectReflections')
		col.prop(LightMesh, 'noDecay')
		col.prop(LightMesh, 'doubleSided')
		col.prop(LightMesh, 'storeWithIrradianceMap')

		layout.separator()
		layout.prop(LightMesh, 'use_include_exclude')

		if LightMesh.use_include_exclude:
			split= layout.split()
			col= split.column()
			col.prop(LightMesh, 'include_exclude')
			col.prop_search(LightMesh,     'include_objects',
							context.scene, 'objects',
							text="Objects")
			col.prop_search(LightMesh, 'include_groups',
							bpy.data,  'groups',
							text="Groups")


class VRAY_OBP_subdivision(VRayObjectPanel, bpy.types.Panel):
	bl_label   = "Subdivision"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		return engine_poll(__class__, context)

	def draw_header(self, context):
		ob= context.object
		VRayObject= ob.vray
		GeomStaticSmoothedMesh= VRayObject.GeomStaticSmoothedMesh
		self.layout.label(text="", icon='VRAY_LOGO_MONO')
		self.layout.prop(GeomStaticSmoothedMesh, 'use', text="")

	def draw(self, context):
		wide_ui= context.region.width > narrowui

		ob= context.object
		VRayObject= ob.vray
		GeomStaticSmoothedMesh= VRayObject.GeomStaticSmoothedMesh

		layout= self.layout
		layout.active= GeomStaticSmoothedMesh.use

		split= layout.split()
		col= split.column()
		col.prop(GeomStaticSmoothedMesh, 'static_subdiv')
		if wide_ui:
			col= split.column()
		col.prop(GeomStaticSmoothedMesh, 'use_globals')

		if not GeomStaticSmoothedMesh.use_globals:
			layout.separator()
			split= layout.split()
			col= split.column()
			col.prop(GeomStaticSmoothedMesh, 'edge_length')
			col.prop(GeomStaticSmoothedMesh, 'max_subdivs')
			if wide_ui:
				col= split.column()
			col.prop(GeomStaticSmoothedMesh, 'view_dep')



class VRAY_OBP_VRayPattern(VRayObjectPanel, bpy.types.Panel):
	bl_label   = "VRayPattern"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		if not engine_poll(__class__, context):
			return False
		if not context.scene.vray.exporter.experimental:
			return False
		return True

	def draw_header(self, context):
		ob = context.object
		VRayObject = ob.vray
		GeomVRayPattern = VRayObject.GeomVRayPattern
		self.layout.label(text="", icon='VRAY_LOGO_MONO')
		self.layout.prop(GeomVRayPattern, 'use', text="")

	def draw(self, context):
		wide_ui = context.region.width > narrowui

		ob = context.object
		VRayObject = ob.vray
		GeomVRayPattern = VRayObject.GeomVRayPattern

		layout = self.layout
		layout.active = GeomVRayPattern.use

		split = layout.split()
		split.label(text="Pattern Object:")
		split.prop_search(GeomVRayPattern, 'pattern_object',
						  context.scene,   'objects',
						  text="")

		layout.separator()

		layout.prop(GeomVRayPattern, 'crop_size')
		layout.operator('vray.pattern_fit', icon='MOD_MESHDEFORM')
		# layout.prop(GeomVRayPattern, 'geometry_bias')
		layout.separator()

		split = layout.split()
		col = split.column()
		col.prop(GeomVRayPattern, 'height')
		if wide_ui:
			col = split.column()
		col.prop(GeomVRayPattern, 'shift')

		layout.separator()

		layout.prop(GeomVRayPattern, 'use_real_world')
		split = layout.split()
		col = split.column()
		col.prop(GeomVRayPattern, 'tiling_u', text="U")
		if wide_ui:
			col = split.column()
		col.prop(GeomVRayPattern, 'tiling_v', text="V")

		layout.label(text="Polygon ID:")
		split = layout.split()
		col = split.column()
		col.prop(GeomVRayPattern, 'polygon_id_from', text="From")
		if wide_ui:
			col = split.column()
		col.prop(GeomVRayPattern, 'polygon_id_to', text="To")

		layout.label(text="Random Segment Count:")
		split = layout.split()
		col = split.column()
		col.prop(GeomVRayPattern, 'random_segment_u', text="U")
		if wide_ui:
			col = split.column()
		col.prop(GeomVRayPattern, 'random_segment_v', text="V")

		layout.prop(GeomVRayPattern, 'random_segment_seed')

		layout.separator()

		split = layout.split()
		col = split.column()
		col.prop(GeomVRayPattern, 'render_base_object')
		if wide_ui:
			col = split.column()
		col.prop(GeomVRayPattern, 'render_pattern_object')


def GetRegClasses():
	return (
		VRAY_OBP_override,
		VRAY_OBP_wrapper,
		VRAY_OBP_render,
		VRAY_OBP_displacement,
		VRAY_OBP_lightmesh,
		VRAY_OBP_subdivision,
		VRAY_OBP_VRayPattern,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = properties_particles
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy

''' vb modules '''
from vb25.ui.ui import *


class VRAY_PP_hair(VRayParticlePanel, bpy.types.Panel):
	bl_label       = "Fur"
	bl_options     = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		return super().poll(context) and context.particle_system.settings.type == 'HAIR'

	def draw(self, context):
		wide_ui= context.region.width > narrowui
		layout= self.layout

		particle_settings= context.particle_system.settings

		VRayFur= particle_settings.vray.VRayFur

		split= layout.split()
		col= split.column()
		col.prop(VRayFur, 'width', text="Fur Width")
		# if wide_ui:
		# 	col= split.column()
		# col.prop(VRayFur, 'make_thinner')
		# if VRayFur.make_thinner:
		# 	col.prop(VRayFur, 'thin_start', text= "Segment", slider= True)


def GetRegClasses():
	return (
		VRAY_PP_hair,
	)


def register():
	from bl_ui import properties_particle
	for member in dir(properties_particle):
		subclass= getattr(properties_particle, member)
		try:
			subclass.COMPAT_ENGINES.add('VRAY_RENDER')
			subclass.COMPAT_ENGINES.add('VRAY_RENDER_PREVIEW')
		except:
			pass
	del properties_particle

	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	from bl_ui import properties_particle
	for member in dir(properties_particle):
		subclass= getattr(properties_particle, member)
		try:
			subclass.COMPAT_ENGINES.remove('VRAY_RENDER')
			subclass.COMPAT_ENGINES.remove('VRAY_RENDER_PREVIEW')
		except:
			pass
	del properties_particle

	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

	del bpy.types.ParticleSettings.vray

########NEW FILE########
__FILENAME__ = properties_render
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui.ui import *
from vb25.plugins import *
from vb25 import version


class VRAY_MT_preset_IM(bpy.types.Menu):
	bl_label= "Irradiance Map Presets"
	preset_subdir= os.path.join("..", "startup", "vb25", "presets", "im")
	preset_operator= "script.execute_preset"
	draw= bpy.types.Menu.draw_preset


class VRAY_MT_preset_global(bpy.types.Menu):
	bl_label= "Global Presets"
	preset_subdir= os.path.join("..", "startup", "vb25", "presets", "render")
	preset_operator= "script.execute_preset"
	draw= bpy.types.Menu.draw_preset


class VRAY_MT_preset_gi(bpy.types.Menu):
	bl_label= "GI Presets"
	preset_subdir= os.path.join("..", "startup", "vb25", "presets", "gi")
	preset_operator= "script.execute_preset"
	draw= bpy.types.Menu.draw_preset


class VRAY_RP_dimensions(VRayRenderPanel, bpy.types.Panel):
	bl_label = "Dimensions"

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		scene= context.scene
		rd=    scene.render
		VRayScene= scene.vray

		# if VRayScene.image_aspect_lock:
		# 	rd.resolution_y= rd.resolution_x / VRayScene.image_aspect

		row = layout.row(align=True)
		row.menu("RENDER_MT_presets", text=bpy.types.RENDER_MT_presets.bl_label)
		row.operator("render.preset_add", text="", icon="ZOOMIN")
		row.operator("render.preset_add", text="", icon="ZOOMOUT").remove_active= True

		split= layout.split()
		col= split.column()
		col.label(text="Resolution:")
		sub= col.column(align=True)
		sub.prop(rd, "resolution_x", text="X")
		sub.prop(rd, "resolution_y", text="Y")
		# sub_aspect= sub.column()
		# sub_aspect.active= not VRayScene.image_aspect_lock
		# sub_aspect.prop(rd, "resolution_y", text="Y")
		sub.operator("vray.flip_resolution", text="", icon="FILE_REFRESH")
		sub.prop(rd, "resolution_percentage", text="")

		row= col.row()
		row.prop(rd, "use_border", text="Border")
		sub= row.row()
		sub.active = rd.use_border
		sub.prop(rd, "use_crop_to_border", text="Crop")

		if wide_ui:
			col= split.column()

		# sub = col.column(align=True)
		# sub.prop(VRayScene, "image_aspect_lock", text="Image aspect")
		# if VRayScene.image_aspect_lock:
		# 	sub.prop(VRayScene, "image_aspect")
		# sub.label(text="Pixel aspect:")
		# sub.prop(rd, "pixel_aspect_x", text="X")
		# sub.prop(rd, "pixel_aspect_y", text="Y")

		# split= layout.split()
		# col = split.column()
		sub = col.column(align=True)
		sub.label(text="Frame Range:")
		sub.prop(scene, "frame_start", text="Start")
		sub.prop(scene, "frame_end", text="End")
		sub.prop(scene, "frame_step", text="Step")

		# if wide_ui:
		# 	col= split.column()

		sub = col.column(align=True)
		sub.label(text="Frame Rate:")
		sub.prop(rd, "fps")
		sub.prop(rd, "fps_base", text="/")
		subrow = sub.row(align=True)
		subrow.prop(rd, "frame_map_old", text="Old")
		subrow.prop(rd, "frame_map_new", text="New")


class VRAY_RP_output(VRayRenderPanel, bpy.types.Panel):
	bl_label	   = "Output"

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW', 'VRAY_RENDER_RT'}

	def draw_header(self, context):
		VRayExporter= context.scene.vray.exporter
		self.layout.prop(VRayExporter, 'auto_save_render', text="")

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		scene = context.scene
		rd    = scene.render.image_settings

		VRayScene      = scene.vray
		VRayExporter   = VRayScene.exporter
		SettingsOutput = VRayScene.SettingsOutput

		layout.active= VRayExporter.auto_save_render

		if wide_ui:
			split= layout.split(percentage=0.2)
			col= split.column()
			col.label(text="Path:")
			col.label(text="Filename:")
			col= split.column()
			col.prop(SettingsOutput, 'img_dir',  text="")
			col.prop(SettingsOutput, 'img_file', text="")
		else:
			layout.prop(SettingsOutput, 'img_dir',  text="")
			layout.prop(SettingsOutput, 'img_file', text="")

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(SettingsOutput, 'img_format', text= "Format")

		img_format = SettingsOutput.img_format

		split= layout.split()
		col= split.column()

		if img_format not in ('JPG', 'VRIMG'):
			col.prop(SettingsOutput, 'color_depth')
		if img_format == 'JPG':
			col.prop(rd, 'quality', slider= True)
		elif img_format == 'PNG':
			col.prop(rd, 'quality', slider= True, text= "Compression")
		elif img_format == 'EXR':
			row= col.row()
			row.prop(rd, 'exr_codec')

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(SettingsOutput, 'img_noAlpha')
		col.prop(SettingsOutput, 'img_separateAlpha')
		if wide_ui:
			col = split.column()
		if img_format == 'EXR':
			col.prop(SettingsOutput, 'relements_separateFiles')
		col.prop(SettingsOutput, 'relements_separateFolders')

		split= layout.split()
		col= split.column()
		col.prop(SettingsOutput, 'img_file_needFrameNumber')
		if wide_ui:
			col = split.column()
		col.prop(VRayExporter, 'image_to_blender')

		# sub= col.column()
		# sub.active= False
		# sub.prop(rd, "use_overwrite")


class VRAY_RP_render(VRayRenderPanel, bpy.types.Panel):
	bl_label       = "Render"

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		rd= context.scene.render

		VRayScene=       context.scene.vray
		VRayExporter=    VRayScene.exporter
		SettingsOptions= VRayScene.SettingsOptions

		split= layout.split()
		col= split.column()
		if VRayExporter.animation:
			render_label= "Animation"
			render_icon= 'RENDER_ANIMATION'
		elif VRayExporter.camera_loop:
			render_label= "Cameras"
			render_icon= 'RENDER_ANIMATION'
		else:
			render_label= "Image"
			render_icon= 'RENDER_STILL'

		col.operator('render.render', text= render_label, icon= render_icon)

		if not VRayExporter.auto_meshes:
			if wide_ui:
				col= split.column()
			col.operator('vray.write_geometry', icon='OUTLINER_OB_MESH')

		if VRayExporter.animation:
			layout.prop(VRayExporter, 'animation_type')

		split= layout.split()
		col= split.column()
		col.label(text="Modules:")
		col.prop(VRayScene.SettingsGI, 'on', text="Global Illumination")
		col.prop(VRayScene.SettingsCaustics, 'on', text="Caustics")
		col.prop(VRayExporter, 'use_displace')
		col.prop(VRayScene.VRayDR, 'on')
		col.prop(VRayScene.VRayBake, 'use')
		col.prop(VRayScene.RTEngine, 'enabled')
		col.prop(VRayScene.VRayStereoscopicSettings, 'use')
		if wide_ui:
			col= split.column()
		col.label(text="Pipeline:")
		col.prop(VRayExporter, 'activeLayers', text="Layers")
		if VRayExporter.activeLayers == 'CUSTOM':
			col.prop(VRayExporter, 'customRenderLayers', text="")
		col.prop(VRayExporter, 'animation')
		if not VRayExporter.animation:
			col.prop(VRayExporter, 'camera_loop')
		if VRayScene.SettingsGI.on:
			col.prop(SettingsOptions, 'gi_dontRenderImage')
		col.prop(VRayExporter, 'use_still_motion_blur')
		col.label(text="Options:")
		if VRayExporter.animation:
			col.prop(VRayExporter, 'check_animated')
		col.prop(VRayExporter, 'draft')

		layout.separator()
		layout.prop(rd, "display_mode", text="Display")



class VRAY_RP_SettingsOptions(VRayRenderPanel, bpy.types.Panel):
	bl_label   = "Globals"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		VRayScene= context.scene.vray
		VRayExporter=    VRayScene.exporter
		SettingsOptions= VRayScene.SettingsOptions

		split= layout.split()
		col= split.column()
		col.label(text="Geometry:")
		col.prop(SettingsOptions, 'geom_doHidden')
		col.prop(SettingsOptions, 'geom_backfaceCull')
		col.prop(SettingsOptions, 'ray_bias', text="Secondary bias")
		if wide_ui:
			col= split.column()
		col.label(text="Lights:")
		col.prop(SettingsOptions, 'light_doLights')
		# col.prop(SettingsOptions, 'light_doDefaultLights')
		col.prop(SettingsOptions, 'light_doHiddenLights')
		col.prop(SettingsOptions, 'light_doShadows')
		col.prop(SettingsOptions, 'light_onlyGI')

		layout.label(text="Materials:")
		split= layout.split()
		col= split.column()
		col.prop(SettingsOptions, 'mtl_override_on')
		if SettingsOptions.mtl_override_on:
			col.prop_search(SettingsOptions, 'mtl_override', bpy.data, 'materials', text="")
		col.prop(SettingsOptions, 'mtl_doMaps')
		if SettingsOptions.mtl_doMaps:
			col.prop(SettingsOptions, 'mtl_filterMaps')
			col.prop(SettingsOptions, 'mtl_filterMapsForSecondaryRays')
		if wide_ui:
			col= split.column()
		col.prop(SettingsOptions, 'mtl_reflectionRefraction')
		if SettingsOptions.mtl_reflectionRefraction:
			col.prop(SettingsOptions, 'mtl_limitDepth')
			if SettingsOptions.mtl_limitDepth:
				col.prop(SettingsOptions, 'mtl_maxDepth')
		col.prop(SettingsOptions, 'mtl_glossy')

		split= layout.split()
		col= split.column()
		col.prop(SettingsOptions, 'mtl_transpMaxLevels')
		if wide_ui:
			col= split.column()
		col.prop(SettingsOptions, 'mtl_transpCutoff')

		layout.separator()
		layout.label(text="Ray Intensity:")
		split = layout.split()
		col = split.column()
		col.prop(SettingsOptions, 'ray_max_intensity_on')
		col = split.column()
		col.active = SettingsOptions.ray_max_intensity_on
		col.prop(SettingsOptions, 'ray_max_intensity')


class VRAY_RP_exporter(VRayRenderPanel, bpy.types.Panel):
	bl_label   = "Exporter"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		rd= context.scene.render
		ve= context.scene.vray.exporter

		row= layout.row(align=True)
		row.menu("VRAY_MT_preset_global", text=bpy.types.VRAY_MT_preset_global.bl_label)
		row.operator("vray.preset_add", text="", icon="ZOOMIN")
		row.operator("vray.preset_add", text="", icon="ZOOMOUT").remove_active = True

		layout.separator()

		split= layout.split()
		col= split.column()
		col.label(text="Options:")
		col.prop(ve, 'autorun')
		col.prop(ve, 'auto_meshes')
		col.prop(ve, 'display')
		col.prop(ve, 'autoclose')
		col.prop(ve, 'debug')
		if wide_ui:
			col= split.column()
		col.label(text="Mesh export:")
		col.prop(ve, 'mesh_active_layers', text= "Active layers")
		col.prop(ve, 'use_instances')
		# col.prop(SettingsOptions, 'geom_displacement')
		col.prop(ve, 'mesh_debug')

		layout.separator()

		layout.label(text="Rendering:")
		split = layout.split()
		col = split.column()
		col.prop(ve, 'use_smoke')
		col.prop(ve, 'use_smoke_hires', text = "Smoke HR")
		if wide_ui:
			col= split.column()
		col.prop(ve, 'use_hair')
		col.prop(ve, 'random_material', text="Randomize Materials")

		layout.separator()

		layout.label(text="Experimental:")
		split = layout.split()
		col = split.column()
		col.prop(ve, 'use_feedback')
		if wide_ui:
			col= split.column()
		col.prop(ve, 'use_progress')

		layout.separator()

		layout.label(text="Advanced:")
		split= layout.split()
		col= split.column()
		col.prop(ve, 'detect_vray')
		if wide_ui:
			col= split.column()
		col.prop(ve, 'display_srgb')
		if not ve.detect_vray:
			split= layout.split()
			col= split.column()
			col.prop(ve, 'vray_binary')
		split= layout.split()
		col= split.column()
		if PLATFORM == "linux":
			col.prop(ve, 'log_window')
			if ve.log_window:
				col.prop(ve, 'log_window_type', text="Terminal")
				if ve.log_window_type == 'CUSTOM':
					col.prop(ve, 'log_window_term')
		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(ve, 'output', text="Export to")
		if ve.output == 'USER':
			col.prop(ve, 'output_dir')
		col.prop(ve, 'output_unique')

		layout.separator()

		layout.operator('vray.update', icon='FILE_REFRESH')

		# Manual render pipeline controls
		if ve.animation:
			render_label = "Animation"
			render_icon  = 'RENDER_ANIMATION'
		elif ve.camera_loop:
			render_label = "Cameras"
			render_icon  = 'RENDER_ANIMATION'
		else:
			render_label = "Image"
			render_icon  = 'RENDER_STILL'


class VRAY_RP_cm(VRayRenderPanel, bpy.types.Panel):
	bl_label = "Color mapping"

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		vs= context.scene.vray
		cm= vs.SettingsColorMapping

		split= layout.split()
		col= split.column()
		col.prop(cm, 'type')
		if cm.type == 'REIN':
			col.prop(cm, "dark_mult", text="Multiplier")
			col.prop(cm, "bright_mult",  text="Burn")
		elif cm.type in ('GCOR', 'GINT'):
			col.prop(cm, "bright_mult", text="Multiplier")
			col.prop(cm, "dark_mult", text="Inverse gamma")
		else:
			col.prop(cm, "bright_mult")
			col.prop(cm, "dark_mult")
		col.prop(cm, "gamma")
		col.prop(cm, "input_gamma")
		if wide_ui:
			col= split.column()
		col.prop(cm, "affect_background")
		col.prop(cm, "subpixel_mapping")
		col.prop(cm, "adaptation_only")
		col.prop(cm, "linearWorkflow")
		col.prop(cm, "clamp_output")
		if cm.clamp_output:
			col.prop(cm, "clamp_level")


class VRAY_RP_aa(VRayRenderPanel, bpy.types.Panel):
	bl_label = "Image sampler"

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		vs= context.scene.vray
		module= vs.SettingsImageSampler

		split= layout.split()
		col= split.column()
		col.prop(module, "type")

		split= layout.split()
		col= split.column()
		col.label(text="Parameters:")

		split= layout.split()
		col= split.column()
		if module.type == 'FXD':
			col.prop(module, "fixed_subdivs")
		elif module.type == 'DMC':
			col.prop(module, "dmc_minSubdivs")
			col.prop(module, "dmc_maxSubdivs")

			if wide_ui:
				col= split.column()
			col.prop(module, "dmc_treshhold_use_dmc", text= "Use DMC sampler thresh.")
			if not module.dmc_treshhold_use_dmc:
				col.prop(module, "dmc_threshold")
			col.prop(module, "dmc_show_samples")
		elif module.type == 'DMC':
			col.prop(module, "subdivision_minRate")
			col.prop(module, "subdivision_maxRate")
			col.prop(module, "subdivision_threshold")

			if wide_ui:
				col= split.column()
			col= split.column()
			col.prop(module, "subdivision_edges")
			col.prop(module, "subdivision_normals")
			if module.subdivision_normals:
				col.prop(module, "subdivision_normals_threshold")
			col.prop(module, "subdivision_jitter")
			col.prop(module, "subdivision_show_samples")
		else:
			col.prop(module, 'progressive_minSubdivs')
			col.prop(module, 'progressive_maxSubdivs')
			col.prop(module, 'progressive_showMask')
			if wide_ui:
				col = split.column()
			col.prop(module, 'progressive_threshold')
			col.prop(module, 'progressive_maxTime')
			col.prop(module, 'progressive_bundleSize')

		if module.type != 'PRG':
			layout.separator()
			
			split= layout.split()
			col= split.column()
			col.label(text="Filter type:")
			if wide_ui:
				col= split.column()
			col.prop(module, "filter_type", text="")
			if module.filter_type not in {'NONE', 'CATMULL'}:
				col.prop(module, "filter_size")


class VRAY_RP_dmc(VRayRenderPanel, bpy.types.Panel):
	bl_label = "DMC sampler"

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		vs= context.scene.vray
		module= vs.SettingsDMCSampler

		split= layout.split()
		col= split.column()
		col.prop(module, "adaptive_threshold")
		col.prop(module, "subdivs_mult")
		col.prop(module, "time_dependent")

		if wide_ui:
			col= split.column()
		col.prop(module, "adaptive_amount")
		col.prop(module, "adaptive_min_samples")


class VRAY_RP_gi(VRayRenderPanel, bpy.types.Panel):
	bl_label = "Global Illumination"

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		SettingsGI= context.scene.vray.SettingsGI
		return super().poll(context) and SettingsGI.on

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		VRayScene=  context.scene.vray
		SettingsGI= VRayScene.SettingsGI

		row= layout.row(align=True)
		row.menu("VRAY_MT_preset_gi", text=bpy.types.VRAY_MT_preset_gi.bl_label)
		row.operator("vray.preset_gi_add", text="", icon="ZOOMIN")
		row.operator("vray.preset_gi_add", text="", icon="ZOOMOUT").remove_active = True

		layout.separator()

		split= layout.split()
		col= split.column()
		col.label(text="GI caustics:")
		sub= col.column()
		sub.prop(SettingsGI, "reflect_caustics", text="Reflect")
		sub.prop(SettingsGI, "refract_caustics", text="Refract")
		if wide_ui:
			col= split.column()
		col.label(text="Post-processing:")
		sub= col.column()
		sub.prop(SettingsGI, "saturation")
		sub.prop(SettingsGI, "contrast")
		sub.prop(SettingsGI, "contrast_base")

		layout.label(text="Primary engine:")
		if wide_ui:
			split= layout.split(percentage=0.35)
		else:
			split= layout.split()
		col= split.column()
		col.prop(SettingsGI, "primary_multiplier", text="Mult")
		if wide_ui:
			col= split.column()
		col.prop(SettingsGI, "primary_engine", text="")

		if SettingsGI.primary_engine != 'SH':
			layout.label(text="Secondary engine:")
			if wide_ui:
				split= layout.split(percentage=0.35)
			else:
				split= layout.split()
			col= split.column()
			col.prop(SettingsGI, "secondary_multiplier", text="Mult")
			if wide_ui:
				col= split.column()
			col.prop(SettingsGI, "secondary_engine", text="")


		layout.separator()

		layout.prop(SettingsGI, 'ao_on', text="Ambient occlusion")
		if SettingsGI.ao_on:
			split= layout.split()
			col= split.column()
			col.prop(SettingsGI, 'ao_amount', slider= True)
			if wide_ui:
				col= split.column()
			col.prop(SettingsGI, 'ao_radius')
			col.prop(SettingsGI, 'ao_subdivs')

		layout.separator()

		split= layout.split()
		col= split.column()
		col.prop(SettingsGI, 'ray_distance_on')
		if wide_ui:
			col= split.column()
		sub= col.column()
		sub.active= SettingsGI.ray_distance_on
		sub.prop(SettingsGI, 'ray_distance')


class VRAY_RP_GI_sh(VRayRenderPanel, bpy.types.Panel):
	bl_label = "Spherical Harmonics"

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		module= context.scene.vray.SettingsGI
		return (engine_poll(__class__, context) and module.on and (module.primary_engine == 'SH'))

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		VRayScene=                  context.scene.vray
		SettingsGI=                 VRayScene.SettingsGI

		layout.prop(SettingsGI, 'spherical_harmonics', expand= True)

		layout.separator()

		if SettingsGI.spherical_harmonics == 'RENDER':
			SphericalHarmonicsRenderer= SettingsGI.SphericalHarmonicsRenderer

			split= layout.split()
			col= split.column()
			col.prop(SphericalHarmonicsRenderer, 'file_name')
			col.prop(SphericalHarmonicsRenderer, 'precalc_light_per_frame')

			layout.separator()

			split= layout.split()
			col= split.column()
			col.prop(SphericalHarmonicsRenderer, 'sample_environment')
			if SphericalHarmonicsRenderer.sample_environment:
				col.prop(SphericalHarmonicsRenderer, 'is_hemispherical')
				col.prop(SphericalHarmonicsRenderer, 'subdivs', slider= True)

			if wide_ui:
				col= split.column()

			col.prop(SphericalHarmonicsRenderer, 'apply_filtering')
			if SphericalHarmonicsRenderer.apply_filtering:
				col.prop(SphericalHarmonicsRenderer, 'filter_strength', slider= True)

		else:
			SphericalHarmonicsExporter= SettingsGI.SphericalHarmonicsExporter

			layout.prop(SphericalHarmonicsExporter, 'file_name')
			layout.prop(SphericalHarmonicsExporter, 'file_format')

			layout.separator()

			split= layout.split()
			col= split.column()
			col.prop(SphericalHarmonicsExporter, 'mode')

			if str(SphericalHarmonicsExporter.mode).endswith('_SEL'):
				col.prop_search(SphericalHarmonicsExporter, 'node',
								   context.scene,              'objects')

			col.prop(SphericalHarmonicsExporter, 'object_space')
			col.prop(SphericalHarmonicsExporter, 'per_normal')

			split= layout.split()
			col= split.column()
			col.prop(SphericalHarmonicsExporter, 'bands', slider= True)
			col.prop(SphericalHarmonicsExporter, 'subdivs', slider= True)
			if wide_ui:
				col= split.column()
			col.prop(SphericalHarmonicsExporter, 'ray_bias')

			if SphericalHarmonicsExporter.mode in ('INT_SEL', 'INT_ALL'):
				col.prop(SphericalHarmonicsExporter, 'bounces')
				col.prop(SphericalHarmonicsExporter, 'hit_recording')


class VRAY_RP_GI_im(VRayRenderPanel, bpy.types.Panel):
	bl_label = "Irradiance Map"

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		module= context.scene.vray.SettingsGI
		return engine_poll(__class__, context) and module.on and module.primary_engine == 'IM'

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		vs= context.scene.vray
		gi= vs.SettingsGI
		module= gi.SettingsIrradianceMap

		split= layout.split()
		colR= split.column()
		colR.prop(module, "mode", text="Mode")

		if module.mode not in ('FILE', 'ANIM_REND'):
			split= layout.split()
			col= split.column()
			col.label(text="Preset:")
			if wide_ui:
				col= split.column()
			col.menu('VRAY_MT_preset_IM', text="Preset")

			split= layout.split()
			split.label(text="Basic parameters:")

			split= layout.split()
			col= split.column(align=True)
			col.prop(module,"min_rate")
			col.prop(module,"max_rate")
			col.prop(module,"subdivs", text= "HSph. subdivs")
			if wide_ui:
				col= split.column(align=True)
			else:
				split= layout.split()
				col= split.column(align=True)
			col.prop(module,"color_threshold", text="Clr thresh", slider=True)
			col.prop(module,"normal_threshold", text="Nrm thresh", slider=True)
			col.prop(module,"distance_threshold", text="Dist thresh", slider=True)

			split= layout.split()
			split.column().prop(module,"interp_samples", text= "Interp. samples")
			if wide_ui:
				split.column()

			split= layout.split()
			split.label(text="Advanced parameters:")
			if wide_ui:
				split= layout.split(percentage=0.7)
			else:
				split= layout.split()
			col= split.column()
			col.prop(module,"interpolation_mode", text="Interp. type")
			col.prop(module,"lookup_mode")
			col.prop(module,"calc_interp_samples")
			if wide_ui:
				col= split.column()
			col.prop(module,"multipass")
			col.prop(module,"randomize_samples", text="Randomize")
			col.prop(module,"check_sample_visibility", text="Check sample")

		if module.mode == 'FILE':
			layout.label(text="Basic parameters:")
			layout.prop(module,"interp_samples", text= "Interp. samples")

			layout.label(text="Advanced parameters:")
			split= layout.split()
			col= split.column()
			col.prop(module,"interpolation_mode", text="Interp. type")
			col.prop(module,"lookup_mode")
			col.prop(module,"calc_interp_samples")

		if module.mode == 'ANIM_REND':
			split= layout.split()
			split.label(text="Basic parameters:")

			split= layout.split()
			colL= split.column()
			colL.prop(module,"interp_frames")

		split= layout.split()
		split.label(text="Detail enhancement:")
		if wide_ui:
			split= layout.split(percentage=0.07)
			split.column().prop(module, "detail_enhancement", text="")
			sub= split.column().row(align=True)
			sub.active= module.detail_enhancement
			sub.prop(module, "detail_radius", text="R")
			sub.prop(module, "detail_subdivs_mult", text="Subdivs", slider=True)
			sub.prop(module, "detail_scale", text="")
		else:
			split= layout.split()
			col= split.column()
			col.prop(module, "detail_enhancement", text="Use")
			sub= col.column(align=True)
			sub.active= module.detail_enhancement
			sub.prop(module, "detail_radius", text="R")
			sub.prop(module, "detail_subdivs_mult", text="Subdivs", slider=True)
			sub.prop(module, "detail_scale", text="")

		layout.label(text="Show:")
		split = layout.split()
		if wide_ui:
			col = split.row()
		else:
			col = split.column()
		col.prop(module,"show_calc_phase", text="Calc phase")
		sub = col.column()
		sub.active = module.show_calc_phase
		sub.prop(module,"show_direct_light", text="Direct light")
		col.prop(module,"show_samples", text="Samples")

		layout.label(text="Options:")
		split= layout.split()
		col= split.column()
		col.prop(module,"multiple_views", text="Use camera path")

		split= layout.split()
		split.label(text="Files:")
		split= layout.split(percentage=0.3)
		colL= split.column()
		colR= split.column()
		if module.mode in ('FILE', 'ANIM_REND'):
			colL.label(text="Map file name:")
			colR.prop(module,"file", text="")
		else:
			colL.prop(module,"auto_save", text="Auto save")
			colR.active= module.auto_save
			colR.prop(module,"auto_save_file", text="")


class VRAY_RP_GI_bf(VRayRenderPanel, bpy.types.Panel):
	bl_label = "Brute Force"

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		module= context.scene.vray.SettingsGI
		return engine_poll(__class__, context) and module.on and (module.primary_engine == 'BF' or module.secondary_engine == 'BF') and (module.primary_engine != 'SH')

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		vsce= context.scene.vray
		gi= vsce.SettingsGI
		module= gi.SettingsDMCGI

		split= layout.split()
		col= split.column()
		col.prop(module, "subdivs")
		if gi.secondary_engine == 'BF':
			if wide_ui:
				col= split.column()
			col.prop(module, "depth")


class VRAY_RP_GI_lc(VRayRenderPanel, bpy.types.Panel):
	bl_label = "Light Cache"

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		module= context.scene.vray.SettingsGI
		return (engine_poll(__class__, context) and module.on and (module.primary_engine == 'LC' or module.secondary_engine == 'LC')) and (module.primary_engine != 'SH')

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		vs= context.scene.vray
		module= vs.SettingsGI.SettingsLightCache

		split= layout.split()
		col= split.column()
		col.prop(module, "mode", text="Mode")

		if not module.mode == 'FILE':
			layout.label(text="Calculation parameters:")
			if wide_ui:
				split= layout.split(percentage=0.6)
			else:
				split= layout.split()
			col= split.column()
			col.prop(module, "subdivs")
			col.prop(module, "sample_size")
			col.prop(module, "world_scale", text="Sample scale")
			if not module.num_passes_auto:
				col.prop(module, "num_passes")
			col.prop(module, "depth", slider= True)

			if wide_ui:
				col= split.column()
			col.prop(module, "store_direct_light")
			col.prop(module, "adaptive_sampling")
			col.prop(module, "show_calc_phase")
			col.prop(module, "num_passes_auto")

		layout.label(text="Reconstruction parameters:")
		split= layout.split(percentage=0.2)
		split.column().prop(module, "filter")
		sub= split.column().row()
		sub.active= module.filter
		sub.prop(module, "filter_type", text="Type")
		if module.filter_type != 'NONE':
			if module.filter_type == 'NEAREST':
				sub.prop(module, "filter_samples")
			else:
				sub.prop(module, "filter_size")
		else:
			sub.label(text="")

		split= layout.split(percentage=0.2)
		split.column().prop(module, "prefilter")
		colR= split.column()
		colR.active= module.prefilter
		colR.prop(module, "prefilter_samples")

		split= layout.split()
		split= layout.split()
		col= split.column()
		col.prop(module, "use_for_glossy_rays")
		col.prop(module, "multiple_views")
		if wide_ui:
			col= split.column()
		col.prop(module, "retrace_enabled")
		sub= col.column()
		sub.active= module.retrace_enabled
		sub.prop(module, "retrace_threshold", text="Retrace thresh.")

		split= layout.split()
		split.label(text="Files:")
		split= layout.split(percentage=0.3)
		colL= split.column()
		colR= split.column()
		if module.mode == 'FILE':
			colL.label(text="Map file name:")
			colR.prop(module,"file", text="")
		else:
			colL.prop(module,"auto_save", text="Auto save")
			colR.active= module.auto_save
			colR.prop(module,"auto_save_file", text="")


class VRAY_RP_displace(VRayRenderPanel, bpy.types.Panel):
	bl_label = "Displace / subdiv"

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		VRayExporter= context.scene.vray.exporter
		return engine_poll(__class__, context) and VRayExporter.use_displace

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		VRayScene= context.scene.vray
		SettingsDefaultDisplacement= VRayScene.SettingsDefaultDisplacement

		split= layout.split()
		col= split.column()
		col.prop(SettingsDefaultDisplacement, 'amount')
		col.prop(SettingsDefaultDisplacement, 'edgeLength')
		col.prop(SettingsDefaultDisplacement, 'maxSubdivs')
		if wide_ui:
			col= split.column()
		col.prop(SettingsDefaultDisplacement, 'viewDependent')
		col.prop(SettingsDefaultDisplacement, 'tightBounds')
		col.prop(SettingsDefaultDisplacement, 'relative')
		col.prop(SettingsDefaultDisplacement, 'override_on')


class VRAY_RP_dr(VRayRenderPanel, bpy.types.Panel):
	bl_label = "Distributed rendering"

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		vs= context.scene.vray
		module= vs.VRayDR
		return engine_poll(__class__, context) and module.on

	def draw(self, context):
		layout = self.layout

		VRayScene = context.scene.vray
		VRayDR          = VRayScene.VRayDR
		SettingsOptions = VRayScene.SettingsOptions

		layout.prop(VRayDR, 'transferAssets')

		if VRayDR.transferAssets == '0':
			layout.prop(VRayDR, 'shared_dir', text="Share Path")
			if PLATFORM == 'win32':
				layout.prop(VRayDR, 'share_name', text="Share Name")
		else:
			split= layout.split()
			col= split.column()
			col.prop(VRayDR, 'renderOnlyOnNodes')
			col.prop(SettingsOptions, 'misc_abortOnMissingAsset')
			col.prop(SettingsOptions, 'dr_overwriteLocalCacheSettings')
			split= layout.split()
			split.active = SettingsOptions.dr_overwriteLocalCacheSettings
			col= split.column()
			col.prop(SettingsOptions, 'dr_assetsCacheLimitType', text="Cache Limit")
			sub = col.row()
			sub.active = SettingsOptions.dr_assetsCacheLimitType != '0'
			sub.prop(SettingsOptions, 'dr_assetsCacheLimitValue', text="Limit")

		layout.separator()
		layout.prop(VRayDR, 'port', text="Port")

		layout.separator()

		split= layout.split()
		row= split.row()
		row.template_list("VRayListDR", "", VRayDR, 'nodes', VRayDR, 'nodes_selected', rows= 3)
		col= row.column(align=True)
		col.operator('vray.render_nodes_add',    text="", icon="ZOOMIN")
		col.operator('vray.render_nodes_remove', text="", icon="ZOOMOUT")

		col = col.row().column(align=True)
		col.operator('vray.dr_nodes_load',       text="", icon="FILE_FOLDER")
		col.operator('vray.dr_nodes_save',       text="", icon="SAVE_PREFS")

		if VRayDR.nodes_selected >= 0 and len(VRayDR.nodes) > 0:
			render_node= VRayDR.nodes[VRayDR.nodes_selected]

			layout.separator()

			layout.prop(render_node, 'name')
			layout.prop(render_node, 'address')


class VRAY_RP_bake(VRayRenderPanel, bpy.types.Panel):
	bl_label   = "Bake"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		VRayScene= context.scene.vray
		VRayBake= VRayScene.VRayBake
		return (engine_poll(__class__, context) and VRayBake.use)

	def draw(self, context):
		wide_ui= context.region.width > narrowui

		VRayScene= context.scene.vray
		VRayBake= VRayScene.VRayBake

		layout= self.layout

		split= layout.split()
		col= split.column()
		col.prop_search(VRayBake, 'bake_node', context.scene, 'objects')
		
		col.prop(VRayBake, 'uvChannel')

		split= layout.split()
		col= split.column()
		col.prop(VRayBake, 'dilation')
		if wide_ui:
			col= split.column()
		col.prop(VRayBake, 'flip_derivs')


class VRAY_PA_SettingsVFB(VRayRenderPanel, bpy.types.Panel):
	bl_label = "Lens Effects"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw_header(self, context):
		VRayScene = context.scene.vray
		SettingsVFB = VRayScene.SettingsVFB
		self.layout.prop(SettingsVFB, 'use', text="")

	def draw(self, context):
		wide_ui = context.region.width > narrowui
		layout = self.layout

		VRayScene = context.scene.vray
		SettingsVFB = VRayScene.SettingsVFB

		layout.active = SettingsVFB.use

		layout.prop(SettingsVFB, 'bloom_on', text="Bloom")
		split = layout.split()
		split.active = SettingsVFB.bloom_on
		col = split.column()
		col.prop(SettingsVFB, 'bloom_mode', text="Mode")
		col.prop(SettingsVFB, 'bloom_fill_edges', text="Fill Edges")
		col.prop(SettingsVFB, 'bloom_weight', text="Weight")
		col.prop(SettingsVFB, 'bloom_size', text="Size")
		col.prop(SettingsVFB, 'bloom_shape', text="Shape")
		if wide_ui:
			col = split.column()
		col.prop(SettingsVFB, 'bloom_mask_intensity_on', text="Mask Intensity")
		col.prop(SettingsVFB, 'bloom_mask_intensity', text="Intensity")
		col.prop(SettingsVFB, 'bloom_mask_objid_on', text="Use Object ID")
		col.prop(SettingsVFB, 'bloom_mask_objid', text="Object ID")
		col.prop(SettingsVFB, 'bloom_mask_mtlid_on', text="Use Material ID")
		col.prop(SettingsVFB, 'bloom_mask_mtlid', text="Material ID")

		layout.prop(SettingsVFB, 'glare_on', text="Glare")
		split = layout.split()
		split.active = SettingsVFB.glare_on
		col = split.column()
		col.prop(SettingsVFB, 'glare_mode', text="Mode")
		col.prop(SettingsVFB, 'glare_type', text="Type")
		col.prop(SettingsVFB, 'glare_fill_edges', text="Fill Edges")
		col.prop(SettingsVFB, 'glare_weight', text="Weight")
		col.prop(SettingsVFB, 'glare_size', text="Size")
		col.prop(SettingsVFB, 'glare_diffraction_on', text="Use Diffraction")
		col.prop(SettingsVFB, 'glare_cam_blades_on', text="Use Blades")
		col.prop(SettingsVFB, 'glare_cam_num_blades', text="Num. Blades")
		col.prop(SettingsVFB, 'glare_cam_rotation', text="Rotation")
		col.prop(SettingsVFB, 'glare_cam_fnumber', text="F-Number")
		if wide_ui:
			col = split.column()
		col.prop(SettingsVFB, 'glare_mask_intensity_on', text="Mask Intensity")
		col.prop(SettingsVFB, 'glare_mask_intensity', text="Intensity")
		col.prop(SettingsVFB, 'glare_mask_objid_on', text="Use Object ID")
		col.prop(SettingsVFB, 'glare_mask_objid', text="Object ID")
		col.prop(SettingsVFB, 'glare_mask_mtlid_on', text="Use Material ID")
		col.prop(SettingsVFB, 'glare_mask_mtlid', text="Material ID")
		col.prop(SettingsVFB, 'glare_image_path', text="Image Path")
		col.prop(SettingsVFB, 'glare_use_obstacle_image', text="Use Obstacle Image")
		col.prop(SettingsVFB, 'glare_obstacle_image_path', text="Obstacle Path")

		layout.label("Misc")
		split = layout.split()
		col = split.column()
		col.prop(SettingsVFB, 'interactive')


class VRAY_RP_SettingsSystem(VRayRenderPanel, bpy.types.Panel):
	bl_label   = "System"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		return engine_poll(__class__, context)

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		rd= context.scene.render

		VRayScene= context.scene.vray
		SettingsRaycaster=        VRayScene.SettingsRaycaster
		SettingsUnitsInfo=        VRayScene.SettingsUnitsInfo
		SettingsRegionsGenerator= VRayScene.SettingsRegionsGenerator
		SettingsOptions=          VRayScene.SettingsOptions
		VRayExporter=             VRayScene.exporter

		layout.label(text="Threads:")
		split= layout.split()
		col= split.column()
		col.row().prop(rd, "threads_mode", expand=True)
		if wide_ui:
			col= split.column(align=True)
		sub= col.column()
		sub.enabled= rd.threads_mode == 'FIXED'
		sub.prop(rd, 'threads', text="Count")
		layout.prop(VRayExporter, 'meshExportThreads')

		layout.separator()
		layout.label(text="Raycaster parameters:")
		split= layout.split()
		col= split.column()
		col.prop(SettingsRaycaster, 'maxLevels')
		col.prop(SettingsRaycaster, 'minLeafSize')
		if wide_ui:
			col= split.column()
		col.prop(SettingsRaycaster, 'faceLevelCoef')
		col.prop(SettingsOptions, 'misc_lowThreadPriority')
		split= layout.split()
		col= split.column()
		col.prop(SettingsRaycaster, 'dynMemLimit')

		layout.separator()
		layout.prop(SettingsRaycaster, 'embreeUse', text="Use Embree")
		split = layout.split()
		split.active = SettingsRaycaster.embreeUse
		col = split.column()
		col.prop(SettingsRaycaster, 'embreeUseMB', text="Use For Motion Blur")
		col.prop(SettingsRaycaster, 'embreeHighPrec', text="High Precision")
		if wide_ui:
			col = split.column()
		col.prop(SettingsRaycaster, 'embreeLowMemory', text="Low Memory")
		col.prop(SettingsRaycaster, 'embreeRayPackets', text="Ray Packets")

		# layout.separator()
		# layout.label(text="Units scale:")
		# split= layout.split()
		# col= split.column()
		# col.prop(SettingsUnitsInfo, 'meters_scale', text="Metric")
		# if wide_ui:
		# 	col= split.column()
		# col.prop(SettingsUnitsInfo, 'photometric_scale', text="Photometric")

		layout.separator()

		layout.label(text="Render region division:")
		split= layout.split()
		col= split.column()
		col.prop(SettingsRegionsGenerator, 'xymeans', text="XY")
		col.prop(SettingsRegionsGenerator, 'seqtype')
		col.prop(SettingsRegionsGenerator, 'reverse')
		if wide_ui:
			col= split.column()
		sub= col.row(align=True)
		sub.prop(SettingsRegionsGenerator, 'xc')
		sub= sub.column()
		sub.active= not SettingsRegionsGenerator.lock_size
		sub.prop(SettingsRegionsGenerator, 'yc')
		col.prop(SettingsRegionsGenerator, 'lock_size')

		layout.separator()
		layout.prop(VRayExporter, 'verboseLevel')


class VRAY_RP_about(VRayRenderPanel, bpy.types.Panel):
	bl_label   = "About"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES= {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		return engine_poll(__class__, context)

	def draw(self, context):
		layout= self.layout

		split= layout.split()
		col= split.column()
		col.label(text="V-Ray For Blender %s" % version.VERSION)
		col.separator()
		col.label(text="URL: http://chaosgroup.com")
		col.label(text="Developer: Andrei Izrantcev")
		col.label(text="Email: andrei.izrantcev@chaosgroup.com")
		col.separator()
		col.label(text="IRC: irc.freenode.net #vrayblender")
		col.separator()
		col.label(text="V-Ray(R) is a registered trademark of Chaos Group Ltd.")


def GetRegClasses():
	return (
		VRAY_MT_preset_IM,
		VRAY_MT_preset_global,
		VRAY_MT_preset_gi,
		VRAY_RP_dimensions,
		VRAY_RP_output,
		VRAY_RP_render,
		VRAY_RP_SettingsOptions,
		VRAY_RP_exporter,
		VRAY_RP_cm,
		VRAY_RP_aa,
		VRAY_RP_dmc,
		VRAY_RP_gi,
		VRAY_RP_GI_sh,
		VRAY_RP_GI_im,
		VRAY_RP_GI_bf,
		VRAY_RP_GI_lc,
		VRAY_RP_displace,
		VRAY_RP_dr,
		VRAY_RP_bake,
		VRAY_PA_SettingsVFB,
		VRAY_RP_SettingsSystem,
		VRAY_RP_about,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = properties_scene
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
  
'''


''' Blender modules '''
import bpy

''' vb modules '''
from vb25.utils import *
from vb25.ui.ui import *
from vb25.plugins import *


class VRAY_RP_Layers(VRayRenderLayersPanel, bpy.types.Panel):
	bl_label   = "Render Elements"
	bl_options = {'HIDE_HEADER'}
	
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		return engine_poll(__class__, context)

	def draw_header(self, context):
		VRayScene = context.scene.vray
		self.layout.prop(VRayScene, 'render_channels_use', text="")

	def draw(self, context):
		VRayScene = context.scene.vray
		self.layout.prop(VRayScene, 'render_channels_use', text="Use Render Elements")

		wide_ui = context.region.width > narrowui
		layout= self.layout

		sce= context.scene
		vsce= sce.vray
		render_channels= vsce.render_channels

		layout.active= vsce.render_channels_use

		row= layout.row()
		row.template_list("VRayListUse", "",
						  vsce, 'render_channels',
						  vsce, 'render_channels_index',
						  rows= 4)
		col= row.column()
		sub= col.row()
		subsub= sub.column(align=True)
		subsub.operator('vray.render_channels_add',	   text="", icon="ZOOMIN")
		subsub.operator('vray.render_channels_remove', text="", icon="ZOOMOUT")

		if vsce.render_channels_index >= 0 and len(render_channels) > 0:
			render_channel= render_channels[vsce.render_channels_index]

			layout.separator()

			if wide_ui:
				split= layout.split(percentage=0.2)
			else:
				split= layout.split()
			col= split.column()
			col.label(text="Name:")
			if wide_ui:
				col= split.column()
			row= col.row(align=True)
			row.prop(render_channel, 'name', text="")

			if wide_ui:
				split= layout.split(percentage=0.2)
			else:
				split= layout.split()
			col= split.column()
			col.label(text="Type:")
			if wide_ui:
				col= split.column()
			col.prop(render_channel, 'type', text="")

			layout.separator()

			if render_channel.type != 'NONE':
				# Box border
				layout= layout.box()

				plugin= PLUGINS['RENDERCHANNEL'].get(render_channel.type)
				if plugin is not None:
					render_channel_data= getattr(render_channel,plugin.PLUG)

					if render_channel.name == "" or render_channel.name == "RenderChannel":
						def get_unique_name():
							for chan in render_channels:
								if render_channel_data.name == chan.name:
									return render_channel_data.name + " (enter unique name)"
							return render_channel_data.name
						render_channel.name= get_unique_name()

					plugin.draw(getattr(render_channel,plugin.PLUG), layout, wide_ui)


class VRAY_SP_includer(VRayScenePanel, bpy.types.Panel):
	bl_label   = "Includes"
	bl_options = {'DEFAULT_CLOSED'}
	
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw_header(self, context):
		VRayScene = context.scene.vray
		Includer  = VRayScene.Includer
		self.layout.label(text="", icon='VRAY_LOGO_MONO')
		self.layout.prop(Includer, 'use', text="")

	def draw(self, context):
		wide_ui= context.region.width > narrowui

		layout= self.layout

		row= layout.row()

		vs= context.scene.vray
		module= vs.Includer
		
		layout.active= module.use

		row.template_list("VRayListUse", "", module, 'nodes', module, 'nodes_selected', rows = 4)

		col= row.column()
		sub= col.row()
		subsub= sub.column(align=True)
		subsub.operator('vray.includer_add',    text="", icon="ZOOMIN")
		subsub.operator('vray.includer_remove', text="", icon="ZOOMOUT")
		sub= col.row()
		subsub= sub.column(align=True)
		subsub.operator("vray.includer_up",   icon='MOVE_UP_VEC',   text="")
		subsub.operator("vray.includer_down", icon='MOVE_DOWN_VEC', text="")

		if module.nodes_selected >= 0 and len(module.nodes) > 0:
			render_node= module.nodes[module.nodes_selected]

			layout.separator()

			layout.prop(render_node, 'name')
			layout.prop(render_node, 'scene')

		# layout.separator()
		# box= layout.box()
		# box.label(text="Enable options export in curent scene:")
		# split = box.split()
		# col= split.column()
		# col.prop(module, 'setting', text="Use export scene setting")
		# col.prop(module, 'camera', text="Use export camera")
		# col.prop(module, 'materials', text="Use export materials")
		
		# col.prop(module, 'environment', text="Use export environment")
		# col.prop(module, 'lights', text="Use export lights")
		# col.prop(module, 'colorMapping_standalone', text="Use Color Mapping")
		# col.prop(module, 'geometry', text="Use export geometry")
		# col.prop(module, 'scene_nodes', text="Use Vray Nodes")


class VRAY_SP_tools(VRayScenePanel, bpy.types.Panel):
	bl_label   = "Tools"
	bl_options = {'DEFAULT_CLOSED'}
	
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw(self, context):
		wide_ui= context.region.width > narrowui

		layout= self.layout

		box= layout.box()
		box.label(text="Scene:")
		split= box.split()
		col= split.column()
		col.operator("vray.convert_materials", icon='MATERIAL')
		if wide_ui:
			col= split.column()
		col.operator("vray.settings_to_text", icon='TEXT')

		layout.separator()

		box= layout.box()
		box.label(text="Object:")
		split= box.split()
		col= split.column()
		col.operator("vray.copy_linked_materials", icon='MATERIAL')

		# layout.separator()

		# layout.operator("vray.update", icon='SCENE_DATA')


class VRAY_SP_lights_tweaker(VRayScenePanel, bpy.types.Panel):
	bl_label   = "Lights"
	bl_options = {'DEFAULT_CLOSED'}
	
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw(self, context):
		wide_ui= context.region.width > narrowui

		layout= self.layout

		split= layout.split()
		col= split.column()

		if bpy.data.lamps:
			for lamp in bpy.data.lamps:
				VRayLamp= lamp.vray
				sub_t= col.row()
				sub_t.label(text= " %s" % lamp.name, icon='LAMP_%s' % lamp.type)

				sub= col.row(align= True)
				sub_c= sub.row()
				sub_c.prop(VRayLamp, 'enabled', text="")
				sub_c.prop(lamp,     'color',     text="")
				sub_v= sub.row()
				sub_v.prop(VRayLamp, 'intensity', text="")
				sub_v.prop(VRayLamp, 'subdivs',   text="")
		else:
			col.label(text="Nothing in bpy.data.lamps...")


def GetRegClasses():
	return (
		VRAY_RP_Layers,
		VRAY_SP_includer,
		VRAY_SP_tools,
		VRAY_SP_lights_tweaker,
	)


def register():
	from bl_ui import properties_scene
	for member in dir(properties_scene):
		subclass = getattr(properties_scene, member)
		try:
			subclass.COMPAT_ENGINES.add('VRAY_RENDER')
			subclass.COMPAT_ENGINES.add('VRAY_RENDER_PREVIEW')
		except:
			pass
	del properties_scene

	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	from bl_ui import properties_scene
	for member in dir(properties_scene):
		subclass = getattr(properties_scene, member)
		try:
			subclass.COMPAT_ENGINES.remove('VRAY_RENDER')
			subclass.COMPAT_ENGINES.remove('VRAY_RENDER_PREVIEW')
		except:
			pass
	del properties_scene

	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = properties_texture
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy

''' vb modules '''
from vb25.utils import *
from vb25.ui.ui import *
from vb25.plugins import *

from bl_ui.properties_material import active_node_mat
from bl_ui.properties_texture  import id_tex_datablock

from bpy.types import Brush, Lamp, Material, Object, ParticleSettings, Texture, World


class VRAY_TP_context(VRayTexturePanel, bpy.types.Panel):
	bl_label = ""
	bl_options = {'HIDE_HEADER'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		if not hasattr(context, "texture_slot"):
			return False

		return ((context.material or context.world or context.lamp or context.brush or context.texture or context.particle_system or isinstance(context.space_data.pin_id, bpy.types.ParticleSettings))
				and engine_poll(cls, context))

	def draw(self, context):
		layout = self.layout
		slot = context.texture_slot
		node = context.texture_node
		space = context.space_data
		tex = context.texture
		idblock = context_tex_datablock(context)
		pin_id = space.pin_id

		if space.use_pin_id and not isinstance(pin_id, bpy.types.Texture):
			idblock = id_tex_datablock(pin_id)
			pin_id = None

		if not space.use_pin_id:
			layout.prop(space, "texture_context", expand=True)

		tex_collection = (pin_id is None) and (node is None) and (not isinstance(idblock, bpy.types.Brush))

		if tex_collection:
			row = layout.row()

			row.template_list("TEXTURE_UL_texslots", "", idblock, "texture_slots", idblock, "active_texture_index", rows=2)

			col = row.column(align=True)
			col.operator("texture.slot_move", text="", icon='TRIA_UP').type = 'UP'
			col.operator("texture.slot_move", text="", icon='TRIA_DOWN').type = 'DOWN'
			col.menu("TEXTURE_MT_specials", icon='DOWNARROW_HLT', text="")

		if tex_collection:
			layout.template_ID(idblock, "active_texture", new="texture.new")
		elif node:
			layout.template_ID(node, "texture", new="texture.new")
		elif idblock:
			layout.template_ID(idblock, "texture", new="texture.new")

		if pin_id:
			layout.template_ID(space, "pin_id")

		if tex:
			split = layout.split(percentage=0.2)

			if slot and tex.use_nodes:
				split.label(text="Output:")
				split.prop(slot, "output_node", text="")

			if not tex.use_nodes:
				layout.prop(tex, 'type', text="Texture")
				if tex.type == 'VRAY':
					layout.prop(tex.vray, 'type', text="Type")


class VRAY_TP_preview(VRayTexturePanel, bpy.types.Panel):
	bl_label = "Preview"

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		tex= context.texture

		if not tex:
			return False

		if tex.type == 'VRAY' and context.scene.render.engine == 'VRAY_RENDER':
			return False

		return super().poll(context)

	def draw(self, context):
		layout= self.layout

		tex= context.texture
		slot= getattr(context, "texture_slot", None)
		idblock= context_tex_datablock(context)

		if idblock:
			layout.template_preview(tex, parent= idblock, slot= slot)
		else:
			layout.template_preview(tex, slot= slot)


class VRAY_TP_influence(VRayTexturePanel, bpy.types.Panel):
	bl_label = "Influence"

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	# @classmethod
	# def poll(cls, context):
	# 	idblock = context_tex_datablock(context)
	# 	if isinstance(idblock, bpy.types.Brush):
	# 		return False

	# 	# If texture used in nodes influence is set by node itself
	# 	if not hasattr(context, 'texture_slot'):
	# 		return False

	# 	texture= context.texture_slot.texture if context.texture_slot else context.texture

	# 	if not texture:
	# 		return False

	# 	if texture.type == 'VRAY' and texture.vray.type == 'NONE':
	# 		return False

	# 	return super().poll(context) and (context.material or context.world or context.lamp or context.brush or context.texture)

	@classmethod
	def poll(cls, context):
		idblock = context_tex_datablock(context)
		if isinstance(idblock, Brush):
			return False

		if not getattr(context, "texture_slot", None):
			return False

		engine = context.scene.render.engine
		return (engine in cls.COMPAT_ENGINES)

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		idblock= context_tex_datablock(context)

		slot=    context.texture_slot
		texture= slot.texture if slot else context.texture

		VRaySlot= texture.vray_slot

		if issubclass(type(idblock), bpy.types.Material):
			material=     active_node_mat(context.material)
			VRayMaterial= material.vray

			PLUGINS['BRDF'][VRayMaterial.type].influence(context, layout, slot)

			PLUGINS['BRDF']['BRDFBump'].influence(context, layout, slot)

			PLUGINS['GEOMETRY']['GeomDisplacedMesh'].influence(context, layout, slot)

		elif issubclass(type(idblock), bpy.types.Lamp):
			VRayLight= VRaySlot.VRayLight

			split= layout.split()
			col= split.column()
			factor_but(col, VRayLight, 'map_color', 'color_mult', "Color")
			factor_but(col, VRayLight, 'map_shadowColor', 'shadowColor_mult', "Shadow")
			if wide_ui:
				col= split.column()
			factor_but(col, VRayLight, 'map_intensity', 'intensity_mult', "Intensity")

		elif issubclass(type(idblock), bpy.types.World):
			split= layout.split()
			col= split.column()
			col.label(text="Environment:")
			factor_but(col, VRaySlot, 'use_map_env_bg',         'env_bg_factor',         "Background")
			if wide_ui:
				col= split.column()
			col.label(text="Override:")
			factor_but(col, VRaySlot, 'use_map_env_gi',         'env_gi_factor',         "GI")
			factor_but(col, VRaySlot, 'use_map_env_reflection', 'env_reflection_factor', "Reflections")
			factor_but(col, VRaySlot, 'use_map_env_refraction', 'env_refraction_factor', "Refractions")

		elif isinstance(idblock, bpy.types.ParticleSettings):
			split = layout.split()

			col = split.column()
			col.label(text="General:")
			factor_but(col, slot, "use_map_time", "time_factor", "Time")
			factor_but(col, slot, "use_map_life", "life_factor", "Lifetime")
			factor_but(col, slot, "use_map_density", "density_factor", "Density")
			factor_but(col, slot, "use_map_size", "size_factor", "Size")

			col = split.column()
			col.label(text="Physics:")
			factor_but(col, slot, "use_map_velocity", "velocity_factor", "Velocity")
			factor_but(col, slot, "use_map_damp", "damp_factor", "Damp")
			factor_but(col, slot, "use_map_gravity", "gravity_factor", "Gravity")
			factor_but(col, slot, "use_map_field", "field_factor", "Force Fields")

			layout.label(text="Hair:")

			split = layout.split()

			col = split.column()
			factor_but(col, slot, "use_map_length", "length_factor", "Length")
			factor_but(col, slot, "use_map_clump", "clump_factor", "Clump")

			col = split.column()
			factor_but(col, slot, "use_map_kink", "kink_factor", "Kink")
			factor_but(col, slot, "use_map_rough", "rough_factor", "Rough")

		layout.separator()

		if not isinstance(idblock, bpy.types.ParticleSettings):
			split= layout.split()
			col= split.column()
			col.prop(VRaySlot,'blend_mode',text="Blend")
			if wide_ui:
				col= split.column()
			col.prop(slot,'use_stencil')



class VRAY_TP_displacement(VRayTexturePanel, bpy.types.Panel):
	bl_label = "Displacement"

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		idblock= context_tex_datablock(context)
		if not type(idblock) == bpy.types.Material:
			return False

		texture_slot= getattr(context,'texture_slot',None)
		if not texture_slot:
			return False

		texture= texture_slot.texture
		if not texture:
			return False

		VRaySlot= texture.vray_slot
		return VRaySlot.map_displacement and engine_poll(cls, context)

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		texture_slot= getattr(context,'texture_slot',None)
		texture= texture_slot.texture if texture_slot else context.texture

		if texture:
			VRaySlot= texture.vray_slot

			if VRaySlot:
				GeomDisplacedMesh= VRaySlot.GeomDisplacedMesh

				split= layout.split()
				col= split.column()
				col.prop(GeomDisplacedMesh, 'displacement_shift', slider=True)
				col.prop(GeomDisplacedMesh, 'water_level', slider=True)
				col.prop(GeomDisplacedMesh, 'resolution')
				col.prop(GeomDisplacedMesh, 'precision')
				if wide_ui:
					col= split.column()
				col.prop(GeomDisplacedMesh, 'keep_continuity')
				col.prop(GeomDisplacedMesh, 'filter_texture')
				if GeomDisplacedMesh.filter_texture:
					col.prop(GeomDisplacedMesh, 'filter_blur')
				col.prop(GeomDisplacedMesh, 'use_bounds')
				if GeomDisplacedMesh.use_bounds:
					sub= col.column(align= True)
					sub.prop(GeomDisplacedMesh, 'min_bound', text="Min", slider= True)
					sub.prop(GeomDisplacedMesh, 'max_bound', text="Max", slider= True)

				split= layout.split()
				col= split.column()
				col.prop(GeomDisplacedMesh, 'use_globals')
				if not GeomDisplacedMesh.use_globals:
					split= layout.split()
					col= split.column()
					col.prop(GeomDisplacedMesh, 'edge_length')
					col.prop(GeomDisplacedMesh, 'max_subdivs')
					if wide_ui:
						col= split.column()
					col.prop(GeomDisplacedMesh, 'view_dep')
					col.prop(GeomDisplacedMesh, 'tight_bounds')


class VRAY_TP_bitmap(VRayTexturePanel, bpy.types.Panel):
	bl_label = "Bitmap"

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		if not engine_poll(cls, context):
			return False

		tex= context.texture
		if not tex:
			return False

		return (tex.type == 'IMAGE' and tex.image)

	def draw(self, context):
		layout= self.layout
		wide_ui= context.region.width > narrowui

		slot= getattr(context,'texture_slot',None)
		tex= slot.texture if slot else context.texture

		BitmapBuffer= tex.image.vray.BitmapBuffer

		split= layout.split()
		col= split.column()
		col.prop(BitmapBuffer, 'color_space')

		split= layout.split()
		col= split.column()
		col.prop(BitmapBuffer, 'filter_type', text="Filter")
		if BitmapBuffer.filter_type != 'NONE':
			col.prop(BitmapBuffer, 'filter_blur')
		if BitmapBuffer.filter_type == 'MIPMAP':
			col.prop(BitmapBuffer, 'interpolation', text="Interp.")
		if wide_ui:
			col= split.column()
		col.prop(BitmapBuffer, 'use_input_gamma')
		if not BitmapBuffer.use_input_gamma:
			col.prop(BitmapBuffer, 'gamma')
			#col.prop(BitmapBuffer, 'gamma_correct')
		col.prop(BitmapBuffer, 'allow_negative_colors')
		col.prop(BitmapBuffer, 'use_data_window')


def GetRegClasses():
	return (
		VRAY_TP_context,
		VRAY_TP_preview,
		VRAY_TP_influence,
		VRAY_TP_displacement,
		VRAY_TP_bitmap,
	)


def register():
	from bl_ui import properties_texture
	properties_texture.TEXTURE_PT_image.COMPAT_ENGINES.add('VRAY_RENDER')
	properties_texture.TEXTURE_PT_image.COMPAT_ENGINES.add('VRAY_RENDER_PREVIEW')
	properties_texture.TEXTURE_PT_voxeldata.COMPAT_ENGINES.add('VRAY_RENDER')
	properties_texture.TEXTURE_PT_voxeldata.COMPAT_ENGINES.add('VRAY_RENDER_PREVIEW')
	del properties_texture

	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	from bl_ui import properties_texture
	try:
		properties_texture.TEXTURE_PT_image.COMPAT_ENGINES.remove('VRAY_RENDER')
		properties_texture.TEXTURE_PT_image.COMPAT_ENGINES.remove('VRAY_RENDER_PREVIEW')
		properties_texture.TEXTURE_PT_voxeldata.COMPAT_ENGINES.remove('VRAY_RENDER')
		properties_texture.TEXTURE_PT_voxeldata.COMPAT_ENGINES.remove('VRAY_RENDER_PREVIEW')
	except:
		pass
	del properties_texture

	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = properties_world
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy
from bpy.props import *

''' vb modules '''
from vb25.utils import *
from vb25.ui.ui import *
from vb25.plugins import *


class VRAY_WP_environment(VRayWorldPanel, bpy.types.Panel):
	bl_label = "Environment"

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw(self, context):
		layout= self.layout

		VRayWorld= context.world.vray

		split= layout.split()
		col= split.column()
		col.label(text="Background:")

		row= layout.row(align=True)
		row.prop(VRayWorld, 'bg_color_mult', text="Mult", slider=True)
		row.prop(VRayWorld, 'bg_color', text="")

		split= layout.split()
		col= split.column()
		col.label(text="Override:")

		split= layout.split()
		col= split.column()
		factor_but(col, VRayWorld, 'gi_override',         'gi_color_mult',         color= 'gi_color',         label= "GI")
		factor_but(col, VRayWorld, 'reflection_override', 'reflection_color_mult', color= 'reflection_color', label= "Reflection")
		factor_but(col, VRayWorld, 'refraction_override', 'refraction_color_mult', color= 'refraction_color', label= "Refraction")

		layout.separator()
		layout.prop(VRayWorld, 'global_light_level', slider= True)


class VRAY_WP_effects(VRayWorldPanel, bpy.types.Panel):
	bl_label   = "Effects"
	bl_options = {'DEFAULT_CLOSED'}

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw_header(self, context):
		VRayScene= context.scene.vray
		self.layout.prop(VRayScene.VRayEffects, 'use', text="")

	def draw(self, context):
		layout= self.layout

		wide_ui= context.region.width > narrowui

		VRayScene= context.scene.vray
		VRayEffects= VRayScene.VRayEffects

		layout.active= VRayEffects.use

		split= layout.split()
		row= split.row()
		row.template_list("VRayListUse", "",
						  VRayEffects, 'effects',
						  VRayEffects, 'effects_selected',
						  rows= 4)
		col= row.column()
		sub= col.row()
		subsub= sub.column(align=True)
		subsub.operator('vray.effect_add',    text="", icon="ZOOMIN")
		subsub.operator('vray.effect_remove', text="", icon="ZOOMOUT")
		sub= col.row()
		subsub= sub.column(align=True)
		subsub.operator("vray.effect_up",   icon='MOVE_UP_VEC',   text="")
		subsub.operator("vray.effect_down", icon='MOVE_DOWN_VEC', text="")

		if VRayEffects.effects_selected >= 0:
			layout.separator()

			effect= VRayEffects.effects[VRayEffects.effects_selected]

			if wide_ui:
				split= layout.split(percentage=0.2)
			else:
				split= layout.split()
			col= split.column()
			col.label(text="Name:")
			if wide_ui:
				col= split.column()
			row= col.row(align=True)
			row.prop(effect, 'name', text="")

			if wide_ui:
				split= layout.split(percentage=0.2)
			else:
				split= layout.split()
			col= split.column()
			col.label(text="Type:")
			if wide_ui:
				col= split.column()
			col.prop(effect, 'type', text="")

			layout.separator()

			# Box border
			box = layout.box()
			box.active = effect.use

			if effect.type == 'FOG':
				PLUGINS['SETTINGS']['SettingsEnvironment'].draw_EnvironmentFog(context, box, effect)

			elif effect.type == 'TOON':
				PLUGINS['SETTINGS']['SettingsEnvironment'].draw_VolumeVRayToon(context, box, effect)

			elif effect.type == 'SFADE':
				PLUGINS['SETTINGS']['SettingsEnvironment'].draw_SphereFade(context, box, effect)


def GetRegClasses():
	return (
		VRAY_WP_environment,
		VRAY_WP_effects,
	)


def register():
	from bl_ui import properties_world
	properties_world.WORLD_PT_context_world.COMPAT_ENGINES.add('VRAY_RENDER')
	del properties_world

	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	from bl_ui import properties_world
	try:
		properties_world.WORLD_PT_context_world.COMPAT_ENGINES.remove('VRAY_RENDER')
	except:
		pass
	del properties_world

	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = ui
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''

import bpy
from bl_ui.properties_material import active_node_mat


narrowui = 200


def context_tex_datablock(context):
	idblock = context.material
	if idblock:
		return active_node_mat(idblock)

	idblock = context.lamp
	if idblock:
		return idblock

	idblock = context.world
	if idblock:
		return idblock

	idblock = context.brush
	if idblock:
		return idblock

	if context.particle_system:
		idblock = context.particle_system.settings

	return idblock


def factor_but(layout, rna_pointer, use, factor, label= None, color= None):
	row= layout.row(align=True)
	row.prop(rna_pointer,
			 use,
			 text= "")
	sub= row.row(align=True)
	sub.active= getattr(rna_pointer, use)
	sub.prop(rna_pointer,
			 factor,
			 slider= True,
			 text= label if label else "")
	if color:
		sub.prop(rna_pointer, color, text="")

	invert= use+'_invert'
	if hasattr(rna_pointer, invert):
		sub.prop(rna_pointer, invert,text= "")


def influenceItemUI(layout, rna_pointer, attr, label):
	textureAttr   = "map_"+attr
	textureMult   = attr+"_mult"
	textureInvert = attr+"_invert"

	row = layout.row(align=True)
	row.prop(rna_pointer, textureAttr, text="")

	sub = row.row(align=True)
	sub.active = getattr(rna_pointer, textureAttr)
	sub.prop(rna_pointer, textureMult, slider=True, text=label)

	if hasattr(rna_pointer, textureInvert):
		sub.prop(rna_pointer, textureInvert, text="")


def engine_poll(cls, context):
	rd= context.scene.render
	return (rd.engine in cls.COMPAT_ENGINES)


def texture_type_poll(cls, context, tex, tex_type):
	if not engine_poll(cls, context):
		return False
	return tex and tex.type == 'VRAY' and tex.vray.type == tex_type


class VRayPanel:
	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	def draw_header(self, context):
		self.layout.label(text="", icon='VRAY_LOGO_MONO')


class VRayDataPanel(VRayPanel):
	bl_space_type  = 'PROPERTIES'
	bl_region_type = 'WINDOW'
	bl_context     = 'data'

	@classmethod
	def poll(cls, context):
		if not engine_poll(cls, context):
			return False
		return context.mesh or context.curve


class VRayLampPanel():
	bl_space_type  = 'PROPERTIES'
	bl_region_type = 'WINDOW'
	bl_context     = 'data'

	@classmethod
	def poll(cls, context):
		return context.lamp and engine_poll(cls, context)


class VRayMaterialPanel():
	bl_space_type  = 'PROPERTIES'
	bl_region_type = 'WINDOW'
	bl_context     = 'material'

	@classmethod
	def poll(cls, context):
		if not engine_poll(cls, context):
			return False

		ma = context.material
		if not ma:
			return False

		VRayMaterial = ma.vray
		if VRayMaterial.nodetree:
			return False

		return True


class VRayObjectPanel(VRayPanel):
	bl_space_type  = 'PROPERTIES'
	bl_region_type = 'WINDOW'
	bl_context     = 'object'

	@classmethod
	def poll(cls, context):
		return engine_poll(cls, context)


class VRayParticlePanel(VRayPanel):
	bl_space_type  = 'PROPERTIES'
	bl_region_type = 'WINDOW'
	bl_context     = 'particle'

	@classmethod
	def poll(cls, context):
		return context.particle_system and engine_poll(cls, context)


class VRayRenderPanel():
	bl_space_type  = 'PROPERTIES'
	bl_region_type = 'WINDOW'
	bl_context     = 'render'

	@classmethod
	def poll(cls, context):
		return engine_poll(cls, context)


class VRayRenderLayersPanel(VRayPanel):
	bl_space_type  = 'PROPERTIES'
	bl_region_type = 'WINDOW'
	bl_context     = 'render_layer'

	@classmethod
	def poll(cls, context):
		return engine_poll(cls, context)


class VRayScenePanel(VRayPanel):
	bl_space_type  = 'PROPERTIES'
	bl_region_type = 'WINDOW'
	bl_context     = 'scene'

	@classmethod
	def poll(cls, context):
		return engine_poll(cls, context)


class VRayTexturePanel(VRayPanel):
	bl_space_type  = 'PROPERTIES'
	bl_region_type = 'WINDOW'
	bl_context     = 'texture'

	COMPAT_ENGINES = {'VRAY_RENDER','VRAY_RENDERER','VRAY_RENDER_PREVIEW'}

	@classmethod
	def poll(cls, context):
		if not engine_poll(cls, context):
			return False
		tex= context.texture
		return tex and (tex.type != 'NONE')


class VRayWorldPanel():
	bl_space_type  = 'PROPERTIES'
	bl_region_type = 'WINDOW'
	bl_context     = 'world'

	@classmethod
	def poll(cls, context):
		return context.world and engine_poll(cls, context)


# List item:
#  <item name> <item use-flag>
#
class VRayListUse(bpy.types.UIList):
	def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
		layout.label(item.name)
		layout.prop(item, 'use')


class VRayList(bpy.types.UIList):
	def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
		layout.label(item.name)


class VRayListDR(bpy.types.UIList):
	def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
		layout.label("%s [%s]" % (item.name, item.address))
		layout.prop(item, 'use', text="")


class VRayListMaterialSlots(bpy.types.UIList):
	def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
		ob   = data
		slot = item
		ma   = slot.material

		split = layout.split(percentage=0.75)

		if ma:
			split.label(text=ma.name, translate=False, icon_value=icon)
			split.prop(slot, 'link', text="", emboss=False, translate=False)
		else:
			split.label(text="")
			split.prop(slot, 'link', text="", emboss=False, translate=False)


def GetRegClasses():
	return (
		VRayListUse,
		VRayList,
		VRayListDR,
		VRayListMaterialSlots,
	)


def register():
	for regClass in GetRegClasses():
		bpy.utils.register_class(regClass)


def unregister():
	for regClass in GetRegClasses():
		bpy.utils.unregister_class(regClass)

########NEW FILE########
__FILENAME__ = utils
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Python modules  '''
import filecmp
import math
import os
import platform
import random
import shutil
import string
import struct
import socket
import stat
import subprocess
import sys
import time
import tempfile
import getpass


''' Blender modules '''
import bpy
import mathutils

''' vb modules '''
import _vray_for_blender

from vb25.plugins import *

PLATFORM= sys.platform
HOSTNAME= socket.gethostname()

PURE_PROCEDURAL= (
	'TexDirt',
	'TexEdges',
	'TexFalloff',
)

COLOR_TABLE= {
	'22500': (0.3764,0.5432,1.0000),
	'34800': (0.3361,0.5095,1.0000),
	'8300': (0.7319,0.7938,1.0000),
	'10100': (0.5978,0.7069,1.0000),
	'7300': (0.8591,0.8704,1.0000),
	'15200': (0.4460,0.5982,1.0000),
	'21400': (0.3830,0.5486,1.0000),
	'28100': (0.3527,0.5235,1.0000),
	'8800': (0.6856,0.7645,1.0000),
	'39100': (0.3290,0.5033,1.0000),
	'8900': (0.6773,0.7593,1.0000),
	'19400': (0.3975,0.5603,1.0000),
	'32300': (0.3413,0.5139,1.0000),
	'12700': (0.4982,0.6371,1.0000),
	'10200': (0.5925,0.7033,1.0000),
	'24300': (0.3673,0.5357,1.0000),
	'22000': (0.3793,0.5456,1.0000),
	'1700': (1.0000,0.1912,0.0000),
	'13600': (0.4762,0.6209,1.0000),
	'5300': (1.0000,0.8167,0.6937),
	'27400': (0.3550,0.5255,1.0000),
	'19300': (0.3984,0.5610,1.0000),
	'10800': (0.5637,0.6836,1.0000),
	'30100': (0.3468,0.5186,1.0000),
	'21100': (0.3850,0.5502,1.0000),
	'8600': (0.7030,0.7757,1.0000),
	'39400': (0.3286,0.5030,1.0000),
	'36200': (0.3336,0.5073,1.0000),
	'16700': (0.4249,0.5819,1.0000),
	'15100': (0.4477,0.5994,1.0000),
	'28400': (0.3517,0.5227,1.0000),
	'30600': (0.3455,0.5174,1.0000),
	'24900': (0.3646,0.5335,1.0000),
	'27300': (0.3553,0.5257,1.0000),
	'1400': (1.0000,0.1303,0.0000),
	'5000': (1.0000,0.7792,0.6180),
	'13900': (0.4698,0.6161,1.0000),
	'34500': (0.3367,0.5100,1.0000),
	'10700': (0.5681,0.6866,1.0000),
	'31000': (0.3444,0.5166,1.0000),
	'27900': (0.3533,0.5241,1.0000),
	'15400': (0.4429,0.5958,1.0000),
	'18100': (0.4093,0.5697,1.0000),
	'16400': (0.4287,0.5848,1.0000),
	'7900': (0.7762,0.8211,1.0000),
	'21200': (0.3843,0.5496,1.0000),
	'35900': (0.3341,0.5077,1.0000),
	'11000': (0.5551,0.6776,1.0000),
	'7700': (0.8014,0.8363,1.0000),
	'6500': (1.0000,0.9445,0.9853),
	'36100': (0.3338,0.5074,1.0000),
	'31300': (0.3437,0.5159,1.0000),
	'3800': (1.0000,0.6028,0.3207),
	'4100': (1.0000,0.6511,0.3927),
	'1900': (1.0000,0.2272,0.0000),
	'38500': (0.3299,0.5041,1.0000),
	'13200': (0.4854,0.6277,1.0000),
	'5700': (1.0000,0.8630,0.7933),
	'27000': (0.3564,0.5266,1.0000),
	'37000': (0.3322,0.5061,1.0000),
	'22300': (0.3776,0.5441,1.0000),
	'6200': (1.0000,0.9156,0.9147),
	'25900': (0.3605,0.5300,1.0000),
	'32400': (0.3411,0.5137,1.0000),
	'16100': (0.4327,0.5879,1.0000),
	'33600': (0.3385,0.5115,1.0000),
	'6800': (0.9488,0.9219,1.0000),
	'25300': (0.3629,0.5321,1.0000),
	'20000': (0.3928,0.5565,1.0000),
	'7000': (0.9102,0.9000,1.0000),
	'37700': (0.3311,0.5052,1.0000),
	'3200': (1.0000,0.4970,0.1879),
	'23800': (0.3696,0.5376,1.0000),
	'32900': (0.3400,0.5128,1.0000),
	'25400': (0.3625,0.5317,1.0000),
	'18700': (0.4036,0.5652,1.0000),
	'33500': (0.3387,0.5117,1.0000),
	'35400': (0.3350,0.5085,1.0000),
	'13500': (0.4785,0.6226,1.0000),
	'26800': (0.3571,0.5272,1.0000),
	'29400': (0.3487,0.5202,1.0000),
	'11400': (0.5394,0.6666,1.0000),
	'6100': (1.0000,0.9055,0.8907),
	'34200': (0.3373,0.5105,1.0000),
	'17500': (0.4156,0.5746,1.0000),
	'20700': (0.3877,0.5524,1.0000),
	'23500': (0.3711,0.5389,1.0000),
	'19800': (0.3943,0.5577,1.0000),
	'4500': (1.0000,0.7111,0.4919),
	'3700': (1.0000,0.5860,0.2974),
	'30800': (0.3450,0.5170,1.0000),
	'38100': (0.3305,0.5046,1.0000),
	'14400': (0.4599,0.6087,1.0000),
	'21800': (0.3805,0.5466,1.0000),
	'29100': (0.3496,0.5209,1.0000),
	'31600': (0.3430,0.5153,1.0000),
	'26100': (0.3597,0.5294,1.0000),
	'23200': (0.3726,0.5401,1.0000),
	'1300': (1.0000,0.1085,0.0000),
	'9200': (0.6543,0.7444,1.0000),
	'35700': (0.3345,0.5080,1.0000),
	'11300': (0.5432,0.6693,1.0000),
	'17000': (0.4212,0.5791,1.0000),
	'12400': (0.5066,0.6432,1.0000),
	'2400': (1.0000,0.3364,0.0501),
	'36800': (0.3326,0.5064,1.0000),
	'14100': (0.4657,0.6131,1.0000),
	'35200': (0.3354,0.5088,1.0000),
	'20900': (0.3863,0.5513,1.0000),
	'26400': (0.3586,0.5284,1.0000),
	'29200': (0.3493,0.5207,1.0000),
	'9700': (0.6208,0.7224,1.0000),
	'18800': (0.4027,0.5644,1.0000),
	'9900': (0.6089,0.7144,1.0000),
	'39700': (0.3281,0.5026,1.0000),
	'11900': (0.5220,0.6542,1.0000),
	'12300': (0.5095,0.6453,1.0000),
	'33000': (0.3398,0.5126,1.0000),
	'24700': (0.3655,0.5342,1.0000),
	'36500': (0.3331,0.5068,1.0000),
	'2900': (1.0000,0.4394,0.1297),
	'19200': (0.3992,0.5616,1.0000),
	'37900': (0.3308,0.5049,1.0000),
	'12900': (0.4929,0.6332,1.0000),
	'39800': (0.3280,0.5025,1.0000),
	'17900': (0.4113,0.5713,1.0000),
	'14200': (0.4638,0.6116,1.0000),
	'22400': (0.3770,0.5437,1.0000),
	'3300': (1.0000,0.5155,0.2087),
	'21500': (0.3824,0.5481,1.0000),
	'2300': (1.0000,0.3149,0.0373),
	'34900': (0.3359,0.5093,1.0000),
	'31900': (0.3423,0.5147,1.0000),
	'19700': (0.3951,0.5584,1.0000),
	'39000': (0.3291,0.5035,1.0000),
	'36600': (0.3329,0.5067,1.0000),
	'30700': (0.3452,0.5172,1.0000),
	'24800': (0.3650,0.5338,1.0000),
	'8200': (0.7423,0.8002,1.0000),
	'24200': (0.3677,0.5361,1.0000),
	'22700': (0.3753,0.5423,1.0000),
	'32000': (0.3420,0.5145,1.0000),
	'27500': (0.3546,0.5252,1.0000),
	'5400': (1.0000,0.8286,0.7187),
	'12000': (0.5187,0.6519,1.0000),
	'28000': (0.3530,0.5238,1.0000),
	'17300': (0.4178,0.5763,1.0000),
	'30200': (0.3465,0.5183,1.0000),
	'10900': (0.5593,0.6806,1.0000),
	'1000': (1.0000,0.0401,0.0000),
	'8500': (0.7123,0.7815,1.0000),
	'10300': (0.5873,0.6998,1.0000),
	'15000': (0.4493,0.6007,1.0000),
	'21600': (0.3817,0.5476,1.0000),
	'28700': (0.3508,0.5219,1.0000),
	'16800': (0.4236,0.5809,1.0000),
	'36300': (0.3334,0.5071,1.0000),
	'39300': (0.3287,0.5031,1.0000),
	'1500': (1.0000,0.1515,0.0000),
	'9400': (0.6402,0.7352,1.0000),
	'10400': (0.5823,0.6964,1.0000),
	'22200': (0.3781,0.5446,1.0000),
	'22800': (0.3748,0.5419,1.0000),
	'21300': (0.3836,0.5491,1.0000),
	'5100': (1.0000,0.7919,0.6433),
	'34600': (0.3365,0.5098,1.0000),
	'13800': (0.4719,0.6177,1.0000),
	'19100': (0.4001,0.5623,1.0000),
	'35800': (0.3343,0.5079,1.0000),
	'7400': (0.8437,0.8614,1.0000),
	'3900': (1.0000,0.6193,0.3444),
	'15700': (0.4384,0.5923,1.0000),
	'32600': (0.3407,0.5133,1.0000),
	'16500': (0.4274,0.5838,1.0000),
	'23300': (0.3721,0.5397,1.0000),
	'30400': (0.3460,0.5179,1.0000),
	'37300': (0.3317,0.5057,1.0000),
	'27100': (0.3560,0.5263,1.0000),
	'4000': (1.0000,0.6354,0.3684),
	'14800': (0.4527,0.6033,1.0000),
	'32500': (0.3409,0.5135,1.0000),
	'5800': (1.0000,0.8740,0.8179),
	'13100': (0.4879,0.6295,1.0000),
	'16200': (0.4313,0.5869,1.0000),
	'25000': (0.3642,0.5331,1.0000),
	'18300': (0.4074,0.5681,1.0000),
	'7100': (0.8923,0.8897,1.0000),
	'33900': (0.3379,0.5110,1.0000),
	'23900': (0.3692,0.5372,1.0000),
	'20300': (0.3905,0.5547,1.0000),
	'29800': (0.3476,0.5192,1.0000),
	'37600': (0.3313,0.5053,1.0000),
	'4300': (1.0000,0.6817,0.4419),
	'15900': (0.4355,0.5901,1.0000),
	'21900': (0.3799,0.5461,1.0000),
	'34000': (0.3377,0.5108,1.0000),
	'13400': (0.4807,0.6243,1.0000),
	'27600': (0.3543,0.5249,1.0000),
	'25500': (0.3621,0.5314,1.0000),
	'5500': (1.0000,0.8403,0.7437),
	'6000': (1.0000,0.8952,0.8666),
	'4900': (1.0000,0.7661,0.5928),
	'26700': (0.3575,0.5275,1.0000),
	'34300': (0.3371,0.5103,1.0000),
	'11700': (0.5287,0.6590,1.0000),
	'29500': (0.3485,0.5200,1.0000),
	'31200': (0.3439,0.5161,1.0000),
	'20600': (0.3884,0.5529,1.0000),
	'23600': (0.3706,0.5384,1.0000),
	'2700': (1.0000,0.3992,0.0950),
	'28900': (0.3502,0.5214,1.0000),
	'3400': (1.0000,0.5336,0.2301),
	'37500': (0.3314,0.5054,1.0000),
	'38800': (0.3294,0.5037,1.0000),
	'30900': (0.3447,0.5168,1.0000),
	'17400': (0.4167,0.5755,1.0000),
	'14500': (0.4581,0.6073,1.0000),
	'4400': (1.0000,0.6966,0.4668),
	'31500': (0.3432,0.5155,1.0000),
	'26000': (0.3601,0.5297,1.0000),
	'29600': (0.3482,0.5197,1.0000),
	'38200': (0.3303,0.5045,1.0000),
	'35600': (0.3346,0.5082,1.0000),
	'11800': (0.5253,0.6566,1.0000),
	'11200': (0.5470,0.6720,1.0000),
	'17700': (0.4134,0.5729,1.0000),
	'6700': (0.9696,0.9336,1.0000),
	'20500': (0.3891,0.5535,1.0000),
	'9300': (0.6471,0.7397,1.0000),
	'12500': (0.5037,0.6411,1.0000),
	'24100': (0.3682,0.5365,1.0000),
	'36900': (0.3324,0.5063,1.0000),
	'18400': (0.4064,0.5674,1.0000),
	'33400': (0.3389,0.5119,1.0000),
	'19600': (0.3959,0.5590,1.0000),
	'38700': (0.3296,0.5038,1.0000),
	'9000': (0.6693,0.7541,1.0000),
	'14600': (0.4563,0.6060,1.0000),
	'39600': (0.3283,0.5027,1.0000),
	'29300': (0.3490,0.5204,1.0000),
	'26300': (0.3589,0.5288,1.0000),
	'33300': (0.3391,0.5120,1.0000),
	'25600': (0.3617,0.5310,1.0000),
	'24600': (0.3659,0.5346,1.0000),
	'18900': (0.4018,0.5637,1.0000),
	'19500': (0.3967,0.5596,1.0000),
	'37800': (0.3309,0.5050,1.0000),
	'17200': (0.4189,0.5772,1.0000),
	'30300': (0.3463,0.5181,1.0000),
	'22900': (0.3742,0.5414,1.0000),
	'14300': (0.4618,0.6102,1.0000),
	'3000': (1.0000,0.4589,0.1483),
	'2800': (1.0000,0.4195,0.1119),
	'2200': (1.0000,0.2930,0.0257),
	'31800': (0.3425,0.5149,1.0000),
	'39900': (0.3279,0.5024,1.0000),
	'8100': (0.7531,0.8069,1.0000),
	'30000': (0.3471,0.5188,1.0000),
	'9500': (0.6335,0.7308,1.0000),
	'32100': (0.3418,0.5143,1.0000),
	'28300': (0.3520,0.5230,1.0000),
	'12100': (0.5156,0.6497,1.0000),
	'24500': (0.3664,0.5349,1.0000),
	'36700': (0.3327,0.5066,1.0000),
	'23000': (0.3737,0.5410,1.0000),
	'1100': (1.0000,0.0631,0.0000),
	'35100': (0.3356,0.5090,1.0000),
	'2100': (1.0000,0.2709,0.0153),
	'20800': (0.3870,0.5518,1.0000),
	'10000': (0.6033,0.7106,1.0000),
	'22600': (0.3759,0.5428,1.0000),
	'21700': (0.3811,0.5471,1.0000),
	'8400': (0.7219,0.7875,1.0000),
	'36000': (0.3339,0.5076,1.0000),
	'16900': (0.4224,0.5800,1.0000),
	'39200': (0.3288,0.5032,1.0000),
	'7200': (0.8753,0.8799,1.0000),
	'15300': (0.4445,0.5970,1.0000),
	'28600': (0.3511,0.5222,1.0000),
	'22100': (0.3787,0.5451,1.0000),
	'14900': (0.4510,0.6020,1.0000),
	'32200': (0.3416,0.5141,1.0000),
	'5200': (1.0000,0.8044,0.6685),
	'34700': (0.3363,0.5096,1.0000),
	'12600': (0.5009,0.6391,1.0000),
	'10500': (0.5774,0.6930,1.0000),
	'1600': (1.0000,0.1718,0.0000),
	'13700': (0.4740,0.6193,1.0000),
	'7500': (0.8289,0.8527,1.0000),
	'19000': (0.4009,0.5630,1.0000),
	'15600': (0.4398,0.5935,1.0000),
	'32700': (0.3404,0.5132,1.0000),
	'16600': (0.4261,0.5829,1.0000),
	'21000': (0.3856,0.5507,1.0000),
	'38600': (0.3297,0.5040,1.0000),
	'28500': (0.3514,0.5225,1.0000),
	'27800': (0.3536,0.5243,1.0000),
	'39500': (0.3284,0.5028,1.0000),
	'4700': (1.0000,0.7392,0.5422),
	'40000': (0.3277,0.5022,1.0000),
	'5900': (1.0000,0.8847,0.8424),
	'13000': (0.4904,0.6314,1.0000),
	'30500': (0.3457,0.5177,1.0000),
	'27200': (0.3557,0.5260,1.0000),
	'37200': (0.3319,0.5058,1.0000),
	'7800': (0.7885,0.8285,1.0000),
	'34400': (0.3369,0.5101,1.0000),
	'33800': (0.3381,0.5112,1.0000),
	'16300': (0.4300,0.5859,1.0000),
	'15500': (0.4413,0.5946,1.0000),
	'18000': (0.4103,0.5705,1.0000),
	'25100': (0.3637,0.5328,1.0000),
	'20200': (0.3913,0.5553,1.0000),
	'17800': (0.4124,0.5721,1.0000),
	'11100': (0.5510,0.6748,1.0000),
	'7600': (0.8149,0.8443,1.0000),
	'29900': (0.3473,0.5190,1.0000),
	'8700': (0.6941,0.7700,1.0000),
	'37100': (0.3321,0.5060,1.0000),
	'34100': (0.3375,0.5106,1.0000),
	'31400': (0.3435,0.5157,1.0000),
	'27700': (0.3540,0.5246,1.0000),
	'5600': (1.0000,0.8518,0.7686),
	'25200': (0.3633,0.5324,1.0000),
	'6900': (0.9290,0.9107,1.0000),
	'4200': (1.0000,0.6666,0.4172),
	'4800': (1.0000,0.7528,0.5675),
	'26600': (0.3578,0.5278,1.0000),
	'38400': (0.3300,0.5042,1.0000),
	'13300': (0.4831,0.6260,1.0000),
	'10600': (0.5727,0.6898,1.0000),
	'31100': (0.3442,0.5164,1.0000),
	'11600': (0.5322,0.6615,1.0000),
	'25800': (0.3609,0.5304,1.0000),
	'6300': (1.0000,0.9254,0.9384),
	'2600': (1.0000,0.3786,0.0790),
	'28800': (0.3505,0.5217,1.0000),
	'23700': (0.3701,0.5380,1.0000),
	'20100': (0.3920,0.5559,1.0000),
	'32800': (0.3402,0.5130,1.0000),
	'3500': (1.0000,0.5515,0.2520),
	'37400': (0.3316,0.5056,1.0000),
	'38300': (0.3302,0.5044,1.0000),
	'26900': (0.3567,0.5269,1.0000),
	'33200': (0.3393,0.5122,1.0000),
	'18600': (0.4045,0.5659,1.0000),
	'25700': (0.3613,0.5307,1.0000),
	'38900': (0.3293,0.5036,1.0000),
	'6600': (0.9917,0.9458,1.0000),
	'20400': (0.3898,0.5541,1.0000),
	'23400': (0.3716,0.5393,1.0000),
	'35500': (0.3348,0.5084,1.0000),
	'24000': (0.3687,0.5368,1.0000),
	'11500': (0.5357,0.6640,1.0000),
	'29700': (0.3479,0.5195,1.0000),
	'18500': (0.4055,0.5666,1.0000),
	'16000': (0.4341,0.5890,1.0000),
	'33700': (0.3383,0.5113,1.0000),
	'15800': (0.4369,0.5912,1.0000),
	'3600': (1.0000,0.5689,0.2745),
	'17600': (0.4145,0.5738,1.0000),
	'14700': (0.4545,0.6046,1.0000),
	'19900': (0.3935,0.5571,1.0000),
	'4600': (1.0000,0.7253,0.5170),
	'29000': (0.3499,0.5212,1.0000),
	'31700': (0.3427,0.5151,1.0000),
	'26200': (0.3593,0.5291,1.0000),
	'1800': (1.0000,0.2097,0.0000),
	'38000': (0.3306,0.5048,1.0000),
	'17100': (0.4201,0.5781,1.0000),
	'23100': (0.3732,0.5405,1.0000),
	'1200': (1.0000,0.0860,0.0000),
	'9100': (0.6617,0.7492,1.0000),
	'3100': (1.0000,0.4781,0.1677),
	'2500': (1.0000,0.3577,0.0640),
	'9600': (0.6271,0.7265,1.0000),
	'14000': (0.4677,0.6146,1.0000),
	'35300': (0.3352,0.5087,1.0000),
	'18200': (0.4083,0.5689,1.0000),
	'12800': (0.4955,0.6351,1.0000),
	'26500': (0.3582,0.5281,1.0000),
	'8000': (0.7644,0.8139,1.0000),
	'6400': (1.0000,0.9351,0.9619),
	'33100': (0.3396,0.5124,1.0000),
	'36400': (0.3332,0.5070,1.0000),
	'24400': (0.3668,0.5353,1.0000),
	'9800': (0.6148,0.7183,1.0000),
	'35000': (0.3357,0.5091,1.0000),
	'2000': (1.0000,0.2484,0.0061),
	'12200': (0.5125,0.6474,1.0000),
	'28200': (0.3524,0.5232,1.0000),
}

ARCH= platform.architecture()[0]
TEX_TYPES=  {'IMAGE', 'VRAY'}
GEOM_TYPES= {'MESH', 'CURVE', 'SURFACE', 'META', 'FONT'}

none_matrix= mathutils.Matrix(((0.0,0.0,0.0,0.0),(0.0,0.0,0.0,0.0),(0.0,0.0,0.0,0.0),(0.0,0.0,0.0,0.0)))


def get_username():
	if PLATFORM == 'win32':
		return "standalone"
	else:
		return getpass.getuser()


def copytree(src, dst, symlinks=False, ignore=None):
	if PLATFORM == 'win32':
		os.system('robocopy /E "%s" "%s"' % (src, dst))
	else:
		if not os.path.exists(dst):
			os.makedirs(dst)
		for item in os.listdir(src):
			s = os.path.join(src, item)
			d = os.path.join(dst, item)
			if os.path.isdir(s):
				shutil.copytree(s, d, symlinks, ignore)
			else:
				shutil.copy2(s, d)


# Get RAM directory
# Used for fast temp file access
def get_ram_basedir():
	if PLATFORM == 'linux':
		return "/dev/shm"
	return tempfile.gettempdir()


# Colorize sting on Linux
def color(text, color=None):
	if not color or not PLATFORM == 'linux':
		return text
	if color == 'green':
		return "\033[0;32m%s\033[0m" % text
	elif color == 'red':
		return "\033[0;31m%s\033[0m" % text
	elif color == 'yellow':
		return "\033[0;33m%s\033[0m" % text
	elif color == 'magenta':
		return "\033[0;35m%s\033[0m" % text
	else:
		return text


# Log message
def debug(scene, message, newline= True, cr= True, error= False):
	# sys.stdout.write("[%s] V-Ray/Blender: %s%s%s" % (
	# 	time.strftime("%Y/%b/%d|%H:%m:%S"),
	# 	color("Error! ", 'red') if error else '',
	# 	message,
	# 	'\n' if newline else '\r' if cr else '')
	# )
	sys.stdout.write("%s: %s%s%s" % (
		color("V-Ray/Blender", 'green'),
		color("Error! ", 'red') if error else '',
		message,
		'\n' if newline else '\r' if cr else '')
	)
	if not newline:
		sys.stdout.flush()


# Prints dictionary
def print_dict(scene, title, params, spacing= 2):
	debug(scene, "%s:" % title)
	for key in sorted(params.keys()):
		if type(params[key]) == dict:
			spacing*= 2
			print_dict(scene, key, params[key], spacing)
			spacing/= 2
		elif type(params[key]) in (list,tuple):
			debug(scene, "%s%s" % (''.join([' ']*int(spacing)), color(key, 'yellow')))
			for item in params[key]:
				debug(scene, ''.join([' ']*int(spacing)*2) + str(item))
		else:
			debug(scene, "%s%s: %s" % (''.join([' ']*int(spacing)), color(key, 'yellow'), params[key]))


# Property
def p(t):
	if type(t) is bool:
		return "%i"%(t)
	elif type(t) is int:
		return "%i"%(t)
	elif type(t) is float:
		return "%.6f"%(t)
	elif type(t) is mathutils.Vector:
		return "Vector(%.3f,%.3f,%.3f)"%(t.x,t.y,t.z)
	elif type(t) is mathutils.Color:
		return "Color(%.3f,%.3f,%.3f)"%(t.r,t.g,t.b)
	elif len(t) == 4 and type(t[0]) is float:
		return "AColor(%.3f,%.3f,%.3f,%.3f)"%(t[0],t[1],t[2],t[3])
	elif type(t) is str:
		if t == "True":
			return "1"
		elif t == "False":
			return "0"
		else:
			return t
	else:
		return "%s"%(t)


# Animated property
def a(scene, t):
	VRayScene    = scene.vray
	VRayExporter = VRayScene.exporter

	frame = scene.frame_current

	if VRayExporter.camera_loop:
		frame = VRayExporter.customFrame
	
	if VRayScene.RTEngine.enabled:
		return p(t)

	if VRayExporter.animation or VRayExporter.camera_loop or VRayExporter.use_still_motion_blur:
		return "interpolate((%i,%s))" % (frame, p(t))

	return p(t)


# Checks if object is animated
#
# TODO: cache results
#
def is_animated(ob):
	# print("ob.name", ob.name)
	# print("ob.animation_data",ob.animation_data)

	if ob.animation_data:
		return True

	if ob.type in GEOM_TYPES:
		# Check if material is animated
		if len(ob.material_slots):
			for slot in ob.material_slots:
				ma = slot.material
				if not ma:
					continue
				if ma.animation_data:
					return True
				# Check if texture is animated
				if len(ma.texture_slots):
					for tSlot in ma.texture_slots:
						if not tSlot:
							continue
						if not tSlot.texture:
							continue
						if tSlot.texture.animation_data:
							return True
	elif ob.type in {'LAMP'}:
		pass

	return False


# Checks if objects mesh is animated
def is_data_animated(ob):
	if not ob.data:
		return False

	print("ob.data.name", ob.name)
	print("ob.data.animation_data", ob.data.animation_data)

	if ob.data.animation_data:
		return True
	if ob.active_shape_key:
		return True
	return False


# Hex value format
def HexFormat(value):
    if type(value) is float:
        bytes= struct.pack('<f', value)
    else:
        bytes= struct.pack('<i', value)
    return ''.join(["%02X" % b for b in bytes])


# Transform matrix string
def transform(m):
	if hasattr(_vray_for_blender, 'getTransformHex'):
		return _vray_for_blender.getTransformHex(m.copy())
	return "Transform(Matrix(Vector(%f,%f,%f),Vector(%f,%f,%f),Vector(%f,%f,%f)),Vector(%f,%f,%f))" % (m[0][0], m[1][0], m[2][0], m[0][1], m[1][1], m[2][1], m[0][2], m[1][2], m[2][2], m[0][3], m[1][3], m[2][3])


# Clean string from forbidden chars
def clean_string(s):
	s= s.replace("+", "p")
	s= s.replace("-", "m")
	for i in range(len(s)):
		c= s[i]
		if not ((c >= 'A' and c <= 'Z') or (c >= 'a' and c <= 'z') or (c >= '0' and c <= '9')):
			s= s.replace(c, "_")
	return s


# The most powerfull unique name generator =)
def get_random_string():
	return ''.join([random.choice(string.ascii_letters) for x in range(16)])


# Append to list only if item not already in list
def append_unique(array, item):
	if item in array:
		return False
	array.append(item)
	return True


# V-Ray uses UV indexes, Blender uses UV names
# Here we store UV name->index map
def get_uv_layer_id(uv_layers, uv_layer_name):
	if not uv_layer_name:
		return 1
	return uv_layers[uv_layer_name] if uv_layer_name in uv_layers else 1

def get_uv_layers_map(sce):
	uv_layers= {}
	uv_id= 1
	for ma in bpy.data.materials:
		for slot in ma.texture_slots:
			if slot and slot.texture:
				if slot.texture.vray.texture_coords == 'UV':
					if slot.uv_layer and slot.uv_layer not in uv_layers:
						uv_layers[slot.uv_layer]= uv_id
						uv_id+= 1

	if sce.vray.exporter.debug:
		for uv_layer in uv_layers:
			print_dict(sce, "UV layer name map", uv_layers)

	return uv_layers


# Generate visibility list for "Hide From View"
def get_visibility_lists(camera):
	VRayCamera= camera.data.vray

	visibility= {
		'all':     [],
		'camera':  [],
		'gi':      [],
		'reflect': [],
		'refract': [],
		'shadows': [],
	}

	if VRayCamera.hide_from_view:
		for hide_type in visibility:
			if getattr(VRayCamera, 'hf_%s' % hide_type):
				if getattr(VRayCamera, 'hf_%s_auto' % hide_type):
					visibility[hide_type]= generate_object_list(group_names_string= 'hf_%s' % camera.name)
				else:
					visibility[hide_type]= generate_object_list(getattr(VRayCamera, 'hf_%s_objects' % hide_type), getattr(VRayCamera, 'hf_%s_groups' % hide_type))

	return visibility


# Generate list objects from ';' separated object and group strings
def generate_object_list(object_names_string= None, group_names_string= None):
	object_list= []

	if object_names_string:
		ob_names= object_names_string.split(';')
		for ob_name in ob_names:
			if ob_name in bpy.data.objects:
				object_list.append(bpy.data.objects[ob_name])

	if group_names_string:
		gr_names= group_names_string.split(';')
		for gr_name in gr_names:
			if gr_name in bpy.data.groups:
				object_list.extend(bpy.data.groups[gr_name].objects)

	dupliGroup = []
	for ob in object_list:
		if ob.dupli_type == 'GROUP' and ob.dupli_group:
			dupliGroup.extend(ob.dupli_group.objects)
	object_list.extend(dupliGroup)

	return object_list


# Generate list of data from ';' separated string
#
def generateDataList(namesString, dataType):
	dataList = []

	dataPtr = getattr(bpy.data, dataType)

	dataNames = namesString.split(';')
	for dataName in dataNames:
		if dataName in dataPtr:
			dataList.append(dataPtr[dataName])

	return dataList


# Get object used as ORCO projection
def get_orco_object(scene, ob, VRayTexture):
	if VRayTexture.object:
		texture_object= get_data_by_name(scene, 'objects', VRayTexture.object)
		if texture_object:
			return texture_object
	return ob


# Naming
# def get_name(data, bus):
# 	name= data.name
# 	if bus['object']['particle'].get('name'):
# 		name= "%s_%s" % (bus['object']['particle']['name'], name)
# 	if bus['object']['dupli'].get('name'):
# 		name= "%s_%s" % (bus['object']['dupli']['name'], name)
# 	if issubclass(type(data), bpy.types.Lamp):
# 		name= 'LA'+name
# 	elif issubclass(type(data), bpy.types.Texture):
# 		name= 'TE'+name
# 	elif type(data) == bpy.types.Material:
# 		name= 'MA'+name
# 	else:
# 		name= 'OB'+name
# 	if data.library:
# 		name+= "%s%s" % ('LI', get_filename(data.library.filepath))
# 	return clean_string(name)
def get_name(ob, prefix= None):
	if not ob:
		return None
	name= ob.name
	if prefix:
		name= prefix+name
	if ob.library:
		name+= "%s%s" % ('LI', get_filename(ob.library.filepath).replace('.blend',''))
	return clean_string(name)


# Get node name
def get_node_name(node_tree, node):
	return "%s%s" % (get_name(node_tree, prefix='NT'),
					 clean_string(node.name))


# Find node connected to socket
def connected_node(node_tree, node_socket):
	for node in node_tree.links:
		if node.to_socket == node_socket:
			return node.from_node
	return None


# Get node_tree Output
def get_output_node(node_tree, output_node_name=None):
	for node in node_tree.nodes:
		if node.type == 'OUTPUT':
			if output_node_name is not None:
				if output_node_name == node.filepath:
					return node
			else:
				return node
	return None


# Get data by name
def get_data_by_name(sce, data_type, name):
	if data_type == 'objects':
		if name in sce.objects:
			return sce.objects[name]
	elif data_type in ('textures','materials','meshes'):
		data_ptr= getattr(bpy.data, data_type)
		if name in data_ptr:
			return data_ptr[name]
	return None


# Get file name
def get_filename(filepath):
	return os.path.basename(bpy.path.abspath(filepath))


def path_sep_to_unix(filepath):
	if PLATFORM != 'win32':
		filepath = filepath.replace('\\\\', '/')
		filepath = filepath.replace('\\', '/')
	return filepath


def get_path(filepath):
	return os.path.normpath(path_sep_to_unix(bpy.path.abspath(filepath)))


def Quotes(path):
	if PLATFORM != 'win32':
		return '"%s"' % (path)
	return path


# Create directory
def create_dir(directory, pathOnly=False):
	directory = path_sep_to_unix(directory)
	if not pathOnly and not os.path.exists(directory):
		debug(None, "Creating directory \"%s\"... " % directory, newline= False, cr= False)
		try:
			os.mkdir(directory)
			sys.stdout.write("%s\n" % (color("done", 'yellow')))
		except OSError:
			directory= tempfile.gettempdir()
			sys.stdout.write("%s\n" % (color("Fail!", 'red')))
			debug(None, "Using default exporting path: %s" % directory)
	return directory

def create_dir_from_filepath(filepath):
	file_path, file_name= os.path.split(bpy.path.abspath(filepath))
	file_path= create_dir(file_path)
	return os.path.join(file_path, file_name)


# Get full filepath
# Also copies file to DR shared folder
def get_full_filepath(bus, ob, filepath):
	def rel_path(filepath):
		if filepath[:2] == "//":
			return True
		else:
			return False

	scene= bus['scene']

	VRayDR          = scene.vray.VRayDR
	SettingsOptions = scene.vray.SettingsOptions

	# If object is linked and path is relative
	# we need to find correct absolute path
	if ob and ob.library and rel_path(filepath):
		lib_path= os.path.dirname(bpy.path.abspath(ob.library.filepath))
		filepath= os.path.normpath(os.path.join(lib_path,filepath[2:]))

	# Full absolute file path
	src_file = bpy.path.abspath(filepath)
	src_file = path_sep_to_unix(src_file)
	src_file = os.path.normpath(src_file)

	if VRayDR.on and VRayDR.transferAssets == '0':
		# File name
		src_filename= os.path.basename(src_file)

		# DR shared directory
		dest_path= bus['filenames']['DR']['dest_dir']

		# If shared directory is not set
		# just return absolute file path
		if not dest_path:
			return src_file

		file_type= os.path.splitext(src_file)[1]

		component_subdir= ""
		if file_type.lower() in ('ies','lens'):
			component_subdir= "misc"
		elif file_type.lower() == "vrmesh":
			component_subdir= "proxy"
		elif file_type.lower() == "vrmap":
			component_subdir= "lightmaps"
		else:
			component_subdir= "textures"

		if component_subdir:
			dest_path= create_dir(os.path.join(dest_path, component_subdir))

		# Copy file to the shared directory
		dest_file= os.path.join(dest_path, src_filename)

		if os.path.isfile(src_file):
			if os.path.exists(dest_file):
				# Copy only if the file was changed
				if not filecmp.cmp(dest_file, src_file):
					debug(scene, "Copying \"%s\" to \"%s\""% (color(src_filename, 'magenta'), dest_path))
					shutil.copyfile(src_file, dest_file)
				else:
					debug(scene, "File \"%s\" exists and not modified."% (color(src_filename, 'magenta')))
			else:
				debug(scene, "Copying \"%s\" to \"%s\"" % (color(src_filename, 'magenta'), dest_path))
				shutil.copyfile(src_file, dest_file)
		else:
			debug(scene, "\"%s\" is not a file!" % (src_file), error= True)
			return src_file

		if PLATFORM == 'win32':
			return "//%s/%s/%s/%s/%s"%(HOSTNAME,
									   VRayDR.share_name,
									   bus['filenames']['DR']['sub_dir'], component_subdir, src_filename)

		return bus['filenames']['DR']['prefix'] + os.sep + component_subdir + os.sep + src_filename
	else:
		return src_file


# True if object on active layer
def object_on_visible_layers(scene, ob):
	VRayScene    = scene.vray
	VRayExporter = VRayScene.exporter

	activeLayers = scene.layers

	if VRayExporter.activeLayers == 'ALL':
		return True
	elif VRayExporter.activeLayers == 'CUSTOM':
		activeLayers = VRayExporter.customRenderLayers

	for l in range(20):
		if ob.layers[l] and activeLayers[l]:
			return True
	return False


# True if object is visible
def object_visible(bus, ob):
	scene= bus['scene']

	VRayScene=       scene.vray
	VRayExporter=    VRayScene.exporter
	SettingsOptions= VRayScene.SettingsOptions

	if not object_on_visible_layers(scene,ob):
		if ob.type == 'LAMP':
			if not SettingsOptions.light_doHiddenLights:
				return False
		if not SettingsOptions.geom_doHidden:
			return False

	if ob.hide_render:
		if ob.type == 'LAMP':
			if not SettingsOptions.light_doHiddenLights:
				return False
		if not SettingsOptions.geom_doHidden:
			return False

	return True


# Distance between 2 objects
def get_distance(ob1, ob2):
	t1 = ob1.matrix_world.to_translation()
	t2 = ob2.matrix_world.to_translation()
	vec = t1 - t2
	return vec.length


# VRayProxy Creator call
def proxy_creator(hq_filepath, vrmesh_filepath, append= False):
	proxycreator_bin= "proxycreator"

	if PLATFORM == 'linux':
		proxycreator_bin += "_linux"
	elif PLATFORM == 'win32':
		proxycreator_bin += "_windows"
	else:
		proxycreator_bin += "_mac"

	if PLATFORM in ['linux', 'win32']:
		proxycreator_bin += "_"+ARCH[:-3]

	if PLATFORM == 'win32':
		proxycreator_bin += ".exe"

	vray_exporter_path= get_vray_exporter_path()
	if vray_exporter_path:
		proxycreator_bin= os.path.join(vray_exporter_path, "bin", proxycreator_bin)

		if os.path.exists(proxycreator_bin):
			debug(None, "Proxy Creator: %s" % (proxycreator_bin))

			mode = os.stat(proxycreator_bin).st_mode
			if not mode & stat.S_IXUSR:
				os.chmod(proxycreator_bin, mode | stat.S_IXUSR)

			cmd= []
			cmd.append(proxycreator_bin)
			if append:
				cmd.append('--append')
			cmd.append(hq_filepath)
			cmd.append(vrmesh_filepath)

			proc= subprocess.call(cmd)

		else:
			debug(None, "Proxy Creator not found!", error= True)


def GetUserConfigDir():
	userConfigDirpath = bpy.utils.user_resource('CONFIG')
	if not os.path.exists(userConfigDirpath):
		os.makedirs(userConfigDirpath)
	return userConfigDirpath


# Returns path to vb25 folder
def get_vray_exporter_path():
	for vb_path in bpy.utils.script_paths(os.path.join('addons','vb25')):
		if vb_path:
			return vb_path
	for vb_path in bpy.utils.script_paths(os.path.join('startup','vb25')):
		if vb_path:
			return vb_path
	return ""


def getColorMappingFilepath():
	return os.path.join(tempfile.gettempdir(), "colorMapping_%s.vrscene" % (get_username()))


# Detects V-Ray Standalone installation
def get_vray_standalone_path(sce):
	VRayExporter= sce.vray.exporter

	vray_bin= "vray"
	if PLATFORM == 'win32':
		vray_bin+= ".exe"

	def get_env_paths(var):
		split_char= ':'
		if PLATFORM == 'win32':
			split_char= ';'
		env_var= os.getenv(var)
		if env_var:
			return env_var.replace('\"','').split(split_char)
		return []

	def find_vray_std_osx_official():
		vrayPath = "/Applications/ChaosGroup/V-Ray/Standalone_for_snow_leopard_x86/bin/snow_leopard_x86/gcc-4.2/vray"
		if os.path.exists(vrayPath):
			return vrayPath
		return None

	def find_vray_std_osx():
		import glob
		instLogFilepath = "/var/log/chaos_installs"
		if not os.path.exists(instLogFilepath):
			return None
		instLog = open(instLogFilepath, 'r').readlines()
		for l in instLog:
			# Example path:
			#  /Applications/ChaosGroup/V-Ray/Standalone_for_snow_leopard_x86/uninstall/linuxinstaller.app/Contents
			#
			if 'V-Ray Standalone' in l and '[UN]' not in l:
				_tmp_, path = l.strip().split('=')

				# Going up to /Applications/ChaosGroup/V-Ray/Standalone_for_snow_leopard_x86/bin
				path = os.path.normpath(os.path.join(path.strip(), '..', '..', '..', "bin"))

				possiblePaths = glob.glob('%s/*/*/vray' % path)
				if len(possiblePaths):
					return possiblePaths[0]
				return None
		return None

	def find_vray_binary(paths):
		if paths:
			for p in paths:
				if p:
					vray_path= os.path.join(p,vray_bin)
					if os.path.exists(vray_path):
						if VRayExporter.debug:
							debug(sce, "V-Ray found in: %s" % (vray_path))
						return vray_path
		return None

	if not VRayExporter.detect_vray and VRayExporter.vray_binary:
		return bpy.path.abspath(VRayExporter.vray_binary)

	# Check 'VRAY_PATH' environment variable
	#
	vray_standalone_paths= get_env_paths('VRAY_PATH')
	if vray_standalone_paths:
		vray_standalone= find_vray_binary(vray_standalone_paths)
		if vray_standalone:
			return vray_standalone

	# On OS X check default path and install log
	#
	if PLATFORM in {'darwin'}:
		path = find_vray_std_osx_official()
		if path is not None:
			return path
		path = find_vray_std_osx()
		if path is not None:
			return path

	# Try to find Standalone in V-Ray For Maya
	#
	for var in os.environ:
		if var.startswith('VRAY_FOR_MAYA'):
			if var.find('MAIN') != -1:
				debug(sce, "Searching in: %s" % (var))
				vray_maya= find_vray_binary([os.path.join(path, 'bin') for path in get_env_paths(var)])
				if vray_maya:
					debug(sce, "V-Ray found in: %s" % (vray_maya))
					return vray_maya

	# Try to find vray binary in %PATH%
	debug(sce, "V-Ray not found! Trying to start \"%s\" command from $PATH..." % (vray_bin), True)

	return shutil.which(vray_bin)


# Inits directories / files
def init_files(bus):
	scene = bus['scene']

	VRayScene = scene.vray
	
	VRayExporter    = VRayScene.exporter
	VRayDR          = VRayScene.VRayDR
	SettingsOutput  = VRayScene.SettingsOutput
	SettingsOptions = VRayScene.SettingsOptions

	(blendfile_path, blendfile_name) = os.path.split(bpy.data.filepath)

	# Blend-file name without extension
	blendfile_name = os.path.basename(bpy.data.filepath)[:-6] if bpy.data.filepath else "default"

	# Default export directory is system's %TMP%
	default_dir = tempfile.gettempdir()

	# Export and output directory
	export_filepath = os.path.join(default_dir, "vrayblender_"+get_username())
	export_filename = "scene"
	output_filepath = default_dir

	if SettingsOutput.img_dir:
		img_dir = SettingsOutput.img_dir
		if img_dir.startswith("//") and not bpy.data.filepath:
			img_dir = default_dir
		output_filepath = bpy.path.abspath(img_dir)
		if '%C' in output_filepath: output_filepath = output_filepath.replace('%C', scene.camera.name)
		if '%S' in output_filepath: output_filepath = output_filepath.replace('%S', scene.name)
		if '%F' in output_filepath: output_filepath = output_filepath.replace('%F', clean_string(blendfile_name))

	if VRayExporter.output == 'USER':
		if VRayExporter.output_dir:
			export_filepath= bpy.path.abspath(VRayExporter.output_dir)

	elif VRayExporter.output == 'SCENE' and bpy.data.filepath:
		export_filepath= os.path.join(blendfile_path, "vrscene")

	if VRayExporter.output_unique:
		export_filename = blendfile_name

	if VRayExporter.output == 'USER':
		export_filepath = bpy.path.abspath(VRayExporter.output_dir)

	if VRayDR.on:
		export_filename = blendfile_name

	# Distributed rendering
	# filepath is relative = blend-file-name/filename
	if VRayDR.on and VRayDR.transferAssets == '0':
		abs_shared_dir  = os.path.normpath(bpy.path.abspath(VRayDR.shared_dir))
		export_filepath = os.path.normpath(os.path.join(abs_shared_dir, blendfile_name + os.sep))

		bus['filenames']['DR']               = {}
		bus['filenames']['DR']['shared_dir'] = abs_shared_dir
		bus['filenames']['DR']['sub_dir']    = blendfile_name
		bus['filenames']['DR']['dest_dir']   = export_filepath
		bus['filenames']['DR']['prefix']     = bus['filenames']['DR']['dest_dir']
		bus['filenames']['DR']['tex_dir']    = os.path.join(export_filepath, "textures")
		bus['filenames']['DR']['ies_dir']    = os.path.join(export_filepath, "IES")

	if bus['preview']:
		export_filename= "preview"
		if PLATFORM == 'linux':
			export_filepath = os.path.join("/dev/shm", "vrayblender_preview_"+get_username())
		else:
			export_filepath = os.path.join(tempfile.gettempdir(), "vrayblender_preview_"+get_username())

	export_directory = create_dir(export_filepath)

	# XXX: Ugly... If there were some error there could be some open files left
	#
	for key in bus['files']:
		f = bus['files']
		if f and not f.closed:
			f.close()

	for key in ('geometry', 'lights', 'materials', 'textures', 'nodes', 'camera', 'scene', 'environment'):
		if key == 'geometry':
			filepath = os.path.join(export_directory, "%s_geometry_00.vrscene" % (export_filename))
		else:
			if key == 'scene' and (VRayDR.on and VRayDR.transferAssets == '0'):
				# Scene file MUST be on top of scene directory
				filepath = os.path.normpath(os.path.join(export_directory, "..", "%s.vrscene" % (export_filename)))
			else:
				filepath = os.path.normpath(os.path.join(export_directory, "%s_%s.vrscene" % (export_filename, key)))
			bus['files'][key] = open(filepath, 'w')
		bus['filenames'][key] = filepath

	# Duplicate "Color mapping" setting to a separate file for correct preview
	#
	cmFilepath = getColorMappingFilepath()
	bus['filenames']['colorMapping'] = cmFilepath
	if not bus['preview']:
		bus['files']['colorMapping'] = open(cmFilepath, 'w')

	# Render output dir
	bus['filenames']['output'] = create_dir(output_filepath, pathOnly=not VRayExporter.auto_save_render)

	# Render output file name
	ext = SettingsOutput.img_format.lower()

	file_name = "render"
	if SettingsOutput.img_file:
		file_name = SettingsOutput.img_file
		if file_name.find("%C") != -1:
			file_name = file_name.replace("%C", scene.camera.name)
		if file_name.find("%S") != -1:
			file_name = file_name.replace("%S", scene.name)
		if file_name.find("%F") != -1:
			file_name = file_name.replace("%F", blendfile_name)
		file_name = clean_string(file_name)
		load_file_name = file_name
	bus['filenames']['output_filename'] = "%s.%s" % (file_name, ext)

	# Render output - load file name
	if SettingsOutput.img_file_needFrameNumber:
		load_file_name = "%s.%.4i" % (load_file_name, scene.frame_current)
	bus['filenames']['output_loadfile'] = "%s.%s" % (load_file_name, ext)

	# Lightmaps path
	# bus['filenames']['lightmaps']= create_dir(os.path.join(export_filepath, "lightmaps"))

	if VRayExporter.debug:
		debug(scene, "Files:")
		for key in sorted(bus['filenames'].keys()):
			debug(scene, "  {0:16}: {1}".format(key.capitalize(), bus['filenames'][key]))


# Converts kelvin temperature to color
def kelvin_to_rgb(temperature):
	return mathutils.Color(COLOR_TABLE[str(int(temperature / 100) * 100)])


# Load render result
def load_result(engine, w, h, filepath):
	if not os.path.exists(filepath):
		return

	if engine is None:
		return

	result = engine.begin_result(0, 0, w, h)
	layer = result.layers[0]
	try:
		layer.load_from_file(filepath)
	except:
		pass
	engine.end_result(result)


def GetStrSize(nBytes):
	BytesSuffix = (
		(1<<30, 'GB'),
		(1<<20, 'MB'),
		(1<<10, 'kB'),
		(1,     'bytes'),
	)
	for b,s in BytesSuffix:
		if nBytes > b:
			break
	return "%.2f %s" % (nBytes/b, s)


def TimeIt(label):
	def real_decorator(function):
		def wrapper(*args, **kwargs):
			ts = time.clock()
			function(*args, **kwargs)
			te = time.clock()
			debug(bpy.context.scene, "%s: %.2f\n" % (label, te-ts))
		return wrapper
	return real_decorator


def RelPath(filepath):
	path = filepath
	try:
		path = bpy.path.relpath(filepath)
	except ValueError:
		pass
	return path

########NEW FILE########
__FILENAME__ = uvwgen
'''

  V-Ray/Blender

  http://vray.cgdo.ru

  Author: Andrey M. Izrantsev (aka bdancer)
  E-Mail: izrantsev@cgdo.ru

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.

'''


''' Blender modules '''
import bpy

''' vb modules '''
from vb25.utils import *
from vb25.plugins import *


def write_UVWGenPlanarWorld(bus):
	scene   = bus['scene']
	ofile   = bus['files']['textures']
	texture = bus['mtex']['texture']

	VRayTexture = texture.vray
	VRaySlot    = texture.vray_slot

	uvwgen = "UWVGPW%s" % bus['mtex']['name']

	ob = get_orco_object(scene, bus['node']['object'], VRayTexture)

	ofile.write("\nUVWGenPlanarWorld %s {" % uvwgen)
	if ob:
		uvw_transform = ob.matrix_world.copy().inverted()
		ofile.write("\n\tuvw_transform= %s; // Object: %s" % (a(scene, transform(uvw_transform)), ob.name))
	ofile.write("\n}\n")

	return uvwgen


def write_UVWGenProjection(bus):
	TYPE= {
		'NONE':   0,
		'FLAT':   1,
		'SPHERE': 2,
		'TUBE':   3,
		'BALL':   4,
		#'CUBE':   5, # cubic
		'CUBE':   6,  # triplanar (looks like Cube actually)
		'TRI':    6,  # triplanar
		'PERS':   8,
	}

	scene= bus['scene']
	ofile= bus['files']['textures']

	texture= bus['mtex']['texture']

	VRayTexture= texture.vray
	VRaySlot=    texture.vray_slot

	uvwgen= "UVP%s" % (bus['mtex']['name'])

	ob= get_orco_object(scene, bus['node']['object'], VRayTexture)

	ofile.write("\nUVWGenProjection %s {" % uvwgen)
	ofile.write("\n\ttype= %d;" % TYPE[VRayTexture.mapping])
	if ob:
		uvw_transform= mathutils.Matrix.Rotation(math.radians(90.0), 4, 'X') # To match Blender mapping
		uvw_transform*= ob.matrix_world.copy().inverted()                    # To remove object transfrom
		ofile.write("\n\tuvw_transform= %s; // Object: %s" % (a(scene, transform(uvw_transform)), ob.name))
	# Add:
	#  - camera_settings
	#  - camera_view
	ofile.write("\n}\n")

	return uvwgen


def write_UVWGenChannel(bus):
	ofile = bus['files']['textures']
	sce   = bus['scene']

	texture = bus['mtex']['texture']
	slot    = bus['mtex'].get('slot')

	uvw_name = "UVC%s" % (bus['mtex']['name'])

	VRayExporter = sce.vray.exporter

	VRaySlot    = texture.vray_slot
	VRayTexture = texture.vray

	uvwgen = None
	if VRayTexture.texture_coords == 'ORCO':
		uvwgen = write_UVWGenProjection(bus)
	elif VRayTexture.texture_coords == 'WORLD':
		uvwgen = write_UVWGenPlanarWorld(bus)

	ofile.write("\nUVWGenMayaPlace2dTexture %s {" % uvw_name)
	if slot:
		if bus['preview']:
			ofile.write('\n\tuvw_channel=0;')
		else:
			if hasattr(slot, 'uv_layer') and slot.uv_layer:
				ofile.write('\n\tuv_set_name="%s";' % slot.uv_layer)
			else:
				ofile.write('\n\tuv_set_name="UVMap";')
			ofile.write("\n\ttranslate_frame_u=%.3f;" % slot.offset[0])
			ofile.write("\n\ttranslate_frame_v=%.3f;" % slot.offset[1])
			# ofile.write("\n\tcoverage_u=%.3f;" % slot.scale[0])
			# ofile.write("\n\tcoverage_v=%.3f;" % slot.scale[1])
	else:
		ofile.write('\n\tuvw_channel=0;')
	ofile.write("\n\tmirror_u=%d;" % VRayTexture.mirror_u)
	ofile.write("\n\tmirror_v=%d;" % VRayTexture.mirror_v)
	ofile.write("\n\trepeat_u=%.3f;" % VRayTexture.tile_u)
	ofile.write("\n\trepeat_v=%.3f;" % VRayTexture.tile_v)
	ofile.write("\n\trotate_frame=%.3f;" % VRaySlot.texture_rot)
	# Optional UVWGen from which the initial uvw coordinates
	# will be taken, instead of the surface point
	if uvwgen:
		ofile.write("\n\tuvwgen=%s;" % uvwgen)
	ofile.write("\n}\n")

	return uvw_name


def write_UVWGenEnvironment(bus):
	MAPPING_TYPE= {
		'SPHERE':  'spherical',
		'ANGULAR': 'angular',
		'SCREEN':  'screen',
		'TUBE':    'max_cylindrical',
		'CUBIC':   'cubic',
		'MBALL':   'mirror_ball',
	}

	scene= bus['scene']
	ofile= bus['files']['textures']

	slot=     bus['mtex']['slot']
	texture=  bus['mtex']['texture']
	tex_name= bus['mtex']['name']

	uvw_name= "UVE%s" % (tex_name)

	VRayTexture= texture.vray
	VRaySlot=    texture.vray_slot

	uvw_matrix=  mathutils.Matrix.Rotation(VRaySlot.texture_rotation_h, 4, 'Z')
	uvw_matrix*= mathutils.Matrix.Rotation(VRaySlot.texture_rotation_v, 4, 'Y')
	#uvw_matrix*= mathutils.Matrix.Rotation(VRaySlot.texture_rotation_w, 4, 'X')

	ofile.write("\nUVWGenEnvironment %s {" % uvw_name)
	ofile.write("\n\tmapping_type= \"%s\";" % MAPPING_TYPE[VRayTexture.environment_mapping])
	if VRayTexture.environment_mapping not in ('SCREEN'):
		ofile.write("\n\tuvw_matrix= %s;" % transform(uvw_matrix))
	else:
		ofile.write("\n\tuvw_transform= %s;" % transform(uvw_matrix))
	ofile.write("\n\twrap_u=1;")
	ofile.write("\n\twrap_v=1;")
	ofile.write("\n\tcrop_u=0;")
	ofile.write("\n\tcrop_v=0;")
	ofile.write("\n}\n")

	return uvw_name


def write_uvwgen(bus):
	slot=    bus['mtex']['slot']
	texture= bus['mtex']['texture']

	if type(slot) is bpy.types.WorldTextureSlot or ('dome' in bus['mtex'] and bus['mtex']['dome']):
		return write_UVWGenEnvironment(bus)

	else:
		VRayTexture= texture.vray

		uvwgen= write_UVWGenChannel(bus)

		# Cache uvwgen under texture name
		bus['cache']['uvwgen'][ bus['mtex']['name'] ]= uvwgen

		# We need to pass normal uvwgen to BRDFBump
		if 'material' in bus:
			bus['material']['normal_uvwgen'] = uvwgen
			bus['material']['bump_uvwgen']   = uvwgen
		return uvwgen

########NEW FILE########
__FILENAME__ = version
VERSION="v2.1030 [8d54f34]"

########NEW FILE########
