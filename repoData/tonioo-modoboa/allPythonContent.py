__FILENAME__ = modoboa-admin
#!/usr/bin/env python
# coding: utf-8

from modoboa.core.commands import handle_command_line

if __name__ == "__main__":
    handle_command_line()


########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Modoboa documentation build configuration file, created by
# sphinx-quickstart on Mon Jan  3 22:29:25 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['.templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Modoboa'
copyright = u'2014, Antoine Nguyen'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.1'
# The full version, including alpha/beta/rc tags.
release = '1.1.2'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['.build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.

on_rtd = os.environ.get('READTHEDOCS', None) == 'True'
if on_rtd:
    html_theme = 'default'
else:
    html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['.static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Modoboadoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Modoboa.tex', u'Modoboa Documentation',
   u'Antoine Nguyen', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'modoboa', u'Modoboa Documentation',
     [u'Antoine Nguyen'], 1)
]

########NEW FILE########
__FILENAME__ = app_settings
# coding: utf-8
from django import forms
from django.conf import settings
from django.utils.translation import ugettext as _, ugettext_lazy
from modoboa.lib.formutils import YesNoField, SeparatorField, InlineRadioSelect
from modoboa.lib.cryptutils import random_key
from modoboa.lib import parameters


def enabled_applications():
    """Return the list of currently enabled extensions

    We check if the table exists before trying to fetch activated
    extensions because the admin module is always imported by Django,
    even before the database exists (example: the first ``syncdb``).

    :return: a list
    """
    from modoboa.core.models import Extension
    from modoboa.core.extensions import exts_pool
    from modoboa.lib.dbutils import db_table_exists

    result = [("user", "user")]
    if db_table_exists("core_extension"):
        exts = Extension.objects.filter(enabled=True)
        for ext in exts:
            extclass = exts_pool.get_extension(ext.name)
            if extclass.available_for_topredirection:
                result.append((ext.name, ext.name))
    return sorted(result, key=lambda e: e[0])


class GeneralParametersForm(parameters.AdminParametersForm):
    app = "core"

    sep1 = SeparatorField(label=ugettext_lazy("Authentication"))

    authentication_type = forms.ChoiceField(
        label=ugettext_lazy("Authentication type"),
        choices=[('local', ugettext_lazy("Local")),
                 ('ldap', "LDAP")],
        initial="local",
        help_text=ugettext_lazy("The backend used for authentication"),
        widget=InlineRadioSelect
    )

    password_scheme = forms.ChoiceField(
        label=ugettext_lazy("Default password scheme"),
        choices=[("sha512crypt", "sha512crypt"),
                 ("sha256crypt", "sha256crypt"),
                 ("md5crypt", ugettext_lazy("md5crypt (weak)")),
                 ("sha256", ugettext_lazy("sha256 (weak)")),
                 ("md5", ugettext_lazy("md5 (weak)")),
                 ("crypt", ugettext_lazy("crypt (weak)")),
                 ("plain", ugettext_lazy("plain (weak)"))],
        initial="sha512crypt",
        help_text=ugettext_lazy("Scheme used to crypt mailbox passwords")
    )

    rounds_number = forms.IntegerField(
        label=ugettext_lazy("Rounds"),
        initial=70000,
        help_text=ugettext_lazy(
            "Number of rounds to use (only used by sha256crypt and "
            "sha512crypt). Must be between 1000 and 999999999, inclusive."
        )
    )

    secret_key = forms.CharField(
        label=ugettext_lazy("Secret key"),
        initial=random_key(),
        help_text=ugettext_lazy("Key used to encrypt/decrypt passwords")
    )

    # LDAP specific settings
    ldap_sep = SeparatorField(label=ugettext_lazy("LDAP settings"))

    ldap_server_address = forms.CharField(
        label=ugettext_lazy("Server address"),
        initial="localhost",
        help_text=ugettext_lazy("The IP address of the DNS name of the LDAP server")
    )

    ldap_server_port = forms.IntegerField(
        label=ugettext_lazy("Server port"),
        initial=389,
        help_text=ugettext_lazy("The TCP port number used by the LDAP server")
    )

    ldap_secured = YesNoField(
        label=ugettext_lazy("Use a secured connection"),
        initial="no",
        help_text=ugettext_lazy("Use an SSL/TLS connection to access the LDAP server")
    )

    ldap_auth_method = forms.ChoiceField(
        label=ugettext_lazy("Authentication method"),
        choices=[('searchbind', ugettext_lazy("Search and bind")),
                 ('directbind', ugettext_lazy("Direct bind"))],
        initial='searchbind',
        help_text=ugettext_lazy("Choose the authentication method to use"),
        widget=InlineRadioSelect
    )

    ldap_bind_dn = forms.CharField(
        label=ugettext_lazy("Bind DN"),
        initial='',
        help_text=ugettext_lazy("The distinguished name to use when binding to the LDAP server. Leave empty for an anonymous bind"),
        required=False
    )

    ldap_bind_password = forms.CharField(
        label=ugettext_lazy("Bind password"),
        initial='',
        help_text=ugettext_lazy("The password to use when binding to the LDAP server (with 'Bind DN')"),
        widget=forms.PasswordInput(render_value=True),
        required=False
    )

    ldap_search_base = forms.CharField(
        label=ugettext_lazy("Users search base"),
        initial="",
        help_text=ugettext_lazy("The distinguished name of the search base used to find users"),
        required=False
    )

    ldap_search_filter = forms.CharField(
        label=ugettext_lazy("Search filter"),
        initial="(mail=%(user)s)",
        help_text=ugettext_lazy("An optional filter string (e.g. '(objectClass=person)'). In order to be valid, it must be enclosed in parentheses."),
        required=False
    )

    ldap_user_dn_template = forms.CharField(
        label=ugettext_lazy("User DN template"),
        initial="",
        help_text=ugettext_lazy("The template used to construct a user's DN. It should contain one placeholder (ie. %(user)s)"),
        required=False
    )

    ldap_password_attribute = forms.CharField(
        label=ugettext_lazy("Password attribute"),
        initial="userPassword",
        help_text=ugettext_lazy("The attribute used to store user passwords")
    )

    ldap_is_active_directory = YesNoField(
        label=ugettext_lazy("Active Directory"),
        initial="no",
        help_text=ugettext_lazy("Tell if the LDAP server is an Active Directory one")
    )

    ldap_admin_groups = forms.CharField(
        label=ugettext_lazy("Administrator groups"),
        initial="",
        help_text=ugettext_lazy(
            "Members of those LDAP Posix groups will be created as domain "
            "administrators. Use ';' characters to separate groups."
        ),
        required=False
    )

    ldap_groups_search_base = forms.CharField(
        label=ugettext_lazy("Groups search base"),
        initial="",
        help_text=ugettext_lazy(
            "The distinguished name of the search base used to find groups"
        ),
        required=False
    )

    sep3 = SeparatorField(label=ugettext_lazy("Miscellaneous"))

    log_maximum_age = forms.IntegerField(
        label=ugettext_lazy("Maximum log record age"),
        initial=365,
        help_text=ugettext_lazy("The maximum age in days of a log record")
    )

    items_per_page = forms.IntegerField(
        label=ugettext_lazy("Items per page"),
        initial=30,
        help_text=ugettext_lazy("Number of displayed items per page")
    )

    default_top_redirection = forms.ChoiceField(
        label=ugettext_lazy("Default top redirection"),
        choices=[],
        initial="user",
        help_text=ugettext_lazy("The default redirection used when no application is specified")
    )

    # Visibility rules
    visibility_rules = {
        "ldap_sep": "authentication_type=ldap",
        "ldap_server_address": "authentication_type=ldap",
        "ldap_server_port": "authentication_type=ldap",
        "ldap_secured": "authentication_type=ldap",
        "ldap_auth_method": "authentication_type=ldap",
        "ldap_bind_dn": "ldap_auth_method=searchbind",
        "ldap_bind_password": "ldap_auth_method=searchbind",
        "ldap_search_base": "ldap_auth_method=searchbind",
        "ldap_search_filter": "ldap_auth_method=searchbind",
        "ldap_user_dn_template": "ldap_auth_method=directbind",
        "ldap_password_attribute": "authentication_type=ldap",
        "ldap_is_active_directory": "authentication_type=ldap",
        "ldap_admin_groups": "authentication_type=ldap",
        "ldap_groups_search_base": "authentication_type=ldap",
    }

    def __init__(self, *args, **kwargs):
        super(GeneralParametersForm, self).__init__(*args, **kwargs)
        self.fields["default_top_redirection"].choices = enabled_applications()

    def clean_secret_key(self):
        if len(self.cleaned_data["secret_key"]) not in [16, 24, 32]:
            raise forms.ValidationError(
                _("Key must be either 16, 24, or 32 bytes long")
            )
        return self.cleaned_data["secret_key"]

    def clean_ldap_user_dn_template(self):
        tpl = self.cleaned_data["ldap_user_dn_template"]
        try:
            test = tpl % {"user": "toto"}
        except (KeyError, ValueError):
            raise forms.ValidationError(_("Invalid syntax"))
        return tpl

    def clean_rounds_number(self):
        value = self.cleaned_data["rounds_number"]
        if value < 1000 or value > 999999999:
            raise forms.ValidationError(_("Invalid rounds number"))
        return value

    def clean(self):
        """Custom validation method

        Depending on 'ldap_auth_method' value, we check for different
        required parameters.
        """
        super(GeneralParametersForm, self).clean()
        if len(self._errors):
            raise forms.ValidationError(self._errors)
        cleaned_data = self.cleaned_data
        if cleaned_data["authentication_type"] != "ldap":
            return cleaned_data

        if cleaned_data["ldap_auth_method"] == "searchbind":
            required_fields = ["ldap_search_base", "ldap_search_filter"]
        else:
            required_fields = ["ldap_user_dn_template"]

        for f in required_fields:
            if not f in cleaned_data or cleaned_data[f] == u'':
                self._errors[f] = self.error_class([_("This field is required")])

        return cleaned_data

    def to_django_settings(self):
        """Apply LDAP related parameters to Django settings

        Doing so, we can use the django_auth_ldap module.
        """
        try:
            import ldap
            from django_auth_ldap.config import LDAPSearch, PosixGroupType
            ldap_available = True
        except ImportError:
            ldap_available = False

        values = self.get_current_values()
        if not ldap_available or values["authentication_type"] != "ldap":
            return
        if not hasattr(settings, "AUTH_LDAP_USER_ATTR_MAP"):
            setattr(settings, "AUTH_LDAP_USER_ATTR_MAP", {
                "first_name": "givenName",
                "email": "mail",
                "last_name": "sn"
            })
        ldap_uri = 'ldaps://' if values["ldap_secured"] == "yes" else "ldap://"
        ldap_uri += "%s:%s" % (values["ldap_server_address"], values["ldap_server_port"])
        setattr(settings, "AUTH_LDAP_SERVER_URI", ldap_uri)
        setattr(settings, "AUTH_LDAP_GROUP_TYPE", PosixGroupType())
        setattr(settings, "AUTH_LDAP_GROUP_SEARCH", LDAPSearch(
            values["ldap_groups_search_base"], ldap.SCOPE_SUBTREE,
            "(objectClass=posixGroup)"
        ))
        if values["ldap_auth_method"] == "searchbind":
            setattr(settings, "AUTH_LDAP_BIND_DN", values["ldap_bind_dn"])
            setattr(settings, "AUTH_LDAP_BIND_PASSWORD", values["ldap_bind_password"])
            search = LDAPSearch(
                values["ldap_search_base"], ldap.SCOPE_SUBTREE,
                values["ldap_search_filter"]
            )
            setattr(settings, "AUTH_LDAP_USER_SEARCH", search)
        else:
            setattr(settings, "AUTH_LDAP_USER_DN_TEMPLATE", values["ldap_user_dn_template"])
        if values["ldap_is_active_directory"] == "yes":
            if not hasattr(settings, "AUTH_LDAP_GLOBAL_OPTIONS"):
                setattr(settings, "AUTH_LDAP_GLOBAL_OPTIONS", {
                    ldap.OPT_REFERRALS: False
                })
            else:
                settings.AUTH_LDAP_GLOBAL_OPTIONS[ldap.OPT_REFERRALS] = False


def translate_language_code(value):
    if "-" in value:
        return value.split("-")[0]
    return value


class UserSettings(parameters.UserParametersForm):
    app = "core"

    sep = SeparatorField(label=ugettext_lazy("Display"))

    lang = forms.ChoiceField(
        initial=translate_language_code(settings.LANGUAGE_CODE),
        label=ugettext_lazy("Prefered language"),
        choices=[("cs", "čeština"), ("de", "deutsch"),
                 ("en", "english"), ("es", "español"),
                 ("fr", "français"), ("it", "italiano"),
                 ("nl", "nederlands"), ("pt", "português"),
                 ("ru", "русский"), ("sv", "svenska")],
        help_text=ugettext_lazy("Prefered language to display pages")
    )

########NEW FILE########
__FILENAME__ = deploy
# coding: utf-8
import sys
import os
import shutil
import getpass
import subprocess
import dj_database_url

from django.core import management
from django.template import Context, Template
from modoboa.lib.sysutils import exec_cmd
from modoboa.core.commands import Command

dbconn_tpl = """
    '{{ conn_name }}': {
        'ENGINE': '{{ ENGINE }}',
        'NAME': '{{ NAME }}',                       # Or path to database file if using sqlite3.
        'USER': '{% if USER %}{{ USER }}{% endif %}',                     # Not used with sqlite3.
        'PASSWORD': '{% if PASSWORD %}{{ PASSWORD }}{% endif %}',                 # Not used with sqlite3.
        'HOST': '{% if HOST %}{{ HOST }}{% endif %}',                       # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '{% if PORT %}{{ PORT }}{% endif %}',                      # Set to empty string for default. Not used with sqlite3.{% if ENGINE == 'django.db.backends.mysql' %}
        'OPTIONS' : {
            "init_command" : 'SET foreign_key_checks = 0;',
        },{% endif %}
    },
"""


class DeployCommand(Command):
    help = "Create a fresh django project (calling startproject) and apply Modoboa specific settings."

    def __init__(self, *args, **kwargs):
        super(DeployCommand, self).__init__(*args, **kwargs)
        self._parser.add_argument('name', type=str,
                                  help='The name of your Modoboa instance')
        self._parser.add_argument(
            '--with-amavis', action='store_true', default=False,
            help='Include amavis configuration'
        )
        self._parser.add_argument(
            '--syncdb', action='store_true', default=False,
            help='Run django syncdb command'
        )
        self._parser.add_argument(
            '--collectstatic', action='store_true', default=False,
            help='Run django collectstatic command'
        )
        self._parser.add_argument(
            '--dburl', type=str, nargs=1, default=None,
            help='The database-url for your modoboa instance')
        self._parser.add_argument(
            '--amavis_dburl', type=str, nargs=1, default=None,
            help='The database-url for your amavis instance')
        self._parser.add_argument(
            '--domain', type=str, nargs=1, default=None,
            help='The domain under which you want to deploy modoboa')


    def _exec_django_command(self, name, cwd, *args):
        """Run a django command for the freshly created project

        :param name: the command name
        :param cwd: the directory where the command must be executed
        """
        cmd = 'python manage.py %s %s' % (name, " ".join(args))
        if not self._verbose:
            p = subprocess.Popen(
                cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
                shell=True, cwd=cwd
            )
            output = p.communicate()
        else:
            p = subprocess.Popen(cmd, shell=True, cwd=cwd)
            p.wait()
            output = None
        if p.returncode:
            if output:
                print >> sys.stderr, "\n".join([l for l in output if l is not None])
            print >> sys.stderr, "%s failed, check your configuration" % cmd

    def ask_db_info(self, name='default'):
        """Prompt the user for database information

        Gather all information required to create a new database
        connection (into settings.py).

        :param name: the connection name
        """
        print "Configuring database connection: %s" % name
        info = {'conn_name': name,
                'ENGINE': raw_input('Database type (mysql, postgres or sqlite3): ')}
        if info['ENGINE'] not in ['mysql', 'postgres', 'sqlite3']:
            raise RuntimeError('Unsupported database engine')

        if info['ENGINE'] == 'sqlite3':
            info['ENGINE'] = 'django.db.backends.sqlite3'
            info['NAME'] = '%s.db' % name
            return info
        if info['ENGINE'] == 'postgres':
            info['ENGINE'] = 'django.db.backends.postgresql_psycopg2'
            default_port = 5432
        else:
            info['ENGINE'] = 'django.db.backends.mysql'
            default_port = 3306
        info['HOST'] = raw_input("Database host (default: 'localhost'): ")
        info['PORT'] = raw_input("Database port (default: '%s'): " % default_port)
        # leave port setting empty, if default value is supplied and
        # leave it to django
        if info['PORT'] == default_port:
            info['PORT'] = ''
        info['NAME'] = raw_input('Database name: ')
        info['USER'] = raw_input('Username: ')
        info['PASSWORD'] = getpass.getpass('Password: ')
        return info

    def handle(self, parsed_args):
        management.call_command(
            'startproject', parsed_args.name, verbosity=False
        )
        if os.path.exists("%(name)s/%(name)s" % {'name': parsed_args.name}):
            # Django 1.4+
            path = "%(name)s/%(name)s" % {'name': parsed_args.name}
            sys.path.append(parsed_args.name)
            django14 = True
        else:
            path = parsed_args.name
            sys.path.append(".")
            django14 = False

        t = Template(dbconn_tpl)

        if parsed_args.dburl:
            info = dj_database_url.config(default=parsed_args.dburl[0])
            # In case the user fails to supply a valid database url, fallback to manual mode
            if not info:
                print "There was a problem with your database-url. \n"
                info = self.ask_db_info()
            #If we set this earlier, our fallback method will never be triggered
            info['conn_name'] = 'default'
        else:
            info = self.ask_db_info()

        default_conn = t.render(Context(info))

        if parsed_args.with_amavis:
            if parsed_args.amavis_dburl:
                amavis_info = dj_database_url.config(default=parsed_args.amavis_dburl[0])
                # In case the user fails to supply a valid database url, fallback to manual mode
                if not amavis_info:
                    amavis_info = self.ask_db_info('amavis')
                #If we set this earlier, our fallback method will never be triggered
                amavis_info['conn_name'] = 'amavis'
            else:
                amavis_info = self.ask_db_info('amavis')

            amavis_conn = t.render(Context(amavis_info))
        else:
            amavis_conn = None

        if parsed_args.domain:
            allowed_host = parsed_args.domain[0]
        else:
            allowed_host = raw_input(
                'Under which domain do you want to deploy modoboa? '
            )

        mod = __import__(parsed_args.name, globals(), locals(), ['settings'])
        tpl = self._render_template(
            "%s/settings.py.tpl" % self._templates_dir, {
                'default_conn': default_conn, 'amavis_conn': amavis_conn,
                'secret_key': mod.settings.SECRET_KEY,
                'name': parsed_args.name, 'django14': django14,
                'allowed_host': allowed_host
            }
        )
        with open("%s/settings.py" % path, "w") as fp:
            fp.write(tpl)
        shutil.copyfile(
            "%s/urls.py.tpl" % self._templates_dir, "%s/urls.py" % path
        )
        os.mkdir("%s/media" % path)

        if parsed_args.syncdb:
            os.unlink("%s/settings.pyc" % path)
            self._exec_django_command(
                "syncdb", parsed_args.name, '--noinput'
            )
            exec_cmd('sed -ri "s|^#(\s+\'south)|\\1|" %s/settings.py' % path)
            self._exec_django_command(
                "syncdb", parsed_args.name,
            )
            self._exec_django_command(
                'migrate', parsed_args.name, '--fake'
            )
            self._exec_django_command(
                "loaddata", parsed_args.name, 'initial_users.json'
            )

        if parsed_args.collectstatic:
            self._exec_django_command(
                "collectstatic", parsed_args.name, '--noinput'
            )

########NEW FILE########
__FILENAME__ = help
# coding: utf-8
import sys
from . import Command


class HelpCommand(Command):
    help = "Display the help message associated to a specific command"

    def __init__(self, *args, **kwargs):
        super(HelpCommand, self).__init__(*args, **kwargs)
        self._parser.add_argument('name', type=str,
                                  help='A command name')

    def handle(self, parsed_args):
        if not parsed_args.name in self._commands:
            print >>sys.stderr, "Unknown command: %s" % parsed_args.name
            sys.exit(1)
        cmd = self._commands[parsed_args.name](self._commands)
        cmd._parser.prog = "modoboa-admin.py %s" % parsed_args.name
        cmd._parser.description = cmd.help
        cmd._parser.print_help()

########NEW FILE########
__FILENAME__ = postfix_maps
# coding: utf-8
import getpass
import inspect
import os
import sys
import datetime
from django.template import Context, Template
from . import Command


class MapFilesGenerator(object):

    def __init__(self):
        self.template = Template("""user = {{ dbuser }}
password = {{ dbpass }}
dbname = {{ dbname }}
hosts = {{ dbhost }}
query = {{ query|safe }}
""")
        self.tpl_context = {
            'dbhost': raw_input('Database host: '),
            'dbname': raw_input('Database name: '),
            'dbuser': raw_input('Username: '),
            'dbpass': getpass.getpass('Password: ')
        }
        if not self.tpl_context['dbhost']:
            self.tpl_context['dbhost'] = '127.0.0.1'

    def __render_map(self, args, mapobject):
        """Render a map file.

        :param args: command line arguments
        :param mapobject: a ``MapFile`` subclass
        """
        content = self.template.render(
            Context(dict(
                self.tpl_context.items(),
                query=getattr(mapobject, args.dbtype)
            ))
        )
        with open("%s/%s" % (args.destdir, mapobject.filename), "w") as fp:
            print >> fp, """# This file was generated on %s by running:
# %s %s
# DO NOT EDIT!
""" % (datetime.datetime.now().isoformat(),
       os.path.basename(sys.argv[0]),
       ' '.join(sys.argv[1:]))
            print >> fp, content

    def __render_std_maps(self, args):
        """Render standard map files.

        (ie. the ones belonging to the 'std' category)

        :param args: command line arguments
        """
        for v in globals().values():
            if not inspect.isclass(v) or not issubclass(v, MapFile):
                continue
            if v is MapFile:
                continue
            if not v.category in args.categories:
                continue
            self.__render_map(args, v)

    def render(self, args):
        """Render all map files.

        :param args: arguments received from the command line
        """
        try:
            os.mkdir(args.destdir)
        except OSError:
            pass
        self.__render_std_maps(args)


class SQLiteMapFilesGenerator(MapFilesGenerator):

    def __init__(self):
        self.template = Template("""dbpath = {{ dbpath }}
query = {{ query|safe }}
""")
        self.tpl_context = {
            'dbpath': raw_input('Database path: ')
        }


class MapFile(object):
    category = 'std'


class DomainsMap(MapFile):
    filename = 'sql-domains.cf'
    mysql = "SELECT name FROM admin_domain WHERE name='%s' AND enabled=1"
    postgres = "SELECT name FROM admin_domain WHERE name='%s' AND enabled"
    sqlite = "SELECT name FROM admin_domain WHERE name='%s' AND enabled=1"


class DomainsAliasesMap(MapFile):
    filename = 'sql-domain-aliases.cf'
    mysql = "SELECT dom.name FROM admin_domain dom INNER JOIN admin_domainalias domal ON dom.id=domal.target_id WHERE domal.name='%s' AND domal.enabled=1 AND dom.enabled=1"
    postgres = "SELECT dom.name FROM admin_domain dom INNER JOIN admin_domainalias domal ON dom.id=domal.target_id WHERE domal.name='%s' AND domal.enabled AND dom.enabled"
    sqlite = "SELECT dom.name FROM admin_domain dom INNER JOIN admin_domainalias domal ON dom.id=domal.target_id WHERE domal.name='%s' AND domal.enabled=1 AND dom.enabled=1"


class AliasesMap(MapFile):
    filename = 'sql-aliases.cf'
    mysql = "(SELECT concat(mb.address, '@', dom.name) FROM admin_mailbox mb INNER JOIN admin_domain dom ON mb.domain_id=dom.id WHERE mb.id IN (SELECT al_mb.mailbox_id FROM admin_alias_mboxes al_mb INNER JOIN admin_alias al ON al_mb.alias_id=al.id INNER JOIN admin_domain dom ON al.domain_id=dom.id WHERE dom.name='%d' AND dom.enabled=1 AND al.address='%u' AND al.enabled=1)) UNION (SELECT concat(al.address, '@', dom.name) FROM admin_alias al INNER JOIN admin_domain dom ON al.domain_id=dom.id WHERE al.id IN (SELECT al_al.to_alias_id FROM admin_alias_aliases al_al INNER JOIN admin_alias al ON al_al.from_alias_id=al.id INNER JOIN admin_domain dom ON al.domain_id=dom.id WHERE dom.name='%d' AND dom.enabled=1 AND al.address='%u' AND al.enabled=1)) UNION (SELECT al.extmboxes FROM admin_alias al INNER JOIN admin_domain dom ON al.domain_id=dom.id WHERE dom.name='%d' AND dom.enabled=1 AND al.address='%u' AND al.enabled=1 AND al.extmboxes<>'')"
    postgres = "(SELECT mb.address || '@' || dom.name FROM admin_mailbox mb INNER JOIN admin_domain dom ON mb.domain_id=dom.id WHERE mb.id IN (SELECT al_mb.mailbox_id FROM admin_alias_mboxes al_mb INNER JOIN admin_alias al ON al_mb.alias_id=al.id INNER JOIN admin_domain dom ON al.domain_id=dom.id WHERE dom.name='%d' AND dom.enabled AND al.address='%u' AND al.enabled)) UNION (SELECT al.address || '@' || dom.name FROM admin_alias al INNER JOIN admin_domain dom ON al.domain_id=dom.id WHERE al.id IN (SELECT al_al.to_alias_id FROM admin_alias_aliases al_al INNER JOIN admin_alias al ON al_al.from_alias_id=al.id INNER JOIN admin_domain dom ON al.domain_id=dom.id WHERE dom.name='%d' AND dom.enabled AND al.address='%u' AND al.enabled)) UNION (SELECT al.extmboxes FROM admin_alias al INNER JOIN admin_domain dom ON al.domain_id=dom.id WHERE dom.name='%d' AND dom.enabled AND al.address='%u' AND al.enabled AND al.extmboxes<>'')"
    sqlite = "(SELECT (mb.address || '@' || dom.name) FROM admin_mailbox mb INNER JOIN admin_domain dom ON mb.domain_id=dom.id WHERE mb.id IN (SELECT al_mb.mailbox_id FROM admin_alias_mboxes al_mb INNER JOIN admin_alias al ON al_mb.alias_id=al.id INNER JOIN admin_domain dom ON al.domain_id=dom.id WHERE dom.name='%d' AND dom.enabled=1 AND al.address='%u' AND al.enabled=1)) UNION (SELECT (al.address || '@' || dom.name) FROM admin_alias al INNER JOIN admin_domain dom ON al.domain_id=dom.id WHERE al.id IN (SELECT al_al.to_alias_id FROM admin_alias_aliases al_al INNER JOIN admin_alias al ON al_al.from_alias_id=al.id INNER JOIN admin_domain dom ON al.domain_id=dom.id WHERE dom.name='%d' AND dom.enabled=1 AND al.address='%u' AND al.enabled=1)) UNION (SELECT al.extmboxes FROM admin_alias al INNER JOIN admin_domain dom ON al.domain_id=dom.id WHERE dom.name='%d' AND dom.enabled=1 AND al.address='%u' AND al.enabled=1 AND al.extmboxes<>'')"


class DomainAliasesMailboxesMap(MapFile):
    filename = 'sql-domain-aliases-mailboxes.cf'
    mysql = "(SELECT concat(mb.address, '@', dom.name) FROM admin_domainalias domal INNER JOIN admin_domain dom ON domal.target_id=dom.id INNER JOIN admin_mailbox mb ON mb.domain_id=dom.id WHERE domal.name='%d' AND dom.enabled=1 AND mb.address='%u') UNION (SELECT concat(al.address, '@', dom.name) FROM admin_domainalias domal INNER JOIN admin_domain dom ON domal.target_id=dom.id INNER JOIN admin_alias al ON al.domain_id=dom.id WHERE domal.name='%d' AND dom.enabled=1 AND al.address='%u')"
    postgres = "(SELECT mb.address || '@' || dom.name FROM admin_domainalias domal INNER JOIN admin_domain dom ON domal.target_id=dom.id INNER JOIN admin_mailbox mb ON mb.domain_id=dom.id WHERE domal.name='%d' AND dom.enabled AND mb.address='%u') UNION (SELECT al.address || '@' || dom.name FROM admin_domainalias domal INNER JOIN admin_domain dom ON domal.target_id=dom.id INNER JOIN admin_alias al ON al.domain_id=dom.id WHERE domal.name='%d' AND dom.enabled AND al.address='%u')"
    sqlite = "(SELECT mb.address || '@' || dom.name FROM admin_domainalias domal INNER JOIN admin_domain dom ON domal.target_id=dom.id INNER JOIN admin_mailbox mb ON mb.domain_id=dom.id WHERE domal.name='%d' AND dom.enabled=1 AND mb.address='%u') UNION (SELECT al.address || '@' || dom.name FROM admin_domainalias domal INNER JOIN admin_domain dom ON domal.target_id=dom.id INNER JOIN admin_alias al ON al.domain_id=dom.id WHERE domal.name='%d' AND dom.enabled=1 AND al.address='%u')"


class CatchallAliasesMap(MapFile):
    filename = 'sql-catchall-aliases.cf'
    mysql = "(SELECT concat(mb.address, '@', dom.name) FROM admin_mailbox mb INNER JOIN admin_domain dom ON mb.domain_id=dom.id WHERE mb.id IN (SELECT al_mb.mailbox_id FROM admin_alias al INNER JOIN admin_domain dom ON al.domain_id=dom.id INNER JOIN admin_alias_mboxes al_mb ON al.id=al_mb.alias_id WHERE al.enabled=1 AND al.address='*' AND dom.name='%d' AND dom.enabled=1)) UNION (SELECT al.extmboxes FROM admin_alias al INNER JOIN admin_domain dom ON al.domain_id=dom.id WHERE al.enabled='1' AND al.extmboxes<>'' AND al.address='*' AND dom.name='%d' AND dom.enabled=1)"
    postgres = "(SELECT mb.address || '@' || dom.name FROM admin_mailbox mb INNER JOIN admin_domain dom ON mb.domain_id=dom.id WHERE mb.id IN (SELECT al_mb.mailbox_id FROM admin_alias al INNER JOIN admin_domain dom ON al.domain_id=dom.id INNER JOIN admin_alias_mboxes al_mb ON al.id=al_mb.alias_id WHERE al.enabled AND al.address='*' AND dom.name='%d' AND dom.enabled)) UNION (SELECT al.extmboxes FROM admin_alias al INNER JOIN admin_domain dom ON al.domain_id=dom.id WHERE al.enabled AND al.extmboxes<>'' AND al.address='*' AND dom.name='%d' AND dom.enabled)"
    sqlite = "(SELECT (mb.address || '@' || dom.name) FROM admin_mailbox mb INNER JOIN admin_domain dom ON mb.domain_id=dom.id WHERE mb.id IN (SELECT al_mb.mailbox_id FROM admin_alias al INNER JOIN admin_domain dom ON al.domain_id=dom.id INNER JOIN admin_alias_mboxes al_mb ON al.id=al_mb.alias_id WHERE al.enabled=1 AND al.address='*' AND dom.name='%d' AND dom.enabled=1)) UNION (SELECT al.extmboxes FROM admin_alias al INNER JOIN admin_domain dom ON al.domain_id=dom.id WHERE al.enabled='1' AND al.extmboxes<>'' AND al.address='*' AND dom.name='%d' AND dom.enabled=1)"


class MaintainMap(MapFile):
    filename = 'sql-maintain.cf'
    mysql = "SELECT '450 Requested mail action not taken: mailbox unavailable' FROM admin_mailbox mb INNER JOIN admin_domain dom ON mb.domain_id=dom.id INNER JOIN admin_mailboxoperation mbop ON mbop.mailbox_id=mb.id WHERE dom.name='%d' AND mb.address='%u' LIMIT 1"
    postgres = "SELECT '450 Requested mail action not taken: mailbox unavailable' FROM admin_mailbox mb INNER JOIN admin_domain dom ON mb.domain_id=dom.id INNER JOIN admin_mailboxoperation mbop ON mbop.mailbox_id=mb.id WHERE dom.name='%d' AND mb.address='%u' LIMIT 1"
    sqlite = "SELECT '450 Requested mail action not taken: mailbox unavailable' FROM admin_mailbox mb INNER JOIN admin_domain dom ON mb.domain_id=dom.id INNER JOIN admin_mailboxoperation mbop ON mbop.mailbox_id=mb.id WHERE dom.name='%d' AND mb.address='%u' LIMIT 1"


class TransportMap(MapFile):
    category = "autoreply"
    filename = 'sql-autoreplies-transport.cf'
    mysql = "SELECT method FROM postfix_autoreply_transport WHERE domain='%s'"
    postgres = "SELECT method FROM postfix_autoreply_transport WHERE domain='%s'"
    sqlite = "SELECT method FROM postfix_autoreply_transport WHERE domain='%s'"


class AutoRepliesMap(MapFile):
    category = "autoreply"
    filename = 'sql-autoreplies.cf'
    mysql = "SELECT full_address, autoreply_address FROM postfix_autoreply_alias WHERE full_address='%s'"
    postgres = "SELECT full_address, autoreply_address FROM postfix_autoreply_alias WHERE full_address='%s'"
    sqlite = "SELECT full_address, autoreply_address FROM postfix_autoreply_alias WHERE full_address='%s'"


class RelayDomainsMap(MapFile):
    category = "relaydomains"
    filename = "sql-relaydomains.cf"
    mysql = "SELECT name FROM postfix_relay_domains_relaydomain WHERE name='%s' AND enabled=1"
    postgres = "SELECT name FROM postfix_relay_domains_relaydomain WHERE name='%s' AND enabled"
    sqlite = "SELECT name FROM postfix_relay_domains_relaydomain WHERE name='%s' AND enabled=1"


class RelayDomainsTransportMap(MapFile):
    category = "relaydomains"
    filename = "sql-relaydomains-transport.cf"
    mysql = "SELECT CONCAT(srv.name, ':[', rdom.target_host, ']') FROM postfix_relay_domains_service AS srv INNER JOIN postfix_relay_domains_relaydomain AS rdom ON rdom.service_id=srv.id WHERE rdom.enabled=1 AND rdom.name='%s'"
    postgres = "SELECT srv.name || ':[' || rdom.target_host || ']' FROM postfix_relay_domains_service AS srv INNER JOIN postfix_relay_domains_relaydomain AS rdom ON rdom.service_id=srv.id WHERE rdom.enabled AND rdom.name='%s'"
    sqlite = "SELECT srv.name || ':[' || rdom.target_host || ']' FROM postfix_relay_domains_service AS srv INNER JOIN postfix_relay_domains_relaydomain AS rdom ON rdom.service_id=srv.id WHERE rdom.enabled=1 AND rdom.name='%s'"


class RelayDomainAliasesTransportMap(MapFile):
    category = "relaydomains"
    filename = "sql-relaydomain-aliases-transport.cf"
    mysql = "SELECT CONCAT(srv.name, ':[', rdom.target_host, ']') FROM postfix_relay_domains_service AS srv INNER JOIN postfix_relay_domains_relaydomain AS rdom ON rdom.service_id=srv.id INNER JOIN postfix_relay_domains_relaydomainalias AS rdomalias ON rdom.id=rdomalias.target_id WHERE rdom.enabled=1 AND rdomalias.enabled=1 AND rdomalias.name='%s'"
    postgres = "SELECT srv.name || ':[' || rdom.target_host || ']' FROM postfix_relay_domains_service AS srv INNER JOIN postfix_relay_domains_relaydomain AS rdom ON rdom.service_id=srv.id INNER JOIN postfix_relay_domains_relaydomainalias AS rdomalias ON rdom.id=rdomalias.target_id WHERE rdom.enabled AND rdomalias.enabled AND rdomalias.name='%s'"
    sqlite = "SELECT srv.name || ':[' || rdom.target_host || ']' FROM postfix_relay_domains_service AS srv INNER JOIN postfix_relay_domains_relaydomain AS rdom ON rdom.service_id=srv.id INNER JOIN postfix_relay_domains_relaydomainalias AS rdomalias ON rdom.id=rdomalias.target_id WHERE rdom.enabled=1 AND rdomalias.enabled=1 AND rdomalias.name='%s'"


class RelayRecipientVerification(MapFile):
    category = "relaydomains"
    filename = "sql-relay-recipient-verification.cf"
    mysql = "SELECT 'reject_unverified_recipient' FROM postfix_relay_domains_relaydomain WHERE verify_recipients=1 AND name='%d'"
    postgres = "SELECT 'reject_unverified_recipient' FROM postfix_relay_domains_relaydomain WHERE verify_recipients AND name='%d'"
    sqlite = "SELECT 'reject_unverified_recipient' FROM postfix_relay_domains_relaydomain WHERE verify_recipients=1 AND name='%d'"


class PostfixMapsCommand(Command):
    help = "Generate ready-to-use postfix map files"

    def __init__(self, *args, **kwargs):
        super(PostfixMapsCommand, self).__init__(*args, **kwargs)
        self._parser.add_argument(
            'destdir', type=str,
            help='Directory that will contain generated map files'
        )
        self._parser.add_argument(
            '--dbtype', type=str, choices=['mysql', 'postgres', 'sqlite'],
            default='mysql',
            help='Used database type'
        )
        self._parser.add_argument(
            '--categories', type=str, nargs='*', default=['std'],
            help='Map file categories to generate (choices: std, autoreply)'
        )

    def handle(self, parsed_args):
        if parsed_args.dbtype == 'sqlite':
            g = SQLiteMapFilesGenerator()
        else:
            g = MapFilesGenerator()
        g.render(parsed_args)

########NEW FILE########
__FILENAME__ = extensions
from django.conf import settings
from django.conf.urls import include


class ModoExtension(object):
    """Base extension class

    Each Modoboa extension must inherit from this class to be
    considered as valid.
    """
    name = None
    label = None
    version = "NA"
    description = ""
    url = None
    needs_media = False
    always_active = False
    available_for_topredirection = False

    def infos(self):
        return dict(
            name=self.name, label=self.label, version=self.version,
            description=self.description, url=self.url,
            always_active=self.always_active
        )

    def init(self):
        pass

    def destroy(self):
        pass

    def load(self):
        pass


class ExtensionsPool(object):
    """The extensions manager"""

    def __init__(self):
        self.extensions = {}

    def register_extension(self, ext, show=True):
        self.extensions[ext.name] = dict(cls=ext, show=show)

    def get_extension(self, name):
        if not name in self.extensions:
            return None
        if not "instance" in self.extensions[name]:
            self.extensions[name]["instance"] = self.extensions[name]["cls"]()
        return self.extensions[name]["instance"]

    def is_extension_enabled(self, name):
        from modoboa.core.models import Extension

        if not name in self.extensions:
            return False
        return Extension.objects.get(name=name).enabled

    def get_extension_infos(self, name):
        instance = self.get_extension(name)
        if instance is None:
            return None
        return instance.infos()

    def load_all(self):
        """Load all enabled extensions.

        Each extension must be loaded in order to integrate with
        Modoboa. Only enabled and special extensions are loaded but
        urls are always returned. The reason is urls are imported only
        once so must know all of them when the python process
        starts. Otherwise, it would lead to unexpected 404 errors :p

        :return: a list of url maps
        """
        from modoboa.core.models import Extension

        result = []
        for ext in settings.MODOBOA_APPS:
            __import__(ext)
            extname = ext.split('.')[-1]
            extinstance = self.get_extension(extname)
            if extinstance is None:
                continue
            try:
                baseurl = extinstance.url \
                    if extinstance.url is not None else extname
                result += [(r'^%s/' % (baseurl),
                            include("%s.urls" % extinstance.__module__))]
            except ImportError:
                # No urls for this extension
                pass
            if not extinstance.always_active:
                try:
                    ext = Extension.objects.get(name=extname)
                    if not ext.enabled:
                        continue
                except Extension.DoesNotExist:
                    continue
            extinstance.load()
        return result

    def list_all(self):
        """List all defined extensions.
        """
        result = []
        for extname, extdef in self.extensions.iteritems():
            if not extdef["show"]:
                continue
            infos = self.get_extension_infos(extname)
            infos["id"] = extname
            result += [infos]
        return sorted(result, key=lambda i: i["name"])

exts_pool = ExtensionsPool()

########NEW FILE########
__FILENAME__ = factories
import factory
from django.contrib.auth.models import Group
from . import models


class PermissionFactory(factory.DjangoModelFactory):
    ABSTRACT_FACTORY = True

    @factory.post_generation
    def set_permission(self, create, extracted, **kwargs):
        if not create:
            return
        self.post_create(models.User.objects.get(pk=1))


class GroupFactory(factory.DjangoModelFactory):
    FACTORY_FOR = Group

    name = 'DefaultGroup'


class UserFactory(PermissionFactory):
    FACTORY_FOR = models.User

    email = factory.LazyAttribute(lambda a: a.username)
    password = '{PLAIN}toto'

    @factory.post_generation
    def groups(self, create, extracted, **kwargs):
        if not create:
            return

        if extracted:
            for group in extracted:
                self.groups.add(Group.objects.get(name=group))

########NEW FILE########
__FILENAME__ = forms
# coding: utf-8
from django import forms
from django.utils.translation import ugettext as _, ugettext_lazy
from modoboa.core.models import User
from modoboa.lib import parameters


class LoginForm(forms.Form):
    username = forms.CharField(
        label=ugettext_lazy("Username"),
        widget=forms.TextInput(attrs={"class": "input-block-level"})
    )
    password = forms.CharField(
        label=ugettext_lazy("Password"),
        widget=forms.PasswordInput(attrs={"class": "input-block-level"})
    )
    rememberme = forms.BooleanField(
        initial=False,
        required=False
    )


class ProfileForm(forms.ModelForm):
    oldpassword = forms.CharField(
        label=ugettext_lazy("Old password"), required=False,
        widget=forms.PasswordInput
    )
    newpassword = forms.CharField(
        label=ugettext_lazy("New password"), required=False,
        widget=forms.PasswordInput
    )
    confirmation = forms.CharField(
        label=ugettext_lazy("Confirmation"), required=False,
        widget=forms.PasswordInput
    )

    class Meta:
        model = User
        fields = ("first_name", "last_name")

    def __init__(self, update_password, *args, **kwargs):
        super(ProfileForm, self).__init__(*args, **kwargs)
        if not update_password:
            del self.fields["oldpassword"]
            del self.fields["newpassword"]
            del self.fields["confirmation"]

    def clean_oldpassword(self):
        if self.cleaned_data["oldpassword"] == "":
            return self.cleaned_data["oldpassword"]

        if parameters.get_admin("AUTHENTICATION_TYPE") != "local":
            return self.cleaned_data["oldpassword"]

        if not self.instance.check_password(self.cleaned_data["oldpassword"]):
            raise forms.ValidationError(_("Old password mismatchs"))
        return self.cleaned_data["oldpassword"]

    def clean_confirmation(self):
        if self.cleaned_data["newpassword"] != self.cleaned_data["confirmation"]:
            raise forms.ValidationError(_("Passwords mismatch"))
        return self.cleaned_data["confirmation"]

    def save(self, commit=True):
        user = super(ProfileForm, self).save(commit=False)
        if commit:
            if self.cleaned_data.has_key("confirmation") and \
                    self.cleaned_data["confirmation"] != "":
                user.set_password(self.cleaned_data["confirmation"], self.cleaned_data["oldpassword"])
            user.save()
        return user

########NEW FILE########
__FILENAME__ = loggers
import logging
from models import Log


class SQLHandler(logging.Handler):

    def emit(self, record):
        Log.objects.create(
            message=record.getMessage(), level=record.levelname,
            logger=record.name
        )

########NEW FILE########
__FILENAME__ = cleanlogs
#!/usr/bin/env python
# coding: utf-8
import datetime
from optparse import make_option
from django.core.management.base import BaseCommand
from django.utils import timezone
from modoboa.core import load_core_settings
from modoboa.core.models import Log
from modoboa.lib import parameters


class Command(BaseCommand):
    args = ''
    help = 'Log table cleanup'

    option_list = BaseCommand.option_list + (
        make_option('--debug',
                    action='store_true',
                    default=False,
                    help='Activate debug output'),
        make_option('--verbose',
                    action='store_true',
                    default=False,
                    help='Display informational messages')
    )

    def __vprint(self, msg):
        if not self.verbose:
            return
        print msg

    def handle(self, *args, **options):
        if options["debug"]:
            import logging
            l = logging.getLogger("django.db.backends")
            l.setLevel(logging.DEBUG)
            l.addHandler(logging.StreamHandler())
        self.verbose = options["verbose"]

        load_core_settings()
        log_maximum_age = int(parameters.get_admin("LOG_MAXIMUM_AGE"))
        self.__vprint("Deleting logs older than %d days..." % log_maximum_age)
        limit = timezone.now() - datetime.timedelta(log_maximum_age)
        Log.objects.filter(date_created__lt=limit).delete()
        self.__vprint("Done.")

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'User'
        db.create_table(u'core_user', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('password', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('last_login', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
            ('is_superuser', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('username', self.gf('django.db.models.fields.CharField')(unique=True, max_length=254)),
            ('first_name', self.gf('django.db.models.fields.CharField')(max_length=30, blank=True)),
            ('last_name', self.gf('django.db.models.fields.CharField')(max_length=30, blank=True)),
            ('email', self.gf('django.db.models.fields.EmailField')(max_length=254, blank=True)),
            ('is_staff', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('is_active', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('date_joined', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
            ('is_local', self.gf('django.db.models.fields.BooleanField')(default=True)),
        ))
        db.send_create_signal(u'core', ['User'])

        # Adding M2M table for field groups on 'User'
        db.create_table(u'core_user_groups', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('user', models.ForeignKey(orm[u'core.user'], null=False)),
            ('group', models.ForeignKey(orm[u'auth.group'], null=False))
        ))
        db.create_unique(u'core_user_groups', ['user_id', 'group_id'])

        # Adding M2M table for field user_permissions on 'User'
        db.create_table(u'core_user_user_permissions', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('user', models.ForeignKey(orm[u'core.user'], null=False)),
            ('permission', models.ForeignKey(orm[u'auth.permission'], null=False))
        ))
        db.create_unique(u'core_user_user_permissions', ['user_id', 'permission_id'])

        # Adding model 'ObjectAccess'
        db.create_table(u'core_objectaccess', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.User'])),
            ('content_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'])),
            ('object_id', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('is_owner', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal(u'core', ['ObjectAccess'])

        # Adding unique constraint on 'ObjectAccess', fields ['user', 'content_type', 'object_id']
        db.create_unique(u'core_objectaccess', ['user_id', 'content_type_id', 'object_id'])

        # Adding model 'Extension'
        db.create_table(u'core_extension', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=150)),
            ('enabled', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal(u'core', ['Extension'])

        # Adding model 'Log'
        db.create_table(u'core_log', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('date_created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('message', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('level', self.gf('django.db.models.fields.CharField')(max_length=15)),
            ('logger', self.gf('django.db.models.fields.CharField')(max_length=30)),
        ))
        db.send_create_signal(u'core', ['Log'])


    def backwards(self, orm):
        # Removing unique constraint on 'ObjectAccess', fields ['user', 'content_type', 'object_id']
        db.delete_unique(u'core_objectaccess', ['user_id', 'content_type_id', 'object_id'])

        # Deleting model 'User'
        db.delete_table(u'core_user')

        # Removing M2M table for field groups on 'User'
        db.delete_table('core_user_groups')

        # Removing M2M table for field user_permissions on 'User'
        db.delete_table('core_user_user_permissions')

        # Deleting model 'ObjectAccess'
        db.delete_table(u'core_objectaccess')

        # Deleting model 'Extension'
        db.delete_table(u'core_extension')

        # Deleting model 'Log'
        db.delete_table(u'core_log')


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'core.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'core.log': {
            'Meta': {'object_name': 'Log'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.CharField', [], {'max_length': '15'}),
            'logger': ('django.db.models.fields.CharField', [], {'max_length': '30'}),
            'message': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        u'core.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['core.User']"})
        },
        u'core.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_local': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        }
    }

    complete_apps = ['core']
########NEW FILE########
__FILENAME__ = 0002_update_permissions
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):
    depends_on = (
        ('admin', '0037_rename_tables'),
    )

    def forwards(self, orm):
        "Write your forwards methods here."
        orm['contenttypes.ContentType'].objects.filter(
            app_label='admin', model__in=['user', 'extension', 'objectaccess']
        ).update(app_label='core')

    def backwards(self, orm):
        "Write your backwards methods here."
        orm['contenttypes.ContentType'].objects.filter(
            app_label='core', model__in=['user', 'extension', 'objectaccess']
        ).update(app_label='admin')

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'core.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'core.log': {
            'Meta': {'object_name': 'Log'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.CharField', [], {'max_length': '15'}),
            'logger': ('django.db.models.fields.CharField', [], {'max_length': '30'}),
            'message': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        u'core.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['core.User']"})
        },
        u'core.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_local': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'reversion.revision': {
            'Meta': {'object_name': 'Revision'},
            'comment': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'manager_slug': ('django.db.models.fields.CharField', [], {'default': "u'default'", 'max_length': '200', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['core.User']", 'null': 'True', 'blank': 'True'})
        },
        u'reversion.version': {
            'Meta': {'object_name': 'Version'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            'format': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.TextField', [], {}),
            'object_id_int': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'object_repr': ('django.db.models.fields.TextField', [], {}),
            'revision': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['reversion.Revision']"}),
            'serialized_data': ('django.db.models.fields.TextField', [], {}),
            'type': ('django.db.models.fields.PositiveSmallIntegerField', [], {'db_index': 'True'})
        }
    }

    complete_apps = ['reversion', 'core']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0003_update_md5crypt_passwords
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models


class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        for user in orm['core.User'].objects.all():
            if user.password.startswith('$1$'):
                user.password = '{MD5-CRYPT}%s' % user.password
                user.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        for user in orm['core.User'].objects.all():
            if user.password.startswith('{MD5-CRYPT}'):
                user.password = user.password.replace('{MD5-CRYPT}', '')
                user.save()

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'core.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'core.log': {
            'Meta': {'object_name': 'Log'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.CharField', [], {'max_length': '15'}),
            'logger': ('django.db.models.fields.CharField', [], {'max_length': '30'}),
            'message': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        u'core.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['core.User']"})
        },
        u'core.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_local': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        }
    }

    complete_apps = ['core']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0004_auto__chg_field_user_password
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'User.password'
        db.alter_column(u'core_user', 'password', self.gf('django.db.models.fields.CharField')(max_length=256))

    def backwards(self, orm):

        # Changing field 'User.password'
        db.alter_column(u'core_user', 'password', self.gf('django.db.models.fields.CharField')(max_length=128))

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'core.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'core.log': {
            'Meta': {'object_name': 'Log'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.CharField', [], {'max_length': '15'}),
            'logger': ('django.db.models.fields.CharField', [], {'max_length': '30'}),
            'message': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        u'core.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['core.User']"})
        },
        u'core.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_local': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        }
    }

    complete_apps = ['core']
########NEW FILE########
__FILENAME__ = models
import sys
import os
import re
import logging
import reversion
from django.db import models
from django.db.models.signals import post_delete
from django.conf import settings
from django.dispatch import receiver
from django.utils import timezone
from django.utils.translation import ugettext as _, ugettext_lazy
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes import generic
from django.contrib.auth.models import (
    UserManager, Group, PermissionsMixin
)
from django.contrib.auth.hashers import make_password, is_password_usable
from modoboa.lib import events, parameters
from modoboa.lib.exceptions import (
    PermDeniedException, InternalError, BadRequest, Conflict
)
from modoboa.lib.sysutils import exec_cmd
from modoboa.core.extensions import exts_pool
from modoboa.core.password_hashers import get_password_hasher

try:
    from modoboa.lib.ldaputils import LDAPAuthBackend
    ldap_available = True
except ImportError:
    ldap_available = False


class User(PermissionsMixin):
    """Custom User model.

    It overloads the way passwords are stored into the database. The
    main reason to change this mechanism is to ensure the
    compatibility with the way Dovecot stores passwords.

    It also adds new attributes and methods.
    """
    username = models.CharField(max_length=254, unique=True)
    first_name = models.CharField(max_length=30, blank=True)
    last_name = models.CharField(max_length=30, blank=True)
    email = models.EmailField(max_length=254, blank=True)
    is_staff = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    date_joined = models.DateTimeField(default=timezone.now)
    is_local = models.BooleanField(default=True)
    password = models.CharField(ugettext_lazy('password'), max_length=256)
    last_login = models.DateTimeField(
        ugettext_lazy('last login'), default=timezone.now
    )

    objects = UserManager()

    USERNAME_FIELD = 'username'
    REQUIRED_FIELDS = ['email']

    class Meta:
        ordering = ["username"]

    password_expr = re.compile(r'\{([\w\-]+)\}(.+)')

    def delete(self, fromuser, *args, **kwargs):
        """Custom delete method

        To check permissions properly, we need to make a distinction
        between 2 cases:

        * If the user owns a mailbox, the check is made on that object
          (useful for domain admins)

        * Otherwise, the check is made on the user
        """
        from modoboa.lib.permissions import \
            get_object_owner, grant_access_to_object, ungrant_access_to_object

        if fromuser == self:
            raise PermDeniedException(
                _("You can't delete your own account")
            )

        if not fromuser.can_access(self):
            raise PermDeniedException

        owner = get_object_owner(self)
        for ooentry in self.objectaccess_set.filter(is_owner=True):
            if ooentry.content_object is not None:
                grant_access_to_object(owner, ooentry.content_object, True)

        events.raiseEvent("AccountDeleted", self, fromuser, **kwargs)
        ungrant_access_to_object(self)
        super(User, self).delete()

    def _crypt_password(self, raw_value):
        scheme = parameters.get_admin("PASSWORD_SCHEME")
        if type(raw_value) is unicode:
            raw_value = raw_value.encode("utf-8")
        return get_password_hasher(scheme.upper())().encrypt(raw_value)

    def set_password(self, raw_value, curvalue=None):
        """Password update

        Update the current mailbox's password with the given clear
        value. This value is encrypted according to the defined method
        before it is saved.

        :param raw_value: the new password's value
        :param curvalue: the current password (for LDAP authentication)
        """
        if self.is_local:
            self.password = self._crypt_password(raw_value)
        else:
            if not ldap_available:
                raise InternalError(
                    _("Failed to update password: LDAP module not installed")
                )
            LDAPAuthBackend().update_user_password(
                self.username, curvalue, raw_value
            )
        events.raiseEvent(
            "PasswordUpdated", self, raw_value, self.pk is None
        )

    def check_password(self, raw_value):
        match = self.password_expr.match(self.password)
        if match is None:
            return False
        if type(raw_value) is unicode:
            raw_value = raw_value.encode("utf-8")
        scheme = match.group(1)
        val2 = match.group(2)
        hasher = get_password_hasher(scheme)
        return hasher().verify(raw_value, val2)

    def get_username(self):
        "Return the identifying username for this User"
        return getattr(self, self.USERNAME_FIELD)

    def __str__(self):
        return self.get_username()

    def natural_key(self):
        return (self.get_username(),)

    def is_anonymous(self):
        """
        Always returns False. This is a way of comparing User objects to
        anonymous users.
        """
        return False

    def is_authenticated(self):
        """
        Always return True. This is a way to tell if the user has been
        authenticated in templates.
        """
        return True

    def set_unusable_password(self):
        # Sets a value that will never be a valid hash
        self.password = make_password(None)

    def has_usable_password(self):
        return is_password_usable(self.password)

    @property
    def tags(self):
        return [{"name": "account", "label": _("account"), "type": "idt"},
                {"name": self.group, "label": self.group,
                 "type": "grp", "color": "info"}]

    @property
    def fullname(self):
        if self.first_name != u"":
            return u"%s %s" % (self.first_name, self.last_name)
        return self.username

    @property
    def identity(self):
        return self.username

    @property
    def name_or_rcpt(self):
        if self.first_name != "":
            return "%s %s" % (self.first_name, self.last_name)
        return "----"

    @property
    def group(self):
        if self.is_superuser:
            return "SuperAdmins"
        try:
            return self.groups.all()[0].name
        except IndexError:
            return "---"

    @property
    def enabled(self):
        return self.is_active

    @property
    def encoded_address(self):
        from email.header import Header
        if self.first_name != "" or self.last_name != "":
            return "%s <%s>" % \
                (Header(self.fullname, 'utf8').encode(), self.email)
        return self.email

    def belongs_to_group(self, name):
        """Simple shortcut to check if this user is a member of a
        specific group.

        :param name: the group's name
        :return: a boolean
        """
        try:
            self.groups.get(name=name)
        except Group.DoesNotExist:
            return False
        return True

    def is_owner(self, obj):
        """Tell is the user is the unique owner of this object

        :param obj: an object inheriting from ``models.Model``
        :return: a boolean
        """
        ct = ContentType.objects.get_for_model(obj)
        try:
            ooentry = self.objectaccess_set.get(content_type=ct, object_id=obj.id)
        except ObjectAccess.DoesNotExist:
            return False
        return ooentry.is_owner

    def can_access(self, obj):
        """Check if the user can access a specific object

        This function is recursive: if the given user hasn't got
        direct access to this object and if he has got access to other
        ``User`` objects, we check if one of those users owns the
        object.

        :param obj: a admin object
        :return: a boolean
        """
        if self.is_superuser:
            return True

        ct = ContentType.objects.get_for_model(obj)
        try:
            ooentry = self.objectaccess_set.get(content_type=ct, object_id=obj.id)
        except ObjectAccess.DoesNotExist:
            pass
        else:
            return True
        if ct.model == "user":
            return False

        ct = ContentType.objects.get_for_model(self)
        qs = self.objectaccess_set.filter(content_type=ct)
        for ooentry in qs.all():
            if ooentry.content_object.is_owner(obj):
                return True
        return False

    def set_role(self, role):
        """Set administrative role for this account

        :param string role: the role to set
        """
        if role is None or self.group == role:
            return
        events.raiseEvent("RoleChanged", self, role)
        self.groups.clear()
        if role == "SuperAdmins":
            self.is_superuser = True
        else:
            if self.is_superuser:
                ObjectAccess.objects.filter(user=self).delete()
            self.is_superuser = False
            try:
                self.groups.add(Group.objects.get(name=role))
            except Group.DoesNotExist:
                self.groups.add(Group.objects.get(name="SimpleUsers"))
            if self.group != "SimpleUsers" and not self.can_access(self):
                from modoboa.lib.permissions import grant_access_to_object
                grant_access_to_object(self, self)
        self.save()

    def post_create(self, creator):
        from modoboa.lib.permissions import grant_access_to_object
        grant_access_to_object(creator, self, is_owner=True)
        events.raiseEvent("AccountCreated", self)

    def save(self, *args, **kwargs):
        if "creator" in kwargs:
            creator = kwargs["creator"]
            del kwargs["creator"]
        else:
            creator = None
        super(User, self).save(*args, **kwargs)
        if creator is not None:
            self.post_create(creator)

    def from_csv(self, user, row, crypt_password=True):
        """Create a new account from a CSV file entry.

        The expected order is the following::

        "account", loginname, password, first name, last name, enabled, group

        Additional fields can be added using the *AccountImported* event.

        :param user: a ``core.User`` instance
        :param row: a list containing the expected information
        :param crypt_password:
        """
        if len(row) < 7:
            raise BadRequest(_("Invalid line"))
        role = row[6].strip()
        if not user.is_superuser and not role in ["SimpleUsers", "DomainAdmins"]:
            raise PermDeniedException(
                _("You can't import an account with a role greater than yours")
            )
        self.username = row[1].strip()
        try:
            User.objects.get(username=self.username)
        except User.DoesNotExist:
            pass
        else:
            raise Conflict
        if role == "SimpleUsers":
            if (len(row) < 8 or not row[7].strip()):
                raise BadRequest(
                    _("The simple user '%s' must have a valid email address" % self.username)
                )
            if self.username != row[7].strip():
                raise BadRequest(
                    _("username and email fields must not differ for '%s'" % self.username)
                )

        if crypt_password:
            self.set_password(row[2].strip())
        else:
            self.password = row[2].strip()
        self.first_name = row[3].strip()
        self.last_name = row[4].strip()
        self.is_active = (row[5].strip() == 'True')
        self.save(creator=user)
        self.set_role(role)
        if len(row) < 8:
            return
        events.raiseEvent("AccountImported", user, self, row[7:])

    def to_csv(self, csvwriter):
        """Export this account.

        The CSV format is used to export.

        :param csvwriter: csv object
        """
        row = ["account", self.username.encode("utf-8"), self.password.encode("utf-8"),
               self.first_name.encode("utf-8"), self.last_name.encode("utf-8"),
               self.is_active, self.group, self.email.encode("utf-8")]
        row += events.raiseQueryEvent("AccountExported", self)
        csvwriter.writerow(row)

reversion.register(User)


def populate_callback(user, group='SimpleUsers'):
    """Populate callback

    If the LDAP authentication backend is in use, this callback will
    be called each time a new user authenticates succesfuly to
    Modoboa. This function is in charge of creating the mailbox
    associated to the provided ``User`` object.

    :param user: a ``User`` instance
    """
    from modoboa.lib.permissions import grant_access_to_object

    sadmins = User.objects.filter(is_superuser=True)
    user.set_role(group)
    user.post_create(sadmins[0])
    for su in sadmins[1:]:
        grant_access_to_object(su, user)
    events.raiseEvent("AccountAutoCreated", user)


class ObjectAccess(models.Model):
    user = models.ForeignKey(User)
    content_type = models.ForeignKey(ContentType)
    object_id = models.PositiveIntegerField()
    content_object = generic.GenericForeignKey('content_type', 'object_id')
    is_owner = models.BooleanField(default=False)

    class Meta:
        unique_together = (("user", "content_type", "object_id"),)

    def __unicode__(self):
        return "%s => %s (%s)" % (self.user, self.content_object, self.content_type)


class Extension(models.Model):
    name = models.CharField(max_length=150)
    enabled = models.BooleanField(
        ugettext_lazy('enabled'),
        help_text=ugettext_lazy("Check to enable this extension")
    )

    def __init__(self, *args, **kwargs):
        super(Extension, self).__init__(*args, **kwargs)

    def __unicode__(self):
        return self.name

    def __get_ext_instance(self):
        if not self.name:
            return None
        if hasattr(self, "instance") and self.instance:
            return
        self.instance = exts_pool.get_extension(self.name)
        if self.instance:
            self.__get_ext_dir()

    def __get_ext_dir(self):
        modname = self.instance.__module__
        path = os.path.realpath(sys.modules[modname].__file__)
        self.extdir = os.path.dirname(path)

    def on(self):
        self.enabled = True
        self.save()

        self.__get_ext_instance()
        self.instance.load()
        self.instance.init()

        if self.instance.needs_media:
            path = os.path.join(settings.MEDIA_ROOT, self.name)
            exec_cmd("mkdir %s" % path)

        events.raiseEvent("ExtEnabled", self)

    def off(self):
        self.__get_ext_instance()
        if self.instance is None:
            return
        self.instance.destroy()

        self.enabled = False
        self.save()

        if self.instance.needs_media:
            path = os.path.join(settings.MEDIA_ROOT, self.name)
            exec_cmd("rm -r %s" % path)

        events.raiseEvent("ExtDisabled", self)

reversion.register(Extension)


class Log(models.Model):
    date_created = models.DateTimeField(auto_now_add=True)
    message = models.CharField(max_length=255)
    level = models.CharField(max_length=15)
    logger = models.CharField(max_length=30)


@receiver(reversion.post_revision_commit)
def post_revision_commit(sender, **kwargs):
    """Custom post-revision hook.

    We want to track all creations and modifications of admin. objects
    (alias, mailbox, user, domain, domain alias, etc.) so we use
    django-reversion for that.

    """
    from modoboa.lib.signals import get_request

    current_user = get_request().user.username 
    logger = logging.getLogger("modoboa.admin")
    for version in kwargs["versions"]:
        if version.object is None:
            continue
        prev_revisions = reversion.get_for_object(version.object)
        if prev_revisions.count() == 1:
            action = _("added")
            level = "info"
        else:
            action = _("modified")
            level = "warning"
        message = _("%(object)s '%(name)s' %(action)s by user %(user)s") % {
            "object": unicode(version.content_type).capitalize(),
            "name": version.object_repr, "action": action,
            "user": current_user
        }
        getattr(logger, level)(message)


@receiver(post_delete)
def log_object_removal(sender, instance, **kwargs):
    """Custom post-delete hook.

    We want to know who was responsible for an object deletion.
    """
    from reversion.models import Version
    from modoboa.lib.signals import get_request

    if not reversion.is_registered(sender):
        return
    del_list = reversion.get_deleted(sender)
    try:
        version = del_list.get(object_id=instance.id)
    except Version.DoesNotExist:
        return
    logger = logging.getLogger("modoboa.admin")
    msg = _("%(object)s '%(name)s' %(action)s by user %(user)s") % {
        "object": unicode(version.content_type).capitalize(),
        "name": version.object_repr, "action": _("deleted"),
        "user": get_request().user.username
    }
    logger.critical(msg)

########NEW FILE########
__FILENAME__ = advanced
"""
Advanced (ie. stronger) password hashers.

This module relies on `passlib` to provide more secure hashers.
"""
from passlib.hash import md5_crypt, sha256_crypt, sha512_crypt
from modoboa.core.password_hashers.base import PasswordHasher
from modoboa.lib import parameters


class MD5CRYPTHasher(PasswordHasher):
    """
    MD5-CRYPT password hasher.

    This scheme can't be considered as secure anymore.
    """
    @property
    def scheme(self):
        return '{MD5-CRYPT}' if self._target == 'local' else '{CRYPT}'

    def _b64encode(self, pwhash):
        return pwhash

    def _encrypt(self, clearvalue, salt=None):
        return md5_crypt.encrypt(clearvalue)

    def verify(self, clearvalue, hashed_value):
        return md5_crypt.verify(clearvalue, hashed_value)


class SHA256CRYPTHasher(PasswordHasher):
    """
    SHA256-CRYPT password hasher.

    Supports rounds and is a good compromise between security and
    performance.
    """
    @property
    def scheme(self):
        return '{SHA256-CRYPT}' if self._target == 'local' else '{CRYPT}'

    def _b64encode(self, pwhash):
        return pwhash

    def _encrypt(self, clearvalue, salt=None):
        rounds = int(parameters.get_admin('ROUNDS_NUMBER'))
        return sha256_crypt.encrypt(clearvalue, rounds=rounds)

    def verify(self, clearvalue, hashed_value):
        return sha256_crypt.verify(clearvalue, hashed_value)


class SHA512CRYPTHasher(PasswordHasher):
    """
    SHA512-CRYPT password hasher.

    Supports rounds and is the strongest scheme provided by
    Modoboa. Requires more resource than SHA256-CRYPT.
    """
    @property
    def scheme(self):
        return '{SHA512-CRYPT}' if self._target == 'local' else '{CRYPT}'

    def _b64encode(self, pwhash):
        return pwhash

    def _encrypt(self, clearvalue, salt=None):
        rounds = int(parameters.get_admin('ROUNDS_NUMBER'))
        return sha512_crypt.encrypt(clearvalue, rounds=rounds)

    def verify(self, clearvalue, hashed_value):
        return sha512_crypt.verify(clearvalue, hashed_value)

########NEW FILE########
__FILENAME__ = base
"""
Base password hashers.

Contains weak hashers (the original ones) available with Modoboa.
"""
import crypt
import hashlib
import base64
import string
from random import Random
from django.utils.crypto import constant_time_compare


class PasswordHasher(object):
    """
    Base class of all hashers.
    """
    def __init__(self, target='local'):
        self._target = target

    def _encrypt(self, clearvalue, salt=None):
        raise NotImplementedError

    def _b64encode(self, pwhash):
        """Encode :keyword:`pwhash` using base64 if needed.

        :param str pwhash: password hash
        :return: base64 encoded hash or original hash
        """
        if self._target == 'ldap':
            return base64.b64encode(pwhash)
        return pwhash

    def encrypt(self, clearvalue):
        """Encrypt a password.

        The format used to store passwords is the same than dovecot's one::

          {SCHEME}<hash>

        <hash> may differ according to the used scheme.

        :param str clearvalue: clear password
        :rtype: str
        :return: encrypted password
        """
        pwhash = self._b64encode(self._encrypt(clearvalue))
        return '%s%s' % (self.scheme, pwhash)

    def verify(self, clearvalue, hashed_value):
        """Verify a password against a hashed value.

        :param str clearvalue: clear password
        :param str hashed_value: password previously hashed
        :return: True if passwords match, False otherwise
        """
        return constant_time_compare(
            self._b64encode(self._encrypt(clearvalue, hashed_value)),
            hashed_value
        )


class PLAINHasher(PasswordHasher):
    """
    Plain (ie. clear) password hasher.
    """
    @property
    def scheme(self):
        return '{PLAIN}'

    def _encrypt(self, clearvalue, salt=None):
        return clearvalue


class CRYPTHasher(PasswordHasher):
    """
    crypt password hasher.

    Uses python `crypt` standard module.
    """
    @property
    def scheme(self):
        return '{CRYPT}'

    def _encrypt(self, clearvalue, salt=None):
        if salt is None:
            salt = "".join(Random().sample(string.letters + string.digits, 2))
        return crypt.crypt(clearvalue, salt)


class MD5Hasher(PasswordHasher):
    """
    MD5 password hasher.

    Uses python `hashlib` standard module.
    """
    @property
    def scheme(self):
        return '{MD5}'

    def _encrypt(self, clearvalue, salt=None):
        obj = hashlib.md5(clearvalue)
        return obj.hexdigest()


class SHA256Hasher(PasswordHasher):
    """
    SHA256 password hasher.

    Uses python `hashlib` and `base64` standard modules.
    """
    @property
    def scheme(self):
        return '{SHA256}'

    def _encrypt(self, clearvalue, salt=None):
        return hashlib.sha256(clearvalue).digest()

    def _b64encode(self, pwhash):
        """Encode :keyword:`pwhash` using base64.

        :param str pwhash: password hash
        :return: base64 encoded hash
        """
        return base64.b64encode(pwhash)

########NEW FILE########
__FILENAME__ = tables
from django.utils.translation import ugettext_lazy
from modoboa.lib import tables


class ExtensionsTable(tables.Table):
    idkey = "id"
    selection = tables.SelectionColumn("selection", width="4%", header=False)
    label = tables.Column("label", label=ugettext_lazy("Name"), width="15%")
    version = tables.Column(
        "version", label=ugettext_lazy("Version"), width="6%"
    )
    descr = tables.Column("description", label=ugettext_lazy("Description"))

    cols_order = ["selection", "label", "version", "descr"]

########NEW FILE########
__FILENAME__ = core_tags
import re
from django import template
from django.template.loader import render_to_string
from django.utils import timezone
from django.utils.translation import ugettext as _
from django.core.urlresolvers import reverse
from django.contrib.sessions.models import Session
from modoboa.lib import events


register = template.Library()


@register.simple_tag
def core_menu(selection, user):
    entries = \
        events.raiseQueryEvent("AdminMenuDisplay", "top_menu", user)
    if user.is_superuser:
        entries += [
            {"name": "settings",
             "label": _("Modoboa"),
             "url": reverse("modoboa.core.views.admin.viewsettings")}
        ]

    if not len(entries):
        return ""
    return render_to_string("common/menulist.html", {
        "entries": entries,
        "selection": selection,
        "user": user}
    )


@register.simple_tag
def extensions_menu(selection, user):
    menu = events.raiseQueryEvent("UserMenuDisplay", "top_menu", user)
    return render_to_string('common/menulist.html', {
        "selection": selection, "entries": menu, "user": user
    })


@register.simple_tag
def admin_menu(selection, user):
    entries = [
        {"name": "extensions",
         "class": "ajaxlink",
         "url": "extensions/",
         "label": _("Extensions"),
         "img": ""},
        {"name": "info",
         "class": "ajaxlink",
         "url": "info/",
         "label": _("Information")},
        {"name": "logs",
         "class": "ajaxlink",
         "url": "logs/?sort_order=-date_created",
         "label": _("Logs")},
        {"name": "parameters",
         "class": "ajaxlink",
         "url": "parameters/",
         "img": "",
         "label": _("Parameters")},
    ]
    return render_to_string('common/menu.html', {
        "entries": entries,
        "css": "nav nav-list",
        "selection": selection,
        "user": user
    })


@register.simple_tag
def user_menu(user, selection):
    entries = [
        {"name": "user",
         "img": "icon-user icon-white",
         "label": user.fullname,
         "menu": [
                {"name": "settings",
                 "img": "icon-list",
                 "label": _("Settings"),
                 "url": reverse("modoboa.core.views.user.index")}
         ]}
    ]

    entries[0]["menu"] += \
        events.raiseQueryEvent("UserMenuDisplay", "options_menu", user) \
        + [{"name": "logout",
            "url": reverse("modoboa.core.views.auth.dologout"),
            "label": _("Logout"),
            "img": "icon-off"}]

    return render_to_string("common/menulist.html", {
        "selection": selection, "entries": entries, "user": user
    })


@register.simple_tag
def uprefs_menu(selection, user):
    entries = [
        {"name": "profile",
         "class": "ajaxlink",
         "url": "profile/",
         "label": _("Profile")},
        {"name": "preferences",
         "class": "ajaxlink",
         "url": "preferences/",
         "label": _("Preferences")},
    ]
    entries += events.raiseQueryEvent("UserMenuDisplay", "uprefs_menu", user)
    entries = sorted(entries, key=lambda e: e["label"])
    return render_to_string('common/menu.html', {
        "entries": entries,
        "css": "nav nav-list",
        "selection": selection,
        "user": user
    })


@register.filter
def colorize_level(level):
    classes = {
        "INFO": "text-info",
        "WARNING": "text-warning",
        "CRITICAL": "text-error"
    }
    if not level in classes:
        return level
    return "<p class='%s'>%s</p>" % (classes[level], level)


@register.filter
def tohtml(message):
    return re.sub("'(.*?)'", "<strong>\g<1></strong>", message)


@register.simple_tag
def visirule(field):
    if not hasattr(field, 'form') or \
            not hasattr(field.form, "visirules") or \
            not field.html_name in field.form.visirules:
        return ""
    rule = field.form.visirules[field.html_name]
    return " data-visibility-field='%s' data-visibility-value='%s' " \
        % (rule["field"], rule["value"])


@register.simple_tag
def get_version():
    import pkg_resources
    return pkg_resources.get_distribution("modoboa").version


class ConnectedUsers(template.Node):
    def __init__(self, varname):
        self.varname = varname

    def render(self, context):
        from modoboa.core.models import User

        sessions = Session.objects.filter(expire_date__gte=timezone.now())
        uid_list = []
        # Build a list of user ids from that query
        for session in sessions:
            data = session.get_decoded()
            uid = data.get('_auth_user_id', None)
            if uid:
                uid_list.append(uid)

        # Query all logged in users based on id list
        context[self.varname] = []
        for uid in uid_list:
            try:
                context[self.varname].append(User.objects.get(pk=uid))
            except User.DoesNotExist:
                pass
        return ''


@register.tag
def connected_users(parser, token):
    try:
        tag, a, varname = token.split_contents()
    except ValueError:
        raise template.TemplateSyntaxError(
            'connected_users usage: {% connected_users as users %}'
        )
    return ConnectedUsers(varname)


@register.simple_tag
def get_modoboa_logo():
    import os
    from django.conf import settings

    try:
        logo = settings.MODOBOA_CUSTOM_LOGO
    except AttributeError:
        logo = None
    if logo is None:
        return os.path.join(settings.STATIC_URL, "css/modoboa.png")
    return logo


@register.simple_tag
def load_optionalmenu(user):
    menu = events.raiseQueryEvent("UserMenuDisplay", "top_menu_middle", user)
    return template.loader.render_to_string(
        'common/menulist.html',
        {"entries": menu, "user": user}
    )


@register.simple_tag
def load_notifications(user):
    content = events.raiseQueryEvent("TopNotifications", user)
    return "".join(content)


@register.simple_tag
def display_messages(msgs):
    text = ""
    level = "info"
    for m in msgs:
        level = m.tags
        text += unicode(m) + "\\\n"

    if level == "info":
        level = "success"
        timeout = "2000"
    else:
        timeout = "undefined"

    return """
<script type="text/javascript">
    $(document).ready(function() {
        $('body').notify('%s', '%s', %s);
    });
</script>
""" % (level, text, timeout)

########NEW FILE########
__FILENAME__ = tests
from django.core.urlresolvers import reverse
from modoboa.lib.tests import ModoTestCase
from . import factories


class ProfileTestCase(ModoTestCase):
    fixtures = ['initial_users.json']

    def setUp(self):
        super(ProfileTestCase, self).setUp()
        self.account = factories.UserFactory(
            username="user@test.com", groups=('SimpleUsers',)
        )

    def test_update_password(self):
        """Password update

        Two cases:
        * The default admin changes his password (no associated Mailbox)
        * A normal user changes his password
        """
        self.ajax_post(reverse("modoboa.core.views.user.profile"),
                       {"oldpassword": "password",
                        "newpassword": "titi", "confirmation": "titi"})
        self.clt.logout()

        self.assertEqual(
            self.clt.login(username="admin", password="titi"), True
        )
        self.assertEqual(
            self.clt.login(username="user@test.com", password="toto"), True
        )

        self.ajax_post(
            reverse("modoboa.core.views.user.profile"),
            {"oldpassword": "toto",
             "newpassword": "tutu", "confirmation": "tutu"}
        )
        self.clt.logout()
        self.assertTrue(
            self.clt.login(username="user@test.com", password="tutu")
        )

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns


urlpatterns = patterns(
    '',

    (r'^accounts/login/$', 'modoboa.core.views.auth.dologin'),
    (r'^accounts/logout/$', 'modoboa.core.views.auth.dologout'),

    (r'^core/$', 'modoboa.core.views.admin.viewsettings'),
    (r'^core/parameters/$', 'modoboa.core.views.admin.viewparameters'),
    (r'^core/parameters/save/$', 'modoboa.core.views.admin.saveparameters'),
    (r'^core/extensions/$', 'modoboa.core.views.admin.viewextensions'),
    (r'^core/extensions/save/$', 'modoboa.core.views.admin.saveextensions'),
    (r'^core/info/$', 'modoboa.core.views.admin.information'),
    (r'^core/logs/$', 'modoboa.core.views.admin.logs'),

    (r'^user/$', 'modoboa.core.views.user.index'),
    (r'^user/preferences/$', 'modoboa.core.views.user.preferences'),
    (r'^user/profile/$', 'modoboa.core.views.user.profile'),
)

########NEW FILE########
__FILENAME__ = admin
from django.shortcuts import render
from django.template.loader import render_to_string
from django.utils.translation import ugettext as _
from django.contrib.auth.decorators import (
    login_required, user_passes_test
)
from modoboa.lib import parameters
from modoboa.lib.webutils import (
    _render_to_string, render_to_json_response
)
from modoboa.lib.listing import get_sort_order, get_listing_page
from modoboa.core.models import Extension, Log
from modoboa.core.tables import ExtensionsTable


@login_required
@user_passes_test(lambda u: u.is_superuser)
def viewsettings(request, tplname='core/settings_header.html'):
    return render(request, tplname, {
        "selection": "settings"
    })


@login_required
@user_passes_test(lambda u: u.is_superuser)
def viewparameters(request, tplname='core/parameters.html'):
    return render_to_json_response({
        "left_selection": "parameters",
        "content": _render_to_string(request, tplname, {
            "forms": parameters.get_admin_forms
        })
    })


@login_required
@user_passes_test(lambda u: u.is_superuser)
def saveparameters(request):
    for formdef in parameters.get_admin_forms(request.POST):
        form = formdef["form"]
        if form.is_valid():
            form.save()
            form.to_django_settings()
            continue
        return render_to_json_response(
            {'form_errors': form.errors, 'prefix': form.app}, status=400
        )
    return render_to_json_response(_("Parameters saved"))


@login_required
@user_passes_test(lambda u: u.is_superuser)
def viewextensions(request, tplname='core/extensions.html'):
    from modoboa.core.extensions import exts_pool

    exts = exts_pool.list_all()
    for ext in exts:
        try:
            dbext = Extension.objects.get(name=ext["id"])
            ext["selection"] = dbext.enabled
        except Extension.DoesNotExist:
            dbext = Extension()
            dbext.name = ext["id"]
            dbext.enabled = False
            dbext.save()
            ext["selection"] = False

    tbl = ExtensionsTable(request, exts)
    return render_to_json_response({
        "content": _render_to_string(request, tplname, {"extensions": tbl})
    })


@login_required
@user_passes_test(lambda u: u.is_superuser)
def saveextensions(request):
    actived_exts = Extension.objects.filter(enabled=True)
    found = []
    for k in request.POST.keys():
        if k.startswith("select_"):
            parts = k.split("_", 1)
            dbext = Extension.objects.get(name=parts[1])
            if not dbext in actived_exts:
                dbext.on()
            else:
                found += [dbext]
    for ext in actived_exts:
        if not ext in found:
            ext.off()

    return render_to_json_response(_("Modifications applied."))


@login_required
@user_passes_test(lambda u: u.is_superuser)
def information(request, tplname="core/information.html"):
    return render_to_json_response({
        "content": render_to_string(tplname, {})
    })


@login_required
@user_passes_test(lambda u: u.is_superuser)
def logs(request, tplname="core/logs.html"):
    from modoboa.lib.templatetags.lib_tags import pagination_bar

    sort_order, sort_dir = get_sort_order(
        request.GET, "date_created",
        allowed_values=['date_created', 'level', 'logger', 'message']
    )
    page = get_listing_page(
        Log.objects.all().order_by("%s%s" % (sort_dir, sort_order)),
        request.GET.get("page", 1)
    )
    return render_to_json_response({
        "content": render_to_string(tplname, {
            "logs": page.object_list,
        }),
        "page": page.number,
        "paginbar": pagination_bar(page),
    })

########NEW FILE########
__FILENAME__ = auth
# coding: utf-8
import logging
from django.views.decorators.cache import never_cache
from django.contrib.auth import authenticate, login, logout
from django.http import HttpResponse, HttpResponseRedirect
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext as _
from modoboa.lib import events, parameters
from modoboa.lib.webutils import _render_to_string
from modoboa.core.forms import LoginForm


def dologin(request):
    error = None
    if request.method == "POST":
        form = LoginForm(request.POST)
        if form.is_valid():
            logger = logging.getLogger('modoboa.auth')
            user = authenticate(username=form.cleaned_data["username"],
                                password=form.cleaned_data["password"])
            if user and user.is_active:
                login(request, user)
                if not form.cleaned_data["rememberme"]:
                    request.session.set_expiry(0)

                request.session["django_language"] = \
                    parameters.get_user(request.user, "LANG")

                logger.info(
                    _("User '%s' successfully logged in" % user.username)
                )
                events.raiseEvent("UserLogin", request,
                                  form.cleaned_data["username"],
                                  form.cleaned_data["password"])

                nextlocation = request.POST.get("next", None)
                if nextlocation is None or nextlocation == "None":
                    if user.group == "SimpleUsers":
                        nextlocation = reverse("modoboa.lib.webutils.topredirection")
                    else:
                        nextlocation = reverse("domains")
                return HttpResponseRedirect(nextlocation)
            error = _("Your username and password didn't match. Please try again.")
            logger.warning("Failed connection attempt from '%(addr)s' as user '%(user)s'" \
                               % {"addr": request.META["REMOTE_ADDR"],
                                  "user": form.cleaned_data["username"]})

        nextlocation = request.POST.get("next", None)
        httpcode = 401
    else:
        form = LoginForm()
        nextlocation = request.GET.get("next", None)
        httpcode = 200

    return HttpResponse(_render_to_string(request, "registration/login.html", {
        "form": form, "error": error, "next": nextlocation,
        "annoucements": events.raiseQueryEvent("GetAnnouncement", "loginpage")
    }), status=httpcode)

dologin = never_cache(dologin)


def dologout(request):
    """Logout the current user.
    """
    if not request.user.is_anonymous():
        events.raiseEvent("UserLogout", request)
        logger = logging.getLogger("modoboa.auth")
        logger.info(_("User '%s' logged out" % request.user.username))
        logout(request)
    return HttpResponseRedirect(reverse(dologin))

########NEW FILE########
__FILENAME__ = user
from django.shortcuts import render
from django.utils.translation import ugettext as _
from django.contrib.auth.decorators import login_required
from modoboa.lib import events, parameters
from modoboa.lib.webutils import (
    _render_to_string, render_to_json_response
)
from modoboa.lib.cryptutils import encrypt
from modoboa.core.forms import ProfileForm


@login_required
def index(request, tplname="core/user_index.html"):
    extrajs = events.raiseQueryEvent("ExtraUprefsJS", request.user)
    return render(request, tplname, {
        "selection": "user",
        "extrajs": "".join(extrajs)
    })


@login_required
def profile(request, tplname='core/user_profile.html'):
    update_password = True
    if True in events.raiseQueryEvent("PasswordChange", request.user):
        update_password = False

    if request.method == "POST":
        form = ProfileForm(
            update_password, request.POST, instance=request.user
        )
        if form.is_valid():
            form.save()
            if update_password and form.cleaned_data["confirmation"] != "":
                request.session["password"] = encrypt(form.cleaned_data["confirmation"])
            return render_to_json_response(_("Profile updated"))
        return render_to_json_response({'form_errors': form.errors}, status=400)

    form = ProfileForm(update_password, instance=request.user)
    return render_to_json_response({
        "content": _render_to_string(request, tplname, {
            "form": form
        })
    })


@login_required
def preferences(request):
    if request.method == "POST":
        for formdef in parameters.get_user_forms(request.user, request.POST)():
            form = formdef["form"]
            if form.is_valid():
                form.save()
                continue
            return render_to_json_response({
                "prefix": form.app, "form_errors": form.errors
            }, status=400)

        return render_to_json_response(_("Preferences saved"))

    return render_to_json_response({
        "content": _render_to_string(request, "core/user_preferences.html", {
            "forms": parameters.get_user_forms(request.user)
        })
    })

########NEW FILE########
__FILENAME__ = urls
# coding: utf-8
from django.conf.urls import patterns

urlpatterns = patterns('modoboa.demo.views',
    (r'^sendvirus/$', 'send_virus'),
    (r'^sendspam/$', 'send_spam'),
)

########NEW FILE########
__FILENAME__ = views
# coding: utf-8
import os
from django.conf import settings
from django.contrib.auth.decorators import login_required
from django.utils.translation import ugettext as _
from modoboa.lib.webutils import render_to_json_response
from modoboa.lib.emailutils import sendmail_simple, sendmail_fromfile
from modoboa.extensions.admin.lib import needs_mailbox


@login_required
@needs_mailbox()
def send_virus(request):
    status, error = sendmail_fromfile("virus@example.net", request.user.username,
                                      os.path.join(settings.MODOBOA_DIR,
                                                   "tmp/virus.msg"))
    if status:
        return render_to_json_response(_("Message sent"))
    return render_to_json_response(error, status=500)


@login_required
@needs_mailbox()
def send_spam(request):
    status, error = sendmail_simple("spam@example.net", request.user.username, content="""
This is the GTUBE, the
        Generic
        Test for
        Unsolicited
        Bulk
        Email

If your spam filter supports it, the GTUBE provides a test by which you
can verify that the filter is installed correctly and is detecting incoming
spam. You can send yourself a test mail containing the following string of
characters (in upper case and with no white spaces and line breaks):

XJS*C4JDBQADN1.NSBN3*2IDNEN*GTUBE-STANDARD-ANTI-UBE-TEST-EMAIL*C.34X

You should send this test mail from an account outside of your network.
""")
    if status:
        return render_to_json_response(_("Message sent"))
    return render_to_json_response(respmsg=error, status=500)

########NEW FILE########
__FILENAME__ = app_settings
from django import forms
from django.conf import settings
from django.utils.translation import ugettext_lazy
from modoboa.lib.formutils import YesNoField, SeparatorField
from modoboa.lib.sysutils import exec_cmd
from modoboa.lib import parameters
import os


class AdminParametersForm(parameters.AdminParametersForm):
    app = "admin"

    mbsep = SeparatorField(label=ugettext_lazy("Mailboxes"))

    handle_mailboxes = YesNoField(
        label=ugettext_lazy("Handle mailboxes on filesystem"),
        initial="no",
        help_text=ugettext_lazy("Rename or remove mailboxes on the filesystem when they get renamed or removed within Modoboa")
    )

    mailboxes_owner = forms.CharField(
        label=ugettext_lazy("Mailboxes ower"),
        initial="vmail",
        help_text=ugettext_lazy("The UNIX account who owns mailboxes on the filesystem")
    )

    default_domain_quota = forms.IntegerField(
        label=ugettext_lazy("Default domain quota"),
        initial=0,
        help_text=ugettext_lazy(
            "Default quota (in MB) applied to freshly created domains with no "
            "value specified. A value of 0 means no quota."
        ),
        widget=forms.TextInput(attrs={'class': 'span2'})
    )

    auto_account_removal = YesNoField(
        label=ugettext_lazy("Automatic account removal"),
        initial="no",
        help_text=ugettext_lazy("When a mailbox is removed, also remove the associated account")
    )

    # Visibility rules
    visibility_rules = {
        "mailboxes_owner": "handle_mailboxes=yes",
    }

    def __init__(self, *args, **kwargs):
        super(AdminParametersForm, self).__init__(*args, **kwargs)
        hide_fields = False
        dpath = None
        code, output = exec_cmd("which dovecot")
        if not code:
            dpath = output.strip()
        else:
            known_paths = getattr(
                settings, "DOVECOT_LOOKUP_PATH",
                ("/usr/sbin/dovecot", "/usr/local/sbin/dovecot")
            )
            for fpath in known_paths:
                if os.path.isfile(fpath) and os.access(fpath, os.X_OK):
                    dpath = fpath
        if dpath:
            try:
                code, version = exec_cmd("%s --version" % dpath)
            except OSError:
                hide_fields = True
            else:
                if code or not version.strip().startswith("2"):
                    hide_fields = True
        else:
            hide_fields = True
        if hide_fields:
            del self.fields["handle_mailboxes"]
            del self.fields["mailboxes_owner"]

    def clean_default_domain_quota(self):
        """Ensure quota is a positive integer."""
        if self.cleaned_data['default_domain_quota'] < 0:
            raise forms.ValidationError(
                ugettext_lazy('Must be a positive integer')
            )
        return self.cleaned_data['default_domain_quota']

########NEW FILE########
__FILENAME__ = factories
from modoboa.core.factories import PermissionFactory, UserFactory
from . import models


class DomainFactory(PermissionFactory):
    FACTORY_FOR = models.Domain

    quota = 10
    enabled = True


class MailboxFactory(PermissionFactory):
    FACTORY_FOR = models.Mailbox

    quota = 10
    enabled = True


class AliasFactory(PermissionFactory):
    FACTORY_FOR = models.Alias

    enabled = True

def populate_database():
    """Create test data.

    2 domains, 1 domain admin, 2 users
    """
    dom = DomainFactory.create(name="test.com")
    admin = UserFactory(
        username="admin@test.com", groups=('DomainAdmins', ), password='{PLAIN}toto'
    )
    MailboxFactory(address='admin', domain=dom, user=admin)
    account = UserFactory.create(
        username="user@test.com", groups=('SimpleUsers',),
    )
    MailboxFactory.create(address='user', domain=dom, user=account)

    fwd = AliasFactory.create(
        address='forward', domain=dom, extmboxes='user@external.com'
    )
    al = AliasFactory.create(
        address='alias', domain=dom
    )
    al.mboxes.add(account.mailbox_set.all()[0])
    AliasFactory.create(
        address='postmaster', domain=dom, extmboxes='toto@titi.com,test@truc.fr'
    )
    dom.add_admin(admin)

    dom2 = DomainFactory.create(name='test2.com', quota=0)
    admin = UserFactory.create(
        username='admin@test2.com', groups=('DomainAdmins',), password='{PLAIN}toto'
    )
    MailboxFactory.create(address='admin', domain=dom2, user=admin)
    u = UserFactory.create(
        username='user@test2.com', groups=('SimpleUsers',)
    )
    MailboxFactory.create(address='user', domain=dom2, user=u)
    dom2.add_admin(admin)

########NEW FILE########
__FILENAME__ = account
from django import forms
from django.utils.translation import ugettext as _, ugettext_lazy
from django.http import QueryDict
from modoboa.lib import events, parameters
from modoboa.lib.exceptions import PermDeniedException, Conflict, NotFound
from modoboa.lib.permissions import get_account_roles
from modoboa.lib.emailutils import split_mailbox
from modoboa.lib.formutils import (
    DomainNameField, DynamicForm, TabForms
)
from modoboa.core.models import User
from modoboa.extensions.admin.models import (
    Domain, Mailbox, Alias
)


class AccountFormGeneral(forms.ModelForm):
    username = forms.CharField(
        label=ugettext_lazy("Username"),
        help_text=ugettext_lazy(
            "The user's name. Must be a valid e-mail address for simple users "
            "or administrators with a mailbox."
        )
    )
    role = forms.ChoiceField(
        label=ugettext_lazy("Role"),
        choices=[('', ugettext_lazy("Choose"))],
        help_text=ugettext_lazy("What level of permission this user will have")
    )
    password1 = forms.CharField(
        label=ugettext_lazy("Password"), widget=forms.PasswordInput
    )
    password2 = forms.CharField(
        label=ugettext_lazy("Confirmation"),
        widget=forms.PasswordInput,
        help_text=ugettext_lazy("Enter the same password as above, for verification.")
    )

    class Meta:
        model = User
        fields = ("username", "first_name", "last_name", "role", "is_active")

    def __init__(self, user, *args, **kwargs):
        super(AccountFormGeneral, self).__init__(*args, **kwargs)
        self.fields.keyOrder = ['role', 'username', 'first_name', 'last_name',
                                'password1', 'password2', 'is_active']
        self.fields["is_active"].label = _("Enabled")
        self.user = user
        if user.group == "DomainAdmins":
            self.fields["role"] = forms.CharField(
                label="",
                widget=forms.HiddenInput, required=False
            )
        else:
            self.fields["role"].choices = [('', ugettext_lazy("Choose"))]
            self.fields["role"].choices += \
                get_account_roles(user, kwargs['instance']) \
                if 'instance' in kwargs else get_account_roles(user)

        if "instance" in kwargs:
            account = kwargs["instance"]
            domain_disabled = account.mailbox_set.count() and \
                not account.mailbox_set.all()[0].domain.enabled
            if domain_disabled:
                self.fields["is_active"].widget.attrs['disabled'] = "disabled"
            if args:
                if args[0].get("password1", "") == "" \
                   and args[0].get("password2", "") == "":
                    self.fields["password1"].required = False
                    self.fields["password2"].required = False
                if domain_disabled:
                    del self.fields["is_active"]
            self.fields["role"].initial = account.group
            if not account.is_local \
               and parameters.get_admin("LDAP_AUTH_METHOD", app="core") == "directbind":
                del self.fields["password1"]
                del self.fields["password2"]

    def domain_is_disabled(self):
        """Little shortcut to get the domain's state.

        We need this information inside a template and the form is the
        only object available...

        """
        if not self.instance.mailbox_set.count():
            return False
        return self.instance.mailbox_set.all()[0].domain.enabled == False

    def clean_role(self):
        if self.user.group == "DomainAdmins":
            if self.instance == self.user:
                return "DomainAdmins"
            return "SimpleUsers"
        return self.cleaned_data["role"]

    def clean_username(self):
        from django.core.validators import validate_email
        if not "role" in self.cleaned_data:
            return self.cleaned_data["username"]
        if self.cleaned_data["role"] != "SimpleUsers":
            return self.cleaned_data["username"]
        uname = self.cleaned_data["username"].lower()
        validate_email(uname)
        return uname

    def clean_password2(self):
        password1 = self.cleaned_data.get("password1", "")
        password2 = self.cleaned_data["password2"]
        if password1 != password2:
            raise forms.ValidationError(_("The two password fields didn't match."))
        return password2

    def save(self, commit=True):
        account = super(AccountFormGeneral, self).save(commit=False)
        if self.user == account and not self.cleaned_data["is_active"]:
            raise PermDeniedException(_("You can't disable your own account"))
        if commit:
            if "password1" in self.cleaned_data \
               and self.cleaned_data["password1"] != "":
                account.set_password(self.cleaned_data["password1"])
            account.save()
            account.set_role(self.cleaned_data["role"])
        return account


class AccountFormMail(forms.Form, DynamicForm):
    email = forms.EmailField(label=ugettext_lazy("E-mail"), required=False)
    quota = forms.IntegerField(
        label=ugettext_lazy("Quota"),
        required=False,
        help_text=_("Quota in MB for this mailbox. Define a custom value or "
                    "use domain's default one. Leave empty to define an "
                    "unlimited value (not allowed for domain "
                    "administrators)."),
        widget=forms.widgets.TextInput(attrs={"class": "span1"})
    )
    quota_act = forms.BooleanField(required=False)
    aliases = forms.EmailField(
        label=ugettext_lazy("Alias(es)"),
        required=False,
        help_text=ugettext_lazy(
            "Alias(es) of this mailbox. Indicate only one address per input, "
            "press ENTER to add a new input. Use the '*' character to create "
            "a 'catchall' alias (ex: *@domain.tld)."
        )
    )

    def __init__(self, *args, **kwargs):
        if "instance" in kwargs:
            self.mb = kwargs["instance"]
            del kwargs["instance"]
        else:
            self.mb = None
        super(AccountFormMail, self).__init__(*args, **kwargs)
        self.extra_fields = []
        for fname, field in events.raiseQueryEvent('ExtraFormFields', 'mailform', self.mb):
            self.fields[fname] = field
            self.extra_fields.append(fname)
        if self.mb is not None:
            self.fields["email"].required = True
            cpt = 1
            for alias in self.mb.alias_set.all():
                if len(alias.get_recipients()) >= 2:
                    continue
                name = "aliases_%d" % cpt
                self._create_field(forms.EmailField, name, alias.full_address)
                cpt += 1
            self.fields["email"].initial = self.mb.full_address            
            self.fields["quota_act"].initial = self.mb.use_domain_quota
            if not self.mb.use_domain_quota and self.mb.quota:
                self.fields["quota"].initial = self.mb.quota
        else:
            self.fields["quota_act"].initial = True

        if len(args) and isinstance(args[0], QueryDict):
            self._load_from_qdict(args[0], "aliases", forms.EmailField)

    def clean_email(self):
        """Ensure lower case emails"""
        return self.cleaned_data["email"].lower()

    def clean(self):
        """Custom fields validation.

        Check if quota is >= 0 only when the domain value is not used.
        """
        super(AccountFormMail, self).clean()
        if self._errors:
            raise forms.ValidationError(self._errors)
        if not self.cleaned_data["quota_act"] \
                and self.cleaned_data['quota'] is not None:
            if self.cleaned_data["quota"] < 0:
                self._errors["quota"] = self.error_class(
                    [_("Must be a positive integer")])
                del self.cleaned_data["quota"]
        return self.cleaned_data

    def create_mailbox(self, user, account):
        locpart, domname = split_mailbox(self.cleaned_data["email"])
        try:
            domain = Domain.objects.get(name=domname)
        except Domain.DoesNotExist:
            raise NotFound(_("Domain does not exist"))
        if not user.can_access(domain):
            raise PermDeniedException
        try:
            Mailbox.objects.get(address=locpart, domain=domain)
        except Mailbox.DoesNotExist:
            pass
        else:
            raise Conflict(
                _("Mailbox %s already exists" % self.cleaned_data["email"])
            )
        events.raiseEvent("CanCreate", user, "mailboxes")
        self.mb = Mailbox(address=locpart, domain=domain, user=account,
                          use_domain_quota=self.cleaned_data["quota_act"])
        self.mb.set_quota(self.cleaned_data["quota"], 
                          user.has_perm("admin.add_domain"))
        self.mb.save(creator=user)

    def update_mailbox(self, user, account):
        newaddress = None
        if self.cleaned_data["email"] != self.mb.full_address:
            newaddress = self.cleaned_data["email"]
        elif account.group == "SimpleUsers" and account.username != self.mb.full_address:
            newaddress = account.username
        if newaddress is not None:
            self.mb.old_full_address = self.mb.full_address
            local_part, domname = split_mailbox(newaddress)
            try:
                domain = Domain.objects.get(name=domname)
            except Domain.DoesNotExist:
                raise NotFound(_("Domain does not exist"))
            if not user.can_access(domain):
                raise PermDeniedException
            self.mb.rename(local_part, domain)

        self.mb.use_domain_quota = self.cleaned_data["quota_act"]
        override_rules = True \
            if not self.mb.quota or user.has_perm("admin.add_domain") \
            else False
        self.mb.set_quota(self.cleaned_data["quota"], override_rules)
        self.mb.save()
        events.raiseEvent('MailboxModified', self.mb)

    def save(self, user, account):
        if self.cleaned_data["email"] == "":
            return None

        if self.cleaned_data["quota_act"]:
            self.cleaned_data["quota"] = None

        if not hasattr(self, "mb") or self.mb is None:
            self.create_mailbox(user, account)
        else:
            self.update_mailbox(user, account)
        events.raiseEvent(
            'SaveExtraFormFields', 'mailform', self.mb, self.cleaned_data
        )

        account.email = self.cleaned_data["email"]
        account.save()

        aliases = []
        for name, value in self.cleaned_data.iteritems():
            if not name.startswith("aliases"):
                continue
            if value == "":
                continue
            aliases.append(value)

        for alias in self.mb.alias_set.all():
            if not alias.full_address in aliases:
                if len(alias.get_recipients()) >= 2:
                    continue
                alias.delete()
            else:
                aliases.remove(alias.full_address)
        if aliases:
            events.raiseEvent(
                "CanCreate", user, "mailbox_aliases", len(aliases)
            )
            for alias in aliases:
                local_part, domname = split_mailbox(alias)
                try:
                    self.mb.alias_set.get(address=local_part, domain__name=domname)
                except Alias.DoesNotExist:
                    pass
                else:
                    continue
                al = Alias(address=local_part, enabled=account.is_active)
                al.domain = Domain.objects.get(name=domname)
                al.save(int_rcpts=[self.mb], creator=user)

        return self.mb


class AccountPermissionsForm(forms.Form, DynamicForm):
    domains = DomainNameField(
        label=ugettext_lazy("Domain(s)"),
        required=False,
        help_text=ugettext_lazy("Domain(s) that user administrates")
    )

    def __init__(self, *args, **kwargs):
        if "instance" in kwargs:
            self.account = kwargs["instance"]
            del kwargs["instance"]

        super(AccountPermissionsForm, self).__init__(*args, **kwargs)

        if not hasattr(self, "account") or self.account is None:
            return
        for pos, domain in enumerate(Domain.objects.get_for_admin(self.account)):
            name = "domains_%d" % (pos + 1)
            self._create_field(DomainNameField, name, domain.name)
        if len(args) and isinstance(args[0], QueryDict):
            self._load_from_qdict(args[0], "domains", DomainNameField)

    def save(self):
        current_domains = [dom.name for dom in Domain.objects.get_for_admin(self.account)]
        for name, value in self.cleaned_data.items():
            if not name.startswith("domains"):
                continue
            if value in ["", None]:
                continue
            if not value in current_domains:
                domain = Domain.objects.get(name=value)
                domain.add_admin(self.account)

        for domain in Domain.objects.get_for_admin(self.account):
            if not len(filter(lambda name: self.cleaned_data[name] == domain.name,
                              self.cleaned_data.keys())):
                domain.remove_admin(self.account)


class AccountForm(TabForms):

    def __init__(self, user, *args, **kwargs):
        self.user = user
        self.forms = [
            dict(id="general", title=_("General"),
                 formtpl="admin/account_general_form.html",
                 cls=AccountFormGeneral,
                 new_args=[user], mandatory=True),
            dict(id="mail", title=_("Mail"), formtpl="admin/mailform.html",
                 cls=AccountFormMail),
            dict(id="perms", title=_("Permissions"), formtpl="admin/permsform.html",
                 cls=AccountPermissionsForm)
        ]
        cbargs = [user]
        if "instances" in kwargs:
            cbargs += [kwargs["instances"]["general"]]
        self.forms += events.raiseQueryEvent("ExtraAccountForm", *cbargs)

        super(AccountForm, self).__init__(*args, **kwargs)

    def check_perms(self, account):
        if account.is_superuser:
            return False
        return self.user.has_perm("admin.add_domain") \
            and account.has_perm("core.add_user")

    def _before_is_valid(self, form):
        if form["id"] == "general":
            return True

        if hasattr(self, "check_%s" % form["id"]):
            if not getattr(self, "check_%s" % form["id"])(self.account):
                return False
            return True

        if False in events.raiseQueryEvent("CheckExtraAccountForm", self.account, form):
            return False
        return True

    def save_general_form(self):
        self.account = self.forms[0]["instance"].save()

    def save(self):
        """Custom save method

        As forms interact with each other, it is simpler to make
        custom code to save them.
        """
        self.forms[1]["instance"].save(self.user, self.account)
        if len(self.forms) <= 2:
            return
        for f in self.forms[2:]:
            f["instance"].save()

########NEW FILE########
__FILENAME__ = alias
from django import forms
from django.utils.translation import ugettext as _, ugettext_lazy
from django.http import QueryDict
from modoboa.lib.exceptions import BadRequest, NotFound, Conflict
from modoboa.lib.emailutils import split_mailbox
from modoboa.lib.formutils import (
    DynamicForm
)
from modoboa.extensions.admin.models import (
    Domain, Mailbox, Alias
)


class AliasForm(forms.ModelForm, DynamicForm):
    email = forms.EmailField(
        label=ugettext_lazy("Email address"),
        help_text=ugettext_lazy(
            "The distribution list address. Use the '*' character to create a "
            "'catchall' address (ex: *@domain.tld)."
        )
    )
    recipients = forms.EmailField(
        label=ugettext_lazy("Recipients"), required=False,
        help_text=ugettext_lazy(
            "Mailbox(es) this alias will point to. Indicate only one address "
            "per input, press ENTER to add a new input."
        )
    )

    class Meta:
        model = Alias
        fields = ("enabled",)

    def __init__(self, user, *args, **kwargs):
        self.user = user
        super(AliasForm, self).__init__(*args, **kwargs)
        self.fields.keyOrder = ['email', 'recipients', 'enabled']

        if len(args) and isinstance(args[0], QueryDict):
            if "instance" in kwargs:
                if not kwargs["instance"].domain.enabled:
                    del self.fields["enabled"]
            self._load_from_qdict(args[0], "recipients", forms.EmailField)
        elif "instance" in kwargs:
            dlist = kwargs["instance"]
            self.fields["email"].initial = dlist.full_address
            if not dlist.domain.enabled:
                self.fields["enabled"].widget.attrs["disabled"] = "disabled"
            cpt = 1
            for al in dlist.aliases.all():
                name = "recipients_%d" % cpt
                self._create_field(forms.EmailField, name, al.full_address, 2)
                cpt += 1
            for mb in dlist.mboxes.all():
                name = "recipients_%d" % (cpt)
                self._create_field(forms.EmailField, name, mb.full_address, 2)
                cpt += 1
            for addr in dlist.extmboxes.split(','):
                if addr == "":
                    continue
                name = "recipients_%d" % (cpt)
                self._create_field(forms.EmailField, name, addr, 2)
                cpt += 1

    def clean_email(self):
        localpart, domname = split_mailbox(self.cleaned_data["email"])
        try:
            domain = Domain.objects.get(name=domname)
        except Domain.DoesNotExist:
            raise forms.ValidationError(_("Domain does not exist"))
        if not self.user.can_access(domain):
            raise forms.ValidationError(
                _("You don't have access to this domain")
            )
        return self.cleaned_data["email"]

    def set_recipients(self):
        """Recipients dispatching

        We make a difference between 'local' recipients (the ones hosted
        by Modoboa) and 'external' recipients.
        """
        self.ext_rcpts = []
        self.int_rcpts = []
        total = 0

        for k, v in self.cleaned_data.items():
            if not k.startswith("recipients"):
                continue
            if v == "":
                continue
            local_part, domname = split_mailbox(v)
            if domname is None:
                raise BadRequest(
                    u"%s %s" % (_("Invalid mailbox"), v)
                )
            try:
                domain = Domain.objects.get(name=domname)
            except Domain.DoesNotExist:
                domain = None
            if domain is not None:
                try:
                    rcpt = Alias.objects.get(domain=domain, address=local_part)
                    if rcpt.full_address == self.cleaned_data["email"]:
                        rcpt = None
                except Alias.DoesNotExist:
                    rcpt = None
                if rcpt is None:
                    try:
                        rcpt = Mailbox.objects.get(domain=domain, address=local_part)
                    except Mailbox.DoesNotExist:
                        raise NotFound(
                            _("Local recipient %s not found" % v)
                        )
                if rcpt in self.int_rcpts:
                    raise Conflict(
                        _("Recipient %s already present" % v)
                    )
                self.int_rcpts += [rcpt]
                total += 1
                continue

            if v in self.ext_rcpts:
                raise Conflict(
                    _("Recipient %s already present" % v)
                )
            self.ext_rcpts += [v]
            total += 1

        if total == 0:
            raise BadRequest(_("No recipient defined"))

    def save(self, commit=True):
        alias = super(AliasForm, self).save(commit=False)
        localpart, domname = split_mailbox(self.cleaned_data["email"])
        alias.address = localpart
        alias.domain = Domain.objects.get(name=domname)
        if commit:
            alias.save(int_rcpts=self.int_rcpts, ext_rcpts=self.ext_rcpts)
            self.save_m2m()
        return alias

########NEW FILE########
__FILENAME__ = domain
from django import forms
from django.http import QueryDict
from django.utils.translation import ugettext as _, ugettext_lazy
from modoboa.lib import events, parameters
from modoboa.lib.exceptions import Conflict
from modoboa.lib.formutils import (
    DomainNameField, YesNoField, DynamicForm, TabForms
)
from modoboa.core.models import User
from modoboa.extensions.admin.models import (
    Domain, DomainAlias, Mailbox, Alias, Quota
)


class DomainFormGeneral(forms.ModelForm, DynamicForm):
    quota = forms.IntegerField(
        label=ugettext_lazy("Quota"),
        required=False,
        help_text=ugettext_lazy(
            "Default quota in MB applied to mailboxes. Leave empty to use the "
            "default value."
        ),
        widget=forms.TextInput(attrs={"class": "span1"})
    )
    aliases = DomainNameField(
        label=ugettext_lazy("Alias(es)"),
        required=False,
        help_text=ugettext_lazy(
            "Alias(es) of this domain. Indicate only one name per input, "
            "press ENTER to add a new input."
        )
    )

    class Meta:
        model = Domain
        fields = ("name", "quota", "aliases", "enabled")

    def __init__(self, *args, **kwargs):
        self.oldname = None
        if "instance" in kwargs:
            self.oldname = kwargs["instance"].name
        super(DomainFormGeneral, self).__init__(*args, **kwargs)

        if len(args) and isinstance(args[0], QueryDict):
            self._load_from_qdict(args[0], "aliases", DomainNameField)
        elif "instance" in kwargs:
            d = kwargs["instance"]
            for pos, dalias in enumerate(d.domainalias_set.all()):
                name = "aliases_%d" % (pos + 1)
                self._create_field(forms.CharField, name, dalias.name, 3)

    def clean_quota(self):
        if self.cleaned_data['quota'] is None:
            return int(parameters.get_admin('DEFAULT_DOMAIN_QUOTA'))
        if self.cleaned_data['quota'] < 0:
            raise forms.ValidationError(_("Must be a positive integer"))
        return self.cleaned_data['quota']

    def clean(self):
        """Custom fields validation.

        We want to prevent duplicate names between domains and domain
        aliases. Extensions have the possibility to declare other
        objects (see *CheckDomainName* event).

        The validation way is not very smart...
        """
        super(DomainFormGeneral, self).clean()
        if self._errors:
            raise forms.ValidationError(self._errors)

        cleaned_data = self.cleaned_data
        name = cleaned_data["name"]
        dtypes = events.raiseQueryEvent('CheckDomainName')
        for dtype, label in [(DomainAlias, _('domain alias'))] + dtypes:
            try:
                dtype.objects.get(name=name)
            except dtype.DoesNotExist:
                pass
            else:
                self._errors["name"] = self.error_class(
                    [_("A %s with this name already exists" % unicode(label))]
                )
                del cleaned_data["name"]
                break
        for k in cleaned_data.keys():
            if not k.startswith("aliases"):
                continue
            if cleaned_data[k] == "":
                del cleaned_data[k]
                continue
            for dtype, label in [(Domain, _('domain'))] + dtypes:
                try:
                    dtype.objects.get(name=cleaned_data[k])
                except dtype.DoesNotExist:
                    continue
                self._errors[k] = self.error_class(
                    [_("A %s with this name already exists" % unicode(label))]
                )
                del cleaned_data[k]
                break
        return cleaned_data

    def update_mailbox_quotas(self, domain):
        """Update all quota records associated to this domain

        This method must be called only when a domain gets renamed. As
        the primary key used for a quota is an email address, rename a
        domain will change all associated email addresses, so it will
        change the primary keys used for quotas. The consequence is we
        can't issue regular UPDATE queries using the .save() method of
        a Quota instance (it will trigger an INSERT as the primary key
        has changed).

        So, we use this ugly hack to bypass this behaviour. It is not
        perfomant at all as it will generate one query per quota
        record to update.
        """
        for q in Quota.objects.filter(username__contains="@%s" % self.oldname).values('username'):
            username = q['username'].replace('@%s' % self.oldname, '@%s' % domain.name)
            Quota.objects.filter(username=q['username']).update(username=username)

    def save(self, user, commit=True, domalias_post_create=False):
        """Custom save method

        Updating a domain may have consequences on other objects
        (domain alias, mailbox, quota). The most tricky part concerns
        quotas update.

        """
        d = super(DomainFormGeneral, self).save(commit=False)
        if commit:
            old_mail_homes = None
            if self.oldname is not None and d.name != self.oldname:
                d.name = self.oldname
                old_mail_homes = \
                    dict((mb.id, mb.mail_home) for mb in d.mailbox_set.all())
                d.name = self.cleaned_data['name']
            d.save()
            Mailbox.objects.filter(domain=d, use_domain_quota=True) \
                .update(quota=d.quota)
            aliases = []
            for k, v in self.cleaned_data.iteritems():
                if not k.startswith("aliases"):
                    continue
                if v in ["", None]:
                    continue
                aliases.append(v)
            for dalias in d.domainalias_set.all():
                if not dalias.name in aliases:
                    dalias.delete()
                else:
                    aliases.remove(dalias.name)
            if aliases:
                events.raiseEvent("CanCreate", user, "domain_aliases", len(aliases))
                for alias in aliases:
                    try:
                        d.domainalias_set.get(name=alias)
                    except DomainAlias.DoesNotExist:
                        pass
                    else:
                        continue
                    al = DomainAlias(name=alias, target=d, enabled=d.enabled)
                    al.save(creator=user) if domalias_post_create else al.save()

            if old_mail_homes is not None:
                self.update_mailbox_quotas(d)
                for mb in d.mailbox_set.all():
                    mb.rename_dir(old_mail_homes[mb.id])

        return d


class DomainFormOptions(forms.Form):
    create_dom_admin = YesNoField(
        label=ugettext_lazy("Create a domain administrator"),
        initial="no",
        help_text=ugettext_lazy("Automatically create an administrator for this domain")
    )

    dom_admin_username = forms.CharField(
        label=ugettext_lazy("Name"),
        initial="admin",
        help_text=ugettext_lazy(
            "The administrator's name. Don't include the domain's name here, "
            "it will be automatically appended."
        ),
        widget=forms.widgets.TextInput(attrs={"class": "input-small"}),
        required=False
    )

    create_aliases = YesNoField(
        label=ugettext_lazy("Create aliases"),
        initial="yes",
        help_text=ugettext_lazy("Automatically create standard aliases for this domain"),
        required=False
    )

    def __init__(self, user, *args, **kwargs):
        super(DomainFormOptions, self).__init__(*args, **kwargs)
        if False in events.raiseQueryEvent('UserCanSetRole', user, 'DomainAdmins'):
            self.fields = {}
            return
        if args:
            if args[0].get("create_dom_admin", "no") == "yes":
                self.fields["dom_admin_username"].required = True
                self.fields["create_aliases"].required = True

    def clean_dom_admin_username(self):
        if '@' in self.cleaned_data["dom_admin_username"]:
            raise forms.ValidationError(_("Invalid format"))
        return self.cleaned_data["dom_admin_username"]

    def save(self, user, domain):
        if not self.fields:
            return
        if self.cleaned_data["create_dom_admin"] == "no":
            return
        username = "%s@%s" % (self.cleaned_data["dom_admin_username"], domain.name)
        try:
            da = User.objects.get(username=username)
        except User.DoesNotExist:
            pass
        else:
            raise Conflict(_("User '%s' already exists" % username))
        events.raiseEvent("CanCreate", user, "mailboxes")
        da = User(username=username, email=username, is_active=True)
        da.set_password("password")
        da.save()
        da.set_role("DomainAdmins")
        da.post_create(user)
        mb = Mailbox(address=self.cleaned_data["dom_admin_username"], domain=domain,
                     user=da, use_domain_quota=True)
        mb.set_quota(override_rules=user.has_perm("admin.change_domain"))
        mb.save(creator=user)

        if self.cleaned_data["create_aliases"] == "yes":
            events.raiseEvent("CanCreate", user, "mailbox_aliases")
            al = Alias(address="postmaster", domain=domain, enabled=True)
            al.save(int_rcpts=[mb], creator=user)

        domain.add_admin(da)


class DomainForm(TabForms):
    def __init__(self, user, *args, **kwargs):
        self.user = user
        self.forms = []
        if user.has_perm("admin.change_domain"):
            self.forms.append(dict(
                id="general", title=_("General"), formtpl="admin/domain_general_form.html",
                cls=DomainFormGeneral, mandatory=True
            ))

        cbargs = [user]
        if "instances" in kwargs:
            cbargs += [kwargs["instances"]["general"]]
        self.forms += events.raiseQueryEvent("ExtraDomainForm", *cbargs)
        if not self.forms:
            self.active_id = "admins"
        super(DomainForm, self).__init__(*args, **kwargs)

    def save(self, user):
        """Custom save method

        As forms interact with each other, it is easier to make custom
        code to save them.
        """
        self.forms[0]['instance'].save(user, domalias_post_create=True)
        for f in self.forms[1:]:
            f["instance"].save(user)

########NEW FILE########
__FILENAME__ = export
from django import forms
from django.utils.translation import ugettext_lazy


class ExportDataForm(forms.Form):
    filename = forms.CharField(
        label=ugettext_lazy("File name"), max_length=100, required=False
    )
    sepchar = forms.CharField(
        label=ugettext_lazy("Separator"), max_length=1, required=False
    )

    def __init__(self, *args, **kwargs):
        super(ExportDataForm, self).__init__(*args, **kwargs)
        self.fields["sepchar"].widget.attrs = {"class": "span1"}

    def clean_sepchar(self):
        if self.cleaned_data["sepchar"] == "":
            return ";"
        return str(self.cleaned_data["sepchar"])

    def clean_filename(self):
        if self.cleaned_data["filename"] == "":
            return self.fields["filename"].initial
        return str(self.cleaned_data["filename"])


class ExportDomainsForm(ExportDataForm):
    def __init__(self, *args, **kwargs):
        super(ExportDomainsForm, self).__init__(*args, **kwargs)
        self.fields["filename"].initial = "modoboa-domains.csv"


class ExportIdentitiesForm(ExportDataForm):
    def __init__(self, *args, **kwargs):
        super(ExportIdentitiesForm, self).__init__(*args, **kwargs)
        self.fields["filename"].initial = "modoboa-identities.csv"

########NEW FILE########
__FILENAME__ = forward
from django import forms
from django.utils.translation import ugettext as _, ugettext_lazy
from modoboa.lib.exceptions import BadRequest, PermDeniedException
from modoboa.lib.emailutils import split_mailbox
from modoboa.extensions.admin.models import (
    Domain
)


class ForwardForm(forms.Form):
    dest = forms.CharField(
        label=ugettext_lazy("Recipient(s)"),
        widget=forms.Textarea,
        required=False,
        help_text=ugettext_lazy("Indicate one or more recipients separated by a ','")
    )
    keepcopies = forms.BooleanField(
        label=ugettext_lazy("Keep local copies"),
        required=False,
        help_text=ugettext_lazy("Forward messages and store copies into your local mailbox")
    )

    def parse_dest(self):
        self.dests = []
        rawdata = self.cleaned_data["dest"].strip()
        if rawdata == "":
            return
        for d in rawdata.split(","):
            local_part, domname = split_mailbox(d)
            if not local_part or not domname or not len(domname):
                raise BadRequest("Invalid mailbox syntax for %s" % d)
            try:
                Domain.objects.get(name=domname)
            except Domain.DoesNotExist:
                self.dests += [d]
            else:
                raise PermDeniedException(
                    _("You can't define a forward to a local destination. "
                      "Please ask your administrator to create an alias "
                      "instead.")
                )

########NEW FILE########
__FILENAME__ = import_
from django import forms
from django.utils.translation import ugettext_lazy


class ImportDataForm(forms.Form):
    sourcefile = forms.FileField(label=ugettext_lazy("Select a file"))
    sepchar = forms.CharField(
        label=ugettext_lazy("Separator"), max_length=1, required=False
    )
    continue_if_exists = forms.BooleanField(
        label=ugettext_lazy("Continue on error"), required=False,
        help_text=ugettext_lazy("Don't treat duplicated objects as error")
    )

    def __init__(self, *args, **kwargs):
        super(ImportDataForm, self).__init__(*args, **kwargs)
        self.fields["sepchar"].widget.attrs = {"class": "span1"}

    def clean_sepchar(self):
        if self.cleaned_data["sepchar"] == "":
            return ";"
        return str(self.cleaned_data["sepchar"])


class ImportIdentitiesForm(ImportDataForm):
    crypt_password = forms.BooleanField(
        label=ugettext_lazy("Crypt passwords"), required=False,
        help_text=ugettext_lazy("Check this option if passwords contained in your file are not crypted")
    )

########NEW FILE########
__FILENAME__ = lib
# coding: utf-8
from functools import wraps
from itertools import chain
from django.db.models import Q
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from django.contrib.contenttypes.models import ContentType
from django.utils.translation import ugettext as _
from modoboa.core.models import User
from modoboa.lib import parameters, events
from modoboa.lib.exceptions import PermDeniedException
from modoboa.lib.emailutils import split_mailbox
from modoboa.extensions.admin.models import (
    Domain, Alias
)


def needs_mailbox():
    """Check if the current user owns at least one mailbox

    Some applications (the webmail for example) need a mailbox to
    work.
    """
    def decorator(f):
        @wraps(f)
        def wrapped_f(request, *args, **kwargs):
            if request.user.mailbox_set.count():
                return f(request, *args, **kwargs)
            raise PermDeniedException(_("A mailbox is required"))
        return wrapped_f
    return decorator


def get_sort_order(qdict, default, allowed_values=None):
    """Return a sort order from a querydict object

    :param QueryDict qdict: the object to analyse
    :param string default: the default sort order if no one is found
    :param list allowed_values: an optional list of allowed values
    :return: a 2uple of strings
    """
    sort_order = qdict.get("sort_order", default)
    if sort_order.startswith("-"):
        sort_dir = "-"
        sort_order = sort_order[1:]
    else:
        sort_dir = ""
    if allowed_values is not None and not sort_order in allowed_values:
        return (default, "")
    return (sort_order, sort_dir)


def get_listing_page(objects, pagenum):
    """Return specific a listing page.

    A page contains a limited number of elements (see
    ITEMS_PER_PAGE). If the given page number is wrong, the first page
    will be always returned.

    :param list objects: object list to paginate
    :param int pagenum: page number
    :return: a ``Page`` object
    """
    paginator = Paginator(
        objects, int(parameters.get_admin("ITEMS_PER_PAGE", app="core"))
    )
    try:
        page = paginator.page(int(pagenum))
    except (EmptyPage, PageNotAnInteger, ValueError):
        page = paginator.page(paginator.num_pages)
    return page


def get_identities(user, searchquery=None, idtfilter=None, grpfilter=None):
    """Return all the identities owned by a user.

    :param user: the desired user
    :param str searchquery: search pattern
    :param list idtfilter: identity type filters
    :param list grpfilter: group names filters
    :return: a queryset
    """
    accounts = []
    if idtfilter is None or not idtfilter or idtfilter == "account":
        ids = user.objectaccess_set \
            .filter(content_type=ContentType.objects.get_for_model(user)) \
            .values_list('object_id', flat=True)
        q = Q(pk__in=ids)
        if searchquery is not None:
            q &= Q(username__icontains=searchquery) \
                | Q(email__icontains=searchquery)
        if grpfilter is not None and grpfilter:
            if grpfilter == "SuperAdmins":
                q &= Q(is_superuser=True)
            else:
                q &= Q(groups__name=grpfilter)
        accounts = User.objects.select_related().filter(q)

    aliases = []
    if idtfilter is None or not idtfilter \
            or (idtfilter in ["alias", "forward", "dlist"]):
        alct = ContentType.objects.get_for_model(Alias)
        ids = user.objectaccess_set.filter(content_type=alct) \
            .values_list('object_id', flat=True)
        q = Q(pk__in=ids)
        if searchquery is not None:
            if '@' in searchquery:
                local_part, domname = split_mailbox(searchquery)
                if local_part:
                    q &= Q(address__icontains=local_part)
                if domname:
                    q &= Q(domain__name__icontains=domname)
            else:
                q &= Q(address__icontains=searchquery) | \
                    Q(domain__name__icontains=searchquery)
        aliases = Alias.objects.select_related().filter(q)
        if idtfilter is not None and idtfilter:
            aliases = [al for al in aliases if al.type == idtfilter]
    return chain(accounts, aliases)


def get_domains(user, domfilter=None, searchquery=None, **extrafilters):
    """Return all the domains the user can access.

    :param ``User`` user: user object
    :param str searchquery: filter
    :rtype: list
    :return: a list of domains and/or relay domains
    """
    domains = []
    if domfilter is None or not domfilter or domfilter == 'domain':
        domains = Domain.objects.get_for_admin(user)
        if searchquery is not None:
            q = Q(name__contains=searchquery)
            q |= Q(domainalias__name__contains=searchquery)
            domains = domains.filter(q).distinct()
    extra_domain_entries = events.raiseQueryEvent(
        'ExtraDomainEntries', user, domfilter, searchquery, **extrafilters
    )
    return chain(domains, extra_domain_entries)

########NEW FILE########
__FILENAME__ = handle_mailbox_operations
import os
import logging
from optparse import make_option
from django.core.management.base import BaseCommand
from modoboa.lib import parameters
from modoboa.lib.sysutils import exec_cmd
from modoboa.lib.exceptions import InternalError
from modoboa.extensions.admin import AdminConsole
from modoboa.extensions.admin.models import MailboxOperation


class OperationError(Exception):
    pass


class Command(BaseCommand):
    help = 'Handles rename and delete operations on mailboxes'

    option_list = BaseCommand.option_list + (
        make_option(
            '--pidfile', default='/tmp/handle_mailbox_operations.pid',
            help='Path to the file that will contain the PID of this process'
        ),
    )

    def __init__(self, *args, **kwargs):
        super(Command, self).__init__(*args, **kwargs)
        self.logger = logging.getLogger('modoboa.admin')

    def rename_mailbox(self, operation):
        if not os.path.exists(operation.argument):
            return
        new_mail_home = operation.mailbox.mail_home
        dirname = os.path.dirname(new_mail_home)
        if not os.path.exists(dirname):
            try:
                os.makedirs(dirname)
            except os.error as e:
                raise OperationError(str(e))
        code, output = exec_cmd(
            "mv %s %s" % (operation.argument, new_mail_home)
        )
        if code:
            raise OperationError(output)

    def delete_mailbox(self, operation):
        if not os.path.exists(operation.argument):
            return
        code, output = exec_cmd(
            "rm -r %s" % operation.argument
        )
        if code:
            raise OperationError(output)

    def check_pidfile(self, path):
        """Check if this command is already running

        :param str path: path to the file containing the PID
        :return: a boolean, True means we can go further
        """
        if os.path.exists(path):
            with open(path) as fp:
                pid = fp.read().strip()
            code, output = exec_cmd(
                "grep handle_mailbox_operations /proc/%s/cmdline" % pid
            )
            if not code:
                return False
        with open(path, 'w') as fp:
            print >> fp, os.getpid()
        return True

    def handle(self, *args, **options):
        AdminConsole().load()
        if parameters.get_admin("HANDLE_MAILBOXES") == 'no':
            return
        if not self.check_pidfile(options['pidfile']):
            return
        for ope in MailboxOperation.objects.all():
            try:
                f = getattr(self, '%s_mailbox' % ope.type)
            except AttributeError:
                continue
            try:
                f(ope)
            except (OperationError, InternalError) as e:
                self.logger.critical('%s failed (reason: %s)',
                                     ope, str(e).encode('utf-8'))
            else:
                self.logger.info('%s succeed', ope)
                ope.delete()
        os.unlink(options['pidfile'])

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):
    
    def forwards(self, orm):
        
        # Adding model 'Domain'
        db.create_table('admin_domain', (
            ('quota', self.gf('django.db.models.fields.IntegerField')()),
            ('enabled', self.gf('django.db.models.fields.BooleanField')(default=False, blank=True)),
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=100)),
        ))
        db.send_create_signal('admin', ['Domain'])

        # Adding model 'Mailbox'
        db.create_table('admin_mailbox', (
            ('domain', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['admin.Domain'])),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('quota', self.gf('django.db.models.fields.IntegerField')()),
            ('full_address', self.gf('django.db.models.fields.CharField')(max_length=150)),
            ('gid', self.gf('django.db.models.fields.IntegerField')()),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('address', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('path', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('password', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('uid', self.gf('django.db.models.fields.IntegerField')()),
        ))
        db.send_create_signal('admin', ['Mailbox'])

        # Adding model 'Alias'
        db.create_table('admin_alias', (
            ('enabled', self.gf('django.db.models.fields.BooleanField')(default=False, blank=True)),
            ('mbox', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['admin.Mailbox'])),
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('full_address', self.gf('django.db.models.fields.CharField')(max_length=150)),
            ('address', self.gf('django.db.models.fields.CharField')(max_length=100)),
        ))
        db.send_create_signal('admin', ['Alias'])
    
    def backwards(self, orm):
        
        # Deleting model 'Domain'
        db.delete_table('admin_domain')

        # Deleting model 'Mailbox'
        db.delete_table('admin_mailbox')

        # Deleting model 'Alias'
        db.delete_table('admin_alias')
    
    
    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '150'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mbox': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Mailbox']"})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '150'}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User', 'db_table': "'auth_user'"},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }
    
    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0002_auto__del_field_alias_mbox
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):
    no_dry_run = True
    
    def forwards(self, orm):
        
        # Adding M2M table for field mboxes on 'Alias'
        db.create_table('admin_alias_mboxes', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('alias', models.ForeignKey(orm['admin.alias'], null=False)),
            ('mailbox', models.ForeignKey(orm['admin.mailbox'], null=False))
        ))
        db.create_unique('admin_alias_mboxes', ['alias_id', 'mailbox_id'])

        for alias in orm.Alias.objects.all():
            alias.mboxes.add(alias.mbox_id)
            alias.save()

        # Deleting field 'Alias.mbox'
        db.delete_column('admin_alias', 'mbox_id')
    
    def backwards(self, orm):
        
        # Adding field 'Alias.mbox'
        db.add_column('admin_alias', 'mbox', self.gf('django.db.models.fields.related.ForeignKey')(default=-1, to=orm['admin.Mailbox']), keep_default=False)

        # Removing M2M table for field mboxes on 'Alias'
        db.delete_table('admin_alias_mboxes')
    
    
    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '150'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']"})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '150'}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }
    
    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0003_auto__add_extension
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Extension'
        db.create_table('admin_extension', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=150)),
            ('enabled', self.gf('django.db.models.fields.BooleanField')(default=False, blank=True)),
        ))
        db.send_create_signal('admin', ['Extension'])


    def backwards(self, orm):
        
        # Deleting model 'Extension'
        db.delete_table('admin_extension')


    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '150'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '150'}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0004_add_permissions
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models
#from django.contrib.auth.models import Permission
#from django.contrib.contenttypes.models import ContentType


class Migration(DataMigration):

    def forwards(self, orm):
        #perm_ct = ContentType.objects.get(app_label="auth", model="permission")
        perm_ct = orm["contenttypes.ContentType"].objects.get(app_label="auth", model="permission")
        view_perms = orm['auth.Permission'](
            name="View permissions", codename="view_permissions",
            content_type=perm_ct
        )
        view_perms.save()

    def backwards(self, orm):
        p = orm['auth.Permission'].objects.get(codename="view_permissions")
        p.delete()


    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '150'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '150'}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin', 'contenttypes']

########NEW FILE########
__FILENAME__ = 0005_increase_columns_length
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        db.alter_column('auth_user', "username", models.CharField(unique=True, max_length=254))
        db.alter_column('auth_user', "email", models.CharField(max_length=254))

    def backwards(self, orm):
        raise RuntimeError("Cannot revert this migration")

    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '150'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '150'}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0006_auto__add_domainalias
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'DomainAlias'
        db.create_table('admin_domainalias', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(unique=True, max_length=100)),
            ('target', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['admin.Domain'])),
            ('enabled', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('admin', ['DomainAlias'])

    def backwards(self, orm):
        
        # Deleting model 'DomainAlias'
        db.delete_table('admin_domainalias')

        grp = orm["auth.Group"].objects.get(name="DomainAdmins")
        for pcode in ["view_domaliases", "add_domainalias", "change_domainalias",
                      "delete_domainalias"]:
            grp.permissions.remove(orm["auth.Permissions"].objects.get(codename=pcode))
        grp.save()

    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '150'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '150'}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0007_auto__del_field_alias_full_address__chg_field_alias_address__del_field
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'Alias.full_address'
        db.delete_column('admin_alias', 'full_address')

        # Changing field 'Alias.address'
        db.alter_column('admin_alias', 'address', self.gf('django.db.models.fields.CharField')(max_length=254))

        # Deleting field 'Mailbox.full_address'
        db.delete_column('admin_mailbox', 'full_address')


    def backwards(self, orm):
        
        # User chose to not deal with backwards NULL issues for 'Alias.full_address'
        raise RuntimeError("Cannot reverse this migration. 'Alias.full_address' and its values cannot be restored.")

        # Changing field 'Alias.address'
        db.alter_column('admin_alias', 'address', self.gf('django.db.models.fields.CharField')(max_length=100))

        # User chose to not deal with backwards NULL issues for 'Mailbox.full_address'
        raise RuntimeError("Cannot reverse this migration. 'Mailbox.full_address' and its values cannot be restored.")


    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0008_update_mailbox_path
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models


class Migration(DataMigration):

    def forwards(self, orm):
        for mb in orm.Mailbox.objects.all():
            mb.path = mb.path.replace(mb.domain.name + "/", "", 1)
            mb.save()


    def backwards(self, orm):
        raise RuntimeError("Cannot revert this migration")

    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0009_auto__add_field_alias_extmboxes
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Alias.extmboxes'
        db.add_column('admin_alias', 'extmboxes', self.gf('django.db.models.fields.TextField')(default='', blank=True), keep_default=False)
        db.add_column('admin_alias', 'domain', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['admin.Domain'], default=-1))


    def backwards(self, orm):
        
        # Deleting field 'Alias.extmboxes'
        db.delete_column('admin_alias', 'extmboxes')
        db.delete_column('admin_alias', 'domain')


    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0010_fill_alias_domain
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models


class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        for alias in orm.Alias.objects.all():
            alias.domain = alias.mboxes.all()[0].domain
            alias.save()

    def backwards(self, orm):
        "Write your backwards methods here."


    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0011_auto__add_objectdates__add_field_domain_dates__add_field_domainalias_d
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'ObjectDates'
        db.create_table('admin_objectdates', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('creation', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('last_modification', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
        ))
        db.send_create_signal('admin', ['ObjectDates'])

        # Adding field 'Domain.dates'
        db.add_column('admin_domain', 'dates', self.gf('django.db.models.fields.related.ForeignKey')(default=-1, to=orm['admin.ObjectDates']), keep_default=False)

        # Adding field 'DomainAlias.dates'
        db.add_column('admin_domainalias', 'dates', self.gf('django.db.models.fields.related.ForeignKey')(default=-1, to=orm['admin.ObjectDates']), keep_default=False)

        # Adding field 'Alias.dates'
        db.add_column('admin_alias', 'dates', self.gf('django.db.models.fields.related.ForeignKey')(default=-1, to=orm['admin.ObjectDates']), keep_default=False)

        # Adding field 'Mailbox.dates'
        db.add_column('admin_mailbox', 'dates', self.gf('django.db.models.fields.related.ForeignKey')(default=-1, to=orm['admin.ObjectDates']), keep_default=False)


    def backwards(self, orm):
        
        # Deleting model 'ObjectDates'
        db.delete_table('admin_objectdates')

        # Deleting field 'Domain.dates'
        db.delete_column('admin_domain', 'dates_id')

        # Deleting field 'DomainAlias.dates'
        db.delete_column('admin_domainalias', 'dates_id')

        # Deleting field 'Alias.dates'
        db.delete_column('admin_alias', 'dates_id')

        # Deleting field 'Mailbox.dates'
        db.delete_column('admin_mailbox', 'dates_id')


    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0012_fill_object_dates
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models


def create_od(orm, obj):
    od = orm.ObjectDates()
    od.save()
    obj.dates = od
    obj.save()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        for domain in orm.Domain.objects.all():
            create_od(orm, domain)
        for domalias in orm.DomainAlias.objects.all():
            create_od(orm, domainalias)
        for mbox in orm.Mailbox.objects.all():
            create_od(orm, mbox)
        for mbalias in orm.Alias.objects.all():
            create_od(orm, mbalias)

    def backwards(self, orm):
        "Write your backwards methods here."
        orm.ObjectDates.objects.all().delete()

    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['admin.ObjectDates']", 'unique': 'True'}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['admin.ObjectDates']", 'unique': 'True'}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['admin.ObjectDates']", 'unique': 'True'}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['admin.ObjectDates']", 'unique': 'True'}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0013_update_mailbox_path
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models


class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        for mb in orm.Mailbox.objects.all():
            mb.path = "%s/" % mb.address
            mb.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("Cannot reverse this migration.")

    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0014_auto__add_unique_domain_name
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding unique constraint on 'Domain', fields ['name']
        db.create_unique('admin_domain', ['name'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Domain', fields ['name']
        db.delete_unique('admin_domain', ['name'])


    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0015_move_passwords
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models
from modoboa.lib.models import Parameter
from modoboa.lib.dbutils import db_table_exists


class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        if not db_table_exists("lib_parameter"):
            return
        try:
            s = Parameter.objects.get(name='admin.PASSWORD_SCHEME').value
        except Parameter.DoesNotExist:
            s = "crypt"
            
        for mb in orm.Mailbox.objects.all():
            mb.user.password = '{%s}%s' % (s.upper(), mb.password)
            mb.user.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("Cannot reverse this migration.")

    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin', 'auth']

########NEW FILE########
__FILENAME__ = 0016_auto__add_objectaccess__add_unique_objectaccess_user_content_type_obje
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'ObjectAccess'
        db.create_table('admin_objectaccess', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('content_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'])),
            ('object_id', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('is_owner', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('admin', ['ObjectAccess'])

        # Adding unique constraint on 'ObjectAccess', fields ['user', 'content_type', 'object_id']
        db.create_unique('admin_objectaccess', ['user_id', 'content_type_id', 'object_id'])

        # Deleting field 'Mailbox.password'
        db.delete_column('admin_mailbox', 'password')

        # Deleting field 'Mailbox.name'
        db.delete_column('admin_mailbox', 'name')

    def backwards(self, orm):
        raise RuntimeError("Cannot reverse this migration.")

    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']" })
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0017_set_permissions
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models
from django.core.exceptions import ObjectDoesNotExist


class Migration(DataMigration):

    def grant_access(self, orm, user, ct, obj, is_owner=False):
        objaccess = orm["admin.ObjectAccess"](
            user=user, content_type=ct, object_id=obj.id
        )
        objaccess.is_owner = is_owner
        objaccess.save()

    def forwards(self, orm):
        superusers = orm['auth.User'].objects.filter(is_superuser=True)
        if not len(superusers):
            # Empty db, nothing to do
            return

        # 1: all superadmins must be able to access every defined
        # object. (user, domain, domain alias, mailbox, alias)
        try:
            uct = orm['contenttypes.ContentType'].objects.get(
                app_label='auth', model='user'
            )
        except ObjectDoesNotExist:
            uct = orm['contenttypes.ContentType'](
                name='user', app_label='auth', model='user'
            )
            uct.save()
        for account in orm['auth.User'].objects.all():
            for i, su in enumerate(superusers):
                self.grant_access(orm, su, uct, account, i == 0)
        domct = orm['contenttypes.ContentType'].objects.get(
            app_label='admin', model='domain'
            )
        for dom in orm["admin.Domain"].objects.all():
            for i, su in enumerate(superusers):
                self.grant_access(orm, su, domct, dom, i == 0)
        dalct = orm['contenttypes.ContentType'].objects.get(
            app_label='admin', model='domainalias'
            )
        for domalias in orm["admin.DomainAlias"].objects.all():
            for i, su in enumerate(superusers):
                self.grant_access(orm, su, dalct, domalias, i == 0)
        mbct = orm['contenttypes.ContentType'].objects.get(
            app_label='admin', model='mailbox'
            )
        for mb in orm["admin.Mailbox"].objects.all():
            for i, su in enumerate(superusers):
                self.grant_access(orm, su, mbct, mb, i == 0)
        alct = orm['contenttypes.ContentType'].objects.get(
            app_label='admin', model='alias'
            )
        for alias in orm["admin.Alias"].objects.all():
            for i, su in enumerate(superusers):
                self.grant_access(orm, su, alct, alias, i == 0)

        # 2: domain admins must have access to their domain's content
        for da in orm['auth.User'].objects.filter(groups__name='DomainAdmins'):
            dom = da.mailbox_set.all()[0].domain
            self.grant_access(orm, da, domct, dom)

            for mb in dom.mailbox_set.all():
                self.grant_access(orm, da, mbct, mb)
                self.grant_access(orm, da, uct, mb.user)
            for al in dom.alias_set.all():
                self.grant_access(orm, da, alct, al)

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("Cannot revert this migration")

    models = {
        'admin.alias': {
            'Meta': {'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['contenttypes', 'admin']

########NEW FILE########
__FILENAME__ = 0018_auto__add_unique_alias_domain_address
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding unique constraint on 'Alias', fields ['domain', 'address']
        db.create_unique('admin_alias', ['domain_id', 'address'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Alias', fields ['domain', 'address']
        db.delete_unique('admin_alias', ['domain_id', 'address'])


    models = {
        'admin.alias': {
            'Meta': {'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0019_set_default_group
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models


class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        try:
            sugroup = orm["auth.Group"].objects.get(name="SimpleUsers")
        except orm["auth.Group"].DoesNotExist:
            sugroup = orm["auth.Group"](name="SimpleUsers")
            sugroup.save()
        for account in orm['auth.User'].objects.all():
            if not len(account.groups.all()):
                account.groups.add(sugroup)
                account.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("Cannot reverse this migration")


    models = {
        'admin.alias': {
            'Meta': {'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0020_rename_amavis_ext
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models
from django.core.exceptions import ObjectDoesNotExist


class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        try:
            ext = orm["admin.Extension"].objects.get(name="amavis_quarantine")
        except ObjectDoesNotExist:
            return
        ext.name = "amavis"
        ext.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        try:
            ext = orm["admin.Extension"].objects.get(name="amavis")
        except ObjectDoesNotExist:
            return
        ext.name = "amavis_quarantine"
        ext.save()

    models = {
        'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0021_default_superadmin_ownership
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models
from django.core.exceptions import ObjectDoesNotExist


class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        try:
            su = orm['auth.User'].objects.get(pk=1)
        except ObjectDoesNotExist:
            return
        uct = orm['contenttypes.ContentType'].objects.get(
            app_label='auth', model='user'
        )
        su.objectaccess_set.filter(content_type=uct, object_id=1).update(is_owner=True)

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("Cannot revert this migration")

    models = {
        'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['contenttypes', 'admin']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0022_auto__del_field_mailbox_uid__del_field_mailbox_gid__del_field_mailbox_
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting field 'Mailbox.uid'
        db.delete_column('admin_mailbox', 'uid')

        # Deleting field 'Mailbox.gid'
        db.delete_column('admin_mailbox', 'gid')

        # Deleting field 'Mailbox.path'
        db.delete_column('admin_mailbox', 'path')


    def backwards(self, orm):

        # User chose to not deal with backwards NULL issues for 'Mailbox.uid'
        raise RuntimeError("Cannot reverse this migration. 'Mailbox.uid' and its values cannot be restored.")

        # User chose to not deal with backwards NULL issues for 'Mailbox.gid'
        raise RuntimeError("Cannot reverse this migration. 'Mailbox.gid' and its values cannot be restored.")

        # User chose to not deal with backwards NULL issues for 'Mailbox.path'
        raise RuntimeError("Cannot reverse this migration. 'Mailbox.path' and its values cannot be restored.")

    models = {
        'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0023_auto__add_quota
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'Quota'
        db.create_table('admin_quota', (
            ('username', self.gf('django.db.models.fields.EmailField')(max_length=75, primary_key=True)),
            ('bytes', self.gf('django.db.models.fields.IntegerField')(default=0)),
            ('messages', self.gf('django.db.models.fields.IntegerField')(default=0)),
        ))
        db.send_create_signal('admin', ['Quota'])


    def backwards(self, orm):
        # Deleting model 'Quota'
        db.delete_table('admin_quota')


    models = {
        'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'admin.quota': {
            'Meta': {'object_name': 'Quota'},
            'bytes': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'messages': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'username': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'primary_key': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0024_create_quotas
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models


class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        for mb in orm["admin.Mailbox"].objects.all():
            orm["admin.Quota"].objects.create(username="%s@%s" % (mb.address, mb.domain.name))

    def backwards(self, orm):
        "Write your backwards methods here."
        orm["admin.Quota"].objects.all().delete()

    models = {
        'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'admin.quota': {
            'Meta': {'object_name': 'Quota'},
            'bytes': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'messages': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'username': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'primary_key': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0025_auto__add_field_quota_mbox
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'Quota.mbox'
        db.add_column(u'admin_quota', 'mbox',
                      self.gf('django.db.models.fields.related.OneToOneField')(related_name='quota_value', unique=True, null=True, to=orm['admin.Mailbox']),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'Quota.mbox'
        db.delete_column(u'admin_quota', 'mbox_id')


    models = {
        u'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        u'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        u'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"})
        },
        u'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'admin.quota': {
            'Meta': {'object_name': 'Quota'},
            'bytes': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'mbox': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'quota_value'", 'unique': 'True', 'null': 'True', 'to': u"orm['admin.Mailbox']"}),
            'messages': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'username': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'primary_key': 'True'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0026_set_quota_mbox
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models


class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        for mb in orm["admin.Mailbox"].objects.all():
            q = orm["admin.Quota"].objects.get(username="%s@%s" % (mb.address, mb.domain.name))
            q.mbox = mb
            q.save()

    def backwards(self, orm):
        "Write your backwards methods here."

    models = {
        u'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        u'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        u'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"})
        },
        u'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'admin.quota': {
            'Meta': {'object_name': 'Quota'},
            'bytes': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'mbox': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'quota_value'", 'unique': 'True', 'null': 'True', 'to': u"orm['admin.Mailbox']"}),
            'messages': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'username': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'primary_key': 'True'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0027_auto__add_field_mailbox_use_domain_quota
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'Mailbox.use_domain_quota'
        db.add_column(u'admin_mailbox', 'use_domain_quota',
                      self.gf('django.db.models.fields.BooleanField')(default=False),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'Mailbox.use_domain_quota'
        db.delete_column(u'admin_mailbox', 'use_domain_quota')


    models = {
        u'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        u'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        u'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"})
        },
        u'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'use_domain_quota': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'admin.quota': {
            'Meta': {'object_name': 'Quota'},
            'bytes': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'mbox': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'quota_value'", 'unique': 'True', 'null': 'True', 'to': u"orm['admin.Mailbox']"}),
            'messages': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'username': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'primary_key': 'True'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0028_auto__chg_field_mailbox_quota
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'Mailbox.quota'
        db.alter_column(u'admin_mailbox', 'quota', self.gf('django.db.models.fields.PositiveIntegerField')())

    def backwards(self, orm):

        # Changing field 'Mailbox.quota'
        db.alter_column(u'admin_mailbox', 'quota', self.gf('django.db.models.fields.IntegerField')())

    models = {
        u'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        u'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        u'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"})
        },
        u'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'use_domain_quota': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'admin.quota': {
            'Meta': {'object_name': 'Quota'},
            'bytes': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'mbox': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'quota_value'", 'unique': 'True', 'null': 'True', 'to': u"orm['admin.Mailbox']"}),
            'messages': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'username': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'primary_key': 'True'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0029_auto__add_user__chg_field_mailbox_user__chg_field_objectaccess_user
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        db.rename_table('auth_user', 'admin_user')
        db.rename_table('auth_user_groups', 'admin_user_groups')
        db.rename_table('auth_user_user_permissions', 'admin_user_user_permissions')
        db.send_create_signal('admin', ['User'])

        # Changing field 'Mailbox.user'
        db.alter_column(u'admin_mailbox', 'user_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['admin.User']))
        # Changing field 'ObjectAccess.user'
        db.alter_column(u'admin_objectaccess', 'user_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['admin.User']))

    def backwards(self, orm):
        raise RuntimeError("Cannot revert this migration")

    models = {
        u'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        u'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        u'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"})
        },
        u'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'use_domain_quota': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'admin.quota': {
            'Meta': {'object_name': 'Quota'},
            'bytes': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'mbox': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'quota_value'", 'unique': 'True', 'null': 'True', 'to': u"orm['admin.Mailbox']"}),
            'messages': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'username': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'primary_key': 'True'})
        },
        u'admin.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0030_update_permissions
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        try:
            orig_ct = orm["contenttypes.ContentType"].objects.get(app_label="auth", name="user")
        except orm["contenttypes.ContentType"].DoesNotExist:
            return
        new_ct = orm["contenttypes.ContentType"].objects.get(app_label="admin", name="user")
        orm["auth.Permission"].objects.filter(content_type=orig_ct).update(content_type=new_ct)
        orig_ct.delete()

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("Cannot revert this migration")

    models = {
        u'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        u'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        u'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"})
        },
        u'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'use_domain_quota': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'admin.quota': {
            'Meta': {'object_name': 'Quota'},
            'bytes': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'mbox': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'quota_value'", 'unique': 'True', 'null': 'True', 'to': u"orm['admin.Mailbox']"}),
            'messages': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'username': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'primary_key': 'True'})
        },
        u'admin.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin', 'auth', 'contenttypes']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0031_auto__add_aliases_to_alias
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding M2M table for field aliases on 'Alias'
        db.create_table(u'admin_alias_aliases', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('from_alias', models.ForeignKey(orm[u'admin.alias'], null=False)),
            ('to_alias', models.ForeignKey(orm[u'admin.alias'], null=False))
        ))
        db.create_unique(u'admin_alias_aliases', ['from_alias_id', 'to_alias_id'])


    def backwards(self, orm):
        # Removing M2M table for field aliases on 'Alias'
        db.delete_table('admin_alias_aliases')


    models = {
        u'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'aliases': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Alias']", 'symmetrical': 'False'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        u'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        u'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"})
        },
        u'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'use_domain_quota': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'admin.quota': {
            'Meta': {'object_name': 'Quota'},
            'bytes': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'mbox': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'quota_value'", 'unique': 'True', 'null': 'True', 'to': u"orm['admin.Mailbox']"}),
            'messages': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'username': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'primary_key': 'True'})
        },
        u'admin.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']
########NEW FILE########
__FILENAME__ = 0032_auto__chg_field_quota_bytes
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'Quota.bytes'
        db.alter_column(u'admin_quota', 'bytes', self.gf('django.db.models.fields.BigIntegerField')())

    def backwards(self, orm):

        # Changing field 'Quota.bytes'
        db.alter_column(u'admin_quota', 'bytes', self.gf('django.db.models.fields.IntegerField')())

    models = {
        u'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'aliases': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Alias']", 'symmetrical': 'False'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        u'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        u'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"})
        },
        u'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'use_domain_quota': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'admin.quota': {
            'Meta': {'object_name': 'Quota'},
            'bytes': ('django.db.models.fields.BigIntegerField', [], {'default': '0'}),
            'mbox': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'quota_value'", 'unique': 'True', 'null': 'True', 'to': u"orm['admin.Mailbox']"}),
            'messages': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'username': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'primary_key': 'True'})
        },
        u'admin.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']
########NEW FILE########
__FILENAME__ = 0033_auto__chg_field_mailbox_address__chg_field_quota_username
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'Mailbox.address'
        db.alter_column(u'admin_mailbox', 'address', self.gf('django.db.models.fields.CharField')(max_length=252))

        # Changing field 'Quota.username'
        db.alter_column(u'admin_quota', 'username', self.gf('django.db.models.fields.EmailField')(max_length=254, primary_key=True))

    def backwards(self, orm):

        # Changing field 'Mailbox.address'
        db.alter_column(u'admin_mailbox', 'address', self.gf('django.db.models.fields.CharField')(max_length=100))

        # Changing field 'Quota.username'
        db.alter_column(u'admin_quota', 'username', self.gf('django.db.models.fields.EmailField')(max_length=75, primary_key=True))

    models = {
        u'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'aliases': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Alias']", 'symmetrical': 'False'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        u'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        u'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"})
        },
        u'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '252'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'use_domain_quota': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'admin.quota': {
            'Meta': {'object_name': 'Quota'},
            'bytes': ('django.db.models.fields.BigIntegerField', [], {'default': '0'}),
            'mbox': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'quota_value'", 'unique': 'True', 'null': 'True', 'to': u"orm['admin.Mailbox']"}),
            'messages': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'username': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'primary_key': 'True'})
        },
        u'admin.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']
########NEW FILE########
__FILENAME__ = 0034_auto__add_field_user_is_local
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'User.is_local'
        db.add_column('admin_user', 'is_local',
                      self.gf('django.db.models.fields.BooleanField')(default=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'User.is_local'
        db.delete_column('admin_user', 'is_local')


    models = {
        u'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'aliases': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Alias']", 'symmetrical': 'False'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        u'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        u'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"})
        },
        u'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '252'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'use_domain_quota': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'admin.quota': {
            'Meta': {'object_name': 'Quota'},
            'bytes': ('django.db.models.fields.BigIntegerField', [], {'default': '0'}),
            'mbox': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'quota_value'", 'unique': 'True', 'null': 'True', 'to': u"orm['admin.Mailbox']"}),
            'messages': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'username': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'primary_key': 'True'})
        },
        u'admin.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_local': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = 0035_set_local_flag
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Remember to use orm['appname.ModelName'] rather than "from appname.models..."
        for user in orm['admin.User'].objects.all():
            if user.password != '!':
                continue
            user.is_local = False
            user.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("Cannot revert this migration")

    models = {
        u'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'aliases': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Alias']", 'symmetrical': 'False'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        u'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        u'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"})
        },
        u'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '252'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'use_domain_quota': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'admin.quota': {
            'Meta': {'object_name': 'Quota'},
            'bytes': ('django.db.models.fields.BigIntegerField', [], {'default': '0'}),
            'mbox': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'quota_value'", 'unique': 'True', 'null': 'True', 'to': u"orm['admin.Mailbox']"}),
            'messages': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'username': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'primary_key': 'True'})
        },
        u'admin.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_local': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0036_auto__add_mailboxoperation
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'MailboxOperation'
        db.create_table(u'admin_mailboxoperation', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('mailbox', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['admin.Mailbox'], null=True, blank=True)),
            ('type', self.gf('django.db.models.fields.CharField')(max_length=20)),
            ('argument', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal(u'admin', ['MailboxOperation'])


    def backwards(self, orm):
        # Deleting model 'MailboxOperation'
        db.delete_table(u'admin_mailboxoperation')


    models = {
        u'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'aliases': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Alias']", 'symmetrical': 'False'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        u'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        u'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"})
        },
        u'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '252'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'use_domain_quota': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.mailboxoperation': {
            'Meta': {'object_name': 'MailboxOperation'},
            'argument': ('django.db.models.fields.TextField', [], {}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mailbox': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Mailbox']", 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '20'})
        },
        u'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'admin.quota': {
            'Meta': {'object_name': 'Quota'},
            'bytes': ('django.db.models.fields.BigIntegerField', [], {'default': '0'}),
            'mbox': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'quota_value'", 'unique': 'True', 'null': 'True', 'to': u"orm['admin.Mailbox']"}),
            'messages': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'username': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'primary_key': 'True'})
        },
        u'admin.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_local': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin']
########NEW FILE########
__FILENAME__ = 0037_rename_tables
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    depends_on = (
        ('core', '0001_initial'),
    )

    def forwards(self, orm):
        db.rename_table('admin_user', 'core_user')
        # Changing field 'Mailbox.user'
        db.alter_column(u'admin_mailbox', 'user_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.User']))

        db.rename_table('admin_objectaccess', 'core_objectaccess')
        db.alter_column(u'core_objectaccess', 'user_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.User']))

        db.rename_table('admin_user_groups', 'core_user_groups')
        db.rename_table('admin_user_user_permissions', 'core_user_user_permissions')

        db.rename_table('admin_extension', 'core_extension')

    def backwards(self, orm):
        db.rename_table('core_user', 'admin_user')
        # Changing field 'Mailbox.user'
        db.alter_column(u'admin_mailbox', 'user_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['admin.User']))

        db.rename_table('core_objectaccess', 'admin_objectaccess')
        db.alter_column(u'admin_objectaccess', 'user_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['admin.User']))

        db.rename_table('core_user_groups', 'admin_user_groups')
        db.rename_table('core_user_user_permissions', 'admin_user_user_permissions')

        db.rename_table('core_extension', 'admin_extension')

    models = {
        'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'aliases': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Alias']", 'symmetrical': 'False'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '252'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'use_domain_quota': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['core.User']"})
        },
        u'admin.mailboxoperation': {
            'Meta': {'object_name': 'MailboxOperation'},
            'argument': ('django.db.models.fields.TextField', [], {}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mailbox': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Mailbox']", 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '20'})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'admin.quota': {
            'Meta': {'object_name': 'Quota'},
            'bytes': ('django.db.models.fields.BigIntegerField', [], {'default': '0'}),
            'mbox': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'quota_value'", 'unique': 'True', 'null': 'True', 'to': "orm['admin.Mailbox']"}),
            'messages': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'username': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'primary_key': 'True'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'core.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['core.User']"})
        },
        u'core.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_local': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        }
    }

    complete_apps = ['admin']

########NEW FILE########
__FILENAME__ = alias
import reversion
from django.db import models
from django.utils.translation import ugettext as _, ugettext_lazy
from modoboa.lib.emailutils import split_mailbox
from modoboa.lib.exceptions import (
    PermDeniedException, BadRequest, Conflict
)
from .base import AdminObject
from .domain import Domain
from .mailbox import Mailbox


class Alias(AdminObject):
    """
    Mailbox alias.
    """
    address = models.CharField(
        ugettext_lazy('address'), max_length=254,
        help_text=ugettext_lazy(
            "The alias address (without the domain part). For a 'catch-all' "
            "address, just enter an * character."
        )
    )
    domain = models.ForeignKey(Domain)
    mboxes = models.ManyToManyField(
        Mailbox, verbose_name=ugettext_lazy('mailboxes'),
        help_text=ugettext_lazy("The mailboxes this alias points to")
    )
    aliases = models.ManyToManyField(
        'Alias',
        help_text=ugettext_lazy("The aliases this alias points to")
    )
    extmboxes = models.TextField(blank=True)
    enabled = models.BooleanField(
        ugettext_lazy('enabled'),
        help_text=ugettext_lazy("Check to activate this alias")
    )
    _objectname = 'MailboxAlias'

    class Meta:
        permissions = (
            ("view_aliases", "View aliases"),
        )
        unique_together = (("address", "domain"),)
        ordering = ["domain__name", "address"]
        app_label = 'admin'

    def __unicode__(self):
        return self.full_address

    @property
    def full_address(self):
        return "%s@%s" % (self.address, self.domain.name)

    @property
    def identity(self):
        return self.full_address

    @property
    def name_or_rcpt(self):
        rcpts_count = self.get_recipients_count()
        if not rcpts_count:
            return "---"
        rcpts = self.get_recipients()
        if rcpts_count > 1:
            return "%s, ..." % rcpts[0]
        return rcpts[0]

    @property
    def type(self):
        cpt = self.get_recipients_count()
        if cpt > 1:
            return "dlist"
        if self.extmboxes != "":
            return "forward"
        return "alias"

    @property
    def tags(self):
        labels = {
            "dlist": _("distribution list"),
            "forward": _("forward"),
            "alias": _("alias")
        }
        altype = self.type
        return [{"name": altype, "label": labels[altype], "type": "idt"}]

    def post_create(self, creator):
        from modoboa.lib.permissions import grant_access_to_object
        super(Alias, self).post_create(creator)
        if creator.is_superuser:
            for admin in self.domain.admins:
                grant_access_to_object(admin, self)

    def save(self, *args, **kwargs):
        if 'ext_rcpts' in kwargs:
            self.extmboxes = ",".join(kwargs['ext_rcpts']) \
                if kwargs['ext_rcpts'] else ""
            del kwargs['ext_rcpts']
        if 'int_rcpts' in kwargs:
            int_rcpts = kwargs['int_rcpts']
            del kwargs['int_rcpts']
        else:
            int_rcpts = []
        super(Alias, self).save(*args, **kwargs)
        curaliases = self.aliases.all()
        curmboxes = self.mboxes.all()
        for t in int_rcpts:
            if isinstance(t, Alias):
                if not t in curaliases:
                    self.aliases.add(t)
                continue
            if not t in curmboxes:
                self.mboxes.add(t)
        for t in curaliases:
            if not t in int_rcpts:
                self.aliases.remove(t)
        for t in curmboxes:
            if not t in int_rcpts:
                self.mboxes.remove(t)

    def get_recipients(self, with_external=True):
        """Return the recipients list.

        Internal and external addresses are mixed into a single list.

        :param bool with_external: include external addresses or not
        :rtype: list
        :return: a list of addresses
        """
        result = [al.full_address for al in self.aliases.all()]
        result += [mb.full_address for mb in self.mboxes.all()]
        if with_external and self.extmboxes != "":
            result += self.extmboxes.split(',')
        return result

    def get_recipients_count(self):
        """Return the number of recipients of this alias.

        :rtype: int
        """
        total = 0
        if self.extmboxes != "":
            total += len(self.extmboxes.split(','))
        return total + self.aliases.count() + self.mboxes.count()

    def from_csv(self, user, row, expected_elements=5):
        """Create a new alias from a CSV file entry

        """
        if len(row) < expected_elements:
            raise BadRequest(_("Invalid line: %s" % row))
        localpart, domname = split_mailbox(row[1].strip())
        try:
            domain = Domain.objects.get(name=domname)
        except Domain.DoesNotExist:
            raise BadRequest(_("Domain '%s' does not exist" % domname))
        if not user.can_access(domain):
            raise PermDeniedException
        try:
            Alias.objects.get(address=localpart, domain__name=domain)
        except Alias.DoesNotExist:
            pass
        else:
            raise Conflict
        self.address = localpart
        self.domain = domain
        self.enabled = (row[2].strip() == 'True')
        int_rcpts = []
        ext_rcpts = []
        for rcpt in row[3:]:
            rcpt = rcpt.strip()
            if not rcpt:
                continue
            localpart, domname = split_mailbox(rcpt)
            try:
                Domain.objects.get(name=domname)
            except Domain.DoesNotExist:
                ext_rcpts += [rcpt]
                continue
            try:
                target = Alias.objects.get(
                    domain__name=domname, address=localpart
                )
                if target.full_address == self.full_address:
                    target = None
            except Alias.DoesNotExist:
                target = None
            if target is None:
                try:
                    target = Mailbox.objects.get(address=localpart,
                                                 domain__name=domname)
                except Mailbox.DoesNotExist:
                    raise BadRequest(_("Local recipient %s not found" % rcpt))
            int_rcpts += [target]
        self.save(int_rcpts=int_rcpts, ext_rcpts=ext_rcpts, creator=user)

    def to_csv(self, csvwriter):
        row = [self.type, self.full_address.encode("utf-8"), self.enabled]
        row += self.get_recipients()
        csvwriter.writerow(row)

reversion.register(Alias)

########NEW FILE########
__FILENAME__ = base
from django.db import models
from modoboa.lib import events
from modoboa.lib.permissions import (
    grant_access_to_object, ungrant_access_to_object
)


class ObjectDates(models.Model):
    """Dates recording for admin objects

    This table keeps creation and last modification dates for Domains,
    domain aliases, mailboxes and aliases objects.
    """
    creation = models.DateTimeField(auto_now_add=True)
    last_modification = models.DateTimeField(auto_now=True)

    class Meta:
        app_label = 'admin'

    @staticmethod
    def set_for_object(obj):
        """Initialize or update dates for a given object.

        :param obj: an admin object (Domain, Mailbox, etc)
        """
        try:
            dates = getattr(obj, "dates")
        except ObjectDates.DoesNotExist:
            dates = ObjectDates()
        dates.save()
        obj.dates = dates


class AdminObject(models.Model):
    """Abstract model to support dates

    Inherit from this model to automatically add the "dates" feature
    to another model. It defines the appropriate field and handles
    saves.
    """
    dates = models.ForeignKey(ObjectDates)
    _objectname = None

    class Meta:
        abstract = True

    @property
    def creation(self):
        return self.dates.creation

    @property
    def last_modification(self):
        return self.dates.last_modification

    @property
    def objectname(self):
        if self._objectname is None:
            return self.__class__.__name__
        return self._objectname

    def post_create(self, creator):
        grant_access_to_object(creator, self, is_owner=True)
        events.raiseEvent("%sCreated" % self.objectname, creator, self)

    def save(self, *args, **kwargs):
        ObjectDates.set_for_object(self)
        if "creator" in kwargs:
            creator = kwargs["creator"]
            del kwargs["creator"]
        else:
            creator = None
        super(AdminObject, self).save(*args, **kwargs)
        if creator is not None:
            self.post_create(creator)

    def delete(self):
        events.raiseEvent("%sDeleted" % self.objectname, self)
        ungrant_access_to_object(self)
        super(AdminObject, self).delete()

########NEW FILE########
__FILENAME__ = domain
import reversion
from django.db import models
from django.db.models.manager import Manager
from django.utils.translation import ugettext as _, ugettext_lazy
from django.contrib.contenttypes import generic
from modoboa.lib import events, parameters
from modoboa.lib.exceptions import BadRequest, Conflict
from modoboa.core.models import User, ObjectAccess
from .base import AdminObject


class DomainManager(Manager):

    def get_for_admin(self, admin):
        """Return the domains belonging to this admin

        The result is a ``QuerySet`` object, so this function can be used
        to fill ``ModelChoiceField`` objects.
        """
        if admin.is_superuser:
            return self.get_query_set()
        return self.get_query_set().filter(owners__user=admin)


class Domain(AdminObject):
    """Mail domain.
    """
    name = models.CharField(ugettext_lazy('name'), max_length=100, unique=True,
                            help_text=ugettext_lazy("The domain name"))
    quota = models.IntegerField()
    enabled = models.BooleanField(
        ugettext_lazy('enabled'),
        help_text=ugettext_lazy("Check to activate this domain")
    )
    owners = generic.GenericRelation(ObjectAccess)

    objects = DomainManager()

    class Meta:
        permissions = (
            ("view_domain", "View domain"),
            ("view_domains", "View domains"),
        )
        ordering = ["name"]
        app_label = 'admin'

    @property
    def domainalias_count(self):
        return self.domainalias_set.count()

    @property
    def mailbox_count(self):
        return self.mailbox_set.count()

    @property
    def mbalias_count(self):
        return self.alias_set.count()

    @property
    def tags(self):
        return [{"name": "domain", "label": _("Domain"), "type": "dom"}]

    @property
    def admins(self):
        """Return the domain administrators of this domain

        :return: a list of User objects
        """
        return [oa.user for oa in self.owners.filter(user__is_superuser=False)]

    @property
    def aliases(self):
        return self.domainalias_set

    def add_admin(self, account):
        """Add a new administrator for this domain

        :param User account: the administrotor to add
        """
        from modoboa.lib.permissions import grant_access_to_object
        grant_access_to_object(account, self)
        for mb in self.mailbox_set.all():
            if mb.user.has_perm("admin.add_domain"):
                continue
            grant_access_to_object(account, mb)
            grant_access_to_object(account, mb.user)
        for al in self.alias_set.all():
            grant_access_to_object(account, al)

    def remove_admin(self, account):
        """Remove an administrator of this domain.

        :param User account: administrator to remove
        """
        from modoboa.lib.permissions import \
            ungrant_access_to_object, get_object_owner

        if get_object_owner(self) == account:
            events.raiseEvent('DomainOwnershipRemoved', account, self)
        ungrant_access_to_object(self, account)
        for mb in self.mailbox_set.all():
            if mb.user.has_perm("admin.add_domain"):
                continue
            ungrant_access_to_object(mb, account)
            ungrant_access_to_object(mb.user, account)
        for al in self.alias_set.all():
             ungrant_access_to_object(al, account)

    def delete(self, fromuser, keepdir=False):
        """Custom delete method.
        """
        from modoboa.lib.permissions import ungrant_access_to_objects
        from .mailbox import Quota

        if self.domainalias_set.count():
            events.raiseEvent("DomainAliasDeleted", self.domainalias_set.all())
            ungrant_access_to_objects(self.domainalias_set.all())
        if self.alias_set.count():
            events.raiseEvent("MailboxAliasDeleted", self.alias_set.all())
            ungrant_access_to_objects(self.alias_set.all())
        if parameters.get_admin("AUTO_ACCOUNT_REMOVAL") == "yes":
            for account in User.objects.filter(mailbox__domain__name=self.name):
                account.delete(fromuser, keepdir)
        elif self.mailbox_set.count():
            Quota.objects.filter(username__contains='@%s' % self.name).delete()
            events.raiseEvent("MailboxDeleted", self.mailbox_set.all())
            ungrant_access_to_objects(self.mailbox_set.all())
        super(Domain, self).delete()

    def __str__(self):
        return self.name

    def from_csv(self, user, row):
        """Create a new domain from a CSV entry.

        The expected fields order is the following::

          "domain", name, quota, enabled

        :param ``core.User`` user: user creating the domain
        :param str row: a list containing domain's definition
        """
        if len(row) < 4:
            raise BadRequest(_("Invalid line"))
        self.name = row[1].strip()
        try:
            Domain.objects.get(name=self.name)
        except Domain.DoesNotExist:
            pass
        else:
            raise Conflict
        try:
            self.quota = int(row[2].strip())
        except ValueError:
            raise BadRequest(_("Invalid quota value for domain '%s'" % self.name))
        self.enabled = (row[3].strip() == 'True')
        self.save(creator=user)

    def to_csv(self, csvwriter):
        csvwriter.writerow(["domain", self.name, self.quota, self.enabled])
        for dalias in self.domainalias_set.all():
            dalias.to_csv(csvwriter)

    def post_create(self, creator):
        """Post creation actions.

        :param ``User`` creator: user whos created this domain
        """
        super(Domain, self).post_create(creator)
        for domalias in self.domainalias_set.all():
            domalias.post_create(creator)

reversion.register(Domain)

########NEW FILE########
__FILENAME__ = domain_alias
import reversion
from django.db import models
from django.utils.translation import ugettext as _, ugettext_lazy
from modoboa.lib.exceptions import BadRequest, Conflict
from .base import AdminObject
from .domain import Domain


class DomainAlias(AdminObject):
    name = models.CharField(ugettext_lazy("name"), max_length=100, unique=True,
                            help_text=ugettext_lazy("The alias name"))
    target = models.ForeignKey(
        Domain, verbose_name=ugettext_lazy('target'),
        help_text=ugettext_lazy("The domain this alias points to")
    )
    enabled = models.BooleanField(
        ugettext_lazy('enabled'),
        help_text=ugettext_lazy("Check to activate this alias")
    )

    class Meta:
        permissions = (
            ("view_domaliases", "View domain aliases"),
        )
        app_label = 'admin'

    def __unicode__(self):
        return self.name

    def from_csv(self, user, row):
        """Create a domain alias from a CSV row

        Expected format: ["domainalias", domain alias name, targeted domain, enabled]

        :param user: a ``User`` object
        :param row: a list containing the alias definition
        """
        if len(row) < 4:
            raise BadRequest(_("Invalid line"))
        self.name = row[1].strip()
        for model in [DomainAlias, Domain]:
            try:
                model.objects.get(name=self.name)
            except model.DoesNotExist:
                pass
            else:
                raise Conflict
        domname = row[2].strip()
        try:
            self.target = Domain.objects.get(name=domname)
        except Domain.DoesNotExist:
            raise BadRequest(_("Unknown domain %s" % domname))
        self.enabled = row[3].strip() == 'True'
        self.save(creator=user)

    def to_csv(self, csvwriter):
        """Export a domain alias using CSV format

        :param csvwriter: a ``csv.writer`` object
        """
        csvwriter.writerow(["domainalias", self.name,
                            self.target.name, self.enabled])

reversion.register(DomainAlias)

########NEW FILE########
__FILENAME__ = mailbox
import os
import pwd
import reversion
from django.db import models
from django.db.models import Q
from django.db.models.manager import Manager
from django.contrib.contenttypes.models import ContentType
from django.utils.translation import ugettext as _, ugettext_lazy
from django.db.models.signals import pre_delete
from django.dispatch import receiver
from modoboa.lib import parameters, events
from modoboa.lib.exceptions import BadRequest, InternalError
from modoboa.lib.sysutils import exec_cmd
from modoboa.core.models import User
from .base import AdminObject
from .domain import Domain


class MailboxManager(Manager):

    def get_for_admin(self, admin, squery=None):
        """Return the mailboxes that belong to this admin.

        The result will contain the mailboxes defined for each domain that
        user can see.

        :param string squery: a search query
        :return: a list of ``Mailbox`` objects
        """
        qf = None
        if squery is not None:
            if '@' in squery:
                parts = squery.split('@')
                addrfilter = '@'.join(parts[:-1])
                domfilter = parts[-1]
                qf = Q(address__contains=addrfilter) & Q(domain__name__contains=domfilter)
            else:
                qf = Q(address__contains=squery) | Q(domain__name__contains=squery)
        ids = admin.objectaccess_set \
            .filter(content_type=ContentType.objects.get_for_model(Mailbox)) \
            .values_list('object_id', flat=True)
        if qf is not None:
            qf = Q(pk__in=ids) & qf
        else:
            qf = Q(pk__in=ids)
        return self.get_query_set().filter(qf)


class Mailbox(AdminObject):
    address = models.CharField(
        ugettext_lazy('address'), max_length=252,
        help_text=ugettext_lazy("Mailbox address (without the @domain.tld part)")
    )
    quota = models.PositiveIntegerField()
    use_domain_quota = models.BooleanField(default=False)
    domain = models.ForeignKey(Domain)
    user = models.ForeignKey(User)

    objects = MailboxManager()

    class Meta:
        permissions = (
            ("view_mailboxes", "View mailboxes"),
        )
        app_label = 'admin'

    def __init__(self, *args, **kwargs):
        super(Mailbox, self).__init__(*args, **kwargs)
        self.__mail_home = None

    def __str__(self):
        return self.full_address

    def __full_address(self, localpart):
        return "%s@%s" % (localpart, self.domain.name)

    @property
    def full_address(self):
        return self.__full_address(self.address)

    @property
    def enabled(self):
        return self.user.is_active

    @property
    def alias_count(self):
        return self.alias_set.count()

    @property
    def mail_home(self):
        """Retrieve the home directory of this mailbox.
 
        The home directory refers to the place on the file system
        where the mailbox data is stored.

        We ask dovecot to give us this information because there are
        several patterns to understand and we don't want to implement
        them.        
        """
        hm = parameters.get_admin("HANDLE_MAILBOXES", raise_error=False)
        if hm is None or hm == "no":
            return None
        if self.__mail_home is None:
            curuser = pwd.getpwuid(os.getuid()).pw_name
            mbowner = parameters.get_admin("MAILBOXES_OWNER")
            options = {}
            if curuser != mbowner:
                options['sudo_user'] = mbowner
            code, output = exec_cmd(
                "doveadm user %s -f home" % self.full_address, **options
            ) 
            if code:
                raise InternalError(_("Failed to retrieve mailbox location (%s)" % output))
            self.__mail_home = output.strip()
        return self.__mail_home

    @property
    def alias_addresses(self):
        """Return all alias address of this mailbox.

        :rtype: list of string
        """
        aliases = []
        for alias in self.alias_set.all():
            aliases += [alias.full_address]
        return aliases

    def rename_dir(self, old_mail_home):
        hm = parameters.get_admin("HANDLE_MAILBOXES", raise_error=False)
        if hm is None or hm == "no":
            return
        MailboxOperation.objects.create(
            mailbox=self, type='rename', argument=old_mail_home
        )

    def rename(self, address, domain):
        """Rename the mailbox

        :param string address: the new mailbox's address (local part)
        :param Domain domain: the new mailbox's domain
        """
        old_mail_home = self.mail_home
        qs = Quota.objects.filter(username=self.full_address)
        self.address = address
        self.domain = domain
        qs.update(username=self.full_address)
        self.rename_dir(old_mail_home)

    def delete_dir(self):
        hm = parameters.get_admin("HANDLE_MAILBOXES", raise_error=False)
        if hm is None or hm == "no":
            return
        MailboxOperation.objects.create(type='delete', argument=self.mail_home)

    def set_quota(self, value=None, override_rules=False):
        """Set or update quota's value for this mailbox.

        A value equal to 0 means the mailbox won't have any quota. The
        following cases allow people to define such behaviour:
        * The domain has no quota
        * :keyword:`override_rules` is True

        :param integer value: the quota's value
        :param bool override_rules: allow to override defined quota rules
        """
        if value is None:
            if self.use_domain_quota:
                self.quota = self.domain.quota
            else:
                self.quota = 0
        elif int(value) > self.domain.quota and not override_rules:
            raise BadRequest(
                _("Quota is greater than the allowed domain's limit (%dM)" % self.domain.quota)
            )
        else:
            self.quota = value
        if not self.quota and self.domain.quota and not override_rules:
            raise BadRequest(_("A quota is required"))

    def get_quota(self):
        """Get quota limit.
        
        :rtype: int
        """
        q = Quota.objects.get(username=self.full_address)
        return int(q.bytes / 1048576)

    def get_quota_in_percent(self):
        """Get current quota usage.

        :rtype: int
        """
        if not self.quota:
            return 0
        q = Quota.objects.get(username=self.full_address)
        return int(q.bytes / float(self.quota * 1048576) * 100)

    def post_create(self, creator):
        from modoboa.lib.permissions import grant_access_to_object
        super(Mailbox, self).post_create(creator)
        if creator.is_superuser and not self.user.has_perm("admin.add_domain"):
            # A super user is creating a new mailbox. Give
            # access to that mailbox (and the associated
            # account) to the appropriate domain admins,
            # except if the new account has a more important
            # role (SuperAdmin, Reseller)
            for admin in self.domain.admins:
                grant_access_to_object(admin, self)
                grant_access_to_object(admin, self.user)

    def save(self, *args, **kwargs):
        super(Mailbox, self).save(*args, **kwargs)
        try:
            q = self.quota_value
        except Quota.DoesNotExist:
            Quota.objects.create(mbox=self, username=self.full_address)

    def delete(self, keepdir=False):
        """Custom delete method

        We try to delete the associated quota in the same time (it may
        has already been removed if we're deleting a domain).

        :param bool keepdir: delete the mailbox home dir on the filesystem or not
        """
        try:
            q = Quota.objects.get(username=self.full_address)
        except Quota.DoesNotExist:
            pass
        else:
            q.delete()
        if not keepdir:
            self.delete_dir()
        super(Mailbox, self).delete()

reversion.register(Mailbox)


@receiver(pre_delete, sender=Mailbox)
def mailbox_deleted_handler(sender, **kwargs):
    """``Mailbox`` pre_delete signal receiver

    In order to properly handle deletions (ie. we don't want to leave
    orphan records into the db), we define this custom receiver.

    It manually removes the mailbox from the aliases it is linked to
    and then remove all empty aliases.
    """
    from modoboa.lib.permissions import ungrant_access_to_object

    mb = kwargs['instance']
    events.raiseEvent("MailboxDeleted", mb)
    ungrant_access_to_object(mb)
    for alias in mb.alias_set.all():
        alias.mboxes.remove(mb)
        if alias.mboxes.count() == 0:
            alias.delete()


class Quota(models.Model):
    username = models.EmailField(primary_key=True, max_length=254)
    bytes = models.BigIntegerField(default=0)
    messages = models.IntegerField(default=0)

    mbox = models.OneToOneField(Mailbox, related_name="quota_value", null=True)

    class Meta:
        app_label = 'admin'


class MailboxOperation(models.Model):
    mailbox = models.ForeignKey(Mailbox, blank=True, null=True)
    type = models.CharField(
        max_length=20, choices=(('rename', 'rename'), ('delete', 'delete'))
    )
    argument = models.TextField()

    class Meta:
        app_label = 'admin'

    def __str__(self):
        if self.type == 'rename':
            return 'Rename %s -> %s' % (self.argument, self.mailbox.mail_home)
        return 'Delete %s' % self.argument 

########NEW FILE########
__FILENAME__ = tables
# coding: utf-8
from django.utils.translation import ugettext_lazy
from modoboa.lib import tables


class ExtensionsTable(tables.Table):
    idkey = "id"
    selection = tables.SelectionColumn("selection", width="4%", header=False)
    label = tables.Column("label", label=ugettext_lazy("Name"), width="15%")
    version = tables.Column(
        "version", label=ugettext_lazy("Version"), width="6%"
    )
    descr = tables.Column("description", label=ugettext_lazy("Description"))

    cols_order = ["selection", "label", "version", "descr"]

########NEW FILE########
__FILENAME__ = admin_tags
from django import template
from django.template.loader import render_to_string
from django.utils.translation import ugettext as _, ugettext_lazy
from django.core.urlresolvers import reverse
from modoboa.lib import events
from modoboa.lib.webutils import render_actions
from modoboa.lib.templatetags.lib_tags import render_link

register = template.Library()

genders = {
    "Enabled": (ugettext_lazy("enabled_m"), ugettext_lazy("enabled_f"))
}


@register.simple_tag
def domains_menu(selection, user):
    """Specific menu for domain related operations.

    Corresponds to the menu visible on the left column when you go to
    Domains.

    :param str selection: menu entry currently selected
    :param ``User`` user: connected user
    :rtype: str
    :return: rendered menu (as HTML)
    """
    if not user.has_perm("admin.add_domain"):
        return ""

    entries = [
        {"name": "newdomain",
         "label": _("Add domain"),
         "img": "icon-plus",
         "modal": True,
         "modalcb": "admin.newdomain_cb",
         "url": reverse("modoboa.extensions.admin.views.domain.newdomain")},
    ]
    entries += events.raiseQueryEvent("ExtraDomainMenuEntries", user)
    entries += [
        {"name": "import",
         "label": _("Import"),
         "img": "icon-folder-open",
         "url": reverse("modoboa.extensions.admin.views.import.import_domains"),
         "modal": True,
         "modalcb": "admin.importform_cb"},
        {"name": "export",
         "label": _("Export"),
         "img": "icon-share-alt",
         "url": reverse("modoboa.extensions.admin.views.export.export_domains"),
         "modal": True,
         "modalcb": "admin.exportform_cb"}
    ]

    return render_to_string('common/menulist.html', {
        "entries": entries,
        "selection": selection,
        "user": user
    })


@register.simple_tag
def identities_menu(user):
    """Menu specific to the Identities page.

    :param ``User`` user: the connecter user
    :rtype: str
    :return: the rendered menu
    """
    entries = [
        {"name": "identities",
         "label": _("List identities"),
         "img": "icon-user",
         "class": "ajaxlink",
         "url": "list/"},
        {"name": "quotas",
         "label": _("List quotas"),
         "img": "icon-hdd",
         "class": "ajaxlink",
         "url": "quotas/"},
        {"name": "newaccount",
         "label": _("Add account"),
         "img": "icon-plus",
         "modal": True,
         "modalcb": "admin.newaccount_cb",
         "url": reverse("modoboa.extensions.admin.views.identity.newaccount")},
        {"name": "newalias",
         "label": _("Add alias"),
         "img": "icon-plus",
         "modal": True,
         "modalcb": "admin.aliasform_cb",
         "url": reverse("modoboa.extensions.admin.views.alias.newalias")},
        {"name": "newforward",
         "label": _("Add forward"),
         "img": "icon-plus",
         "modal": True,
         "modalcb": "admin.aliasform_cb",
         "url": reverse("modoboa.extensions.admin.views.alias.newforward")},
        {"name": "newdlist",
         "label": _("Add distribution list"),
         "img": "icon-plus",
         "modal": True,
         "modalcb": "admin.aliasform_cb",
         "url": reverse("modoboa.extensions.admin.views.alias.newdlist")},
        {"name": "import",
         "label": _("Import"),
         "img": "icon-folder-open",
         "url": reverse("modoboa.extensions.admin.views.import.import_identities"),
         "modal": True,
         "modalcb": "admin.importform_cb"},
        {"name": "export",
         "label": _("Export"),
         "img": "icon-share-alt",
         "url": reverse("modoboa.extensions.admin.views.export.export_identities"),
         "modal": True,
         "modalcb": "admin.exportform_cb"
         }
    ]

    return render_to_string('common/menulist.html', {
        "entries": entries,
        "user": user
    })


@register.simple_tag
def domain_actions(user, domain):
    actions = []
    if domain.__class__.__name__ == 'Domain':
        actions = [
            {"name": "listidentities",
             "url": reverse("modoboa.extensions.admin.views.identity.identities") + "#list/?searchquery=@%s" % domain.name,
             "title": _("View the domain's identities"),
             "img": "icon-user"}
        ]
        if user.has_perm("admin.delete_domain"):
            actions.append({
                "name": "deldomain",
                "url": reverse(
                    "modoboa.extensions.admin.views.domain.deldomain",
                    args=[domain.id]
                ),
                "title": _("Delete %s?" % domain.name),
                "img": "icon-trash"
            })
    else:
        actions = events.raiseQueryEvent('GetDomainActions', user, domain)

    return render_actions(actions)


@register.simple_tag
def identity_actions(user, ident):
    name = ident.__class__.__name__
    objid = ident.id
    if name == "User":
        actions = events.raiseQueryEvent("ExtraAccountActions", ident)
        actions += [
            {"name": "delaccount",
             "url": reverse("modoboa.extensions.admin.views.identity.delaccount", args=[objid]),
             "img": "icon-trash",
             "title": _("Delete %s?" % ident.username)},
        ]
    else:
        actions = [
            {"name": "delalias",
             "url": reverse("modoboa.extensions.admin.views.alias.delalias") + "?selection=%s" % objid,
             "img": "icon-trash",
             "title": _("Delete %s?" % ident.full_address)},
        ]
    return render_actions(actions)


@register.simple_tag
def domain_modify_link(domain):
    linkdef = {"label": domain.name, "modal": True}
    if domain.__class__.__name__ == "Domain":
        linkdef["url"] = reverse(
            "modoboa.extensions.admin.views.domain.editdomain",
            args=[domain.id]
        )
        linkdef["modalcb"] = "admin.domainform_cb"
    else:
        tmp = events.raiseDictEvent('GetDomainModifyLink', domain)
        for key in ['url', 'modalcb']:
            linkdef[key] = tmp[key]
    return render_link(linkdef)


@register.simple_tag
def domain_aliases(domain):
    """Display domain aliases of this domain.

    :param domain:
    :rtype: str
    """
    if not domain.aliases.count():
        return '---'
    res = ''
    for alias in domain.aliases.all():
        res += '%s<br/>' % alias.name
    return res


@register.simple_tag
def identity_modify_link(identity, active_tab='default'):
    """Return the appropriate modification link.

    According to the identity type, a specific modification link (URL)
    must be used.

    :param identity: a ``User`` or ``Alias`` instance
    :param str active_tab: the tab to display
    :rtype: str
    """
    linkdef = {"label": identity.identity, "modal": True}
    if identity.__class__.__name__ == "User":
        linkdef["url"] = reverse(
            "modoboa.extensions.admin.views.identity.editaccount",
            args=[identity.id]
        )
        linkdef["url"] += "?active_tab=%s" % active_tab
        linkdef["modalcb"] = "admin.editaccount_cb"
    else:
        linkdef["url"] = reverse(
            "modoboa.extensions.admin.views.alias.editalias",
            args=[identity.id]
        )
        linkdef["modalcb"] = "admin.aliasform_cb"
    return render_link(linkdef)


@register.simple_tag
def domadmin_actions(daid, domid):
    actions = [{
        "name": "removeperm",
        "url": reverse("modoboa.extensions.admin.views.identity.remove_permission") + "?domid=%s&daid=%s" % (domid, daid),
        "img": "icon-trash",
        "title": _("Remove this permission")
    }]
    return render_actions(actions)


@register.filter
def gender(value, target):
    if value in genders:
        trans = target == "m" and genders[value][0] or genders[value][1]
        if trans.find("_") == -1:
            return trans
    return value


@register.simple_tag
def get_extra_admin_content(user, target, currentpage):
    res = events.raiseQueryEvent(
        "ExtraAdminContent", user, target, currentpage
    )
    return "".join(res)


@register.simple_tag
def disable_identity(identity):
    """Disable an identity.

    Finding this information depends on the identity type.
    """
    if identity.__class__.__name__ == "User":
        if identity.is_active and identity.mailbox_set.count() \
           and identity.mailbox_set.all()[0].domain.enabled:
            return ""
    elif identity.enabled and identity.domain.enabled:
        return ""
    return "muted"

########NEW FILE########
__FILENAME__ = account
from django.core.urlresolvers import reverse
from modoboa.core.models import User
from modoboa.lib.tests import ModoTestCase
from modoboa.extensions.admin.models import (
    Domain, Mailbox
)
from modoboa.extensions.admin import factories


class AccountTestCase(ModoTestCase):
    fixtures = ["initial_users.json"]

    def setUp(self):
        super(AccountTestCase, self).setUp()
        factories.populate_database()

    def test_crud(self):
        values = dict(
            username="tester@test.com", first_name="Tester", last_name="Toto",
            password1="toto", password2="toto", role="SimpleUsers",
            quota_act=True,
            is_active=True, email="tester@test.com", stepid='step2'
        )
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.newaccount"),
            values
        )

        account = User.objects.get(username="tester@test.com")
        mb = account.mailbox_set.all()[0]
        self.assertEqual(mb.full_address, "tester@test.com")
        self.assertEqual(mb.quota, 10)
        self.assertEqual(mb.enabled, True)
        self.assertEqual(mb.quota_value.username, "tester@test.com")
        self.assertEqual(account.username, mb.full_address)
        self.assertTrue(account.check_password("toto"))
        self.assertEqual(account.first_name, "Tester")
        self.assertEqual(account.last_name, "Toto")
        self.assertEqual(mb.domain.mailbox_count, 3)

        values["username"] = "pouet@test.com"
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[account.id]),
            values
        )
        mb = Mailbox.objects.get(pk=mb.id)
        self.assertEqual(mb.full_address, "pouet@test.com")
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.delaccount",
                    args=[account.id]),
            {}
        )

    def _set_quota(self, email, value, expected_status=200):
        account = User.objects.get(username=email)
        values = {
            "username": email, "role": "SimpleUsers", "quota_act": False,
            "is_active": True, "quota": value, "email": email
        }
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[account.id]),
            values, status=expected_status
        )

    def test_set_nul_quota_as_superadmin(self):
        self._set_quota("user@test.com", 0)

    def test_set_nul_quota_as_domainadmin(self):
        self.clt.logout()
        self.assertTrue(self.clt.login(username="admin@test.com", password="toto"))
        self._set_quota("user@test.com", 0, 400)
        self.clt.logout()
        self.assertTrue(self.clt.login(username="admin@test2.com", password="toto"))
        self._set_quota("user@test2.com", 0)


class PermissionsTestCase(ModoTestCase):
    fixtures = ["initial_users.json"]

    def setUp(self):
        super(PermissionsTestCase, self).setUp()
        factories.populate_database()
        self.user = User.objects.get(username='user@test.com')
        self.values = dict(
            username=self.user.username, role="DomainAdmins",
            is_active=self.user.is_active, email="user@test.com",
            quota_act=True
        )

    def tearDown(self):
        self.clt.logout()

    def test_domain_admins(self):
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[self.user.id]),
            self.values
        )
        self.assertEqual(self.user.group, "DomainAdmins")

        self.values["role"] = "SimpleUsers"
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[self.user.id]),
            self.values
        )
        self.assertNotEqual(self.user.group, 'DomainAdmins')

    def test_superusers(self):
        self.values["role"] = "SuperAdmins"
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[self.user.id]),
            self.values
        )
        self.assertEqual(User.objects.get(username="user@test.com").is_superuser, True)

        self.values["role"] = "SimpleUsers"
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[self.user.id]),
            self.values
        )
        self.assertEqual(User.objects.get(username="user@test.com").is_superuser, False)

    def test_self_modif(self):
        self.clt.logout()
        self.assertEqual(self.clt.login(username="admin@test.com", password="toto"),
                         True)
        admin = User.objects.get(username="admin@test.com")
        values = dict(
            username="admin@test.com", first_name="Admin",
            password1="", password2="",
            quota=10, is_active=True, email="admin@test.com"
        )
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[admin.id]),
            values
        )
        self.assertEqual(admin.group, "DomainAdmins")
        self.assertEqual(admin.can_access(Domain.objects.get(name="test.com")), True)

        values["role"] = "SuperAdmins"
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[admin.id]),
            values
        )
        admin = User.objects.get(username="admin@test.com")
        self.assertEqual(admin.group, "DomainAdmins")

    def test_domadmin_access(self):
        self.clt.logout()
        self.assertEqual(self.clt.login(username="admin@test.com", password="toto"),
                         True)
        response = self.clt.get(
            reverse("modoboa.extensions.admin.views.domain.domains")
        )
        self.assertEqual(response.status_code, 200)

        response = self.clt.get(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[self.user.id]),
            HTTP_X_REQUESTED_WITH='XMLHttpRequest')
        self.assertNotEqual(response["Content-Type"], "application/json")

    def test_domainadmin_deletes_superadmin(self):
        """Check domain admins restrictions about super admins

        When a super admin owns a mailbox and a domain admin exists
        for the associated domain, this domain admin must not be able
        to access the super admin.
        """
        values = dict(
            username="superadmin2@test.com", first_name="Super",
            last_name="Admin", password1="toto", password2="toto",
            role="SuperAdmins", is_active=True,
            email="superadmin2@test.com", stepid='step2'
        )
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.newaccount"),
            values
        )
        account = User.objects.get(username="superadmin2@test.com")
        self.clt.logout()
        self.clt.login(username="admin@test.com", password="toto")
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.delaccount",
                    args=[account.id]), {}, 403
        )

    def test_domainadmin_dlist_local_domain_not_owned(self):
        """Check if a domain admin can use a local mailbox he can't
        access as a recipient in a distribution list"""
        values = dict(
            email="all@test.com",
            recipients="user@test.com",
            recipients_1="user@test2.com",
            enabled=True
        )
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.alias.newdlist"), values
        )

########NEW FILE########
__FILENAME__ = alias
from django.core.urlresolvers import reverse
from modoboa.core.models import User
from modoboa.lib.tests import ModoTestCase
from modoboa.extensions.admin.models import (
    Alias
)
from modoboa.extensions.admin import factories


class AliasTestCase(ModoTestCase):
    fixtures = ["initial_users.json"]

    def setUp(self):
        super(AliasTestCase, self).setUp()
        factories.populate_database()

    def test_alias(self):
        user = User.objects.get(username="user@test.com")
        values = dict(
            username="user@test.com", role=user.group,
            is_active=user.is_active, email="user@test.com",
            aliases="toto@test.com", aliases_1="titi@test.com"
        )
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[user.id]),
            values
        )
        self.assertEqual(user.mailbox_set.all()[0].alias_set.count(), 2)

        del values["aliases_1"]
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[user.id]),
            values
        )
        self.assertEqual(user.mailbox_set.all()[0].alias_set.count(), 1)

    def test_dlist(self):
        values = dict(email="all@test.com",
                      recipients="user@test.com",
                      recipients_1="admin@test.com",
                      recipients_2="ext@titi.com",
                      enabled=True)
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.alias.newdlist"), values
        )
        user = User.objects.get(username="user@test.com")
        self.assertEqual(user.mailbox_set.all()[0].alias_set.count(), 2)
        admin = User.objects.get(username="admin@test.com")
        self.assertEqual(admin.mailbox_set.all()[0].alias_set.count(), 1)

        dlist = Alias.objects.get(address="all", domain__name="test.com")
        self.assertEqual(len(dlist.get_recipients()), 3)
        del values["recipients_1"]
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.alias.editalias",
                    args=[dlist.id]),
            values
        )
        self.assertEqual(dlist.get_recipients_count(), 2)

        self.ajax_post(
            reverse("modoboa.extensions.admin.views.alias.delalias") + "?selection=%d" \
                % dlist.id, {}
        )
        self.assertRaises(Alias.DoesNotExist, Alias.objects.get,
                          address="all", domain__name="test.com")

    def test_forward(self):
        values = dict(email="forward2@test.com", recipients="rcpt@dest.com")
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.alias.newforward"), values
        )
        fwd = Alias.objects.get(address="forward2", domain__name="test.com")
        self.assertEqual(fwd.get_recipients_count(), 1)

        values["recipients"] = "rcpt2@dest.com"
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.alias.editalias",
                    args=[fwd.id]),
            values
        )
        self.assertEqual(fwd.get_recipients_count(), 1)

        self.ajax_post(
            reverse("modoboa.extensions.admin.views.alias.delalias") + "?selection=%d" \
                % fwd.id, {}
        )
        self.assertRaises(Alias.DoesNotExist, Alias.objects.get,
                          address="forward2", domain__name="test.com")

    def test_forward_and_local_copies(self):
        values = dict(email="user@test.com", recipients="rcpt@dest.com")
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.alias.newforward"), values
        )
        fwd = Alias.objects.get(address="user", domain__name="test.com")
        self.assertEqual(fwd.get_recipients_count(), 1)

        values["recipients"] = "rcpt@dest.com"
        values["recipients_1"] = "user@test.com"
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.alias.editalias", args=[fwd.id]),
            values
        )
        fwd = Alias.objects.get(pk=fwd.pk)
        self.assertEqual(fwd.get_recipients_count(), 2)
        self.assertEqual(fwd.aliases.count(), 0)

########NEW FILE########
__FILENAME__ = domain
from django.core.urlresolvers import reverse
from modoboa.core.models import User
from modoboa.lib import parameters
from modoboa.lib.tests import ModoTestCase
from modoboa.extensions.admin.models import (
    Domain, Alias
)
from modoboa.extensions.admin import factories


class DomainTestCase(ModoTestCase):
    fixtures = ["initial_users.json"]

    def setUp(self):
        super(DomainTestCase, self).setUp()
        factories.populate_database()

    def test_create(self):
        """Test the creation of a domain
        """
        values = {
            "name": "pouet.com", "quota": 100, "create_dom_admin": "no",
            "stepid": 'step2'
        }
        self.ajax_post(reverse("modoboa.extensions.admin.views.domain.newdomain"), values)
        dom = Domain.objects.get(name="pouet.com")
        self.assertEqual(dom.name, "pouet.com")
        self.assertEqual(dom.quota, 100)
        self.assertEqual(dom.enabled, False)
        self.assertFalse(dom.admins)

    def test_create_with_template(self):
        """Test the creation of a domain with a template

        """
        values = {
            "name": "pouet.com", "quota": 100, "create_dom_admin": "yes",
            "dom_admin_username": "toto", "create_aliases": "yes",
            "stepid": 'step2'
        }
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.domain.newdomain"),
            values
        )
        dom = Domain.objects.get(name="pouet.com")
        da = User.objects.get(username="toto@pouet.com")
        self.assertIn(da, dom.admins)
        al = Alias.objects.get(address="postmaster", domain__name="pouet.com")
        self.assertIn(da.mailbox_set.all()[0], al.mboxes.all())
        self.assertTrue(da.can_access(al))

    def test_create_with_template_and_empty_quota(self):
        """Test the creation of a domain with a template and no quota"""
        values = {
            "name": "pouet.com", "quota": 0, "create_dom_admin": "yes",
            "dom_admin_username": "toto", "create_aliases": "yes",
            "stepid": 'step2'
        }
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.domain.newdomain"),
            values
        )
        dom = Domain.objects.get(name="pouet.com")
        da = User.objects.get(username="toto@pouet.com")
        self.assertIn(da, dom.admins)
        al = Alias.objects.get(address="postmaster", domain__name="pouet.com")
        self.assertIn(da.mailbox_set.all()[0], al.mboxes.all())
        self.assertTrue(da.can_access(al))

    def test_create_using_default_quota(self):
        parameters.save_admin('DEFAULT_DOMAIN_QUOTA', 50, app='admin')
        values = {
            "name": "pouet.com", "create_dom_admin": "yes",
            "dom_admin_username": "toto", "create_aliases": "yes",
            "stepid": 'step2'
        }
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.domain.newdomain"),
            values
        )
        dom = Domain.objects.get(name="pouet.com")
        self.assertEqual(dom.quota, 50)
        da = User.objects.get(username="toto@pouet.com")
        self.assertEqual(da.mailbox_set.all()[0].quota, 50)

    def test_modify(self):
        """Test the modification of a domain

        Rename 'test.com' domain to 'pouet.com'
        """
        values = {
            "name": "pouet.com", "quota": 100, "enabled": True
        }
        dom = Domain.objects.get(name="test.com")
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.domain.editdomain",
                    args=[dom.id]), 
            values
        )
        dom = Domain.objects.get(name="pouet.com")
        self.assertEqual(dom.name, "pouet.com")
        self.assertTrue(dom.enabled)

    def test_delete(self):
        """Test the removal of a domain
        """
        dom = Domain.objects.get(name="test.com")
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.domain.deldomain",
                    args=[dom.id]),
            {}
        )
        with self.assertRaises(Domain.DoesNotExist):
            Domain.objects.get(pk=1)

########NEW FILE########
__FILENAME__ = domain_alias
from django.core.urlresolvers import reverse
from modoboa.lib.tests import ModoTestCase
from modoboa.extensions.admin.models import (
    Domain, DomainAlias
)
from modoboa.extensions.admin import factories


class DomainAliasTestCase(ModoTestCase):
    fixtures = ['initial_users.json']

    def setUp(self):
        super(DomainAliasTestCase, self).setUp()
        factories.populate_database()
        self.dom = Domain.objects.get(name='test.com')

    def test_model(self):
        dom = Domain.objects.get(name="test.com")
        domal = DomainAlias()
        domal.name = "domalias.net"
        domal.target = dom
        domal.save()
        self.assertEqual(dom.domainalias_count, 1)

        domal.name = "domalias.org"
        domal.save()

        domal.delete()

    def test_form(self):
        dom = Domain.objects.get(name="test.com")
        values = dict(name=dom.name, quota=dom.quota, enabled=dom.enabled,
                      aliases="domalias.net", aliases_1="domalias.com")
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.domain.editdomain",
                    args=[dom.id]),
            values
        )
        self.assertEqual(dom.domainalias_set.count(), 2)

        del values["aliases_1"]
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.domain.editdomain",
                    args=[dom.id]),
            values
        )
        self.assertEqual(dom.domainalias_set.count(), 1)

########NEW FILE########
__FILENAME__ = export
from django.core.urlresolvers import reverse
from modoboa.lib.tests import ModoTestCase
from modoboa.extensions.admin import factories


class ExportTestCase(ModoTestCase):
    fixtures = ["initial_users.json"]

    def setUp(self):
        super(ExportTestCase, self).setUp()
        factories.populate_database()

    def __export_identities(self, idtfilter="", grpfilter=""):
        self.clt.get(
            reverse("modoboa.extensions.admin.views.identity._identities") \
                + "?grpfilter=%s&idtfilter=%s" % (grpfilter, idtfilter)
        )
        return self.clt.post(
            reverse("modoboa.extensions.admin.views.export.export_identities"),
            {"filename": "test.csv"}
        )

    def assertListEqual(self, list1, list2):
        list2 = list2.split('\r\n')
        for entry in list1.split('\r\n'):
            if not entry:
                continue
            self.assertIn(entry, list2)

    def test_export_identities(self):
        response = self.__export_identities()
        self.assertListEqual(
            "account;admin;{CRYPT}dTTsGDkA5ZHKg;;;True;SuperAdmins;;\r\naccount;admin@test.com;{PLAIN}toto;;;True;DomainAdmins;admin@test.com;10;test.com\r\naccount;admin@test2.com;{PLAIN}toto;;;True;DomainAdmins;admin@test2.com;10;test2.com\r\naccount;user@test.com;{PLAIN}toto;;;True;SimpleUsers;user@test.com;10\r\naccount;user@test2.com;{PLAIN}toto;;;True;SimpleUsers;user@test2.com;10\r\nalias;alias@test.com;True;user@test.com\r\nforward;forward@test.com;True;user@external.com\r\ndlist;postmaster@test.com;True;toto@titi.com;test@truc.fr\r\n",
            response.content.strip()
        )

    def test_export_simpleusers(self):
        response = self.__export_identities(
            idtfilter="account", grpfilter="SimpleUsers"
        )
        self.assertListEqual(
            "account;user@test.com;{PLAIN}toto;;;True;SimpleUsers;user@test.com;10\r\naccount;user@test2.com;{PLAIN}toto;;;True;SimpleUsers;user@test2.com;10", 
            response.content.strip()
        )

    def test_export_superadmins(self):
        response = self.__export_identities(
            idtfilter="account", grpfilter="SuperAdmins"
        )
        self.assertEqual(
            response.content.strip(),
            "account;admin;{CRYPT}dTTsGDkA5ZHKg;;;True;SuperAdmins;;"
        )

    def test_export_domainadmins(self):
        response = self.__export_identities(
            idtfilter="account", grpfilter="DomainAdmins"
        )
        self.assertListEqual(
            "account;admin@test.com;{PLAIN}toto;;;True;DomainAdmins;admin@test.com;10;test.com\r\naccount;admin@test2.com;{PLAIN}toto;;;True;DomainAdmins;admin@test2.com;10;test2.com",
            response.content.strip()
        )

    def test_export_aliases(self):
        response = self.__export_identities(idtfilter="alias")
        self.assertEqual(
            response.content.strip(),
            "alias;alias@test.com;True;user@test.com"
        )

    def test_export_forwards(self):
        response = self.__export_identities(idtfilter="forward")
        self.assertEqual(
            response.content.strip(),
            "forward;forward@test.com;True;user@external.com"
        )

    def test_export_dlists(self):
        response = self.__export_identities(idtfilter="dlist")
        self.assertEqual(
            response.content.strip(),
            "dlist;postmaster@test.com;True;toto@titi.com;test@truc.fr"
        )

########NEW FILE########
__FILENAME__ = import_
# coding: utf-8
from django.core.urlresolvers import reverse
from django.core.files.base import ContentFile
from modoboa.core.models import User
from modoboa.lib.tests import ModoTestCase
from modoboa.extensions.admin.models import (
    Domain, Alias, DomainAlias
)
from modoboa.extensions.admin import factories


class ImportTestCase(ModoTestCase):
    fixtures = ["initial_users.json"]

    def setUp(self):
        super(ImportTestCase, self).setUp()
        factories.populate_database()

    def test_domains_import(self):
        f = ContentFile(b"""domain; domain1.com; 100; True
domain; domain2.com; 200; False
domainalias; domalias1.com; domain1.com; True
""", name="domains.csv")
        self.clt.post(
            reverse("modoboa.extensions.admin.views.import.import_domains"), {
                "sourcefile": f
            }
        )
        admin = User.objects.get(username="admin")
        dom = Domain.objects.get(name="domain1.com")
        self.assertEqual(dom.quota, 100)
        self.assertTrue(dom.enabled)
        self.assertTrue(admin.is_owner(dom))
        domalias = DomainAlias.objects.get(name="domalias1.com")
        self.assertEqual(domalias.target, dom)
        self.assertTrue(dom.enabled)
        self.assertTrue(admin.is_owner(domalias))
        dom = Domain.objects.get(name="domain2.com")
        self.assertEqual(dom.quota, 200)
        self.assertFalse(dom.enabled)
        self.assertTrue(admin.is_owner(dom))

    def test_import_domains_with_conflict(self):
        f = ContentFile(b"""domain;test.alias;10;True
domainalias;test.alias;test.com;True
""", name="domains.csv")
        resp = self.clt.post(
            reverse("modoboa.extensions.admin.views.import.import_domains"), {
                "sourcefile": f
            }
        )
        self.assertIn('Object already exists: domainalias', resp.content)

    def test_identities_import(self):
        f = ContentFile(b"""
account; user1@test.com; toto; User; One; True; SimpleUsers; user1@test.com; 0
account; truc@test.com; toto; René; Truc; True; DomainAdmins; truc@test.com; 5; test.com
alias; alias1@test.com; True; user1@test.com
forward; fwd1@test.com; True; user@extdomain.com
dlist; dlist@test.com; True; user1@test.com; user@extdomain.com
""", name="identities.csv")
        self.clt.post(
            reverse("modoboa.extensions.admin.views.import.import_identities"),
            {"sourcefile": f, "crypt_password": True}
        )
        admin = User.objects.get(username="admin")
        u1 = User.objects.get(username="user1@test.com")
        mb1 = u1.mailbox_set.all()[0]
        self.assertTrue(admin.is_owner(u1))
        self.assertEqual(u1.email, "user1@test.com")
        self.assertEqual(u1.first_name, "User")
        self.assertEqual(u1.last_name, "One")
        self.assertTrue(u1.is_active)
        self.assertEqual(u1.group, "SimpleUsers")
        self.assertTrue(mb1.use_domain_quota)
        self.assertEqual(mb1.quota, 0)
        self.assertTrue(admin.is_owner(mb1))
        self.assertEqual(mb1.full_address, "user1@test.com")
        self.assertTrue(self.clt.login(username="user1@test.com", password="toto"))

        da = User.objects.get(username="truc@test.com")
        damb = da.mailbox_set.all()[0]
        self.assertEqual(da.first_name, u"René")
        self.assertEqual(da.group, "DomainAdmins")
        self.assertEqual(damb.quota, 5)
        self.assertFalse(damb.use_domain_quota)
        self.assertEqual(damb.full_address, "truc@test.com")
        dom = Domain.objects.get(name="test.com")
        self.assertIn(da, dom.admins)
        u = User.objects.get(username="user@test.com")
        self.assertTrue(da.can_access(u))

        al = Alias.objects.get(address="alias1", domain__name="test.com")
        self.assertIn(u1.mailbox_set.all()[0], al.mboxes.all())
        self.assertTrue(admin.is_owner(al))

        fwd = Alias.objects.get(address="fwd1", domain__name="test.com")
        self.assertIn("user@extdomain.com", fwd.extmboxes)
        self.assertTrue(admin.is_owner(fwd))

        dlist = Alias.objects.get(address="dlist", domain__name="test.com")
        self.assertIn(u1.mailbox_set.all()[0], dlist.mboxes.all())
        self.assertIn("user@extdomain.com", dlist.extmboxes)
        self.assertTrue(admin.is_owner(dlist))

    def test_import_invalid_quota(self):
        f = ContentFile(b"""
account; user1@test.com; toto; User; One; True; SimpleUsers; user1@test.com; ; test.com
""", name="identities.csv")
        resp = self.clt.post(
            reverse("modoboa.extensions.admin.views.import.import_identities"),
            {"sourcefile": f, "crypt_password": True}
        )
        self.assertIn('wrong quota value', resp.content)

    def test_import_quota_too_big(self):
        self.clt.logout()
        self.clt.login(username="admin@test.com", password="toto")
        f = ContentFile(b"""
account; user1@test.com; toto; User; One; True; SimpleUsers; user1@test.com; 20
""", name="identities.csv")
        resp = self.clt.post(
            reverse("modoboa.extensions.admin.views.import.import_identities"),
            {"sourcefile": f, "crypt_password": True}
        )
        self.assertIn('Quota is greater than the allowed', resp.content)

    def test_import_missing_quota(self):
        f = ContentFile(b"""
account; user1@test.com; toto; User; One; True; SimpleUsers; user1@test.com
""", name="identities.csv")
        resp = self.clt.post(
            reverse("modoboa.extensions.admin.views.import.import_identities"),
            {"sourcefile": f, "crypt_password": True}
        )
        account = User.objects.get(username="user1@test.com")
        self.assertEqual(
            account.mailbox_set.all()[0].quota,
            account.mailbox_set.all()[0].domain.quota
        )

    def test_import_duplicate(self):
        f = ContentFile(b"""
account; admin@test.com; toto; Admin; ; True; DomainAdmins; admin@test.com; 0; test.com
account; truc@test.com; toto; René; Truc; True; DomainAdmins; truc@test.com; 0; test.com
""", name="identities.csv")
        self.clt.post(
            reverse("modoboa.extensions.admin.views.import.import_identities"),
            {"sourcefile": f, "crypt_password": True,
             "continue_if_exists": True}
        )
        admin = User.objects.get(username="admin")
        u1 = User.objects.get(username="truc@test.com")
        self.assertTrue(admin.is_owner(u1))

    def test_import_superadmin(self):
        """Check if a domain admin can import a superadmin

        Expected result: no
        """
        self.clt.logout()
        self.assertTrue(self.clt.login(username="admin@test.com", password="toto"))
        f = ContentFile(b"""
account; sa@test.com; toto; Super; Admin; True; SuperAdmins; superadmin@test.com; 50
""", name="identities.csv")
        self.clt.post(
            reverse("modoboa.extensions.admin.views.import.import_identities"),
            {"sourcefile": f, "crypt_password": True,
             "continue_if_exists": True}
        )
        with self.assertRaises(User.DoesNotExist):
            User.objects.get(username="sa@test.com")

    def test_import_alias_with_empty_values(self):
        f = ContentFile(b"""
alias;user.alias@test.com;True;user@test.com;;;;;;;;;;;;;;;;
""", name="identities.csv")
        self.clt.post(
            reverse("modoboa.extensions.admin.views.import.import_identities"),
            {"sourcefile": f, "crypt_password": True,
             "continue_if_exists": True}
        )
        alias = Alias.objects.get(
            domain__name="test.com", address="user.alias"
        )
        self.assertEqual(alias.type, "alias")

########NEW FILE########
__FILENAME__ = password_schemes
from django.core.urlresolvers import reverse
from modoboa.core import load_core_settings
from modoboa.core.models import User
from modoboa.lib.tests import ModoTestCase
from modoboa.lib import parameters
from modoboa.extensions.admin import factories


class PasswordSchemesTestCase(ModoTestCase):
    fixtures = ['initial_users.json']

    def setUp(self):
        super(PasswordSchemesTestCase, self).setUp()
        factories.populate_database()
        load_core_settings()

    def _create_account(self):
        values = dict(
            username="tester@test.com", first_name="Tester", last_name="Toto",
            password1="toto", password2="toto", role="SimpleUsers",
            quota_act=True,
            is_active=True, email="tester@test.com", stepid='step2'
        )
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.newaccount"),
            values
        )

    def _test_scheme(self, name, startpattern):
        parameters.save_admin('PASSWORD_SCHEME', name, app='core')
        self._create_account()
        account = User.objects.get(username='tester@test.com')
        self.assertTrue(account.password.startswith(startpattern))
        self.assertTrue(account.check_password('toto'))

    def test_sha512crypt_scheme(self):
        self._test_scheme('sha512crypt', '{SHA512-CRYPT}')
        
    def test_sha256crypt_scheme(self):
        self._test_scheme('sha256crypt', '{SHA256-CRYPT}')

    def test_md5crypt_scheme(self):
        self._test_scheme('md5crypt', '{MD5-CRYPT}')

    def test_sha256_scheme(self):
        self._test_scheme('sha256', '{SHA256}')

    def test_md5_scheme(self):
        self._test_scheme('md5', '{MD5}')

    def test_crypt(self):
        self._test_scheme('crypt', '{CRYPT}')

    def test_plain(self):
        self._test_scheme('plain', '{PLAIN}')

########NEW FILE########
__FILENAME__ = user
from django.core.urlresolvers import reverse
from modoboa.core.models import User
from modoboa.lib.tests import ModoTestCase
from modoboa.extensions.admin.factories import populate_database
from modoboa.extensions.admin.models import Alias


class ForwardTestCase(ModoTestCase):
    fixtures = ['initial_users.json']

    def setUp(self):
        super(ForwardTestCase, self).setUp()
        populate_database()

    def test_forward_permissions(self):
        self.clt.logout()
        self.clt.login(username='user@test.com', password='toto')
        self.ajax_post(
            reverse('modoboa.extensions.admin.views.user.forward'),
            {'dest': 'user@extdomain.com', 'keepcopies': True}
        )
        forward = Alias.objects.get(address='user', domain__name='test.com')
        sadmin = User.objects.get(username='admin')
        self.assertTrue(sadmin.can_access(forward))        
        domadmin = User.objects.get(username='admin@test.com')
        self.assertTrue(domadmin.can_access(forward))

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url


urlpatterns = patterns(
    'modoboa.extensions.admin.views.domain',
    (r'^$', 'index'),
    url(r'^domains/$', 'domains', name="domains"),
    (r'^domains/list/$', '_domains'),
    (r'^domains/flatlist/$', 'domains_list'),
    (r'^domains/new/', 'newdomain'),
    (r'^domains/(?P<dom_id>\d+)/edit/$', 'editdomain'),
    (r'^domains/(?P<dom_id>\d+)/delete/$', 'deldomain'),
)

urlpatterns += patterns(
    'modoboa.extensions.admin.views.identity',
    (r'^permissions/remove/$', 'remove_permission'),

    (r'^identities/$', 'identities'),
    (r'^identities/list/$', '_identities'),
    (r'^identities/quotas/$', 'list_quotas'),

    (r'^accounts/list/$', 'accounts_list'),
    (r'^accounts/new/$', 'newaccount'),
    (r'^accounts/edit/(?P<accountid>\d+)/$', 'editaccount'),
    (r'^accounts/delete/(?P<accountid>\d+)/$', 'delaccount'),
)

urlpatterns += patterns(
    'modoboa.extensions.admin.views.alias',
    (r'^distriblists/new/$', 'newdlist'),
    (r'^forwards/new/$', 'newforward'),

    (r'^aliases/new/$', 'newalias'),
    (r'^aliases/edit/(?P<alid>\d+)/$', 'editalias'),
    (r'^aliases/delete/$', 'delalias'),
)

urlpatterns += patterns(
    'modoboa.extensions.admin.views.import',
    (r'^domains/import/$', 'import_domains'),
    (r'^identities/import/$', 'import_identities'),
)

urlpatterns += patterns(
    'modoboa.extensions.admin.views.export',
    (r'^domains/export/$', 'export_domains'),
    (r'^identities/export/$', 'export_identities'),
)

########NEW FILE########
__FILENAME__ = alias
import reversion
from django.db import transaction, IntegrityError
from django.utils.translation import ugettext as _, ungettext
from django.shortcuts import render
from django.core.urlresolvers import reverse
from django.contrib.auth.decorators import (
    login_required, permission_required
)
from modoboa.lib import events
from modoboa.lib.webutils import render_to_json_response
from modoboa.lib.exceptions import PermDeniedException, Conflict
from modoboa.extensions.admin.forms import AliasForm
from modoboa.extensions.admin.models import Alias


def _validate_alias(request, form, successmsg, callback=None):
    """Alias validation

    Common function shared between creation and modification actions.
    """
    if form.is_valid():
        form.set_recipients()
        try:
            alias = form.save()
        except IntegrityError:
            raise Conflict(_("Alias with this name already exists"))
        if callback:
            callback(request.user, alias)
        return render_to_json_response(successmsg)

    return render_to_json_response({'form_errors': form.errors}, status=400)


def _new_alias(request, title, action, successmsg,
               tplname="admin/aliasform.html"):
    events.raiseEvent("CanCreate", request.user, "mailbox_aliases")
    if request.method == "POST":
        def callback(user, alias):
            alias.post_create(user)

        form = AliasForm(request.user, request.POST)
        return _validate_alias(
            request, form, successmsg, callback
        )

    ctx = {
        "title": title,
        "action": action,
        "formid": "aliasform",
        "action_label": _("Create"),
        "action_classes": "submit",
        "form": AliasForm(request.user)
    }
    return render(request, tplname, ctx)


@login_required
@permission_required("admin.add_alias")
@transaction.commit_on_success
@reversion.create_revision()
def newdlist(request):
    return _new_alias(
        request, _("New distribution list"), reverse(newdlist),
        _("Distribution list created")
    )


@login_required
@permission_required("admin.add_alias")
@transaction.commit_on_success
@reversion.create_revision()
def newalias(request):
    return _new_alias(
        request, _("New alias"), reverse(newalias),
        _("Alias created")
    )


@login_required
@permission_required("admin.add_alias")
@transaction.commit_on_success
@reversion.create_revision()
def newforward(request):
    return _new_alias(
        request, _("New forward"), reverse(newforward),
        _("Forward created")
    )


@login_required
@permission_required("admin.change_alias")
@transaction.commit_on_success
@reversion.create_revision()
def editalias(request, alid, tplname="admin/aliasform.html"):
    alias = Alias.objects.get(pk=alid)
    if not request.user.can_access(alias):
        raise PermDeniedException
    if request.method == "POST":
        if len(alias.get_recipients()) >= 2:
            successmsg = _("Distribution list modified")
        elif alias.extmboxes != "":
            successmsg = _("Forward modified")
        else:
            successmsg = _("Alias modified")
        form = AliasForm(request.user, request.POST, instance=alias)
        return _validate_alias(request, form, successmsg)

    ctx = {
        'action': reverse(editalias, args=[alias.id]),
        'formid': 'aliasform',
        'title': alias.full_address,
        'action_label': _('Update'),
        'action_classes': 'submit',
        'form': AliasForm(request.user, instance=alias)
    }
    return render(request, tplname, ctx)


@login_required
@permission_required("admin.delete_alias")
@transaction.commit_on_success
def delalias(request):
    selection = request.GET["selection"].split(",")
    for alid in selection:
        alias = Alias.objects.get(pk=alid)
        if not request.user.can_access(alias):
            raise PermDeniedException
        if alias.type == 'dlist':
            msg = "Distribution list deleted"
            msgs = "Distribution lists deleted"
        elif alias.type == 'forward':
            msg = "Forward deleted"
            msgs = "Forwards deleted"
        else:
            msg = "Alias deleted"
            msgs = "Aliases deleted"
        alias.delete()

    msg = ungettext(msg, msgs, len(selection))
    return render_to_json_response(msg)

########NEW FILE########
__FILENAME__ = domain
import reversion
from django.http import HttpResponseRedirect
from django.utils.translation import ugettext as _, ungettext
from django.core.urlresolvers import reverse
from django.db import transaction
from django.shortcuts import render
from django.views.decorators.csrf import ensure_csrf_cookie
from django.contrib.auth.decorators import (
    login_required, permission_required, user_passes_test
)
from modoboa.lib import parameters, events
from modoboa.lib.webutils import (
    _render_to_string, render_to_json_response
)
from modoboa.lib.formutils import CreationWizard
from modoboa.lib.exceptions import (
    ModoboaException, PermDeniedException, BadRequest
)
from modoboa.lib.templatetags.lib_tags import pagination_bar
from modoboa.extensions.admin.lib import get_sort_order, get_listing_page
from modoboa.extensions.admin.models import Domain, Mailbox
from modoboa.extensions.admin.forms import (
    DomainForm, DomainFormGeneral, DomainFormOptions
)
from modoboa.extensions.admin.lib import get_domains


@login_required
def index(request):
    return HttpResponseRedirect(reverse(domains))


@login_required
@user_passes_test(
    lambda u: u.has_perm("admin.view_domains") or u.has_perm("admin.view_mailboxes")
)
def _domains(request):
    sort_order, sort_dir = get_sort_order(request.GET, "name")
    filters = dict(
        (flt, request.GET.get(flt, None))
        for flt in ['domfilter', 'searchquery']
        + events.raiseQueryEvent('ExtraDomainFilters')
    )
    request.session['domains_filters'] = filters
    domainlist = get_domains(
        request.user, **filters
    )
    if sort_order == 'name':
        domainlist = sorted(
            domainlist,
            key=lambda d: getattr(d, sort_order), reverse=sort_dir == '-'
        )
    else:
        domainlist = sorted(domainlist, key=lambda d: d.tags[0],
                            reverse=sort_dir == '-')
    page = get_listing_page(domainlist, request.GET.get("page", 1))
    return render_to_json_response({
        "table": _render_to_string(request, 'admin/domains_table.html', {
            'domains': page.object_list,
            'tableid': 'domains'
        }),
        "page": page.number,
        "paginbar": pagination_bar(page),
        "handle_mailboxes": parameters.get_admin("HANDLE_MAILBOXES",
                                                 raise_error=False),
        "auto_account_removal": parameters.get_admin("AUTO_ACCOUNT_REMOVAL")
    })


@login_required
@ensure_csrf_cookie
def domains(request, tplname="admin/domains.html"):
    if not request.user.has_perm("admin.view_domains"):
        if request.user.has_perm("admin.view_mailboxes"):
            return HttpResponseRedirect(
                reverse('modoboa.extensions.admin.views.identity.identities')
            )
        return HttpResponseRedirect(reverse("modoboa.core.views.user.index"))
    return render(request, tplname, {"selection": "domains"})


@login_required
@permission_required("core.add_user")
def domains_list(request):
    doms = [dom.name for dom in Domain.objects.get_for_admin(request.user)]
    return render_to_json_response(doms)


@login_required
@permission_required("admin.add_domain")
@transaction.commit_on_success
@reversion.create_revision()
def newdomain(request, tplname="common/wizard_forms.html"):
    events.raiseEvent("CanCreate", request.user, "domains")

    cwizard = CreationWizard()
    cwizard.add_step(DomainFormGeneral, _("General"),
                     [dict(classes="btn-inverse next", label=_("Next"))],
                     formtpl="admin/domain_general_form.html")
    cwizard.add_step(
        DomainFormOptions, _("Options"),
        [dict(classes="btn-primary submit", label=_("Create")),
         dict(classes="btn-inverse prev", label=_("Previous"))],
        formtpl="admin/domain_options_form.html",
        new_args=[request.user]
    )

    if request.method == "POST":
        retcode, data = cwizard.validate_step(request)
        if retcode == -1:
            raise BadRequest(data)
        if retcode == 1:
            return render_to_json_response(
                {'title': cwizard.get_title(data + 1), 'stepid': data}
            )
        if retcode == 2:
            genform = cwizard.steps[0]["form"]
            domain = genform.save(request.user)
            domain.post_create(request.user)
            try:
                cwizard.steps[1]["form"].save(request.user, domain)
            except ModoboaException as e:
                transaction.rollback()
                raise
            return render_to_json_response(_("Domain created"))
        return render_to_json_response({
            'stepid': data, 'form_errors': cwizard.errors
        }, status=400)

    ctx = {"title": _("New domain"),
           "action_label": _("Create"),
           "action_classes": "submit",
           "action": reverse(newdomain),
           "formid": "domform"}
    cwizard.create_forms()
    ctx.update(steps=cwizard.steps)
    ctx.update(subtitle="1. %s" % cwizard.steps[0]['title'])
    return render(request, tplname, ctx)


@login_required
@permission_required("admin.view_domains")
@transaction.commit_on_success
@reversion.create_revision()
def editdomain(request, dom_id, tplname="admin/editdomainform.html"):
    domain = Domain.objects.get(pk=dom_id)
    if not request.user.can_access(domain):
        raise PermDeniedException

    instances = dict(general=domain)
    events.raiseEvent("FillDomainInstances", request.user, domain, instances)
    if request.method == "POST":
        domain.oldname = domain.name
        form = DomainForm(request.user, request.POST, instances=instances)
        if form.is_valid():
            form.save(request.user)
            events.raiseEvent("DomainModified", domain)
            return render_to_json_response(_("Domain modified"))
        return render_to_json_response({
            'form_errors': form.errors
        }, status=400)

    domadmins = [u for u in domain.admins
                 if request.user.can_access(u) and not u.is_superuser]
    if not request.user.is_superuser:
        domadmins = [u for u in domadmins if u.group == "DomainAdmins"]
    ctx = {"title": domain.name,
           "action_label": _("Update"),
           "action_classes": "submit",
           "action": reverse(editdomain, args=[dom_id]),
           "formid": "domform",
           "domain": domain,
           "tabs": DomainForm(request.user, instances=instances),
           "domadmins": domadmins}
    return render(request, tplname, ctx)


@login_required
@permission_required("admin.delete_domain")
@transaction.commit_on_success
def deldomain(request, dom_id):
    keepdir = True if request.POST.get("keepdir", "false") == "true" else False
    try:
        mb = Mailbox.objects.get(user__id=request.user.id)
    except Mailbox.DoesNotExist:
        mb = None

    dom = Domain.objects.get(pk=dom_id)
    if not request.user.can_access(dom):
        raise PermDeniedException
    if mb and mb.domain == dom:
        raise PermDeniedException(_("You can't delete your own domain"))
    dom.delete(request.user, keepdir)

    msg = ungettext("Domain deleted", "Domains deleted", 1)
    return render_to_json_response(msg)

########NEW FILE########
__FILENAME__ = export
import csv
import cStringIO
from rfc6266 import build_header
from django.http import HttpResponse
from django.shortcuts import render
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext as _
from django.contrib.auth.decorators import (
    login_required, permission_required, user_passes_test
)
from modoboa.extensions.admin.lib import get_domains, get_identities
from modoboa.extensions.admin.forms import (
    ExportIdentitiesForm, ExportDomainsForm
)


def _export(content, filename):
    """Export a csv file's content

    :param content: the content to export (string)
    :param filename: the name that will appear into the response
    :return: an ``HttpResponse`` object
    """
    resp = HttpResponse(content)
    resp["Content-Type"] = "text/csv"
    resp["Content-Length"] = len(content)
    resp["Content-Disposition"] = build_header(filename)
    return resp


@login_required
@user_passes_test(
    lambda u: u.has_perm("core.add_user") or u.has_perm("admin.add_alias")
)
def export_identities(request):
    ctx = {
        "title": _("Export identities"),
        "action_label": _("Export"),
        "action_classes": "submit",
        "formid": "exportform",
        "action": reverse(export_identities),
    }

    if request.method == "POST":
        form = ExportIdentitiesForm(request.POST)
        form.is_valid()
        fp = cStringIO.StringIO()
        csvwriter = csv.writer(fp, delimiter=form.cleaned_data["sepchar"])
        for ident in get_identities(request.user, **request.session['identities_filters']):
            ident.to_csv(csvwriter)
        content = fp.getvalue()
        fp.close()
        return _export(content, form.cleaned_data["filename"])

    ctx["form"] = ExportIdentitiesForm()
    return render(request, "common/generic_modal_form.html", ctx)


@login_required
@permission_required("admin.add_domain")
def export_domains(request):
    ctx = {
        "title": _("Export domains"),
        "action_label": _("Export"),
        "action_classes": "submit",
        "formid": "exportform",
        "action": reverse(export_domains),
    }

    if request.method == "POST":
        form = ExportDomainsForm(request.POST)
        form.is_valid()
        fp = cStringIO.StringIO()
        csvwriter = csv.writer(fp, delimiter=form.cleaned_data["sepchar"])
        for dom in get_domains(request.user,
                               **request.session['domains_filters']):
            dom.to_csv(csvwriter)
        content = fp.getvalue()
        fp.close()
        return _export(content, form.cleaned_data["filename"])

    ctx["form"] = ExportDomainsForm()
    return render(request, "common/generic_modal_form.html", ctx)

########NEW FILE########
__FILENAME__ = identity
import reversion
from django.shortcuts import render
from django.db import transaction
from django.utils.translation import ugettext as _, ungettext
from django.core.urlresolvers import reverse
from django.contrib.auth.decorators import (
    login_required, permission_required, user_passes_test
)
from django.views.decorators.csrf import ensure_csrf_cookie
from modoboa.lib import parameters, events
from modoboa.lib.exceptions import (
    PermDeniedException, BadRequest
)
from modoboa.lib.webutils import (
    _render_to_string, render_to_json_response
)
from modoboa.lib.formutils import CreationWizard
from modoboa.lib.templatetags.lib_tags import pagination_bar
from modoboa.core.models import User
from modoboa.extensions.admin.models import Mailbox, Domain
from modoboa.extensions.admin.lib import (
    get_sort_order, get_listing_page, get_identities
)
from modoboa.extensions.admin.forms import (
    AccountForm, AccountFormGeneral, AccountFormMail
)


@login_required
@user_passes_test(
    lambda u: u.has_perm("core.add_user") or u.has_perm("admin.add_alias")
)
def _identities(request):
    filters = dict((fname, request.GET.get(fname, None))
                   for fname in ['searchquery', 'idtfilter', 'grpfilter'])
    request.session['identities_filters'] = filters
    idents_list = get_identities(request.user, **filters)
    sort_order, sort_dir = get_sort_order(request.GET, "identity",
                                          ["identity", "name_or_rcpt", "tags"])
    if sort_order in ["identity", "name_or_rcpt"]:
        objects = sorted(idents_list, key=lambda o: getattr(o, sort_order),
                         reverse=sort_dir == '-')
    else:
        objects = sorted(idents_list, key=lambda o: o.tags[0],
                         reverse=sort_dir == '-')
    page = get_listing_page(objects, request.GET.get("page", 1))
    return render_to_json_response({
        "table": _render_to_string(request, "admin/identities_table.html", {
            "identities": page.object_list,
            "tableid": "objects_table"
        }),
        "handle_mailboxes": parameters.get_admin("HANDLE_MAILBOXES",
                                                 raise_error=False),
        "page": page.number,
        "paginbar": pagination_bar(page)
    })


@login_required
@user_passes_test(
    lambda u: u.has_perm("admin.add_user") or u.has_perm("admin.add_alias")
)
@ensure_csrf_cookie
def identities(request, tplname="admin/identities.html"):
    return render(request, tplname, {
        "selection": "identities",
        "deflocation": "list/"
    })


@login_required
@permission_required("core.add_user")
def accounts_list(request):
    accs = User.objects.filter(is_superuser=False) \
        .exclude(groups__name='SimpleUsers')
    res = [a.username for a in accs.all()]
    return render_to_json_response(res)


@login_required
@permission_required("admin.add_mailbox")
def list_quotas(request, tplname="admin/quotas.html"):
    from modoboa.lib.dbutils import db_type

    sort_order, sort_dir = get_sort_order(request.GET, "address")
    mboxes = Mailbox.objects.get_for_admin(
        request.user, request.GET.get("searchquery", None)
    )
    mboxes = mboxes.exclude(quota=0)
    if sort_order in ["address", "quota", "quota_value__bytes"]:
        mboxes = mboxes.order_by("%s%s" % (sort_dir, sort_order))
    elif sort_order == "quota_usage":
        if db_type() == "postgres":
            select = '(admin_quota.bytes::float / (CAST(admin_mailbox.quota AS BIGINT) * 1048576)) * 100'
        else:
            select = 'admin_quota.bytes / (admin_mailbox.quota * 1048576) * 100'
        mboxes = mboxes.extra(
            select={'quota_usage': select},
            where=["admin_quota.mbox_id=admin_mailbox.id"],
            tables=["admin_quota"],
            order_by=["%s%s" % (sort_dir, sort_order)]
        )
    else:
        raise BadRequest(_("Invalid request"))
    page = get_listing_page(mboxes, request.GET.get("page", 1))
    return render_to_json_response({
        "page": page.number,
        "paginbar": pagination_bar(page),
        "table": _render_to_string(request, tplname, {
            "mboxes": page
        })
    })


@login_required
@permission_required("core.add_user")
@transaction.commit_on_success
@reversion.create_revision()
def newaccount(request, tplname='common/wizard_forms.html'):
    """Create a new account.

    .. note:: An issue still remains int this code: if all validation
       steps are successful but an error occurs after we call 'save',
       the account will be created. It happens transaction management
       doesn't work very well with nested functions. Need to wait for
       django 1.6 and atomicity.
    """
    cwizard = CreationWizard()
    cwizard.add_step(AccountFormGeneral, _("General"),
                     [dict(classes="btn-inverse next", label=_("Next"))],
                     new_args=[request.user])
    cwizard.add_step(AccountFormMail, _("Mail"),
                     [dict(classes="btn-primary submit", label=_("Create")),
                      dict(classes="btn-inverse prev", label=_("Previous"))],
                     formtpl="admin/mailform.html")

    if request.method == "POST":
        retcode, data = cwizard.validate_step(request)
        if retcode == -1:
            raise BadRequest(data)
        if retcode == 1:
            return render_to_json_response(
                {'title': cwizard.get_title(data + 1), 'stepid': data}
            )
        if retcode == 2:
            genform = cwizard.steps[0]["form"]
            account = genform.save()
            account.post_create(request.user)
            mailform = cwizard.steps[1]["form"]
            mailform.save(request.user, account)
            return render_to_json_response(_("Account created"))
        return render_to_json_response({
            'stepid': data, 'form_errors': cwizard.errors
        }, status=400)

    ctx = {
        'title': _("New account"),
        'action': reverse(newaccount),
        'formid': 'newaccount_form',
        'submit_label': _("Create")
    }
    cwizard.create_forms()
    ctx.update(steps=cwizard.steps)
    ctx.update(subtitle="1. %s" % cwizard.steps[0]['title'])
    return render(request, tplname, ctx)


@login_required
@permission_required("core.change_user")
@transaction.commit_on_success
@reversion.create_revision()
def editaccount(request, accountid, tplname="common/tabforms.html"):
    account = User.objects.get(pk=accountid)
    if not request.user.can_access(account):
        raise PermDeniedException
    mb = None
    if account.mailbox_set.count():
        mb = account.mailbox_set.all()[0]

    instances = dict(general=account, mail=mb, perms=account)
    events.raiseEvent("FillAccountInstances", request.user, account, instances)

    if request.method == "POST":
        classes = {}
        form = AccountForm(request.user, request.POST,
                           instances=instances, classes=classes)
        account.oldgroup = account.group
        if form.is_valid(mandatory_only=True):
            form.save_general_form()
            if form.is_valid(optional_only=True):
                events.raiseEvent("AccountModified", account, form.account)
                form.save()
                return render_to_json_response(_("Account updated"))
        return render_to_json_response({'form_errors': form.errors}, status=400)

    ctx = {
        'title': account.username,
        'formid': 'accountform',
        'action': reverse(editaccount, args=[accountid]),
        'action_label': _('Update'),
        'action_classes': 'submit',
        'tabs': AccountForm(request.user, instances=instances)
    }
    active_tab_id = request.GET.get("active_tab", "default")
    if active_tab_id != "default":
        ctx["tabs"].active_id = active_tab_id
    return render(request, tplname, ctx)


@login_required
@permission_required("core.delete_user")
@transaction.commit_on_success
def delaccount(request, accountid):
    keepdir = True if request.POST.get("keepdir", "false") == "true" else False
    User.objects.get(pk=accountid).delete(request.user, keep_mb_dir=keepdir)
    return render_to_json_response(
        ungettext("Account deleted", "Accounts deleted", 1)
    )


@login_required
@permission_required("admin.add_domain")
def remove_permission(request):
    domid = request.GET.get("domid", None)
    daid = request.GET.get("daid", None)
    if domid is None or daid is None:
        raise BadRequest(_("Invalid request"))
    try:
        account = User.objects.get(pk=daid)
        domain = Domain.objects.get(pk=domid)
    except (User.DoesNotExist, Domain.DoesNotExist):
        raise BadRequest(_("Invalid request"))
    if not request.user.can_access(account) or not request.user.can_access(domain):
        raise PermDeniedException
    domain.remove_admin(account)
    return render_to_json_response({})

########NEW FILE########
__FILENAME__ = import
import csv
import reversion
from django.utils.translation import ugettext as _
from django.shortcuts import render
from django.core.urlresolvers import reverse
from django.db import transaction
from django.contrib.auth.decorators import (
    login_required, permission_required, user_passes_test
)
from modoboa.lib import events
from modoboa.lib.exceptions import ModoboaException, Conflict
from modoboa.core.models import User
from modoboa.extensions.admin.models import (
    Domain, DomainAlias, Alias
)
from modoboa.extensions.admin.forms import ImportIdentitiesForm, ImportDataForm


@transaction.commit_on_success
def import_domain(user, row, formopts):
    """Specific code for domains import"""
    dom = Domain()
    dom.from_csv(user, row)


@transaction.commit_on_success
def import_domainalias(user, row, formopts):
    """Specific code for domain aliases import"""
    domalias = DomainAlias()
    domalias.from_csv(user, row)


@login_required
@permission_required("admin.add_domain")
@transaction.commit_on_success
def import_domains(request):
    if request.method == "POST":
        return importdata(request)

    helptext = _("""Provide a CSV file where lines respect one of the following formats:
<ul>
  <li><em>domain; name; quota; enabled</em></li>
  <li><em>domainalias; name; targeted domain; enabled</em></li>
  %s
</ul>
<p>The first element of each line is mandatory and must be equal to one of the previous values.</p>
<p>You can use a different character as separator.</p>
""" % ''.join([unicode(hlp) for hlp in events.raiseQueryEvent('ExtraDomainImportHelp')]))

    ctx = dict(
        title=_("Import domains"),
        action_label=_("Import"),
        action_classes="submit",
        action=reverse(import_domains),
        formid="importform",
        enctype="multipart/form-data",
        target="import_target",
        helptext=helptext,
        form=ImportDataForm()
    )
    return render(request, "admin/importform.html", ctx)


@transaction.commit_on_success
def import_account(user, row, formopts):
    """Specific code for accounts import"""
    account = User()
    account.from_csv(user, row, formopts["crypt_password"])


@transaction.commit_on_success
def _import_alias(user, row, **kwargs):
    """Specific code for aliases import"""
    alias = Alias()
    alias.from_csv(user, row, **kwargs)


def import_alias(user, row, formopts):
    _import_alias(user, row, expected_elements=4)


def import_forward(user, row, formopts):
    _import_alias(user, row, expected_elements=4)


def import_dlist(user, row, formopts):
    _import_alias(user, row)


@reversion.create_revision()
def importdata(request, formclass=ImportDataForm):
    """Generic import function

    As the process of importing data from a CSV file is the same
    whatever the type, we do a maximum of the work here.

    :param request: a ``Request`` instance
    :param typ: a string indicating the object type being imported
    :return: a ``Response`` instance
    """
    error = None
    form = formclass(request.POST, request.FILES)
    if form.is_valid():
        try:
            reader = csv.reader(request.FILES['sourcefile'],
                                delimiter=form.cleaned_data['sepchar'])
        except csv.Error as inst:
            error = str(inst)

        if error is None:
            try:
                cpt = 0
                for row in reader:
                    if not row:
                        continue
                    try:
                        fct = globals()["import_%s" % row[0].strip()]
                    except KeyError:
                        fct = events.raiseQueryEvent(
                            'ImportObject', row[0].strip()
                        )
                        if not fct:
                            continue
                        fct = fct[0]
                    try:
                        fct(request.user, row, form.cleaned_data)
                    except Conflict:
                        if form.cleaned_data["continue_if_exists"]:
                            continue
                        raise Conflict(
                            _("Object already exists: %s"
                              % form.cleaned_data['sepchar'].join(row[:2]))
                        )
                    cpt += 1
                msg = _("%d objects imported successfully" % cpt)
                return render(request, "admin/import_done.html", {
                    "status": "ok", "msg": msg
                })
            except (ModoboaException), e:
                error = str(e)

    return render(request, "admin/import_done.html", {
        "status": "ko", "msg": error
    })


@login_required
@user_passes_test(
    lambda u: u.has_perm("core.add_user") or u.has_perm("admin.add_alias")
)
def import_identities(request):
    if request.method == "POST":
        return importdata(request, ImportIdentitiesForm)

    helptext = _("""Provide a CSV file where lines respect one of the following formats:
<ul>
<li><em>account; loginname; password; first name; last name; enabled; group; address; quota; [, domain, ...]</em></li>
<li><em>alias; address; enabled; internal recipient</em></li>
<li><em>forward; address; enabled; external recipient</em></li>
<li><em>dlist; address; enabled; recipient; recipient; ...</em></li>
</ul>
<p>The first element of each line is mandatory and must be equal to one of the previous values.</p>

<p>You can use a different character as separator.</p>
""")
    ctx = dict(
        title=_("Import identities"),
        action_label=_("Import"),
        action_classes="submit",
        action=reverse(import_identities),
        formid="importform",
        enctype="multipart/form-data",
        target="import_target",
        form=ImportIdentitiesForm(),
        helptext=helptext
    )
    return render(request, "admin/importform.html", ctx)

########NEW FILE########
__FILENAME__ = user
import reversion
from django.contrib.auth.decorators import login_required
from django.utils.translation import ugettext as _
from modoboa.lib.webutils import (
    render_to_json_response, _render_to_string
)
from modoboa.extensions.admin.lib import needs_mailbox
from modoboa.extensions.admin.models import Alias, Mailbox
from modoboa.extensions.admin.forms import ForwardForm


@login_required
@needs_mailbox()
@reversion.create_revision()
def forward(request, tplname='admin/forward.html'):
    mb = request.user.mailbox_set.all()[0]
    try:
        al = Alias.objects.get(address=mb.address,
                               domain__name=mb.domain.name)
    except Alias.DoesNotExist:
        al = None
    if request.method == "POST":
        form = ForwardForm(request.POST)
        error = None
        if form.is_valid():
            if al is None:
                al = Alias()
                al.address = mb.address
                al.domain = mb.domain
                al.enabled = mb.user.is_active
            intdests = []
            if form.cleaned_data["keepcopies"]:
                intdests += [mb]
            form.parse_dest()
            al.save(
                int_rcpts=intdests, ext_rcpts=form.dests, creator=request.user
            )
            return render_to_json_response(_("Forward updated"))

        return render_to_json_response(
            {'form_errors': form.errors}, status=400
        )

    form = ForwardForm()
    if al is not None:
        form.fields["dest"].initial = al.extmboxes
        try:
            al.mboxes.get(pk=mb.id)
        except Mailbox.DoesNotExist:
            pass
        else:
            form.fields["keepcopies"].initial = True
    return render_to_json_response({
        "content": _render_to_string(request, tplname, {
            "form": form
        })
    })

########NEW FILE########
__FILENAME__ = app_settings
# coding: utf-8
from django.utils.translation import ugettext_lazy as _
from django import forms
from modoboa.lib.parameters import AdminParametersForm, UserParametersForm
from modoboa.lib.formutils import SeparatorField, YesNoField, InlineRadioSelect


class ParametersForm(AdminParametersForm):
    app = "amavis"

    qsettings_sep = SeparatorField(label=_("Quarantine settings"))

    max_messages_age = forms.IntegerField(
        label=_("Maximum message age"),
        initial=14,
        help_text=_("Quarantine messages maximum age (in days) before deletion")
    )

    sep1 = SeparatorField(label=_("Messages releasing"))
                          
    released_msgs_cleanup = YesNoField(
        label=_("Remove released messages"),
        initial="no",
        help_text=_("Remove messages marked as released while cleaning up the database")
    )

    am_pdp_mode = forms.ChoiceField(
        label=_("Amavis connection mode"),
        choices=[("inet", "inet"), ("unix", "unix")],
        initial="unix",
        help_text=_("Mode used to access the PDP server"),
        widget=InlineRadioSelect
    )

    am_pdp_host = forms.CharField(
        label=_("PDP server address"),
        initial="localhost",
        help_text=_("PDP server address (if inet mode)")
    )

    am_pdp_port = forms.IntegerField(
        label=_("PDP server port"),
        initial=9998,
        help_text=_("PDP server port (if inet mode)")
    )

    am_pdp_socket = forms.CharField(
        label=_("PDP server socket"),
        initial="/var/amavis/amavisd.sock",
        help_text=_("Path to the PDP server socket (if unix mode)")
    )
    
    check_requests_interval = forms.IntegerField(
        label=_("Check requests interval"),
        initial=30,
        help_text=_("Interval between two release requests checks")
    )

    user_can_release = YesNoField(
        label=_("Allow direct release"),
        initial="no",
        help_text=_("Allow users to directly release their messages")
    )

    self_service = YesNoField(
        label=_("Enable self-service mode"),
        initial="no",
        help_text=_("Activate the 'self-service' mode")
    )

    notifications_sender = forms.EmailField(
        label=_("Notifications sender"),
        initial="notification@modoboa.org",
        help_text=_("The e-mail address used to send notitications")
    )

    visibility_rules = {
        "am_pdp_host": "am_pdp_mode=inet",
        "am_pdp_port": "am_pdp_mode=inet",
        "am_pdp_socket": "am_pdp_mode=unix"
    }


class UserSettings(UserParametersForm):
    app = "amavis"

    dsep = SeparatorField(label=_("Display"))

    messages_per_page = forms.IntegerField(
        initial=40,
        label=_("Number of displayed emails per page"),
        help_text=_("Set the maximum number of messages displayed in a page")
    )

########NEW FILE########
__FILENAME__ = dbrouter
class AmavisRouter(object):
    """A router to control all database operations on models in
    the amavis application"""

    def db_for_read(self, model, **hints):
        "Point all operations on amavis models to 'amavis'"
        if model._meta.app_label == 'amavis':
            return 'amavis'
        return None

    def db_for_write(self, model, **hints):
        "Point all operations on amavis models to 'amavis'"
        if model._meta.app_label == 'amavis':
            return 'amavis'
        return None

    def allow_relation(self, obj1, obj2, **hints):
        "Allow any relation if a model in amavis is involved"
        if obj1._meta.app_label == 'amavis' \
                or obj2._meta.app_label == 'amavis':
            return True
        return None

    def allow_syncdb(self, db, model):
        "Make sure the amavis app only appears on the 'amavis' db"
        if db == 'amavis':
            return model._meta.app_label == 'amavis'
        elif model._meta.app_label == 'amavis':
            return False
        return None

########NEW FILE########
__FILENAME__ = forms
# coding: utf-8
from django import forms
from modoboa.lib.formutils import InlineRadioSelect
from modoboa.extensions.amavis.models import Policy, Users


class DomainPolicyForm(forms.ModelForm):
    spam_subject_tag2_act = forms.BooleanField()

    class Meta:
        model = Policy
        fields = ('bypass_virus_checks', 'bypass_spam_checks',
                  'spam_tag2_level', 'spam_subject_tag2',
                  'spam_kill_level', 'bypass_banned_checks')
        widgets = {
            'bypass_virus_checks': InlineRadioSelect(),
            'bypass_spam_checks': InlineRadioSelect(),
            'spam_tag2_level': forms.TextInput(attrs={'class': 'span1'}),
            'spam_kill_level': forms.TextInput(attrs={'class': 'span1'}),
            'spam_subject_tag2': forms.TextInput(attrs={'class': 'span2'}),
            'bypass_banned_checks': InlineRadioSelect(),
        }

    def __init__(self, *args, **kwargs):
        if "instance" in kwargs:
            self.domain = kwargs["instance"]
            try:
                policy = Users.objects.get(email="@%s" % self.domain.name).policy
                kwargs["instance"] = policy
            except (Users.DoesNotExist, Policy.DoesNotExist):
                del kwargs["instance"]
        super(DomainPolicyForm, self).__init__(*args, **kwargs)
        for f in self.fields.keys():
            self.fields[f].required = False

    def save(self, user, commit=True):
        policy = super(DomainPolicyForm, self).save(commit=False)
        for field in ['bypass_spam_checks', 'bypass_virus_checks',
                  'bypass_banned_checks']:
            if getattr(policy, field) == '':
                setattr(policy, field, None)

        if self.cleaned_data['spam_subject_tag2_act']:
            policy.spam_subject_tag2 = None

        if commit:
            policy.save()
            try:
                u = Users.objects.get(fullname=policy.policy_name)
            except Users.DoesNotExist:
                u = Users.objects.get(email="@%s" % self.domain.name)
                u.policy = policy
                policy.save()
        return policy

########NEW FILE########
__FILENAME__ = general_callbacks
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext as _
from django.template import Template, Context
from modoboa.lib import events, parameters
from modoboa.extensions.admin.models import DomainAlias
from modoboa.extensions.amavis.lib import (
    create_user_and_policy, update_user_and_policy, delete_user_and_policy,
    create_user_and_use_policy, delete_user
)


@events.observe("UserMenuDisplay")
def menu(target, user):
    if target == "top_menu":
        return [
            {"name": "quarantine",
             "label": _("Quarantine"),
             "url": reverse('modoboa.extensions.amavis.views.index')}
        ]
    return []


@events.observe("DomainCreated")
def on_domain_created(user, domain):
    create_user_and_policy(domain.name)


@events.observe("DomainModified")
def on_domain_modified(domain):
    update_user_and_policy(domain.oldname, domain.name)


@events.observe("DomainDeleted")
def on_domain_deleted(domain):
    delete_user_and_policy(domain.name)


@events.observe("DomainAliasCreated")
def on_domain_alias_created(user, domainalias):
    create_user_and_use_policy(domainalias.name, domainalias.target.name)


@events.observe("DomainAliasDeleted")
def on_domain_alias_deleted(domainaliases):
    if isinstance(domainaliases, DomainAlias):
        domainaliases = [domainaliases]
    for domainalias in domainaliases:
        delete_user(domainalias.name)


@events.observe("GetStaticContent")
def extra_static_content(caller, user):
    if user.group == "SimpleUsers":
        return []

    if caller == 'top' and parameters.get_admin("USER_CAN_RELEASE") == 'no':
        tpl = Template("""<script type="text/javascript">
$(document).ready(function() {
    var poller = new Poller("{{ url }}", {
        interval: {{ interval }},
        success_cb: function(data) {
            var $link = $("#nbrequests");
            var $maincounter = $("#alerts-counter");

            if (data.requests > 0) {
                $maincounter.html(data.requests);
                $link.children("span").html(data.requests);
                $maincounter.closest('div').removeClass('hidden');
            } else {
                $maincounter.closest('div').addClass('hidden');
            }
        }
    });
});
</script>
""")
        return [tpl.render(
            Context({
                'url': reverse("modoboa.extensions.amavis.views.nbrequests"),
                'interval': int(parameters.get_admin("CHECK_REQUESTS_INTERVAL")) * 1000,
                'text': _("pending requests"),
            })
        )]

    if caller == 'domains':
        tpl = Template("""<script type="text/javascript">
$(document).bind('domform_init', function() {
    activate_widget.call($('#id_spam_subject_tag2_act'));
});
</script>
""")

        return [tpl.render(Context({}))]
    return []


@events.observe("TopNotifications")
def display_requests(user):
    from .sql_listing import get_wrapper

    if parameters.get_admin("USER_CAN_RELEASE") == "yes" \
            or user.group == "SimpleUsers":
        return []
    nbrequests = get_wrapper().get_pending_requests(user)

    url = reverse("modoboa.extensions.amavis.views.index")
    url += "#listing/?viewrequests=1"
    tpl = Template("""<ul class="nav pull-right {{ css }}">
  <li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">
      <i class="icon-white icon-bell"></i> <span id="alerts-counter" class="label label-important">{{ nbrequests }}</span>
    </a>
    <ul class="dropdown-menu">
      <li>
        <a id="nbrequests" href="{{ url }}">
          <span class="label label-important">{{ nbrequests }}</span> {{ label }}
        </a>
      </li>
    </ul>
  </li>
</ul>""")
    css = "hidden" if nbrequests == 0 else ""
    return [tpl.render(Context(dict(
        label=_("Pending requests"), url=url, css=css,
        nbrequests=nbrequests
    )))]


def send_amavis_form():
    """
    """
    from .forms import DomainPolicyForm
    return [{
        'id': 'amavis', 'title': _("Content filter"), 'cls': DomainPolicyForm,
        'formtpl': 'amavis/domain_content_filter.html'
    }]


@events.observe("ExtraDomainForm")
def extra_domain_form(user, domain):
    if not user.has_perm("admin.view_domains"):
        return []
    return send_amavis_form()


@events.observe('ExtraRelayDomainForm')
def extra_relaydomain_form(user, rdomain):
    if not user.has_perm("postfix_relay_domains.add_relaydomain"):
        return []
    return send_amavis_form()


@events.observe("FillDomainInstances")
def fill_domain_instances(user, domain, instances):
    if not user.has_perm("admin.view_domains"):
        return
    instances["amavis"] = domain


@events.observe("FillRelayDomainInstances")
def fill_relaydomain_instances(user, rdomain, instances):
    if not user.has_perm("postfix_relay_domains.add_relaydomain"):
        return
    instances["amavis"] = rdomain

########NEW FILE########
__FILENAME__ = lib
# coding: utf-8
import socket
import re
import struct
import string
from functools import wraps
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext as _
from modoboa.lib import parameters
from modoboa.lib.exceptions import InternalError
from modoboa.lib.webutils import NavigationParameters
from modoboa.extensions.amavis.models import Users, Policy


def selfservice(ssfunc=None):
    """Decorator used to expose views to the 'self-service' feature

    The 'self-service' feature allows users to act on quarantined
    messages without beeing authenticated.

    This decorator only acts as a 'router'.

    :param ssfunc: the function to call if the 'self-service'
                   pre-requisites are satisfied
    """
    def decorator(f):
        @wraps(f)
        def wrapped_f(request, *args, **kwargs):
            if request.user.is_authenticated():
                return f(request, *args, **kwargs)
            if parameters.get_admin("SELF_SERVICE") == "no":
                from django.contrib.auth.views import redirect_to_login
                return redirect_to_login(
                    reverse("modoboa.extensions.amavis.views.index")
                )
            return ssfunc(request, *args, **kwargs)
        return wrapped_f
    return decorator


class AMrelease(object):
    def __init__(self):
        mode = parameters.get_admin("AM_PDP_MODE")
        try:
            if mode == "inet":
                host = parameters.get_admin('AM_PDP_HOST')
                port = parameters.get_admin('AM_PDP_PORT')
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.sock.connect((host, int(port)))
            else:
                path = parameters.get_admin('AM_PDP_SOCKET')
                self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                self.sock.connect(path)
        except socket.error, err:
            raise InternalError(
                _("Connection to amavis failed: %s" % str(err))
            )

    def decode(self, answer):
        def repl(match):
            return struct.pack("B", string.atoi(match.group(0)[1:], 16))

        return re.sub(r"%([0-9a-fA-F]{2})", repl, answer)

    def __del__(self):
        self.sock.close()

    def sendreq(self, mailid, secretid, recipient, *others):
        self.sock.send("""request=release
mail_id=%s
secret_id=%s
quar_type=Q
recipient=%s

""" % (mailid, secretid, recipient))
        answer = self.sock.recv(1024)
        answer = self.decode(answer)
        if re.search("250 [\d\.]+ Ok", answer):
            return True
        return False


class QuarantineNavigationParameters(NavigationParameters):
    """
    Specific NavigationParameters subclass for the quarantine.
    """
    def __init__(self, request):
        super(QuarantineNavigationParameters, self).__init__(
            request, 'quarantine_navparams'
        )
        self.parameters += [('msgtype', None, False)]

    def back_to_listing(self):
        """Return the current listing URL.

        Looks into the user's session and the current request to build
        the URL.

        :return: a string
        """
        url = "listing"
        params = []
        navparams = self.request.session[self.sessionkey]
        if "page" in navparams:
            params += ["page=%s" % navparams["page"]]
        if "order" in navparams:
            params += ["sort_order=%s" % navparams["order"]]
        params += ["%s=%s" % (p[0], navparams[p[0]])
                   for p in self.parameters if p[0] in navparams]
        if params:
            url += "?%s" % ("&".join(params))
        return url


def create_user_and_policy(name):
    """Create records.

    Create two records (a user and a policy) using :keyword:`name` as
    an identifier.

    :param str name: name
    """
    policy = Policy.objects.create(policy_name=name[:32])
    Users.objects.create(
        email="@%s" % name, fullname=name,
        priority=7, policy=policy
    )


def create_user_and_use_policy(name, policy_name):
    """Create a *users* record and use an existing policy.

    :param str name: user record name
    :param str policy_name: policy name
    """
    policy = Policy.objects.get(policy_name=policy_name[:32])
    Users.objects.create(
        email="@%s" % name, fullname=name,
        priority=7, policy=policy
    )


def update_user_and_policy(oldname, newname):
    """Update records.

    :param str oldname: old name
    :param str newname: new name
    """
    if oldname == newname:
        return
    u = Users.objects.get(email="@%s" % oldname)
    u.email = "@%s" % newname
    u.fullname = newname
    u.policy.policy_name = newname[:32]
    u.policy.save()
    u.save()


def delete_user_and_policy(name):
    """Delete records.

    :param str name: identifier
    """
    try:
        u = Users.objects.get(email="@%s" % name)
    except Users.DoesNotExist:
        return
    u.policy.delete()
    u.delete()


def delete_user(name):
    """Delete a *users* record.

    :param str name: user record name
    """
    try:
        Users.objects.get(email="@%s" % name).delete()
    except Users.DoesNotExist:
        pass

########NEW FILE########
__FILENAME__ = amnotify
#!/usr/bin/env python
# coding: utf-8
from optparse import make_option
from django.core.management.base import BaseCommand, CommandError
from django.template.loader import render_to_string
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext as _
from modoboa.core.models import User
from modoboa.lib import parameters
from modoboa.lib.emailutils import sendmail_simple
from modoboa.extensions.admin.models import Domain
from modoboa.extensions.amavis import Amavis
from modoboa.extensions.amavis.models import (
    Msgrcpt
)
from modoboa.extensions.amavis.sql_listing import get_wrapper


class Command(BaseCommand):
    help = 'Amavis notification tool'

    sender = None
    baseurl = None
    listingurl = None

    option_list = BaseCommand.option_list + (
        make_option("--baseurl", type="string", default=None,
                    help="The scheme and hostname used to access Modoboa"),
        make_option("--smtp_host", type="string", default="localhost",
                    help="The address of the SMTP server used to send notifications"),
        make_option("--smtp_port", type="int", default=25,
                    help="The listening port of the SMTP server used to send notifications"),
        make_option("--verbose", action="store_true",
                    help="Activate verbose mode")
    )

    def handle(self, *args, **options):
        if options["baseurl"] is None:
            raise CommandError("You must provide the --baseurl option")
        self.options = options
        Amavis().load()
        self.notify_admins_pending_requests()

    def send_pr_notification(self, rcpt, reqs):
        if self.options["verbose"]:
            print "Sending notification to %s" % rcpt
        total = reqs.count()
        reqs = reqs.all()[:10]
        content = render_to_string(
            "amavis/notifications/pending_requests.html", dict(
                total=total, requests=reqs,
                baseurl=self.baseurl, listingurl=self.listingurl
            )
        )
        status, msg = sendmail_simple(
            self.sender, rcpt,
            subject=_("[modoboa] Pending release requests"),
            content=content,
            server=self.options["smtp_host"],
            port=self.options["smtp_port"]
        )
        if not status:
            print msg

    def notify_admins_pending_requests(self):
        self.sender = parameters.get_admin("NOTIFICATIONS_SENDER",
                                           app="amavis")
        self.baseurl = self.options["baseurl"].strip("/")
        self.listingurl = self.baseurl \
            + reverse("modoboa.extensions.amavis.views._listing") \
            + "?viewrequests=1"

        for da in User.objects.filter(groups__name="DomainAdmins"):
            if not da.mailbox_set.count():
                continue
            rcpt = da.mailbox_set.all()[0].full_address
            reqs = get_wrapper().get_domains_pending_requests(
                Domain.objects.get_for_admin(da)
            )
            if reqs.count():
                self.send_pr_notification(rcpt, reqs)

        reqs = Msgrcpt.objects.filter(rs='p')
        if not reqs.count():
            if self.options["verbose"]:
                print "No release request currently pending"
            return
        for su in User.objects.filter(is_superuser=True):
            if not su.mailbox_set.count():
                continue
            rcpt = su.mailbox_set.all()[0].full_address
            self.send_pr_notification(rcpt, reqs)

########NEW FILE########
__FILENAME__ = qcleanup
#!/usr/bin/env python
# coding: utf-8

import time
from optparse import make_option
from django.core.management.base import BaseCommand
from modoboa.lib import parameters
from modoboa.extensions.amavis import Amavis
from modoboa.extensions.amavis.models import (
    Msgrcpt, Msgs, Maddr
)


class Command(BaseCommand):
    args = ''
    help = 'Amavis quarantine cleanup'

    option_list = BaseCommand.option_list + (
        make_option('--debug',
                    action='store_true',
                    default=False,
                    help='Activate debug output'),
        make_option('--verbose',
                    action='store_true',
                    default=False,
                    help='Display informational messages')
    )

    def __vprint(self, msg):
        if not self.verbose:
            return
        print msg

    def handle(self, *args, **options):
        if options["debug"]:
            import logging
            l = logging.getLogger("django.db.backends")
            l.setLevel(logging.DEBUG)
            l.addHandler(logging.StreamHandler())
        self.verbose = options["verbose"]

        Amavis().load()

        max_messages_age = int(parameters.get_admin("MAX_MESSAGES_AGE",
                                                    app="amavis"))

        flags = ['D']
        if parameters.get_admin("RELEASED_MSGS_CLEANUP",
                                app="amavis") == "yes":
            flags += ['R']

        self.__vprint("Deleting marked messages...")
        ids = Msgrcpt.objects.filter(rs__in=flags).values("mail_id").distinct()
        for msg in Msgs.objects.filter(mail_id__in=ids):
            if not msg.msgrcpt_set.exclude(rs__in=flags).count():
                msg.delete()

        self.__vprint("Deleting messages older than %d days..." % max_messages_age)
        limit = int(time.time()) - (max_messages_age * 24 * 3600)
        Msgs.objects.filter(time_num__lt=limit).delete()

        self.__vprint("Deleting unreferenced e-mail addresses...")
        for maddr in Maddr.objects.all():
            if not maddr.msgs_set.count() and not maddr.msgrcpt_set.count():
                maddr.delete()

        self.__vprint("Done.")

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        pass

    def backwards(self, orm):
        pass

    models = {
        'amavis.maddr': {
            'Meta': {'object_name': 'Maddr', 'db_table': "u'maddr'", 'managed': 'False'},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '765'}),
            'email': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'id': ('django.db.models.fields.BigIntegerField', [], {'primary_key': 'True'}),
            'partition_tag': ('django.db.models.fields.IntegerField', [], {'unique': 'True', 'null': 'True', 'blank': 'True'})
        },
        'amavis.mailaddr': {
            'Meta': {'object_name': 'Mailaddr', 'db_table': "u'mailaddr'", 'managed': 'False'},
            'email': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'id': ('django.db.models.fields.IntegerField', [], {'primary_key': 'True'}),
            'priority': ('django.db.models.fields.IntegerField', [], {})
        },
        'amavis.msgrcpt': {
            'Meta': {'unique_together': "(('partition_tag', 'mail', 'rseqnum'),)", 'object_name': 'Msgrcpt', 'db_table': "u'msgrcpt'", 'managed': 'False'},
            'bl': ('django.db.models.fields.CharField', [], {'max_length': '3', 'blank': 'True'}),
            'bspam_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'content': ('django.db.models.fields.CharField', [], {'max_length': '3'}),
            'ds': ('django.db.models.fields.CharField', [], {'max_length': '3'}),
            'is_local': ('django.db.models.fields.CharField', [], {'max_length': '3'}),
            'mail': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['amavis.Msgs']", 'primary_key': 'True'}),
            'partition_tag': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'rid': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['amavis.Maddr']", 'primary_key': 'True', 'db_column': "'rid'"}),
            'rs': ('django.db.models.fields.CharField', [], {'max_length': '3'}),
            'rseqnum': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'smtp_resp': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'wl': ('django.db.models.fields.CharField', [], {'max_length': '3', 'blank': 'True'})
        },
        'amavis.msgs': {
            'Meta': {'unique_together': "(('partition_tag', 'mail_id'),)", 'object_name': 'Msgs', 'db_table': "u'msgs'", 'managed': 'False'},
            'am_id': ('django.db.models.fields.CharField', [], {'max_length': '60'}),
            'client_addr': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'content': ('django.db.models.fields.CharField', [], {'max_length': '1', 'blank': 'True'}),
            'dsn_sent': ('django.db.models.fields.CharField', [], {'max_length': '3', 'blank': 'True'}),
            'from_addr': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'max_length': '765'}),
            'mail_id': ('django.db.models.fields.CharField', [], {'max_length': '12', 'primary_key': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'originating': ('django.db.models.fields.CharField', [], {'max_length': '3'}),
            'partition_tag': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'policy': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'quar_loc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'quar_type': ('django.db.models.fields.CharField', [], {'max_length': '1', 'blank': 'True'}),
            'secret_id': ('django.db.models.fields.CharField', [], {'max_length': '12', 'blank': 'True'}),
            'sid': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['amavis.Maddr']", 'db_column': "'sid'"}),
            'size': ('django.db.models.fields.IntegerField', [], {}),
            'spam_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'subject': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'time_iso': ('django.db.models.fields.CharField', [], {'max_length': '48'}),
            'time_num': ('django.db.models.fields.IntegerField', [], {})
        },
        'amavis.policy': {
            'Meta': {'object_name': 'Policy', 'db_table': "u'policy'", 'managed': 'False'},
            'addr_extension_bad_header': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'addr_extension_banned': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'addr_extension_spam': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'addr_extension_virus': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'archive_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'bad_header_admin': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'bad_header_lover': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'bad_header_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'banned_admin': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'banned_files_lover': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'banned_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'banned_rulenames': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'bypass_banned_checks': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '3', 'null': 'True'}),
            'bypass_header_checks': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'bypass_spam_checks': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '3', 'null': 'True'}),
            'bypass_virus_checks': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '3', 'null': 'True'}),
            'clean_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'disclaimer_options': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'forward_method': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message_size_limit': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'newvirus_admin': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'policy_name': ('django.db.models.fields.CharField', [], {'max_length': '96', 'blank': 'True'}),
            'sa_userconf': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'sa_username': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_admin': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_dsn_cutoff_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'spam_kill_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'spam_lover': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'spam_quarantine_cutoff_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'spam_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_subject_tag': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_subject_tag2': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_subject_tag3': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_tag2_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'spam_tag3_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'spam_tag_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'unchecked_lover': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'unchecked_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'virus_admin': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'virus_lover': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'virus_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'warnbadhrecip': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'warnbannedrecip': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'warnvirusrecip': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'})
        },
        'amavis.quarantine': {
            'Meta': {'ordering': "['-mail__time_num']", 'unique_together': "(('partition_tag', 'mail', 'chunk_ind'),)", 'object_name': 'Quarantine', 'db_table': "u'quarantine'", 'managed': 'False'},
            'chunk_ind': ('django.db.models.fields.IntegerField', [], {}),
            'mail': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['amavis.Msgs']", 'primary_key': 'True'}),
            'mail_text': ('django.db.models.fields.TextField', [], {}),
            'partition_tag': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'amavis.users': {
            'Meta': {'object_name': 'Users', 'db_table': "u'users'", 'managed': 'False'},
            'email': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'fullname': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'policy': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['amavis.Policy']"}),
            'priority': ('django.db.models.fields.IntegerField', [], {})
        },
        'amavis.wblist': {
            'Meta': {'object_name': 'Wblist', 'db_table': "u'wblist'", 'managed': 'False'},
            'rid': ('django.db.models.fields.IntegerField', [], {'primary_key': 'True'}),
            'sid': ('django.db.models.fields.IntegerField', [], {'primary_key': 'True'}),
            'wb': ('django.db.models.fields.CharField', [], {'max_length': '30'})
        }
    }

    complete_apps = ['amavis']

########NEW FILE########
__FILENAME__ = 0002_create_records
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models
from django.core.exceptions import ObjectDoesNotExist

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        orm["amavis.Users"].objects.all().delete()
        if not orm['amavis.Policy'].objects.all():
            orm["amavis.Policy"].objects.create(
                id=1, policy_name='default', bypass_virus_checks=None,
                bypass_spam_checks=None, bypass_banned_checks=None,
                spam_subject_tag2=None
            )
        for dom in orm["admin.Domain"].objects.all():
            orm["amavis.Users"].objects.create(email="@%s" % dom.name, fullname=dom.name,
                                               priority=7, policy_id=1)
        try:
            ext = orm["admin.Extension"].objects.get(name="amavis")
        except ObjectDoesNotExist:
            return
        if ext.enabled:
            for dom in orm["admin.Domain"].objects.all():
                u = orm["amavis.Users"].objects.get(email="@%s" % dom.name)
                u.policy = orm["amavis.Policy"].objects.create(policy_name=dom.name)
                u.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("Cannot revert this migration")

    models = {
        'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'amavis.maddr': {
            'Meta': {'object_name': 'Maddr', 'db_table': "u'maddr'", 'managed': 'False'},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '765'}),
            'email': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'id': ('django.db.models.fields.BigIntegerField', [], {'primary_key': 'True'}),
            'partition_tag': ('django.db.models.fields.IntegerField', [], {'unique': 'True', 'null': 'True', 'blank': 'True'})
        },
        'amavis.mailaddr': {
            'Meta': {'object_name': 'Mailaddr', 'db_table': "u'mailaddr'", 'managed': 'False'},
            'email': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'id': ('django.db.models.fields.IntegerField', [], {'primary_key': 'True'}),
            'priority': ('django.db.models.fields.IntegerField', [], {})
        },
        'amavis.msgrcpt': {
            'Meta': {'unique_together': "(('partition_tag', 'mail', 'rseqnum'),)", 'object_name': 'Msgrcpt', 'db_table': "u'msgrcpt'", 'managed': 'False'},
            'bl': ('django.db.models.fields.CharField', [], {'max_length': '3', 'blank': 'True'}),
            'bspam_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'content': ('django.db.models.fields.CharField', [], {'max_length': '3'}),
            'ds': ('django.db.models.fields.CharField', [], {'max_length': '3'}),
            'is_local': ('django.db.models.fields.CharField', [], {'max_length': '3'}),
            'mail': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['amavis.Msgs']", 'primary_key': 'True'}),
            'partition_tag': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'rid': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['amavis.Maddr']", 'primary_key': 'True', 'db_column': "'rid'"}),
            'rs': ('django.db.models.fields.CharField', [], {'max_length': '3'}),
            'rseqnum': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'smtp_resp': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'wl': ('django.db.models.fields.CharField', [], {'max_length': '3', 'blank': 'True'})
        },
        'amavis.msgs': {
            'Meta': {'unique_together': "(('partition_tag', 'mail_id'),)", 'object_name': 'Msgs', 'db_table': "u'msgs'", 'managed': 'False'},
            'am_id': ('django.db.models.fields.CharField', [], {'max_length': '60'}),
            'client_addr': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'content': ('django.db.models.fields.CharField', [], {'max_length': '1', 'blank': 'True'}),
            'dsn_sent': ('django.db.models.fields.CharField', [], {'max_length': '3', 'blank': 'True'}),
            'from_addr': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'max_length': '765'}),
            'mail_id': ('django.db.models.fields.CharField', [], {'max_length': '12', 'primary_key': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'originating': ('django.db.models.fields.CharField', [], {'max_length': '3'}),
            'partition_tag': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'policy': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'quar_loc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'quar_type': ('django.db.models.fields.CharField', [], {'max_length': '1', 'blank': 'True'}),
            'secret_id': ('django.db.models.fields.CharField', [], {'max_length': '12', 'blank': 'True'}),
            'sid': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['amavis.Maddr']", 'db_column': "'sid'"}),
            'size': ('django.db.models.fields.IntegerField', [], {}),
            'spam_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'subject': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'time_iso': ('django.db.models.fields.CharField', [], {'max_length': '48'}),
            'time_num': ('django.db.models.fields.IntegerField', [], {})
        },
        'amavis.policy': {
            'Meta': {'object_name': 'Policy', 'db_table': "u'policy'", 'managed': 'False'},
            'addr_extension_bad_header': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'addr_extension_banned': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'addr_extension_spam': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'addr_extension_virus': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'archive_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'bad_header_admin': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'bad_header_lover': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'bad_header_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'banned_admin': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'banned_files_lover': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'banned_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'banned_rulenames': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'bypass_banned_checks': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '3', 'null': 'True'}),
            'bypass_header_checks': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'bypass_spam_checks': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '3', 'null': 'True'}),
            'bypass_virus_checks': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '3', 'null': 'True'}),
            'clean_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'disclaimer_options': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'forward_method': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message_size_limit': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'newvirus_admin': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'policy_name': ('django.db.models.fields.CharField', [], {'max_length': '96', 'blank': 'True'}),
            'sa_userconf': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'sa_username': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_admin': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_dsn_cutoff_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'spam_kill_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'spam_lover': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'spam_quarantine_cutoff_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'spam_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_subject_tag': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_subject_tag2': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_subject_tag3': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_tag2_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'spam_tag3_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'spam_tag_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'unchecked_lover': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'unchecked_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'virus_admin': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'virus_lover': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'virus_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'warnbadhrecip': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'warnbannedrecip': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'warnvirusrecip': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'})
        },
        'amavis.quarantine': {
            'Meta': {'ordering': "['-mail__time_num']", 'unique_together': "(('partition_tag', 'mail', 'chunk_ind'),)", 'object_name': 'Quarantine', 'db_table': "u'quarantine'", 'managed': 'False'},
            'chunk_ind': ('django.db.models.fields.IntegerField', [], {}),
            'mail': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['amavis.Msgs']", 'primary_key': 'True'}),
            'mail_text': ('django.db.models.fields.TextField', [], {}),
            'partition_tag': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'amavis.users': {
            'Meta': {'object_name': 'Users', 'db_table': "u'users'", 'managed': 'False'},
            'email': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'fullname': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'policy': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['amavis.Policy']"}),
            'priority': ('django.db.models.fields.IntegerField', [], {})
        },
        'amavis.wblist': {
            'Meta': {'object_name': 'Wblist', 'db_table': "u'wblist'", 'managed': 'False'},
            'rid': ('django.db.models.fields.IntegerField', [], {'primary_key': 'True'}),
            'sid': ('django.db.models.fields.IntegerField', [], {'primary_key': 'True'}),
            'wb': ('django.db.models.fields.CharField', [], {'max_length': '30'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['admin', 'amavis']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0003_create_domalias_records
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models
from django.core.exceptions import ObjectDoesNotExist

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        try:
            ext = orm["core.Extension"].objects.get(name="amavis")
        except ObjectDoesNotExist:
            return
        if not ext.enabled:
            return
        for domalias in orm["admin.DomainAlias"].objects.all():
            u = orm["amavis.Users"](
                email="@%s" % domalias.name, fullname=domalias.name, priority=7
            )
            u.policy = orm["amavis.Policy"].objects.get(policy_name=domalias.target.name)
            u.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("Cannot revert this migration")

    models = {
        'admin.alias': {
            'Meta': {'ordering': "['domain__name', 'address']", 'unique_together': "(('address', 'domain'),)", 'object_name': 'Alias'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '254'}),
            'aliases': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Alias']", 'symmetrical': 'False'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'extmboxes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mboxes': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['admin.Mailbox']", 'symmetrical': 'False'})
        },
        'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.domainalias': {
            'Meta': {'object_name': 'DomainAlias'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'target': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '252'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'use_domain_quota': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['core.User']"})
        },
        'admin.mailboxoperation': {
            'Meta': {'object_name': 'MailboxOperation'},
            'argument': ('django.db.models.fields.TextField', [], {}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mailbox': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Mailbox']", 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '20'})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'admin.quota': {
            'Meta': {'object_name': 'Quota'},
            'bytes': ('django.db.models.fields.BigIntegerField', [], {'default': '0'}),
            'mbox': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'quota_value'", 'unique': 'True', 'null': 'True', 'to': "orm['admin.Mailbox']"}),
            'messages': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'username': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'primary_key': 'True'})
        },
        u'amavis.maddr': {
            'Meta': {'object_name': 'Maddr', 'db_table': "u'maddr'", 'managed': 'False'},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '765'}),
            'email': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'id': ('django.db.models.fields.BigIntegerField', [], {'primary_key': 'True'}),
            'partition_tag': ('django.db.models.fields.IntegerField', [], {'unique': 'True', 'null': 'True', 'blank': 'True'})
        },
        u'amavis.mailaddr': {
            'Meta': {'object_name': 'Mailaddr', 'db_table': "u'mailaddr'", 'managed': 'False'},
            'email': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'id': ('django.db.models.fields.IntegerField', [], {'primary_key': 'True'}),
            'priority': ('django.db.models.fields.IntegerField', [], {})
        },
        u'amavis.msgrcpt': {
            'Meta': {'unique_together': "(('partition_tag', 'mail', 'rseqnum'),)", 'object_name': 'Msgrcpt', 'db_table': "u'msgrcpt'", 'managed': 'False'},
            'bl': ('django.db.models.fields.CharField', [], {'max_length': '3', 'blank': 'True'}),
            'bspam_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'content': ('django.db.models.fields.CharField', [], {'max_length': '3'}),
            'ds': ('django.db.models.fields.CharField', [], {'max_length': '3'}),
            'is_local': ('django.db.models.fields.CharField', [], {'max_length': '3'}),
            'mail': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['amavis.Msgs']", 'primary_key': 'True'}),
            'partition_tag': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'rid': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['amavis.Maddr']", 'primary_key': 'True', 'db_column': "'rid'"}),
            'rs': ('django.db.models.fields.CharField', [], {'max_length': '3'}),
            'rseqnum': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'smtp_resp': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'wl': ('django.db.models.fields.CharField', [], {'max_length': '3', 'blank': 'True'})
        },
        u'amavis.msgs': {
            'Meta': {'unique_together': "(('partition_tag', 'mail_id'),)", 'object_name': 'Msgs', 'db_table': "u'msgs'", 'managed': 'False'},
            'am_id': ('django.db.models.fields.CharField', [], {'max_length': '60'}),
            'client_addr': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'content': ('django.db.models.fields.CharField', [], {'max_length': '1', 'blank': 'True'}),
            'dsn_sent': ('django.db.models.fields.CharField', [], {'max_length': '3', 'blank': 'True'}),
            'from_addr': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'max_length': '765'}),
            'mail_id': ('django.db.models.fields.CharField', [], {'max_length': '12', 'primary_key': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'originating': ('django.db.models.fields.CharField', [], {'max_length': '3'}),
            'partition_tag': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'policy': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'quar_loc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'quar_type': ('django.db.models.fields.CharField', [], {'max_length': '1', 'blank': 'True'}),
            'secret_id': ('django.db.models.fields.CharField', [], {'max_length': '12', 'blank': 'True'}),
            'sid': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['amavis.Maddr']", 'db_column': "'sid'"}),
            'size': ('django.db.models.fields.IntegerField', [], {}),
            'spam_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'subject': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'time_iso': ('django.db.models.fields.CharField', [], {'max_length': '48'}),
            'time_num': ('django.db.models.fields.IntegerField', [], {})
        },
        u'amavis.policy': {
            'Meta': {'object_name': 'Policy', 'db_table': "u'policy'", 'managed': 'False'},
            'addr_extension_bad_header': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'addr_extension_banned': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'addr_extension_spam': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'addr_extension_virus': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'archive_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'bad_header_admin': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'bad_header_lover': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'bad_header_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'banned_admin': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'banned_files_lover': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'banned_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'banned_rulenames': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'bypass_banned_checks': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '3', 'null': 'True'}),
            'bypass_header_checks': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'bypass_spam_checks': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '3', 'null': 'True'}),
            'bypass_virus_checks': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '3', 'null': 'True'}),
            'clean_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'disclaimer_options': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'forward_method': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message_size_limit': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'newvirus_admin': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'policy_name': ('django.db.models.fields.CharField', [], {'max_length': '96', 'blank': 'True'}),
            'sa_userconf': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'sa_username': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_admin': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_dsn_cutoff_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'spam_kill_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'spam_lover': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'spam_quarantine_cutoff_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'spam_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_subject_tag': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_subject_tag2': ('django.db.models.fields.CharField', [], {'default': 'None', 'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_subject_tag3': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'spam_tag2_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'spam_tag3_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'spam_tag_level': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'unchecked_lover': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'unchecked_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'virus_admin': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'virus_lover': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'virus_quarantine_to': ('django.db.models.fields.CharField', [], {'max_length': '192', 'null': 'True', 'blank': 'True'}),
            'warnbadhrecip': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'warnbannedrecip': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'}),
            'warnvirusrecip': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True', 'blank': 'True'})
        },
        u'amavis.quarantine': {
            'Meta': {'ordering': "['-mail__time_num']", 'unique_together': "(('partition_tag', 'mail', 'chunk_ind'),)", 'object_name': 'Quarantine', 'db_table': "u'quarantine'", 'managed': 'False'},
            'chunk_ind': ('django.db.models.fields.IntegerField', [], {}),
            'mail': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['amavis.Msgs']", 'primary_key': 'True'}),
            'mail_text': ('django.db.models.fields.TextField', [], {}),
            'partition_tag': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        u'amavis.users': {
            'Meta': {'object_name': 'Users', 'db_table': "u'users'", 'managed': 'False'},
            'email': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'fullname': ('django.db.models.fields.CharField', [], {'max_length': '765', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'policy': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['amavis.Policy']"}),
            'priority': ('django.db.models.fields.IntegerField', [], {})
        },
        u'amavis.wblist': {
            'Meta': {'object_name': 'Wblist', 'db_table': "u'wblist'", 'managed': 'False'},
            'rid': ('django.db.models.fields.IntegerField', [], {'primary_key': 'True'}),
            'sid': ('django.db.models.fields.IntegerField', [], {'primary_key': 'True'}),
            'wb': ('django.db.models.fields.CharField', [], {'max_length': '30'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'core.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'core.log': {
            'Meta': {'object_name': 'Log'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.CharField', [], {'max_length': '15'}),
            'logger': ('django.db.models.fields.CharField', [], {'max_length': '30'}),
            'message': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        u'core.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['core.User']"})
        },
        u'core.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_local': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        }
    }

    complete_apps = ['core', 'admin', 'amavis']
    symmetrical = True

########NEW FILE########
__FILENAME__ = models
# This is an auto-generated Django model module.
# You'll have to do the following manually to clean this up:
#     * Rearrange models' order
#     * Make sure each model has one field with primary_key=True
# Feel free to rename the models, but don't rename db_table values or field names.
#
# Also note: You'll have to insert the output of 'django-admin.py sqlcustom [appname]'
# into your database.
#
# Original Amavis version : 2.6.2

from django.db import models
from django.utils.translation import ugettext_lazy


class Maddr(models.Model):
    partition_tag = models.IntegerField(unique=True, null=True, blank=True)
    id = models.BigIntegerField(primary_key=True)
    email = models.CharField(unique=True, max_length=255)
    domain = models.CharField(max_length=765)

    class Meta:
        db_table = u'maddr'
        managed = False


class Mailaddr(models.Model):
    id = models.IntegerField(primary_key=True)
    priority = models.IntegerField()
    email = models.CharField(unique=True, max_length=255)

    class Meta:
        db_table = u'mailaddr'
        managed = False


class Msgs(models.Model):
    partition_tag = models.IntegerField(null=True, blank=True)
    mail_id = models.CharField(max_length=12, primary_key=True)
    secret_id = models.CharField(max_length=12, blank=True)
    am_id = models.CharField(max_length=60)
    time_num = models.IntegerField()
    time_iso = models.CharField(max_length=48)
    sid = models.ForeignKey(Maddr, db_column='sid')
    policy = models.CharField(max_length=765, blank=True)
    client_addr = models.CharField(max_length=765, blank=True)
    size = models.IntegerField()
    originating = models.CharField(max_length=3)
    content = models.CharField(max_length=1, blank=True)
    quar_type = models.CharField(max_length=1, blank=True)
    quar_loc = models.CharField(max_length=255, blank=True)
    dsn_sent = models.CharField(max_length=3, blank=True)
    spam_level = models.FloatField(null=True, blank=True)
    message_id = models.CharField(max_length=765, blank=True)
    from_addr = models.CharField(max_length=765, blank=True)
    subject = models.CharField(max_length=765, blank=True)
    host = models.CharField(max_length=765)

    class Meta:
        db_table = u'msgs'
        managed = False
        unique_together = ('partition_tag', 'mail_id')


class Msgrcpt(models.Model):
    partition_tag = models.IntegerField(null=True, blank=True)
    mail = models.ForeignKey(Msgs, primary_key=True)
    rid = models.ForeignKey(Maddr, db_column='rid')
    rseqnum = models.IntegerField(default=0)
    is_local = models.CharField(max_length=3)
    content = models.CharField(max_length=3)
    ds = models.CharField(max_length=3)
    rs = models.CharField(max_length=3)
    bl = models.CharField(max_length=3, blank=True)
    wl = models.CharField(max_length=3, blank=True)
    bspam_level = models.FloatField(null=True, blank=True)
    smtp_resp = models.CharField(max_length=765, blank=True)

    class Meta:
        db_table = u'msgrcpt'
        managed = False
        unique_together = ("partition_tag", "mail", "rseqnum")


class Policy(models.Model):
    policy_name = models.CharField(max_length=32, blank=True)
    virus_lover = models.CharField(max_length=3, blank=True, null=True)
    spam_lover = models.CharField(max_length=3, blank=True, null=True)
    unchecked_lover = models.CharField(max_length=3, blank=True, null=True)
    banned_files_lover = models.CharField(max_length=3, blank=True, null=True)
    bad_header_lover = models.CharField(max_length=3, blank=True, null=True)
    bypass_virus_checks = models.CharField(
        ugettext_lazy("Virus filter"), default='', null=True,
        choices=(('N', ugettext_lazy('yes')),
                 ('Y', ugettext_lazy('no')),
                 ('', ugettext_lazy('default'))),
        max_length=3,
        help_text=ugettext_lazy("Bypass virus checks or not. Choose 'default' to use global settings.")
        )
    bypass_spam_checks = models.CharField(
        ugettext_lazy("Spam filter"), default='', null=True,
        choices=(('N', ugettext_lazy('yes')),
                 ('Y', ugettext_lazy('no')),
                 ('', ugettext_lazy('default'))),
        max_length=3,
        help_text=ugettext_lazy("Bypass spam checks or not. Choose 'default' to use global settings.")
        )
    bypass_banned_checks = models.CharField(
        ugettext_lazy("Banned filter"), default='', null=True,
        choices=(('N', ugettext_lazy('yes')),
                 ('Y', ugettext_lazy('no')),
                 ('', ugettext_lazy('default'))),
        max_length=3,
        help_text=ugettext_lazy("Bypass banned checks or not. Choose 'default' to use global settings.")
        )
    bypass_header_checks = models.CharField(max_length=3, blank=True, null=True)
    virus_quarantine_to = models.CharField(max_length=192, blank=True, null=True)
    spam_quarantine_to = models.CharField(max_length=192, blank=True, null=True)
    banned_quarantine_to = models.CharField(max_length=192, blank=True, null=True)
    unchecked_quarantine_to = models.CharField(max_length=192, blank=True, null=True)
    bad_header_quarantine_to = models.CharField(max_length=192, blank=True, null=True)
    clean_quarantine_to = models.CharField(max_length=192, blank=True, null=True)
    archive_quarantine_to = models.CharField(max_length=192, blank=True, null=True)
    spam_tag_level = models.FloatField(null=True, blank=True)
    spam_tag2_level = models.FloatField(null=True, blank=True)
    spam_tag3_level = models.FloatField(null=True, blank=True)
    spam_kill_level = models.FloatField(null=True, blank=True)
    spam_dsn_cutoff_level = models.FloatField(null=True, blank=True)
    spam_quarantine_cutoff_level = models.FloatField(null=True, blank=True)
    addr_extension_virus = models.CharField(max_length=192, blank=True, null=True)
    addr_extension_spam = models.CharField(max_length=192, blank=True, null=True)
    addr_extension_banned = models.CharField(max_length=192, blank=True, null=True)
    addr_extension_bad_header = models.CharField(max_length=192, blank=True, null=True)
    warnvirusrecip = models.CharField(max_length=3, blank=True, null=True)
    warnbannedrecip = models.CharField(max_length=3, blank=True, null=True)
    warnbadhrecip = models.CharField(max_length=3, blank=True, null=True)
    newvirus_admin = models.CharField(max_length=192, blank=True, null=True)
    virus_admin = models.CharField(max_length=192, blank=True, null=True)
    banned_admin = models.CharField(max_length=192, blank=True, null=True)
    bad_header_admin = models.CharField(max_length=192, blank=True, null=True)
    spam_admin = models.CharField(max_length=192, blank=True, null=True)
    spam_subject_tag = models.CharField(max_length=192, blank=True, null=True)
    spam_subject_tag2 = models.CharField(
        ugettext_lazy("Spam marker"), default=None,
        max_length=192, blank=True, null=True,
        help_text=ugettext_lazy("Modify spam subject using the specified text. Choose 'default' to use global settings.")
        )
    spam_subject_tag3 = models.CharField(max_length=192, blank=True, null=True)
    message_size_limit = models.IntegerField(null=True, blank=True)
    banned_rulenames = models.CharField(max_length=192, blank=True, null=True)
    disclaimer_options = models.CharField(max_length=192, blank=True, null=True)
    forward_method = models.CharField(max_length=192, blank=True, null=True)
    sa_userconf = models.CharField(max_length=192, blank=True, null=True)
    sa_username = models.CharField(max_length=192, blank=True, null=True)

    class Meta:
        db_table = u'policy'
        managed = False


class Quarantine(models.Model):
    partition_tag = models.IntegerField(null=True, blank=True)
    mail = models.ForeignKey(Msgs, primary_key=True)
    chunk_ind = models.IntegerField()
    mail_text = models.TextField()

    class Meta:
        db_table = u'quarantine'
        managed = False
        ordering = ["-mail__time_num"]
        unique_together = ("partition_tag", "mail", "chunk_ind")


class Users(models.Model):
    id = models.AutoField(primary_key=True)
    priority = models.IntegerField()
    policy = models.ForeignKey(Policy)
    email = models.CharField(unique=True, max_length=255)
    fullname = models.CharField(max_length=765, blank=True)

    class Meta:
        db_table = u'users'
        managed = False


class Wblist(models.Model):
    rid = models.IntegerField(primary_key=True)
    sid = models.IntegerField(primary_key=True)
    wb = models.CharField(max_length=30)

    class Meta:
        db_table = u'wblist'
        managed = False

########NEW FILE########
__FILENAME__ = sql_listing
# coding: utf-8
import re
from datetime import datetime
from django.template.loader import render_to_string
from django.utils.translation import ugettext_lazy
from django.db.models import Q
from modoboa.lib import tables
from modoboa.lib.webutils import static_url
from modoboa.lib.email_listing import MBconnector, EmailListing
from modoboa.lib.emailutils import Email
from modoboa.lib.dbutils import db_type
from modoboa.extensions.admin.models import Domain
from .models import Quarantine, Msgrcpt


class Qtable(tables.Table):
    tableid = "emails"
    styles = "table-condensed"
    idkey = "mailid"

    selection = tables.SelectionColumn(
        "selection", safe=True, width='5px', header=None, sortable=False
    )
    type = tables.Column(
        "type", align="center", width="30px", sort_order="type", safe=True
    )
    rstatus = tables.ImgColumn(
        "rstatus", width='25px', sortable=False
    )
    score = tables.Column(
        "score", label=ugettext_lazy("Score"), limit=6,
        sort_order="score", cssclass="openable"
    )
    to = tables.Column(
        "to", label=ugettext_lazy("To"), sort_order="to", cssclass="openable"
    )
    from_ = tables.Column(
        "from", label=ugettext_lazy("From"), limit=30,
        sort_order="from", cssclass="openable"
    )
    subject = tables.Column(
        "subject", label=ugettext_lazy("Subject"), limit=40,
        sort_order="subject", cssclass="openable"
    )
    time = tables.Column(
        "date", label=ugettext_lazy("Date"), sort_order="date",
        cssclass="openable"
    )

    cols_order = [
        'selection', 'type', 'rstatus', 'score', 'to', 'from_', 'subject',
        'time'
    ]

    def parse_type(self, value):
        color = 'important' if value in ['S', 'V'] else 'warning'
        return '<span class="label label-%s">%s</span>' % (color, value)

    def parse_date(self, value):
        return datetime.fromtimestamp(value)


class SQLconnector(MBconnector):
    order_translation_table = {
        "type": "mail__msgrcpt__content",
        "score": "mail__msgrcpt__bspam_level",
        "date": "mail__time_num",
        "subject": "mail__subject",
        "from": "mail__from_addr",
        "to": "mail__msgrcpt__rid__email"
    }

    def __init__(self, mail_ids=None, filter=None):
        self.count = None
        self.messages = None
        self.mail_ids = mail_ids
        self.filter = filter

    def messages_count(self, **kwargs):
        if self.count is None:
            filter = Q(chunk_ind=1)
            if self.mail_ids is not None:
                filter &= Q(mail__in=self.mail_ids)
            if self.filter:
                filter &= self.filter
            self.messages = Quarantine.objects.filter(filter).values(
                "mail__from_addr",
                "mail__msgrcpt__rid__email",
                "mail__subject",
                "mail__mail_id",
                "mail__time_num",
                "mail__msgrcpt__content",
                "mail__msgrcpt__bspam_level",
                "mail__msgrcpt__rs"
            )
            if "order" in kwargs:
                order = kwargs["order"]
                sign = ""
                if order[0] == "-":
                    sign = "-"
                    order = order[1:]
                order = self.order_translation_table[order]
                self.messages = self.messages.order_by(sign + order)

            self.count = self.messages.count()
        return self.count

    def fetch(self, start=None, stop=None, **kwargs):
        emails = []
        for qm in self.messages[start - 1:stop]:
            m = {"from": qm["mail__from_addr"],
                 "to": qm["mail__msgrcpt__rid__email"],
                 "subject": qm["mail__subject"],
                 "mailid": qm["mail__mail_id"],
                 "date": qm["mail__time_num"],
                 "type": qm["mail__msgrcpt__content"],
                 "score": qm["mail__msgrcpt__bspam_level"]}
            rs = qm["mail__msgrcpt__rs"]
            if rs == 'D':
                continue
            elif rs in ['', ' ']:
                m["class"] = "unseen"
            elif rs == 'R':
                m["img_rstatus"] = static_url("pics/release.png")
            elif rs == 'p':
                m["class"] = "pending"
            emails.append(m)
        return emails


class SQLWrapper(object):
    """A simple SQL wrapper.

    This wrapper has been added just to answer the *Postgres bytea
    fields* issue :p

    The base class doesn't add anything special but defines the method
    (and so piece of SQL queries) that should be overloaded when
    Postgres is in use.

    See ``PgWrapper`` for the real mess...
    """

    def _exec(self, query, args):
        """Execute a raw SQL query.

        :param string query: query to execute
        :param list args: a list of arguments to replace in :kw:`query`
        """
        from django.db import connections, transaction

        cursor = connections['amavis'].cursor()
        cursor.execute(query, args)
        transaction.commit_unless_managed(using='amavis')

    def get_mails(self, request, rcptfilter=None):
        """Retrieve all messages visible by a user.

        Simple users can only see the messages 

        :rtype: QuerySet
        """
        q = Q(rs='p') \
            if request.GET.get("viewrequests", None) == "1" else ~Q(rs='D')
        if request.user.group == 'SimpleUsers':
            rcpts = [request.user.email] \
                + request.user.mailbox_set.all()[0].alias_addresses
            q &= Q(rid__email__in=rcpts)
        elif not request.user.is_superuser:
            doms = Domain.objects.get_for_admin(request.user)
            regexp = "(%s)" % '|'.join([dom.name for dom in doms])
            doms_q = Q(rid__email__regex=regexp)
            q &= doms_q
        if rcptfilter is not None:
            q &= Q(rid__email__contains=rcptfilter)
        return Msgrcpt.objects.filter(q).values("mail_id")

    def get_recipient_message(self, address, mailid):
        return Msgrcpt.objects.get(mail=mailid, rid__email=address)

    def set_msgrcpt_status(self, address, mailid, status):
        """Change the status (rs field) of a message recipient.

        :param string status: status
        """
        from modoboa.extensions.amavis.models import Maddr

        addr = Maddr.objects.get(email=address)
        self._exec(
            "UPDATE msgrcpt SET rs=%s WHERE mail_id=%s AND rid=%s",
            [status, mailid, addr.id]
        )

    def get_recipient_messages(self, address, mailids):
        return Msgrcpt.objects.filter(mail__in=mailids, rid__email=address)

    def get_domains_pending_requests(self, domains):
        regexp = "(%s)" % '|'.join([dom.name for dom in domains])
        return Msgrcpt.objects.filter(rs='p', rid__email__regex=regexp)

    def get_pending_requests(self, user):
        """Return the number of current pending requests

        :param user: a ``User`` instance
        """
        rq = Q(rs='p')
        if not user.is_superuser:
            doms = Domain.objects.get_for_admin(user)
            if not doms.count():
                return 0
            regexp = "(%s)" % '|'.join([dom.name for dom in doms])
            doms_q = Q(rid__email__regex=regexp)
            rq &= doms_q
        return Msgrcpt.objects.filter(rq).count()

    def get_mail_content(self, mailid):
        return Quarantine.objects.filter(mail=mailid)


class PgWrapper(SQLWrapper):
    """The postgres wrapper

    Make use of ``QuerySet.extra`` and postgres ``convert_from``
    function to let the quarantine manager work as expected !
    """

    def get_mails(self, request, rcptfilter=None):
        q = Q(rs='p') \
            if request.GET.get("viewrequests", None) == "1" else ~Q(rs='D')
        where = ["U0.rid=maddr.id"]
        if request.user.group == 'SimpleUsers':
            rcpts = [request.user.email] \
                + request.user.mailbox_set.all()[0].alias_addresses
            where.append("convert_from(maddr.email, 'UTF8') IN (%s)" \
                             % (','.join(["'%s'" % rcpt for rcpt in rcpts])))
        elif not request.user.is_superuser:
            doms = Domain.objects.get_for_admin(request.user)
            regexp = "(%s)" % '|'.join([dom.name for dom in doms])
            where.append("convert_from(maddr.email, 'UTF8') ~ '%s'" % regexp)
        if rcptfilter is not None:
            where.append("convert_from(maddr.email, 'UTF8') LIKE '%%%s%%'"
                         % rcptfilter)
        return Msgrcpt.objects.filter(q)\
            .extra(where=where, tables=['maddr']).values("mail_id")

    def get_recipient_message(self, address, mailid):
        qset = Msgrcpt.objects.filter(mail=mailid).extra(
            where=["msgrcpt.rid=maddr.id", "convert_from(maddr.email, 'UTF8') = '%s'" % address],
            tables=['maddr']
        )
        return qset.all()[0]

    def get_recipient_messages(self, address, mailids):
        return Msgrcpt.objects.filter(mail__in=mailids).extra(
            where=["U0.rid=maddr.id", "convert_from(maddr.email, 'UTF8') = '%s'" % address],
            tables=['maddr']
        )

    def get_domains_pending_requests(self, domains):
        regexp = "(%s)" % '|'.join([dom.name for dom in domains])
        return Msgrcpt.objects.filter(rs='p').extra(
            where=["msgrcpt.rid=maddr.id", "convert_from(maddr.email, 'UTF8') ~ '%s'" % regexp],
            tables=['maddr']
        )

    def get_pending_requests(self, user):
        rq = Q(rs='p')
        if not user.is_superuser:
            doms = Domain.objects.get_for_admin(user)
            if not doms.count():
                return 0
            regexp = "(%s)" % '|'.join([dom.name for dom in doms])
            return Msgrcpt.objects.filter(rq).extra(
                where=["msgrcpt.rid=maddr.id", "convert_from(maddr.email, 'UTF8') ~ '%s'" % (regexp,)],
                tables=['maddr']
            ).count()
        return Msgrcpt.objects.filter(rq).count()

    def get_mail_content(self, mailid):
        return Quarantine.objects.filter(mail=mailid).extra(
            select={'mail_text': "convert_from(mail_text, 'UTF8')"}
        )


def get_wrapper():
    """Return the appropriate *Wrapper class

    The result depends on the DB engine in use.
    """
    if db_type("amavis") == 'postgres':
        return PgWrapper()
    return SQLWrapper()


class SQLlisting(EmailListing):
    tpl = "amavis/index.html"
    tbltype = Qtable
    deflocation = "listing/"
    defcallback = "updatelisting"
    reset_wm_url = True

    def __init__(self, user, msgs, filter, **kwargs):
        self.mbc = SQLconnector(msgs, filter)
        super(SQLlisting, self).__init__(**kwargs)
        self.show_listing_headers = True


class SQLemail(Email):
    def __init__(self, *args, **kwargs):
        super(SQLemail, self).__init__(*args, **kwargs)
        fields = ["From", "To", "Cc", "Date", "Subject"]
        for f in fields:
            label = f
            self.headers += [
                {"name": label, "value": self.get_header(self.msg, f)}
            ]
            setattr(self, label, self.msg[f])
        qreason = self.get_header(self.msg, "X-Amavis-Alert")
        self.qtype = ""
        self.qreason = ""
        if qreason != "":
            if ',' in qreason:
                self.qtype, self.qreason = qreason.split(',', 1)
            elif qreason.startswith("BAD HEADER SECTION "):
                # Workaround for amavis <= 2.8.0 :p
                self.qtype = "BAD HEADER SECTION"
                self.qreason = qreason[19:]

    @property
    def msg(self):
        """
        """
        import email

        if self._msg is None:
            qmails = get_wrapper().get_mail_content(self.mailid)
            self._msg = email.message_from_string(
                "".join([qm.mail_text for qm in qmails])
            )
            self._parse(self._msg)
        return self._msg

    def render_headers(self, **kwargs):
        return render_to_string("amavis/mailheaders.html", {
            "qtype": self.qtype, "qreason": self.qreason,
            "headers": self.headers,
        })

########NEW FILE########
__FILENAME__ = amavis_tags
from django import template
from django.template.loader import render_to_string
from django.utils.translation import ugettext as _
from django.core.urlresolvers import reverse
from django.conf import settings
from modoboa.lib.webutils import _render_to_string

register = template.Library()


@register.simple_tag
def viewm_menu(mail_id, rcpt):
    entries = [
        {"name": "release",
         "img": "icon-white icon-ok",
         "class": "btn-success",
         "url": reverse('modoboa.extensions.amavis.views.release', args=[mail_id])
         + ("?rcpt=%s" % rcpt if rcpt else ""),
         "label": _("Release")},
        {"name": "delete",
         "class": "btn-danger",
         "img": "icon-white icon-trash",
         "url": reverse('modoboa.extensions.amavis.views.delete', args=[mail_id])
         + ("?rcpt=%s" % rcpt if rcpt else ""),
         "label": _("Delete")},
        {"name": "headers",
         "url": reverse('modoboa.extensions.amavis.views.viewheaders', args=[mail_id]),
         "label": _("View full headers")},
    ]

    menu = render_to_string('common/buttons_list.html',
                            {"entries": entries, "extraclasses": "pull-left"})

    entries = [{"name": "close",
                "url": "javascript:history.go(-1);",
                "img": "icon-remove"}]
    menu += render_to_string(
        'common/buttons_list.html',
        {"entries": entries, "extraclasses": "pull-right"}
    )

    return menu


@register.simple_tag
def viewm_menu_simple(user, mail_id, rcpt, secret_id=""):
    entries = [
        {"name": "release",
         "img": "icon-white icon-ok",
         "class": "btn-success",
         "url": reverse('modoboa.extensions.amavis.views.release', args=[mail_id]) \
             + ("?rcpt=%s" % rcpt \
                    + (("&secret_id=%s" % secret_id) if secret_id != "" else "")),
         "label": _("Release")},
        {"name": "delete",
         "img": "icon-white icon-trash",
         "class": "btn-danger",
         "url": reverse('modoboa.extensions.amavis.views.delete', args=[mail_id]) \
             + "?rcpt=%s" % rcpt \
             + ("&secret_id=%s" % secret_id if secret_id != "" else ""),
         "label": _("Delete")},
    ]

    return render_to_string('common/buttons_list.html',
                            {"entries": entries})


@register.simple_tag
def quar_menu():
    """Render the quarantine listing menu.

    :rtype: str
    :return: resulting HTML
    """
    extraopts = [{"name": "to", "label": _("To")}]
    return render_to_string('amavis/main_action_bar.html', {
        'extraopts': extraopts
    })

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns

urlpatterns = patterns(
    'modoboa.extensions.amavis.views',
    (r'^$', 'index'),
    (r'^listing/$', '_listing'),
    (r'^getmailcontent/(?P<mail_id>[\w\-\+]+)/$', 'getmailcontent'),
    (r'^process/$', 'process'),
    (r'^nbrequests/$', 'nbrequests'),
    (r'^delete/(?P<mail_id>[\w\-\+]+)/$', 'delete'),
    (r'^release/(?P<mail_id>[\w\-\+]+)/$', 'release'),
    (r'^(?P<mail_id>[\w\-\+]+)/$', 'viewmail'),
    (r'^(?P<mail_id>[\w\-\+]+)/headers/$', 'viewheaders'),
    )

########NEW FILE########
__FILENAME__ = views
# coding: utf-8
import email
from django.shortcuts import render
from django.http import HttpResponseRedirect, Http404
from django.template import Template, Context
from django.utils.translation import ugettext as _, ungettext
from django.core.urlresolvers import reverse
from django.contrib.auth.decorators \
    import login_required, user_passes_test
from django.db.models import Q
from modoboa.lib import parameters
from modoboa.lib.exceptions import BadRequest
from modoboa.lib.webutils import (
    getctx, ajax_response, render_to_json_response
)
from modoboa.lib.templatetags.lib_tags import pagination_bar
from modoboa.extensions.admin.models import Mailbox, Domain
from modoboa.extensions.amavis.templatetags.amavis_tags import (
    quar_menu, viewm_menu
)
from .lib import selfservice, AMrelease, QuarantineNavigationParameters
from .sql_listing import SQLlisting, SQLemail, get_wrapper
from .models import Msgrcpt


def empty_quarantine(request):
    content = "<div class='alert alert-info'>%s</div>" % _("Empty quarantine")
    ctx = getctx("ok", level=2, listing=content)
    return render_to_json_response(ctx)


@login_required
def _listing(request):
    flt = None
    rcptfilter = None
    msgs = None

    if not request.user.is_superuser and request.user.group != 'SimpleUsers':
        if not Domain.objects.get_for_admin(request.user).count():
            return empty_quarantine(request)

    navparams = QuarantineNavigationParameters(request)
    navparams.store()
    pattern = navparams.get('pattern', '')
    if pattern:
        criteria = navparams.get('criteria')
        if criteria == "both":
            criteria = "from_addr,subject,to"
        for c in criteria.split(","):
            if c == "from_addr":
                nfilter = Q(mail__from_addr__contains=pattern)
            elif c == "subject":
                nfilter = Q(mail__subject__contains=pattern)
            elif c == "to":
                rcptfilter = pattern
                continue
            else:
                raise BadRequest("unsupported search criteria %s" % c)
            flt = nfilter if flt is None else flt | nfilter
    msgtype = navparams.get('msgtype', None)
    if msgtype is not None:
        nfilter = Q(mail__msgrcpt__content=msgtype)
        flt = flt | nfilter if flt is not None else nfilter

    msgs = get_wrapper().get_mails(request, rcptfilter)
    page = navparams.get('page')
    lst = SQLlisting(
        request.user, msgs, flt,
        navparams=request.session["quarantine_navparams"],
        elems_per_page=int(parameters.get_user(request.user, "MESSAGES_PER_PAGE"))
    )
    page = lst.paginator.getpage(page)
    if not page:
        return empty_quarantine(request)

    content = lst.fetch(request, page.id_start, page.id_stop)
    ctx = getctx(
        "ok", listing=content, paginbar=pagination_bar(page), page=page.number
    )
    if request.session.get('location', 'listing') != 'listing':
        ctx['menu'] = quar_menu()
    request.session['location'] = 'listing'
    return render_to_json_response(ctx)


@login_required
def index(request):
    return render(request, "amavis/index.html", dict(
        deflocation="listing/?sort_order=-date", defcallback="listing_cb",
        selection="quarantine"
    ))


def getmailcontent_selfservice(request, mail_id):
    mail = SQLemail(mail_id, mformat="plain", links="0")
    return render(request, "common/viewmail.html", {
        "headers": mail.render_headers(),
        "mailbody": mail.body
    })


@selfservice(getmailcontent_selfservice)
def getmailcontent(request, mail_id):
    mail = SQLemail(mail_id, mformat="plain", links="0")
    return render(request, "common/viewmail.html", {
        "headers": mail.render_headers(),
        "mailbody": mail.body
    })


def viewmail_selfservice(request, mail_id,
                         tplname="amavis/viewmail_selfservice.html"):
    rcpt = request.GET.get("rcpt", None)
    secret_id = request.GET.get("secret_id", "")
    if rcpt is None:
        raise Http404
    content = Template("""{% load url from future %}
<iframe src="{% url 'modoboa.extensions.amavis.views.getmailcontent' mail_id %}" id="mailcontent"></iframe>
""").render(Context(dict(mail_id=mail_id)))

    return render(request, tplname, dict(
        mail_id=mail_id, rcpt=rcpt, secret_id=secret_id, content=content
    ))


@selfservice(viewmail_selfservice)
def viewmail(request, mail_id):
    rcpt = request.GET["rcpt"]
    if request.user.mailbox_set.count():
        mb = Mailbox.objects.get(user=request.user)
        if rcpt == mb.full_address or rcpt in mb.alias_addresses:
            get_wrapper().set_msgrcpt_status(rcpt, mail_id, 'V')

    content = Template("""
<iframe src="{{ url }}" id="mailcontent"></iframe>
""").render(Context({"url": reverse(getmailcontent, args=[mail_id])}))
    menu = viewm_menu(mail_id, rcpt)
    ctx = getctx("ok", menu=menu, listing=content)
    request.session['location'] = 'viewmail'
    return render_to_json_response(ctx)


@login_required
def viewheaders(request, mail_id):
    content = ""
    for qm in get_wrapper().get_mail_content(mail_id):
        content += qm.mail_text
    msg = email.message_from_string(content)
    return render(request, 'amavis/viewheader.html', {
        "headers": msg.items()
    })


def check_mail_id(request, mail_id):
    if type(mail_id) in [str, unicode]:
        if "rcpt" in request.POST:
            mail_id = ["%s %s" % (request.POST["rcpt"], mail_id)]
        else:
            mail_id = [mail_id]
    return mail_id


def delete_selfservice(request, mail_id):
    rcpt = request.GET.get("rcpt", None)
    if rcpt is None:
        raise BadRequest(_("Invalid request"))
    try:
        get_wrapper().set_msgrcpt_status(rcpt, mail_id, 'D')
    except Msgrcpt.DoesNotExist:
        raise BadRequest(_("Invalid request"))
    return render_to_json_response(_("Message deleted"))


@selfservice(delete_selfservice)
def delete(request, mail_id):
    """Delete message selection.

    :param str mail_id: message unique identifier
    """
    mail_id = check_mail_id(request, mail_id)
    wrapper = get_wrapper()
    mb = Mailbox.objects.get(user=request.user) \
        if request.user.group == 'SimpleUsers' else None
    for mid in mail_id:
        r, i = mid.split()
        if mb is not None and r != mb.full_address \
                and not r in mb.alias_addresses:
            continue
        wrapper.set_msgrcpt_status(r, i, 'D')
    message = ungettext("%(count)d message deleted successfully",
                        "%(count)d messages deleted successfully",
                        len(mail_id)) % {"count": len(mail_id)}
    return ajax_response(
        request, respmsg=message,
        url=QuarantineNavigationParameters(request).back_to_listing()
    )


def release_selfservice(request, mail_id):
    rcpt = request.GET.get("rcpt", None)
    secret_id = request.GET.get("secret_id", None)
    if rcpt is None or secret_id is None:
        raise BadRequest(_("Invalid request"))
    wrapper = get_wrapper()
    try:
        msgrcpt = wrapper.get_recipient_message(rcpt, mail_id)
    except Msgrcpt.DoesNotExist:
        raise BadRequest(_("Invalid request"))
    if secret_id != msgrcpt.mail.secret_id:
        raise BadRequest(_("Invalid request"))
    if parameters.get_admin("USER_CAN_RELEASE") == "no":
        wrapper.set_msgrcpt_status(rcpt, mail_id, 'p')
        msg = _("Request sent")
    else:
        amr = AMrelease()
        result = amr.sendreq(mail_id, secret_id, rcpt)
        if result:
            wrapper.set_msgrcpt_status(rcpt, mail_id, 'R')
            msg = _("Message released")
        else:
            raise BadRequest(result)
    return render_to_json_response(msg)


@selfservice(release_selfservice)
def release(request, mail_id):
    """Release message selection.

    :param str mail_id: message unique identifier
    """
    mail_id = check_mail_id(request, mail_id)
    msgrcpts = []
    wrapper = get_wrapper()
    mb = Mailbox.objects.get(user=request.user) \
        if request.user.group == 'SimpleUsers' else None
    for mid in mail_id:
        r, i = mid.split()
        if mb is not None and r != mb.full_address \
                and not r in mb.alias_addresses:
            continue
        msgrcpts += [wrapper.get_recipient_message(r, i)]
    if mb is not None and parameters.get_admin("USER_CAN_RELEASE") == "no":
        for msgrcpt in msgrcpts:
            wrapper.set_msgrcpt_status(
                msgrcpt.rid.email, msgrcpt.mail.mail_id, 'p'
            )
        message = ungettext("%(count)d request sent",
                            "%(count)d requests sent",
                            len(mail_id)) % {"count": len(mail_id)}
        return ajax_response(
            request, "ok", respmsg=message,
            url=QuarantineNavigationParameters(request).back_to_listing()
        )

    amr = AMrelease()
    error = None
    for rcpt in msgrcpts:
        result = amr.sendreq(
            rcpt.mail.mail_id, rcpt.mail.secret_id, rcpt.rid.email
        )
        if result:
            wrapper.set_msgrcpt_status(rcpt.rid.email, rcpt.mail.mail_id, 'R')
        else:
            error = result
            break

    if not error:
        message = ungettext("%(count)d message released successfully",
                            "%(count)d messages released successfully",
                            len(mail_id)) % {"count": len(mail_id)}
    else:
        message = error
    return ajax_response(
        request, "ko" if error else "ok", respmsg=message,
        url=QuarantineNavigationParameters(request).back_to_listing()
    )


@login_required
def process(request):
    ids = request.POST.get("selection", "")
    ids = ids.split(",")
    if not len(ids):
        return HttpResponseRedirect(reverse(index))

    if request.POST["action"] == "release":
        return release(request, ids)

    if request.POST["action"] == "delete":
        return delete(request, ids)


@login_required
@user_passes_test(lambda u: u.group != 'SimpleUsers')
def nbrequests(request):
    result = get_wrapper().get_pending_requests(request.user)
    return render_to_json_response({'requests': result})

########NEW FILE########
__FILENAME__ = app_settings
from django import forms
from django.utils.translation import ugettext_lazy as _
from modoboa.lib.parameters import AdminParametersForm
from modoboa.lib.formutils import SeparatorField


class ParametersForm(AdminParametersForm):
    app = "limits"

    defv_sep = SeparatorField(label=_("Default limits"))
    
    deflt_domain_admins_limit = forms.IntegerField(
        label=_("Domain admins"),
        initial=0,
        help_text=_("Maximum number of allowed domain administrators for a new administrator"),
        widget=forms.widgets.TextInput(attrs={"class": "span1"})
    )
    deflt_domains_limit = forms.IntegerField(
        label=_("Domains"),
        initial=0,
        help_text=_("Maximum number of allowed domains for a new administrator"),
        widget=forms.widgets.TextInput(attrs={"class": "span1"})
    )
    deflt_domain_aliases_limit = forms.IntegerField(
        label=_("Domain aliases"),
        initial=0,
        help_text=_("Maximum number of allowed domain aliases for a new administrator"),
        widget=forms.widgets.TextInput(attrs={"class": "span1"})
    )
    deflt_mailboxes_limit = forms.IntegerField(
        label=_("Mailboxes"),
        initial=0,
        help_text=_("Maximum number of allowed mailboxes for a new administrator"),
        widget=forms.widgets.TextInput(attrs={"class": "span1"})
    )
    deflt_mailbox_aliases_limit = forms.IntegerField(
        label=_("Mailbox aliases"),
        initial=0,
        help_text=_("Maximum number of allowed aliases for a new administrator"),
        widget=forms.widgets.TextInput(attrs={"class": "span1"})
    )

    def __init__(self, *args, **kwargs):
        super(AdminParametersForm, self).__init__(*args, **kwargs)
        self._load_extra_parameters('A')

########NEW FILE########
__FILENAME__ = controls
# coding: utf-8
"""
:mod:`controls` --- provides event handlers that check if limits are reached
----------------------------------------------------------------------------

"""
from modoboa.lib import events
from modoboa.lib.permissions import get_object_owner
from .lib import LimitReached, inc_limit_usage, dec_limit_usage
from .models import LimitTemplates, LimitsPool


def check_limit(user, lname, count=1):
    """Check if a user has reached a defined limit

    We check if the user will not reach the given limit after this
    creation.

    :param user: a ``User`` object
    :param int count: the number of objects the user tries to create
    :raises: ``LimitReached``
    """
    try:
        if user.limitspool.will_be_reached(lname, count):
            raise LimitReached(user.limitspool.get_limit(lname))
    except LimitsPool.DoesNotExist:
        pass


def move_pool_resource(owner, user):
    """Move resource from one pool to another

    When an account doesn't need a pool anymore, we move the
    associated resource to the pool of its owner.
    """
    try:
        pool = user.limitspool
    except LimitsPool.DoesNotExist:
        return
    if not owner.is_superuser:
        for ltpl in LimitTemplates().templates:
            l = user.limitspool.get_limit(ltpl[0])
            if l.maxvalue < 0:
                continue
            ol = owner.limitspool.get_limit(ltpl[0])
            ol.curvalue += l.curvalue
            ol.maxvalue += l.maxvalue
            ol.save()

    user.limitspool.delete()


@events.observe('DomainCreated')
def inc_nb_domains(user, domain):
    inc_limit_usage(user, 'domains_limit')


@events.observe('DomainDeleted')
def dec_nb_domains(domain, owner=None):
    if owner is None:
        owner = get_object_owner(domain)
    dec_limit_usage(owner, 'domains_limit')
    for domalias in domain.domainalias_set.all():
        dec_nb_domaliases(domalias)
    for mailbox in domain.mailbox_set.all():
        dec_nb_mailboxes(mailbox)
    for mbalias in domain.alias_set.all():
        dec_nb_mbaliases(mbalias)


@events.observe('DomainAliasCreated')
def inc_nb_domaliases(user, domalias):
    inc_limit_usage(user, 'domain_aliases_limit')


@events.observe('DomainAliasDeleted')
def dec_nb_domaliases(domainaliases):
    from modoboa.extensions.admin.models import DomainAlias

    if isinstance(domainaliases, DomainAlias):
        domainaliases = [domainaliases]
    for domainalias in domainaliases:
        owner = get_object_owner(domainalias)
        dec_limit_usage(owner, 'domain_aliases_limit')


@events.observe('MailboxCreated')
def inc_nb_mailboxes(user, mailbox):
    inc_limit_usage(user, 'mailboxes_limit')


@events.observe('MailboxDeleted')
def dec_nb_mailboxes(mailboxes):
    from modoboa.extensions.admin.models import Mailbox

    if isinstance(mailboxes, Mailbox):
        mailboxes = [mailboxes]
    for mailbox in mailboxes:
        owner = get_object_owner(mailbox)
        dec_limit_usage(owner, 'mailboxes_limit')


@events.observe('MailboxAliasCreated')
def inc_nb_mbaliases(user, mailboxalias):
    inc_limit_usage(user, 'mailbox_aliases_limit')


@events.observe('MailboxAliasDeleted')
def dec_nb_mbaliases(mailboxaliases):
    from modoboa.extensions.admin.models import Alias

    if isinstance(mailboxaliases, Alias):
        mailboxaliases = [mailboxaliases]
    for alias in mailboxaliases:
        owner = get_object_owner(alias)
        dec_limit_usage(owner, 'mailbox_aliases_limit')


@events.observe('CanCreate')
def can_create_new_object(user, objtype, count=1):
    check_limit(user, '%s_limit' % objtype, count)


@events.observe("AccountCreated")
def create_pool(user):
    owner = get_object_owner(user)
    if not owner.group in ['SuperAdmins', 'Resellers']:
        return

    if user.group == 'DomainAdmins':
        check_limit(owner, 'domain_admins_limit')
        inc_limit_usage(owner, 'domain_admins_limit')

    if user.group in ['DomainAdmins', 'Resellers']:
        p, created = LimitsPool.objects.get_or_create(user=user)
        p.create_limits(owner)


@events.observe("UserCanSetRole")
def user_can_set_role(user, role, account=None):
    """Check if the user can still set this role.

    The only interesting case concerns resellers defining new domain
    administrators. We want to check if they are allowed to do this
    operation before any modification is made to :keyword:`account`.

    :param ``User`` user: connected user
    :param ``User`` account: account modified (None on creation)
    :param str newrole: role to check
    """
    if role == 'DomainAdmins':
        lname = 'domain_admins_limit'
    else:
        return [True]
    if user.is_superuser or not user.limitspool.will_be_reached(lname):
        return [True]
    if account is not None and account.group == role:
        return [True]
    return [False]


@events.observe("AccountModified")
def on_account_modified(old, new):
    """Update limits when roles are updated"""
    owner = get_object_owner(old)
    if owner.group not in ["SuperAdmins", "Resellers"]:
        # Domain admins can't change the role so nothing to check.
        return

    if new.group != "SuperAdmins":
        # Check if account needs a pool (case: a superadmin is
        # downgraded)
        try:
            pool = new.limitspool
        except LimitsPool.DoesNotExist:
            p = LimitsPool(user=new)
            p.save()
            p.create_limits(owner)

    if not new.group in ["DomainAdmins", "Resellers"]:
        move_pool_resource(owner, new)

    if old.oldgroup == "DomainAdmins":
        if new.group != "DomainAdmins":
            dec_limit_usage(owner, 'domain_admins_limit')
        return

    if new.group == "DomainAdmins":
        check_limit(owner, 'domain_admins_limit')
        inc_limit_usage(owner, 'domain_admins_limit')


@events.observe("AccountDeleted")
def on_account_deleted(account, byuser, **kwargs):
    owner = get_object_owner(account)
    if not owner.group in ["SuperAdmins", "Resellers"]:
        return

    move_pool_resource(owner, account)

    if account.group == "DomainAdmins":
        dec_limit_usage(owner, 'domain_admins_limit')


@events.observe('DomainOwnershipRemoved')
def domain_ownership_removed(reseller, domain):
    """DomainOwnershipRemoved listener.

    The access :keyword:`reseller` had to :keyword:`domain` has been
    removed by a super adminstrator. We must decrement all limit
    usages.

    :param ``User`` reseller: reseller that created :keyword:`domain`
    :param ``Domain`` domain: domain
    """
    dec_nb_domains(domain, reseller)
    for dadmin in domain.admins:
        if reseller.is_owner(dadmin):
            dec_limit_usage(reseller, 'domain_admins_limit')

########NEW FILE########
__FILENAME__ = forms
# coding: utf-8
from django import forms
from django.utils.translation import ugettext as _, ugettext_lazy
from modoboa.lib import parameters
from .models import LimitTemplates
from .lib import BadLimitValue, UnsufficientResource


class ResourcePoolForm(forms.Form):

    def __init__(self, *args, **kwargs):
        self.account = None
        if "instance" in kwargs:
            self.account = kwargs["instance"]
            del kwargs["instance"]
        super(ResourcePoolForm, self).__init__(*args, **kwargs)
        for tpl in LimitTemplates().templates:
            if len(tpl) > 3 and self.account is not None and self.account.group != tpl[3]:
                continue
            self.fields[tpl[0]] = forms.IntegerField(
                label=tpl[1], help_text=tpl[2]
            )
        if hasattr(self, "account"):
            self.load_from_user(self.account)

    def check_limit_value(self, lname):
        if self.cleaned_data[lname] < -1:
            raise forms.ValidationError(_("Invalid limit"))
        return self.cleaned_data[lname]

    def clean(self):
        cleaned_data = super(ResourcePoolForm, self).clean()
        for lname in self.fields.keys():
            if not lname in self._errors and cleaned_data[lname] < -1:
                self._errors[lname] = self.error_class([_('Invalid limit')])
                del cleaned_data[lname]
        return cleaned_data

    def load_from_user(self, user):
        for lname in self.fields.keys():
            self.fields[lname].initial = user.limitspool.getmaxvalue(lname)
            # The following lines will become useless in a near
            # future.
            if self.fields[lname].initial == -2:
                self.fields[lname].initial = parameters.get_admin("DEFLT_%s" % lname.upper())

    def allocate_from_pool(self, limit, pool):
        """Allocate resource using an existing pool.

        When a reseller creates a domain administrator, he generally
        assigns him resource to create new objetcs. As a reseller may
        also be limited, the resource he gives is taken from its own
        pool.
        """
        ol = pool.get_limit(limit.name)
        if ol.maxvalue == -2:
            raise BadLimitValue(_("Your resources are not initialized yet"))
        newvalue = self.cleaned_data[limit.name]
        if newvalue == -1 and ol.maxvalue != -1:
            raise BadLimitValue(
                _("You're not allowed to define unlimited values")
            )

        if limit.maxvalue > -1:
            newvalue -= limit.maxvalue
            if newvalue == 0:
                return
        remain = ol.maxvalue - ol.curvalue
        if newvalue > remain:
            raise UnsufficientResource(ol)
        ol.maxvalue -= newvalue
        ol.save()

    def save(self):
        from modoboa.lib.permissions import get_object_owner

        owner = get_object_owner(self.account)
        for ltpl in LimitTemplates().templates:
            if not ltpl[0] in self.cleaned_data:
                continue
            l = self.account.limitspool.limit_set.get(name=ltpl[0])
            if not owner.is_superuser:
                self.allocate_from_pool(l, owner.limitspool)
            l.maxvalue = self.cleaned_data[ltpl[0]]
            l.save()

########NEW FILE########
__FILENAME__ = general_callbacks
from django.utils.translation import ugettext as _
from modoboa.lib import events
from modoboa.extensions.limits.models import LimitTemplates
from modoboa.extensions.limits.forms import ResourcePoolForm


@events.observe("GetExtraRoles")
def get_extra_roles(user):
    if user.is_superuser:
        return [("Resellers", _("Reseller")), ]
    return []


@events.observe("ExtraAdminContent")
def display_pool_usage(user, target, currentpage):
    from django.template.loader import render_to_string

    if target != "leftcol" or user.is_superuser:
        return []
    if currentpage == "identities":
        names = ["mailboxes_limit", "mailbox_aliases_limit"]
        if user.has_perm("admin.add_domain"):
            names += ["domain_admins_limit"]
    else:
        names = [
            tpl[0] for tpl in LimitTemplates().templates
            if tpl[0] not in ["domain_admins_limit", "mailboxes_limit",
                              "mailbox_aliases_limit"]
            and (len(tpl) == 3 or tpl[3] == user.group)
        ]

    limits = user.limitspool.limit_set.filter(name__in=names, maxvalue__gt=0)
    if len(limits) == 0:
        return []
    return [render_to_string("limits/poolusage.html", dict(limits=limits))]


@events.observe("ExtraAccountForm")
def extra_account_form(user, account=None):
    if not user.group in ["SuperAdmins", "Resellers"]:
        return []
    if account is not None and \
            not account.group in ["Resellers", "DomainAdmins"]:
        return []

    return [
        dict(
            id="resources", title=_("Resources"), cls=ResourcePoolForm
        )
    ]


@events.observe("CheckExtraAccountForm")
def check_form_access(account, form):
    if form["id"] != "resources":
        return [True]
    if not account.belongs_to_group("Resellers") and \
       not account.belongs_to_group("DomainAdmins"):
        return [False]
    return [True]


@events.observe("FillAccountInstances")
def fill_account_instances(user, account, instances):
    if not user.is_superuser and not user.belongs_to_group("Resellers"):
        return
    if not account.belongs_to_group("Resellers") and \
       not account.belongs_to_group("DomainAdmins"):
        return
    instances["resources"] = account


@events.observe("GetStaticContent")
def get_static_content(caller, user):
    if caller not in ['domains', 'identities']:
        return []
    if user.group == "SimpleUsers":
        return []
    return ["""<style>
.resource {
    margin: 5px 0;
}

.resource .progress {
    margin-bottom: 0px;
}

.resource .progress .bar {
    color: #000000;
}
</style>
<script type="text/javascript">
$(document).ready(function() {
    $(".progress").tooltip();
});
</script>
"""]

########NEW FILE########
__FILENAME__ = lib
# coding: utf-8
"""
:mod:`lib` --- public functions
-------------------------------

"""
from django.utils.translation import ugettext as _
from modoboa.lib.exceptions import ModoboaException
from modoboa.extensions.limits.models import LimitsPool


class LimitReached(ModoboaException):
    http_code = 403

    def __init__(self, limit):
        self.limit = limit

    def __str__(self):
        return _("%s: limit reached") % self.limit.label


class UnsufficientResource(ModoboaException):
    http_code = 424

    def __init__(self, limit):
        self.limit = limit

    def __str__(self):
        return _("Not enough resources")


class BadLimitValue(ModoboaException):
    http_code = 400


def inc_limit_usage(user, lname):
    """Increase a given limit usage.

    """
    try:
        user.limitspool.inc_curvalue(lname)
    except LimitsPool.DoesNotExist:
        pass


def dec_limit_usage(user, lname):
    if user is None:
        return
    try:
        user.limitspool.dec_curvalue(lname)
    except LimitsPool.DoesNotExist:
        pass

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'LimitsPool'
        db.create_table('limits_limitspool', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['auth.User'], unique=True)),
        ))
        db.send_create_signal('limits', ['LimitsPool'])

        # Adding model 'Limit'
        db.create_table('limits_limit', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('curvalue', self.gf('django.db.models.fields.IntegerField')(default=0)),
            ('maxvalue', self.gf('django.db.models.fields.IntegerField')(default=-2)),
            ('pool', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['limits.LimitsPool'])),
        ))
        db.send_create_signal('limits', ['Limit'])

        # Adding unique constraint on 'Limit', fields ['name', 'pool']
        db.create_unique('limits_limit', ['name', 'pool_id'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Limit', fields ['name', 'pool']
        db.delete_unique('limits_limit', ['name', 'pool_id'])

        # Deleting model 'LimitsPool'
        db.delete_table('limits_limitspool')

        # Deleting model 'Limit'
        db.delete_table('limits_limit')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'limits.limit': {
            'Meta': {'unique_together': "(('name', 'pool'),)", 'object_name': 'Limit'},
            'curvalue': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'maxvalue': ('django.db.models.fields.IntegerField', [], {'default': '-2'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'pool': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['limits.LimitsPool']"})
        },
        'limits.limitspool': {
            'Meta': {'object_name': 'LimitsPool'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['limits']

########NEW FILE########
__FILENAME__ = 0002_update_user_foreign_key
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        db.alter_column(u'limits_limitspool', 'user_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['admin.User']))

    def backwards(self, orm):
        pass

    models = {
        u'admin.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'limits.limit': {
            'Meta': {'unique_together': "(('name', 'pool'),)", 'object_name': 'Limit'},
            'curvalue': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'maxvalue': ('django.db.models.fields.IntegerField', [], {'default': '-2'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'pool': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['limits.LimitsPool']"})
        },
        u'limits.limitspool': {
            'Meta': {'object_name': 'LimitsPool'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': u"orm['admin.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['limits']

########NEW FILE########
__FILENAME__ = 0003_auto__chg_field_limitspool_user
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):
    depends_on = (
        ('admin', '0037_rename_tables'),
    )

    def forwards(self, orm):

        # Changing field 'LimitsPool.user'
        db.alter_column(u'limits_limitspool', 'user_id', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['core.User'], unique=True))

    def backwards(self, orm):

        # Changing field 'LimitsPool.user'
        db.alter_column(u'limits_limitspool', 'user_id', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['admin.User'], unique=True))

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'core.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_local': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'limits.limit': {
            'Meta': {'unique_together': "(('name', 'pool'),)", 'object_name': 'Limit'},
            'curvalue': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'maxvalue': ('django.db.models.fields.IntegerField', [], {'default': '-2'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'pool': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['limits.LimitsPool']"})
        },
        u'limits.limitspool': {
            'Meta': {'object_name': 'LimitsPool'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': u"orm['core.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['limits']

########NEW FILE########
__FILENAME__ = models
# coding: utf-8
from django.db import models
from django.utils.translation import ugettext as _, ugettext_lazy
from modoboa.lib import parameters
from modoboa.lib.singleton import Singleton
from django.conf import settings
from modoboa.lib import events


class LimitTemplates(Singleton):

    def __init__(self):
        self.__templates = [
            ("domain_admins_limit", ugettext_lazy("Domain admins"),
             ugettext_lazy("Maximum number of domain administrators this user can create"),
             'Resellers'),
            ("domains_limit", ugettext_lazy("Domains"),
             ugettext_lazy("Maximum number of domains this user can create"),
             'Resellers'),
            ("domain_aliases_limit", ugettext_lazy("Domain aliases"),
             ugettext_lazy("Maximum number of domain aliases this user can create"),
             'Resellers'),
            ("mailboxes_limit", ugettext_lazy("Mailboxes"),
             ugettext_lazy("Maximum number of mailboxes this user can create")),
            ("mailbox_aliases_limit", ugettext_lazy("Mailbox aliases"),
             ugettext_lazy("Maximum number of mailbox aliases this user can create"))
        ]
    
    @property
    def templates(self):
        return self.__templates + events.raiseQueryEvent('GetExtraLimitTemplates')


class LimitsPool(models.Model):
    user = models.OneToOneField(settings.AUTH_USER_MODEL)

    def create_limits(self, creator):
        """Create limits for this pool.

        All limits defined into ``LimitTemplates`` will be created. If
        the creator is a super administrator, the default maximum values
        will be used.

        :param ``User`` creator: user creating this pool
        """
        for ltpl in LimitTemplates().templates:
            try:
                Limit.objects.get(name=ltpl[0], pool=self)
            except Limit.DoesNotExist:
                maxvalue = int(parameters.get_admin("DEFLT_%s" % ltpl[0].upper())) \
                    if creator.is_superuser else 0
                Limit.objects.create(
                    name=ltpl[0], pool=self, maxvalue=maxvalue
                )

    def getcurvalue(self, lname):
        l = self.limit_set.get(name=lname)
        return l.curvalue

    def getmaxvalue(self, lname):
        l = self.limit_set.get(name=lname)
        return l.maxvalue

    def set_maxvalue(self, lname, value):
        l = self.limit_set.get(name=lname)
        l.maxvalue = value
        l.save()

    def inc_curvalue(self, lname, nb=1):
        l = self.limit_set.get(name=lname)
        l.curvalue += nb
        l.save()

    def dec_curvalue(self, lname, nb=1):
        l = self.limit_set.get(name=lname)
        if not l.curvalue:
            return
        l.curvalue -= nb
        l.save()

    def dec_limit(self, lname, nb=1):
        l = self.limit_set.get(name=lname)
        l.curvalue -= nb
        if l.maxvalue > -1:
            l.maxvalue -= nb
        l.save()

    def inc_limit(self, lname, nb=1):
        l = self.limit_set.get(name=lname)
        l.curvalue += nb
        if l.maxvalue > -1:
            l.maxvalue += nb
        l.save()

    def will_be_reached(self, lname, nb=1):
        l = self.limit_set.get(name=lname)
        if l.maxvalue <= -1:
            return False
        if l.curvalue + nb > l.maxvalue:
            return True
        return False

    def get_limit(self, lname):
        try:
            return self.limit_set.get(name=lname)
        except Limit.DoesNotExist:
            return None


class Limit(models.Model):
    name = models.CharField(max_length=255)
    curvalue = models.IntegerField(default=0)
    maxvalue = models.IntegerField(default=-2)
    pool = models.ForeignKey(LimitsPool)

    class Meta:
        unique_together = (("name", "pool"),)

    @property
    def usage(self):
        if self.maxvalue < 0:
            return -1
        if self.maxvalue == 0:
            return 0
        return int(float(self.curvalue) / self.maxvalue * 100)

    @property
    def label(self):
        for l in LimitTemplates().templates:
            if l[0] == self.name:
                return l[1]
        return ""

    def __str__(self):
        if self.maxvalue == -2:
            return _("undefined")
        if self.maxvalue == -1:
            return _("unlimited")
        return "%d%%" % self.usage

########NEW FILE########
__FILENAME__ = tests
from django.core.urlresolvers import reverse
from modoboa.lib.tests import ExtTestCase
from modoboa.lib import parameters
from modoboa.core.models import User
from modoboa.core.factories import UserFactory
from modoboa.extensions.admin.factories import (
    DomainFactory, MailboxFactory, populate_database
)
from modoboa.extensions.admin.models import Alias, Domain, DomainAlias
from modoboa.extensions.limits.models import LimitTemplates


class PermissionsTestCase(ExtTestCase):
    fixtures = ["initial_users.json"]

    def setUp(self):
        super(PermissionsTestCase, self).setUp()
        self.activate_extensions('limits')
        populate_database()

    def test_domainadmin_deletes_reseller(self):
        """Check if a domain admin can delete a reseller.

        Expected result: no.
        """
        values = dict(
            username="reseller@test.com", first_name="Reseller", last_name="",
            password1="toto", password2="toto", role="Resellers",
            is_active=True, email="reseller@test.com", stepid='step2'
        )
        self.ajax_post(reverse("modoboa.extensions.admin.views.identity.newaccount"), values)
        account = User.objects.get(username="reseller@test.com")
        self.clt.logout()
        self.clt.login(username="admin@test.com", password="toto")
        resp = self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.delaccount", args=[account.id]),
            {}, status=403
        )
        self.assertEqual(resp, "Permission denied")


class ResourceTestCase(ExtTestCase):
    fixtures = ["initial_users.json"]

    def setUp(self):
        """Custom setUp method.

        The 'limits' is manually loaded to ensure extra parameters
        provided by 'postfix_relay_domains' are properly received.
        """
        super(ResourceTestCase, self).setUp()
        self.activate_extensions('limits')
        for tpl in LimitTemplates().templates:
            parameters.save_admin('DEFLT_%s' % tpl[0].upper(), 2, app='limits')
        populate_database()

    def _create_account(self, username, role='SimpleUsers', status=200):
        values = dict(
            username=username, first_name="Tester", last_name="Toto",
            password1="toto", password2="toto", role=role,
            quota_act=True,
            is_active=True, email=username, stepid='step2',
        )
        return self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.newaccount"),
            values, status
        )

    def _create_alias(self, email, rcpt='user@test.com', status=200):
        values = dict(
            email=email, recipients=rcpt, enabled=True
        )
        return self.ajax_post(
            reverse("modoboa.extensions.admin.views.alias.newalias"),
            values, status
        )

    def _create_domain(self, name, status=200, withtpl=False):
        values = {
            "name": name, "quota": 100, "create_dom_admin": "no",
            "create_aliases": "no", "stepid": 'step2'
        }
        if withtpl:
            values['create_dom_admin'] = 'yes'
            values['dom_admin_username'] = 'admin'
            values['create_aliases'] = 'yes'
        return self.ajax_post(
            reverse("modoboa.extensions.admin.views.domain.newdomain"),
            values, status
        )

    def _domain_alias_operation(self, optype, domain, name, status=200):
        dom = Domain.objects.get(name=domain)
        values = {
            'name': dom.name, 'quota': dom.quota, 'enabled': dom.enabled,
        }
        aliases = [alias.name for alias in dom.domainalias_set.all()]
        if optype == 'add':
            aliases.append(name)
        else:
            aliases.remove(name)
        for cpt, alias in enumerate(aliases):
            fname = 'aliases' if not cpt else 'aliases_%d' % cpt
            values[fname] = alias
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.domain.editdomain",
                    args=[dom.id]),
            values, status
        )

    def _check_limit(self, name, curvalue, maxvalue):
        l = self.user.limitspool.get_limit('%s_limit' % name)
        self.assertEqual(l.curvalue, curvalue)
        self.assertEqual(l.maxvalue, maxvalue)


class DomainAdminTestCase(ResourceTestCase):

    def setUp(self):
        super(DomainAdminTestCase, self).setUp()
        self.user = User.objects.get(username='admin@test.com')
        self.user.limitspool.set_maxvalue('mailboxes_limit', 2)
        self.user.limitspool.set_maxvalue('mailbox_aliases_limit', 2)
        self.clt.logout()
        self.clt.login(username='admin@test.com', password='toto')

    def test_mailboxes_limit(self):        
        self._create_account('tester1@test.com')
        self._check_limit('mailboxes', 1, 2)
        self._create_account('tester2@test.com')
        self._check_limit('mailboxes', 2, 2)
        resp = self._create_account('tester3@test.com', status=403)
        self._check_limit('mailboxes', 2, 2)
        self.ajax_post(
            reverse('modoboa.extensions.admin.views.identity.delaccount',
                    args=[User.objects.get(username='tester2@test.com').id]),
            {}
        )
        self._check_limit('mailboxes', 1, 2)

    def test_aliases_limit(self):
        self._create_alias('alias1@test.com')
        self._check_limit('mailbox_aliases', 1, 2)
        self._create_alias('alias2@test.com')
        self._check_limit('mailbox_aliases', 2, 2)
        resp = self._create_alias('alias3@test.com', status=403)
        self._check_limit('mailbox_aliases', 2, 2)
        self.ajax_post(
            reverse('modoboa.extensions.admin.views.alias.delalias') + '?selection=%d' \
                % Alias.objects.get(address='alias2', domain__name='test.com').id,
            {}
        )
        self._check_limit('mailbox_aliases', 1, 2)

    def test_aliases_limit_through_account_form(self):
        user = User.objects.get(username='user@test.com')
        values = dict(
            username=user.username, role=user.group,
            is_active=user.is_active, email=user.email, quota_act=True,
            aliases="alias1@test.com", aliases_1="alias2@test.com"
        )
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[user.id]),
            values
        )
        Alias.objects.get(address='alias1', domain__name='test.com')
        self._check_limit('mailbox_aliases', 2, 2)


class ResellerTestCase(ResourceTestCase):

    def setUp(self):
        super(ResellerTestCase, self).setUp()
        self.user = UserFactory.create(
            username='reseller', groups=('Resellers',)
        )
        self.clt.logout()
        self.clt.login(username='reseller', password='toto')

    def test_domains_limit(self):
        self._create_domain('domain1.tld')
        self._check_limit('domains', 1, 2)
        self._create_domain('domain2.tld')
        self._check_limit('domains', 2, 2)
        resp = self._create_domain('domain3.tld', 403)
        self._check_limit('domains', 2, 2)
        self.ajax_post(
            reverse('modoboa.extensions.admin.views.domain.deldomain',
                    args=[Domain.objects.get(name='domain2.tld').id]),
            {}
        )
        self._check_limit('domains', 1, 2)

    def test_domain_aliases_limit(self):
        self._create_domain('pouet.com')
        self._domain_alias_operation('add', 'pouet.com', 'domain_alias1.tld')
        self._check_limit('domain_aliases', 1, 2)
        self._domain_alias_operation('add', 'pouet.com', 'domain_alias2.tld')
        self._check_limit('domain_aliases', 2, 2)
        resp = self._domain_alias_operation(
            'add', 'pouet.com', 'domain_alias3.tld', 403
        )
        self._check_limit('domain_aliases', 2, 2)
        self._domain_alias_operation('delete', 'pouet.com', 'domain_alias2.tld')
        self._check_limit('domain_aliases', 1, 2)

    def test_domain_admins_limit(self):
        self._create_domain('domain.tld')
        self._create_account('admin1@domain.tld', role='DomainAdmins')
        self._check_limit('domain_admins', 1, 2)
        self._create_account('admin2@domain.tld', role='DomainAdmins')
        self._check_limit('domain_admins', 2, 2)
        resp = self._create_account('admin3@domain.tld', role='DomainAdmins', status=400)
        self.assertEqual(
            resp['form_errors']['role'][0],
            'Select a valid choice. DomainAdmins is not one of the available choices.'
        )
        self._check_limit('domain_admins', 2, 2)
        
        self.user.limitspool.set_maxvalue('mailboxes_limit', 3)
        self._create_account('user1@domain.tld')
        user = User.objects.get(username='user1@domain.tld')
        values = {
            'username': user.username, 'role': 'DomainAdmins', 'quota_act': True,
            'is_active': user.is_active, 'email': user.email
        }
        resp = self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[user.id]),
            values, status=400
        )
        self.assertEqual(
            resp['form_errors']['role'][0],
            'Select a valid choice. DomainAdmins is not one of the available choices.'
        )
        self._check_limit('domain_admins', 2, 2)

    def test_domain_admin_resource_are_empty(self):
        self._create_domain('domain.tld')
        self._create_account('admin1@domain.tld', role='DomainAdmins')
        domadmin = User.objects.get(username='admin1@domain.tld')
        for l in ['mailboxes', 'mailbox_aliases']:
            self.assertEqual(
                domadmin.limitspool.get_limit('%s_limit' % l).maxvalue, 0
            )

    def test_domain_admins_limit_from_domain_tpl(self):
        self.user.limitspool.set_maxvalue('domains_limit', 3)
        self._create_domain('domain1.tld', withtpl=True)
        self._create_domain('domain2.tld', withtpl=True)
        self._check_limit('domain_admins', 2, 2)
        self._check_limit('domains', 2, 3)
        resp = self._create_domain('domain3.tld', status=200, withtpl=True)
        self._check_limit('domain_admins', 2, 2)
        self._check_limit('domains', 3, 3)

    def test_reseller_deletes_domain(self):
        """Check if all resources are restored after the deletion.
        """
        self._create_domain('domain.tld', withtpl=True)
        dom = Domain.objects.get(name="domain.tld")
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.domain.deldomain",
                    args=[dom.id]),
            {}
        )
        self._check_limit('domains', 0, 2)
        self._check_limit('domain_admins', 1, 2)
        self._check_limit('mailboxes', 0, 2)
        self._check_limit('mailbox_aliases', 0, 2)

    def test_sadmin_removes_ownership(self):
        self._create_domain('domain.tld', withtpl=True)
        dom = Domain.objects.get(name="domain.tld")
        self.clt.logout()
        self.clt.login(username='admin', password='password')
        self.ajax_get(
            reverse(
                'modoboa.extensions.admin.views.identity.remove_permission'
            ) + '?domid=%d&daid=%d' % (dom.id, self.user.id)
            , {}
        )
        self._check_limit('domains', 0, 2)
        self._check_limit('domain_admins', 0, 2)
        self._check_limit('mailboxes', 0, 2)
        self._check_limit('mailbox_aliases', 0, 2)

    def test_allocate_from_pool(self):
        self._create_domain('domain.tld')
        self._create_account('admin1@domain.tld', role='DomainAdmins')
        user = User.objects.get(username='admin1@domain.tld')

        # Give 1 mailbox and 2 aliases to the admin -> should work
        values = {
            'username': user.username, 'role': user.group, 'quota_act': True,
            'is_active': user.is_active, 'email': user.email,
            'mailboxes_limit': 1, 'mailbox_aliases_limit': 2
        }
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[user.id]),
            values
        )
        self._check_limit('mailboxes', 1, 1)
        self._check_limit('mailbox_aliases', 0, 0)

        # Delete the admin -> resources should go back to the
        # reseller's pool
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.delaccount",
                    args=[user.id]),
            {}
        )
        self._check_limit('mailboxes', 0, 2)
        self._check_limit('mailbox_aliases', 0, 2)

    def test_restore_resources(self):
        self._create_domain('domain.tld')
        dom = Domain.objects.get(name='domain.tld')
        self._create_account('admin1@domain.tld', role='DomainAdmins')
        user = User.objects.get(username='admin1@domain.tld')
        values = {
            'username': user.username, 'role': user.group, 'quota_act': True,
            'is_active': user.is_active, 'email': user.email,
            'mailboxes_limit': 1, 'mailbox_aliases_limit': 2
        }
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[user.id]),
            values
        )
        dom.add_admin(user)
        self.clt.logout()
        self.clt.login(username='admin1@domain.tld', password='toto')
        self._create_account('user1@domain.tld')
        self._create_alias('alias1@domain.tld', 'user1@domain.tld')
        self._create_alias('alias2@domain.tld', 'user1@domain.tld')
        self.clt.logout()
        self.clt.login(username='reseller', password='toto')
        # Delete the admin -> resources should go back to the
        # reseller's pool
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.delaccount",
                    args=[user.id]),
            {}
        )
        self._check_limit('mailboxes', 1, 2)
        self._check_limit('mailbox_aliases', 2, 2)

    def test_change_role(self):
        self._create_domain('domain.tld')
        self._create_account('admin1@domain.tld', role='DomainAdmins')
        user = User.objects.get(username='admin1@domain.tld')

        # Give 1 mailbox and 2 aliases to the admin -> should work
        values = {
            'username': user.username, 'role': user.group, 'quota_act': True,
            'is_active': user.is_active, 'email': user.email,
            'mailboxes_limit': 1, 'mailbox_aliases_limit': 2
        }
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[user.id]),
            values
        )
        self._check_limit('mailboxes', 1, 1)
        self._check_limit('mailbox_aliases', 0, 0)

        # Change admin role to SimpleUser -> resources should go back
        # to the reseller.
        values = {
            'username': user.username, 'role': 'SimpleUsers', 'quota_act': True,
            'is_active': user.is_active, 'email': user.email,
        }
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[user.id]),
            values
        )
        self._check_limit('mailboxes', 1, 2)
        self._check_limit('mailbox_aliases', 0, 2)
        

    def test_allocate_too_much(self):
        self._create_domain('domain.tld')
        self._create_account('admin1@domain.tld', role='DomainAdmins')
        user = User.objects.get(username='admin1@domain.tld')

        # Give 2 mailboxes and 3 aliases to the admin -> should fail.
        values = {
            'username': user.username, 'role': user.group, 'quota_act': True,
            'is_active': user.is_active, 'email': user.email,
            'mailboxes_limit': 2, 'mailbox_aliases_limit': 3
        }
        resp = self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[user.id]),
            values, 424
        )
        self.assertEqual(resp, 'Not enough resources')
        self._check_limit('mailboxes', 1, 2)
        self._check_limit('mailbox_aliases', 0, 2)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns

urlpatterns = patterns(
    'modoboa.extensions.limits.views',

    )

########NEW FILE########
__FILENAME__ = views
# coding: utf-8

########NEW FILE########
__FILENAME__ = app_settings
# coding: utf-8
from django.utils.translation import ugettext_lazy
from django import forms
from modoboa.lib.parameters import AdminParametersForm
from modoboa.lib.formutils import SeparatorField


class ParametersForm(AdminParametersForm):
    app = "postfix_autoreply"

    general_sep = SeparatorField(label=ugettext_lazy("General"))

    autoreplies_timeout = forms.IntegerField(
        label=ugettext_lazy("Automatic reply timeout"),
        initial=86400,
        help_text=ugettext_lazy("Timeout in seconds between two auto-replies to the same recipient")
    )

    default_subject = forms.CharField(
        label=ugettext_lazy("Default subject"),
        initial=ugettext_lazy("I'm off"),
        help_text=ugettext_lazy(
            "Default subject used when an auto-reply message is created automatically"
        )
    )

    default_content = forms.CharField(
        label=ugettext_lazy("Default content"),
        initial=ugettext_lazy(
            """I'm currently off. I'll answer as soon as I come back.

Best regards,
%(name)s
"""),
        help_text=ugettext_lazy(
            "Default content used when an auto-reply message is created "
            "automatically. The '%(name)s' macro will be replaced by the "
            "user's full name."
        ),
        widget=forms.widgets.Textarea
    )

    def clean_default_content(self):
        """Check if the provided value is valid.

        Must be a valid format string which will be used with the %
        operator.
        """
        tpl = self.cleaned_data["default_content"]
        try:
            test = tpl % {"name": "Antoine Nguyen"}
        except (KeyError, ValueError):
            raise forms.ValidationError(ugettext_lazy("Invalid syntax"))
        return tpl

########NEW FILE########
__FILENAME__ = forms
# coding: utf-8
import datetime
from django import forms
from django.utils.translation import ugettext as _, ugettext_lazy
from django.utils import timezone
from .models import ARmessage


class ARmessageForm(forms.ModelForm):
    fromdate = forms.DateTimeField(
        label=ugettext_lazy('From'),
        required=False,
        help_text=ugettext_lazy("Activate your auto reply from this date"),
        widget=forms.TextInput(
            attrs={'class': 'datefield', 'readonly': 'readonly'}
        )
    )
    untildate = forms.DateTimeField(
        label=ugettext_lazy('Until'),
        required=False,
        help_text=ugettext_lazy("Activate your auto reply until this date"),
        widget=forms.TextInput(
            attrs={'class': 'datefield', 'readonly': 'readonly'}
        )
    )

    class Meta:
        model = ARmessage
        fields = ('subject', 'content', 'enabled')

    def __init__(self, *args, **kwargs):
        super(ARmessageForm, self).__init__(*args, **kwargs)
        self.fields.keyOrder = [
            'subject', 'content', 'fromdate', 'untildate', 'enabled'
        ]
        if 'instance' in kwargs and kwargs['instance'] is not None:
            self.fields['fromdate'].initial = \
                kwargs['instance'].fromdate.replace(second=0, microsecond=0)
            self.fields['untildate'].initial = kwargs['instance'].untildate

    def clean(self):
        """Custom fields validaton.

        We want to be sure that fromdate < untildate and that they are
        both in the future.
        """
        super(ARmessageForm, self).clean()
        if self._errors:
            raise forms.ValidationError(self._errors)
        if self.cleaned_data["fromdate"] is not None:
            if self.cleaned_data["fromdate"] < timezone.now():
                self._errors["fromdate"] = self.error_class([_("This date is over")])
                del self.cleaned_data['fromdate']
        else:
            self.cleaned_data['fromdate'] = timezone.now()
        if self.cleaned_data["untildate"] is not None:
            if self.cleaned_data["untildate"] < timezone.now():
                self._errors["untildate"] = self.error_class([_("This date is over")])
                del self.cleaned_data['untildate']
            elif 'fromdate' in self.cleaned_data and \
                    self.cleaned_data['untildate'] < self.cleaned_data['fromdate']:
                self._errors["untildate"] = \
                    self.error_class([_("Must be greater than start date")])
                del self.cleaned_data['untildate']
        return self.cleaned_data

########NEW FILE########
__FILENAME__ = general_callbacks
from django.utils import timezone
from django.utils.translation import ugettext_lazy
from modoboa.lib import events, parameters
from modoboa.extensions.postfix_autoreply.models import Transport, Alias
from .models import ARmessage


@events.observe("ExtraUprefsJS")
def extra_js(user):
    return ["""function autoreply_cb() {
    $('.datefield').datetimepicker({
        format: 'yyyy-mm-dd hh:ii:ss',
        language: '%(lang)s',
        autoclose: true,
        todayHighlight: true,
        todayBtn: 'linked'
    });
}
""" % {'lang': parameters.get_user(user, "LANG", app="core")}
    ]


@events.observe("UserMenuDisplay")
def menu(target, user):
    if target != "uprefs_menu":
        return []
    if not user.mailbox_set.count():
        return []
    return [
        {"name": "autoreply",
         "class": "ajaxlink",
         "url": "autoreply/",
         "label": ugettext_lazy("Auto-reply message")}
    ]


@events.observe("DomainCreated")
def onDomainCreated(user, domain):
    transport = Transport()
    transport.domain = "autoreply.%s" % domain.name
    transport.method = "autoreply:"
    transport.save()


@events.observe("DomainModified")
def onDomainModified(domain):
    if domain.oldname == domain.name:
        return
    Transport.objects.filter(domain="autoreply.%s" % domain.oldname) \
        .update(domain="autoreply.%s" % domain.name)
    for al in Alias.objects.filter(full_address__contains="@%s" % domain.oldname):
        new_address = al.full_address.replace("@%s" % domain.oldname, "@%s" % domain.name)
        al.full_address = new_address
        al.autoreply_address = "%s@autoreply.%s" % (new_address, domain.name)
        al.save()


@events.observe("DomainDeleted")
def onDomainDeleted(domain):
    Transport.objects.filter(domain="autoreply.%s" % domain.name).delete()


@events.observe("MailboxCreated")
def onMailboxCreated(user, mailbox):
    alias = Alias()
    alias.full_address = mailbox.full_address
    alias.autoreply_address = \
        "%s@autoreply.%s" % (mailbox.full_address, mailbox.domain.name)
    alias.save()


@events.observe("MailboxDeleted")
def onMailboxDeleted(mailboxes):
    from modoboa.extensions.admin.models import Mailbox

    if isinstance(mailboxes, Mailbox):
        mailboxes = [mailboxes]
    for mailbox in mailboxes:
        try:
            alias = Alias.objects.get(full_address=mailbox.full_address)
        except Alias.DoesNotExist:
            pass
        else:
            alias.delete()


@events.observe("MailboxModified")
def onMailboxModified(mailbox):
    if not hasattr(mailbox, 'old_full_address'):
        return
    if mailbox.full_address == mailbox.old_full_address:
        return
    alias = Alias.objects.get(full_address=mailbox.old_full_address)
    alias.full_address = mailbox.full_address
    alias.autoreply_address =  \
        "%s@autoreply.%s" % (mailbox.full_address, mailbox.domain.name)
    alias.save()


@events.observe("ExtraFormFields")
def extra_mailform_fields(form_name, mailbox=None):
    """Define extra fields to include in mail forms.

    For now, only the auto-reply state can be modified.

    :param str form_name: form name (must be 'mailform')
    :param Mailbox mailbox: mailbox
    """
    from modoboa.lib.formutils import YesNoField

    if form_name != "mailform":
        return []
    status = False
    if mailbox is not None and mailbox.armessage_set.count():
        status = mailbox.armessage_set.all()[0].enabled
    return [
        ('autoreply', YesNoField(
            label=ugettext_lazy("Enable auto-reply"),
            initial="yes" if status else "no",
            help_text=ugettext_lazy("Enable or disable Postfix auto-reply")
        ))
    ]


@events.observe("SaveExtraFormFields")
def save_extra_mailform_fields(form_name, mailbox, values):
    """Set the auto-reply status for a mailbox.

    If a corresponding auto-reply message exists, we update its
    status. Otherwise, we create a message using default values.

    :param str form_name: form name (must be 'mailform')
    :param Mailbox mailbox: mailbox
    :param dict values: form values
    """
    if form_name != 'mailform':
        return
    if mailbox.armessage_set.count():
        arm = mailbox.armessage_set.all()[0]
    else:
        arm = ARmessage(mbox=mailbox)
        arm.subject = parameters.get_admin("DEFAULT_SUBJECT")
        arm.content = parameters.get_admin("DEFAULT_CONTENT") \
            % {'name': mailbox.user.fullname}
        arm.fromdate = timezone.now()
    arm.enabled = True if values['autoreply'] == 'yes' else False
    arm.save()

########NEW FILE########
__FILENAME__ = autoreply
#!/usr/bin/env python
# coding: utf-8
import sys
import datetime
from django.core.management.base import BaseCommand, CommandError
from django.utils import timezone
from modoboa.lib import parameters
from modoboa.lib.emailutils import split_mailbox, sendmail_simple
from modoboa.extensions.admin.models import Mailbox
from modoboa.extensions.postfix_autoreply import PostfixAutoreply
from modoboa.extensions.postfix_autoreply.models import ARmessage, ARhistoric


def send_autoreply(sender, mailbox, armessage):
    if armessage.fromdate > timezone.now():
        return
    if armessage.untildate is not None \
        and armessage.untildate < timezone.now():
        armessage.enabled = False
        armessage.save()
        return

    try:
        lastar = ARhistoric.objects.get(armessage=armessage.id, sender=sender)
        PostfixAutoreply().load()
        timeout = parameters.get_admin("AUTOREPLIES_TIMEOUT",
                                       app="postfix_autoreply")
        delta = datetime.timedelta(seconds=int(timeout))
        now = timezone.make_aware(datetime.datetime.now(),
                                  timezone.get_default_timezone())
        if lastar.last_sent + delta > now:
            sys.exit(0)
    except ARhistoric.DoesNotExist:
        lastar = ARhistoric()
        lastar.armessage = armessage
        lastar.sender = sender

    sendmail_simple(mailbox.user.encoded_address, sender, armessage.subject,
                    armessage.content.encode('utf-8'))

    lastar.last_sent = datetime.datetime.now()
    lastar.save()


class Command(BaseCommand):
    args = '<sender> <recipient ...>'
    help = 'Send autoreply emails'

    def handle(self, *args, **options):
        if len(args) < 2:
            raise CommandError("usage: ./manage.py autoreply <sender> <recipient ...>")

        sender = args[0]
        for fulladdress in args[1:]:
            address, domain = split_mailbox(fulladdress)
            try:
                mbox = Mailbox.objects.get(address=address, domain__name=domain)
            except Mailbox.DoesNotExist:
                print "Unknown recipient %s" % (fulladdress)
                continue
            try:
                armessage = ARmessage.objects.get(mbox=mbox.id, enabled=True)
            except ARmessage.DoesNotExist:
                continue

            send_autoreply(sender, mbox, armessage)

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):
    
    def forwards(self, orm):
        
        # Adding model 'Transport'
        db.create_table('postfix_autoreply_transport', (
            ('domain', self.gf('django.db.models.fields.CharField')(max_length=300)),
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('method', self.gf('django.db.models.fields.CharField')(max_length=255)),
        ))
        db.send_create_signal('postfix_autoreply', ['Transport'])

        # Adding model 'Alias'
        db.create_table('postfix_autoreply_alias', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('full_address', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('autoreply_address', self.gf('django.db.models.fields.CharField')(max_length=255)),
        ))
        db.send_create_signal('postfix_autoreply', ['Alias'])
    
    
    def backwards(self, orm):
        
        # Deleting model 'Transport'
        db.delete_table('postfix_autoreply_transport')

        # Deleting model 'Alias'
        db.delete_table('postfix_autoreply_alias')
    
    
    models = {
        'postfix_autoreply.alias': {
            'Meta': {'object_name': 'Alias'},
            'autoreply_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'postfix_autoreply.transport': {
            'Meta': {'object_name': 'Transport'},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '300'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'method': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }
    
    complete_apps = ['postfix_autoreply']

########NEW FILE########
__FILENAME__ = 0002_auto__add_armessage__add_arhistoric
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from modoboa.lib.dbutils import db_table_exists

class Migration(SchemaMigration):
    
    def forwards(self, orm):
        # Renaming/Creating model 'ARmessage'
        if db_table_exists('main_armessage'):
            db.rename_table('main_armessage', 'postfix_autoreply_armessage')
        else:
            db.create_table('postfix_autoreply_armessage', (
                    ('mbox', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['admin.Mailbox'])),
                    ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
                    ('subject', self.gf('django.db.models.fields.CharField')(max_length=255)),
                    ('content', self.gf('django.db.models.fields.TextField')()),
                    ('enabled', self.gf('django.db.models.fields.BooleanField')(default=False, blank=True))
                    ))
            db.send_create_signal('postfix_autoreply', ['ARmessage'])

        db.add_column('postfix_autoreply_armessage', 'untildate',
                      models.DateTimeField(null=True))

        # Renaming model 'ARhistoric'
        if db_table_exists('main_arhistoric'):
            db.rename_table('main_arhistoric', 'postfix_autoreply_arhistoric')
        else:
            db.create_table('postfix_autoreply_arhistoric', (
                    ('armessage', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['postfix_autoreply.ARmessage'])),
                    ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
                    ('last_sent', self.gf('django.db.models.fields.DateTimeField')(auto_now=True)),
                    ('sender', self.gf('django.db.models.fields.TextField')()),
                    ))
            db.send_create_signal('postfix_autoreply', ['ARhistoric'])
    
    
    def backwards(self, orm):
        raise RuntimeError("Cannot reverse this migration.")
    
    
    models = {
        'admin.domain': {
            'Meta': {'object_name': 'Domain'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '150'}),
            'gid': ('django.db.models.fields.IntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'path': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'quota': ('django.db.models.fields.IntegerField', [], {}),
            'uid': ('django.db.models.fields.IntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'postfix_autoreply.alias': {
            'Meta': {'object_name': 'Alias'},
            'autoreply_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'postfix_autoreply.arhistoric': {
            'Meta': {'object_name': 'ARhistoric'},
            'armessage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['postfix_autoreply.ARmessage']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'sender': ('django.db.models.fields.TextField', [], {})
        },
        'postfix_autoreply.armessage': {
            'Meta': {'object_name': 'ARmessage'},
            'content': ('django.db.models.fields.TextField', [], {}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mbox': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Mailbox']"}),
            'subject': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'untildate': ('django.db.models.fields.DateTimeField', [], {})
        },
        'postfix_autoreply.transport': {
            'Meta': {'object_name': 'Transport'},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '300'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'method': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }
    
    complete_apps = ['postfix_autoreply']

########NEW FILE########
__FILENAME__ = 0003_auto__chg_field_arhistoric_sender
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'ARhistoric.sender'
        db.alter_column(u'postfix_autoreply_arhistoric', 'sender', self.gf('django.db.models.fields.CharField')(max_length=254))

    def backwards(self, orm):

        # Changing field 'ARhistoric.sender'
        db.alter_column(u'postfix_autoreply_arhistoric', 'sender', self.gf('django.db.models.fields.TextField')())

    models = {
        u'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        u'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '252'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'use_domain_quota': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'admin.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_local': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'postfix_autoreply.alias': {
            'Meta': {'object_name': 'Alias'},
            'autoreply_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'postfix_autoreply.arhistoric': {
            'Meta': {'object_name': 'ARhistoric'},
            'armessage': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['postfix_autoreply.ARmessage']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'sender': ('django.db.models.fields.CharField', [], {'max_length': '254'})
        },
        u'postfix_autoreply.armessage': {
            'Meta': {'object_name': 'ARmessage'},
            'content': ('django.db.models.fields.TextField', [], {}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mbox': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Mailbox']"}),
            'subject': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'untildate': ('django.db.models.fields.DateTimeField', [], {})
        },
        u'postfix_autoreply.transport': {
            'Meta': {'object_name': 'Transport'},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '300'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'method': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['postfix_autoreply']
########NEW FILE########
__FILENAME__ = 0004_auto__add_unique_arhistoric_sender_armessage
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding unique constraint on 'ARhistoric', fields ['sender', 'armessage']
        db.create_unique(u'postfix_autoreply_arhistoric', ['sender', 'armessage_id'])


    def backwards(self, orm):
        # Removing unique constraint on 'ARhistoric', fields ['sender', 'armessage']
        db.delete_unique(u'postfix_autoreply_arhistoric', ['sender', 'armessage_id'])


    models = {
        u'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        u'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '252'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'use_domain_quota': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"})
        },
        u'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'admin.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_local': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'postfix_autoreply.alias': {
            'Meta': {'object_name': 'Alias'},
            'autoreply_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'postfix_autoreply.arhistoric': {
            'Meta': {'unique_together': "(('armessage', 'sender'),)", 'object_name': 'ARhistoric'},
            'armessage': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['postfix_autoreply.ARmessage']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'sender': ('django.db.models.fields.CharField', [], {'max_length': '254'})
        },
        u'postfix_autoreply.armessage': {
            'Meta': {'object_name': 'ARmessage'},
            'content': ('django.db.models.fields.TextField', [], {}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mbox': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.Mailbox']"}),
            'subject': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'untildate': ('django.db.models.fields.DateTimeField', [], {})
        },
        u'postfix_autoreply.transport': {
            'Meta': {'object_name': 'Transport'},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '300'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'method': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['postfix_autoreply']
########NEW FILE########
__FILENAME__ = 0005_auto__add_field_armessage_fromdate
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from django.utils import timezone


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'ARmessage.fromdate'
        db.add_column(u'postfix_autoreply_armessage', 'fromdate',
                      self.gf('django.db.models.fields.DateTimeField')(default=timezone.now),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'ARmessage.fromdate'
        db.delete_column(u'postfix_autoreply_armessage', 'fromdate')


    models = {
        'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '252'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'use_domain_quota': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['core.User']"})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'core.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['core.User']"})
        },
        u'core.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_local': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'postfix_autoreply.alias': {
            'Meta': {'object_name': 'Alias'},
            'autoreply_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'postfix_autoreply.arhistoric': {
            'Meta': {'unique_together': "(('armessage', 'sender'),)", 'object_name': 'ARhistoric'},
            'armessage': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['postfix_autoreply.ARmessage']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'sender': ('django.db.models.fields.CharField', [], {'max_length': '254'})
        },
        u'postfix_autoreply.armessage': {
            'Meta': {'object_name': 'ARmessage'},
            'content': ('django.db.models.fields.TextField', [], {}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'fromdate': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mbox': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Mailbox']"}),
            'subject': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'untildate': ('django.db.models.fields.DateTimeField', [], {})
        },
        u'postfix_autoreply.transport': {
            'Meta': {'object_name': 'Transport'},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '300'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'method': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['postfix_autoreply']

########NEW FILE########
__FILENAME__ = 0006_auto__chg_field_armessage_untildate
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'ARmessage.untildate'
        db.alter_column(u'postfix_autoreply_armessage', 'untildate', self.gf('django.db.models.fields.DateTimeField')(null=True))

    def backwards(self, orm):

        # User chose to not deal with backwards NULL issues for 'ARmessage.untildate'
        raise RuntimeError("Cannot reverse this migration. 'ARmessage.untildate' and its values cannot be restored.")

    models = {
        'admin.domain': {
            'Meta': {'ordering': "['name']", 'object_name': 'Domain'},
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'quota': ('django.db.models.fields.IntegerField', [], {})
        },
        'admin.mailbox': {
            'Meta': {'object_name': 'Mailbox'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '252'}),
            'dates': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.ObjectDates']"}),
            'domain': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Domain']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'quota': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'use_domain_quota': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['core.User']"})
        },
        'admin.objectdates': {
            'Meta': {'object_name': 'ObjectDates'},
            'creation': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'core.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['core.User']"})
        },
        u'core.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_local': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'postfix_autoreply.alias': {
            'Meta': {'object_name': 'Alias'},
            'autoreply_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'full_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'postfix_autoreply.arhistoric': {
            'Meta': {'unique_together': "(('armessage', 'sender'),)", 'object_name': 'ARhistoric'},
            'armessage': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['postfix_autoreply.ARmessage']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'sender': ('django.db.models.fields.CharField', [], {'max_length': '254'})
        },
        u'postfix_autoreply.armessage': {
            'Meta': {'object_name': 'ARmessage'},
            'content': ('django.db.models.fields.TextField', [], {}),
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'fromdate': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mbox': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['admin.Mailbox']"}),
            'subject': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'untildate': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'})
        },
        u'postfix_autoreply.transport': {
            'Meta': {'object_name': 'Transport'},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '300'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'method': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['postfix_autoreply']
########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.utils import timezone
from modoboa.extensions.admin.models import Mailbox


class Transport(models.Model):
    domain = models.CharField(max_length=300)
    method = models.CharField(max_length=255)


class Alias(models.Model):
    full_address = models.CharField(max_length=255)
    autoreply_address = models.CharField(max_length=255)


class ARmessage(models.Model):
    mbox = models.ForeignKey(Mailbox)
    subject = models.CharField(
        _('subject'), max_length=255,
        help_text=_("The subject that will appear in sent emails")
    )
    content = models.TextField(
        _('content'),
        help_text=_("The content that will appear in sent emails")
    )
    enabled = models.BooleanField(
        _('enabled'),
        help_text=_("Activate/Deactivate your auto reply")
    )
    fromdate = models.DateTimeField(default=timezone.now)
    untildate = models.DateTimeField(null=True, blank=True)


class ARhistoric(models.Model):
    armessage = models.ForeignKey(ARmessage)
    last_sent = models.DateTimeField(auto_now=True)
    sender = models.CharField(max_length=254)

    class Meta:
        unique_together = ("armessage", "sender")

########NEW FILE########
__FILENAME__ = tests
from django.core.urlresolvers import reverse
from modoboa.core.models import User
from modoboa.lib.tests import ExtTestCase
from modoboa.extensions.admin import factories
from modoboa.extensions.admin.models import (
    Domain
)
from modoboa.extensions.postfix_autoreply.models import (
    Transport, Alias, ARmessage
)


class EventsTestCase(ExtTestCase):
    fixtures = ['initial_users.json']

    def setUp(self):
        super(EventsTestCase, self).setUp()
        self.activate_extensions('postfix_autoreply')
        factories.populate_database()

    def test_domain_created_event(self):
        values = {
            "name": "domain.tld", "quota": 100, "create_dom_admin": "no",
            "stepid": 'step2'
        }
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.domain.newdomain"),
            values
        )
        trans = Transport.objects.get(domain='autoreply.domain.tld')

    def test_domain_deleted_event(self):
        dom = Domain.objects.get(name="test.com")
        trans = Transport.objects.get(domain='autoreply.test.com')
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.domain.deldomain",
                    args=[dom.id]),
            {}
        )
        with self.assertRaises(Transport.DoesNotExist):
            Transport.objects.get(domain='autoreply.test.com')

    def test_domain_modified_event(self):
        values = {
            "name": "test.fr", "quota": 100, "enabled": True
        }
        dom = Domain.objects.get(name="test.com")
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.domain.editdomain",
                    args=[dom.id]),
            values
        )
        trans = Transport.objects.get(domain='autoreply.test.fr')
        self.assertEqual(
            Alias.objects.filter(full_address__contains='@test.fr').count(), 2
        )
        for al in Alias.objects.filter(full_address__contains='@test.fr'):
            self.assertIn('autoreply.test.fr', al.autoreply_address)

    def test_mailbox_created_event(self):
        values = {
            'username': "tester@test.com", 'first_name': 'Tester', 'last_name': 'Toto',
            'password1': 'toto', 'password2': 'toto', 'role': 'SimpleUsers',
            'quota_act': True, 'is_active': True, 'email': 'tester@test.com',
            'stepid': 'step2', 'autoreply': 'no'
        }
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.newaccount"),
            values
        )
        al = Alias.objects.get(full_address='tester@test.com')
        self.assertEqual(al.autoreply_address, 'tester@test.com@autoreply.test.com')
        arm = ARmessage.objects.get(mbox__address='tester')

    def test_mailbox_deleted_event(self):
        account = User.objects.get(username="user@test.com")
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.delaccount",
                    args=[account.id]),
            {}
        )
        with self.assertRaises(Alias.DoesNotExist):
            Alias.objects.get(full_address='user@test.com')
        with self.assertRaises(ARmessage.DoesNotExist):
            ARmessage.objects.get(mbox__address='user', mbox__domain__name='test.com')


    def test_modify_mailbox_event(self):
        values = {
            'username': "leon@test.com", 'first_name': 'Tester', 'last_name': 'Toto',
            'role': 'SimpleUsers', 'quota_act': True, 'is_active': True, 
            'email': 'leon@test.com', 'autoreply': 'no'
        }
        account = User.objects.get(username="user@test.com")
        self.ajax_post(
            reverse("modoboa.extensions.admin.views.identity.editaccount",
                    args=[account.id]),
            values
        )
        with self.assertRaises(Alias.DoesNotExist):
            Alias.objects.get(full_address='user@test.com')
        al = Alias.objects.get(full_address='leon@test.com')


class FormTestCase(ExtTestCase):
    fixtures = ['initial_users.json']

    def setUp(self):
        super(FormTestCase, self).setUp()
        self.activate_extensions('postfix_autoreply')
        factories.populate_database()

    # def test_set_autoreply(self):
    #     self.clt.get(
    #         reverse('modoboa.core.views.user.index')
    #     )
    #     values = {
    #         'subject': 'test', 'content': "I'm off", "enabled": True
    #     }
    #     self.ajax_post(
    #         reverse('modoboa.extensions.postfix_autoreply.views.autoreply'),
    #         values
    #     )
    #     account = User.objects.get(username="user@test.com")
    #     arm = ARmessage.objects.get(mbox=account.mailbox_set.all()[0])
    #     self.assertEqual(arm.subject, 'test')
    #     self.assertTrue(arm.enabled)
    #     self.assertFalse(arm.untildate)
    #     self.assertTrue(arm.fromdate)

########NEW FILE########
__FILENAME__ = views
# coding: utf-8
from datetime import date
from django.contrib.auth.decorators import login_required
from django.utils.translation import ugettext as _
from modoboa.lib.webutils import (
    render_to_json_response, _render_to_string
)
from modoboa.extensions.admin.lib import needs_mailbox
from modoboa.extensions.admin.models import Mailbox
from .forms import ARmessageForm
from .models import ARmessage


@login_required
@needs_mailbox()
def autoreply(request, tplname="postfix_autoreply/autoreply.html"):
    mb = Mailbox.objects.get(user=request.user.id)
    try:
        arm = ARmessage.objects.get(mbox=mb.id)
    except ARmessage.DoesNotExist:
        arm = None
    if request.method == "POST":
        if arm:
            form = ARmessageForm(request.POST, instance=arm)
        else:
            form = ARmessageForm(request.POST)
        if form.is_valid():
            arm = form.save(commit=False)
            arm.fromdate = form.cleaned_data["fromdate"]
            arm.untildate = form.cleaned_data["untildate"]
            arm.mbox = mb
            arm.save()
            return render_to_json_response(
                _("Auto reply message updated successfully.")
            )

        return render_to_json_response(
            {"form_errors": form.errors}, status=400
        )

    form = ARmessageForm(instance=arm)
    return render_to_json_response({
        "content": _render_to_string(request, tplname, {"form": form}),
        "onload_cb": "autoreply_cb"
    })

########NEW FILE########
__FILENAME__ = amavis_callbacks
from modoboa.lib import events
from modoboa.extensions.amavis.lib import (
    create_user_and_policy, update_user_and_policy, delete_user_and_policy,
    create_user_and_use_policy, delete_user
)


@events.observe("RelayDomainCreated")
def on_relay_domain_created(user, rdomain):
    create_user_and_policy(rdomain.name)


@events.observe("RelayDomainModified")
def on_relay_domain_modified(rdomain):
    update_user_and_policy(rdomain.oldname, rdomain.name)


@events.observe("RelayDomainDeleted")
def on_relay_domain_deleted(rdomain):
    delete_user_and_policy(rdomain.name)


@events.observe("RelayDomainAliasCreated")
def on_relay_domain_alias_created(user, rdomainalias):
    create_user_and_use_policy(rdomainalias.name, rdomainalias.target.name)


@events.observe("RelayDomainAliasDeleted")
def on_relay_domain_alias_deleted(rdomainalias):
    delete_user(rdomainalias.name)

########NEW FILE########
__FILENAME__ = app_settings
from django import forms
from django.utils.translation import ugettext_lazy
from modoboa.lib import parameters


class AdminParametersForm(parameters.AdminParametersForm):
    app = "postfix_relay_domains"

    master_cf_path = forms.CharField(
        label=ugettext_lazy("Postfix's master.cf path"),
        initial="/etc/postfix/master.cf",
        help_text=ugettext_lazy('Path to the master.cf configuration file')
    )

########NEW FILE########
__FILENAME__ = factories
import factory
from modoboa.core.factories import PermissionFactory
from . import models


class ServiceFactory(factory.DjangoModelFactory):
    FACTORY_FOR = models.Service
    FACTORY_DJANGO_GET_OR_CREATE = ('name', )

    name = 'dummy'


class RelayDomainFactory(PermissionFactory):
    FACTORY_FOR = models.RelayDomain

    target_host = 'external.host.tld'
    service = factory.SubFactory(ServiceFactory)


class RelayDomainAliasFactory(PermissionFactory):
    FACTORY_FOR = models.RelayDomainAlias

    enabled = True

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.http import QueryDict
from django.utils.translation import ugettext as _, ugettext_lazy
from modoboa.lib import events
from modoboa.lib.formutils import DynamicForm, DomainNameField, TabForms
from modoboa.extensions.admin.models import Domain, DomainAlias
from .models import RelayDomain, RelayDomainAlias


class RelayDomainFormGeneral(forms.ModelForm, DynamicForm):
    aliases = DomainNameField(
        label=ugettext_lazy("Alias(es)"),
        required=False,
        help_text=ugettext_lazy(
            "Alias(es) of this relay domain. Indicate only one name per input"
            ", press ENTER to add a new input."
        )
    )

    class Meta:
        model = RelayDomain
        exclude = ['dates']
        widgets = {
            'service': forms.Select(attrs={'class': 'span2'})
        }

    def __init__(self, *args, **kwargs):
        super(RelayDomainFormGeneral, self).__init__(*args, **kwargs)
        if args and isinstance(args[0], QueryDict):
            self._load_from_qdict(args[0], "aliases", DomainNameField)
        elif 'instance' in kwargs:
            rd = kwargs['instance']
            for pos, rdalias in enumerate(rd.relaydomainalias_set.all()):
                name = "aliases_%d" % (pos + 1)
                self._create_field(forms.CharField, name, rdalias.name, 3)

    def clean(self):
        """Custom fields validaton.

        We want to prevent duplicate names between domains, relay
        domains, domain aliases and relay domain aliases.

        The validation way is not very smart...
        """
        super(RelayDomainFormGeneral, self).clean()
        if self._errors:
            raise forms.ValidationError(self._errors)
        cleaned_data = self.cleaned_data
        for dtype, label in [(Domain, _('domain')),
                             (DomainAlias, _('domain alias')),
                             (RelayDomainAlias, _('relay domain alias'))]:
            try:
                dtype.objects.get(name=cleaned_data['name'])
            except dtype.DoesNotExist:
                pass
            else:
                self._errors["name"] = self.error_class(
                    [_("A %s with this name already exists" % label)]
                )
                del cleaned_data["name"]
                break

        for k in cleaned_data.keys():
            if not k.startswith("aliases"):
                continue
            if not cleaned_data[k]:
                del cleaned_data[k]
                continue
            for dtype, name in [(RelayDomain, _('relay domain')),
                                (DomainAlias, _('domain alias')),
                                (Domain, _('domain'))]:
                try:
                    dtype.objects.get(name=cleaned_data[k])
                except dtype.DoesNotExist:
                    pass
                else:
                    self._errors[k] = self.error_class(
                        [_("A %s with this name already exists" % name)]
                    )
                    del cleaned_data[k]
                    break

        return cleaned_data

    def save(self, user, commit=True, rdomalias_post_create=False):
        """Custom save method.

        As relay domain aliases are defined using the same form as
        relay domains, we need to save them manually.

        :param ``User`` user: connected user
        """
        rd = super(RelayDomainFormGeneral, self).save(commit=False)
        if commit:
            rd.save()
            aliases = []
            for k, v in self.cleaned_data.iteritems():
                if not k.startswith("aliases"):
                    continue
                if v in ["", None]:
                    continue
                aliases.append(v)
            for rdalias in rd.relaydomainalias_set.all():
                if not rdalias.name in aliases:
                    rdalias.delete()
                else:
                    aliases.remove(rdalias.name)
            if aliases:
                events.raiseEvent(
                    "CanCreate", user, "relay_domain_aliases", len(aliases)
                )
                for alias in aliases:
                    try:
                        rd.relaydomainalias_set.get(name=alias)
                    except RelayDomainAlias.DoesNotExist:
                        pass
                    else:
                        continue
                    al = RelayDomainAlias(
                        name=alias, target=rd, enabled=rd.enabled
                    )
                    al.save(creator=user) \
                        if rdomalias_post_create else al.save()
        return rd


class RelayDomainForm(TabForms):
    """Specific edition form for relay domains.

    We use a *tabs* compatible form because extensions can add their
    own tab. (ex: amavis)
    """
    def __init__(self, user, *args, **kwargs):
        self.user = user
        self.forms = []
        if user.has_perm("postfix_relay_domains.change_relaydomain"):
            self.forms.append({
                'id': 'general', 'title': _("General"), 
                'formtpl': 'postfix_relay_domains/relaydomain_form.html',
                'cls': RelayDomainFormGeneral, 'mandatory': True
            })

        cbargs = [user]
        if "instances" in kwargs:
            cbargs += [kwargs["instances"]["general"]]
        self.forms += events.raiseQueryEvent("ExtraRelayDomainForm", *cbargs)
        super(RelayDomainForm, self).__init__(*args, **kwargs)

    def save(self, user):
        """Custom save method

        As forms interact with each other, it is easier to make custom
        code to save them.
        """
        self.forms[0]['instance'].save(user, rdomalias_post_create=True)
        for f in self.forms[1:]:
            f["instance"].save(user)

########NEW FILE########
__FILENAME__ = general_callbacks
from django.core.urlresolvers import reverse
from django.template import Template, Context
from django.conf import settings
from django.utils.translation import ugettext_lazy
from django.db.models import Q
from modoboa.lib import events
from .models import RelayDomain, RelayDomainAlias


@events.observe('GetStaticContent')
def static_content(caller, user):
    if caller != 'domains':
        return []

    t = Template("""<script src="{{ STATIC_URL }}postfix_relay_domains/js/relay_domains.js" type="text/javascript"></script>
<script type="text/javascript">
  var rdomain;
  $(document).ready(function() {
    rdomain = new RelayDomains({});
  });
</script>
""")
    return [t.render(Context({'STATIC_URL': settings.STATIC_URL}))]


@events.observe('ExtraDomainFilters')
def extra_domain_filters():
    return ['srvfilter']


@events.observe('ExtraDomainMenuEntries')
def extra_domain_menu_entries(user):
    return [
        {"name": "newrelaydomain",
         "label": ugettext_lazy("Add relay domain"),
         "img": "icon-plus",
         "modal": True,
         "modalcb": "rdomain.domainform_cb",
         "url": reverse(
             "modoboa.extensions.postfix_relay_domains.views.create"
         )},
    ]


@events.observe('ExtraDomainEntries')
def extra_domain_entries(user, domfilter, searchquery, **extrafilters):
    if domfilter is not None and domfilter and domfilter != 'relaydomain':
        return []
    relay_domains = RelayDomain.objects.get_for_admin(user)
    if searchquery is not None:
        q = Q(name__contains=searchquery)
        q |= Q(relaydomainalias__name__contains=searchquery)
        relay_domains = relay_domains.filter(q).distinct()
    if 'srvfilter' in extrafilters and extrafilters['srvfilter']:
        relay_domains = relay_domains.filter(
            Q(service__name=extrafilters['srvfilter'])
        )
    return relay_domains


@events.observe('GetDomainModifyLink')
def rdomain_modify_link(domain):
    if not isinstance(domain, RelayDomain):
        return {}
    return {
        'url': reverse(
            'modoboa.extensions.postfix_relay_domains.views.edit',
            args=[domain.id]
        ),
        'modalcb': 'rdomain.editdomain_form_cb'
    }


@events.observe('GetDomainActions')
def rdomain_actions(user, domain):
    if not isinstance(domain, RelayDomain):
        return []
    if not user.has_perm("postfix_relay_domains.delete_relaydomain"):
        return []
    return [{
        "name": "delrelaydomain",
        "url": reverse("modoboa.extensions.postfix_relay_domains.views.delete",
                       args=[domain.id]),
        "title": ugettext_lazy("Delete %s?" % domain.name),
        "img": "icon-trash"
    }]


@events.observe('CheckDomainName')
def check_domain_name():
    return [
        (RelayDomain, ugettext_lazy('relay domain')),
        (RelayDomainAlias, ugettext_lazy('relay domain alias'))
    ]


@events.observe('GetExtraLimitTemplates')
def extra_limit_templates():
    return [
        ('relay_domains_limit', ugettext_lazy('Relay domains'),
         ugettext_lazy('Maximum number of relay domains this user can create'),
         'Resellers'),
        ("relay_domain_aliases_limit", ugettext_lazy("Relay domain aliases"),
         ugettext_lazy('Maximum number of relay domain aliases this user can create'),
         'Resellers'),
    ]


@events.observe('ExtraDomainImportHelp')
def extra_domain_import_help():
    return [ugettext_lazy("""
<li><em>relaydomain; name; target host; service; enabled; verify recipients</em></li>
<li><em>relaydomainalias; name; target; enabled</em></li>
""")]


@events.observe('ImportObject')
def get_import_func(objtype):
    from .lib import import_relaydomain, import_relaydomainalias

    if objtype == 'relaydomain':
        return [import_relaydomain]
    if objtype == 'relaydomainalias':
        return [import_relaydomainalias]
    return []


@events.observe('ExtEnabled')
def extension_enabled(extension):
    """ExtEnabled event listener.

    Usefull when *limits* or *amavis* extensions are activated after
    *postfix_relay_domains*.

    :param extension: enabled extension
    """
    from modoboa.extensions.postfix_relay_domains import (
        init_limits_dependant_features, init_amavis_dependant_features
    )
    if extension.name == 'limits':
        init_limits_dependant_features()
    if extension.name == 'amavis':
        init_amavis_dependant_features()

########NEW FILE########
__FILENAME__ = lib
from django.db import transaction
from .models import RelayDomain, RelayDomainAlias


@transaction.commit_on_success
def import_relaydomain(user, row, formopts):
    """Specific code for relay domains import"""
    RelayDomain().from_csv(user, row)


@transaction.commit_on_success
def import_relaydomainalias(user, row, formopts):
    """Specific code for relay domain aliases import"""
    RelayDomainAlias().from_csv(user, row)

########NEW FILE########
__FILENAME__ = limits_callbacks
from django.utils.translation import ugettext_lazy
from modoboa.lib import events
from modoboa.lib.permissions import get_object_owner
from modoboa.extensions.limits.lib import inc_limit_usage, dec_limit_usage
from .models import RelayDomainAlias


@events.observe('GetExtraParameters')
def extra_parameters(app, level):
    from django import forms

    if app != 'limits' or level != 'A':
        return {}
    return {
        'deflt_relay_domains_limit': forms.IntegerField(
            label=ugettext_lazy("Relay domains"),
            initial=0,
            help_text=ugettext_lazy(
                "Maximum number of allowed relay domains for a new administrator"
            ),
            widget=forms.widgets.TextInput(attrs={"class": "span1"})
        ),
        'deflt_relay_domain_aliases_limit': forms.IntegerField(
            label=ugettext_lazy("Relay domain aliases"),
            initial=0,
            help_text=ugettext_lazy(
                "Maximum number of allowed relay domain aliases for a new administrator"
            ),
            widget=forms.widgets.TextInput(attrs={"class": "span1"})
        )
    }


@events.observe('RelayDomainCreated')
def inc_relaydomains_count(user, rdomain):
    inc_limit_usage(user, 'relay_domains_limit')


@events.observe('RelayDomainDeleted')
def dec_relaydomains_count(rdomain):
    owner = get_object_owner(rdomain)
    dec_limit_usage(owner, 'relay_domains_limit')
    for rdomalias in rdomain.relaydomainalias_set.all():
        dec_rdomaliases_count(rdomalias)


@events.observe('RelayDomainAliasCreated')
def inc_rdomaliases_count(user, rdomalias):
    inc_limit_usage(user, 'relay_domain_aliases_limit')


@events.observe('RelayDomainAliasDeleted')
def dec_rdomaliases_count(rdomainaliases):
    if isinstance(rdomainaliases, RelayDomainAlias):
        rdomainaliases = [rdomainaliases]
    for rdomainalias in rdomainaliases:
        owner = get_object_owner(rdomainalias)
        dec_limit_usage(owner, 'relay_domain_aliases_limit')

########NEW FILE########
__FILENAME__ = models
import reversion
from django.db import models
from django.db.models.manager import Manager
from django.contrib.contenttypes import generic
from django.utils.translation import ugettext as _, ugettext_lazy
from modoboa.core.models import ObjectAccess
from modoboa.lib import parameters
from modoboa.lib.exceptions import BadRequest, NotFound
from modoboa.extensions.admin.models import AdminObject


class RelayDomainManager(Manager):

    def get_for_admin(self, admin):
        """Return the relay domains belonging to this admin.

        The result is a ``QuerySet`` object, so this function can be used
        to fill ``ModelChoiceField`` objects.
        """
        if admin.is_superuser:
            return self.get_query_set()
        return self.get_query_set().filter(owners__user=admin)


class ServiceManager(Manager):

    def load_from_master_cf(self):
        """Load services from the master.cf file.

        Parse the configuration file to update the service table. New
        entries are saved and outdated ones (ie. present in the
        database but not in the file) are removed.
        """
        with open(parameters.get_admin('MASTER_CF_PATH')) as fp:
            content = fp.read()
        services = []
        for line in content.split('\n'):
            if not line or line.startswith('#'):
                continue
            parts = line.strip().split()
            if len(parts) != 8:
                continue
            if parts[7] != 'smtp':
                continue
            srv, created = self.get_or_create(name=parts[0])
            services.append(parts[0])
        to_delete = []
        for service in self.all():
            if not service.name in services:
                to_delete.append(service.name)
        Service.objects.filter(name__in=to_delete).delete()


class Service(models.Model):
    """Postfix service.
    """
    name = models.CharField(
        ugettext_lazy('name'), max_length=100, unique=True,
        help_text=ugettext_lazy('The service name')
    )

    objects = ServiceManager()

    def __str__(self):
        return self.name


class RelayDomain(AdminObject):
    """Relay domain.

    A relay domain differs from a usual domaine because its final
    destination is not reached yet. It must be accepted by the MTA but
    it will then be transfered to another one.
    """
    name = models.CharField(
        ugettext_lazy('name'), max_length=100, unique=True,
        help_text=ugettext_lazy('The domain name')
    )
    target_host = models.CharField(
        ugettext_lazy('target host'), max_length=255,
        help_text=ugettext_lazy('Remote destination of this domain')
    )
    service = models.ForeignKey(Service, default='relay')
    enabled = models.BooleanField(
        ugettext_lazy('enabled'),
        help_text=ugettext_lazy('Check to activate this domain')
    )
    verify_recipients = models.BooleanField(
        ugettext_lazy('verify recipients'),
        help_text=ugettext_lazy('Check for valid recipients')
    )

    owners = generic.GenericRelation(ObjectAccess)

    objects = RelayDomainManager()

    class Meta:
        ordering = ['name']

    @property
    def tags(self):
        return [
            {"name": "relaydomain", "label": _("Relay Domain"), "type": "dom"},
            {"name": self.service.name, "label": "%s:" % self.service.name, 
             "type": "srv", "color": "info"}
        ]

    @property
    def aliases(self):
        return self.relaydomainalias_set

    def __str__(self):
        return self.name

    def to_csv(self, csvwriter):
        """Export this relay domain to CSV.

        :param csvwriter:
        """
        csvwriter.writerow(
            ["relaydomain", self.name, self.target_host, 
             self.service.name, self.enabled, self.verify_recipients]
        )
        for rdalias in self.relaydomainalias_set.all():
            rdalias.to_csv(csvwriter)

    def from_csv(self, user, row):
        """Import a relay domain from CSV.

        :param user: user importing the relay domain
        :param str row: relay domain definition
        """
        if len(row) != 6:
            raise BadRequest(_("Invalid line"))
        self.name = row[1].strip()
        self.target_host = row[2].strip()
        self.service, created = Service.objects.get_or_create(name=row[3].strip())
        self.enabled = (row[4].strip() == 'True')
        self.verify_recipients = (row[5].strip() == 'True')
        self.save(creator=user)

    def post_create(self, creator):
        """Post creation actions.

        :param ``User`` creator: user whos created this relay domain
        """
        super(RelayDomain, self).post_create(creator)
        for rdomalias in self.relaydomainalias_set.all():
            rdomalias.post_create(creator)

reversion.register(RelayDomain)


class RelayDomainAlias(AdminObject):
    """Relay domain alias.

    """
    name = models.CharField(
        ugettext_lazy("name"), max_length=100, unique=True,
        help_text=ugettext_lazy("The alias name")
    )
    target = models.ForeignKey(
        RelayDomain, verbose_name=ugettext_lazy('target'),
        help_text=ugettext_lazy("The relay domain this alias points to")
    )
    enabled = models.BooleanField(
        ugettext_lazy('enabled'),
        help_text=ugettext_lazy("Check to activate this alias")
    )

    def __str__(self):
        return self.name

    def to_csv(self, csvwriter):
        """Export this relay domain alias to CSV.

        :param csvwriter:
        """
        csvwriter.writerow(
            ['relaydomainalias', self.name, self.target.name, self.enabled]
        )

    def from_csv(self, user, row):
        """Import a relay domain alias from CSV.

        :param user: user importing the relay domain alias
        :param str row: relay domain alias definition
        """
        if len(row) != 4:
            raise BadRequest(_("Invalid line"))
        self.name = row[1].strip()
        try:
            self.target = RelayDomain.objects.get(name=row[2].strip())
        except RelayDomain.DoesNotExist:
            raise NotFound(_("Relay domain %s does not exist" % row[2].strip()))
        self.enabled = (row[3].strip() == 'True')
        self.save(creator=user)

reversion.register(RelayDomainAlias)

########NEW FILE########
__FILENAME__ = tests
from django.core.urlresolvers import reverse
from modoboa.core.factories import UserFactory
from modoboa.lib import parameters
from modoboa.lib.tests import ExtTestCase
from modoboa.extensions.admin import factories
from modoboa.extensions.limits.tests import ResourceTestCase
from .models import RelayDomain, RelayDomainAlias, Service
from .factories import RelayDomainFactory, RelayDomainAliasFactory


class Operations(object):

    def _create_relay_domain(self, name, status=200):
        srv, created = Service.objects.get_or_create(name='dummy')
        values = {
            'name': name, 'target_host': 'external.host.tld',
            'service': srv.id, 'enabled': True
        }
        return self.ajax_post(
            reverse("modoboa.extensions.postfix_relay_domains.views.create"),
            values, status
        )

    def _relay_domain_alias_operation(self, optype, rdomain, name, status=200):
        rdom = RelayDomain.objects.get(name=rdomain)
        values = {
            'name': rdom.name, 'target_host': rdom.target_host,
            'service': rdom.service.id
        }
        aliases = [alias.name for alias in rdom.relaydomainalias_set.all()]
        if optype == 'add':
            aliases.append(name)
        else:
            aliases.remove(name)
        for cpt, alias in enumerate(aliases):
            fname = 'aliases' if not cpt else 'aliases_%d' % cpt
            values[fname] = alias
        return self.ajax_post(
            reverse("modoboa.extensions.postfix_relay_domains.views.edit",
                    args=[rdom.id]),
            values, status
        )

    def _check_limit(self, name, curvalue, maxvalue):
        l = self.user.limitspool.get_limit('%s_limit' % name)
        self.assertEqual(l.curvalue, curvalue)
        self.assertEqual(l.maxvalue, maxvalue)


class RelayDomainsTestCase(ExtTestCase, Operations):
    fixtures = ['initial_users.json']

    def setUp(self):
        super(RelayDomainsTestCase, self).setUp()
        self.activate_extensions('postfix_relay_domains')
        factories.populate_database()
        self.rdom = RelayDomainFactory(name='relaydomain.tld')
        RelayDomainAliasFactory(name='relaydomainalias.tld', target=self.rdom)

    def test_create_relaydomain(self):
        """Test the creation of a relay domain.

        We also check that unique constraints are respected: domain,
        relay domain alias.

        FIXME: add a check for domain alias.
        """
        self._create_relay_domain('relaydomain1.tld')
        rdom = RelayDomain.objects.get(name='relaydomain1.tld')
        self.assertEqual(rdom.target_host, 'external.host.tld')
        self.assertEqual(rdom.service.name, 'dummy')
        self.assertEqual(rdom.enabled, True)
        self.assertEqual(rdom.verify_recipients, False)

        resp = self._create_relay_domain('test.com', 400)
        self.assertEqual(resp['form_errors']['name'][0],
                         'A domain with this name already exists')
        resp = self._create_relay_domain('relaydomainalias.tld', 400)
        self.assertEqual(
            resp['form_errors']['name'][0],
            'A relay domain alias with this name already exists'
        )

    def test_create_relaydomainalias(self):
        """Test the creation of a relay domain alias.

        We also check that unique constraints are respected: domain,
        relay domain.

        FIXME: add a check for domain alias.
        """
        self._relay_domain_alias_operation(
            'add', self.rdom.name, 'relaydomainalias1.tld'
        )
        resp = self._relay_domain_alias_operation(
            'add', self.rdom.name, 'test.com', 400
        )
        self.assertEqual(
            resp['form_errors']['aliases_2'][0],
            'A domain with this name already exists'
        )
        resp = self._relay_domain_alias_operation(
            'add', self.rdom.name, self.rdom.name, 400
        )
        self.assertEqual(
            resp['form_errors']['aliases_2'][0],
            'A relay domain with this name already exists'
        )

    def test_edit_relaydomain(self):
        """Test the modification of a relay domain.

        Rename 'relaydomain.tld' domain to 'relaydomain.org'
        """
        values = {
            'name': 'relaydomain.org', 'target_host': self.rdom.target_host,
            'service': self.rdom.service.id
        }
        self.ajax_post(
            reverse('modoboa.extensions.postfix_relay_domains.views.edit',
                    args=[self.rdom.id]),
            values
        )
        RelayDomain.objects.get(name='relaydomain.org')

    def test_edit_relaydomainalias(self):
        """Test the modification of a relay domain alias.

        Rename 'relaydomainalias.tld' domain to 'relaydomainalias.net'
        """
        values = {
            'name': 'relaydomain.org', 'target_host': self.rdom.target_host,
            'service': self.rdom.service.id, 'aliases': 'relaydomainalias.net'
        }
        self.ajax_post(
            reverse('modoboa.extensions.postfix_relay_domains.views.edit',
                    args=[self.rdom.id]),
            values
        )
        RelayDomainAlias.objects.get(name='relaydomainalias.net')
        with self.assertRaises(RelayDomainAlias.DoesNotExist):
            RelayDomainAlias.objects.get(name='relaydomainalias.tld')

    def test_delete_relaydomain(self):
        """Test the removal of a relay domain
        """
        self.ajax_post(
            reverse("modoboa.extensions.postfix_relay_domains.views.delete",
                    args=[self.rdom.id]),
            {}
        )
        with self.assertRaises(RelayDomain.DoesNotExist):
            RelayDomain.objects.get(name='relaydomain.tld')

    def test_delete_relaydomainalias(self):
        """Test the remove of a relay domain alias
        """
        self._relay_domain_alias_operation(
            'del', self.rdom.name, 'relaydomainalias.tld'
        )
        with self.assertRaises(RelayDomain.DoesNotExist):
            RelayDomain.objects.get(name='relaydomainalias.tld')


class LimitsTestCase(ExtTestCase, Operations):
    fixtures = ['initial_users.json']

    def setUp(self):
        super(LimitsTestCase, self).setUp()
        from modoboa.extensions.limits.models import LimitTemplates

        self.activate_extensions('limits', 'postfix_relay_domains')
        for tpl in LimitTemplates().templates:
            parameters.save_admin('DEFLT_%s' % tpl[0].upper(), 2, app='limits')
        self.user = UserFactory.create(
            username='reseller', groups=('Resellers',)
        )
        self.clt.logout()
        self.clt.login(username='reseller', password='toto')

    def test_relay_domains_limit(self):
        self._create_relay_domain('relaydomain1.tld')
        self._check_limit('relay_domains', 1, 2)
        self._create_relay_domain('relaydomain2.tld')
        self._check_limit('relay_domains', 2, 2)
        resp = self._create_relay_domain('relaydomain3.tld', 403)
        self._check_limit('relay_domains', 2, 2)
        self.ajax_post(
            reverse('modoboa.extensions.postfix_relay_domains.views.delete',
                    args=[RelayDomain.objects.get(name='relaydomain2.tld').id]),
            {}
        )
        self._check_limit('relay_domains', 1, 2)

    def test_relay_domain_aliases_limit(self):
        self._create_relay_domain('relaydomain1.tld')
        self._relay_domain_alias_operation(
            'add', 'relaydomain1.tld', 'relay_domain_alias1.tld'
        )
        self._check_limit('relay_domain_aliases', 1, 2)
        self._relay_domain_alias_operation(
            'add', 'relaydomain1.tld', 'relay_domain_alias2.tld'
        )
        self._check_limit('relay_domain_aliases', 2, 2)
        self._relay_domain_alias_operation(
            'add', 'relaydomain1.tld', 'relay_domain_alias3.tld', 403
        )
        self._check_limit('relay_domain_aliases', 2, 2)
        self._relay_domain_alias_operation(
            'delete', 'relaydomain1.tld', 'relay_domain_alias2.tld'
        )
        self._check_limit('relay_domain_aliases', 1, 2)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns

urlpatterns = patterns(
    'modoboa.extensions.postfix_relay_domains.views',
    (r'^relaydomains/new/', 'create'),
    (r'^relaydomains/(?P<rdom_id>\d+)/edit/$', 'edit'),
    (r'^relaydomains/(?P<rdom_id>\d+)/delete/$', 'delete'),
    (r'^relaydomains/scan_services/$', 'scan_for_services'),
)

########NEW FILE########
__FILENAME__ = views
import reversion
from django.shortcuts import render
from django.db import transaction
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext as _
from django.views.decorators.http import require_http_methods
from django.contrib.auth.decorators import (
    login_required, permission_required
)
from modoboa.lib import events
from modoboa.lib.exceptions import PermDeniedException
from modoboa.lib.webutils import render_to_json_response
from .models import RelayDomain, Service
from .forms import RelayDomainForm, RelayDomainFormGeneral


@login_required
@permission_required("postfix_relay_domains.add_relaydomain")
@transaction.commit_on_success
@reversion.create_revision()
def create(request, tplname="postfix_relay_domains/new_relaydomain_form.html"):
    events.raiseEvent("CanCreate", request.user, "relay_domains")
    if request.method == 'POST':
        form = RelayDomainFormGeneral(request.POST)
        if form.is_valid():
            rdom = form.save(request.user)
            rdom.post_create(request.user)
            return render_to_json_response(_("Relay domain created"))
        return render_to_json_response(
            {'form_errors': form.errors}, status=400
        )

    ctx = {"title": _("New relay domain"),
           "action_label": _("Create"),
           "action_classes": "submit",
           "action": reverse(create),
           "formid": "rdomform",
           "form": RelayDomainFormGeneral()}
    return render(request, tplname, ctx)


@login_required
@permission_required("postfix_relay_domains.change_relaydomain")
@reversion.create_revision()
def edit(request, rdom_id, tplname='common/tabforms.html'):
    rdom = RelayDomain.objects.get(pk=rdom_id)
    if not request.user.can_access(rdom):
        raise PermDeniedException
    instances = {'general': rdom}
    events.raiseEvent("FillRelayDomainInstances", request.user, rdom, instances)
    if request.method == 'POST':
        rdom.oldname = rdom.name
        form = RelayDomainForm(request.user, request.POST, instances=instances)
        if form.is_valid():
            form.save(request.user)
            events.raiseEvent('RelayDomainModified', rdom)
            return render_to_json_response(_('Relay domain modified'))

        return render_to_json_response(
            {'form_errors': form.errors}, status=400
        )
    ctx = {
        'action': reverse(edit, args=[rdom.id]),
        'formid': 'rdomform',
        'title': rdom.name,
        'action_label': _("Update"),
        'action_classes': "submit",
        'tabs': RelayDomainForm(request.user, instances=instances)
    }
    return render(request, tplname, ctx)


@login_required
@permission_required("postfix_relay_domains.delete_relaydomain")
def delete(request, rdom_id):
    rdom = RelayDomain.objects.get(pk=rdom_id)
    if not request.user.can_access(rdom):
        raise PermDeniedException
    rdom.delete()
    return render_to_json_response(_('Relay domain deleted'))


@login_required
@permission_required("postfix_relay_domains.add_service")
@require_http_methods(["POST"])
def scan_for_services(request):
    try:
        Service.objects.load_from_master_cf()
    except IOError as e:
        return render_to_json_response([str(e)], status=500)

    return render_to_json_response(
        dict((srv.name, srv.id) for srv in Service.objects.all())
    )

########NEW FILE########
__FILENAME__ = app_settings
# coding: utf-8
from django.utils.translation import ugettext_lazy as _
from django import forms
from sievelib.managesieve import SUPPORTED_AUTH_MECHS
from modoboa.lib.parameters import AdminParametersForm, UserParametersForm
from modoboa.lib.formutils import SeparatorField, YesNoField, InlineRadioSelect


def supported_auth_mechs():
    values = [('AUTO', 'auto')]
    for m in SUPPORTED_AUTH_MECHS:
        values += [(m, m.lower())]
    return values


class ParametersForm(AdminParametersForm):
    app = "sievefilters"

    sep1 = SeparatorField(label=_("ManageSieve settings"))

    server = forms.CharField(
        label=_("Server address"),
        initial="127.0.0.1",
        help_text=_("Address of your MANAGESIEVE server")
    )

    port = forms.IntegerField(
        label=_("Server port"),
        initial=4190,
        help_text=_("Listening port of your MANAGESIEVE server")
    )

    starttls = YesNoField(
        label=_("Connect using STARTTLS"),
        initial="no",
        help_text=_("Use the STARTTLS extension")
    )

    authentication_mech = forms.ChoiceField(
        label=_("Authentication mechanism"),
        choices=supported_auth_mechs(),
        initial="auto",
        help_text=_("Prefered authentication mechanism")
    )


class UserSettings(UserParametersForm):
    app = "sievefilters"

    sep1 = SeparatorField(label=_("General"))

    editor_mode = forms.ChoiceField(
        initial="gui",
        label=_("Editor mode"),
        choices=[("raw", "raw"), ("gui", "simplified")],
        help_text=_("Select the mode you want the editor to work in"),
        widget=InlineRadioSelect
    )

    @staticmethod
    def has_access(user):
        return user.mailbox_set.count() != 0

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.http import QueryDict
from django.utils.translation import ugettext as _, ugettext_lazy
from django.forms.widgets import RadioFieldRenderer, RadioSelect, RadioInput
from django.utils.safestring import mark_safe
from django.utils.html import conditional_escape
from django.utils.encoding import force_unicode
from modoboa.extensions.admin.templatetags.admin_tags import gender


class FiltersSetForm(forms.Form):
    name = forms.CharField()
    active = forms.BooleanField(
        label=gender("Active", "m"), required=False,
        initial=False,
        help_text=ugettext_lazy("Check to activate this filters set")
    )


class CustomRadioInput(RadioInput):
    def __unicode__(self):
        return self.render()

    def render(self, name=None, value=None, attrs=None, choices=()):
        name = name or self.name
        value = value or self.value
        attrs = attrs or self.attrs
        if 'id' in self.attrs:
            label_for = ' for="%s_%s"' % (self.attrs['id'], self.index)
        else:
            label_for = ''
        choice_label = conditional_escape(force_unicode(self.choice_label))
        return mark_safe(
            u'<label%s class="radio inline">%s %s</label>'
            % (label_for, self.tag(), choice_label)
        )


class CustomRadioFieldRenderer(RadioFieldRenderer):
    def __iter__(self):
        for i, choice in enumerate(self.choices):
            yield CustomRadioInput(self.name, self.value, self.attrs.copy(), choice, i)

    def __getitem__(self, idx):
        choice = self.choices[idx]
        return CustomRadioInput(self.name, self.value, self.attrs.copy(), choice, idx)

    def render(self):
        return mark_safe(u'\n'.join([force_unicode(w) for w in self]))


class CustomRadioSelect(RadioSelect):
    renderer = CustomRadioFieldRenderer


class FilterForm(forms.Form):
    def __init__(self, conditions, actions, request, *args, **kwargs):
        super(FilterForm, self).__init__(*args, **kwargs)

        self.fields["name"] = forms.CharField(label=_("Name"))
        self.fields["match_type"] = forms.ChoiceField(
            choices=[("allof", _("All of the following")),
                     ("anyof", _("Any of the following")),
                     ("all", _("All messages"))],
            initial="anyof",
            widget=CustomRadioSelect(attrs={"class": "radio inline"})
        )

        self.header_operators = [
            ("contains", _("contains"), "string"),
            ("notcontains", _("does not contain"), "string"),
            ("is", _("is"), "string"),
            ("isnot", _("is not"), "string")
        ]

        self.cond_templates = [
            {"name": "Subject", "label": _("Subject"), "operators": self.header_operators},
            {"name": "From", "label": _("Sender"), "operators": self.header_operators},
            {"name": "To", "label": _("Recipient"), "operators": self.header_operators},
            {"name": "Cc", "label": _("Cc"), "operators": self.header_operators},
            {"name": "size", "label": _("Size"),
             "operators": [("over", _("is greater than"), "number"),
                           ("under", _("is less than"), "number")]},
        ]

        self.action_templates = [
            {"name": "fileinto", "label": _("Move message to"),
             "args": [{"type": "list", "vloader": "userfolders"}]},
            {"name": "redirect", "label": _("Redirect message to"),
             "args": [{"type": "string"}]},
        ]

        self.conds_cnt = 0
        for c in conditions:
            getattr(self, "_build_%s_field" % c[0])(c[1], c[2])
        self.actions_cnt = 0
        for a in actions:
            getattr(self, "_build_%s_field" % a[0])(request, a[1])

    def clean_name(self):
        """Check that name does not contain strange chars.
        """
        if '#' in self.cleaned_data["name"]:
            raise forms.ValidationError(_("Wrong filter name"))
        return self.cleaned_data["name"]

    def _build_header_field(self, name, op, value):
        targets = []
        ops = []
        vfield = None
        for tpl in self.cond_templates:
            targets += [(tpl["name"], tpl["label"]), ]
            if tpl["name"] != name:
                continue
            for opdef in tpl["operators"]:
                ops += [opdef[:2]]
                if op != opdef[0]:
                    continue
                if opdef[2] in ["string", "number"]:
                    vfield = forms.CharField(max_length=255, initial=value)

        self.fields["cond_target_%d" % self.conds_cnt] = \
            forms.ChoiceField(initial=name, choices=targets)
        self.fields["cond_operator_%d" % self.conds_cnt] = \
            forms.ChoiceField(initial=op, choices=ops)
        self.fields["cond_value_%d" % self.conds_cnt] = vfield
        self.conds_cnt += 1

    def _build_Subject_field(self, op, value):
        self._build_header_field("Subject", op, value)

    def _build_To_field(self, op, value):
        self._build_header_field("To", op, value)

    def _build_From_field(self, op, value):
        self._build_header_field("From", op, value)

    def _build_Cc_field(self, op, value):
        self._build_header_field("Cc", op, value)

    def _build_size_field(self, op, value):
        self._build_header_field("size", op, value)

    def _build_action_field(self, request, name, value):
        actions = []
        args = None
        for tpl in self.action_templates:
            actions += [(tpl["name"], tpl["label"]), ]
            if name == tpl["name"]:
                args = tpl["args"]
        self.fields["action_name_%d" % self.actions_cnt] = \
            forms.ChoiceField(initial=name, choices=actions)
        for cnt in xrange(0, len(args)):
            arg = args[cnt]
            aname = "action_arg_%d_%d" % (self.actions_cnt, cnt)
            if arg["type"] == "string":
                self.fields[aname] = forms.CharField(max_length=255, initial=value)
            elif arg["type"] == "list":
                choices = getattr(self, arg["vloader"])(request)
                self.fields[aname] = forms.ChoiceField(initial=value, choices=choices)
        self.actions_cnt += 1

    def _build_redirect_field(self, request, value):
        self._build_action_field(request, "redirect", value)

    def _build_fileinto_field(self, request, value):
        self._build_action_field(request, "fileinto", value)

    def __build_folders_list(self, folders, user, imapc, parentmb=None):
        ret = []
        for fd in folders:
            value = fd["path"] if "path" in fd else fd["name"]
            if parentmb:
                ret += [(value, fd["name"].replace("%s%s" % (parentmb, imapc.hdelimiter), ""))]
            else:
                ret += [(value, fd["name"])]
            if "sub" in fd:
                submboxes = imapc.getmboxes(user, value, unseen_messages=False)
                ret += self.__build_folders_list(submboxes, user, imapc, value)
        return ret

    def userfolders(self, request):
        from modoboa.extensions.webmail.lib import get_imapconnector

        mbc = get_imapconnector(request)
        ret = mbc.getmboxes(request.user, unseen_messages=False)

        folders = self.__build_folders_list(ret, request.user, mbc)
        return folders

    def tofilter(self):
        conditions = []
        actions = []
        for cpt in xrange(0, self.conds_cnt):
            conditions += [(self.cleaned_data["cond_target_%d" % cpt],
                            ":" + self.cleaned_data["cond_operator_%d" % cpt],
                            self.cleaned_data["cond_value_%d" % cpt])]
        for cpt in xrange(0, self.actions_cnt):
            naction = (self.cleaned_data["action_name_%d" % cpt],)
            argcpt = 0
            while True:
                try:
                    naction += (self.cleaned_data["action_arg_%d_%d" % (cpt, argcpt)],)
                except KeyError:
                    break
                argcpt += 1
            actions += [naction]

        return (conditions, actions)


def build_filter_form_from_qdict(request):
    conditions = []
    actions = []
    qdict = QueryDict("", mutable=True)
    qdict["name"] = request.POST["name"]
    qdict["match_type"] = request.POST["match_type"]
    cpt = 0
    i = 0
    if qdict["match_type"] != "all":
        while True:
            if cpt == int(request.POST["conds"]):
                break
            if "cond_target_%d" % i in request.POST:
                qdict["cond_target_%d" % cpt] = request.POST["cond_target_%d" % i]
                qdict["cond_operator_%d" % cpt] = request.POST["cond_operator_%d" % i]
                qdict["cond_value_%d" % cpt] = request.POST["cond_value_%d" % i]
                condtarget = request.POST["cond_target_%d" % i]
                condop = request.POST["cond_operator_%d" % i]
                condvalue = request.POST["cond_value_%d" % i]
                conditions += [(condtarget, condop, condvalue)]
                cpt += 1
            i += 1
    cpt = 0
    i = 0
    while True:
        if cpt == int(request.POST["actions"]):
            break
        if "action_name_%d" % i in request.POST:
            qdict["action_name_%d" % cpt] = request.POST["action_name_%d" % i]
            action = request.POST["action_name_%d" % i]
            argcpt = 0
            args = []
            while True:
                try:
                    qdict["action_arg_%d_%d" % (cpt, argcpt)] = \
                        request.POST["action_arg_%d_%d" % (i, argcpt)]
                    args += [request.POST["action_arg_%d_%d" % (i, argcpt)]]
                except KeyError:
                    break
                argcpt += 1
            args = [action] + args
            actions += [args]
            cpt += 1
        i += 1

    return FilterForm(conditions, actions, request, qdict)


def build_filter_form_from_filter(request, name, fobj):
    from sievelib.commands import SizeCommand, TrueCommand

    match_type = fobj["test"].name
    conditions = []
    for t in fobj["test"]["tests"]:
        if isinstance(t, TrueCommand):
            match_type = "all"
            conditions += [("Subject", "contains", "")]
            break
        elif isinstance(t, SizeCommand):
            conditions += [("size", t["comparator"][1:], t["limit"])]
        else:
            conditions += [(t["header-names"].strip('"'),
                            t["match-type"][1:],
                            t["key-list"].strip('"'))]
    actions = []
    for c in fobj.children:
        action = (c.name,)
        for arg in c.args_definition:
            action += (c[arg["name"]].strip('"'),)
        actions += [action]

    form = FilterForm(conditions, actions, request)
    form.fields["name"].initial = name
    form.fields["match_type"].initial = match_type
    return form

########NEW FILE########
__FILENAME__ = general_callbacks
from django.utils.translation import ugettext as _
from django.core.urlresolvers import reverse
from modoboa.lib import events


@events.observe("UserMenuDisplay")
def menu(target, user):
    if target != "options_menu":
        return []
    if not user.mailbox_set.count():
        return []
    return [
        {"name": "sievefilters",
         "label": _("Message filters"),
         "url": reverse("modoboa.extensions.sievefilters.views.index"),
         "img": "icon-check"}
    ]


@events.observe("UserLogout")
def userlogout(request):
    from .lib import SieveClient

    if not request.user.mailbox_set.count():
        return
    try:
        sc = SieveClient(user=request.user.username,
                         password=request.session["password"])
    except Exception:
        pass
    else:
        sc.logout()

########NEW FILE########
__FILENAME__ = lib
# coding: utf-8

from django.utils.translation import ugettext as _
from sievelib.managesieve import Client, Error
from sievelib.parser import Parser
from sievelib.factory import FiltersSet
from modoboa.lib import parameters
from modoboa.lib.exceptions import ModoboaException
from modoboa.lib.connections import ConnectionsManager, ConnectionError


class SieveClientError(ModoboaException):
    http_code = 424


class SieveClient(object):
    __metaclass__ = ConnectionsManager

    def __init__(self, user=None, password=None):
        try:
            ret, msg = self.login(user, password)
        except Error, e:
            raise ConnectionError(str(e))
        if not ret:
            raise ConnectionError(msg)

    def login(self, user, password):
        self.msc = Client(parameters.get_admin("SERVER"),
                          int(parameters.get_admin("PORT")),
                          debug=False)
        use_starttls = True if parameters.get_admin("STARTTLS") == "yes" else False
        authmech = parameters.get_admin("AUTHENTICATION_MECH")
        if authmech == "AUTO":
            authmech = None
        try:
            ret = self.msc.connect(user, password, use_starttls, authmech)
        except Error:
            ret = False
        if not ret:
            return False, _("Connection to MANAGESIEVE server failed, check your configuration")
        return True, None

    def logout(self):
        self.msc.logout()
        self.msc = None

    def refresh(self, user, password):
        import ssl

        if self.msc is not None:
            try:
                self.msc.capability()
            except Error, e:
                pass
            else:
                return
        try:
            ret, msg = self.login(user, password)
        except (Error, ssl.SSLError), e:
            raise ConnectionError(e)
        if not ret:
            raise ConnectionError(msg)

    def listscripts(self):
        return self.msc.listscripts()

    def getscript(self, name, format="raw"):
        content = self.msc.getscript(name)
        if content is None:
            raise SieveClientError(self.msc.errmsg)
        if format == "raw":
            return content
        p = Parser()
        if not p.parse(content):
            print "Parse error????"
            return None
        fs = FiltersSet(name)
        fs.from_parser_result(p)
        return fs

    def pushscript(self, name, content, active=False):
        if type(content) is unicode:
            content = content.encode("utf-8")
        if not self.msc.havespace(name, len(content)):
            error = "%s (%s)" % (_("Not enough space on server"), self.msc.errmsg)
            raise SieveClientError(error)
        if not self.msc.putscript(name, content):
            raise SieveClientError(self.msc.errmsg)
        if active and not self.msc.setactive(name):
            raise SieveClientError(self.msc.errmsg)

    def deletescript(self, name):
        if not self.msc.deletescript(name):
            raise SieveClientError(self.msc.errmsg)

    def activatescript(self, name):
        if not self.msc.setactive(name):
            raise SieveClientError(self.msc.errmsg)

########NEW FILE########
__FILENAME__ = sfilters_tags
from django import template
from django.template.loader import render_to_string
from django.utils.translation import ugettext as _
from django.core.urlresolvers import reverse
from modoboa.lib.webutils import render_actions

register = template.Library()


@register.simple_tag
def sfilters_menu(user):
    entries = [
        {"name": "newfilterset",
         "img": "icon-plus",
         "label": _("New filters set"),
         "url": reverse("modoboa.extensions.sievefilters.views.new_filters_set"),
         "modal": True,
         "modalcb": "filtersetform_cb"
         }
    ]

    return render_to_string('common/menulist.html',
                            {"entries": entries, "user": user})


@register.simple_tag
def fset_menu(mode, setname):
    entries = []
    if mode == "gui":
        entries += [
            {"name": "newfilter",
             "img": "icon-plus",
             "label": _("New filter"),
             "url": reverse("modoboa.extensions.sievefilters.views.newfilter",
                             args=[setname]),
             "modal": True,
             "autowidth": True,
             "modalcb": "filterform_cb"}
        ]
    if mode == "raw":
        entries += [
            {"name": "savefs",
             "img": "icon-download-alt",
             "label": _("Save filters set"),
             "url": reverse("modoboa.extensions.sievefilters.views.savefs",
                             args=[setname])},
        ]

    entries += [
        {"name": "activatefs",
         "img": "icon-ok",
         "label": _("Activate filters set"),
         "url": reverse("modoboa.extensions.sievefilters.views.activate_filters_set",
                         args=[setname])},
        {"name": "removefs",
         "img": "icon-trash",
         "label": _("Remove filters set"),
         "url": reverse("modoboa.extensions.sievefilters.views.remove_filters_set",
                         args=[setname])},
        {"name": "downloadfs",
         "img": "icon-download",
         "label": _("Download"),
         "url": reverse("modoboa.extensions.sievefilters.views.download_filters_set",
                         args=[setname])}
    ]

    return render_to_string('common/menulist.html',
                            {"entries": entries})


@register.simple_tag
def filter_actions(setname, f, position, islast):
    actions = [
        {"name": "editfilter",
         "url": reverse("modoboa.extensions.sievefilters.views.editfilter",
                         args=[setname, f["name"]]),
         "img": "icon-edit",
         "title": _("Edit filter"),
         "modal": True,
         "autowidth": True,
         "modalcb": "filterform_cb"},
        {"name": "removefilter",
         "url": reverse("modoboa.extensions.sievefilters.views.removefilter",
                         args=[setname, f["name"]]),
         "img": "icon-trash",
         "title": _("Remove this filter")}
    ]
    if position != 1:
        actions += [
            {"name": "movefilter_up",
             "url": reverse("modoboa.extensions.sievefilters.views.move_filter_up",
                             args=[setname, f["name"]]),
             "img": "icon-arrow-up",
             "title": _("Move this filter up")}
        ]
    if not islast:
        actions += [
            {"name": "movefilter_down",
             "url": reverse("modoboa.extensions.sievefilters.views.move_filter_down",
                             args=[setname, f["name"]]),
             "img": "icon-arrow-down",
             "title": _("Move this filter down")},
        ]
    return render_actions(actions)


@register.simple_tag
def display_errors(errors):
    if not len(errors):
        return ""
    t = template.Template("""
<ul class="errors">
  {% for error in errors %}
  <li>{{ error|safe }}</li>
  {% endfor %}
</ul>
""")
    return t.render(template.Context({
        "errors": errors
    }))


@register.simple_tag
def display_condition(form, cnt):
    target = form["cond_target_%d" % cnt]
    operator = form["cond_operator_%d" % cnt]
    value = form["cond_value_%d" % cnt]
    t = template.Template("""
<div id="condition_{{ idx }}" class="item">
  {{ tfield }}{{ofield}}{{ vfield }}{{ verrors }}
</div>
""")
    return t.render(template.Context({
        "idx": cnt,
        "tfield": target,
        "ofield": operator,
        "vfield": value,
        "verrors": display_errors(value.errors)
    }))


@register.simple_tag
def display_action(form, cnt):
    action = form["action_name_%d" % cnt]
    values = []
    acnt = 0
    verrors = []
    while True:
        try:
            values += [form["action_arg_%d_%d" % (cnt, acnt)]]
            if len(form["action_arg_%d_%d" % (cnt, acnt)].errors):
                verrors += form["action_arg_%d_%d" % (cnt, acnt)].errors
            acnt += 1
        except KeyError:
            break
    t = template.Template("""
<div id="action_{{ idx }}" class="item">
  {{ afield }}{% for v in values %}{{ v }}{% endfor %}{{ verrors }}
</div>
""")
    return t.render(template.Context({
        "idx": cnt,
        "afield": action, "values": values,
        "verrors": display_errors(verrors)
    }))

########NEW FILE########
__FILENAME__ = test
if __name__ == "__main__":
    clt = ManageSieveClient("mail.koalabs.org", 2000)
    if clt.connect("tonio@ngyn.org", "aka/12;c", starttls=True):
        print clt.get_sasl_mechanisms()
        print clt.get_sieve_capabilities()        
        print clt.havespace("test", 45)

        if not clt.putscript("myscript", """require ["fileinto", "envelope"];

if envelope :contains "to" "tmartin+sent" {
  fileinto "INBOX.sent";
}
"""):
            print clt.errmsg

        if not clt.putscript("test", """#comment
InvalidSieveCommand
"""):
            print clt.errmsg

        clt.deletescript("thescript")

        if not clt.setactive("myscript"):
            print clt.errmsg
        print clt.listscripts()

        sc = clt.getscript("myscript")
        if sc is None:
            print clt.errmsg
        else:
            print sc

        if not clt.renamescript("myscript", "thescript"):
            print clt.errmsg

        clt.setactive("")

        if not clt.deletescript("thescript"):
            print clt.errmsg
    else:
        print clt.errmsg
    clt.logout()


########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns

urlpatterns = patterns('modoboa.extensions.sievefilters.views',
    (r'^$', 'index'),
    (r'^savefs/(?P<name>.+)/$', 'savefs'),
    (r'^newfs/$', 'new_filters_set'),
    (r'^removefs/(?P<name>.+)/$', 'remove_filters_set'),
    (r'^activatefs/(?P<name>.+)/$', 'activate_filters_set'),
    (r'^downloadfs/(?P<name>.+)/$', 'download_filters_set'),
    (r'^templates/(?P<ftype>\w+)/$', 'get_templates'),
    (r'^(?P<setname>.+)/newfilter/$', 'newfilter'),
    (r'^(?P<setname>.+)/editfilter/(?P<fname>.+)/$', 'editfilter'),
    (r'^(?P<setname>.+)/removefilter/(?P<fname>.+)/$', 'removefilter'),
    (r'^(?P<setname>.+)/togglestate/(?P<fname>.+)/$', 
     'toggle_filter_state'),
    (r'^(?P<setname>.+)/moveup/(?P<fname>.+)/$', 
     'move_filter_up'),
    (r'^(?P<setname>.+)/movedown/(?P<fname>.+)/$', 
     'move_filter_down'),
    (r'^(?P<name>.+)/$', 'getfs'),
)

########NEW FILE########
__FILENAME__ = views
# coding: utf-8
from sievelib.managesieve import Error
from sievelib.commands import BadArgument, BadValue
from rfc6266 import build_header
from django.shortcuts import render
from django.http import HttpResponse
from django.template.loader import render_to_string
from django.contrib.auth.decorators import login_required
from django.utils.translation import ugettext as _
from django.core.urlresolvers import reverse
from modoboa.lib import parameters
from modoboa.lib.webutils import _render_error, \
    ajax_response, render_to_json_response
from modoboa.lib.connections import ConnectionError
from modoboa.lib.exceptions import BadRequest
from modoboa.extensions.admin.lib import needs_mailbox
from .lib import SieveClient, SieveClientError
from .forms import (
    FilterForm, build_filter_form_from_qdict, build_filter_form_from_filter,
    FiltersSetForm
)
from .templatetags.sfilters_tags import fset_menu


@login_required
@needs_mailbox()
def index(request, tplname="sievefilters/index.html"):
    from modoboa.extensions.webmail.lib import get_imapconnector

    try:
        sc = SieveClient(user=request.user.username,
                         password=request.session["password"])
    except ConnectionError, e:
        return _render_error(request, user_context={"error": e})

    try:
        active_script, scripts = sc.listscripts()
    except Error, e:
        return _render_error(request, user_context={"error": e})

    if active_script is None:
        active_script = ""
        default_script = "%s/" % scripts[0] if len(scripts) else ""
    else:
        default_script = "%s/" % active_script
    return render(request, tplname, {
        "selection": "user",
        "active_script": active_script,
        "default_script": default_script,
        "scripts": sorted(scripts),
        "hdelimiter": get_imapconnector(request).hdelimiter
    })


@login_required
@needs_mailbox()
def get_templates(request, ftype):
    if ftype == "condition":
        return render_to_json_response(
            FilterForm([], [], request).cond_templates
        )
    return render_to_json_response(
        FilterForm([], [], request).action_templates
    )


@login_required
@needs_mailbox()
def getfs(request, name):
    sc = SieveClient(user=request.user.username,
                     password=request.session["password"])
    editormode = parameters.get_user(request.user, "EDITOR_MODE")
    error = None
    try:
        content = sc.getscript(name, format=editormode)
    except SieveClientError, e:
        error = str(e)
    else:
        if content is None:
            error = _("Failed to retrieve filters set")

    if error is not None:
        return ajax_response(request, "ko", respmsg=error)

    if editormode == "raw":
        htmlcontent = render_to_string("sievefilters/rawfilter.html", dict(
            name=name, scriptcontent=content
        ))
    else:
        htmlcontent = render_to_string("sievefilters/guieditor.html", dict(
            fs=content
        ))

    menu = '<ul id="fsetmenu" class="nav nav-list"><li class="nav-header">%s</li>%s</ul>' % \
        (_("Actions"), fset_menu(editormode, name))
    resp = dict(menu=menu, content=htmlcontent)
    return render_to_json_response(resp)


def build_filter_ctx(ctx, form):
    ctx["form"] = form
    ctx["conds_nb"] = range(form.conds_cnt)
    ctx["actions_nb"] = range(form.actions_cnt)
    return ctx


def submitfilter(request, setname, okmsg, tplname, tplctx, update=False, sc=None):
    form = build_filter_form_from_qdict(request)
    if form.is_valid():
        if sc is None:
            sc = SieveClient(user=request.user.username,
                             password=request.session["password"])
        fset = sc.getscript(setname, format="fset")
        conditions, actions = form.tofilter()
        match_type = form.cleaned_data["match_type"]
        if match_type == "all":
            match_type = "anyof"
            conditions = [("true",)]
        fltname = form.cleaned_data["name"].encode("utf-8")
        try:
            if not update:
                fset.addfilter(fltname, conditions, actions,
                               match_type)
            else:
                oldname = request.POST["oldname"].encode("utf-8")
                fset.updatefilter(
                    oldname, fltname, conditions, actions, match_type
                )
        except (BadArgument, BadValue) as inst:
            raise BadRequest(str(inst))
        sc.pushscript(fset.name, str(fset))
        return render_to_json_response(okmsg)

    return render_to_json_response({'form_errors': form.errors}, status=400)


@login_required
@needs_mailbox()
def newfilter(request, setname, tplname="sievefilters/filter.html"):
    ctx = dict(
        title=_("New filter"),
        formid="filterform",
        action=reverse(newfilter, args=[setname]),
        action_label=_("Create"),
        action_classes="submit"
    )
    if request.method == "POST":
        return submitfilter(
            request, setname, _("Filter created"), tplname, ctx
        )

    conds = [("Subject", "contains", "")]
    actions = [("fileinto", "")]
    form = FilterForm(conds, actions, request)
    ctx = build_filter_ctx(ctx, form)
    return render(request, tplname, ctx)


@login_required
@needs_mailbox()
def editfilter(request, setname, fname, tplname="sievefilters/filter.html"):
    ctx = dict(
        title=_("Edit filter"),
        formid="filterform",
        action=reverse(editfilter, args=[setname, fname]),
        action_label=_("Update"),
        action_classes="submit"
    )
    sc = SieveClient(user=request.user.username,
                     password=request.session["password"])
    if request.method == "POST":
        return submitfilter(request, setname, _("Filter modified"), tplname, ctx,
                            update=True, sc=sc)

    fset = sc.getscript(setname, format="fset")
    if type(fname) is unicode:
        fname = fname.encode("utf-8")
    f = fset.getfilter(fname)
    form = build_filter_form_from_filter(request, fname, f)
    ctx = build_filter_ctx(ctx, form)
    ctx["oldname"] = fname
    ctx["hidestyle"] = "none" \
        if form.fields["match_type"].initial == "all" else "block"
    return render(request, tplname, ctx)


@login_required
@needs_mailbox()
def removefilter(request, setname, fname):
    sc = SieveClient(user=request.user.username,
                     password=request.session["password"])
    fset = sc.getscript(setname, format="fset")
    if fset.removefilter(fname.encode("utf-8")):
        sc.pushscript(fset.name, str(fset))
        return render_to_json_response(_("Filter removed"))
    return render_to_json_response(_("Failed to remove filter"), status=500)


@login_required
@needs_mailbox()
def savefs(request, name):
    if not "scriptcontent" in request.POST:
        return
    sc = SieveClient(user=request.user.username,
                     password=request.session["password"])
    try:
        sc.pushscript(name, request.POST["scriptcontent"])
    except SieveClientError, e:
        error = str(e)
        return ajax_response(request, "ko", respmsg=error)
    return ajax_response(request, respmsg=_("Filters set saved"))


@login_required
@needs_mailbox()
def new_filters_set(request, tplname="common/generic_modal_form.html"):
    if request.method == "POST":
        form = FiltersSetForm(request.POST)
        if form.is_valid():
            sc = SieveClient(user=request.user.username,
                             password=request.session["password"])
            sc.pushscript(form.cleaned_data["name"], "# Empty script",
                          form.cleaned_data["active"])
            return render_to_json_response({
                "url": form.cleaned_data["name"],
                "active": form.cleaned_data["active"],
                "respmsg": _("Filters set created")
            })
        return render_to_json_response({'form_errors': form.errors}, status=400)

    ctx = {"title": _("Create a new filters set"),
           "formid": "newfiltersset",
           "action_label": _("Create"),
           "action_classes": "submit",
           "action": reverse(new_filters_set),
           "withmenu": False,
           "withunseen": False,
           "form": FiltersSetForm()}
    return render(request, tplname, ctx)


@login_required
@needs_mailbox()
def remove_filters_set(request, name):
    sc = SieveClient(user=request.user.username,
                     password=request.session["password"])
    sc.deletescript(name)
    acs, scripts = sc.listscripts()
    return render_to_json_response(dict(
        respmsg=_("Filters set deleted"), newfs=acs
    ))


@login_required
@needs_mailbox()
def activate_filters_set(request, name):
    sc = SieveClient(user=request.user.username,
                     password=request.session["password"])
    try:
        sc.activatescript(name)
    except SieveClientError, e:
        return ajax_response(request, "ko", respmsg=str(e))
    return ajax_response(request, respmsg=_("Filters set activated"))


@login_required
@needs_mailbox()
def download_filters_set(request, name):
    sc = SieveClient(user=request.user.username,
                     password=request.session["password"])
    try:
        script = sc.getscript(name)
    except SieveClientError, e:
        return ajax_response(request, "ko", respmsg=str(e))

    resp = HttpResponse(script)
    resp["Content-Type"] = "text/plain; charset=utf-8"
    resp["Content-Length"] = len(script)
    resp["Content-Disposition"] = build_header('%s.txt' % name)
    return resp


@login_required
@needs_mailbox()
def toggle_filter_state(request, setname, fname):
    sc = SieveClient(user=request.user.username,
                     password=request.session["password"])
    if type(fname) is unicode:
        fname = fname.encode("utf-8")
    fset = sc.getscript(setname, format="fset")
    if fset.is_filter_disabled(fname):
        ret = fset.enablefilter(fname)
        newstate = _("yes")
        color = "green"
    else:
        ret = fset.disablefilter(fname)
        newstate = _("no")
        color = "red"
    if not ret:
        pass
    sc.pushscript(setname, str(fset))
    return render_to_json_response({
        "label": newstate,
        "color": color
    })


def move_filter(request, setname, fname, direction):
    sc = SieveClient(user=request.user.username,
                     password=request.session["password"])
    fset = sc.getscript(setname, format="fset")
    fset.movefilter(fname.encode("utf-8"), direction)
    sc.pushscript(setname, str(fset))
    return ajax_response(
        request, template="sievefilters/guieditor.html", fs=fset
    )


@login_required
@needs_mailbox()
def move_filter_up(request, setname, fname):
    return move_filter(request, setname, fname, "up")


@login_required
@needs_mailbox()
def move_filter_down(request, setname, fname):
    return move_filter(request, setname, fname, "down")

########NEW FILE########
__FILENAME__ = app_settings
# coding: utf-8
from django.utils.translation import ugettext_lazy
from django import forms
from modoboa.lib.parameters import AdminParametersForm
from modoboa.lib.formutils import SeparatorField


class ParametersForm(AdminParametersForm):
    app = "stats"

    general_sep = SeparatorField(label=ugettext_lazy("General"))

    logfile = forms.CharField(
        label=ugettext_lazy("Path to the log file"),
        initial="/var/log/mail.log",
        help_text=ugettext_lazy("Path to log file used to collect statistics")
    )

    rrd_rootdir = forms.CharField(
        label=ugettext_lazy("Directory to store RRD files"),
        initial="/tmp/modoboa",
        help_text=ugettext_lazy("Path to directory where RRD files are stored")
    )

########NEW FILE########
__FILENAME__ = general_callbacks
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext as _
from modoboa.lib import events


@events.observe("UserMenuDisplay")
def menu(target, user):
    if target != "top_menu" or user.group == "SimpleUsers":
        return []
    return [
        {"name": "stats",
         "label": _("Statistics"),
         "url": reverse('fullindex')}
    ]


@events.observe("GetGraphSets")
def get_default_graphic_sets():
    from modoboa.extensions.stats.graphics import MailTraffic

    gset = MailTraffic()
    return {gset.html_id: gset}

########NEW FILE########
__FILENAME__ = graphics
import os
import inspect
from lxml import etree
from django.utils.translation import ugettext_lazy
from modoboa.lib import parameters
from modoboa.lib.sysutils import exec_cmd


class Curve(object):
    """Graphic curve.

    Simple way to represent a graphic curve.
    """
    def __init__(self, dsname, color, legend, cfunc="AVERAGE"):
        """Constructor.
        """
        self.dsname = dsname
        self.color = color
        self.legend = legend.encode("utf-8")
        self.cfunc = cfunc

    def to_rrd_command_args(self, rrdfile):
        """Convert this curve to the approriate RRDtool command.

        :param str rrdfile: RRD file name
        :return: a list
        """
        rrdfile = os.path.join(
            parameters.get_admin("RRD_ROOTDIR"), "%s.rrd" % rrdfile
        )
        return [
            'DEF:%s=%s:%s:%s' %
            (self.dsname, rrdfile, self.dsname, self.cfunc),
            'CDEF:%(ds)spm=%(ds)s,60,*' % {"ds": self.dsname},
            'XPORT:%spm:"%s"' % (self.dsname, self.legend)
        ]


class Graphic(object):
    """Graphic.

    """
    def __init__(self):
        """Constructor.
        """
        self._curves = []
        try:
            order = getattr(self, "order")
        except AttributeError:
            for member in inspect.getmembers(self):
                if isinstance(member[1], Curve):
                    self._curves += [member[1]]
        else:
            for name in order:
                try:
                    curve = getattr(self, name)
                except AttributeError:
                    continue
                if not isinstance(curve, Curve):
                    continue
                self._curves += [curve]

    @property
    def display_name(self):
        return self.__class__.__name__.lower()

    def export(self, rrdfile, start, end):
        """
        """
        result = []
        cmdargs = []
        for curve in self._curves:
            result += [{
                "name": curve.legend, "color": curve.color, "data": []
            }]
            cmdargs += curve.to_rrd_command_args(rrdfile)
        cmd = "rrdtool xport --start %s --end %s " % (str(start), str(end))
        cmd += " ".join(cmdargs)
        code, output = exec_cmd(cmd)
        if code:
            return []
        tree = etree.fromstring(output)
        for row in tree.xpath('/xport/data/row'):
            timestamp = int(row.find('t').text)
            for vindex, value in enumerate(row.findall('v')):
                if value.text == 'NaN':
                    result[vindex]['data'].append({'x': timestamp, 'y': 0})
                else:
                    result[vindex]['data'].append(
                        {'x': timestamp, 'y': float(value.text)}
                    )
        return result


class AverageTraffic(Graphic):
    """Average traffic.
    """
    title = ugettext_lazy('Average traffic')
    vertlabel = ugettext_lazy('msgs/min')

    # Curve definitions
    sent = Curve("sent", "lawngreen", ugettext_lazy("sent messages"))
    recv = Curve("recv", "steelblue", ugettext_lazy("received messages"))
    bounced = Curve("bounced", "yellow", ugettext_lazy("bounced messages"))
    reject = Curve("reject", "tomato", ugettext_lazy("rejected messages"))

    order = ['reject', 'bounced', 'recv', 'sent']


class AverageTrafficSize(Graphic):
    """Average traffic size.
    """
    title = ugettext_lazy('Average normal traffic size')
    vertlabel = ugettext_lazy('bytes/min')

    # Curve definitions
    size_recv = Curve("size_recv", "orange", ugettext_lazy("received size"))
    size_sent = Curve(
        "size_sent", "mediumturquoise", ugettext_lazy("sent size")
    )


class GraphicSet(object):
    title = None
    _graphics = []

    def __init__(self):
        self.__ginstances = []

    @property
    def html_id(self):
        return self.__class__.__name__.lower()

    @property
    def graphics(self):
        if not self.__ginstances:
            self.__ginstances = [graphic() for graphic in self._graphics]
        return self.__ginstances

    def get_graphic_names(self):
        return [graphic.display_name for graphic in self._graphics]

    def export(self, rrdfile, start, end):
        result = {}
        for graph in self.graphics:
            result[graph.display_name] = {
                "title": graph.title.encode("utf-8"),
                "curves": graph.export(rrdfile, start, end)
            }
        return result


class MailTraffic(GraphicSet):
    title = ugettext_lazy('Mail traffic')
    _graphics = [AverageTraffic, AverageTrafficSize]

########NEW FILE########
__FILENAME__ = lib
# coding: utf-8
import sys
import time


def date_to_timestamp(timetuple):
    """Date conversion.

    Returns a date and a time in seconds from the epoch.

    :param list timetuple: list containing date
    :return: an integer
    """
    date = " ".join(
        [("%d" % elem) if type(elem) is int else elem for elem in timetuple]
    )
    fmt = "%Y %m %d %H %M %S" \
          if timetuple[1].isdigit() else "%Y %b %d %H %M %S"
    try:
        local = time.strptime(date, fmt)
    except ValueError:
        print >> sys.stderr, "Error: failed to convert date and time"
        return 0
    return int(time.mktime(local))

########NEW FILE########
__FILENAME__ = logparser
#!/usr/bin/env python
# coding: utf-8
"""
Postfix log parser.

This scripts parses a log file produced by postfix (or using the same
format). It looks for predefined events and build statistics about
their occurence rate.

At the, somes default graphics are generated using the grapher module.
(see grapher.py)

Predefined events are:
 * Per domain sent/received messages,
 * Per domain received bad messages (bounced, reject for now),
 * Per domain sent/received traffics size,
 * Global consolidation of all previous events.

"""
import time
import sys
import os
import re
import rrdtool
import string
from django.core.management.base import BaseCommand
from optparse import make_option
from modoboa.lib import parameters
from modoboa.extensions.admin.models import Domain
from modoboa.extensions.stats import Stats
from modoboa.extensions.stats.lib import date_to_timestamp


rrdstep = 60
xpoints = 540
points_per_sample = 3
variables = ["sent", "recv", "bounced", "reject", "spam", "virus",
             "size_sent", "size_recv"]


class LogParser(object):

    def __init__(self, options, workdir, year=None):
        """Constructor
        """
        self.logfile = options["logfile"]
        self.debug = options["debug"]
        self.verbose = options["verbose"]
        try:
            self.f = open(self.logfile)
        except IOError as errno:
            self._dprint("%s" % errno)
            sys.exit(1)
        self.workdir = workdir
        self.__year = year
        self.cfs = ['AVERAGE', 'MAX']

        curtime = time.localtime()
        if not self.__year:
            self.__year = curtime.tm_year
        self.curmonth = curtime.tm_mon

        self.data = {}
        self.domains = []
        for dom in Domain.objects.all():
            self.domains += [str(dom.name)]
            self.data[str(dom.name)] = {}
        self.data["global"] = {}

        self.workdict = {}
        self.lupdates = {}
        self._s_date_expr = \
            re.compile(r"(?P<month>\w+)\s+(?P<day>\d+)\s+(?P<hour>\d+):(?P<min>\d+):(?P<sec>\d+)(?P<eol>.*)")
        self._hp_date_expr = \
            re.compile(r"(?P<year>\d+)-(?P<month>\d+)-(?P<day>\d+)T(?P<hour>\d+):(?P<min>\d+):(?P<sec>\d+)\.\d+\+\d+:\d+(?P<eol>.*)")
        self.date_expr = None
        self.line_expr = \
            re.compile(r"\s+([-\w]+)\s+(\w+)/?\w*[[](\d+)[]]:\s+(.*)")
        self._id_expr = re.compile(r"(\w+): (.*)")
        self._prev_se = -1
        self._prev_mi = -1
        self._prev_ho = -1
        self.cur_t = 0

    def _dprint(self, msg):
        """Print a debug message if required.

        :param str msg: debug message
        """
        if not self.debug:
            return
        print msg

    def _parse_date(self, line):
        """Try to match a date inside :kw:`line` and to convert it to
        a timestamp.

        We try different date format until we find valid one. We then
        store it for future use.

        :param str line: a log entry
        :return: the remaining part of the line or None
        """
        match = None
        if self.date_expr is None:
            for expr in [self._s_date_expr, self._hp_date_expr]:
                match = expr.match(line)
                if match is not None:
                    self.date_expr = expr
                    break
        else:
            match = self.date_expr.match(line)
        if match is None:
            return None
        ho = match.group("hour")
        mi = match.group("min")
        se = match.group("sec")
        se = int(int(se) / rrdstep)  # rrd step is one-minute => se = 0
        if self._prev_se != se or self._prev_mi != mi or self._prev_ho != ho:
            mo = match.group("month")
            da = match.group("day")
            try:
                ye = match.group("year")
            except IndexError:
                ye = self.year(mo)
            self.cur_t = date_to_timestamp([ye, mo, da, ho, mi, se])
            self.cur_t = self.cur_t - self.cur_t % rrdstep
            self._prev_mi = mi
            self._prev_ho = ho
            self._prev_se = se
        return match.group('eol')

    def init_rrd(self, fname, m):
        """init_rrd

        Set-up Data Sources (DS)
        Set-up Round Robin Archives (RRA):
        - day,week,month and year archives
        - 2 types : AVERAGE and MAX

        parameter : start time
        return    : last epoch recorded
        """
        ds_type = 'ABSOLUTE'
        rows = xpoints / points_per_sample
        realrows = int(rows * 1.1)    # ensure that the full range is covered
        day_steps = int(3600 * 24 / (rrdstep * rows))
        week_steps = day_steps * 7
        month_steps = week_steps * 5
        year_steps = month_steps * 12

        # Set up data sources for our RRD
        params = []
        for v in variables:
            params += ['DS:%s:%s:%s:0:U' % (v, ds_type, rrdstep * 2)]

        # Set up RRD to archive data
        for cf in ['AVERAGE', 'MAX']:
            for step in [day_steps, week_steps, month_steps, year_steps]:
                params += ['RRA:%s:0.5:%s:%s' % (cf, step, realrows)]

        # With those setup, we can now created the RRD
        rrdtool.create(str(fname),
                       '--start', str(m),
                       '--step', str(rrdstep),
                       *params)
        return m

    def update_rrd(self, dom, t):
        """update_rrd

        Update RRD with records at t time.

        True  : if data are up-to-date for current minute
        False : syslog may have probably been already recorded
        or something wrong
        """
        fname = "%s/%s.rrd" % (self.workdir, dom)
        m = t - (t % rrdstep)
        if not os.path.exists(fname):
            self.lupdates[fname] = self.init_rrd(fname, m)
            self._dprint("[rrd] create new RRD file %s" % fname)
        else:
            if not fname in self.lupdates:
                self.lupdates[fname] = rrdtool.last(str(fname))

        if m <= self.lupdates[fname]:
            if self.verbose:
                print "[rrd] VERBOSE events at %s already recorded in RRD" % m
            return False

        tpl = ""
        for v in variables:
            if tpl != "":
                tpl += ":"
            tpl += v
        # Missing some RRD steps
        # Est ce vraiment nécessaire... ?
        if m > self.lupdates[fname] + rrdstep:
            values = ""
            for v in variables:
                if values != "":
                    values += ":"
                values += "0"
            for p in range(self.lupdates[fname] + rrdstep, m, rrdstep):
                if self.verbose:
                    print "[rrd] VERBOSE update -t %s %s:%s (SKIP)" \
                        % (tpl, p, values)
                rrdtool.update(str(fname), "-t", tpl, "%s:%s" % (p, values))

        values = "%s" % m
        tpl = ""
        for v in variables:
            values += ":"
            values += str(self.data[dom][m][v])
            if tpl != "":
                tpl += ":"
            tpl += v
        if self.verbose:
            print "[rrd] VERBOSE update -t %s %s" % (tpl, values)

        rrdtool.update(str(fname), "-t", tpl, values)
        self.lupdates[fname] = m
        return True

    def initcounters(self, dom):
        init = {}
        for v in variables:
            init[v] = 0
        self.data[dom][self.cur_t] = init

    def inc_counter(self, dom, counter, val=1):
        if dom is not None and dom in self.domains:
            if not self.cur_t in self.data[dom]:
                self.initcounters(dom)
            self.data[dom][self.cur_t][counter] += val

        if not self.cur_t in self.data["global"]:
            self.initcounters("global")
        self.data["global"][self.cur_t][counter] += val

    def year(self, month):
        """Return the appropriate year

        Date used in log files don't always embark the year so we need
        to guess it :p

        This method tries to deal with year changes in a simply
        (ugly?) way: if we currently are in january and the given
        month is different, return the current year -1. Otherwise,
        return the current year.

        Obviously, this method only works for year to year + 1
        changes.

        :param month: the month of the current record beeing parsed
        :return: an integer
        """
        month = time.strptime(month, "%b").tm_mon if not month.isdigit() \
            else int(month)
        if self.curmonth == 1 and month != self.curmonth:
            return self.__year - 1
        return self.__year

    def _parse_line(self, line):
        """Parse a single log line.

        :param str line: log line
        """
        line = self._parse_date(line)
        if line is None:
            return
        m = self.line_expr.match(line)
        if not m:
            return
        host, prog, pid, log = m.groups()
        m = self._id_expr.match(log)
        if m is None:
            self._dprint("Unknown line format: %s" % log)
            return
        (line_id, line_log) = m.groups()
        if line_id == "NOQUEUE":
            addrto = re.match("reject: .*from=<.*> to=<[^@]+@([^>]+)>", line_log)
            if addrto and addrto.group(1) in self.domains:
                self.inc_counter(addrto.group(1), 'reject')
            return
        m = re.search("message-id=<([^>]*)>", line_log)
        if m is not None:
            self.workdict[line_id] = {'from': m.group(1), 'size': 0}
            return
        m = re.search("from=<([^>]*)>, size=(\d+)", line_log)
        if m is not None:
            self.workdict[line_id] = {
                'from': m.group(1), 'size': string.atoi(m.group(2))
            }
            return

        m = re.search("to=<([^>]*)>.*status=(\S+)", line_log)
        if m is not None:
            if not line_id in self.workdict:
                self._dprint("Inconsistent mail (%s: %s), skipping" \
                                 % (line_id, m.group(1)))
                return
            if not m.group(2) in variables:
                self._dprint("Unsupported status %s, skipping" % m.group(2))
                return
            addrfrom = re.match("([^@]+)@(.+)", self.workdict[line_id]['from'])
            if addrfrom is not None and addrfrom.group(2) in self.domains:
                self.inc_counter(addrfrom.group(2), 'sent')
                self.inc_counter(addrfrom.group(2), 'size_sent',
                                 self.workdict[line_id]['size'])
            addrto = re.match("([^@]+)@(.+)", m.group(1))
            domname = addrto.group(2) if addrto is not None else None
            if m.group(2) == "sent":
                self.inc_counter(addrto.group(2), 'recv')
                self.inc_counter(addrto.group(2), 'size_recv',
                                 self.workdict[line_id]['size'])
            else:
                self.inc_counter(domname, m.group(2))
            return
        self._dprint("Unknown line format: %s" % line_log)

    def process(self):
        """Process the log file.

        We parse it and then generate standard graphics (day, week,
        month).
        """
        for line in self.f.readlines():
            self._parse_line(line)

        for dom, data in self.data.iteritems():
            self._dprint("[rrd] dealing with domain %s" % dom)
            for t in sorted(data.keys()):
                self.update_rrd(dom, t)


class Command(BaseCommand):
    help = 'Log file parser'

    option_list = BaseCommand.option_list + (
        make_option("--logfile", default=None,
                    help="postfix log in syslog format", metavar="FILE"),
        make_option("--verbose", default=False, action="store_true",
                    dest="verbose", help="Set verbose mode"),
        make_option("--debug", default=False, action="store_true",
                    help="Set debug mode")
    )

    def handle(self, *args, **options):
        Stats().load()
        if options["logfile"] is None:
            options["logfile"] = parameters.get_admin("LOGFILE", app="stats")
        p = LogParser(options, parameters.get_admin("RRD_ROOTDIR", app="stats"))
        p.process()

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url


urlpatterns = patterns(
    'modoboa.extensions.stats.views',
    url(r'^$', 'index', name='fullindex'),
    url(r'^graphs/$', "graphs"),
)

########NEW FILE########
__FILENAME__ = views
# coding: utf-8
import re
import time
from django.shortcuts import render
from django.utils.translation import ugettext as _
from django.contrib.auth.decorators import (
    login_required, user_passes_test, permission_required
)
from modoboa.lib import events
from modoboa.lib.exceptions import BadRequest, PermDeniedException, NotFound
from modoboa.lib.webutils import (
    render_to_json_response
)
from modoboa.extensions.admin.models import (
    Domain
)
from modoboa.extensions.stats.lib import date_to_timestamp


@login_required
@permission_required("admin.view_mailboxes")
def index(request):
    """
    FIXME: how to select a default graph set ?
    """
    deflocation = "graphs/?gset=mailtraffic"
    if not request.user.is_superuser:
        if not Domain.objects.get_for_admin(request.user).count():
            raise NotFound(_("No statistics available"))

    graph_sets = events.raiseDictEvent('GetGraphSets')
    periods = [{"name": "day", "label": _("Day")},
               {"name": "week", "label": _("Week")},
               {"name": "month", "label": _("Month")},
               {"name": "year", "label": _("Year")}]
    return render(request, 'stats/index.html', {
        "periods": periods,
        "selection": "stats",
        "deflocation": deflocation,
        "graph_sets": graph_sets
    })


@login_required
@user_passes_test(lambda u: u.group != "SimpleUsers")
def graphs(request):
    gset = request.GET.get("gset", None)
    gsets = events.raiseDictEvent("GetGraphSets")
    if not gset in gsets:
        raise NotFound(_("Unknown graphic set"))
    searchq = request.GET.get("searchquery", None)
    period = request.GET.get("period", "day")
    tplvars = dict(graphs={}, period=period)
    if searchq in [None, "global"]:
        if not request.user.is_superuser:
            if not Domain.objects.get_for_admin(request.user).count():
                return render_to_json_response({})
            tplvars.update(
                domain=Domain.objects.get_for_admin(request.user)[0].name
            )
        else:
            tplvars.update(domain="global")
    else:
        domain = Domain.objects.filter(name__contains=searchq)
        if domain.count() != 1:
            return render_to_json_response({})
        if not request.user.can_access(domain[0]):
            raise PermDeniedException
        tplvars.update(domain=domain[0].name)
    if period == "custom":
        if not "start" in request.GET or not "end" in request.GET:
            raise BadRequest(_("Bad custom period"))
        start = request.GET["start"]
        end = request.GET["end"]
        expr = re.compile(r'[:\- ]')
        period_name = "%s_%s" % (expr.sub('', start), expr.sub('', end))
        start = date_to_timestamp(expr.split(start))
        end = date_to_timestamp(expr.split(end))
    else:
        end = int(time.mktime(time.localtime()))
        start = "-1%s" % period
        period_name = period

    tplvars['graphs'] = gsets[gset].export(tplvars["domain"], start, end)
    tplvars["period_name"] = period_name
    tplvars["start"] = start
    tplvars["end"] = end

    return render_to_json_response(tplvars)

########NEW FILE########
__FILENAME__ = app_settings
# coding: utf-8
from django import forms
from django.utils.translation import ugettext_lazy as _
from modoboa.lib.parameters import AdminParametersForm, UserParametersForm
from modoboa.lib.formutils import SeparatorField, YesNoField, InlineRadioSelect


class ParametersForm(AdminParametersForm):
    app = "webmail"

    sep3 = SeparatorField(label=_("General"))

    max_attachment_size = forms.CharField(
        label=_("Maximum attachment size"),
        initial="2048",
        help_text=_("Maximum attachment size in bytes (or KB, MB, GB if specified)")
    )

    sep1 = SeparatorField(label=_("IMAP settings"))

    imap_server = forms.CharField(
        label=_("Server address"),
        initial="127.0.0.1",
        help_text=_("Address of your IMAP server")
    )

    imap_secured = YesNoField(
        label=_("Use a secured connection"),
        initial="no",
        help_text=_("Use a secured connection to access IMAP server")
    )
    
    imap_port = forms.IntegerField(
        label=_("Server port"),
        initial=143,
        help_text=_("Listening port of your IMAP server")
    )

    sep2 = SeparatorField(label=_("SMTP settings"))

    smtp_server = forms.CharField(
        label=_("Server address"),
        initial="127.0.0.1",
        help_text=_("Address of your SMTP server")
    )

    smtp_secured_mode = forms.ChoiceField(
        label=_("Secured connection mode"),
        choices=[("none", _("None")),
                 ("starttls", "STARTTLS"),
                 ("ssl", "SSL/TLS")],
        initial="none",
        help_text=_("Use a secured connection to access SMTP server"),
        widget=InlineRadioSelect
    )
    
    smtp_port = forms.IntegerField(
        label=_("Server port"),
        initial=25,
        help_text=_("Listening port of your SMTP server")
    )

    smtp_authentication = YesNoField(
        label=_("Authentication required"),
        initial="no",
        help_text=_("Server needs authentication")
    )


class UserSettings(UserParametersForm):
    app = "webmail"

    sep1 = SeparatorField(label=_("Display"))
    
    displaymode = forms.ChoiceField(
        initial="plain",
        label=_("Default message display mode"),
        choices=[("html", "html"), ("plain", "text")],
        help_text=_("The default mode used when displaying a message"),
        widget=InlineRadioSelect
    )

    enable_links = YesNoField(
        initial="no",
        label=_("Enable HTML links display"),
        help_text=_("Enable/Disable HTML links display")
    )

    messages_per_page = forms.IntegerField(
        initial=40,
        label=_("Number of displayed emails per page"),
        help_text=_("Sets the maximum number of messages displayed in a page")
    )

    refresh_interval = forms.IntegerField(
        initial=300,
        label=_("Listing refresh rate"),
        help_text=_("Automatic folder refresh rate (in seconds)")
    )

    mboxes_col_width = forms.IntegerField(
        initial=200,
        label=_("Mailboxes container's width"),
        help_text=_("The width of the mailbox list container")
    )

    sep2 = SeparatorField(label=_("Mailboxes"))

    trash_folder = forms.CharField(
        initial="Trash",
        label=_("Trash folder"),
        help_text=_("Folder where deleted messages go")
    )

    sent_folder = forms.CharField(
        initial="Sent",
        label=_("Sent folder"),
        help_text=_("Folder where copies of sent messages go")
    )

    drafts_folder = forms.CharField(
        initial="Drafts",
        label=_("Drafts folder"),
        help_text=_("Folder where drafts go")
    )

    sep3 = SeparatorField(label=_("Composing messages"))

    editor = forms.ChoiceField(
        initial="plain",
        label=_("Default editor"),
        choices=[("html", "html"), ("plain", "text")],
        help_text=_("The default editor to use when composing a message"),
        widget=InlineRadioSelect
    )

    signature = forms.CharField(
        initial="",
        label=_("Signature text"),
        help_text=_("User defined email signature"),
        widget=forms.widgets.Textarea,
        required=False
    )

    visibility_rules = {
        "enable_links": "displaymode=html"
    }

    @staticmethod
    def has_access(user):
        return user.mailbox_set.count() != 0

    def clean_mboxes_col_width(self):
        """Check if the entered value is a positive integer.

        It must also be different from 0.
        """
        if self.cleaned_data['mboxes_col_width'] <= 0:
            raise forms.ValidationError(
                _('Value must be a positive integer (> 0)')
            )
        return self.cleaned_data['mboxes_col_width']

########NEW FILE########
__FILENAME__ = exceptions
# coding: utf-8
"""
:mod:`exceptions` --- Webmail custom exceptions
-----------------------------------------------

"""
import re
from django.utils.translation import ugettext as _
from modoboa.lib.exceptions import ModoboaException, InternalError


class WebmailInternalError(InternalError):
    errorexpr = re.compile(r'\[([^\]]+)\]\s*([^\.]+)')

    def __init__(self, reason, ajax=False):
        match = WebmailInternalError.errorexpr.match(reason)
        if not match:
            self.reason = reason
        else:
            self.reason = "%s: %s" % (_("Server response"), match.group(2))
        self.ajax = ajax

    def __str__(self):
        return self.reason


class UnknownAction(ModoboaException):
    """
    Use this exception when the webmail encounter an unknown action.
    """
    http_code = 404

    def __init__(self):
        super(UnknownAction, self).__init__(_("Unknown action"))


class ImapError(ModoboaException):
    def __init__(self, reason):
        self.reason = reason

    def __str__(self):
        return str(self.reason)

########NEW FILE########
__FILENAME__ = forms
# coding: utf-8
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

import lxml.html

from django import forms
from django.conf import settings
from django.utils.translation import ugettext_lazy as _

from modoboa.lib import parameters
from modoboa.lib.emailutils import set_email_headers
from .lib import (
    ImapEmail, create_mail_attachment
)


def html2plaintext(content):
    """HTML to plain text translation.

    :param content: some HTML content
    """
    if not content:
        return ""
    html = lxml.html.fromstring(content)
    plaintext = ""
    for ch in html.iter():
        p = None
        if ch.text is not None:
            p = ch.text.strip('\r\t\n')
        if ch.tag == "img":
            p = ch.get("alt")
        if p is None:
            continue
        plaintext += p + "\n"
    return plaintext


def make_body_images_inline(body):
    """Looks for images inside the body and make them inline.

    Before sending a message in HTML format, it is necessary to find
    all img tags contained in the body in order to rewrite them. For
    example, icons provided by CKeditor are stored on the server
    filesystem and not accessible from the outside. We must embark
    them as parts of the MIME message if we want recipients to
    display them correctly.

    :param body: the HTML body to parse
    """
    import os
    from email.mime.image import MIMEImage
    from urlparse import urlparse

    html = lxml.html.fromstring(body)
    parts = []
    for tag in html.iter("img"):
        src = tag.get("src")
        if src is None:
            continue
        o = urlparse(src)
        path = os.path.join(settings.MODOBOA_DIR, o.path[1:])
        if not os.path.exists(path):
            continue
        fname = os.path.basename(path)
        cid = "%s@modoboa" % os.path.splitext(fname)[0]
        tag.set("src", "cid:%s" % cid)
        with open(path, "rb") as fp:
            part = MIMEImage(fp.read())
        part["Content-ID"] = "<%s>" % cid
        part.replace_header(
            "Content-Type", '%s; name="%s"' % (part["Content-Type"], fname)
        )
        part["Content-Disposition"] = "inline"
        parts.append(part)
    return lxml.html.tostring(html), parts


class ComposeMailForm(forms.Form):
    """Compose mail form.
    """
    to = forms.CharField(label=_("To"))
    cc = forms.CharField(label=_("Cc"), required=False)
    cci = forms.CharField(label=_("Cci"), required=False)
    subject = forms.CharField(
        label=_("Subject"), max_length=255, required=False
    )
    origmsgid = forms.CharField(
        label="", widget=forms.HiddenInput(), required=False
    )
    body = forms.CharField(widget=forms.widgets.Textarea)

    def _html_msg(self):
        """Create a multipart message.

        We attach two alternatives:
        * text/html
        * text/plain
        """
        msg = MIMEMultipart(_subtype="related")
        submsg = MIMEMultipart(_subtype="alternative")
        body = self.cleaned_data["body"]
        charset = "utf-8"
        if body:
            tbody = html2plaintext(body)
            body, images = make_body_images_inline(body)
        else:
            tbody = ""
            images = []
        submsg.attach(
            MIMEText(tbody.encode(charset), _subtype="plain", _charset=charset)
        )
        submsg.attach(
            MIMEText(body.encode(charset), _subtype="html", _charset=charset)
        )
        msg.attach(submsg)
        for img in images:
            msg.attach(img)
        return msg

    def _plain_msg(self):
        """Create a simple text message.
        """
        charset = "utf-8"
        text = MIMEText(self.cleaned_data["body"].encode(charset),
                        _subtype="plain", _charset=charset)
        return text

    def _build_msg(self, request):
        """Convert form's content to a MIME message.
        """
        editormode = parameters.get_user(request.user, "EDITOR")
        msg = getattr(self, "_%s_msg" % editormode)()

        if request.session["compose_mail"]["attachments"]:
            wrapper = MIMEMultipart(_subtype="mixed")
            wrapper.attach(msg)
            for attdef in request.session["compose_mail"]["attachments"]:
                wrapper.attach(create_mail_attachment(attdef))
            msg = wrapper
        return msg

    def to_msg(self, request):
        """Convert form's content to an object ready to send.

        We set headers at the end to be sure no one will override
        them.

        """
        msg = self._build_msg(request)
        set_email_headers(
            msg, self.cleaned_data["subject"], request.user.encoded_address,
            self.cleaned_data['to']
        )
        origmsgid = self.cleaned_data.get("origmsgid", None)
        if origmsgid:
            msg["References"] = msg["In-Reply-To"] = origmsgid
        return msg


class ForwardMailForm(ComposeMailForm):
    """Forward mail form.
    """

    def _build_msg(self, request):
        """Convert form's content to a MIME message.

        We also add original attachments (if any) to the new message.
        """
        from modoboa.extensions.webmail.lib import decode_payload

        mbox = request.GET.get("mbox", None)
        mailid = request.GET.get("mailid", None)
        msg = super(ForwardMailForm, self)._build_msg(request)
        origmsg = ImapEmail(request, False, "%s:%s" % (mbox, mailid))
        if origmsg.attachments:
            if not msg.is_multipart or not msg.get_content_subtype() == "mixed":
                wrapper = MIMEMultipart(_subtype="mixed")
                wrapper.attach(msg)
                msg = wrapper
            for attpart, fname in origmsg.attachments.items():
                attdef, payload = origmsg.fetch_attachment(attpart)
                attdef["fname"] = fname
                msg.attach(create_mail_attachment(
                    attdef, decode_payload(attdef["encoding"], payload)
                ))
        return msg


class FolderForm(forms.Form):
    oldname = forms.CharField(
        label="", widget=forms.HiddenInput(), required=False
    )
    name = forms.CharField()


class AttachmentForm(forms.Form):
    attachment = forms.FileField(label=_("Select a file"))

########NEW FILE########
__FILENAME__ = general_callbacks
from django.utils.translation import ugettext as _
from django.core.urlresolvers import reverse
from modoboa.lib import events


@events.observe("UserMenuDisplay")
def menu(target, user):
    if target != "top_menu":
        return []
    if not user.mailbox_set.count():
        return []
    return [
        {"name": "webmail",
         "label": _("Webmail"),
         "url": reverse("modoboa.extensions.webmail.views.index")},
    ]


@events.observe("UserLogout")
def userlogout(request):
    from .lib import IMAPconnector
    from .exceptions import ImapError

    if not request.user.mailbox_set.count():
        return
    try:
        m = IMAPconnector(user=request.user.username,
                          password=request.session["password"])
    except Exception:
        # TODO silent exception are bad : we should at least log it
        return

    # The following statement may fail under Python 2.6...
    try:
        m.logout()
    except ImapError:
        pass

########NEW FILE########
__FILENAME__ = attachments
import os
from rfc6266 import build_header
from django.conf import settings
from django.core.files.uploadhandler import FileUploadHandler, SkipFile
from modoboa.lib import parameters
from modoboa.lib.exceptions import InternalError
from modoboa.lib.webutils import size2integer


def set_compose_session(request):
    """Initialize a new "compose" session.

    It is used to keep track of attachments defined with a new
    message. Each new message will be associated with a unique ID (in
    order to avoid conflicts between users).

    :param request: a Request object.
    :return: the new unique ID.
    """
    import uuid
    randid = str(uuid.uuid4()).replace("-", "")
    request.session["compose_mail"] = {"id": randid, "attachments": []}
    return randid


def save_attachment(f):
    """Save a new attachment to the filesystem.

    The attachment is not saved using its own name to the
    filesystem. To avoid conflicts, a random name is generated and
    used instead.

    :param f: an uploaded file object (see Django's documentation)
    :return: the new random name
    """
    from tempfile import NamedTemporaryFile

    dstdir = os.path.join(settings.MEDIA_ROOT, "webmail")
    try:
        fp = NamedTemporaryFile(dir=dstdir, delete=False)
    except Exception as e:
        raise InternalError(str(e))
    for chunk in f.chunks():
        fp.write(chunk)
    fp.close()
    return fp.name


def clean_attachments(attlist):
    """Remove all attachments from the filesystem

    :param attlist: a list of 2-uple. Each element must contain the
                    following information : (random name, real name).
    """
    for att in attlist:
        fullpath = os.path.join(settings.MEDIA_ROOT, "webmail", att["tmpname"])
        try:
            os.remove(fullpath)
        except OSError:
            pass


def create_mail_attachment(attdef, payload=None):
    """Create the MIME part corresponding to the given attachment.

    Mandatory keys: 'fname', 'tmpname', 'content-type'

    :param attdef: a dictionary containing the attachment definition
    :return: a MIMEBase object
    """
    from email import Encoders
    from email.mime.base import MIMEBase

    if "content-type" in attdef:
        maintype, subtype = attdef["content-type"].split("/")
    elif "Content-Type" in attdef:
        maintype, subtype = attdef["Content-Type"].split("/")
    else:
        return None
    res = MIMEBase(maintype, subtype)
    if payload is None:
        with open(os.path.join(
            settings.MEDIA_ROOT, "webmail", attdef["tmpname"]), "rb") as fp:
            res.set_payload(fp.read())
    else:
        res.set_payload(payload)
    Encoders.encode_base64(res)
    if type(attdef['fname']) is str:
        attdef['fname'] = attdef['fname'].decode('utf-8')
    res['Content-Disposition'] = build_header(attdef['fname'])
    return res


class AttachmentUploadHandler(FileUploadHandler):
    """
    Simple upload handler to limit the size of the attachments users
    can upload.
    """

    def __init__(self, request=None):
        super(AttachmentUploadHandler, self).__init__(request)
        self.total_upload = 0
        self.toobig = False
        self.maxsize = size2integer(parameters.get_admin("MAX_ATTACHMENT_SIZE"))

    def receive_data_chunk(self, raw_data, start):
        self.total_upload += len(raw_data)
        if self.total_upload >= self.maxsize:
            self.toobig = True
            raise SkipFile()
        return raw_data

    def file_complete(self, file_size):
        return None

########NEW FILE########
__FILENAME__ = fetch_parser
# coding: utf-8
"""
:mod:`fetch_parser` --- Simple parser for FETCH responses
---------------------------------------------------------

The ``imaplib`` module doesn't parse IMAP responses, it returns raw
values. This is pretty annoying when one FETCH command is issued to
retrieve multiple attributes of a message.

This simple module tries to fix that *problem*.
"""

class ParseError(Exception):
    pass


class Token(object):
    def __init__(self, value):
        self.value = value


class Literal(Token):
    def __init__(self, value):
        super(Literal, self).__init__(value)
        self.next_token_len = int(self.value[1:-1])


def parse_next_token(buf):
    """Look for the next *token*

    By *token*, I mean: *literal*, *quoted* or anything else until the
    next ' ' or ')' character (number, NIL and others should fall into
    this last category).

    :param buf: the buffer to parse
    :return: the position of the token's last caracter into ``buf``
    """
    end = -1
    klass = Token
    if buf[0] == '{':
        # Literal
        end = buf.find('}')
        klass = Literal
    elif buf[0] == '"':
        # quoted
        end = buf.find('"', 1)
    else:
        for pos, c in enumerate(buf):
            if c in [' ', ')']:
                end = pos - 1
                break
        if end == -1:
            raise ParseError("End of buffer reached while looking for a token end")
    end += 1
    token = klass(buf[:end])
    return token, end


def parse_bodystructure(buf, depth=0, prefix=""):
    """Special parser for BODYSTRUCTURE response

    This function tries to transform a BODYSTRUCTURE response sent by
    the server into the corresponding list structure.

    :param buf: the buffer to parse
    :return: a list object and the position of the last scanned
             character into ``buf``
    """
    ret = []
    pos = 1  # skip the first ')'
    nb_bodystruct = 0
    pnum = 1
    while pos < len(buf):
        c = buf[pos]
        if c == '(':
            nprefix = "%s.%s" % (prefix, pnum) if prefix != "" else "%s" % pnum
            subret, end = parse_bodystructure(buf[pos:], depth + 1, nprefix)
            pnum += 1
            if nb_bodystruct == 0:
                ret.append(subret)
            elif nb_bodystruct == 1:
                newret = [ret.pop(-1), subret]
                ret.append(newret)
            else:
                ret[-1].append(subret)
            pos += end + 1
            nb_bodystruct += 1
            continue

        if c == ')':
            partnum = None
            if depth:
                # FIXME : the following is buggy because it doesn't
                # make a difference between a content-disposition with
                # multiple args beeing parsed and a mime part! (see
                # the last example at the end of the file)
                if type(ret[0]) == list or len(ret) >= 7:
                    partnum = prefix
            if partnum is not None:
                return [{"partnum": partnum, "struct": ret}], pos
            return ret, pos
        if c == ' ':
            pos += 1
            continue
        nb_bodystruct = 0
        token, end = parse_next_token(buf[pos:])
        pos += end
        if isinstance(token, Literal):
            ret.append(buf[pos:pos + token.next_token_len].strip('"'))
            pos += token.next_token_len
        else:
            ret.append(token.value.strip('"'))

    raise ParseError("End of buffer reached while looking for a BODY/BODYSTRUCTURE end")


def parse_fetch_response(data):
    """Parse a FETCH response, previously issued by a UID command

    We extract the message number, the UID and its value and consider
    what remains as the response data.

    :param data: the data returned by the ``imaplib`` command
    :return: a dictionnary
    """
    result = {}
    cpt = 0
    while cpt < len(data):
        content = ()
        while cpt < len(data) and data[cpt] != ')':
            if type(data[cpt]) == str:
                # FIXME : probably an unsolicited response
                cpt += 1
                continue
            content += data[cpt]
            cpt += 1
        cpt += 1

        buf = "".join(content)
        parts = buf.split(' ', 3)
        msgdef = result[int(parts[2])] = {}
        response = parts[3]

        while len(response):
            if response.startswith('BODY') and response[4] == '[':
                end = response.find(']', 5)
                if response[end + 1] == '<':
                    end = response.find('>', end + 1)
                end += 1
            else:
                end = response.find(' ')
            cmdname = response[:end]
            response = response[end + 1:]

            end = 0
            if cmdname in ['BODY', 'BODYSTRUCTURE', 'FLAGS']:
                parendepth = 0
                instring = False
                for pos, c in enumerate(response):
                    if not instring and c == '"':
                        instring = True
                        continue
                    if instring and c == '"':
                        if pos and response[pos - 1] != '\\':
                            instring = False
                            continue
                    if not instring and c == '(':
                        parendepth += 1
                        continue
                    if not instring and c == ')':
                        parendepth -= 1
                        if parendepth == 0:
                            end = pos + 1
                            break
            else:
                token, end = parse_next_token(response)
                if isinstance(token, Literal):
                    response = response[end:]
                    end = token.next_token_len

            msgdef[cmdname] = response[:end]
            response = response[end + 1:]
            try:
                func = globals()["parse_%s" % cmdname.lower()]
                msgdef[cmdname] = func(msgdef[cmdname])[0]
            except KeyError:
                pass

    return result


def dump_bodystructure(bs, depth=0):
    if depth:
        print " " * (depth * 4),
    if type(bs[0]) == dict:
        print "%s :" % bs[0]["partnum"],
        struct = bs[0]["struct"]
    else:
        struct = bs

    if type(struct[0]) == list:
        print "multipart/%s" % struct[1]
        for part in struct[0]:
            dump_bodystructure(part, depth + 1)
    else:
        print "%s/%s" % (struct[0], struct[1])


if __name__ == "__main__":
#    resp = [('855 (UID 46931 BODYSTRUCTURE ((("text" "plain" ("charset" "iso-8859-1") NIL NIL "quoted-printable" 886 32 NIL NIL NIL NIL)("text" "html" ("charset" "us-ascii") NIL NIL "quoted-printable" 1208 16 NIL NIL NIL NIL) "alternative" ("boundary" "----=_NextPart_001_0003_01CCC564.B2F64FF0") NIL NIL NIL)("application" "octet-stream" ("name" "Carte Verte_2.pdf") NIL NIL "base64" 285610 NIL ("attachment" ("filename" "Carte Verte_2.pdf")) NIL NIL) "mixed" ("boundary" "----=_NextPart_000_0002_01CCC564.B2F64FF0") NIL NIL NIL) BODY[HEADER.FIELDS (DATE FROM TO CC SUBJECT)] {153}', 'From: <Service.client10@maaf.fr>\r\nTo: <TONIO@NGYN.ORG>\r\nCc: \r\nSubject: Notre contact du 28/12/2011 - 192175092\r\nDate: Wed, 28 Dec 2011 13:29:17 +0100\r\n\r\n'), ')']

 #    #resp = [('856 (UID 46936 BODYSTRUCTURE (("text" "plain" ("charset" "ISO-8859-1") NIL NIL "quoted-printable" 724 22 NIL NIL NIL NIL)("text" "html" ("charset" "ISO-8859-1") NIL NIL "quoted-printable" 2662 48 NIL NIL NIL NIL) "alternative" ("boundary" "----=_Part_1326887_254624357.1325083973970") NIL NIL NIL) BODY[HEADER.FIELDS (DATE FROM TO CC SUBJECT)] {258}', 'Date: Wed, 28 Dec 2011 15:52:53 +0100 (CET)\r\nFrom: =?ISO-8859-1?Q?Malakoff_M=E9d=E9ric?= <communication@communication.malakoffmederic.com>\r\nTo: Antoine Nguyen <tonio@ngyn.org>\r\nSubject: =?ISO-8859-1?Q?Votre_inscription_au_grand_Jeu_Malakoff_M=E9d=E9ric?=\r\n\r\n'), ')']

    resp = [('856 (UID 11111 BODYSTRUCTURE ((("text" "plain" ("charset" "UTF-8") NIL NIL "7bit" 0 0 NIL NIL NIL NIL) "mixed" ("boundary" "----=_Part_407172_3159001.1321948277321") NIL NIL NIL)("application" "octet-stream" ("name" "26274308.pdf") NIL NIL "base64" 14906 NIL ("attachment" ("filename" "26274308.pdf")) NIL NIL) "mixed" ("boundary" "----=_Part_407171_9686991.1321948277321") NIL NIL NIL)',), ')']

#    resp = [('19 (UID 19 FLAGS (\\Seen) BODYSTRUCTURE (("text" "plain" ("charset" "ISO-8859-1" "format" "flowed") NIL NIL "7bit" 2 1 NIL NIL NIL NIL)("message" "rfc822" ("name*" "ISO-8859-1\'\'%5B%49%4E%53%43%52%49%50%54%49%4F%4E%5D%20%52%E9%63%E9%70%74%69%6F%6E%20%64%65%20%76%6F%74%72%65%20%64%6F%73%73%69%65%72%20%64%27%69%6E%73%63%72%69%70%74%69%6F%6E%20%46%72%65%65%20%48%61%75%74%20%44%E9%62%69%74") NIL NIL "8bit" 3632 ("Wed, 13 Dec 2006 20:30:02 +0100" {70}',
#  "[INSCRIPTION] R\xe9c\xe9ption de votre dossier d'inscription Free Haut D\xe9bit"),
#            (' (("Free Haut Debit" NIL "inscription" "freetelecom.fr")) (("Free Haut Debit" NIL "inscription" "freetelecom.fr")) ((NIL NIL "hautdebit" "freetelecom.fr")) ((NIL NIL "nguyen.antoine" "wanadoo.fr")) NIL NIL NIL "<20061213193125.9DA0919AC@dgroup2-2.proxad.net>") ("text" "plain" ("charset" "iso-8859-1") NIL NIL "8bit" 1428 38 NIL ("inline" NIL) NIL NIL) 76 NIL ("inline" ("filename*" "ISO-8859-1\'\'%5B%49%4E%53%43%52%49%50%54%49%4F%4E%5D%20%52%E9%63%E9%70%74%69%6F%6E%20%64%65%20%76%6F%74%72%65%20%64%6F%73%73%69%65%72%20%64%27%69%6E%73%63%72%69%70%74%69%6F%6E%20%46%72%65%65%20%48%61%75%74%20%44%E9%62%69%74")) NIL NIL) "mixed" ("boundary" "------------040706080908000209030901") NIL NIL NIL) BODY[HEADER.FIELDS (DATE FROM TO CC SUBJECT)] {266}',
#             'Date: Tue, 19 Dec 2006 19:50:13 +0100\r\nFrom: Antoine Nguyen <nguyen.antoine@wanadoo.fr>\r\nTo: Antoine Nguyen <tonio@koalabs.org>\r\nSubject: [Fwd: [INSCRIPTION] =?ISO-8859-1?Q?R=E9c=E9ption_de_votre_?=\r\n =?ISO-8859-1?Q?dossier_d=27inscription_Free_Haut_D=E9bit=5D?=\r\n\r\n'), ')']

    # resp = [('123 (UID 3 BODYSTRUCTURE (((("text" "plain" ("charset" "iso-8859-1") NIL NIL "quoted-printable" 1266 30 NIL NIL NIL NIL)("text" "html" ("charset" "iso-8859-1") NIL NIL "quoted-printable" 8830 227 NIL NIL NIL NIL) "alternative" ("boundary" "_000_152AC7ECD1F8AB43A9AD95DBDDCA3118082C09GKIMA24cmcicfr_") NIL NIL NIL)("image" "png" ("name" "image005.png") "<image005.png@01CC6CAA.4FADC490>" "image005.png" "base64" 7464 NIL ("inline" ("filename" "image005.png" "size" "5453" "creation-date" "Tue, 06 Sep 2011 13:33:49 GMT" "modification-date" "Tue, 06 Sep 2011 13:33:49 GMT")) NIL NIL)("image" "jpeg" ("name" "image006.jpg") "<image006.jpg@01CC6CAA.4FADC490>" "image006.jpg" "base64" 2492 NIL ("inline" ("filename" "image006.jpg" "size" "1819" "creation-date" "Tue, 06 Sep 2011 13:33:49 GMT" "modification-date" "Tue, 06 Sep 2011 13:33:49 GMT")) NIL NIL) "related" ("boundary" "_006_152AC7ECD1F8AB43A9AD95DBDDCA3118082C09GKIMA24cmcicfr_" "type" "multipart/alternative") NIL NIL NIL)("application" "pdf" ("name" "bilan assurance CIC.PDF") NIL "bilan assurance CIC.PDF" "base64" 459532 NIL ("attachment" ("filename" "bilan assurance CIC.PDF" "size" "335811" "creation-date" "Fri, 16 Sep 2011 12:45:23 GMT" "modification-date" "Fri, 16 Sep 2011 12:45:23 GMT")) NIL NIL)(("text" "plain" ("charset" "utf-8") NIL NIL "quoted-printable" 1389 29 NIL NIL NIL NIL)("text" "html" ("charset" "utf-8") NIL NIL "quoted-printable" 1457 27 NIL NIL NIL NIL) "alternative" ("boundary" "===============0775904800==") ("inline" NIL) NIL NIL) "mixed" ("boundary" "_007_152AC7ECD1F8AB43A9AD95DBDDCA3118082C09GKIMA24cmcicfr_") NIL ("fr-FR") NIL)',), ')']

    # resp = [('856 (UID 11111 BODYSTRUCTURE ((("text" "plain" ("charset" "UTF-8") NIL NIL "7bit" 0 0 NIL NIL NIL NIL) "mixed" ("boundary" "----=_Part_407172_3159001.1321948277321") NIL NIL NIL)("application" "octet-stream" ("name" "26274308.pdf") NIL NIL "base64" 14906 NIL ("attachment" ("filename" "(26274308.pdf")) NIL NIL) "mixed" ("boundary" "----=_Part_407171_9686991.1321948277321") NIL NIL NIL)',), ')']

    print parse_fetch_response(resp)

########NEW FILE########
__FILENAME__ = imapemail
"""
Set of classes to manipulate/display emails inside the webmail.
"""
import os
import re
import email

import chardet
from rfc6266 import parse_headers

from django.conf import settings
from django.utils.translation import ugettext as _

from modoboa.lib import parameters, u2u_decode
from modoboa.lib.emailutils import Email, EmailAddress
from .imaputils import (
    get_imapconnector, BodyStructure
)
from .utils import decode_payload


class ImapEmail(Email):
    """
    A class to represent an email fetched from an IMAP server.
    """
    headernames = [
        ('From', True),
        ('To', True),
        ('Cc', True),
        ('Date', True),
        ('Subject', True),
    ]

    def __init__(self, request, addrfull, *args, **kwargs):
        super(ImapEmail, self).__init__(*args, **kwargs)
        self.request = request
        self.addrfull = addrfull
        self.imapc = get_imapconnector(request)
        self.mbox, self.mailid = self.mailid.split(":")

        headers = self.msg['BODY[HEADER.FIELDS (%s)]' % self.headers_as_text]
        msg = email.message_from_string(headers)
        for hdr in self.headernames:
            label = hdr[0]
            hdrvalue = self.get_header(msg, label)
            if not hdrvalue:
                continue
            if hdr[1]:
                self.headers += [{"name": label, "value": hdrvalue}]
            label = re.sub("-", "_", label)
            setattr(self, label, hdrvalue)

    def get_header(self, msg, hdrname):
        """Look for a particular header.

        We also try to decode the default value.
        """
        from . import imapheader

        hdrvalue = super(ImapEmail, self).get_header(msg, hdrname)
        if not hdrvalue:
            return ""
        try:
            key = re.sub("-", "_", hdrname).lower()
            hdrvalue = getattr(imapheader, "parse_%s" % key)(
                hdrvalue, full=self.addrfull
            )
        except AttributeError:
            pass
        return hdrvalue

    @property
    def msg(self):
        """
        """
        if self._msg is None:
            self._msg = self.imapc.fetchmail(
                self.mbox, self.mailid, readonly=False,
                headers=self.headers_as_list
            )
            self.bs = BodyStructure(self._msg['BODYSTRUCTURE'])
            self._find_attachments()
            if not self.dformat in ["plain", "html"]:
                self.dformat = parameters.get_user(
                    self.request.user, self.dformat
                )
            fallback_fmt = "html" if self.dformat == "plain" else "plain"
            self.mformat = self.dformat \
                if self.dformat in self.bs.contents else fallback_fmt
        return self._msg

    @property
    def headers_as_list(self):
        return [hdr[0].upper() for hdr in self.headernames]

    @property
    def headers_as_text(self):
        return " ".join(self.headers_as_list)

    @property
    def body(self):
        """Load email's body.

        This operation has to be made "on demand" because it requires
        a communication with the IMAP server.

        """
        if self._body is None and self.bs.contents:
            bodyc = u''
            for part in self.bs.contents[self.mformat]:
                pnum = part['pnum']
                data = self.imapc._cmd(
                    "FETCH", self.mailid, "(BODY.PEEK[%s])" % pnum
                )
                content = decode_payload(
                    part['encoding'], data[int(self.mailid)]['BODY[%s]' % pnum]
                )
                charset = self._find_content_charset(part)
                if charset is not None:
                    try:
                        content = content.decode(charset)
                    except (UnicodeDecodeError, LookupError):
                        result = chardet.detect(content)
                        content = content.decode(result['encoding'])
                bodyc += content
            self._fetch_inlines()
            self._body = getattr(self, "viewmail_%s" % self.mformat)(
                bodyc, links=self.links
            )
        return self._body

    @body.setter
    def body(self, value):
        self._body = value

    def _find_content_charset(self, part):
        for pos, elem in enumerate(part["params"]):
            if elem == "charset":
                return part["params"][pos + 1]
        return None

    def _find_attachments(self):
        """Retrieve attachments from the parsed body structure.

        We try to find and decode a file name for each attachment. If
        we failed, a generic name will be used (ie. part_1, part_2, ...).
        """
        for att in self.bs.attachments:
            attname = "part_%s" % att["pnum"]
            if "params" in att and att["params"] != "NIL":
                attname = u2u_decode.u2u_decode(att["params"][1]) \
                    .strip("\r\t\n")
            elif "disposition" in att and len(att["disposition"]) > 1:
                for pos, value in enumerate(att["disposition"][1]):
                    if not value.startswith("filename"):
                        continue
                    header = "%s; %s=%s" \
                        % (att['disposition'][0],
                           value,
                           att["disposition"][1][pos + 1].strip("\r\t\n"))
                    attname = parse_headers(header).filename_unsafe
                    if attname is None:
                        attname = u2u_decode.u2u_decode(
                            att["disposition"][1][pos + 1]
                        ).strip("\r\t\n")
                    break
            self.attachments[att["pnum"]] = attname

    def _fetch_inlines(self):
        for cid, params in self.bs.inlines.iteritems():
            if re.search(r"\.\.", cid):
                continue
            fname = "webmail/%s_%s" % (self.mailid, cid)
            path = os.path.join(settings.MEDIA_ROOT, fname)
            params["fname"] = os.path.join(settings.MEDIA_URL, fname)
            if os.path.exists(path):
                continue

            pdef, content = self.imapc.fetchpart(
                self.mailid, self.mbox, params["pnum"]
            )
            with open(path, "wb") as fpo:
                fpo.write(decode_payload(params["encoding"], content))

    def map_cid(self, url):
        m = re.match(".*cid:(.+)", url)
        if m:
            if m.group(1) in self.bs.inlines:
                return self.bs.inlines[m.group(1)]["fname"]
        return url

    def render_headers(self, **kwargs):
        from django.template.loader import render_to_string

        res = render_to_string("webmail/headers.html", {
            "headers": self.headers,
            "folder": kwargs["folder"], "mail_id": kwargs["mail_id"],
            "attachments": self.attachments != {} and self.attachments or None
        })
        return res

    def fetch_attachment(self, pnum):
        """Fetch an attachment from the IMAP server.
        """
        return self.imapc.fetchpart(self.mailid, self.mbox, pnum)


class Modifier(ImapEmail):
    def __init__(self, form, *args, **kwargs):
        kwargs["dformat"] = "EDITOR"
        super(Modifier, self).__init__(*args, **kwargs)
        self.form = form
        getattr(self, "_modify_%s" % self.dformat)()

    def _modify_plain(self):
        self.body = re.sub("</?pre>", "", self.body)

    def _modify_html(self):
        pass


class ReplyModifier(Modifier):
    headernames = ImapEmail.headernames + \
        [("Reply-To", True),
         ("Message-ID", False)]

    def __init__(self, *args, **kwargs):
        super(ReplyModifier, self).__init__(*args, **kwargs)

        self.textheader = "%s %s" % (self.From, _("wrote:"))
        if hasattr(self, "Message_ID"):
            self.form.fields["origmsgid"].initial = self.Message_ID
        if not hasattr(self, "Reply_To"):
            self.form.fields["to"].initial = self.From
        else:
            self.form.fields["to"].initial = self.Reply_To
        if self.request.GET.get("all", "0") == "1":  # reply-all
            self.form.fields["cc"].initial = ""
            toparse = self.To.split(",")
            if hasattr(self, 'Cc'):
                toparse += self.Cc.split(",")
            for addr in toparse:
                tmp = EmailAddress(addr)
                if tmp.address and tmp.address == self.request.user.username:
                    continue
                if self.form.fields["cc"].initial != "":
                    self.form.fields["cc"].initial += ", "
                self.form.fields["cc"].initial += tmp.fulladdress
        m = re.match(r"re\s*:\s*.+", self.Subject.lower())
        if m:
            self.form.fields["subject"].initial = self.Subject
        else:
            self.form.fields["subject"].initial = "Re: %s" % self.Subject

    def _modify_plain(self):
        super(ReplyModifier, self)._modify_plain()
        lines = self.body.split('\n')
        body = ""
        for l in lines:
            if body != "":
                body += "\n"
            body += ">%s" % l
        self.body = body


class ForwardModifier(Modifier):
    def __init__(self, *args, **kwargs):
        super(ForwardModifier, self).__init__(*args, **kwargs)
        self._header()
        self.form.fields["subject"].initial = "Fwd: %s" % self.Subject

    def __getfunc(self, name):
        return getattr(self, "%s_%s" % (name, self.dformat))

    def _header(self):
        self.textheader = self.__getfunc("_header_begin")() + "\n"
        self.textheader += \
            self.__getfunc("_header_line")(_("Subject"), self.Subject)
        self.textheader += \
            self.__getfunc("_header_line")(_("Date"), self.Date)
        for hdr in ["From", "To", "Reply-To"]:
            try:
                key = re.sub("-", "_", hdr)
                value = getattr(self, key)
                self.textheader += \
                    self.__getfunc("_header_line")(_(hdr), value)
            except AttributeError:
                pass
        self.textheader += self.__getfunc("_header_end")()

    def _header_begin_plain(self):
        return "----- %s -----" % _("Original message")

    def _header_begin_html(self):
        return  "----- %s -----" % _("Original message")

    def _header_line_plain(self, key, value):
        return "%s: %s\n" % (key, value)

    def _header_line_html(self, key, value):
        return "<p>%s: %s</p>" % (key, value)

    def _header_end_plain(self):
        return "\n"

    def _header_end_html(self):
        return ""

########NEW FILE########
__FILENAME__ = imapheader
"""
Set of functions used to parse and transform email headers.
"""
import chardet
from modoboa.lib.emailutils import EmailAddress

__all__ = [
    'parse_from', 'parse_to', 'parse_message_id', 'parse_date',
    'parse_reply_to', 'parse_cc', 'parse_subject'
]


def to_unicode(value):
    """Try to convert a string to unicode.
    """
    if value is None or type(value) is unicode:
        return value
    try:
        value = value.decode('utf-8')
    except UnicodeDecodeError:
        pass
    else:
        return value
    try:
        res = chardet.detect(value)
    except UnicodeDecodeError:
        return value
    if res["encoding"] == "ascii":
        return value
    return value.decode(res["encoding"])


def parse_address(value, **kwargs):
    """Parse an email address.
    """
    addr = EmailAddress(value)
    if "full" in kwargs.keys() and kwargs["full"]:
        return to_unicode(addr.fulladdress)
    result = addr.name and addr.name or addr.fulladdress
    return to_unicode(result)


def parse_address_list(values, **kwargs):
    """Parse a list of email addresses.
    """
    lst = values.split(",")
    result = ""
    for addr in lst:
        if result != "":
            result += ", "
        result += parse_address(addr, **kwargs)
    return result


def parse_from(value, **kwargs):
    """Parse a From: header.
    """
    return parse_address(value, **kwargs)


def parse_to(value, **kwargs):
    """Parse a To: header.
    """
    return parse_address_list(value, **kwargs)


def parse_cc(value, **kwargs):
    """Parse a Cc: header.
    """
    return parse_address_list(value, **kwargs)


def parse_reply_to(value, **kwargs):
    """Parse a Reply-To: header.
    """
    return parse_address_list(value, **kwargs)


def parse_date(value, **kwargs):
    """Parse a Date: header.
    """
    import datetime
    import email

    tmp = email.utils.parsedate_tz(value)
    if not tmp:
        return value
    ndate = datetime.datetime(*(tmp)[:7])
    now = datetime.datetime.now()
    try:
        if now - ndate > datetime.timedelta(7):
            return ndate.strftime("%d.%m.%Y %H:%M")
        return ndate.strftime("%a %H:%M")
    except ValueError:
        return value


def parse_message_id(value, **kwargs):
    """Parse a Message-ID: header.
    """
    return value.strip('\n')


def parse_subject(value, **kwargs):
    """Parse a Subject: header.
    """
    from modoboa.lib import u2u_decode

    try:
        subject = u2u_decode.u2u_decode(value)
    except UnicodeDecodeError:
        subject = value
    return to_unicode(subject)


########NEW FILE########
__FILENAME__ = imaputils
# coding: utf-8
"""
:mod:`imaputils` --- Extra IMAPv4 utilities
-------------------------------------------
"""
import imaplib
import ssl
import email
import re
import time
from functools import wraps
from django.utils.translation import ugettext as _
from modoboa.lib import parameters, imap_utf7
from modoboa.lib.exceptions import InternalError
from modoboa.lib.connections import ConnectionsManager
from modoboa.lib.webutils import static_url
from ..exceptions import ImapError, WebmailInternalError
from .fetch_parser import parse_fetch_response

#imaplib.Debug = 4


class capability(object):
    """
    Simple decorator to check if the server presents the required
    capability. If not, a fallback method is called instead.

    :param name: the capability name (upper case)
    :param fallback_method: a method's name
    """
    def __init__(self, name, fallback_method):
        self.name = name
        self.fallback_method = fallback_method

    def __call__(self, method):
        @wraps(method)
        def wrapped_func(cls, *args, **kwargs):
            if self.name in cls.capabilities:
                return method(cls, *args, **kwargs)
            return getattr(cls, self.fallback_method)(cls, **kwargs)

        return wrapped_func


class BodyStructure(object):
    """
    BODYSTRUCTURE response parser.

    Just a simple class that tries to distinguish content parts from
    attachments.
    """
    def __init__(self, definition=None):
        self.is_multipart = False
        self.contents = {}
        self.attachments = []
        self.inlines = {}

        if definition is not None:
            self.load_from_definition(definition)

    def __store_part(self, definition, pnum, multisubtype):
        """Store the given message part in the appropriate category.

        This method sort parts in two categories:

        * contents (what is going to be displayed)
        * attachments

        As there is no official definition about what is a content and
        what is an attachment, the following rules are applied:

        * If the MIME type is text/plain or text/html:

         * If no previous part of this type has already been seen, it's a content
         * Otherwise it's an attachment

        * Else, if the multipart subtype is related, we consider this
          part as content because it is certainly an embedded image

        * Any other MIME type is considered as an attachment (for now)

        :param definition: a part definition (list)
        :param pnum: the part's number
        :param multisubtype: the multipart subtype
        """
        pnum = "1" if pnum is None else pnum
        params = dict(pnum=pnum, params=definition[2], cid=definition[3],
                      description=definition[4], encoding=definition[5],
                      size=definition[6])
        mtype = definition[0].lower()
        subtype = definition[1].lower()
        ftype = "%s/%s" % (definition[0].lower(), subtype)
        if ftype in ("text/plain", "text/html"):
            if not subtype in self.contents:
                self.contents[subtype] = [params]
            else:
                self.contents[subtype].append(params)
            return
        elif multisubtype in ["related"]:
            self.inlines[params["cid"].strip("<>")] = params
            return

        params["Content-Type"] = ftype
        if len(definition) > 7:
            extensions = ["md5", "disposition", "language", "location"]
            if mtype == "text":
                extensions = ["textlines"] + extensions
            elif ftype == "message/rfc822":
                extensions = ["envelopestruct", "bodystruct", "textlines"] + extensions
            for idx, value in enumerate(definition[7:]):
                params[extensions[idx]] = value

        self.attachments += [params]

    def load_from_definition(self, definition, multisubtype=None):
        if type(definition) == dict:
            struct = definition["struct"]
            pnum = definition["partnum"]
        elif type(definition[0]) == dict:
            struct = definition[0]["struct"]
            pnum = definition[0]["partnum"]
        else:
            struct = definition
            pnum = None

        if type(struct[0]) == list:
            for part in struct[0]:
                self.load_from_definition(part, struct[1])
            return

        self.__store_part(struct, pnum, multisubtype)

    def has_attachments(self):
        return len(self.attachments)

    def find_attachment(self, pnum):
        for att in self.attachments:
            if pnum == att["pnum"]:
                return att
        return None


class IMAPconnector(object):
    __metaclass__ = ConnectionsManager

    list_base_pattern = r'\((?P<flags>.*?)\) "(?P<delimiter>.*)" "?(?P<name>[^"]*)"?'
    list_response_pattern_literal = re.compile(r'\((?P<flags>.*?)\) "(?P<delimiter>.*)" \{(?P<namelen>\d+)\}')
    list_response_pattern = re.compile(list_base_pattern)
    listextended_response_pattern = \
        re.compile(list_base_pattern + r'\s*(?P<childinfo>.*)')
    unseen_pattern = re.compile(r'[^\(]+\(UNSEEN (\d+)\)')

    def __init__(self, user=None, password=None):
        self.__hdelimiter = None
        self.criterions = []
        self.address = parameters.get_admin("IMAP_SERVER")
        self.port = int(parameters.get_admin("IMAP_PORT"))
        self.login(user, password)

    def _cmd(self, name, *args, **kwargs):
        """IMAP command wrapper

        To simplify errors handling, this wrapper calls the
        appropriate method (``uid`` or FIXME) and then check the
        return code. If an error has occured, an ``ImapError``
        exception is raised.

        For specific commands commands (FETCH, ...), the result is
        parsed using the IMAPclient module before being returned.

        :param name: the command's name
        :return: the command's result
        """
        if name in ['FETCH', 'SORT', 'STORE', 'COPY', 'SEARCH']:
            try:
                typ, data = self.m.uid(name, *args)
            except imaplib.IMAP4.error, e:
                raise ImapError(e)
            if typ == "NO":
                raise ImapError(data)
            if name == 'FETCH':
                return parse_fetch_response(data)
            return data

        try:
            typ, data = self.m._simple_command(name, *args)
        except imaplib.IMAP4.error, e:
            raise ImapError(e)
        if typ == "NO":
            raise ImapError(data)
        if not 'responses' in kwargs:
            if not name in self.m.untagged_responses:
                return None
            return self.m.untagged_responses.pop(name)
        res = []
        for r in kwargs['responses']:
            if not r in self.m.untagged_responses:
                return None
            res.append(self.m.untagged_responses.pop(r))
        return res

    def __find_content_in_bodystruct(self, bodystruct, mtype, stype, prefix=""):
        """Retrieve the number (index) of a specific part

        This part number will generally be used inside a FETCH request
        to specify a ``BODY.PEEK`` section.

        :param bodystruct: a BODYSTRUCTURE list
        :param mtype: the MIME main type (like text)
        :param stype: the MIME sub type (like plain)
        :param prefix: the prefix that will be added to the current part number
        :return: a tuple (index (None on error), encoding (string), size (int))
        """
        if type(bodystruct[0]) in [list, tuple]:
            cpt = 1
            for part in bodystruct[0]:
                nprefix = "%s" % cpt if prefix == "" else "%s.%d" % (prefix, cpt)
                index, encoding, size = \
                    self.__find_content_in_bodystruct(part, mtype, stype, nprefix)
                if index is not None:
                    return (index, encoding, size)
                cpt += 1
        else:
            if bodystruct[0].lower() == mtype and bodystruct[1].lower() == stype:
                return ("1" if not len(prefix) else prefix,
                        bodystruct[5], int(bodystruct[6]))
        return (None, None, 0)

    @property
    def hdelimiter(self):
        """Return the default hierachy delimiter.

        This is a simple way to retrieve the default delimiter (see
        http://www.imapwiki.org/ClientImplementation/MailboxList).

        :return: a string
        """
        if self.__hdelimiter is None:
            data = self._cmd("LIST", "", "")
            m = self.list_response_pattern.match(data[0])
            if m is None:
                raise InternalError(_("Failed to retrieve hierarchy delimiter"))
            self.__hdelimiter = m.group('delimiter')
        return self.__hdelimiter

    def refresh(self, user, password):
        """Check if current connection needs a refresh

        Is it really secure?
        """
        if self.m is not None:
            try:
                self._cmd("CHECK")
            except ImapError:
                if hasattr(self, "current_mailbox"):
                    del self.current_mailbox
            else:
                return
        self.login(user, password)

    def login(self, user, passwd):
        """Custom login method

        We connect to the server, issue a LOGIN command. If
        successfull, we try to record a eventuel CAPABILITY untagged
        response. Otherwise, we issue the command.

        :param user: username
        :param passwd: password
        """
        import socket
        if type(user) is unicode:
            user = user.encode("utf-8")
        if type(passwd) is unicode:
            passwd = passwd.encode("utf-8")
        try:
            secured = parameters.get_admin("IMAP_SECURED")
            if secured == "yes":
                self.m = imaplib.IMAP4_SSL(self.address, self.port)
            else:
                self.m = imaplib.IMAP4(self.address, self.port)
        except (socket.error, imaplib.IMAP4.error, ssl.SSLError), error:
            raise ImapError(_("Connection to IMAP server failed: %s" % error))

        data = self._cmd("LOGIN", user, passwd)
        self.m.state = "AUTH"
        if "CAPABILITY" in self.m.untagged_responses:
            self.capabilities = \
                self.m.untagged_responses.pop('CAPABILITY')[0].split()
        else:
            data = self._cmd("CAPABILITY")
            self.capabilities = data[0].split()

    def logout(self):
        try:
            self._cmd("CHECK")
        except ImapError:
            pass
        self._cmd("LOGOUT")
        del self.m
        self.m = None

    def messages_count(self, **kwargs):
        """An enhanced version of messages_count

        With IMAP, to know how many messages a mailbox contains, we
        have to make a request to the server. To avoid requests
        multiplications, we sort messages in the same time. This will
        be usefull for other methods.

        :param order: sorting order
        :param folder: mailbox to scan
        """
        if "order" in kwargs and kwargs["order"]:
            sign = kwargs["order"][:1]
            criterion = kwargs["order"][1:].upper()
            if sign == '-':
                criterion = "REVERSE %s" % criterion
        else:
            criterion = "REVERSE DATE"
        folder = kwargs["folder"] if "folder" in kwargs else None

        # FIXME: pourquoi suis je obligé de faire un SELECT ici?  un
        # EXAMINE plante mais je pense que c'est du à une mauvaise
        # lecture des réponses de ma part...
        self.select_mailbox(folder, readonly=False)
        data = self._cmd("SORT", "(%s)" % criterion, "UTF-8", "(NOT DELETED)",
                         *self.criterions)
        self.messages = data[0].split()
        self.getquota(folder)
        return len(self.messages)

    def select_mailbox(self, name, readonly=True, force=False):
        """Issue a SELECT/EXAMINE command to the server

        The given name is first 'imap-utf7' encoded.

        :param name: mailbox's name
        :param readonly:
        """
        if hasattr(self, "current_mailbox"):
            if self.current_mailbox == name and not force:
                return
        self.current_mailbox = name
        name = name.encode("imap4-utf-7")
        if readonly:
            self._cmd("EXAMINE", name)
        else:
            self._cmd("SELECT", name)
        self.m.state = "SELECTED"

    def unseen_messages(self, mailbox):
        """Return the number of unseen messages

        :param mailbox: the mailbox's name
        :return: an integer
        """
        data = self._cmd("STATUS", mailbox.encode("imap4-utf-7"), "(UNSEEN)")
        m = self.unseen_pattern.match(data[-1])
        if m is None:
            return 0
        return int(m.group(1))

    def _encode_mbox_name(self, folder):
        if not folder:
            return "INBOX"
        return folder.encode("imap4-utf-7")

    def _parse_mailbox_name(self, descr, prefix, delimiter, parts):
        if not len(parts):
            return False
        path = "%s%s%s" % (prefix, delimiter, parts[0])
        sdescr = None
        for d in descr:
            if d["path"] == path:
                sdescr = d
                break
        if sdescr is None:
            sdescr = {"name": parts[0], "path": path, "sub": []}
            descr += [sdescr]
        if self._parse_mailbox_name(sdescr["sub"], path, delimiter, parts[1:]):
            sdescr["class"] = "subfolders"
        return True

    def _listmboxes_simple(self, topmailbox='INBOX', mailboxes=None, **kwargs):
        #data = self._cmd("LIST", "", "*")
        if not mailboxes: mailboxes = []
        (status, data) = self.m.list()
        newmboxes = []
        for mb in data:
            flags, delimiter, name = self.list_response_pattern.match(mb).groups()
            name = name.strip('"').decode("imap4-utf-7")
            mdm_found = False
            for idx, mdm in enumerate(mailboxes):
                if mdm["name"] == name:
                    mdm_found = True
                    descr = mailboxes[idx]
                    break
            if not mdm_found:
                descr = dict(name=name)
                newmboxes += [descr]

            if re.search("\%s" % delimiter, name):
                parts = name.split(delimiter)
                if not "path" in descr:
                    descr["path"] = parts[0]
                    descr["sub"] = []
                if self._parse_mailbox_name(descr["sub"], parts[0], delimiter,
                                            parts[1:]):
                    descr["class"] = "subfolders"
                continue

        from operator import itemgetter
        mailboxes += sorted(newmboxes, key=itemgetter("name"))

    @capability('LIST-EXTENDED', '_listmboxes_simple')
    def _listmboxes(self, topmailbox, mailboxes, until_mailbox=None):
        """Retrieve mailboxes list.
        
        """
        pattern = "%s%s%%" % (topmailbox.encode("imap4-utf-7"), self.hdelimiter) \
            if len(topmailbox) else "%"
        resp = self._cmd("LIST", "", pattern, "RETURN", "(CHILDREN)")
        newmboxes = []
        for mb in resp:
            if not mb:
                continue
            if type(mb) in [str, unicode]:
                flags, delimiter, name, childinfo = \
                    self.listextended_response_pattern.match(mb).groups()
            else:
                flags, delimiter, namelen = self.list_response_pattern_literal.match(mb[0]).groups()
                name = mb[1][0:int(namelen)]
            flags = flags.split(' ')
            name = name.decode("imap4-utf-7")
            mdm_found = False
            for idx, mdm in enumerate(mailboxes):
                if mdm["name"] == name:
                    mdm_found = True
                    descr = mailboxes[idx]
                    break
            if not mdm_found:
                descr = dict(name=name)
                newmboxes += [descr]

            if r'\Marked' in flags or not r'\UnMarked' in flags:
                descr["send_status"] = True
            if r'\HasChildren' in flags:
                if r'\NonExistent' in flags:
                    descr["removed"] = True
                descr["path"] = name
                descr["sub"] = []
                if until_mailbox and until_mailbox.startswith(name):
                    self._listmboxes(name, descr["sub"], until_mailbox)

        from operator import itemgetter
        mailboxes += sorted(newmboxes, key=itemgetter("name"))

    def getmboxes(self, user, topmailbox='', until_mailbox=None, unseen_messages=True):
        """Returns a list of mailboxes for a particular user

        By default, only the first level of mailboxes under
        ``topmailbox`` is returned. If ``until_mailbox`` is specified,
        all levels needed to access this mailbox will be returned.

        :param user: a ``User`` instance
        :param topmailbox: the mailbox where to start in the tree
        :param until_mailbox: the deepest needed mailbox
        :param unseen_messages: include unseen messages counters or not
        :return: a list
        """
        if topmailbox:
            md_mailboxes = []
        else:
            md_mailboxes = [
                {"name": "INBOX", "class": "icon-inbox"},
                {"name": parameters.get_user(user, "DRAFTS_FOLDER"),
                 "class": "icon-file"},
                {"name": 'Junk', "class": "icon-fire"},
                {"name": parameters.get_user(user, "SENT_FOLDER"),
                 "class": "icon-envelope"},
                {"name": parameters.get_user(user, "TRASH_FOLDER"),
                 "class": "icon-trash"}
            ]
        if until_mailbox:
            name, parent = separate_mailbox(until_mailbox, self.hdelimiter)
            if parent:
                until_mailbox = parent
        self._listmboxes(topmailbox, md_mailboxes, until_mailbox)

        if unseen_messages:
            for mb in md_mailboxes:
                if not "send_status" in mb:
                    continue
                del mb["send_status"]
                key = "path" if "path" in mb else "name"
                if not mb.get("removed", False):
                    count = self.unseen_messages(mb[key])
                if count == 0:
                    continue
                mb["unseen"] = count
        return md_mailboxes

    def _add_flag(self, mbox, msgset, flag):
        """Add flag(s) to a messages set

        :param mbox: the mailbox containing the messages
        :param msgset: messages set (uid)
        :param flag: the flag to add
        """
        self.select_mailbox(mbox, False)
        self._cmd("STORE", msgset, "+FLAGS", flag)

    def mark_messages_unread(self, mbox, msgset):
        """Mark a set of messages as unread

        :param mbox: the mailbox containing the messages
        :param msgset: messages set (uid)
        """
        self.select_mailbox(mbox, False)
        self._cmd("STORE", msgset, "-FLAGS", r'(\Seen)')

    def mark_messages_read(self, mbox, msgset):
        """Mark a set of messages as unread

        :param mbox: the mailbox containing the messages
        :param msgset: messages set (uid)
        """
        self._add_flag(mbox, msgset, r'(\Seen)')

    def msg_forwarded(self, mailbox, mailid):
        self._add_flag(mailbox, mailid, '($Forwarded)')

    def msg_answered(self, mailbox, mailid):
        """Add the \Answered flag to this email"""
        self._add_flag(mailbox, mailid, r'(\Answered)')

    def move(self, msgset, oldmailbox, newmailbox):
        """Move messages between mailboxes

        """
        self.select_mailbox(oldmailbox, False)
        self._cmd("COPY", msgset, newmailbox.encode("imap4-utf-7"))
        self._cmd("STORE", msgset, "+FLAGS", r'(\Deleted \Seen)')

    def push_mail(self, folder, msg):
        now = imaplib.Time2Internaldate(time.time())
        self.m.append(self._encode_mbox_name(folder), r'(\Seen)', now, str(msg))

    def empty(self, mbox):
        self.select_mailbox(mbox, False)
        resp = self._cmd("SEARCH", "ALL")
        seq = ",".join(resp[0].split())
        if seq == "":
            return
        self._cmd("STORE", seq, "+FLAGS", r'(\Deleted)')
        self._cmd("EXPUNGE")

    def compact(self, mbox):
        """Compact a specific mailbox

        Issue an EXPUNGE command for the specified mailbox.

        :param mbox: the mailbox's name
        """
        self.select_mailbox(mbox, False)
        self._cmd("EXPUNGE")

    def create_folder(self, name, parent=None):
        if parent is not None:
            name = "%s%s%s" % (parent, self.hdelimiter, name)
        typ, data = self.m.create(self._encode_mbox_name(name))
        if typ == "NO":
            raise WebmailInternalError(data[0])
        return True

    def rename_folder(self, oldname, newname):
        typ, data = self.m.rename(self._encode_mbox_name(oldname),
                                  self._encode_mbox_name(newname))
        if typ == "NO":
            raise WebmailInternalError(data[0], ajax=True)
        return True

    def delete_folder(self, name):
        typ, data = self.m.delete(self._encode_mbox_name(name))
        if typ == "NO":
            raise WebmailInternalError(data[0])
        return True

    def getquota(self, mailbox):
        if not "QUOTA" in self.capabilities:
            self.quota_limit = self.quota_actual = None
            return

        data = self._cmd("GETQUOTAROOT", self._encode_mbox_name(mailbox),
                         responses=["QUOTAROOT", "QUOTA"])
        if data is None:
            self.quota_limit = self.quota_actual = None
            return

        quotadef = data[1][0]
        m = re.search("\(STORAGE (\d+) (\d+)\)", quotadef)
        if not m:
            print "Problem while parsing quota def"
            return
        self.quota_limit = int(m.group(2))
        self.quota_actual = int(m.group(1))

    def fetchpart(self, uid, mbox, partnum):
        """Retrieve a specific message part

        Useful to fetch attachments from the server. Part headers and
        the payload are returned separatly.

        :param uid: a message UID
        :param mbox: the mailbox containing the message
        :param partnum: the part number
        :return: a 2uple (dict, string)
        """
        self.select_mailbox(mbox, False)
        data = self._cmd("FETCH", uid, "(BODYSTRUCTURE BODY[%s])" % partnum)
        bs = BodyStructure(data[int(uid)]["BODYSTRUCTURE"])
        attdef = bs.find_attachment(partnum)
        return attdef, data[int(uid)]["BODY[%s]" % partnum]

    def fetch(self, start, stop=None, mbox=None, **kwargs):
        """Retrieve information about messages from the server

        Issue a FETCH command to retrieve information about one or
        more messages (such as headers) from the server.

        :param start: index of the first message
        :param stop: index of the last message (optionnal)
        :param mbox: the mailbox that contains the messages
        """
        self.select_mailbox(mbox, False)
        if start and stop:
            submessages = self.messages[start - 1:stop]
            range = ",".join(submessages)
        else:
            submessages = [start]
            range = start
        query = '(FLAGS BODYSTRUCTURE BODY.PEEK[HEADER.FIELDS (DATE FROM TO CC SUBJECT)])'
        data = self._cmd("FETCH", range, query)
        result = []
        for uid in submessages:
            msg = email.message_from_string(data[int(uid)]['BODY[HEADER.FIELDS (DATE FROM TO CC SUBJECT)]'])
            msg['imapid'] = uid
            if not r'\Seen' in data[int(uid)]['FLAGS']:
                msg['style'] = 'unseen'
            if r'\Answered' in data[int(uid)]['FLAGS']:
                msg['img_flags'] = [static_url('pics/answered.png')]
            if r'$Forwarded' in data[int(uid)]['FLAGS']:
                if 'img_flags' in msg:
                    msg['img_flags'] += [static_url('pics/forwarded.png')]
                else:
                    msg['img_flags'] = [static_url('pics/forwarded.png')]
            bs = BodyStructure(data[int(uid)]['BODYSTRUCTURE'])
            if bs.has_attachments():
                msg['img_withatts'] = static_url('pics/attachment.png')
            result += [msg]
        return result

    def fetchmail(self, mbox, mailid, readonly=True, headers=None):
        """Retrieve information about a specific message

        Issue a FETCH command to retrieve a message's content from the
        server. In order to not overload the server, we first retrieve
        the BODYSTRUCTURE of the message. Then, according to the
        result and to the user's preferences, we retrieve the
        appropriate content (plain, html, etc.).

        :param mbox: the mailbox containing the message
        :param mailid: the message's unique id
        :param readonly:
        :param headers:
        """
        self.select_mailbox(mbox, readonly)
        if headers is None:
            headers = ['DATE', 'FROM', 'TO', 'CC', 'SUBJECT']
        bcmd = "BODY.PEEK" if readonly else "BODY"
        data = self._cmd(
            "FETCH", mailid,
            "(BODYSTRUCTURE %s[HEADER.FIELDS (%s)])" % (bcmd, " ".join(headers))
        )
        return data[int(mailid)]


def separate_mailbox(fullname, sep="."):
    """Split a mailbox name

    If a separator is found in ``fullname``, this function returns the
    corresponding name and parent mailbox name.
    """
    if sep in fullname:
        parts = fullname.split(sep)
        name = parts[-1]
        parent = sep.join(parts[0:len(parts) - 1])
        return name, parent
    return fullname, None


def get_imapconnector(request):
    """Simple shortcut to create a connector

    :param request: a ``Request`` object
    """
    imapc = IMAPconnector(user=request.user.username,
                          password=request.session["password"])
    return imapc


if __name__ == "__main__":
    import doctest
    doctest.testmod()

########NEW FILE########
__FILENAME__ = listing
from django.conf import settings
from django.utils.translation import ugettext_lazy

from modoboa.lib import parameters, tables
from modoboa.lib.email_listing import EmailListing
from . import IMAPconnector, imapheader


class WMtable(tables.Table):
    """
    Webmail listing table.
    """
    tableid = "emails"
    styles = "table-condensed"
    idkey = "imapid"
    drag = tables.ImgColumn(
        "drag", cssclass="draggable left", width="1%",
        defvalue="%spics/grippy.png" % settings.STATIC_URL,
        header="<input type='checkbox' name='toggleselect' id='toggleselect' />"
    )
    selection = tables.SelectionColumn(
        "selection", safe=True, width='1%', header=None, sortable=False
    )
    flags = tables.ImgColumn("flags", width="3%")
    withatts = tables.ImgColumn("withatts", width="2%")
    subject = tables.Column(
        "subject", label=ugettext_lazy("Subject"), width="50%", limit=60,
        cssclass="openable"
    )
    from_ = tables.Column(
        "from", width="20%", label=ugettext_lazy("From"), limit=30,
        cssclass="openable"
    )
    date = tables.Column(
        "date", width="15%", label=ugettext_lazy("Date"), cssclass="openable"
    )

    cols_order = [
        "drag", "selection", "withatts", "flags", "subject", "from_", "date"
    ]

    def parse(self, header, value):
        if value is None:
            return ""
        try:
            value = getattr(imapheader, "parse_%s" % header)(value)
        except AttributeError:
            pass
        return value


class ImapListing(EmailListing):
    tpl = "webmail/index.html"
    tbltype = WMtable
    deflocation = "INBOX/"
    defcallback = "wm_updatelisting"
    reset_wm_url = False

    def __init__(self, user, password, **kwargs):
        self.user = user
        self.mbc = IMAPconnector(user=user.username, password=password)
        if "pattern" in kwargs and kwargs["pattern"]:
            self.parse_search_parameters(
                kwargs["criteria"], kwargs["pattern"]
            )
        else:
            self.mbc.criterions = []

        super(ImapListing, self).__init__(**kwargs)
        self.extravars["refreshrate"] = \
            int(parameters.get_user(user, "REFRESH_INTERVAL")) * 1000

    def parse_search_parameters(self, criterion, pattern):

        def or_criterion(old, c):
            if old == "":
                return c
            return "OR (%s) (%s)" % (old, c)

        if criterion == u"both":
            criterion = u"from_addr, subject"
        criterions = ""
        if type(pattern) is unicode:
            pattern = pattern.encode("utf-8")
        if type(criterion) is unicode:
            criterion = criterion.encode("utf-8")
        for c in criterion.split(','):
            if c == "from_addr":
                key = "FROM"
            elif c == "subject":
                key = "SUBJECT"
            else:
                continue
            criterions = \
                or_criterion(criterions, '(%s "%s")' % (key, pattern))
        self.mbc.criterions = [criterions]

    @staticmethod
    def computequota(mbc):
        try:
            return int(float(mbc.quota_actual) \
                / float(mbc.quota_limit) * 100)
        except (AttributeError, TypeError):
            return -1

    def getquota(self):
        return ImapListing.computequota(self.mbc)

########NEW FILE########
__FILENAME__ = sendmail
import smtplib
from modoboa.lib import parameters
from modoboa.lib.emailutils import prepare_addresses
from modoboa.lib.webutils import _render_to_string
from modoboa.lib.cryptutils import get_password
from modoboa.extensions.webmail.exceptions import WebmailInternalError
from . import get_imapconnector, clean_attachments


def send_mail(request, form, posturl=None):
    """Email verification and sending.

    If the form does not present any error, a new MIME message is
    constructed. Then, a connection is established with the defined
    SMTP server and the message is finally sent.

    :param request: a Request object
    :param posturl: the url to post the message form to
    :return: a 2-uple (True|False, HttpResponse)
    """
    if not form.is_valid():
        editormode = parameters.get_user(request.user, "EDITOR")
        listing = _render_to_string(
            request, "webmail/compose.html",
            {"form": form, "noerrors": True,
             "body": form.cleaned_data.get("body", "").strip(),
             "posturl": posturl}
        )
        return False, dict(status="ko", listing=listing, editor=editormode)

    msg = form.to_msg(request)
    rcpts = prepare_addresses(form.cleaned_data["to"], "envelope")
    for hdr in ["cc", "cci"]:
        if form.cleaned_data[hdr]:
            msg[hdr.capitalize()] = prepare_addresses(form.cleaned_data[hdr])
            rcpts += prepare_addresses(form.cleaned_data[hdr], "envelope")
    try:
        secmode = parameters.get_admin("SMTP_SECURED_MODE")
        if secmode == "ssl":
            s = smtplib.SMTP_SSL(parameters.get_admin("SMTP_SERVER"),
                                 int(parameters.get_admin("SMTP_PORT")))
        else:
            s = smtplib.SMTP(parameters.get_admin("SMTP_SERVER"),
                             int(parameters.get_admin("SMTP_PORT")))
            if secmode == "starttls":
                s.starttls()
    except Exception as text:
        raise WebmailInternalError(str(text))

    if parameters.get_admin("SMTP_AUTHENTICATION") == "yes":
        try:
            s.login(request.user.username, get_password(request))
        except smtplib.SMTPException as err:
            raise WebmailInternalError(str(err))
    try:
        s.sendmail(request.user.email, rcpts, msg.as_string())
        s.quit()
    except smtplib.SMTPException as err:
        raise WebmailInternalError(str(err))

    sentfolder = parameters.get_user(request.user, "SENT_FOLDER")
    get_imapconnector(request).push_mail(sentfolder, msg)
    clean_attachments(request.session["compose_mail"]["attachments"])
    del request.session["compose_mail"]
    return True, {}

########NEW FILE########
__FILENAME__ = signature
import re
from modoboa.lib import parameters


class EmailSignature(object):
    """User signature

    :param user: User object
    """
    def __init__(self, user):
        self._sig = ""
        dformat = parameters.get_user(user, "EDITOR")
        content = parameters.get_user(user, "SIGNATURE")
        if len(content):
            getattr(self, "_format_sig_%s" % dformat)(content)

    def _format_sig_plain(self, content):
        self._sig = """
---
%s""" % content

    def _format_sig_html(self, content):
        content = re.sub("\n", "<br/>", content)
        self._sig = """<br/>
---<br/>
%s""" % content

    def __repr__(self):
        return self._sig

########NEW FILE########
__FILENAME__ = tables
from django.conf import settings
from django.utils.translation import ugettext_lazy

from modoboa.lib import tables
from . import imapheader


class WMtable(tables.Table):
    """
    The webmail listing.
    """
    tableid = "emails"
    styles = "table-condensed"
    idkey = "imapid"
    drag = tables.ImgColumn(
        "drag", cssclass="draggable left", width="1%",
        defvalue="%spics/grippy.png" % settings.STATIC_URL,
        header="<input type='checkbox' name='toggleselect' id='toggleselect' />"
    )
    selection = tables.SelectionColumn(
        "selection", safe=True, width='1%', header=None, sortable=False
    )
    flags = tables.ImgColumn("flags", width="3%")
    withatts = tables.ImgColumn("withatts", width="2%")
    subject = tables.Column(
        "subject", label=ugettext_lazy("Subject"), width="50%", limit=60,
        cssclass="openable"
    )
    from_ = tables.Column(
        "from", width="20%", label=ugettext_lazy("From"), limit=30,
        cssclass="openable"
    )
    date = tables.Column(
        "date", width="15%", label=ugettext_lazy("Date"), cssclass="openable"
    )

    cols_order = [
        "drag", "selection", "withatts", "flags", "subject", "from_", "date"
    ]

    def parse(self, header, value):
        if value is None:
            return ""
        try:
            value = getattr(imapheader, "parse_%s" % header)(value)
        except AttributeError:
            pass
        return value

########NEW FILE########
__FILENAME__ = utils
"""
Misc. utilities.
"""
from modoboa.lib.webutils import NavigationParameters


def decode_payload(encoding, payload):
    """Decode the payload according to the given encoding

    Supported encodings: base64, quoted-printable.

    :param encoding: the encoding's name
    :param payload: the value to decode
    :return: a string
    """
    encoding = encoding.lower()
    if encoding == "base64":
        import base64
        return base64.b64decode(payload)
    elif encoding == "quoted-printable":
        import quopri
        return quopri.decodestring(payload)
    return payload


class WebmailNavigationParameters(NavigationParameters):
    """
    Specific NavigationParameters subclass for the webmail.
    """
    def __init__(self, request, defmailbox=None):
        super(WebmailNavigationParameters, self).__init__(
            request, 'webmail_navparams'
        )
        if defmailbox is not None:
            self.parameters += [('mbox', defmailbox, False)]

########NEW FILE########
__FILENAME__ = webmail_tags
# coding: utf-8
from django import template
from django.template.loader import render_to_string
from django.utils.translation import ugettext as _
from django.core.urlresolvers import reverse
from django.conf import settings
from modoboa.extensions import webmail
from modoboa.extensions.webmail.lib import separate_mailbox
from modoboa.lib import parameters

register = template.Library()


@register.simple_tag
def viewmail_menu(selection, folder, user, mail_id=None):
    entries = [
        {"name": "reply",
         "url": "action=reply&mbox=%s&mailid=%s" % (folder, mail_id),
         "img": "icon-share",
         "label": _("Reply")},
        {"name": "replyall",
         "url": "action=reply&mbox=%s&mailid=%s&all=1" % (folder, mail_id),
         "img": "",
         "label": _("Reply all")},
        {"name": "forward",
         "url": "action=forward&mbox=%s&mailid=%s" % (folder, mail_id),
         "img": "icon-arrow-right",
         "label": _("Forward")},
        {"name": "delete",
         "img": "icon-trash",
         "url": reverse(webmail.views.delete) + "?mbox=%s&selection[]=%s" % (folder, mail_id),
         "label": _("Delete")},
        {"name": "display_options",
         "label": _("Display options"),
         "menu": [
             {"name": "activate_links",
              "label": _("Activate links")},
             {"name": "disable_links",
              "label": _("Disable links")}
         ]
         }
    ]
    menu = render_to_string('common/buttons_list.html',
                            {"selection": selection, "entries": entries,
                             "user": user, "extraclasses": "pull-left"})

    entries = [{"name": "close",
                "title": _("Close this message"),
                "img": "icon-remove"}]
    menu += render_to_string(
        'common/buttons_list.html',
        {"entries": entries, "extraclasses": "pull-right"}
    )
    return menu


@register.simple_tag
def compose_menu(selection, backurl, user):
    entries = [
        {"name": "back",
         "url": "javascript:history.go(-2);",
         "img": "icon-arrow-left",
         "label": _("Back")},
        {"name": "sendmail",
         "url": "",
         "img": "icon-envelope",
         "label": _("Send")},
    ]
    return render_to_string('common/buttons_list.html',
                            {"selection": selection, "entries": entries,
                             "user": user})


@register.simple_tag
def listmailbox_menu(selection, folder, user):
    entries = [
        {"name": "compose",
         "url": "compose",
         "img": "icon-edit",
         "label": _("New message"),
         "class": "btn"},
        {"name": "totrash",
         "label": "",
         "class": "",
         "img": "icon-trash",
         "url": reverse("modoboa.extensions.webmail.views.delete"),
         },
        {"name": "mark",
         "label": _("Mark messages"),
         "class": "btn",
         "menu": [
             {"name": "mark-read",
              "label": _("As read"),
              "url": reverse(webmail.views.mark, args=[folder]) + "?status=read"},
             {"name": "mark-unread",
              "label": _("As unread"),
              "url": reverse(webmail.views.mark, args=[folder]) + "?status=unread"}
         ]
         },
        {"name": "actions",
         "label": _("Actions"),
         "class": "btn",
         "menu": [
             {"name": "compress",
              "label": _("Compress folder"),
              "url": "compact/%s/" % folder}
         ]
         },
    ]
    if folder == parameters.get_user(user, "TRASH_FOLDER"):
        entries[1]["class"] += " disabled"
        entries[3]["menu"] += [
            {"name": "empty",
             "label": _("Empty folder"),
             "url": reverse(webmail.views.empty, args=[folder])}
        ]
    return render_to_string('webmail/main_action_bar.html', {
        'selection': selection, 'entries': entries, 'user': user, 'css': "nav",
        'STATIC_URL': settings.STATIC_URL
    })


@register.simple_tag
def print_mailboxes(tree, selected=None, withunseen=False, selectonly=False, hdelimiter='.'):
    """Display a tree of mailboxes and sub-mailboxes

    :param tree: the mailboxes to display
    """
    result = ""

    for mbox in tree:
        cssclass = ""
        name = mbox["path"] if "sub" in mbox else mbox["name"]
        label = separate_mailbox(mbox["name"], hdelimiter)[0]
        if mbox.get("removed", False):
            cssclass = "disabled"
        elif selected == name:
            cssclass = "active"
        result += "<li name='%s' class='droppable %s'>\n" % (name, cssclass)
        if "sub" in mbox:
            if selected is not None and selected != name and selected.count(name):
                ul_state = "visible"
                div_state = "expanded"
            else:
                ul_state = "hidden"
                div_state = "collapsed"
            result += "<div class='clickbox %s'></div>" % div_state

        cssclass = "block"
        extra_attrs = ""
        if withunseen and "unseen" in mbox:
            label += " (%d)" % mbox["unseen"]
            cssclass += " unseen"
            extra_attrs = ' data-toggle="%d"' % mbox["unseen"]
        iclass = mbox["class"] if "class" in mbox else "icon-folder-close"
        result += """<a href='%s' class='%s' name='%s'%s>
  <i class="%s"></i>
  %s
</a>
""" % ("path" in mbox and mbox["path"] or mbox["name"], cssclass,
       'selectfolder' if selectonly else 'loadfolder',
       extra_attrs, iclass, label)

        if "sub" in mbox and len(mbox["sub"]):
            result += "<ul name='%s' class='nav nav-list %s'>" % (mbox["path"], ul_state) \
                + print_mailboxes(mbox["sub"], selected, withunseen, selectonly, hdelimiter) + "</ul>\n"
        result += "</li>\n"
    return result


@register.simple_tag
def mboxes_menu():
    entries = [
        {"name": "newmbox",
         "url": reverse(webmail.views.newfolder),
         "img": "icon-plus",
         "title": _("Create a new mailbox"),
         "modal": True,
         "modalcb": "webmail.mboxform_cb",
         "closecb": "webmail.mboxform_close",
         "class": "btn btn-mini"},
        {"name": "editmbox",
         "url": reverse(webmail.views.editfolder),
         "img": "icon-edit",
         "title": _("Edit the selected mailbox"),
         "class": "btn btn-mini"},
        {"name": "removembox",
         "url": reverse(webmail.views.delfolder),
         "img": "icon-remove",
         "title": _("Remove the selected mailbox"),
         "class": "btn btn-mini"}
    ]

    return render_to_string('common/buttons_list.html', dict(
        entries=entries, css="nav"
    ))

########NEW FILE########
__FILENAME__ = urls
# coding: utf-8
from django.conf.urls import patterns

urlpatterns = patterns(
    'modoboa.extensions.webmail.views',
    (r'^$', "index"),
    (r'^submailboxes', "submailboxes"),
    (r'^getmailcontent', 'getmailcontent'),
    (r'^unseenmsgs', 'check_unseen_messages'),

    (r'^delete/$', 'delete'),
    (r'^move/$', "move"),
    (r'^mark/(?P<name>.+)/$', "mark"),
    (r'^empty/(?P<name>.+)/$', "empty"),
    (r'^compact/(?P<name>.+)/$', "compact"),
    (r'^newfolder/$', "newfolder"),
    (r'^editfolder/$', 'editfolder'),
    (r'^delfolder/$', 'delfolder'),

    (r'^attachments/$', 'attachments'),
    (r'^delattachment/$', 'delattachment'),
    (r'^getattachment/$', 'getattachment'),
)

########NEW FILE########
__FILENAME__ = views
# coding: utf-8
import os
from rfc6266 import build_header
from django.conf import settings
from django.http import HttpResponse
from django.shortcuts import render
from django.template import Template, Context
from django.utils.translation import ugettext as _, ungettext
from django.core.urlresolvers import reverse
from django.contrib.auth.decorators import login_required
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.gzip import gzip_page
from modoboa.lib import parameters
from modoboa.lib.exceptions import ModoboaException, BadRequest
from modoboa.lib.webutils import (
    _render_to_string, ajax_response, render_to_json_response
)
from modoboa.extensions.admin.lib import needs_mailbox
from .exceptions import UnknownAction
from .forms import (
    FolderForm, AttachmentForm, ComposeMailForm, ForwardMailForm
)
from .lib import (
    decode_payload, AttachmentUploadHandler,
    save_attachment, ImapListing, EmailSignature,
    clean_attachments, set_compose_session, send_mail,
    ImapEmail, WebmailNavigationParameters, ReplyModifier, ForwardModifier,
    get_imapconnector, IMAPconnector, separate_mailbox
)
from templatetags import webmail_tags


@login_required
@needs_mailbox()
@gzip_page
def getattachment(request):
    """Fetch a message attachment

    FIXME: par manque de caching, le bodystructure du message est
    redemandé pour accéder aux headers de cette pièce jointe.

    :param request: a ``Request`` object
    """
    mbox = request.GET.get("mbox", None)
    mailid = request.GET.get("mailid", None)
    pnum = request.GET.get("partnumber", None)
    fname = request.GET.get("fname", None)
    if not mbox or not mailid or not pnum or not fname:
        raise BadRequest(_("Invalid request"))

    imapc = get_imapconnector(request)
    partdef, payload = imapc.fetchpart(mailid, mbox, pnum)
    resp = HttpResponse(decode_payload(partdef["encoding"], payload))
    resp["Content-Type"] = partdef["Content-Type"]
    resp["Content-Transfer-Encoding"] = partdef["encoding"]
    resp["Content-Disposition"] = build_header(fname)
    if int(partdef["size"]) < 200:
        resp["Content-Length"] = partdef["size"]
    return resp


@login_required
@needs_mailbox()
def move(request):
    for arg in ["msgset", "to"]:
        if not arg in request.GET:
            raise BadRequest(_("Invalid request"))
    mbc = get_imapconnector(request)
    navparams = WebmailNavigationParameters(request)
    mbc.move(request.GET["msgset"], navparams.get('mbox'), request.GET["to"])
    resp = listmailbox(request, navparams.get('mbox'), update_session=False)
    return render_to_json_response(resp)


@login_required
@needs_mailbox()
def delete(request):
    mbox = request.GET.get("mbox", None)
    selection = request.GET.getlist("selection[]", None)
    if mbox is None or selection is None:
        raise BadRequest(_("Invalid request"))
    selection = [item for item in selection if item.isdigit()]
    mbc = get_imapconnector(request)
    mbc.move(",".join(selection), mbox,
             parameters.get_user(request.user, "TRASH_FOLDER"))
    count = len(selection)
    message = ungettext("%(count)d message deleted",
                        "%(count)d messages deleted",
                        count) % {"count": count}
    return render_to_json_response(message)


@login_required
@needs_mailbox()
def mark(request, name):
    status = request.GET.get("status", None)
    ids = request.GET.get("ids", None)
    if status is None or ids is None:
        raise BadRequest(_("Invalid request"))
    imapc = get_imapconnector(request)
    try:
        getattr(imapc, "mark_messages_%s" % status)(name, ids)
    except AttributeError:
        raise UnknownAction

    return render_to_json_response({
        'action': status, 'mbox': name,
        'unseen': imapc.unseen_messages(name)
    })


@login_required
@needs_mailbox()
def empty(request, name):
    if name != parameters.get_user(request.user, "TRASH_FOLDER"):
        raise BadRequest(_("Invalid request"))
    get_imapconnector(request).empty(name)
    content = "<div class='alert alert-info'>%s</div>" % _("Empty mailbox")
    return render_to_json_response({
        'listing': content, 'mailbox': name
    })


@login_required
@needs_mailbox()
def compact(request, name):
    imapc = get_imapconnector(request)
    imapc.compact(name)
    return render_to_json_response({})


@login_required
@needs_mailbox()
def newfolder(request, tplname="webmail/folder.html"):
    mbc = IMAPconnector(user=request.user.username,
                        password=request.session["password"])

    if request.method == "POST":
        form = FolderForm(request.POST)
        if form.is_valid():
            pf = request.POST.get("parent_folder", None)
            mbc.create_folder(form.cleaned_data["name"], pf)
            return render_to_json_response({
                'respmsg': _("Mailbox created"),
                'newmb': form.cleaned_data["name"], 'parent': pf
            })

        return render_to_json_response({'form_errors': form.errors}, status=400)

    ctx = {"title": _("Create a new mailbox"),
           "formid": "mboxform",
           "action": reverse(newfolder),
           "action_label": _("Create"),
           "action_classes": "submit",
           "withunseen": False,
           "selectonly": True,
           "mboxes": mbc.getmboxes(request.user),
           "hdelimiter": mbc.hdelimiter,
           "form": FolderForm(),
           "selected": None}
    return render(request, tplname, ctx)


@login_required
@needs_mailbox()
def editfolder(request, tplname="webmail/folder.html"):
    mbc = IMAPconnector(user=request.user.username,
                        password=request.session["password"])
    ctx = {"title": _("Edit mailbox"),
           "formid": "mboxform",
           "action": reverse(editfolder),
           "action_label": _("Update"),
           "action_classes": "submit",
           "withunseen": False,
           "selectonly": True,
           "hdelimiter": mbc.hdelimiter}

    if request.method == "POST":
        form = FolderForm(request.POST)
        if form.is_valid():
            pf = request.POST.get("parent_folder", None)
            oldname, oldparent = separate_mailbox(
                request.POST["oldname"], sep=mbc.hdelimiter
            )
            res = {'respmsg': _("Mailbox updated")}
            if form.cleaned_data["name"] != oldname \
                    or (pf != oldparent):
                newname = form.cleaned_data["name"] if pf is None \
                    else mbc.hdelimiter.join([pf, form.cleaned_data["name"]])
                mbc.rename_folder(request.POST["oldname"], newname)
                res["oldmb"] = oldname
                res["newmb"] = form.cleaned_data["name"]
                res["oldparent"] = oldparent
                res["newparent"] = pf
                WebmailNavigationParameters(request).remove('mbox')
            return render_to_json_response(res)

        return render_to_json_response({'form_errors': form.errors}, status=400)

    name = request.GET.get("name", None)
    if name is None:
        raise BadRequest(_("Invalid request"))
    shortname, parent = separate_mailbox(name, sep=mbc.hdelimiter)
    ctx = {"title": _("Edit mailbox"),
           "formid": "mboxform",
           "action": reverse(editfolder),
           "action_label": _("Update"),
           "action_classes": "submit",
           "withunseen": False,
           "selectonly": True,
           "hdelimiter": mbc.hdelimiter,
           "mboxes": mbc.getmboxes(request.user, until_mailbox=parent),
           "form": FolderForm(),
           "selected": parent}
    ctx["form"].fields["oldname"].initial = name
    ctx["form"].fields["name"].initial = shortname
    return render(request, tplname, ctx)


@login_required
@needs_mailbox()
def delfolder(request):
    name = request.GET.get("name", None)
    if name is None:
        raise BadRequest(_("Invalid request"))
    mbc = IMAPconnector(user=request.user.username,
                        password=request.session["password"])
    mbc.delete_folder(name)
    WebmailNavigationParameters(request).remove('mbox')
    return ajax_response(request)


@login_required
@csrf_exempt
@needs_mailbox()
def attachments(request, tplname="webmail/attachments.html"):
    if request.method == "POST":
        csuploader = AttachmentUploadHandler()
        request.upload_handlers.insert(0, csuploader)
        error = None
        form = AttachmentForm(request.POST, request.FILES)
        if form.is_valid():
            try:
                fobj = request.FILES["attachment"]
                tmpname = save_attachment(fobj)
                request.session["compose_mail"]["attachments"] \
                    += [{"fname": str(fobj),
                         "content-type": fobj.content_type,
                         "size": fobj.size,
                         "tmpname": os.path.basename(tmpname)}]
                request.session.modified = True
                return render(request, "webmail/upload_done.html", {
                    "status": "ok", "fname": request.FILES["attachment"],
                    "tmpname": os.path.basename(tmpname)
                })
            except ModoboaException as inst:
                error = _("Failed to save attachment: ") + str(inst)

        if csuploader.toobig:
            error = _("Attachment is too big (limit: %s)"
                      % parameters.get_admin("MAX_ATTACHMENT_SIZE"))
        return render(request, "webmail/upload_done.html", {
            "status": "ko", "error": error
        })
    ctx = {
        "title": _("Attachments"),
        "formid": "uploadfile",
        "target": "upload_target",
        "enctype": "multipart/form-data",
        "form": AttachmentForm(),
        "action": reverse(attachments),
        "attachments": request.session["compose_mail"]["attachments"]
    }
    return render(request, tplname, ctx)


@login_required
@needs_mailbox()
def delattachment(request):
    if not "compose_mail" in request.session \
            or not "name" in request.GET \
            or not request.GET["name"]:
        return ajax_response(request, "ko", respmsg=_("Bad query"))

    error = None
    for att in request.session["compose_mail"]["attachments"]:
        if att["tmpname"] == request.GET["name"]:
            request.session["compose_mail"]["attachments"].remove(att)
            fullpath = os.path.join(
                settings.MEDIA_ROOT, "webmail", att["tmpname"]
            )
            try:
                os.remove(fullpath)
            except OSError, e:
                error = _("Failed to remove attachment: ") + str(e)
                break
            request.session.modified = True
            return ajax_response(request)
    if error is None:
        error = _("Unknown attachment")
    return ajax_response(request, "ko", respmsg=error)


def render_mboxes_list(request, imapc):
    """Return the HTML representation of a mailboxes list

    :param request: a ``Request`` object
    :param imapc: an ``IMAPconnector` object
    :return: a string
    """
    curmbox = WebmailNavigationParameters(request).get("mbox", "INBOX")
    return _render_to_string(request, "webmail/folders.html", {
        "selected": curmbox,
        "mboxes": imapc.getmboxes(request.user),
        "withunseen": True
    })


def listmailbox(request, defmailbox="INBOX", update_session=True):
    """Mailbox content listing

    Return a list of messages contained in the specified mailbox. The
    number of elements returned depends on the ``MESSAGES_PER_PAGE``
    parameter. (user preferences)

    :param request: a ``Request`` object
    :param defmailbox: the default mailbox (when not present inside request arguments)
    :return: a dictionnary
    """
    navparams = WebmailNavigationParameters(request, defmailbox)
    if update_session:
        navparams.store()
    mbox = navparams.get('mbox')
    lst = ImapListing(
        request.user, request.session["password"],
        baseurl="?action=listmailbox&mbox=%s&" % mbox,
        folder=mbox,
        elems_per_page=int(parameters.get_user(request.user, "MESSAGES_PER_PAGE")),
        **request.session["webmail_navparams"]
    )
    return lst.render(request, navparams.get('page'))


def render_compose(request, form, posturl, email=None, insert_signature=False):
    editor = parameters.get_user(request.user, "EDITOR")
    if email is None:
        body = ""
        textheader = ""
    else:
        body = email.body
        textheader = email.textheader
    if insert_signature:
        signature = EmailSignature(request.user)
        body += str(signature)
    randid = None
    if not "id" in request.GET:
        if "compose_mail" in request.session:
            clean_attachments(request.session["compose_mail"]["attachments"])
        randid = set_compose_session(request)
    elif not "compose_mail" in request.session \
            or request.session["compose_mail"]["id"] != request.GET["id"]:
        randid = set_compose_session(request)

    attachments = request.session["compose_mail"]["attachments"]
    if attachments:
        short_att_list = "(%s)" % ", ".join(
            [att['fname'] for att in (attachments[:2] + [{"fname": "..."}]
             if len(attachments) > 2 else attachments)]
        )
    else:
        short_att_list = ""
    content = _render_to_string(request, "webmail/compose.html", {
        "form": form, "bodyheader": textheader,
        "body": body, "posturl": posturl,
        "attachments": attachments, "short_att_list": short_att_list
    })

    ctx = dict(listing=content, editor=editor)
    if randid is not None:
        ctx["id"] = randid
    return ctx


def compose(request):
    url = "?action=compose"
    if request.method == "POST":
        form = ComposeMailForm(request.POST)
        status, resp = send_mail(request, form, posturl=url)
        return resp

    form = ComposeMailForm()
    return render_compose(request, form, url, insert_signature=True)


def get_mail_info(request):
    """Retrieve a mailbox and an email ID from a request.
    """
    mbox = request.GET.get("mbox", None)
    mailid = request.GET.get("mailid", None)
    if mbox is None or mailid is None:
        raise BadRequest(_("Invalid request"))
    return mbox, mailid


def new_compose_form(request, action, mbox, mailid):
    """Return a new composition form.

    Valid for reply and forward actions only.
    """
    form = ComposeMailForm()
    modclass = globals()["%sModifier" % action.capitalize()]
    email = modclass(form, request, True, "%s:%s" % (mbox, mailid), links="1")
    url = "?action=%s&mbox=%s&mailid=%s" % (action, mbox, mailid)
    return render_compose(request, form, url, email)


def reply(request):
    """Reply to email.
    """
    mbox, mailid = get_mail_info(request)
    if request.method == "POST":
        url = "?action=reply&mbox=%s&mailid=%s" % (mbox, mailid)
        form = ComposeMailForm(request.POST)
        status, resp = send_mail(request, form, url)
        if status:
            get_imapconnector(request).msg_answered(mbox, mailid)
        return resp
    return new_compose_form(request, "reply", mbox, mailid)


def forward(request):
    """Forward email.
    """
    mbox, mailid = get_mail_info(request)
    if request.method == "POST":
        url = "?action=forward&mbox=%s&mailid=%s" % (mbox, mailid)
        form = ForwardMailForm(request.POST)
        status, resp = send_mail(request, form, url)
        if status:
            get_imapconnector(request).msg_forwarded(mbox, mailid)
        return resp
    return new_compose_form(request, "forward", mbox, mailid)


@login_required
@needs_mailbox()
def getmailcontent(request):
    mbox = request.GET.get("mbox", None)
    mailid = request.GET.get("mailid", None)
    if mbox is None or mailid is None:
        raise BadRequest(_("Invalid request"))
    email = ImapEmail(
        request, False, "%s:%s" % (mbox, mailid), dformat="DISPLAYMODE",
        links=int(request.GET["links"])
    )
    return render(request, "common/viewmail.html", {
        "headers": email.render_headers(folder=mbox, mail_id=mailid),
        "folder": mbox, "imapid": mailid,
        "mailbody": email.body if email.body else ""
    })


def viewmail(request):
    mbox = request.GET.get("mbox", None)
    mailid = request.GET.get("mailid", None)
    if mbox is None or mailid is None:
        raise BadRequest(_("Invalid request"))
    links = request.GET.get("links", None)
    if links is None:
        links = 1 if parameters.get_user(request.user, "ENABLE_LINKS") == "yes" else 0
    else:
        links = int(links)

    url = reverse(getmailcontent) + "?mbox=%s&mailid=%s&links=%d" % \
        (mbox, mailid, links)
    content = Template("""
<iframe src="{{ url }}" id="mailcontent"></iframe>
""").render(Context({"url": url}))

    return dict(listing=content, menuargs=dict(mail_id=mailid))


@login_required
@needs_mailbox()
def submailboxes(request):
    topmailbox = request.GET.get('topmailbox', '')
    mboxes = get_imapconnector(request).getmboxes(request.user, topmailbox)
    return render_to_json_response(mboxes)


@login_required
@needs_mailbox()
def check_unseen_messages(request):
    mboxes = request.GET.get("mboxes", None)
    if not mboxes:
        raise BadRequest(_("Invalid request"))
    mboxes = mboxes.split(",")
    counters = dict()
    imapc = get_imapconnector(request)
    for mb in mboxes:
        counters[mb] = imapc.unseen_messages(mb)
    return render_to_json_response(counters)


@login_required
@needs_mailbox()
def index(request):
    """Webmail actions handler

    Problèmes liés à la navigation 'anchor based'
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Lors d'un rafraichissemt complet, une première requête est envoyée
    vers /webmail/. On ne connait pas encore l'action qui va être
    demandée mais on peut déjà envoyer des informations indépendantes
    (comme les dossiers, le quota).

    Si on se contente de cela, l'affichage donnera un aspect décomposé
    qui n'est pas très séduisant (à cause de la latence notamment). Il
    faudrait pouvoir envoyer le menu par la même occasion, le souci
    étant de savoir lequel...

    Une solution possible : il suffirait de déplacer le menu vers la
    droite pour l'aligner avec le contenu, remonter la liste des
    dossiers (même hauteur que le menu) et renvoyer le menu en même
    temps que le contenu. Le rendu sera plus uniforme je pense.

    """
    action = request.GET.get("action", None)
    if action is not None:
        if not action in globals():
            raise UnknownAction
        response = globals()[action](request)
    else:
        if request.is_ajax():
            raise BadRequest(_("Invalid request"))
        response = dict(selection="webmail")

    curmbox = WebmailNavigationParameters(request).get("mbox", "INBOX")
    if not request.is_ajax():
        request.session["lastaction"] = None
        imapc = get_imapconnector(request)
        response["hdelimiter"] = imapc.hdelimiter
        response["mboxes"] = render_mboxes_list(request, imapc)
        imapc.getquota(curmbox)
        response["refreshrate"] = \
            int(parameters.get_user(request.user, "REFRESH_INTERVAL"))
        response["quota"] = ImapListing.computequota(imapc)
        trash = parameters.get_user(request.user, "TRASH_FOLDER")
        response["trash"] = trash
        response["ro_mboxes"] = [
            "INBOX", "Junk",
            parameters.get_user(request.user, "SENT_FOLDER"),
            trash,
            parameters.get_user(request.user, "DRAFTS_FOLDER")
        ]
        response['mboxes_col_width'] = \
            int(parameters.get_user(request.user, 'MBOXES_COL_WIDTH'))
        return render(request, "webmail/index.html", response)

    if action in ["reply", "forward"]:
        action = "compose"
    if request.session["lastaction"] != action:
        extra_args = {}
        if "menuargs" in response:
            extra_args = response["menuargs"]
            del response["menuargs"]
        try:
            response["menu"] = \
                getattr(webmail_tags, "%s_menu" % action)("", curmbox, request.user, **extra_args)
        except KeyError:
            pass

    response.update(callback=action)
    http_status = 200
    if "status" in response:
        del response['status']
        http_status = 400
    return render_to_json_response(response, status=http_status)

########NEW FILE########
__FILENAME__ = authbackends
from django.contrib.auth.backends import ModelBackend
from modoboa.core.models import User
from modoboa.lib import parameters
from modoboa.lib.emailutils import split_mailbox


class SimpleBackend(ModelBackend):

    def authenticate(self, username=None, password=None):
        try:
            user = User.objects.get(username=username)
        except User.DoesNotExist:
            return None
        if not user.check_password(password):
            return None
        return user

    def get_user(self, user_id):
        try:
            return User.objects.get(pk=user_id)
        except User.DoesNotExist:
            return None

try:
    from django_auth_ldap.backend import (
        LDAPBackend as orig_LDAPBackend, _LDAPUser
    )
    from modoboa.core.models import populate_callback

    class LDAPBackend(orig_LDAPBackend):

        def get_or_create_user(self, username, ldap_user):
            """
            This must return a (User, created) 2-tuple for the given
            LDAP user.  username is the Django-friendly username of
            the user. ldap_user.dn is the user's DN and
            ldap_user.attrs contains all of their LDAP attributes.
            """
            group = 'SimpleUsers'
            admin_groups = parameters \
                .get_admin('LDAP_ADMIN_GROUPS', app='core').split(';')
            for grp in admin_groups:
                if grp.strip() in ldap_user.group_names:
                    group = 'DomainAdmins'
                    break
            if group == 'SimpleUsers':
                lpart, domain = split_mailbox(username)
                if domain is None:
                    return None
            user, created = User.objects.get_or_create(
                username__iexact=username,
                defaults={'username': username.lower(), 'is_local': False}
            )
            if created:
                populate_callback(user, group)
            return user, created

        def get_user(self, user_id):
            user = None
            try:
                user = User.objects.get(pk=user_id)
                _LDAPUser(self, user=user)  # This sets user.ldap_user
            except User.DoesNotExist:
                pass
            return user

        def authenticate(self, username, password):
            auth_type = parameters.get_admin("AUTHENTICATION_TYPE", app="core")
            if auth_type == "ldap":
                return super(LDAPBackend, self).authenticate(username, password)
            return None

except ImportError:
    pass

########NEW FILE########
__FILENAME__ = compat
from django.conf import settings

user_model_name = getattr(settings, 'AUTH_USER_MODEL', 'auth.User')
user_table_name = "auth_user" if user_model_name == "auth.User" else "core_user"

########NEW FILE########
__FILENAME__ = connections
from modoboa.lib.cryptutils import decrypt


class ConnectionsManager(type):
    """Singleton pattern implementation

    This class is specialized in connection management.
    """
    def __init__(cls, name, bases, ctx):
        super(ConnectionsManager, cls).__init__(name, bases, ctx)
        cls.instances = {}

    def __call__(cls, **kwargs):
        key = None
        if "user" in kwargs:
            key = kwargs["user"]
        else:
            return None
        if not key in cls.instances:
            cls.instances[key] = None
        if "password" in kwargs:
            kwargs["password"] = decrypt(kwargs["password"])

        if cls.instances[key] is None:
            cls.instances[key] = \
                super(ConnectionsManager, cls).__call__(**kwargs)
        else:
            cls.instances[key].refresh(key, kwargs["password"])
        return cls.instances[key]


class ConnectionError(Exception):
    pass

########NEW FILE########
__FILENAME__ = cryptutils
# coding: utf-8
from Crypto.Cipher import AES
import base64
import random
import string
from modoboa.lib import parameters


def random_key(l=16):
    """Generate a random key

    :param integer l: the key's length
    :return: a string
    """
    char_set = string.digits + string.letters + string.punctuation
    return ''.join(random.sample(char_set * l, l))


def encrypt(clear):
    key = parameters.get_admin("SECRET_KEY", app="core")
    obj = AES.new(key, AES.MODE_ECB)
    if type(clear) is unicode:
        clear = clear.encode("utf-8")
    if len(clear) % AES.block_size:
        clear += " " * (AES.block_size - len(clear) % AES.block_size)
    ciph = obj.encrypt(clear)
    ciph = base64.b64encode(ciph)
    return ciph


def decrypt(ciph):
    obj = AES.new(
        parameters.get_admin("SECRET_KEY", app="core"), AES.MODE_ECB
    )
    ciph = base64.b64decode(ciph)
    clear = obj.decrypt(ciph)
    return clear.rstrip(' ')


def get_password(request):
    return decrypt(request.session["password"])

########NEW FILE########
__FILENAME__ = dbutils
# coding: utf-8
from django.db import connection
from django.conf import settings
from django.utils.translation import ugettext as _
from modoboa.lib.exceptions import InternalError


def db_table_exists(table, cursor=None):
    """Check if table exists

    Taken from here:
    https://gist.github.com/527113/307c2dec09ceeb647b8fa1d6d49591f3352cb034

    """
    try:
        if not cursor:
            cursor = connection.cursor()
        if not cursor:
            raise Exception
        table_names = connection.introspection.get_table_list(cursor)
    except:
        raise Exception("unable to determine if the table '%s' exists" % table)
    else:
        return table in table_names


def db_type(cname="default"):
    """Return the type of the *default* database

    Supported values : 'postgres', 'mysql', 'sqlite'

    :param str cname: connection name
    :return: a string or None
    """
    if not cname in settings.DATABASES:
        raise InternalError(_("Connection to database %s not configured" % cname))
    for t in ['postgres', 'mysql', 'sqlite']:
        if settings.DATABASES[cname]['ENGINE'].find(t) != -1:
            return t
    return None

########NEW FILE########
__FILENAME__ = emailutils
# coding: utf-8
import time
import re
import smtplib
from email.header import Header, decode_header
from email.mime.text import MIMEText
from email.utils import make_msgid, formatdate, parseaddr
from django.template.loader import render_to_string
from django.conf import settings
from modoboa.lib import u2u_decode


class EmailAddress(object):
    def __init__(self, address):
        self.fulladdress = u2u_decode.u2u_decode(address).strip("\r\t\n")
        (self.name, self.address) = parseaddr(self.fulladdress)
        if self.name == "":
            self.fulladdress = self.address

    def __str__(self):
        return self.fulladdress


class Email(object):
    def __init__(self, mailid, mformat="plain", dformat="plain", links=0):
        self.attached_map = {}
        self.contents = {"html": "", "plain": ""}
        self.headers = []
        self.attachments = {}
        self.mailid = mailid
        self.mformat = mformat
        self.dformat = dformat
        self.links = links
        self._msg = None
        self._body = None

        if not mformat in self.contents or self.contents[mformat] == "":
            # Fallback
            self.mformat = mformat == "html" and "plain" or "html"

    @property
    def msg(self):
        """Return an email.message object.
        """
        raise NotImplementedError

    @property
    def body(self):
        """Return email's body.
        """
        if self._body is None:
            self._body = getattr(self, "viewmail_%s" % self.mformat) \
                (self.contents[self.mformat], links=self.links)
        return self._body

    def get_header(self, msg, hdrname):
        """Look for a particular header.

        :param string hdrname: header name
        :return: header avalue
        """
        for name in [hdrname, hdrname.upper()]:
            if name in msg:
                return msg[name]
        return ""

    def _parse_default(self, msg, level):
        """Default parser

        All parts handled by this parser will be consireded as
        attachments.
        """
        fname = msg.get_filename()
        if fname is not None:
            decoded = decode_header(fname)
            value = decoded[0][1] is None and decoded[0][0] \
                or unicode(decoded[0][0], decoded[0][1])
        else:
            value = "part_%s" % level
        self.attachments[level] = value

    def _parse_text(self, msg, level):
        """Displayable content parser

        text, html, calendar, etc. All those contents can be displayed
        inside a navigator.
        """
        if msg.get_content_subtype() not in ["plain", "html"]:
            self._parse_default(msg, level)
            target = "plain"
        else:
            target = msg.get_content_subtype()
        self.contents[target] += decode(msg.get_payload(decode=True),
                                        charset=msg.get_content_charset())

    def _parse_image(self, msg, level):
        """image/* parser

        The only reason to make a specific parser for images is that,
        sometimes, messages embark inline images, which means they
        must be displayed and not attached.
        """
        if self.dformat == "html" and self.links \
                and "Content-Disposition" in msg:
            if msg["Content-Disposition"].startswith("inline"):
                cid = None
                if "Content-ID" in msg:
                    m = re.match("<(.+)>", msg["Content-ID"])
                    cid = m is not None and m.group(1) or msg["Content-ID"]
                fname = msg.get_filename()
                if fname is None:
                    if "Content-Location" in msg:
                        fname = msg["Content-Location"]
                    elif cid is not None:
                        fname = cid
                    else:
                        # I give up for now :p
                        return
                self.attached_map[cid] = re.match("^http:", fname) and fname \
                    or self.__save_image(fname, msg)
                return
        self._parse_default(msg, level)

    def _parse(self, msg, level=None):
        """Recursive email parser

        A message structure can be complex. To correctly handle
        unknown MIME types, a simple rule is applied : if I don't know
        how to display a specific part, it becomes an attachment! If
        no name is specified for an attachment, the part number
        described in the RFC 3501 (which retrieves BODY sections) is
        used to build a file name (like part_1.1).

        :param msg: message (or part) to parse
        :param level: current part number
        """
        if msg.is_multipart() and msg.get_content_maintype() != "message":
            cpt = 1
            for part in msg.get_payload():
                nlevel = level is None and ("%d" % cpt) \
                    or "%s.%d" % (level, cpt)
                self._parse(part, nlevel)
                cpt += 1
            return

        if level is None:
            level = "1"
        try:
            getattr(self, "_parse_%s" % msg.get_content_maintype())(msg, level)
        except AttributeError:
            self._parse_default(msg, level)

    def __save_image(self, fname, part):
        """Save an inline image on the filesystem.

        Some HTML messages are using inline images (attached images
        with links on them inside the body). In order to display them,
        images are saved on the filesystem and links contained in the
        message are modified.

        :param fname: the image associated filename
        :param part: the email part that contains the image payload
        """
        if re.search(r"\.\.", fname):
            return None
        path = "/static/tmp/" + fname
        fp = open(settings.MODOBOA_DIR + path, "wb")
        fp.write(part.get_payload(decode=True))
        fp.close()
        return path

    def map_cid(self, url):
        """Replace attachment links.

        :param str url: original url
        :rtype: string
        :return: internal link
        """
        match = re.match(".*cid:(.+)", url)
        if match is not None:
            if match.group(1) in self.attached_map:
                return self.attached_map[match.group(1)]
        return url

    def render_headers(self, **kwargs):
        return render_to_string("common/mailheaders.html", {
            "headers": self.headers,
        })

    def viewmail_plain(self, content, **kwargs):
        return "<pre>%s</pre>" % content

    def viewmail_html(self, content, **kwargs):
        import lxml.html

        if content is None or content == "":
            return ""
        links = kwargs.get("links", 0)
        html = lxml.html.fromstring(content)
        if not links:
            html.rewrite_links(lambda x: None)
        else:
            html.rewrite_links(self.map_cid)
            for link in html.iterlinks():
                link[0].set('target', '_blank')
        body = html.find("body")
        if body is None:
            body = lxml.html.tostring(html)
        else:
            body = lxml.html.tostring(body)
            body = re.sub("<(/?)body", lambda m: "<%sdiv" % m.group(1), body)
        return body


def split_mailbox(mailbox):
    """Tries to split a mailbox in two parts (local part and domain name)

    :return: a 2-uple (local part, domain)
    """
    try:
        mailbox.index("@")
    except ValueError:
        return mailbox, None
    parts = mailbox.split('@')
    if len(parts) == 2:
        address = parts[0]
        domain = parts[1]
    else:
        domain = parts[-1]
        address = "@".join(parts[:-1])
    return (address, domain)


def decode(s, encodings=('utf8', 'latin1', 'windows-1252', 'ascii'), charset=None):
    if charset is not None:
        try:
            return s.decode(charset, 'ignore')
        except LookupError:
            pass

    for encoding in encodings:
        try:
            return s.decode(encoding)
        except UnicodeDecodeError:
            pass
    return s.decode('ascii', 'ignore')


def prepare_addresses(addresses, usage="header"):
    """Prepare addresses before using them

    FIXME: We need a real address parser here! If a name contains a
    separator, it creates two wrong addresses.

    :param list addresses: a list of addresses
    :param string usage: how those addresses are going to be used
    :return: a string or a list depending on usage value
    """
    result = []
    for address in re.split('[,;]', addresses):
        name, addr = parseaddr(address)
        if name and usage == "header":
            result.append("%s <%s>" % (Header(name, 'utf8').encode(), addr))
        else:
            result.append(addr)
    if usage == "header":
        return ",".join(result)
    return result


def set_email_headers(msg, subject, sender, rcpt):
    """Set mandatory headers.

    Subject, From, To, Message-ID, User-Agent, Date
    """
    import pkg_resources

    msg["Subject"] = Header(subject, 'utf8')
    msg["From"] = sender
    msg["To"] = prepare_addresses(rcpt)
    msg["Message-ID"] = make_msgid()
    msg["User-Agent"] = "Modoboa %s" % \
        (pkg_resources.get_distribution("modoboa").version)
    msg["Date"] = formatdate(time.time(), True)


def __sendmail(sender, rcpt, msgstring, server='localhost', port=25):
    """Message sending

    Return a tuple (True, None) on success, (False, error message)
    otherwise.

    :param sender: sender address
    :param rcpt: recipient address
    :param msgstring: the message structure (must be a string)
    :param server: the sending server's address
    :param port: the listening port
    :return: tuple
    """
    try:
        s = smtplib.SMTP(server, port)
        s.sendmail(sender, [rcpt], msgstring)
        s.quit()
    except smtplib.SMTPException, e:
        return False, "SMTP error: %s" % str(e)
    return True, None


def sendmail_simple(sender, rcpt, subject="Sample message", content="", **kwargs):
    """Simple way to send a text message

    Send a text/plain message with basic headers (msg-id, date).

    Return a tuple (True, None) on success, (False, error message)
    otherwise.

    :param sender: sender address
    :param rcpt: recipient address
    :param subject: message's subject
    :param content: message's content
    :return: tuple
    """
    msg = MIMEText(content, _charset='utf-8')
    set_email_headers(msg, subject, sender, rcpt)
    return __sendmail(sender, rcpt, msg.as_string(), **kwargs)


def sendmail_fromfile(sender, rcpt, fname):
    """Send a message contained within a file

    The given file name must represent a valid message structure. It
    must not include the From: and To: headers, they are automatically
    added by the function.

    :param sender: sender address
    :param rcpt: recipient address
    :param fname: the name of the file containing the message
    :return: a tuple
    """
    try:
        fp = open(fname)
    except IOError, e:
        return False, str(e)

    content = """From: %s
To: %s
""" % (sender, rcpt)
    content += fp.read()
    fp.close()

    return __sendmail(sender, rcpt, content)

########NEW FILE########
__FILENAME__ = email_listing
# -*- coding: utf-8 -*-
import re
from django.conf import settings
from django.template.loader import render_to_string
from django.template import Template, Context
from django.utils.translation import ugettext as _

attached_map = {}


class MBconnector(object):
    def __init__(self, address, port):
        self.address = address
        self.port = port

    def messages_count(self, **kwargs):
        pass


class Page(object):
    def __init__(self, pageid, id_start, id_stop, items, 
                 items_per_page, has_previous, has_next,
                 baseurl=None):
        self.number = pageid
        self.id_start = id_start
        self.id_stop = id_stop
        self.items = items
        self.items_per_page = items_per_page
        self.has_previous = has_previous
        self.has_next = has_next
        self.baseurl = baseurl

    def previous_page_number(self):
        if not self.has_previous:
            return False
        return self.number - 1

    def next_page_number(self):
        if not self.has_next:
            return False
        return self.number + 1

    def last_page(self):
        lid = self.items / self.items_per_page
        if not lid:
            return 1
        if self.items % self.items_per_page:
            lid += 1
        return lid


class Paginator(object):
    def __init__(self, total, elems_per_page):
        self.total = total
        self.elems_per_page = elems_per_page
        self.num_pages = total / elems_per_page
        if total % elems_per_page:
            self.num_pages += 1

    def _indexes(self, page):
        id_start = self.elems_per_page * page + 1
        id_stop = id_start + self.elems_per_page - 1
        return (id_start, id_stop)

    def getpage(self, page):
        if page < 1:
            return None
        id_start, id_stop = self._indexes(page - 1)
        has_previous = has_next = False
        if id_start <= self.total:
            if page > 1:
                has_previous = True
            if id_stop < self.total:
                has_next = True
            else:
                id_stop = self.total
        else:
            return None
        p = Page(page, id_start, id_stop, self.total,
                 self.elems_per_page, has_previous, has_next)
        p.paginator = self
        return p


class EmailListing(object):

    def __init__(self, baseurl=None, folder=None, elems_per_page=40, 
                 navparams={}, **kwargs):
        self.folder = folder
        self.elems_per_page = elems_per_page
        self.navparams = navparams
        self.extravars = {}
        self.show_listing_headers = False
        self.empty = "empty" in kwargs and kwargs["empty"] or False
        if self.empty:
            return
        if "order" in kwargs:
            order = kwargs["order"]
        elif "order" in self.navparams:
            order = self.navparams["order"]
        else:
            order = None
        self.paginator = Paginator(
            self.mbc.messages_count(folder=self.folder, order=order),
            elems_per_page
        )
        self.baseurl = baseurl

    @staticmethod
    def render_navbar(page, baseurl=None):
        if page is None:
            return ""
        context = {
            "page": page, "STATIC_URL": settings.STATIC_URL, "baseurl": baseurl
        }
        return render_to_string("common/pagination_bar.html", context)

    def fetch(self, request, id_start, id_stop):
        table = self.tbltype(
            request,
            self.mbc.fetch(start=id_start, stop=id_stop,
                           mbox=self.folder,
                           nbelems=self.elems_per_page)
        )
        tpl = Template("""
<form method="POST" id="listingform">
  {{ table }}
</form>""")
        return tpl.render(
            Context({
                "table": table.render(withheader=self.show_listing_headers)
            })
        )

    def render(self, request, pageid=1, **kwargs):
        page = self.paginator.getpage(pageid)
        if not page:
            listing = "<div class='alert alert-info'>%s</div>" % _("Empty mailbox")
        else:
            listing = self.fetch(request, page.id_start, page.id_stop)
        return dict(listing=listing, navbar=self.render_navbar(page, self.baseurl))

########NEW FILE########
__FILENAME__ = events
# -*- coding: utf-8 -*-

"""
:mod:`events` --- simple events handling
----------------------------------------

This module provides a simple way of managing events between Modoboa
core application and additional components.

"""
from functools import wraps
import inspect
import re
from django.conf import settings
from modoboa.lib.sysutils import guess_extension_name

events = []
callbacks = {}


def declare(nevents):
    """Declare new events

    :param list nevents: a list of event names
    """
    for evt in nevents:
        if not evt in events:
            events.append(evt)


def register(event, callback):
    """Register a plugin callback for a specific event

    The event must be declared in this module.

    :param event: the event to listen to
    :param callback: a function to execute when the event is raised
    """
    # if not event in events:
    #     print "Event %s not registered" % event
    #     return 0
    if not event in callbacks.keys():
        callbacks[event] = {}
    fullname = "%s.%s" % (callback.__module__, callback.__name__)
    if not fullname in callbacks[event]:
        callbacks[event][fullname] = callback
    return 1


class observe(object):
    """Event observing decorator

    Automatically register the decorated function to observe the given
    event. If the decorated function is located into an extension, we
    check before each call if the extension is enabled or not. If
    that's not the case, the callback is not called.

    .. note::

        That's not a really optimized behaviour but I haven't found
        another solution to achieve that feature.

    :param evtname: the event's name
    """
    def __init__(self, *evtnames, **kwargs):
        self.evtnames = evtnames
        if "extname" in kwargs:
            self.extname = kwargs["extname"]

    def __guess_extension_name(self, modname):
        if modname.startswith('modoboa.extensions'):
            m = re.match(r'modoboa\.extensions\.([^\.]+)', modname)
            if m:
                return m.group(1)
        return None

    def __call__(self, f):
        modname = inspect.getmodule(inspect.stack()[1][0]).__name__
        extname = self.extname if hasattr(self, "extname") \
            else self.__guess_extension_name(modname)

        @wraps(f)
        def wrapped_f(*args, **kwargs):
            if extname:
                from modoboa.core.models import Extension
                from modoboa.core.extensions import exts_pool
                try:
                    ext = Extension.objects.get(name=extname)
                except Extension.DoesNotExist:
                    extdef = exts_pool.get_extension(extname)
                    if not extdef.always_active:
                        return []
                else:
                    if not ext.enabled:
                        return None
            elif not modname in settings.MODOBOA_APPS:
                return []
            return f(*args, **kwargs)
        for evt in self.evtnames:
            register(evt, wrapped_f)
        return wrapped_f


def unregister(event, callback):
    """Unregister a callback for a specific event

    :param event: the targeted event
    :param callback: the callback to remove
    """
    if not event in events:
        return False
    if not event in callbacks:
        return False
    fullname = "%s.%s" % (callback.__module__, callback.__name__)
    try:
        del callbacks[event][fullname]
    except KeyError:
        pass


def unregister_extension(extension=None):
    """Unregister all callbacks declared by an extension.

    :param str extension: extension full name (ie. module name)
    """
    if extension is None:
        extension = guess_extension_name()
    for evt, values in callbacks.items():
        for name in values.keys():
            if extension in name:
                del callbacks[evt][name]


def raiseEvent(event, *args, **kwargs):
    """Raise a specific event

    Any additional keyword argument will be passed to registered
    callbacks.

    :param event: the event to raise
    """
    if not event in events or not event in callbacks:
        return 0
    for callback in callbacks[event].values():
        callback(*args, **kwargs)
    return 1


def raiseQueryEvent(event, *args, **kwargs):
    """Raise a specific event and wait for answers from callbacks

    Any additional keyword argument will be passed to registered
    callbacks. Callback answers are returned as a list.

    :param event: the event to raise
    """
    result = []
    if not event in events or not event in callbacks:
        return result
    for callback in callbacks[event].values():
        tmp = callback(*args, **kwargs)
        if tmp is None:
            # Callback is registered but associated extension is
            # disabled.
            continue
        result += tmp
    return result


def raiseDictEvent(event, *args):
    """Raise a specific event and return result as a dictionnary

    Any additional keyword argument will be passed to registered
    callbacks. Callback answers must be dictionnaries.

    :param event: the event to raise
    :return: a dictionnary
    """
    result = {}
    if not event in events or not event in callbacks:
        return result
    for callback in callbacks[event].values():
        tmp = callback(*args)
        if tmp is None:
            # Callback is registered but associated extension is
            # disabled.
            continue
        for k, v in tmp.iteritems():
            result[k] = v
    return result

########NEW FILE########
__FILENAME__ = exceptions
# coding: utf-8
"""
:mod:`exceptions` --- Custom Modoboa exceptions
-----------------------------------------------

"""
from django.utils.translation import ugettext as _


class ModoboaException(Exception):
    """
    Base class for Modoboa custom exceptions.
    """
    http_code = None

    def __init__(self, *args, **kwargs):
        if 'http_code' in kwargs:
            self.http_code = kwargs['http_code']
            del kwargs['http_code']
        super(ModoboaException, self).__init__(*args, **kwargs)


class InternalError(ModoboaException):
    """
    Use this exception for system errors, missing dependencies, etc.
    """
    http_code = 500


class BadRequest(ModoboaException):
    """
    Use this exception when received data doesn't validate a specific
    format (example: wrong CSV line) or doesn't respect validation
    rules.
    """
    http_code = 400


class NotFound(ModoboaException):
    """
    Use this exception to indicate the requested resource could not be
    found.
    """
    http_code = 404


class Conflict(ModoboaException):
    """
    Use this exception to indicate that the request could not be
    processed because of conflict in the request.
    """
    http_code = 409


class PermDeniedException(ModoboaException):
    """
    Use this exception when a user tries to do something he is not
    allowed to.
    """
    http_code = 403

    def __init__(self, msg=None):
        self.msg = msg

    def __str__(self):
        if self.msg:
            return _("Permission denied: %s" % self.msg)
        return _("Permission denied")

########NEW FILE########
__FILENAME__ = formutils
# coding: utf-8
import re
from django.utils.translation import ugettext as _, ugettext_lazy
from django.forms import ChoiceField
from django.forms.widgets import RadioSelect, RadioInput
from django.forms.fields import CharField, Field
from django.core.exceptions import ValidationError
from django.utils.encoding import force_unicode
from django.utils.safestring import mark_safe
from django.utils.html import conditional_escape


class CreationWizard(object):
    def __init__(self, done_cb=None):
        self.steps = []
        self.done_cb = done_cb

    @property
    def errors(self):
        result = {}
        for step in self.steps:
            for name, value in step['form'].errors.items():
                if name == '__all__':
                    continue
                result[name] = value
        return result

    def add_step(self, cls, title, buttons, formtpl=None, new_args=None):
        self.steps += [dict(cls=cls, title=title, buttons=buttons,
                            formtpl=formtpl, new_args=new_args)]

    def create_forms(self, data=None):
        for step in self.steps:
            args = []
            if 'new_args' in step and step["new_args"]:
                args += step["new_args"]
            if data:
                args.append(data)
            step["form"] = step["cls"](*args)

    def validate_step(self, request):
        stepid = request.POST.get("stepid", None)
        if stepid is None:
            return -1, _("Invalid request")

        stepid = stepid.replace("step", "")
        stepid = int(stepid)
        if stepid < 0 or stepid > len(self.steps):
            return -1, _("Invalid request")
        self.create_forms(request.POST)
        statuses = []
        for cpt in xrange(0, stepid):
            statuses.append(self.steps[cpt]["form"].is_valid())
        if False in statuses:
            return 0, stepid
        if stepid == len(self.steps):
            if self.done_cb is not None:
                self.done_cb(self.steps)
            return 2, None
        return 1, stepid

    def get_title(self, stepid):
        return "%d. %s" % (stepid, self.steps[stepid - 1]["title"])


class DynamicForm(object):

    def _create_field(self, typ, name, value=None, pos=None):
        self.fields[name] = typ(label="", required=False)
        if value is not None:
            self.fields[name].initial = value
        if pos:
            self.fields.keyOrder.remove(name)
            self.fields.keyOrder.insert(pos, name)

    def _load_from_qdict(self, qdict, pattern, typ):
        expr = re.compile(r'%s_\d+' % pattern)
        values = []
        for k, v in qdict.iteritems():
            if k == pattern or expr.match(k):
                values.append((k, v))

        ndata = self.data.copy()
        values.reverse()
        for v in values:
            if v[0] in self.fields:
                continue
            self._create_field(typ, v[0])
            ndata[v[0]] = v[1]
        self.data = ndata


class TabForms(object):
    """
    Simple forms container

    This class tries to encapsulate multiple forms that will be
    displayed using tabs. It is different from a classical formset
    because it can contain different forms.
    """
    def __init__(self, data=None, instances=None, classes=None):
        to_remove = []
        for fd in self.forms:
            args = []
            kwargs = {}
            if "new_args" in fd:
                args += fd["new_args"]
            if data is not None:
                args.append(data)
            if instances is not None:
                if hasattr(self, "check_%s" % fd["id"]):
                    if not getattr(self, "check_%s" % fd["id"])(instances[fd["id"]]):
                        to_remove += [fd]
                        continue
                kwargs["instance"] = instances[fd["id"]]
            if classes is not None and fd["id"] in classes:
                fd["instance"] = classes[fd["id"]](*args, **kwargs)
            else:
                fd["instance"] = fd["cls"](*args, **kwargs)
        self.forms = [form for form in self.forms if not form in to_remove]
        if self.forms:
            self.active_id = self.forms[0]["id"]

    def _before_is_valid(self, form):
        return True

    @property
    def errors(self):
        result = {}
        for f in self.forms:
            for name, value in f['instance'].errors.items():
                if name == '__all__':
                    continue
                result[name] = value
        return result
    
    def is_valid(self, mandatory_only=False, optional_only=False):
        to_remove = []
        for f in self.forms:
            if mandatory_only and \
               (not 'mandatory' in f or not f["mandatory"]):
                continue
            elif optional_only and \
               ('mandatory' in f and f["mandatory"]):
                continue
            if not self._before_is_valid(f):
                to_remove.append(f)
                continue
            if not f["instance"].is_valid():
                self.active_id = f["id"]
                return False
        self.forms = [f for f in self.forms if not f in to_remove]
        return True

    def save(self, *args, **kwargs):
        raise RuntimeError

    def remove_tab(self, tabid):
        for f in self.forms:
            if f["id"] == tabid:
                self.forms.remove(f)
                break

    def __iter__(self):
        return self.forward()

    def forward(self):
        for form in self.forms:
            yield form

#
# Custom fields from here
#


def is_valid_host(host):
    """IDN compatible domain validator
    """
    host = host.encode('idna').lower()
    if not hasattr(is_valid_host, '_re'):
        is_valid_host._re = re.compile(r'^([0-9a-z][-\w]*[0-9a-z]\.)+[a-z0-9\-]{2,15}$')
    return bool(is_valid_host._re.match(host))


def validate_domain_name(value):
    if not is_valid_host(value):
        raise ValidationError(_('Enter a valid domain name'), 'invalid')


class DomainNameField(CharField):
    """
    A subclass of CharField that only accepts a valid domain name.
    """
    default_error_messages = {
        'invalid': _('Enter a valid domain name')
    }

    default_validators = [validate_domain_name]

    def clean(self, value):
        value = self.to_python(value).strip()
        return super(DomainNameField, self).clean(value)


class CustomRadioInput(RadioInput):
    def __unicode__(self):
        if 'id' in self.attrs:
            label_for = ' for="%s_%s"' % (self.attrs['id'], self.index)
        else:
            label_for = ''
        choice_label = conditional_escape(force_unicode(self.choice_label))
        return mark_safe(
            u'<label class="radio inline" %s>%s %s</label>'
            % (label_for, self.tag(), choice_label)
        )


class InlineRadioRenderer(RadioSelect.renderer):
    def __iter__(self):
        for i, choice in enumerate(self.choices):
            yield CustomRadioInput(
                self.name, self.value, self.attrs.copy(), choice, i
            )

    def render(self):
        return mark_safe(
            u'\n'.join([u'%s\n' % force_unicode(w) for w in self])
        )


class InlineRadioSelect(RadioSelect):
    renderer = InlineRadioRenderer


class SeparatorField(Field):
    def __init__(self, *args, **kwargs):
        kwargs["required"] = False
        super(SeparatorField, self).__init__(*args, **kwargs)


class YesNoField(ChoiceField):
    def __init__(self, *args, **kwargs):
        kwargs["choices"] = [
            ("yes", ugettext_lazy("Yes")), ("no", ugettext_lazy("No"))
        ]
        kwargs["widget"] = InlineRadioSelect
        super(YesNoField, self).__init__(*args, **kwargs)

########NEW FILE########
__FILENAME__ = imap_utf7
# -*- coding: iso-8859-1 -*-

"""
Imap folder names are encoded using a special version of utf-7 as defined in RFC 
2060 section 5.1.3.

5.1.3.  Mailbox International Naming Convention

   By convention, international mailbox names are specified using a
   modified version of the UTF-7 encoding described in [UTF-7].  The
   purpose of these modifications is to correct the following problems
   with UTF-7:

      1) UTF-7 uses the "+" character for shifting; this conflicts with
         the common use of "+" in mailbox names, in particular USENET
         newsgroup names.

      2) UTF-7's encoding is BASE64 which uses the "/" character; this
         conflicts with the use of "/" as a popular hierarchy delimiter.

      3) UTF-7 prohibits the unencoded usage of "\"; this conflicts with
         the use of "\" as a popular hierarchy delimiter.

      4) UTF-7 prohibits the unencoded usage of "~"; this conflicts with
         the use of "~" in some servers as a home directory indicator.

      5) UTF-7 permits multiple alternate forms to represent the same
         string; in particular, printable US-ASCII chararacters can be
         represented in encoded form.

   In modified UTF-7, printable US-ASCII characters except for "&"
   represent themselves; that is, characters with octet values 0x20-0x25
   and 0x27-0x7e.  The character "&" (0x26) is represented by the two-
   octet sequence "&-".

   All other characters (octet values 0x00-0x1f, 0x7f-0xff, and all
   Unicode 16-bit octets) are represented in modified BASE64, with a
   further modification from [UTF-7] that "," is used instead of "/".
   Modified BASE64 MUST NOT be used to represent any printing US-ASCII
   character which can represent itself.

   "&" is used to shift to modified BASE64 and "-" to shift back to US-
   ASCII.  All names start in US-ASCII, and MUST end in US-ASCII (that
   is, a name that ends with a Unicode 16-bit octet MUST end with a "-
   ").

      For example, here is a mailbox name which mixes English, Japanese,
      and Chinese text: ~peter/mail/&ZeVnLIqe-/&U,BTFw-

Found here:
http://svn.plone.org/svn/collective/mxmImapClient/trunk/imapUTF7.py

"""
import binascii
import codecs

# encoding

def modified_base64(s):
    s = s.encode('utf-16be')
    return binascii.b2a_base64(s).rstrip('\n=').replace('/', ',')

def doB64(_in, r):
    if _in:
        r.append('&%s-' % modified_base64(''.join(_in)))
        del _in[:]

def encoder(s):
    r = []
    _in = []
    for c in s:
        ordC = ord(c)
        if 0x20 <= ordC <= 0x25 or 0x27 <= ordC <= 0x7e:
            doB64(_in, r)
            r.append(c)
        elif c == '&':
            doB64(_in, r)
            r.append('&-')
        else:
            _in.append(c)
    doB64(_in, r)
    return (str(''.join(r)), len(s))


# decoding

def modified_unbase64(s):
    b = binascii.a2b_base64(s.replace(',', '/') + '===')
    return unicode(b, 'utf-16be')


def decoder(s):
    r = []
    decode = []
    for c in s:
        if c == '&' and not decode:
            decode.append('&')
        elif c == '-' and decode:
            if len(decode) == 1:
                r.append('&')
            else:
                r.append(modified_unbase64(''.join(decode[1:])))
            decode = []
        elif decode:
            decode.append(c)
        else:
            r.append(c)
    if decode:
        r.append(modified_unbase64(''.join(decode[1:])))
    bin_str = ''.join(r)
    return (bin_str, len(s))


class StreamReader(codecs.StreamReader):
    def decode(self, s, errors='strict'):
        return decoder(s)


class StreamWriter(codecs.StreamWriter):
    def decode(self, s, errors='strict'):
        return encoder(s)


def imap4_utf_7(name):
    if name == 'imap4-utf-7':
        return (encoder, decoder, StreamReader, StreamWriter)
codecs.register(imap4_utf_7)


## testing methods

def imapUTF7Encode(ust):
    "Returns imap utf-7 encoded version of string"
    return ust.encode('imap4-utf-7')

def imapUTF7EncodeSequence(seq):
    "Returns imap utf-7 encoded version of strings in sequence"
    return [imapUTF7Encode(itm) for itm in seq]


def imapUTF7Decode(st):
    "Returns utf7 encoded version of imap utf-7 string"
    return st.decode('imap4-utf-7')

def imapUTF7DecodeSequence(seq):
    "Returns utf7 encoded version of imap utf-7 strings in sequence"
    return [imapUTF7Decode(itm) for itm in seq]


def utf8Decode(st):
    "Returns utf7 encoded version of imap utf-7 string"
    return st.decode('utf-8')


def utf7SequenceToUTF8(seq):
    "Returns utf7 encoded version of imap utf-7 strings in sequence"
    return [itm.decode('imap4-utf-7').encode('utf-8') for itm in seq]


__all__ = ['imapUTF7Encode', 'imapUTF7Decode', ]

if __name__=='__main__':

##    print u'bx'.encode('imap4-utf-7')
##    print 'expected b&APg-x'
##
##    print u'bx'.encode('imap4-utf-7')
##    print 'expected b&AOU-x'
##
    print '#######'
    print 'bx'
    e = imapUTF7Encode(u'bx')
    print e
    print imapUTF7Decode(e).encode('latin-1')

    print '#######'
    print 'bx'
    e = imapUTF7Encode(u'bx')
    print e
    print imapUTF7Decode(e).encode('latin-1')

    print '#######'
    print '~/bg'
    e = imapUTF7Encode(u'~/bg')
    print e
    print imapUTF7Decode(e).encode('latin-1')

    print '#######'
    print 'Ting & Sger'
    e = imapUTF7Encode(u'Ting & Sger')
    print e
    print imapUTF7Decode(e).encode('latin-1')

##    e = imapUTF7Decode('b&AOU-x')
##    print e.encode('latin-1')
##
##    e = imapUTF7Decode('b&APg-x')
##    print e.encode('latin-1')
##
    print '#######'
    print '~/Flder/mailbx & stuff + more'
    n = u'~/Flder/mailbx & stuff + more'
    e = imapUTF7Encode(n)
    print e
    print imapUTF7Decode(e).encode('latin-1')

    print '#######'
    print '~peter/mail/&ZeVnLIqe-/&U,BTFw-'
    print imapUTF7Decode('~peter/mail/&ZeVnLIqe-/&U,BTFw-').encode('utf-8')
    

########NEW FILE########
__FILENAME__ = ldaputils
# coding: utf-8

"""
:mod:`ldaputils` --- a collection of LDAP based classes/functions
-----------------------------------------------------------------

For a first version, the LDAP support offered by Modoboa only supports
one global server definition : the one the django-auth-ldap uses.

Extra information about Active Directory
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Extracted from `this blog
<http://www.dirmgr.com/blog/2010/8/26/ldap-password-changes-in-active-directory.html>`_:

- Active Directory doesn't appear to support the password modify
  extended operation, so you must change passwords using a normal LDAP
  modify operation.

- Active Directory stores passwords in the unicodePwd attribute,
  rather than userPassword.

- Active Directory will only accept password changes over secure
  connections. I have only ever used SSL. It may be that you can also
  use StartTLS, or perhaps SASL with confidentiality, but I'm not sure
  about that.

- The new password must be enclosed in quotation marks, and it must
  use a UTF-16 little-endian encoding.

- Active Directory may impose some strength requirements on the
  password, although exactly what those requirements are may vary from
  one instance to another.

"""
import ldap
from django.conf import settings
from django.utils.translation import ugettext as _
from modoboa.core.password_hashers import get_password_hasher
from modoboa.lib import parameters
from modoboa.lib.exceptions import InternalError


class LDAPAuthBackend(object):
    def __init__(self):
        self.server_uri = self._setting(
            "AUTH_LDAP_SERVER_URI", "ldap://localhost"
        )
        self.pwd_attr = self._setting("LDAP_PASSWORD_ATTR", "userPassword")
        self.ldap_ad = self._setting("LDAP_ACTIVE_DIRECTORY", False)
        self.conn = None
        self.user_filter = self._setting("LDAP_USER_FILTER", "")
        self.user_dn = None

    def _setting(self, name, default):
        try:
            value = getattr(settings, name)
        except AttributeError:
            value = default
        return value

    def _get_conn(self, dn, password):
        conn = ldap.initialize(self.server_uri)
        conn.set_option(ldap.OPT_X_TLS_DEMAND, True)
        conn.set_option(ldap.OPT_DEBUG_LEVEL, 255)
        conn.simple_bind_s(dn, password)
        return conn

    def connect_to_server(self, user, password):
        if parameters.get_admin("LDAP_AUTH_METHOD", app="core") == "searchbind":
            bind_dn = self._setting("AUTH_LDAP_BIND_DN", "")
            bind_pwd = self._setting("AUTH_LDAP_BIND_PASSWORD", "")
            self.conn = self._get_conn(bind_dn, bind_pwd)
            self.user_dn = self._find_user_dn(user)
        else:
            tpl = self._setting("AUTH_LDAP_USER_DN_TEMPLATE", "")
            self.user_dn = tpl % {"user": user}
            self.conn = self._get_conn(self.user_dn, password)

    def _find_user_dn(self, user):
        sbase = parameters.get_admin("LDAP_SEARCH_BASE", app="core")
        sfilter = parameters.get_admin("LDAP_SEARCH_FILTER", app="core")
        sfilter = sfilter % {"user": user}
        res = self.conn.search_s(sbase, ldap.SCOPE_SUBTREE, sfilter)
        try:
            dn = res[0][0]
        except IndexError:
            return None
        return dn

    def _crypt_password(self, clearpassword):
        """Overidding of the crypt_password function (LDAP compliant)

        :param clearpassword: the clear password
        :return: the encrypted password
        """
        scheme = parameters.get_admin("PASSWORD_SCHEME", app="core")
        hasher = get_password_hasher(scheme.upper())('ldap')
        return hasher.encrypt(clearpassword)

    def update_user_password(self, user, password, newpassword):
        try:
            self.connect_to_server(user, password)
            if self.ldap_ad:
                newpassword = ('"%s"' % newpassword).encode('utf-16').lstrip('\377\376')
            ldif = [(ldap.MOD_REPLACE,
                     self.pwd_attr,
                     self._crypt_password(newpassword))]
            self.conn.modify_s(self.user_dn, ldif)
        except ldap.LDAPError as e:
            raise InternalError(_("Failed to update password: %s" % str(e)))

########NEW FILE########
__FILENAME__ = listing
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from modoboa.lib import parameters


def get_sort_order(qdict, default, allowed_values=None):
    """Return a sort order from a querydict object

    :param QueryDict qdict: the object to analyse
    :param string default: the default sort order if no one is found
    :param list allowed_values: an optional list of allowed values
    :return: a 2uple of strings
    """
    sort_order = qdict.get("sort_order", default)
    if sort_order.startswith("-"):
        sort_dir = "-"
        sort_order = sort_order[1:]
    else:
        sort_dir = ""
    if allowed_values is not None and not sort_order in allowed_values:
        return (default, "")
    return (sort_order, sort_dir)


def get_listing_page(objects, pagenum):
    paginator = Paginator(objects, int(parameters.get_admin("ITEMS_PER_PAGE", app="core")))
    try:
        page = paginator.page(int(pagenum))
    except (EmptyPage, PageNotAnInteger, ValueError):
        page = paginator.page(paginator.num_pages)
    return page

########NEW FILE########
__FILENAME__ = middleware
# coding: utf-8
"""
Custom middlewares.
"""
import re
from django.http import Http404, HttpResponseRedirect
from modoboa.core.models import Extension
from modoboa.core.extensions import exts_pool
from modoboa.lib.webutils import (
    _render_error, ajax_response, render_to_json_response
)
from modoboa.lib.exceptions import ModoboaException
from modoboa.lib.signals import request_accessor


class ExtControlMiddleware(object):
    def process_view(self, request, view, args, kwargs):
        m = re.match("modoboa\.extensions\.(\w+)", view.__module__)
        if m is None:
            return None
        try:
            ext = Extension.objects.get(name=m.group(1))
        except Extension.DoesNotExist:
            extdef = exts_pool.get_extension(m.group(1))
            if extdef.always_active:
                return None
            raise Http404
        if ext.enabled:
            return None
        raise Http404


class AjaxLoginRedirect(object):
    def process_response(self, request, response):
        if request.is_ajax():
            if type(response) == HttpResponseRedirect:
                response.status_code = 278
        return response


class CommonExceptionCatcher(object):
    def process_exception(self, request, exception):
        if not isinstance(exception, ModoboaException):
            return None

        if not request.is_ajax():
            return _render_error(
                request, user_context=dict(error=str(exception))
            )
        if exception.http_code is None:
            return ajax_response(
                request, status="ko", respmsg=unicode(exception), norefresh=True
            )
        return render_to_json_response(
            unicode(exception), status=exception.http_code
        )


class RequestCatcherMiddleware(object):
    """
    Simple middleware to store the current request.
    """

    def __init__(self):
        self._request = None
        request_accessor.connect(self)

    def process_request(self, request):
        self._request = request

    def __call__(self, **kwargs):
        return self._request

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):
    
    def forwards(self, orm):
        
        # Adding model 'Parameter'
        db.create_table('lib_parameter', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('value', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
        ))
        db.send_create_signal('lib', ['Parameter'])

        # Adding model 'UserParameter'
        db.create_table('lib_userparameter', (
            ('value', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
        ))
        db.send_create_signal('lib', ['UserParameter'])
    
    
    def backwards(self, orm):
        
        # Deleting model 'Parameter'
        db.delete_table('lib_parameter')

        # Deleting model 'UserParameter'
        db.delete_table('lib_userparameter')
    
    
    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'lib.parameter': {
            'Meta': {'object_name': 'Parameter'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'lib.userparameter': {
            'Meta': {'object_name': 'UserParameter'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }
    
    complete_apps = ['lib']

########NEW FILE########
__FILENAME__ = 0002_move_secret_key
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models


class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        try:
            p = orm.Parameter.objects.get(name="webmail.SECRET_KEY")
        except orm.Parameter.DoesNotExist:
            pass
        else:
            p.name = "auth.SECRET_KEY"
            p.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        p = orm.Parameter.objects.get(name="auth.SECRET_KEY")
        p.name = "webmail.SECRET_KEY"
        p.save()

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'lib.parameter': {
            'Meta': {'object_name': 'Parameter'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'lib.userparameter': {
            'Meta': {'object_name': 'UserParameter'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['lib']

########NEW FILE########
__FILENAME__ = 0003_clean_parameters
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models
from django.core.exceptions import ObjectDoesNotExist


class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        orm["lib.Parameter"].objects.filter(name__in=[
            "admin.STORAGE_PATH", "admin.VIRTUAL_GID", "admin.MAILBOX_TYPE",
            "admin.MAILDIR_ROOT"
        ]).delete()
        try:
            orm["lib.parameter"].objects.filter(name="general.DEFAULT_TOP_REDICTION").update(name="admin.DEFAULT_TOP_REDICTION")
        except ObjectDoesNotExist:
            pass
        try:
            orm["lib.parameter"].objects.filter(name="admin.CREATE_DIRECTORIES").update(name="admin.HANDLE_MAILBOXES")
        except ObjectDoesNotExist:
            pass
        try:
            orm["lib.parameter"].objects.filter(name="admin.VIRTUAL_UID").update(name="admin.MAILBOXES_OWNER")
        except ObjectDoesNotExist:
            pass
        try:
            orm["lib.parameter"].objects.filter(name="auth.SECRET_KEY").update(name="admin.SECRET_KEY")
        except ObjectDoesNotExist:
            pass

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("Cannot revert this migration")

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'lib.parameter': {
            'Meta': {'object_name': 'Parameter'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'lib.userparameter': {
            'Meta': {'object_name': 'UserParameter'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['lib']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0004_auto__add_log__chg_field_userparameter_user
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'Log'
        db.create_table(u'lib_log', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('date_created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('message', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('level', self.gf('django.db.models.fields.CharField')(max_length=15)),
            ('logger', self.gf('django.db.models.fields.CharField')(max_length=30)),
        ))
        db.send_create_signal(u'lib', ['Log'])

        # Changing field 'UserParameter.user'
        db.alter_column(u'lib_userparameter', 'user_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['admin.User']))

    def backwards(self, orm):
        raise RuntimeError("Cannot revert this migration")

    models = {
        u'admin.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'lib.log': {
            'Meta': {'object_name': 'Log'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.CharField', [], {'max_length': '15'}),
            'logger': ('django.db.models.fields.CharField', [], {'max_length': '30'}),
            'message': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        u'lib.parameter': {
            'Meta': {'object_name': 'Parameter'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        u'lib.userparameter': {
            'Meta': {'object_name': 'UserParameter'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['admin.User']"}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['lib']

########NEW FILE########
__FILENAME__ = 0005_rename_table
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):
    depends_on = (
        ('admin', '0037_rename_tables'),
    )

    def forwards(self, orm):
        db.rename_table('lib_log', 'core_log')
        db.send_create_signal('core', ['Log'])

        # Changing field 'UserParameter.user'
        db.alter_column(u'lib_userparameter', 'user_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['core.User']))

    def backwards(self, orm):
        db.rename_table('core_log', 'lib_log')
        db.send_create_signal(u'lib', ['Log'])

        # Changing field 'UserParameter.user'
        db.alter_column(u'lib_userparameter', 'user_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['admin.User']))

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'core.extension': {
            'Meta': {'object_name': 'Extension'},
            'enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150'})
        },
        u'core.log': {
            'Meta': {'object_name': 'Log'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.CharField', [], {'max_length': '15'}),
            'logger': ('django.db.models.fields.CharField', [], {'max_length': '30'}),
            'message': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        u'core.objectaccess': {
            'Meta': {'unique_together': "(('user', 'content_type', 'object_id'),)", 'object_name': 'ObjectAccess'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_owner': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['core.User']"})
        },
        u'core.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_local': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'lib.parameter': {
            'Meta': {'object_name': 'Parameter'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        u'lib.userparameter': {
            'Meta': {'object_name': 'UserParameter'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['core.User']"}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['core', 'lib']

########NEW FILE########
__FILENAME__ = 0006_move_parameters
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):
    depends_on = (
        ('admin', '0037_rename_tables'),
    )

    params = ['AUTHENTICATION_TYPE', 'PASSWORD_SCHEME', 'SECRET_KEY', 
              'LOG_MAXIMUM_AGE', 'ITEMS_PER_PAGE', 'DEFAULT_TOP_REDIRECTION']

    def forwards(self, orm):
        "Write your forwards methods here."
        for p in orm['lib.Parameter'].objects.filter(
            name__in=['admin.%s' % n for n in self.params]):
            p.name = p.name.replace('admin.', 'core.')
            p.save()
        for ldap_p in orm['lib.Parameter'].objects.filter(name__contains='admin.LDAP'):
            ldap_p.name = ldap_p.name.replace('admin.', 'core.')
            ldap_p.save()
        
    def backwards(self, orm):
        "Write your backwards methods here."
        for p in orm['lib.Parameter'].objects.filter(
            name__in=['core.%s' % n for n in self.params]):
            p.name = p.name.replace('core.', 'admin.')
            p.save()
        for ldap_p in orm['lib.Parameter'].objects.filter(name__contains='core.LDAP'):
            ldap_p.name = ldap_p.name.replace('core.', 'admin.')
            ldap_p.save()

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'core.user': {
            'Meta': {'ordering': "['username']", 'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '254', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_local': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254'})
        },
        u'lib.parameter': {
            'Meta': {'object_name': 'Parameter'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        u'lib.userparameter': {
            'Meta': {'object_name': 'UserParameter'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['core.User']"}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['lib']
    symmetrical = True

########NEW FILE########
__FILENAME__ = models
import reversion
from django.db import models
from django.conf import settings


class Parameter(models.Model):
    name = models.CharField(max_length=255)
    value = models.CharField(max_length=255)

    @property
    def shortname(self):
        return self.name.split(".")[1].lower()

    def __unicode__(self):
        return self.name

reversion.register(Parameter)


class UserParameter(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL)
    name = models.CharField(max_length=255)
    value = models.CharField(max_length=255)

    @property
    def shortname(self):
        return self.name.split(".")[1].lower()

########NEW FILE########
__FILENAME__ = parameters
# coding: utf-8
"""
This interface provides a simple way to declare and store parameters
in Modoboa's database.

Core components or extensions can register their own parameters, which
will be available and modifiable directly from the web interface.

Only super users will be able to access this part of the web interface.
"""
from django import forms
from modoboa.lib import events
from modoboa.lib.sysutils import guess_extension_name
from modoboa.lib.exceptions import ModoboaException

_params = {'A': {}, 'U': {}}


class NotDefined(ModoboaException):
    http_code = 404

    def __init__(self, app, name):
        self.app = app
        self.name = name

    def __str__(self):
        return "Application '%s' and/or parameter '%s' not defined" \
            % (self.app, self.name)


class GenericParametersForm(forms.Form):
    """Base class for parameter forms.

    Each extension has the possibility to define global parameters.
    """
    app = None
    visibility_rules = None

    def __init__(self, *args, **kwargs):
        if self.app is None:
            raise NotImplementedError

        kwargs["prefix"] = self.app
        super(GenericParametersForm, self).__init__(*args, **kwargs)

        self.visirules = {}
        if self.visibility_rules is not None:
            for key, rule in self.visibility_rules.items():
                field, value = rule.split("=")
                visibility = {
                    "field": "id_%s-%s" % (self.app, field), "value": value
                }
                self.visirules["%s-%s" % (self.app, key)] = visibility

        if not args:
            self._load_initial_values()

    def _load_initial_values(self):
        raise NotImplementedError

    def _decode_value(self, value):
        return value.decode('unicode_escape').replace('\\r\\n', '\n')

    def _load_extra_parameters(self, level):
        params = events.raiseDictEvent('GetExtraParameters', self.app, level)
        for pname, pdef in params.items():
            self.fields[pname] = pdef

    def _save_parameter(self, p, name, value):
        if p.value == value:
            return
        name = name.lower()
        if hasattr(self, "update_%s" % name):
            getattr(self, "update_%s" % name)(value)
        if type(value) is unicode:
            p.value = value.encode("unicode_escape").strip()
        else:
            p.value = str(value)
        p.save()

    def save(self):
        raise NotImplementedError


class AdminParametersForm(GenericParametersForm):
    def _load_initial_values(self):
        from .models import Parameter

        names = ["%s.%s" % (self.app, name.upper()) for name in self.fields.keys()]
        for p in Parameter.objects.filter(name__in=names):
            self.fields[p.shortname].initial = self._decode_value(p.value)

    def save(self):
        from .models import Parameter
        from modoboa.lib.formutils import SeparatorField

        for name, value in self.cleaned_data.items():
            if type(self.fields[name]) is SeparatorField:
                continue
            fullname = "%s.%s" % (self.app, name.upper())
            try:
                p = Parameter.objects.get(name=fullname)
            except Parameter.DoesNotExist:
                p = Parameter()
                p.name = fullname
            self._save_parameter(p, name, value)

    def to_django_settings(self):
        pass

    def get_current_values(self):
        values = {}
        for key in self.fields.keys():
            try:
                values[key] = get_admin(key.upper(), app=self.app)
            except NotDefined:
                pass
        return values


class UserParametersForm(GenericParametersForm):
    def __init__(self, *args, **kwargs):
        self.user = kwargs.pop("user") if "user" in kwargs else None
        super(UserParametersForm, self).__init__(*args, **kwargs)

    def _load_initial_values(self):
        if self.user is None:
            return
        from .models import UserParameter

        names = ["%s.%s" % (self.app, name.upper()) for name in self.fields.keys()]
        for p in UserParameter.objects.filter(user=self.user, name__in=names):
            self.fields[p.shortname].initial = self._decode_value(p.value)

    @staticmethod
    def has_access(user):
        return True

    def save(self):
        from .models import UserParameter
        from modoboa.lib.formutils import SeparatorField

        for name, value in self.cleaned_data.items():
            if type(self.fields[name]) is SeparatorField:
                continue
            fullname = "%s.%s" % (self.app, name.upper())
            try:
                p = UserParameter.objects.get(user=self.user, name=fullname)
            except UserParameter.DoesNotExist:
                p = UserParameter()
                p.user = self.user
                p.name = fullname
            self._save_parameter(p, name, value)


def register(formclass, label):
    """Register a form class containing parameters

    formclass must inherit from ``AdminParametersForm`` or
    ``UserParametersForm``.

    :param formclass: a form class
    :param string label: the label to display in parameters or settings pages
    """
    from modoboa.lib.formutils import SeparatorField

    if issubclass(formclass, AdminParametersForm):
        level = 'A'
    elif issubclass(formclass, UserParametersForm):
        level = 'U'
    else:
        raise RuntimeError("Unknown parameter class")
    _params[level][formclass.app] = {
        "label": label, "form": formclass, "defaults": {}
    }
    form = formclass()
    for name, field in form.fields.items():
        if type(field) is SeparatorField:
            continue
        _params[level][formclass.app]["defaults"][name.upper()] = field.initial


def unregister(app=None):
    """Unregister an application

    All parameters associated to this application will also be
    removed.

    :param app: the application's name (string)
    """
    if app is None:
        app = guess_extension_name()
    for lvlparams in _params.values():
        if app in lvlparams:
            del lvlparams[app]


def __is_defined(app, level, name):
    if not level in ['A', 'U'] \
        or not app in _params[level] \
        or not name in _params[level][app]["defaults"]:
        raise NotDefined(app, name)


def save_admin(name, value, app=None):
    from .models import Parameter

    if app is None:
        app = guess_extension_name()
    __is_defined(app, 'A', name)
    fullname = "%s.%s" % (app, name)
    try:
        p = Parameter.objects.get(name=fullname)
    except Parameter.DoesNotExist:
        p = Parameter()
        p.name = fullname
        p.value = None
    f = get_parameter_form('A', name, app)
    f()._save_parameter(p, name, value)


def save_user(user, name, value, app=None):
    from .models import UserParameter

    if app is None:
        app = guess_extension_name()
    __is_defined(app, 'U', name)
    fullname = "%s.%s" % (app, name)
    try:
        p = UserParameter.objects.get(user=user, name=fullname)
    except UserParameter.DoesNotExist:
        p = UserParameter()
        p.user = user
        p.name = fullname
    f = get_parameter_form('U', name, app)
    f()._save_parameter(p, name, value)


def get_admin(name, app=None, raise_error=True):
    """Return an administrative parameter

    A ``NotDefined`` exception if the parameter doesn't exist.

    :param name: the parameter's name
    :param app: the application owning the parameter
    :return: the corresponding value as a string
    """
    from .models import Parameter

    if app is None:
        app = guess_extension_name()
    try:
        __is_defined(app, "A", name)
    except NotDefined:
        if raise_error:
            raise
        return None
    try:
        p = Parameter.objects.get(name="%s.%s" % (app, name))
    except Parameter.DoesNotExist:
        return _params["A"][app]["defaults"][name]
    return p.value.decode("unicode_escape").replace('\\r\\n', '\n')


def get_user(user, name, app=None, raise_error=True):
    """Return a parameter for a specific user

    A ``NotDefined`` exception if the parameter doesn't exist.

    :param ``User`` user: the desired user
    :param name: the parameter's name
    :param app: the application owning the parameter
    :return: the corresponding value as a string
    """
    from .models import UserParameter

    if app is None:
        app = guess_extension_name()
    try:
        __is_defined(app, "U", name)
    except NotDefined:
        if raise_error:
            raise
        return None
    try:
        p = UserParameter.objects.get(user=user, name="%s.%s" % (app, name))
    except UserParameter.DoesNotExist:
        return _params["U"][app]["defaults"][name]
    return p.value.decode("unicode_escape")


def get_sorted_apps(level, first="core"):
    """Retrieve the sorted list of all registerd applications.

    :param str level: application level
    :param str first: force the first item of the result
    :rtype: list
    """
    sorted_apps = []
    if first in _params[level]:
        sorted_apps.append(first)
    sorted_apps += sorted(
        [app for app in _params[level].keys() if app != first],
        key=lambda app: _params[level][app]["label"]
    )
    return sorted_apps


def get_admin_forms(*args, **kwargs):
    """Get all admin level forms.

    Generates an instance of each declared form.
    """
    for app in get_sorted_apps('A'):
        formdef = _params['A'][app]
        yield {"label": formdef["label"],
               "form": formdef["form"](*args, **kwargs)}


def get_user_forms(user, *args, **kwargs):
    kwargs["user"] = user
    sorted_apps = get_sorted_apps('U', first="general")

    def realfunc():
        for app in sorted_apps:
            formdef = _params['U'][app]
            if not formdef["form"].has_access(user):
                continue
            yield {"label": formdef["label"],
                   "form": formdef["form"](*args, **kwargs)}

    return realfunc


def get_parameter_form(level, name, app=None):
    """Return the form containing a specific parameter

    :param string level: associated level
    :param string name: paremeter's name
    :param string app: parameter's application
    :return: a form class
    """
    if app is None:
        app = guess_extension_name()
    __is_defined(app, level, name)
    return _params[level][app]["form"]


def apply_to_django_settings():
    for form in get_admin_forms():
        form["form"].to_django_settings()

########NEW FILE########
__FILENAME__ = permissions
# coding: utf-8
from django.contrib.contenttypes.models import ContentType
from django.utils.translation import ugettext as _
from django.db import IntegrityError
from modoboa.core.models import ObjectAccess, User
from modoboa.lib import events
from modoboa.lib.exceptions import ModoboaException


def get_account_roles(user, account=None):
    """Return the list of available account roles.

    This function is used to create or modify an account. The returned
    list can be extended by listening to the ``GetExtraRoles`` event.

    :param ``User`` user: connected user
    :param ``User`` account: account beeing modified (None on creation)
    :return: list of strings
    """
    std_roles = [("SimpleUsers", _("Simple user"))]
    if user.is_superuser:
        std_roles += [("SuperAdmins",  _("Super administrator"))]
    filters = events.raiseQueryEvent(
        'UserCanSetRole', user, 'DomainAdmins', account
    )
    if user.has_perm("admin.add_domain") and \
            (not filters or True in filters):
        std_roles += [("DomainAdmins", _("Domain administrator"))]
    std_roles += events.raiseQueryEvent("GetExtraRoles", user)
    return sorted(std_roles, key=lambda role: role[1])


def grant_access_to_object(user, obj, is_owner=False):
    """Grant access to an object for a given user

    There are two different cases where we want to grant access to an
    object for a specific user:

    * He is the owner (he's just created the object)
    * He is going to administrate the object (but he is not the owner)

    If the user is the owner, we also grant access to this object to
    all super users.

    :param user: a ``User`` object
    :param obj: an admin. object (Domain, Mailbox, ...)
    :param is_owner: the user is the unique object's owner
    """
    ct = ContentType.objects.get_for_model(obj)
    try:
        entry = user.objectaccess_set.get(content_type=ct, object_id=obj.id)
        entry.is_owner = is_owner
        entry.save()
    except ObjectAccess.DoesNotExist:
        pass
    else:
        return

    ObjectAccess.objects.create(
        user=user, content_type=ct, object_id=obj.id, is_owner=is_owner
    )
    if not is_owner:
        return
    from modoboa.core.models import User
    for su in User.objects.filter(is_superuser=True):
        if su == user:
            continue
        ObjectAccess.objects.get_or_create(
            user=su, content_type=ct, object_id=obj.id
        )


def grant_access_to_objects(user, objects, ct):
    """Grant access to a collection of objects

    All objects in the collection must share the same type (ie. ``ct``
    applies to all objects).

    :param user: a ``User`` object
    :param objects: a list of objects
    :param ct: the content type
    """
    for obj in objects:
        try:
            ObjectAccess.objects.create(user=user, content_type=ct, object_id=obj.id)
        except IntegrityError:
            pass


def ungrant_access_to_object(obj, user=None):
    """Ungrant access to an object for a specific user

    If no user is provided, all entries referencing this object are
    deleted from the database.

    If a user is provided, we only remove his access. If it was the
    owner, we give the ownership to the first super admin we find.

    :param obj: an object inheriting from ``models.Model``
    :param user: a ``User`` object
    """
    ct = ContentType.objects.get_for_model(obj)
    if user is not None:
        try:
            ObjectAccess.objects.get(
                user=user, content_type=ct, object_id=obj.id
            ).delete()
        except ObjectAccess.DoesNotExist:
            pass
        try:
            ObjectAccess.objects.get(
                content_type=ct, object_id=obj.id, is_owner=True
            )
        except ObjectAccess.DoesNotExist:
            grant_access_to_object(
                User.objects.filter(is_superuser=True)[0], obj, True
            )
    else:
        ObjectAccess.objects.filter(
            content_type=ct, object_id=obj.id
        ).delete()


def ungrant_access_to_objects(objects):
    """Cancel all accesses for a given objects list

    :param objects: a list of objects inheriting from ``model.Model``
    """
    for obj in objects:
        ct = ContentType.objects.get_for_model(obj)
        ObjectAccess.objects.filter(content_type=ct, object_id=obj.id).delete()


def get_object_owner(obj):
    """Return the unique owner of this object

    :param obj: an object inheriting from ``model.Model``
    :return: a ``User`` object
    """
    ct = ContentType.objects.get_for_model(obj)
    try:
        entry = ObjectAccess.objects.get(content_type=ct, object_id=obj.id, is_owner=True)
    except ObjectAccess.DoesNotExist:
        return None
    return entry.user

########NEW FILE########
__FILENAME__ = signals
"""
Custom signals.
"""
from django.dispatch import Signal

request_accessor = Signal()

def get_request():
    """Get the current request from anywhere.
    """
    return request_accessor.send(None)[0][1]

########NEW FILE########
__FILENAME__ = singleton


# works in Python 2 & 3
class _Singleton(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = \
                super(_Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]


class Singleton(_Singleton('SingletonMeta', (object,), {})):
    pass

########NEW FILE########
__FILENAME__ = sysutils
# coding: utf-8

"""
This module extra functions/shortcuts to communicate with the system
(executing commands, etc.)
"""
import subprocess
import inspect
import re


def exec_cmd(cmd, sudo_user=None, **kwargs):
    """Execute a shell command.

    Run a command using the current user. Set :keyword:`sudo_user` if
    you need different privileges.

    :param str cmd: the command to execute
    :param str sudo_user: a valid system username
    :rtype: tuple
    :return: return code, command output
    """
    if sudo_user is not None:
        cmd = "sudo -u %s %s" % (sudo_user, cmd)
    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT, **kwargs)
    output = p.communicate()[0]
    return p.returncode, output


def guess_extension_name():
    """Tries to guess the application's name by inspecting the stack.

    :return: a string or None
    """
    modname = inspect.getmodule(inspect.stack()[2][0]).__name__
    match = re.match(r"(?:modoboa\.)?(?:extensions\.)?([^\.$]+)", modname)
    if match is not None:
        return match.group(1)
    return None

########NEW FILE########
__FILENAME__ = tables
# coding: utf-8
"""
:mod:`tables` --- simple tabular renderer
-----------------------------------------

This module offers a simple (I hope so) interface to render tabular
data. For a given Table class, it generates the corresponding HTML
output (using standard tags like <table> and co.).

"""
import inspect
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext as _
from django.template import Template, RequestContext, Context
from templatetags.lib_tags import render_link


class Column(object):
    """Simple column representation
    """
    def __init__(self, name, **kwargs):
        self.name = name
        self.sortable = True
        for k, v in kwargs.iteritems():
            setattr(self, k, v)

    def __unicode__(self):
        try:
            label = getattr(self, "label")
        except AttributeError:
            return u''
        return label

    def transform(self, row, col, table):
        if "class" in row.keys():
            col["cssclass"] += col["cssclass"] != "" \
                and ", %s" % row["class"] or row["class"]
        try:
            col["value"] = table.parse(self.name, row[self.name])
        except AttributeError:
            col["value"] = row[self.name]
        try:
            limit = getattr(self, "limit")
            if limit:
                # The value is not necessarily a string, so...
                col["value"] = unicode(col["value"], "utf-8") if isinstance(col["value"], str) else unicode(col["value"])
                if len(col["value"]) > limit:
                    col["value"] = col["value"][0:limit] + "..."
        except AttributeError:
            pass
        try:
            col["safe"] = getattr(self, "safe")
        except AttributeError:
            pass


class SelectionColumn(Column):
    """Specific column: selection

    A 'selection' column contains only checkboxes (one per row). It is
    usefull to select rows for grouped actions (modify, delete, etc.)
    """
    def __unicode__(self):
        if self.header:
            return "<input type='checkbox' name='selectall' id='selectall' />"
        return ""

    def render(self, value, selection):
        return "<input type='checkbox' id='%(id)s' name='select_%(value)s' value='%(value)s' %(checked)s/>" \
            % {'id': self.name, 'value': value,
               "checked": "checked=''" if selection else ""}

    def transform(self, row, col, table):
        selection = row[self.name] if self.name in row else False
        col["value"] = self.render(row[table.idkey], selection)
        col["safe"] = True


class ImgColumn(Column):
    """Specific column: image

    This kind of column only contains images tags (<img>).
    """
    def __str__(self):
        self.sortable = False
        try:
            return getattr(self, "header")
        except AttributeError:
            return ""

    def render(self, value):
        if type(value) in [list, tuple]:
            return "".join(["<img src='%s' />" % i for i in value])
        return "<img src='%s' />" % value

    def transform(self, row, col, table):
        key = "img_%s" % self.name
        if key in row.keys():
            col["value"] = self.render(row[key])
        else:
            try:
                col["value"] = self.render(self.defvalue)
            except Exception:
                pass
        col["safe"] = True


class DivColumn(Column):
    def __str__(self):
        return ""

    def render(self):
        return "<div>&nbsp;</div>"

    def transform(self, row, col, table):
        col["value"] = self.render()
        col["safe"] = True


class ActionColumn(Column):
    def render(self, fct, user, rowid):
        return fct(user, rowid)

    def transform(self, row, col, table):
        col["value"] = self.render(self.defvalue, table.request.user, row[table.idkey])
        col["safe"] = True


class LinkColumn(Column):
    def render(self, rowid, value):
        linkdef = dict(label=value, modal=self.modal)
        if type(self.urlpattern) is dict:
            t, value = rowid.split(":")
            linkdef.update(url=reverse(self.urlpattern[t], args=[value]),
                           modalcb=self.modalcb[t])
        else:
            linkdef.update(url=reverse(self.urlpattern, args=[rowid]),
                           modalcb=self.modalcb)
        return render_link(linkdef)

    def transform(self, row, col, table):
        col["value"] = self.render(row[table.idkey], row[self.name])
        col["safe"] = True


class Table(object):
    tableid = ""

    def __init__(self, request, rows=None):
        self.columns = []
        self.request = request
        if rows is None:
            rows = {}
        try:
            order = getattr(self, "cols_order")
        except AttributeError:
            for m in inspect.getmembers(self):
                if isinstance(m[1], Column):
                    try:
                        if getattr(m[1], "first"):
                            self.columns = [m[1]] + self.columns
                    except AttributeError:
                        self.columns += [m[1]]
        else:
            for colname in order:
                try:
                    col = getattr(self, colname)
                except AttributeError:
                    continue
                if not isinstance(col, Column):
                    continue
                self.columns += [col]

        if rows != {}:
            self.populate(rows)

    def populate(self, rows):
        self.rows = []
        trcpt = 0
        for row in rows:
            nrow = {"id": row[self.idkey], "cols": [], "trcpt": trcpt}
            for name in ["style", "options"]:
                if name in row:
                    nrow[name] = row[name]

            for c in self.columns:
                newcol = {"name": c.name}
                for key in ["width", "align", "cssclass"]:
                    try:
                        newcol[key] = getattr(c, key)
                    except AttributeError:
                        newcol[key] = ""
                c.transform(row, newcol, self)
                nrow["cols"] += [newcol]
            self.rows += [nrow]
            trcpt += 1

    def _rows_from_model(self, objects, include_type_in_id=False):
        rows = []
        for obj in objects:
            nrow = {}
            try:
                idkey = getattr(self, "idkey")
                nrow[idkey] = getattr(obj, idkey)
                if include_type_in_id:
                    nrow[idkey] = "%s:%s" % (obj.__class__.__name__, nrow[idkey])
            except AttributeError:
                pass
            for c in self.columns:
                try:
                    nrow[c.name] = getattr(obj, c.name)
                except AttributeError:
                    pass
            for meth in ["options", "class"]:
                try:
                    nrow[meth] = getattr(self, "row_%s" % meth)(self.request, obj)
                except AttributeError:
                    pass
            rows += [nrow]
        return rows

    def parse(self, header, value):
        try:
            return getattr(self, "parse_%s" % header)(value)
        except AttributeError:
            return value

    def __unicode__(self):
        return self.render()

    def render(self, withheader=True):
        if len(self.rows):
            try:
                styles = self.styles
            except AttributeError:
                styles = "table-striped table-bordered"

            t = Template("""
<table id="{{ tableid }}" class="table {{ styles }}">
  {% if withheader %}{% include "common/table_head.html" %}{% endif %}
  {% include "common/table_body.html" %}
</table>
""")
            return t.render(RequestContext(self.request, {
                "table": self, "tableid": self.tableid, "styles": styles,
                "withheader": withheader
            }))

        t = Template("""
<div class="alert alert-info">%s</div>
""" % _("No entries to display"))
        return t.render(Context())

########NEW FILE########
__FILENAME__ = lib_tags
# coding: utf-8
from datetime import datetime
from django import template
from django.template import Template, Context
from django.template.loader import render_to_string
from django.utils.translation import ugettext_lazy
from modoboa.lib import events
from modoboa.lib.formutils import SeparatorField

register = template.Library()


@register.simple_tag
def join(items, sep=','):
    res = ""
    for k, v in items.iteritems():
        if res != "":
            res += sep
        res += "%s : '%s'" % (k, v)
    return res


@register.simple_tag
def tolist(values):
    return "[%s]" % ",".join(['"%s"' % v for v in values])


@register.simple_tag
def render_form(form, tpl=None):
    if tpl is not None:
        return render_to_string(tpl, dict(form=form))

    ret = ""
    for field in form:
        ret += "%s\n" % render_field(field)
    return ret


@register.simple_tag
def render_field(field, help_display_mode="tooltip"):
    from modoboa.core.templatetags.core_tags import visirule

    if type(field.form.fields[field.name]) is SeparatorField:
        return "<h5%s>%s</h5>" % (visirule(field), unicode(field.label))

    return render_to_string("common/generic_field.html", dict(
        field=field, help_display_mode=help_display_mode
    ))


@register.simple_tag
def render_field_appended(field, text):
    return render_to_string("common/generic_field.html", dict(
        field=field, help_display_mode="tooltip", appended_text=text
    ))


@register.simple_tag
def render_field_with_activator(field, activator_label=ugettext_lazy("activate")):
    return render_to_string("common/generic_field.html", {
        "field": field, "help_display_mode": "tooltip", "activator": True,
        "activator_label": activator_label, "deactivate_if_empty": True
    })


@register.simple_tag
def render_and_hide_field(field):
    return render_to_string("common/generic_field.html", dict(
        field=field, hidden=True
    ))


@register.simple_tag
def render_fields_group(form, pattern):
    from django.forms import forms

    first = forms.BoundField(form, form.fields[pattern], pattern)
    label = first.label
    group = [first]
    cpt = 1
    haserror = len(first.errors) != 0
    while True:
        fname = "%s_%d" % (pattern, cpt)
        if not fname in form.fields:
            break
        bfield = forms.BoundField(form, form.fields[fname], fname)
        if len(bfield.errors):
            haserror = True
        group += [bfield]
        cpt += 1

    return render_to_string("common/generic_fields_group.html", dict(
        label=label, help_text=first.help_text, group=group, haserror=haserror
    ))


@register.simple_tag
def render_extra_fields(form):
    result = ''
    for fname in form.extra_fields:
        result += render_to_string("common/generic_field.html", {
            'field': form[fname], 'help_display_mode': 'tooltip'
        })
    return result


@register.simple_tag
def pagination_bar(page):
    return render_to_string("common/pagination_bar.html", dict(
        page=page, baseurl="?"
    ))


@register.simple_tag
def alert(msg, typ):
    t = Template("""<div class="alert alert-{{ type }}">
<a class="close" data-dismiss="alert">×</a>
{{ msg }}
</div>""")
    return t.render(Context(dict(type=typ, msg=msg)))


@register.simple_tag
def render_link(linkdef, mdclass=""):
    t = Template("""<a href="{{ link.url }}" name="{{ link.name }}" title="{{ link.title }}"
{% if link.modal %}data-toggle="ajaxmodal{% if link.autowidth %}-autowidth{% endif %}"{% endif %}
{% if link.modalcb %}modalcb="{{ link.modalcb }}"{% endif %}
{% if link.closecb %}closecb="{{ link.closecb }}"{% endif %}
class="{{ mdclass }}{% if link.class %} {{ link.class }}{% endif %}"
{% if link.confirm %} onclick="return confirm('{{ link.confirm }}')"{% endif %}>
{% if link.img %}<i class="{{ link.img }}"></i>{% endif %}
{{ link.label }}</a>""")
    return t.render(Context(dict(link=linkdef, mdclass=mdclass)))


@register.simple_tag
def progress_color(value):
    value = int(value)
    if value < 50:
        return "progress-success"
    if value < 80:
        return "progress-warning"
    return "progress-danger"


@register.filter
def fromunix(value):
    return datetime.fromtimestamp(int(value))


@register.simple_tag
def render_tags(tags):
    t = Template("""{% for tag in tags %}
<span class="label{% if tag.color %} label-{{ tag.color }}{% endif %}">
  <a href="#" class="filter {{ tag.type }}" name="{{ tag.name }}">{{ tag.label }}</a>
</span>
{% endfor %}
""")
    return t.render(Context({"tags": tags}))


@register.simple_tag
def extra_static_content(caller, user):
    """Get extra static content from extensions.

    :param str caller: the application (location) responsible for the call
    :param ``User`` user: connected user
    """
    tpl = template.Template(
        "{% for sc in static_content %}{{ sc|safe }}{% endfor %}"
    )
    return tpl.render(
        template.Context({
            'static_content': events.raiseQueryEvent("GetStaticContent", caller, user)
        })
    )

########NEW FILE########
__FILENAME__ = tests
# coding: utf-8
import json
from django.test import TestCase
from django.test.client import Client
from django import forms
from django.core.urlresolvers import reverse
from modoboa.lib import parameters


class ModoTestCase(TestCase):

    def setUp(self, username="admin", password="password"):
        self.clt = Client()
        self.assertEqual(self.clt.login(username=username, password=password), True)

    def ajax_request(self, method, url, params, status=200):
        response = getattr(self.clt, method) \
            (url, params, HTTP_X_REQUESTED_WITH='XMLHttpRequest')
        self.assertEqual(response.status_code, status)
        return json.loads(response.content)

    def ajax_post(self, *args, **kwargs):
        return self.ajax_request('post', *args, **kwargs)

    def ajax_get(self, *args, **kwargs):
        return self.ajax_request('get', *args, **kwargs)


class ExtTestCase(ModoTestCase):

    def setUp(self, *args, **kwargs):
        super(ExtTestCase, self).setUp(*args, **kwargs)
        self.clt.get(reverse("modoboa.core.views.admin.viewextensions"))

    def activate_extensions(self, *names):
        from modoboa.core.extensions import exts_pool

        self.ajax_post(
            reverse("modoboa.core.views.admin.saveextensions"),
            dict(("select_%s" % name, "1") for name in names)
        )
        for name in names:
            exts_pool.get_extension(name).load()


class TestParams(parameters.AdminParametersForm):
    app = "test"

    param1 = forms.CharField(label="Test", initial="toto")
    param2 = forms.IntegerField(label="Int", initial=42)

    def update_param2(self, value):
        raise RuntimeError("new value %d" % value)


class TestUserParams(parameters.UserParametersForm):
    app = "test"

    param1 = forms.CharField(label="Test", initial="titi")
    param2 = forms.IntegerField(label="Int", initial=42)

    def update_param2(self, value):
        raise RuntimeError("new value %d" % value)


class ParameterTestCase(TestCase):
    """Simple test cases for ``modoboa.lib.parameters`` module.
    """

    def setUp(self):
        from modoboa.core.models import User
        parameters.register(TestParams, "Test")
        parameters.register(TestUserParams, "TestUser")
        self.user = User.objects.create(username="tester")

    def test_register_form(self):
        self.assertIn("test", parameters._params['A'])

    def test_unregister(self):
        parameters.unregister("test")
        self.assertNotIn("test", parameters._params['A'])

    def test_get_parameter_form(self):
        self.assertIs(parameters.get_parameter_form('A', 'PARAM1', 'test'), TestParams)

    def test_save_admin(self):
        parameters.save_admin("PARAM1", "45", app="test")
        self.assertEqual(parameters.get_admin("PARAM1", app="test"), "45")

    def test_update_param(self):
        with self.assertRaisesRegexp(RuntimeError, "new value 35"):
            parameters.save_admin("PARAM2", 35, app="test")

    def test_get_admin(self):
        self.assertEqual(parameters.get_admin("PARAM1", "test"), "toto")
        with self.assertRaises(parameters.NotDefined):
            parameters.get_admin("TOTO", "test")

    def test_get_user(self):
        self.assertEqual(parameters.get_user(self.user, "PARAM1", "test"), "titi")
        with self.assertRaises(parameters.NotDefined):
            parameters.get_user(self.user, "TOTO", "test")

    def test_save_user(self):
        parameters.save_user(self.user, "PARAM1", "pouet", "test")
        self.assertEqual(parameters.get_user(self.user, "PARAM1", "test"), "pouet")

########NEW FILE########
__FILENAME__ = u2u_decode
#!/usr/bin/env python
# coding: utf-8
"""
u2u_decode.py

unstructured rfc2047 header to unicode
"""
import re
from email.header import decode_header, make_header

# check spaces between encoded_words (and strip them)
sre = re.compile(r'\?=[ \t]+=\?')
# re pat for MIME encoded_word (without trailing spaces)
mre = re.compile(r'=\?[^?]*?\?[bq]\?[^?\t]*?\?=', re.I)


def clean_spaces(m):
    """Replace unencoded spaces in string

    :param str m: a match object
    :return: the cleaned string
    """
    return m.group(0).replace(" ", "=20")


def decode_mime(m):
    """substitute matching encoded_word with unicode equiv.
    """
    h = decode_header(clean_spaces(m))
    try:
        u = unicode(make_header(h))
    except UnicodeDecodeError:
        return m.group(0)
    return u


def u2u_decode(s):
    ur"""utility function for (final) decoding of mime header

    note: resulting string is in one line (no \n within)
    note2: spaces between enc_words are stripped (see RFC2047)

    >>> u2u_decode('=?ISO-8859-15?Q?=20Profitez de tous les services en ligne sur impots.gouv.fr?=')
    u' Profitez de tous les services en ligne sur impots.gouv.fr'
    >>> u2u_decode('=?ISO-8859-1?Q?Accus=E9?= de =?ISO-8859-1?Q?r=E9ception?= de votre annonce')
    u'Accus\xe9 de r\xe9ception de votre annonce'
    >>> u2u_decode('Sm=?ISO-8859-1?B?9g==?=rg=?ISO-8859-1?B?5Q==?=sbord')
    u'Sm\xf6rg\xe5sbord'
    """
    s = ''.join(s.splitlines())
    s = sre.sub('?==?', s)
    u = mre.sub(decode_mime, s)
    return u

########NEW FILE########
__FILENAME__ = webutils
# coding: utf-8

"""
This module contains extra functions/shortcuts used to render HTML.
"""
import sys
import re
import json
from django.core.urlresolvers import reverse
from django.http import HttpResponse, HttpResponseRedirect
from django.contrib.auth.decorators import login_required
from django.shortcuts import render
from django.template.loader import render_to_string
from django import template
from django.conf import settings


def _render_to_string(request, tpl, user_context):
    """Custom rendering function.

    Just a wrapper which automatically adds a RequestContext instance
    (useful to use settings variables like STATIC_URL inside templates)
    """
    return render_to_string(tpl, user_context,
                            context_instance=template.RequestContext(request))


def _render_error(request, errortpl="error", user_context=None):
    if user_context is None:
        user_context = {}
    return render(
        request, "common/%s.html" % errortpl, user_context
    )


def render_actions(actions):
    t = template.Template("""{% load lib_tags %}
{% for a in actions %}{% render_link a %}{% endfor %}
""")
    return t.render(template.Context(dict(actions=actions)))


def getctx(status, level=1, callback=None, **kwargs):
    if not callback:
        callername = sys._getframe(level).f_code.co_name
    else:
        callername = callback
    ctx = {"status": status, "callback": callername}
    for kw, v in kwargs.iteritems():
        ctx[kw] = v
    return ctx


def ajax_response(request, status="ok", respmsg=None,
                  url=None, ajaxnav=False, norefresh=False, 
                  template=None, **kwargs):
    """Ajax response shortcut

    Simple shortcut that sends an JSON response. If a template is
    provided, a 'content' field will be added to the response,
    containing the result of this template rendering.

    :param request: a Request object
    :param status: the response status ('ok' or 'ko)
    :param respmsg: the message that will displayed in the interface
    :param url: url to display after receiving this response
    :param ajaxnav:
    :param norefresh: do not refresh the page after receiving this response
    :param template: eventual template's path
    :param kwargs: dict used for template rendering
    """
    ctx = {}
    for k, v in kwargs.iteritems():
        ctx[k] = v
    if template is not None:
        content = _render_to_string(request, template, ctx)
    elif kwargs.has_key("content"):
        content = kwargs["content"]
    else:
        content = ""
    jsonctx = {"status": status, "content": content}
    if respmsg is not None:
        jsonctx["respmsg"] = respmsg
    if ajaxnav:
        jsonctx["ajaxnav"] = True
    if url is not None:
        jsonctx["url"] = url
    jsonctx["norefresh"] = norefresh
    return HttpResponse(json.dumps(jsonctx), mimetype="application/json")


def render_to_json_response(context, **response_kwargs):
    """Simple shortcut to render a JSON response.

    :param dict context: response content
    :return: ``HttpResponse`` object
    """
    data = json.dumps(context)
    response_kwargs['content_type'] = 'application/json'
    return HttpResponse(data, **response_kwargs)


def static_url(path):
    """Returns the correct static url for a given file

    :param path: the targeted static media
    """
    if path.startswith("/"):
        path = path[1:]
    return "%s%s" % (settings.STATIC_URL, path)


def size2integer(value):
    """Try to convert a string representing a size to an integer value
    in bytes.

    Supported formats:
    * K|k for KB
    * M|m for MB
    * G|g for GB

    :param value: the string to convert
    :return: the corresponding integer value
    """
    m = re.match("(\d+)\s*(\w+)", value)
    if m is None:
        if re.match("\d+", value):
            return int(value)
        return 0
    if m.group(2)[0] in ["K", "k"]:
        return int(m.group(1)) * 2 ** 10
    if m.group(2)[0] in ["M", "m"]:
        return int(m.group(1)) * 2 ** 20
    if m.group(2)[0] in ["G", "g"]:
        return int(m.group(1)) * 2 ** 30
    return 0


@login_required
def topredirection(request):
    """Simple view to redirect the request when no application is specified.

    The default "top redirection" can be specified in the *Admin >
    Settings* panel. It is the application that will be
    launched. Those not allowed to access the application will be
    redirected to their preferences page.

    This feature only applies to simple users.

    :param request: a Request object
    """
    from modoboa.lib import parameters
    from modoboa.core.extensions import exts_pool

    if request.user.group == 'SimpleUsers':
        topredir = parameters.get_admin("DEFAULT_TOP_REDIRECTION", app="core")
        if topredir != "user":
            infos = exts_pool.get_extension_infos(topredir)
            path = infos["url"] if infos["url"] else infos["name"]
        else:
            path = reverse("modoboa.core.views.user.index")
    else:
        path = reverse("domains")
    return HttpResponseRedirect(path)


class NavigationParameters(object):
    """
    Just a simple object to manipulate navigation parameters.
    """

    def __init__(self, request, sessionkey):
        self.request = request
        self.sessionkey = sessionkey
        self.parameters = [('pattern', '', True),
                           ('criteria', 'from_addr', False)]

    def store(self):
        """Store navigation parameters into session.
        """
        if not self.sessionkey in self.request.session:
            self.request.session[self.sessionkey] = {}
        navparams = self.request.session[self.sessionkey]
        navparams["order"] = self.request.GET.get("sort_order", "-date")
        navparams["page"] = int(self.request.GET.get("page", 1))
        for param, defvalue, escape in self.parameters:
            value = self.request.GET.get(param, defvalue)
            if value is None:
                if param in navparams:
                    del navparams[param]
                continue
            navparams[param] = re.escape(value) if escape else value
        self.request.session.modified = True

    def get(self, param, default_value=None):
        """Retrieve a navigation parameter.

        Just a simple getter to avoid using the full key name to
        access a parameter.

        :param str param: parameter name
        :param defaultvalue: default value if none is found
        :return: parameter's value
        """
        if not self.sessionkey in self.request.session:
            return default_value
        return self.request.session[self.sessionkey].get(param, default_value)

    def remove(self, param):
        """Remove a navigation parameter from session.

        :param str param: parameter name
        """
        navparams = self.request.session[self.sessionkey]
        if param in navparams:
            del navparams[param]

########NEW FILE########
__FILENAME__ = migrate
#!/usr/bin/env python
# coding: utf-8

"""
Automatic postfixadmin to Modoboa migration
===========================================

This script provides an easy way to migrate an existing postfixadmin
database to a Modoboa one.

As the two products do not share the same schema, some informations
will be lost on the new database. Here is the list:
 * Description, transport and backup MX for domains
 * Logs
 * Fetchmail table

Mailboxes organisation on the filesystem will change. PostfixAdmin
uses the following layout::

  <topdir>/domain.tld/user@domain.tld/

Whereas Modoboa uses the following::

  <topdir>/domain.tld/user/

To rename directories, you'll need the appropriate permissions.

Domain administrators that manage more than one domain will not be
completly restored. They will only be administrator of the domain that
corresponds to their username.

Vacation messages will not be migrated by this script. Users will have
to define new messages by using Modoboa's autoreply plugin. (if
activated)

One last point about passwords. PostfixAdmin uses different hash
algorithms to store passwords so this script does not modify
them. They are copied "as is" is the new database. In order to use
them, you'll have to adapt the ``PASSWORD_SCHEME`` parameter in the
admin. panel. Currently, it appears that the ``crypt`` scheme is
compatible with PostfixAdmin ``md5crypt`` algorithm...

"""
import os
import sys
from django.db.utils import ConnectionDoesNotExist
from django.db.models import Q
from django.contrib.auth.models import Group
import modoboa.admin.models as md_models
import models as pf_models
from modoboa.lib.sysutils import exec_cmd
from modoboa.lib.emailutils import split_mailbox

def migrate_dates(oldobj):
    """Creates a new ObjectDates instance

    Due to Django limitations, we only retrieve the creation date. The
    modification date will be set to 'now' because the corresponding
    field in Modoboa's schema has the 'auto_now' attribute to True.
    (see https://docs.djangoproject.com/en/dev/ref/models/fields/#django.db.models.DateField).

    :param oldobj: the PostfixAdmin record which is beeing migrated.
    """
    dates = md_models.ObjectDates()
    dates.save()

    dates.creation = oldobj.created
    dates.save()
    return dates

def migrate_domain_aliases(domain, options):
    print "\tMigrating domain aliases"
    old_domain_aliases = pf_models.AliasDomain.objects.using(options._from).filter(target_domain=domain.name)
    for old_da in old_domain_aliases:
        new_da = md_models.DomainAlias()
        new_da.name = old_da.alias_domain
        new_da.target = old_da.target_domain
        new_da.enabled = new_da.active
        new_da.dates = migrate_dates(old_da)
        new_da.save(using=options.to)

def migrate_mailbox_aliases(domain, options):
    print "\tMigrating mailbox aliases"
    old_aliases = pf_models.Alias.objects.using(options._from).filter(domain=domain.name)
    for old_al in old_aliases:
        if old_al.address == old_al.goto:
            continue
        new_al = md_models.Alias()
        local_part, tmp = split_mailbox(old_al.address)
        if local_part is None or not len(local_part):
            if tmp is None or not len(tmp):
                print """Warning: skipping alias %s (cannot retrieve local part).
You will need to recreate it manually.
""" % old_al.address
                continue
            new_al.address = "*"
        else:
            new_al.address = local_part
        new_al.domain = domain
        new_al.enabled = old_al.active
        extmboxes = []
        intmboxes = []
        for goto in old_al.goto.split(","):
            try:
                mb = md_models.Mailbox.objects.using(options.to).get(user__username=goto)
            except md_models.Mailbox.DoesNotExist:
                extmboxes += [goto]
            else:
                intmboxes += [mb]
        new_al.dates = migrate_dates(old_al)
        new_al.save(intmboxes, extmboxes, using=options.to)

def migrate_mailboxes(domain, options):
    print "\tMigrating mailboxes"
    old_mboxes = pf_models.Mailbox.objects.using(options._from).filter(domain=domain.name)
    for old_mb in old_mboxes:
        new_mb = md_models.Mailbox()
        new_mb.address = old_mb.local_part
        new_mb.domain = domain
        new_mb.dates = migrate_dates(old_mb)
        if old_mb.quota:
            new_mb.quota = old_mb.quota / 1024000

        new_mb.path = "%s/" % old_mb.local_part
        if options.rename_dirs:
            oldpath = os.path.join(options.mboxes_path, domain.name, old_mb.maildir)
            newpath = os.path.join(options.mboxes_path, domain.name, new_mb.path)
            code, output = exec_cmd("mv %s %s" % (oldpath, newpath))
            if code:
                print "Error: cannot rename mailbox directory\n%s" % output
                sys.exit(1)

        new_mb.save(name=old_mb.name, password=old_mb.password, using=options.to)


def migrate_domain(old_dom, options):
    print "Migrating domain %s" % old_dom.domain
    newdom = md_models.Domain()
    newdom.name = old_dom.domain
    newdom.enabled = old_dom.active
    newdom.quota = old_dom.maxquota
    newdom.dates = migrate_dates(old_dom)
    newdom.save(using=options.to)
    migrate_mailboxes(newdom, options)
    migrate_mailbox_aliases(newdom, options)
    migrate_domain_aliases(newdom, options)

def migrate_admins(options):
    print "Migrating administrators"

    dagroup = Group.objects.using(options.to).get(name="DomainAdmins")
    for old_admin in pf_models.Admin.objects.using(options._from).all():
        local_part, domname = split_mailbox(old_admin.username)
        try:
            query = Q(username=old_admin.username) & \
                (Q(domain="ALL") | Q(domain=domname))
            creds = pf_models.DomainAdmins.objects.using(options._from).get(query)
        except pf_models.DomainAdmins.DoesNotExist:
            print "Warning: skipping useless admin %s" % (old_admin.username)
            continue
        try:
            user = md_models.User.objects.using(options.to).get(username=old_admin.username)
        except md_models.User.DoesNotExist:
            try:
                domain = md_models.Domain.objects.using(options.to).get(name=domname)
            except md_models.Domain.DoesNotExist:
                print "Warning: skipping domain admin %s, domain not found" \
                    % old_admin.username
                continue
            user = md_models.User()
            user.username = old_admin.username
            user.email = old_admin.username
            user.password = old_admin.password
            user.is_active = old_admin.active
            user.save(using=options.to)

        user.date_joined = old_admin.modified
        if creds.domain == "ALL":
            user.is_superuser = True
        else:
            user.groups.add(dagroup)
        user.save(using=options.to)

def do_migration(options):
    pf_domains = pf_models.Domain.objects.using(options._from).all()
    for olddom in pf_domains:
        if olddom.domain == "ALL":
            continue
        migrate_domain(olddom, options)
    migrate_admins(options)

if __name__ == "__main__":
    from optparse import OptionParser

    parser = OptionParser()
    parser.add_option("-f", "--from", dest="_from", default="pfxadmin",
                      help="Name of postfixadmin db connection declared in settings.py")
    parser.add_option("-t", "--to", default="default",
                      help="Name of the Modoboa db connection declared in settings.py")
    parser.add_option("-r", "--rename-dirs", action="store_true",
                      help="Rename mailbox directories (default is no)")
    parser.add_option("-p", "--mboxes-path", default=None,
                      help="Path where directories are stored on the filesystem (used only if --rename-dirs)")

    options, args = parser.parse_args()

    if options.rename_dirs and options.mboxes_path is None:
        print "Error: you must provide the --mboxes-path option"
        sys.exit(1)

    try:
        do_migration(options)
    except ConnectionDoesNotExist, e:
        print e

########NEW FILE########
__FILENAME__ = models
# coding: utf-8
# This is an auto-generated Django model module.
# You'll have to do the following manually to clean this up:
#     * Rearrange models' order
#     * Make sure each model has one field with primary_key=True
# Feel free to rename the models, but don't rename db_table values or field names.
#
# Also note: You'll have to insert the output of 'django-admin.py sqlcustom [appname]'
# into your database.

from django.db import models

class Admin(models.Model):
    username = models.CharField(max_length=765, primary_key=True)
    password = models.CharField(max_length=765)
    created = models.DateTimeField()
    modified = models.DateTimeField()
    active = models.IntegerField()

    class Meta:
        db_table = u'admin'
        app_label = 'pfxadmin_migrate'
        managed = False


class Alias(models.Model):
    address = models.CharField(max_length=765, primary_key=True)
    goto = models.TextField()
    domain = models.CharField(max_length=765)
    created = models.DateTimeField()
    modified = models.DateTimeField()
    active = models.IntegerField()

    class Meta:
        db_table = u'alias'
        app_label = 'pfxadmin_migrate'
        managed = False


class AliasDomain(models.Model):
    alias_domain = models.CharField(max_length=765, primary_key=True)
    target_domain = models.CharField(max_length=765)
    created = models.DateTimeField()
    modified = models.DateTimeField()
    active = models.IntegerField()

    class Meta:
        db_table = u'alias_domain'
        app_label = 'pfxadmin_migrate'
        managed = False


class Config(models.Model):
    id = models.IntegerField(primary_key=True)
    name = models.CharField(unique=True, max_length=60)
    value = models.CharField(max_length=60)

    class Meta:
        db_table = u'config'
        app_label = 'pfxadmin_migrate'
        managed = False


class Domain(models.Model):
    domain = models.CharField(max_length=765, primary_key=True)
    description = models.CharField(max_length=765)
    aliases = models.IntegerField()
    mailboxes = models.IntegerField()
    maxquota = models.BigIntegerField()
    quota = models.BigIntegerField()
    transport = models.CharField(max_length=765)
    backupmx = models.IntegerField()
    created = models.DateTimeField()
    modified = models.DateTimeField()
    active = models.IntegerField()

    class Meta:
        db_table = u'domain'
        app_label = 'pfxadmin_migrate'
        managed = False


class DomainAdmins(models.Model):
    username = models.CharField(max_length=765)
    domain = models.CharField(max_length=765)
    created = models.DateTimeField(primary_key=True)
    active = models.IntegerField()

    class Meta:
        db_table = u'domain_admins'
        app_label = 'pfxadmin_migrate'
        managed = False


class Fetchmail(models.Model):
    id = models.IntegerField(primary_key=True)
    mailbox = models.CharField(max_length=765)
    src_server = models.CharField(max_length=765)
    src_auth = models.CharField(max_length=33, blank=True)
    src_user = models.CharField(max_length=765)
    src_password = models.CharField(max_length=765)
    src_folder = models.CharField(max_length=765)
    poll_time = models.IntegerField()
    fetchall = models.IntegerField()
    keep = models.IntegerField()
    protocol = models.CharField(max_length=12, blank=True)
    usessl = models.IntegerField()
    extra_options = models.TextField(blank=True)
    returned_text = models.TextField(blank=True)
    mda = models.CharField(max_length=765)
    date = models.DateTimeField()

    class Meta:
        db_table = u'fetchmail'
        app_label = 'pfxadmin_migrate'
        managed = False


class Log(models.Model):
    timestamp = models.DateTimeField()
    username = models.CharField(max_length=765)
    domain = models.CharField(max_length=765)
    action = models.CharField(max_length=765)
    data = models.TextField()

    class Meta:
        db_table = u'log'
        app_label = 'pfxadmin_migrate'
        managed = False


class Mailbox(models.Model):
    username = models.CharField(max_length=765, primary_key=True)
    password = models.CharField(max_length=765)
    name = models.CharField(max_length=765)
    maildir = models.CharField(max_length=765)
    quota = models.BigIntegerField()
    local_part = models.CharField(max_length=765)
    domain = models.CharField(max_length=765)
    created = models.DateTimeField()
    modified = models.DateTimeField()
    active = models.IntegerField()

    class Meta:
        db_table = u'mailbox'
        app_label = 'pfxadmin_migrate'
        managed = False


class Quota(models.Model):
    username = models.CharField(max_length=765, primary_key=True)
    path = models.CharField(max_length=300, primary_key=True)
    current = models.BigIntegerField(null=True, blank=True)

    class Meta:
        db_table = u'quota'
        app_label = 'pfxadmin_migrate'
        managed = False


class Quota2(models.Model):
    username = models.CharField(max_length=300, primary_key=True)
    bytes = models.BigIntegerField()
    messages = models.IntegerField()

    class Meta:
        db_table = u'quota2'
        app_label = 'pfxadmin_migrate'
        managed = False


class Vacation(models.Model):
    email = models.CharField(max_length=765)
    subject = models.CharField(max_length=765)
    body = models.TextField()
    cache = models.TextField()
    domain = models.CharField(max_length=765)
    created = models.DateTimeField()
    active = models.IntegerField()

    class Meta:
        db_table = u'vacation'
        app_label = 'pfxadmin_migrate'
        managed = False


class VacationNotification(models.Model):
    on_vacation = models.ForeignKey(Vacation, db_column='on_vacation')
    notified = models.CharField(max_length=765, primary_key=True)
    notified_at = models.DateTimeField()

    class Meta:
        db_table = u'vacation_notification'
        app_label = 'pfxadmin_migrate'
        managed = False

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include
from django.conf import settings
from modoboa.core.extensions import exts_pool
from modoboa.lib import parameters, events
from modoboa.core import load_core_settings

load_core_settings()

urlpatterns = patterns(
    '',
    (r'^$', 'modoboa.lib.webutils.topredirection'),
    (r'^jsi18n/$', 'django.views.i18n.javascript_catalog',
     {'packages': ('modoboa', ), }),
    ('', include('modoboa.core.urls')),
)

urlpatterns += patterns(
    '',
    *events.raiseQueryEvent("ExtraUprefsRoutes")
)

urlpatterns += patterns(
    '',
    *exts_pool.load_all()
)

parameters.apply_to_django_settings()

if 'modoboa.demo' in settings.INSTALLED_APPS:
    urlpatterns += patterns(
        '',
        (r'^demo/', include('modoboa.demo.urls'))
    )

if settings.DEBUG:
    from django.contrib.staticfiles.urls import staticfiles_urlpatterns
    from django.conf.urls.static import static
    urlpatterns += staticfiles_urlpatterns()
    urlpatterns += static(
        settings.MEDIA_URL, document_root=settings.MEDIA_ROOT
    )

########NEW FILE########
__FILENAME__ = install_from_scratch
# coding: utf-8

import os
import tempfile
import pexpect
import shutil
import unittest
from modoboa.lib.sysutils import exec_cmd


class DeployTest(unittest.TestCase):
    dbtype = "mysql"
    dbhost = "localhost"
    projname = "modoboa_test"
    dbuser = "travis"
    dbpassword = ""

    def setUp(self):
        self.workdir = tempfile.mkdtemp()

    def tearDown(self):
        path = os.path.join(self.workdir, self.projname)
        code, output = exec_cmd("python manage.py test core lib admin limits postfix_relay_domains", cwd=path)
        self.assertEqual(code, 0)

    def test_standard(self):
        timeout = 2
        cmd = "modoboa-admin.py deploy --syncdb --collectstatic %s" % self.projname
        child = pexpect.spawn(cmd, cwd=self.workdir)
        fout = open('install_from_scratch.log','w')
        child.logfile = fout
        child.expect("Database type \(mysql, postgres or sqlite3\):", timeout=timeout)
        child.sendline(self.dbtype)
        child.expect("Database host \(default: 'localhost'\):", timeout=timeout)
        child.sendline(self.dbhost)
        child.expect("Database port \(default: '3306'\):", timeout=timeout)
        child.sendline('3306')
        child.expect("Database name:", timeout=timeout)
        child.sendline(self.projname)
        child.expect("Username:", timeout=timeout)
        child.sendline(self.dbuser)
        child.expect("Password:", timeout=timeout)
        child.sendline(self.dbpassword)
        child.expect("Under which domain do you want to deploy modoboa?", timeout=timeout)
        child.sendline("localhost")
        child.wait()
        fout.close()
        self.assertEqual(child.exitstatus, 0)

    def test_silent(self):
        dburl = "%s://%s:%s@%s/%s" \
            % (self.dbtype, self.dbuser, self.dbpassword,
               self.dbhost, self.projname)
        cmd = "modoboa-admin.py deploy --syncdb --collectstatic --dburl %s --domain %s %s" \
            % (dburl, 'localhost', self.projname)
        code, output = exec_cmd(cmd, cwd=self.workdir)
        self.assertEqual(code, 0)


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
