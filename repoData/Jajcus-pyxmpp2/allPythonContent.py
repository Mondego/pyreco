__FILENAME__ = htmlmerge
#!/usr/bin/python

import libxml2
import sys


class Merger:
    def __init__(self,template_file,content_file):
        self.template_doc=libxml2.parseFile(template_file)
        self.content_doc=libxml2.parseFile(content_file)
    def merge(self):
        output_doc=self.template_doc.copyDoc(True)
        slot=output_doc.xpathEval('//*[@id="main"]')[0]
        content=self.content_doc.xpathEval('//*[@class="document"]/*')
        for node in content:
            nn=slot.addChild(node.copyNode(True))
        output_doc.getRootElement().reconciliateNs(output_doc)
        return output_doc

m=Merger(sys.argv[1],sys.argv[2])
out=m.merge()
print out.serialize(format=True)
# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = make_conformance_table
#!/usr/bin/python

"""Fetch an XMPP RFC and build a reStructuredText table with the
conformance features sets"""

import argparse
import re
import textwrap
import itertools

from urlparse import urljoin

from lxml import etree
from lxml import html

ROLES_RE = re.compile(r"Client ([^.,]*), Server ([^.,]*)|Both ([^.,]*)")


class Feature(object):
    def __init__(self, name, descr, url, client, server):
        self.name = name
        self.descr = descr
        self.url = url
        self.client = client
        self.server = server

    @classmethod
    def from_element(cls, element, base_url):
        r = element.xpath("dt[text()='Feature:']/following-sibling::dd[1]")
        name = r[0].text.strip()
        r = element.xpath("dt[text()='Description:']/following-sibling::dd[1]")
        descr = r[0].text.strip()
        r = element.xpath("dt[text()='Section:']/following-sibling::dd[1]/a")
        url = urljoin(base_url, r[0].get("href"))
        r = element.xpath("dt[text()='Roles:']/following-sibling::dd[1]")
        match = ROLES_RE.match(r[0].text)
        if match.group(3):
            client = match.group(3)
            server = match.group(3)
        else:
            client = match.group(1)
            server = match.group(2)
        return cls(name, descr, url, client, server)

    def __unicode__(self):
        return u"""Feature: {0.name}
Description: {0.descr}
URL: {0.url}
Client: {0.client}
Server: {0.server}
""".format(self)

def print_grid_table(features, add_notes = False):
    feature_width = 10
    descr_width = 40
    role_width = 6
    for feature in features:
        if len(feature.name) + 3 > feature_width:
            feature_width = len(feature.name) + 3


    rule = ("+" + (feature_width + 2) * "-" + "+" + (descr_width + 2) * "-" +
            "+" + (role_width + 2) * "-" + "+" + (role_width + 2) * "-" + "+")
    print
    print rule
    print u"| {0} | {1} | {2} | {3} |".format("Feature".ljust(feature_width),
            "Description".ljust(descr_width), "Client".ljust(role_width),
            "Server".ljust(role_width)).encode("utf-8")
    print rule.replace("-", "=")
    for feature in features:
        name_l = [ "`{0}`_".format(feature.name) ]
        desc_l = textwrap.wrap(feature.descr, descr_width)

        height = max(len(name_l), len(desc_l))
        name_i = itertools.chain(name_l, itertools.repeat(u""))
        desc_i = itertools.chain(desc_l, itertools.repeat(u""))
        client_i = itertools.chain([feature.client], itertools.repeat(u""))
        server_i = itertools.chain([feature.server], itertools.repeat(u""))
       
        for i in xrange(height):
            print u"| {0} | {1} | {2} | {3} |".format(
                    name_i.next().ljust(feature_width),
                    desc_i.next().ljust(descr_width),
                    client_i.next().ljust(role_width),
                    server_i.next().ljust(role_width)).encode("utf-8")
        print rule
    print

def print_list_table(features, add_notes = False):
    print
    print ".. list-table::"
    print "   :widths: 10 40 8 8 34"
    print "   :header-rows: 1"
    print 
    print "   * - Feature"
    print "     - Description"
    print "     - Client"
    print "     - Server"
    if add_notes:
        print "     - Notes"
    for feature in features:
        print u"   * - `{0}`_".format(feature.name).encode("utf-8")
        print u"     - {0}".format(feature.descr).encode("utf-8")
        print u"     - {0}".format(feature.client).encode("utf-8")
        print u"     - {0}".format(feature.server).encode("utf-8")
        if add_notes:
            print "     - "
    print


def main():
    arg_parser = argparse.ArgumentParser(
                                    description = 'Conformance table builder')
    arg_parser.add_argument('rfc', help = "RFC number or URL"
                                            " (the xmpp.org HTML RFCs only)")
    arg_parser.add_argument('--list', help = "Use list format",
                    action = 'store_const', const = 'list', dest = 'mode',
                    default = 'grid')
    arg_parser.add_argument('--blank', help = "Leave empty 'role' fields",
                                                        action = 'store_true')
    arg_parser.add_argument('--notes', help = "Add a 'notes' column",
                                                        action = 'store_true')
    args = arg_parser.parse_args()
    try:
        int(args.rfc)
        rfc_url = "http://xmpp.org/rfcs/rfc{0}.html".format(args.rfc)
    except ValueError:
        rfc_url = args.rfc

    tree = html.parse(rfc_url)
    feature_elements = tree.xpath("//dl[dt='Feature:']")
    features = [Feature.from_element(e, rfc_url) for e in feature_elements]

    if args.blank:
        for feature in features:
            if feature.client != "N/A":
                feature.client = ""
            if feature.server != "N/A":
                feature.server = ""

    if args.mode == "list":
        print_list_table(features, args.notes)
    else:
        print_grid_table(features, args.notes)

    for feature in features:
        print u".. _{0}: {1}".format(feature.name, feature.url)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = fix_docstrings

from lib2to3 import fixer_base, pytree
from lib2to3.pgen2 import token

def is_docstring(stmt):
    if isinstance(stmt, pytree.Node) and \
            stmt.children[0].type == token.STRING:
                return True
    return None

class FixDocstrings(fixer_base.BaseFix):
    PATTERN = 'simple_stmt' 
    def transform(self, node, results):
        if not is_docstring(node):
            return
        new = node.clone()
        old_s = node.children[0].value
        new_s = old_s.replace("`unicode`", "`str`")
        if old_s == new_s:
            return
        new.children[0].value = new_s
        return new

########NEW FILE########
__FILENAME__ = fix_rename_unicode
"""
Taken from: http://lucumr.pocoo.org/2010/2/11/porting-to-python-3-a-guide/
"""
from lib2to3 import fixer_base
from lib2to3.fixer_util import Name

class FixRenameUnicode(fixer_base.BaseFix):
    PATTERN = r"funcdef< 'def' name='__unicode__' parameters< '(' NAME ')' > any+ >"

    def transform(self, node, results):
        name = results['name']
        name.replace(Name('__str__', prefix=name.prefix))

########NEW FILE########
__FILENAME__ = make_settings_doc
#!/usr/bin/python

from glob import glob
import codecs

import pyxmpp2
from pyxmpp2.settings import XMPPSettings

def import_modules():
    base = pyxmpp2.__path__[0]
    for filename in glob(base + "/*.py") + glob(base + "/*/*.py"):
        try:
            module_name = "pyxmpp2" + filename[len(base):-3].replace("/", ".")
            __import__(module_name)
        except ImportError:
            pass

def type_string(type_spec):
    if isinstance(type_spec, basestring):
        return type_spec
    try:
        if type_spec.__module__ == '__builtin__':
            return u"``{0}``".format(type_spec.__name__)
        if hasattr(type_spec, "im_class"):
            klass = type_spec.im_class
            type_name = u".".join((klass.__module__, klass.__name__,
                                                        type_spec.__name__))
        else:
            type_name = u".".join((type_spec.__module__, type_spec.__name__))
        if type_name.startswith(u"pyxmpp2."):
            return u"`{0}`".format(type_name)
        else:
            return u":std:`{0}`".format(type_name)
    except AttributeError:
        return u"`{0}`".format(type_spec.__name__)

def default_string(setting):
    if setting.default_d:
        return setting.default_d
    if setting.default is not None:
        default = setting.default
    elif setting.factory:
        default = setting.factory(XMPPSettings())
    else:
        return u"``None``"
    return u"``{0!r}``".format(default)

def cmdline_string(setting):
    option = setting.name.replace("_", "-")
    if setting.type is bool:
        return "--{0} | --no-{0}".format(option)
    else:
        return "--{0} {1}".format(option, setting.name.upper())

def dump_settings_group(doc, index, settings):
    for setting in settings:
        print >> doc
        #print >> doc, u".. _{0}:".format(setting.name)
        #print >> doc
        print >> doc, setting.name
        print >> doc, u"." * len(setting.name)
        print >> doc
        print >> doc, u"  * Type: {0}".format(type_string(setting.type))
        print >> doc, u"  * Default: {0}".format(default_string(setting))
        if setting.cmdline_help:
            print >> doc, u"  * Command line: ``{0}``".format(cmdline_string(
                                                                    setting))
        print >> doc
        print >> doc, setting.doc
        print >> index, u'{0} setting\t#{1}'.format(
                        setting.name, setting.name.replace("_", "-"))

def dump_settings(doc, index):
    basic_settings = [ x for x in XMPPSettings._defs.values() if x.basic ]
    basic_settings = sorted(basic_settings, key = lambda x: x.name)
    extra_settings = [ x for x in XMPPSettings._defs.values() if not x.basic ]
    extra_settings = sorted(extra_settings, key = lambda x: x.name)

    print >> index, "settings list\t#"

    print >> doc, ".. default-role:: pyxmpp2"
    print >> doc
    print >> doc, "PyXMPP2 Settings"
    print >> doc, "================"
    print >> doc
    print >> doc, u"Basic Settings"
    print >> doc, u"--------------"
    print >> doc
    print >> doc, u"It is recommended these settings can be configured by the"
    print >> doc, u"end user, as they may be required for correct operation with"
    print >> doc, u"a specific service"
    dump_settings_group(doc, index, basic_settings)

    print >> doc
    print >> doc, u"Extra Settings"
    print >> doc, u"--------------"
    print >> doc
    print >> doc, u"These settings can even further change the PyXMPP"
    print >> doc, u" behaviour, but in most cases there is no need to set them."
    dump_settings_group(doc, index, extra_settings)

if __name__ == "__main__":
    import_modules()
    with codecs.open("Settings.rst", "w", encoding = "utf-8") as doc:
        with codecs.open("settings.txt", "w", encoding = "utf-8") as index:
            dump_settings(doc, index)


########NEW FILE########
__FILENAME__ = check_version
#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
Example of using the pyxmpp2.ext.version module to request version information
from the remote entity.
"""

import sys
import logging
from getpass import getpass
import argparse

from pyxmpp2.jid import JID
from pyxmpp2.ext.version import request_software_version
from pyxmpp2.client import Client
from pyxmpp2.settings import XMPPSettings
from pyxmpp2.interfaces import EventHandler, event_handler, QUIT
from pyxmpp2.streamevents import AuthorizedEvent, DisconnectedEvent

class VersionChecker(EventHandler):
    """Version checker implementation."""
    def __init__(self, my_jid, target_jid, settings):
        self.client = Client(my_jid, [self], settings)
        self.target_jid = target_jid

    def run(self):
        """Request client connection and start the main loop."""
        self.client.connect()
        self.client.run()

    def disconnect(self):
        """Request disconnection and let the main loop run for a 2 more
        seconds for graceful disconnection."""
        self.client.disconnect()
        self.client.run(timeout = 2)

    @event_handler(AuthorizedEvent)
    def handle_authorized(self, event):
        """Send the initial presence after log-in."""
        request_software_version(self.client, self.target_jid,
                                        self.success, self.failure)

    def success(self, version):
        print("Name: {0}".format(version.name))
        print("Version: {0}".format(version.version))
        if version.os_name is not None:
            print("Operating System: {0}".format(version.os_name))
        else:
            print("Operating System name not available")
        self.client.disconnect()

    def failure(self, stanza):
        print("Version query failed")
        if stanza and stanza.stanza_type == "error":
            cond_name = stanza.error.condition_name
            text = stanza.error.text
            if text:
                print("Error: {0} ({1})".format(cond_name, text))
            else:
                print("Error: {0}".format(cond_name))
        self.client.disconnect()

    @event_handler(DisconnectedEvent)
    def handle_disconnected(self, event):
        """Quit the main loop upon disconnection."""
        return QUIT
    
def main():
    """Parse the command-line arguments and run the tool."""
    parser = argparse.ArgumentParser(description = 'XMPP version checker',
                                    parents = [XMPPSettings.get_arg_parser()])
    parser.add_argument('source', metavar = 'SOURCE', 
                                        help = 'Source JID')
    parser.add_argument('target', metavar = 'TARGET', nargs = '?',
                            help = 'Target JID (default: domain of SOURCE)')
    parser.add_argument('--debug',
                        action = 'store_const', dest = 'log_level',
                        const = logging.DEBUG, default = logging.INFO,
                        help = 'Print debug messages')
    parser.add_argument('--quiet', const = logging.ERROR,
                        action = 'store_const', dest = 'log_level',
                        help = 'Print only error messages')
    args = parser.parse_args()
    settings = XMPPSettings()
    settings.load_arguments(args)
    
    if settings.get("password") is None:
        password = getpass("{0!r} password: ".format(args.source))
        if sys.version_info.major < 3:
            password = password.decode("utf-8")
        settings["password"] = password

    if sys.version_info.major < 3:
        args.source = args.source.decode("utf-8")

    source = JID(args.source)

    if args.target:
        if sys.version_info.major < 3:
            args.target = args.target.decode("utf-8")
        target = JID(args.target)
    else:
        target = JID(source.domain)

    logging.basicConfig(level = args.log_level)

    checker = VersionChecker(source, target, settings)
    try:
        checker.run()
    except KeyboardInterrupt:
        checker.disconnect()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = echobot
#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
An 'echo bot' â€“ simple client that just confirms any presence subscriptions
and echoes incoming messages.
"""

import sys
import logging
from getpass import getpass
import argparse

from pyxmpp2.jid import JID
from pyxmpp2.message import Message
from pyxmpp2.presence import Presence
from pyxmpp2.client import Client
from pyxmpp2.settings import XMPPSettings
from pyxmpp2.interfaces import EventHandler, event_handler, QUIT
from pyxmpp2.streamevents import AuthorizedEvent, DisconnectedEvent
from pyxmpp2.interfaces import XMPPFeatureHandler
from pyxmpp2.interfaces import presence_stanza_handler, message_stanza_handler
from pyxmpp2.ext.version import VersionProvider

class EchoBot(EventHandler, XMPPFeatureHandler):
    """Echo Bot implementation."""
    def __init__(self, my_jid, settings):
        version_provider = VersionProvider(settings)
        self.client = Client(my_jid, [self, version_provider], settings)

    def run(self):
        """Request client connection and start the main loop."""
        self.client.connect()
        self.client.run()

    def disconnect(self):
        """Request disconnection and let the main loop run for a 2 more
        seconds for graceful disconnection."""
        self.client.disconnect()
        self.client.run(timeout = 2)

    @presence_stanza_handler("subscribe")
    def handle_presence_subscribe(self, stanza):
        logging.info(u"{0} requested presence subscription"
                                                    .format(stanza.from_jid))
        presence = Presence(to_jid = stanza.from_jid.bare(),
                                                    stanza_type = "subscribe")
        return [stanza.make_accept_response(), presence]

    @presence_stanza_handler("subscribed")
    def handle_presence_subscribed(self, stanza):
        logging.info(u"{0!r} accepted our subscription request"
                                                    .format(stanza.from_jid))
        return True

    @presence_stanza_handler("unsubscribe")
    def handle_presence_unsubscribe(self, stanza):
        logging.info(u"{0} canceled presence subscription"
                                                    .format(stanza.from_jid))
        presence = Presence(to_jid = stanza.from_jid.bare(),
                                                    stanza_type = "unsubscribe")
        return [stanza.make_accept_response(), presence]

    @presence_stanza_handler("unsubscribed")
    def handle_presence_unsubscribed(self, stanza):
        logging.info(u"{0!r} acknowledged our subscrption cancelation"
                                                    .format(stanza.from_jid))
        return True

    @message_stanza_handler()
    def handle_message(self, stanza):
        """Echo every non-error ``<message/>`` stanza.
        
        Add "Re: " to subject, if any.
        """
        if stanza.subject:
            subject = u"Re: " + stanza.subject
        else:
            subject = None
        msg = Message(stanza_type = stanza.stanza_type,
                        from_jid = stanza.to_jid, to_jid = stanza.from_jid,
                        subject = subject, body = stanza.body,
                        thread = stanza.thread)
        return msg

    @event_handler(DisconnectedEvent)
    def handle_disconnected(self, event):
        """Quit the main loop upon disconnection."""
        return QUIT
    
    @event_handler()
    def handle_all(self, event):
        """Log all events."""
        logging.info(u"-- {0}".format(event))

def main():
    """Parse the command-line arguments and run the bot."""
    parser = argparse.ArgumentParser(description = 'XMPP echo bot',
                                    parents = [XMPPSettings.get_arg_parser()])
    parser.add_argument('jid', metavar = 'JID', 
                                        help = 'The bot JID')
    parser.add_argument('--debug',
                        action = 'store_const', dest = 'log_level',
                        const = logging.DEBUG, default = logging.INFO,
                        help = 'Print debug messages')
    parser.add_argument('--quiet', const = logging.ERROR,
                        action = 'store_const', dest = 'log_level',
                        help = 'Print only error messages')
    parser.add_argument('--trace', action = 'store_true',
                        help = 'Print XML data sent and received')

    args = parser.parse_args()
    settings = XMPPSettings({
                            "software_name": "Echo Bot"
                            })
    settings.load_arguments(args)

    if settings.get("password") is None:
        password = getpass("{0!r} password: ".format(args.jid))
        if sys.version_info.major < 3:
            password = password.decode("utf-8")
        settings["password"] = password

    if sys.version_info.major < 3:
        args.jid = args.jid.decode("utf-8")

    logging.basicConfig(level = args.log_level)
    if args.trace:
        print "enabling trace"
        handler = logging.StreamHandler()
        handler.setLevel(logging.DEBUG)
        for logger in ("pyxmpp2.IN", "pyxmpp2.OUT"):
            logger = logging.getLogger(logger)
            logger.setLevel(logging.DEBUG)
            logger.addHandler(handler)
            logger.propagate = False

    bot = EchoBot(JID(args.jid), settings)
    try:
        bot.run()
    except KeyboardInterrupt:
        bot.disconnect()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = roster
#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
A roster interface example.

Usage:

    roster.py JID show [--presence]

    roster.py JID monitor [--presence]

    roster.py JID add [--subscribe] [--approve] CONTACT [NAME] [GROUP ...]

    roster.py JID remove CONTACT

    roster.py JID update CONTACT [NAME] [GROUP [GROUP ...]]

        positional arguments:
            CONTACT     The JID to add
            NAME        Contact name
            GROUP       Group names

    roster.py --help 

        for the general help
"""

import os
import sys
import logging
from getpass import getpass
import argparse

from collections import defaultdict

from pyxmpp2.jid import JID
from pyxmpp2.presence import Presence
from pyxmpp2.client import Client
from pyxmpp2.settings import XMPPSettings
from pyxmpp2.interfaces import EventHandler, event_handler, QUIT
from pyxmpp2.interfaces import XMPPFeatureHandler, presence_stanza_handler
from pyxmpp2.streamevents import AuthorizedEvent, DisconnectedEvent
from pyxmpp2.roster import RosterReceivedEvent, RosterUpdatedEvent

class RosterTool(EventHandler, XMPPFeatureHandler):
    """Echo Bot implementation."""
    def __init__(self, my_jid, args, settings):
        self.args = args
        self.client = Client(my_jid, [self], settings)
        self.presence = defaultdict(dict)

    def run(self):
        """Request client connection and start the main loop."""
        if self.args.roster_cache and os.path.exists(self.args.roster_cache):
            logging.info(u"Loading roster from {0!r}"
                                            .format(self.args.roster_cache))
            try:
                self.client.roster_client.load_roster(self.args.roster_cache)
            except (IOError, ValueError), err:
                logging.error(u"Could not load the roster: {0!r}".format(err))
        self.client.connect()
        self.client.run()

    def disconnect(self):
        """Request disconnection and let the main loop run for a 2 more
        seconds for graceful disconnection.
        """
        self.client.disconnect()
        self.client.run(timeout = 2)

    def print_item(self, item):
        print u"    JID: {0}".format(item.jid)
        if item.name is not None:
            print u"    Name: {0}".format(item.name)
        print u"    Subscription: {0}".format(item.subscription)
        if item.ask:
            print u"    Pending {0}".format(item.ask)
        if item.approved:
            print u"    Approved"
        if item.groups:
            groups = u",".join(
                            [u"'{0}'".format(g) for g in item.groups])
            print u"    Groups: {0}".format(groups)
        if not self.args.presence:
            return
        presences = self.presence.get(item.jid)
        if not presences:
            print u"    OFFLINE"
        else:
            print u"    ONLINE:"
            for jid, presence in presences.items():
                if presence.show:
                    show = u": [{0}]".format(presence.show)
                elif not presence.status:
                    show = u""
                else:
                    show = u":"
                if presence.status:
                    status = u" '{0}'".format(presence.status)
                else:
                    status = u""
                print u"      /{0}{1}{2}".format(jid.resource, show, status)

    @event_handler(RosterReceivedEvent)
    def handle_roster_received(self, event):
        if self.args.action == "show":
            if self.args.presence:
                logging.info(u"Waiting for incoming presence information...")
                self.client.main_loop.delayed_call(5, self.delayed_show)
            else:
                self.print_roster()
                self.client.disconnect()
        elif self.args.action == "monitor":
            self.print_roster()
        elif self.args.action == "add":
            self.add_contact()
        elif self.args.action == "remove":
            self.remove_contact()
        elif self.args.action == "update":
            self.update_contact()
        else:
            self.client.disconnect()

    def delayed_show(self):
        self.print_roster()
        self.client.disconnect()

    def print_roster(self):
        roster = self.client.roster  # event.roster would also do
        print "Roster received:"
        if roster.version is None:
            print u"  (not versioned)"
        else:
            print u"  Version: '{0}'".format(roster.version)
        if len(roster):
            print u"  Items:"
            for item in roster.values():
                self.print_item(item)
                print
        else:
            print "  Empty"
            print

    def add_contact(self):
        roster_client = self.client.roster_client
        roster_client.add_item(jid = JID(self.args.contact),
                name = self.args.name, groups = self.args.groups,
                                        callback = self._add_success,
                                            error_callback = self._add_error)
        if self.args.subscribe:
            presence = Presence(to_jid = self.args.contact,
                                            stanza_type = 'subscribe')
            self.client.send(presence)
        if self.args.approve:
            if "pre-approvals" not in roster_client.server_features:
                logging.error("Subscription pre-approvals not available")
            else:
                presence = Presence(to_jid = self.args.contact,
                                                stanza_type = 'subscribed')
                self.client.send(presence)

    def _add_success(self, item):
        print "Roster item added: {0}".format(item.jid)
        self.client.disconnect()

    def _add_error(self, stanza):
        if stanza:
            error = stanza.error
            if error.text:
                print "Roster item add failed: {0}".format(
                                                        error.condition_name)
            else:
                print "Roster item add failed: {0} ({1})".format(
                                            error.condition_name, error.text)
        else:
            print "Roster item add failed: timeout"
        self.client.disconnect()

    def update_contact(self):
        roster_client = self.client.roster_client
        roster_client.update_item(jid = JID(self.args.contact),
                name = self.args.name, groups = self.args.groups,
                                        callback = self._update_success,
                                            error_callback = self._update_error)

    def _update_success(self, item):
        print "Roster item updateed: {0}".format(item.jid)
        self.client.disconnect()

    def _update_error(self, stanza):
        if stanza:
            error = stanza.error
            if error.text:
                print "Roster item update failed: {0}".format(
                                                        error.condition_name)
            else:
                print "Roster item update failed: {0} ({1})".format(
                                            error.condition_name, error.text)
        else:
            print "Roster item update failed: timeout"
        self.client.disconnect()

    def remove_contact(self):
        roster_client = self.client.roster_client
        roster_client.remove_item(jid = JID(self.args.contact),
                                        callback = self._rm_success,
                                            error_callback = self._rm_error)

    def _rm_success(self, item):
        print "Roster item removed: {0}".format(item.jid)
        self.client.disconnect()

    def _rm_error(self, stanza):
        if stanza:
            error = stanza.error
            if error.text:
                print "Roster item remove failed: {0}".format(
                                                        error.condition_name)
            else:
                print "Roster item remove failed: {0} ({1})".format(
                                            error.condition_name, error.text)
        else:
            print "Roster item remove failed: timeout"
        self.client.disconnect()

    @event_handler(RosterUpdatedEvent)
    def handle_roster_update(self, event):
        if self.args.action != "monitor":
            return
        item = event.item
        if item.subscription == "remove":
            print u"Item removed:"
            print u"  JID: {0}".format(item.jid)
        else:
            if event.old_item:
                print u"Item modified:"
            else:
                print u"Item added:"
            print u"  JID: {0}".format(item.jid)
            self.print_item(item)
        print
    
    @event_handler(DisconnectedEvent)
    def handle_disconnected(self, event):
        if self.client.roster and self.args.roster_cache:
            logging.info(u"Saving roster to {0!r}"
                                            .format(self.args.roster_cache))
            self.client.roster_client.save_roster(self.args.roster_cache)
        return QUIT

    @event_handler()
    def handle_all(self, event):
        """Log all events."""
        logging.info(u"-- {0}".format(event))

    @presence_stanza_handler()
    def handle_available_presence(self, stanza):
        jid = stanza.from_jid
        self.presence[jid.bare()][jid] = stanza
        if self.args.action != "monitor":
            return
        if not self.args.presence:
            return
        print u"Presence change:"
        if stanza.show:
            show = u": [{0}]".format(stanza.show)
        elif not stanza.status:
            show = u""
        else:
            show = u":"
        if stanza.status:
            status = u" '{0}'".format(stanza.status)
        else:
            status = u""
        print u"  {0} is now ONLINE{1}{2}".format(jid, show, status)
        print
    
    @presence_stanza_handler("unavailable")
    def handle_unavailable_presence(self, stanza):
        jid = stanza.from_jid
        self.presence[jid.bare()].pop(jid, None)

        if self.args.action != "monitor":
            return
        if not self.args.presence:
            return
        print u"Presence change:"
        if stanza.status:
            status = u": '{0}'".format(stanza.status)
        else:
            status = u""
        print u"  {0} is now OFFLINE{1}".format(jid, status)
        print
 
def main():
    """Parse the command-line arguments and run the bot."""
    parser = argparse.ArgumentParser(description = 'XMPP echo bot',
                                    parents = [XMPPSettings.get_arg_parser()])
    parser.add_argument('--debug',
                        action = 'store_const', dest = 'log_level',
                        const = logging.DEBUG, default = logging.INFO,
                        help = 'Print debug messages')
    parser.add_argument('--quiet', const = logging.ERROR,
                        action = 'store_const', dest = 'log_level',
                        help = 'Print only error messages')
    parser.add_argument('--trace', action = 'store_true',
                        help = 'Print XML data sent and received')
    parser.add_argument('--roster-cache', 
                        help = 'Store roster in this file')
    parser.add_argument('jid', metavar = 'JID', 
                                        help = 'The bot JID')
    subparsers = parser.add_subparsers(help = 'Action', dest = "action")
    show_p = subparsers.add_parser('show', help = 'Show roster and exit')
    show_p.add_argument('--presence', action = 'store_true',
                        help = 'Wait 5 s for contact presence information'
                                ' and display it with the roster')
    mon_p = subparsers.add_parser('monitor', help = 
                                        'Show roster and subsequent changes')
    mon_p.add_argument('--presence', action = 'store_true',
                        help = 'Show contact presence changes too')
    add_p = subparsers.add_parser('add', help = 'Add an item to the roster')
    add_p.add_argument('--subscribe', action = 'store_true', dest = 'subscribe',
                        help = 'Request a presence subscription too')
    add_p.add_argument('--approve', action = 'store_true', dest = 'approve',
                        help = 'Pre-approve subscription from the contact'
                                                ' (requires server support)')
    add_p.add_argument('contact', metavar = 'CONTACT', help = 'The JID to add')
    add_p.add_argument('name', metavar = 'NAME', nargs = '?',
                                            help = 'Contact name')
    add_p.add_argument('groups', metavar = 'GROUP', nargs = '*',
                                            help = 'Group names')
    rm_p = subparsers.add_parser('remove',
                                    help = 'Remove an item from the roster')
    rm_p.add_argument('contact', metavar = 'CONTACT',
                                    help = 'The JID to remove')
    upd_p = subparsers.add_parser('update', 
                                    help = 'Update an item in the roster')
    upd_p.add_argument('contact', metavar = 'CONTACT',
                                    help = 'The JID to update')
    upd_p.add_argument('name', metavar = 'NAME', nargs = '?',
                                            help = 'Contact name')
    upd_p.add_argument('groups', metavar = 'GROUP', nargs = '*',
                                            help = 'Group names')

    args = parser.parse_args()
    settings = XMPPSettings()
    settings.load_arguments(args)

    if settings.get("password") is None:
        password = getpass("{0!r} password: ".format(args.jid))
        if sys.version_info.major < 3:
            password = password.decode("utf-8")
        settings["password"] = password

    if sys.version_info.major < 3:
        args.jid = args.jid.decode("utf-8")
        if getattr(args, "contact", None):
            args.contact = args.contact.decode("utf-8")
        if getattr(args, "name", None):
            args.name = args.name.decode("utf-8")
        if getattr(args, "groups", None):
            args.groups = [g.decode("utf-8") for g in args.groups]

    logging.basicConfig(level = args.log_level)
    if args.trace:
        print "enabling trace"
        handler = logging.StreamHandler()
        handler.setLevel(logging.DEBUG)
        for logger in ("pyxmpp2.IN", "pyxmpp2.OUT"):
            logger = logging.getLogger(logger)
            logger.setLevel(logging.DEBUG)
            logger.addHandler(handler)
            logger.propagate = False
           
    if args.action == "monitor" or args.action == "show" and args.presence:
        # According to RFC6121 it could be None for 'monitor' (no need to send
        # initial presence to request roster), but Google seems to require that
        # to send roster pushes
        settings["initial_presence"] = Presence(priority = -1)
    else:
        settings["initial_presence"] = None

    tool = RosterTool(JID(args.jid), args, settings)
    try:
        tool.run()
    except KeyboardInterrupt:
        tool.disconnect()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = send_message_client
#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
A simple client example.

The script asks for a sender JID and password, target JID and a message.
Then, it connects to the sender's server and sends the message to the target
JID.
"""

import sys
import logging
from getpass import getpass

from pyxmpp2.jid import JID
from pyxmpp2.message import Message
from pyxmpp2.client import Client
from pyxmpp2.settings import XMPPSettings
from pyxmpp2.interfaces import EventHandler, event_handler, QUIT
from pyxmpp2.streamevents import AuthorizedEvent, DisconnectedEvent

class MyHandler(EventHandler):
    def __init__(self, target_jid, message):
        self.target_jid = target_jid
        self.message = message

    @event_handler(AuthorizedEvent)
    def handle_authorized(self, event):
        message = Message(to_jid = self.target_jid, body = self.message)
        event.stream.send(message)
        event.stream.disconnect()

    @event_handler(DisconnectedEvent)
    def handle_disconnected(self, event):
        return QUIT
    
    @event_handler()
    def handle_all(self, event):
        logging.info(u"-- {0}".format(event))

logging.basicConfig(level = logging.INFO) # change to 'DEBUG' to see more

your_jid = raw_input("Your jid: ")
your_password = getpass("Your password: ")
target_jid = raw_input("Target jid: ")
message = raw_input("Message: ")

if sys.version_info.major < 3:
    your_jid = your_jid.decode("utf-8")
    your_password = your_password.decode("utf-8")
    target_jid = target_jid.decode("utf-8")
    message = message.decode("utf-8")

handler = MyHandler(JID(target_jid), message)
settings = XMPPSettings({
                            u"password": your_password,
                            u"starttls": True,
                            u"tls_verify_peer": False,
                        })
client = Client(JID(your_jid), [handler], settings)
client.connect()
client.run()


########NEW FILE########
__FILENAME__ = simple_send_message
#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
Example of the 'simple API' usage.

The simplest possible way to send an XMPP message.
"""

from getpass import getpass
from pyxmpp2.simple import send_message

your_jid = raw_input("Your jid: ")
your_password = getpass("Your password: ")
target_jid = raw_input("Target jid: ")
message = raw_input("Message: ")
    
send_message(your_jid, your_password, target_jid, message)

########NEW FILE########
__FILENAME__ = binding
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# pylint: disable-msg=W0201

"""Resource binding implementation.

Normative reference:
  - `RFC 6120 <http://xmpp.org/rfcs/rfc6120.html>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import logging
import uuid

from .etree import ElementTree, element_to_unicode

from .constants import BIND_QNP
from .settings import XMPPSettings
from .streamevents import BindingResourceEvent, AuthorizedEvent
from .exceptions import ResourceConstraintProtocolError, JIDError
from .exceptions import BadRequestProtocolError, FatalStreamError
from .iq import Iq
from .jid import JID
from .interfaces import XMPPFeatureHandler
from .interfaces import iq_set_stanza_handler
from .interfaces import StanzaPayload, payload_element_name
from .interfaces import StreamFeatureHandler, StreamFeatureHandled

logger = logging.getLogger("pyxmpp2.binding")


FEATURE_BIND = BIND_QNP + u"bind"
BIND_JID_TAG = BIND_QNP + u"jid"
BIND_RESOURCE_TAG = BIND_QNP + u"resource"

@payload_element_name(FEATURE_BIND)
class ResourceBindingPayload(StanzaPayload):
    """Resource binding <iq/> stanza payload.

    :Ivariables:
        - `jid`: content of the <jid/> child element
        - `resource`: content of the <resource/> child element
    :Types:
        - `jid`: `JID`
        - `resource`: `unicode`
    """
    def __init__(self, jid = None, resource = None):
        self.jid = jid
        self.resource = resource

    @classmethod
    def from_xml(cls, element):
        jid = None
        resource = None
        for child in element:
            if child.tag == BIND_JID_TAG:
                if jid:
                    raise BadRequestProtocolError(
                                "<bind/> contains multiple <jid/> elements")
                jid = JID(child.text)
            if child.tag == BIND_RESOURCE_TAG:
                if resource:
                    raise BadRequestProtocolError(
                            "<bind/> contains multiple <resource/> elements")
                resource = child.text
        return cls(jid, resource)

    def as_xml(self):
        element = ElementTree.Element(FEATURE_BIND)
        if self.jid:
            sub = ElementTree.SubElement(element, BIND_JID_TAG)
            sub.text = unicode(self.jid)
        if self.resource:
            sub = ElementTree.SubElement(element, BIND_RESOURCE_TAG)
            sub.text = self.resource
        return element

class ResourceBindingHandler(StreamFeatureHandler, XMPPFeatureHandler):
    """Resource binding implementation.

    Can handle only one stream at time.

    To be used e.g. as one of the handlers passed to a client class
    constructor.
    """
    def __init__(self, settings = None):
        self.stream = None
        self.settings = settings if settings else XMPPSettings()

    def make_stream_features(self, stream, features):
        """Add resource binding feature to the <features/> element of the
        stream.

        [receving entity only]

        :returns: update <features/> element.
        """
        self.stream = stream
        if stream.peer_authenticated and not stream.peer.resource:
            ElementTree.SubElement(features, FEATURE_BIND)

    def handle_stream_features(self, stream, features):
        """Process incoming <stream:features/> element.

        [initiating entity only]

        The received features element is available in `features`.
        """
        logger.debug(u"Handling stream features: {0}".format(
                                        element_to_unicode(features)))
        element = features.find(FEATURE_BIND)
        if element is None:
            logger.debug("No <bind/> in features")
            return None
        resource = stream.settings["resource"]
        self.bind(stream, resource)
        return StreamFeatureHandled("Resource binding", mandatory = True)

    def bind(self, stream, resource):
        """Bind to a resource.

        [initiating entity only]

        :Parameters:
            - `resource`: the resource name to bind to.
        :Types:
            - `resource`: `unicode`

        XMPP stream is authenticated for bare JID only. To use
        the full JID it must be bound to a resource.
        """
        self.stream = stream
        stanza = Iq(stanza_type = "set")
        payload = ResourceBindingPayload(resource = resource)
        stanza.set_payload(payload)
        self.stanza_processor.set_response_handlers(stanza,
                                        self._bind_success, self._bind_error)
        stream.send(stanza)
        stream.event(BindingResourceEvent(resource))

    def _bind_success(self, stanza):
        """Handle resource binding success.

        [initiating entity only]

        :Parameters:
            - `stanza`: <iq type="result"/> stanza received.

        Set `streambase.StreamBase.me` to the full JID negotiated."""
        # pylint: disable-msg=R0201
        payload = stanza.get_payload(ResourceBindingPayload)
        jid = payload.jid
        if not jid:
            raise BadRequestProtocolError(u"<jid/> element mising in"
                                                    " the bind response")
        self.stream.me = jid
        self.stream.event(AuthorizedEvent(self.stream.me))

    def _bind_error(self, stanza): # pylint: disable-msg=R0201,W0613
        """Handle resource binding success.

        [initiating entity only]

        :raise FatalStreamError:"""
        raise FatalStreamError("Resource binding failed")

    @iq_set_stanza_handler(ResourceBindingPayload)
    def handle_bind_iq_set(self, stanza):
        """Handler <iq type="set"/> for resource binding."""
        # pylint: disable-msg=R0201
        if not self.stream:
            logger.error("Got bind stanza before stream feature has been set")
            return False
        if self.stream.initiator:
            return False
        peer = self.stream.peer
        if peer.resource:
            raise ResourceConstraintProtocolError(
                        u"Only one resource per client supported")
        resource = stanza.get_payload(ResourceBindingPayload).resource
        jid = None
        if resource:
            try:
                jid = JID(peer.local, peer.domain, resource)
            except JIDError:
                pass
        if jid is None:
            resource = unicode(uuid.uuid4())
            jid = JID(peer.local, peer.domain, resource)
        response = stanza.make_result_response()
        payload = ResourceBindingPayload(jid = jid)
        response.set_payload(payload)
        self.stream.peer = jid
        self.stream.event(AuthorizedEvent(jid))
        return response

def default_resource_factory(settings):
    """Factory for the 'resource' setting default: use random uuid"""
    # pylint: disable-msg=W0613
    return unicode(uuid.uuid4())

XMPPSettings.add_setting("resource", type = unicode, basic = False,
    cmdline_help = "Default JID resource",
    doc = """JID resource to bind. Use the server-provided resource if not set.
Automatically set to the resource of the JID provided to the `ClientStream`
constructor."""
    )

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = cache
#
# (C) Copyright 2005-2010 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""Caching proxy for Jabber/XMPP objects.

This package provides facilities to retrieve and transparently cache
cachable objects like Service Discovery responses or e.g. client version
informations."""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

raise ImportError("{0} is not yet rewritten for PyXMPP2".format(__name__))

import threading
from datetime import datetime, timedelta

_state_values = {
        'new': 0,
        'fresh': 1,
        'old': 2,
        'stale': 3,
        'purged': 4
    };

# locking order (anti-deadlock):
# CacheSuite, Cache, CacheHandler, CacheItem

class CacheItem(object):
    """An item in a cache.

    :Ivariables:
        - `value`: item value (cached object).
        - `address`: item address.
        - `state`: current state.
        - `state_value`: numerical value of the current state (lower number means
          fresher item).
        - `timestamp`: time when the object was created.
        - `freshness_time`: time when the object stops being fresh.
        - `expire_time`: time when the object expires.
        - `purge_time`: time when the object should be purged. When 0 then
          item will never be automaticaly purged.
        - `_lock`: lock for thread safety.
    :Types:
        - `value`: `instance`
        - `address`: any hashable
        - `state`: `str`
        - `state_value`: `int`
        - `timestamp`: :std:`datetime`
        - `freshness_time`: :std:`datetime`
        - `expire_time`: :std:`datetime`
        - `purge_time`: :std:`datetime`
        - `_lock`: :std:`threading.RLock`"""
    __slots__ = ['value', 'address', 'state', 'timestamp', 'freshness_time',
            'expire_time', 'purge_time', 'state_value', '_lock']
    def __init__(self, address, value, freshness_period, expiration_period,
            purge_period, state = "new"):
        """Initialize an CacheItem object.

        :Parameters:
            - `address`: item address.
            - `value`: item value (cached object).
            - `freshness_period`: time interval after which the object stops being fresh.
            - `expiration_period`: time interval after which the object expires.
            - `purge_period`: time interval after which the object should be purged. When 0 then
              item will never be automaticaly purged.
            - `state`: initial state.
        :Types:
            - `address`: any hashable
            - `value`: `instance`
            - `freshness_period`: `timedelta`
            - `expiration_period`: `timedelta`
            - `purge_period`: `timedelta`
            - `state`: `str`"""
        if freshness_period>expiration_period:
            raise ValueError("freshness_period greater then expiration_period")
        if expiration_period>purge_period:
            raise ValueError("expiration_period greater then purge_period")
        self.address = address
        self.value = value
        now = datetime.utcnow()
        self.timestamp = now
        self.freshness_time = now+freshness_period
        self.expire_time = now+expiration_period
        if purge_period:
            self.purge_time = now+purge_period
        else:
            self.purge_time = datetime.max
        self.state = state
        self.state_value = _state_values[state]
        self._lock = threading.RLock()

    def update_state(self):
        """Update current status of the item and compute time of the next
        state change.

        :return: the new state.
        :returntype: :std:`datetime`"""
        self._lock.acquire()
        try:
            now = datetime.utcnow()
            if self.state == 'new':
                self.state = 'fresh'
            if self.state == 'fresh':
                if now > self.freshness_time:
                    self.state = 'old'
            if self.state == 'old':
                if now > self.expire_time:
                    self.state = 'stale'
            if self.state == 'stale':
                if now > self.purge_time:
                    self.state = 'purged'
            self.state_value = _state_values[self.state]
            return self.state
        finally:
            self._lock.release()

    def __cmp__(self,other):
        try:
            return cmp(
                    (-self.state_value, self.timestamp, id(self)),
                    (-other.state_value, other.timestamp, id(other))
                )
        except AttributeError:
            return cmp(id(self),id(other))

_hour = timedelta(hours = 1)

class CacheFetcher:
    """Base class for cache object fetchers -- classes responsible for
    retrieving objects from network.

    An instance of a fetcher class is created for each object requested and
    not found in the cache, then `fetch` method is called to initialize
    the asynchronous retrieval process. Fetcher object's `got_it` method
    should be called on a successfull retrieval and `error` otherwise.
    `timeout` will be called when the request timeouts.

    :Ivariables:
        - `cache`: cache object which created this fetcher.
        - `address`: requested item address.
        - `timeout_time`: timeout time.
        - `active`: `True` as long as the fetcher is active and requestor
          expects one of the handlers to be called.
    :Types:
        - `cache`: `Cache`
        - `address`: any hashable
        - `timeout_time`: :std:`datetime`
        - `active`: `bool`
    """
    def __init__(self, cache, address,
            item_freshness_period, item_expiration_period, item_purge_period,
            object_handler, error_handler, timeout_handler, timeout_period,
            backup_state = None):
        """Initialize an `CacheFetcher` object.

        :Parameters:
            - `cache`: cache object which created this fetcher.
            - `address`: requested item address.
            - `item_freshness_period`: freshness period for the requested item.
            - `item_expiration_period`: expiration period for the requested item.
            - `item_purge_period`: purge period for the requested item.
            - `object_handler`: function to be called after the item is fetched.
            - `error_handler`: function to be called on error.
            - `timeout_handler`: function to be called on timeout
            - `timeout_period`: timeout interval.
            - `backup_state`: when not `None` and the fetch fails than an
              object from cache of at least this state will be passed to the
              `object_handler`. If such object is not available, then
              `error_handler` is called.
        :Types:
            - `cache`: `Cache`
            - `address`: any hashable
            - `item_freshness_period`: `timedelta`
            - `item_expiration_period`: `timedelta`
            - `item_purge_period`: `timedelta`
            - `object_handler`: callable(address, value, state)
            - `error_handler`: callable(address, error_data)
            - `timeout_handler`: callable(address)
            - `timeout_period`: `timedelta`
            - `backup_state`: `bool`"""
        self.cache = cache
        self.address = address
        self._item_freshness_period = item_freshness_period
        self._item_expiration_period = item_expiration_period
        self._item_purge_period = item_purge_period
        self._object_handler = object_handler
        self._error_handler = error_handler
        self._timeout_handler = timeout_handler
        if timeout_period:
            self.timeout_time = datetime.utcnow()+timeout_period
        else:
            self.timeout_time = datetime.max
        self._backup_state = backup_state
        self.active = True

    def _deactivate(self):
        """Remove the fetcher from cache and mark it not active."""
        self.cache.remove_fetcher(self)
        if self.active:
            self._deactivated()

    def _deactivated(self):
        """Mark the fetcher inactive after it is removed from the cache."""
        self.active = False

    def fetch(self):
        """Start the retrieval process.

        This method must be implemented in any fetcher class."""
        raise RuntimeError("Pure virtual method called")

    def got_it(self, value, state = "new"):
        """Handle a successfull retrieval and call apriopriate handler.

        Should be called when retrieval succeeds.

        Do nothing when the fetcher is not active any more (after
        one of handlers was already called).

        :Parameters:
            - `value`: fetched object.
            - `state`: initial state of the object.
        :Types:
            - `value`: any
            - `state`: `str`"""
        if not self.active:
            return
        item = CacheItem(self.address, value, self._item_freshness_period,
                self._item_expiration_period, self._item_purge_period, state)
        self._object_handler(item.address, item.value, item.state)
        self.cache.add_item(item)
        self._deactivate()

    def error(self, error_data):
        """Handle a retrieval error and call apriopriate handler.

        Should be called when retrieval fails.

        Do nothing when the fetcher is not active any more (after
        one of handlers was already called).

        :Parameters:
            - `error_data`: additional information about the error (e.g. `StanzaError` instance).
        :Types:
            - `error_data`: fetcher dependant
        """
        if not self.active:
            return
        if not self._try_backup_item():
            self._error_handler(self.address, error_data)
        self.cache.invalidate_object(self.address)
        self._deactivate()

    def timeout(self):
        """Handle fetcher timeout and call apriopriate handler.

        Is called by the cache object and should _not_ be called by fetcher or
        application.

        Do nothing when the fetcher is not active any more (after
        one of handlers was already called)."""
        if not self.active:
            return
        if not self._try_backup_item():
            if self._timeout_handler:
                self._timeout_handler(self.address)
            else:
                self._error_handler(self.address, None)
        self.cache.invalidate_object(self.address)
        self._deactivate()

    def _try_backup_item(self):
        """Check if a backup item is available in cache and call
        the item handler if it is.

        :return: `True` if backup item was found.
        :returntype: `bool`"""
        if not self._backup_state:
            return False
        item = self.cache.get_item(self.address, self._backup_state)
        if item:
            self._object_handler(item.address, item.value, item.state)
            return True
        else:
            False

class Cache:
    """Caching proxy for object retrieval and caching.

    Object factories ("fetchers") are registered in the `Cache` object and used
    to e.g. retrieve requested objects from network.  They are called only when
    the requested object is not in the cache or is not fresh enough.

    A state (freshness level) name may be provided when requesting an object.
    When the cached item state is "less fresh" then requested, then new object
    will be retrieved.

    Following states are defined:

      - 'new': always a new object should be retrieved.
      - 'fresh': a fresh object (not older than freshness time)
      - 'old': object not fresh, but most probably still valid.
      - 'stale': object known to be expired.

    :Ivariables:
        - `default_freshness_period`: default freshness period (in seconds).
        - `default_expiration_period`: default expiration period (in seconds).
        - `default_purge_period`: default purge period (in seconds). When
          0 then items are never purged because of their age.
        - `max_items`: maximum number of items to store.
        - `_items`: dictionary of stored items.
        - `_items_list`: list of stored items with the most suitable for
          purging first.
        - `_fetcher`: fetcher class for this cache.
        - `_active_fetchers`: list of active fetchers sorted by the time of
          its expiration time.
        - `_lock`: lock for thread safety.
    :Types:
        - `default_freshness_period`: timedelta
        - `default_expiration_period`: timedelta
        - `default_purge_period`: timedelta
        - `max_items`: `int`
        - `_items`: `dict` of (`classobj`, addr) -> `CacheItem`
        - `_items_list`: `list` of (`int`, :std:`datetime`, `CacheItem`)
        - `_fetcher`: `CacheFetcher` based class
        - `_active_fetchers`: `list` of (`int`, `CacheFetcher`)
        - `_lock`: :std:`threading.RLock`
    """
    def __init__(self, max_items, default_freshness_period = _hour,
            default_expiration_period = 12*_hour, default_purge_period = 24*_hour):
        """Initialize a `Cache` object.

            :Parameters:
                - `default_freshness_period`: default freshness period (in seconds).
                - `default_expiration_period`: default expiration period (in seconds).
                - `default_purge_period`: default purge period (in seconds). When
                  0 then items are never purged because of their age.
                - `max_items`: maximum number of items to store.
            :Types:
                - `default_freshness_period`: number
                - `default_expiration_period`: number
                - `default_purge_period`: number
                - `max_items`: number
        """
        self.default_freshness_period = default_freshness_period
        self.default_expiration_period = default_expiration_period
        self.default_purge_period = default_purge_period
        self.max_items = max_items
        self._items = {}
        self._items_list = []
        self._fetcher = None
        self._active_fetchers = []
        self._purged = 0
        self._lock = threading.RLock()

    def request_object(self, address, state, object_handler,
            error_handler = None, timeout_handler = None,
            backup_state = None, timeout = timedelta(minutes=60),
            freshness_period = None, expiration_period = None,
            purge_period = None):
        """Request an object with given address and state not worse than
        `state`. The object will be taken from cache if available, and
        created/fetched otherwise. The request is asynchronous -- this metod
        doesn't return the object directly, but the `object_handler` is called
        as soon as the object is available (this may be before `request_object`
        returns and may happen in other thread). On error the `error_handler`
        will be called, and on timeout -- the `timeout_handler`.

        :Parameters:
            - `address`: address of the object requested.
            - `state`: the worst acceptable object state. When 'new' then always
              a new object will be created/fetched. 'stale' will select any
              item available in cache.
            - `object_handler`: function to be called when object is available.
              It will be called with the following arguments: address, object
              and its state.
            - `error_handler`: function to be called on object retrieval error.
              It will be called with two arguments: requested address and
              additional error information (fetcher-specific, may be
              StanzaError for XMPP objects).  If not given, then the object
              handler will be called with object set to `None` and state
              "error".
            - `timeout_handler`: function to be called on object retrieval
              timeout.  It will be called with only one argument: the requested
              address. If not given, then the `error_handler` will be called
              instead, with error details set to `None`.
            - `backup_state`: when set and object in state `state` is not
              available in the cache and object retrieval failed then object
              with this state will also be looked-up in the cache and provided
              if available.
            - `timeout`: time interval after which retrieval of the object
              should be given up.
            - `freshness_period`: time interval after which the item created
              should become 'old'.
            - `expiration_period`: time interval after which the item created
              should become 'stale'.
            - `purge_period`: time interval after which the item created
              shuld be removed from the cache.
        :Types:
            - `address`: any hashable
            - `state`: "new", "fresh", "old" or "stale"
            - `object_handler`: callable(address, value, state)
            - `error_handler`: callable(address, error_data)
            - `timeout_handler`: callable(address)
            - `backup_state`: "new", "fresh", "old" or "stale"
            - `timeout`: `timedelta`
            - `freshness_period`: `timedelta`
            - `expiration_period`: `timedelta`
            - `purge_period`: `timedelta`
        """
        self._lock.acquire()
        try:
            if state == 'stale':
                state = 'purged'
            item = self.get_item(address, state)
            if item:
                object_handler(item.address, item.value, item.state)
                return
            if not self._fetcher:
                raise TypeError("No cache fetcher defined")
            if not error_handler:
                def default_error_handler(address, _unused):
                    "Default error handler."
                    return object_handler(address, None, 'error')
                error_handler = default_error_handler
            if not timeout_handler:
                def default_timeout_handler(address):
                    "Default timeout handler."
                    return error_handler(address, None)
                timeout_handler = default_timeout_handler
            if freshness_period is None:
                freshness_period = self.default_freshness_period
            if expiration_period is None:
                expiration_period = self.default_expiration_period
            if purge_period is None:
                purge_period = self.default_purge_period

            fetcher = self._fetcher(self, address, freshness_period,
                    expiration_period, purge_period, object_handler, error_handler,
                    timeout_handler, timeout, backup_state)
            fetcher.fetch()
            self._active_fetchers.append((fetcher.timeout_time,fetcher))
            self._active_fetchers.sort()
        finally:
            self._lock.release()

    def invalidate_object(self, address, state = 'stale'):
        """Force cache item state change (to 'worse' state only).

        :Parameters:
            - `state`: the new state requested.
        :Types:
            - `state`: `str`"""
        self._lock.acquire()
        try:
            item = self.get_item(address)
            if item and item.state_value<_state_values[state]:
                item.state=state
                item.update_state()
                self._items_list.sort()
        finally:
            self._lock.release()

    def add_item(self, item):
        """Add an item to the cache.

        Item state is updated before adding it (it will not be 'new' any more).

        :Parameters:
            - `item`: the item to add.
        :Types:
            - `item`: `CacheItem`

        :return: state of the item after addition.
        :returntype: `str`
        """
        self._lock.acquire()
        try:
            state = item.update_state()
            if state != 'purged':
                if len(self._items_list) >= self.max_items:
                    self.purge_items()
                self._items[item.address] = item
                self._items_list.append(item)
                self._items_list.sort()
            return item.state
        finally:
            self._lock.release()

    def get_item(self, address, state = 'fresh'):
        """Get an item from the cache.

        :Parameters:
            - `address`: its address.
            - `state`: the worst state that is acceptable.
        :Types:
            - `address`: any hashable
            - `state`: `str`

        :return: the item or `None` if it was not found.
        :returntype: `CacheItem`"""
        self._lock.acquire()
        try:
            item = self._items.get(address)
            if not item:
                return None
            self.update_item(item)
            if _state_values[state] >= item.state_value:
                return item
            return None
        finally:
            self._lock.release()

    def update_item(self, item):
        """Update state of an item in the cache.

        Update item's state and remove the item from the cache
        if its new state is 'purged'

        :Parameters:
            - `item`: item to update.
        :Types:
            - `item`: `CacheItem`

        :return: new state of the item.
        :returntype: `str`"""

        self._lock.acquire()
        try:
            state = item.update_state()
            self._items_list.sort()
            if item.state == 'purged':
                self._purged += 1
                if self._purged > 0.25*self.max_items:
                    self.purge_items()
            return state
        finally:
            self._lock.release()

    def num_items(self):
        """Get the number of items in the cache.

        :return: number of items.
        :returntype: `int`"""
        return len(self._items_list)

    def purge_items(self):
        """Remove purged and overlimit items from the cache.

        TODO: optimize somehow.

        Leave no more than 75% of `self.max_items` items in the cache."""
        self._lock.acquire()
        try:
            il=self._items_list
            num_items = len(il)
            need_remove = num_items - int(0.75 * self.max_items)

            for _unused in range(need_remove):
                item=il.pop(0)
                try:
                    del self._items[item.address]
                except KeyError:
                    pass

            while il and il[0].update_state()=="purged":
                item=il.pop(0)
                try:
                    del self._items[item.address]
                except KeyError:
                    pass
        finally:
            self._lock.release()

    def tick(self):
        """Do the regular cache maintenance.

        Must be called from time to time for timeouts and cache old items
        purging to work."""
        self._lock.acquire()
        try:
            now = datetime.utcnow()
            for t,f in list(self._active_fetchers):
                if t > now:
                    break
                f.timeout()
            self.purge_items()
        finally:
            self._lock.release()

    def remove_fetcher(self, fetcher):
        """Remove a running fetcher from the list of active fetchers.

        :Parameters:
            - `fetcher`: fetcher instance.
        :Types:
            - `fetcher`: `CacheFetcher`"""
        self._lock.acquire()
        try:
            for t, f in list(self._active_fetchers):
                if f is fetcher:
                    self._active_fetchers.remove((t, f))
                    f._deactivated()
                    return
        finally:
            self._lock.release()

    def set_fetcher(self, fetcher_class):
        """Set the fetcher class.

        :Parameters:
            - `fetcher_class`: the fetcher class.
        :Types:
            - `fetcher_class`: `CacheFetcher` based class
        """
        self._lock.acquire()
        try:
            self._fetcher = fetcher_class
        finally:
            self._lock.release()

class CacheSuite:
    """Caching proxy for object retrieval and caching.

    Object factories for other classes are registered in the
    `Cache` object and used to e.g. retrieve requested objects from network.
    They are called only when the requested object is not in the cache
    or is not fresh enough.

    Objects are addressed using their class and a class dependant address.
    Eg. `pyxmpp.jabber.disco.DiscoInfo` objects are addressed using
    (`pyxmpp.jabber.disco.DiscoInfo`,(jid, node)) tuple.

    Additionaly a state (freshness level) name may be provided when requesting
    an object. When the cached item state is "less fresh" then requested, then
    new object will be retrieved.

    Following states are defined:

      - 'new': always a new object should be retrieved.
      - 'fresh': a fresh object (not older than freshness time)
      - 'old': object not fresh, but most probably still valid.
      - 'stale': object known to be expired.

    :Ivariables:
        - `default_freshness_period`: default freshness period (in seconds).
        - `default_expiration_period`: default expiration period (in seconds).
        - `default_purge_period`: default purge period (in seconds). When
          0 then items are never purged because of their age.
        - `max_items`: maximum number of obejects of one class to store.
        - `_caches`: dictionary of per-class caches.
        - `_lock`: lock for thread safety.
    :Types:
        - `default_freshness_period`: timedelta
        - `default_expiration_period`: timedelta
        - `default_purge_period`: timedelta
        - `max_items`: `int`
        - `_caches`: `dict` of (`classobj`, addr) -> `Cache`
        - `_lock`: :std:`threading.RLock`
    """
    def __init__(self, max_items, default_freshness_period = _hour,
            default_expiration_period = 12*_hour, default_purge_period = 24*_hour):
        """Initialize a `Cache` object.

            :Parameters:
                - `default_freshness_period`: default freshness period (in seconds).
                - `default_expiration_period`: default expiration period (in seconds).
                - `default_purge_period`: default purge period (in seconds). When
                  0 then items are never purged because of their age.
                - `max_items`: maximum number of items to store.
            :Types:
                - `default_freshness_period`: number
                - `default_expiration_period`: number
                - `default_purge_period`: number
                - `max_items`: number
        """
        self.default_freshness_period = default_freshness_period
        self.default_expiration_period = default_expiration_period
        self.default_purge_period = default_purge_period
        self.max_items = max_items
        self._caches = {}
        self._lock = threading.RLock()

    def request_object(self, object_class, address, state, object_handler,
            error_handler = None, timeout_handler = None,
            backup_state = None, timeout = None,
            freshness_period = None, expiration_period = None, purge_period = None):
        """Request an object of given class, with given address and state not
        worse than `state`. The object will be taken from cache if available,
        and created/fetched otherwise. The request is asynchronous -- this
        metod doesn't return the object directly, but the `object_handler` is
        called as soon as the object is available (this may be before
        `request_object` returns and may happen in other thread). On error the
        `error_handler` will be called, and on timeout -- the
        `timeout_handler`.

        :Parameters:
            - `object_class`: class (type) of the object requested.
            - `address`: address of the object requested.
            - `state`: the worst acceptable object state. When 'new' then always
              a new object will be created/fetched. 'stale' will select any
              item available in cache.
            - `object_handler`: function to be called when object is available.
              It will be called with the following arguments: address, object
              and its state.
            - `error_handler`: function to be called on object retrieval error.
              It will be called with two arguments: requested address and
              additional error information (fetcher-specific, may be
              StanzaError for XMPP objects).  If not given, then the object
              handler will be called with object set to `None` and state
              "error".
            - `timeout_handler`: function to be called on object retrieval
              timeout.  It will be called with only one argument: the requested
              address. If not given, then the `error_handler` will be called
              instead, with error details set to `None`.
            - `backup_state`: when set and object in state `state` is not
              available in the cache and object retrieval failed then object
              with this state will also be looked-up in the cache and provided
              if available.
            - `timeout`: time interval after which retrieval of the object
              should be given up.
            - `freshness_period`: time interval after which the item created
              should become 'old'.
            - `expiration_period`: time interval after which the item created
              should become 'stale'.
            - `purge_period`: time interval after which the item created
              shuld be removed from the cache.
        :Types:
            - `object_class`: `classobj`
            - `address`: any hashable
            - `state`: "new", "fresh", "old" or "stale"
            - `object_handler`: callable(address, value, state)
            - `error_handler`: callable(address, error_data)
            - `timeout_handler`: callable(address)
            - `backup_state`: "new", "fresh", "old" or "stale"
            - `timeout`: `timedelta`
            - `freshness_period`: `timedelta`
            - `expiration_period`: `timedelta`
            - `purge_period`: `timedelta`
        """

        self._lock.acquire()
        try:
            if object_class not in self._caches:
                raise TypeError("No cache for %r" % (object_class,))

            self._caches[object_class].request_object(address, state, object_handler,
                    error_handler, timeout_handler, backup_state, timeout,
                    freshness_period, expiration_period, purge_period)
        finally:
            self._lock.release()

    def tick(self):
        """Do the regular cache maintenance.

        Must be called from time to time for timeouts and cache old items
        purging to work."""
        self._lock.acquire()
        try:
            for cache in self._caches.values():
                cache.tick()
        finally:
            self._lock.release()

    def register_fetcher(self, object_class, fetcher_class):
        """Register a fetcher class for an object class.

        :Parameters:
            - `object_class`: class to be retrieved by the fetcher.
            - `fetcher_class`: the fetcher class.
        :Types:
            - `object_class`: `classobj`
            - `fetcher_class`: `CacheFetcher` based class
        """
        self._lock.acquire()
        try:
            cache = self._caches.get(object_class)
            if not cache:
                cache = Cache(self.max_items, self.default_freshness_period,
                        self.default_expiration_period, self.default_purge_period)
                self._caches[object_class] = cache
            cache.set_fetcher(fetcher_class)
        finally:
            self._lock.release()

    def unregister_fetcher(self, object_class):
        """Unregister a fetcher class for an object class.

        :Parameters:
            - `object_class`: class retrieved by the fetcher.
        :Types:
            - `object_class`: `classobj`
        """
        self._lock.acquire()
        try:
            cache = self._caches.get(object_class)
            if not cache:
                return
            cache.set_fetcher(None)
        finally:
            self._lock.release()

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = cert
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""TLS certificate handling.
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import sys
import logging
import ssl

from collections import defaultdict
from datetime import datetime

try:
    import pyasn1  # pylint: disable=W0611
    import pyasn1_modules.rfc2459  # pylint: disable=W0611
    HAVE_PYASN1 = True
except ImportError:
    HAVE_PYASN1 = False

from .jid import JID, are_domains_equal
from .exceptions import JIDError

logger = logging.getLogger("pyxmpp2.cert")

class CertificateData(object):
    """Certificate information interface.

    This class provides only that information from the certificate, which
    is provided by the python API.
    """
    def __init__(self):
        self.validated = False
        self.subject_name = None
        self.not_after = None
        self.common_names = None
        self.alt_names = {}

    @property
    def display_name(self):
        """Get human-readable subject name derived from the SubjectName
        or SubjectAltName field.
        """
        if self.subject_name:
            return u", ".join( [ u", ".join(
                        [ u"{0}={1}".format(k,v) for k, v in dn_tuple ] )
                            for dn_tuple in self.subject_name ])
        for name_type in ("XmppAddr", "DNS", "SRV"):
            names = self.alt_names.get(name_type)
            if names:
                return names[0]
        return u"<unknown>"

    def get_jids(self):
        """Return JIDs for which this certificate is valid (except the domain
        wildcards).

        :Returtype: `list` of `JID`
        """
        result = []
        if ("XmppAddr" in self.alt_names or "DNS" in self.alt_names
                                            or "SRVName" in self.alt_names):
            addrs =  self.alt_names.get("XmppAddr", [])
            addrs += [ addr for addr in self.alt_names.get("DNS", [])
                                            if not addr.startswith("*.") ]
            addrs += [ addr.split(".", 1)[1] for addr
                                        in self.alt_names.get("SRVName", [])
                            if (addr.startswith("_xmpp-server.")
                                    or addr.startswith("_xmpp-client."))]
            warn_bad = True
        elif self.common_names:
            addrs = [addr for addr in self.common_names
                                if "@" not in addr and "/" not in addr]
            warn_bad = False
        else:
            return []
        for addr in addrs:
            try:
                jid = JID(addr)
                if jid not in result:
                    result.append(jid)
            except JIDError, err:
                if warn_bad:
                    logger.warning(u"Bad JID in the certificate: {0!r}: {1}"
                                                            .format(addr, err))
        return result

    def verify_server(self, server_name, srv_type = 'xmpp-client'):
        """Verify certificate for a server.

        :Parameters:
            - `server_name`: name of the server presenting the cerificate
            - `srv_type`: service type requested, as used in the SRV record
        :Types:
            - `server_name`: `unicode` or `JID`
            - `srv_type`: `unicode`

        :Return: `True` if the certificate is valid for given name, `False`
        otherwise.
        """
        server_jid = JID(server_name)
        if "XmppAddr" not in self.alt_names and "DNS" not in self.alt_names \
                                and "SRV" not in self.alt_names:
            return self.verify_jid_against_common_name(server_jid)
        names = [name for name in self.alt_names.get("DNS", [])
                                        if not name.startswith(u"*.")]
        names += self.alt_names.get("XmppAddr", [])
        for name in names:
            logger.debug("checking {0!r} against {1!r}".format(server_jid,
                                                                name))
            try:
                jid = JID(name)
            except ValueError:
                logger.debug("Not a valid JID: {0!r}".format(name))
                continue
            if jid == server_jid:
                logger.debug("Match!")
                return True
        if srv_type and self.verify_jid_against_srv_name(server_jid, srv_type):
            return True
        wildcards = [name[2:] for name in self.alt_names.get("DNS", [])
                                                if name.startswith("*.")]
        if not wildcards or not "." in server_jid.domain:
            return False
        logger.debug("checking {0!r} against wildcard domains: {1!r}"
                                                .format(server_jid, wildcards))
        server_domain = JID(domain = server_jid.domain.split(".", 1)[1])
        for domain in wildcards:
            logger.debug("checking {0!r} against {1!r}".format(server_domain,
                                                                domain))
            try:
                jid = JID(domain)
            except ValueError:
                logger.debug("Not a valid JID: {0!r}".format(name))
                continue
            if jid == server_domain:
                logger.debug("Match!")
                return True
        return False

    def verify_jid_against_common_name(self, jid):
        """Return `True` if jid is listed in the certificate commonName.

        :Parameters:
            - `jid`: JID requested (domain part only)
        :Types:
            - `jid`: `JID`

        :Returntype: `bool`
        """
        if not self.common_names:
            return False
        for name in self.common_names:
            try:
                cn_jid = JID(name)
            except ValueError:
                continue
            if jid == cn_jid:
                return True
        return False

    def verify_jid_against_srv_name(self, jid, srv_type):
        """Check if the cerificate is valid for given domain-only JID
        and a service type.

        :Parameters:
            - `jid`: JID requested (domain part only)
            - `srv_type`: service type, e.g. 'xmpp-client'
        :Types:
            - `jid`: `JID`
            - `srv_type`: `unicode`
        :Returntype: `bool`
        """
        srv_prefix = u"_" + srv_type + u"."
        srv_prefix_l = len(srv_prefix)
        for srv in self.alt_names.get("SRVName", []):
            logger.debug("checking {0!r} against {1!r}".format(jid,
                                                                srv))
            if not srv.startswith(srv_prefix):
                logger.debug("{0!r} does not start with {1!r}"
                                                .format(srv, srv_prefix))
                continue
            try:
                srv_jid = JID(srv[srv_prefix_l:])
            except ValueError:
                continue
            if srv_jid == jid:
                logger.debug("Match!")
                return True
        return False

    def verify_client(self, client_jid = None, domains = None):
        """Verify certificate for a client.

        Please note that `client_jid` is only a hint to choose from the names,
        other JID may be returned if `client_jid` is not included in the
        certificate.

        :Parameters:
            - `client_jid`: client name requested. May be `None` to allow
              any name in one of the `domains`.
            - `domains`: list of domains we can handle.
        :Types:
            - `client_jid`: `JID`
            - `domains`: `list` of `unicode`

        :Return: one of the jids in the certificate or `None` is no authorized
        name is found.
        """
        jids = [jid for jid in self.get_jids() if jid.local]
        if not jids:
            return None
        if client_jid is not None and client_jid in jids:
            return client_jid
        if domains is None:
            return jids[0]
        for jid in jids:
            for domain in domains:
                if are_domains_equal(jid.domain, domain):
                    return jid
        return None

class BasicCertificateData(CertificateData):
    """Certificate information interface.

    This class provides only that information from the certificate, which
    is provided by the python API.
    """
    @classmethod
    def from_ssl_socket(cls, ssl_socket):
        """Load certificate data from an SSL socket.
        """
        cert = cls()
        try:
            data = ssl_socket.getpeercert()
        except AttributeError:
            # PyPy doesn't have .getppercert
            return cert
        logger.debug("Certificate data from ssl module: {0!r}".format(data))
        if not data:
            return cert
        cert.validated = True
        cert.subject_name = data.get('subject')
        cert.alt_names = defaultdict(list)
        if 'subjectAltName' in data:
            for name, value in data['subjectAltName']:
                cert.alt_names[name].append(value)
        if 'notAfter' in data:
            tstamp = ssl.cert_time_to_seconds(data['notAfter'])
            cert.not_after = datetime.utcfromtimestamp(tstamp)
        if sys.version_info.major < 3:
            cert._decode_names() # pylint: disable=W0212
        cert.common_names = []
        if cert.subject_name:
            for part in cert.subject_name:
                for name, value in part:
                    if name == 'commonName':
                        cert.common_names.append(value)
        return cert

    def _decode_names(self):
        """Decode names (hopefully ASCII or UTF-8) into Unicode.
        """
        if self.subject_name is not None:
            subject_name = []
            for part in self.subject_name:
                new_part = []
                for name, value in part:
                    try:
                        name = name.decode("utf-8")
                        value = value.decode("utf-8")
                    except UnicodeError:
                        continue
                    new_part.append((name, value))
                subject_name.append(tuple(new_part))
            self.subject_name = tuple(subject_name)
        for key, old in self.alt_names.items():
            new = []
            for name in old:
                try:
                    name = name.decode("utf-8")
                except UnicodeError:
                    continue
                new.append(name)
            self.alt_names[key] = new

DN_OIDS = {
        (2, 5, 4, 41): u"name",
        (2, 5, 4, 4): u"surname",
        (2, 5, 4, 42): u"givenName",
        (2, 5, 4, 43): u"initials",
        (2, 5, 4, 3): u"commonName",
        (2, 5, 4, 7): u"localityName",
        (2, 5, 4, 8): u"stateOrProvinceName",
        (2, 5, 4, 10): u"organizationName",
        (2, 5, 4, 11): u"organizationalUnitName",
        (2, 5, 4, 12): u"title",
        (2, 5, 4, 6): u"countryName",
}

def _decode_asn1_string(data):
    """Convert ASN.1 string to a Unicode string.
    """
    if isinstance(data, BMPString):
        return bytes(data).decode("utf-16-be")
    else:
        return bytes(data).decode("utf-8")

if HAVE_PYASN1:
    from pyasn1_modules.rfc2459 import Certificate, DirectoryString, MAX, Name
    from pyasn1_modules import pem
    from pyasn1.codec.der import decoder as der_decoder
    from pyasn1.type.char import BMPString, IA5String, UTF8String
    from pyasn1.type.univ import Sequence, SequenceOf, Choice
    from pyasn1.type.univ import Any, ObjectIdentifier, OctetString
    from pyasn1.type.namedtype import NamedTypes, NamedType
    from pyasn1.type.useful import GeneralizedTime
    from pyasn1.type.constraint import ValueSizeConstraint
    from pyasn1.type import tag

    XMPPADDR_OID = ObjectIdentifier('1.3.6.1.5.5.7.8.5')
    SRVNAME_OID = ObjectIdentifier('1.3.6.1.5.5.7.8.7')
    SUBJECT_ALT_NAME_OID = ObjectIdentifier('2.5.29.17')

    class OtherName(Sequence):
        # pylint: disable=C0111,R0903
        componentType = NamedTypes(
                NamedType('type-id', ObjectIdentifier()),
                NamedType('value', Any().subtype(explicitTag = tag.Tag(
                                tag.tagClassContext, tag.tagFormatSimple, 0)))
                )

    class GeneralName(Choice):
        # pylint: disable=C0111,R0903
        componentType = NamedTypes(
                NamedType('otherName',
                    OtherName().subtype(implicitTag = tag.Tag(
                        tag.tagClassContext, tag.tagFormatSimple, 0))),
                NamedType('rfc822Name',
                    IA5String().subtype(implicitTag = tag.Tag(
                        tag.tagClassContext, tag.tagFormatSimple, 1))),
                NamedType('dNSName',
                    IA5String().subtype(implicitTag = tag.Tag(
                        tag.tagClassContext, tag.tagFormatSimple, 2))),
                NamedType('x400Address',
                    OctetString().subtype(implicitTag = tag.Tag(
                        tag.tagClassContext, tag.tagFormatSimple, 3))),
                NamedType('directoryName',
                    Name().subtype(implicitTag = tag.Tag(
                        tag.tagClassContext, tag.tagFormatSimple, 4))),
                NamedType('ediPartyName',
                    OctetString().subtype(implicitTag = tag.Tag(
                        tag.tagClassContext, tag.tagFormatSimple, 5))),
                NamedType('uniformResourceIdentifier',
                    IA5String().subtype(implicitTag = tag.Tag(
                        tag.tagClassContext, tag.tagFormatSimple, 6))),
                NamedType('iPAddress',
                    OctetString().subtype(implicitTag = tag.Tag(
                        tag.tagClassContext, tag.tagFormatSimple, 7))),
                NamedType('registeredID',
                    ObjectIdentifier().subtype(implicitTag = tag.Tag(
                        tag.tagClassContext, tag.tagFormatSimple, 8))),
                )

    class GeneralNames(SequenceOf):
        # pylint: disable=C0111,R0903
        componentType = GeneralName()
        sizeSpec = SequenceOf.sizeSpec + ValueSizeConstraint(1, MAX)


class ASN1CertificateData(CertificateData):
    """Certificate information interface.

    This class actually decodes the certificate, providing all the
    names there.
    """
    _cert_asn1_type = None
    @classmethod
    def from_ssl_socket(cls, ssl_socket):
        """Get certificate data from an SSL socket.
        """
        try:
            data = ssl_socket.getpeercert(True)
        except AttributeError:
            # PyPy doesn't have .getpeercert
            data = None
        if not data:
            logger.debug("No certificate infromation")
            return cls()
        result = cls.from_der_data(data)
        result.validated = bool(ssl_socket.getpeercert())
        return result

    @classmethod
    def from_der_data(cls, data):
        """Decode DER-encoded certificate.

        :Parameters:
            - `data`: the encoded certificate
        :Types:
            - `data`: `bytes`

        :Return: decoded certificate data
        :Returntype: ASN1CertificateData
        """
        # pylint: disable=W0212
        logger.debug("Decoding DER certificate: {0!r}".format(data))
        if cls._cert_asn1_type is None:
            cls._cert_asn1_type = Certificate()
        cert = der_decoder.decode(data, asn1Spec = cls._cert_asn1_type)[0]
        result = cls()
        tbs_cert = cert.getComponentByName('tbsCertificate')
        subject = tbs_cert.getComponentByName('subject')
        logger.debug("Subject: {0!r}".format(subject))
        result._decode_subject(subject)
        validity = tbs_cert.getComponentByName('validity')
        result._decode_validity(validity)
        extensions = tbs_cert.getComponentByName('extensions')
        if extensions:
            for extension in extensions:
                logger.debug("Extension: {0!r}".format(extension))
                oid = extension.getComponentByName('extnID')
                logger.debug("OID: {0!r}".format(oid))
                if oid != SUBJECT_ALT_NAME_OID:
                    continue
                value = extension.getComponentByName('extnValue')
                logger.debug("Value: {0!r}".format(value))
                if isinstance(value, Any):
                    # should be OctetString, but is Any
                    # in pyasn1_modules-0.0.1a
                    value = der_decoder.decode(value,
                                                asn1Spec = OctetString())[0]
                alt_names = der_decoder.decode(value,
                                            asn1Spec = GeneralNames())[0]
                logger.debug("SubjectAltName: {0!r}".format(alt_names))
                result._decode_alt_names(alt_names)
        return result

    def _decode_subject(self, subject):
        """Load data from a ASN.1 subject.
        """
        self.common_names = []
        subject_name = []
        for rdnss in subject:
            for rdns in rdnss:
                rdnss_list = []
                for nameval in rdns:
                    val_type = nameval.getComponentByName('type')
                    value = nameval.getComponentByName('value')
                    if val_type not in DN_OIDS:
                        logger.debug("OID {0} not supported".format(val_type))
                        continue
                    val_type = DN_OIDS[val_type]
                    value = der_decoder.decode(value,
                                            asn1Spec = DirectoryString())[0]
                    value = value.getComponent()
                    try:
                        value = _decode_asn1_string(value)
                    except UnicodeError:
                        logger.debug("Cannot decode value: {0!r}".format(value))
                        continue
                    if val_type == u"commonName":
                        self.common_names.append(value)
                    rdnss_list.append((val_type, value))
                subject_name.append(tuple(rdnss_list))
        self.subject_name = tuple(subject_name)

    def _decode_validity(self, validity):
        """Load data from a ASN.1 validity value.
        """
        not_after = validity.getComponentByName('notAfter')
        not_after = str(not_after.getComponent())
        if isinstance(not_after, GeneralizedTime):
            self.not_after = datetime.strptime(not_after, "%Y%m%d%H%M%SZ")
        else:
            self.not_after = datetime.strptime(not_after, "%y%m%d%H%M%SZ")
        self.alt_names = defaultdict(list)

    def _decode_alt_names(self, alt_names):
        """Load SubjectAltName from a ASN.1 GeneralNames value.

        :Values:
            - `alt_names`: the SubjectAltNama extension value
        :Types:
            - `alt_name`: `GeneralNames`
        """
        for alt_name in alt_names:
            tname = alt_name.getName()
            comp = alt_name.getComponent()
            if tname == "dNSName":
                key = "DNS"
                value = _decode_asn1_string(comp)
            elif tname == "uniformResourceIdentifier":
                key = "URI"
                value = _decode_asn1_string(comp)
            elif tname == "otherName":
                oid = comp.getComponentByName("type-id")
                value = comp.getComponentByName("value")
                if oid == XMPPADDR_OID:
                    key = "XmppAddr"
                    value = der_decoder.decode(value,
                                            asn1Spec = UTF8String())[0]
                    value = _decode_asn1_string(value)
                elif oid == SRVNAME_OID:
                    key = "SRVName"
                    value = der_decoder.decode(value,
                                            asn1Spec = IA5String())[0]
                    value = _decode_asn1_string(value)
                else:
                    logger.debug("Unknown other name: {0}".format(oid))
                    continue
            else:
                logger.debug("Unsupported general name: {0}"
                                                        .format(tname))
                continue
            self.alt_names[key].append(value)

    @classmethod
    def from_file(cls, filename):
        """Load certificate from a file.
        """
        with open(filename, "r") as pem_file:
            data = pem.readPemFromFile(pem_file)
        return cls.from_der_data(data)

if HAVE_PYASN1:
    def get_certificate_from_ssl_socket(ssl_socket):
        """Get certificate data from an SSL socket.
        """
        return ASN1CertificateData.from_ssl_socket(ssl_socket)
else:
    def get_certificate_from_ssl_socket(ssl_socket):
        """Get certificate data from an SSL socket.
        """
        return BasicCertificateData.from_ssl_socket(ssl_socket)

def get_certificate_from_file(filename):
    """Get certificate data from a PEM file.
    """
    return ASN1CertificateData.from_file(filename)

########NEW FILE########
__FILENAME__ = client
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""Basic XMPP-IM client implementation.

The `Client` class provides the base for client applications.

To create an XMPP client session applications should create a `Client` instance
providing in the constructor: a client JID, settings and handlers providing
application behaviour (the list may contain a single handler object which will
be 'the application). The `Client` class will provide some other handlers:
`StreamTLSHandler`, `StreamSASLHandler`, `SessionHandler`,
`ResourceBindingHandler` and `RosterClient`. The last one is available via the
`Client.roster_client` attribute and should be used to manipulate the roster.
The roster itself is available via the `Client.roster` property.

The `Client` object will open an XMPP stream after the `Client.connect` method
is called. It will send the initial presence (specified by
the :r:`initial_presence setting` ) upon log-in and the final presence on
log-out.  Other presence handling, including subscriptions is the
responsibility of the application.

The API is asynchronous and actual connection is made and data exchanged in the
main event loop. A `MainLoop` object can be passed to the `Client` constructor,
but this is not needed, as `Client` will create one if needed. The main loop
can be started by `Client.run()`.

To close the XMPP session use the `Client.disconnect()` method.

Normative reference:
  - :RFC:`6120`
  - :RFC:`6121`
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import logging

from .clientstream import ClientStream
from .mainloop import main_loop_factory
from .interfaces import EventHandler, event_handler
from .interfaces import TimeoutHandler, timeout_handler
from .streamevents import DisconnectedEvent, AuthenticatedEvent
from .streamevents import AuthorizedEvent
from .transport import TCPTransport
from .settings import XMPPSettings
from .session import SessionHandler
from .streamtls import StreamTLSHandler
from .streamsasl import StreamSASLHandler
from .binding import ResourceBindingHandler
from .stanzaprocessor import StanzaProcessor
from .roster import RosterClient
from .presence import Presence

logger = logging.getLogger("pyxmpp2.client")

def _move_session_handler(handlers):
    """Find a SessionHandler instance in the list and move it to the beginning.
    """
    index = 0
    for i, handler in enumerate(handlers):
        if isinstance(handler, SessionHandler):
            index = i
            break
    if index:
        handlers[:index + 1] = [handlers[index]] + handlers[:index]

class Client(StanzaProcessor, TimeoutHandler, EventHandler):
    """Base class for an XMPP-IM client.

    Joins the `MainLoop`, `ClientStream` and some basic handlers together,
    so a client application needs only to add its handlers.

    :Ivariables:
        - `jid`: configured JID of the client (current full JID is avialable as
          ``self.stream.jid``).
        - `main_loop`: the main loop object
        - `settings`: configuration settings
        - `handlers`: stream and main loop handlers provided via the
          constructor
        - `stream`: the stream object when connected
        - `roster_client`: the roster interface object
        - `_ml_handlers`: list of handlers installed by this object to at the
          main loop
    :Types:
        - `jid`: `jid.JID`
        - `main_loop`: `main_loop.interfaces.MainLoop`
        - `settings`: `XMPPSettings`
        - `stream`: `clientstream.ClientStream`
        - `roster_client`: `RosterClient`
    """
    # pylint: disable=R0902,R0904
    def __init__(self, jid, handlers, settings = None, main_loop = None):
        """Initialize a Client object.

        :Parameters:
            - `jid`: user JID for the connection.
            - `settings`: client settings.
            - `main_loop`: Main event loop to attach to. If None, a loop
              will be created.
        :Types:
            - `jid`: `jid.JID`
            - `settings`: `settings.XMPPSettings`
            - `main_loop`: `main_loop.interfaces.MainLoop`
        """
        self._ml_handlers = []
        self.jid = jid
        self.settings = settings if settings else XMPPSettings()
        StanzaProcessor.__init__(self, self.settings[u"default_stanza_timeout"])
        self.handlers = handlers
        self._base_handlers = self.base_handlers_factory()
        self.roster_client = self.roster_client_factory()
        self._base_handlers += [self.roster_client]
        self._ml_handlers += list(handlers) + self._base_handlers + [self]
        _move_session_handler(self._ml_handlers)
        if main_loop is not None:
            self.main_loop = main_loop
            for handler in self._ml_handlers:
                self.main_loop.add_handler(handler)
        else:
            self.main_loop = main_loop_factory(settings, self._ml_handlers)
        self.stream = None

    def __del__(self):
        for handler in self._ml_handlers:
            self.main_loop.remove_handler(handler)
        self._ml_handlers = []

    @property
    def roster(self):
        """Current roster.

        Shortcut for ``self.roster_client.roster``.
        """
        with self.lock:
            if self.roster_client is not None:
                return self.roster_client.roster
            else:
                return None

    def connect(self):
        """Schedule a new XMPP c2s connection.
        """
        with self.lock:
            if self.stream:
                logger.debug("Closing the previously used stream.")
                self._close_stream()

            transport = TCPTransport(self.settings)

            addr = self.settings["server"]
            if addr:
                service = None
            else:
                addr = self.jid.domain
                service = self.settings["c2s_service"]

            transport.connect(addr, self.settings["c2s_port"], service)
            handlers = self._base_handlers
            handlers += self.handlers + [self]
            self.clear_response_handlers()
            self.setup_stanza_handlers(handlers, "pre-auth")
            stream = ClientStream(self.jid, self, handlers, self.settings)
            stream.initiate(transport)
            self.main_loop.add_handler(transport)
            self.main_loop.add_handler(stream)
            self._ml_handlers += [transport, stream]
            self.stream = stream
            self.uplink = stream

    def disconnect(self):
        """Gracefully disconnect from the server."""
        with self.lock:
            if self.stream:
                if self.settings[u"initial_presence"]:
                    self.send(Presence(stanza_type = "unavailable"))
                self.stream.disconnect()

    def close_stream(self):
        """Close the stream immediately.
        """
        with self.lock:
            self._close_stream()

    def _close_stream(self):
        """Same as `close_stream` but with the `lock` acquired.
        """
        self.stream.close()
        if self.stream.transport in self._ml_handlers:
            self._ml_handlers.remove(self.stream.transport)
            self.main_loop.remove_handler(self.stream.transport)
        self.stream = None
        self.uplink = None

    def run(self, timeout = None):
        """Call the main loop.

        Convenience wrapper for ``self.main_loop.loop``
        """
        self.main_loop.loop(timeout)

    @event_handler(AuthenticatedEvent)
    def _stream_authenticated(self, event):
        """Handle the `AuthenticatedEvent`.
        """
        with self.lock:
            if event.stream != self.stream:
                return
            self.me = event.stream.me
            self.peer = event.stream.peer
            handlers = self._base_handlers
            handlers += self.handlers + [self]
            self.setup_stanza_handlers(handlers, "post-auth")

    @event_handler(AuthorizedEvent)
    def _stream_authorized(self, event):
        """Handle the `AuthorizedEvent`.
        """
        with self.lock:
            if event.stream != self.stream:
                return
            self.me = event.stream.me
            self.peer = event.stream.peer
            presence = self.settings[u"initial_presence"]
            if presence:
                self.send(presence)

    @event_handler(DisconnectedEvent)
    def _stream_disconnected(self, event):
        """Handle stream disconnection event.
        """
        with self.lock:
            if event.stream != self.stream:
                return
            if self.stream is not None and event.stream == self.stream:
                if self.stream.transport in self._ml_handlers:
                    self._ml_handlers.remove(self.stream.transport)
                    self.main_loop.remove_handler(self.stream.transport)
                self.stream = None
                self.uplink = None

    @timeout_handler(1)
    def regular_tasks(self):
        """Do some housekeeping (cache expiration, timeout handling).

        This method should be called periodically from the application's
        main loop.

        :Return: suggested delay (in seconds) before the next call to this
                                                                    method.
        :Returntype: `int`
        """
        with self.lock:
            ret = self._iq_response_handlers.expire()
            if ret is None:
                return 1
            else:
                return min(1, ret)

    def base_handlers_factory(self):
        """Default base client handlers factory.

        Subclasses can provide different behaviour by overriding this.

        :Return: list of handlers
        """
        tls_handler = StreamTLSHandler(self.settings)
        sasl_handler = StreamSASLHandler(self.settings)
        session_handler = SessionHandler()
        binding_handler = ResourceBindingHandler(self.settings)
        return [tls_handler, sasl_handler, binding_handler, session_handler]

    def roster_client_factory(self):
        """Creates the `RosterClient` instance for the `roster_client`
        attribute.

        Subclasses can provide different behaviour by overriding this. The
        overriding method can return `None` if no roster client is needed.

        :Return: `RosterClient`
        """
        return RosterClient(self.settings)

def _initial_presence_factory(settings):
    """Factory for the :r:`initial_presence setting` default.
    """
    # pylint: disable=W0613
    return Presence()

XMPPSettings.add_setting(u"initial_presence",
    factory = _initial_presence_factory,
    default_d = u"Just ``Presence()``",
    doc = """Default initial presence stanza, to be send on login.
Set to ``None`` not to send the initial presence."""
    )

XMPPSettings.add_setting(u"c2s_port", default = 5222, basic = True,
    type = int, validator = XMPPSettings.get_int_range_validator(1, 65536),
    cmdline_help = "Port number for XMPP client connections",
    doc = """Port number for client to server connections."""
    )

XMPPSettings.add_setting(u"c2s_service", default = "xmpp-client",
    type = unicode,
    cmdline_help = "SRV service name XMPP client connections",
    doc = """SRV service name for client to server connections."""
    )

XMPPSettings.add_setting(u"server", type = unicode, basic = True,
    cmdline_help = "Server address. (Default: use SRV lookup)",
    doc = """Server address to connect to. By default a DNS SRV record look-up
is done for the requested JID domain part and if that fails - 'A' or 'AAAA'
record lookup for the same domain. This setting may be used to force using
a specific server or when SRV look-ups are not available."""
    )
XMPPSettings.add_setting(u"default_stanza_timeout", type = float, default = 300,
        validator = XMPPSettings.validate_positive_float,
        cmdline_help = "Time in seconds to wait for a stanza response",
        doc = u"""Time in seconds to wait for a stanza response."""
    )

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = clientstream
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# pylint: disable-msg=W0221

"""Client-Server stream handling.

Normative reference:
  - `RFC 6120 <http://www.ietf.org/rfc/rfc6120.txt>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

from .streambase import StreamBase
from .jid import JID
from .settings import XMPPSettings
from .constants import STANZA_CLIENT_NS

class ClientStream(StreamBase):
    """Handles XMPP-IM c2s stream.

    Both client and server side of the connection is supported.
    """
    # pylint: disable=R0904
    def __init__(self, jid, stanza_route, handlers, settings = None):
        """Initialize the ClientStream object.

        :Parameters:
            - `jid`: local JID.
            - `handlers`: XMPP feature and event handlers
            - `settings`: PyXMPP settings for the stream
        :Types:
            - `jid`: `JID`
            - `settings`: `XMPPSettings`
        """
        if handlers is None:
            handlers = []
        if settings is None:
            settings = XMPPSettings()
        if "resource" not in settings:
            settings["resource"] = jid.resource
        StreamBase.__init__(self, STANZA_CLIENT_NS, stanza_route,
                                                        handlers, settings)
        self.me = JID(jid.local, jid.domain)

    def initiate(self, transport, to = None):
        """Initiate an XMPP connection over the `transport`.

        :Parameters:
            - `transport`: an XMPP transport instance
            - `to`: peer name (defaults to own jid domain part)
        """
        if to is None:
            to = JID(self.me.domain)
        return StreamBase.initiate(self, transport, to)

    def receive(self, transport, myname = None):
        """Receive an XMPP connection over the `transport`.

        :Parameters:
            - `transport`: an XMPP transport instance
            - `myname`: local stream endpoint name (defaults to own jid domain
              part).
        """
        if myname is None:
            myname = JID(self.me.domain)
        return StreamBase.receive(self, transport, myname)

    def fix_out_stanza(self, stanza):
        """Fix outgoing stanza.

        On a client clear the sender JID. On a server set the sender
        address to the own JID if the address is not set yet."""
        StreamBase.fix_out_stanza(self, stanza)
        if self.initiator:
            if stanza.from_jid:
                stanza.from_jid = None
        else:
            if not stanza.from_jid:
                stanza.from_jid = self.me

    def fix_in_stanza(self, stanza):
        """Fix an incoming stanza.

        Ona server replace the sender address with authorized client JID."""
        StreamBase.fix_in_stanza(self, stanza)
        if not self.initiator:
            if stanza.from_jid != self.peer:
                stanza.set_from(self.peer)

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = constants
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"Common XMPP constants."""

XML_NS = "http://www.w3.org/XML/1998/namespace"
XML_QNP = "{{{0}}}".format(XML_NS)

STREAM_NS = "http://etherx.jabber.org/streams"
STREAM_QNP = "{{{0}}}".format(STREAM_NS)
STREAM_ROOT_TAG = STREAM_QNP + "stream"

BIND_NS = "urn:ietf:params:xml:ns:xmpp-bind"
BIND_QNP = "{{{0}}}".format(BIND_NS)

SESSION_NS = "urn:ietf:params:xml:ns:xmpp-session"
SESSION_QNP = "{{{0}}}".format(SESSION_NS)

STANZA_CLIENT_NS = "jabber:client"
STANZA_CLIENT_QNP = "{{{0}}}".format(STANZA_CLIENT_NS)

STANZA_SERVER_NS = "jabber:server"
STANZA_SERVER_QNP = "{{{0}}}".format(STANZA_SERVER_NS)

STANZA_NAMESPACES = (STANZA_CLIENT_NS, STANZA_SERVER_NS)

STANZA_ERROR_NS = 'urn:ietf:params:xml:ns:xmpp-stanzas'
STANZA_ERROR_QNP = "{{{0}}}".format(STANZA_ERROR_NS)

STREAM_ERROR_NS = 'urn:ietf:params:xml:ns:xmpp-streams'
STREAM_ERROR_QNP = "{{{0}}}".format(STREAM_ERROR_NS)

PYXMPP_ERROR_NS = 'http://pyxmpp.jajcus.net/xmlns/errors'
PYXMPP_ERROR_QNP = "{{{0}}}".format(PYXMPP_ERROR_NS)

SASL_NS = "urn:ietf:params:xml:ns:xmpp-sasl"
SASL_QNP = "{{{0}}}".format(SASL_NS)

TLS_NS = "urn:ietf:params:xml:ns:xmpp-tls"
TLS_QNP = "{{{0}}}".format(TLS_NS)


XML_LANG_QNAME = XML_QNP + "lang"

########NEW FILE########
__FILENAME__ = error
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""XMPP error handling.

Normative reference:
  - `RFC 6120 <http://xmpp.org/rfcs/rfc6120.html>`__
  - `RFC 3920 <http://xmpp.org/rfcs/rfc3920.html>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import logging

from .etree import ElementTree, ElementClass
from copy import deepcopy

from .constants import STANZA_ERROR_NS, STREAM_ERROR_NS
from .constants import STREAM_QNP, STANZA_ERROR_QNP, STREAM_ERROR_QNP
from .constants import STANZA_CLIENT_QNP, STANZA_SERVER_QNP, STANZA_NAMESPACES
from .constants import XML_LANG_QNAME
from .xmppserializer import serialize

logger = logging.getLogger("pyxmpp2.error")

STREAM_ERRORS = {
            u"bad-format":
                ("Received XML cannot be processed",),
            u"bad-namespace-prefix":
                ("Bad namespace prefix",),
            u"conflict":
                ("Closing stream because of conflicting stream being opened",),
            u"connection-timeout":
                ("Connection was idle too long",),
            u"host-gone":
                ("Hostname is no longer hosted on the server",),
            u"host-unknown":
                ("Hostname requested is not known to the server",),
            u"improper-addressing":
                ("Improper addressing",),
            u"internal-server-error":
                ("Internal server error",),
            u"invalid-from":
                ("Invalid sender address",),
            u"invalid-namespace":
                ("Invalid namespace",),
            u"invalid-xml":
                ("Invalid XML",),
            u"not-authorized":
                ("Not authorized",),
            u"not-well-formed":
                ("XML sent by client is not well formed",),
            u"policy-violation":
                ("Local policy violation",),
            u"remote-connection-failed":
                ("Remote connection failed",),
            u"reset":
                ("Stream reset",),
            u"resource-constraint":
                ("Remote connection failed",),
            u"restricted-xml":
                ("Restricted XML received",),
            u"see-other-host":
                ("Redirection required",),
            u"system-shutdown":
                ("The server is being shut down",),
            u"undefined-condition":
                ("Unknown error",),
            u"unsupported-encoding":
                ("Unsupported encoding",),
            u"unsupported-feature":
                ("Unsupported feature",),
            u"unsupported-stanza-type":
                ("Unsupported stanza type",),
            u"unsupported-version":
                ("Unsupported protocol version",),
    }

STREAM_ERRORS_Q = dict([( "{{{0}}}{1}".format(STREAM_ERROR_NS, x[0]), x[1])
                                            for x in STREAM_ERRORS.items()])

UNDEFINED_STREAM_CONDITION = \
        "{urn:ietf:params:xml:ns:xmpp-streams}undefined-condition"
UNDEFINED_STANZA_CONDITION = \
        "{urn:ietf:params:xml:ns:xmpp-stanzas}undefined-condition"

STANZA_ERRORS = {
            u"bad-request":
                ("Bad request",
                "modify"),
            u"conflict":
                ("Named session or resource already exists",
                "cancel"),
            u"feature-not-implemented":
                ("Feature requested is not implemented",
                "cancel"),
            u"forbidden":
                ("You are forbidden to perform requested action",
                "auth"),
            u"gone":
                ("Recipient or server can no longer be contacted"
                                                        " at this address",
                "modify"),
            u"internal-server-error":
                ("Internal server error",
                "wait"),
            u"item-not-found":
                ("Item not found"
                ,"cancel"),
            u"jid-malformed":
                ("JID malformed",
                "modify"),
            u"not-acceptable":
                ("Requested action is not acceptable",
                "modify"),
            u"not-allowed":
                ("Requested action is not allowed",
                "cancel"),
            u"not-authorized":
                ("Not authorized",
                "auth"),
            u"policy-violation":
                ("Policy violation",
                "cancel"),
            u"recipient-unavailable":
                ("Recipient is not available",
                "wait"),
            u"redirect":
                ("Redirection",
                "modify"),
            u"registration-required":
                ("Registration required",
                "auth"),
            u"remote-server-not-found":
                ("Remote server not found",
                "cancel"),
            u"remote-server-timeout":
                ("Remote server timeout",
                "wait"),
            u"resource-constraint":
                ("Resource constraint",
                "wait"),
            u"service-unavailable":
                ("Service is not available",
                "cancel"),
            u"subscription-required":
                ("Subscription is required",
                "auth"),
            u"undefined-condition":
                ("Unknown error",
                "cancel"),
            u"unexpected-request":
                ("Unexpected request",
                "wait"),
    }

STANZA_ERRORS_Q = dict([( "{{{0}}}{1}".format(STANZA_ERROR_NS, x[0]), x[1])
                                            for x in STANZA_ERRORS.items()])

OBSOLETE_CONDITIONS = {
            # changed between RFC 3920 and RFC 6120
            "{urn:ietf:params:xml:ns:xmpp-streams}xml-not-well-formed":
                    "{urn:ietf:params:xml:ns:xmpp-streams}not-well-formed",
            "{urn:ietf:params:xml:ns:xmpp-streams}invalid-id":
                                                UNDEFINED_STREAM_CONDITION,
            "{urn:ietf:params:xml:ns:xmpp-stanzas}payment-required":
                                                UNDEFINED_STANZA_CONDITION,
}

class ErrorElement(object):
    """Base class for both XMPP stream and stanza errors

    :Ivariables:
        - `condition`: the condition element
        - `text`: human-readable error description
        - `custom_condition`: list of custom condition elements
        - `language`: xml:lang of the error element
    :Types:
        - `condition_name`: `unicode`
        - `condition`: `unicode`
        - `text`: `unicode`
        - `custom_condition`: `list` of :etree:`ElementTree.Element`
        - `language`: `unicode`

    """
    error_qname = "{unknown}error"
    text_qname = "{unknown}text"
    cond_qname_prefix = "{unknown}"
    def __init__(self, element_or_cond, text = None, language = None):
        """Initialize an StanzaErrorElement object.

        :Parameters:
            - `element_or_cond`: XML <error/> element to decode or an error
              condition name or element.
            - `text`: optional description to override the default one
            - `language`: RFC 3066 language tag for the description
        :Types:
            - `element_or_cond`: :etree:`ElementTree.Element` or `unicode`
            - `text`: `unicode`
            - `language`: `unicode`
        """
        self.text = None
        self.custom_condition = []
        self.language = language
        if isinstance(element_or_cond, basestring):
            self.condition = ElementTree.Element(self.cond_qname_prefix
                                                        + element_or_cond)
        elif not isinstance(element_or_cond, ElementClass):
            raise TypeError, "Element or unicode string expected"
        else:
            self._from_xml(element_or_cond)

        if text:
            self.text = text

    def _from_xml(self, element):
        """Initialize an ErrorElement object from an XML element.

        :Parameters:
            - `element`: XML element to be decoded.
        :Types:
            - `element`: :etree:`ElementTree.Element`
        """
        # pylint: disable-msg=R0912
        if element.tag != self.error_qname:
            raise ValueError(u"{0!r} is not a {1!r} element".format(
                                                    element, self.error_qname))
        lang = element.get(XML_LANG_QNAME, None)
        if lang:
            self.language = lang
        self.condition = None
        for child in element:
            if child.tag.startswith(self.cond_qname_prefix):
                if self.condition is not None:
                    logger.warning("Multiple conditions in XMPP error element.")
                    continue
                self.condition = deepcopy(child)
            elif child.tag == self.text_qname:
                lang = child.get(XML_LANG_QNAME, None)
                if lang:
                    self.language = lang
                self.text = child.text.strip()
            else:
                bad = False
                for prefix in (STREAM_QNP, STANZA_CLIENT_QNP, STANZA_SERVER_QNP,
                                            STANZA_ERROR_QNP, STREAM_ERROR_QNP):
                    if child.tag.startswith(prefix):
                        logger.warning("Unexpected stream-namespaced"
                                                        " element in error.")
                        bad = True
                        break
                if not bad:
                    self.custom_condition.append( deepcopy(child) )
        if self.condition is None:
            self.condition = ElementTree.Element(self.cond_qname_prefix
                                                    + "undefined-condition")
        if self.condition.tag in OBSOLETE_CONDITIONS:
            new_cond_name = OBSOLETE_CONDITIONS[self.condition.tag]
            self.condition = ElementTree.Element(new_cond_name)

    @property
    def condition_name(self):
        """Return the condition name (condition element name without the
        namespace)."""
        return self.condition.tag.split("}", 1)[1]

    def add_custom_condition(self, element):
        """Add custom condition element to the error.

        :Parameters:
            - `element`: XML element
        :Types:
            - `element`: :etree:`ElementTree.Element`

        """
        self.custom_condition.append(element)

    def serialize(self):
        """Serialize the stanza into a Unicode XML string.

        :return: serialized element.
        :returntype: `unicode`"""
        return serialize(self.as_xml())

    def as_xml(self):
        """Return the XML error representation.

        :returntype: :etree:`ElementTree.Element`"""
        result = ElementTree.Element(self.error_qname)
        result.append(deepcopy(self.condition))
        if self.text:
            text = ElementTree.SubElement(result, self.text_qname)
            if self.language:
                text.set(XML_LANG_QNAME, self.language)
            text.text = self.text
        return result

class StreamErrorElement(ErrorElement):
    """Stream error element."""
    error_qname = STREAM_QNP + "error"
    text_qname = STREAM_QNP + "text"
    cond_qname_prefix = STREAM_ERROR_QNP
    def __init__(self, element_or_cond, text = None, language = None):
        """Initialize an StreamErrorElement object.

        :Parameters:
            - `element_or_cond`: XML <error/> element to decode or an error
              condition name or element.
            - `text`: optional description to override the default one
            - `language`: RFC 3066 language tag for the description
        :Types:
            - `element_or_cond`: :etree:`ElementTree.Element` or `unicode`
            - `text`: `unicode`
            - `language`: `unicode`
        """
        if isinstance(element_or_cond, unicode):
            if element_or_cond not in STREAM_ERRORS:
                raise ValueError("Bad error condition")
        ErrorElement.__init__(self, element_or_cond, text, language)

    def get_message(self):
        """Get the standard English message for the error.

        :return: the error message.
        :returntype: `unicode`"""
        cond = self.condition_name
        if cond in STREAM_ERRORS:
            return STREAM_ERRORS[cond][0]
        else:
            return None

class StanzaErrorElement(ErrorElement):
    """Stanza error element.

    :Ivariables:
        - `error_type`: 'type' of the error, one of: 'auth', 'cancel',
          'continue', 'modify', 'wait'
    :Types:
        - `error_type`: `unicode`
    """
    error_qname = STANZA_CLIENT_QNP + "error"
    text_qname = STANZA_CLIENT_QNP + "text"
    cond_qname_prefix = STANZA_ERROR_QNP
    def __init__(self, element_or_cond, text = None, language = None,
                                                            error_type = None):
        """Initialize an StanzaErrorElement object.

        :Parameters:
            - `element_or_cond`: XML <error/> element to decode or an error
              condition name or element.
            - `text`: optional description to override the default one
            - `language`: RFC 3066 language tag for the description
            - `error_type`: 'type' of the error, one of: 'auth', 'cancel',
              'continue', 'modify', 'wait'
        :Types:
            - `element_or_cond`: :etree:`ElementTree.Element` or `unicode`
            - `text`: `unicode`
            - `language`: `unicode`
            - `error_type`: `unicode`
        """
        self.error_type = None
        if isinstance(element_or_cond, basestring):
            if element_or_cond not in STANZA_ERRORS:
                raise ValueError(u"Bad error condition")
        elif element_or_cond.tag.startswith(u"{"):
            namespace = element_or_cond.tag[1:].split(u"}", 1)[0]
            if namespace not in STANZA_NAMESPACES:
                raise ValueError(u"Bad error namespace {0!r}".format(namespace))
            self.error_qname = u"{{{0}}}error".format(namespace)
            self.text_qname = u"{{{0}}}text".format(namespace)
        else:
            raise ValueError(u"Bad error namespace - no namespace")
        ErrorElement.__init__(self, element_or_cond, text, language)
        if error_type is not None:
            self.error_type = error_type
        if self.condition.tag in STANZA_ERRORS_Q:
            cond = self.condition.tag
        else:
            cond = UNDEFINED_STANZA_CONDITION
        if not self.error_type:
            self.error_type = STANZA_ERRORS_Q[cond][1]

    def _from_xml(self, element):
        """Initialize an ErrorElement object from an XML element.

        :Parameters:
            - `element`: XML element to be decoded.
        :Types:
            - `element`: :etree:`ElementTree.Element`
        """
        ErrorElement._from_xml(self, element)
        error_type = element.get(u"type")
        if error_type:
            self.error_type = error_type

    def get_message(self):
        """Get the standard English message for the error.

        :return: the error message.
        :returntype: `unicode`"""
        cond = self.condition_name
        if cond in STANZA_ERRORS:
            return STANZA_ERRORS[cond][0]
        else:
            return None

    def as_xml(self, stanza_namespace = None): # pylint: disable-msg=W0221
        """Return the XML error representation.

        :Parameters:
            - `stanza_namespace`: namespace URI of the containing stanza
        :Types:
            - `stanza_namespace`: `unicode`

        :returntype: :etree:`ElementTree.Element`"""
        if stanza_namespace:
            self.error_qname = "{{{0}}}error".format(stanza_namespace)
            self.text_qname = "{{{0}}}text".format(stanza_namespace)
        result = ErrorElement.as_xml(self)
        result.set("type", self.error_type)
        return result

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = etree
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""ElementTree API selection.

The rest of PyXMPP2 package imports the ElementTree API from this module.

The actual API can be selected in one of two ways:

By importing this module (before anything else) its :etree:`ElementTree`
variable:

.. python::

    import pyxmpp2.etree
    import xml.etree.cElementTree
    pyxmpp2.etree.ElementTree = xml.etree.cElementTree

Or by setting the 'PYXMPP2_ETREE' environment variable, e.g.::

    $ PYXMPP2_ETREE="xml.etree"

By default the standard Python ElementTree implementation is used
(`xml.etree.ElementTree
<http://docs.python.org/library/xml.etree.elementtree.html>`__)
"""
# pylint: disable=C0103

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import os
import sys
from abc import ABCMeta

if "PYXMPP2_ETREE" in os.environ:
    ElementTree = __import__(os.environ["PYXMPP2_ETREE"], fromlist=[""])
else:
    from xml.etree import ElementTree # pylint: disable=W0404

class ElementClass:
    """Abstract class used to reference the :etree:`ElementTree.Element`
    object type of the selected Element Tree implementation.
    """
    # pylint: disable=W0232,R0903
    __metaclass__ = ABCMeta
    element_type = None
    @classmethod
    def __subclasshook__(cls, other):
        if cls.element_type is None:
            cls.element_type = type(ElementTree.Element("x"))
        if cls is ElementClass:
            return other is cls.element_type or hasattr(other, "tag")
        return NotImplemented

def element_to_unicode(element):
    """Serialize an XML element into a unicode string.

    This should work the same on Python2 and Python3 and with all
    :etree:`ElementTree` implementations.

    :Parameters:
        - `element`: the XML element to serialize
    :Types:
        - `element`: :etree:`ElementTree.Element`
    """
    if hasattr(ElementTree, 'tounicode'):
        # pylint: disable=E1103
        return ElementTree.tounicode("element")
    elif sys.version_info.major < 3:
        return unicode(ElementTree.tostring(element))
    else:
        return ElementTree.tostring(element, encoding = "unicode")



########NEW FILE########
__FILENAME__ = exceptions
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""PyXMPP exceptions.

This module defines all exceptions raised by PyXMPP.
"""
# pylint: disable-msg=R0901

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import logging


class Error(StandardError):
    """Base class for all PyXMPP exceptions."""
    pass

class JIDError(Error, ValueError):
    "Exception raised when invalid JID is used"
    pass

class PyXMPPIOError(Error):
    """Exception raised on I/O error."""
    pass

class StreamError(Error):
    """Base class for all stream errors."""
    pass

class StreamEncryptionRequired(StreamError):
    """Exception raised when stream encryption is requested, but not used."""
    pass

class HostMismatch(StreamError):
    """Exception raised when the connected host name is other then requested."""
    pass

class FatalStreamError(StreamError):
    """Base class for all fatal Stream exceptions.

    When `FatalStreamError` is raised the stream is no longer usable."""
    pass

class StreamParseError(FatalStreamError):
    """Raised when invalid XML is received in an XMPP stream."""
    pass

class DNSError(FatalStreamError):
    """Raised when no host name could be resolved for the target."""
    pass

class UnexpectedCNAMEError(DNSError):
    """Raised when CNAME record was found when A or AAAA was expected."""
    pass

class StreamAuthenticationError(FatalStreamError):
    """Raised when stream authentication fails."""
    pass

class TLSNegotiationFailed(FatalStreamError):
    """Raised when stream TLS negotiation fails."""
    pass

class TLSError(FatalStreamError):
    """Raised on TLS error during stream processing."""
    pass

class SASLNotAvailable(StreamAuthenticationError):
    """Raised when SASL authentication is requested, but not available."""
    pass

class SASLMechanismNotAvailable(StreamAuthenticationError):
    """Raised when none of SASL authentication mechanisms requested is
    available."""
    pass

class SASLAuthenticationFailed(StreamAuthenticationError):
    """Raised when stream SASL authentication fails."""
    pass

class StringprepError(Error):
    """Exception raised when string preparation results in error."""
    pass

class ClientError(Error):
    """Raised on a client error."""
    pass

class NoRouteError(Error):
    """Raised when a stanza cannot be routed internally."""
    pass

class FatalClientError(ClientError):
    """Raised on a fatal client error."""
    pass

class ClientStreamError(StreamError):
    """Raised on a client stream error."""
    pass

class FatalClientStreamError(FatalStreamError):
    """Raised on a fatal client stream error."""
    pass

class LegacyAuthenticationError(ClientStreamError):
    """Raised on a legacy authentication error."""
    pass

class RegistrationError(ClientStreamError):
    """Raised on a in-band registration error."""
    pass

class ComponentStreamError(StreamError):
    """Raised on a component error."""
    pass

class FatalComponentStreamError(ComponentStreamError, FatalStreamError):
    """Raised on a fatal component error."""
    pass

########################
# Protocol Errors

class ProtocolError(Error):
    """Raised when there is something wrong with a stanza processed.

    When not processed earlier by an application, the exception will be catched
    by the stanza dispatcher to return XMPP error to the stanza sender, when
    allowed.

    ProtocolErrors handled internally by PyXMPP will be logged via the logging
    interface. Errors reported to the sender will be logged using
    "pyxmpp2.ProtocolError.reported" channel and the ignored errors using
    "pyxmpp2.ProtocolError.ignored" channel. Both with the "debug" level.

    """

    logger_reported = logging.getLogger("pyxmpp2.ProtocolError.reported")
    logger_ignored = logging.getLogger("pyxmpp2.ProtocolError.ignored")

    def __init__(self, xmpp_name, message):
        Error.__init__(self, xmpp_name, message)

    @property
    def xmpp_name(self):
        """XMPP error name which should be reported"""
        return self.args[0]
    @property
    def message(self):
        """The error message."""
        return self.args[1]
    def log_reported(self):
        """Log message via the "pyxmpp.ProtocolError.reported" logger."""
        self.logger_reported.debug(u"Protocol error detected: {0}"
                                                        .format(self.message))
    def log_ignored(self):
        """Log message via the "pyxmpp.ProtocolError.ignored" logger."""
        self.logger_ignored.debug(u"Protocol error detected: {0}"
                                                        .format(self.message))
    def __unicode__(self):
        return str(self.args[1])
    def __repr__(self):
        return "<ProtocolError %r %r>" % (self.xmpp_name, self.message)

class BadRequestProtocolError(ProtocolError):
    """Raised when invalid stanza is processed and 'bad-request' error should
    be reported."""
    def __init__(self, message):
        ProtocolError.__init__(self, "bad-request", message)

class NotAcceptableProtocolError(ProtocolError):
    """Raised when invalid stanza is processed and 'not-acceptable' error
    should be reported."""
    def __init__(self, message):
        ProtocolError.__init__(self, "not-acceptable", message)

class JIDMalformedProtocolError(ProtocolError, JIDError):
    """Raised when invalid JID is encountered."""
    def __init__(self, message):
        JIDError.__init__(self)
        ProtocolError.__init__(self, "jid-malformed", message)

class FeatureNotImplementedProtocolError(ProtocolError):
    """Raised when stanza requests a feature which is not (yet) implemented."""
    def __init__(self, message):
        ProtocolError.__init__(self, "feature-not-implemented", message)

class ServiceUnavailableProtocolError(ProtocolError):
    """Raised when stanza requests a feature which is not (yet) implemented."""
    def __init__(self, message):
        ProtocolError.__init__(self, "service-unavailable", message)

class ResourceConstraintProtocolError(ProtocolError):
    """Raised when stanza requests a feature which is not (yet) implemented."""
    def __init__(self, message):
        ProtocolError.__init__(self, "resource-constraint", message)

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = expdict
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""Dictionary with item expiration."""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import time
import threading
import logging

logger = logging.getLogger("pyxmpp2.expdict")

_NO_DEFAULT = object()

class ExpiringDictionary(dict):
    """An extension to standard Python dictionary objects which implements item
    expiration.

    Each item in ExpiringDictionary has its expiration time assigned, after
    which the item is removed from the mapping.

    :Ivariables:
        - `_timeouts`: a dictionary with timeout values and timeout callback for
          stored objects.
        - `_default_timeout`: the default timeout value (in seconds from now).
        - `_lock`: access synchronization lock.
    :Types:
        - `_timeouts`: `dict`
        - `_default_timeout`: `float`
        - `_lock`: :std:`threading.RLock`"""
    __slots__ = ['_timeouts', '_default_timeout', '_lock']
    def __init__(self, default_timeout = 300.0):
        """Initialize an `ExpiringDictionary` object.

        :Parameters:
            - `default_timeout`: default timeout value (in seconds) for stored
              objects.
        :Types:
            - `default_timeout`: `float`
        """
        dict.__init__(self)
        self._timeouts = {}
        self._default_timeout = default_timeout
        self._lock = threading.RLock()

    def __delitem__(self, key):
        with self._lock:
            logger.debug("expdict.__delitem__({0!r})".format(key))
            del self._timeouts[key]
            return dict.__delitem__(self, key)

    def __getitem__(self, key):
        with self._lock:
            logger.debug("expdict.__getitem__({0!r})".format(key))
            self._expire_item(key)
            return dict.__getitem__(self, key)

    def pop(self, key, default = _NO_DEFAULT):
        with self._lock:
            self._expire_item(key)
            del self._timeouts[key]
            if default is not _NO_DEFAULT:
                return dict.pop(self, key, default)
            else:
                return dict.pop(self, key)

    def __setitem__(self, key, value):
        logger.debug("expdict.__setitem__({0!r}, {1!r})".format(key, value))
        return self.set_item(key, value)

    def set_item(self, key, value, timeout = None, timeout_callback = None):
        """Set item of the dictionary.

        :Parameters:
            - `key`: the key.
            - `value`: the object to store.
            - `timeout`: timeout value for the object (in seconds from now).
            - `timeout_callback`: function to be called when the item expires.
              The callback should accept none, one (the key) or two (the key
              and the value) arguments.
        :Types:
            - `key`: any hashable value
            - `value`: any python object
            - `timeout`: `int`
            - `timeout_callback`: callable
        """
        with self._lock:
            logger.debug("expdict.__setitem__({0!r}, {1!r}, {2!r}, {3!r})"
                            .format(key, value, timeout, timeout_callback))
            if not timeout:
                timeout = self._default_timeout
            self._timeouts[key] = (time.time() + timeout, timeout_callback)
            return dict.__setitem__(self, key, value)

    def expire(self):
        """Do the expiration of dictionary items.

        Remove items that expired by now from the dictionary.

        :Return: time, in seconds, when the next item expires or `None`
        :returntype: `float`
        """
        with self._lock:
            logger.debug("expdict.expire. timeouts: {0!r}"
                                                    .format(self._timeouts))
            next_timeout = None
            for k in self._timeouts.keys():
                ret = self._expire_item(k)
                if ret is not None:
                    if next_timeout is None:
                        next_timeout = ret
                    else:
                        next_timeout = min(next_timeout, ret)
            return next_timeout

    def clear(self):
        with self._lock:
            self._timeouts.clear()
            dict.clear(self)

    def _expire_item(self, key):
        """Do the expiration of a dictionary item.

        Remove the item if it has expired by now.

        :Parameters:
            - `key`: key to the object.
        :Types:
            - `key`: any hashable value
        """
        (timeout, callback) = self._timeouts[key]
        now = time.time()
        if timeout <= now:
            item = dict.pop(self, key)
            del self._timeouts[key]
            if callback:
                try:
                    callback(key, item)
                except TypeError:
                    try:
                        callback(key)
                    except TypeError:
                        callback()
            return None
        else:
            return timeout - now

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = component
#
# (C) Copyright 2003-2010 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
"""Component (jabber:component:accept) stream handling.

Normative reference:
  - `JEP 114 <http://www.jabber.org/jeps/jep-0114.html>`__
"""

from __future__ import absolute_import, division

raise ImportError("{0} is not yet rewritten for PyXMPP2".format(__name__))

__docformat__="restructuredtext en"

import hashlib

import logging

from ..stream import Stream
from ..streambase import stanza_factory,HostMismatch
from ..xmlextra import common_doc,common_root
from ..utils import to_utf8
from ..exceptions import StreamError,FatalStreamError,ComponentStreamError,FatalComponentStreamError

class ComponentStream(Stream):
    """Handles jabberd component (jabber:component:accept) connection stream.

    :Ivariables:
        - `server`: server to use.
        - `port`: port number to use.
        - `secret`: authentication secret.
    :Types:
        - `server`: `unicode`
        - `port`: `int`
        - `secret`: `unicode`"""

    def __init__(self, jid, secret, server, port, keepalive = 0, owner = None):
        """Initialize a `ComponentStream` object.

        :Parameters:
            - `jid`: JID of the component.
            - `secret`: authentication secret.
            - `server`: server address.
            - `port`: TCP port number on the server.
            - `keepalive`: keepalive interval. 0 to disable.
            - `owner`: `Client`, `Component` or similar object "owning" this stream.
        """
        Stream.__init__(self, "jabber:component:accept",
                    sasl_mechanisms = [],
                    tls_settings = None,
                    keepalive = keepalive,
                    owner = owner)
        self.server=server
        self.port=port
        self.me=jid
        self.secret=secret
        self.process_all_stanzas=1
        self.__logger=logging.getLogger("pyxmpp2.jabberd.ComponentStream")

    def _reset(self):
        """Reset `ComponentStream` object state, making the object ready to
        handle new connections."""
        Stream._reset(self)

    def connect(self,server=None,port=None):
        """Establish a client connection to a server.

        [component only]

        :Parameters:
            - `server`: name or address of the server to use.  If not given
              then use the one specified when creating the object.
            - `port`: port number of the server to use.  If not given then use
              the one specified when creating the object.

        :Types:
            - `server`: `unicode`
            - `port`: `int`"""
        self.lock.acquire()
        try:
            self._connect(server,port)
        finally:
            self.lock.release()

    def _connect(self,server=None,port=None):
        """Same as `ComponentStream.connect` but assume `self.lock` is acquired."""
        if self.me.node or self.me.resource:
            raise Value("Component JID may have only domain defined")
        if not server:
            server=self.server
        if not port:
            port=self.port
        if not server or not port:
            raise ValueError("Server or port not given")
        Stream._connect(self,server,port,None,self.me)

    def accept(self,sock):
        """Accept an incoming component connection.

        [server only]

        :Parameters:
            - `sock`: a listening socket."""
        Stream.accept(self,sock,None)

    def stream_start(self,doc):
        """Process <stream:stream> (stream start) tag received from peer.

        Call `Stream.stream_start`, but ignore any `HostMismatch` error.

        :Parameters:
            - `doc`: document created by the parser"""
        try:
            Stream.stream_start(self,doc)
        except HostMismatch:
            pass

    def _post_connect(self):
        """Initialize authentication when the connection is established
        and we are the initiator."""
        if self.initiator:
            self._auth()

    def _compute_handshake(self):
        """Compute the authentication handshake value.

        :return: the computed hash value.
        :returntype: `str`"""
        return hashlib.sha1(to_utf8(self.stream_id)+to_utf8(self.secret)).hexdigest()

    def _auth(self):
        """Authenticate on the server.

        [component only]"""
        if self.authenticated:
            self.__logger.debug("_auth: already authenticated")
            return
        self.__logger.debug("doing handshake...")
        hash_value=self._compute_handshake()
        n=common_root.newTextChild(None,"handshake",hash_value)
        self._write_node(n)
        n.unlinkNode()
        n.freeNode()
        self.__logger.debug("handshake hash sent.")

    def _process_node(self,node):
        """Process first level element of the stream.

        Handle component handshake (authentication) element, and
        treat elements in "jabber:component:accept", "jabber:client"
        and "jabber:server" equally (pass to `self.process_stanza`).
        All other elements are passed to `Stream._process_node`.

        :Parameters:
            - `node`: XML node describing the element
        """
        ns=node.ns()
        if ns:
            ns_uri=node.ns().getContent()
        if (not ns or ns_uri=="jabber:component:accept") and node.name=="handshake":
            if self.initiator and not self.authenticated:
                self.authenticated=1
                self.state_change("authenticated",self.me)
                self._post_auth()
                return
            elif not self.authenticated and node.getContent()==self._compute_handshake():
                self.peer=self.me
                n=common_doc.newChild(None,"handshake",None)
                self._write_node(n)
                n.unlinkNode()
                n.freeNode()
                self.peer_authenticated=1
                self.state_change("authenticated",self.peer)
                self._post_auth()
                return
            else:
                self._send_stream_error("not-authorized")
                raise FatalComponentStreamError("Hanshake error.")

        if ns_uri in ("jabber:component:accept","jabber:client","jabber:server"):
            stanza=stanza_factory(node)
            self.lock.release()
            try:
                self.process_stanza(stanza)
            finally:
                self.lock.acquire()
                stanza.free()
            return
        return Stream._process_node(self,node)

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = dataforms
#
# (C) Copyright 2005-2010 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
"""Jabber Data Forms support.

Normative reference:
  - `JEP 4 <http://www.jabber.org/jeps/jep-0004.html>`__
"""

from __future__ import absolute_import, division

raise ImportError("{0} is not yet rewritten for PyXMPP2".format(__name__))

__docformat__="restructuredtext en"

import copy
import libxml2
import warnings
from ..objects import StanzaPayloadObject
from ..utils import from_utf8, to_utf8
from ..xmlextra import xml_element_ns_iter
from ..jid import JID
from ..exceptions import BadRequestProtocolError

DATAFORM_NS = "jabber:x:data"

class Option(StanzaPayloadObject):
    """One of optional data form field values.

    :Ivariables:
        - `label`: option label.
        - `value`: option value.
    :Types:
        - `label`: `unicode`
        - `value`: `unicode`
    """
    xml_element_name = "option"
    xml_element_namespace = DATAFORM_NS

    def __init__(self, value = None, label = None, values = None):
        """Initialize an `Option` object.

        :Parameters:
            - `value`: option value (mandatory).
            - `label`: option label (human-readable description).
            - `values`: for backward compatibility only.
        :Types:
            - `label`: `unicode`
            - `value`: `unicode`
        """
        self.label = label

        if value:
            self.value = value
        elif values:
            warnings.warn("Option constructor accepts only single value now.", DeprecationWarning, stacklevel=1)
            self.value = values[0]
        else:
            raise TypeError("value argument to pyxmpp.dataforms.Option is required")


    @property
    def values(self):
        """Return list of option values (always single element). Obsolete. For
        backwards compatibility only."""
        return [self.value]

    def complete_xml_element(self, xmlnode, doc):
        """Complete the XML node with `self` content.

        :Parameters:
            - `xmlnode`: XML node with the element being built. It has already
              right name and namespace, but no attributes or content.
            - `doc`: document to which the element belongs.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`
            - `doc`: `libxml2.xmlDoc`"""
        _unused = doc
        if self.label is not None:
            xmlnode.setProp("label", self.label.encode("utf-8"))
        xmlnode.newTextChild(xmlnode.ns(), "value", self.value.encode("utf-8"))
        return xmlnode

    @classmethod
    def _new_from_xml(cls, xmlnode):
        """Create a new `Option` object from an XML element.

        :Parameters:
            - `xmlnode`: the XML element.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`

        :return: the object created.
        :returntype: `Option`
        """
        label = from_utf8(xmlnode.prop("label"))
        child = xmlnode.children
        value = None
        for child in xml_element_ns_iter(xmlnode.children, DATAFORM_NS):
            if child.name == "value":
                value = from_utf8(child.getContent())
                break
        if value is None:
            raise BadRequestProtocolError("No value in <option/> element")
        return cls(value, label)

class Field(StanzaPayloadObject):
    """A data form field.

    :Ivariables:
        - `name`: field name.
        - `values`: field values.
        - `value`: field value parsed according to the form type.
        - `label`: field label (human-readable description).
        - `type`: field type ("boolean", "fixed", "hidden", "jid-multi",
          "jid-single", "list-multi", "list-single", "text-multi",
          "text-private" or "text-single").
        - `options`: field options (for "list-multi" or "list-single" fields).
        - `required`: `True` when the field is required.
        - `desc`: natural-language description of the field.
    :Types:
        - `name`: `unicode`
        - `values`: `list` of `unicode`
        - `value`: `bool` for "boolean" field, `JID` for "jid-single", `list` of `JID`
          for "jid-multi", `list` of `unicode` for "list-multi" and "text-multi"
          and `unicode` for other field types.
        - `label`: `unicode`
        - `type`: `str`
        - `options`: `Option`
        - `required`: `boolean`
        - `desc`: `unicode`
    """
    xml_element_name = "field"
    xml_element_namespace = DATAFORM_NS
    allowed_types = ("boolean", "fixed", "hidden", "jid-multi",
                "jid-single", "list-multi", "list-single", "text-multi",
                "text-private", "text-single")
    def __init__(self, name = None, values = None, field_type = None, label = None,
            options = None, required = False, desc = None, value = None):
        """Initialize a `Field` object.

        :Parameters:
            - `name`: field name.
            - `values`: raw field values. Not to be used together with `value`.
            - `field_type`: field type.
            - `label`: field label.
            - `options`: optional values for the field.
            - `required`: `True` if the field is required.
            - `desc`: natural-language description of the field.
            - `value`: field value or values in a field_type-specific type. May be used only
              if `values` parameter is not provided.
        :Types:
            - `name`: `unicode`
            - `values`: `list` of `unicode`
            - `field_type`: `str`
            - `label`: `unicode`
            - `options`: `list` of `Option`
            - `required`: `bool`
            - `desc`: `unicode`
            - `value`: `bool` for "boolean" field, `JID` for "jid-single", `list` of `JID`
              for "jid-multi", `list` of `unicode` for "list-multi" and "text-multi"
              and `unicode` for other field types.
        """
        self.name = name
        if field_type is not None and field_type not in self.allowed_types:
            raise ValueError("Invalid form field type: %r" % (field_type,))
        self.type = field_type
        if value is not None:
            if values:
                raise ValueError("values or value must be given, not both")
            self.value = value
        elif not values:
            self.values = []
        else:
            self.values = list(values)
        if field_type and not field_type.endswith("-multi") and len(self.values) > 1:
            raise ValueError("Multiple values for a single-value field")
        self.label = label
        if not options:
            self.options = []
        elif field_type and not field_type.startswith("list-"):
            raise ValueError("Options not allowed for non-list fields")
        else:
            self.options = list(options)
        self.required = required
        self.desc = desc

    def __getattr__(self, name):
        if name != "value":
            raise AttributeError("'Field' object has no attribute %r" % (name,))
        values = self.values
        t = self.type
        l = len(values)
        if t is not None:
            if t == "boolean":
                if l == 0:
                    return None
                elif l == 1:
                    v = values[0]
                    if v in ("0","false"):
                        return False
                    elif v in ("1","true"):
                        return True
                raise ValueError("Bad boolean value")
            elif t.startswith("jid-"):
                values = [JID(v) for v in values]
            if t.endswith("-multi"):
                return values
        if l == 0:
            return None
        elif l == 1:
            return values[0]
        else:
            raise ValueError("Multiple values of a single-value field")

    def __setattr__(self, name, value):
        if name != "value":
            self.__dict__[name] = value
            return
        if value is None:
            self.values = []
            return
        t = self.type
        if t == "boolean":
            if value:
                self.values = ["1"]
            else:
                self.values = ["0"]
            return
        if t and t.endswith("-multi"):
            values = list(value)
        else:
            values = [value]
        if t and t.startswith("jid-"):
            values = [JID(v).as_unicode() for v in values]
        self.values = values

    def add_option(self, value, label):
        """Add an option for the field.

        :Parameters:
            - `value`: option values.
            - `label`: option label (human-readable description).
        :Types:
            - `value`: `list` of `unicode`
            - `label`: `unicode`
        """
        if type(value) is list:
            warnings.warn(".add_option() accepts single value now.", DeprecationWarning, stacklevel=1)
            value = value[0]
        if self.type not in ("list-multi", "list-single"):
            raise ValueError("Options are allowed only for list types.")
        option = Option(value, label)
        self.options.append(option)
        return option

    def complete_xml_element(self, xmlnode, doc):
        """Complete the XML node with `self` content.

        :Parameters:
            - `xmlnode`: XML node with the element being built. It has already
              right name and namespace, but no attributes or content.
            - `doc`: document to which the element belongs.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`
            - `doc`: `libxml2.xmlDoc`"""
        if self.type is not None and self.type not in self.allowed_types:
            raise ValueError("Invalid form field type: %r" % (self.type,))
        if self.type is not None:
            xmlnode.setProp("type", self.type)
        if not self.label is None:
            xmlnode.setProp("label", to_utf8(self.label))
        if not self.name is None:
            xmlnode.setProp("var", to_utf8(self.name))
        if self.values:
            if self.type and len(self.values) > 1 and not self.type.endswith(u"-multi"):
                raise ValueError("Multiple values not allowed for %r field" % (self.type,))
            for value in self.values:
                xmlnode.newTextChild(xmlnode.ns(), "value", to_utf8(value))
        for option in self.options:
            option.as_xml(xmlnode, doc)
        if self.required:
            xmlnode.newChild(xmlnode.ns(), "required", None)
        if self.desc:
            xmlnode.newTextChild(xmlnode.ns(), "desc", to_utf8(self.desc))
        return xmlnode

    @classmethod
    def _new_from_xml(cls, xmlnode):
        """Create a new `Field` object from an XML element.

        :Parameters:
            - `xmlnode`: the XML element.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`

        :return: the object created.
        :returntype: `Field`
        """
        field_type = xmlnode.prop("type")
        label = from_utf8(xmlnode.prop("label"))
        name = from_utf8(xmlnode.prop("var"))
        child = xmlnode.children
        values = []
        options = []
        required = False
        desc = None
        while child:
            if child.type != "element" or child.ns().content != DATAFORM_NS:
                pass
            elif child.name == "required":
                required = True
            elif child.name == "desc":
                desc = from_utf8(child.getContent())
            elif child.name == "value":
                values.append(from_utf8(child.getContent()))
            elif child.name == "option":
                options.append(Option._new_from_xml(child))
            child = child.next
        if field_type and not field_type.endswith("-multi") and len(values) > 1:
            raise BadRequestProtocolError("Multiple values for a single-value field")
        return cls(name, values, field_type, label, options, required, desc)

class Item(StanzaPayloadObject):
    """An item of multi-item form data (e.g. a search result).

    Additionally to the direct access to the contained fields via the `fields` attribute,
    `Item` object provides an iterator and mapping interface for field access. E.g.::

        for field in item:
            ...

    or::

        field = item['field_name']

    or::

        if 'field_name' in item:
            ...

    :Ivariables:
        - `fields`: the fields of the item.
    :Types:
        - `fields`: `list` of `Field`.
    """
    xml_element_name = "item"
    xml_element_namespace = DATAFORM_NS

    def __init__(self, fields = None):
        """Initialize an `Item` object.

        :Parameters:
            - `fields`: item fields.
        :Types:
            - `fields`: `list` of `Field`.
        """
        if fields is None:
            self.fields = []
        else:
            self.fields = list(fields)

    def __getitem__(self, name_or_index):
        if isinstance(name_or_index, int):
            return self.fields[name_or_index]
        for f in self.fields:
            if f.name == name_or_index:
                return f
        raise KeyError(name_or_index)

    def __contains__(self, name):
        for f in self.fields:
            if f.name == name:
                return True
        return False

    def __iter__(self):
        for field in self.fields:
            yield field

    def add_field(self, name = None, values = None, field_type = None,
            label = None, options = None, required = False, desc = None, value = None):
        """Add a field to the item.

        :Parameters:
            - `name`: field name.
            - `values`: raw field values. Not to be used together with `value`.
            - `field_type`: field type.
            - `label`: field label.
            - `options`: optional values for the field.
            - `required`: `True` if the field is required.
            - `desc`: natural-language description of the field.
            - `value`: field value or values in a field_type-specific type. May be used only
              if `values` parameter is not provided.
        :Types:
            - `name`: `unicode`
            - `values`: `list` of `unicode`
            - `field_type`: `str`
            - `label`: `unicode`
            - `options`: `list` of `Option`
            - `required`: `bool`
            - `desc`: `unicode`
            - `value`: `bool` for "boolean" field, `JID` for "jid-single", `list` of `JID`
              for "jid-multi", `list` of `unicode` for "list-multi" and "text-multi"
              and `unicode` for other field types.

        :return: the field added.
        :returntype: `Field`
        """
        field = Field(name, values, field_type, label, options, required, desc, value)
        self.fields.append(field)
        return field

    def complete_xml_element(self, xmlnode, doc):
        """Complete the XML node with `self` content.

        :Parameters:
            - `xmlnode`: XML node with the element being built. It has already
              right name and namespace, but no attributes or content.
            - `doc`: document to which the element belongs.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`
            - `doc`: `libxml2.xmlDoc`"""
        for field in self.fields:
            field.as_xml(xmlnode, doc)

    @classmethod
    def _new_from_xml(cls, xmlnode):
        """Create a new `Item` object from an XML element.

        :Parameters:
            - `xmlnode`: the XML element.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`

        :return: the object created.
        :returntype: `Item`
        """
        child = xmlnode.children
        fields = []
        while child:
            if child.type != "element" or child.ns().content != DATAFORM_NS:
                pass
            elif child.name == "field":
                fields.append(Field._new_from_xml(child))
            child = child.next
        return cls(fields)

class Form(StanzaPayloadObject):
    """A JEP-0004 compliant data form.

    Additionally to the direct access to the contained fields via the `fields` attribute,
    `Form` object provides an iterator and mapping interface for field access. E.g.::

        for field in form:
            ...

    or::

        field = form['field_name']

    :Ivariables:
        - `type`: form type ("form", "submit", "cancel" or "result").
        - `title`: form title.
        - `instructions`: instructions for a form user.
        - `fields`: the fields in the form.
        - `reported_fields`: list of fields returned in a multi-item data form.
        - `items`: items in a multi-item data form.
    :Types:
        - `title`: `unicode`
        - `instructions`: `unicode`
        - `fields`: `list` of `Field`
        - `reported_fields`: `list` of `Field`
        - `items`: `list` of `Item`
    """
    allowed_types = ("form", "submit", "cancel", "result")
    xml_element_name = "x"
    xml_element_namespace = DATAFORM_NS

    def __init__(self, xmlnode_or_type = "form", title = None, instructions = None,
            fields = None, reported_fields = None, items = None):
        """Initialize a `Form` object.

        :Parameters:
            - `xmlnode_or_type`: XML element to parse or a form title.
            - `title`: form title.
            - `instructions`: instructions for the form.
            - `fields`: form fields.
            - `reported_fields`: fields reported in multi-item data.
            - `items`: items of multi-item data.
        :Types:
            - `xmlnode_or_type`: `libxml2.xmlNode` or `str`
            - `title`: `unicode`
            - `instructions`: `unicode`
            - `fields`: `list` of `Field`
            - `reported_fields`: `list` of `Field`
            - `items`: `list` of `Item`
        """
        if isinstance(xmlnode_or_type, libxml2.xmlNode):
            self.__from_xml(xmlnode_or_type)
        elif xmlnode_or_type not in self.allowed_types:
            raise ValueError("Form type %r not allowed." % (xmlnode_or_type,))
        else:
            self.type = xmlnode_or_type
            self.title = title
            self.instructions = instructions
            if fields:
                self.fields = list(fields)
            else:
                self.fields = []
            if reported_fields:
                self.reported_fields = list(reported_fields)
            else:
                self.reported_fields = []
            if items:
                self.items = list(items)
            else:
                self.items = []

    def __getitem__(self, name_or_index):
        if isinstance(name_or_index, int):
            return self.fields[name_or_index]
        for f in self.fields:
            if f.name == name_or_index:
                return f
        raise KeyError(name_or_index)

    def __contains__(self, name):
        for f in self.fields:
            if f.name == name:
                return True
        return False

    def __iter__(self):
        for field in self.fields:
            yield field

    def add_field(self, name = None, values = None, field_type = None,
            label = None, options = None, required = False, desc = None, value = None):
        """Add a field to the form.

        :Parameters:
            - `name`: field name.
            - `values`: raw field values. Not to be used together with `value`.
            - `field_type`: field type.
            - `label`: field label.
            - `options`: optional values for the field.
            - `required`: `True` if the field is required.
            - `desc`: natural-language description of the field.
            - `value`: field value or values in a field_type-specific type. May be used only
              if `values` parameter is not provided.
        :Types:
            - `name`: `unicode`
            - `values`: `list` of `unicode`
            - `field_type`: `str`
            - `label`: `unicode`
            - `options`: `list` of `Option`
            - `required`: `bool`
            - `desc`: `unicode`
            - `value`: `bool` for "boolean" field, `JID` for "jid-single", `list` of `JID`
              for "jid-multi", `list` of `unicode` for "list-multi" and "text-multi"
              and `unicode` for other field types.

        :return: the field added.
        :returntype: `Field`
        """
        field = Field(name, values, field_type, label, options, required, desc, value)
        self.fields.append(field)
        return field

    def add_item(self, fields = None):
        """Add and item to the form.

        :Parameters:
            - `fields`: fields of the item (they may be added later).
        :Types:
            - `fields`: `list` of `Field`

        :return: the item added.
        :returntype: `Item`
        """
        item = Item(fields)
        self.items.append(item)
        return item

    def make_submit(self, keep_types = False):
        """Make a "submit" form using data in `self`.

        Remove uneeded information from the form. The information removed
        includes: title, instructions, field labels, fixed fields etc.

        :raise ValueError: when any required field has no value.

        :Parameters:
            - `keep_types`: when `True` field type information will be included
              in the result form. That is usually not needed.
        :Types:
            - `keep_types`: `bool`

        :return: the form created.
        :returntype: `Form`"""
        result = Form("submit")
        for field in self.fields:
            if field.type == "fixed":
                continue
            if not field.values:
                if field.required:
                    raise ValueError("Required field with no value!")
                continue
            if keep_types:
                result.add_field(field.name, field.values, field.type)
            else:
                result.add_field(field.name, field.values)
        return result

    def copy(self):
        """Get a deep copy of `self`.

        :return: a deep copy of `self`.
        :returntype: `Form`"""
        return copy.deepcopy(self)

    def complete_xml_element(self, xmlnode, doc):
        """Complete the XML node with `self` content.

        :Parameters:
            - `xmlnode`: XML node with the element being built. It has already
              right name and namespace, but no attributes or content.
            - `doc`: document to which the element belongs.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`
            - `doc`: `libxml2.xmlDoc`"""
        if self.type not in self.allowed_types:
            raise ValueError("Form type %r not allowed." % (self.type,))
        xmlnode.setProp("type", self.type)
        if self.type == "cancel":
            return
        ns = xmlnode.ns()
        if self.title is not None:
            xmlnode.newTextChild(ns, "title", to_utf8(self.title))
        if self.instructions is not None:
            xmlnode.newTextChild(ns, "instructions", to_utf8(self.instructions))
        for field in self.fields:
            field.as_xml(xmlnode, doc)
        if self.type != "result":
            return
        if self.reported_fields:
            reported = xmlnode.newChild(ns, "reported", None)
            for field in self.reported_fields:
                field.as_xml(reported, doc)
        for item in self.items:
            item.as_xml(xmlnode, doc)

    def __from_xml(self, xmlnode):
        """Initialize a `Form` object from an XML element.

        :Parameters:
            - `xmlnode`: the XML element.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`
        """
        self.fields = []
        self.reported_fields = []
        self.items = []
        self.title = None
        self.instructions = None
        if (xmlnode.type != "element" or xmlnode.name != "x"
                or xmlnode.ns().content != DATAFORM_NS):
            raise ValueError("Not a form: " + xmlnode.serialize())
        self.type = xmlnode.prop("type")
        if not self.type in self.allowed_types:
            raise BadRequestProtocolError("Bad form type: %r" % (self.type,))
        child = xmlnode.children
        while child:
            if child.type != "element" or child.ns().content != DATAFORM_NS:
                pass
            elif child.name == "title":
                self.title = from_utf8(child.getContent())
            elif child.name == "instructions":
                self.instructions = from_utf8(child.getContent())
            elif child.name == "field":
                self.fields.append(Field._new_from_xml(child))
            elif child.name == "item":
                self.items.append(Item._new_from_xml(child))
            elif child.name == "reported":
                self.__get_reported(child)
            child = child.next

    def __get_reported(self, xmlnode):
        """Parse the <reported/> element of the form.

        :Parameters:
            - `xmlnode`: the element to parse.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`"""
        child = xmlnode.children
        while child:
            if child.type != "element" or child.ns().content != DATAFORM_NS:
                pass
            elif child.name == "field":
                self.reported_fields.append(Field._new_from_xml(child))
            child = child.next
# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = delay
#
# (C) Copyright 2003-2010 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""Delayed delivery mark (jabber:x:delay) handling.

Normative reference:
  - `JEP 91 <http://www.jabber.org/jeps/jep-0091.html>`__
"""

from __future__ import absolute_import, division

__docformat__="restructuredtext en"

raise ImportError("{0} is not yet rewritten for PyXMPP2".format(__name__))

import libxml2
import time
import datetime

from ..jid import JID

from ..utils import to_utf8,from_utf8
from ..xmlextra import get_node_ns_uri
from ..utils import datetime_utc_to_local,datetime_local_to_utc
from ..objects import StanzaPayloadObject
from ..exceptions import BadRequestProtocolError, JIDMalformedProtocolError, JIDError

DELAY_NS="jabber:x:delay"

class Delay(StanzaPayloadObject):
    """
    Delayed delivery tag.

    Represents 'jabber:x:delay' (JEP-0091) element of a Jabber stanza.

    :Ivariables:
        - `delay_from`: the "from" value of the delay element
        - `reason`: the "reason" (content) of the delay element
        - `timestamp`: the UTC timestamp as naive datetime object
    """

    xml_element_name = "x"
    xml_element_namespace = DELAY_NS

    def __init__(self,node_or_datetime,delay_from=None,reason=None,utc=True):
        """
        Initialize the Delay object.

        :Parameters:
            - `node_or_datetime`: an XML node to parse or the timestamp.
            - `delay_from`: JID of the entity which adds the delay mark
              (when `node_or_datetime` is a timestamp).
            - `reason`: reason of the delay (when `node_or_datetime` is a
              timestamp).
            - `utc`: if `True` then the timestamp is assumed to be UTC,
              otherwise it is assumed to be local time.
        :Types:
            - `node_or_datetime`: `libxml2.xmlNode` or `datetime.datetime`
            - `delay_from`: `pyxmpp.JID`
            - `reason`: `unicode`
            - `utc`: `bool`"""
        if isinstance(node_or_datetime,libxml2.xmlNode):
            self.from_xml(node_or_datetime)
        else:
            if utc:
                self.timestamp=node_or_datetime
            else:
                self.timestamp=datetime_local_to_utc(node_or_datetime)
            self.delay_from=JID(delay_from)
            self.reason=unicode(reason)

    def from_xml(self,xmlnode):
        """Initialize Delay object from an XML node.

        :Parameters:
            - `xmlnode`: the jabber:x:delay XML element.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`"""
        if xmlnode.type!="element":
            raise ValueError("XML node is not a jabber:x:delay element (not an element)")
        ns=get_node_ns_uri(xmlnode)
        if ns and ns!=DELAY_NS or xmlnode.name!="x":
            raise ValueError("XML node is not a jabber:x:delay element")
        stamp=xmlnode.prop("stamp")
        if stamp.endswith("Z"):
            stamp=stamp[:-1]
        if "-" in stamp:
            stamp=stamp.split("-",1)[0]
        try:
            tm = time.strptime(stamp, "%Y%m%dT%H:%M:%S")
        except ValueError:
            raise BadRequestProtocolError("Bad timestamp")
        tm=tm[0:8]+(0,)
        self.timestamp=datetime.datetime.fromtimestamp(time.mktime(tm))
        delay_from=from_utf8(xmlnode.prop("from"))
        if delay_from:
            try:
                self.delay_from = JID(delay_from)
            except JIDError:
                raise JIDMalformedProtocolError("Bad JID in the jabber:x:delay 'from' attribute")
        else:
            self.delay_from = None
        self.reason = from_utf8(xmlnode.getContent())

    def complete_xml_element(self, xmlnode, _unused):
        """Complete the XML node with `self` content.

        Should be overriden in classes derived from `StanzaPayloadObject`.

        :Parameters:
            - `xmlnode`: XML node with the element being built. It has already
              right name and namespace, but no attributes or content.
            - `_unused`: document to which the element belongs.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`
            - `_unused`: `libxml2.xmlDoc`"""
        tm=self.timestamp.strftime("%Y%m%dT%H:%M:%S")
        xmlnode.setProp("stamp",tm)
        if self.delay_from:
            xmlnode.setProp("from",self.delay_from.as_utf8())
        if self.reason:
            xmlnode.setContent(to_utf8(self.reason))

    def get_datetime_local(self):
        """Get the timestamp as a local time.

        :return: the timestamp of the delay element represented in the local
          timezone.
        :returntype: `datetime.datetime`"""
        r=datetime_utc_to_local(self.timestamp)
        return r

    def get_datetime_utc(self):
        """Get the timestamp as a UTC.

        :return: the timestamp of the delay element represented in UTC.
        :returntype: `datetime.datetime`"""
        return self.timestamp

    def __str__(self):
        n=self.as_xml()
        r=n.serialize()
        n.freeNode()
        return r

    def __cmp__(self,other):
        return cmp(timestamp, other.timestamp)

def get_delays(stanza):
    """Get jabber:x:delay elements from the stanza.

    :Parameters:
        - `stanza`: a, probably delayed, stanza.
    :Types:
        - `stanza`: `pyxmpp.stanza.Stanza`

    :return: list of delay tags sorted by the timestamp.
    :returntype: `list` of `Delay`"""
    delays=[]
    n=stanza.xmlnode.children
    while n:
        if n.type=="element" and get_node_ns_uri(n)==DELAY_NS and n.name=="x":
            delays.append(Delay(n))
        n=n.next
    delays.sort()
    return delays

def get_delay(stanza):
    """Get the oldest jabber:x:delay elements from the stanza.

    :Parameters:
        - `stanza`: a, probably delayed, stanza.
    :Types:
        - `stanza`: `pyxmpp.stanza.Stanza`

    The return value, if not `None`, contains a quite reliable
    timestamp of a delayed (e.g. from offline storage) message.

    :return: the oldest delay tag of the stanza or `None`.
    :returntype: `Delay`"""
    delays=get_delays(stanza)
    if not delays:
        return None
    return get_delays(stanza)[0]

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = disco
#
# (C) Copyright 2003-2010 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# pylint: disable-msg=W0201
"""Jabber Service Discovery support.

Normative reference:
  - `JEP 30 <http://www.jabber.org/jeps/jep-0030.html>`__
"""

from __future__ import absolute_import, division

__docformat__="restructuredtext en"

raise ImportError("{0} is not yet rewritten for PyXMPP2".format(__name__))

import warnings

import libxml2

from ..xmlextra import common_doc,common_root
from ..jid import JID
from .. import cache

from ..utils import to_utf8
from ..objects import StanzaPayloadWrapperObject
from ..exceptions import ProtocolError

DISCO_NS="http://jabber.org/protocol/disco"
DISCO_ITEMS_NS=DISCO_NS+"#items"
DISCO_INFO_NS=DISCO_NS+"#info"

class DiscoItem(StanzaPayloadWrapperObject):
    """An item of disco#items reply.

    :Ivariables:
        - `jid`: the JID of the item.
        - `node`: node name of the item.
        - `name`: name of the item.
        - `action`: action of the item.
        - `disco`: the disco reply this is the part of.
        - `xmlnode`: XML element describing the item.
    :Types:
        - `jid`: `JID`
        - `node`: `unicode`
        - `name`: `unicode`
        - `action`: `unicode`
        - `disco`: `DiscoItems`
        - `xmlnode`: `libxml2.xmlNode`
    """
    def __init__(self,disco,xmlnode_or_jid,node=None,name=None,action=None):
        """Initialize an `DiscoItem` object.

        :Parameters:
            - `disco`: the disco#items reply `self` is a part of.
            - `xmlnode_or_jid`: XML element describing the item or the JID of
              the item.
            - `node`: disco node of the item.
            - `name`: name of the item.
            - `action`: 'action' attribute of the item.
        :Types:
            - `disco`: `DiscoItems`
            - `xmlnode_or_jid`: `libxml2.xmlNode` or `JID`
            - `node`: `unicode`
            - `name`: `unicode`
            - `action`: `unicode`
        """
        self.disco=disco
        if isinstance(xmlnode_or_jid,JID):
            if disco:
                self.xmlnode=disco.xmlnode.newChild(None,"item",None)
            else:
                self.xmlnode=common_root.newChild(None,"item",None)
                ns=self.xmlnode.newNs(DISCO_ITEMS_NS,None)
                self.xmlnode.setNs(ns)
            self.set_jid(xmlnode_or_jid)
            self.set_name(name)
            self.set_node(node)
            self.set_action(action)
        else:
            if disco is None:
                self.xmlnode=xmlnode_or_jid.copyNode(1)
            else:
                self.xmlnode=xmlnode_or_jid
            if name:
                self.set_name(name)
            if node:
                self.set_node(node)
            if action:
                self.set_action(action)
        self.xpath_ctxt=common_doc.xpathNewContext()
        self.xpath_ctxt.setContextNode(self.xmlnode)
        self.xpath_ctxt.xpathRegisterNs("d",DISCO_ITEMS_NS)

    def __del__(self):
        if self.disco is None:
            if self.xmlnode:
                self.xmlnode.unlinkNode()
                self.xmlnode.freeNode()
                self.xmlnode=None
        if self.xpath_ctxt:
            self.xpath_ctxt.xpathFreeContext()

    def __str__(self):
        return self.xmlnode.serialize()

    def remove(self):
        """Remove `self` from the containing `DiscoItems` object."""
        if self.disco is None:
            return
        self.xmlnode.unlinkNode()
        oldns=self.xmlnode.ns()
        ns=self.xmlnode.newNs(oldns.getContent(),None)
        self.xmlnode.replaceNs(oldns,ns)
        common_root.addChild(self.xmlnode())
        self.disco=None

    def get_name(self):
        """Get the name of the item.

        :return: the name of the item or `None`.
        :returntype: `unicode`"""
        name = self.xmlnode.prop("name")
        if name is None:
            return None
        return name.decode("utf-8")

    def set_name(self, name):
        """Set the name of the item.

        :Parameters:
            - `name`: the new name or `None`.
        :Types:
            - `name`: `unicode` """
        if name is None:
            if self.xmlnode.hasProp("name"):
                self.xmlnode.unsetProp("name")
            return
        name = unicode(name)
        self.xmlnode.setProp("name", name.encode("utf-8"))

    name = property(get_name, set_name)

    def get_node(self):
        """Get the node of the item.

        :return: the node of the item or `None`.
        :returntype: `unicode`"""
        node = self.xmlnode.prop("node")
        if node is None:
            return None
        return node.decode("utf-8")

    def set_node(self,node):
        """Set the node of the item.

        :Parameters:
            - `node`: the new node or `None`.
        :Types:
            - `node`: `unicode`
        """
        if node is None:
            if self.xmlnode.hasProp("node"):
                self.xmlnode.unsetProp("node")
            return
        node = unicode(node)
        self.xmlnode.setProp("node", node.encode("utf-8"))

    node = property(get_node, set_node)

    def get_action(self):
        """Get the action attribute of the item.

        :return: the action of the item or `None`.
        :returntype: `unicode`"""
        action=self.xmlnode.prop("action")
        if action is None:
            return None
        return action.decode("utf-8")

    def set_action(self,action):
        """Set the action of the item.

        :Parameters:
            - `action`: the new action or `None`.
        :Types:
            - `action`: `unicode`
        """
        if action is None:
            if self.xmlnode.hasProp("action"):
                self.xmlnode.unsetProp("action")
            return
        if action not in ("remove","update"):
            raise ValueError("Action must be 'update' or 'remove'")
        action = unicode(action)
        self.xmlnode.setProp("action", action.encode("utf-8"))

    action = property(get_action, set_action)

    def get_jid(self):
        """Get the JID of the item.

        :return: the JID of the item.
        :returntype: `JID`"""
        jid = self.xmlnode.prop("jid")
        return JID( jid.decode("utf-8") )

    def set_jid(self,jid):
        """Set the JID of the item.

        :Parameters:
            - `jid`: the new jid.
        :Types:
            - `jid`: `JID`
        """
        self.xmlnode.setProp("jid", jid.as_unicode().encode("utf-8"))

    jid = property(get_jid, set_jid)

class DiscoIdentity(StanzaPayloadWrapperObject):
    """An <identity/> element of disco#info reply.

    Identifies an item by its name, category and type.

    :Ivariables:
        - `disco`: the disco reply this is the part of.
        - `xmlnode`: XML element describing the identity.
    :Types:
        - `disco`: `DiscoInfo`
        - `xmlnode`: `libxml2.xmlNode`
    """
    def __init__(self, disco, xmlnode_or_name, item_category=None, item_type=None, replace=False):
        """Initialize an `DiscoIdentity` object.

        :Parameters:
            - `disco`: the disco#info reply `self` is a part of.
            - `xmlnode_or_name`: XML element describing the identity or the
              name of the item described.
            - `item_category`: category of the item described.
            - `item_type`: type of the item described.
            - `replace`: if `True` than all other <identity/> elements in
              `disco` will be removed.
        :Types:
            - `disco`: `DiscoItems`
            - `xmlnode_or_name`: `libxml2.xmlNode` or `unicode`
            - `item_category`: `unicode`
            - `item_type`: `unicode`
            - `replace`: `bool`
        """
        self.disco=disco
        if disco and replace:
            old=disco.xpath_ctxt.xpathEval("d:identity")
            if old:
                for n in old:
                    n.unlinkNode()
                    n.freeNode()
        if isinstance(xmlnode_or_name,libxml2.xmlNode):
            if disco is None:
                self.xmlnode=xmlnode_or_name.copyNode(1)
            else:
                self.xmlnode=xmlnode_or_name
        elif not item_category:
            raise ValueError("DiscoInfo requires category")
        elif not item_type:
            raise ValueError("DiscoInfo requires type")
        else:
            if disco:
                self.xmlnode=disco.xmlnode.newChild(None,"identity",None)
            else:
                self.xmlnode=common_root.newChild(None,"identity",None)
                ns=self.xmlnode.newNs(DISCO_INFO_NS,None)
                self.xmlnode.setNs(ns)
            self.set_name(xmlnode_or_name)
            self.set_category(item_category)
            self.set_type(item_type)
        self.xpath_ctxt=common_doc.xpathNewContext()
        self.xpath_ctxt.setContextNode(self.xmlnode)
        self.xpath_ctxt.xpathRegisterNs("d",DISCO_INFO_NS)

    def __del__(self):
        if self.disco is None:
            if self.xmlnode:
                self.xmlnode.unlinkNode()
                self.xmlnode.freeNode()
                self.xmlnode=None
        if self.xpath_ctxt:
            self.xpath_ctxt.xpathFreeContext()

    def __str__(self):
        return self.xmlnode.serialize()

    def remove(self):
        """Remove `self` from the containing `DiscoInfo` object."""
        if self.disco is None:
            return
        self.xmlnode.unlinkNode()
        oldns=self.xmlnode.ns()
        ns=self.xmlnode.newNs(oldns.getContent(),None)
        self.xmlnode.replaceNs(oldns,ns)
        common_root.addChild(self.xmlnode())
        self.disco=None

    def get_name(self):
        """Get the name of the item.

        :return: the name of the item or `None`.
        :returntype: `unicode`"""
        var = self.xmlnode.prop("name")
        if not var:
            var = ""
        return var.decode("utf-8")

    def set_name(self,name):
        """Set the name of the item.

        :Parameters:
            - `name`: the new name or `None`.
        :Types:
            - `name`: `unicode` """
        if not name:
            raise ValueError("name is required in DiscoIdentity")
        name = unicode(name)
        self.xmlnode.setProp("name", name.encode("utf-8"))

    name = property(get_name, set_name)

    def get_category(self):
        """Get the category of the item.

        :return: the category of the item.
        :returntype: `unicode`"""
        var = self.xmlnode.prop("category")
        if not var:
            var = "?"
        return var.decode("utf-8")

    def set_category(self, category):
        """Set the category of the item.

        :Parameters:
            - `category`: the new category.
        :Types:
            - `category`: `unicode` """
        if not category:
            raise ValueError("Category is required in DiscoIdentity")
        category = unicode(category)
        self.xmlnode.setProp("category", category.encode("utf-8"))

    category = property(get_category, set_category)

    def get_type(self):
        """Get the type of the item.

        :return: the type of the item.
        :returntype: `unicode`"""
        item_type = self.xmlnode.prop("type")
        if not item_type:
            item_type = "?"
        return item_type.decode("utf-8")

    def set_type(self, item_type):
        """Set the type of the item.

        :Parameters:
            - `item_type`: the new type.
        :Types:
            - `item_type`: `unicode` """
        if not item_type:
            raise ValueError("Type is required in DiscoIdentity")
        item_type = unicode(item_type)
        self.xmlnode.setProp("type", item_type.encode("utf-8"))

    type = property(get_type, set_type)

class DiscoItems(StanzaPayloadWrapperObject):
    """A disco#items response or publish-request object.

    :Ivariables:
        - `node`: node name of the disco#items element.
        - `items`: items in the disco#items element.
        - `xmlnode`: XML element listing the items.
    :Types:
        - `node`: `unicode`
        - `items`: `tuple` of `DiscoItem`
        - `xmlnode`: `libxml2.xmlNode`
    """
    def __init__(self,xmlnode_or_node=None):
        """Initialize an `DiscoItems` object.

        Wrap an existing disco#items XML element or create a new one.

        :Parameters:
            - `xmlnode_or_node`: XML node to be wrapped into `self` or an item
              node name.
        :Types:
            - `xmlnode_or_node`: `libxml2.xmlNode` or `unicode`"""
        self.xmlnode=None
        self.xpath_ctxt=None
        if isinstance(xmlnode_or_node,libxml2.xmlNode):
            ns=xmlnode_or_node.ns()
            if ns.getContent() != DISCO_ITEMS_NS:
                raise ValueError("Bad disco-items namespace")
            self.xmlnode=xmlnode_or_node.docCopyNode(common_doc,1)
            common_root.addChild(self.xmlnode)
            self.ns=self.xmlnode.ns()
        else:
            self.xmlnode=common_root.newChild(None,"query",None)
            self.ns=self.xmlnode.newNs(DISCO_ITEMS_NS,None)
            self.xmlnode.setNs(self.ns)
            self.set_node(xmlnode_or_node)
        self.xpath_ctxt=common_doc.xpathNewContext()
        self.xpath_ctxt.setContextNode(self.xmlnode)
        self.xpath_ctxt.xpathRegisterNs("d",DISCO_ITEMS_NS)

    def __del__(self):
        if self.xmlnode:
            self.xmlnode.unlinkNode()
            self.xmlnode.freeNode()
            self.xmlnode=None
        if self.xpath_ctxt:
            self.xpath_ctxt.xpathFreeContext()
            self.xpath_ctxt=None

    def get_node(self):
        """Get the node address of the `DiscoItems` object.

        :return: the node name.
        :returntype: `unicode`"""
        node = self.xmlnode.prop("node")
        if not node:
            return None
        return node.decode("utf-8")

    def set_node(self, node):
        """Set the node of the disco#item element.

        :Parameters:
            - `node`: the new node or `None`.
        :Types:
            - `node`: `unicode`
        """
        if node is None:
            if self.xmlnode.hasProp("node"):
                self.xmlnode.unsetProp("node")
            return
        node = unicode(node)
        self.xmlnode.setProp("node", node.encode("utf-8"))

    node = property(get_node, set_node)

    def get_items(self):
        """Get the items contained in `self`.

        :return: the items contained.
        :returntype: `list` of `DiscoItem`"""
        ret=[]
        l=self.xpath_ctxt.xpathEval("d:item")
        if l is not None:
            for i in l:
                ret.append(DiscoItem(self, i))
        return ret

    def set_items(self, item_list):
        """Set items in the disco#items object.

        All previous items are removed.

        :Parameters:
            - `item_list`: list of items or item properties
              (jid,node,name,action).
        :Types:
            - `item_list`: sequence of `DiscoItem` or sequence of sequences
        """
        for item in self.items:
            item.remove()
        for item in item_list:
            try:
                self.add_item(item.jid,item.node,item.name,item.action)
            except AttributeError:
                self.add_item(*item)

    items = property(get_items, set_items, doc = "List of `DiscoItems`")

    def invalidate_items(self):
        """Clear cached item list."""
        warnings.warn("DiscoItems.invalidate_items() is deprecated and not needed any more.", DeprecationWarning, stacklevel=1)

    def add_item(self,jid,node=None,name=None,action=None):
        """Add a new item to the `DiscoItems` object.

        :Parameters:
            - `jid`: item JID.
            - `node`: item node name.
            - `name`: item name.
            - `action`: action for a "disco push".
        :Types:
            - `jid`: `pyxmpp.JID`
            - `node`: `unicode`
            - `name`: `unicode`
            - `action`: `unicode`

        :returns: the item created.
        :returntype: `DiscoItem`."""
        return DiscoItem(self,jid,node,name,action)

    def has_item(self,jid,node=None):
        """Check if `self` contains an item.

        :Parameters:
            - `jid`: JID of the item.
            - `node`: node name of the item.
        :Types:
            - `jid`: `JID`
            - `node`: `libxml2.xmlNode`

        :return: `True` if the item is found in `self`.
        :returntype: `bool`"""
        l=self.xpath_ctxt.xpathEval("d:item")
        if l is None:
            return False
        for it in l:
            di=DiscoItem(self,it)
            if di.jid==jid and di.node==node:
                return True
        return False

class DiscoInfo(StanzaPayloadWrapperObject):
    """A disco#info response object.

    :Ivariables:
        - `node`: node name of the disco#info element (cached).
        - `identities`: identities in the disco#info object.
        - `features`: features in the disco#info object.
        - `xmlnode`: XML element listing the items.
    :Types:
        - `node`: `unicode`
        - `identities`: `tuple` of `DiscoIdentity`
        - `features`: `tuple` of `unicode`
        - `xmlnode`: `libxml2.xmlNode`
    """
    def __init__(self,xmlnode_or_node=None, parent=None, doc=None):
        """Initialize an `DiscoInfo` object.

        Wrap an existing disco#info XML element or create a new one.

        :Parameters:
            - `xmlnode_or_node`: XML node to be wrapped into `self` or an item
              node name.
            - `parent`: parent node for the `DiscoInfo` element.
            - `doc`: document for the `DiscoInfo` element.
        :Types:
            - `xmlnode_or_node`: `libxml2.xmlNode` or `unicode`
            - `parent`: `libxml2.xmlNode`
            - `doc`: `libxml2.xmlDoc`
            """
        self.xmlnode=None
        self.xpath_ctxt=None
        if not doc:
            doc=common_doc
        if not parent:
            parent=common_root
        if isinstance(xmlnode_or_node,libxml2.xmlNode):
            ns=xmlnode_or_node.ns()
            if ns.getContent() != DISCO_INFO_NS:
                raise ValueError("Bad disco-info namespace")
            self.xmlnode=xmlnode_or_node.docCopyNode(doc,1)
            parent.addChild(self.xmlnode)
        else:
            self.xmlnode=parent.newChild(None,"query",None)
            self.ns=self.xmlnode.newNs(DISCO_INFO_NS,None)
            self.xmlnode.setNs(self.ns)
            self.set_node(xmlnode_or_node)

        self.xpath_ctxt=doc.xpathNewContext()
        self.xpath_ctxt.setContextNode(self.xmlnode)
        self.xpath_ctxt.xpathRegisterNs("d",DISCO_INFO_NS)

    def __del__(self):
        if self.xmlnode:
            self.xmlnode.unlinkNode()
            self.xmlnode.freeNode()
            self.xmlnode=None
        if self.xpath_ctxt:
            self.xpath_ctxt.xpathFreeContext()
            self.xpath_ctxt=None

    def get_node(self):
        """Get the node address of the `DiscoInfo` object.

        :return: the node name.
        :returntype: `unicode`"""

        node=self.xmlnode.prop("node")
        if not node:
            return None
        return node.decode("utf-8")

    def set_node(self,node):
        """Set the node of the disco#info element.

        :Parameters:
            - `node`: the new node or `None`.
        :Types:
            - `node`: `unicode`
        """
        if node is None:
            if self.xmlnode.hasProp("node"):
                self.xmlnode.unsetProp("node")
            return
        node = unicode(node)
        self.xmlnode.setProp("node", node.encode("utf-8"))

    node = property(get_node, set_node)

    def get_features(self):
        """Get the features contained in `self`.

        :return: the list of features.
        :returntype: `list` of `unicode`"""
        l = self.xpath_ctxt.xpathEval("d:feature")
        ret = []
        for f in l:
            if f.hasProp("var"):
                ret.append( f.prop("var").decode("utf-8") )
        return ret

    def set_features(self, features):
        """Set features in the disco#info object.

        All existing features are removed from `self`.

        :Parameters:
            - `features`: list of features.
        :Types:
            - `features`: sequence of `unicode`
        """
        for var in self.features:
            self.remove_feature(var)

        for var in features:
            self.add_feature(var)

    features = property(get_features, set_features)

    def has_feature(self,var):
        """Check if `self` contains the named feature.

        :Parameters:
            - `var`: the feature name.
        :Types:
            - `var`: `unicode`

        :return: `True` if the feature is found in `self`.
        :returntype: `bool`"""
        if not var:
            raise ValueError("var is None")
        if '"' not in var:
            expr=u'd:feature[@var="%s"]' % (var,)
        elif "'" not in var:
            expr=u"d:feature[@var='%s']" % (var,)
        else:
            raise ValueError("Invalid feature name")

        l=self.xpath_ctxt.xpathEval(to_utf8(expr))
        if l:
            return True
        else:
            return False

    def invalidate_features(self):
        """Clear cached feature list."""
        warnings.warn("DiscoInfo.invalidate_features() is deprecated and not needed any more.", DeprecationWarning, stacklevel=1)

    def add_feature(self,var):
        """Add a feature to `self`.

        :Parameters:
            - `var`: the feature name.
        :Types:
            - `var`: `unicode`"""
        if self.has_feature(var):
            return
        n=self.xmlnode.newChild(None, "feature", None)
        n.setProp("var", to_utf8(var))

    def remove_feature(self,var):
        """Remove a feature from `self`.

        :Parameters:
            - `var`: the feature name.
        :Types:
            - `var`: `unicode`"""
        if not var:
            raise ValueError("var is None")
        if '"' not in var:
            expr='d:feature[@var="%s"]' % (var,)
        elif "'" not in var:
            expr="d:feature[@var='%s']" % (var,)
        else:
            raise ValueError("Invalid feature name")

        l=self.xpath_ctxt.xpathEval(expr)
        if not l:
            return

        for f in l:
            f.unlinkNode()
            f.freeNode()

    def get_identities(self):
        """List the identity objects contained in `self`.

        :return: the list of identities.
        :returntype: `list` of `DiscoIdentity`"""
        ret=[]
        l=self.xpath_ctxt.xpathEval("d:identity")
        if l is not None:
            for i in l:
                ret.append(DiscoIdentity(self,i))
        return ret

    def set_identities(self,identities):
        """Set identities in the disco#info object.

        Remove all existing identities from `self`.

        :Parameters:
            - `identities`: list of identities or identity properties
              (jid,node,category,type,name).
        :Types:
            - `identities`: sequence of `DiscoIdentity` or sequence of sequences
        """
        for identity in self.identities:
            identity.remove()
        for identity in identities:
            try:
                self.add_identity(identity.name,identity.category,identity.type)
            except AttributeError:
                self.add_identity(*identity)

    identities = property(get_identities, set_identities)

    def identity_is(self,item_category,item_type=None):
        """Check if the item described by `self` belongs to the given category
        and type.

        :Parameters:
            - `item_category`: the category name.
            - `item_type`: the type name. If `None` then only the category is
              checked.
        :Types:
            - `item_category`: `unicode`
            - `item_type`: `unicode`

        :return: `True` if `self` contains at least one <identity/> object with
            given type and category.
        :returntype: `bool`"""
        if not item_category:
            raise ValueError("bad category")
        if not item_type:
            type_expr=u""
        elif '"' not in item_type:
            type_expr=u' and @type="%s"' % (item_type,)
        elif "'" not in type:
            type_expr=u" and @type='%s'" % (item_type,)
        else:
            raise ValueError("Invalid type name")
        if '"' not in item_category:
            expr=u'd:identity[@category="%s"%s]' % (item_category,type_expr)
        elif "'" not in item_category:
            expr=u"d:identity[@category='%s'%s]" % (item_category,type_expr)
        else:
            raise ValueError("Invalid category name")

        l=self.xpath_ctxt.xpathEval(to_utf8(expr))
        if l:
            return True
        else:
            return False

    def invalidate_identities(self):
        """Clear cached identity list."""
        warnings.warn("DiscoInfo.invalidate_identities() is deprecated and not needed any more.", DeprecationWarning, stacklevel=1)

    def add_identity(self,item_name,item_category=None,item_type=None):
        """Add an identity to the `DiscoInfo` object.

        :Parameters:
            - `item_name`: name of the item.
            - `item_category`: category of the item.
            - `item_type`: type of the item.
        :Types:
            - `item_name`: `unicode`
            - `item_category`: `unicode`
            - `item_type`: `unicode`

        :returns: the identity created.
        :returntype: `DiscoIdentity`"""
        return DiscoIdentity(self,item_name,item_category,item_type)

class DiscoCacheFetcherBase(cache.CacheFetcher):
    """Base class for disco cache fetchers.

    :Cvariables:
        - `stream`: stream used by the fetcher.
        - `disco_class`: disco class to be used (`DiscoInfo` or `DiscoItems`).
    :Types:
        - `stream`: `pyxmpp.stream.Stream`
        - `disco_class`: `classobj`
    """
    stream=None
    disco_class=None
    def fetch(self):
        """Initialize the Service Discovery process."""
        from ..iq import Iq
        jid,node = self.address
        iq = Iq(to_jid = jid, stanza_type = "get")
        disco = self.disco_class(node)
        iq.add_content(disco.xmlnode)
        self.stream.set_response_handlers(iq,self.__response, self.__error,
                self.__timeout)
        self.stream.send(iq)

    def __response(self,stanza):
        """Handle successful disco response.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `pyxmpp.stanza.Stanza`"""
        try:
            d=self.disco_class(stanza.get_query())
            self.got_it(d)
        except ValueError,e:
            self.error(e)

    def __error(self,stanza):
        """Handle disco error response.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `pyxmpp.stanza.Stanza`"""
        try:
            self.error(stanza.get_error())
        except ProtocolError:
            from ..error import StanzaErrorNode
            self.error(StanzaErrorNode("undefined-condition"))

    def __timeout(self,stanza):
        """Handle disco timeout."""
        pass

def register_disco_cache_fetchers(cache_suite,stream):
    """Register Service Discovery cache fetchers into given
    cache suite and using the stream provided.

    :Parameters:
        - `cache_suite`: the cache suite where the fetchers are to be
          registered.
        - `stream`: the stream to be used by the fetchers.
    :Types:
        - `cache_suite`: `cache.CacheSuite`
        - `stream`: `pyxmpp.stream.Stream`
    """
    tmp=stream
    class DiscoInfoCacheFetcher(DiscoCacheFetcherBase):
        """Cache fetcher for DiscoInfo."""
        stream=tmp
        disco_class=DiscoInfo
    class DiscoItemsCacheFetcher(DiscoCacheFetcherBase):
        """Cache fetcher for DiscoItems."""
        stream=tmp
        disco_class=DiscoItems
    cache_suite.register_fetcher(DiscoInfo,DiscoInfoCacheFetcher)
    cache_suite.register_fetcher(DiscoItems,DiscoItemsCacheFetcher)

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = legacyauth
#
# (C) Copyright 2003-2010 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
"""XMPP stream support with fallback to legacy non-SASL Jabber authentication.

Normative reference:
  - `JEP 78 <http://www.jabber.org/jeps/jep-0078.html>`__
"""

from __future__ import absolute_import, division

__docformat__="restructuredtext en"

raise ImportError("{0} is not yet rewritten for PyXMPP2".format(__name__))

import hashlib
import logging

from ..iq import Iq
from ..utils import to_utf8,from_utf8
from ..jid import JID
from ..clientstream import ClientStream
from .register import Register

from ..exceptions import ClientStreamError, LegacyAuthenticationError, RegistrationError

class LegacyClientStream(ClientStream):
    """Handles Jabber (both XMPP and legacy protocol) client connection stream.

    Both client and server side of the connection is supported. This class handles
    client SASL and legacy authentication, authorisation and XMPP resource binding.
    """
    def __init__(self, jid, password = None, server = None, port = 5222,
            auth_methods = ("sasl:DIGEST-MD5", "digest"),
            tls_settings = None, keepalive = 0, owner = None):
        """Initialize a LegacyClientStream object.

        :Parameters:
            - `jid`: local JID.
            - `password`: user's password.
            - `server`: server to use. If not given then address will be derived form the JID.
            - `port`: port number to use. If not given then address will be derived form the JID.
            - `auth_methods`: sallowed authentication methods. SASL authentication mechanisms
              in the list should be prefixed with "sasl:" string.
            - `tls_settings`: settings for StartTLS -- `TLSSettings` instance.
            - `keepalive`: keepalive output interval. 0 to disable.
            - `owner`: `Client`, `Component` or similar object "owning" this stream.
        :Types:
            - `jid`: `pyxmpp.JID`
            - `password`: `unicode`
            - `server`: `unicode`
            - `port`: `int`
            - `auth_methods`: sequence of `str`
            - `tls_settings`: `pyxmpp.TLSSettings`
            - `keepalive`: `int`
        """
        (self.authenticated, self.available_auth_methods, self.auth_stanza,
                self.peer_authenticated, self.auth_method_used,
                self.registration_callback, self.registration_form, self.__register) = (None,) * 8
        ClientStream.__init__(self, jid, password, server, port,
                            auth_methods, tls_settings, keepalive, owner)
        self.__logger=logging.getLogger("pyxmpp2.jabber.LegacyClientStream")

    def _reset(self):
        """Reset the `LegacyClientStream` object state, making the object ready
        to handle new connections."""
        ClientStream._reset(self)
        self.available_auth_methods = None
        self.auth_stanza = None
        self.registration_callback = None

    def _post_connect(self):
        """Initialize authentication when the connection is established
        and we are the initiator."""
        if not self.initiator:
            if "plain" in self.auth_methods or "digest" in self.auth_methods:
                self.set_iq_get_handler("query","jabber:iq:auth",
                            self.auth_in_stage1)
                self.set_iq_set_handler("query","jabber:iq:auth",
                            self.auth_in_stage2)
        elif self.registration_callback:
            iq = Iq(stanza_type = "get")
            iq.set_content(Register())
            self.set_response_handlers(iq, self.registration_form_received, self.registration_error)
            self.send(iq)
            return
        ClientStream._post_connect(self)

    def _post_auth(self):
        """Unregister legacy authentication handlers after successfull
        authentication."""
        ClientStream._post_auth(self)
        if not self.initiator:
            self.unset_iq_get_handler("query","jabber:iq:auth")
            self.unset_iq_set_handler("query","jabber:iq:auth")

    def _try_auth(self):
        """Try to authenticate using the first one of allowed authentication
        methods left.

        [client only]"""
        if self.authenticated:
            self.__logger.debug("try_auth: already authenticated")
            return
        self.__logger.debug("trying auth: %r" % (self._auth_methods_left,))
        if not self._auth_methods_left:
            raise LegacyAuthenticationError("No allowed authentication methods available")
        method=self._auth_methods_left[0]
        if method.startswith("sasl:"):
            return ClientStream._try_auth(self)
        elif method not in ("plain","digest"):
            self._auth_methods_left.pop(0)
            self.__logger.debug("Skipping unknown auth method: %s" % method)
            return self._try_auth()
        elif self.available_auth_methods is not None:
            if method in self.available_auth_methods:
                self._auth_methods_left.pop(0)
                self.auth_method_used=method
                if method=="digest":
                    self._digest_auth_stage2(self.auth_stanza)
                else:
                    self._plain_auth_stage2(self.auth_stanza)
                self.auth_stanza=None
                return
            else:
                self.__logger.debug("Skipping unavailable auth method: %s" % method)
        else:
            self._auth_stage1()

    def auth_in_stage1(self,stanza):
        """Handle the first stage (<iq type='get'/>) of legacy ("plain" or
        "digest") authentication.

        [server only]"""
        self.lock.acquire()
        try:
            if "plain" not in self.auth_methods and "digest" not in self.auth_methods:
                iq=stanza.make_error_response("not-allowed")
                self.send(iq)
                return

            iq=stanza.make_result_response()
            q=iq.new_query("jabber:iq:auth")
            q.newChild(None,"username",None)
            q.newChild(None,"resource",None)
            if "plain" in self.auth_methods:
                q.newChild(None,"password",None)
            if "digest" in self.auth_methods:
                q.newChild(None,"digest",None)
            self.send(iq)
            iq.free()
        finally:
            self.lock.release()

    def auth_in_stage2(self,stanza):
        """Handle the second stage (<iq type='set'/>) of legacy ("plain" or
        "digest") authentication.

        [server only]"""
        self.lock.acquire()
        try:
            if "plain" not in self.auth_methods and "digest" not in self.auth_methods:
                iq=stanza.make_error_response("not-allowed")
                self.send(iq)
                return

            username=stanza.xpath_eval("a:query/a:username",{"a":"jabber:iq:auth"})
            if username:
                username=from_utf8(username[0].getContent())
            resource=stanza.xpath_eval("a:query/a:resource",{"a":"jabber:iq:auth"})
            if resource:
                resource=from_utf8(resource[0].getContent())
            if not username or not resource:
                self.__logger.debug("No username or resource found in auth request")
                iq=stanza.make_error_response("bad-request")
                self.send(iq)
                return

            if stanza.xpath_eval("a:query/a:password",{"a":"jabber:iq:auth"}):
                if "plain" not in self.auth_methods:
                    iq=stanza.make_error_response("not-allowed")
                    self.send(iq)
                    return
                else:
                    return self._plain_auth_in_stage2(username,resource,stanza)
            if stanza.xpath_eval("a:query/a:digest",{"a":"jabber:iq:auth"}):
                if "plain" not in self.auth_methods:
                    iq=stanza.make_error_response("not-allowed")
                    self.send(iq)
                    return
                else:
                    return self._digest_auth_in_stage2(username,resource,stanza)
        finally:
            self.lock.release()

    def _auth_stage1(self):
        """Do the first stage (<iq type='get'/>) of legacy ("plain" or
        "digest") authentication.

        [client only]"""
        iq=Iq(stanza_type="get")
        q=iq.new_query("jabber:iq:auth")
        q.newTextChild(None,"username",to_utf8(self.my_jid.node))
        q.newTextChild(None,"resource",to_utf8(self.my_jid.resource))
        self.send(iq)
        self.set_response_handlers(iq,self.auth_stage2,self.auth_error,
                            self.auth_timeout,timeout=60)
        iq.free()

    def auth_timeout(self):
        """Handle legacy authentication timeout.

        [client only]"""
        self.lock.acquire()
        try:
            self.__logger.debug("Timeout while waiting for jabber:iq:auth result")
            if self._auth_methods_left:
                self._auth_methods_left.pop(0)
        finally:
            self.lock.release()

    def auth_error(self,stanza):
        """Handle legacy authentication error.

        [client only]"""
        self.lock.acquire()
        try:
            err=stanza.get_error()
            ae=err.xpath_eval("e:*",{"e":"jabber:iq:auth:error"})
            if ae:
                ae=ae[0].name
            else:
                ae=err.get_condition().name
            raise LegacyAuthenticationError("Authentication error condition: %s"
                        % (ae,))
        finally:
            self.lock.release()

    def auth_stage2(self,stanza):
        """Handle the first stage authentication response (result of the <iq
        type="get"/>).

        [client only]"""
        self.lock.acquire()
        try:
            self.__logger.debug("Procesing auth response...")
            self.available_auth_methods=[]
            if (stanza.xpath_eval("a:query/a:digest",{"a":"jabber:iq:auth"}) and self.stream_id):
                self.available_auth_methods.append("digest")
            if (stanza.xpath_eval("a:query/a:password",{"a":"jabber:iq:auth"})):
                self.available_auth_methods.append("plain")
            self.auth_stanza=stanza.copy()
            self._try_auth()
        finally:
            self.lock.release()

    def _plain_auth_stage2(self, _unused):
        """Do the second stage (<iq type='set'/>) of legacy "plain"
        authentication.

        [client only]"""
        iq=Iq(stanza_type="set")
        q=iq.new_query("jabber:iq:auth")
        q.newTextChild(None,"username",to_utf8(self.my_jid.node))
        q.newTextChild(None,"resource",to_utf8(self.my_jid.resource))
        q.newTextChild(None,"password",to_utf8(self.password))
        self.send(iq)
        self.set_response_handlers(iq,self.auth_finish,self.auth_error)
        iq.free()

    def _plain_auth_in_stage2(self, username, _unused, stanza):
        """Handle the second stage (<iq type='set'/>) of legacy "plain"
        authentication.

        [server only]"""
        password=stanza.xpath_eval("a:query/a:password",{"a":"jabber:iq:auth"})
        if password:
            password=from_utf8(password[0].getContent())
        if not password:
            self.__logger.debug("No password found in plain auth request")
            iq=stanza.make_error_response("bad-request")
            self.send(iq)
            return

        if self.check_password(username,password):
            iq=stanza.make_result_response()
            self.send(iq)
            self.peer_authenticated=True
            self.auth_method_used="plain"
            self.state_change("authorized",self.peer)
            self._post_auth()
        else:
            self.__logger.debug("Plain auth failed")
            iq=stanza.make_error_response("bad-request")
            e=iq.get_error()
            e.add_custom_condition('jabber:iq:auth:error',"user-unauthorized")
            self.send(iq)

    def _digest_auth_stage2(self, _unused):
        """Do the second stage (<iq type='set'/>) of legacy "digest"
        authentication.

        [client only]"""
        iq=Iq(stanza_type="set")
        q=iq.new_query("jabber:iq:auth")
        q.newTextChild(None,"username",to_utf8(self.my_jid.node))
        q.newTextChild(None,"resource",to_utf8(self.my_jid.resource))

        digest = hashlib.sha1(to_utf8(self.stream_id)+to_utf8(self.password)).hexdigest()

        q.newTextChild(None,"digest",digest)
        self.send(iq)
        self.set_response_handlers(iq,self.auth_finish,self.auth_error)
        iq.free()

    def _digest_auth_in_stage2(self, username, _unused, stanza):
        """Handle the second stage (<iq type='set'/>) of legacy "digest"
        authentication.

        [server only]"""
        digest=stanza.xpath_eval("a:query/a:digest",{"a":"jabber:iq:auth"})
        if digest:
            digest=digest[0].getContent()
        if not digest:
            self.__logger.debug("No digest found in digest auth request")
            iq=stanza.make_error_response("bad-request")
            self.send(iq)
            return

        password,pwformat=self.get_password(username)
        if not password or pwformat!="plain":
            iq=stanza.make_error_response("bad-request")
            e=iq.get_error()
            e.add_custom_condition('jabber:iq:auth:error',"user-unauthorized")
            self.send(iq)
            return

        mydigest = hashlib.sha1(to_utf8(self.stream_id)+to_utf8(password)).hexdigest()

        if mydigest==digest:
            iq=stanza.make_result_response()
            self.send(iq)
            self.peer_authenticated=True
            self.auth_method_used="digest"
            self.state_change("authorized",self.peer)
            self._post_auth()
        else:
            self.__logger.debug("Digest auth failed: %r != %r" % (digest,mydigest))
            iq=stanza.make_error_response("bad-request")
            e=iq.get_error()
            e.add_custom_condition('jabber:iq:auth:error',"user-unauthorized")
            self.send(iq)

    def auth_finish(self, _unused):
        """Handle success of the legacy authentication."""
        self.lock.acquire()
        try:
            self.__logger.debug("Authenticated")
            self.authenticated=True
            self.state_change("authorized",self.my_jid)
            self._post_auth()
        finally:
            self.lock.release()

    def registration_error(self, stanza):
        """Handle in-band registration error.

        [client only]

        :Parameters:
            - `stanza`: the error stanza received or `None` on timeout.
        :Types:
            - `stanza`: `pyxmpp.stanza.Stanza`"""
        self.lock.acquire()
        try:
            err=stanza.get_error()
            ae=err.xpath_eval("e:*",{"e":"jabber:iq:auth:error"})
            if ae:
                ae=ae[0].name
            else:
                ae=err.get_condition().name
            raise RegistrationError("Authentication error condition: %s" % (ae,))
        finally:
            self.lock.release()

    def registration_form_received(self, stanza):
        """Handle registration form received.

        [client only]

        Call self.registration_callback with the registration form received
        as the argument. Use the value returned by the callback will be a
        filled-in form.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `pyxmpp.iq.Iq`"""
        self.lock.acquire()
        try:
            self.__register = Register(stanza.get_query())
            self.registration_callback(stanza, self.__register.get_form())
        finally:
            self.lock.release()

    def submit_registration_form(self, form):
        """Submit a registration form.

        [client only]

        :Parameters:
            - `form`: the filled-in form. When form is `None` or its type is
              "cancel" the registration is to be canceled.

        :Types:
            - `form`: `pyxmpp.jabber.dataforms.Form`"""
        self.lock.acquire()
        try:
            if form and form.type!="cancel":
                self.registration_form = form
                iq = Iq(stanza_type = "set")
                iq.set_content(self.__register.submit_form(form))
                self.set_response_handlers(iq, self.registration_success, self.registration_error)
                self.send(iq)
            else:
                self.__register = None
        finally:
            self.lock.release()

    def registration_success(self, stanza):
        """Handle registration success.

        [client only]

        Clean up registration stuff, change state to "registered" and initialize
        authentication.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `pyxmpp.iq.Iq`"""
        _unused = stanza
        self.lock.acquire()
        try:
            self.state_change("registered", self.registration_form)
            if ('FORM_TYPE' in self.registration_form
                    and self.registration_form['FORM_TYPE'].value == 'jabber:iq:register'):
                if 'username' in self.registration_form:
                    self.my_jid = JID(self.registration_form['username'].value,
                            self.my_jid.domain, self.my_jid.resource)
                if 'password' in self.registration_form:
                    self.password = self.registration_form['password'].value
            self.registration_callback = None
            self._post_connect()
        finally:
            self.lock.release()

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = muc
#
# (C) Copyright 2003-2010 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
"""Jabber Multi-User Chat implementation.

Normative reference:
  - `JEP 45 <http://www.jabber.org/jeps/jep-0045.html>`__
"""

from __future__ import absolute_import

__docformat__="restructuredtext en"

import logging

from ..presence import Presence
from ..message import Message
from ..iq import Iq
from ..jid import JID

from ..xmlextra import xml_element_ns_iter

from .muccore import MucPresence,MucUserX,MucItem,MucStatus
from .muccore import MUC_OWNER_NS

from .dataforms import DATAFORM_NS, Form

import weakref

class MucRoomHandler:
    """
    Base class for MUC room handlers.

    Methods of this class will be called for various events in the room.

    :Ivariables:
      - `room_state`: MucRoomState object describing room state and its
        participants.

    """
    def __init__(self):
        """Initialize a `MucRoomHandler` object."""
        self.room_state=None
        self.__logger=logging.getLogger("pyxmpp.jabber.MucRoomHandler")

    def assign_state(self,state_obj):
        """Assign a state object to this `MucRoomHandler` instance.

        :Parameters:
            - `state_obj`: the state object.
        :Types:
            - `state_obj`: `MucRoomState`"""
        self.room_state=state_obj

    def room_created(self, stanza):
        """
        Called when the room has been created.

        Default action is to request an "instant room" by accepting the default
        configuration. Instead the application may want to request a
        configuration form and submit it.

        :Parameters:
            - `stanza`: the stanza received.

        :Types:
            - `stanza`: `pyxmpp.stanza.Stanza`
        """
        _unused = stanza
        self.room_state.request_instant_room()

    def configuration_form_received(self,form):
        """
        Called when a requested configuration form is received.

        The form, after filling-in shoul be passed to `self.room_state.configure_room`.

        :Parameters:
            - `form`: the configuration form.

        :Types:
            - `form`: `pyxmpp.jabber.dataforms.Form`
        """
        pass

    def room_configured(self):
        """
        Called after a successfull room configuration.
        """
        pass

    def user_joined(self,user,stanza):
        """
        Called when a new participant joins the room.

        :Parameters:
            - `user`: the user joining.
            - `stanza`: the stanza received.

        :Types:
            - `user`: `MucRoomUser`
            - `stanza`: `pyxmpp.stanza.Stanza`
        """
        pass

    def user_left(self,user,stanza):
        """
        Called when a participant leaves the room.

        :Parameters:
            - `user`: the user leaving.
            - `stanza`: the stanza received.

        :Types:
            - `user`: `MucRoomUser`
            - `stanza`: `pyxmpp.stanza.Stanza`
        """
        pass

    def role_changed(self,user,old_role,new_role,stanza):
        """
        Called when a role of an user has been changed.

        :Parameters:
            - `user`: the user (after update).
            - `old_role`: user's role before update.
            - `new_role`: user's role after update.
            - `stanza`: the stanza received.

        :Types:
            - `user`: `MucRoomUser`
            - `old_role`: `unicode`
            - `new_role`: `unicode`
            - `stanza`: `pyxmpp.stanza.Stanza`
        """
        pass

    def affiliation_changed(self,user,old_aff,new_aff,stanza):
        """
        Called when a affiliation of an user has been changed.

        `user` MucRoomUser object describing the user (after update).
        `old_aff` is user's affiliation before update.
        `new_aff` is user's affiliation after update.
        `stanza` the stanza received.
        """
        pass

    def nick_change(self,user,new_nick,stanza):
        """
        Called when user nick change is started.

        :Parameters:
            - `user`: the user (before update).
            - `new_nick`: the new nick.
            - `stanza`: the stanza received.

        :Types:
            - `user`: `MucRoomUser`
            - `new_nick`: `unicode`
            - `stanza`: `pyxmpp.stanza.Stanza`
        """
        pass

    def nick_changed(self,user,old_nick,stanza):
        """
        Called after a user nick has been changed.

        :Parameters:
            - `user`: the user (after update).
            - `old_nick`: the old nick.
            - `stanza`: the stanza received.

        :Types:
            - `user`: `MucRoomUser`
            - `old_nick`: `unicode`
            - `stanza`: `pyxmpp.stanza.Stanza`
        """
        pass

    def presence_changed(self,user,stanza):
        """
        Called whenever user's presence changes (includes nick, role or
        affiliation changes).

        :Parameters:
            - `user`: MucRoomUser object describing the user.
            - `stanza`: the stanza received.

        :Types:
            - `user`: `MucRoomUser`
            - `stanza`: `pyxmpp.stanza.Stanza`
        """
        pass

    def subject_changed(self,user,stanza):
        """
        Called when the room subject has been changed.

        :Parameters:
            - `user`: the user changing the subject.
            - `stanza`: the stanza used to change the subject.

        :Types:
            - `user`: `MucRoomUser`
            - `stanza`: `pyxmpp.stanza.Stanza`
        """
        pass

    def message_received(self,user,stanza):
        """
        Called when groupchat message has been received.

        :Parameters:
            - `user`: the sender.
            - `stanza`: is the message stanza received.

        :Types:
            - `user`: `MucRoomUser`
            - `stanza`: `pyxmpp.stanza.Stanza`
        """
        pass

    def room_configuration_error(self,stanza):
        """
        Called when an error stanza is received in reply to a room
        configuration request.

        By default `self.error` is called.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `pyxmpp.stanza.Stanza`
        """
        self.error(stanza)

    def error(self,stanza):
        """
        Called when an error stanza is received.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `pyxmpp.stanza.Stanza`
        """
        err=stanza.get_error()
        self.__logger.debug("Error from: %r Condition: %r"
                % (stanza.get_from(),err.get_condition))

class MucRoomUser:
    """
    Describes a user of a MUC room.

    The attributes of this object should not be changed directly.

    :Ivariables:
        - `presence`: last presence stanza received for the user.
        - `role`: user's role.
        - `affiliation`: user's affiliation.
        - `room_jid`: user's room jid.
        - `real_jid`: user's real jid or None if not available.
        - `nick`: user's nick (resource part of `room_jid`)
    :Types:
        - `presence`: `MucPresence`
        - `role`: `str`
        - `affiliation`: `str`
        - `room_jid`: `JID`
        - `real_jid`: `JID`
        - `nick`: `unicode`
    """
    def __init__(self,presence_or_user_or_jid):
        """
        Initialize a `MucRoomUser` object.

        :Parameters:
            - `presence_or_user_or_jid`: a MUC presence stanza with user
              information, a user object to copy or a room JID of a user.
        :Types:
            - `presence_or_user_or_jid`: `MucPresence` or `MucRoomUser` or
              `JID`

        When `presence_or_user_or_jid` is a JID user's
        role and affiliation are set to "none".
        """
        if isinstance(presence_or_user_or_jid,MucRoomUser):
            self.presence=presence_or_user_or_jid.presence
            self.role=presence_or_user_or_jid.role
            self.affiliation=presence_or_user_or_jid.affiliation
            self.room_jid=presence_or_user_or_jid.room_jid
            self.real_jid=presence_or_user_or_jid.real_jid
            self.nick=presence_or_user_or_jid.nick
            self.new_nick=None
        else:
            self.affiliation="none"
            self.presence=None
            self.real_jid=None
            self.new_nick=None
            if isinstance(presence_or_user_or_jid,JID):
                self.nick=presence_or_user_or_jid.resource
                self.room_jid=presence_or_user_or_jid
                self.role="none"
            elif isinstance(presence_or_user_or_jid,Presence):
                self.nick=None
                self.room_jid=None
                self.role="participant"
                self.update_presence(presence_or_user_or_jid)
            else:
                raise TypeError("Bad argument type for MucRoomUser constructor")

    def update_presence(self,presence):
        """
        Update user information.

        :Parameters:
            - `presence`: a presence stanza with user information update.
        :Types:
            - `presence`: `MucPresence`
        """
        self.presence=MucPresence(presence)
        t=presence.get_type()
        if t=="unavailable":
            self.role="none"
            self.affiliation="none"
        self.room_jid=self.presence.get_from()
        self.nick=self.room_jid.resource
        mc=self.presence.get_muc_child()
        if isinstance(mc,MucUserX):
            items=mc.get_items()
            for item in items:
                if not isinstance(item,MucItem):
                    continue
                if item.role:
                    self.role=item.role
                if item.affiliation:
                    self.affiliation=item.affiliation
                if item.jid:
                    self.real_jid=item.jid
                if item.nick:
                    self.new_nick=item.nick
                break

    def same_as(self,other):
        """Check if two `MucRoomUser` objects describe the same user in the
        same room.

        :Parameters:
            - `other`: the user object to compare `self` with.
        :Types:
            - `other`: `MucRoomUser`

        :return: `True` if the two object describe the same user.
        :returntype: `bool`"""
        return self.room_jid==other.room_jid

class MucRoomState:
    """
    Describes the state of a MUC room, handles room events
    and provides an interface for room actions.

    :Ivariables:
        - `own_jid`: real jid of the owner (client using this class).
        - `room_jid`: room jid of the owner.
        - `handler`: MucRoomHandler object containing callbacks to be called.
        - `manager`: MucRoomManager object managing this room.
        - `joined`: True if the channel is joined.
        - `subject`: current subject of the room.
        - `users`: dictionary of users in the room. Nicknames are the keys.
        - `me`: MucRoomUser instance of the owner.
        - `configured`: `False` if the room requires configuration.
    """
    def __init__(self,manager,own_jid,room_jid,handler):
        """
        Initialize a `MucRoomState` object.

        :Parameters:
            - `manager`: an object to manage this room.
            - `own_jid`: real JID of the owner (client using this class).
            - `room_jid`: room JID of the owner (provides the room name and
              the nickname).
            - `handler`: an object to handle room events.
        :Types:
            - `manager`: `MucRoomManager`
            - `own_jid`: JID
            - `room_jid`: JID
            - `handler`: `MucRoomHandler`
        """
        self.own_jid=own_jid
        self.room_jid=room_jid
        self.handler=handler
        self.manager=weakref.proxy(manager)
        self.joined=False
        self.subject=None
        self.users={}
        self.me=MucRoomUser(room_jid)
        self.configured = None
        self.configuration_form = None
        handler.assign_state(self)
        self.__logger=logging.getLogger("pyxmpp.jabber.MucRoomState")

    def get_user(self,nick_or_jid,create=False):
        """
        Get a room user with given nick or JID.

        :Parameters:
            - `nick_or_jid`: the nickname or room JID of the user requested.
            - `create`: if `True` and `nick_or_jid` is a JID, then a new
              user object will be created if there is no such user in the room.
        :Types:
            - `nick_or_jid`: `unicode` or `JID`
            - `create`: `bool`

        :return: the named user or `None`
        :returntype: `MucRoomUser`
        """
        if isinstance(nick_or_jid,JID):
            if not nick_or_jid.resource:
                return None
            for u in self.users.values():
                if nick_or_jid in (u.room_jid,u.real_jid):
                    return u
            if create:
                return MucRoomUser(nick_or_jid)
            else:
                return None
        return self.users.get(nick_or_jid)

    def set_stream(self,stream):
        """
        Called when current stream changes.

        Mark the room not joined and inform `self.handler` that it was left.

        :Parameters:
            - `stream`: the new stream.
        :Types:
            - `stream`: `pyxmpp.stream.Stream`
        """
        _unused = stream
        if self.joined and self.handler:
            self.handler.user_left(self.me,None)
        self.joined=False

    def join(self, password=None, history_maxchars = None,
            history_maxstanzas = None, history_seconds = None, history_since = None):
        """
        Send a join request for the room.

        :Parameters:
            - `password`: password to the room.
            - `history_maxchars`: limit of the total number of characters in
              history.
            - `history_maxstanzas`: limit of the total number of messages in
              history.
            - `history_seconds`: send only messages received in the last
              `history_seconds` seconds.
            - `history_since`: Send only the messages received since the
              dateTime specified (UTC).
        :Types:
            - `password`: `unicode`
            - `history_maxchars`: `int`
            - `history_maxstanzas`: `int`
            - `history_seconds`: `int`
            - `history_since`: `datetime.datetime`
        """
        if self.joined:
            raise RuntimeError("Room is already joined")
        p=MucPresence(to_jid=self.room_jid)
        p.make_join_request(password, history_maxchars, history_maxstanzas,
                history_seconds, history_since)
        self.manager.stream.send(p)

    def leave(self):
        """
        Send a leave request for the room.
        """
        if self.joined:
            p=MucPresence(to_jid=self.room_jid,stanza_type="unavailable")
            self.manager.stream.send(p)

    def send_message(self,body):
        """
        Send a message to the room.

        :Parameters:
            - `body`: the message body.
        :Types:
            - `body`: `unicode`
        """
        m=Message(to_jid=self.room_jid.bare(),stanza_type="groupchat",body=body)
        self.manager.stream.send(m)

    def set_subject(self,subject):
        """
        Send a subject change request to the room.

        :Parameters:
            - `subject`: the new subject.
        :Types:
            - `subject`: `unicode`
        """
        m=Message(to_jid=self.room_jid.bare(),stanza_type="groupchat",subject=subject)
        self.manager.stream.send(m)

    def change_nick(self,new_nick):
        """
        Send a nick change request to the room.

        :Parameters:
            - `new_nick`: the new nickname requested.
        :Types:
            - `new_nick`: `unicode`
        """
        new_room_jid=JID(self.room_jid.node,self.room_jid.domain,new_nick)
        p=Presence(to_jid=new_room_jid)
        self.manager.stream.send(p)

    def get_room_jid(self,nick=None):
        """
        Get own room JID or a room JID for given `nick`.

        :Parameters:
            - `nick`: a nick for which the room JID is requested.
        :Types:
            - `nick`: `unicode`

        :return: the room JID.
        :returntype: `JID`
        """
        if nick is None:
            return self.room_jid
        return JID(self.room_jid.node,self.room_jid.domain,nick)

    def get_nick(self):
        """
        Get own nick.

        :return: own nick.
        :returntype: `unicode`
        """
        return self.room_jid.resource

    def process_available_presence(self,stanza):
        """
        Process <presence/> received from the room.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `MucPresence`
        """
        fr=stanza.get_from()
        if not fr.resource:
            return
        nick=fr.resource
        user=self.users.get(nick)
        if user:
            old_user=MucRoomUser(user)
            user.update_presence(stanza)
            user.nick=nick
        else:
            old_user=None
            user=MucRoomUser(stanza)
            self.users[user.nick]=user
        self.handler.presence_changed(user,stanza)
        if fr==self.room_jid and not self.joined:
            self.joined=True
            self.me=user
            mc=stanza.get_muc_child()
            if isinstance(mc,MucUserX):
                status = [i for i in mc.get_items() if isinstance(i,MucStatus) and i.code==201]
                if status:
                    self.configured = False
                    self.handler.room_created(stanza)
            if self.configured is None:
                self.configured = True
        if not old_user or old_user.role=="none":
            self.handler.user_joined(user,stanza)
        else:
            if old_user.nick!=user.nick:
                self.handler.nick_changed(user,old_user.nick,stanza)
                if old_user.room_jid==self.room_jid:
                    self.room_jid=fr
            if old_user.role!=user.role:
                self.handler.role_changed(user,old_user.role,user.role,stanza)
            if old_user.affiliation!=user.affiliation:
                self.handler.affiliation_changed(user,old_user.affiliation,user.affiliation,stanza)

    def process_unavailable_presence(self,stanza):
        """
        Process <presence type="unavailable"/> received from the room.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `MucPresence`
        """
        fr=stanza.get_from()
        if not fr.resource:
            return
        nick=fr.resource
        user=self.users.get(nick)
        if user:
            old_user=MucRoomUser(user)
            user.update_presence(stanza)
            self.handler.presence_changed(user,stanza)
            if user.new_nick:
                mc=stanza.get_muc_child()
                if isinstance(mc,MucUserX):
                    renames=[i for i in mc.get_items() if isinstance(i,MucStatus) and i.code==303]
                    if renames:
                        self.users[user.new_nick]=user
                        del self.users[nick]
                        return
        else:
            old_user=None
            user=MucRoomUser(stanza)
            self.users[user.nick]=user
            self.handler.presence_changed(user,stanza)
        if fr==self.room_jid and self.joined:
            self.joined=False
            self.handler.user_left(user,stanza)
            self.manager.forget(self)
            self.me=user
        elif old_user:
            self.handler.user_left(user,stanza)
        # TODO: kicks

    def process_groupchat_message(self,stanza):
        """
        Process <message type="groupchat"/> received from the room.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `Message`
        """
        fr=stanza.get_from()
        user=self.get_user(fr,True)
        s=stanza.get_subject()
        if s:
            self.subject=s
            self.handler.subject_changed(user,stanza)
        else:
            self.handler.message_received(user,stanza)

    def process_error_message(self,stanza):
        """
        Process <message type="error"/> received from the room.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `Message`
        """
        self.handler.error(stanza)

    def process_error_presence(self,stanza):
        """
        Process <presence type="error"/> received from the room.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `Presence`
        """
        self.handler.error(stanza)

    def process_configuration_form_success(self, stanza):
        """
        Process successful result of a room configuration form request.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `Presence`
        """
        if stanza.get_query_ns() != MUC_OWNER_NS:
            raise ValueError("Bad result namespace") # TODO: ProtocolError
        query = stanza.get_query()
        form = None
        for el in xml_element_ns_iter(query.children, DATAFORM_NS):
            form = Form(el)
            break
        if not form:
            raise ValueError("No form received") # TODO: ProtocolError
        self.configuration_form = form
        self.handler.configuration_form_received(form)

    def process_configuration_form_error(self, stanza):
        """
        Process error response for a room configuration form request.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `Presence`
        """
        self.handler.error(stanza)

    def request_configuration_form(self):
        """
        Request a configuration form for the room.

        When the form is received `self.handler.configuration_form_received` will be called.
        When an error response is received then `self.handler.error` will be called.

        :return: id of the request stanza.
        :returntype: `unicode`
        """
        iq = Iq(to_jid = self.room_jid.bare(), stanza_type = "get")
        iq.new_query(MUC_OWNER_NS, "query")
        self.manager.stream.set_response_handlers(
                iq, self.process_configuration_form_success, self.process_configuration_form_error)
        self.manager.stream.send(iq)
        return iq.get_id()

    def process_configuration_success(self, stanza):
        """
        Process success response for a room configuration request.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `Presence`
        """
        _unused = stanza
        self.configured = True
        self.handler.room_configured()

    def process_configuration_error(self, stanza):
        """
        Process error response for a room configuration request.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `Presence`
        """
        self.handler.room_configuration_error(stanza)

    def configure_room(self, form):
        """
        Configure the room using the provided data.
        Do nothing if the provided form is of type 'cancel'.

        :Parameters:
            - `form`: the configuration parameters. Should be a 'submit' form made by filling-in
              the configuration form retireved using `self.request_configuration_form` or
              a 'cancel' form.
        :Types:
            - `form`: `Form`

        :return: id of the request stanza or `None` if a 'cancel' form was provieded.
        :returntype: `unicode`
        """

        if form.type == "cancel":
            return None
        elif form.type != "submit":
            raise ValueError("A 'submit' form required to configure a room")
        iq = Iq(to_jid = self.room_jid.bare(), stanza_type = "set")
        query = iq.new_query(MUC_OWNER_NS, "query")
        form.as_xml(query)
        self.manager.stream.set_response_handlers(
                iq, self.process_configuration_success, self.process_configuration_error)
        self.manager.stream.send(iq)
        return iq.get_id()

    def request_instant_room(self):
        """
        Request an "instant room" -- the default configuration for a MUC room.

        :return: id of the request stanza.
        :returntype: `unicode`
        """
        if self.configured:
            raise RuntimeError("Instant room may be requested for unconfigured room only")
        form = Form("submit")
        return self.configure_room(form)

class MucRoomManager:
    """
    Manage collection of MucRoomState objects and dispatch events.

    :Ivariables:
      - `rooms`: a dictionary containing known MUC rooms. Unicode room JIDs are the
        keys.
      - `stream`: the stream associated with the room manager.

    """
    def __init__(self,stream):
        """
        Initialize a `MucRoomManager` object.

        :Parameters:
            - `stream`: a stream to be initially assigned to `self`.
        :Types:
            - `stream`: `pyxmpp.stream.Stream`
        """
        self.rooms={}
        self.stream,self.jid=(None,)*2
        self.set_stream(stream)
        self.__logger=logging.getLogger("pyxmpp.jabber.MucRoomManager")

    def set_stream(self,stream):
        """
        Change the stream assigned to `self`.

        :Parameters:
            - `stream`: the new stream to be assigned to `self`.
        :Types:
            - `stream`: `pyxmpp.stream.Stream`
        """
        self.jid=stream.me
        self.stream=stream
        for r in self.rooms.values():
            r.set_stream(stream)

    def set_handlers(self,priority=10):
        """
        Assign MUC stanza handlers to the `self.stream`.

        :Parameters:
            - `priority`: priority for the handlers.
        :Types:
            - `priority`: `int`
        """
        self.stream.set_message_handler("groupchat",self.__groupchat_message,None,priority)
        self.stream.set_message_handler("error",self.__error_message,None,priority)
        self.stream.set_presence_handler("available",self.__presence_available,None,priority)
        self.stream.set_presence_handler("unavailable",self.__presence_unavailable,None,priority)
        self.stream.set_presence_handler("error",self.__presence_error,None,priority)

    def join(self, room, nick, handler, password = None, history_maxchars = None,
            history_maxstanzas = None, history_seconds = None, history_since = None):
        """
        Create and return a new room state object and request joining
        to a MUC room.

        :Parameters:
            - `room`: the name of a room to be joined
            - `nick`: the nickname to be used in the room
            - `handler`: is an object to handle room events.
            - `password`: password for the room, if any
            - `history_maxchars`: limit of the total number of characters in
              history.
            - `history_maxstanzas`: limit of the total number of messages in
              history.
            - `history_seconds`: send only messages received in the last
              `history_seconds` seconds.
            - `history_since`: Send only the messages received since the
              dateTime specified (UTC).

        :Types:
            - `room`: `JID`
            - `nick`: `unicode`
            - `handler`: `MucRoomHandler`
            - `password`: `unicode`
            - `history_maxchars`: `int`
            - `history_maxstanzas`: `int`
            - `history_seconds`: `int`
            - `history_since`: `datetime.datetime`

        :return: the room state object created.
        :returntype: `MucRoomState`
        """

        if not room.node or room.resource:
            raise ValueError("Invalid room JID")

        room_jid = JID(room.node, room.domain, nick)

        cur_rs = self.rooms.get(room_jid.bare().as_unicode())
        if cur_rs and cur_rs.joined:
            raise RuntimeError("Room already joined")

        rs=MucRoomState(self, self.stream.me, room_jid, handler)
        self.rooms[room_jid.bare().as_unicode()]=rs
        rs.join(password, history_maxchars, history_maxstanzas,
            history_seconds, history_since)
        return rs

    def get_room_state(self,room):
        """Get the room state object of a room.

        :Parameters:
            - `room`: JID or the room which state is requested.
        :Types:
            - `room`: `JID`

        :return: the state object.
        :returntype: `MucRoomState`"""
        return self.rooms.get(room.bare().as_unicode())

    def forget(self,rs):
        """
        Remove a room from the list of managed rooms.

        :Parameters:
            - `rs`: the state object of the room.
        :Types:
            - `rs`: `MucRoomState`
        """
        try:
            del self.rooms[rs.room_jid.bare().as_unicode()]
        except KeyError:
            pass

    def __groupchat_message(self,stanza):
        """Process a groupchat message from a MUC room.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `Message`

        :return: `True` if the message was properly recognized as directed to
            one of the managed rooms, `False` otherwise.
        :returntype: `bool`"""
        fr=stanza.get_from()
        key=fr.bare().as_unicode()
        rs=self.rooms.get(key)
        if not rs:
            self.__logger.debug("groupchat message from unknown source")
            return False
        rs.process_groupchat_message(stanza)
        return True

    def __error_message(self,stanza):
        """Process an error message from a MUC room.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `Message`

        :return: `True` if the message was properly recognized as directed to
            one of the managed rooms, `False` otherwise.
        :returntype: `bool`"""
        fr=stanza.get_from()
        key=fr.bare().as_unicode()
        rs=self.rooms.get(key)
        if not rs:
            return False
        rs.process_error_message(stanza)
        return True

    def __presence_error(self,stanza):
        """Process an presence error from a MUC room.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `Presence`

        :return: `True` if the stanza was properly recognized as generated by
            one of the managed rooms, `False` otherwise.
        :returntype: `bool`"""
        fr=stanza.get_from()
        key=fr.bare().as_unicode()
        rs=self.rooms.get(key)
        if not rs:
            return False
        rs.process_error_presence(stanza)
        return True

    def __presence_available(self,stanza):
        """Process an available presence from a MUC room.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `Presence`

        :return: `True` if the stanza was properly recognized as generated by
            one of the managed rooms, `False` otherwise.
        :returntype: `bool`"""
        fr=stanza.get_from()
        key=fr.bare().as_unicode()
        rs=self.rooms.get(key)
        if not rs:
            return False
        rs.process_available_presence(MucPresence(stanza))
        return True

    def __presence_unavailable(self,stanza):
        """Process an unavailable presence from a MUC room.

        :Parameters:
            - `stanza`: the stanza received.
        :Types:
            - `stanza`: `Presence`

        :return: `True` if the stanza was properly recognized as generated by
            one of the managed rooms, `False` otherwise.
        :returntype: `bool`"""
        fr=stanza.get_from()
        key=fr.bare().as_unicode()
        rs=self.rooms.get(key)
        if not rs:
            return False
        rs.process_unavailable_presence(MucPresence(stanza))
        return True

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = muccore
#
# (C) Copyright 2003-2010 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
"""Jabber Multi-User Chat implementation.

Normative reference:
  - `JEP 45 <http://www.jabber.org/jeps/jep-0045.html>`__
"""

from __future__ import absolute_import

__docformat__="restructuredtext en"

import libxml2

from ..utils import to_utf8,from_utf8
from ..xmlextra import common_doc, common_root, common_ns, get_node_ns_uri
from ..presence import Presence
from ..iq import Iq
from ..jid import JID
from .. import xmlextra
from ..objects import StanzaPayloadWrapperObject
from ..xmlextra import xml_element_iter

MUC_NS="http://jabber.org/protocol/muc"
MUC_USER_NS=MUC_NS+"#user"
MUC_ADMIN_NS=MUC_NS+"#admin"
MUC_OWNER_NS=MUC_NS+"#owner"

affiliations=("admin","member","none","outcast","owner")
roles=("moderator","none","participant","visitor")

class MucXBase(StanzaPayloadWrapperObject):
    """
    Base class for MUC-specific stanza payload - wrapper around
    an XML element.

    :Ivariables:
        - `xmlnode`: the wrapped XML node
    """
    element="x"
    ns=None
    def __init__(self, xmlnode=None, copy=True, parent=None):
        """
        Copy MucXBase object or create a new one, possibly
        based on or wrapping an XML node.

        :Parameters:
            - `xmlnode`: is the object to copy or an XML node to wrap.
            - `copy`: when `True` a copy of the XML node provided will be included
              in `self`, the node will be copied otherwise.
            - `parent`: parent node for the created/copied XML element.
        :Types:
            - `xmlnode`: `MucXBase` or `libxml2.xmlNode`
            - `copy`: `bool`
            - `parent`: `libxml2.xmlNode`
        """
        if self.ns==None:
            raise RuntimeError("Pure virtual class called")
        self.xmlnode=None
        self.borrowed=False
        if isinstance(xmlnode,libxml2.xmlNode):
            if copy:
                self.xmlnode=xmlnode.docCopyNode(common_doc,1)
                common_root.addChild(self.xmlnode)
            else:
                self.xmlnode=xmlnode
                self.borrowed=True
            if copy:
                ns=xmlnode.ns()
                xmlextra.replace_ns(self.xmlnode, ns, common_ns)
        elif isinstance(xmlnode,MucXBase):
            if not copy:
                raise TypeError("MucXBase may only be copied")
            self.xmlnode=xmlnode.xmlnode.docCopyNode(common_doc,1)
            common_root.addChild(self.xmlnode)
        elif xmlnode is not None:
            raise TypeError("Bad MucX constructor argument")
        else:
            if parent:
                self.xmlnode=parent.newChild(None,self.element,None)
                self.borrowed=True
            else:
                self.xmlnode=common_root.newChild(None,self.element,None)
            ns=self.xmlnode.newNs(self.ns,None)
            self.xmlnode.setNs(ns)

    def __del__(self):
        if self.xmlnode:
            self.free()

    def free(self):
        """
        Unlink and free the XML node owned by `self`.
        """
        if not self.borrowed:
            self.xmlnode.unlinkNode()
            self.xmlnode.freeNode()
        self.xmlnode=None

    def free_borrowed(self):
        """
        Detach the XML node borrowed by `self`.
        """
        self.xmlnode=None

    def xpath_eval(self,expr):
        """
        Evaluate XPath expression in context of `self.xmlnode`.

        :Parameters:
            - `expr`: the XPath expression
        :Types:
            - `expr`: `unicode`

        :return: the result of the expression evaluation.
        :returntype: list of `libxml2.xmlNode`
        """
        ctxt = common_doc.xpathNewContext()
        ctxt.setContextNode(self.xmlnode)
        ctxt.xpathRegisterNs("muc",self.ns.getContent())
        ret=ctxt.xpathEval(to_utf8(expr))
        ctxt.xpathFreeContext()
        return ret

    def serialize(self):
        """
        Serialize `self` as XML.

        :return: serialized `self.xmlnode`.
        :returntype: `str`
        """
        return self.xmlnode.serialize()

class MucX(MucXBase):
    """
    Wrapper for http://www.jabber.org/protocol/muc namespaced
    stanza payload "x" elements.
    """
    ns=MUC_NS
    def __init__(self, xmlnode=None, copy=True, parent=None):
        MucXBase.__init__(self,xmlnode=xmlnode, copy=copy, parent=parent)

    def set_history(self, parameters):
        """
        Set history parameters.

        Types:
            - `parameters`: `HistoryParameters`
        """
        for child in xml_element_iter(self.xmlnode.children):
            if get_node_ns_uri(child) == MUC_NS and child.name == "history":
                child.unlinkNode()
                child.freeNode()
                break

        if parameters.maxchars and parameters.maxchars < 0:
            raise ValueError("History parameter maxchars must be positive")
        if parameters.maxstanzas and parameters.maxstanzas < 0:
            raise ValueError("History parameter maxstanzas must be positive")
        if parameters.maxseconds and parameters.maxseconds < 0:
            raise ValueError("History parameter maxseconds must be positive")

        hnode=self.xmlnode.newChild(self.xmlnode.ns(), "history", None)

        if parameters.maxchars is not None:
            hnode.setProp("maxchars", str(parameters.maxchars))
        if parameters.maxstanzas is not None:
            hnode.setProp("maxstanzas", str(parameters.maxstanzas))
        if parameters.maxseconds is not None:
            hnode.setProp("maxseconds", str(parameters.maxseconds))
        if parameters.since is not None:
            hnode.setProp("since", parameters.since.strftime("%Y-%m-%dT%H:%M:%SZ"))

    def get_history(self):
        """Return history parameters carried by the stanza.

        :returntype: `HistoryParameters`"""
        for child in xml_element_iter(self.xmlnode.children):
            if get_node_ns_uri(child) == MUC_NS and child.name == "history":
                maxchars = from_utf8(child.prop("maxchars"))
                if maxchars is not None:
                    maxchars = int(maxchars)
                maxstanzas = from_utf8(child.prop("maxstanzas"))
                if maxstanzas is not None:
                    maxstanzas = int(maxstanzas)
                maxseconds = from_utf8(child.prop("maxseconds"))
                if maxseconds is not None:
                    maxseconds = int(maxseconds)
                # TODO: since -- requires parsing of Jabber dateTime profile
                since = None
                return HistoryParameters(maxchars, maxstanzas, maxseconds, since)

    def set_password(self, password):
        """Set password for the MUC request.

        :Parameters:
            - `password`: password
        :Types:
            - `password`: `unicode`"""
        for child in xml_element_iter(self.xmlnode.children):
            if get_node_ns_uri(child) == MUC_NS and child.name == "password":
                child.unlinkNode()
                child.freeNode()
                break

        if password is not None:
            self.xmlnode.newTextChild(self.xmlnode.ns(), "password", to_utf8(password))

    def get_password(self):
        """Get password from the MUC request.

        :returntype: `unicode`
        """
        for child in xml_element_iter(self.xmlnode.children):
            if get_node_ns_uri(child) == MUC_NS and child.name == "password":
                return from_utf8(child.getContent())
        return None

class HistoryParameters(object):
    """Provides parameters for MUC history management

    :Ivariables:
        - `maxchars`: limit of the total number of characters in history.
        - `maxstanzas`: limit of the total number of messages in history.
        - `seconds`: send only messages received in the last `seconds` seconds.
        - `since`: Send only the messages received since the dateTime (UTC)
          specified.
    :Types:
        - `maxchars`: `int`
        - `maxstanzas`: `int`
        - `seconds`: `int`
        - `since`: `datetime.datetime`
    """
    def __init__(self, maxchars = None, maxstanzas = None, maxseconds = None, since = None):
        """Initializes a `HistoryParameters` object.

        :Parameters:
            - `maxchars`: limit of the total number of characters in history.
            - `maxstanzas`: limit of the total number of messages in history.
            - `maxseconds`: send only messages received in the last `seconds` seconds.
            - `since`: Send only the messages received since the dateTime specified.
        :Types:
            - `maxchars`: `int`
            - `maxstanzas`: `int`
            - `maxseconds`: `int`
            - `since`: `datetime.datetime`
        """
        self.maxchars = maxchars
        self.maxstanzas = maxstanzas
        self.maxseconds = maxseconds
        self.since = since


class MucItemBase(object):
    """
    Base class for <status/> and <item/> element wrappers.
    """
    def __init__(self):
        if self.__class__ is MucItemBase:
            raise RuntimeError("Abstract class called")

class MucItem(MucItemBase):
    """
    MUC <item/> element -- describes a room occupant.

    :Ivariables:
        - `affiliation`: affiliation of the user.
        - `role`: role of the user.
        - `jid`: JID of the user.
        - `nick`: nickname of the user.
        - `actor`: actor modyfying the user data.
        - `reason`: reason of change of the user data.
    :Types:
        - `affiliation`: `str`
        - `role`: `str`
        - `jid`: `JID`
        - `nick`: `unicode`
        - `actor`: `JID`
        - `reason`: `unicode`
    """
    def __init__(self,xmlnode_or_affiliation,role=None,jid=None,nick=None,actor=None,reason=None):
        """
        Initialize a `MucItem` object.

        :Parameters:
            - `xmlnode_or_affiliation`: XML node to be pased or the affiliation of
              the user being described.
            - `role`: role of the user.
            - `jid`: JID of the user.
            - `nick`: nickname of the user.
            - `actor`: actor modyfying the user data.
            - `reason`: reason of change of the user data.
        :Types:
            - `xmlnode_or_affiliation`: `libxml2.xmlNode` or `str`
            - `role`: `str`
            - `jid`: `JID`
            - `nick`: `unicode`
            - `actor`: `JID`
            - `reason`: `unicode`
        """
        self.jid,self.nick,self.actor,self.affiliation,self.reason,self.role=(None,)*6
        MucItemBase.__init__(self)
        if isinstance(xmlnode_or_affiliation,libxml2.xmlNode):
            self.__from_xmlnode(xmlnode_or_affiliation)
        else:
            self.__init(xmlnode_or_affiliation,role,jid,nick,actor,reason)

    def __init(self,affiliation,role,jid=None,nick=None,actor=None,reason=None):
        """Initialize a `MucItem` object from a set of attributes.

        :Parameters:
            - `affiliation`: affiliation of the user.
            - `role`: role of the user.
            - `jid`: JID of the user.
            - `nick`: nickname of the user.
            - `actor`: actor modyfying the user data.
            - `reason`: reason of change of the user data.
        :Types:
            - `affiliation`: `str`
            - `role`: `str`
            - `jid`: `JID`
            - `nick`: `unicode`
            - `actor`: `JID`
            - `reason`: `unicode`
        """
        if not affiliation:
            affiliation=None
        elif affiliation not in affiliations:
            raise ValueError("Bad affiliation")
        self.affiliation=affiliation
        if not role:
            role=None
        elif role not in roles:
            raise ValueError("Bad role")
        self.role=role
        if jid:
            self.jid=JID(jid)
        else:
            self.jid=None
        if actor:
            self.actor=JID(actor)
        else:
            self.actor=None
        self.nick=nick
        self.reason=reason

    def __from_xmlnode(self, xmlnode):
        """Initialize a `MucItem` object from an XML node.

        :Parameters:
            - `xmlnode`: the XML node.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`
        """
        actor=None
        reason=None
        n=xmlnode.children
        while n:
            ns=n.ns()
            if ns and ns.getContent()!=MUC_USER_NS:
                continue
            if n.name=="actor":
                actor=n.getContent()
            if n.name=="reason":
                reason=n.getContent()
            n=n.next
        self.__init(
            from_utf8(xmlnode.prop("affiliation")),
            from_utf8(xmlnode.prop("role")),
            from_utf8(xmlnode.prop("jid")),
            from_utf8(xmlnode.prop("nick")),
            from_utf8(actor),
            from_utf8(reason),
            );

    def as_xml(self,parent):
        """
        Create XML representation of `self`.

        :Parameters:
            - `parent`: the element to which the created node should be linked to.
        :Types:
            - `parent`: `libxml2.xmlNode`

        :return: an XML node.
        :returntype: `libxml2.xmlNode`
        """
        n=parent.newChild(None,"item",None)
        if self.actor:
            n.newTextChild(None,"actor",to_utf8(self.actor))
        if self.reason:
            n.newTextChild(None,"reason",to_utf8(self.reason))
        n.setProp("affiliation",to_utf8(self.affiliation))
        if self.role:
            n.setProp("role",to_utf8(self.role))
        if self.jid:
            n.setProp("jid",to_utf8(self.jid.as_unicode()))
        if self.nick:
            n.setProp("nick",to_utf8(self.nick))
        return n

class MucStatus(MucItemBase):
    """
    MUC <item/> element - describes special meaning of a stanza

    :Ivariables:
        - `code`: staus code, as defined in JEP 45
    :Types:
        - `code`: `int`
    """
    def __init__(self,xmlnode_or_code):
        """Initialize a `MucStatus` element.

        :Parameters:
            - `xmlnode_or_code`: XML node to parse or a status code.
        :Types:
            - `xmlnode_or_code`: `libxml2.xmlNode` or `int`
        """
        self.code=None
        MucItemBase.__init__(self)
        if isinstance(xmlnode_or_code,libxml2.xmlNode):
            self.__from_xmlnode(xmlnode_or_code)
        else:
            self.__init(xmlnode_or_code)

    def __init(self,code):
        """Initialize a `MucStatus` element from a status code.

        :Parameters:
            - `code`: the status code.
        :Types:
            - `code`: `int`
        """
        code=int(code)
        if code<0 or code>999:
            raise ValueError("Bad status code")
        self.code=code

    def __from_xmlnode(self, xmlnode):
        """Initialize a `MucStatus` element from an XML node.

        :Parameters:
            - `xmlnode`: XML node to parse.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`
        """
        self.code=int(xmlnode.prop("code"))

    def as_xml(self,parent):
        """
        Create XML representation of `self`.

        :Parameters:
            - `parent`: the element to which the created node should be linked to.
        :Types:
            - `parent`: `libxml2.xmlNode`

        :return: an XML node.
        :returntype: `libxml2.xmlNode`
        """
        n=parent.newChild(None,"status",None)
        n.setProp("code","%03i" % (self.code,))
        return n

class MucUserX(MucXBase):
    """
    Wrapper for http://www.jabber.org/protocol/muc#user namespaced
    stanza payload "x" elements and usually containing information
    about a room user.

    :Ivariables:
        - `xmlnode`: wrapped XML node
    :Types:
        - `xmlnode`: `libxml2.xmlNode`
    """
    ns=MUC_USER_NS
    def get_items(self):
        """Get a list of objects describing the content of `self`.

        :return: the list of objects.
        :returntype: `list` of `MucItemBase` (`MucItem` and/or `MucStatus`)
        """
        if not self.xmlnode.children:
            return []
        ret=[]
        n=self.xmlnode.children
        while n:
            ns=n.ns()
            if ns and ns.getContent()!=self.ns:
                pass
            elif n.name=="item":
                ret.append(MucItem(n))
            elif n.name=="status":
                ret.append(MucStatus(n))
            # FIXME: alt,decline,invite,password
            n=n.next
        return ret
    def clear(self):
        """
        Clear the content of `self.xmlnode` removing all <item/>, <status/>, etc.
        """
        if not self.xmlnode.children:
            return
        n=self.xmlnode.children
        while n:
            ns=n.ns()
            if ns and ns.getContent()!=MUC_USER_NS:
                pass
            else:
                n.unlinkNode()
                n.freeNode()
            n=n.next
    def add_item(self,item):
        """Add an item to `self`.

        :Parameters:
            - `item`: the item to add.
        :Types:
            - `item`: `MucItemBase`
        """
        if not isinstance(item,MucItemBase):
            raise TypeError("Bad item type for muc#user")
        item.as_xml(self.xmlnode)

class MucOwnerX(MucXBase):
    """
    Wrapper for http://www.jabber.org/protocol/muc#owner namespaced
    stanza payload "x" elements and usually containing information
    about a room user.

    :Ivariables:
        - `xmlnode`: wrapped XML node.
    :Types:
        - `xmlnode`: `libxml2.xmlNode`
    """
    # FIXME: implement
    pass

class MucAdminQuery(MucUserX):
    """
    Wrapper for http://www.jabber.org/protocol/muc#admin namespaced
    IQ stanza payload "query" elements and usually describing
    administrative actions or their results.

    Not implemented yet.
    """
    ns=MUC_ADMIN_NS
    element="query"

class MucStanzaExt:
    """
    Base class for MUC specific stanza extensions. Used together
    with one of stanza classes (Iq, Message or Presence).
    """
    def __init__(self):
        """Initialize a `MucStanzaExt` derived object."""
        if self.__class__ is MucStanzaExt:
            raise RuntimeError("Abstract class called")
        self.xmlnode=None
        self.muc_child=None

    def get_muc_child(self):
        """
        Get the MUC specific payload element.

        :return: the object describing the stanza payload in MUC namespace.
        :returntype: `MucX` or `MucUserX` or `MucAdminQuery` or `MucOwnerX`
        """
        if self.muc_child:
            return self.muc_child
        if not self.xmlnode.children:
            return None
        n=self.xmlnode.children
        while n:
            if n.name not in ("x","query"):
                n=n.next
                continue
            ns=n.ns()
            if not ns:
                n=n.next
                continue
            ns_uri=ns.getContent()
            if (n.name,ns_uri)==("x",MUC_NS):
                self.muc_child=MucX(n)
                return self.muc_child
            if (n.name,ns_uri)==("x",MUC_USER_NS):
                self.muc_child=MucUserX(n)
                return self.muc_child
            if (n.name,ns_uri)==("query",MUC_ADMIN_NS):
                self.muc_child=MucAdminQuery(n)
                return self.muc_child
            if (n.name,ns_uri)==("query",MUC_OWNER_NS):
                self.muc_child=MucOwnerX(n)
                return self.muc_child
            n=n.next

    def clear_muc_child(self):
        """
        Remove the MUC specific stanza payload element.
        """
        if self.muc_child:
            self.muc_child.free_borrowed()
            self.muc_child=None
        if not self.xmlnode.children:
            return
        n=self.xmlnode.children
        while n:
            if n.name not in ("x","query"):
                n=n.next
                continue
            ns=n.ns()
            if not ns:
                n=n.next
                continue
            ns_uri=ns.getContent()
            if ns_uri in (MUC_NS,MUC_USER_NS,MUC_ADMIN_NS,MUC_OWNER_NS):
                n.unlinkNode()
                n.freeNode()
            n=n.next

    def make_muc_userinfo(self):
        """
        Create <x xmlns="...muc#user"/> element in the stanza.

        :return: the element created.
        :returntype: `MucUserX`
        """
        self.clear_muc_child()
        self.muc_child=MucUserX(parent=self.xmlnode)
        return self.muc_child

    def make_muc_admin_quey(self):
        """
        Create <query xmlns="...muc#admin"/> element in the stanza.

        :return: the element created.
        :returntype: `MucAdminQuery`
        """
        self.clear_muc_child()
        self.muc_child=MucAdminQuery(parent=self.xmlnode)
        return self.muc_child

    def muc_free(self):
        """
        Free MUC specific data.
        """
        if self.muc_child:
            self.muc_child.free_borrowed()

class MucPresence(Presence,MucStanzaExt):
    """
    Extend `Presence` with MUC related interface.
    """
    def __init__(self, xmlnode=None,from_jid=None,to_jid=None,stanza_type=None,stanza_id=None,
            show=None,status=None,priority=0,error=None,error_cond=None):
        """Initialize a `MucPresence` object.

        :Parameters:
            - `xmlnode`: XML node to_jid be wrapped into the `MucPresence` object
              or other Presence object to be copied. If not given then new
              presence stanza is created using following parameters.
            - `from_jid`: sender JID.
            - `to_jid`: recipient JID.
            - `stanza_type`: staza type: one of: None, "available", "unavailable",
              "subscribe", "subscribed", "unsubscribe", "unsubscribed" or
              "error". "available" is automaticaly changed to_jid None.
            - `stanza_id`: stanza id -- value of stanza's "id" attribute
            - `show`: "show" field of presence stanza. One of: None, "away",
              "xa", "dnd", "chat".
            - `status`: descriptive text for the presence stanza.
            - `priority`: presence priority.
            - `error_cond`: error condition name. Ignored if `stanza_type` is not "error"
        :Types:
            - `xmlnode`: `unicode` or `libxml2.xmlNode` or `pyxmpp.stanza.Stanza`
            - `from_jid`: `JID`
            - `to_jid`: `JID`
            - `stanza_type`: `unicode`
            - `stanza_id`: `unicode`
            - `show`: `unicode`
            - `status`: `unicode`
            - `priority`: `unicode`
            - `error_cond`: `unicode`"""
        MucStanzaExt.__init__(self)
        Presence.__init__(self,xmlnode,from_jid=from_jid,to_jid=to_jid,
                stanza_type=stanza_type,stanza_id=stanza_id,
                show=show,status=status,priority=priority,
                error=error,error_cond=error_cond)

    def copy(self):
        """
        Return a copy of `self`.
        """
        return MucPresence(self)

    def make_join_request(self, password = None, history_maxchars = None,
            history_maxstanzas = None, history_seconds = None,
            history_since = None):
        """
        Make the presence stanza a MUC room join request.

        :Parameters:
            - `password`: password to the room.
            - `history_maxchars`: limit of the total number of characters in
              history.
            - `history_maxstanzas`: limit of the total number of messages in
              history.
            - `history_seconds`: send only messages received in the last
              `seconds` seconds.
            - `history_since`: Send only the messages received since the
              dateTime specified (UTC).
        :Types:
            - `password`: `unicode`
            - `history_maxchars`: `int`
            - `history_maxstanzas`: `int`
            - `history_seconds`: `int`
            - `history_since`: `datetime.datetime`
        """
        self.clear_muc_child()
        self.muc_child=MucX(parent=self.xmlnode)
        if (history_maxchars is not None or history_maxstanzas is not None
                or history_seconds is not None or history_since is not None):
            history = HistoryParameters(history_maxchars, history_maxstanzas,
                    history_seconds, history_since)
            self.muc_child.set_history(history)
        if password is not None:
            self.muc_child.set_password(password)

    def get_join_info(self):
        """If `self` is a MUC room join request return the information contained.

        :return: the join request details or `None`.
        :returntype: `MucX`
        """
        x=self.get_muc_child()
        if not x:
            return None
        if not isinstance(x,MucX):
            return None
        return x

    def free(self):
        """Free the data associated with this `MucPresence` object."""
        self.muc_free()
        Presence.free(self)

class MucIq(Iq,MucStanzaExt):
    """
    Extend `Iq` with MUC related interface.
    """
    def __init__(self,xmlnode=None,from_jid=None,to_jid=None,stanza_type=None,stanza_id=None,
            error=None,error_cond=None):
        """Initialize an `Iq` object.

        :Parameters:
            - `xmlnode`: XML node to_jid be wrapped into the `Iq` object
              or other Iq object to be copied. If not given then new
              presence stanza is created using following parameters.
            - `from_jid`: sender JID.
            - `to_jid`: recipient JID.
            - `stanza_type`: staza type: one of: "get", "set", "result" or "error".
            - `stanza_id`: stanza id -- value of stanza's "id" attribute. If not
              given, then unique for the session value is generated.
            - `error_cond`: error condition name. Ignored if `stanza_type` is not "error".
        :Types:
            - `xmlnode`: `unicode` or `libxml2.xmlNode` or `Iq`
            - `from_jid`: `JID`
            - `to_jid`: `JID`
            - `stanza_type`: `unicode`
            - `stanza_id`: `unicode`
            - `error_cond`: `unicode`"""
        MucStanzaExt.__init__(self)
        Iq.__init__(self,xmlnode,from_jid=from_jid,to_jid=to_jid,
                stanza_type=stanza_type,stanza_id=stanza_id,
                error=error,error_cond=error_cond)

    def copy(self):
        """ Return a copy of `self`.  """
        return MucIq(self)

    def make_kick_request(self,nick,reason):
        """
        Make the iq stanza a MUC room participant kick request.

        :Parameters:
            - `nick`: nickname of user to kick.
            - `reason`: reason of the kick.
        :Types:
            - `nick`: `unicode`
            - `reason`: `unicode`

        :return: object describing the kick request details.
        :returntype: `MucItem`
        """
        self.clear_muc_child()
        self.muc_child=MucAdminQuery(parent=self.xmlnode)
        item=MucItem("none","none",nick=nick,reason=reason)
        self.muc_child.add_item(item)
        return self.muc_child

    def free(self):
        """Free the data associated with this `MucIq` object."""
        self.muc_free()
        Iq.free(self)

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = register
#
# (C) Copyright 2005-2010 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""In-band registration (jabber:iq:register) handling.

Normative reference:
  - `JEP 77 <http://www.jabber.org/jeps/jep-0077.html>`__
"""

from __future__ import absolute_import, division

__docformat__="restructuredtext en"

raise ImportError("{0} is not yet rewritten for PyXMPP2".format(__name__))

import libxml2
import logging

from ..utils import to_utf8,from_utf8
from ..xmlextra import get_node_ns_uri
from ..objects import StanzaPayloadObject
from ..xmlextra import xml_element_iter

from .dataforms import DATAFORM_NS, Form

REGISTER_NS="jabber:iq:register"

legacy_fields = {
        "username": ("text-single", u"Account name associated with the user"),
        "nick": ("text-single", u"Familiar name of the user"),
        "password": ("text-private", u"Password or secret for the user"),
        "name": ("text-single", u"Full name of the user"),
        "first": ("text-single", u"First name or given name of the user"),
        "last": ("text-single", u"Last name, surname, or family name of the user"),
        "email": ("text-single", u"Email address of the user"),
        "address": ("text-single", u"Street portion of a physical or mailing address"),
        "city": ("text-single", u"Locality portion of a physical or mailing address"),
        "state": ("text-single", u"Region portion of a physical or mailing address"),
        "zip": ("text-single", u"Postal code portion of a physical or mailing address"),
        "phone": ("text-single", u"Telephone number of the user"),
        "url": ("text-single", u"URL to web page describing the user"),
        "date": ("text-single", u"Some date (e.g., birth date, hire date, sign-up date)"),
        "misc": ("text-single", u"Free-form text field (obsolete)"),
        "text": ("text-single", u"Free-form text field (obsolete)"),
        "key": ("text-single", u"Session key for transaction (obsolete)"),
        }

class Register(StanzaPayloadObject):
    """
    Delayed delivery tag.

    Represents 'jabber:iq:register' (JEP-0077) element of a Jabber <iq/> stanza.

    Please note that it is recommended to use `get_form` and `submit_form` records
    instead of accessing the `form` and legacy fields directly. This way both
    legacy and Data Forms registration would work transparently to the application.

    :Ivariables:
        - `form`: registration form (when available)
        - `registered`: `True` if entity is already registered
        - `instrutions`: Registration instructions (legacy protocol)
        - `username`: Username field (legacy protocol)
        - `nick`: Nickname (legacy protocol)
        - `password`: Password (legacy protocol)
        - `name`: Name field (legacy protocol)
        - `first`: First name field (legacy protocol)
        - `last`: Last name field (legacy protocol)
        - `email`: E-mail field (legacy protocol)
        - `address`: Address field (legacy protocol)
        - `city`: City field (legacy protocol)
        - `state`: State field (legacy protocol)
        - `zip`: ZIP code field (legacy protocol)
        - `phone`: Phone field (legacy protocol)
        - `url`: URL field (legacy protocol)
        - `date`: Date field (legacy protocol)
        - `misc`: Misc field (legacy protocol, obsolete)
        - `text`: Text field (legacy protocol, obsolete)
        - `key`: Key field (legacy protocol, obsolete)
        - `remove`: `True` when the account should be removed
    :Types:
        - `form`: `pyxmpp.jabber.dataforms.Form`
        - `registered`: `bool`
        - `instrutions`: `unicode`
        - `username`: `unicode`
        - `nick`: `unicode`
        - `password`: `unicode`
        - `name`: `unicode`
        - `first`: `unicode`
        - `last`: `unicode`
        - `email`: `unicode`
        - `address`: `unicode`
        - `city`: `unicode`
        - `state`: `unicode`
        - `zip`: `unicode`
        - `phone`: `unicode`
        - `url`: `unicode`
        - `date`: `unicode`
        - `misc`: `unicode`
        - `text`: `unicode`
        - `key`: `unicode`
        - `remove`: `True` when the account should be removed
    """

    xml_element_name = "query"
    xml_element_namespace = REGISTER_NS

    def __init__(self, xmlnode = None):
        """
        Initialize the `Register` object.

        :Parameters:
            - `xmlnode`: an optional XML node to parse.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`
        """
        self.__logger=logging.getLogger("pyxmpp2.jabber.Register")
        self.form = None
        self.registered = False
        self.instructions = None
        self.remove = False
        for f in legacy_fields:
            setattr(self, f, None)
        if isinstance(xmlnode,libxml2.xmlNode):
            self.__from_xml(xmlnode)

    def __from_xml(self, xmlnode):
        """Initialize `Register` from an XML node.

        :Parameters:
            - `xmlnode`: the jabber:x:register XML element.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`"""

        self.__logger.debug("Converting jabber:iq:register element from XML")
        if xmlnode.type!="element":
            raise ValueError("XML node is not a jabber:iq:register element (not an element)")
        ns=get_node_ns_uri(xmlnode)
        if ns and ns!=REGISTER_NS or xmlnode.name!="query":
            raise ValueError("XML node is not a jabber:iq:register element")

        for element in xml_element_iter(xmlnode.children):
            ns = get_node_ns_uri(element)
            if ns == DATAFORM_NS and element.name == "x" and not self.form:
                self.form = Form(element)
            elif ns != REGISTER_NS:
                continue
            name = element.name
            if name == "instructions" and not self.instructions:
                self.instructions = from_utf8(element.getContent())
            elif name == "registered":
                self.registered = True
            elif name == "remove":
                self.remove = True
            elif name in legacy_fields and not getattr(self, name):
                value = from_utf8(element.getContent())
                if value is None:
                    value = u""
                self.__logger.debug(u"Setting legacy field %r to %r" % (name, value))
                setattr(self, name, value)

    def complete_xml_element(self, xmlnode, doc):
        """Complete the XML node with `self` content.

        :Parameters:
            - `xmlnode`: XML node with the element being built. It has already
              right name and namespace, but no attributes or content.
            - `doc`: document to which the element belongs.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`
            - `doc`: `libxml2.xmlDoc`"""
        ns = xmlnode.ns()
        if self.instructions is not None:
            xmlnode.newTextChild(ns, "instructions", to_utf8(self.instructions))
        if self.form:
            self.form.as_xml(xmlnode, doc)
        if self.remove:
            xmlnode.newChild(ns, "remove", None)
        else:
            if self.registered:
                xmlnode.newChild(ns, "registered", None)
            for field in legacy_fields:
                value = getattr(self, field)
                if value is not None:
                    xmlnode.newTextChild(ns, field, to_utf8(value))

    def get_form(self, form_type = "form"):
        """Return Data Form for the `Register` object.

        Convert legacy fields to a data form if `self.form` is `None`, return `self.form` otherwise.

        :Parameters:
            - `form_type`: If "form", then a form to fill-in should be
              returned. If "sumbit", then a form with submitted data.
        :Types:
            - `form_type`: `unicode`

        :return: `self.form` or a form created from the legacy fields
        :returntype: `pyxmpp.jabber.dataforms.Form`"""

        if self.form:
            if self.form.type != form_type:
                raise ValueError("Bad form type in the jabber:iq:register element")
            return self.form

        form = Form(form_type, instructions = self.instructions)
        form.add_field("FORM_TYPE", [u"jabber:iq:register"], "hidden")
        for field in legacy_fields:
            field_type, field_label = legacy_fields[field]
            value = getattr(self, field)
            if value is None:
                continue
            if form_type == "form":
                if not value:
                    value = None
                form.add_field(name = field, field_type = field_type, label = field_label,
                        value = value, required = True)
            else:
                form.add_field(name = field, value = value)
        return form

    def submit_form(self, form):
        """Make `Register` object for submitting the registration form.

        Convert form data to legacy fields if `self.form` is `None`.

        :Parameters:
            - `form`: The form to submit. Its type doesn't have to be "submit"
              (a "submit" form will be created here), so it could be the form
              obtained from `get_form` just with the data entered.

        :return: new registration element
        :returntype: `Register`"""

        result = Register()
        if self.form:
            result.form = form.make_submit()
            return result

        if "FORM_TYPE" not in form or "jabber:iq:register" not in form["FORM_TYPE"].values:
            raise ValueError("FORM_TYPE is not jabber:iq:register")

        for field in legacy_fields:
            self.__logger.debug(u"submitted field %r" % (field, ))
            value = getattr(self, field)
            try:
                form_value = form[field].value
            except KeyError:
                if value:
                    raise ValueError("Required field with no value!")
                continue
            setattr(result, field, form_value)

        return result


# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = vcard
#
# (C) Copyright 2003-2010 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# pylint: disable-msg=W0302
"""Jabber vCard and MIME (RFC 2426) vCard implementation.

Normative reference:
  - `JEP 54 <http://www.jabber.org/jeps/jep-0054.html>`__
  - `RFC 2425 <http://www.ietf.org/rfc/rfc2425.txt>`__
  - `RFC 2426 <http://www.ietf.org/rfc/rfc2426.txt>`__
"""

from __future__ import absolute_import, division


__docformat__="restructuredtext en"

raise ImportError("{0} is not yet rewritten for PyXMPP2".format(__name__))

import base64
import binascii
import libxml2
import re

import pyxmpp.jid
from ..utils import to_utf8,from_utf8
from ..xmlextra import get_node_ns
from ..objects import StanzaPayloadObject
from ..exceptions import BadRequestProtocolError, JIDMalformedProtocolError, JIDError

VCARD_NS="vcard-temp"

class Empty(Exception):
    """Exception raised when parsing empty vcard element. Such element will
    be ignored."""
    pass

valid_string_re=re.compile(r"^[\w\d \t]*$")
non_quoted_semicolon_re=re.compile(r'(?<!\\);')

def quote_semicolon(value):
    return value.replace(r';', r'\;')

def unquote_semicolon(value):
    return value.replace(r'\;', r';')

def rfc2425encode(name,value,parameters=None,charset="utf-8"):
    """Encodes a vCard field into an RFC2425 line.

    :Parameters:
        - `name`: field type name
        - `value`: field value
        - `parameters`: optional parameters
        - `charset`: encoding of the output and of the `value` (if not
          `unicode`)
    :Types:
        - `name`: `str`
        - `value`: `unicode` or `str`
        - `parameters`: `dict` of `str` -> `str`
        - `charset`: `str`

    :return: the encoded RFC2425 line (possibly folded)
    :returntype: `str`"""
    if not parameters:
        parameters={}
    if type(value) is unicode:
        value=value.replace(u"\r\n",u"\\n")
        value=value.replace(u"\n",u"\\n")
        value=value.replace(u"\r",u"\\n")
        value=value.encode(charset,"replace")
    elif type(value) is not str:
        raise TypeError("Bad type for rfc2425 value")
    elif not valid_string_re.match(value):
        parameters["encoding"]="b"
        value=binascii.b2a_base64(value)

    ret=str(name).lower()
    for k,v in parameters.items():
        ret+=";%s=%s" % (str(k),str(v))
    ret+=":"
    while(len(value)>70):
        ret+=value[:70]+"\r\n "
        value=value[70:]
    ret+=value+"\r\n"
    return ret

class VCardField:
    """Base class for vCard fields.

    :Ivariables:
        - `name`: name of the field.
    """
    def __init__(self,name):
        """Initialize a `VCardField` object.

        Set its name.

        :Parameters:
            - `name`: field name
        :Types:
            - `name`: `str`"""
        self.name=name
    def __repr__(self):
        return "<%s %r>" % (self.__class__,self.rfc2426())
    def rfc2426(self):
        """RFC2426-encode the field content.

        :return: the field in the RFC 2426 format.
        :returntype: `str`"""
        return ""

class VCardString(VCardField):
    """Generic class for all standard text fields in the vCard.

    :Ivariables:
        - `value`: field value.
    :Types:
        - `value`: `unicode`"""
    def __init__(self,name, value, rfc2425parameters = None, empty_ok = False):
        """Initialize a `VCardString` object.

        :Parameters:
            - `name`: field name
            - `value`: field value as string or an XML node
            - `rfc2425parameters`: optional RFC 2425 parameters
        :Types:
            - `name`: `str`
            - `value`: `str` or `libxml2.xmlNode`
            - `rfc2425parameters`: `dict`"""
        _unused = rfc2425parameters
        VCardField.__init__(self,name)
        if isinstance(value,libxml2.xmlNode):
            value=value.getContent()
            if value:
                self.value=unicode(value,"utf-8","replace").strip()
            else:
                self.value=u""
        else:
            self.value=value
        if not self.value and not empty_ok:
            raise Empty("Empty string value")
    def rfc2426(self):
        """RFC2426-encode the field content.

        :return: the field in the RFC 2426 format.
        :returntype: `str`"""
        return rfc2425encode(self.name,self.value)
    def as_xml(self,parent):
        """Create vcard-tmp XML representation of the field.

        :Parameters:
            - `parent`: parent node for the element
        :Types:
            - `parent`: `libxml2.xmlNode`

        :return: xml node with the field data.
        :returntype: `libxml2.xmlNode`"""
        return parent.newTextChild(None, to_utf8(self.name.upper()), to_utf8(self.value))
    def __unicode__(self):
        return self.value
    def __str__(self):
        return self.value.encode("utf-8")

class VCardXString(VCardString):
    """Generic class for all text vCard fields not defined in RFC 2426.

    In the RFC 2425 representation field name will be prefixed with 'x-'.

    :Ivariables:
        - `value`: field value.
    :Types:
        - `value`: `unicode`"""
    def rfc2426(self):
        """RFC2426-encode the field content.

        :return: the field in the RFC 2426 format.
        :returntype: `str`"""
        return rfc2425encode("x-"+self.name,self.value)

class VCardJID(VCardField):
    """JID vCard field.

    This field is not defined in RFC 2426, so it will be named 'x-jabberid'
    in RFC 2425 output.

    :Ivariables:
        - `value`: field value.
    :Types:
        - `value`: `JID`"""
    def __init__(self,name,value,rfc2425parameters=None):
        """Initialize a `VCardJID` object.

        :Parameters:
            - `name`: field name
            - `value`: field value as string or an XML node
            - `rfc2425parameters`: optional RFC 2425 parameters
        :Types:
            - `name`: `str`
            - `value`: `str` or `libxml2.xmlNode`
            - `rfc2425parameters`: `dict`"""
        _unused = rfc2425parameters
        VCardField.__init__(self,name)
        if isinstance(value,libxml2.xmlNode):
            try:
                self.value=pyxmpp.jid.JID(value.getContent())
            except JIDError:
                raise JIDMalformedProtocolError("JID malformed")
        else:
            self.value=pyxmpp.jid.JID(value)
        if not self.value:
            raise Empty("Empty JID value")
    def rfc2426(self):
        """RFC2426-encode the field content.

        :return: the field in the RFC 2426 format.
        :returntype: `str`"""
        return rfc2425encode("x-jabberid",self.value.as_unicode())
    def as_xml(self,parent):
        """Create vcard-tmp XML representation of the field.

        :Parameters:
            - `parent`: parent node for the element
        :Types:
            - `parent`: `libxml2.xmlNode`

        :return: xml node with the field data.
        :returntype: `libxml2.xmlNode`"""
        name=to_utf8(self.name.upper())
        content=self.value.as_utf8()
        return parent.newTextChild(None, name, content)
    def __unicode__(self):
        return self.value.as_unicode()
    def __str__(self):
        return self.value.as_string()

class VCardName(VCardField):
    """Name vCard field.

    :Ivariables:
        - `family`: family name.
        - `given`: given name.
        - `middle`: middle name.
        - `prefix`: name prefix.
        - `suffix`: name suffix.
    :Types:
        - `family`: `unicode`
        - `given`: `unicode`
        - `middle`: `unicode`
        - `prefix`: `unicode`
        - `suffix`: `unicode`"""
    def __init__(self,name,value,rfc2425parameters=None):
        """Initialize a `VCardName` object.

        :Parameters:
            - `name`: field name
            - `value`: field value as string or an XML node
            - `rfc2425parameters`: optional RFC 2425 parameters
        :Types:
            - `name`: `str`
            - `value`: `str` or `libxml2.xmlNode`
            - `rfc2425parameters`: `dict`"""
        _unused = rfc2425parameters
        VCardField.__init__(self,name)
        if self.name.upper()!="N":
            raise RuntimeError("VCardName handles only 'N' type")
        if isinstance(value,libxml2.xmlNode):
            self.family,self.given,self.middle,self.prefix,self.suffix=[u""]*5
            empty=1
            n=value.children
            vns=get_node_ns(value)
            while n:
                if n.type!='element':
                    n=n.next
                    continue
                ns=get_node_ns(n)
                if (ns and vns and ns.getContent()!=vns.getContent()):
                    n=n.next
                    continue
                if n.name=='FAMILY':
                    self.family=unicode(n.getContent(),"utf-8")
                    empty=0
                if n.name=='GIVEN':
                    self.given=unicode(n.getContent(),"utf-8")
                    empty=0
                if n.name=='MIDDLE':
                    self.middle=unicode(n.getContent(),"utf-8")
                    empty=0
                if n.name=='PREFIX':
                    self.prefix=unicode(n.getContent(),"utf-8")
                    empty=0
                if n.name=='SUFFIX':
                    self.suffix=unicode(n.getContent(),"utf-8")
                    empty=0
                n=n.next
            if empty:
                raise Empty("Empty N value")
        else:
            v=non_quoted_semicolon_re.split(value)
            value=[u""]*5
            value[:len(v)]=v
            self.family,self.given,self.middle,self.prefix,self.suffix=(
                unquote_semicolon(val) for val in value)
    def rfc2426(self):
        """RFC2426-encode the field content.

        :return: the field in the RFC 2426 format.
        :returntype: `str`"""
        return rfc2425encode("n",u';'.join(quote_semicolon(val) for val in
                (self.family,self.given,self.middle,self.prefix,self.suffix)))
    def as_xml(self,parent):
        """Create vcard-tmp XML representation of the field.

        :Parameters:
            - `parent`: parent node for the element
        :Types:
            - `parent`: `libxml2.xmlNode`

        :return: xml node with the field data.
        :returntype: `libxml2.xmlNode`"""
        n=parent.newChild(None,"N",None)
        n.newTextChild(None,"FAMILY",to_utf8(self.family))
        n.newTextChild(None,"GIVEN",to_utf8(self.given))
        n.newTextChild(None,"MIDDLE",to_utf8(self.middle))
        n.newTextChild(None,"PREFIX",to_utf8(self.prefix))
        n.newTextChild(None,"SUFFIX",to_utf8(self.suffix))
        return n
    def __unicode__(self):
        r=[]
        if self.prefix:
            r.append(self.prefix.replace(u",",u" "))
        if self.given:
            r.append(self.given.replace(u",",u" "))
        if self.middle:
            r.append(self.middle.replace(u",",u" "))
        if self.family:
            r.append(self.family.replace(u",",u" "))
        if self.suffix:
            r.append(self.suffix.replace(u",",u" "))
        return u" ".join(r)
    def __str__(self):
        return self.__unicode__().encode("utf-8")

class VCardImage(VCardField):
    """Image vCard field.

    :Ivariables:
        - `image`: image binary data (when `uri` is None)
        - `uri`: image URI (when `image` is None)
        - `type`: optional image type
    :Types:
        - `image`: `str`
        - `uri`: `unicode`
        - `type`: `unicode`"""
    def __init__(self,name,value,rfc2425parameters=None):
        """Initialize a `VCardImage` object.

        :Parameters:
            - `name`: field name
            - `value`: field value as string or an XML node
            - `rfc2425parameters`: optional RFC 2425 parameters
        :Types:
            - `name`: `str`
            - `value`: `str` or `libxml2.xmlNode`
            - `rfc2425parameters`: `dict`"""
        VCardField.__init__(self,name)
        if not rfc2425parameters:
            rfc2425parameters={}
        self.uri,self.type,self.image=[None]*3
        if isinstance(value,libxml2.xmlNode):
            n=value.children
            vns=get_node_ns(value)
            while n:
                if n.type!='element':
                    n=n.next
                    continue
                ns=get_node_ns(n)
                if (ns and vns and ns.getContent()!=vns.getContent()):
                    n=n.next
                    continue
                if n.name=='TYPE':
                    self.type=unicode(n.getContent(),"utf-8","replace")
                if n.name=='BINVAL':
                    self.image=base64.decodestring(n.getContent())
                if n.name=='EXTVAL':
                    self.uri=unicode(n.getContent(),"utf-8","replace")
                n=n.next
            if (self.uri and self.image) or (not self.uri and not self.image):
                raise ValueError("Bad %s value in vcard" % (name,))
            if (not self.uri and not self.image):
                raise Empty("Bad %s value in vcard" % (name,))
        else:
            if rfc2425parameters.get("value", "").lower()=="uri":
                self.uri=value
                self.type=None
            else:
                self.type=rfc2425parameters.get("type")
                self.image=value
    def rfc2426(self):
        """RFC2426-encode the field content.

        :return: the field in the RFC 2426 format.
        :returntype: `str`"""
        if self.uri:
            return rfc2425encode(self.name,self.uri,{"value":"uri"})
        elif self.image:
            if self.type:
                p={"type":self.type}
            else:
                p={}
            return rfc2425encode(self.name,self.image,p)
    def as_xml(self,parent):
        """Create vcard-tmp XML representation of the field.

        :Parameters:
            - `parent`: parent node for the element
        :Types:
            - `parent`: `libxml2.xmlNode`

        :return: xml node with the field data.
        :returntype: `libxml2.xmlNode`"""
        n=parent.newChild(None,self.name.upper(),None)
        if self.uri:
            n.newTextChild(None,"EXTVAL",to_utf8(self.uri))
        else:
            if self.type:
                n.newTextChild(None,"TYPE",self.type)
            n.newTextChild(None,"BINVAL",binascii.b2a_base64(self.image))
        return n
    def __unicode__(self):
        if self.uri:
            return self.uri
        if self.type:
            return u"(%s data)" % (self.type,)
        return u"(binary data)"
    def __str__(self):
        return self.__unicode__().encode("utf-8")


class VCardAdr(VCardField):
    """Address vCard field.

    :Ivariables:
        - `type`: type of the address.
        - `pobox`: the post office box.
        - `extadr`: the extended address.
        - `street`: the street address.
        - `locality`: the locality (e.g. city).
        - `region`: the region.
        - `pcode`: the postal code.
        - `ctry`: the country.
    :Types:
        - `type`: `list` of "home","work","postal","parcel","dom","intl" or "pref"
        - `pobox`: `unicode`
        - `extadr`: `unicode`
        - `street`: `unicode`
        - `locality`: `unicode`
        - `region`: `unicode`
        - `pcode`: `unicode`
        - `ctry`: `unicode`"""
    def __init__(self,name,value,rfc2425parameters=None):
        """Initialize a `VCardAdr` object.

        :Parameters:
            - `name`: field name
            - `value`: field value as string or an XML node
            - `rfc2425parameters`: optional RFC 2425 parameters
        :Types:
            - `name`: `str`
            - `value`: `str` or `libxml2.xmlNode`
            - `rfc2425parameters`: `dict`"""
        VCardField.__init__(self,name)
        if not rfc2425parameters:
            rfc2425parameters={}
        if self.name.upper()!="ADR":
            raise RuntimeError("VCardAdr handles only 'ADR' type")
        (self.pobox,self.extadr,self.street,self.locality,
                self.region,self.pcode,self.ctry)=[""]*7
        self.type=[]
        if isinstance(value,libxml2.xmlNode):
            self.__from_xml(value)
        else:
            t=rfc2425parameters.get("type")
            if t:
                self.type=t.split(",")
            else:
                self.type=["intl","postal","parcel","work"]
            v=non_quoted_semicolon_re.split(value)
            value=[""]*7
            value[:len(v)]=v
            (self.pobox,self.extadr,self.street,self.locality,
                    self.region,self.pcode,self.ctry)=(
                unquote_semicolon(val) for val in value)

    def __from_xml(self,value):
        """Initialize a `VCardAdr` object from and XML element.

        :Parameters:
            - `value`: field value as an XML node
        :Types:
            - `value`: `libxml2.xmlNode`"""
        n=value.children
        vns=get_node_ns(value)
        while n:
            if n.type!='element':
                n=n.next
                continue
            ns=get_node_ns(n)
            if (ns and vns and ns.getContent()!=vns.getContent()):
                n=n.next
                continue
            if n.name=='POBOX':
                self.pobox=unicode(n.getContent(),"utf-8","replace")
            elif n.name in ('EXTADR', 'EXTADD'):
                self.extadr=unicode(n.getContent(),"utf-8","replace")
            elif n.name=='STREET':
                self.street=unicode(n.getContent(),"utf-8","replace")
            elif n.name=='LOCALITY':
                self.locality=unicode(n.getContent(),"utf-8","replace")
            elif n.name=='REGION':
                self.region=unicode(n.getContent(),"utf-8","replace")
            elif n.name=='PCODE':
                self.pcode=unicode(n.getContent(),"utf-8","replace")
            elif n.name=='CTRY':
                self.ctry=unicode(n.getContent(),"utf-8","replace")
            elif n.name in ("HOME","WORK","POSTAL","PARCEL","DOM","INTL",
                    "PREF"):
                self.type.append(n.name.lower())
            n=n.next
        if self.type==[]:
            self.type=["intl","postal","parcel","work"]
        elif "dom" in self.type and "intl" in self.type:
            raise ValueError("Both 'dom' and 'intl' specified in vcard ADR")

    def rfc2426(self):
        """RFC2426-encode the field content.

        :return: the field in the RFC 2426 format.
        :returntype: `str`"""
        return rfc2425encode("adr",u';'.join(quote_semicolon(val) for val in
                (self.pobox,self.extadr,self.street,self.locality,
                        self.region,self.pcode,self.ctry)),
                {"type":",".join(self.type)})

    def as_xml(self,parent):
        """Create vcard-tmp XML representation of the field.

        :Parameters:
            - `parent`: parent node for the element
        :Types:
            - `parent`: `libxml2.xmlNode`

        :return: xml node with the field data.
        :returntype: `libxml2.xmlNode`"""
        n=parent.newChild(None,"ADR",None)
        for t in ("home","work","postal","parcel","dom","intl","pref"):
            if t in self.type:
                n.newChild(None,t.upper(),None)
        n.newTextChild(None,"POBOX",to_utf8(self.pobox))
        n.newTextChild(None,"EXTADD",to_utf8(self.extadr))
        n.newTextChild(None,"STREET",to_utf8(self.street))
        n.newTextChild(None,"LOCALITY",to_utf8(self.locality))
        n.newTextChild(None,"REGION",to_utf8(self.region))
        n.newTextChild(None,"PCODE",to_utf8(self.pcode))
        n.newTextChild(None,"CTRY",to_utf8(self.ctry))
        return n

class VCardLabel(VCardField):
    """Address label vCard field.

    :Ivariables:
        - `lines`: list of label text lines.
        - `type`: type of the label.
    :Types:
        - `lines`: `list` of `unicode`
        - `type`: `list` of "home","work","postal","parcel","dom","intl" or "pref"
    """
    def __init__(self,name,value,rfc2425parameters=None):
        """Initialize a `VCardLabel` object.

        :Parameters:
            - `name`: field name
            - `value`: field value as string or an XML node
            - `rfc2425parameters`: optional RFC 2425 parameters
        :Types:
            - `name`: `str`
            - `value`: `str` or `libxml2.xmlNode`
            - `rfc2425parameters`: `dict`"""
        VCardField.__init__(self,name)
        if not rfc2425parameters:
            rfc2425parameters={}
        if self.name.upper()!="LABEL":
            raise RuntimeError("VCardAdr handles only 'LABEL' type")
        if isinstance(value,libxml2.xmlNode):
            self.lines=[]
            self.type=[]
            n=value.children
            vns=get_node_ns(value)
            while n:
                if n.type!='element':
                    n=n.next
                    continue
                ns=get_node_ns(n)
                if (ns and vns and ns.getContent()!=vns.getContent()):
                    n=n.next
                    continue
                if n.name=='LINE':
                    l=unicode(n.getContent(),"utf-8","replace").strip()
                    l=l.replace("\n"," ").replace("\r"," ")
                    self.lines.append(l)
                elif n.name in ("HOME","WORK","POSTAL","PARCEL","DOM","INTL",
                        "PREF"):
                    self.type.append(n.name.lower())
                n=n.next
            if self.type==[]:
                self.type=["intl","postal","parcel","work"]
            elif "dom" in self.type and "intl" in self.type:
                raise ValueError("Both 'dom' and 'intl' specified in vcard LABEL")
            if not self.lines:
                self.lines=[""]
        else:
            t=rfc2425parameters.get("type")
            if t:
                self.type=t.split(",")
            else:
                self.type=["intl","postal","parcel","work"]
            self.lines=value.split("\\n")

    def rfc2426(self):
        """RFC2426-encode the field content.

        :return: the field in the RFC 2426 format.
        :returntype: `str`"""
        return rfc2425encode("label",u"\n".join(self.lines),
                {"type":",".join(self.type)})
    def as_xml(self,parent):
        """Create vcard-tmp XML representation of the field.

        :Parameters:
            - `parent`: parent node for the element
        :Types:
            - `parent`: `libxml2.xmlNode`

        :return: xml node with the field data.
        :returntype: `libxml2.xmlNode`"""
        n=parent.newChild(None,"ADR",None)
        for t in ("home","work","postal","parcel","dom","intl","pref"):
            if t in self.type:
                n.newChild(None,t.upper(),None)
        for l in self.lines:
            n.newTextChild(None,"LINE",l)
        return n

class VCardTel(VCardField):
    """Telephone vCard field.

    :Ivariables:
        - `number`: phone number.
        - `type`: type of the phone number.
    :Types:
        - `number`: `unicode`
        - `type`: `list` of "home","work","voice","fax","pager","msg","cell","video","bbs","modem","isdn","pcs" or "pref".
    """
    def __init__(self,name,value,rfc2425parameters=None):
        """Initialize a `VCardTel` object.

        :Parameters:
            - `name`: field name
            - `value`: field value as string or an XML node
            - `rfc2425parameters`: optional RFC 2425 parameters
        :Types:
            - `name`: `str`
            - `value`: `str` or `libxml2.xmlNode`
            - `rfc2425parameters`: `dict`"""
        VCardField.__init__(self,name)
        if not rfc2425parameters:
            rfc2425parameters={}
        if self.name.upper()!="TEL":
            raise RuntimeError("VCardTel handles only 'TEL' type")
        if isinstance(value,libxml2.xmlNode):
            self.number=None
            self.type=[]
            n=value.children
            vns=get_node_ns(value)
            while n:
                if n.type!='element':
                    n=n.next
                    continue
                ns=get_node_ns(n)
                if (ns and vns and ns.getContent()!=vns.getContent()):
                    n=n.next
                    continue
                if n.name=='NUMBER':
                    self.number=unicode(n.getContent(),"utf-8","replace")
                elif n.name in ("HOME","WORK","VOICE","FAX","PAGER","MSG",
                        "CELL","VIDEO","BBS","MODEM","ISDN","PCS",
                        "PREF"):
                    self.type.append(n.name.lower())
                n=n.next
            if self.type==[]:
                self.type=["voice"]
            if not self.number:
                raise Empty("No tel number")
        else:
            t=rfc2425parameters.get("type")
            if t:
                self.type=t.split(",")
            else:
                self.type=["voice"]
            self.number=value
    def rfc2426(self):
        """RFC2426-encode the field content.

        :return: the field in the RFC 2426 format.
        :returntype: `str`"""
        return rfc2425encode("tel",self.number,{"type":",".join(self.type)})
    def as_xml(self,parent):
        """Create vcard-tmp XML representation of the field.

        :Parameters:
            - `parent`: parent node for the element
        :Types:
            - `parent`: `libxml2.xmlNode`

        :return: xml node with the field data.
        :returntype: `libxml2.xmlNode`"""
        n=parent.newChild(None,"TEL",None)
        for t in ("home","work","voice","fax","pager","msg","cell","video",
                "bbs","modem","isdn","pcs","pref"):
            if t in self.type:
                n.newChild(None,t.upper(),None)
        n.newTextChild(None,"NUMBER",to_utf8(self.number))
        return n

class VCardEmail(VCardField):
    """E-mail vCard field.

    :Ivariables:
        - `address`: e-mail address.
        - `type`: type of the address.
    :Types:
        - `address`: `unicode`
        - `type`: `list` of "home","work","internet" or "x400".
    """
    def __init__(self,name,value,rfc2425parameters=None):
        """Initialize a `VCardEmail` object.

        :Parameters:
            - `name`: field name
            - `value`: field value as string or an XML node
            - `rfc2425parameters`: optional RFC 2425 parameters
        :Types:
            - `name`: `str`
            - `value`: `str` or `libxml2.xmlNode`
            - `rfc2425parameters`: `dict`"""
        VCardField.__init__(self,name)
        if not rfc2425parameters:
            rfc2425parameters={}
        if self.name.upper()!="EMAIL":
            raise RuntimeError("VCardEmail handles only 'EMAIL' type")
        if isinstance(value,libxml2.xmlNode):
            self.address=None
            self.type=[]
            n=value.children
            vns=get_node_ns(value)
            while n:
                if n.type!='element':
                    n=n.next
                    continue
                ns=get_node_ns(n)
                if (ns and vns and ns.getContent()!=vns.getContent()):
                    n=n.next
                    continue
                if n.name=='USERID':
                    self.address=unicode(n.getContent(),"utf-8","replace")
                elif n.name in ("HOME","WORK","INTERNET","X400"):
                    self.type.append(n.name.lower())
                n=n.next
            if self.type==[]:
                self.type=["internet"]
            if not self.address:
                raise Empty("No USERID")
        else:
            t=rfc2425parameters.get("type")
            if t:
                self.type=t.split(",")
            else:
                self.type=["internet"]
            self.address=value
    def rfc2426(self):
        """RFC2426-encode the field content.

        :return: the field in the RFC 2426 format.
        :returntype: `str`"""
        return rfc2425encode("email",self.address,{"type":",".join(self.type)})
    def as_xml(self,parent):
        """Create vcard-tmp XML representation of the field.

        :Parameters:
            - `parent`: parent node for the element
        :Types:
            - `parent`: `libxml2.xmlNode`

        :return: xml node with the field data.
        :returntype: `libxml2.xmlNode`"""
        n=parent.newChild(None,"EMAIL",None)
        for t in ("home","work","internet","x400"):
            if t in self.type:
                n.newChild(None,t.upper(),None)
        n.newTextChild(None,"USERID",to_utf8(self.address))
        return n

class VCardGeo(VCardField):
    """Geographical location vCard field.

    :Ivariables:
        - `lat`: the latitude.
        - `lon`: the longitude.
    :Types:
        - `lat`: `unicode`
        - `lon`: `unicode`
    """
    def __init__(self,name,value,rfc2425parameters=None):
        """Initialize a `VCardGeo` object.

        :Parameters:
            - `name`: field name
            - `value`: field value as string or an XML node
            - `rfc2425parameters`: optional RFC 2425 parameters
        :Types:
            - `name`: `str`
            - `value`: `str` or `libxml2.xmlNode`
            - `rfc2425parameters`: `dict`"""
        _unused = rfc2425parameters
        VCardField.__init__(self,name)
        if self.name.upper()!="GEO":
            raise RuntimeError("VCardName handles only 'GEO' type")
        if isinstance(value,libxml2.xmlNode):
            self.lat,self.lon=[None]*2
            n=value.children
            vns=get_node_ns(value)
            while n:
                if n.type!='element':
                    n=n.next
                    continue
                ns=get_node_ns(n)
                if (ns and vns and ns.getContent()!=vns.getContent()):
                    n=n.next
                    continue
                if n.name=='LAT':
                    self.lat=unicode(n.getContent(),"utf-8")
                if n.name=='LON':
                    self.lon=unicode(n.getContent(),"utf-8")
                n=n.next
            if not self.lat or not self.lon:
                raise ValueError("Bad vcard GEO value")
        else:
            self.lat,self.lon=(unquote_semicolon(val) for val in non_quoted_semicolon_re.split(value))
    def rfc2426(self):
        """RFC2426-encode the field content.

        :return: the field in the RFC 2426 format.
        :returntype: `str`"""
        return rfc2425encode("geo",u';'.join(quote_semicolon(val) for val in
                (self.lat,self.lon)))
    def as_xml(self,parent):
        """Create vcard-tmp XML representation of the field.

        :Parameters:
            - `parent`: parent node for the element
        :Types:
            - `parent`: `libxml2.xmlNode`

        :return: xml node with the field data.
        :returntype: `libxml2.xmlNode`"""
        n=parent.newChild(None,"GEO",None)
        n.newTextChild(None,"LAT",to_utf8(self.lat))
        n.newTextChild(None,"LON",to_utf8(self.lon))
        return n

class VCardOrg(VCardField):
    """Organization vCard field.

    :Ivariables:
        - `name`: organization name.
        - `unit`: organizational unit.
    :Types:
        - `name`: `unicode`
        - `unit`: `unicode`
    """
    def __init__(self,name,value,rfc2425parameters=None):
        """Initialize a `VCardOrg` object.

        :Parameters:
            - `name`: field name
            - `value`: field value as string or an XML node
            - `rfc2425parameters`: optional RFC 2425 parameters
        :Types:
            - `name`: `str`
            - `value`: `str` or `libxml2.xmlNode`
            - `rfc2425parameters`: `dict`"""
        _unused = rfc2425parameters
        VCardField.__init__(self,name)
        if self.name.upper()!="ORG":
            raise RuntimeError("VCardName handles only 'ORG' type")
        if isinstance(value,libxml2.xmlNode):
            self.name,self.unit=None,""
            n=value.children
            vns=get_node_ns(value)
            while n:
                if n.type!='element':
                    n=n.next
                    continue
                ns=get_node_ns(n)
                if (ns and vns and ns.getContent()!=vns.getContent()):
                    n=n.next
                    continue
                if n.name=='ORGNAME':
                    self.name=unicode(n.getContent(),"utf-8")
                if n.name=='ORGUNIT':
                    self.unit=unicode(n.getContent(),"utf-8")
                n=n.next
            if not self.name:
                raise Empty("Bad vcard ORG value")
        else:
            sp=non_quoted_semicolon_re.split(value,1)
            if len(sp)>1:
                self.name,self.unit=(unquote_semicolon(val) for val in sp)
            else:
                self.name=unquote_semicolon(sp[0])
                self.unit=None
    def rfc2426(self):
        """RFC2426-encode the field content.

        :return: the field in the RFC 2426 format.
        :returntype: `str`"""
        if self.unit:
            return rfc2425encode("org",u';'.join(quote_semicolon(val) for val in
                                      (self.name,self.unit)))
        else:
            return rfc2425encode("org",unicode(quote_semicolon(self.name)))
    def as_xml(self,parent):
        """Create vcard-tmp XML representation of the field.

        :Parameters:
            - `parent`: parent node for the element
        :Types:
            - `parent`: `libxml2.xmlNode`

        :return: xml node with the field data.
        :returntype: `libxml2.xmlNode`"""
        n=parent.newChild(None,"ORG",None)
        n.newTextChild(None,"ORGNAME",to_utf8(self.name))
        n.newTextChild(None,"ORGUNIT",to_utf8(self.unit))
        return n

class VCardCategories(VCardField):
    """Categories vCard field.

    :Ivariables:
        - `keywords`: category keywords.
    :Types:
        - `keywords`: `list` of `unicode`
    """
    def __init__(self,name,value,rfc2425parameters=None):
        """Initialize a `VCardCategories` object.

        :Parameters:
            - `name`: field name
            - `value`: field value as string or an XML node
            - `rfc2425parameters`: optional RFC 2425 parameters
        :Types:
            - `name`: `str`
            - `value`: `str` or `libxml2.xmlNode`
            - `rfc2425parameters`: `dict`"""
        _unused = rfc2425parameters
        VCardField.__init__(self,name)
        self.name=name
        if self.name.upper()!="CATEGORIES":
            raise RuntimeError("VCardName handles only 'CATEGORIES' type")
        if isinstance(value,libxml2.xmlNode):
            self.keywords=[]
            n=value.children
            vns=get_node_ns(value)
            while n:
                if n.type!='element':
                    n=n.next
                    continue
                ns=get_node_ns(n)
                if (ns and vns and ns.getContent()!=vns.getContent()):
                    n=n.next
                    continue
                if n.name=='KEYWORD':
                    self.keywords.append(unicode(n.getContent(),"utf-8"))
                n=n.next
            if not self.keywords:
                raise Empty("Bad vcard CATEGORIES value")
        else:
            self.keywords=value.split(",")
    def rfc2426(self):
        """RFC2426-encode the field content.

        :return: the field in the RFC 2426 format.
        :returntype: `str`"""
        return rfc2425encode("keywords",u",".join(self.keywords))
    def as_xml(self,parent):
        """Create vcard-tmp XML representation of the field.

        :Parameters:
            - `parent`: parent node for the element
        :Types:
            - `parent`: `libxml2.xmlNode`

        :return: xml node with the field data.
        :returntype: `libxml2.xmlNode`"""
        n=parent.newChild(None,"CATEGORIES",None)
        for k in self.keywords:
            n.newTextChild(None,"KEYWORD",to_utf8(k))
        return n

class VCardSound(VCardField):
    """Sound vCard field.

    :Ivariables:
        - `sound`: binary sound data (when `uri` is None)
        - `uri`: sound URI (when `sound` is None)
        - `phonetic`: phonetic transcription
    :Types:
        - `sound`: `str`
        - `uri`: `unicode`
        - `phonetic`: `unicode`"""
    def __init__(self,name,value,rfc2425parameters=None):
        """Initialize a `VCardSound` object.

        :Parameters:
            - `name`: field name
            - `value`: field value as string or an XML node
            - `rfc2425parameters`: optional RFC 2425 parameters
        :Types:
            - `name`: `str`
            - `value`: `str` or `libxml2.xmlNode`
            - `rfc2425parameters`: `dict`"""
        VCardField.__init__(self,name)
        if not rfc2425parameters:
            rfc2425parameters={}
        self.uri,self.sound,self.phonetic=[None]*3
        if isinstance(value,libxml2.xmlNode):
            n=value.children
            vns=get_node_ns(value)
            while n:
                if n.type!='element':
                    n=n.next
                    continue
                ns=get_node_ns(n)
                if (ns and vns and ns.getContent()!=vns.getContent()):
                    n=n.next
                    continue
                if n.name=='BINVAL':
                    if (self.phonetic or self.uri):
                        raise ValueError("Bad SOUND value in vcard")
                    self.sound=base64.decodestring(n.getContent())
                if n.name=='PHONETIC':
                    if (self.sound or self.uri):
                        raise ValueError("Bad SOUND value in vcard")
                    self.phonetic=unicode(n.getContent(),"utf-8","replace")
                if n.name=='EXTVAL':
                    if (self.phonetic or self.sound):
                        raise ValueError("Bad SOUND value in vcard")
                    self.uri=unicode(n.getContent(),"utf-8","replace")
                n=n.next
            if (not self.phonetic and not self.uri and not self.sound):
                raise Empty("Bad SOUND value in vcard")
        else:
            if rfc2425parameters.get("value", "").lower()=="uri":
                self.uri=value
                self.sound=None
                self.phonetic=None
            else:
                self.sound=value
                self.uri=None
                self.phonetic=None
    def rfc2426(self):
        """RFC2426-encode the field content.

        :return: the field in the RFC 2426 format.
        :returntype: `str`"""
        if self.uri:
            return rfc2425encode(self.name,self.uri,{"value":"uri"})
        elif self.sound:
            return rfc2425encode(self.name,self.sound)
    def as_xml(self,parent):
        """Create vcard-tmp XML representation of the field.

        :Parameters:
            - `parent`: parent node for the element
        :Types:
            - `parent`: `libxml2.xmlNode`

        :return: xml node with the field data.
        :returntype: `libxml2.xmlNode`"""
        n=parent.newChild(None,self.name.upper(),None)
        if self.uri:
            n.newTextChild(None,"EXTVAL",to_utf8(self.uri))
        elif self.phonetic:
            n.newTextChild(None,"PHONETIC",to_utf8(self.phonetic))
        else:
            n.newTextChild(None,"BINVAL",binascii.b2a_base64(self.sound))
        return n

class VCardPrivacy(VCardField):
    """Privacy vCard field.

    :Ivariables:
        - `value`: privacy information about the vcard data ("public", "private"
          or "confidental")
    :Types:
        - `value`: `str` """
    def __init__(self,name,value,rfc2425parameters=None):
        """Initialize a `VCardPrivacy` object.

        :Parameters:
            - `name`: field name
            - `value`: field value as string or an XML node
            - `rfc2425parameters`: optional RFC 2425 parameters
        :Types:
            - `name`: `str`
            - `value`: `str` or `libxml2.xmlNode`
            - `rfc2425parameters`: `dict`"""
        _unused = rfc2425parameters
        VCardField.__init__(self,name)
        if isinstance(value,libxml2.xmlNode):
            self.value=None
            n=value.children
            vns=get_node_ns(value)
            while n:
                if n.type!='element':
                    n=n.next
                    continue
                ns=get_node_ns(n)
                if (ns and vns and ns.getContent()!=vns.getContent()):
                    n=n.next
                    continue
                if n.name=='PUBLIC':
                    self.value="public"
                elif n.name=='PRIVATE':
                    self.value="private"
                elif n.name=='CONFIDENTAL':
                    self.value="confidental"
                n=n.next
            if not self.value:
                raise Empty
        else:
            self.value=value
    def rfc2426(self):
        """RFC2426-encode the field content.

        :return: the field in the RFC 2426 format.
        :returntype: `str`"""
        return rfc2425encode(self.name,self.value)
    def as_xml(self,parent):
        """Create vcard-tmp XML representation of the field.

        :Parameters:
            - `parent`: parent node for the element
        :Types:
            - `parent`: `libxml2.xmlNode`

        :return: xml node with the field data.
        :returntype: `libxml2.xmlNode`"""
        if self.value in ("public","private","confidental"):
            n=parent.newChild(None,self.name.upper(),None)
            n.newChild(None,self.value.upper(),None)
            return n
        return None

class VCardKey(VCardField):
    """Key vCard field.

    :Ivariables:
        - `type`: key type.
        - `cred`: key data.
    :Types:
        - `type`: `unicode`
        - `cred`: `str` """
    def __init__(self,name,value,rfc2425parameters=None):
        """Initialize a `VCardKey` object.

        :Parameters:
            - `name`: field name
            - `value`: field value as string or an XML node
            - `rfc2425parameters`: optional RFC 2425 parameters
        :Types:
            - `name`: `str`
            - `value`: `str` or `libxml2.xmlNode`
            - `rfc2425parameters`: `dict`"""
        VCardField.__init__(self,name)
        if not rfc2425parameters:
            rfc2425parameters={}
        if isinstance(value,libxml2.xmlNode):
            self.type,self.cred=None,None
            n=value.children
            vns=get_node_ns(value)
            while n:
                if n.type!='element':
                    n=n.next
                    continue
                ns=get_node_ns(n)
                if (ns and vns and ns.getContent()!=vns.getContent()):
                    n=n.next
                    continue
                if n.name=='TYPE':
                    self.type=unicode(n.getContent(),"utf-8","replace")
                if n.name=='CRED':
                    self.cred=base64.decodestring(n.getContent())
                n=n.next
            if not self.cred:
                raise Empty("Bad %s value in vcard" % (name,))
        else:
            self.type=rfc2425parameters.get("type")
            self.cred=value
    def rfc2426(self):
        """RFC2426-encode the field content.

        :return: the field in the RFC 2426 format.
        :returntype: `str`"""
        if self.type:
            p={"type":self.type}
        else:
            p={}
        return rfc2425encode(self.name,self.cred,p)
    def as_xml(self,parent):
        """Create vcard-tmp XML representation of the field.

        :Parameters:
            - `parent`: parent node for the element
        :Types:
            - `parent`: `libxml2.xmlNode`

        :return: xml node with the field data.
        :returntype: `libxml2.xmlNode`"""
        n=parent.newChild(None,self.name.upper(),None)
        if self.type:
            n.newTextChild(None,"TYPE",self.type)
        n.newTextChild(None,"CRED",binascii.b2a_base64(self.cred))
        return n

class VCard(StanzaPayloadObject):
    """Jabber (vcard-temp) or RFC2426 vCard.

    :Ivariables:
        - `fn`: full name.
        - `n`: structural name.
        - `nickname`: nickname(s).
        - `photo`: photo(s).
        - `bday`: birthday date(s).
        - `adr`: address(es).
        - `label`: address label(s).
        - `tel`: phone number(s).
        - `email`: e-mail address(es).
        - `jabberid`: JID(s).
        - `mailer`: mailer(s).
        - `tz`: timezone(s).
        - `geo`: geolocation(s).
        - `title`: title(s).
        - `role`: role(s).
        - `logo`: logo(s).
        - `org`: organization(s).
        - `categories`: categories.
        - `note`: note(s).
        - `prodid`: product id(s).
        - `rev`: revision(s).
        - `sort-string`: sort string(s).
        - `sound`: sound(s).
        - `uid`: user identifier(s).
        - `url`: URL(s).
        - `class`: class(es).
        - `key`: key(s).
        - `desc`: description.
    :Types:
        - `fn`: `VCardString`,
        - `n`: `VCardName`,
        - `nickname`: `list` of `VCardString`
        - `photo`: `list` of `VCardImage`
        - `bday`: `list` of `VCardString`
        - `adr`: `list` of `VCardAdr`
        - `label`: `list` of `VCardLabel`
        - `tel`: `list` of `VCardTel`
        - `email`: `list` of `VCardEmail`
        - `jabberid`: `list` of `VCardJID`
        - `mailer`: `list` of `VCardString`
        - `tz`: `list` of `VCardString`
        - `geo`: `list` of `VCardGeo`
        - `title`: `list` of `VCardString`
        - `role`: `list` of `VCardString`
        - `logo`: `list` of `VCardImage`
        - `org`: `list` of `VCardOrg`
        - `categories`: `list` of `VCardCategories`
        - `note`: `list` of `VCardString`
        - `prodid`: `list` of `VCardString`
        - `rev`: `list` of `VCardString`
        - `sort-string`: `list` of `VCardString`
        - `sound`: `list` of `VCardSound`
        - `uid`: `list` of `VCardString`
        - `url`: `list` of `VCardString`
        - `class`: `list` of `VCardString`
        - `key`: `list` of `VCardKey`
        - `desc`: `list` of `VCardXString`
    """

    xml_element_name = "vCard"
    xml_element_namespace = VCARD_NS

    components={
            #"VERSION": (VCardString,"optional"),
            "FN": (VCardString,"required"),
            "N": (VCardName,"required"),
            "NICKNAME": (VCardString,"multi"),
            "PHOTO": (VCardImage,"multi"),
            "BDAY": (VCardString,"multi"),
            "ADR": (VCardAdr,"multi"),
            "LABEL": (VCardLabel,"multi"),
            "TEL": (VCardTel,"multi"),
            "EMAIL": (VCardEmail,"multi"),
            "JABBERID": (VCardJID,"multi"),
            "MAILER": (VCardString,"multi"),
            "TZ": (VCardString,"multi"),
            "GEO": (VCardGeo,"multi"),
            "TITLE": (VCardString,"multi"),
            "ROLE": (VCardString,"multi"),
            "LOGO": (VCardImage,"multi"),
            "AGENT": ("VCardAgent","ignore"), #FIXME: agent field
            "ORG": (VCardOrg,"multi"),
            "CATEGORIES": (VCardCategories,"multi"),
            "NOTE": (VCardString,"multi"),
            "PRODID": (VCardString,"multi"),
            "REV": (VCardString,"multi"),
            "SORT-STRING": (VCardString,"multi"),
            "SOUND": (VCardSound,"multi"),
            "UID": (VCardString,"multi"),
            "URL": (VCardString,"multi"),
            "CLASS": (VCardString,"multi"),
            "KEY": (VCardKey,"multi"),
            "DESC": (VCardXString,"multi"),
        };
    def __init__(self,data):
        """Initialize a VCard object from data which may be XML node
        or an RFC2426 string.

        :Parameters:
            - `data`: vcard to parse.
        :Types:
            - `data`: `libxml2.xmlNode`, `unicode` or `str`"""

        # to make pylint happy
        self.n = None
        del self.n

        self.content={}
        if isinstance(data,libxml2.xmlNode):
            self.__from_xml(data)
        else:
            self.__from_rfc2426(data)
        if not self.content.get("N") and self.content.get("FN"):
            s=self.content['FN'].value.replace(";",",")
            s=s.split(None,2)
            if len(s)==2:
                s=u"%s;%s;;;" % (s[1],s[0])
            elif len(s)==3:
                s=u"%s;%s;%s" % (s[2],s[0],s[1])
            else:
                s=u"%s;;;;" % (s[0],)
            self.content["N"]=VCardName("N",s)
        elif not self.content.get("FN") and self.content.get("N"):
            self.__make_fn()
        for c, (_unused, tp) in self.components.items():
            if self.content.has_key(c):
                continue
            if tp=="required":
                raise ValueError("%s is missing" % (c,))
            elif tp=="multi":
                self.content[c]=[]
            elif tp=="optional":
                self.content[c]=None
            else:
                continue

    def __make_fn(self):
        """Initialize the mandatory `self.fn` from `self.n`.

        This is a workaround for buggy clients which set only one of them."""
        s=[]
        if self.n.prefix:
            s.append(self.n.prefix)
        if self.n.given:
            s.append(self.n.given)
        if self.n.middle:
            s.append(self.n.middle)
        if self.n.family:
            s.append(self.n.family)
        if self.n.suffix:
            s.append(self.n.suffix)
        s=u" ".join(s)
        self.content["FN"]=VCardString("FN", s, empty_ok = True)

    def __from_xml(self,data):
        """Initialize a VCard object from XML node.

        :Parameters:
            - `data`: vcard to parse.
        :Types:
            - `data`: `libxml2.xmlNode`"""
        ns=get_node_ns(data)
        if ns and ns.getContent()!=VCARD_NS:
            raise ValueError("Not in the %r namespace" % (VCARD_NS,))
        if data.name!="vCard":
            raise ValueError("Bad root element name: %r" % (data.name,))
        n=data.children
        dns=get_node_ns(data)
        while n:
            if n.type!='element':
                n=n.next
                continue
            ns=get_node_ns(n)
            if (ns and dns and ns.getContent()!=dns.getContent()):
                n=n.next
                continue
            if not self.components.has_key(n.name):
                n=n.next
                continue
            cl,tp=self.components[n.name]
            if tp in ("required","optional"):
                if self.content.has_key(n.name):
                    raise ValueError("Duplicate %s" % (n.name,))
                try:
                    self.content[n.name]=cl(n.name,n)
                except Empty:
                    pass
            elif tp=="multi":
                if not self.content.has_key(n.name):
                    self.content[n.name]=[]
                try:
                    self.content[n.name].append(cl(n.name,n))
                except Empty:
                    pass
            n=n.next

    def __from_rfc2426(self,data):
        """Initialize a VCard object from an RFC2426 string.

        :Parameters:
            - `data`: vcard to parse.
        :Types:
            - `data`: `libxml2.xmlNode`, `unicode` or `str`"""
        data=from_utf8(data)
        lines=data.split("\n")
        started=0
        current=None
        for l in lines:
            if not l:
                continue
            if l[-1]=="\r":
                l=l[:-1]
            if not l:
                continue
            if l[0] in " \t":
                if current is None:
                    continue
                current+=l[1:]
                continue
            if not started and current and current.upper().strip()=="BEGIN:VCARD":
                started=1
            elif started and current.upper().strip()=="END:VCARD":
                current=None
                break
            elif current and started:
                self._process_rfc2425_record(current)
            current=l
        if started and current:
            self._process_rfc2425_record(current)

    def _process_rfc2425_record(self,data):
        """Parse single RFC2425 record and update attributes of `self`.

        :Parameters:
            - `data`: the record (probably multiline)
        :Types:
            - `data`: `unicode`"""
        label,value=data.split(":",1)
        value=value.replace("\\n","\n").replace("\\N","\n")
        psplit=label.lower().split(";")
        name=psplit[0]
        params=psplit[1:]
        if u"." in name:
            name=name.split(".",1)[1]
        name=name.upper()
        if name in (u"X-DESC",u"X-JABBERID"):
            name=name[2:]
        if not self.components.has_key(name):
            return
        if params:
            params=dict([p.split("=",1) for p in params])
        cl,tp=self.components[name]
        if tp in ("required","optional"):
            if self.content.has_key(name):
                raise ValueError("Duplicate %s" % (name,))
            try:
                self.content[name]=cl(name,value,params)
            except Empty:
                pass
        elif tp=="multi":
            if not self.content.has_key(name):
                self.content[name]=[]
            try:
                self.content[name].append(cl(name,value,params))
            except Empty:
                pass
        else:
            return
    def __repr__(self):
        return "<vCard of %r>" % (self.content["FN"].value,)
    def rfc2426(self):
        """Get the RFC2426 representation of `self`.

        :return: the UTF-8 encoded RFC2426 representation.
        :returntype: `str`"""
        ret="begin:VCARD\r\n"
        ret+="version:3.0\r\n"
        for _unused, value in self.content.items():
            if value is None:
                continue
            if type(value) is list:
                for v in value:
                    ret+=v.rfc2426()
            else:
                v=value.rfc2426()
                ret+=v
        return ret+"end:VCARD\r\n"

    def complete_xml_element(self, xmlnode, _unused):
        """Complete the XML node with `self` content.

        Should be overriden in classes derived from `StanzaPayloadObject`.

        :Parameters:
            - `xmlnode`: XML node with the element being built. It has already
              right name and namespace, but no attributes or content.
            - `_unused`: document to which the element belongs.
        :Types:
            - `xmlnode`: `libxml2.xmlNode`
            - `_unused`: `libxml2.xmlDoc`"""
        for _unused1, value in self.content.items():
            if value is None:
                continue
            if type(value) is list:
                for v in value:
                    v.as_xml(xmlnode)
            else:
                value.as_xml(xmlnode)

    def __getattr__(self,name):
        try:
            return self.content[name.upper().replace("_","-")]
        except KeyError:
            raise AttributeError("Attribute %r not found" % (name,))
    def __getitem__(self,name):
        return self.content[name.upper()]

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = version
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# pylint: disable-msg=W0201

"""Software Version query and advertisement.

To advertise software version in your client or component add
a `VersionProvider` instance to your payload.

To request a remote entity version information, use the
`request_software_version` function.

Normative reference:
  - `XEP-0092 <http://xmpp.org/extensions/xep-0092.html>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import platform
import logging

from ..etree import ElementTree

from ..version import version as pyxmpp2_version # pylint: disable=E0611
from ..settings import XMPPSettings
from ..iq import Iq
from ..interfaces import XMPPFeatureHandler, feature_uri
from ..interfaces import iq_get_stanza_handler
from ..interfaces import StanzaPayload, payload_element_name

logger = logging.getLogger("pyxmpp2.ext.version")

_QNP = u"{jabber:iq:version}"
QUERY_TAG = _QNP + "query"
NAME_TAG = _QNP + "name"
VERSION_TAG = _QNP + "version"
OS_TAG = _QNP + "os"

@payload_element_name(QUERY_TAG)
class VersionPayload(StanzaPayload):
    """Software version (XEP-0092) stanza payload.

    :Ivariables:
        - `name`: software name
        - `version`: software version
        - `os_name`: operating system name

    :Types:
        - `name`: `unicode`
        - `version`: `unicode`
        - `os_name`: `unicode`
    """
    def __init__(self, name = None, version = None, os_name = None):
        self.name = name
        self.version = version
        self.os_name = os_name

    @classmethod
    def from_xml(cls, element):
        name = None
        version = None
        os_name = None
        for child in element:
            if child.tag == NAME_TAG:
                name = child.text
            elif child.tag == VERSION_TAG:
                version = child.text
            elif child.tag == OS_TAG:
                os_name = child.text
        return cls(name, version, os_name)

    def as_xml(self):
        element = ElementTree.Element(QUERY_TAG)
        if self.name is None and self.version is None and self.os_name is None:
            return element
        sub = ElementTree.SubElement(element, NAME_TAG)
        sub.text = self.name
        sub = ElementTree.SubElement(element, VERSION_TAG)
        sub.text = self.version
        if self.os_name:
            sub = ElementTree.SubElement(element, OS_TAG)
            sub.text = self.os_name
        return element

@feature_uri("jabber:iq:version")
class VersionProvider(XMPPFeatureHandler):
    """Provides the Software version (XEP-0092) service.

    Handles incoming software version queries with values from:

        - :r:`software_name setting`
        - :r:`software_version setting`
        - :r:`software_os setting`
    """
    # pylint: disable=R0903
    def __init__(self, settings = None):
        self.settings = settings if settings else XMPPSettings()

    @iq_get_stanza_handler(VersionPayload)
    def handle_version_iq_get(self, stanza):
        """Handler <iq type="get"/> for a software version query."""
        payload = VersionPayload(name = self.settings["software_name"],
                                 version = self.settings["software_version"],
                                 os_name = self.settings["software_os"]
                                 )
        response = stanza.make_result_response()
        response.set_payload(payload)
        return response

def request_software_version(stanza_processor, target_jid, callback,
                                                    error_callback = None):
    """Request software version information from a remote entity.

    When a valid response is received the `callback` will be handled
    with a `VersionPayload` instance as its only argument. The object will
    provide the requested infromation.

    In case of error stanza received or invalid response the `error_callback`
    (if provided) will be called with the offending stanza (which can
    be ``<iq type='error'/>`` or ``<iq type='result'>``) as its argument.

    The same function will be called on timeout, with the argument set to
    `None`.

    :Parameters:
        - `stanza_processor`: a object used to send the query and handle
          response. E.g. a `pyxmpp2.client.Client` instance
        - `target_jid`: the JID of the entity to query
        - `callback`: function to be called with a valid response
        - `error_callback`: function to be called on error
    :Types:
        - `stanza_processor`: `StanzaProcessor`
        - `target_jid`: `JID`
    """
    stanza = Iq(to_jid = target_jid, stanza_type = "get")
    payload = VersionPayload()
    stanza.set_payload(payload)
    def wrapper(stanza):
        """Wrapper for the user-provided `callback` that extracts the payload
        from stanza received."""
        payload = stanza.get_payload(VersionPayload)
        if payload is None:
            if error_callback:
                error_callback(stanza)
            else:
                logger.warning("Invalid version query response.")
        else:
            callback(payload)
    stanza_processor.set_response_handlers(stanza, wrapper, error_callback)
    stanza_processor.send(stanza)

def _os_name_factory(settings):
    """Factory for the :r:`software_os setting` default.
    """
    # pylint: disable-msg=W0613,W0142
    return u"{0} {1} {2}".format(platform.system(), platform.release(),
                                                        platform.machine())

def _version_factory(settings):
    """Factory for the :r:`software_version setting` default.
    """
    # pylint: disable-msg=W0613
    if "software_name" not in settings:
        # plain version only if the default software_name is used
        return unicode(pyxmpp2_version)
    else:
        return u"@PyXMPP2/{0}".format(pyxmpp2_version)

XMPPSettings.add_setting("software_name", type = unicode, basic = False,
    default = "PyXMPP2",
    cmdline_help = "Software name for XEP-0092 query.",
    doc = """Software name for XEP-0092 query."""
    )
XMPPSettings.add_setting("software_version", type = unicode, basic = False,
    factory = _version_factory,
#    default_d = "PyXMPP2 version",
    cmdline_help = "Software version for XEP-0092 query.",
    doc = """Software version for XEP-0092 query."""
    )

XMPPSettings.add_setting("software_os", type = unicode, basic = False,
    factory = _os_name_factory,
    default_d = "Operating system running this code",
    cmdline_help = "Operating system name for XEP-0092 query.",
    doc = """Operating system name for XEP-0092 query."""
    )


########NEW FILE########
__FILENAME__ = interfaces
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""Base interfaces of PyXMPP2.

:Variables:
    - `NO_CHANGE`: constant used as the default for some function arguments
"""
# pylint: disable-msg=R0201

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import logging

from abc import ABCMeta, abstractmethod

try:
    # pylint: disable=E0611
    from abc import abstractclassmethod
except ImportError:
    # pylint: disable=C0103
    abstractclassmethod = classmethod

from copy import deepcopy

# pylint: disable=W0611
from .mainloop.interfaces import Event, QUIT, EventHandler, event_handler
# pylint: disable=W0611
from .mainloop.interfaces import TimeoutHandler, timeout_handler

class Resolver:
    """Abstract base class for asynchronous DNS resolvers to be used
    with PyxMPP.
    """
    # pylint: disable-msg=W0232
    __metaclass__ = ABCMeta

    @abstractmethod
    def resolve_srv(self, domain, service, protocol, callback):
        """Start looking up an SRV record for `service` at `domain`.

        `callback` will be called with a properly sorted list of (hostname,
        port) pairs on success. The list will be empty on error and it will
        contain only (".", 0) when the service is explicitely disabled.

        :Parameters:
            - `domain`: domain name to look up
            - `service`: service name e.g. 'xmpp-client'
            - `protocol`: protocol name, e.g. 'tcp'
            - `callback`: a function to be called with a list of received
              addresses
        :Types:
            - `domain`: `unicode`
            - `service`: `unicode`
            - `protocol`: `unicode`
            - `callback`: function accepting a single argument
        """
        raise NotImplementedError

    @abstractmethod
    def resolve_address(self, hostname, callback, allow_cname = True):
        """Start looking up an A or AAAA record.

        `callback` will be called with a list of IPv4 or IPv6 address literals
        on success. The list will be empty on error.

        :Parameters:
            - `hostname`: the host name to look up
            - `callback`: a function to be called with a list of received
              addresses
            - `allow_cname`: `True` if CNAMEs should be followed
        :Types:
            - `hostname`: `unicode`
            - `callback`: function accepting a single argument
            - `allow_cname`: `bool`
        """
        raise NotImplementedError

class XMPPTransport:
    """Abstract base class for XMPP transport implementations."""
    # pylint: disable-msg=R0922,W0232
    __metaclass__ = ABCMeta

    @abstractmethod
    def set_target(self, stream):
        """Make the `stream` the target for this transport instance.

        The 'stream_start', 'stream_end' and 'stream_element' methods
        of the target will be called when appropriate content is received.

        :Parameters:
            - `stream`: the stream handler to receive stream content
              from the transport
        :Types:
            - `stream`: `StreamBase`
        """
        pass

    @abstractmethod
    def send_stream_head(self, stanza_namespace, stream_from, stream_to,
                        stream_id = None, version = u'1.0', language = None):
        """
        Send stream head via the transport.

        :Parameters:
            - `stanza_namespace`: namespace of stream stanzas (e.g.
              'jabber:client')
            - `stream_from`: the 'from' attribute of the stream. May be `None`.
            - `stream_to`: the 'to' attribute of the stream. May be `None`.
            - `version`: the 'version' of the stream.
            - `language`: the 'xml:lang' of the stream
        :Types:
            - `stanza_namespace`: `unicode`
            - `stream_from`: `unicode`
            - `stream_to`: `unicode`
            - `version`: `unicode`
            - `language`: `unicode`
        """
        # pylint: disable-msg=R0913
        pass

    @abstractmethod
    def restart(self):
        """Restart the stream after SASL or StartTLS handshake.

        For the initiator a new call to `send_stream_head` is required too."""
        pass

    @abstractmethod
    def send_stream_tail(self):
        """
        Send stream tail via the transport.
        """
        pass

    @abstractmethod
    def send_element(self, element):
        """
        Send an element via the transport.
        """
        pass

    @abstractmethod
    def is_connected(self):
        """
        Check if the transport is connected.

        :Return: `True` if is connected.
        """
        return False

    @abstractmethod
    def disconnect(self):
        """Gracefully disconnect the connection.
        """
        pass

    @property
    def auth_properties(self):
        """Channel properties for authentication and authorization.
        """
        return {}

class StanzaRoute:
    """Base class for objects that can send and receive stanzas."""
    # pylint: disable=W0232
    @abstractmethod
    def send(self, stanza):
        """Send stanza through this route."""
        pass

    @abstractmethod
    def uplink_receive(self, stanza):
        """Handle stanza received from 'uplink'."""
        pass

class XMPPFeatureHandler:
    """Base class for objects handling incoming stanzas.

    The subclasses should provide methods decorated with one of:

      - `iq_get_stanza_handler`: for methods handling ``<iq type="get"/>``
        stanzas.
      - `iq_set_stanza_handler`: for methods handling ``<iq type="set"/>``
        stanzas.
      - `message_stanza_handler`: for methods handling ``<message />`` stanzas
      - `presence_stanza_handler`: for methods handling ``<presence />``
        stanzas

    :Ivariables:
        - `stanza_processor`: a stanza processor where this object was
          registered most recently (injected by `StanzaProcessor`)
    :Types:
        - `stanza_processor`: `StanzaProcessor`
    """
    # pylint: disable-msg=W0232,R0903
    __metaclass__ = ABCMeta
    stanza_processor = None

def feature_uri(uri):
    """Decorating attaching a feature URI (for Service Discovery or Capability
    to a XMPPFeatureHandler class."""
    def decorator(class_):
        """Returns a decorated class"""
        if "_pyxmpp_feature_uris" not in class_.__dict__:
            class_._pyxmpp_feature_uris = set()
        class_._pyxmpp_feature_uris.add(uri)
        return class_
    return decorator

def _iq_handler(iq_type, payload_class, payload_key, usage_restriction):
    """Method decorator generator for decorating <iq type='get'/> stanza
    handler methods in `XMPPFeatureHandler` subclasses.

    :Parameters:
        - `payload_class`: payload class expected
        - `payload_key`: payload class specific filtering key
        - `usage_restriction`: optional usage restriction: "pre-auth" or
          "post-auth"
    :Types:
        - `payload_class`: subclass of `StanzaPayload`
        - `usage_restriction`: `unicode`
    """
    def decorator(func):
        """The decorator"""
        func._pyxmpp_stanza_handled = ("iq", iq_type)
        func._pyxmpp_payload_class_handled = payload_class
        func._pyxmpp_payload_key = payload_key
        func._pyxmpp_usage_restriction = usage_restriction
        return func
    return decorator


def iq_get_stanza_handler(payload_class, payload_key = None,
                                            usage_restriction = "post-auth"):
    """Method decorator generator for decorating <iq type='get'/> stanza
    handler methods in `XMPPFeatureHandler` subclasses.

    :Parameters:
        - `payload_class`: payload class expected
        - `payload_key`: payload class specific filtering key
        - `usage_restriction`: optional usage restriction: "pre-auth" or
          "post-auth"
    :Types:
        - `payload_class`: subclass of `StanzaPayload`
        - `usage_restriction`: `unicode`
    """
    return _iq_handler("get", payload_class, payload_key, usage_restriction)

def iq_set_stanza_handler(payload_class, payload_key = None,
                                            usage_restriction = "post-auth"):
    """Method decorator generator for decorating <iq type='set'/> stanza
    handler methods in `XMPPFeatureHandler` subclasses.

    :Parameters:
        - `payload_class`: payload class expected
        - `payload_key`: payload class specific filtering key
        - `usage_restriction`: optional usage restriction: "pre-auth" or
          "post-auth"
    :Types:
        - `payload_class`: subclass of `StanzaPayload`
        - `usage_restriction`: `unicode`
    """
    return _iq_handler("set", payload_class, payload_key, usage_restriction)

def _stanza_handler(element_name, stanza_type, payload_class, payload_key,
                                                            usage_restriction):
    """Method decorator generator for decorating <message/> or <presence/>
    stanza handler methods in `XMPPFeatureHandler` subclasses.

    :Parameters:
        - `element_name`: "message" or "presence"
        - `stanza_type`: expected value of the 'type' attribute of the stanza
        - `payload_class`: payload class expected
        - `payload_key`: payload class specific filtering key
        - `usage_restriction`: optional usage restriction: "pre-auth" or
          "post-auth"
    :Types:
        - `element_name`: `unicode`
        - `stanza_type`: `unicode`
        - `payload_class`: subclass of `StanzaPayload`
        - `usage_restriction`: `unicode`
    """
    def decorator(func):
        """The decorator"""
        func._pyxmpp_stanza_handled = (element_name, stanza_type)
        func._pyxmpp_payload_class_handled = payload_class
        func._pyxmpp_payload_key = payload_key
        func._pyxmpp_usage_restriction = usage_restriction
        return func
    return decorator

def message_stanza_handler(stanza_type = None, payload_class = None,
                        payload_key = None, usage_restriction = "post-auth"):
    """Method decorator generator for decorating <message/>
    stanza handler methods in `XMPPFeatureHandler` subclasses.

    :Parameters:
        - `payload_class`: payload class expected
        - `stanza_type`: expected value of the 'type' attribute of the stanza.
          `None` means all types except 'error'
        - `payload_key`: payload class specific filtering key
        - `usage_restriction`: optional usage restriction: "pre-auth" or
          "post-auth"
    :Types:
        - `payload_class`: subclass of `StanzaPayload`
        - `stanza_type`: `unicode`
        - `usage_restriction`: `unicode`
    """
    if stanza_type is None:
        stanza_type = "normal"
    return _stanza_handler("message", stanza_type, payload_class, payload_key,
                                                            usage_restriction)

def presence_stanza_handler(stanza_type = None, payload_class = None,
                        payload_key = None, usage_restriction = "post-auth"):
    """Method decorator generator for decorating <presence/>
    stanza handler methods in `XMPPFeatureHandler` subclasses.

    :Parameters:
        - `payload_class`: payload class expected
        - `stanza_type`: expected value of the 'type' attribute of the stanza.
        - `payload_key`: payload class specific filtering key
        - `usage_restriction`: optional usage restriction: "pre-auth" or
          "post-auth"
    :Types:
        - `payload_class`: subclass of `StanzaPayload`
        - `stanza_type`: `unicode`
        - `usage_restriction`: `unicode`
    """
    return _stanza_handler("presence", stanza_type, payload_class, payload_key,
                                                            usage_restriction)

class StanzaPayload:
    """Abstract base class for stanza payload objects.

    Subclasses are used to encapsulate stanza payload data
    and to reference payload type in stanza handlers or when
    requesting particular payload from a stanza.
    """
    # pylint: disable=W0232
    __metaclass__ = ABCMeta

    @abstractclassmethod
    def from_xml(cls, element):
        """Create a `cls` instance from an XML element.

        :Parameters:
            - `element`: the XML element
        :Types:
            - `element`: :etree:`ElementTree.Element`
        """
        # pylint: disable=E0213
        raise NotImplementedError

    @abstractmethod
    def as_xml(self):
        """Return the XML representation of the payload.

        :returntype: :etree:`ElementTree.Element`
        """
        raise NotImplementedError

    def copy(self):
        """Return a deep copy of self."""
        return deepcopy(self)

    @property
    def handler_key(self):
        """Defines a key which may be used when registering handlers
        for stanzas with this payload."""
        # pylint: disable-msg=R0201
        return None

def payload_element_name(element_name):
    """Class decorator generator for decorationg
    `StanzaPayload` subclasses.

    :Parameters:
        - `element_name`: XML element qname handled by the class
    :Types:
        - `element_name`: `unicode`
    """
    def decorator(klass):
        """The payload_element_name decorator."""
        # pylint: disable-msg=W0212,W0404
        from .stanzapayload import STANZA_PAYLOAD_CLASSES
        from .stanzapayload import STANZA_PAYLOAD_ELEMENTS
        if hasattr(klass, "_pyxmpp_payload_element_name"):
            klass._pyxmpp_payload_element_name.append(element_name)
        else:
            klass._pyxmpp_payload_element_name = [element_name]
        if element_name in STANZA_PAYLOAD_CLASSES:
            logger = logging.getLogger('pyxmpp.payload_element_name')
            logger.warning("Overriding payload class for {0!r}".format(
                                                                element_name))
        STANZA_PAYLOAD_CLASSES[element_name] = klass
        STANZA_PAYLOAD_ELEMENTS[klass].append(element_name)
        return klass
    return decorator


class StreamFeatureHandled(object):
    """Object returned by a stream feature handler for recognized and handled
    features.
    """
    # pylint: disable-msg=R0903
    def __init__(self, feature_name, mandatory = False):
        self.feature_name = feature_name
        self.mandatory = mandatory
    def __repr__(self):
        if self.mandatory:
            return "StreamFeatureHandled({0!r}, mandatory = True)".format(
                                                            self.feature_name)
        else:
            return "StreamFeatureHandled({0!r})".format(self.feature_name)
    def __str__(self):
        return self.feature_name

class StreamFeatureNotHandled(object):
    """Object returned by a stream feature handler for recognized,
    but unhandled features.
    """
    # pylint: disable-msg=R0903
    def __init__(self, feature_name, mandatory = False):
        self.feature_name = feature_name
        self.mandatory = mandatory
    def __repr__(self):
        if self.mandatory:
            return "StreamFeatureNotHandled({0!r}, mandatory = True)".format(
                                                            self.feature_name)
        else:
            return "StreamFeatureNotHandled({0!r})".format(self.feature_name)
    def __str__(self):
        return self.feature_name

class StreamFeatureHandler:
    """Base class for stream feature handlers.

    The `handle_stream_features` and `make_stream_features` should
    process and populate the ``<stream::features/>`` element as needed.

    Other methods, decorated with the `stream_element_handler` decorated,
    will be called to handle matching stream element.
    """
    # pylint: disable-msg=W0232
    __metaclass__ = ABCMeta
    def handle_stream_features(self, stream, features):
        """Handle features announced by the stream peer.

        [initiator only]

        :Parameters:
            - `stream`: the stream
            - `features`: the features element just received
        :Types:
            - `stream`: `StreamBase`
            - `features`: :etree:`ElementTree.Element`

        :Return:
            - `StreamFeatureHandled` instance if a feature was recognized and
              handled
            - `StreamFeatureNotHandled` instance if a feature was recognized
              but not handled
            - `None` if no feature was recognized
        """
        # pylint: disable-msg=W0613,R0201
        return False

    def make_stream_features(self, stream, features):
        """Update the features element announced by the stream.

        [receiver only]

        :Parameters:
            - `stream`: the stream
            - `features`: the features element about to be sent
        :Types:
            - `stream`: `StreamBase`
            - `features`: :etree:`ElementTree.Element`
        """
        # pylint: disable-msg=W0613,R0201
        return False

def stream_element_handler(element_name, usage_restriction = None):
    """Method decorator generator for decorating stream element
    handler methods in `StreamFeatureHandler` subclasses.

    :Parameters:
        - `element_name`: stream element QName
        - `usage_restriction`: optional usage restriction: "initiator" or
          "receiver"
    :Types:
        - `element_name`: `unicode`
        - `usage_restriction`: `unicode`
    """
    def decorator(func):
        """The decorator"""
        func._pyxmpp_stream_element_handled = element_name
        func._pyxmpp_usage_restriction = usage_restriction
        return func
    return decorator

class _NO_CHANGE(object):
    """Class for the `NO_CHANGE` constant.
    """
    # pylint: disable=C0103,R0903
    def __str__(self):
        return "NO_CHANGE"
    def __repr__(self):
        return "NO_CHANGE"

NO_CHANGE = _NO_CHANGE()
del _NO_CHANGE

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = iq
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""Iq XMPP stanza handling

Normative reference:
  - `RFC 3920 <http://www.ietf.org/rfc/rfc3920.txt>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"


from .etree import ElementClass

from .stanza import Stanza

IQ_TYPES = ("get", "set", "result", "error")

class Iq(Stanza):
    """<message /> stanza class."""
    # pylint: disable-msg=R0902
    element_name = "message"
    def __init__(self, element = None, from_jid = None, to_jid = None,
                            stanza_type = None, stanza_id = None,
                            error = None, error_cond=None, return_path = None,
                            language = None):
        """Initialize an `Iq` object.

        :Parameters:
            - `element`: XML element of this stanza.
            - `from_jid`: sender JID.
            - `to_jid`: recipient JID.
            - `stanza_type`: staza type: one of: "get", "set", "response"
              or "error".
            - `stanza_id`: stanza id -- value of stanza's "id" attribute. If
              not given, then unique for the session value is generated.
            - `error_cond`: error condition name. Ignored if `stanza_type`
              is not "error".
            - `language`: default language for the stanza content
        :Types:
            - `element`: :etree:`ElementTree.Element`
            - `from_jid`: `JID`
            - `to_jid`: `JID`
            - `stanza_type`: `unicode`
            - `stanza_id`: `unicode`
            - `error`: `pyxmpp.error.StanzaErrorElement`
            - `error_cond`: `unicode`
            - `language`: `unicode`
        """
        # pylint: disable-msg=R0913

        if stanza_type is None:
            if element is None:
                raise ValueError("Missing iq type")
        elif stanza_type not in IQ_TYPES:
            raise ValueError("Bad iq type")

        if element is None and stanza_id is None and stanza_type in (
                                                                "get", "set"):
            stanza_id = self.gen_id()

        if element is None:
            element = "iq"
        elif not isinstance(element, ElementClass):
            raise TypeError("Couldn't make Iq from " + repr(element))

        Stanza.__init__(self, element, from_jid = from_jid, to_jid = to_jid,
                        stanza_type = stanza_type, stanza_id = stanza_id,
                        error = error, error_cond = error_cond,
                        return_path = return_path, language = language)


        if self.element_name != "iq":
            raise ValueError("The element is not <iq/>")

    def copy(self):
        """Create a deep copy of the stanza.

        :returntype: `Iq`"""
        result = Iq(None, self.from_jid, self.to_jid,
                        self.stanza_type, self.stanza_id, self.error,
                        self._return_path())
        if self._payload is None:
            self.decode_payload()
        for payload in self._payload:
            # use Stanza.add_payload to skip the payload length check
            Stanza.add_payload(result, payload)
        return result

    def make_error_response(self, cond):
        """Create error response for the a "get" or "set" iq stanza.

        :Parameters:
            - `cond`: error condition name, as defined in XMPP specification.

        :return: new `Iq` object with the same "id" as self, "from" and "to"
            attributes swapped, type="error" and containing <error /> element
            plus payload of `self`.
        :returntype: `Iq`"""

        if self.stanza_type in ("result", "error"):
            raise ValueError("Errors may not be generated for"
                                                " 'result' and 'error' iq")

        stanza = Iq(stanza_type="error", from_jid = self.to_jid,
                        to_jid = self.from_jid, stanza_id = self.stanza_id,
                        error_cond = cond)
        if self._payload is None:
            self.decode_payload()
        for payload in self._payload:
            # use Stanza.add_payload to skip the payload length check
            Stanza.add_payload(stanza, payload)
        return stanza

    def make_result_response(self):
        """Create result response for the a "get" or "set" iq stanza.

        :return: new `Iq` object with the same "id" as self, "from" and "to"
            attributes replaced and type="result".
        :returntype: `Iq`"""

        if self.stanza_type not in ("set", "get"):
            raise ValueError("Results may only be generated for"
                                                        " 'set' or 'get' iq")
        stanza = Iq(stanza_type = "result", from_jid = self.to_jid,
                        to_jid = self.from_jid, stanza_id = self.stanza_id)
        return stanza

    def add_payload(self, payload):
        """Add new the stanza payload. Fails if there is already some
        payload element attached (<iq/> stanza can contain only one payload
        element)

        Marks the stanza dirty.

        :Parameters:
            - `payload`: XML element or stanza payload object to add
        :Types:
            - `payload`: :etree:`ElementTree.Element` or
              `interfaces.StanzaPayload`
        """
        if self._payload is None:
            self.decode_payload()
        if len(self._payload) >= 1:
            raise ValueError("Cannot add more payload to Iq stanza")
        return Stanza.add_payload(self, payload)

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = jid
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""jid -- XMPP address handling

Normative reference:
  - `RFC 6122 <http://xmpp.org/rfcs/rfc6122.html>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import re
import weakref
import warnings
import socket
import logging

from encodings import idna

from .xmppstringprep import NODEPREP, RESOURCEPREP
from .exceptions import JIDError, StringprepError

logger = logging.getLogger("pyxmpp2.jid")

# to enforce the UseSTD3ASCIIRules flag of IDNA
GOOD_OUTER = u"[^\x00-\x2C\x2E-\x2F\x3A-\x40\x5B-\x60\x7B-\x7F-]"
GOOD_INNER = u"[^\x00-\x2C\x2E-\x2F\x3A-\x40\x5B-\x60\x7B-\x7F]"
STD3_LABEL_RE = re.compile(u"^{0}({1}*{0})?$".format(GOOD_OUTER, GOOD_INNER))

# '.' equivalents, according to IDNA
UNICODE_DOT_RE = re.compile(u"[\u3002\uFF0E\uFF61]")

def are_domains_equal(domain1, domain2):
    """Compare two International Domain Names.

    :Parameters:
        - `domain1`: domains name to compare
        - `domain2`: domains name to compare
    :Types:
        - `domain1`: `unicode`
        - `domain2`: `unicode`

    :return: True `domain1` and `domain2` are equal as domain names."""

    domain1 = domain1.encode("idna")
    domain2 = domain2.encode("idna")
    return domain1.lower() == domain2.lower()

def _validate_ip_address(family, address):
    """Check if `address` is valid IP address and return it, in a normalized
    form.

    :Parameters:
        - `family`: ``socket.AF_INET`` or ``socket.AF_INET6``
        - `address`: the IP address to validate
    """
    try:
        info = socket.getaddrinfo(address, 0, family, socket.SOCK_STREAM, 0,
                                                        socket.AI_NUMERICHOST)
    except socket.gaierror, err:
        logger.debug("gaierror: {0} for {1!r}".format(err, address))
        raise ValueError("Bad IP address")

    if not info:
        logger.debug("getaddrinfo result empty")
        raise ValueError("Bad IP address")
    addr = info[0][4]
    logger.debug(" got address: {0!r}".format(addr))

    try:
        return socket.getnameinfo(addr, socket.NI_NUMERICHOST)[0]
    except socket.gaierror, err:
        logger.debug("gaierror: {0} for {1!r}".format(err, addr))
        raise ValueError("Bad IP address")

class JID(object):
    """JID.

    :Ivariables:
        - `local`: localpart of the JID
        - `domain`: domainpart of the JID
        - `resource`: resourcepart of the JID

    JID objects are immutable. They are also cached for better performance.
    """
    cache = weakref.WeakValueDictionary()
    __slots__ = ("local", "domain", "resource", "__weakref__",)
    def __new__(cls, local_or_jid = None, domain = None, resource = None,
                                                                check = True):
        """Create a new JID object or take one from the cache.

        :Parameters:
            - `local_or_jid`: localpart of the JID, JID object to copy, or
              Unicode representation of the JID.
            - `domain`: domain part of the JID
            - `resource`: resource part of the JID
            - `check`: if `False` then JID is not checked for specifiaction
              compliance.
        """

        if isinstance(local_or_jid, JID):
            return local_or_jid

        if domain is None and resource is None:
            obj = cls.cache.get(unicode(local_or_jid))
            if obj:
                return obj

        obj = object.__new__(cls)

        if local_or_jid:
            local_or_jid = unicode(local_or_jid)
        if (local_or_jid and not domain and not resource):
            local, domain, resource = cls.__from_unicode(local_or_jid)
            cls.cache[local_or_jid] = obj
        else:
            if domain is None and resource is None:
                raise JIDError("At least domain must be given")
            if check:
                local = cls.__prepare_local(local_or_jid)
                domain = cls.__prepare_domain(domain)
                resource = cls.__prepare_resource(resource)
            else:
                local = local_or_jid
        object.__setattr__(obj, "local", local)
        object.__setattr__(obj, "domain", domain)
        object.__setattr__(obj, "resource", resource)
        return obj

    def __setattr__(self, name, value):
        raise RuntimeError("JID objects are immutable!")

    def __attribute_declarations__(self):
        # to make pylint happy
        self.local = u""
        self.domain = u""
        self.resource = u""

    @classmethod
    def __from_unicode(cls, data, check = True):
        """Return jid tuple from an Unicode string.

        :Parameters:
            - `data`: the JID string
            - `check`: when `False` then the JID is not checked for
              specification compliance.

        :Return: (localpart, domainpart, resourcepart) tuple"""
        parts1 = data.split(u"/", 1)
        parts2 = parts1[0].split(u"@", 1)
        if len(parts2) == 2:
            local = parts2[0]
            domain = parts2[1]
            if check:
                local = cls.__prepare_local(local)
                domain = cls.__prepare_domain(domain)
        else:
            local = None
            domain = parts2[0]
            if check:
                domain = cls.__prepare_domain(domain)
        if len(parts1) == 2:
            resource = parts1[1]
            if check:
                resource = cls.__prepare_resource(parts1[1])
        else:
            resource = None
        if not domain:
            raise JIDError("Domain is required in JID.")
        return (local, domain, resource)

    @staticmethod
    def __prepare_local(data):
        """Prepare localpart of the JID

        :Parameters:
            - `data`: localpart of the JID
        :Types:
            - `data`: `unicode`

        :raise JIDError: if the local name is too long.
        :raise pyxmpp.xmppstringprep.StringprepError: if the
            local name fails Nodeprep preparation."""
        if not data:
            return None
        data = unicode(data)
        try:
            local = NODEPREP.prepare(data)
        except StringprepError, err:
            raise JIDError(u"Local part invalid: {0}".format(err))
        if len(local.encode("utf-8")) > 1023:
            raise JIDError(u"Local part too long")
        return local

    @staticmethod
    def __prepare_domain(data):
        """Prepare domainpart of the JID.

        :Parameters:
            - `data`: Domain part of the JID
        :Types:
            - `data`: `unicode`

        :raise JIDError: if the domain name is too long.
        """
        # pylint: disable=R0912
        if not data:
            raise JIDError("Domain must be given")
        data = unicode(data)
        if not data:
            raise JIDError("Domain must be given")
        if u'[' in data:
            if data[0] == u'[' and data[-1] == u']':
                try:
                    addr = _validate_ip_address(socket.AF_INET6, data[1:-1])
                    return "[{0}]".format(addr)
                except ValueError, err:
                    logger.debug("ValueError: {0}".format(err))
                    raise JIDError(u"Invalid IPv6 literal in JID domainpart")
            else:
                raise JIDError(u"Invalid use of '[' or ']' in JID domainpart")
        elif data[0].isdigit() and data[-1].isdigit():
            try:
                addr = _validate_ip_address(socket.AF_INET, data)
            except ValueError, err:
                logger.debug("ValueError: {0}".format(err))
        data = UNICODE_DOT_RE.sub(u".", data)
        data = data.rstrip(u".")
        labels = data.split(u".")
        try:
            labels = [idna.nameprep(label) for label in labels]
        except UnicodeError:
            raise JIDError(u"Domain name invalid")
        for label in labels:
            if not STD3_LABEL_RE.match(label):
                raise JIDError(u"Domain name invalid")
            try:
                idna.ToASCII(label)
            except UnicodeError:
                raise JIDError(u"Domain name invalid")
        domain = u".".join(labels)
        if len(domain.encode("utf-8")) > 1023:
            raise JIDError(u"Domain name too long")
        return domain

    @staticmethod
    def __prepare_resource(data):
        """Prepare the resourcepart of the JID.

        :Parameters:
            - `data`: Resourcepart of the JID

        :raise JIDError: if the resource name is too long.
        :raise pyxmpp.xmppstringprep.StringprepError: if the
            resourcepart fails Resourceprep preparation."""
        if not data:
            return None
        data = unicode(data)
        try:
            resource = RESOURCEPREP.prepare(data)
        except StringprepError, err:
            raise JIDError(u"Local part invalid: {0}".format(err))
        if len(resource.encode("utf-8")) > 1023:
            raise JIDError("Resource name too long")
        return resource

    def __unicode__(self):
        return self.as_unicode()

    def __repr__(self):
        return "JID(%r)" % (self.as_unicode())

    def as_utf8(self):
        """UTF-8 encoded JID representation.

        :return: UTF-8 encoded JID."""
        return self.as_unicode().encode("utf-8")

    def as_string(self):
        """UTF-8 encoded JID representation.

        *Deprecated* Always use Unicode objects, or `as_utf8` if you really want.

        :return: UTF-8 encoded JID."""
        warnings.warn("JID.as_string() is deprecated. Use unicode()"
                " or `as_utf8` instead.", DeprecationWarning, stacklevel=1)
        return self.as_utf8()

    def as_unicode(self):
        """Unicode string JID representation.

        :return: JID as Unicode string."""
        result = self.domain
        if self.local:
            result = self.local + u'@' + result
        if self.resource:
            result = result + u'/' + self.resource
        if not JID.cache.has_key(result):
            JID.cache[result] = self
        return result

    def bare(self):
        """Make bare JID made by removing resource from current `self`.

        :return: new JID object without resource part."""
        return JID(self.local, self.domain, check = False)

    def __eq__(self, other):
        if other is None:
            return False
        elif type(other) in (str, unicode):
            try:
                other = JID(other)
            except StandardError:
                return False
        elif not isinstance(other, JID):
            return False

        return (self.local == other.local
            and are_domains_equal(self.domain, other.domain)
            and self.resource == other.resource)

    def __ne__(self, other):
        return not self == other

    def __lt__(self, other):
        if other is None:
            return False
        return unicode(self) < unicode(other)

    def __gt__(self, other):
        if other is None:
            return True
        return unicode(self) > unicode(other)

    def __le__(self, other):
        if other is None:
            return False
        return unicode(self) <= unicode(other)

    def __ge__(self, other):
        if other is None:
            return True
        return unicode(self) >= unicode(other)

    def __hash__(self):
        return hash(self.local) ^ hash(self.domain) ^ hash(self.resource)

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = base
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""Main loop implementation Base.
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import time
import logging
import inspect

from .events import EventDispatcher
from .interfaces import EventHandler, IOHandler, TimeoutHandler, MainLoop, QUIT
from ..settings import XMPPSettings

logger = logging.getLogger("pyxmpp2.mainloop.base")

class MainLoopBase(MainLoop):
    """Base class for main loop implementations."""
    # pylint: disable-msg=W0223
    def __init__(self, settings = None, handlers = None):
        self.settings = settings if settings else XMPPSettings()
        if not handlers:
            handlers = []
        self._timeout_handlers = []
        self.event_dispatcher = EventDispatcher(self.settings, handlers)
        self.event_queue = self.settings["event_queue"]
        self._quit = False
        self._started = False
        for handler in handlers:
            self.add_handler(handler)

    def add_handler(self, handler):
        if isinstance(handler, IOHandler):
            self._add_io_handler(handler)
        if isinstance(handler, TimeoutHandler):
            self._add_timeout_handler(handler)
        if isinstance(handler, EventHandler):
            self.event_dispatcher.add_handler(handler)

    def remove_handler(self, handler):
        if isinstance(handler, IOHandler):
            self._remove_io_handler(handler)
        if isinstance(handler, TimeoutHandler):
            self._remove_timeout_handler(handler)
        if isinstance(handler, EventHandler):
            self.event_dispatcher.remove_handler(handler)

    def _add_io_handler(self, handler):
        """Add an `IOHandler` to the loop."""
        raise NotImplementedError

    def _remove_io_handler(self, handler):
        """Remove an `IOHandler` from the loop."""
        raise NotImplementedError

    @property
    def finished(self):
        return self._quit
    @property
    def started(self):
        return self._started
    def quit(self):
        self.event_queue.put(QUIT)
    def loop(self, timeout = None):
        interval = self.settings["poll_interval"]
        if timeout is None:
            while not self._quit:
                self.loop_iteration(interval)
        else:
            timeout = time.time() + timeout
            while not self._quit and time.time() < timeout:
                self.loop_iteration(interval)
    def loop_iteration(self, timeout = 1):
        if self.check_events():
            return
        time.sleep(timeout)
    def check_events(self):
        """Call the event dispatcher.

        Quit the main loop when the `QUIT` event is reached.

        :Return: `True` if `QUIT` was reached.
        """
        if self.event_dispatcher.flush() is QUIT:
            self._quit = True
            return True
        return False

    def _add_timeout_handler(self, handler):
        """Add a `TimeoutHandler` to the main loop."""
        # pylint: disable-msg=W0212
        now = time.time()
        for dummy, method in inspect.getmembers(handler, callable):
            if not hasattr(method, "_pyxmpp_timeout"):
                continue
            self._timeout_handlers.append((now + method._pyxmpp_timeout,
                                                                    method))
        self._timeout_handlers.sort(key = lambda x: x[0])

    def _remove_timeout_handler(self, handler):
        """Remove `TimeoutHandler` from the main loop."""
        self._timeout_handlers = [(t, h) for (t, h)
                                            in self._timeout_handlers
                                            if h.im_self != handler]

    def _call_timeout_handlers(self):
        """Call the timeout handlers due.

        :Return: (next_event_timeout, sources_handled) tuple.
            next_event_timeout is number of seconds until the next timeout
            event, sources_handled is number of handlers called.
        """
        sources_handled = 0
        now = time.time()
        schedule = None
        while self._timeout_handlers:
            schedule, handler = self._timeout_handlers[0]
            if schedule <= now:
                # pylint: disable-msg=W0212
                logger.debug("About to call a timeout handler: {0!r}"
                                                        .format(handler))
                self._timeout_handlers = self._timeout_handlers[1:]
                result = handler()
                logger.debug(" handler result: {0!r}".format(result))
                rec = handler._pyxmpp_recurring
                if rec:
                    logger.debug(" recurring, restarting in {0} s"
                                        .format(handler._pyxmpp_timeout))
                    self._timeout_handlers.append(
                                    (now + handler._pyxmpp_timeout, handler))
                    self._timeout_handlers.sort(key = lambda x: x[0])
                elif rec is None and result is not None:
                    logger.debug(" auto-recurring, restarting in {0} s"
                                                            .format(result))
                    self._timeout_handlers.append((now + result, handler))
                    self._timeout_handlers.sort(key = lambda x: x[0])
                sources_handled += 1
            else:
                break
            if self.check_events():
                return 0, sources_handled
        if self._timeout_handlers and schedule:
            timeout = schedule - now
        else:
            timeout = None
        return timeout, sources_handled


########NEW FILE########
__FILENAME__ = events
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# pylint: disable-msg=W0201

"""PyXMPP events."""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import Queue
import threading
import logging
import inspect

from collections import defaultdict

logger = logging.getLogger("pyxmpp2.mainloop.events")

from .interfaces import EventHandler, Event, QUIT
from ..settings import XMPPSettings

class EventDispatcher(object):
    """Dispatches events from an event queue to event handlers.

    Events are `interfaces.Event` instances stored in the event queue
    (defined by the "event_queue" setting). Event handlers are `EventHandler`
    subclass instance methods decorated with the `interfaces.event_handler`
    decorator.

    :Ivariables:
        - `queue`: the event queue
        - `handlers`: list of handler objects
        - `lock`: the thread synchronisation lock
        - `_handler_map`: mapping of event type to list of handler methods
    :Types:
        - `queue`: :std:`Queue.Queue`
        - `handlers`: `list` of `EventHandler`
        - `lock`: :std:`threading.RLock`
        - `_handler_map`: `type` -> `list` of callable mapping
    """
    def __init__(self, settings = None, handlers = None):
        """Initialize the event dispatcher.

        :Parameters:
            - `settings`: the settings. "event_queue" settings provides the
              event queue object.
            - `handlers`: the initial list of event handler objects.
        :Types:
            - `settings`: `XMPPSettings`
            - `handlers`: iterable of objects
        """
        if settings is None:
            settings = XMPPSettings()
        self.queue = settings["event_queue"]
        self._handler_map = defaultdict(list)
        if handlers:
            self.handlers = list(handlers)
        else:
            self.handlers = []
        self._update_handlers()
        self.lock = threading.RLock()

    def add_handler(self, handler):
        """Add a handler object.

        :Parameters:
            - `handler`: the object providing event handler methods
        :Types:
            - `handler`: `EventHandler`
        """
        if not isinstance(handler, EventHandler):
            raise TypeError, "Not an EventHandler"
        with self.lock:
            if handler in self.handlers:
                return
            self.handlers.append(handler)
            self._update_handlers()

    def remove_handler(self, handler):
        """Remove a handler object.

        :Parameters:
            - `handler`: the object to remove
        """
        with self.lock:
            if handler in self.handlers:
                self.handlers.remove(handler)
                self._update_handlers()

    def _update_handlers(self):
        """Update `_handler_map` after `handlers` have been
        modified."""
        handler_map = defaultdict(list)
        for i, obj in enumerate(self.handlers):
            for dummy, handler in inspect.getmembers(obj, callable):
                if not hasattr(handler, "_pyxmpp_event_handled"):
                    continue
                # pylint: disable-msg=W0212
                event_class = handler._pyxmpp_event_handled
                handler_map[event_class].append( (i, handler) )
        self._handler_map = handler_map

    def dispatch(self, block = False, timeout = None):
        """Get the next event from the queue and pass it to
        the appropriate handlers.

        :Parameters:
            - `block`: wait for event if the queue is empty
            - `timeout`: maximum time, in seconds, to wait if `block` is `True`
        :Types:
            - `block`: `bool`
            - `timeout`: `float`

        :Return: the event handled (may be `QUIT`) or `None`
        """
        logger.debug(" dispatching...")
        try:
            event = self.queue.get(block, timeout)
        except Queue.Empty:
            logger.debug("    queue empty")
            return None
        try:
            logger.debug("    event: {0!r}".format(event))
            if event is QUIT:
                return QUIT
            handlers = list(self._handler_map[None])
            klass = event.__class__
            if klass in self._handler_map:
                handlers += self._handler_map[klass]
            logger.debug("    handlers: {0!r}".format(handlers))
            # to restore the original order of handler objects
            handlers.sort(key = lambda x: x[0])
            for dummy, handler in handlers:
                logger.debug(u"  passing the event to: {0!r}".format(handler))
                result = handler(event)
                if isinstance(result, Event):
                    self.queue.put(result)
                elif result and event is not QUIT:
                    return event
            return event
        finally:
            self.queue.task_done()

    def flush(self, dispatch = True):
        """Read all events currently in the queue and dispatch them to the
        handlers unless `dispatch` is `False`.

        Note: If the queue contains `QUIT` the events after it won't be
        removed.

        :Parameters:
            - `dispatch`: if the events should be handled (`True`) or ignored
              (`False`)

        :Return: `QUIT` if the `QUIT` event was reached.
        """
        if dispatch:
            while True:
                event = self.dispatch(False)
                if event in (None, QUIT):
                    return event
        else:
            while True:
                try:
                    self.queue.get(False)
                except Queue.Empty:
                    return None

    def loop(self):
        """Wait for and dispatch events until `QUIT` is reached.
        """
        while self.dispatch(True) is not QUIT:
            pass

def _event_queue_factory(settings):
    """Create the default event queue object.

    Use the :r:`event_queue_max_size setting` for the maximum queue size.
    """
    return Queue.Queue(settings["event_queue_max_size"])

XMPPSettings.add_setting(u"event_queue", type = Queue.Queue,
        factory = _event_queue_factory, cache = True,
        default_d = "A :std:`Queue.Queue` instance",
        doc = u"""Queue used to post events by various components and to
dispatch them from the main loop."""
    )
XMPPSettings.add_setting(u"event_queue_max_size", type = int,
        default = 0,
        doc = u"""Maximum size of the default event loop. Posting events
will block when the queue is full. This will cause lock-up of a single-thread,
but may be useful in multi-threaded applications."""
    )


########NEW FILE########
__FILENAME__ = glib
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""GLib main loop integration.
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import inspect
import sys
import logging
import glib
import functools

from .interfaces import HandlerReady, PrepareAgain
from .base import MainLoopBase

logger = logging.getLogger("pyxmpp2.mainloop.glib")

def hold_exception(method):
    """Decorator for glib callback methods of GLibMainLoop used to store the
    exception raised."""
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        """Wrapper for methods decorated with `hold_exception`."""
        # pylint: disable=W0703,W0212
        try:
            return method(self, *args, **kwargs)
        except Exception:
            if self.exc_info:
                raise
            if not self._stack:
                logger.debug('@hold_exception wrapped method {0!r} called'
                            ' from outside of the main loop'.format(method))
                raise
            self.exc_info = sys.exc_info()
            logger.debug(u"exception in glib main loop callback:",
                                                exc_info = self.exc_info)
            # pylint: disable=W0212
            main_loop = self._stack[-1]
            if main_loop is not None:
                main_loop.quit()
            return False
    return wrapper

class GLibMainLoop(MainLoopBase):
    """Wrapper for the GLib main event loop.
    """
    # pylint: disable=R0902
    def __init__(self, settings = None, handlers = None):
        self._unprepared_handlers = {}
        self._io_sources = {}
        self._timer_sources = {}
        self._prepare_sources = {}
        self._stack = []
        self.exc_info = None
        self._anything_done = False
        self._unprepared_pending = set()
        MainLoopBase.__init__(self, settings, handlers)

    def __del__(self):
        for tag in self._prepare_sources.values():
            glib.source_remove(tag)
        for tag in self._io_sources.values():
            glib.source_remove(tag)
        for tag in self._timer_sources.values():
            glib.source_remove(tag)

    def _add_io_handler(self, handler):
        """Add an I/O handler to the loop."""
        self._unprepared_handlers[handler] = None
        self._configure_io_handler(handler)

    def _configure_io_handler(self, handler):
        """Register an io-handler with the glib main loop."""
        if self.check_events():
            return
        if handler in self._unprepared_handlers:
            old_fileno = self._unprepared_handlers[handler]
            prepared = self._prepare_io_handler(handler)
        else:
            old_fileno = None
            prepared = True
        fileno = handler.fileno()
        if old_fileno is not None and fileno != old_fileno:
            tag = self._io_sources.pop(handler, None)
            if tag is not None:
                glib.source_remove(tag)
        if not prepared:
            self._unprepared_handlers[handler] = fileno
        if fileno is None:
            logger.debug(" {0!r}.fileno() is None, not polling"
                                                    .format(handler))
            return
        events = 0
        if handler.is_readable():
            logger.debug(" {0!r} readable".format(handler))
            events |= glib.IO_IN | glib.IO_ERR
        if handler.is_writable():
            logger.debug(" {0!r} writable".format(handler))
            events |= glib.IO_OUT | glib.IO_HUP | glib.IO_ERR
        if events:
            logger.debug(" registering {0!r} handler fileno {1} for"
                            " events {2}".format(handler, fileno, events))
            glib.io_add_watch(fileno, events, self._io_callback, handler)

    @hold_exception
    def _io_callback(self, fileno, condition, handler):
        """Called by glib on I/O event."""
        # pylint: disable=W0613
        self._anything_done = True
        logger.debug("_io_callback called for {0!r}, cond: {1}".format(handler,
                                                                    condition))
        try:
            if condition & glib.IO_HUP:
                handler.handle_hup()
            if condition & glib.IO_IN:
                handler.handle_read()
            elif condition & glib.IO_ERR:
                handler.handle_err()
            if condition & glib.IO_OUT:
                handler.handle_write()
            if self.check_events():
                return False
        finally:
            self._io_sources.pop(handler, None)
            self._configure_io_handler(handler)
            self._prepare_pending()
        return False

    def _prepare_io_handler(self, handler):
        """Call the `interfaces.IOHandler.prepare` method and
        remove the handler from unprepared handler list when done.
        """
        logger.debug(" preparing handler: {0!r}".format(handler))
        self._unprepared_pending.discard(handler)
        ret = handler.prepare()
        logger.debug("   prepare result: {0!r}".format(ret))
        if isinstance(ret, HandlerReady):
            del self._unprepared_handlers[handler]
            prepared = True
        elif isinstance(ret, PrepareAgain):
            if ret.timeout == 0:
                tag = glib.idle_add(self._prepare_io_handler_cb, handler)
                self._prepare_sources[handler] = tag
            elif ret.timeout is not None:
                timeout = ret.timeout
                timeout = int(timeout * 1000)
                if not timeout:
                    timeout = 1
                tag = glib.timeout_add(timeout, self._prepare_io_handler_cb,
                                                                    handler)
                self._prepare_sources[handler] = tag
            else:
                self._unprepared_pending.add(handler)
            prepared = False
        else:
            raise TypeError("Unexpected result type from prepare()")
        return prepared

    def _prepare_pending(self):
        """Prepare pending handlers.
        """
        if not self._unprepared_pending:
            return
        for handler in list(self._unprepared_pending):
            self._configure_io_handler(handler)
        self.check_events()

    @hold_exception
    def _prepare_io_handler_cb(self, handler):
        """Timeout callback called to try prepare an IOHandler again."""
        self._anything_done = True
        logger.debug("_prepar_io_handler_cb called for {0!r}".format(handler))
        self._configure_io_handler(handler)
        self._prepare_sources.pop(handler, None)
        return False

    def _remove_io_handler(self, handler):
        """Remove an i/o-handler."""
        if handler in self._unprepared_handlers:
            del self._unprepared_handlers[handler]
        tag = self._prepare_sources.pop(handler, None)
        if tag is not None:
            glib.source_remove(tag)
        tag = self._io_sources.pop(handler, None)
        if tag is not None:
            glib.source_remove(tag)

    def _add_timeout_handler(self, handler):
        """Add a `TimeoutHandler` to the main loop."""
        # pylint: disable=W0212
        for dummy, method in inspect.getmembers(handler, callable):
            if not hasattr(method, "_pyxmpp_timeout"):
                continue
            tag = glib.timeout_add(int(method._pyxmpp_timeout * 1000),
                                                self._timeout_cb, method)
            self._timer_sources[method] = tag

    def _remove_timeout_handler(self, handler):
        """Remove `TimeoutHandler` from the main loop."""
        for dummy, method in inspect.getmembers(handler, callable):
            if not hasattr(method, "_pyxmpp_timeout"):
                continue
            tag = self._timer_sources.pop(method, None)
            if tag is not None:
                glib.source_remove(tag)

    @hold_exception
    def _timeout_cb(self, method):
        """Call the timeout handler due.
        """
        self._anything_done = True
        logger.debug("_timeout_cb() called for: {0!r}".format(method))
        result = method()
        # pylint: disable=W0212
        rec = method._pyxmpp_recurring
        if rec:
            self._prepare_pending()
            return True

        if rec is None and result is not None:
            logger.debug(" auto-recurring, restarting in {0} s"
                                                            .format(result))
            tag = glib.timeout_add(int(result * 1000), self._timeout_cb, method)
            self._timer_sources[method] = tag
        else:
            self._timer_sources.pop(method, None)
        self._prepare_pending()
        return False

    def loop(self, timeout = None):
        main_loop = glib.MainLoop()
        self._stack.append(main_loop)
        try:
            self._prepare_pending()
            if timeout is None:
                logger.debug("Calling main_loop.run()")
                main_loop.run()
                logger.debug("..main_loop.run() exited")
            else:
                tag = glib.timeout_add(int(timeout * 1000),
                                            self._loop_timeout_cb, main_loop)
                try:
                    logger.debug("Calling main_loop.run()")
                    main_loop.run()
                    logger.debug("..main_loop.run() exited")
                finally:
                    glib.source_remove(tag)
        finally:
            self._stack.pop()
        if self.exc_info:
            (exc_type, exc_value, ext_stack), self.exc_info = (self.exc_info,
                                                                        None)
            raise exc_type, exc_value, ext_stack

    def loop_iteration(self, timeout = 1):
        self._stack.append(None)
        try:
            if self.check_events():
                return
            self._prepare_pending()
            def dummy_cb():
                "Dummy callback function to force event if none are pending."
                self._anything_done = True
                logger.debug("Dummy timeout func called")
                return True
            self._anything_done = False
            tag = None
            logger.debug("Calling main_context_default().iteration()")
            while not self._anything_done:
                if not glib.main_context_default().pending() and not tag:
                    tag = glib.timeout_add(int(timeout * 1000), dummy_cb)
                glib.main_context_default().iteration(True)
            if tag:
                glib.source_remove(tag)
            logger.debug("..main_context_default().iteration() exited")
        finally:
            self._stack.pop()
        if self.exc_info:
            (exc_type, exc_value, ext_stack), self.exc_info = (self.exc_info,
                                                                        None)
            raise exc_type, exc_value, ext_stack

    def _loop_timeout_cb(self, main_loop):
        """Stops the loop after the time specified in the `loop` call.
        """
        self._anything_done = True
        logger.debug("_loop_timeout_cb() called")
        main_loop.quit()

    def check_events(self):
        result = MainLoopBase.check_events(self)
        if result:
            main_loop = self._stack[-1]
            if main_loop:
                main_loop.quit()
        return result


########NEW FILE########
__FILENAME__ = interfaces
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""Abstract base classes for the main loop framework.

:Variables:
    - `QUIT`: event (instance of a QuitEvent class) used to terminate
      the main event loop.
"""
# pylint: disable=R0201

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

from abc import ABCMeta, abstractmethod, abstractproperty

class IOHandlerPrepareResult(object):
    """Result of the `IOHandler.prepare` method."""
    # pylint: disable-msg=R0903,R0921,R0922
    pass

class HandlerReady(IOHandlerPrepareResult):
    """Returned by the `IOHandler.prepare` method
    when the object is ready to handle I/O events and doesn't need further
    calls to the `IOHandler.prepare` method.
    """
    # pylint: disable-msg=R0903
    def __repr__(self):
        return "HandlerReady()"

class PrepareAgain(IOHandlerPrepareResult):
    """Returned by the `IOHandler.prepare` method
    when the method needs to be called again.

    :Ivariables:
      - `timeout`: how long may the main loop wait before calling
        `IOHandler.prepare` again. `None` means wait until the next loop
        iteration whenever it happens, `0` - do not wait on I/O in this
        iteration.
    """
    # pylint: disable-msg=R0903
    def __init__(self, timeout = None):
        IOHandlerPrepareResult.__init__(self)
        self.timeout = timeout
    def __repr__(self):
        if self.timeout is not None:
            return "PrepareAgain({0!r})".format(self.timeout)
        else:
            return "PrepareAgain()"

class IOHandler:
    """Wrapper for a socket or a file descriptor to be used in event loop
    or for I/O threads."""
    # pylint: disable-msg=W0232,R0921
    __metaclass__ = ABCMeta

    @abstractmethod
    def fileno(self):
        """Return file descriptor to poll or select."""
        return None

    @abstractmethod
    def is_readable(self):
        """
        :Return: `True` when the I/O channel can be read
        """
        return False

    @abstractmethod
    def wait_for_readability(self):
        """
        Stop current thread until the channel is readable.

        :Return: `False` if it won't be readable (e.g. is closed)
        """
        return False

    @abstractmethod
    def is_writable(self):
        """
        :Return: `True` when the I/O channel can be written to
        """
        return False

    @abstractmethod
    def prepare(self):
        """
        Prepare the I/O handler for the event loop or an event loop
        iteration.

        :Return: `HandlerReady()` if there is no need to call `prepare` again
            or `PrepareAgain()` otherwise.
        :Returntype: `IOHandlerPrepareResult`
        """
        return HandlerReady()

    @abstractmethod
    def wait_for_writability(self):
        """
        Stop current thread until the channel is writable.

        :Return: `False` if it won't be readable (e.g. is closed)
        """
        return False

    @abstractmethod
    def handle_write(self):
        """
        Handle the 'channel writable' state. E.g. send buffered data via a
        socket.
        """
        pass

    @abstractmethod
    def handle_read(self):
        """
        Handle the 'channel readable' state. E.g. read from a socket.
        """
        pass

    @abstractmethod
    def handle_hup(self):
        """
        Handle the 'channel hungup' state. The handler should not be writtable
        after this.
        """
        pass

    @abstractmethod
    def handle_err(self):
        """
        Handle an error reported.
        """
        pass

    @abstractmethod
    def handle_nval(self):
        """
        Handle an 'invalid file descriptor' event.
        """
        pass

    @abstractmethod
    def close(self):
        """Close the channell immediately, so it won't expect more events."""
        pass

class Event:
    """Base class for PyXMPP2 events.
    """
    # pylint: disable-msg=W0232,R0903,R0921,R0922
    __metaclass__ = ABCMeta

    @abstractmethod
    def __unicode__(self):
        return repr(self)

QUIT = None
class QuitEvent(Event):
    """The `QUIT` event class."""
    # pylint: disable-msg=W0232,R0903
    def __unicode__(self):
        return "Quit"
QUIT = QuitEvent()
del QuitEvent

class EventHandler:
    """Base class for PyXMPP event handlers."""
    # pylint: disable-msg=W0232,R0903
    __metaclass__ = ABCMeta

def event_handler(event_class = None):
    """Method decorator generator for decorating event handlers.

    To be used on `EventHandler` subclass methods only.

    Such methods may return:
        - `True`: if they 'completely' handled the event and no more events
          should be called (use with care)
        - `QUIT`: to quit the main loop. Other handlers still will be called
          for current event and nother events in the queue.

    :Parameters:
        - `event_class`: event class expected
    :Types:
        - `event_class`: subclass of `Event`
    """
    def decorator(func):
        """The decorator"""
        func._pyxmpp_event_handled = event_class
        return func
    return decorator

class TimeoutHandler:
    """Base class for PyXMPP timeout handlers."""
    # pylint: disable-msg=W0232,R0903
    __metaclass__ = ABCMeta

def timeout_handler(interval, recurring = None):
    """Method decorator generator for decorating event handlers.

    To be used on `TimeoutHandler` subclass methods only.

    :Parameters:
        - `interval`: interval (in seconds) before the method will be called.
        - `recurring`: When `True`, the handler will be called each `interval`
          seconds, when `False` it will be called only once. If `True`,
          then the handler should return the next interval or `None` if it
          should not be called again.
    :Types:
        - `interval`: `float`
        - `recurring`: `bool`
    """
    def decorator(func):
        """The decorator"""
        func._pyxmpp_timeout = interval
        func._pyxmpp_recurring = recurring
        return func
    return decorator

class MainLoop:
    """Base class for main loop implementations."""
    # pylint: disable-msg=W0232
    __metaclass__ = ABCMeta
    @abstractmethod
    def add_handler(self, handler):
        """Add a new handler to the main loop.

        :Parameters:
            - `handler`: the handler object to add
        :Types:
            - `handler`: `IOHandler` or `EventHandler` or `TimeoutHandler`
        """
        pass

    @abstractmethod
    def remove_handler(self, handler):
        """Add a new handler to the main loop.

        Do nothing if the handler is not registered at the main loop.

        :Parameters:
            - `handler`: the handler object to add
        :Types:
            - `handler`: `IOHandler` or `EventHandler` or `TimeoutHandler`
        """
        pass

    def delayed_call(self, delay, function):
        """Schedule function to be called from the main loop after `delay`
        seconds.

        :Parameters:
            - `delay`: seconds to wait
        :Types:
            - `delay`: `float`
        """
        main_loop = self
        handler = []
        class DelayedCallHandler(TimeoutHandler):
            """Wrapper timeout handler class for the delayed call."""
            # pylint: disable=R0903
            @timeout_handler(delay, False)
            def callback(self):
                """Wrapper timeout handler method for the delayed call."""
                try:
                    function()
                finally:
                    main_loop.remove_handler(handler[0])
        handler.append(DelayedCallHandler())
        self.add_handler(handler[0])

    @abstractmethod
    def quit(self):
        """Make the loop stop after the current iteration."""
        pass

    @abstractproperty
    def started(self):
        """`True` then the loop has been started.
        """
        return False

    @abstractproperty
    def finished(self):
        """`True` then the loop has been finished or is about to finish (the
        final iteration in progress).
        """
        return False

    @abstractmethod
    def loop(self, timeout = None):
        """Run the loop.

        :Parameters:
            - `timeout`: time to loop, if not given the method will run
              until `finished`
        :Types:
            - `timeout`: `float`
        """
        pass

    @abstractmethod
    def loop_iteration(self, timeout = 1):
        """Single loop iteration.

        :Parameters:
            - `timeout`: maximum time (in seconds) to block for
        :Types:
            - `timeout`: `float`

        """
        pass


########NEW FILE########
__FILENAME__ = poll
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""I/O Handling classes

This module has a purpose similar to :std:`asyncore` from the base library, but
should be more usable, especially for PyXMPP.

Also, these interfaces should allow building application not only in
asynchronous event loop model, but also threaded model.
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import logging
import select

from .interfaces import HandlerReady, PrepareAgain
from .base import MainLoopBase

logger = logging.getLogger("pyxmpp2.mainloop.poll")

class PollMainLoop(MainLoopBase):
    """Main event loop based on the poll() syscall."""
    def __init__(self, settings = None, handlers = None):
        self._handlers = {}
        self._unprepared_handlers = {}
        self.poll = select.poll()
        self._timeout = None
        MainLoopBase.__init__(self, settings, handlers)

    def _add_io_handler(self, handler):
        """Add an I/O handler to the loop."""
        self._unprepared_handlers[handler] = None
        self._configure_io_handler(handler)

    def _configure_io_handler(self, handler):
        """Register an io-handler at the polling object."""
        if self.check_events():
            return
        if handler in self._unprepared_handlers:
            old_fileno = self._unprepared_handlers[handler]
            prepared = self._prepare_io_handler(handler)
        else:
            old_fileno = None
            prepared = True
        fileno = handler.fileno()
        if old_fileno is not None and fileno != old_fileno:
            del self._handlers[old_fileno]
            try:
                self.poll.unregister(old_fileno)
            except KeyError:
                # The socket has changed, but the old one isn't registered,
                # e.g. ``prepare`` wants to connect again
                pass
        if not prepared:
            self._unprepared_handlers[handler] = fileno
        if not fileno:
            return
        self._handlers[fileno] = handler
        events = 0
        if handler.is_readable():
            logger.debug(" {0!r} readable".format(handler))
            events |= select.POLLIN
        if handler.is_writable():
            logger.debug(" {0!r} writable".format(handler))
            events |= select.POLLOUT
        if events:
            logger.debug(" registering {0!r} handler fileno {1} for"
                            " events {2}".format(handler, fileno, events))
            self.poll.register(fileno, events)

    def _prepare_io_handler(self, handler):
        """Call the `interfaces.IOHandler.prepare` method and
        remove the handler from unprepared handler list when done.
        """
        logger.debug(" preparing handler: {0!r}".format(handler))
        ret = handler.prepare()
        logger.debug("   prepare result: {0!r}".format(ret))
        if isinstance(ret, HandlerReady):
            del self._unprepared_handlers[handler]
            prepared = True
        elif isinstance(ret, PrepareAgain):
            if ret.timeout is not None:
                if self._timeout is not None:
                    self._timeout = min(self._timeout, ret.timeout)
                else:
                    self._timeout = ret.timeout
            prepared = False
        else:
            raise TypeError("Unexpected result type from prepare()")
        return prepared

    def _remove_io_handler(self, handler):
        """Remove an i/o-handler."""
        if handler in self._unprepared_handlers:
            old_fileno = self._unprepared_handlers[handler]
            del self._unprepared_handlers[handler]
        else:
            old_fileno = handler.fileno()
        if old_fileno is not None:
            try:
                del self._handlers[old_fileno]
                self.poll.unregister(old_fileno)
            except KeyError:
                pass

    def loop_iteration(self, timeout = 60):
        """A loop iteration - check any scheduled events
        and I/O available and run the handlers.
        """
        next_timeout, sources_handled = self._call_timeout_handlers()
        if self._quit:
            return sources_handled
        if self._timeout is not None:
            timeout = min(timeout, self._timeout)
        if next_timeout is not None:
            timeout = min(next_timeout, timeout)
        for handler in list(self._unprepared_handlers):
            self._configure_io_handler(handler)
        events = self.poll.poll(timeout * 1000)
        self._timeout = None
        for (fileno, event) in events:
            if event & select.POLLHUP:
                self._handlers[fileno].handle_hup()
            if event & select.POLLNVAL:
                self._handlers[fileno].handle_nval()
            if event & select.POLLIN:
                self._handlers[fileno].handle_read()
            elif event & select.POLLERR:
                # if POLLIN was set this condition should be already handled
                self._handlers[fileno].handle_err()
            if event & select.POLLOUT:
                self._handlers[fileno].handle_write()
            sources_handled += 1
            self._configure_io_handler(self._handlers[fileno])
        return sources_handled

########NEW FILE########
__FILENAME__ = select
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""I/O Handling classes

This module has a purpose similar to :std:`asyncore` from the base library, but
should be more usable, especially for PyXMPP.

Also, these interfaces should allow building application not only in
asynchronous event loop model, but also threaded model.
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import time
import select
import logging

from .interfaces import HandlerReady, PrepareAgain
from .base import MainLoopBase

logger = logging.getLogger("pyxmpp2.mainloop.select")

class SelectMainLoop(MainLoopBase):
    """Main event loop implementation based on the `select.select()` call."""
    def __init__(self, settings = None, handlers = None):
        self._handlers = []
        self._prepared = set()
        MainLoopBase.__init__(self, settings, handlers)

    def _add_io_handler(self, handler):
        """Add an I/O handler to the loop."""
        self._handlers.append(handler)

    def _remove_io_handler(self, handler):
        self._handlers.remove(handler)

    def loop_iteration(self, timeout = 60):
        """A loop iteration - check any scheduled events
        and I/O available and run the handlers.
        """
        if self.check_events():
            return 0
        next_timeout, sources_handled = self._call_timeout_handlers()
        if self._quit:
            return sources_handled
        if next_timeout is not None:
            timeout = min(next_timeout, timeout)
        readable, writable, next_timeout = self._prepare_handlers()
        if next_timeout is not None:
            timeout = min(next_timeout, timeout)
        if not readable and not writable:
            readable, writable, _unused = [], [], None
            time.sleep(timeout)
        else:
            logger.debug("select({0!r}, {1!r}, [], {2!r})"
                                    .format( readable, writable,timeout))
            readable, writable, _unused = select.select(
                                            readable, writable, [], timeout)
        for handler in readable:
            handler.handle_read()
            sources_handled += 1
        for handler in writable:
            handler.handle_write()
            sources_handled += 1
        return sources_handled

    def _prepare_handlers(self):
        """Prepare the I/O handlers.

        :Return: (readable, writable, timeout) tuple. 'readable' is the list
            of readable handlers, 'writable' - the list of writable handlers,
            'timeout' the suggested maximum timeout for this loop iteration or
            `None`
        """
        timeout = None
        readable = []
        writable = []
        for handler in self._handlers:
            if handler not in self._prepared:
                logger.debug(" preparing handler: {0!r}".format(handler))
                ret = handler.prepare()
                logger.debug("   prepare result: {0!r}".format(ret))
                if isinstance(ret, HandlerReady):
                    self._prepared.add(handler)
                elif isinstance(ret, PrepareAgain):
                    if ret.timeout is not None:
                        if timeout is None:
                            timeout = ret.timeout
                        else:
                            timeout = min(timeout, ret.timeout)
                else:
                    raise TypeError("Unexpected result type from prepare()")
            if not handler.fileno():
                logger.debug(" {0!r}: no fileno".format(handler))
                continue
            if handler.is_readable():
                logger.debug(" {0!r} readable".format(handler))
                readable.append(handler)
            if handler.is_writable():
                logger.debug(" {0!r} writable".format(handler))
                writable.append(handler)
        return readable, writable, timeout


########NEW FILE########
__FILENAME__ = threads
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""I/O Handling classes

This module has a purpose similar to :std:`asyncore` from the base library, but
should be more usable, especially for PyXMPP.

Also, these interfaces should allow building application not only in
asynchronous event loop model, but also threaded model.
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import time
import threading
import logging
import sys
import Queue
import inspect

from .interfaces import MainLoop, HandlerReady, PrepareAgain
from .interfaces import IOHandler, QUIT, EventHandler, TimeoutHandler
from .events import EventDispatcher
from ..settings import XMPPSettings
from .wait import wait_for_read, wait_for_write

logger = logging.getLogger("pyxmpp2.mainloop.threads")

class IOThread(object):
    """Base class for `ReadingThread` and `WrittingThread`.

    :Ivariables:
        - `name`: thread name (for debugging)
        - `io_handler`: the I/O handler object to poll
        - `thread`: the actual thread object
        - `exc_info`: this will hold exception information tuple for the
          last exception raised in the thread.
        - `exc_queue`: queue to put all exceptions raised in the thread.

    :Types:
        - `name`: `unicode`
        - `io_handler`: `IOHandler`
        - `thread`: :std:`threading.Thread`
        - `exc_info`: (type, value, traceback) tuple
    """
    def __init__(self, settings, io_handler, name, daemon = True,
                                                        exc_queue = None):
        # pylint: disable=R0913
        self.settings = settings if settings else XMPPSettings()
        self.name = name
        self.io_handler = io_handler
        self.thread = threading.Thread(name = name, target = self._run)
        self.thread.daemon = daemon
        self.exc_info = None
        self.exc_queue = exc_queue
        self._quit = False

    def start(self):
        """Start the thread.
        """
        self.thread.start()

    def is_alive(self):
        """Check if the thread is alive."""
        return self.thread.is_alive()

    def stop(self):
        """Request the thread to stop."""
        self._quit = True

    def join(self, timeout=None):
        """Join the thread (wait until it stops)."""
        return self.thread.join(timeout)

    def _run(self):
        """The thread function. Calls `self.run()` in loop and if it raises an
        exception, stores it in self.exc_queue. If `exc_queue` is None
        the exception will abort the thread.
        """
        logger.debug("{0}: entering thread".format(self.name))
        while True:
            try:
                self.run()
            except Exception: # pylint: disable-msg=W0703
                self.exc_info = sys.exc_info()
                logger.debug(u"exception in the {0!r} thread:"
                                .format(self.name), exc_info = self.exc_info)
                if self.exc_queue:
                    self.exc_queue.put( (self, self.exc_info) )
                    continue
                else:
                    logger.debug("{0}: aborting thread".format(self.name))
                    return
            except:
                logger.debug("{0}: aborting thread".format(self.name))
                return
            break
        logger.debug("{0}: exiting thread".format(self.name))

    def run(self):
        """The thread function."""
        raise NotImplementedError

class ReadingThread(IOThread):
    """A thread reading from io_handler.

    This thread will be also the one to call the `IOHandler.prepare` method
    until HandlerReady is returned.

    It can be used (together with `WrittingThread`) instead of
    a main loop."""
    def __init__(self, settings, io_handler, name = None, daemon = True,
                                                            exc_queue = None):
        # pylint: disable=R0913
        if name is None:
            name = u"{0!r} reader".format(io_handler)
        IOThread.__init__(self, settings, io_handler, name, daemon, exc_queue)

    def run(self):
        """The thread function.

        First, call the handler's 'prepare' method until it returns
        `HandlerReady` then loop waiting for the socket input and calling
        'handle_read' on the handler.
        """
        # pylint: disable-msg=R0912
        interval = self.settings["poll_interval"]
        prepared = False
        timeout = 0.1
        while not self._quit:
            if not prepared:
                logger.debug("{0}: preparing handler: {1!r}".format(
                                                   self.name, self.io_handler))
                ret = self.io_handler.prepare()
                logger.debug("{0}: prepare result: {1!r}".format(self.name,
                                                                        ret))
                if isinstance(ret, HandlerReady):
                    prepared = True
                elif isinstance(ret, PrepareAgain):
                    if ret.timeout is not None:
                        timeout = ret.timeout
                else:
                    raise TypeError("Unexpected result type from prepare()")
            if self.io_handler.is_readable():
                logger.debug("{0}: readable".format(self.name))
                fileno = self.io_handler.fileno()
                if fileno is not None:
                    readable = wait_for_read(fileno, interval)
                    if readable:
                        self.io_handler.handle_read()
            elif not prepared:
                if timeout:
                    time.sleep(timeout)
            else:
                logger.debug("{0}: waiting for readability".format(self.name))
                if not self.io_handler.wait_for_readability():
                    break

class WrittingThread(IOThread):
    """A thread reading from io_handler.

    It can be used (together with `WrittingThread`) instead of
    a main loop."""
    def __init__(self, settings, io_handler, name = None, daemon = True,
                                                            exc_queue = None):
        # pylint: disable=R0913
        if name is None:
            name = u"{0!r} writer".format(io_handler)
        IOThread.__init__(self, settings, io_handler, name, daemon, exc_queue)

    def run(self):
        """The thread function.

        Loop waiting for the handler and socket being writable and calling
        `interfaces.IOHandler.handle_write`.
        """
        while not self._quit:
            interval = self.settings["poll_interval"]
            if self.io_handler.is_writable():
                logger.debug("{0}: writable".format(self.name))
                fileno = self.io_handler
                if fileno:
                    writable = wait_for_write(fileno, interval)
                    if writable:
                        self.io_handler.handle_write()
            else:
                logger.debug("{0}: waiting for writaility".format(self.name))
                if not self.io_handler.wait_for_writability():
                    break

class EventDispatcherThread(object):
    """Event dispatcher thread.

    :Ivariables:
        - `name`: thread name (for debugging)
        - `event_queue`: the event queue to poll
        - `thread`: the actual thread object
        - `exc_info`: this will hold exception information tuple whenever the
          thread was aborted by an exception.

    :Types:
        - `name`: `unicode`
        - `event_queue`: :std:`Queue.Queue`
        - `thread`: :std:`threading.Thread`
        - `exc_info`: (type, value, traceback) tuple
    """
    def __init__(self, event_dispatcher, name = None,
                                            daemon = True, exc_queue = None):
        if name is None:
            name = "event dispatcher"
        self.name = name
        self.thread = threading.Thread(name = name, target = self.run)
        self.thread.daemon = daemon
        self.exc_info = None
        self.exc_queue = exc_queue
        self.event_dispatcher = event_dispatcher

    def start(self):
        """Start the thread."""
        self.thread.start()

    def is_alive(self):
        """Check if the thread is alive."""
        return self.thread.is_alive()

    def join(self, timeout=None):
        """Join the thread."""
        return self.thread.join(timeout)

    def run(self):
        """The thread function. Calls `self.run()` and if it raises
        an exception, stores it in self.exc_info and exc_queue
        """
        logger.debug("{0}: entering thread".format(self.name))
        while True:
            try:
                self.event_dispatcher.loop()
            except Exception: # pylint: disable-msg=W0703
                self.exc_info = sys.exc_info()
                logger.debug(u"exception in the {0!r} thread:"
                                .format(self.name), exc_info = self.exc_info)
                if self.exc_queue:
                    self.exc_queue.put( (self, self.exc_info) )
                    continue
                else:
                    logger.debug("{0}: aborting thread".format(self.name))
                    return
            except:
                logger.debug("{0}: aborting thread".format(self.name))
                return
            break
        logger.debug("{0}: exiting thread".format(self.name))

class TimeoutThread(object):
    """Thread to handle `TimeoutHandler` methods.

    :Ivariables:
        - `method`: the timout handler method
        - `name`: thread name (for debugging)
        - `thread`: the actual thread object
        - `exc_info`: this will hold exception information tuple whenever the
          thread was aborted by an exception.
        - `exc_queue`: queue for raised exceptions

    :Types:
        - `name`: `unicode`
        - `method`: a bound method decorated with `interfaces.timeout_handler`
        - `thread`: :std:`threading.Thread`
        - `exc_info`: (type, value, traceback) tuple
        - `exc_queue`: queue for raised exceptions
    """
    def __init__(self, method, name = None, daemon = True, exc_queue = None):
        if name is None:
            name = "{0!r} timer thread"
        self.name = name
        self.method = method
        self.thread = threading.Thread(name = name, target = self._run)
        self.thread.daemon = daemon
        self.exc_info = None
        self.exc_queue = exc_queue
        self._quit = False

    def start(self):
        """Start the thread.
        """
        self.thread.start()

    def is_alive(self):
        """Check if the thread is alive."""
        return self.thread.is_alive()

    def stop(self):
        """Request the thread to stop."""
        self._quit = True

    def join(self, timeout=None):
        """Join the thread (wait until it stops)."""
        return self.thread.join(timeout)

    def _run(self):
        """The thread function. Calls `self.run()` and if it raises
        an exception, stores it in self.exc_info
        """
        logger.debug("{0}: entering thread".format(self.name))
        while True:
            try:
                self.run()
            except Exception: # pylint: disable-msg=W0703
                self.exc_info = sys.exc_info()
                logger.debug(u"exception in the {0!r} thread:"
                                .format(self.name), exc_info = self.exc_info)
                if self.exc_queue:
                    self.exc_queue.put( (self, self.exc_info) )
                    continue
                else:
                    logger.debug("{0}: aborting thread".format(self.name))
                    return
            except:
                logger.debug("{0}: aborting thread".format(self.name))
                return
            break
        logger.debug("{0}: exiting thread".format(self.name))

    def run(self):
        """The thread function."""
        # pylint: disable-msg=W0212
        timeout = self.method._pyxmpp_timeout
        recurring = self.method._pyxmpp_recurring
        while not self._quit and timeout is not None:
            if timeout:
                time.sleep(timeout)
            if self._quit:
                break
            ret = self.method()
            if recurring is None:
                timeout = ret
            elif not recurring:
                break

class ThreadPool(MainLoop):
    """Thread pool object, as a replacement for an asychronous event loop."""
    # pylint: disable-msg=R0902
    def __init__(self, settings = None, handlers = None):
        self.settings = settings if settings else XMPPSettings()
        self.io_handlers = []
        self.timeout_handlers = []
        self.event_queue = self.settings["event_queue"]
        self.event_dispatcher = EventDispatcher(self.settings, handlers)
        self.exc_queue = Queue.Queue()
        self.io_threads = []
        self.timeout_threads = []
        self.event_thread = None
        self.daemon = False
        if handlers:
            for handler in handlers:
                self.add_handler(handler)

    def add_handler(self, handler):
        if isinstance(handler, IOHandler):
            self._add_io_handler(handler)
        if isinstance(handler, EventHandler):
            self.event_dispatcher.add_handler(handler)
        if isinstance(handler, TimeoutHandler):
            self._add_timeout_handler(handler)

    def remove_handler(self, handler):
        if isinstance(handler, IOHandler):
            self._remove_io_handler(handler)
        if isinstance(handler, EventHandler):
            self.event_dispatcher.remove_handler(handler)
        if isinstance(handler, TimeoutHandler):
            self._remove_timeout_handler(handler)

    def _add_io_handler(self, handler):
        """Add an IOHandler to the pool.
        """
        self.io_handlers.append(handler)
        if self.event_thread is None:
            return

    def _run_io_threads(self, handler):
        """Start threads for an IOHandler.
        """
        reader = ReadingThread(self.settings, handler, daemon = self.daemon,
                                                exc_queue = self.exc_queue)
        writter = WrittingThread(self.settings, handler, daemon = self.daemon,
                                                exc_queue = self.exc_queue)
        self.io_threads += [reader, writter]
        reader.start()
        writter.start()

    def _remove_io_handler(self, handler):
        """Remove an IOHandler from the pool.
        """
        if handler not in self.io_handlers:
            return
        self.io_handlers.remove(handler)
        for thread in self.io_threads:
            if thread.io_handler is handler:
                thread.stop()

    def _add_timeout_handler(self, handler):
        """Add a TimeoutHandler to the pool.
        """
        self.timeout_handlers.append(handler)
        if self.event_thread is None:
            return
        self._run_timeout_threads(handler)

    def _run_timeout_threads(self, handler):
        """Start threads for a TimeoutHandler.
        """
        # pylint: disable-msg=W0212
        for dummy, method in inspect.getmembers(handler, callable):
            if not hasattr(method, "_pyxmpp_timeout"):
                continue
            thread = TimeoutThread(method, daemon = self.daemon,
                                                    exc_queue = self.exc_queue)
            self.timeout_threads.append(thread)
            thread.start()

    def _remove_timeout_handler(self, handler):
        """Remove a TimeoutHandler from the pool.
        """
        if handler not in self.timeout_handlers:
            return
        self.timeout_handlers.remove(handler)
        for thread in self.timeout_threads:
            if thread.method.im_self is handler:
                thread.stop()

    def start(self, daemon = False):
        """Start the threads."""
        self.daemon = daemon
        self.io_threads = []
        self.event_thread = EventDispatcherThread(self.event_dispatcher,
                                    daemon = daemon, exc_queue = self.exc_queue)
        self.event_thread.start()
        for handler in self.io_handlers:
            self._run_io_threads(handler)
        for handler in self.timeout_handlers:
            self._run_timeout_threads(handler)

    def stop(self, join = False, timeout = None):
        """Stop the threads.

        :Parameters:
            - `join`: join the threads (wait until they exit)
            - `timeout`: maximum time (in seconds) to wait when `join` is
              `True`).  No limit when `timeout` is `None`.
        """
        logger.debug("Closing the io handlers...")
        for handler in self.io_handlers:
            handler.close()
        if self.event_thread and self.event_thread.is_alive():
            logger.debug("Sending the QUIT signal")
            self.event_queue.put(QUIT)
        logger.debug("  sent")
        threads = self.io_threads + self.timeout_threads
        for thread in threads:
            logger.debug("Stopping thread: {0!r}".format(thread))
            thread.stop()
        if not join:
            return
        if self.event_thread:
            threads.append(self.event_thread)
        if timeout is None:
            for thread in threads:
                thread.join()
        else:
            timeout1 = (timeout * 0.01) / len(threads)
            threads_left = []
            for thread in threads:
                logger.debug("Quick-joining thread {0!r}...".format(thread))
                thread.join(timeout1)
                if thread.is_alive():
                    logger.debug("  thread still alive".format(thread))
                    threads_left.append(thread)
            if threads_left:
                timeout2 = (timeout * 0.99) / len(threads_left)
                for thread in threads_left:
                    logger.debug("Joining thread {0!r}...".format(thread))
                    thread.join(timeout2)
        self.io_threads = []
        self.event_thread = None

    @property
    def finished(self):
        return self.event_thread is None or not self.event_thread.is_alive()

    @property
    def started(self):
        return self.event_thread is not None

    def quit(self):
        self.event_queue.put(QUIT)

    def loop(self, timeout = None):
        if not self.event_thread:
            return
        interval = self.settings["poll_interval"]
        if timeout is None:
            while self.event_thread.is_alive():
                self.loop_iteration(interval)
        else:
            timeout = time.time() + timeout
            while self.event_thread.is_alive() and time.time() < timeout:
                self.loop_iteration(interval)

    def loop_iteration(self, timeout = 0.1):
        """Wait up to `timeout` seconds, raise any exception from the
        threads.
        """
        try:
            exc_info = self.exc_queue.get(True, timeout)[1]
        except Queue.Empty:
            return
        exc_type, exc_value, ext_stack = exc_info
        raise exc_type, exc_value, ext_stack


########NEW FILE########
__FILENAME__ = tornado
#
# (C) Copyright 2012 lilydjwg <lilydjwg@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""Tornado main loop integration."""

from __future__ import absolute_import, division

import logging
from functools import partial
import inspect
import time

from tornado import ioloop
from .interfaces import HandlerReady, PrepareAgain, QUIT
from .base import MainLoopBase

logger = logging.getLogger(__name__)

class TornadoMainLoop(MainLoopBase):
    """Main event loop based on Tornado's ioloop."""

    def __init__(self, settings = None, handlers = None, io_loop=None):
        self._handlers = {}
        self._unprepared_handlers = {}
        self.io_loop = io_loop or ioloop.IOLoop.instance()
        MainLoopBase.__init__(self, settings, handlers)

    def _add_io_handler(self, handler):
        """Add an I/O handler to the loop."""
        logger.debug('adding io handler: %r', handler)
        self._unprepared_handlers[handler] = None
        self._configure_io_handler(handler)

    def _configure_io_handler(self, handler):
        """Register an io-handler at the polling object."""
        if self.check_events():
            return
        if handler in self._unprepared_handlers:
            old_fileno = self._unprepared_handlers[handler]
            prepared = self._prepare_io_handler(handler)
        else:
            old_fileno = None
            prepared = True
        fileno = handler.fileno()
        if old_fileno is not None and fileno != old_fileno:
            del self._handlers[old_fileno]
            # remove_handler won't raise something like KeyError if the fd
            # isn't registered; it will just print a debug log.
            self.io_loop.remove_handler(old_fileno)
        if not prepared:
            self._unprepared_handlers[handler] = fileno
        if not fileno:
            return
        update = fileno in self._handlers
        events = ioloop.IOLoop.NONE
        if handler.is_readable():
            logger.debug(" {0!r} readable".format(handler))
            events |= ioloop.IOLoop.READ
        if handler.is_writable():
            logger.debug(" {0!r} writable".format(handler))
            events |= ioloop.IOLoop.WRITE

        if self._handlers.get(fileno, None) == events:
            return
        self._handlers[fileno] = events
        if events:
            logger.debug(" registering {0!r} handler fileno {1} for"
                            " events {2}".format(handler, fileno, events))
            if update:
                self.io_loop.update_handler(fileno, events)
            else:
                self.io_loop.add_handler(
                    fileno, partial(self._handle_event, handler), events
                )

    def _prepare_io_handler(self, handler):
        """Call the `interfaces.IOHandler.prepare` method and
        remove the handler from unprepared handler list when done.
        """
        logger.debug(" preparing handler: {0!r}".format(handler))
        ret = handler.prepare()
        logger.debug("   prepare result: {0!r}".format(ret))
        if isinstance(ret, HandlerReady):
            del self._unprepared_handlers[handler]
            prepared = True
        elif isinstance(ret, PrepareAgain):
            if ret.timeout is not None:
                now = time.time()
                self.io_loop.add_timeout(
                    now + ret.timeout,
                    partial(self._configure_io_handler, handler)
                )
            else:
                self.io_loop.add_callback(
                    partial(self._configure_io_handler, handler)
                )
            prepared = False
        else:
            raise TypeError("Unexpected result type from prepare()")
        return prepared

    def _remove_io_handler(self, handler):
        """Remove an i/o-handler."""
        if handler in self._unprepared_handlers:
            old_fileno = self._unprepared_handlers[handler]
            del self._unprepared_handlers[handler]
        else:
            old_fileno = handler.fileno()
        if old_fileno is not None:
            del self._handlers[old_fileno]
            self.io_loop.remove_handler(handler.fileno())

    def _add_timeout_handler(self, handler):
        logger.debug('adding timeout handler: %r', handler)
        now = time.time()
        for dummy, method in inspect.getmembers(handler, callable):
            if not hasattr(method, "_pyxmpp_timeout"):
                continue
            # pylint: disable=W0212
            logger.debug(" registering {0!r} handler with timeout {1}".format(
                handler, method._pyxmpp_timeout))
            handler._tornado_timeout = self.io_loop.add_timeout(
                now + method._pyxmpp_timeout, method
            )

    def _remove_timeout_handler(self, handler):
        for dummy, method in inspect.getmembers(handler, callable):
            if not hasattr(method, "_tornado_timeout"):
                continue
            # pylint: disable=W0212
            self.io_loop.remove_timeout(method._tornado_timeout)

    def quit(self):
        self._quit = True
        self.io_loop.stop()

    def loop(self, timeout=None):
        logger.debug('looping, timeout is %r', timeout)
        if timeout is not None:
            now = time.time()
            self.io_loop.add_timeout(now + timeout, self.quit)
        self.io_loop.start()

    def loop_iteration(self, timeout=1):
        pass

    def check_events(self):
        if self.event_dispatcher.flush() is QUIT:
            self.quit()
            return True
        return False

    def _handle_event(self, handler, fd, event):
        """handle I/O events"""
        # pylint: disable=C0103
        logger.debug('_handle_event: %r, %r, %r', handler, fd, event)
        if event & ioloop.IOLoop.ERROR:
            handler.handle_hup()
        if event & ioloop.IOLoop.READ:
            handler.handle_read()
        if event & ioloop.IOLoop.WRITE:
            handler.handle_write()
        self._configure_io_handler(handler)

########NEW FILE########
__FILENAME__ = wait
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# pylint: disable-msg=W0201

"""Utility functions to wait until a socket (or object implementing .fileno()
in POSIX) is ready for input or output."""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import select

if hasattr(select, "poll"):
    def wait_for_read(socket, timeout = None):
        """Wait up to `timeout` seconds until `socket` is ready for reading.
        """
        if timeout is not None:
            timeout *= 1000
        poll = select.poll()
        poll.register(socket, select.POLLIN)
        events = poll.poll(timeout)
        return bool(events)
    def wait_for_write(socket, timeout = None):
        """Wait up to `timeout` seconds until `socket` is ready for writing.
        """
        if timeout is not None:
            timeout *= 1000
        poll = select.poll()
        poll.register(socket, select.POLLOUT)
        events = poll.poll(timeout)
        return bool(events)
else:
    def wait_for_read(socket, timeout = None):
        """Wait up to `timeout` seconds until `socket` is ready for reading.
        """
        readable = select.select([socket], [], [], timeout)[0]
        return bool(readable)
    def wait_for_write(socket, timeout = None):
        """Wait up to `timeout` seconds until `socket` is ready for writing.
        """
        writable = select.select([], [socket], [], timeout)[1]
        return bool(writable)


########NEW FILE########
__FILENAME__ = message
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""Message XMPP stanza handling

Normative reference:
  - `RFC 3920 <http://www.ietf.org/rfc/rfc3920.txt>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

from .etree import ElementTree, ElementClass
from .stanza import Stanza

MESSAGE_TYPES = ("normal", "chat", "headline", "error", "groupchat")

class Message(Stanza):
    """<message /> stanza class.
    """
    # pylint: disable-msg=R0902,R0904
    element_name = "message"
    def __init__(self, element = None, from_jid = None, to_jid = None,
                            stanza_type = None, stanza_id = None,
                            error = None, error_cond = None, return_path = None,
                            language = None,
                            subject = None, body = None, thread = None):
        """Initialize a `Message` object.

        :Parameters:
            - `element`: XML element of this stanza.
            - `from_jid`: sender JID.
            - `to_jid`: recipient JID.
            - `stanza_type`: staza type: one of: "normal", "chat", "headline",
              "error", "groupchat"
            - `stanza_id`: stanza id -- value of stanza's "id" attribute. If
              not given, then unique for the session value is generated.
            - `error_cond`: error condition name. Ignored if `stanza_type`
              is not "error".
            - `language`: default language for the stanza content
            - `subject`: message subject,
            - `body`: message body.
            - `thread`: message thread id.
        :Types:
            - `element`: :etree:`ElementTree.Element`
            - `from_jid`: `JID`
            - `to_jid`: `JID`
            - `stanza_type`: `unicode`
            - `stanza_id`: `unicode`
            - `error`: `pyxmpp.error.StanzaErrorElement`
            - `error_cond`: `unicode`
            - `subject`: `unicode`
            - `body`: `unicode`
            - `thread`: `unicode`
            - `language`: `unicode`
        """
        # pylint: disable-msg=R0913
        self._subject = None
        self._body = None
        self._thread = None
        if element is None:
            element = "message"
        elif not isinstance(element, ElementClass):
            raise TypeError("Couldn't make Message from " + repr(element))

        Stanza.__init__(self, element, from_jid = from_jid, to_jid = to_jid,
                        stanza_type = stanza_type, stanza_id = stanza_id,
                        error = error, error_cond = error_cond,
                        return_path = return_path, language = language)

        if self.element_name != "message":
            raise ValueError("The element is not <message/>")

        self._subject_tag = self._ns_prefix + "subject"
        self._body_tag = self._ns_prefix + "body"
        self._thread_tag = self._ns_prefix + "thread"

        if self._element is not None:
            self._decode_subelements()

        if subject is not None:
            self.subject = subject
        if body is not None:
            self.body = body
        if thread is not None:
            self.thread = thread

    def _decode_subelements(self):
        """Decode the stanza subelements."""
        for child in self._element:
            if child.tag == self._subject_tag:
                self._subject = child.text
            elif child.tag == self._body_tag:
                self._body = child.text
            elif child.tag == self._thread_tag:
                self._thread = child.text

    def as_xml(self):
        """Return the XML stanza representation.

        Always return an independent copy of the stanza XML representation,
        which can be freely modified without affecting the stanza.

        :returntype: :etree:`ElementTree.Element`"""
        result = Stanza.as_xml(self)
        if self._subject:
            child = ElementTree.SubElement(result, self._subject_tag)
            child.text = self._subject
        if self._body:
            child = ElementTree.SubElement(result, self._body_tag)
            child.text = self._body
        if self._thread:
            child = ElementTree.SubElement(result, self._thread_tag)
            child.text = self._thread
        return result

    def copy(self):
        """Create a deep copy of the stanza.

        :returntype: `Message`"""
        result = Message(None, self.from_jid, self.to_jid,
                        self.stanza_type, self.stanza_id, self.error,
                        self._return_path(), self._subject, self._body,
                                                            self._thread)
        for payload in self._payload:
            result.add_payload(payload.copy())
        return result

    @property
    def subject(self): # pylint: disable-msg=E0202
        """Message subject.

        :Returntype: `unicode`
        """
        return self._subject

    @subject.setter # pylint: disable-msg=E1101
    def subject(self, subject): # pylint: disable-msg=E0202,E0102,C0111
        self._subject = unicode(subject)
        self._dirty = True

    @property
    def body(self): # pylint: disable-msg=E0202
        """Message body.

        :Returntype: `unicode`
        """
        return self._body

    @body.setter # pylint: disable-msg=E1101
    def body(self, body): # pylint: disable-msg=E0202,E0102,C0111
        self._body = unicode(body)
        self._dirty = True

    @property
    def thread(self): # pylint: disable-msg=E0202
        """Thread id.

        :Returntype: `unicode`
        """
        return self._thread

    @thread.setter # pylint: disable-msg=E1101
    def thread(self, thread): # pylint: disable-msg=E0202,E0102,C0111
        self._thread = unicode(thread)
        self._dirty = True

    def make_error_response(self, cond):
        """Create error response for any non-error message stanza.

        :Parameters:
            - `cond`: error condition name, as defined in XMPP specification.

        :return: new message stanza with the same "id" as self, "from" and
            "to" attributes swapped, type="error" and containing <error />
            element plus payload of `self`.
        :returntype: `Message`"""

        if self.stanza_type == "error":
            raise ValueError("Errors may not be generated in response"
                                                                " to errors")

        msg = Message(stanza_type = "error", from_jid = self.to_jid,
                        to_jid = self.from_jid, stanza_id = self.stanza_id,
                        error_cond = cond,
                        subject = self._subject, body = self._body,
                        thread = self._thread)

        if self._payload is None:
            self.decode_payload()
        for payload in self._payload:
            msg.add_payload(payload.copy())

        return msg

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = presence
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""Presence XMPP stanza handling

Normative reference:
  - `RFC 3920 <http://www.ietf.org/rfc/rfc3920.txt>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

from .etree import ElementTree, ElementClass

from .exceptions import BadRequestProtocolError
from .stanza import Stanza

PRESENCE_TYPES = ("available", "unavailable", "probe",
                    "subscribe", "unsubscribe", "subscribed", "unsubscribed",
                    "invisible", "error")

ACCEPT_RESPONSES = {
        "subscribe": "subscribed",
        "subscribed": "subscribe",
        "unsubscribe": "unsubscribed",
        "unsubscribed": "unsubscribe",
        }

DENY_RESPONSES = {
        "subscribe": "unsubscribed",
        "subscribed": "unsubscribe",
        "unsubscribe": "subscribed",
        "unsubscribed": "subscribe",
        }

class Presence(Stanza):
    """<presence /> stanza.

    """
    # pylint: disable-msg=R0902,R0904
    element_name = "presence"
    def __init__(self, element = None, from_jid = None, to_jid = None,
                            stanza_type = None, stanza_id = None,
                            error = None, error_cond = None, return_path = None,
                            language = None,
                            show = None, status = None, priority = None):
        """Initialize a `Presence` object.

        :Parameters:
            - `element`: XML element
            - `from_jid`: sender JID.
            - `to_jid`: recipient JID.
            - `stanza_type`: staza type: one of: None, "available",
              "unavailable", "subscribe", "subscribed", "unsubscribe",
              "unsubscribed" or "error". "available" is automaticaly changed to
              None.
            - `stanza_id`: stanza id -- value of stanza's "id" attribute
            - `language`: default language for the stanza content
            - `show`: "show" field of presence stanza. One of: None, "away",
              "xa", "dnd", "chat".
            - `status`: descriptive text for the presence stanza.
            - `priority`: presence priority.
            - `error_cond`: error condition name. Ignored if `stanza_type` is
              not "error"
        :Types:
            - `element`: :etree:`ElementTree.Element`
            - `from_jid`: `JID`
            - `to_jid`: `JID`
            - `stanza_type`: `unicode`
            - `stanza_id`: `unicode`
            - `language`: `unicode`
            - `show`: `unicode`
            - `status`: `unicode`
            - `priority`: `int`
            - `error_cond`: `unicode`
        """
        # pylint: disable-msg=R0913
        self._show = None
        self._status = None
        self._priority = 0
        if element is None:
            element = "presence"
        elif not isinstance(element, ElementClass):
            raise TypeError("Couldn't make Presence from " + repr(element))

        if stanza_type is not None and stanza_type not in PRESENCE_TYPES:
            raise ValueError("Bad presence type")
        elif stanza_type == 'available':
            stanza_type = None

        Stanza.__init__(self, element, from_jid = from_jid, to_jid = to_jid,
                        stanza_type = stanza_type, stanza_id = stanza_id,
                        error = error, error_cond = error_cond,
                        return_path = return_path, language = language)

        if self.element_name != "presence":
            raise ValueError("The element is not <presence />")

        self._show_tag = self._ns_prefix + "show"
        self._status_tag = self._ns_prefix + "status"
        self._priority_tag = self._ns_prefix + "priority"

        if self._element is not None:
            self._decode_subelements()

        if show is not None:
            self.show = show
        if status is not None:
            self.status = status
        if priority is not None:
            self.priority = priority

    def _decode_subelements(self):
        """Decode the stanza subelements."""
        for child in self._element:
            if child.tag == self._show_tag:
                self._show = child.text
            elif child.tag == self._status_tag:
                self._status = child.text
            elif child.tag == self._priority_tag:
                try:
                    self._priority = int(child.text.strip())
                    if self._priority < -128 or self._priority > 127:
                        raise ValueError
                except ValueError:
                    raise BadRequestProtocolError(
                                            "Presence priority not an integer")

    def as_xml(self):
        """Return the XML stanza representation.

        Always return an independent copy of the stanza XML representation,
        which can be freely modified without affecting the stanza.

        :returntype: :etree:`ElementTree.Element`"""
        result = Stanza.as_xml(self)
        if self._show:
            child = ElementTree.SubElement(result, self._show_tag)
            child.text = self._show
        if self._status:
            child = ElementTree.SubElement(result, self._status_tag)
            child.text = self._status
        if self._priority:
            child = ElementTree.SubElement(result, self._priority_tag)
            child.text = unicode(self._priority)
        return result

    def copy(self):
        """Create a deep copy of the stanza.

        :returntype: `Presence`"""
        result = Presence(None, self.from_jid, self.to_jid,
                        self.stanza_type, self.stanza_id, self.error,
                        self._return_path(),
                        self._show, self._status, self._priority)
        if self._payload is None:
            self.decode_payload()
        for payload in self._payload:
            result.add_payload(payload.copy())
        return result

    @property
    def show(self): # pylint: disable-msg=E0202
        """Presence status type.

        :returntype: `unicode`
        """
        return self._show

    @show.setter # pylint: disable-msg=E1101
    def show(self, show): # pylint: disable-msg=E0202,E0102,C0111
        self._show = unicode(show)
        self._dirty = True

    @property
    def status(self): # pylint: disable-msg=E0202
        """Presence status message.

        :returntype: `unicode`
        """
        return self._status

    @status.setter # pylint: disable-msg=E1101
    def status(self, status): # pylint: disable-msg=E0202,E0102,C0111
        self._status = unicode(status)
        self._dirty = True

    @property
    def priority(self): # pylint: disable-msg=E0202
        """Presence priority.

        :returntype: `unicode`
        """
        return self._priority

    @priority.setter # pylint: disable-msg=E1101
    def priority(self, priority): # pylint: disable-msg=E0202,E0102,C0111
        priority = int(priority)
        if priority < -128 or priority > 127:
            raise ValueError("Priority must be in the (-128, 128) range")
        self._priority = priority
        self._dirty = True

    def make_accept_response(self):
        """Create "accept" response for the "subscribe" / "subscribed" /
        "unsubscribe" / "unsubscribed" presence stanza.

        :return: new stanza.
        :returntype: `Presence`
        """
        if self.stanza_type not in ("subscribe", "subscribed",
                                                "unsubscribe", "unsubscribed"):
            raise ValueError("Results may only be generated for 'subscribe',"
                "'subscribed','unsubscribe' or 'unsubscribed' presence")
        stanza = Presence(stanza_type = ACCEPT_RESPONSES[self.stanza_type],
                            from_jid = self.to_jid, to_jid = self.from_jid,
                                                    stanza_id = self.stanza_id)
        return stanza

    def make_deny_response(self):
        """Create "deny" response for the "subscribe" / "subscribed" /
        "unsubscribe" / "unsubscribed" presence stanza.

        :return: new presence stanza.
        :returntype: `Presence`
        """
        if self.stanza_type not in ("subscribe", "subscribed",
                                                "unsubscribe", "unsubscribed"):
            raise ValueError("Results may only be generated for 'subscribe',"
                "'subscribed','unsubscribe' or 'unsubscribed' presence")
        stanza = Presence(stanza_type = DENY_RESPONSES[self.stanza_type],
                            from_jid = self.to_jid, to_jid = self.from_jid,
                                                    stanza_id = self.stanza_id)
        return stanza

    def make_error_response(self, cond):
        """Create error response for the any non-error presence stanza.

        :Parameters:
            - `cond`: error condition name, as defined in XMPP specification.
        :Types:
            - `cond`: `unicode`

        :return: new presence stanza.
        :returntype: `Presence`
        """

        if self.stanza_type == "error":
            raise ValueError("Errors may not be generated in response"
                                                                " to errors")

        stanza = Presence(stanza_type = "error", from_jid = self.from_jid,
                            to_jid = self.to_jid, stanza_id = self.stanza_id,
                            status = self._status, show = self._show,
                            priority = self._priority, error_cond = cond)

        if self._payload is None:
            self.decode_payload()

        for payload in self._payload:
            stanza.add_payload(payload)

        return stanza

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = resolver
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""DNS resolever with SRV record support.

Normative reference:
  - `RFC 1035 <http://www.ietf.org/rfc/rfc1035.txt>`__
  - `RFC 2782 <http://www.ietf.org/rfc/rfc2782.txt>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import socket
import random
import logging
import threading
import Queue

from .settings import XMPPSettings
from .interfaces import Resolver

logger = logging.getLogger("pyxmpp2.resolver")

try:
    import dns.resolver     # pylint: disable=W0404
    import dns.name         # pylint: disable=W0404
    import dns.exception    # pylint: disable=W0404

    HAVE_DNSPYTHON = True
except ImportError:
    HAVE_DNSPYTHON = False

def is_ipv6_available():
    """Check if IPv6 is available.

    :Return: `True` when an IPv6 socket can be created.
    """
    try:
        socket.socket(socket.AF_INET6).close()
    except (socket.error, AttributeError):
        return False
    return True

def is_ipv4_available():
    """Check if IPv4 is available.

    :Return: `True` when an IPv4 socket can be created.
    """
    try:
        socket.socket(socket.AF_INET).close()
    except socket.error:
        return False
    return True

def shuffle_srv(records):
    """Randomly reorder SRV records using their weights.

    :Parameters:
        - `records`: SRV records to shuffle.
    :Types:
        - `records`: sequence of :dns:`dns.rdtypes.IN.SRV`

    :return: reordered records.
    :returntype: `list` of :dns:`dns.rdtypes.IN.SRV`"""
    if not records:
        return []
    ret = []
    while len(records) > 1:
        weight_sum = 0
        for rrecord in records:
            weight_sum += rrecord.weight + 0.1
        thres = random.random() * weight_sum
        weight_sum = 0
        for rrecord in records:
            weight_sum += rrecord.weight + 0.1
            if thres < weight_sum:
                records.remove(rrecord)
                ret.append(rrecord)
                break
    ret.append(records[0])
    return ret

def reorder_srv(records):
    """Reorder SRV records using their priorities and weights.

    :Parameters:
        - `records`: SRV records to shuffle.
    :Types:
        - `records`: `list` of :dns:`dns.rdtypes.IN.SRV`

    :return: reordered records.
    :returntype: `list` of :dns:`dns.rdtypes.IN.SRV`"""
    records = list(records)
    records.sort()
    ret = []
    tmp = []
    for rrecord in records:
        if not tmp or rrecord.priority == tmp[0].priority:
            tmp.append(rrecord)
            continue
        ret += shuffle_srv(tmp)
        tmp = [rrecord]
    if tmp:
        ret += shuffle_srv(tmp)
    return ret

class ThreadedResolverBase(Resolver):
    """Base class for threaded resolvers.

    Starts worker threads, each running a blocking resolver implementation
    and communicates with them to provide non-blocking asynchronous API.
    """
    def __init__(self, settings =  None, max_threads = 1):
        if settings:
            self.settings = settings
        else:
            self.settings = XMPPSettings()
        self.threads = []
        self.queue = Queue.Queue()
        self.lock = threading.RLock()
        self.max_threads = max_threads
        self.last_thread_n = 0

    def _make_resolver(self):
        """Return the blocking resolver implementation that should be
        used by the resolver threads.
        """
        raise NotImplementedError

    def stop(self):
        """Stop the resolver threads.
        """
        with self.lock:
            for dummy in self.threads:
                self.queue.put(None)

    def _start_thread(self):
        """Start a new working thread unless the maximum number of threads
        has been reached or the request queue is empty.
        """
        with self.lock:
            if self.threads and self.queue.empty():
                return
            if len(self.threads) >= self.max_threads:
                return
            thread_n = self.last_thread_n + 1
            self.last_thread_n = thread_n
            thread = threading.Thread(target = self._run,
                            name = "{0!r} #{1}".format(self, thread_n),
                            args = (thread_n,))
            self.threads.append(thread)
            thread.daemon = True
            thread.start()

    def resolve_address(self, hostname, callback, allow_cname = True):
        request = ("resolve_address", (hostname, callback, allow_cname))
        self._start_thread()
        self.queue.put(request)

    def resolve_srv(self, domain, service, protocol, callback):
        request = ("resolve_srv", (domain, service, protocol, callback))
        self._start_thread()
        self.queue.put(request)

    def _run(self, thread_n):
        """The thread function."""
        try:
            logger.debug("{0!r}: entering thread #{1}"
                                                .format(self, thread_n))
            resolver = self._make_resolver()
            while True:
                request = self.queue.get()
                if request is None:
                    break
                method, args = request
                logger.debug(" calling {0!r}.{1}{2!r}"
                                            .format(resolver, method, args))
                getattr(resolver, method)(*args) # pylint: disable=W0142
                self.queue.task_done()
            logger.debug("{0!r}: leaving thread #{1}"
                                                .format(self, thread_n))
        finally:
            self.threads.remove(threading.currentThread())

class DumbBlockingResolver(Resolver):
    """Simple blocking resolver using only the standard Python library.

    This doesn't support SRV lookups!

    `resolve_srv` will raise NotImplementedError
    `resolve_address` will block until the lookup completes or fail and then
    call the callback immediately.
    """
    # pylint: disable-msg=R0921
    def __init__(self, settings = None):
        if settings:
            self.settings = settings
        else:
            self.settings = XMPPSettings()

    def resolve_srv(self, domain, service, protocol, callback):
        raise NotImplementedError("The DumbBlockingResolver cannot resolve"
                " SRV records. DNSPython or target hostname explicitely set"
                                                                " required")

    def resolve_address(self, hostname, callback, allow_cname = True):
        """Start looking up an A or AAAA record.

        `callback` will be called with a list of (family, address) tuples
        on success. Family is :std:`socket.AF_INET` or :std:`socket.AF_INET6`,
        the address is IPv4 or IPv6 literal. The list will be empty on error.

        :Parameters:
            - `hostname`: the host name to look up
            - `callback`: a function to be called with a list of received
              addresses
            - `allow_cname`: `True` if CNAMEs should be followed
        :Types:
            - `hostname`: `unicode`
            - `callback`: function accepting a single argument
            - `allow_cname`: `bool`
        """
        if self.settings["ipv6"]:
            if self.settings["ipv4"]:
                family = socket.AF_UNSPEC
            else:
                family = socket.AF_INET6
        elif self.settings["ipv4"]:
            family = socket.AF_INET
        else:
            logger.warning("Neither IPv6 or IPv4 allowed.")
            callback([])
            return
        try:
            ret = socket.getaddrinfo(hostname, 0, family, socket.SOCK_STREAM, 0)
        except socket.gaierror, err:
            logger.warning("Couldn't resolve {0!r}: {1}".format(hostname,
                                                                        err))
            callback([])
            return
        except IOError as err:
            logger.warning("Couldn't resolve {0!r}, unexpected error: {1}"
                                                        .format(hostname,err))
            callback([])
            return
        if family == socket.AF_UNSPEC:
            tmp = ret
            if self.settings["prefer_ipv6"]:
                ret = [ addr for addr in tmp if addr[0] == socket.AF_INET6 ]
                ret += [ addr for addr in tmp if addr[0] == socket.AF_INET ]
            else:
                ret = [ addr for addr in tmp if addr[0] == socket.AF_INET ]
                ret += [ addr for addr in tmp if addr[0] == socket.AF_INET6 ]
        callback([(addr[0], addr[4][0]) for addr in ret])


if HAVE_DNSPYTHON:
    class BlockingResolver(Resolver):
        """Blocking resolver using the DNSPython package.

        Both `resolve_srv` and `resolve_address` will block until the
        lookup completes or fail and then call the callback immediately.
        """
        def __init__(self, settings =  None):
            if settings:
                self.settings = settings
            else:
                self.settings = XMPPSettings()

        def resolve_srv(self, domain, service, protocol, callback):
            """Start looking up an SRV record for `service` at `domain`.

            `callback` will be called with a properly sorted list of (hostname,
            port) pairs on success. The list will be empty on error and it will
            contain only (".", 0) when the service is explicitely disabled.

            :Parameters:
                - `domain`: domain name to look up
                - `service`: service name e.g. 'xmpp-client'
                - `protocol`: protocol name, e.g. 'tcp'
                - `callback`: a function to be called with a list of received
                  addresses
            :Types:
                - `domain`: `unicode`
                - `service`: `unicode`
                - `protocol`: `unicode`
                - `callback`: function accepting a single argument
            """
            if isinstance(domain, unicode):
                domain = domain.encode("idna").decode("us-ascii")
            domain = "_{0}._{1}.{2}".format(service, protocol, domain)
            try:
                records = dns.resolver.query(domain, 'SRV')
            except dns.exception.DNSException, err:
                logger.warning("Could not resolve {0!r}: {1}"
                                    .format(domain, err.__class__.__name__))
                callback([])
                return
            if not records:
                callback([])
                return

            result = []
            for record in reorder_srv(records):
                hostname = record.target.to_text()
                if hostname in (".", ""):
                    continue
                result.append((hostname, record.port))

            if not result:
                callback([(".", 0)])
            else:
                callback(result)
            return

        def resolve_address(self, hostname, callback, allow_cname = True):
            """Start looking up an A or AAAA record.

            `callback` will be called with a list of (family, address) tuples
            (each holiding socket.AF_*  and IPv4 or IPv6 address literal) on
            success. The list will be empty on error.

            :Parameters:
                - `hostname`: the host name to look up
                - `callback`: a function to be called with a list of received
                  addresses
                - `allow_cname`: `True` if CNAMEs should be followed
            :Types:
                - `hostname`: `unicode`
                - `callback`: function accepting a single argument
                - `allow_cname`: `bool`
            """
            if isinstance(hostname, unicode):
                hostname = hostname.encode("idna").decode("us-ascii")
            rtypes = []
            if self.settings["ipv6"]:
                rtypes.append(("AAAA", socket.AF_INET6))
            if self.settings["ipv4"]:
                rtypes.append(("A", socket.AF_INET))
            if not self.settings["prefer_ipv6"]:
                rtypes.reverse()
            exception = None
            result = []
            for rtype, rfamily in rtypes:
                try:
                    try:
                        records = dns.resolver.query(hostname, rtype)
                    except dns.exception.DNSException:
                        records = dns.resolver.query(hostname + ".", rtype)
                except dns.exception.DNSException, err:
                    exception = err
                    continue
                if not allow_cname and records.rrset.name != dns.name.from_text(
                                                                    hostname):
                    logger.warning("Unexpected CNAME record found for {0!r}"
                                                            .format(hostname))
                    continue
                if records:
                    for record in records:
                        result.append((rfamily, record.to_text()))

            if not result and exception:
                logger.warning("Could not resolve {0!r}: {1}".format(hostname,
                                                exception.__class__.__name__))
            callback(result)

    class ThreadedResolver(ThreadedResolverBase):
        """Threaded resolver implementation using the DNSPython
        :dns:`dns.resolver` module.
        """
        def _make_resolver(self):
            return BlockingResolver(self.settings)

    _DEFAULT_RESOLVER = BlockingResolver
else:
    _DEFAULT_RESOLVER = DumbBlockingResolver

XMPPSettings.add_setting(u"dns_resolver", type = Resolver,
        factory = _DEFAULT_RESOLVER,
        default_d = "A `{0}` instance".format(_DEFAULT_RESOLVER.__name__),
        doc = u"""The DNS resolver implementation to be used by PyXMPP."""
    )
XMPPSettings.add_setting(u"ipv4", type = bool, default = True,
        cmdline_help = "Allow IPv4 address lookup",
        doc = u"""Look up IPv4 addresses for a server host name."""
    )
XMPPSettings.add_setting(u"ipv6", type = bool, basic = True,
        factory = lambda x: is_ipv6_available(), cache = True,
        cmdline_help = "Allow IPv6 address lookup",
        doc = u"""Look up IPv6 addresses for a server host name."""
    )
XMPPSettings.add_setting(u"prefer_ipv6", type = bool, basic = True,
        default = True,
        cmdline_help = "Prefer IPv6",
        doc = u"""When enabled IPv6 and connecting to a dual-stack XMPP server
IPv6 addresses will be tried first."""
    )

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = roster
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""XMPP-IM roster handling.

This module provides a `Roster` class representing the roster (XMPP contact
list), a `RosterClient` class for requesting the roster and manipulating
the roster on server and related clases (`RosterItem`, `RosterPayload`).

The roster contains JIDs of the contacts, their display names, names of the
groups they belong to and presence subscription information.

The interface provided by this module can be used to add  and remove items
in the roster and to change the name and group infromation of the items,
however the presence subscription should be managed by different means (handling
of the `Presence` stanzas) and the `Roster` object provides only the current
subscription state information.

Normative reference:
  - :RFC:`6121`
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import logging

from collections import Sequence, Mapping

from .etree import ElementTree
from .settings import XMPPSettings
from .jid import JID
from .iq import Iq
from .interfaces import XMPPFeatureHandler
from .interfaces import iq_set_stanza_handler
from .interfaces import StanzaPayload, payload_element_name
from .interfaces import EventHandler, event_handler, Event
from .interfaces import NO_CHANGE
from .streamevents import AuthorizedEvent, GotFeaturesEvent
from .exceptions import BadRequestProtocolError, NotAcceptableProtocolError

logger = logging.getLogger("pyxmpp2.roster")

ROSTER_NS = u"jabber:iq:roster"
ROSTER_QNP = u"{{{0}}}".format(ROSTER_NS)
QUERY_TAG = ROSTER_QNP + u"query"
ITEM_TAG = ROSTER_QNP + u"item"
GROUP_TAG = ROSTER_QNP + u"group"
FEATURE_ROSTERVER = "{urn:xmpp:features:rosterver}ver"
FEATURE_APPROVALS = "{urn:xmpp:features:pre-approval}sub"

class RosterReceivedEvent(Event):
    """Event emitted when roster is received from server.

    :Ivariables:
        - `roster_client`: roster client object that emitted this event
        - `roster`: the roster received
    :Types:
        - `roster_client`: `RosterClient`
        - `roster`: `Roster`
    """
    # pylint: disable=R0903
    def __init__(self, roster_client, roster):
        self.roster_client = roster_client
        self.roster = roster

    def __unicode__(self):
        return u"Roster received ({0} items)".format(len(self.roster))

class RosterUpdatedEvent(Event):
    """Event emitted when roster update is received.

    :Ivariables:
        - `roster_client`: roster client object that emitted this event
        - `item`: the update received
    :Types:
        - `roster_client`: `RosterClient`
        - `item`: `RosterItem`
    """
    # pylint: disable=R0903
    def __init__(self, roster_client, old_item, item):
        self.roster_client = roster_client
        self.old_item = old_item
        self.item = item

    def __unicode__(self):
        return u"Roster update received for: {0}".format(self.item.jid)

class RosterNotReceivedEvent(Event):
    """Event emitted when a roster request fails.

    :Ivariables:
        - `roster_client`: roster client object that emitted this event
        - `stanza`: the invalid or error stanza received, `None` in case of
          time-out.
    :Types:
        - `roster_client`: `RosterClient`
        - `stanza`: `Stanza`
    """
    # pylint: disable=R0903
    def __init__(self, roster_client, stanza):
        self.roster_client = roster_client
        self.stanza = stanza

    def __unicode__(self):
        if self.stanza is None:
            return u"Roster fetch fail (timeout)"
        if self.stanza.stanza_type == u"error":
            cond = self.stanza.error.condition_name
            text = self.stanza.error.text
            if text:
                return u"Roster fetch fail: {0} ({1})".format(cond, text)
            else:
                return u"Roster fetch fail: {0}".format(cond)
        else:
            return u"Roster fetch fail: invalid response from server"

class RosterItem(object):
    """
    Roster item.

    Represents part of a roster, or roster update request.

    :Ivariables:
        - `jid`: the JID
        - `name`: visible name
        - `groups`: roster groups the item belongs to
        - `subscription`: subscription type (None, "to", "from", "both",
                                                                or "remove")
        - `ask`: "subscribe" if there was unreplied subsription request sent
        - `approved`: `True` if the entry subscription is pre-approved
    :Types:
        - `jid`: `JID`
        - `name`: `unicode`
        - `groups`: `set` of `unicode`
        - `subscription`: `unicode`
        - `ask`: `unicode`
        - `approved`: `bool`
    """
    def __init__(self, jid, name = None, groups = None,
                            subscription = None, ask = None, approved = None):
        """
        Initialize a roster item element.

        :Parameters:
            - `jid`: entry jid
            - `name`: item visible name
            - `groups`: iterable of groups the item is member of
            - `subscription`: subscription type (None, "to", "from", "both"
                                                                    or "remove")
            - `ask`: "subscribe" if there was unreplied subscription request
              sent
            - `approved`: `True` if the entry subscription is pre-approved
        """
        # pylint: disable=R0913
        self.jid = JID(jid)
        if name is not None:
            self.name = unicode(name)
        else:
            self.name = None
        if groups is not None:
            self.groups = set(groups)
        else:
            self.groups = set()
        if subscription == u"none":
            subscription = None
        # no verify because of RFC 6121, section 2.1.2.5 (client MUST ignore...)
        self.subscription = subscription
        if ask is not None:
            self.ask = ask
        else:
            self.ask = None
        self.approved = bool(approved)
        self._duplicate_group = False

    @classmethod
    def from_xml(cls, element):
        """Make a RosterItem from an XML element.

        :Parameters:
            - `element`: the XML element
        :Types:
            - `element`: :etree:`ElementTree.Element`

        :return: a freshly created roster item
        :returntype: `cls`
        """
        if element.tag != ITEM_TAG:
            raise ValueError("{0!r} is not a roster item".format(element))
        try:
            jid = JID(element.get("jid"))
        except ValueError:
            raise BadRequestProtocolError(u"Bad item JID")
        subscription = element.get("subscription")
        ask = element.get("ask")
        name = element.get("name")
        duplicate_group = False
        groups = set()
        for child in element:
            if child.tag != GROUP_TAG:
                continue
            group = child.text
            if group is None:
                group = u""
            if group in groups:
                duplicate_group = True
            else:
                groups.add(group)
        approved = element.get("approved")
        if approved == "true":
            approved = True
        elif approved in ("false", None):
            approved = False
        else:
            logger.debug("RosterItem.from_xml: got unknown 'approved':"
                            " {0!r}, changing to False".format(approved))
            approved = False
        result = cls(jid, name, groups, subscription, ask, approved)
        result._duplicate_group = duplicate_group
        return result

    def as_xml(self, parent = None):
        """Make an XML element from self.

        :Parameters:
            - `parent`: Parent element
        :Types:
            - `parent`: :etree:`ElementTree.Element`
        """
        if parent is not None:
            element = ElementTree.SubElement(parent, ITEM_TAG)
        else:
            element = ElementTree.Element(ITEM_TAG)
        element.set("jid", unicode(self.jid))
        if self.name is not None:
            element.set("name", self.name)
        if self.subscription is not None:
            element.set("subscription", self.subscription)
        if self.ask:
            element.set("ask", self.ask)
        if self.approved:
            element.set("approved", "true")
        for group in self.groups:
            ElementTree.SubElement(element, GROUP_TAG).text = group
        return element

    def _verify(self, valid_subscriptions, fix):
        """Check if `self` is valid roster item.

        Valid item must have proper `subscription` and valid value for 'ask'.

        :Parameters:
            - `valid_subscriptions`: sequence of valid subscription values
            - `fix`: if `True` than replace invalid 'subscription' and 'ask'
              values with the defaults
        :Types:
            - `fix`: `bool`

        :Raise: `ValueError` if the item is invalid.
        """
        if self.subscription not in valid_subscriptions:
            if fix:
                logger.debug("RosterItem.from_xml: got unknown 'subscription':"
                        " {0!r}, changing to None".format(self.subscription))
                self.subscription = None
            else:
                raise ValueError("Bad 'subscription'")
        if self.ask not in (None, u"subscribe"):
            if fix:
                logger.debug("RosterItem.from_xml: got unknown 'ask':"
                                " {0!r}, changing to None".format(self.ask))
                self.ask = None
            else:
                raise ValueError("Bad 'ask'")

    def verify_roster_result(self, fix = False):
        """Check if `self` is valid roster item.

        Valid item must have proper `subscription` value other than 'remove'
        and valid value for 'ask'.

        :Parameters:
            - `fix`: if `True` than replace invalid 'subscription' and 'ask'
              values with the defaults
        :Types:
            - `fix`: `bool`

        :Raise: `ValueError` if the item is invalid.
        """
        self._verify((None, u"from", u"to", u"both"), fix)

    def verify_roster_push(self, fix = False):
        """Check if `self` is valid roster push item.

        Valid item must have proper `subscription` value other and valid value
        for 'ask'.

        :Parameters:
            - `fix`: if `True` than replace invalid 'subscription' and 'ask'
              values with the defaults
        :Types:
            - `fix`: `bool`

        :Raise: `ValueError` if the item is invalid.
        """
        self._verify((None, u"from", u"to", u"both", u"remove"), fix)

    def verify_roster_set(self, fix = False, settings = None):
        """Check if `self` is valid roster set item.

        For use on server to validate incoming roster sets.

        Valid item must have proper `subscription` value other and valid value
        for 'ask'. The lengths of name and group names must fit the configured
        limits.

        :Parameters:
            - `fix`: if `True` than replace invalid 'subscription' and 'ask'
              values with right defaults
            - `settings`: settings object providing the name limits
        :Types:
            - `fix`: `bool`
            - `settings`: `XMPPSettings`

        :Raise: `BadRequestProtocolError` if the item is invalid.
        """
        # pylint: disable=R0912
        try:
            self._verify((None, u"remove"), fix)
        except ValueError, err:
            raise BadRequestProtocolError(unicode(err))
        if self.ask:
            if fix:
                self.ask = None
            else:
                raise BadRequestProtocolError("'ask' in roster set")
        if self.approved:
            if fix:
                self.approved = False
            else:
                raise BadRequestProtocolError("'approved' in roster set")
        if settings is None:
            settings = XMPPSettings()
        name_length_limit = settings["roster_name_length_limit"]
        if self.name and len(self.name) > name_length_limit:
            raise NotAcceptableProtocolError(u"Roster item name too long")
        group_length_limit = settings["roster_group_name_length_limit"]
        for group in self.groups:
            if not group:
                raise NotAcceptableProtocolError(u"Roster group name empty")
            if len(group) > group_length_limit:
                raise NotAcceptableProtocolError(u"Roster group name too long")
        if self._duplicate_group:
            raise BadRequestProtocolError(u"Item group duplicated")

    def __repr__(self):
        return "<RosterItem {0!r}>".format(unicode(self.jid))

@payload_element_name(QUERY_TAG)
class RosterPayload(StanzaPayload, Sequence):
    """<query/> element carried via a roster Iq stanza.

    Can contain a single item or whole roster with optional version
    information.

    len(), "in" and [] work like for a sequence of roster items.

    :Ivariables:
        - `version`: the version attribute
        - `_items`: roster item list
    :Types:
        - `_items`: `list` of `RosterItem`
    """
    def __init__(self, items = None, version = None):
        """
        :Parameters:
            - `items`: sequence of roster items
            - `version`: optional roster version string
        :Types:
            - `items`: iterable
            - `version`: `unicode`
        """
        if items is not None:
            self._items = list(items)
        else:
            self._items = []
        self.version = version

    @classmethod
    def from_xml(cls, element):
        """
        Create a `RosterPayload` object from an XML element.

        :Parameters:
            - `element`: the XML element
        :Types:
            - `element`: :etree:`ElementTree.Element`

        :return: a freshly created roster payload
        :returntype: `cls`
        """
        # pylint: disable-msg=W0221
        items = []
        jids = set()
        if element.tag != QUERY_TAG:
            raise ValueError("{0!r} is not a roster item".format(element))
        version = element.get("ver")
        for child in element:
            if child.tag != ITEM_TAG:
                logger.debug("Unknown element in roster: {0!r}".format(child))
                continue
            item = RosterItem.from_xml(child)
            if item.jid in jids:
                logger.warning("Duplicate jid in roster: {0!r}".format(
                                                                    item.jid))
                continue
            jids.add(item.jid)
            items.append(item)
        return cls(items, version)

    def as_xml(self):
        """Return the XML representation of roster payload.

        Makes a <query/> element with <item/> children.
        """
        element = ElementTree.Element(QUERY_TAG)
        if self.version is not None:
            element.set("ver", self.version)
        for item in self._items:
            item.as_xml(element)
        return element

    def __iter__(self):
        return iter(self._items)

    def __len__(self):
        return len(self._items)

    def __getitem__(self, index):
        return self._items[index]

    def __eq__(self, other):
        # pylint: disable=W0212
        if not isinstance(other, RosterPayload):
            return False
        return set(self._items) == set(other._items)

    def __ne__(self, other):
        return not self.__eq__(other)

    def items(self):
        """Return the roster items.

        :Returntype: iterable of `RosterType`
        """
        return self._items

class Roster(RosterPayload, Mapping):
    """Represents the XMPP roster (contact list).

    Works like an ordered JID->RosterItem dictionary with a few exceptions:

        - the `items()` method returns roster items (values), not JIDs (keys)
        - for [] or get() a JID or a numeric index can be used

    Please note that changes to this object do not automatically affect
    any remote copy of the roster.

    :Ivariables:
        - `_jids`: jid -> item index dictionary
    :Types:
        - `_jids`: `dict` of `JID` -> `int`
    """
    def __init__(self, items = None, version = None):
        if items:
            for item in items:
                if item.subscription == "remove":
                    raise ValueError("Roster item subscription cannot be"
                                                                " 'remove'")
        RosterPayload.__init__(self, items, version)
        self._jids = dict((item.jid, i) for i, item in enumerate(self._items))
        if len(self._items) != len(self._jids):
            raise ValueError(u"Duplicate JIDs")

    @classmethod
    def from_xml(cls, element):
        try:
            return super(Roster, cls).from_xml(element)
        except ValueError, err:
            raise BadRequestProtocolError(unicode(err))

    def __contains__(self, value):
        if isinstance(value, JID):
            return value in self._jids
        else:
            return RosterPayload.__contains__(self, value)

    def __getitem__(self, key):
        if isinstance(key, int):
            return RosterPayload.__getitem__(self, key)
        elif isinstance(key, JID):
            jid = self._jids[key]
            return self._items[jid]
        else:
            raise TypeError("Roster items may be indexed by int or JID only")

    def keys(self):
        """Return the JIDs in the roster.

        :Returntype: iterable of `JID`
        """
        return self._jids.keys()

    def values(self):
        """Return the roster items.

        :Returntype: iterable of `RosterType`
        """
        return self._items

    items = values

    @property
    def groups(self):
        """Set of groups defined in the roster.

        :Return: the groups
        :ReturnType: `set` of `unicode`
        """
        groups = set()
        for item in self._items:
            groups |= item.groups
        return groups

    def get_items_by_name(self, name, case_sensitive = True):
        """
        Return a list of items with given name.

        :Parameters:
            - `name`: name to look-up
            - `case_sensitive`: if `False` the matching will be case
              insensitive.
        :Types:
            - `name`: `unicode`
            - `case_sensitive`: `bool`

        :Returntype: `list` of `RosterItem`
        """
        if not case_sensitive and name:
            name = name.lower()
        result = []
        for item in self._items:
            if item.name == name:
                result.append(item)
            elif item.name is None:
                continue
            elif not case_sensitive and item.name.lower() == name:
                result.append(item)
        return result

    def get_items_by_group(self, group, case_sensitive = True):
        """
        Return a list of items within a given group.

        :Parameters:
            - `name`: name to look-up
            - `case_sensitive`: if `False` the matching will be case
              insensitive.
        :Types:
            - `name`: `unicode`
            - `case_sensitive`: `bool`

        :Returntype: `list` of `RosterItem`
        """
        result = []
        if not group:
            for item in self._items:
                if not item.groups:
                    result.append(item)
            return result
        if not case_sensitive:
            group = group.lower()
        for item in self._items:
            if group in item.groups:
                result.append(item)
            elif not case_sensitive and group in [g.lower() for g
                                                            in item.groups]:
                result.append(item)
        return result

    def add_item(self, item, replace = False):
        """
        Add an item to the roster.

        This will not automatically update the roster on the server.

        :Parameters:
            - `item`: the item to add
            - `replace`: if `True` then existing item will be replaced,
              otherwise a `ValueError` will be raised on conflict
        :Types:
            - `item`: `RosterItem`
            - `replace`: `bool`
        """
        if item.jid in self._jids:
            if replace:
                self.remove_item(item.jid)
            else:
                raise ValueError("JID already in the roster")
        index = len(self._items)
        self._items.append(item)
        self._jids[item.jid] = index

    def remove_item(self, jid):
        """Remove item from the roster.

        :Parameters:
            - `jid`: JID of the item to remove
        :Types:
            - `jid`: `JID`
        """
        if jid not in self._jids:
            raise KeyError(jid)
        index = self._jids[jid]
        for i in range(index, len(self._jids)):
            self._jids[self._items[i].jid] -= 1
        del self._jids[jid]
        del self._items[index]

class RosterClient(XMPPFeatureHandler, EventHandler):
    """Client side implementation of the roster management (:RFC:`6121`,
    section 2.)

    :Parameters:
        - `settings`: roster client settings
        - `roster`: the roster
        - `server`: roster server JID (usually the domain part of user JID)
        - `server_features`: set of features supported by the server. May
          contain ``"versioning"`` and ``"pre-approvals"``
        - `_event_queue`: the event queue
    :Types:
        - `settings`: `XMPPSettings`
        - `roster`: `Roster`
        - `server`: `JID`
        - `server_features`: `set` of `unicode`
        - `_event_queue`: :std:`Queue.Queue`
    """
    def __init__(self, settings = None):
        self.settings = settings if settings else XMPPSettings()
        self.roster = None
        self.server = None
        self._event_queue = self.settings["event_queue"]
        self.server_features = set()

    def load_roster(self, source):
        """Load roster from an XML file.

        Can be used before the connection is started to load saved
        roster copy, for efficient retrieval of versioned roster.

        :Parameters:
            - `source`: file name or a file object
        :Types:
            - `source`: `str` or file-like object
        """
        try:
            tree = ElementTree.parse(source)
        except ElementTree.ParseError, err:
            raise ValueError("Invalid roster format: {0}".format(err))
        roster = Roster.from_xml(tree.getroot())
        for item in roster:
            item.verify_roster_result(True)
        self.roster = roster

    def save_roster(self, dest, pretty = True):
        """Save the roster to an XML file.

        Can be used to save the last know roster copy for faster loading
        of a verisoned roster (if server supports that).

        :Parameters:
            - `dest`: file name or a file object
            - `pretty`: pretty-format the roster XML
        :Types:
            - `dest`: `str` or file-like object
            - `pretty`: `bool`
        """
        if self.roster is None:
            raise ValueError("No roster")
        element = self.roster.as_xml()
        if pretty:
            if len(element):
                element.text = u'\n  '
            p_child = None
            for child in element:
                if p_child is not None:
                    p_child.tail = u'\n  '
                if len(child):
                    child.text = u'\n    '
                p_grand = None
                for grand in child:
                    if p_grand is not None:
                        p_grand.tail = u'\n    '
                    p_grand = grand
                if p_grand is not None:
                    p_grand.tail = u'\n  '
                p_child = child
            if p_child is not None:
                p_child.tail = u"\n"
        tree = ElementTree.ElementTree(element)
        tree.write(dest, "utf-8")

    @event_handler(GotFeaturesEvent)
    def handle_got_features_event(self, event):
        """Check for roster related features in the stream features received
        and set `server_features` accordingly.
        """
        server_features = set()
        logger.debug("Checking roster-related features")
        if event.features.find(FEATURE_ROSTERVER) is not None:
            logger.debug("  Roster versioning available")
            server_features.add("versioning")
        if event.features.find(FEATURE_APPROVALS) is not None:
            logger.debug("  Subscription pre-approvals available")
            server_features.add("pre-approvals")
        self.server_features = server_features

    @event_handler(AuthorizedEvent)
    def handle_authorized_event(self, event):
        """Request roster upon login."""
        self.server = event.authorized_jid.bare()
        if "versioning" in self.server_features:
            if self.roster is not None and self.roster.version is not None:
                version = self.roster.version
            else:
                version = u""
        else:
            version = None
        self.request_roster(version)

    def request_roster(self, version = None):
        """Request roster from server.

        :Parameters:
            - `version`: if not `None` versioned roster will be requested
              for given local version. Use "" to request full roster.
        :Types:
            - `version`: `unicode`
        """
        processor = self.stanza_processor
        request = Iq(stanza_type = "get")
        request.set_payload(RosterPayload(version = version))
        processor.set_response_handlers(request,
                                    self._get_success, self._get_error)
        processor.send(request)

    def _get_success(self, stanza):
        """Handle successful response to the roster request.
        """
        payload = stanza.get_payload(RosterPayload)
        if payload is None:
            if "versioning" in self.server_features and self.roster:
                logger.debug("Server will send roster delta in pushes")
            else:
                logger.warning("Bad roster response (no payload)")
                self._event_queue.put(RosterNotReceivedEvent(self, stanza))
                return
        else:
            items = list(payload)
            for item in items:
                item.verify_roster_result(True)
            self.roster = Roster(items, payload.version)
        self._event_queue.put(RosterReceivedEvent(self, self.roster))

    def _get_error(self, stanza):
        """Handle failure of the roster request.
        """
        if stanza:
            logger.debug(u"Roster request failed: {0}".format(
                                                stanza.error.condition_name))
        else:
            logger.debug(u"Roster request failed: timeout")
        self._event_queue.put(RosterNotReceivedEvent(self, stanza))

    @iq_set_stanza_handler(RosterPayload)
    def handle_roster_push(self, stanza):
        """Handle a roster push received from server.
        """
        if self.server is None and stanza.from_jid:
            logger.debug(u"Server address not known, cannot verify roster push"
                                " from {0}".format(stanza.from_jid))
            return stanza.make_error_response(u"service-unavailable")
        if self.server and stanza.from_jid and stanza.from_jid != self.server:
            logger.debug(u"Roster push from invalid source: {0}".format(
                                                            stanza.from_jid))
            return stanza.make_error_response(u"service-unavailable")
        payload = stanza.get_payload(RosterPayload)
        if len(payload) != 1:
            logger.warning("Bad roster push received ({0} items)"
                                                    .format(len(payload)))
            return stanza.make_error_response(u"bad-request")
        if self.roster is None:
            logger.debug("Dropping roster push - no roster here")
            return True
        item = payload[0]
        item.verify_roster_push(True)
        old_item = self.roster.get(item.jid)
        if item.subscription == "remove":
            if old_item:
                self.roster.remove_item(item.jid)
        else:
            self.roster.add_item(item, replace = True)
        self._event_queue.put(RosterUpdatedEvent(self, old_item, item))
        return stanza.make_result_response()

    def add_item(self, jid, name = None, groups = None,
                                callback = None, error_callback = None):
        """Add a contact to the roster.

        :Parameters:
            - `jid`: contact's jid
            - `name`: name for the contact
            - `groups`: sequence of group names the contact should belong to
            - `callback`: function to call when the request succeeds. It should
              accept a single argument - a `RosterItem` describing the
              requested change
            - `error_callback`: function to call when the request fails. It
              should accept a single argument - an error stanza received
              (`None` in case of timeout)
        :Types:
            - `jid`: `JID`
            - `name`: `unicode`
            - `groups`: sequence of `unicode`
        """
        # pylint: disable=R0913
        if jid in self.roster:
            raise ValueError("{0!r} already in the roster".format(jid))
        item = RosterItem(jid, name, groups)
        self._roster_set(item, callback, error_callback)

    def update_item(self, jid, name = NO_CHANGE, groups = NO_CHANGE,
                                callback = None, error_callback = None):
        """Modify a contact in the roster.

        :Parameters:
            - `jid`: contact's jid
            - `name`: a new name for the contact
            - `groups`: a sequence of group names the contact should belong to
            - `callback`: function to call when the request succeeds. It should
              accept a single argument - a `RosterItem` describing the
              requested change
            - `error_callback`: function to call when the request fails. It
              should accept a single argument - an error stanza received
              (`None` in case of timeout)
        :Types:
            - `jid`: `JID`
            - `name`: `unicode`
            - `groups`: sequence of `unicode`
        """
        # pylint: disable=R0913
        item = self.roster[jid]
        if name is NO_CHANGE and groups is NO_CHANGE:
            return
        if name is NO_CHANGE:
            name = item.name
        if groups is NO_CHANGE:
            groups = item.groups
        item = RosterItem(jid, name, groups)
        self._roster_set(item, callback, error_callback)

    def remove_item(self, jid, callback = None, error_callback = None):
        """Remove a contact from the roster.

        :Parameters:
            - `jid`: contact's jid
            - `callback`: function to call when the request succeeds. It should
              accept a single argument - a `RosterItem` describing the
              requested change
            - `error_callback`: function to call when the request fails. It
              should accept a single argument - an error stanza received
              (`None` in case of timeout)
        :Types:
            - `jid`: `JID`
        """
        item = self.roster[jid]
        if jid not in self.roster:
            raise KeyError(jid)
        item = RosterItem(jid, subscription = "remove")
        self._roster_set(item, callback, error_callback)

    def _roster_set(self, item, callback, error_callback):
        """Send a 'roster set' to the server.

        :Parameters:
            - `item`: the requested change
        :Types:
            - `item`: `RosterItem`
        """
        stanza = Iq(to_jid = self.server, stanza_type = "set")
        payload = RosterPayload([item])
        stanza.set_payload(payload)
        def success_cb(result_stanza):
            """Success callback for roster set."""
            if callback:
                callback(item)
        def error_cb(error_stanza):
            """Error callback for roster set."""
            if error_callback:
                error_callback(error_stanza)
            else:
                logger.error("Roster change of '{0}' failed".format(item.jid))
        processor = self.stanza_processor
        processor.set_response_handlers(stanza,
                                    success_cb, error_cb)
        processor.send(stanza)

XMPPSettings.add_setting(u"roster_name_length_limit", type = int,
        default = 1023,
        doc = u"""Maximum length of roster item name."""
    )
XMPPSettings.add_setting(u"roster_group_name_length_limit", type = int,
        default = 1023,
        doc = u"""Maximum length of roster group name."""
    )

########NEW FILE########
__FILENAME__ = core
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
"""Base classes for PyXMPP SASL implementation.

Normative reference:
  - `RFC 4422 <http://www.ietf.org/rfc/rfc4422.txt>`__


Authentication properties
-------------------------

Most authentication mechanisms needs some data to identify the
authenticating entity and/or to provide characteristics of the communication
channel. These are passed as a `properties` mapping to the ``.start()``
method to a server or client authenticator.

Similar mechanism is used to return data obtained via the authentication
process: the `Success` object has a `Success.properties` attribute with
the data obtained.

The mapping contains name->value pairs. Meaning of those is generally
mechanism-dependant, but these are the usually expected properties:

  * For input to the ``start()`` method:

    * ``"username"`` - the user name. Required by all password based mechanisms.
    * ``"password"`` - the user's password.  Required by all password based
      mechanisms.
    * ``"authzid"`` - authorization id. Optional for most mechanisms.
    * ``"security-layer"`` - security layer if any. ``"TLS"`` when TLS is in
      use.
    * ``"channel-binding"`` - mapping of 'channel binding type' to 'channel
      binding date' if available on the channel
    * ``"service-type"`` - service type as required by the DIGEST-MD5 protocol
    * ``"service-domain"`` - service domain (the 'serv-name' or 'host' part of
      diges-uri of DIGEST-MD5)
    * ``"service-hostname"`` - service host name (the 'host' par of diges-uri
      of DIGEST-MD5)
    * ``"remote-ip"`` - remote IP address
    * ``"realm"`` - the realm to use if needed
    * ``"realms"`` - list of acceptable realms
    * ``"available_mechanisms"`` - mechanism list provided by peer
    * ``"enabled_mechanisms"`` - mechanisms enabled on our side

  * For output, via the `Success.properties` attribute:

    * ``"username"`` - the authenticated user name
    * ``"authzid"`` - the authorization id
    * ``"realm"`` - the realm

"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import uuid
import hashlib
import logging

from base64 import standard_b64encode

from abc import ABCMeta, abstractmethod

try:
    # pylint: disable=E0611
    from abc import abstractclassmethod
except ImportError:
    # pylint: disable=C0103
    abstractclassmethod = classmethod

logger = logging.getLogger("pyxmpp2.sasl.core")

CLIENT_MECHANISMS_D = {}
CLIENT_MECHANISMS = []
SECURE_CLIENT_MECHANISMS = []

SERVER_MECHANISMS_D = {}
SERVER_MECHANISMS = []
SECURE_SERVER_MECHANISMS = []

class PasswordDatabase:
    """Password database interface.

    PasswordDatabase object is responsible for providing or verification of
    user authentication credentials on a server.

    All the methods of the `PasswordDatabase` may be overridden in derived
    classes for specific authentication and authorization policy.
    """
    # pylint: disable-msg=W0232,R0201
    __metaclass__ = ABCMeta
    def get_password(self, username, acceptable_formats, properties):
        """Get the password for user authentication.

        By default returns (None, None) providing no password. Should be
        overridden in derived classes unless only `check_password` functionality
        is available.

        :Parameters:
            - `username`: the username for which the password is requested.
            - `acceptable_formats`: a sequence of acceptable formats of the
              password data. Could be "plain" (plain text password),
              "md5:user:realm:password" (MD5 hex digest of user:realm:password)
              or any other mechanism-specific encoding. This allows
              non-plain-text storage of passwords. But only "plain" format will
              work with all password authentication mechanisms.
            - `properties`: mapping with authentication properties (those
              provided to the authenticator's ``start()`` method plus some
              already obtained via the mechanism).
        :Types:
            - `username`: `unicode`
            - `acceptable_formats`: sequence of `unicode`
            - `properties`: mapping

        :return: the password and its encoding (format).
        :returntype: `unicode`,`unicode` tuple.
        """
        # pylint: disable-msg=W0613
        return None, None

    def check_password(self, username, password, properties):
        """Check the password validity.

        Used by plain-text authentication mechanisms.

        Default implementation: retrieve a "plain" password for the `username`
        and `realm` using `self.get_password` and compare it with the password
        provided.

        May be overridden e.g. to check the password against some external
        authentication mechanism (PAM, LDAP, etc.).

        :Parameters:
            - `username`: the username for which the password verification is
              requested.
            - `password`: the password to verify.
            - `properties`: mapping with authentication properties (those
              provided to the authenticator's ``start()`` method plus some
              already obtained via the mechanism).
        :Types:
            - `username`: `unicode`
            - `password`: `unicode`
            - `properties`: mapping

        :return: `True` if the password is valid.
        :returntype: `bool`
        """
        logger.debug("check_password{0!r}".format(
                                            (username, password, properties)))
        pwd, pwd_format = self.get_password(username,
                    (u"plain", u"md5:user:realm:password"), properties)
        if pwd_format == u"plain":
            logger.debug("got plain password: {0!r}".format(pwd))
            return pwd is not None and password == pwd
        elif pwd_format in (u"md5:user:realm:password"):
            logger.debug("got md5:user:realm:password password: {0!r}"
                                                            .format(pwd))
            realm = properties.get("realm")
            if realm is None:
                realm = ""
            else:
                realm = realm.encode("utf-8")
            username = username.encode("utf-8")
            password = password.encode("utf-8")

            # pylint: disable-msg=E1101
            urp_hash = hashlib.md5(b"%s:%s:%s").hexdigest()
            return urp_hash == pwd
        logger.debug("got password in unknown format: {0!r}".format(pwd_format))
        return False


def default_nonce_factory():
    """Generate a random string for digest authentication challenges.

    The string should be cryptographicaly secure random pattern.

    :return: the string generated.
    :returntype: `bytes`
    """
    return uuid.uuid4().hex.encode("us-ascii")

class Reply(object):
    """Base class for SASL authentication reply objects.

    :Ivariables:
        - `data`: optional reply data.
    :Types:
        - `data`: `bytes`
    """
    # pylint: disable-msg=R0903
    def __init__(self, data = None):
        """Initialize the `Reply` object.

        :Parameters:
            - `data`: optional reply data.
        :Types:
            - `data`: `bytes`
        """
        self.data = data

    def encode(self):
        """Base64-encode the data contained in the reply when appropriate.

        :return: encoded data.
        :returntype: `unicode`
        """
        if self.data is None:
            return ""
        elif not self.data:
            return "="
        else:
            ret = standard_b64encode(self.data)
            return ret.decode("us-ascii")

class Challenge(Reply):
    """The challenge SASL message (server's challenge for the client)."""
    # pylint: disable-msg=R0903
    def __init__(self, data):
        """Initialize the `Challenge` object."""
        Reply.__init__(self, data)
    def __repr__(self):
        return "<sasl.Challenge: {0!r}>".format(self.data)

class Response(Reply):
    """The response SASL message (clients's reply the server's
    challenge)."""
    # pylint: disable-msg=R0903
    def __init__(self, data):
        """Initialize the `Response` object."""
        Reply.__init__(self, data)
    def __repr__(self):
        return "<sasl.Response: {0!r}>".format(self.data)

class Failure(Reply):
    """The failure SASL message.

    :Ivariables:
        - `reason`: the failure reason.
    :Types:
        - `reason`: `unicode`.
    """
    # pylint: disable-msg=R0903
    def __init__(self, reason):
        """Initialize the `Failure` object.

        :Parameters:
            - `reason`: the failure reason.
        :Types:
            - `reason`: `unicode`.
        """
        Reply.__init__(self, None)
        self.reason = reason
    def __repr__(self):
        return "<sasl.Failure: {0!r}>".format(self.reason)

class Success(Reply):
    """The success SASL message (sent by the server on authentication
    success).
    """
    # pylint: disable-msg=R0903
    def __init__(self, properties = None, data = None):
        """Initialize the `Success` object.

        :Parameters:
            - `properties`: the `authentication properties`_ obtained
            - `data`: the success data to be sent to the client
        :Types:
            - `properties`: mapping
            - `data`: `bytes`
        """
        # pylint: disable-msg=R0913
        Reply.__init__(self, data)
        if properties:
            self.properties = properties
        else:
            self.properties = {}

    def __repr__(self):
        return "<sasl.Success: {0!r} data: {1!r}>".format(
                                                    self.properties, self.data)

class ClientAuthenticator:
    """Base class for client authenticators.

    A client authenticator class is a client-side implementation of a SASL
    mechanism. One `ClientAuthenticator` object may be used for one
    client authentication process.
    """
    __metaclass__ = ABCMeta
    def __init__(self):
        """Initialize a `ClientAuthenticator` object."""
        pass

    @abstractclassmethod
    def are_properties_sufficient(cls, properties):
        """Check if the provided properties are sufficient for
        this authentication mechanism.

        If `are_properties_sufficient` returns False for given `properties`
        mapping, the `start` method of `cls` instance will also fail with
        such argument.

        :Parameters:
            - `properties`: the `authentication properties`_
        :Types:
            - `properties`: mapping

        :Return: if the mechanism can be used with those properties
        """
        # pylint: disable=E0213,W0613,R0201
        return False

    @abstractmethod
    def start(self, properties):
        """Start the authentication process.

        :Parameters:
            - `properties`: the `authentication properties`_
        :Types:
            - `properties`: mapping

        :return: the initial response to send to the server or a failuer
            indicator.
        :returntype: `Response` or `Failure`
        """
        raise NotImplementedError

    @abstractmethod
    def challenge(self, challenge):
        """Process the server's challenge.

        :Parameters:
            - `challenge`: the challenge.
        :Types:
            - `challenge`: `bytes`

        :return: the response or a failure indicator.
        :returntype: `Response` or `Failure`"""
        raise NotImplementedError

    @abstractmethod
    def finish(self, data):
        """Handle authentication succes information from the server.

        :Parameters:
            - `data`: the optional additional data returned with the success.
        :Types:
            - `data`: `bytes`

        :return: success or failure indicator.
        :returntype: `Success` or `Failure`"""
        raise NotImplementedError

class ServerAuthenticator:
    """Base class for server authenticators.

    A server authenticator class is a server-side implementation of a SASL
    mechanism. One `ServerAuthenticator` object may be used for one
    client authentication process.
    """
    __metaclass__ = ABCMeta
    def __init__(self, password_database):
        """Initialize a `ServerAuthenticator` object.

        :Parameters:
            - `password_database`: a password database
        :Types:
            - `password_database`: `PasswordDataBase`
        """
        self.password_database = password_database

    @classmethod
    def are_properties_sufficient(cls, properties):
        """Check if the provided properties are sufficient for
        this authentication mechanism.

        If `are_properties_sufficient` returns False for given `properties`
        mapping, the `start` method of `cls` instance will also fail with
        such argument.

        :Parameters:
            - `properties`: the `authentication properties`_
        :Types:
            - `properties`: mapping

        :Return: if the mechanism can be used with those properties
        """
        # pylint: disable=E0213,W0613,R0201
        return True

    @abstractmethod
    def start(self, properties, initial_response):
        """Start the authentication process.

        :Parameters:
            - `properties`: the `authentication properties`_
            - `initial_response`: the initial response send by the client with
              the authentication request.

        :Types:
            - `properties`: mapping
            - `initial_response`: `bytes`

        :return: a challenge, a success or a failure indicator.
        :returntype: `Challenge` or `Failure` or `Success`"""
        raise NotImplementedError

    @abstractmethod
    def response(self, response):
        """Process a response from a client.

        :Parameters:
            - `response`: the response from the client to our challenge.
        :Types:
            - `response`: `bytes`

        :return: a challenge, a success or a failure indicator.
        :returntype: `Challenge` or `Success` or `Failure`"""
        raise NotImplementedError

def _key_func(item):
    """Key function used for sorting SASL authenticator classes
    """
    # pylint: disable-msg=W0212
    klass = item[1]
    return (klass._pyxmpp_sasl_secure, klass._pyxmpp_sasl_preference)

def _register_client_authenticator(klass, name):
    """Add a client authenticator class to `CLIENT_MECHANISMS_D`,
    `CLIENT_MECHANISMS` and, optionally, to `SECURE_CLIENT_MECHANISMS`
    """
    # pylint: disable-msg=W0212
    CLIENT_MECHANISMS_D[name] = klass
    items = sorted(CLIENT_MECHANISMS_D.items(), key = _key_func, reverse = True)
    CLIENT_MECHANISMS[:] = [k for (k, v) in items ]
    SECURE_CLIENT_MECHANISMS[:] = [k for (k, v) in items
                                                    if v._pyxmpp_sasl_secure]

def _register_server_authenticator(klass, name):
    """Add a client authenticator class to `SERVER_MECHANISMS_D`,
    `SERVER_MECHANISMS` and, optionally, to `SECURE_SERVER_MECHANISMS`
    """
    # pylint: disable-msg=W0212
    SERVER_MECHANISMS_D[name] = klass
    items = sorted(SERVER_MECHANISMS_D.items(), key = _key_func, reverse = True)
    SERVER_MECHANISMS[:] = [k for (k, v) in items ]
    SECURE_SERVER_MECHANISMS[:] = [k for (k, v) in items
                                                    if v._pyxmpp_sasl_secure]

def sasl_mechanism(name, secure, preference = 50):
    """Class decorator generator for `ClientAuthenticator` or
    `ServerAuthenticator` subclasses. Adds the class to the pyxmpp.sasl
    mechanism registry.

    :Parameters:
        - `name`: SASL mechanism name
        - `secure`: if the mechanims can be considered secure - `True`
          if it can be used over plain-text channel
        - `preference`: mechanism preference level (the higher the better)
    :Types:
        - `name`: `unicode`
        - `secure`: `bool`
        - `preference`: `int`
    """
    # pylint: disable-msg=W0212
    def decorator(klass):
        """The decorator."""
        klass._pyxmpp_sasl_secure = secure
        klass._pyxmpp_sasl_preference = preference
        if issubclass(klass, ClientAuthenticator):
            _register_client_authenticator(klass, name)
        elif issubclass(klass, ServerAuthenticator):
            _register_server_authenticator(klass, name)
        else:
            raise TypeError("Not a ClientAuthenticator"
                                            " or ServerAuthenticator class")
        return klass
    return decorator

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = digest_md5
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
"""DIGEST-MD5 authentication mechanism for PyXMPP SASL implementation.

Normative reference:
  - `RFC 2831 <http://www.ietf.org/rfc/rfc2831.txt>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

from binascii import b2a_hex
import re
import logging

import hashlib

from .core import ClientAuthenticator, ServerAuthenticator
from .core import Failure, Response, Challenge, Success, Failure
from .core import sasl_mechanism, default_nonce_factory

logger = logging.getLogger("pyxmpp2.sasl.digest_md5")

QUOTE_RE = re.compile(br"(?<!\\)\\(.)")
PARAM_RE = re.compile(br'^(?P<var>[^=]+)\=(?P<val>(\"(([^"\\]+)|(\\\")'
                            br'|(\\\\))+\")|([^",]+))(\s*\,\s*(?P<rest>.*))?$')

def _unquote(data):
    """Unquote quoted value from DIGEST-MD5 challenge or response.

    If `data` doesn't start or doesn't end with '"' then return it unchanged,
    remove the quotes and escape backslashes otherwise.

    :Parameters:
        - `data`: a quoted string.
    :Types:
        - `data`: `bytes`

    :return: the unquoted string.
    :returntype: `bytes`
    """
    if not data.startswith(b'"') or not data.endswith(b'"'):
        return data
    return QUOTE_RE.sub(b"\\1", data[1:-1])

def _quote(data):
    """Prepare a string for quoting for DIGEST-MD5 challenge or response.

    Don't add the quotes, only escape '"' and "\\" with backslashes.

    :Parameters:
        - `data`: a raw string.
    :Types:
        - `data`: `bytes`

    :return: `data` with '"' and "\\" escaped using "\\".
    :returntype: `bytes`
    """
    data = data.replace(b'\\', b'\\\\')
    data = data.replace(b'"', b'\\"')
    return data

def _h_value(data):
    """H function of the DIGEST-MD5 algorithm (MD5 sum).

    :Parameters:
        - `data`: a byte string.
    :Types:
        - `data`: `bytes`

    :return: MD5 sum of the string.
    :returntype: `bytes`"""
    # pylint: disable-msg=E1101
    return hashlib.md5(data).digest()

def _kd_value(k_val, s_val):
    """KD function of the DIGEST-MD5 algorithm.

    :Parameters:
        - `k_val`: a byte string.
        - `s_val`: a byte string.
    :Types:
        - `k_val`: `bytes`
        - `s_val`: `bytes`

    :return: MD5 sum of the strings joined with ':'.
    :returntype: `bytes`"""
    return _h_value(b":".join((k_val, s_val)))

def _make_urp_hash(username, realm, passwd):
    """Compute MD5 sum of username:realm:password.

    :Parameters:
        - `username`: a username.
        - `realm`: a realm.
        - `passwd`: a password.
    :Types:
        - `username`: `bytes`
        - `realm`: `bytes`
        - `passwd`: `bytes`

    :return: the MD5 sum of the parameters joined with ':'.
    :returntype: `bytes`"""
    if realm is None:
        realm = b""
    return _h_value(b":".join((username, realm, passwd)))

def _compute_response(urp_hash, nonce, cnonce, nonce_count, authzid,
                                                                    digest_uri):
    """Compute DIGEST-MD5 response value.

    :Parameters:
        - `urp_hash`: MD5 sum of username:realm:password.
        - `nonce`: nonce value from a server challenge.
        - `cnonce`: cnonce value from the client response.
        - `nonce_count`: nonce count value.
        - `authzid`: authorization id.
        - `digest_uri`: digest-uri value.
    :Types:
        - `urp_hash`: `bytes`
        - `nonce`: `bytes`
        - `nonce_count`: `int`
        - `authzid`: `bytes`
        - `digest_uri`: `bytes`

    :return: the computed response value.
    :returntype: `bytes`"""
    # pylint: disable-msg=C0103,R0913
    logger.debug("_compute_response{0!r}".format((urp_hash, nonce, cnonce,
                                            nonce_count, authzid,digest_uri)))
    if authzid:
        a1 = b":".join((urp_hash, nonce, cnonce, authzid))
    else:
        a1 = b":".join((urp_hash, nonce, cnonce))
    a2 = b"AUTHENTICATE:" + digest_uri
    return b2a_hex(_kd_value(b2a_hex(_h_value(a1)), b":".join((
            nonce, nonce_count, cnonce, b"auth", b2a_hex(_h_value(a2))))))

def _compute_response_auth(urp_hash, nonce, cnonce, nonce_count, authzid,
                                                                    digest_uri):
    """Compute DIGEST-MD5 rspauth value.

    :Parameters:
        - `urp_hash`: MD5 sum of username:realm:password.
        - `nonce`: nonce value from a server challenge.
        - `cnonce`: cnonce value from the client response.
        - `nonce_count`: nonce count value.
        - `authzid`: authorization id.
        - `digest_uri`: digest-uri value.
    :Types:
        - `urp_hash`: `bytes`
        - `nonce`: `bytes`
        - `nonce_count`: `int`
        - `authzid`: `bytes`
        - `digest_uri`: `bytes`

    :return: the computed rspauth value.
    :returntype: `bytes`"""
    # pylint: disable-msg=C0103,R0913
    logger.debug("_compute_response_auth{0!r}".format((urp_hash, nonce, cnonce,
                                            nonce_count, authzid, digest_uri)))
    if authzid:
        a1 = b":".join((urp_hash, nonce, cnonce, authzid))
    else:
        a1 = b":".join((urp_hash, nonce, cnonce))
    a2 = b":" + digest_uri
    return b2a_hex(_kd_value(b2a_hex(_h_value(a1)), b":".join((
            nonce, nonce_count, cnonce, b"auth", b2a_hex(_h_value(a2))))))

@sasl_mechanism("DIGEST-MD5", 70)
class DigestMD5ClientAuthenticator(ClientAuthenticator):
    """Provides DIGEST-MD5 SASL authentication for a client.

    Authentication properties used:

        - ``"username"`` - user name (required)
        - ``"authzid"`` - authorization id (optional)
        - ``"service-type"`` - service type as required by the DIGEST-MD5
          protocol (required)
        - ``"service-domain"`` - service domain (the 'serv-name' or 'host' part
          of diges-uri of DIGEST-MD5) (required)
        - ``"service-hostname"`` - service host name (the 'host' par of
          diges-uri of DIGEST-MD5) (required)
        - ``"realm"`` - the realm to use if needed (optional)
        - ``"realms"`` - list of acceptable realms (optional)

    Authentication properties returned:

        - ``"username"`` - user name
        - ``"authzid"`` - authorization id
    """
    # pylint: disable-msg=R0902
    def __init__(self):
        """Initialize a `DigestMD5ClientAuthenticator` object."""
        ClientAuthenticator.__init__(self)
        self.username = None
        self.rspauth_checked = None
        self.response_auth = None
        self.authzid = None
        self.realm = None
        self.nonce_count = None
        self.in_properties = None

    @classmethod
    def are_properties_sufficient(cls, properties):
        return ("username" in properties
                and "password" in properties
                and "service-type" in properties
                and "service-domain" in properties)

    def start(self, properties):
        self.username = properties["username"]
        self.authzid = properties.get("authzid", "")
        self.in_properties = properties
        self.nonce_count = 0
        self.response_auth = None
        self.rspauth_checked = False
        self.realm = None
        return Response(None)

    def challenge(self, challenge):
        """Process a challenge and return the response.

        :Parameters:
            - `challenge`: the challenge from server.
        :Types:
            - `challenge`: `bytes`

        :return: the response or a failure indicator.
        :returntype: `sasl.Response` or `sasl.Failure`"""
        # pylint: disable-msg=R0911,R0912
        if not challenge:
            logger.debug("Empty challenge")
            return Failure("bad-challenge")

        # workaround for some buggy implementations
        challenge = challenge.split(b'\x00')[0]

        if self.response_auth:
            return self._final_challenge(challenge)
        realms = []
        nonce = None
        charset = "iso-8859-1"
        while challenge:
            match = PARAM_RE.match(challenge)
            if not match:
                logger.debug("Challenge syntax error: {0!r}".format(challenge))
                return Failure("bad-challenge")
            challenge = match.group("rest")
            var = match.group("var")
            val = match.group("val")
            logger.debug("{0!r}: {1!r}".format(var, val))
            if var == b"realm":
                realms.append(_unquote(val))
            elif var == b"nonce":
                if nonce:
                    logger.debug("Duplicate nonce")
                    return Failure("bad-challenge")
                nonce = _unquote(val)
            elif var == b"qop":
                qopl = _unquote(val).split(b",")
                if b"auth" not in qopl:
                    logger.debug("auth not supported")
                    return Failure("not-implemented")
            elif var == b"charset":
                if val != b"utf-8":
                    logger.debug("charset given and not utf-8")
                    return Failure("bad-challenge")
                charset = "utf-8"
            elif var == b"algorithm":
                if val != b"md5-sess":
                    logger.debug("algorithm given and not md5-sess")
                    return Failure("bad-challenge")
        if not nonce:
            logger.debug("nonce not given")
            return Failure("bad-challenge")
        return self._make_response(charset, realms, nonce)

    def _make_response(self, charset, realms, nonce):
        """Make a response for the first challenge from the server.

        :Parameters:
            - `charset`: charset name from the challenge.
            - `realms`: realms list from the challenge.
            - `nonce`: nonce value from the challenge.
        :Types:
            - `charset`: `bytes`
            - `realms`: `bytes`
            - `nonce`: `bytes`

        :return: the response or a failure indicator.
        :returntype: `sasl.Response` or `sasl.Failure`"""
        # pylint: disable-msg=R0914,R0915
        params = []
        realm = self._get_realm(realms, charset)
        if isinstance(realm, Failure):
            return realm
        elif realm:
            realm = _quote(realm)
            params.append(b'realm="' + realm + b'"')

        try:
            username = self.username.encode(charset)
        except UnicodeError:
            logger.debug("Couldn't encode username to {0!r}".format(charset))
            return Failure("incompatible-charset")

        username = _quote(username)
        params.append(b'username="' + username + b'"')

        cnonce = self.in_properties.get(
                                    "nonce_factory", default_nonce_factory)()
        cnonce = _quote(cnonce)
        params.append(b'cnonce="' + cnonce + b'"')

        params.append(b'nonce="' + nonce + b'"')

        self.nonce_count += 1

        nonce_count = "{0:08x}".format(self.nonce_count).encode("us-ascii")
        params.append(b'nc=' + nonce_count)

        params.append(b'qop=auth')

        serv_type = self.in_properties["service-type"]
        serv_type = serv_type.encode("us-ascii")
        serv_name = self.in_properties["service-domain"]
        host = self.in_properties.get("service-hostname", serv_name)
        serv_name = serv_name.encode("idna")
        host = host.encode("idna")

        if serv_name and serv_name != host:
            digest_uri = b"/".join((serv_type, host, serv_name))
        else:
            digest_uri = b"/".join((serv_type, host))

        digest_uri = _quote(digest_uri)
        params.append(b'digest-uri="' + digest_uri + b'"')

        if self.authzid:
            try:
                authzid = self.authzid.encode(charset)
            except UnicodeError:
                logger.debug("Couldn't encode authzid to {0!r}".format(charset))
                return Failure("incompatible-charset")
            authzid = _quote(authzid)
        else:
            authzid = b""

        try:
            epasswd = self.in_properties["password"].encode(charset)
        except UnicodeError:
            logger.debug("Couldn't encode password to {0!r}"
                                                        .format(charset))
            return Failure("incompatible-charset")
        logger.debug("Encoded password: {0!r}".format(epasswd))
        urp_hash = _make_urp_hash(username, realm, epasswd)

        response = _compute_response(urp_hash, nonce, cnonce, nonce_count,
                                                        authzid, digest_uri)
        self.response_auth = _compute_response_auth(urp_hash, nonce, cnonce,
                                            nonce_count, authzid, digest_uri)
        params.append(b'response=' + response)
        if authzid:
            params.append(b'authzid="' + authzid + b'"')
        return Response(b",".join(params))

    def _get_realm(self, realms, charset):
        """Choose a realm from the list specified by the server.

        :Parameters:
            - `realms`: the realm list.
            - `charset`: encoding of realms on the list.
        :Types:
            - `realms`: `list` of `bytes`
            - `charset`: `bytes`

        :return: the realm chosen or a failure indicator.
        :returntype: `bytes` or `Failure`"""
        if realms:
            realm = realms[0]
            ap_realms = self.in_properties.get("realms")
            if ap_realms is not None:
                realms = (unicode(r, charset) for r in realms)
                for ap_realm in ap_realms:
                    if ap_realm in realms:
                        realm = ap_realm
                        break
            realm = realm.decode(charset)
        else:
            realm = self.in_properties.get("realm")
        if realm is not None:
            self.realm = realm
            try:
                realm = realm.encode(charset)
            except UnicodeError:
                logger.debug("Couldn't encode realm from utf-8 to {0!r}"
                                                            .format(charset))
                return Failure("incompatible-charset")
        return realm

    def _final_challenge(self, challenge):
        """Process the second challenge from the server and return the response.

        :Parameters:
            - `challenge`: the challenge from server.
        :Types:
            - `challenge`: `bytes`

        :return: the response or a failure indicator.
        :returntype: `sasl.Response` or `sasl.Failure`
        """
        if self.rspauth_checked:
            return Failure("extra-challenge")
        challenge = challenge.split(b'\x00')[0]
        rspauth = None
        while challenge:
            match = PARAM_RE.match(challenge)
            if not match:
                logger.debug("Challenge syntax error: {0!r}".format(challenge))
                return Failure("bad-challenge")
            challenge = match.group("rest")
            var = match.group("var")
            val = match.group("val")
            logger.debug("{0!r}: {1!r}".format(var, val))
            if var == b"rspauth":
                rspauth = val
        if not rspauth:
            logger.debug("Final challenge without rspauth")
            return Failure("bad-success")
        if rspauth == self.response_auth:
            self.rspauth_checked = True
            return Response(None)
        else:
            logger.debug("Wrong rspauth value - peer is cheating?")
            logger.debug("my rspauth: {0!r}".format(self.response_auth))
            return Failure("bad-success")

    def finish(self, data):
        """Process success indicator from the server.

        Process any addiitional data passed with the success.
        Fail if the server was not authenticated.

        :Parameters:
            - `data`: an optional additional data with success.
        :Types:
            - `data`: `bytes`

        :return: success or failure indicator.
        :returntype: `sasl.Success` or `sasl.Failure`"""
        if not self.response_auth:
            logger.debug("Got success too early")
            return Failure("bad-success")
        if self.rspauth_checked:
            properties = {
                    "username": self.username,
                    "realm": self.realm,
                    "authzid": self.authzid
                    }
            return Success(properties)
        else:
            ret = self._final_challenge(data)
            if isinstance(ret, Failure):
                return ret
            if self.rspauth_checked:
                properties = {
                        "username": self.username,
                        "realm": self.realm,
                        "authzid": self.authzid
                        }
                return Success(properties)
            else:
                logger.debug("Something went wrong when processing additional"
                                                        " data with success?")
                return Failure("bad-success")

@sasl_mechanism("DIGEST-MD5", 70)
class DigestMD5ServerAuthenticator(ServerAuthenticator):
    """Provides DIGEST-MD5 SASL authentication for a server.

    Authentication properties used:

        - ``"service-type"`` - service type as required by the DIGEST-MD5
          protocol (optional, verified if provided)
        - ``"service-domain"`` - service domain (the 'serv-name' or 'host' part
          of diges-uri of DIGEST-MD5) (optional, verified if provided)
        - ``"service-hostname"`` - service host name (the 'host' par of
          diges-uri of DIGEST-MD5) (optional, verified if provided)
        - ``"realms"`` - list of acceptable realms (optional)
        - ``"realm"`` - the realm to use ``"realms"`` is not set (optional)

    Authentication properties returned:

        - ``"username"`` - user name
        - ``"authzid"`` - authorization id
    """
    def __init__(self, password_database):
        """Initialize a `DigestMD5ServerAuthenticator` object."""
        ServerAuthenticator.__init__(self, password_database)
        self.nonce = None
        self.last_nonce_count = None
        self.in_properties = None
        self.out_properties = None
        self.realm = None

    def start(self, properties, initial_response):
        _unused = initial_response
        self.in_properties = properties
        self.last_nonce_count = 0
        params = []
        realms = properties.get("realms")
        if realms:
            self.realm = realms[0]
            for realm in realms:
                realm = _quote(realm.encode("utf-8"))
                params.append(b'realm="' + realm + b'"')
        else:
            self.realm = properties.get("realm")
            if self.realm:
                realm = _quote(self.realm.encode("utf-8"))
                params.append(b'realm="' + realm + b'"')
        nonce = self.in_properties.get(
                                    "nonce_factory", default_nonce_factory)()
        nonce = _quote(nonce)
        self.nonce = nonce
        params.append(b'nonce="' + nonce + b'"')
        params.append(b'qop="auth"')
        params.append(b'charset=utf-8')
        params.append(b'algorithm=md5-sess')
        self.out_properties = None
        return Challenge(b",".join(params))

    def response(self, response):
        """Process a client reponse.

        :Parameters:
            - `response`: the response from the client.
        :Types:
            - `response`: `bytes`

        :return: a challenge, a success indicator or a failure indicator.
        :returntype: `sasl.Challenge`, `sasl.Success` or `sasl.Failure`"""
        if self.out_properties:
            return Success(self.out_properties)
        if not response:
            return Failure("not-authorized")
        return self._parse_response(response)

    def _parse_response(self, response):
        """Parse a client reponse and pass to further processing.

        :Parameters:
            - `response`: the response from the client.
        :Types:
            - `response`: `bytes`

        :return: a challenge, a success indicator or a failure indicator.
        :returntype: `sasl.Challenge`, `sasl.Success` or `sasl.Failure`"""
        # pylint: disable-msg=R0912

        # workaround for some SASL implementations
        response = response.split(b'\x00')[0]

        if self.realm:
            realm = self.realm.encode("utf-8")
            realm = _quote(realm)
        else:
            realm = None

        username = None
        cnonce = None
        digest_uri = None
        response_val = None
        authzid = None
        nonce_count = None
        while response:
            match = PARAM_RE.match(response)
            if not match:
                logger.debug("Response syntax error: {0!r}".format(response))
                return Failure("not-authorized")
            response = match.group("rest")
            var = match.group("var")
            val = match.group("val")
            logger.debug("{0!r}: {1!r}".format(var, val))
            if var == b"realm":
                realm = val[1:-1]
            elif var == b"cnonce":
                if cnonce:
                    logger.debug("Duplicate cnonce")
                    return Failure("not-authorized")
                cnonce = val[1:-1]
            elif var == b"qop":
                if val != b'auth':
                    logger.debug("qop other then 'auth'")
                    return Failure("not-authorized")
            elif var == b"digest-uri":
                digest_uri = val[1:-1]
            elif var == b"authzid":
                authzid = val[1:-1]
            elif var == b"username":
                username = val[1:-1]
            elif var == b"response":
                response_val = val
            elif var == b"nc":
                nonce_count = val
                self.last_nonce_count += 1
                if int(nonce_count) != self.last_nonce_count:
                    logger.debug("bad nonce: {0!r} != {1!r}"
                            .format(nonce_count, self.last_nonce_count))
                    return Failure("not-authorized")
        return self._check_params(username, realm, cnonce, digest_uri,
                                        response_val, authzid, nonce_count)

    def _check_params(self, username, realm, cnonce, digest_uri, response_val,
                                                        authzid, nonce_count):
        """Check parameters of a client reponse and pass them to further
        processing.

        :Parameters:
            - `username`: user name.
            - `realm`: realm.
            - `cnonce`: cnonce value.
            - `digest_uri`: digest-uri value.
            - `response_val`: response value computed by the client.
            - `authzid`: authorization id.
            - `nonce_count`: nonce count value.
        :Types:
            - `username`: `bytes`
            - `realm`: `bytes`
            - `cnonce`: `bytes`
            - `digest_uri`: `bytes`
            - `response_val`: `bytes`
            - `authzid`: `bytes`
            - `nonce_count`: `bytes`

        :return: a challenge, a success indicator or a failure indicator.
        :returntype: `sasl.Challenge`, `sasl.Success` or `sasl.Failure`"""
        # pylint: disable-msg=R0913
        if not cnonce:
            logger.debug("Required 'cnonce' parameter not given")
            return Failure("not-authorized")
        if not response_val:
            logger.debug("Required 'response' parameter not given")
            return Failure("not-authorized")
        if not username:
            logger.debug("Required 'username' parameter not given")
            return Failure("not-authorized")
        if not digest_uri:
            logger.debug("Required 'digest_uri' parameter not given")
            return Failure("not-authorized")
        if not nonce_count:
            logger.debug("Required 'nc' parameter not given")
            return Failure("not-authorized")
        return self._make_final_challenge(username, realm, cnonce, digest_uri,
                response_val, authzid, nonce_count)

    def _make_final_challenge(self, username, realm, cnonce, digest_uri,
                                        response_val, authzid, nonce_count):
        """Send the second challenge in reply to the client response.

        :Parameters:
            - `username`: user name.
            - `realm`: realm.
            - `cnonce`: cnonce value.
            - `digest_uri`: digest-uri value.
            - `response_val`: response value computed by the client.
            - `authzid`: authorization id.
            - `nonce_count`: nonce count value.
        :Types:
            - `username`: `bytes`
            - `realm`: `bytes`
            - `cnonce`: `bytes`
            - `digest_uri`: `bytes`
            - `response_val`: `bytes`
            - `authzid`: `bytes`
            - `nonce_count`: `bytes`

        :return: a challenge, a success indicator or a failure indicator.
        :returntype: `sasl.Success` or `sasl.Failure`
        """
        # pylint: disable-msg=R0912,R0913,R0914
        username_uq = username.replace(b'\\', b'')
        if authzid:
            authzid_uq = authzid.replace(b'\\', b'')
        else:
            authzid_uq = None
        if realm:
            realm_uq = realm.replace(b'\\', b'')
        else:
            realm_uq = None
        digest_uri_uq = digest_uri.replace(b'\\', b'')
        props = dict(self.in_properties)
        props["realm"] = realm_uq.decode("utf-8")
        password, pformat = self.password_database.get_password(
                                        username_uq.decode("utf-8"),
                            (u"plain", u"md5:user:realm:pass"), props)
        if pformat == u"md5:user:realm:pass":
            urp_hash = password.a2b_hex()
        elif pformat == u"plain":
            urp_hash = _make_urp_hash(username, realm, password.encode("utf-8"))
        else:
            logger.debug(u"Couldn't get password.")
            return Failure(u"not-authorized")
        valid_response = _compute_response(urp_hash, self.nonce, cnonce,
                                            nonce_count, authzid, digest_uri)
        if response_val != valid_response:
            logger.debug(u"Response mismatch: {0!r} != {1!r}".format(
                                                response_val, valid_response))
            return Failure(u"not-authorized")
        try:
            fields = digest_uri_uq.split(b"/")
            if len(fields) == 3:
                serv_type, host, serv_name = [f.decode("utf-8") for f in fields]
            elif len(fields) == 2:
                serv_type, host = [f.decode("utf-8") for f in fields]
                serv_name = None
            else:
                raise ValueError
        except (ValueError, UnicodeError):
            logger.debug("Bad digest_uri: {0!r}".format(digest_uri_uq))
            return Failure("not-authorized")
        if "service-type" in self.in_properties:
            if serv_type != self.in_properties["service-type"]:
                logger.debug(u"Bad serv-type: {0!r} != {1!r}"
                        .format(serv_type, self.in_properties["service-type"]))
                return Failure("not-authorized")
        if "service-domain" in self.in_properties:
            if serv_name:
                if serv_name != self.in_properties["service-domain"]:
                    logger.debug(u"serv-name: {0!r} != {1!r}".format(serv_name,
                                        self.in_properties["service-domain"]))
                return Failure("not-authorized")
            elif (host != self.in_properties["service-domain"]
                    and host != self.in_properties.get("service-hostname")):
                logger.debug(u"bad host: {0!r} != {1!r}"
                            u" & {0!r} != {2!r}".format(host,
                            self.in_properties["service-domain"],
                            self.in_properties.get("service-hostname")))
                return Failure("not-authorized")
        if "service-hostname" in self.in_properties:
            if host != self.in_properties["service-hostname"]:
                logger.debug(u"bad host: {0!r} != {1!r}".format(host,
                                        self.in_properties["service-hostname"]))
                return Failure("not-authorized")
        rspauth = _compute_response_auth(urp_hash, self.nonce, cnonce,
                                        nonce_count, authzid, digest_uri)
        if authzid_uq is not None:
            authzid_uq =  authzid_uq.decode("utf-8")
        self.out_properties = {
                        "username": username.decode("utf-8"),
                        "realm": realm.decode("utf-8"),
                        "authzid": authzid_uq,
                        "service-type": serv_type,
                        "service-domain": serv_name if serv_name else host,
                        "service-hostname": host
                        }
        return Success(self.out_properties, b"rspauth=" + rspauth)

########NEW FILE########
__FILENAME__ = external
#
# (C) Copyright 2009 Michal Witkowski <neuro@o2.pl>
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
"""External SASL authentication mechanism for PyXMPP SASL implementation.

Normative reference:
  - `RFC 6120 <http://www.ietf.org/rfc/rfc3920.txt>`__
  - `XEP-0178 <http://xmpp.org/extensions/xep-0178.html#c2s>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

from .core import ClientAuthenticator, Response, Success
from .core import sasl_mechanism

@sasl_mechanism("EXTERNAL", False, 20)
class ExternalClientAuthenticator(ClientAuthenticator):
    """Provides client-side External SASL (TLS-Identify) authentication."""
    def __init__(self):
        ClientAuthenticator.__init__(self)
        self.authzid = None

    @classmethod
    def are_properties_sufficient(cls, properties):
        return True

    def start(self, properties):
        self.authzid = properties.get("authzid")
        # TODO: This isn't very XEP-0178'ish.
        # XEP-0178 says "=" should be sent when only one id-on-xmppAddr is
        # in the cert, but we don't know that. Still, this conforms to the
        # standard and works.
        if self.authzid:
            return Response(self.authzid)
        else:
            return Response(b"")

    def finish(self, data):
        """Handle authentication success information from the server.

        :Parameters:
            - `data`: the optional additional data returned with the success.
        :Types:
            - `data`: `bytes`

        :return: a success indicator.
        :returntype: `Success`"""
        return Success({"authzid": self.authzid})

########NEW FILE########
__FILENAME__ = gssapi
#
# (C) Copyright 2008 Jelmer Vernooij <jelmer@samba.org>
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
"""GSSAPI authentication mechanism for PyXMPP SASL implementation.

Normative reference:
  - `RFC 4752 <http://www.ietf.org/rfc/rfc4752.txt>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import base64
import kerberos

import logging

from .core import ClientAuthenticator, Response, Success
from .core import sasl_mechanism

logger = logging.getLogger("pyxmpp2.sasl.gssapi")

@sasl_mechanism("GSSAPI", 75)
class GSSAPIClientAuthenticator(ClientAuthenticator):
    """Provides client-side GSSAPI SASL (Kerberos 5) authentication."""

    def __init__(self):
        ClientAuthenticator.__init__(self)
        self.username = None
        self._gss = None
        self.step = None
        self.authzid = None

    @classmethod
    def are_properties_sufficient(cls, properties):
        return "username" in properties and ("authzid" in properties or
                                            "service-hostname" in properties)

    def start(self, properties):
        self.username = properties["username"]
        self.authzid = properties.get("authzid")
        _unused, self._gss = kerberos.authGSSClientInit(self.authzid or
                    "{0}@{1}".format("xmpp", properties["service-hostname"]))
        self.step = 0
        return self.challenge(b"")

    def challenge(self, challenge):
        if self.step == 0:
            ret = kerberos.authGSSClientStep(self._gss,
                                                base64.b64encode(challenge))
            if ret != kerberos.AUTH_GSS_CONTINUE:
                self.step = 1
        elif self.step == 1:
            ret = kerberos.authGSSClientUnwrap(self._gss,
                                                base64.b64encode(challenge))
            response = kerberos.authGSSClientResponse(self._gss)
            ret = kerberos.authGSSClientWrap(self._gss, response, self.username)
        response = kerberos.authGSSClientResponse(self._gss)
        if response is None:
            return Response(b"")
        else:
            return Response(base64.b64decode(response))

    def finish(self, data):
        self.username = kerberos.authGSSClientUserName(self._gss)
        logger.debug("Authenticated as {0!r}".format(
                                    kerberos.authGSSClientUserName(self._gss)))
        return Success({"username": self.username, "authzid": self.authzid})

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = plain
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
"""PLAIN authentication mechanism for PyXMPP SASL implementation.

Normative reference:
  - `RFC 4616 <http://www.ietf.org/rfc/rfc4616.txt>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import logging

from .core import ClientAuthenticator, ServerAuthenticator
from .core import Success, Failure, Challenge, Response
from .core import sasl_mechanism

logger = logging.getLogger("pyxmpp2.sasl.plain")

@sasl_mechanism("PLAIN", 10)
class PlainClientAuthenticator(ClientAuthenticator):
    """Provides PLAIN SASL authentication for a client.

    Authentication properties used:

        - ``"username"`` - user name (required)
        - ``"authzid"`` - authorization id (optional)

    Authentication properties returned:

        - ``"username"`` - user name
        - ``"authzid"`` - authorization id
    """
    def __init__(self):
        ClientAuthenticator.__init__(self)
        self.username = None
        self.finished = None
        self.password = None
        self.authzid = None
        self.properties = None

    @classmethod
    def are_properties_sufficient(cls, properties):
        return "username" in properties and "password" in properties

    def start(self, properties):
        self.properties = properties
        self.username = properties["username"]
        self.authzid = properties.get("authzid", u"")
        self.finished = False
        return self.challenge(b"")

    def challenge(self, challenge):
        if self.finished:
            logger.debug(u"Already authenticated")
            return Failure(u"extra-challenge")
        self.finished = True
        password = self.properties["password"]
        return Response(b"\000".join(( self.authzid.encode("utf-8"),
                            self.username.encode("utf-8"),
                            password.encode("utf-8"))))

    def finish(self, data):
        return Success({"username": self.username, "authzid": self.authzid})

@sasl_mechanism("PLAIN", 10)
class PlainServerAuthenticator(ServerAuthenticator):
    """Provides PLAIN SASL authentication for a server.

    Authentication properties used: None

    Authentication properties returned:

        - ``"username"`` - user name
        - ``"authzid"`` - authorization id
    """
    def __init__(self, password_database):
        ServerAuthenticator.__init__(self, password_database)
        self.properties = None

    def start(self, properties, initial_response):
        self.properties = properties
        if not initial_response:
            return Challenge(b"")
        return self.response(initial_response)

    def response(self, response):
        fields = response.split(b"\000")
        if len(fields) != 3:
            logger.debug(u"Bad response: {0!r}".format(response))
            return Failure("not-authorized")
        authzid, username, password = fields
        authzid = authzid.decode("utf8")
        username = username.decode("utf8")
        password = password.decode("utf8")
        out_props = {"username": username, "authzid": authzid}
        props = dict(self.properties)
        props.update(out_props)
        if not self.password_database.check_password(username, password,
                                                            self.properties):
            logger.debug("Bad password. Response was: {0!r}".format(response))
            return Failure("not-authorized")
        return Success(out_props)

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = saslprep
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""SASLprep stringprep profile.

Normative reference:
  - :RFC:`4013`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import stringprep

from ..xmppstringprep import Profile, b1_mapping, c12_mapping, nfkc

SASLPREP = Profile(
    unassigned = (stringprep.in_table_a1,),
    mapping = (b1_mapping, c12_mapping),
    normalization = nfkc,
    prohibited = (  stringprep.in_table_c12, stringprep.in_table_c21,
                    stringprep.in_table_c22, stringprep.in_table_c3,
                    stringprep.in_table_c4, stringprep.in_table_c5,
                    stringprep.in_table_c6, stringprep.in_table_c7,
                    stringprep.in_table_c8, stringprep.in_table_c9 ),
    bidi = True)

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = scram
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
"""SCRAM authentication mechanisms for PyXMPP SASL implementation.

Normative reference:
  - :RFC:`5802`
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import sys
import re
import logging
import hashlib
import hmac

from binascii import a2b_base64
from base64 import standard_b64encode

from .core import ClientAuthenticator, ServerAuthenticator
from .core import Failure, Response, Challenge, Success, Failure
from .core import sasl_mechanism, default_nonce_factory
from .saslprep import SASLPREP

logger = logging.getLogger("pyxmpp2.sasl.scram")

HASH_FACTORIES = {
        "SHA-1": hashlib.sha1,      # pylint: disable=E1101
        "SHA-224": hashlib.sha224,  # pylint: disable=E1101
        "SHA-256": hashlib.sha256,  # pylint: disable=E1101
        "SHA-384": hashlib.sha384,  # pylint: disable=E1101
        "SHA-512": hashlib.sha512,  # pylint: disable=E1101
        "MD-5": hashlib.md5,        # pylint: disable=E1101
        }

VALUE_CHARS_RE = re.compile(br"^[\x21-\x2B\x2D-\x7E]+$")
_QUOTED_VALUE_RE = br"(?:[\x21-\x2B\x2D-\x7E]|=2C|=3D)+"

CLIENT_FIRST_MESSAGE_RE = re.compile(
        br"^(?P<gs2_header>(?:y|n|p=(?P<cb_name>[a-zA-z0-9.-]+)),"
                        br"(?:a=(?P<authzid>" + _QUOTED_VALUE_RE + br"))?,)"
        br"(?P<client_first_bare>(?P<mext>m=[^\000=]+,)?"
                                br"n=(?P<username>" + _QUOTED_VALUE_RE + br"),"
                                br"r=(?P<nonce>[\x21-\x2B\x2D-\x7E]+)"
                                br"(?:,.*)?)$"
                                )

SERVER_FIRST_MESSAGE_RE = re.compile(
                                br"^(?P<mext>m=[^\000=]+,)?"
                                br"r=(?P<nonce>[\x21-\x2B\x2D-\x7E]+),"
                                br"s=(?P<salt>[a-zA-Z0-9/+=]+),"
                                br"i=(?P<iteration_count>\d+)"
                                br"(?:,.*)?$"
                                )

CLIENT_FINAL_MESSAGE_RE = re.compile(
        br"(?P<without_proof>c=(?P<cb>[a-zA-Z0-9/+=]+),"
                                br"(?:r=(?P<nonce>[\x21-\x2B\x2D-\x7E]+))"
                                br"(?:,.*)?)"
        br",p=(?P<proof>[a-zA-Z0-9/+=]+)$"
        )

SERVER_FINAL_MESSAGE_RE = re.compile(
        br"^(?:e=(?P<error>[^,]+)|v=(?P<verifier>[a-zA-Z0-9/+=]+)(?:,.*)?)$")

class SCRAMOperations(object):
    """Functions used during SCRAM authentication and defined in the RFC.

    """
    def __init__(self, hash_function_name):
        self.hash_function_name = hash_function_name
        self.hash_factory = HASH_FACTORIES[hash_function_name]
        self.digest_size = self.hash_factory().digest_size

    @staticmethod
    def Normalize(str_):
        """The Normalize(str) function.

        This one also accepts Unicode string input (in the RFC only UTF-8
        strings are used).
        """
        # pylint: disable=C0103
        if isinstance(str_, bytes):
            str_ = str_.decode("utf-8")
        return SASLPREP.prepare(str_).encode("utf-8")

    def HMAC(self, key, str_):
        """The HMAC(key, str) function."""
        # pylint: disable=C0103
        return hmac.new(key, str_, self.hash_factory).digest()

    def H(self, str_):
        """The H(str) function."""
        # pylint: disable=C0103
        return self.hash_factory(str_).digest()

    if sys.version_info.major >= 3:
        @staticmethod
        # pylint: disable=C0103
        def XOR(str1, str2):
            """The XOR operator for two byte strings."""
            return bytes(a ^ b for a, b in zip(str1, str2))
    else:
        @staticmethod
        # pylint: disable=C0103
        def XOR(str1, str2):
            """The XOR operator for two byte strings."""
            return "".join(chr(ord(a) ^ ord(b)) for a, b in zip(str1, str2))

    def Hi(self, str_, salt, i):
        """The Hi(str, salt, i) function."""
        # pylint: disable=C0103
        Uj = self.HMAC(str_, salt + b"\000\000\000\001") # U1
        result = Uj
        for _ in range(2, i + 1):
            Uj = self.HMAC(str_, Uj)               # Uj = HMAC(str, Uj-1)
            result = self.XOR(result,  Uj)         # ... XOR Uj-1 XOR Uj
        return result

    @staticmethod
    def escape(data):
        """Escape the ',' and '=' characters for 'a=' and 'n=' attributes.

        Replaces '=' with '=3D' and ',' with '=2C'.

        :Parameters:
            - `data`: string to escape
        :Types:
            - `data`: `bytes`
        """
        return data.replace(b'=', b'=3D').replace(b',', b'=2C')

    @staticmethod
    def unescape(data):
        """Unescape the ',' and '=' characters for 'a=' and 'n=' attributes.

        Reverse of `escape`.

        :Parameters:
            - `data`: string to unescape
        :Types:
            - `data`: `bytes`
        """
        return data.replace(b'=2C', b',').replace(b'=3D', b'=')

class SCRAMClientAuthenticator(SCRAMOperations, ClientAuthenticator):
    """Provides SCRAM SASL authentication for a client.

    :Ivariables:
        - `password`: current authentication password
        - `pformat`: current authentication password format
        - `realm`: current authentication realm
    """
    # pylint: disable-msg=R0902
    def __init__(self, hash_name, channel_binding):
        """Initialize a `SCRAMClientAuthenticator` object.

        :Parameters:
            - `hash_function_name`: hash function name, e.g. ``"SHA-1"``
            - `channel_binding`: `True` to enable channel binding
        :Types:
            - `hash_function_name`: `unicode`
            - `channel_binding`: `bool`
        """
        ClientAuthenticator.__init__(self)
        SCRAMOperations.__init__(self, hash_name)
        self.name = "SCRAM-{0}".format(hash_name)
        if channel_binding:
            self.name += "-PLUS"
        self.channel_binding = channel_binding
        self.username = None
        self.password = None
        self.authzid = None
        self._c_nonce = None
        self._server_first_message = False
        self._client_first_message_bare = False
        self._gs2_header = None
        self._finished = False
        self._auth_message = None
        self._salted_password = None
        self._cb_data = None

    @classmethod
    def are_properties_sufficient(cls, properties):
        return "username" in properties and "password" in properties

    def start(self, properties):
        self.username = properties["username"]
        self.password = properties["password"]
        self.authzid = properties.get("authzid", u"")
        c_nonce = properties.get("nonce_factory", default_nonce_factory)()
        if not VALUE_CHARS_RE.match(c_nonce):
            c_nonce = standard_b64encode(c_nonce)
        self._c_nonce = c_nonce

        if self.channel_binding:
            cb_data = properties.get("channel-binding")
            if not cb_data:
                raise ValueError("No channel binding data provided")
            if "tls-unique" in cb_data:
                cb_type = "tls-unique"
            elif "tls-server-end-point" in cb_data:
                cb_type = "tls-server-end-point"
            elif cb_data:
                cb_type = cb_data.keys()[0]
            self._cb_data = cb_data[cb_type]
            cb_flag = b"p=" + cb_type.encode("utf-8")
        else:
            plus_name = self.name + "-PLUS"
            if plus_name in properties.get("enabled_mechanisms", []):
                # -PLUS is enabled (supported) on our side,
                # but was not selected - that means it was not included
                # in the server features
                cb_flag = b"y"
            else:
                cb_flag = b"n"

        if self.authzid:
            authzid = b"a=" + self.escape(self.authzid.encode("utf-8"))
        else:
            authzid = b""
        gs2_header = cb_flag + b"," + authzid + b","
        self._gs2_header = gs2_header
        nonce = b"r=" + c_nonce
        client_first_message_bare = (b"n=" +
                self.escape(self.username.encode("utf-8")) + b"," + nonce)
        self._client_first_message_bare = client_first_message_bare
        client_first_message = gs2_header + client_first_message_bare
        return Response(client_first_message)

    def challenge(self, challenge):
        """Process a challenge and return the response.

        :Parameters:
            - `challenge`: the challenge from server.
        :Types:
            - `challenge`: `bytes`

        :return: the response or a failure indicator.
        :returntype: `sasl.Response` or `sasl.Failure`
        """
        # pylint: disable=R0911
        if not challenge:
            logger.debug("Empty challenge")
            return Failure("bad-challenge")

        if self._server_first_message:
            return self._final_challenge(challenge)

        match = SERVER_FIRST_MESSAGE_RE.match(challenge)
        if not match:
            logger.debug("Bad challenge syntax: {0!r}".format(challenge))
            return Failure("bad-challenge")

        self._server_first_message = challenge

        mext = match.group("mext")
        if mext:
            logger.debug("Unsupported extension received: {0!r}".format(mext))
            return Failure("bad-challenge")

        nonce = match.group("nonce")
        if not nonce.startswith(self._c_nonce):
            logger.debug("Nonce does not start with our nonce")
            return Failure("bad-challenge")

        salt = match.group("salt")
        try:
            salt = a2b_base64(salt)
        except ValueError:
            logger.debug("Bad base64 encoding for salt: {0!r}".format(salt))
            return Failure("bad-challenge")

        iteration_count = match.group("iteration_count")
        try:
            iteration_count = int(iteration_count)
        except ValueError:
            logger.debug("Bad iteration_count: {0!r}".format(iteration_count))
            return Failure("bad-challenge")

        return self._make_response(nonce, salt, iteration_count)

    def _make_response(self, nonce, salt, iteration_count):
        """Make a response for the first challenge from the server.

        :return: the response or a failure indicator.
        :returntype: `sasl.Response` or `sasl.Failure`
        """
        self._salted_password = self.Hi(self.Normalize(self.password), salt,
                                                            iteration_count)
        self.password = None # not needed any more
        if self.channel_binding:
            channel_binding = b"c=" + standard_b64encode(self._gs2_header +
                                                                self._cb_data)
        else:
            channel_binding = b"c=" + standard_b64encode(self._gs2_header)

        # pylint: disable=C0103
        client_final_message_without_proof = (channel_binding + b",r=" + nonce)

        client_key = self.HMAC(self._salted_password, b"Client Key")
        stored_key = self.H(client_key)
        auth_message = ( self._client_first_message_bare + b"," +
                                    self._server_first_message + b"," +
                                        client_final_message_without_proof )
        self._auth_message = auth_message
        client_signature = self.HMAC(stored_key, auth_message)
        client_proof = self.XOR(client_key, client_signature)
        proof = b"p=" + standard_b64encode(client_proof)
        client_final_message = (client_final_message_without_proof + b"," +
                                                                    proof)
        return Response(client_final_message)

    def _final_challenge(self, challenge):
        """Process the second challenge from the server and return the
        response.

        :Parameters:
            - `challenge`: the challenge from server.
        :Types:
            - `challenge`: `bytes`

        :return: the response or a failure indicator.
        :returntype: `sasl.Response` or `sasl.Failure`
        """
        if self._finished:
            return Failure("extra-challenge")

        match = SERVER_FINAL_MESSAGE_RE.match(challenge)
        if not match:
            logger.debug("Bad final message syntax: {0!r}".format(challenge))
            return Failure("bad-challenge")

        error = match.group("error")
        if error:
            logger.debug("Server returned SCRAM error: {0!r}".format(error))
            return Failure(u"scram-" + error.decode("utf-8"))

        verifier = match.group("verifier")
        if not verifier:
            logger.debug("No verifier value in the final message")
            return Failure("bad-succes")

        server_key = self.HMAC(self._salted_password, b"Server Key")
        server_signature = self.HMAC(server_key, self._auth_message)
        if server_signature != a2b_base64(verifier):
            logger.debug("Server verifier does not match")
            return Failure("bad-succes")

        self._finished = True
        return Response(None)

    def finish(self, data):
        """Process success indicator from the server.

        Process any addiitional data passed with the success.
        Fail if the server was not authenticated.

        :Parameters:
            - `data`: an optional additional data with success.
        :Types:
            - `data`: `bytes`

        :return: success or failure indicator.
        :returntype: `sasl.Success` or `sasl.Failure`"""
        if not self._server_first_message:
            logger.debug("Got success too early")
            return Failure("bad-success")
        if self._finished:
            return Success({"username": self.username, "authzid": self.authzid})
        else:
            ret = self._final_challenge(data)
            if isinstance(ret, Failure):
                return ret
            if self._finished:
                return Success({"username": self.username,
                                                    "authzid": self.authzid})
            else:
                logger.debug("Something went wrong when processing additional"
                                                        " data with success?")
                return Failure("bad-success")

class SCRAMServerAuthenticator(SCRAMOperations, ServerAuthenticator):
    """Provides SCRAM SASL authentication for a server.
    """
    def __init__(self, hash_name, channel_binding, password_database):
        """Initialize a `SCRAMClientAuthenticator` object.

        :Parameters:
            - `hash_function_name`: hash function name, e.g. ``"SHA-1"``
            - `channel_binding`: `True` to enable channel binding
        :Types:
            - `hash_function_name`: `unicode`
            - `channel_binding`: `bool`
        """
        ServerAuthenticator.__init__(self, password_database)
        SCRAMOperations.__init__(self, hash_name)
        self.name = "SCRAM-{0}".format(hash_name)
        if channel_binding:
            self.name += "-PLUS"
        self.channel_binding = channel_binding
        self.properties = None
        self.out_properties = None
        self._client_first_message_bare = None
        self._stored_key = None
        self._server_key = None

    def start(self, properties, initial_response):
        self.properties = properties
        self._client_first_message_bare = None
        self.out_properties = {}
        if not initial_response:
            return Challenge(b"")
        return self.response(initial_response)

    def response(self, response):
        if self._client_first_message_bare:
            logger.debug("Client final message: {0!r}".format(response))
            return self._handle_final_response(response)
        else:
            logger.debug("Client first message: {0!r}".format(response))
            return self._handle_first_response(response)

    def _handle_first_response(self, response):
        match = CLIENT_FIRST_MESSAGE_RE.match(response)
        if not match:
            logger.debug("Bad response syntax: {0!r}".format(response))
            return Failure("not-authorized")

        mext = match.group("mext")
        if mext:
            logger.debug("Unsupported extension received: {0!r}".format(mext))
            return Failure("not-authorized")

        gs2_header = match.group("gs2_header")
        cb_name = match.group("cb_name")
        if self.channel_binding:
            if not cb_name:
                logger.debug("{0!r} used with no channel-binding"
                                                            .format(self.name))
                return Failure("not-authorized")
            cb_name = cb_name.decode("utf-8")
            if cb_name not in self.properties["channel-binding"]:
                logger.debug("Channel binding data type {0!r} not available"
                                                            .format(cb_name))
                return Failure("not-authorized")
        else:
            if gs2_header.startswith(b'y'):
                plus_name = self.name + "-PLUS"
                if plus_name in self.properties.get("enabled_mechanisms", []):
                    logger.warning("Channel binding downgrade attack detected")
                    return Failure("not-authorized")
            elif gs2_header.startswith(b'p'):
                # is this really an error?
                logger.debug("Channel binding requested for {0!r}"
                                                            .format(self.name))
                return Failure("not-authorized")

        authzid = match.group("authzid")
        if authzid:
            self.out_properties['authzid'] = self.unescape(authzid
                                                            ).decode("utf-8")
        else:
            self.out_properties['authzid'] = None
        username = self.unescape(match.group("username")).decode("utf-8")
        self.out_properties['username'] = username

        nonce_factory = self.properties.get("nonce_factory",
                                                        default_nonce_factory)

        properties = dict(self.properties)
        properties.update(self.out_properties)

        s_pformat = "SCRAM-{0}-SaltedPassword".format(self.hash_function_name)
        k_pformat = "SCRAM-{0}-Keys".format(self.hash_function_name)
        password, pformat = self.password_database.get_password(username,
                                           (s_pformat, "plain"), properties)
        if pformat == s_pformat:
            if password is not None:
                salt, iteration_count, salted_password = password
            else:
                logger.debug("No password for user {0!r}".format(username))
        elif pformat != k_pformat:
            salt = self.properties.get("SCRAM-salt")
            if not salt:
                salt = nonce_factory()
            iteration_count = self.properties.get("SCRAM-iteration-count", 4096)
            if pformat == "plain" and password is not None:
                salted_password = self.Hi(self.Normalize(password), salt,
                                                            iteration_count)
            else:
                logger.debug("No password for user {0!r}".format(username))
                password = None
                # to prevent timing attack, compute the key anyway
                salted_password = self.Hi(self.Normalize(""), salt,
                                                            iteration_count)
        if pformat == k_pformat:
            salt, iteration_count, stored_key, server_key = password
        else:
            client_key = self.HMAC(salted_password, b"Client Key")
            stored_key = self.H(client_key)
            server_key = self.HMAC(salted_password, b"Server Key")

        if password is not None:
            self._stored_key = stored_key
            self._server_key = server_key
        else:
            self._stored_key = None
            self._server_key = None

        c_nonce = match.group("nonce")
        s_nonce = nonce_factory()
        if not VALUE_CHARS_RE.match(s_nonce):
            s_nonce = standard_b64encode(s_nonce)
        nonce = c_nonce + s_nonce
        server_first_message = (
                            b"r=" + nonce
                            + b",s=" + standard_b64encode(salt)
                            + b",i=" + str(iteration_count).encode("utf-8")
                            )
        self._nonce = nonce
        self._cb_name  = cb_name
        self._gs2_header = gs2_header
        self._client_first_message_bare = match.group("client_first_bare")
        self._server_first_message = server_first_message
        return Challenge(server_first_message)

    def _handle_final_response(self, response):
        match = CLIENT_FINAL_MESSAGE_RE.match(response)
        if not match:
            logger.debug("Bad response syntax: {0!r}".format(response))
            return Failure("not-authorized")
        if match.group("nonce") != self._nonce:
            logger.debug("Bad nonce in the final client response")
            return Failure("not-authorized")
        cb_input = a2b_base64(match.group("cb"))
        if not cb_input.startswith(self._gs2_header):
            logger.debug("GS2 header in the final response ({0!r}) doesn't"
                    " match the one sent in the first message ({1!r})"
                                        .format(cb_input, self._gs2_header))
            return Failure("not-authorized")
        if self._cb_name:
            cb_data = cb_input[len(self._gs2_header):]
            if cb_data != self.properties["channel-binding"][self._cb_name]:
                logger.debug("Channel binding data doesn't match")
                return Failure("not-authorized")

        proof = a2b_base64(match.group("proof"))

        auth_message = (self._client_first_message_bare + b"," +
                                    self._server_first_message + b"," +
                                        match.group("without_proof"))
        if self._stored_key is None:
            # compute something to prevent timing attack
            client_signature = self.HMAC(b"", auth_message)
            client_key = self.XOR(client_signature, proof)
            self.H(client_key)
            logger.debug("Authentication failed (bad username)")
            return Failure("not-authorized")

        client_signature = self.HMAC(self._stored_key, auth_message)
        client_key = self.XOR(client_signature, proof)
        if self.H(client_key) != self._stored_key:
            logger.debug("Authentication failed")
            return Failure("not-authorized")

        server_signature = self.HMAC(self._server_key, auth_message)
        server_final_message = b"v=" + standard_b64encode(server_signature)
        return Success(self.out_properties, server_final_message)

@sasl_mechanism("SCRAM-SHA-1", 80)
class SCRAM_SHA_1_ClientAuthenticator(SCRAMClientAuthenticator):
    """The SCRAM-SHA-1 client authenticator.

    Authentication properties used:

        - ``"username"`` - user name (required)
        - ``"authzid"`` - authorization id (optional)
        - ``"enabled_mechanisms"`` - list of mechanism enabled on the client.
          Used to detect when an attacker removes the -PLUS version from the
          list of mechanism supported by the server.

    Authentication properties returned:

        - ``"username"`` - user name
        - ``"authzid"`` - authorization id
    """
    # pylint: disable=C0103
    def __init__(self):
        SCRAMClientAuthenticator.__init__(self, "SHA-1", False)

@sasl_mechanism("SCRAM-SHA-1-PLUS", 90)
class SCRAM_SHA_1_PLUS_ClientAuthenticator(SCRAMClientAuthenticator):
    """The SCRAM-SHA-1-PLUS client authenticator.

    Authentication properties used: same as for
    `SCRAM_SHA_1_ClientAuthenticator`, plus:

        - ``"channel-binding"`` - channel-binding data, as a dictionary
          channel-binding-type (`unicode`) -> channel-binding data(`bytes`).
          Channel binding type should be 'tls-unique', as other may be not
          supported by the other side.

    Authentication properties returned: same as for
    `SCRAM_SHA_1_ClientAuthenticator`

    """
    # pylint: disable=C0103
    def __init__(self):
        SCRAMClientAuthenticator.__init__(self, "SHA-1", True)
    @classmethod
    def are_properties_sufficient(cls, properties):
        ret = super(SCRAM_SHA_1_PLUS_ClientAuthenticator, cls
                                ).are_properties_sufficient(properties)
        if not ret:
            return False
        return bool(properties.get("channel-binding"))

@sasl_mechanism("SCRAM-SHA-1", 80)
class SCRAM_SHA_1_ServerAuthenticator(SCRAMServerAuthenticator):
    """The SCRAM-SHA-1 server authenticator.

    Authentication properties used:

        - ``"enabled_mechanisms"`` - list of mechanism enabled on the server.
          Used to detect when an attacker removes the -PLUS version from the
          list of mechanism supported by the server while it is sent to the
          client.
        - ``"SCRAM-salt"`` - salt to be applied on a plain text password
          (default: a random string)
        - ``"SCRAM-iteration-count"`` - iteration-count parameter for hashing
          a plain text password (default: 4096)

    Authentication properties returned:

        - ``"username"`` - user name
        - ``"authzid"`` - authorization id

    """
    # pylint: disable=C0103
    def __init__(self, password_database):
        SCRAMServerAuthenticator.__init__(self, "SHA-1", False,
                                                            password_database)

@sasl_mechanism("SCRAM-SHA-1-PLUS", 90)
class SCRAM_SHA_1_PLUS_ServerAuthenticator(SCRAMServerAuthenticator):
    """The SCRAM-SHA-1-PLUS server authenticator.

    Authentication properties used: same as for
    `SCRAM_SHA_1_ServerAuthenticator`, plus:

        - ``"channel-binding"`` - channel-binding data, as a dictionary
          channel-binding-type (`unicode`) -> channel-binding data(`bytes`).
          Channel binding type should be 'tls-unique', as other may be not
          supported by the other side.

    Authentication properties returned: same as for
    `SCRAM_SHA_1_ServerAuthenticator`

    """
    # pylint: disable=C0103
    def __init__(self, password_database):
        SCRAMServerAuthenticator.__init__(self, "SHA-1", True,
                                                            password_database)
    @classmethod
    def are_properties_sufficient(cls, properties):
        ret = super(SCRAM_SHA_1_PLUS_ServerAuthenticator, cls
                                ).are_properties_sufficient(properties)
        if not ret:
            return False
        return bool(properties.get("channel-binding"))


########NEW FILE########
__FILENAME__ = xfacebookplatform
#
# (C) Copyright 2012 Ramnath Krishnamurthy <k.ramnath@gmail.com>
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
"""XFacebookPlatform authentication mechanism for PyXMPP SASL implementation.

Normative reference:
  - `RFC 4752 <http://www.ietf.org/rfc/rfc4752.txt>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import logging

from .core import ClientAuthenticator, Response, Success
from .core import sasl_mechanism

import time, urllib

logger = logging.getLogger("pyxmpp2.sasl.xfb")

@sasl_mechanism(name='X-FACEBOOK-PLATFORM', secure=False, preference=100)
class XFacebookPlatformClientAuthenticator(ClientAuthenticator):
    """Provides client-side XFacebookPlatform authentication."""
    def __init__(self):
        self.access_token = None
        self.api_key = None
        ClientAuthenticator.__init__(self)

    @classmethod
    def are_properties_sufficient(cls, properties):
        if ('facebook_access_token' in properties
                            and 'facebook_api_key' in properties):
            return True
        return False

    def start(self, properties):
        self.access_token = properties['facebook_access_token']
        self.api_key = properties['facebook_api_key']
        return Response(None)

    def challenge(self, challenge):
        in_params = dict([part.split('=') for part in challenge.split('&')])
        out_params = {}
        out_params['nonce'] = in_params['nonce']
        out_params['method'] = in_params['method']
        out_params['access_token'] = self.access_token
        out_params['api_key'] = self.api_key
        out_params['call_id'] = float(round(time.time() * 1000))
        out_params['v'] = '1.0'
        data = urllib.urlencode(out_params)
        return Response(data)

    def finish(self, data):
        return Success(None)


########NEW FILE########
__FILENAME__ = listener
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""TCP Socket listener
======================
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import threading
import socket
import logging

try:
    from socket import SOMAXCONN
except ImportError:
    SOMAXCONN = 5

from ..mainloop.interfaces import IOHandler, HandlerReady
from ..exceptions import PyXMPPIOError

logger = logging.getLogger("pyxmpp2.server.listener")

from ..transport import BLOCKING_ERRORS



class TCPListener(IOHandler):
    """Listens on a TCPSocket calling a function on incoming connection.

    :Ivariables:
        - `_lock`: thread synchronisaton lock
        - `_socket`: the listening socket
        - `_target`: function to be called with accepted connection. It should
          expect two arguments: a connected socket and a socket address (as
          returned by accept)
    :Types:
        - `_lock`: :std:`threading.RLock`
        - `_socket`: socket object
        - `_target`: callable
    """
    _socket = None
    def __init__(self, family, address, target):
        """Initialize the `TCPListener` object and create the socket.

        :Parameters:
            - `family`: address family (:std:`socket.AF_INET` or
              :std:`socket.AF_INET6`)
            - `address`: address to listen on (address, port)
            - `target`: function to call on an accepted connection
        """
        self._socket = None
        self._lock = threading.RLock()
        self._target = target
        sock = socket.socket(family, socket.SOCK_STREAM)
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind(address)
        except:
            sock.close()
            raise
        self._socket = sock

    def __del__(self):
        if self._socket:
            self._socket.close()
            self._socket = None

    def close(self):
        with self._lock:
            if self._socket:
                self._socket.close()
                self._socket = None

    def prepare(self):
        """When connecting start the next connection step and schedule
        next `prepare` call, when connected return `HandlerReady()`
        """
        with self._lock:
            if self._socket:
                self._socket.listen(SOMAXCONN)
                self._socket.setblocking(False)
            return HandlerReady()

    def fileno(self):
        """Return file descriptor to poll or select."""
        with self._lock:
            if self._socket:
                return self._socket.fileno()

    def is_readable(self):
        with self._lock:
            return self._socket is not None

    def wait_for_readability(self):
        with self._lock:
            return self._socket is not None

    def is_writable(self):
        return False

    def wait_for_writability(self):
        return False

    def handle_write(self):
        return

    def handle_read(self):
        """
        Accept any incoming connections.
        """
        with self._lock:
            logger.debug("handle_read()")
            if self._socket is None:
                return
            while True:
                try:
                    sock, address = self._socket.accept()
                except socket.error, err:
                    if err.args[0] in BLOCKING_ERRORS:
                        break
                    else:
                        raise
                logger.debug("Accepted connection from: {0!r}".format(address))
                self._target(sock, address)

    def handle_hup(self):
        self.close()

    def handle_err(self):
        self.close()
        raise PyXMPPIOError("Unhandled error on socket")

    def handle_nval(self):
        self.close()
        raise PyXMPPIOError("Invalid file descriptor used in main event loop")

########NEW FILE########
__FILENAME__ = session
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# pylint: disable-msg=W0201

"""IM Session establishement implementation.

This module provides a stream feature handler to implement the
IM session establishment request defined in :RFC:`3921`, but dropped
in :RFC:`6120`. The implementation is needed for backward compatibility.

Normative reference:
  - :RFC:`3921`
  - :RFC:`6120` (Appendix E. states it should be no-op now, when implemented
    on server side)
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import logging

from .etree import ElementTree

from .constants import SESSION_QNP
from .streamevents import AuthorizedEvent
from .exceptions import FatalStreamError
from .stanzapayload import XMLPayload
from .iq import Iq
from .interfaces import XMPPFeatureHandler
from .interfaces import iq_set_stanza_handler
from .interfaces import StreamFeatureHandler
from .interfaces import EventHandler, event_handler

logger = logging.getLogger("pyxmpp2.session")

SESSION_TAG = SESSION_QNP + u"session"

class SessionHandler(StreamFeatureHandler, XMPPFeatureHandler, EventHandler):
    """:RFC:`3921` session establishment implementation.

    """
    def __init__(self):
        """Initialize the SASL handler"""
        super(SessionHandler, self).__init__()

    def make_stream_features(self, stream, features):
        established = getattr(stream, "_session_established", False)
        if stream.peer_authenticated and not established:
            ElementTree.SubElement(features, SESSION_TAG)

    def handle_stream_features(self, stream, features):
        pass

    @event_handler(AuthorizedEvent)
    def handle_authorized(self, event):
        """Send session esteblishment request if the feature was advertised by
        the server.
        """
        stream = event.stream
        if not stream:
            return
        if not stream.initiator:
            return
        if stream.features is None:
            return
        element = stream.features.find(SESSION_TAG)
        if element is None:
            return
        logger.debug("Establishing IM session")
        stanza = Iq(stanza_type = "set")
        payload = XMLPayload(ElementTree.Element(SESSION_TAG))
        stanza.set_payload(payload)
        self.stanza_processor.set_response_handlers(stanza,
                                        self._session_success,
                                        self._session_error)
        stream.send(stanza)

    def _session_success(self, stanza):
        """Handle session establishment success.

        [initiating entity only]

        :Parameters:
            - `stanza`: <iq type="result"/> stanza received.

        """
        # pylint: disable-msg=R0201,W0613
        logger.debug("Session established")

    def _session_error(self, stanza): # pylint: disable-msg=R0201,W0613
        """Handle resource session establishment error.

        [initiating entity only]

        :raise FatalStreamError:"""
        raise FatalStreamError("Session establishment failed")

    @iq_set_stanza_handler(XMLPayload, SESSION_TAG)
    def handle_bind_iq_set(self, stanza):
        """Handler <iq type="set"/> for session establishment."""
        # pylint: disable-msg=R0201
        logger.debug("Accepting session establishment request.")
        return stanza.make_result_response()

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = settings
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# pylint: disable-msg=W0201

"""General settings container.

The behaviour of the XMPP implementation may be controlled by many, many
parameters, like addresses, authetication methods, TLS settings, keep alive,
etc.
Those need to be passed from one component to other and passing it directly
via function parameters would only mess up the API.

Instead an `XMPPSettings` object will be used to pass all the optional
parameters. It will also provide the defaults.

This is also a mechanism for dependency injection, allowing different
components share the same objects, like event queue or DNS resolver
implementation.
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import sys
import argparse
import logging

from collections import MutableMapping

logger = logging.getLogger("pyxmpp2.settings")

class _SettingDefinition(object):
    """A PyXMPP2 setting meta-data and defaults."""
    # pylint: disable-msg=R0902,R0903
    def __init__(self, name, type = unicode, default = None, factory = None,
                        cache = False, default_d = None, doc = None,
                        cmdline_help = None, validator = None, basic = False):
        # pylint: disable-msg=W0622,R0913
        self.name = name
        self.type = type
        self.default = default
        self.factory = factory
        self.cache = cache
        self.default_d = default_d
        self.doc = doc
        self.cmdline_help = cmdline_help
        self.basic = basic
        self.validator = validator

class XMPPSettings(MutableMapping):
    """Container for various parameters used all over PyXMPP.

    It can be used like a regular dictionary, but will provide reasonable
    defaults for PyXMPP for parameters which are not explicitely set.

    All known PyXMPP settings are included in the :r:`settings list`.

    :CVariables:
        - `_defaults`: defaults for registered parameters.
        - `_defaults_factories`: factory functions providing default values
          which cannot be hard-coded.
    :Ivariables:
        - `_settings`: current values of the parameters explicitely set.
    """
    _defs = {}
    def __init__(self, data = None):
        """Create settings, optionally initialized with `data`.

        :Parameters:
            - `data`: initial data
        :Types:
            - `data`: any mapping, including `XMPPSettings`
        """
        if data is None:
            self._settings = {}
        else:
            self._settings = dict(data)
    def __len__(self):
        """Number of parameters set."""
        return len(self._settings)
    def __iter__(self):
        """Iterate over the parameter names."""
        for key in self._settings.iterkeys():
            return self[key]
    def __contains__(self, key):
        """Check if a parameter is set.

        :Parameters:
            - `key`: the parameter name
        :Types:
            - `key`: `unicode`
        """
        return key in self._settings
    def __getitem__(self, key):
        """Get a parameter value. Return the default if no value is set
        and the default is provided by PyXMPP.

        :Parameters:
            - `key`: the parameter name
        :Types:
            - `key`: `unicode`
        """
        return self.get(key, required = True)
    def __setitem__(self, key, value):
        """Set a parameter value.

        :Parameters:
            - `key`: the parameter name
            - `value`: the new value
        :Types:
            - `key`: `unicode`
        """
        self._settings[unicode(key)] = value
    def __delitem__(self, key):
        """Unset a parameter value.

        :Parameters:
            - `key`: the parameter name
        :Types:
            - `key`: `unicode`
        """
        del self._settings[key]
    def get(self, key, local_default = None, required = False):
        """Get a parameter value.

        If parameter is not set, return `local_default` if it is not `None`
        or the PyXMPP global default otherwise.

        :Raise `KeyError`: if parameter has no value and no global default

        :Return: parameter value
        """
        # pylint: disable-msg=W0221
        if key in self._settings:
            return self._settings[key]
        if local_default is not None:
            return local_default
        if key in self._defs:
            setting_def = self._defs[key]
            if setting_def.default is not None:
                return setting_def.default
            factory = setting_def.factory
            if factory is None:
                return None
            value = factory(self)
            if setting_def.cache is True:
                setting_def.default = value
            return value
        if required:
            raise KeyError(key)
        return local_default
    def keys(self):
        """Return names of parameters set.

        :Returntype: - `list` of `unicode`
        """
        return self._settings.keys()
    def items(self):
        """Return names and values of parameters set.

        :Returntype: - `list` of tuples
        """
        return self._settings.items()

    def load_arguments(self, args):
        """Load settings from :std:`ArgumentParser` output.

        :Parameters:
            - `args`: output of argument parsed based on the one
              returned by `get_arg_parser()`
        """
        for name, setting in self._defs.items():
            if sys.version_info.major < 3:
                # pylint: disable-msg=W0404
                from locale import getpreferredencoding
                encoding = getpreferredencoding()
                name = name.encode(encoding, "replace")
            attr = "pyxmpp2_" + name
            try:
                self[setting.name] = getattr(args, attr)
            except AttributeError:
                pass

    @classmethod
    def add_setting(cls, name, type = unicode, default = None, factory = None,
                        cache = False, default_d = None, doc = None,
                        cmdline_help = None, validator = None, basic = False):
        """Add a new setting definition.

        :Parameters:
            - `name`: setting name
            - `type`: setting type object or type description
            - `default`: default value
            - `factory`: default value factory
            - `cache`: if `True` the `factory` will be called only once
              and its value stored as a constant default.
            - `default_d`: description of the default value
            - `doc`: setting documentation
            - `cmdline_help`: command line argument description. When not
              provided then the setting won't be available as a command-line
              option
            - `basic`: when `True` the option is considered a basic option -
              one of those which should usually stay configurable in
              an application.
            - `validator`: function validating command-line option value string
              and returning proper value for the settings objects. Defaults
              to `type`.
        :Types:
            - `name`: `unicode`
            - `type`: type or `unicode`
            - `factory`: a callable
            - `cache`: `bool`
            - `default_d`: `unicode`
            - `doc`: `unicode`
            - `cmdline_help`: `unicode`
            - `basic`: `bool`
            - `validator`: a callable
        """
        # pylint: disable-msg=W0622,R0913
        setting_def = _SettingDefinition(name, type, default, factory,
                                            cache, default_d, doc,
                                            cmdline_help, validator, basic)
        if name not in cls._defs:
            cls._defs[name] = setting_def
            return
        duplicate = cls._defs[name]
        if duplicate.type != setting_def.type:
            raise ValueError("Setting duplicate, with a different type")
        if duplicate.default != setting_def.default:
            raise ValueError("Setting duplicate, with a different default")
        if duplicate.factory != setting_def.factory:
            raise ValueError("Setting duplicate, with a different factory")

    @staticmethod
    def validate_string_list(value):
        """Validator for string lists to be used with `add_setting`."""
        try:
            if sys.version_info.major < 3:
                # pylint: disable-msg=W0404
                from locale import getpreferredencoding
                encoding = getpreferredencoding()
                value = value.decode(encoding)
            return [x.strip() for x in value.split(u",")]
        except (AttributeError, TypeError, UnicodeError):
            raise ValueError("Bad string list")

    @staticmethod
    def validate_positive_int(value):
        """Positive integer validator to be used with `add_setting`."""
        value = int(value)
        if value <= 0:
            raise ValueError("Positive number required")
        return value

    @staticmethod
    def validate_positive_float(value):
        """Positive float validator to be used with `add_setting`."""
        value = float(value)
        if value <= 0:
            raise ValueError("Positive number required")
        return value

    @staticmethod
    def get_int_range_validator(start, stop):
        """Return an integer range validator to be used with `add_setting`.

        :Parameters:
            - `start`: minimum value for the integer
            - `stop`: the upper bound (maximum value + 1)
        :Types:
            - `start`: `int`
            - `stop`: `int`

        :return: a validator function
        """
        def validate_int_range(value):
            """Integer range validator."""
            value = int(value)
            if value >= start and value < stop:
                return value
            raise ValueError("Not in <{0},{1}) range".format(start, stop))
        return validate_int_range

    @classmethod
    def list_all(cls, basic = None):
        """List known settings.

        :Parameters:
            - `basic`: When `True` then limit output to the basic settings,
              when `False` list only the extra settings.
        """
        if basic is None:
            return [s for s in cls._defs]
        else:
            return [s.name for s in cls._defs.values() if s.basic == basic]

    @classmethod
    def get_arg_parser(cls, settings = None, option_prefix = u'--',
                                                            add_help = False):
        """Make a command-line option parser.

        The returned parser may be used as a parent parser for application
        argument parser.

        :Parameters:
            - `settings`: list of PyXMPP2 settings to consider. By default
              all 'basic' settings are provided.
            - `option_prefix`: custom prefix for PyXMPP2 options. E.g.
              ``'--xmpp'`` to differentiate them from not xmpp-related
              application options.
            - `add_help`: when `True` a '--help' option will be included
              (probably already added in the application parser object)
        :Types:
            - `settings`: list of `unicode`
            - `option_prefix`: `str`
            - `add_help`:

        :return: an argument parser object.
        :returntype: :std:`argparse.ArgumentParser`
        """
        # pylint: disable-msg=R0914,R0912
        parser = argparse.ArgumentParser(add_help = add_help,
                                            prefix_chars = option_prefix[0])
        if settings is None:
            settings = cls.list_all(basic = True)

        if sys.version_info.major < 3:
            # pylint: disable-msg=W0404
            from locale import getpreferredencoding
            encoding = getpreferredencoding()
            def decode_string_option(value):
                """Decode a string option."""
                return value.decode(encoding)

        for name in settings:
            if name not in cls._defs:
                logger.debug("get_arg_parser: ignoring unknown option {0}"
                                                                .format(name))
                return
            setting = cls._defs[name]
            if not setting.cmdline_help:
                logger.debug("get_arg_parser: option {0} has no cmdline"
                                                                .format(name))
                return
            if sys.version_info.major < 3:
                name = name.encode(encoding, "replace")
            option = option_prefix + name.replace("_", "-")
            dest = "pyxmpp2_" + name
            if setting.validator:
                opt_type = setting.validator
            elif setting.type is unicode and sys.version_info.major < 3:
                opt_type = decode_string_option
            else:
                opt_type = setting.type
            if setting.default_d:
                default_s = setting.default_d
                if sys.version_info.major < 3:
                    default_s = default_s.encode(encoding, "replace")
            elif setting.default is not None:
                default_s = repr(setting.default)
            else:
                default_s = None
            opt_help = setting.cmdline_help
            if sys.version_info.major < 3:
                opt_help = opt_help.encode(encoding, "replace")
            if default_s:
                opt_help += " (Default: {0})".format(default_s)
            if opt_type is bool:
                opt_action = _YesNoAction
            else:
                opt_action = "store"
            parser.add_argument(option,
                                action = opt_action,
                                default = setting.default,
                                type = opt_type,
                                help = opt_help,
                                metavar = name.upper(),
                                dest = dest)
        return parser

class _YesNoAction(argparse.Action):
    """Custom std:`argparse` option to handle boolean options
    via '--no-' prefixes.

    For every "--something" option a "--no-something" option will be added
    storing a `False` value (original option will store `True`).
    """
    # pylint: disable-msg=R0903
    def __init__(self, option_strings, **kwargs):
        strings = []
        self.positive_strings = set()
        for string in option_strings:
            if string[0] != string[1]:
                raise ValueError("Doubly-prefixed option expected")
            strings.append(string)
            self.positive_strings.add(string)
            neg_string = string[:2] + "no" + string[1:]
            strings.append(neg_string)
        kwargs["nargs"] = 0
        super(_YesNoAction, self).__init__(strings, **kwargs)

    def __call__(self, parser, namespace, value, option_string = None):
        if option_string in self.positive_strings:
            setattr(namespace, self.dest, True)
        else:
            setattr(namespace, self.dest, False)


########NEW FILE########
__FILENAME__ = simple
#
# (C) Copyright 2005-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""Simple API for simple things like sendig messages.

The simplest way to send a message:

    >>> from pyxmpp2.simple import send_message
    >>> send_message("bob@example.org", "bob's password", "alice@example.org",
    ...                                                          "Hello Alice")

Please note, though:
    - this is inefficient for anything more than sending a single message,
      as a new connection is established and closed for each `send_message`
      call.
    - the default TLS settings are insecure (not peer certificate validation)
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import sys

from .interfaces import EventHandler, event_handler, QUIT
from .client import Client
from .jid import JID
from .streamevents import AuthorizedEvent, DisconnectedEvent
from .message import Message
from .settings import XMPPSettings

class FireAndForget(EventHandler):
    """A minimal XMPP client that just connects to a server
    and runs single function.

    :Ivariables:
        - `action`: the function to run after the stream is authorized
        - `client`: a `Client` instance to do the rest of the job
    :Types:
        - `action`: a callable accepting a single 'client' argument
        - `client`: `pyxmpp2.client.Client`
    """
    def __init__(self, local_jid, action, settings):
        self.action = action
        self.client = Client(local_jid, [self], settings)

    def run(self):
        """Request client connection and start the main loop."""
        self.client.connect()
        self.client.run()

    def disconnect(self):
        """Request disconnection and let the main loop run for a 2 more
        seconds for graceful disconnection."""
        self.client.disconnect()
        self.client.run(timeout = 2)

    @event_handler(AuthorizedEvent)
    def handle_authorized(self, event):
        """Send the initial presence after log-in."""
        # pylint: disable=W0613
        self.action(self.client)
        self.client.disconnect()

    @event_handler(DisconnectedEvent)
    def handle_disconnected(self, event):
        """Quit the main loop upon disconnection."""
        # pylint: disable=W0613,R0201
        return QUIT

def send_message(source_jid, password, target_jid, body, subject = None,
                message_type = "chat", message_thread = None, settings = None):
    """Star an XMPP session and send a message, then exit.

    :Parameters:
        - `source_jid`: sender JID
        - `password`: sender password
        - `target_jid`: recipient JID
        - `body`: message body
        - `subject`: message subject
        - `message_type`: message type
        - `message_thread`: message thread id
        - `settings`: other settings
    :Types:
        - `source_jid`: `pyxmpp2.jid.JID` or `basestring`
        - `password`: `basestring`
        - `target_jid`: `pyxmpp.jid.JID` or `basestring`
        - `body`: `basestring`
        - `subject`: `basestring`
        - `message_type`: `basestring`
        - `settings`: `pyxmpp2.settings.XMPPSettings`
    """
    # pylint: disable=R0913,R0912
    if sys.version_info.major < 3:
        # pylint: disable-msg=W0404
        from locale import getpreferredencoding
        encoding = getpreferredencoding()
        if isinstance(source_jid, str):
            source_jid = source_jid.decode(encoding)
        if isinstance(password, str):
            password = password.decode(encoding)
        if isinstance(target_jid, str):
            target_jid = target_jid.decode(encoding)
        if isinstance(body, str):
            body = body.decode(encoding)
        if isinstance(message_type, str):
            message_type = message_type.decode(encoding)
        if isinstance(message_thread, str):
            message_thread = message_thread.decode(encoding)

    if not isinstance(source_jid, JID):
        source_jid = JID(source_jid)
    if not isinstance(target_jid, JID):
        target_jid = JID(target_jid)

    msg = Message(to_jid = target_jid, body = body, subject = subject,
                                                    stanza_type = message_type)
    def action(client):
        """Send a mesage `msg` via a client."""
        client.stream.send(msg)

    if settings is None:
        settings = XMPPSettings({"starttls": True, "tls_verify_peer": False})

    if password is not None:
        settings["password"] = password

    handler = FireAndForget(source_jid, action, settings)
    try:
        handler.run()
    except KeyboardInterrupt:
        handler.disconnect()
        raise

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = stanza
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""General XMPP Stanza handling.

Normative reference:
  - `RFC 6120 <http://www.ietf.org/rfc/rfc6120.txt>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

from .etree import ElementTree, ElementClass
import random
import weakref

from .exceptions import BadRequestProtocolError, JIDMalformedProtocolError
from .jid import JID
from .stanzapayload import XMLPayload, payload_factory
from .stanzapayload import payload_class_for_element_name
from .xmppserializer import serialize
from .constants import STANZA_NAMESPACES, STANZA_CLIENT_NS, XML_LANG_QNAME
from .error import StanzaErrorElement
from .interfaces import StanzaPayload

random.seed()

class Stanza(object):
    """Base class for all XMPP stanzas.

    :Ivariables:
        - `_payload`: the stanza payload
        - `_error`: error associated a stanza of type "error"
        - `_namespace`: namespace of this stanza element
        - `_return_path`: weak reference to the return route object
    :Types:
        - `_payload`: `list` of (`unicode`, `StanzaPayload`)
        - `_error`: `pyxmpp2.error.StanzaErrorElement`
        - `_namespace`: `unicode`
        - `_return_path`: weakref to `StanzaRoute`
    """
    # pylint: disable-msg=R0902
    element_name = "Unknown"
    def __init__(self, element, from_jid = None, to_jid = None,
                            stanza_type = None, stanza_id = None,
                            error = None, error_cond = None,
                            return_path = None, language = None):
        """Initialize a Stanza object.

        :Parameters:
            - `element`: XML element of this stanza, or element name for a new
              stanza. If element is given it must not be modified later,
              unless `decode_payload()` and `mark_dirty()` methods are called
              first (the element changes won't affec the stanza then).
            - `from_jid`: sender JID.
            - `to_jid`: recipient JID.
            - `stanza_type`: staza type: one of: "get", "set", "result" or
              "error".
            - `stanza_id`: stanza id -- value of stanza's "id" attribute. If
              not given, then unique for the session value is generated.
            - `error`: error object. Ignored if `stanza_type` is not "error".
            - `error_cond`: error condition name. Ignored if `stanza_type` is
              not "error" or `error` is not None.
            - `return_path`: route for sending responses to this stanza. Will
              be weakly referenced.
            - `language`: default language for the stanza content
        :Types:
            - `element`: `unicode` or :etree:`ElementTree.Element`
            - `from_jid`: `JID`
            - `to_jid`: `JID`
            - `stanza_type`: `unicode`
            - `stanza_id`: `unicode`
            - `error`: `pyxmpp.error.StanzaErrorElement`
            - `error_cond`: `unicode`
            - `return_path`: `StanzaRoute`
            - `language`: `unicode`
        """
        # pylint: disable-msg=R0913
        self._error = None
        self._from_jid = None
        self._to_jid = None
        self._stanza_type = None
        self._stanza_id = None
        self._language = language
        if isinstance(element, ElementClass):
            self._element = element
            self._dirty = False
            self._decode_attributes()
            if not element.tag.startswith("{"):
                raise ValueError("Element has no namespace")
            else:
                self._namespace, self.element_name = element.tag[1:].split("}")
                if self._namespace not in STANZA_NAMESPACES:
                    raise BadRequestProtocolError("Wrong stanza namespace")
            self._payload = None
        else:
            self._element = None
            self._dirty = True
            self.element_name = unicode(element)
            self._namespace = STANZA_CLIENT_NS
            self._payload = []

        self._ns_prefix = "{{{0}}}".format(self._namespace)
        self._element_qname = self._ns_prefix + self.element_name

        if from_jid is not None:
            self.from_jid = from_jid

        if to_jid is not None:
            self.to_jid = to_jid

        if stanza_type:
            self.stanza_type = stanza_type

        if stanza_id:
            self.stanza_id = stanza_id

        if self.stanza_type == "error":
            if error:
                self._error = StanzaErrorElement(error)
            elif error_cond:
                self._error = StanzaErrorElement(error_cond)
            else:
                self._decode_error()

        if return_path is not None:
            self._return_path = weakref.ref(return_path)

    def _decode_attributes(self):
        """Decode attributes of the stanza XML element
        and put them into the stanza properties."""
        try:
            from_jid = self._element.get('from')
            if from_jid:
                self._from_jid = JID(from_jid)
            to_jid = self._element.get('to')
            if to_jid:
                self._to_jid = JID(to_jid)
        except ValueError:
            raise JIDMalformedProtocolError
        self._stanza_type = self._element.get('type')
        self._stanza_id = self._element.get('id')
        lang = self._element.get(XML_LANG_QNAME)
        if lang:
            self._language = lang

    def _decode_error(self):
        """Decode error element of the stanza."""
        error_qname = self._ns_prefix + "error"
        for child in self._element:
            if child.tag == error_qname:
                self._error = StanzaErrorElement(child)
                return
        raise BadRequestProtocolError("Error element missing in"
                                                            " an error stanza")

    def copy(self):
        """Create a deep copy of the stanza.

        :returntype: `Stanza`"""
        result = Stanza(self.element_name, self.from_jid, self.to_jid,
                        self.stanza_type, self.stanza_id, self.error,
                        self._return_path())
        if self._payload is None:
            self.decode_payload()
        for payload in self._payload:
            result.add_payload(payload.copy())
        return result

    def serialize(self):
        """Serialize the stanza into a Unicode XML string.

        :return: serialized stanza.
        :returntype: `unicode`"""
        return serialize(self.get_xml())

    def as_xml(self):
        """Return the XML stanza representation.

        Always return an independent copy of the stanza XML representation,
        which can be freely modified without affecting the stanza.

        :returntype: :etree:`ElementTree.Element`"""
        attrs = {}
        if self._from_jid:
            attrs['from'] = unicode(self._from_jid)
        if self._to_jid:
            attrs['to'] = unicode(self._to_jid)
        if self._stanza_type:
            attrs['type'] = self._stanza_type
        if self._stanza_id:
            attrs['id'] = self._stanza_id
        if self._language:
            attrs[XML_LANG_QNAME] = self._language
        element = ElementTree.Element(self._element_qname, attrs)
        if self._payload is None:
            self.decode_payload()
        for payload in self._payload:
            element.append(payload.as_xml())
        if self._error:
            element.append(self._error.as_xml(
                                        stanza_namespace = self._namespace))
        return element

    def get_xml(self):
        """Return the XML stanza representation.

        This returns the original or cached XML representation, which
        may be much more efficient than `as_xml`.

        Result of this function should never be modified.

        :returntype: :etree:`ElementTree.Element`"""
        if not self._dirty:
            return self._element
        element = self.as_xml()
        self._element = element
        self._dirty = False
        return element

    def decode_payload(self, specialize = False):
        """Decode payload from the element passed to the stanza constructor.

        Iterates over stanza children and creates StanzaPayload objects for
        them. Called automatically by `get_payload()` and other methods that
        access the payload.

        For the `Stanza` class stanza namespace child elements will also be
        included as the payload. For subclasses these are no considered
        payload."""
        if self._payload is not None:
            # already decoded
            return
        if self._element is None:
            raise ValueError("This stanza has no element to decode""")
        payload = []
        if specialize:
            factory = payload_factory
        else:
            factory = XMLPayload
        for child in self._element:
            if self.__class__ is not Stanza:
                if child.tag.startswith(self._ns_prefix):
                    continue
            payload.append(factory(child))
        self._payload = payload

    @property
    def from_jid(self): # pylint: disable-msg=E0202
        """Source JID of the stanza.

        :returntype: `JID`
        """
        return self._from_jid

    @from_jid.setter # pylint: disable-msg=E1101
    def from_jid(self, from_jid): # pylint: disable-msg=E0202,E0102,C0111
        if from_jid is None:
            self._from_jid = None
        else:
            self._from_jid = JID(from_jid)
        self._dirty = True

    @property
    def to_jid(self): # pylint: disable-msg=E0202
        """Destination JID of the stanza.

        :returntype: `JID`
        """
        return self._to_jid

    @to_jid.setter # pylint: disable-msg=E1101
    def to_jid(self, to_jid): # pylint: disable-msg=E0202,E0102,C0111
        if to_jid is None:
            self._to_jid = None
        else:
            self._to_jid = JID(to_jid)
        self._dirty = True

    @property
    def stanza_type(self): # pylint: disable-msg=C0111,E0202
        """Stanza type, one of: "get", "set", "result" or "error".

        :returntype: `unicode`
        """
        return self._stanza_type

    @stanza_type.setter # pylint: disable-msg=E1101
    def stanza_type(self, stanza_type): # pylint: disable-msg=E0202,E0102,C0111
        self._stanza_type = unicode(stanza_type)
        self._dirty = True

    @property
    def stanza_id(self): # pylint: disable-msg=C0111,E0202
        """Stanza id.

        :returntype: `unicode`
        """
        return self._stanza_id

    @stanza_id.setter # pylint: disable-msg=E1101
    def stanza_id(self, stanza_id): # pylint: disable-msg=E0202,E0102,C0111
        self._stanza_id = unicode(stanza_id)
        self._dirty = True

    @property
    def error(self): # pylint: disable-msg=E0202
        """Stanza error element.

        :returntype: `StanzaErrorElement`
        """
        return self._error

    @error.setter # pylint: disable-msg=E1101
    def error(self, error): # pylint: disable-msg=E0202,E0102,C0111
        self._error = error
        self._dirty = True

    @property
    def return_path(self): # pylint: disable-msg=E0202
        """Stream the stanza was received from.

        :returntype: `StanzaRoute`
        """
        return self._return_path()

    def mark_dirty(self):
        """Mark the stanza 'dirty' so the XML representation will be
        re-built the next time it is requested.

        This should be called each time the payload attached to the stanza is
        modifed."""
        self._dirty = True

    def set_payload(self, payload):
        """Set stanza payload to a single item.

        All current stanza content of will be dropped.
        Marks the stanza dirty.

        :Parameters:
            - `payload`: XML element or stanza payload object to use
        :Types:
            - `payload`: :etree:`ElementTree.Element` or `StanzaPayload`
        """
        if isinstance(payload, ElementClass):
            self._payload = [ XMLPayload(payload) ]
        elif isinstance(payload, StanzaPayload):
            self._payload = [ payload ]
        else:
            raise TypeError("Bad payload type")
        self._dirty = True

    def add_payload(self, payload):
        """Add new the stanza payload.

        Marks the stanza dirty.

        :Parameters:
            - `payload`: XML element or stanza payload object to add
        :Types:
            - `payload`: :etree:`ElementTree.Element` or `StanzaPayload`
        """
        if self._payload is None:
            self.decode_payload()
        if isinstance(payload, ElementClass):
            self._payload.append(XMLPayload(payload))
        elif isinstance(payload, StanzaPayload):
            self._payload.append(payload)
        else:
            raise TypeError("Bad payload type")
        self._dirty = True

    def get_all_payload(self, specialize = False):
        """Return list of stanza payload objects.

        :Parameters:
            - `specialize`: If `True`, then return objects of specialized
              `StanzaPayload` classes whenever possible, otherwise the
              representation already available will be used (often
              `XMLPayload`)

        :Returntype: `list` of `StanzaPayload`
        """
        if self._payload is None:
            self.decode_payload(specialize)
        elif specialize:
            for i, payload in enumerate(self._payload):
                if isinstance(payload, XMLPayload):
                    klass = payload_class_for_element_name(
                                                        payload.element.tag)
                    if klass is not XMLPayload:
                        payload = klass.from_xml(payload.element)
                        self._payload[i] = payload
        return list(self._payload)

    def get_payload(self, payload_class, payload_key = None,
                                                        specialize = False):
        """Get the first payload item matching the given class
        and optional key.

        Payloads may be addressed using a specific payload class or
        via the generic `XMLPayload` element, though the `XMLPayload`
        representation is available only as long as the element is not
        requested by a more specific type.

        :Parameters:
            - `payload_class`: requested payload class, a subclass of
              `StanzaPayload`. If `None` get the first payload in whatever
              class is available.
            - `payload_key`: optional key for additional match. When used
              with `payload_class` = `XMLPayload` this selects the element to
              match
            - `specialize`: If `True`, and `payload_class` is `None` then
              return object of a specialized `StanzaPayload` subclass whenever
              possible
        :Types:
            - `payload_class`: `StanzaPayload`
            - `specialize`: `bool`

        :Return: payload element found or `None`
        :Returntype: `StanzaPayload`
        """
        if self._payload is None:
            self.decode_payload()
        if payload_class is None:
            if self._payload:
                payload = self._payload[0]
                if specialize and isinstance(payload, XMLPayload):
                    klass = payload_class_for_element_name(
                                                        payload.element.tag)
                    if klass is not XMLPayload:
                        payload = klass.from_xml(payload.element)
                        self._payload[0] = payload
                return payload
            else:
                return None
        # pylint: disable=W0212
        elements = payload_class._pyxmpp_payload_element_name
        for i, payload in enumerate(self._payload):
            if isinstance(payload, XMLPayload):
                if payload_class is not XMLPayload:
                    if payload.xml_element_name not in elements:
                        continue
                    payload = payload_class.from_xml(payload.element)
            elif not isinstance(payload, payload_class):
                continue
            if payload_key is not None and payload_key != payload.handler_key():
                continue
            self._payload[i] = payload
            return payload
        return None

    last_id = random.randrange(1000000)

    @classmethod
    def gen_id(cls):
        """Generate stanza id unique for the session.

        :return: the new id."""
        cls.last_id += 1
        return str(cls.last_id)

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = stanzapayload
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""XMPP payload classes."""

import logging
from collections import defaultdict

from .etree import ElementClass
from .interfaces import StanzaPayload

STANZA_PAYLOAD_CLASSES = {}
STANZA_PAYLOAD_ELEMENTS = defaultdict(list)

logger = logging.getLogger("pyxmpp2.stanzapayload")

class XMLPayload(StanzaPayload):
    """Transparent XML payload for stanza.

    This object can be used for any stanza payload.
    It doesn't decode the XML element, but instead keeps it in the ElementTree
    format.

    :Ivariables:
        - `xml_element_name`: qualified name of the wrapped element
        - `element`: the wrapped element
    :Types:
        - `xml_element_name`: `unicode`
        - `element`: :etree:`ElementTree.Element`
    """
    def __init__(self, data):
        if isinstance(data, StanzaPayload):
            data = data.as_xml()
        if not isinstance(data, ElementClass):
            raise TypeError("ElementTree.Element required")
        self.xml_element_name = data.tag
        self.element = data

    @classmethod
    def from_xml(cls, element):
        return cls(element)

    def as_xml(self):
        return self.element

    @property
    def handler_key(self):
        """Return `xml_element_name` as the extra key for stanza
        handlers."""
        return self.xml_element_name

def payload_class_for_element_name(element_name):
    """Return a payload class for given element name."""
    logger.debug(" looking up payload class for element: {0!r}".format(
                                                                element_name))
    logger.debug("  known: {0!r}".format(STANZA_PAYLOAD_CLASSES))
    if element_name in STANZA_PAYLOAD_CLASSES:
        return STANZA_PAYLOAD_CLASSES[element_name]
    else:
        return XMLPayload

def payload_element_names_for_class(klass):
    """Return a payload element name for given class."""
    return STANZA_PAYLOAD_ELEMENTS[klass]

def payload_factory(element):
    """Return a specialized `StanzaPayload` object for given element.
    """
    return payload_class_for_element_name(element.tag).from_xml(element)

########NEW FILE########
__FILENAME__ = stanzaprocessor
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""Handling of XMPP stanzas.

Normative reference:
  - :RFC:`6129`
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import logging
import threading
from collections import defaultdict
import inspect

from .expdict import ExpiringDictionary
from .exceptions import ProtocolError, BadRequestProtocolError
from .exceptions import ServiceUnavailableProtocolError, NoRouteError
from .stanza import Stanza
from .message import Message
from .presence import Presence
from .stanzapayload import XMLPayload
from .iq import Iq

from .interfaces import XMPPFeatureHandler, StanzaRoute

logger = logging.getLogger("pyxmpp2.stanzaprocessor")

def stanza_factory(element, return_path = None, language = None):
    """Creates Iq, Message or Presence object for XML stanza `element`

    :Parameters:
        - `element`: the stanza XML element
        - `return_path`: object through which responses to this stanza should
          be sent (will be weakly referenced by the stanza object).
        - `language`: default language for the stanza
    :Types:
        - `element`: :etree:`ElementTree.Element`
        - `return_path`: `StanzaRoute`
        - `language`: `unicode`
    """
    tag = element.tag
    if tag.endswith("}iq") or tag == "iq":
        return Iq(element, return_path = return_path, language = language)
    if tag.endswith("}message") or tag == "message":
        return Message(element, return_path = return_path, language = language)
    if tag.endswith("}presence") or tag == "presence":
        return Presence(element, return_path = return_path, language = language)
    else:
        return Stanza(element, return_path = return_path, language = language)

class StanzaProcessor(StanzaRoute):
    """Universal stanza handler/router class.

    Provides facilities to set up custom handlers for various types of stanzas.

    :Ivariables:
        - `lock`: lock object used to synchronize access to the
          `StanzaProcessor` object.
        - `me`: local JID.
        - `peer`: remote endpoint JID.
        - `process_all_stanzas`: when `True` then all stanzas received (and
          not only those addressed to `me`) are considered local.
        - `uplink`: object to route outgoing stanzas through
    :Types:
        - `lock`: :std:`threading.RLock`
        - `me`: `JID`
        - `peer`: `JID`
        - `process_all_stanzas`: `bool`
        - `uplink`: `StanzaRoute`
    """
    # pylint: disable-msg=R0902
    def __init__(self, default_timeout = 300):
        """Initialize a `StanzaProcessor` object.

        :Parameters:
            - `default_timeout`: default timeout for IQ response handlers
        """
        self.me = None
        self.peer = None
        self.uplink = None
        self.process_all_stanzas = True
        self._iq_response_handlers = ExpiringDictionary(default_timeout)
        self._iq_handlers = defaultdict(dict)
        self._message_handlers = []
        self._presence_handlers = []
        self.lock = threading.RLock()

    def _process_handler_result(self, response):
        """Examines out the response returned by a stanza handler and sends all
        stanzas provided.

        :Parameters:
            - `response`: the response to process. `None` or `False` means 'not
              handled'. `True` means 'handled'. Stanza or stanza list means
              handled with the stanzas to send back
        :Types:
            - `response`: `bool` or `Stanza` or iterable of `Stanza`

        :Returns:
            - `True`: if `response` is `Stanza`, iterable or `True` (meaning
              the stanza was processed).
            - `False`: when `response` is `False` or `None`

        :returntype: `bool`
        """

        if response is None or response is False:
            return False

        if isinstance(response, Stanza):
            self.send(response)
            return True

        try:
            response = iter(response)
        except TypeError:
            return bool(response)

        for stanza in response:
            if isinstance(stanza, Stanza):
                self.send(stanza)
            else:
                logger.warning(u"Unexpected object in stanza handler result:"
                                                    u" {0!r}".format(stanza))
        return True

    def _process_iq_response(self, stanza):
        """Process IQ stanza of type 'response' or 'error'.

        :Parameters:
            - `stanza`: the stanza received
        :Types:
            - `stanza`: `Iq`

        If a matching handler is available pass the stanza to it.  Otherwise
        ignore it if it is "error" or "result" stanza or return
        "feature-not-implemented" error if it is "get" or "set".
        """
        stanza_id = stanza.stanza_id
        from_jid = stanza.from_jid
        if from_jid:
            ufrom = from_jid.as_unicode()
        else:
            ufrom = None
        res_handler = err_handler = None
        try:
            res_handler, err_handler = self._iq_response_handlers.pop(
                                                    (stanza_id, ufrom))
        except KeyError:
            logger.debug("No response handler for id={0!r} from={1!r}"
                                                .format(stanza_id, ufrom))
            logger.debug(" from_jid: {0!r} peer: {1!r}  me: {2!r}"
                                        .format(from_jid, self.peer, self.me))
            if ( (from_jid == self.peer or from_jid == self.me
                            or self.me and from_jid == self.me.bare()) ):
                try:
                    logger.debug("  trying id={0!r} from=None"
                                                        .format(stanza_id))
                    res_handler, err_handler = \
                            self._iq_response_handlers.pop(
                                                    (stanza_id, None))
                except KeyError:
                    pass
        if stanza.stanza_type == "result":
            if res_handler:
                response = res_handler(stanza)
            else:
                return False
        else:
            if err_handler:
                response = err_handler(stanza)
            else:
                return False
        self._process_handler_result(response)
        return True

    def process_iq(self, stanza):
        """Process IQ stanza received.

        :Parameters:
            - `stanza`: the stanza received
        :Types:
            - `stanza`: `Iq`

        If a matching handler is available pass the stanza to it.  Otherwise
        ignore it if it is "error" or "result" stanza or return
        "feature-not-implemented" error if it is "get" or "set"."""

        typ = stanza.stanza_type
        if typ in ("result", "error"):
            return self._process_iq_response(stanza)
        if typ not in ("get", "set"):
            raise BadRequestProtocolError("Bad <iq/> type")
        logger.debug("Handling <iq type='{0}'> stanza: {1!r}".format(
                                                            stanza, typ))
        payload = stanza.get_payload(None)
        logger.debug("  payload: {0!r}".format(payload))
        if not payload:
            raise BadRequestProtocolError("<iq/> stanza with no child element")
        handler = self._get_iq_handler(typ, payload)
        if not handler:
            payload = stanza.get_payload(None, specialize = True)
            logger.debug("  specialized payload: {0!r}".format(payload))
            if not isinstance(payload, XMLPayload):
                handler = self._get_iq_handler(typ, payload)
        if handler:
            response = handler(stanza)
            self._process_handler_result(response)
            return True
        else:
            raise ServiceUnavailableProtocolError("Not implemented")

    def _get_iq_handler(self, iq_type, payload):
        """Get an <iq/> handler for given iq  type and payload."""
        key = (payload.__class__, payload.handler_key)
        logger.debug("looking up iq {0} handler for {1!r}, key: {2!r}"
                            .format(iq_type, payload, key))
        logger.debug("handlers: {0!r}".format(self._iq_handlers))
        handler = self._iq_handlers[iq_type].get(key)
        return handler

    def __try_handlers(self, handler_list, stanza, stanza_type = None):
        """ Search the handler list for handlers matching
        given stanza type and payload namespace. Run the
        handlers found ordering them by priority until
        the first one which returns `True`.

        :Parameters:
            - `handler_list`: list of available handlers
            - `stanza`: the stanza to handle
            - `stanza_type`: stanza type override (value of its "type"
              attribute)

        :return: result of the last handler or `False` if no
            handler was found.
        """
        # pylint: disable=W0212
        if stanza_type is None:
            stanza_type = stanza.stanza_type
        payload = stanza.get_all_payload()
        classes = [p.__class__ for p in payload]
        keys = [(p.__class__, p.handler_key) for p in payload]
        for handler in handler_list:
            type_filter = handler._pyxmpp_stanza_handled[1]
            class_filter = handler._pyxmpp_payload_class_handled
            extra_filter = handler._pyxmpp_payload_key
            if type_filter != stanza_type:
                continue
            if class_filter:
                if extra_filter is None and class_filter not in classes:
                    continue
                if extra_filter and (class_filter, extra_filter) not in keys:
                    continue
            response = handler(stanza)
            if self._process_handler_result(response):
                return True
        return False

    def process_message(self, stanza):
        """Process message stanza.

        Pass it to a handler of the stanza's type and payload namespace.
        If no handler for the actual stanza type succeeds then hadlers
        for type "normal" are used.

        :Parameters:
            - `stanza`: message stanza to be handled
        """

        stanza_type = stanza.stanza_type
        if stanza_type is None:
            stanza_type = "normal"

        if self.__try_handlers(self._message_handlers, stanza,
                                                stanza_type = stanza_type):
            return True

        if stanza_type not in ("error", "normal"):
            # try 'normal' handler additionaly to the regular handler
            return self.__try_handlers(self._message_handlers, stanza,
                                                    stanza_type = "normal")
        return False

    def process_presence(self, stanza):
        """Process presence stanza.

        Pass it to a handler of the stanza's type and payload namespace.

        :Parameters:
            - `stanza`: presence stanza to be handled
        """

        stanza_type = stanza.stanza_type
        return self.__try_handlers(self._presence_handlers, stanza, stanza_type)

    def route_stanza(self, stanza):
        """Process stanza not addressed to us.

        Return "recipient-unavailable" return if it is not
        "error" nor "result" stanza.

        This method should be overriden in derived classes if they
        are supposed to handle stanzas not addressed directly to local
        stream endpoint.

        :Parameters:
            - `stanza`: presence stanza to be processed
        """
        if stanza.stanza_type not in ("error", "result"):
            response = stanza.make_error_response(u"recipient-unavailable")
            self.send(response)
        return True

    def process_stanza(self, stanza):
        """Process stanza received from the stream.

        First "fix" the stanza with `self.fix_in_stanza()`,
        then pass it to `self.route_stanza()` if it is not directed
        to `self.me` and `self.process_all_stanzas` is not True. Otherwise
        stanza is passwd to `self.process_iq()`, `self.process_message()`
        or `self.process_presence()` appropriately.

        :Parameters:
            - `stanza`: the stanza received.

        :returns: `True` when stanza was handled
        """

        self.fix_in_stanza(stanza)
        to_jid = stanza.to_jid

        if not self.process_all_stanzas and to_jid and (
                to_jid != self.me and to_jid.bare() != self.me.bare()):
            return self.route_stanza(stanza)

        try:
            if isinstance(stanza, Iq):
                if self.process_iq(stanza):
                    return True
            elif isinstance(stanza, Message):
                if self.process_message(stanza):
                    return True
            elif isinstance(stanza, Presence):
                if self.process_presence(stanza):
                    return True
        except ProtocolError, err:
            typ = stanza.stanza_type
            if typ != 'error' and (typ != 'result'
                                                or stanza.stanza_type != 'iq'):
                response = stanza.make_error_response(err.xmpp_name)
                self.send(response)
                err.log_reported()
            else:
                err.log_ignored()
            return
        logger.debug("Unhandled %r stanza: %r" % (stanza.stanza_type,
                                                        stanza.serialize()))
        return False

    def check_to(self, to_jid):
        """Check "to" attribute of received stream header.

        :return: `to_jid` if it is equal to `self.me`, None otherwise.

        Should be overriden in derived classes which require other logic
        for handling that attribute."""
        if to_jid != self.me:
            return None
        return to_jid

    def set_response_handlers(self, stanza, res_handler, err_handler,
                                    timeout_handler = None, timeout = None):
        """Set response handler for an IQ "get" or "set" stanza.

        This should be called before the stanza is sent.

        :Parameters:
            - `stanza`: an IQ stanza
            - `res_handler`: result handler for the stanza. Will be called
              when matching <iq type="result"/> is received. Its only
              argument will be the stanza received. The handler may return
              a stanza or list of stanzas which should be sent in response.
            - `err_handler`: error handler for the stanza. Will be called
              when matching <iq type="error"/> is received. Its only
              argument will be the stanza received. The handler may return
              a stanza or list of stanzas which should be sent in response
              but this feature should rather not be used (it is better not to
              respond to 'error' stanzas).
            - `timeout_handler`: timeout handler for the stanza. Will be called
              (with no arguments) when no matching <iq type="result"/> or <iq
              type="error"/> is received in next `timeout` seconds.
            - `timeout`: timeout value for the stanza. After that time if no
              matching <iq type="result"/> nor <iq type="error"/> stanza is
              received, then timeout_handler (if given) will be called.
        """
        # pylint: disable-msg=R0913
        self.lock.acquire()
        try:
            self._set_response_handlers(stanza, res_handler, err_handler,
                                                    timeout_handler, timeout)
        finally:
            self.lock.release()

    def _set_response_handlers(self, stanza, res_handler, err_handler,
                                timeout_handler = None, timeout = None):
        """Same as `set_response_handlers` but assume `self.lock` is
        acquired."""
        # pylint: disable-msg=R0913
        self.fix_out_stanza(stanza)
        to_jid = stanza.to_jid
        if to_jid:
            to_jid = unicode(to_jid)
        if timeout_handler:
            def callback(dummy1, dummy2):
                """Wrapper for the timeout handler to make it compatible
                with the `ExpiringDictionary` """
                timeout_handler()
            self._iq_response_handlers.set_item(
                                    (stanza.stanza_id, to_jid),
                                    (res_handler,err_handler),
                                    timeout, callback)
        else:
            self._iq_response_handlers.set_item(
                                    (stanza.stanza_id, to_jid),
                                    (res_handler, err_handler),
                                    timeout)

    def clear_response_handlers(self):
        """Remove all registered response handlers."""
        self._iq_response_handlers.clear()

    def setup_stanza_handlers(self, handler_objects, usage_restriction):
        """Install stanza handlers provided by `handler_objects`"""
        # pylint: disable=W0212
        iq_handlers = {"get": {}, "set": {}}
        message_handlers = []
        presence_handlers = []
        for obj in handler_objects:
            if not isinstance(obj, XMPPFeatureHandler):
                continue
            obj.stanza_processor = self
            for dummy, handler in inspect.getmembers(obj, callable):
                if not hasattr(handler, "_pyxmpp_stanza_handled"):
                    continue
                element_name, stanza_type = handler._pyxmpp_stanza_handled
                restr = handler._pyxmpp_usage_restriction
                if restr and restr != usage_restriction:
                    continue
                if element_name == "iq":
                    payload_class = handler._pyxmpp_payload_class_handled
                    payload_key = handler._pyxmpp_payload_key
                    if (payload_class, payload_key) in iq_handlers[stanza_type]:
                        continue
                    iq_handlers[stanza_type][(payload_class, payload_key)] = \
                            handler
                    continue
                elif element_name == "message":
                    handler_list = message_handlers
                elif element_name == "presence":
                    handler_list = presence_handlers
                else:
                    raise ValueError, "Bad handler decoration"
                handler_list.append(handler)
        with self.lock:
            self._iq_handlers = iq_handlers
            self._presence_handlers = presence_handlers
            self._message_handlers = message_handlers

    def fix_in_stanza(self, stanza):
        """Modify incoming stanza before processing it.

        This implementation does nothig. It should be overriden in derived
        classes if needed."""
        pass

    def fix_out_stanza(self, stanza):
        """Modify outgoing stanza before sending into the stream.

        This implementation does nothig. It should be overriden in derived
        classes if needed."""
        pass

    def uplink_receive(self, stanza):
        self.process_stanza(stanza)

    def send(self, stanza):
        """Send a stanza somwhere.

        The default implementation sends it via the `uplink` if it is defined
        or raises the `NoRouteError`.

        :Parameters:
            - `stanza`: the stanza to send.
        :Types:
            - `stanza`: `pyxmpp.stanza.Stanza`"""
        if self.uplink:
            self.uplink.send(stanza)
        else:
            raise NoRouteError("No route for stanza")

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = streambase
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# pylint: disable-msg=W0201

"""Core XMPP stream functionality.

Normative reference:
  - `RFC 6120 <http://xmpp.org/rfcs/rfc6120.html>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import inspect
import logging
import uuid
import re
import threading

from .etree import ElementTree, element_to_unicode

from .xmppparser import XMLStreamHandler
from .error import StreamErrorElement
from .jid import JID
from .exceptions import StreamError
from .exceptions import FatalStreamError, StreamParseError
from .constants import STREAM_QNP, XML_LANG_QNAME, STREAM_ROOT_TAG
from .settings import XMPPSettings
from .xmppserializer import serialize
from .streamevents import StreamConnectedEvent, GotFeaturesEvent
from .streamevents import AuthenticatedEvent, StreamRestartedEvent
from .stanzaprocessor import stanza_factory

from .interfaces import StreamFeatureHandler
from .interfaces import StreamFeatureHandled, StreamFeatureNotHandled

logger = logging.getLogger("pyxmpp2.streambase")

LANG_SPLIT_RE = re.compile(r"(.*)(?:-[a-zA-Z0-9])?-[a-zA-Z0-9]+$")

ERROR_TAG = STREAM_QNP + u"error"
FEATURES_TAG = STREAM_QNP + u"features"

# just to distinguish those from a domain name
IP_RE = re.compile(r"^((\d+.){3}\d+)|([0-9a-f]*:[0-9a-f:]*:[0-9a-f]*)$")

class StreamBase(XMLStreamHandler):
    """Base class for a generic XMPP stream.

    Responsible for establishing connection, parsing the stream, handling
    stream elements and passing stanzas receiver to other object.
    This doesn't provide any authentication or encryption (both required by
    the XMPP specification) and is not usable on its own.

    Whenever we say "stream" here we actually mean two streams
    (incoming and outgoing) of one connections, as defined by the XMPP
    specification.

    :Ivariables:
        - `authenticated`: `True` if local entity has authenticated to peer
        - `features`: stream features as annouced by the receiver.
        - `handlers`: handlers for stream elements
        - `initiator`: `True` if local stream endpoint is the initiating entity.
        - `lock`: RLock object used to synchronize access to Stream object.
        - `me`: local stream endpoint JID.
        - `peer_authenticated`: `True` if the peer has authenticated to us
        - `peer_language`: language of human-readable stream content selected
          by the peer
        - `peer`: remote stream endpoint JID.
        - `settings`: stream settings
        - `stanza_namespace`: default namespace of the stream
        - `tls_established`: `True` when the stream is protected by TLS
        - `transport`: transport used by this stream
        - `version`: Negotiated version of the XMPP protocol. (0,9) for the
          legacy (pre-XMPP) Jabber protocol.
        - `_element_handlers`: mapping from stream element names to lists of
          methods handling them
        - `_input_state`: `None`, "open" (<stream:stream> has been received)
          "restart" or "closed" (</stream:stream> or EOF has been received)
        - `_output_state`: `None`, "open" (<stream:stream> has been received)
          "restart" or "closed" (</stream:stream> or EOF has been received)
        - `_stanza_namespace_p`: qname prefix of the stanza namespace
        - `_stream_feature_handlers`: stream features handlers
    :Types:
        - `authenticated`: `bool`
        - `features`: :etree:`ElementTree.Element`
        - `handlers`: `list`
        - `initiator`: `bool`
        - `lock`: :std:`threading.RLock`
        - `me`: `JID`
        - `peer_authenticated`: `bool`
        - `peer_language`: `unicode`
        - `peer`: `JID`
        - `settings`: XMPPSettings
        - `stanza_namespace`: `unicode`
        - `tls_established`: `bool`
        - `transport`: `transport.XMPPTransport`
        - `version`: (`int`, `int`) tuple
        - `_element_handlers`: `dict`
        - `_input_state`: `unicode`
        - `_output_state`: `unicode`
        - `_stanza_namespace_p`: `unicode`
        - `_stream_feature_handlers`: `list` of `StreamFeatureHandler`
    """
    # pylint: disable-msg=R0902,R0904
    def __init__(self, stanza_namespace, stanza_route, handlers,
                                                            settings = None):
        """Initialize StreamBase object

        :Parameters:
          - `stanza_namespace`: stream's default namespace URI ("jabber:client"
            for client, "jabber:server" for server, etc.)
          - `stanza_route`: object to handle received stanzas
          - `handlers`: objects to handle the stream events and elements
          - `settings`: extra settings
        :Types:
          - `stanza_namespace`: `unicode`
          - `stanza_route`: `StanzaRoute`
          - `settings`: XMPPSettings
          - `handlers`: `list` of objects
        """
        XMLStreamHandler.__init__(self)
        self.lock = threading.RLock()
        if settings is None:
            settings = XMPPSettings()
        self.settings = settings
        self.stanza_namespace = stanza_namespace
        self._stanza_namespace_p = "{{{0}}}".format(stanza_namespace)
        self.stanza_route = stanza_route
        self.handlers = handlers
        self._stream_feature_handlers = []
        for handler in handlers:
            if isinstance(handler, StreamFeatureHandler):
                self._stream_feature_handlers.append(handler)
        self.me = None
        self.peer = None
        self.stream_id = None
        self.initiator = None
        self.features = None
        self.authenticated = False
        self.peer_authenticated = False
        self.tls_established = False
        self.auth_method_used = None
        self.version = None
        self.language = None
        self.peer_language = None
        self.transport = None
        self._input_state = None
        self._output_state = None
        self._element_handlers = {}

    def initiate(self, transport, to = None):
        """Initiate an XMPP connection over the `transport`.

        :Parameters:
            - `transport`: an XMPP transport instance
            - `to`: peer name
        """
        with self.lock:
            self.initiator = True
            self.transport = transport
            transport.set_target(self)
            if to:
                self.peer = JID(to)
            else:
                self.peer = None
            if transport.is_connected():
                self._initiate()

    def _initiate(self):
        """Initiate an XMPP connection over a connected `transport`.

        [ called with `lock` acquired ]
        """
        self._setup_stream_element_handlers()
        self._send_stream_start()

    def receive(self, transport, myname):
        """Receive an XMPP connection over the `transport`.

        :Parameters:
            - `transport`: an XMPP transport instance
            - `myname`: local stream endpoint name.
        """
        with self.lock:
            self.transport = transport
            transport.set_target(self)
            self.me = JID(myname)
            self.initiator = False
            self._setup_stream_element_handlers()

    def _setup_stream_element_handlers(self):
        """Set up stream element handlers.

        Scans the `handlers` list for `StreamFeatureHandler`
        instances and updates `_element_handlers` mapping with their
        methods decorated with @`stream_element_handler`
        """
        # pylint: disable-msg=W0212
        if self.initiator:
            mode = "initiator"
        else:
            mode = "receiver"
        self._element_handlers = {}
        for handler in self.handlers:
            if not isinstance(handler, StreamFeatureHandler):
                continue
            for _unused, meth in inspect.getmembers(handler, callable):
                if not hasattr(meth, "_pyxmpp_stream_element_handled"):
                    continue
                element_handled = meth._pyxmpp_stream_element_handled
                if element_handled in self._element_handlers:
                    # use only the first matching handler
                    continue
                if meth._pyxmpp_usage_restriction in (None, mode):
                    self._element_handlers[element_handled] = meth

    def disconnect(self):
        """Gracefully close the connection."""
        with self.lock:
            self.transport.disconnect()
            self._output_state = "closed"

    def event(self, event): # pylint: disable-msg=R0201
        """Handle a stream event.

        Called when connection state is changed.

        Should not be called with self.lock acquired!
        """
        event.stream = self
        logger.debug(u"Stream event: {0}".format(event))
        self.settings["event_queue"].put(event)
        return False

    def transport_connected(self):
        """Called when transport has been connected.

        Send the stream head if initiator.
        """
        with self.lock:
            if self.initiator:
                if self._output_state is None:
                    self._initiate()

    def close(self):
        """Forcibly close the connection and clear the stream state."""
        self.transport.close()

    def stream_start(self, element):
        """Process <stream:stream> (stream start) tag received from peer.

        `lock` is acquired when this method is called.

        :Parameters:
            - `element`: root element (empty) created by the parser"""
        with self.lock:
            logger.debug("input document: " + element_to_unicode(element))
            if not element.tag.startswith(STREAM_QNP):
                self._send_stream_error("invalid-namespace")
                raise FatalStreamError("Bad stream namespace")
            if element.tag != STREAM_ROOT_TAG:
                self._send_stream_error("bad-format")
                raise FatalStreamError("Bad root element")

            if self._input_state == "restart":
                event = StreamRestartedEvent(self.peer)
            else:
                event = StreamConnectedEvent(self.peer)
            self._input_state = "open"
            version = element.get("version")
            if version:
                try:
                    major, minor = version.split(".", 1)
                    major, minor = int(major), int(minor)
                except ValueError:
                    self._send_stream_error("unsupported-version")
                    raise FatalStreamError("Unsupported protocol version.")
                self.version = (major, minor)
            else:
                self.version = (0, 9)

            if self.version[0] != 1 and self.version != (0, 9):
                self._send_stream_error("unsupported-version")
                raise FatalStreamError("Unsupported protocol version.")

            peer_lang = element.get(XML_LANG_QNAME)
            self.peer_language = peer_lang
            if not self.initiator:
                lang = None
                languages = self.settings["languages"]
                while peer_lang:
                    if peer_lang in languages:
                        lang = peer_lang
                        break
                    match = LANG_SPLIT_RE.match(peer_lang)
                    if not match:
                        break
                    peer_lang = match.group(0)
                if lang:
                    self.language = lang

            if self.initiator:
                self.stream_id = element.get("id")
                peer = element.get("from")
                if peer:
                    peer = JID(peer)
                if self.peer:
                    if peer and peer != self.peer:
                        logger.debug("peer hostname mismatch: {0!r} != {1!r}"
                                                    .format(peer, self.peer))
                self.peer = peer
            else:
                to = element.get("to")
                if to:
                    to = self.check_to(to)
                    if not to:
                        self._send_stream_error("host-unknown")
                        raise FatalStreamError('Bad "to"')
                    self.me = JID(to)
                peer = element.get("from")
                if peer:
                    peer = JID(peer)
                self._send_stream_start(self.generate_id(), stream_to = peer)
                self._send_stream_features()
            self.event(event)


    def stream_end(self):
        """Process </stream:stream> (stream end) tag received from peer.
        """
        logger.debug("Stream ended")
        with self.lock:
            self._input_state = "closed"
            self.transport.disconnect()
            self._output_state = "closed"

    def stream_eof(self):
        """Process stream EOF.
        """
        self.stream_end()

    def stream_element(self, element):
        """Process first level child element of the stream).

        :Parameters:
            - `element`: XML element received
        :Types:
            - `element`: :etree:`ElementTree.Element`
        """
        with self.lock:
            self._process_element(element)

    def stream_parse_error(self, descr):
        """Called when an error is encountered in the stream.

        :Parameters:
            - `descr`: description of the error
        :Types:
            - `descr`: `unicode`"""
        self.send_stream_error("not-well-formed")
        raise StreamParseError(descr)

    def _send_stream_start(self, stream_id = None, stream_to = None):
        """Send stream start tag."""
        if self._output_state in ("open", "closed"):
            raise StreamError("Stream start already sent")
        if not self.language:
            self.language = self.settings["language"]
        if stream_to:
            stream_to = unicode(stream_to)
        elif self.peer and self.initiator:
            stream_to = unicode(self.peer)
        stream_from = None
        if self.me and (self.tls_established or not self.initiator):
            stream_from = unicode(self.me)
        if stream_id:
            self.stream_id = stream_id
        else:
            self.stream_id = None
        self.transport.send_stream_head(self.stanza_namespace,
                                        stream_from, stream_to,
                                    self.stream_id, language = self.language)
        self._output_state = "open"

    def send_stream_error(self, condition):
        """Send stream error element.

        :Parameters:
            - `condition`: stream error condition name, as defined in the
              XMPP specification.
        """
        with self.lock:
            self._send_stream_error(condition)

    def _send_stream_error(self, condition):
        """Same as `send_stream_error`, but expects `lock` acquired.
        """
        if self._output_state is "closed":
            return
        if self._output_state in (None, "restart"):
            self._send_stream_start()
        element = StreamErrorElement(condition).as_xml()
        self.transport.send_element(element)
        self.transport.disconnect()
        self._output_state = "closed"

    def _restart_stream(self):
        """Restart the stream as needed after SASL and StartTLS negotiation."""
        self._input_state = "restart"
        self._output_state = "restart"
        self.features = None
        self.transport.restart()
        if self.initiator:
            self._send_stream_start(self.stream_id)

    def _make_stream_features(self):
        """Create the <features/> element for the stream.

        [receving entity only]

        :returns: new <features/> element
        :returntype: :etree:`ElementTree.Element`"""
        features = ElementTree.Element(FEATURES_TAG)
        for handler in self._stream_feature_handlers:
            handler.make_stream_features(self, features)
        return features

    def _send_stream_features(self):
        """Send stream <features/>.

        [receiving entity only]"""
        self.features = self._make_stream_features()
        self._write_element(self.features)

    def write_element(self, element):
        """Write XML `element` to the stream.

        :Parameters:
            - `element`: Element node to send.
        :Types:
            - `element`: :etree:`ElementTree.Element`
        """
        with self.lock:
            self._write_element(element)

    def _write_element(self, element):
        """Same as `write_element` but with `lock` already acquired.
        """
        self.transport.send_element(element)

    def send(self, stanza):
        """Write stanza to the stream.

        :Parameters:
            - `stanza`: XMPP stanza to send.
        :Types:
            - `stanza`: `pyxmpp2.stanza.Stanza`
        """
        with self.lock:
            return self._send(stanza)

    def _send(self, stanza):
        """Same as `send` but assume `lock` is acquired."""
        self.fix_out_stanza(stanza)
        element = stanza.as_xml()
        self._write_element(element)

    def _process_element(self, element):
        """Process first level element of the stream.

        The element may be stream error or features, StartTLS
        request/response, SASL request/response or a stanza.

        :Parameters:
            - `element`: XML element
        :Types:
            - `element`: :etree:`ElementTree.Element`
        """
        tag = element.tag
        if tag in self._element_handlers:
            handler = self._element_handlers[tag]
            logger.debug("Passing element {0!r} to method {1!r}"
                                                .format(element, handler))
            handled = handler(self, element)
            if handled:
                return
        if tag.startswith(self._stanza_namespace_p):
            stanza = stanza_factory(element, self, self.language)
            self.uplink_receive(stanza)
        elif tag == ERROR_TAG:
            error = StreamErrorElement(element)
            self.process_stream_error(error)
        elif tag == FEATURES_TAG:
            logger.debug("Got features element: {0}".format(serialize(element)))
            self._got_features(element)
        else:
            logger.debug("Unhandled element: {0}".format(serialize(element)))
            logger.debug(" known handlers: {0!r}".format(
                                                    self._element_handlers))

    def uplink_receive(self, stanza):
        """Handle stanza received from the stream."""
        with self.lock:
            if self.stanza_route:
                self.stanza_route.uplink_receive(stanza)
            else:
                logger.debug(u"Stanza dropped (no route): {0!r}".format(stanza))

    def process_stream_error(self, error):
        """Process stream error element received.

        :Parameters:
            - `error`: error received

        :Types:
            - `error`: `StreamErrorElement`
        """
        # pylint: disable-msg=R0201
        logger.debug("Unhandled stream error: condition: {0} {1!r}"
                            .format(error.condition_name, error.serialize()))

    def check_to(self, to):
        """Check "to" attribute of received stream header.

        :return: `to` if it is equal to `me`, None otherwise.

        Should be overriden in derived classes which require other logic
        for handling that attribute."""
        if to != self.me:
            return None
        return to

    def generate_id(self):
        """Generate a random and unique stream ID.

        :return: the id string generated."""
        # pylint: disable-msg=R0201
        return unicode(uuid.uuid4())

    def _got_features(self, features):
        """Process incoming <stream:features/> element.

        [initiating entity only]

        The received features node is available in `features`."""
        self.features = features
        logger.debug("got features, passing to event handlers...")
        handled = self.event(GotFeaturesEvent(self.features))
        logger.debug("  handled: {0}".format(handled))
        if not handled:
            mandatory_handled = []
            mandatory_not_handled = []
            logger.debug("  passing to stream features handlers: {0}"
                                    .format(self._stream_feature_handlers))
            for handler in self._stream_feature_handlers:
                ret = handler.handle_stream_features(self, self.features)
                if ret is None:
                    continue
                elif isinstance(ret, StreamFeatureHandled):
                    if ret.mandatory:
                        mandatory_handled.append(unicode(ret))
                        break
                    break
                elif isinstance(ret, StreamFeatureNotHandled):
                    if ret.mandatory:
                        mandatory_not_handled.append(unicode(ret))
                        break
                else:
                    raise ValueError("Wrong value returned from a stream"
                            " feature handler: {0!r}".format(ret))
            if mandatory_not_handled and not mandatory_handled:
                self.send_stream_error("unsupported-feature")
                raise FatalStreamError(
                        u"Unsupported mandatory-to-implement features: "
                                        + u" ".join(mandatory_not_handled))

    def is_connected(self):
        """Check if stream is is_connected and stanzas may be sent.

        :return: True if stream connection is active."""
        return self.transport.is_connected() and self._output_state == "open"

    def set_peer_authenticated(self, peer, restart_stream = False):
        """Mark the other side of the stream authenticated as `peer`

        :Parameters:
            - `peer`: local JID just authenticated
            - `restart_stream`: `True` when stream should be restarted (needed
              after SASL authentication)
        :Types:
            - `peer`: `JID`
            - `restart_stream`: `bool`
        """
        with self.lock:
            self.peer_authenticated = True
            self.peer = peer
            if restart_stream:
                self._restart_stream()
        self.event(AuthenticatedEvent(self.peer))

    def set_authenticated(self, me, restart_stream = False):
        """Mark stream authenticated as `me`.

        :Parameters:
            - `me`: local JID just authenticated
            - `restart_stream`: `True` when stream should be restarted (needed
              after SASL authentication)
        :Types:
            - `me`: `JID`
            - `restart_stream`: `bool`
        """
        with self.lock:
            self.authenticated = True
            self.me = me
            if restart_stream:
                self._restart_stream()
        self.event(AuthenticatedEvent(self.me))

    def fix_in_stanza(self, stanza):
        """Fix incoming stanza, setting the implicit fields.

        Used for for servers side of client stream to set proper stanza from.
        """
        # pylint: disable-msg=R0201
        return stanza

    def fix_out_stanza(self, stanza):
        """Fix outgoing, setting or clearing the implicit fields.

        Used for for client side of client stream to clear the 'from'
        attribute.
        """
        # pylint: disable-msg=R0201
        return stanza

    @property
    def auth_properties(self):
        """Authentication properties of the stream.

        Derived from the transport with 'local-jid' and 'service-type' added.
        """
        props = dict(self.settings["extra_auth_properties"])
        if self.transport:
            props.update(self.transport.auth_properties)
        props["local-jid"] = self.me
        props["service-type"] = "xmpp"
        return props

def _languages_factory(settings):
    """Make the default value of the :r:`languages setting`."""
    return [settings["language"]]

XMPPSettings.add_setting(u"language", type = unicode, default = u"en",
        cmdline_help = u"Preferred language of the XMPP stream",
        doc = u"""The preferred language of the XMPP stream."""
    )
XMPPSettings.add_setting(u"languages", type = u"list of ``unicode``",
        validator = XMPPSettings.validate_string_list,
        factory = _languages_factory,
        cmdline_help = u"Accepted languages of the XMPP stream",
        doc = u"""When the remote entity selects one of these languages
on their stream, the same language will be sent in our stream declaration."""
    )
XMPPSettings.add_setting(u"extra_auth_properties", type = "dictionary",
        default = {},
        doc = u"""Extra properties to pass to the SASL authenticators."""
    )

XMPPSettings.add_setting(u"extra_ns_prefixes", type = "prefix -> uri mapping",
        default = {},
        doc = u"""Extra namespace prefix declarations to use at the stream root
element."""
    )

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = streamevents
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# pylint: disable-msg=W0201

"""XMPP stream events."""

# pylint: disable-msg=R0903,W0231

from __future__ import absolute_import, division

from .mainloop.interfaces import Event

class StreamEvent(Event):
    """Base class for all stream events."""
    # pylint: disable-msg=W0223,W0232
    stream = None

class AuthenticatedEvent(StreamEvent):
    """Event raised after stream authentication is complete.
    Usually it happens after SASL authentication and before XMPP resource
    binding.

    Default action: none

    :Ivariables:
        - `authenticated_jid`: JID (bare) just authenticated
    :Types:
        - `authenticated_jid`: `pyxmpp2.jid.JID`
    """
    def __init__(self, authenticated_jid):
        self.authenticated_jid = authenticated_jid
    def __unicode__(self):
        return u"Authenticated: {0}".format(self.authenticated_jid)


class AuthorizedEvent(StreamEvent):
    """Event raised after stream authentication and authorization is complete.
    Usually it happens after SASL authentication and XMPP resource binding.

    Default action: none

    :Ivariables:
        - `authorized_jid`: JID just authorized to use the stream
    :Types:
        - `authorized_jid`: `pyxmpp2.jid.JID`
    """
    def __init__(self, authorized_jid):
        self.authorized_jid = authorized_jid
    def __unicode__(self):
        return u"Authorized: {0}".format(self.authorized_jid)

class BindingResourceEvent(StreamEvent):
    """Emitted when resource binding is initiated for the stream.

    Probably useful only for connection progres monitoring.

    :Ivariables:
        - `resource`: the resource
    :Types:
        - `resource`: `unicode`
    """
    def __init__(self, resource):
        self.resource = resource
    def __unicode__(self):
        if self.resource is None:
            return u"Requesting server-generated resource"
        else:
            return u"Binding resource '{0}'".format(self.resource)

class ConnectedEvent(StreamEvent):
    """Emitted after the stream socket is connected, just before the actual
    XMPP exchange happens.

    :Ivariables:
        - `sockaddr`: remote IP address and port
    :Types:
        - `sockaddr`: (`str`, `int`)
    """
    def __init__(self, sockaddr):
        self.sockaddr = sockaddr
    def __unicode__(self):
        ipaddr, port = self.sockaddr
        if ":" in ipaddr:
            return u"Connected to [{0}]:{1}".format(ipaddr, port)
        else:
            return u"Connected to {0}:{1}".format(ipaddr, port)

class ConnectingEvent(StreamEvent):
    """Emitted on TCP connection attempt. May happen multiple times during
    single stream connection - several addresses may be tried until one answers.

    Probably useful only for connection progres monitoring.

    :Ivariables:
        - `sockaddr`: remote IP address and port
    :Types:
        - `sockaddr`: (`str`, `int`)
    """
    def __init__(self, sockaddr):
        self.sockaddr = sockaddr
    def __unicode__(self):
        ipaddr, port = self.sockaddr
        if ":" in ipaddr:
            return u"Connecting to [{0}]:{1}...".format(ipaddr, port)
        else:
            return u"Connecting to {0}:{1}...".format(ipaddr, port)

class ConnectionAcceptedEvent(StreamEvent):
    """Emitted when a new TCP connection is accepted.

    :Ivariables:
        - `sockaddr`: remote IP address and port
    :Types:
        - `sockaddr`: (`str`, `int`)
    """
    def __init__(self, sockaddr):
        self.sockaddr = sockaddr
    def __unicode__(self):
        ipaddr, port = self.sockaddr
        if ":" in ipaddr:
            return u"Connection received from [{0}]:{1}".format(ipaddr, port)
        else:
            return u"Connection received from {0}:{1}".format(ipaddr, port)

class DisconnectedEvent(StreamEvent):
    """Emitted when the stream is disconnected. No more stanzas will
    be received and no more stanzas can be sent via this stream.

    :Ivariables:
        - `peer`: peer name
    :Types:
        - `peer`: `pyxmpp2.jid.JID`
    """
    def __init__(self, peer):
        self.peer = peer
    def __unicode__(self):
        return u"Disconnected from {0}".format(self.peer)

class GotFeaturesEvent(StreamEvent):
    """Emitted when the stream features are received.

    Default action (skipped if the handler returns `True`) may be, depending
    on the features available, one of:

    - StartTLS initiation
    - SASL authentication
    - Resource binding

    :Ivariables:
        - `features`: the <stream:features/> element
    :Types:
        - `features`: :etree:`ElementTree.Element`
    """
    def __init__(self, features):
        self.features = features
    def __unicode__(self):
        return u"Got stream features"


class ResolvingAddressEvent(StreamEvent):
    """Emitted when staring to resolve an address (A or AAAA) DNS record
    for a hostname.

    Probably useful only for connection progres monitoring.

    :Ivariables:
        - `hostname`: host name
    :Types:
        - `hostname`: `unicode`
    """
    def __init__(self, hostname):
        self.hostname = hostname
    def __unicode__(self):
        return u"Resolving address of '{0}'...".format(self.hostname)

class ResolvingSRVEvent(StreamEvent):
    """Emitted when staring to resolve an SRV DNS record for a domain.

    Probably useful only for connection progres monitoring.

    :Ivariables:
        - `domain`: domain name
        - `service`: service name
    :Types:
        - `hostname`: `unicode`
        - `service`: `unicode`
    """
    def __init__(self, domain, service):
        self.domain = domain
        self.service = service
    def __unicode__(self):
        return u"Resolving SRV record of '{0}' for '{1}'...".format(
                                                self.service, self.domain)

class StreamConnectedEvent(StreamEvent):
    """Emitted when the initial stream handshake (<stream:stream> tag exchange)
    is completed, before any authentication.

    :Ivariables:
        - `peer`: peer name
    :Types:
        - `peer`: `pyxmpp2.jid.JID`
    """
    def __init__(self, peer):
        self.peer = peer
    def __unicode__(self):
        return u"Connected to {0}".format(self.peer)

class TLSConnectingEvent(StreamEvent):
    """Emitted when the TLS handshake starts.
    """
    def __init__(self):
        pass
    def __unicode__(self):
        return u"TLS connecting"

class TLSConnectedEvent(StreamEvent):
    """Emitted when the TLS layer has been established.

    :Ivariables:
        - `cipher`: a three-value tuple containing the name of the cipher being
          used, the version of the SSL protocol that defines its use, and the
          number of secret bits being used
        - `peer_certificate`: certificate data
    :Types:
        - `cipher`: `unicode`
        - `peer_certificate`: `pyxmpp2.cert.Certificate`
    """
    def __init__(self, cipher, peer_certificate):
        self.cipher = cipher
        self.peer_certificate = peer_certificate
    def __unicode__(self):
        if self.peer_certificate and self.peer_certificate.display_name:
            return (u"TLS connected to {0} using {1} cipher {2} ({3} bits)"
                    .format(self.peer_certificate.display_name,
                            self.cipher[0], self.cipher[1], self.cipher[2]))
        return u"TLS connected using {0} cipher {1} ({2} bits)".format(
                            self.cipher[0], self.cipher[1], self.cipher[2])

class StreamRestartedEvent(StreamEvent):
    """Emitted after stream is restarted (<stream:stream> tag exchange)
    e.g. after SASL.

    :Ivariables:
        - `peer`: peer name
    :Types:
        - `peer`: `pyxmpp2.jid.JID`
    """
    def __init__(self, peer):
        self.peer = peer
    def __unicode__(self):
        return u"Connected to {0}".format(self.peer)


########NEW FILE########
__FILENAME__ = streamsasl
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# pylint: disable-msg=W0201

"""SASL support XMPP streams.

Normative reference:
  - `RFC 6120 <http://www.ietf.org/rfc/rfc3920.txt>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import logging
from binascii import a2b_base64

from .etree import ElementTree, element_to_unicode
from .jid import JID
from . import sasl
from .exceptions import SASLNotAvailable, FatalStreamError
from .exceptions import SASLMechanismNotAvailable, SASLAuthenticationFailed
from .constants import SASL_QNP
from .settings import XMPPSettings
from .interfaces import StreamFeatureHandler
from .interfaces import StreamFeatureHandled, StreamFeatureNotHandled
from .interfaces import stream_element_handler

logger = logging.getLogger("pyxmpp2.streamsasl")

class DefaultPasswordDatabase(sasl.PasswordDatabase):
    """Default password database.

    Uses the :r:`user_passwords setting` or :r:`username setting`
    and :r:`password setting`.
    """
    def __init__(self, settings):
        self.settings = settings

    def get_password(self, username, acceptable_formats, properties):
        if "plain" not in acceptable_formats:
            return None, None

        if "user_passwords" in self.settings:
            pwd_map = self.settings["user_passwords"]
            if username in pwd_map:
                return pwd_map[username], "plain"
            else:
                return None, None
        if "username" in self.settings and "password" in self.settings:
            return self.settings["password"], "plain"
        else:
            return None, None


MECHANISMS_TAG = SASL_QNP + u"mechanisms"
MECHANISM_TAG = SASL_QNP + u"mechanism"
CHALLENGE_TAG = SASL_QNP + u"challenge"
SUCCESS_TAG = SASL_QNP + u"success"
FAILURE_TAG = SASL_QNP + u"failure"
AUTH_TAG = SASL_QNP + u"auth"
RESPONSE_TAG = SASL_QNP + u"response"
ABORT_TAG = SASL_QNP + u"abort"

class StreamSASLHandler(StreamFeatureHandler):
    """SASL authentication handler XMPP streams.

    :Ivariables:
        - `peer_sasl_mechanisms`: SASL mechanisms offered by peer
        - `authenticator`: the authenticator object
    :Types:
        - `peer_sasl_mechanisms`: `list` of `unicode`
        - `authenticator`: `sasl.ClientAuthenticator` or
          `sasl.ServerAuthenticator`
    """
    def __init__(self, settings = None):
        """Initialize the SASL handler"""
        if settings is None:
            settings = XMPPSettings()
        self.settings = settings
        self.peer_sasl_mechanisms = None
        self.authenticator = None

    def make_stream_features(self, stream, features):
        """Add SASL features to the <features/> element of the stream.

        [receving entity only]

        :returns: update <features/> element."""
        mechs = self.settings['sasl_mechanisms']
        if mechs and not stream.authenticated:
            sub = ElementTree.SubElement(features, MECHANISMS_TAG)
            for mech in mechs:
                if mech in sasl.SERVER_MECHANISMS:
                    ElementTree.SubElement(sub, MECHANISM_TAG).text = mech
        return features

    def handle_stream_features(self, stream, features):
        """Process incoming <stream:features/> element.

        [initiating entity only]
        """
        element = features.find(MECHANISMS_TAG)
        self.peer_sasl_mechanisms = []
        if element is None:
            return None
        for sub in element:
            if sub.tag != MECHANISM_TAG:
                continue
            self.peer_sasl_mechanisms.append(sub.text)

        if stream.authenticated or not self.peer_sasl_mechanisms:
            return StreamFeatureNotHandled("SASL", mandatory = True)

        username = self.settings.get("username")
        if not username:
            # TODO: other rules for s2s
            if stream.me.local:
                username = stream.me.local
            else:
                username = None
        self._sasl_authenticate(stream, username, self.settings.get("authzid"))
        return StreamFeatureHandled("SASL", mandatory = True)

    @stream_element_handler(AUTH_TAG, "receiver")
    def process_sasl_auth(self, stream, element):
        """Process incoming <sasl:auth/> element.

        [receiving entity only]
        """
        if self.authenticator:
            logger.debug("Authentication already started")
            return False

        password_db = self.settings["password_database"]
        mechanism = element.get("mechanism")
        if not mechanism:
            stream.send_stream_error("bad-format")
            raise FatalStreamError("<sasl:auth/> with no mechanism")

        stream.auth_method_used = mechanism
        self.authenticator = sasl.server_authenticator_factory(mechanism,
                                                                password_db)

        content = element.text.encode("us-ascii")
        ret = self.authenticator.start(stream.auth_properties,
                                                a2b_base64(content))

        if isinstance(ret, sasl.Success):
            element = ElementTree.Element(SUCCESS_TAG)
            element.text = ret.encode()
        elif isinstance(ret, sasl.Challenge):
            element = ElementTree.Element(CHALLENGE_TAG)
            element.text = ret.encode()
        else:
            element = ElementTree.Element(FAILURE_TAG)
            ElementTree.SubElement(element, SASL_QNP + ret.reason)

        stream.write_element(element)

        if isinstance(ret, sasl.Success):
            self._handle_auth_success(stream, ret)
        elif isinstance(ret, sasl.Failure):
            raise SASLAuthenticationFailed("SASL authentication failed: {0}"
                                                            .format(ret.reason))
        return True

    def _handle_auth_success(self, stream, success):
        """Handle successful authentication.

        Send <success/> and mark the stream peer authenticated.

        [receiver only]
        """
        if not self._check_authorization(success.properties, stream):
            element = ElementTree.Element(FAILURE_TAG)
            ElementTree.SubElement(element, SASL_QNP + "invalid-authzid")
            return True
        authzid = success.properties.get("authzid")
        if authzid:
            peer = JID(success.authzid)
        elif "username" in success.properties:
            peer = JID(success.properties["username"], stream.me.domain)
        else:
            # anonymous
            peer = None
        stream.set_peer_authenticated(peer, True)

    @stream_element_handler(CHALLENGE_TAG, "initiator")
    def _process_sasl_challenge(self, stream, element):
        """Process incoming <sasl:challenge/> element.

        [initiating entity only]
        """
        if not self.authenticator:
            logger.debug("Unexpected SASL challenge")
            return False

        content = element.text.encode("us-ascii")
        ret = self.authenticator.challenge(a2b_base64(content))
        if isinstance(ret, sasl.Response):
            element = ElementTree.Element(RESPONSE_TAG)
            element.text = ret.encode()
        else:
            element = ElementTree.Element(ABORT_TAG)

        stream.write_element(element)

        if isinstance(ret, sasl.Failure):
            stream.disconnect()
            raise SASLAuthenticationFailed("SASL authentication failed")

        return True

    @stream_element_handler(RESPONSE_TAG, "receiver")
    def _process_sasl_response(self, stream, element):
        """Process incoming <sasl:response/> element.

        [receiving entity only]
        """
        if not self.authenticator:
            logger.debug("Unexpected SASL response")
            return False

        content = element.text.encode("us-ascii")
        ret = self.authenticator.response(a2b_base64(content))
        if isinstance(ret, sasl.Success):
            element = ElementTree.Element(SUCCESS_TAG)
            element.text = ret.encode()
        elif isinstance(ret, sasl.Challenge):
            element = ElementTree.Element(CHALLENGE_TAG)
            element.text = ret.encode()
        else:
            element = ElementTree.Element(FAILURE_TAG)
            ElementTree.SubElement(element, SASL_QNP + ret.reason)

        stream.write_element(element)

        if isinstance(ret, sasl.Success):
            self._handle_auth_success(stream, ret)
        elif isinstance(ret, sasl.Failure):
            raise SASLAuthenticationFailed("SASL authentication failed: {0!r}"
                                                            .format(ret.reson))
        return True

    def _check_authorization(self, properties, stream):
        """Check authorization id and other properties returned by the
        authentication mechanism.

        [receiving entity only]

        Allow only no authzid or authzid equal to current username@domain

        FIXME: other rules in s2s

        :Parameters:
            - `properties`: data obtained during authentication
        :Types:
            - `properties`: mapping

        :return: `True` if user is authorized to use a provided authzid
        :returntype: `bool`
        """
        authzid = properties.get("authzid")
        if not authzid:
            return True
        try:
            jid = JID(authzid)
        except ValueError:
            return False

        if "username" not in properties:
            result = False
        elif jid.local != properties["username"]:
            result = False
        elif jid.domain != stream.me.domain:
            result = False
        elif jid.resource:
            result = False
        else:
            result = True
        return result

    @stream_element_handler(SUCCESS_TAG, "initiator")
    def _process_sasl_success(self, stream, element):
        """Process incoming <sasl:success/> element.

        [initiating entity only]

        """
        if not self.authenticator:
            logger.debug("Unexpected SASL response")
            return False

        content = element.text

        if content:
            data = a2b_base64(content.encode("us-ascii"))
        else:
            data = None
        ret = self.authenticator.finish(data)
        if isinstance(ret, sasl.Success):
            logger.debug("SASL authentication succeeded")
            authzid = ret.properties.get("authzid")
            if authzid:
                me = JID(authzid)
            elif "username" in ret.properties:
                # FIXME: other rules for server
                me = JID(ret.properties["username"], stream.peer.domain)
            else:
                me = None
            stream.set_authenticated(me, True)
        else:
            logger.debug("SASL authentication failed")
            raise SASLAuthenticationFailed("Additional success data"
                                                        " procesing failed")
        return True

    @stream_element_handler(FAILURE_TAG, "initiator")
    def _process_sasl_failure(self, stream, element):
        """Process incoming <sasl:failure/> element.

        [initiating entity only]
        """
        _unused = stream
        if not self.authenticator:
            logger.debug("Unexpected SASL response")
            return False

        logger.debug("SASL authentication failed: {0!r}".format(
                                                element_to_unicode(element)))
        raise SASLAuthenticationFailed("SASL authentication failed")

    @stream_element_handler(ABORT_TAG, "receiver")
    def _process_sasl_abort(self, stream, element):
        """Process incoming <sasl:abort/> element.

        [receiving entity only]"""
        _unused, _unused = stream, element
        if not self.authenticator:
            logger.debug("Unexpected SASL response")
            return False

        self.authenticator = None
        logger.debug("SASL authentication aborted")
        return True

    def _sasl_authenticate(self, stream, username, authzid):
        """Start SASL authentication process.

        [initiating entity only]

        :Parameters:
            - `username`: user name.
            - `authzid`: authorization ID.
            - `mechanism`: SASL mechanism to use."""
        if not stream.initiator:
            raise SASLAuthenticationFailed("Only initiating entity start"
                                                        " SASL authentication")
        if stream.features is None or not self.peer_sasl_mechanisms:
            raise SASLNotAvailable("Peer doesn't support SASL")

        props = dict(stream.auth_properties)
        if not props.get("service-domain") and (
                                        stream.peer and stream.peer.domain):
            props["service-domain"] = stream.peer.domain
        if username is not None:
            props["username"] = username
        if authzid is not None:
            props["authzid"] = authzid
        if "password" in self.settings:
            props["password"] = self.settings["password"]
        props["available_mechanisms"] = self.peer_sasl_mechanisms
        enabled = sasl.filter_mechanism_list(
                            self.settings['sasl_mechanisms'], props,
                                            self.settings['insecure_auth'])
        if not enabled:
            raise SASLNotAvailable(
                                "None of SASL mechanism selected can be used")
        props["enabled_mechanisms"] = enabled

        mechanism = None
        for mech in enabled:
            if mech in self.peer_sasl_mechanisms:
                mechanism = mech
                break
        if not mechanism:
            raise SASLMechanismNotAvailable("Peer doesn't support any of"
                                                    " our SASL mechanisms")
        logger.debug("Our mechanism: {0!r}".format(mechanism))

        stream.auth_method_used = mechanism
        self.authenticator = sasl.client_authenticator_factory(mechanism)
        initial_response = self.authenticator.start(props)
        if not isinstance(initial_response, sasl.Response):
            raise SASLAuthenticationFailed("SASL initiation failed")

        element = ElementTree.Element(AUTH_TAG)
        element.set("mechanism", mechanism)
        if initial_response.data:
            if initial_response.encode:
                element.text = initial_response.encode()
            else:
                element.text = initial_response.data
        stream.write_element(element)

XMPPSettings.add_setting(u"username", type = unicode, default = None,
        cmdline_help = u"Username to use instead of the JID local part",
        doc = u"""The username to use instead of the JID local part."""
    )
XMPPSettings.add_setting(u"password", type = unicode, basic = True,
        default = None,
        cmdline_help = u"User password",
        doc = u"""A password for password-based SASL mechanisms."""
    )
XMPPSettings.add_setting(u"authzid", type = unicode, default = None,
        cmdline_help = u"Authorization id for SASL",
        doc = u"""The authorization-id (alternative JID) to request during the
SASL authentication."""
    )
XMPPSettings.add_setting(u"sasl_mechanisms",
        type = 'list of ``unicode``',
        validator = XMPPSettings.validate_string_list,
        default = ["SCRAM-SHA-1-PLUS", "SCRAM-SHA-1", "DIGEST-MD5", "PLAIN"],
        cmdline_help = u"SASL mechanism to enable",
        doc = u"""SASL mechanism that can be used for stream authentication."""
    )
XMPPSettings.add_setting(u"insecure_auth", basic = True,
        type = bool,
        default = False,
        cmdline_help = u"Enable insecure SASL mechanisms over unencrypted channels",
        doc = u"""Enable insecure SASL mechanisms over unencrypted channels"""
    )
XMPPSettings.add_setting(u"password_database",
        type = sasl.PasswordDatabase,
        factory = DefaultPasswordDatabase,
        default_d = "A `DefaultPasswordDatabase` instance",
        doc = u"""Object providing or checking user passwords on server."""
    )


# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = streamtls
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# pylint: disable-msg=W0201

"""TLS support for XMPP streams.

Normative reference:
  - `RFC 6120 <http://xmpp.org/rfcs/rfc6120.html>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import logging
import ssl

from ssl import SSLError

from .etree import ElementTree
from .constants import TLS_QNP
from .streambase import FatalStreamError
from .exceptions import TLSNegotiationFailed
from .settings import XMPPSettings
from .streamevents import TLSConnectedEvent

from .interfaces import StreamFeatureHandler
from .interfaces import StreamFeatureHandled, StreamFeatureNotHandled
from .interfaces import stream_element_handler
from .interfaces import EventHandler, event_handler

STARTTLS_TAG = TLS_QNP + u"starttls"
REQUIRED_TAG = TLS_QNP + u"required"
PROCEED_TAG = TLS_QNP + u"proceed"
FAILURE_TAG = TLS_QNP + u"failure"

logger = logging.getLogger("pyxmpp2.streamtls")

class StreamTLSHandler(StreamFeatureHandler, EventHandler):
    """Handler for stream TLS support.
    """
    def __init__(self, settings = None):
        """Initialize the TLS handler.

        :Parameters:
          - `settings`: settings for StartTLS.
        :Types:
          - `settings`: `XMPPSettings`
        """
        if settings is None:
            self.settings = XMPPSettings()
        else:
            self.settings = settings
        self.stream = None
        self.requested = False
        self.tls_socket = None

    def make_stream_tls_features(self, stream, features):
        """Update the <features/> element with StartTLS feature.

        [receving entity only]

        :Parameters:
            - `features`: the <features/> element of the stream.
        :Types:
            - `features`: :etree:`ElementTree.Element`

        :returns: update <features/> element.
        :returntype: :etree:`ElementTree.Element`
        """
        if self.stream and stream is not self.stream:
            raise ValueError("Single StreamTLSHandler instance can handle"
                                                            " only one stream")
        self.stream = stream
        if self.settings["starttls"] and not stream.tls_established:
            tls = ElementTree.SubElement(features, STARTTLS_TAG)
            if self.settings["tls_require"]:
                ElementTree.SubElement(tls, REQUIRED_TAG)
        return features

    def handle_stream_features(self, stream, features):
        """Process incoming StartTLS related element of <stream:features/>.

        [initiating entity only]

        """
        if self.stream and stream is not self.stream:
            raise ValueError("Single StreamTLSHandler instance can handle"
                                                            " only one stream")
        self.stream = stream
        logger.debug(" tls: handling features")
        element = features.find(STARTTLS_TAG)
        if element is None:
            logger.debug(" tls: no starttls feature found")
            if self.settings["tls_require"]:
                raise TLSNegotiationFailed("StartTLS required,"
                                                " but not supported by peer")
            return None
        if len(features) == 1:
            required = True
        else:
            required = element.find(REQUIRED_TAG) is not None
        if stream.tls_established:
            logger.warning("StartTLS offerred when already established")
            return StreamFeatureNotHandled("StartTLS", mandatory = required)

        if self.settings["starttls"]:
            logger.debug("StartTLS negotiated")
            self._request_tls()
            return StreamFeatureHandled("StartTLS", mandatory = required)
        else:
            logger.debug(" tls: not enabled")
            return StreamFeatureNotHandled("StartTLS", mandatory = required)

    def _request_tls(self):
        """Request a TLS-encrypted connection.

        [initiating entity only]"""
        self.requested = True
        element = ElementTree.Element(STARTTLS_TAG)
        self.stream.write_element(element)

    @stream_element_handler(FAILURE_TAG, "initiator")
    def _process_tls_failure(self, stream, element):
        """Handle the <failure /> element.
        """
        # pylint: disable-msg=R0201
        _unused, _unused = stream, element
        raise TLSNegotiationFailed("Peer failed to initialize TLS connection")

    @stream_element_handler(PROCEED_TAG, "initiator")
    def _process_tls_proceed(self, stream, element):
        """Handle the <proceed /> element.
        """
        # pylint: disable-msg=W0613
        if not self.requested:
            logger.debug("Unexpected TLS element: {0!r}".format(element))
            return False
        logger.debug(" tls: <proceed/> received")
        self.requested = False
        self._make_tls_connection()
        return True

    @stream_element_handler(STARTTLS_TAG, "receiver")
    def _process_tls_starttls(self, stream, element):
        """Handle <starttls/> element.
        """
        # pylint: disable-msg=R0201
        _unused, _unused = stream, element
        raise FatalStreamError("TLS not implemented for the receiving side yet")

    def _make_tls_connection(self):
        """Initiate TLS connection.

        [initiating entity only]
        """
        logger.debug("Preparing TLS connection")
        if self.settings["tls_verify_peer"]:
            cert_reqs = ssl.CERT_REQUIRED
        else:
            cert_reqs = ssl.CERT_NONE
        self.stream.transport.starttls(
                    keyfile = self.settings["tls_key_file"],
                    certfile = self.settings["tls_cert_file"],
                    server_side = not self.stream.initiator,
                    cert_reqs = cert_reqs,
                    ssl_version = ssl.PROTOCOL_TLSv1,
                    ca_certs = self.settings["tls_cacert_file"],
                    do_handshake_on_connect = False,
                    )

    @event_handler(TLSConnectedEvent)
    def handle_tls_connected_event(self, event):
        """Verify the peer certificate on the `TLSConnectedEvent`.
        """
        if self.settings["tls_verify_peer"]:
            valid = self.settings["tls_verify_callback"](event.stream,
                                                        event.peer_certificate)
            if not valid:
                raise SSLError("Certificate verification failed")
        event.stream.tls_established = True
        with event.stream.lock:
            event.stream._restart_stream() # pylint: disable-msg=W0212

    @staticmethod
    def is_certificate_valid(stream, cert):
        """Default certificate verification callback for TLS connections.

        :Parameters:
            - `cert`: certificate information
        :Types:
            - `cert`: `CertificateData`

        :return: computed verification result.
        """
        try:
            logger.debug("tls_is_certificate_valid(cert = {0!r})".format(cert))
            if not cert:
                logger.warning("No TLS certificate information received.")
                return False
            if not cert.validated:
                logger.warning("TLS certificate not validated.")
                return False
            srv_type = stream.transport._dst_service # pylint: disable=W0212
            if cert.verify_server(stream.peer, srv_type):
                logger.debug(" tls: certificate valid for {0!r}"
                                                        .format(stream.peer))
                return True
            else:
                logger.debug(" tls: certificate not valid for {0!r}"
                                                        .format(stream.peer))
                return False
        except:
            logger.exception("Exception caught while checking a certificate")
            raise

XMPPSettings.add_setting(u"starttls", type = bool, default = False,
        basic = True,
        cmdline_help = "Enable StartTLS negotiation",
        doc = u"""Enable StartTLS negotiation."""
    )

XMPPSettings.add_setting(u"tls_require", type = bool, default = False,
        basic = True,
        cmdline_help = "Require TLS stream encryption",
        doc = u"""Require TLS stream encryption."""
    )

XMPPSettings.add_setting(u"tls_verify_peer", type = bool, default = True,
        basic = True,
        cmdline_help = "Verify the peer certificate",
        doc = u"""Verify the peer certificate."""
    )

XMPPSettings.add_setting(u"tls_cert_file", type = str,
        cmdline_help = "TLS certificate file",
        doc = u"""Path to the TLS certificate file. The file should contain
the certificate, any immediate certificates needed and it may optionally
contain the private key. All in the PEM format, concatenated."""
    )

XMPPSettings.add_setting(u"tls_key_file", type = str,
        cmdline_help = "TLS certificate private key file",
        doc = u"""Path to the TLS certificate private key file (in the PEM
format). Not needed if the key is included in the file pointed by the
:r:`tls_cert_file setting`."""
    )

XMPPSettings.add_setting(u"tls_cacert_file", type = str, basic = True,
        cmdline_help = "TLS CA certificates file",
        doc = u"""Path to the TLS CA certificates file. The file should contain
the trusted CA certificates in the PEM format, concatenated."""
    )

XMPPSettings.add_setting(u"tls_verify_callback", type = "callable",
        default = StreamTLSHandler.is_certificate_valid,
        doc = u"""A function to verify if a certificate is valid and if the
remote party presenting this certificate is authorized to use the stream.
The function must accept two arguments: a stream and the certificate
to verify."""
    )

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = binding
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

import unittest
import re

from pyxmpp2.streambase import StreamBase
from pyxmpp2.streamevents import * # pylint: disable=W0401,W0614
from pyxmpp2.jid import JID
from pyxmpp2.binding import ResourceBindingHandler
from pyxmpp2.settings import XMPPSettings
from pyxmpp2.stanzaprocessor import StanzaProcessor

from pyxmpp2.interfaces import event_handler

from pyxmpp2.test._util import EventRecorder
from pyxmpp2.test._util import InitiatorSelectTestCase
from pyxmpp2.test._util import ReceiverSelectTestCase

C2S_SERVER_STREAM_HEAD = (b'<stream:stream version="1.0"'
                            b' from="127.0.0.1"'
                            b' xmlns:stream="http://etherx.jabber.org/streams"'
                            b' xmlns="jabber:client">')
C2S_CLIENT_STREAM_HEAD = (b'<stream:stream version="1.0"'
                            b' to="127.0.0.1"'
                            b' xmlns:stream="http://etherx.jabber.org/streams"'
                            b' xmlns="jabber:client">')

BIND_FEATURES = b"""<stream:features>
     <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>
</stream:features>"""

BIND_GENERATED_REQUEST = b"""<iq type="set" id="42">
  <bind  xmlns="urn:ietf:params:xml:ns:xmpp-bind">
  </bind>
</iq>
"""

BIND_GENERATED_RESPONSE = """<iq type="result" id="{0}">
  <bind  xmlns="urn:ietf:params:xml:ns:xmpp-bind">
    <jid>test@127.0.0.1/Generated</jid>
  </bind>
</iq>
"""

BIND_PROVIDED_REQUEST = b"""<iq type="set" id="42">
  <bind  xmlns="urn:ietf:params:xml:ns:xmpp-bind">
    <resource>Provided</resource>
  </bind>
</iq>
"""

BIND_PROVIDED_RESPONSE = """<iq type="result" id="{0}">
  <bind  xmlns="urn:ietf:params:xml:ns:xmpp-bind">
    <jid>test@127.0.0.1/Provided</jid>
  </bind>
</iq>
"""


STREAM_TAIL = b'</stream:stream>'

PARSE_ERROR_RESPONSE = (b'<stream:error><xml-not-well-formed'
                    b'  xmlns="urn:ietf:params:xml:ns:xmpp-streams"/>'
                                        b'</stream:error></stream:stream>')

TIMEOUT = 1.0 # seconds

class AuthorizedEventHandler(EventRecorder):
    @event_handler(AuthorizedEvent)
    def handle_authorized_event(self, event):
        # pylint: disable=R0201
        event.stream.close()
        return True

class TestBindingInitiator(InitiatorSelectTestCase):
    def test_bind_no_resource(self):
        handler = AuthorizedEventHandler()
        handlers = [ResourceBindingHandler(), handler]
        processor = StanzaProcessor()
        processor.setup_stanza_handlers(handlers, "post-auth")
        self.stream = StreamBase(u"jabber:client", processor, handlers)
        processor.uplink = self.stream
        self.stream.me = JID("test@127.0.0.1")
        self.start_transport([handler])
        self.stream.initiate(self.transport)
        self.connect_transport()
        self.server.write(C2S_SERVER_STREAM_HEAD)
        self.wait_short(1)
        self.server.write(BIND_FEATURES)
        req_id = self.wait(1,
                    expect = re.compile(br".*<iq[^>]*id=[\"']([^\"']*)[\"']"))
        self.assertIsNotNone(req_id)
        req_id = req_id.decode("utf-8")
        self.server.write(BIND_GENERATED_RESPONSE.format(req_id)
                                                            .encode("utf-8"))
        self.wait()
        self.assertFalse(self.stream.is_connected())
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [ConnectingEvent,
                    ConnectedEvent, StreamConnectedEvent, GotFeaturesEvent,
                    BindingResourceEvent, AuthorizedEvent, DisconnectedEvent])

    def test_bind(self):
        handler = AuthorizedEventHandler()
        handlers = [ResourceBindingHandler(), handler]
        processor = StanzaProcessor()
        processor.setup_stanza_handlers(handlers, "post-auth")
        self.stream = StreamBase(u"jabber:client", processor, handlers,
                                        XMPPSettings({"resource": "Provided"}))
        processor.uplink = self.stream
        self.stream.me = JID("test@127.0.0.1")
        self.start_transport([handler])
        self.stream.initiate(self.transport)
        self.connect_transport()
        self.server.write(C2S_SERVER_STREAM_HEAD)
        self.wait_short(1)
        self.server.write(BIND_FEATURES)
        req_id = self.wait(1,
                    expect = re.compile(br".*<iq[^>]*id=[\"']([^\"']*)[\"'].*"
                                            br"<resource>Provided</resource>"))
        self.assertIsNotNone(req_id)
        req_id = req_id.decode("utf-8")
        self.server.write(BIND_PROVIDED_RESPONSE.format(req_id).encode("utf-8"))
        self.wait()
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [ConnectingEvent,
                    ConnectedEvent, StreamConnectedEvent, GotFeaturesEvent,
                    BindingResourceEvent, AuthorizedEvent, DisconnectedEvent])

class TestBindingReceiver(ReceiverSelectTestCase):
    def test_bind_no_resource(self):
        handler = EventRecorder()
        handlers = [ResourceBindingHandler(), handler]
        processor = StanzaProcessor()
        self.start_transport(handlers)
        self.stream = StreamBase(u"jabber:client", processor, handlers)
        processor.uplink = self.stream
        self.stream.receive(self.transport, self.addr[0])
        self.stream.set_peer_authenticated(JID("test@127.0.0.1"))
        processor.setup_stanza_handlers(handlers, "post-auth")
        self.client.write(C2S_CLIENT_STREAM_HEAD)
        features = self.wait(
                expect = re.compile(br".*<stream:features>"
                        br"(.*<bind.*urn:ietf:params:xml:ns:xmpp-bind.*)"
                                                    br"</stream:features>"))
        self.assertIsNotNone(features)
        self.client.write(BIND_GENERATED_REQUEST)
        resource = self.wait(
                expect = re.compile(br".*<iq.*id=(?:\"42\"|'42').*>"
                            br"<bind.*<jid>test@127.0.0.1/(.*)</jid>.*</bind>"))
        self.assertTrue(resource)
        self.client.write(STREAM_TAIL)
        self.client.disconnect()
        self.wait()
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [AuthenticatedEvent,
                    StreamConnectedEvent, AuthorizedEvent, DisconnectedEvent])

    def test_bind_resource(self):
        handler = EventRecorder()
        handlers = [ResourceBindingHandler(), handler]
        processor = StanzaProcessor()
        self.start_transport(handlers)
        self.stream = StreamBase(u"jabber:client", processor, handlers)
        processor.uplink = self.stream
        self.stream.receive(self.transport, self.addr[0])
        self.stream.set_peer_authenticated(JID("test@127.0.0.1"))
        processor.setup_stanza_handlers(handlers, "post-auth")
        self.client.write(C2S_CLIENT_STREAM_HEAD)
        features = self.wait(
                expect = re.compile(br".*<stream:features>"
                    br"(.*<bind.*urn:ietf:params:xml:ns:xmpp-bind.*)"
                                                    br"</stream:features>"))
        self.assertIsNotNone(features)
        self.client.write(BIND_PROVIDED_REQUEST)
        resource = self.wait(
                expect = re.compile(br".*<iq.*id=(?:\"42\"|'42').*>"
                            br"<bind.*<jid>test@127.0.0.1/(.*)</jid>.*</bind>"))
        self.assertEqual(resource, b"Provided")
        self.client.write(STREAM_TAIL)
        self.client.disconnect()
        self.wait()
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [AuthenticatedEvent,
                    StreamConnectedEvent, AuthorizedEvent, DisconnectedEvent])

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = cert
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

"""Tests for pyxmpp2.cert"""

import os
import unittest
import socket
import ssl
import threading
import logging

from datetime import datetime

from pyxmpp2.test import _support

from pyxmpp2.jid import JID

from pyxmpp2.cert import HAVE_PYASN1
from pyxmpp2.cert import get_certificate_from_ssl_socket
from pyxmpp2.cert import get_certificate_from_file
from pyxmpp2.cert import ASN1CertificateData, BasicCertificateData

logger = logging.getLogger("pyxmpp2.test.cert")

def socket_with_cert(cert_path, key_path, cacert_path, server_cert = True):
    cert_path = os.path.join(_support.DATA_DIR, cert_path)
    key_path = os.path.join(_support.DATA_DIR, key_path)
    cacert_path = os.path.join(_support.DATA_DIR, cacert_path)
    listen_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listen_sock.bind(("127.0.0.1", 0))
    listen_sock.listen(1)
    addr = listen_sock.getsockname()
    def thread_func():
        try:
            sock = listen_sock.accept()[0]
            sock.setblocking(True) # pylint: disable=E1101
            try:
                ssl.wrap_socket(sock, key_path, cert_path,
                             server_side = server_cert, ca_certs = cacert_path)
            finally:
                sock.close()
        finally:
            listen_sock.close()
    thread = threading.Thread(target = thread_func,
                        name = "pyxmpp2.test.cert certificate provider thread")
    thread.daemon = True
    thread.start()
    client_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_sock.connect(addr)
    if server_cert:
        return ssl.wrap_socket(client_sock, cert_reqs = ssl.CERT_REQUIRED,
                        server_side = False, ca_certs = cacert_path)
    else:
        s_cert_path = os.path.join(_support.DATA_DIR, "server.pem")
        s_key_path = os.path.join(_support.DATA_DIR, "server-key.pem")
        return ssl.wrap_socket(client_sock, s_key_path, s_cert_path,
                        cert_reqs = ssl.CERT_REQUIRED, server_side = True,
                                                    ca_certs = cacert_path)

class TestCertFunctions(unittest.TestCase):
    @unittest.skipUnless("lo-network" in _support.RESOURCES,
                                        "network usage disabled")
    def test_get_certificate_from_ssl_socket(self):
        sock = socket_with_cert("server.pem", "server-key.pem", "ca.pem")
        cert = get_certificate_from_ssl_socket(sock)
        self.assertIsNotNone(cert)
        if HAVE_PYASN1:
            self.assertIsInstance(cert, ASN1CertificateData)
        else:
            self.assertIsInstance(cert, BasicCertificateData)
        self.assertTrue(cert.validated)
        self.assertTrue("server.example.org" in cert.common_names)

    @unittest.skipUnless(HAVE_PYASN1, "No pyasn1")
    def test_get_server_certificate_from_file(self):
        cert_path = os.path.join(_support.DATA_DIR, "server.pem")
        cert = get_certificate_from_file(cert_path)
        self.assertIsNotNone(cert)
        self.assertIsInstance(cert, ASN1CertificateData)
        self.assertFalse(cert.validated)
        self.assertTrue("server.example.org" in cert.common_names)

    @unittest.skipUnless(HAVE_PYASN1, "No pyasn1")
    def test_get_client_certificate_from_file(self):
        cert_path = os.path.join(_support.DATA_DIR, "client.pem")
        cert = get_certificate_from_file(cert_path)
        self.assertIsNotNone(cert)
        self.assertIsInstance(cert, ASN1CertificateData)
        self.assertFalse(cert.validated)
        self.assertTrue("user@server.example.org" in cert.alt_names["XmppAddr"])

class TestBasicCertificateData(unittest.TestCase):
    @staticmethod
    def load_certificate(name, server_cert = True):
        cert_file = name + ".pem"
        key_file = name + "-key.pem"
        sock = socket_with_cert(cert_file, key_file, "ca.pem", server_cert)
        return BasicCertificateData.from_ssl_socket(sock)

    def test_server_cert_fields(self):
        cert = self.load_certificate("server", True)
        self.assertEqual(cert.subject_name, (
                                (('organizationName', u'PyXMPP'),),
                                (('organizationalUnitName', u'Unit Tests'),),
                                (('commonName', u'server.example.org'),)
                                            ))
        self.assertIsInstance(cert.not_after, datetime)
        self.assertGreater(cert.not_after, datetime.now())
        self.assertEqual(list(cert.common_names), [u"server.example.org"])
        self.assertEqual(list(cert.alt_names["DNS"]), [u"server.example.org"])
        if not isinstance(cert, BasicCertificateData):
            self.assertEqual(list(cert.alt_names["SRVName"]),
                                        [u"_xmpp-server.server.example.org"])
        self.assertEqual(cert.display_name, u"organizationName=PyXMPP, "
                            u"organizationalUnitName=Unit Tests, "
                            u"commonName=server.example.org")
        self.assertEqual(cert.get_jids(), [JID("server.example.org")])

    def test_verify_server(self):
        cert = self.load_certificate("server", True)
        self.assertTrue(cert.verify_server(u"server.example.org"))
        self.assertTrue(cert.verify_server(JID(u"server.example.org")))
        self.assertFalse(cert.verify_server(u"wrong.example.org"))
        self.assertFalse(cert.verify_server(JID(u"wrong.example.org")))
        self.assertFalse(cert.verify_server(u"example.org"))
        self.assertFalse(cert.verify_server(u"sub.server.example.org"))


    def test_client_cert_fields(self):
        cert = self.load_certificate("client", False)
        self.assertEqual(cert.subject_name, (
                                (('organizationName', u'PyXMPP'),),
                                (('organizationalUnitName', u'Unit Tests'),),
                                (('commonName', u'Client Name'),)
                                            ))
        self.assertIsInstance(cert.not_after, datetime)
        self.assertGreater(cert.not_after, datetime.now())
        self.assertEqual(list(cert.common_names), [u"Client Name"])
        self.assertFalse(cert.alt_names.get("DNS"))
        self.assertFalse(cert.alt_names.get("SRVName"))
        if not isinstance(cert, BasicCertificateData):
            self.assertEqual(list(cert.alt_names["XmppAddr"]),
                                        [u"user@server.example.org"])
        self.assertEqual(cert.display_name, u"organizationName=PyXMPP, "
                            u"organizationalUnitName=Unit Tests, "
                            u"commonName=Client Name")
        if not isinstance(cert, BasicCertificateData):
            self.assertEqual(cert.get_jids(), [JID("user@server.example.org")])


    def test_server1_cert_fields(self):
        cert = self.load_certificate("server1", True)
        self.assertEqual(cert.subject_name, (
                                (('organizationName', u'PyXMPP'),),
                                (('organizationalUnitName', u'Unit Tests'),),
                                (('commonName', u'common-name.example.org'),)
                                            ))
        self.assertIsInstance(cert.not_after, datetime)
        self.assertGreater(cert.not_after, datetime.now())
        self.assertEqual(list(cert.common_names), [u"common-name.example.org"])
        self.assertEqual(list(cert.alt_names["DNS"]),
                                [u"dns1.example.org", u"dns2.example.org",
                                    u"*.wild.example.org"])
        if not isinstance(cert, BasicCertificateData):
            self.assertEqual(list(cert.alt_names["SRVName"]),
                                    [u"_xmpp-client.client-srv.example.org",
                                        u"_xmpp-server.server-srv.example.org"])
            self.assertEqual(list(cert.alt_names["XmppAddr"]),
                                    [u"xmppaddr1.example.org",
                                        u"xmppaddr2.example.org"])
        self.assertEqual(cert.display_name, u"organizationName=PyXMPP, "
                            u"organizationalUnitName=Unit Tests, "
                            u"commonName=common-name.example.org")
        jids = [JID("dns1.example.org"), JID("dns2.example.org")]
        if not isinstance(cert, BasicCertificateData):
            jids += [ JID("client-srv.example.org"),
                    JID("server-srv.example.org"),
                    JID("xmppaddr1.example.org"), JID("xmppaddr2.example.org")]
        self.assertEqual(set(cert.get_jids()), set(jids))

    def test_client1_cert_fields(self):
        cert = self.load_certificate("client1", False)
        self.assertEqual(cert.subject_name, (
                                (('organizationName', u'PyXMPP'),),
                                (('organizationalUnitName', u'Unit Tests'),),
                                (('commonName', u'common-name@example.org'),)
                                            ))
        self.assertIsInstance(cert.not_after, datetime)
        self.assertGreater(cert.not_after, datetime.now())
        self.assertEqual(list(cert.common_names), [u"common-name@example.org"])
        self.assertFalse(cert.alt_names.get("DNS"))
        self.assertFalse(cert.alt_names.get("SRVName"))
        if not isinstance(cert, BasicCertificateData):
            self.assertEqual(list(cert.alt_names["XmppAddr"]),
                            [u"user1@server.example.org",
                                            u"user2@server.example.org"])
        self.assertEqual(cert.display_name, u"organizationName=PyXMPP, "
                            u"organizationalUnitName=Unit Tests, "
                            u"commonName=common-name@example.org")
        if not isinstance(cert, BasicCertificateData):
            self.assertEqual(cert.get_jids(), [JID("user1@server.example.org"),
                                            JID("user2@server.example.org")])

    def test_verify_server1_wrong(self):
        cert = self.load_certificate("server1", True)
        self.assertFalse(cert.verify_server(u"common-name.example.org"))
        self.assertFalse(cert.verify_server(u"example.org"))
        self.assertFalse(cert.verify_server(u"bad.example.org"))
        self.assertFalse(cert.verify_server(u"wild.example.org"))
        self.assertFalse(cert.verify_server(u"sub.sub.wild.example.org"))
        self.assertFalse(cert.verify_server(u"client-srv.example.org",
                                                                "xmpp-server"))
        self.assertFalse(cert.verify_server(u"server-srv.example.org"))
        self.assertFalse(cert.verify_server(u"server-srv.example.org",
                                                                "xmpp-client"))

    def test_verify_server1_dns(self):
        cert = self.load_certificate("server1", True)
        self.assertTrue(cert.verify_server(u"dns1.example.org"))
        self.assertTrue(cert.verify_server(u"dns2.example.org"))

@unittest.skipUnless(HAVE_PYASN1, "No pyasn1")
class TestASN1CertificateData(TestBasicCertificateData):
    @staticmethod
    def load_certificate(name, server_cert = True):
        cert_file = os.path.join(_support.DATA_DIR, name + ".pem")
        return ASN1CertificateData.from_file(cert_file)

    def test_verify_server1_srv(self):
        cert = self.load_certificate("server1", True)
        self.assertTrue(cert.verify_server(u"client-srv.example.org"))
        self.assertTrue(cert.verify_server(u"client-srv.example.org",
                                                                "xmpp-client"))
        self.assertTrue(cert.verify_server(u"server-srv.example.org",
                                                                "xmpp-server"))

    def test_verify_server1_xmppaddr(self):
        cert = self.load_certificate("server1", True)
        self.assertTrue(cert.verify_server(u"xmppaddr1.example.org"))
        self.assertTrue(cert.verify_server(u"xmppaddr2.example.org"))

    def test_verify_server1_wildcard(self):
        cert = self.load_certificate("server1", True)
        self.assertTrue(cert.verify_server(u"sub.wild.example.org"))
        self.assertTrue(cert.verify_server(u"somethinelse.wild.example.org"))

    def test_verify_client(self):
        cert = self.load_certificate("client", False)
        self.assertEqual(cert.verify_client(), JID("user@server.example.org"))
        self.assertEqual(cert.verify_client(JID("user@server.example.org")),
                                               JID("user@server.example.org"))
        self.assertEqual(cert.verify_client(JID("other@server.example.org")),
                                               JID("user@server.example.org"))
        self.assertEqual(cert.verify_client(domains = ["server.example.org"]),
                                               JID("user@server.example.org"))
        self.assertIsNone(cert.verify_client(domains = ["bad.example.org"]))

        cert = self.load_certificate("server", True)
        self.assertIsNone(cert.verify_client())

    def test_verify_client1(self):
        cert = self.load_certificate("client1", False)
        self.assertEqual(cert.verify_client(), JID("user1@server.example.org"))
        self.assertEqual(cert.verify_client(JID("user1@server.example.org")),
                                               JID("user1@server.example.org"))
        self.assertEqual(cert.verify_client(JID("user2@server.example.org")),
                                               JID("user2@server.example.org"))
        self.assertEqual(cert.verify_client(JID("other@server.example.org")),
                                               JID("user1@server.example.org"))
        self.assertEqual(cert.verify_client(domains = ["server.example.org"]),
                                               JID("user1@server.example.org"))
        self.assertIsNone(cert.verify_client(domains = ["bad.example.org"]))

        cert = self.load_certificate("server1", True)
        self.assertIsNone(cert.verify_client())


# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = ext_version
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

import unittest
import platform

from pyxmpp2.etree import ElementTree

import pyxmpp2.version
from pyxmpp2.iq import Iq
from pyxmpp2.jid import JID
from pyxmpp2.stanzaprocessor import StanzaProcessor
from pyxmpp2.settings import XMPPSettings
from pyxmpp2.stanzapayload import XMLPayload

from pyxmpp2.ext.version import VersionPayload, VersionProvider
from pyxmpp2.ext.version import request_software_version


IQ1 = '''<iq type="get" id="1" xmlns="jabber:client">
<query xmlns="jabber:iq:version"/>
</iq>'''

IQ2 = '''<iq type="response" id="1" xmlns="jabber:client">
<query xmlns="jabber:iq:version">
  <name>NAME</name>
  <version>VERSION</version>
  <os>OS</os>
</query>
</iq>'''

class TestVersionPayload(unittest.TestCase):
    def test_parse_empty(self):
        element = ElementTree.XML(IQ1)
        payload = VersionPayload.from_xml(element[0])
        self.assertIsNone(payload.name)
        self.assertIsNone(payload.version)
        self.assertIsNone(payload.os_name)

    def test_parse_full(self):
        element = ElementTree.XML(IQ2)
        payload = VersionPayload.from_xml(element[0])
        self.assertEqual(payload.name, 'NAME')
        self.assertEqual(payload.version, 'VERSION')
        self.assertEqual(payload.os_name, 'OS')

    def test_build_empty(self):
        payload = VersionPayload()
        self.assertIsNone(payload.name)
        self.assertIsNone(payload.version)
        self.assertIsNone(payload.os_name)
        element = payload.as_xml()
        self.assertEqual(element.tag, "{jabber:iq:version}query")
        self.assertEqual(len(element), 0)

class Processor(StanzaProcessor):
    def __init__(self, handlers):
        StanzaProcessor.__init__(self)
        self.setup_stanza_handlers(handlers, "post-auth")
        self.stanzas_sent = []
    def send(self, stanza):
        self.stanzas_sent.append(stanza)

class TestVersionProvider(unittest.TestCase):
    def test_defaults(self):
        provider = VersionProvider()
        processor = Processor([provider])
        stanza = Iq(ElementTree.XML(IQ1))
        processor.uplink_receive(stanza)
        self.assertEqual(len(processor.stanzas_sent), 1)
        response = processor.stanzas_sent[0]
        self.assertIsInstance(response, Iq)
        self.assertEqual(response.stanza_type, "result")
        payload = response.get_payload(VersionPayload)
        self.assertIsInstance(payload, VersionPayload)
        self.assertEqual(payload.name, "PyXMPP2")
        self.assertEqual(payload.version, pyxmpp2.version.version)
        expected = u" ".join((platform.system(), platform.release(),
                                                        platform.machine()))
        self.assertEqual(payload.os_name, expected)

    def test_custom(self):
        settings = XMPPSettings({
                        "software_name": "NAME",
                        "software_version": "VERSION",
                        "software_os": "OS",
                            })
        provider = VersionProvider(settings)
        processor = Processor([provider])
        stanza = Iq(ElementTree.XML(IQ1))
        processor.uplink_receive(stanza)
        self.assertEqual(len(processor.stanzas_sent), 1)
        response = processor.stanzas_sent[0]
        self.assertIsInstance(response, Iq)
        self.assertEqual(response.stanza_type, "result")
        payload = response.get_payload(VersionPayload)
        self.assertIsInstance(payload, VersionPayload)
        self.assertEqual(payload.name, "NAME")
        self.assertEqual(payload.version, "VERSION")
        self.assertEqual(payload.os_name, "OS")

    def test_bad_request(self):
        provider = VersionProvider()
        processor = Processor([provider])
        stanza = Iq(ElementTree.XML(IQ2))
        stanza.stanza_type = 'set'
        processor.uplink_receive(stanza)
        self.assertEqual(len(processor.stanzas_sent), 1)
        response = processor.stanzas_sent[0]
        self.assertIsInstance(response, Iq)
        self.assertEqual(response.stanza_type, "error")
        self.assertEqual(response.error.condition.tag,
                    "{urn:ietf:params:xml:ns:xmpp-stanzas}service-unavailable")

class TestVersionRequest(unittest.TestCase):
    def test_request(self):
        payload_received = []
        errors_received = []
        def callback(payload):
            payload_received.append(payload)
        def error_callback(stanza):
            errors_received.append(stanza)
        processor = Processor([])
        request_software_version(processor, JID("test@example.org"),
                                                callback, error_callback)
        self.assertEqual(len(processor.stanzas_sent), 1)
        request = processor.stanzas_sent[0]
        self.assertIsInstance(request, Iq)
        self.assertEqual(request.stanza_type, "get")
        payload = request.get_payload(VersionPayload)
        self.assertIsNone(payload.name)
        self.assertIsNone(payload.version)
        self.assertIsNone(payload.os_name)
        response = request.make_result_response()
        payload = XMLPayload(ElementTree.XML(IQ2)[0])
        response.set_payload(payload)
        processor.uplink_receive(response)
        self.assertEqual(len(processor.stanzas_sent), 1)
        self.assertEqual(len(payload_received), 1)
        self.assertEqual(len(errors_received), 0)
        payload = payload_received[0]
        self.assertEqual(payload.name, "NAME")
        self.assertEqual(payload.version, "VERSION")
        self.assertEqual(payload.os_name, "OS")

    def test_request_error(self):
        payload_received = []
        errors_received = []
        def callback(payload):
            payload_received.append(payload)
        def error_callback(stanza):
            errors_received.append(stanza)
        processor = Processor([])
        request_software_version(processor, JID("test@example.org"),
                                                callback, error_callback)
        self.assertEqual(len(processor.stanzas_sent), 1)
        request = processor.stanzas_sent[0]
        self.assertIsInstance(request, Iq)
        self.assertEqual(request.stanza_type, "get")
        payload = request.get_payload(VersionPayload)
        self.assertIsNone(payload.name)
        self.assertIsNone(payload.version)
        self.assertIsNone(payload.os_name)
        response = request.make_error_response(u'service-unavailable')
        processor.uplink_receive(response)
        self.assertEqual(len(processor.stanzas_sent), 1)
        self.assertEqual(len(payload_received), 0)
        self.assertEqual(len(errors_received), 1)
        received = errors_received[0]
        self.assertIsInstance(received, Iq)
        self.assertEqual(received.stanza_type, "error")

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = iq
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

import unittest

from pyxmpp2.etree import ElementTree

from pyxmpp2.iq import Iq
from pyxmpp2.jid import JID
from pyxmpp2.stanzapayload import XMLPayload
from pyxmpp2.error import StanzaErrorElement

IQ1 = """
<iq xmlns="jabber:client" from='source@example.com/res'
                                to='dest@example.com' type='get' id='1'>
<payload xmlns="http://pyxmpp.jajcus.net/xmlns/test"><abc/></payload>
</iq>"""

IQ2 = """
<iq xmlns="jabber:client" to='source@example.com/res'
                                from='dest@example.com' type='result' id='1'>
<payload xmlns="http://pyxmpp.jajcus.net/xmlns/test"><abc/></payload>
</iq>"""

IQ3 = """
<iq xmlns="jabber:client" from='source@example.com/res'
                                to='dest@example.com' type='set' id='2'>
<payload xmlns="http://pyxmpp.jajcus.net/xmlns/test"><abc/></payload>
</iq>"""

IQ4 = """
<iq xmlns="jabber:client" to='source@example.com/res'
                                from='dest@example.com' type='result' id='2'>
</iq>"""

IQ5 = """
<iq xmlns="jabber:client" to='source@example.com/res'
                                from='dest@example.com' type='error' id='1'>
<payload xmlns="http://pyxmpp.jajcus.net/xmlns/test"><abc/></payload>
<error type="modify"><bad-request xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/></error>
</iq>"""


class TestIq(unittest.TestCase):
    def check_iq1(self, iq):
        self.assertEqual(iq.from_jid, JID("source@example.com/res"))
        self.assertEqual(iq.to_jid, JID("dest@example.com"))
        self.assertEqual(iq.stanza_type, "get")
        self.assertEqual(iq.stanza_id, "1")
        payload = iq.get_all_payload()
        self.assertTrue(payload)
        self.assertEqual(payload[0].xml_element_name,
                            "{http://pyxmpp.jajcus.net/xmlns/test}payload")
        self.assertTrue(len(payload[0].element) > 0)
        self.assertEqual(payload[0].element[0].tag,
                                "{http://pyxmpp.jajcus.net/xmlns/test}abc")
        self.assertFalse(iq.error)

    def check_iq2(self, iq):
        self.assertEqual(iq.to_jid, JID("source@example.com/res"))
        self.assertEqual(iq.from_jid, JID("dest@example.com"))
        self.assertEqual(iq.stanza_type, "result")
        self.assertEqual(iq.stanza_id, "1")
        payload = iq.get_all_payload()
        self.assertTrue(payload)
        self.assertEqual(payload[0].xml_element_name,
                                "{http://pyxmpp.jajcus.net/xmlns/test}payload")
        self.assertTrue(len(payload[0].element) > 0)
        self.assertEqual(payload[0].element[0].tag,
                                "{http://pyxmpp.jajcus.net/xmlns/test}abc")
        self.assertFalse(iq.error)

    def check_iq3(self, iq):
        self.assertEqual(iq.from_jid, JID("source@example.com/res"))
        self.assertEqual(iq.to_jid, JID("dest@example.com"))
        self.assertEqual(iq.stanza_type, "set")
        self.assertEqual(iq.stanza_id, "2")
        payload = iq.get_all_payload()
        self.assertTrue(payload)
        self.assertEqual(payload[0].xml_element_name,
                                "{http://pyxmpp.jajcus.net/xmlns/test}payload")
        self.assertTrue(len(payload[0].element) > 0)
        self.assertEqual(payload[0].element[0].tag,
                                "{http://pyxmpp.jajcus.net/xmlns/test}abc")
        self.assertFalse(iq.error)

    def check_iq4(self, iq):
        self.assertEqual(iq.to_jid, JID("source@example.com/res"))
        self.assertEqual(iq.from_jid, JID("dest@example.com"))
        self.assertEqual(iq.stanza_type, "result")
        self.assertEqual(iq.stanza_id, "2")
        payload = iq.get_all_payload()
        self.assertFalse(payload)
        self.assertFalse(iq.error)

    def check_iq5(self, iq):
        self.assertEqual(iq.to_jid, JID("source@example.com/res"))
        self.assertEqual(iq.from_jid, JID("dest@example.com"))
        self.assertEqual(iq.stanza_type, "error")
        self.assertEqual(iq.stanza_id, "1")
        payload = iq.get_all_payload()
        self.assertTrue(payload)
        self.assertEqual(payload[0].xml_element_name,
                                "{http://pyxmpp.jajcus.net/xmlns/test}payload")
        self.assertTrue(len(payload[0].element) > 0)
        self.assertEqual(payload[0].element[0].tag,
                                "{http://pyxmpp.jajcus.net/xmlns/test}abc")
        error = iq.error
        self.assertIsInstance(error, StanzaErrorElement)
        self.assertEqual(error.condition_name, "bad-request")

    def test_iq_get_from_xml(self):
        iq = Iq(ElementTree.XML(IQ1))
        self.check_iq1(iq)

    def test_iq_result_full_from_xml(self):
        iq = Iq(ElementTree.XML(IQ2))
        self.check_iq2(iq)

    def test_iq_set_from_xml(self):
        iq = Iq(ElementTree.XML(IQ3))
        self.check_iq3(iq)

    def test_iq_result_empty_from_xml(self):
        iq = Iq(ElementTree.XML(IQ4))
        self.check_iq4(iq)

    def test_iq_get(self):
        iq = Iq( from_jid = JID("source@example.com/res"),
                to_jid = JID("dest@example.com"),
                stanza_type = "get",
                stanza_id = 1)
        payload = ElementTree.Element(
                                "{http://pyxmpp.jajcus.net/xmlns/test}payload")
        ElementTree.SubElement(payload,
                                "{http://pyxmpp.jajcus.net/xmlns/test}abc")
        payload = XMLPayload(payload)
        iq.add_payload(payload)
        self.check_iq1(iq)
        xml = iq.as_xml()
        self.check_iq1( Iq(xml) )

    def test_iq_result_full(self):
        iq = Iq( to_jid = JID("source@example.com/res"),
                from_jid = JID("dest@example.com"),
                stanza_type = "result",
                stanza_id = 1)
        payload = ElementTree.Element(
                                "{http://pyxmpp.jajcus.net/xmlns/test}payload")
        ElementTree.SubElement(payload,
                                "{http://pyxmpp.jajcus.net/xmlns/test}abc")
        payload = XMLPayload(payload)
        iq.add_payload(payload)
        self.check_iq2(iq)
        xml = iq.as_xml()
        self.check_iq2( Iq(xml) )

    def test_iq_set(self):
        iq = Iq( from_jid = JID("source@example.com/res"),
                to_jid = JID("dest@example.com"),
                stanza_type = "set",
                stanza_id = 2)
        payload = ElementTree.Element(
                                "{http://pyxmpp.jajcus.net/xmlns/test}payload")
        ElementTree.SubElement(payload,
                                "{http://pyxmpp.jajcus.net/xmlns/test}abc")
        payload = XMLPayload(payload)
        iq.add_payload(payload)
        self.check_iq3(iq)
        xml = iq.as_xml()
        self.check_iq3( Iq(xml) )

    def test_iq_result_empty(self):
        iq = Iq( to_jid = JID("source@example.com/res"),
                from_jid = JID("dest@example.com"),
                stanza_type = "result",
                stanza_id = 2)
        self.check_iq4(iq)
        xml = iq.as_xml()
        self.check_iq4( Iq(xml) )

    def test_iq_make_result_response(self):
        iq = Iq(ElementTree.XML(IQ1))
        iq2 = iq.make_result_response()
        payload = ElementTree.Element(
                                "{http://pyxmpp.jajcus.net/xmlns/test}payload")
        ElementTree.SubElement(payload,
                                "{http://pyxmpp.jajcus.net/xmlns/test}abc")
        payload = XMLPayload(payload)
        iq2.add_payload(payload)
        self.check_iq2(iq2)

    def test_iq_make_error_response(self):
        iq = Iq(ElementTree.XML(IQ1))
        iq5 = iq.make_error_response(u"bad-request")
        self.check_iq5(iq5)
        xml = iq5.as_xml()
        self.check_iq5( Iq(xml) )

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = jid
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

"""Tests for pyxmpp2.jid"""

import sys
import unittest

import logging

from pyxmpp2.jid import JID, JIDError
from pyxmpp2 import xmppstringprep

logger = logging.getLogger("pyxmpp2.test.jid")

LONG_DOMAIN = (u"x"*60 + ".") * 16 + u"x" * 47
VALID_JIDS = [
    (u"a@b/c",
        (u"a",u"b",u"c")),
    (u"example.com",
        (None, u"example.com",None)),
    (u"example.com/Test",
        (None, u"example.com","Test")),
    (u"jajcus@jajcus.net",
        (u"jajcus",u"jajcus.net",None)),
    (u"jajcus@192.168.1.1",
        (u"jajcus",u"192.168.1.1",None)),
    (u"jajcus@[2001:0DB8::1]",
        (u"jajcus",u"[2001:db8::1]",None)),
    (u"jajcus@[2001:0DB8::192.168.1.1]",
        (u"jajcus",u"[2001:db8::c0a8:101]",None)),
    (u"jajcus@jajcus.net/Test",
        (u"jajcus",u"jajcus.net",u"Test")),
    (u"Jajcus@jaJCus.net/Test",
        (u"jajcus",u"jajcus.net",u"Test")),
    (u"Jajcus@jaJCus.net/test",
        (u"jajcus",u"jajcus.net",u"test")),
    (u"jajcuÅ›@dÅ¼abber.example.com/Test",
        (u"jajcuÅ›",u"dÅ¼abber.example.com",u"Test")),
    (u"JAJCUÅš@DÅ»ABBER.EXAMPLE.COM/TEST",
        (u"jajcuÅ›",u"dÅ¼abber.example.com",u"TEST")),
    (u"%s@%s/%s" % (u"x"*1023, LONG_DOMAIN, u"x"*1023),
        (u"x"*1023, LONG_DOMAIN, u"x"*1023)),
]

VALID_TUPLES = [
    ((u"a",u"b",u"c"), u"a@b/c"),
    ((None, u"example.com",None), u"example.com"),
    ((u"",u"example.com",u""), u"example.com"),
    ((None, u"example.com","Test"), u"example.com/Test"),
    ((u"jajcus",u"jajcus.net",None), u"jajcus@jajcus.net"),
    ((u"jajcus",u"jajcus.net",u"Test"), u"jajcus@jajcus.net/Test"),
    ((u"Jajcus",u"jaJCus.net",u"Test"), u"jajcus@jajcus.net/Test"),
    ((u"Jajcus",u"jaJCus.net",u"test"), u"jajcus@jajcus.net/test"),
    ((u"jajcuÅ›",u"dÅ¼abber.example.com",u"Test"),
                                        u"jajcuÅ›@dÅ¼abber.example.com/Test"),
    ((u"JAJCUÅš",u"DÅ»ABBER.EXAMPLE.COM",u"TEST"),
                                        u"jajcuÅ›@dÅ¼abber.example.com/TEST"),
]

INVALID_JIDS = [
    u"/Test",
    u"#@$%#^$%#^&^$",
    u"<>@example.com",
    u"\x01\x02\x05@example.com",
    u"test@\x01\x02\x05",
    u"test@example.com/\x01\x02\x05",
    u"%s@%s/%s" % (u"x"*1024, u"x"*1023, u"x"*1023),
    u"%s@%s/%s" % (u"x"*1023, u"x"*1024, u"x"*1023),
    u"%s@%s/%s" % (u"x"*1023, u"x"*1023, u"x"*1024),
    u"%sÃ³@%s/%s" % (u"x"*1022, u"x"*1023, u"x"*1023),
    u"%s@%sÃ³/%s" % (u"x"*1023, u"x"*1022, u"x"*1023),
    u"%s@%s/%sÃ³" % (u"x"*1023, u"x"*1023, u"x"*1022),
]

COMPARISIONS_TRUE = [
    'JID(u"a@b.c") == JID(u"a@b.c")',
    'JID(u"a@b.c") == JID(u"A@b.c")',
    'JID(u"a@b.c") != JID(u"b@b.c")',
    'JID(u"a@b.c") < JID(u"b@b.c")',
    'JID(u"b@b.c") > JID(u"a@b.c")',
    'JID(u"a@b.c") > None',
    'JID(u"1@b.c") > None',
    'None < JID(u"1@b.c")',
]

COMPARISIONS_FALSE = [
    'JID(u"a@b.c") != JID(u"a@b.c")',
    'JID(u"a@b.c") != JID(u"A@b.c")',
    'JID(u"a@b.c") == JID(u"b@b.c")',
    'JID(u"a@b.c") > JID(u"b@b.c")',
    'JID(u"b@b.c") < JID(u"a@b.c")',
    'JID(u"a@b.c") < None',
    'JID(u"1@b.c") < None',
    'None > JID(u"1@b.c")',
]

if sys.version_info[0] >= 3:
    COMPARISIONS_TRUE = [e.replace('u"', '"') for e in COMPARISIONS_TRUE]
    COMPARISIONS_FALSE = [e.replace('u"', '"') for e in COMPARISIONS_FALSE]

class TestJID(unittest.TestCase):
    def test_jid_from_string(self):
        for jid, expected_tuple in VALID_JIDS:
            logging.debug(" checking {0!r}...".format(jid))
            jid = JID(jid)
            jtuple = (jid.local, jid.domain, jid.resource)
            self.assertEqual(jtuple, expected_tuple)
    def test_jid_from_tuple(self):
        for (local, domain, resource), jid in VALID_TUPLES:
            logging.debug(" checking {0!r}...".format(jid))
            j = JID(local, domain, resource)
            self.assertEqual(unicode(j), jid)
    def test_invalid_jids(self):
        for jid in INVALID_JIDS:
            logging.debug(" checking {0!r}...".format(jid))
            with self.assertRaises(JIDError):
                jid = JID(jid)
                logging.debug("   got: {0!r}".format(jid))
    def test_comparision(self):
        for expr in COMPARISIONS_TRUE:
            result = eval(expr)
            self.assertTrue(result, 'Expression %r gave: %r' % (expr, result))
        for expr in COMPARISIONS_FALSE:
            result = eval(expr)
            self.assertFalse(result, 'Expression %r gave: %r' % (expr, result))

class TestUncachedJID(TestJID):
    def setUp(self):
        # pylint: disable=W0404,W0212
        import weakref
        JID.cache = weakref.WeakValueDictionary()
        self.saved_stringprep_cache_size = xmppstringprep._stringprep_cache_size
        xmppstringprep.set_stringprep_cache_size(0)
    def tearDown(self):
        xmppstringprep.set_stringprep_cache_size(
                                            self.saved_stringprep_cache_size)

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = message
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

import unittest

from pyxmpp2.etree import ElementTree

from pyxmpp2.message import Message
from pyxmpp2.jid import JID
from pyxmpp2.stanzapayload import XMLPayload

MESSAGE1 = """
<message xmlns="jabber:client" from='source@example.com/res'
                                to='dest@example.com' type='normal' id='1'>
<subject>Subject</subject>
<body>The body</body>
<thread>thread-id</thread>
<payload xmlns="http://pyxmpp.jajcus.net/xmlns/test"><abc/></payload>
</message>"""

MESSAGE2 = """<message xmlns="jabber:client"/>"""

class TestMessage(unittest.TestCase):
    def check_message_full(self, msg):
        self.assertEqual(msg.from_jid, JID("source@example.com/res"))
        self.assertEqual(msg.to_jid, JID("dest@example.com"))
        self.assertEqual(msg.stanza_type, "normal")
        self.assertEqual(msg.stanza_id, "1")
        self.assertEqual(msg.subject, u"Subject")
        self.assertEqual(msg.body, u"The body")
        self.assertEqual(msg.thread, u"thread-id")
        payload = msg.get_all_payload()
        self.assertTrue(payload)
        self.assertEqual(payload[0].xml_element_name,
                            "{http://pyxmpp.jajcus.net/xmlns/test}payload")
        self.assertTrue(len(payload[0].element) > 0)
        self.assertEqual(payload[0].element[0].tag,
                                "{http://pyxmpp.jajcus.net/xmlns/test}abc")

    def check_message_empty(self, msg):
        self.assertEqual(msg.from_jid, None)
        self.assertEqual(msg.to_jid, None)
        self.assertEqual(msg.stanza_type, None)
        self.assertIsNone(msg.stanza_id)
        self.assertEqual(msg.subject, None)
        self.assertEqual(msg.body, None)
        self.assertEqual(msg.thread, None)
        payload = msg.get_all_payload()
        self.assertFalse(payload)

    def test_message_full_from_xml(self):
        msg = Message(ElementTree.XML(MESSAGE1))
        self.check_message_full(msg)

    def test_message_empty_from_xml(self):
        msg = Message(ElementTree.XML(MESSAGE2))
        self.check_message_empty(msg)

    def test_message_empty(self):
        msg = Message()
        self.check_message_empty(msg)
        xml = msg.as_xml()
        self.check_message_empty(Message(xml))

    def test_message_full(self):
        msg = Message(
                from_jid = JID("source@example.com/res"),
                to_jid = JID("dest@example.com"),
                stanza_type = "normal",
                stanza_id = u"1",
                subject = u"Subject",
                body = u"The body",
                thread = u"thread-id")
        payload = ElementTree.Element(
                            "{http://pyxmpp.jajcus.net/xmlns/test}payload")
        ElementTree.SubElement(payload,
                                "{http://pyxmpp.jajcus.net/xmlns/test}abc")
        payload = XMLPayload(payload)
        msg.add_payload(payload)
        self.check_message_full(msg)
        xml = msg.as_xml()
        self.check_message_full(Message(xml))

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = presence
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

import unittest

from pyxmpp2.etree import ElementTree

from pyxmpp2.presence import Presence
from pyxmpp2.jid import JID
from pyxmpp2.stanzapayload import XMLPayload

PRESENCE1 = """
<presence xmlns="jabber:client" from='source@example.com/res'
                                            to='dest@example.com' id='1'>
<show>away</show>
<status>The Status</status>
<priority>10</priority>
<payload xmlns="http://pyxmpp.jajcus.net/xmlns/test"><abc/></payload>
</presence>"""

PRESENCE2 = """<presence xmlns="jabber:client"/>"""

PRESENCE3 = """<presence xmlns="jabber:client" from='source@example.com/res'
                                to='dest@example.com' type="subscribe" />"""

class TestPresence(unittest.TestCase):
    def check_presence_full(self, pres):
        self.assertEqual(pres.from_jid, JID("source@example.com/res"))
        self.assertEqual(pres.to_jid, JID("dest@example.com"))
        self.assertEqual(pres.stanza_type, None)
        self.assertEqual(pres.stanza_id, "1")
        self.assertEqual(pres.show, "away")
        self.assertEqual(pres.status, "The Status")
        self.assertEqual(pres.priority, 10)
        payload = pres.get_all_payload()
        self.assertTrue(payload)
        self.assertEqual(payload[0].xml_element_name,
                                "{http://pyxmpp.jajcus.net/xmlns/test}payload")
        self.assertTrue(len(payload[0].element) > 0)
        self.assertEqual(payload[0].element[0].tag,
                                "{http://pyxmpp.jajcus.net/xmlns/test}abc")

    def check_presence_empty(self, pres):
        self.assertEqual(pres.from_jid, None)
        self.assertEqual(pres.to_jid, None)
        self.assertEqual(pres.stanza_type, None)
        self.assertIsNone(pres.stanza_id)
        self.assertEqual(pres.show, None)
        self.assertEqual(pres.status, None)
        self.assertEqual(pres.priority, 0)
        payload = pres.get_all_payload()
        self.assertFalse(payload)

    def check_presence_subscribe(self, pres):
        self.assertEqual(pres.from_jid, JID("source@example.com/res"))
        self.assertEqual(pres.to_jid, JID("dest@example.com"))
        self.assertEqual(pres.stanza_type, "subscribe")
        self.assertEqual(pres.stanza_id, None)
        self.assertEqual(pres.show, None)
        self.assertEqual(pres.status, None)

    def test_presence_full_from_xml(self):
        pres = Presence(ElementTree.XML(PRESENCE1))
        self.check_presence_full(pres)

    def test_presence_empty_from_xml(self):
        pres = Presence(ElementTree.XML(PRESENCE2))
        self.check_presence_empty(pres)

    def test_presence_subscribe_from_xml(self):
        pres = Presence(ElementTree.XML(PRESENCE3))
        self.check_presence_subscribe(pres)

    def test_presence_empty(self):
        pres = Presence()
        self.check_presence_empty(pres)
        xml = pres.as_xml()
        self.check_presence_empty(Presence(xml))

    def test_presence_full(self):
        pres = Presence(
                from_jid = JID("source@example.com/res"),
                to_jid = JID("dest@example.com"),
                stanza_type = None,
                stanza_id = u"1",
                show = u"away",
                status = u"The Status",
                priority = 10)
        payload = ElementTree.Element(
                                "{http://pyxmpp.jajcus.net/xmlns/test}payload")
        ElementTree.SubElement(payload,
                                    "{http://pyxmpp.jajcus.net/xmlns/test}abc")
        payload = XMLPayload(payload)
        pres.add_payload(payload)
        self.check_presence_full(pres)
        xml = pres.as_xml()
        self.check_presence_full(Presence(xml))

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = resolver
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

import unittest
import logging
import time

from socket import AF_INET, AF_INET6

try:
    import dns # pylint: disable=W0611
    HAVE_DNSPYTHON = True
except ImportError:
    HAVE_DNSPYTHON = False

from pyxmpp2.mainloop import main_loop_factory
from pyxmpp2.mainloop.interfaces import Event

from pyxmpp2.resolver import is_ipv6_available
from pyxmpp2.resolver import DumbBlockingResolver

if HAVE_DNSPYTHON:
    from pyxmpp2.resolver import BlockingResolver
    from pyxmpp2.resolver import ThreadedResolver

from pyxmpp2.settings import XMPPSettings

from pyxmpp2.test import _support

logger = logging.getLogger("pyxmpp2.test.resolver")

class _Const(object):
    # pylint: disable=R0903
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return self.name
    def __repr__(self):
        return self.name

NO_RESULT = _Const("NO_RESULT")
DUPLICATE = _Const("DUPLICATE")

class DummyEvent(Event):
    # pylint: disable=W0232,R0903
    def __unicode__(self):
        return u"Dummy event"

class _TestResolver(unittest.TestCase):
    def setUp(self):
        # pylint: disable=W0212
        # reset the event queue
        XMPPSettings._defs['event_queue'].default = None
        self.loop = main_loop_factory([])
        self.srv_result = NO_RESULT
        self.address_result = NO_RESULT
        self.wake_up = False

    def wait(self, timeout = 1):
        timeout = time.time() + timeout
        while not self.loop.finished and not self.wake_up:
            self.loop.loop_iteration(0.1)
            if time.time() > timeout:
                break
        self.wake_up = False

    def tearDown(self):
        self.loop.quit()

    def make_resolver(self, settings = None):
        raise NotImplementedError

    def srv_callback(self, result):
        logger.debug("srv_callback: {0!r}".format(result))
        if self.srv_result is not NO_RESULT:
            logger.debug("duplicate call to the srv lookup callback")
            self.srv_result = DUPLICATE
        else:
            self.srv_result = result
        self.wake_up = True
        self.loop.event_queue.put(DummyEvent()) # wake up the main loop

    def address_callback(self, result):
        logger.debug("address_callback: {0!r}".format(result))
        if self.address_result is not NO_RESULT:
            logger.debug("duplicate call to the address lookup callback")
            self.address_result = DUPLICATE
        else:
            self.address_result = result
        self.wake_up = True
        self.loop.event_queue.put(DummyEvent()) # wake up the main loop

    def many_addresses_callback(self, result):
        logger.debug("many_addresses_callback: {0!r}".format(result))
        if self.address_result is NO_RESULT:
            self.address_result = [result]
        else:
            self.address_result.append(result)
        self.wake_up = True
        self.loop.event_queue.put(DummyEvent()) # wake up the main loop

    def test_resolve_srv(self):
        resolver = self.make_resolver()
        self.loop.add_handler(resolver)
        resolver.resolve_srv("lo.test.pyxmpp.jajcus.net",
                                "xmpp-client", "tcp", self.srv_callback)
        self.wait(1)
        self.assertEqual(self.srv_result,
                                [('lo-host.test.pyxmpp.jajcus.net.', 15222)])

    def test_resolve_address(self):
        resolver = self.make_resolver()
        self.loop.add_handler(resolver)
        resolver.resolve_address("lo-host.test.pyxmpp.jajcus.net",
                                                        self.address_callback)
        self.wait(1)
        if is_ipv6_available():
            self.assertEqual(self.address_result, [
                                        (AF_INET6, "::1"),
                                        (AF_INET,  "127.0.0.1")])
        else:
            self.assertEqual(self.address_result, [(AF_INET, "127.0.0.1")])

    def test_resolve_address_prefer_ipv4(self):
        settings = XMPPSettings({"prefer_ipv6": False})
        resolver = self.make_resolver(settings)
        self.loop.add_handler(resolver)
        resolver.resolve_address("lo-host.test.pyxmpp.jajcus.net",
                                                        self.address_callback)
        self.wait(1)
        if is_ipv6_available():
            self.assertEqual(self.address_result, [
                                        (AF_INET,  "127.0.0.1"),
                                        (AF_INET6, "::1")])
        else:
            self.assertEqual(self.address_result, [(AF_INET, "127.0.0.1")])


    def test_resolve_address_ipv4_only(self):
        settings = XMPPSettings({"ipv6": False})
        resolver = self.make_resolver(settings)
        self.loop.add_handler(resolver)
        resolver.resolve_address("lo-host.test.pyxmpp.jajcus.net",
                                                        self.address_callback)
        self.wait(1)
        self.assertEqual(self.address_result, [(AF_INET, "127.0.0.1")])
        self.address_result = NO_RESULT
        resolver.resolve_address("lo4-host.test.pyxmpp.jajcus.net",
                                                        self.address_callback)
        self.wait(1)
        self.assertEqual(self.address_result, [(AF_INET, "127.0.0.1")])
        self.address_result = NO_RESULT
        resolver.resolve_address("lo6-host.test.pyxmpp.jajcus.net",
                                                        self.address_callback)
        self.wait(1)
        self.assertEqual(self.address_result, [])

    @unittest.skipUnless(is_ipv6_available(), "No IPv6 support")
    def test_resolve_address_ipv6_only(self):
        settings = XMPPSettings({"ipv4": False})
        resolver = self.make_resolver(settings)
        self.loop.add_handler(resolver)
        resolver.resolve_address("lo-host.test.pyxmpp.jajcus.net",
                                                        self.address_callback)
        self.wait(1)
        self.assertEqual(self.address_result, [(AF_INET6, "::1")])
        self.address_result = NO_RESULT
        resolver.resolve_address("lo4-host.test.pyxmpp.jajcus.net",
                                                        self.address_callback)
        self.wait(1)
        self.assertEqual(self.address_result, [])
        self.address_result = NO_RESULT
        resolver.resolve_address("lo6-host.test.pyxmpp.jajcus.net",
                                                        self.address_callback)
        self.wait(1)
        self.assertEqual(self.address_result, [(AF_INET6, "::1")])

    def test_resolve_many_addresses(self):
        resolver = self.make_resolver()
        self.loop.add_handler(resolver)
        addresses = ["lo-host", "lo4-host", "lo6-host"]
        addresses += ["nohost{0}".format(i) for i in range(0, 20)]
        addresses = [addr + ".test.pyxmpp.jajcus.net" for addr in addresses]
        for addr in addresses:
            resolver.resolve_address(addr, self.many_addresses_callback)
        timeout = time.time() + 120
        while time.time() < timeout:
            self.wait(1)
            if self.address_result != NO_RESULT and \
                    len(self.address_result) >= len(addresses):
                break
        self.assertEqual(len(self.address_result), len(addresses))
        expected = [[]] * 20
        if is_ipv6_available():
            expected += [[(AF_INET, '127.0.0.1')], [(AF_INET6, '::1')],
                                [(AF_INET6, '::1'), (AF_INET, '127.0.0.1')]]
        else:
            expected += [[], [(AF_INET, '127.0.0.1')], [(2, '127.0.0.1')]]
        results = sorted(self.address_result)
        self.assertEqual(results, expected)

class _TestDumbResolver(_TestResolver):
    def make_resolver(self, settings = None):
        # pylint: disable=E0602
        return DumbResolver(settings)
    def test_resolve_srv(self):
        resolver = self.make_resolver()
        self.loop.add_handler(resolver)
        with self.assertRaises(NotImplementedError):
            resolver.resolve_srv("lo.test.pyxmpp.jajcus.net",
                                "xmpp-client", "tcp", self.srv_callback)
        self.wait(1)
        self.assertEqual(self.srv_result, NO_RESULT)

@unittest.skipUnless("network" in _support.RESOURCES, "network usage disabled")
@unittest.skipUnless(HAVE_DNSPYTHON, "DNSPython not available")
class TestBlockingResolver(_TestResolver):
    def wait(self, timeout = 1):
        return

    def make_resolver(self, settings = None):
        return BlockingResolver(settings)

@unittest.skipUnless("network" in _support.RESOURCES, "network usage disabled")
class TestDumbBlockingResolver(_TestDumbResolver):
    def wait(self, timeout = 1):
        return

    def make_resolver(self, settings = None):
        return DumbBlockingResolver(settings)

@unittest.skipUnless("network" in _support.RESOURCES, "network usage disabled")
@unittest.skipUnless(HAVE_DNSPYTHON, "DNSPython not available")
class TestThreadedResolver(_TestResolver):
    def make_resolver(self, settings = None):
        return ThreadedResolver(settings, 10)

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()


########NEW FILE########
__FILENAME__ = roster
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

import unittest
from Queue import Queue

from pyxmpp2.etree import ElementTree

from pyxmpp2.iq import Iq
from pyxmpp2.jid import JID
from pyxmpp2.stanzaprocessor import StanzaProcessor
from pyxmpp2.settings import XMPPSettings
from pyxmpp2.exceptions import BadRequestProtocolError
from pyxmpp2.exceptions import NotAcceptableProtocolError
from pyxmpp2.mainloop.events import EventDispatcher
from pyxmpp2.streamevents import AuthorizedEvent, GotFeaturesEvent

from pyxmpp2.roster import RosterItem, RosterPayload, Roster
from pyxmpp2.roster import RosterClient
from pyxmpp2.roster import RosterReceivedEvent, RosterNotReceivedEvent

class TestRosterItem(unittest.TestCase):
    def test_parse_empty(self):
        element = ElementTree.XML('<item xmlns="jabber:iq:roster"/>')
        with self.assertRaises(BadRequestProtocolError):
            RosterItem.from_xml(element)

    def test_parse_only_jid(self):
        element = ElementTree.XML('<item xmlns="jabber:iq:roster"'
                                                            ' jid="a@b.c"/>')
        item = RosterItem.from_xml(element)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertIsNone(item.name)
        self.assertEqual(item.groups, set())
        self.assertIsNone(item.subscription)
        self.assertIsNone(item.ask)
        self.assertFalse(item.approved)
        item.verify_roster_result()
        item.verify_roster_result(True)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertIsNone(item.name)
        self.assertEqual(item.groups, set())
        self.assertIsNone(item.subscription)
        self.assertIsNone(item.ask)
        self.assertFalse(item.approved)

    def test_parse_full(self):
        element = ElementTree.XML('<item xmlns="jabber:iq:roster"'
                        ' jid="a@b.c" name="NAME" subscription="to"'
                        ' ask="subscribe" approved="true">'
                        '<group>GROUP1</group><group>GROUP2</group>'
                        '</item>')
        item = RosterItem.from_xml(element)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertEqual(item.name, u"NAME")
        self.assertEqual(item.groups, set(["GROUP1", "GROUP2"]))
        self.assertEqual(item.subscription, "to")
        self.assertEqual(item.ask, "subscribe")
        self.assertTrue(item.approved)
        item.verify_roster_result()
        item.verify_roster_result(True)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertEqual(item.name, u"NAME")
        self.assertEqual(item.groups, set(["GROUP1", "GROUP2"]))
        self.assertEqual(item.subscription, "to")
        self.assertEqual(item.ask, "subscribe")
        self.assertTrue(item.approved)

    def test_bad_subscription(self):
        element = ElementTree.XML('<item xmlns="jabber:iq:roster"'
                        ' jid="a@b.c" name="NAME" subscription="bad"'
                        ' ask="subscribe" approved="true">'
                        '<group>GROUP1</group><group>GROUP2</group>'
                        '</item>')
        item = RosterItem.from_xml(element)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertEqual(item.name, u"NAME")
        self.assertEqual(item.groups, set(["GROUP1", "GROUP2"]))
        self.assertEqual(item.subscription, "bad")
        self.assertEqual(item.ask, "subscribe")
        self.assertTrue(item.approved)
        with self.assertRaises(ValueError):
            item.verify_roster_result()
        item.verify_roster_result(True)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertEqual(item.name, u"NAME")
        self.assertEqual(item.groups, set(["GROUP1", "GROUP2"]))
        self.assertIsNone(item.subscription)
        self.assertEqual(item.ask, "subscribe")
        self.assertTrue(item.approved)

    def test_result_with_remove(self):
        element = ElementTree.XML('<item xmlns="jabber:iq:roster"'
                        ' jid="a@b.c" subscription="remove"/>')
        item = RosterItem.from_xml(element)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertEqual(item.subscription, "remove")
        with self.assertRaises(ValueError):
            item.verify_roster_result()
        item.verify_roster_result(True)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertIsNone(item.subscription)

    def test_push_with_remove(self):
        element = ElementTree.XML('<item xmlns="jabber:iq:roster"'
                        ' jid="a@b.c" subscription="remove"/>')
        item = RosterItem.from_xml(element)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertEqual(item.subscription, "remove")
        item.verify_roster_push()
        item.verify_roster_push(True)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertEqual(item.subscription, "remove")

    def test_set_with_remove(self):
        element = ElementTree.XML('<item xmlns="jabber:iq:roster"'
                        ' jid="a@b.c" subscription="remove"/>')
        item = RosterItem.from_xml(element)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertEqual(item.subscription, "remove")
        item.verify_roster_set()
        item.verify_roster_set(True)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertEqual(item.subscription, "remove")

    def test_set_with_subscription(self):
        element = ElementTree.XML('<item xmlns="jabber:iq:roster"'
                        ' jid="a@b.c" subscription="both"/>')
        item = RosterItem.from_xml(element)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertEqual(item.subscription, "both")
        with self.assertRaises(BadRequestProtocolError):
            item.verify_roster_set()
        item.verify_roster_set(True)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertIsNone(item.subscription)

    def test_set_empty_group(self):
        element = ElementTree.XML('<item xmlns="jabber:iq:roster"'
                        ' jid="a@b.c"><group/></item>')
        item = RosterItem.from_xml(element)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertEqual(item.groups, set([u""]))
        with self.assertRaises(NotAcceptableProtocolError):
            item.verify_roster_set()
        with self.assertRaises(NotAcceptableProtocolError):
            item.verify_roster_set(True)

    def test_set_duplicate_group(self):
        element = ElementTree.XML('<item xmlns="jabber:iq:roster"'
                        ' jid="a@b.c"><group>GROUP1</group>'
                                    '<group>GROUP1</group></item>')
        item = RosterItem.from_xml(element)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertEqual(item.groups, set([u"GROUP1"]))
        with self.assertRaises(BadRequestProtocolError):
            item.verify_roster_set()
        with self.assertRaises(BadRequestProtocolError):
            item.verify_roster_set(True)

    def test_set_full(self):
        element = ElementTree.XML('<item xmlns="jabber:iq:roster"'
                        ' jid="a@b.c" name="NAME" subscription="to"'
                        ' ask="subscribe" approved="true">'
                        '<group>GROUP1</group><group>GROUP2</group>'
                        '</item>')
        item = RosterItem.from_xml(element)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertEqual(item.name, u"NAME")
        self.assertEqual(item.groups, set(["GROUP1", "GROUP2"]))
        self.assertEqual(item.subscription, "to")
        self.assertEqual(item.ask, "subscribe")
        self.assertTrue(item.approved)
        with self.assertRaises(BadRequestProtocolError):
            item.verify_roster_set()
        item.verify_roster_set(True)
        self.assertEqual(item.jid, JID("a@b.c"))
        self.assertEqual(item.name, u"NAME")
        self.assertEqual(item.groups, set(["GROUP1", "GROUP2"]))
        self.assertIsNone(item.subscription)
        self.assertIsNone(item.ask, None)
        self.assertFalse(item.approved)

    def test_build_empty(self):
        item = RosterItem(JID("test@example.org"))
        self.assertEqual(item.jid, JID("test@example.org"))
        self.assertIsNone(item.name)
        self.assertIsNone(item.subscription)
        self.assertIsNone(item.ask)
        self.assertFalse(item.approved)
        self.assertEqual(item.groups, set())
        xml = item.as_xml()
        self.assertEqual(xml.tag, "{jabber:iq:roster}item")
        self.assertEqual(len(xml), 0)
        self.assertEqual(xml.get("jid"), u"test@example.org")
        self.assertEqual(xml.get("name"), None)
        self.assertEqual(xml.get("subscription"), None)
        self.assertEqual(xml.get("ask"), None)
        self.assertEqual(xml.get("approved"), None)

        # check if serializable
        self.assertTrue(ElementTree.tostring(xml))

    def test_build_full(self):
        item = RosterItem(JID("test@example.org"), "NAME", ["G1", "G2"],
                                "from", "subscribe", "true")
        self.assertEqual(item.jid, JID("test@example.org"))
        self.assertEqual(item.name, "NAME")
        self.assertEqual(item.subscription, "from")
        self.assertEqual(item.ask, "subscribe")
        self.assertTrue(item.approved)
        self.assertEqual(item.groups, set(["G1", "G2"]))
        xml = item.as_xml()
        self.assertEqual(xml.tag, "{jabber:iq:roster}item")
        self.assertEqual(len(xml), 2)
        self.assertEqual(xml.get("jid"), u"test@example.org")
        self.assertEqual(xml.get("name"), "NAME")
        self.assertEqual(xml.get("subscription"), "from")
        self.assertEqual(xml.get("ask"), "subscribe")
        self.assertEqual(xml.get("approved"), "true")
        self.assertEqual(xml[0].tag, "{jabber:iq:roster}group")
        self.assertEqual(xml[1].tag, "{jabber:iq:roster}group")
        self.assertEqual(set([xml[0].text, xml[1].text]), set(["G1", "G2"]))

        # check if serializable
        self.assertTrue(ElementTree.tostring(xml))

class Processor(StanzaProcessor):
    def __init__(self, handlers):
        StanzaProcessor.__init__(self)
        self.setup_stanza_handlers(handlers, "post-auth")
        self.stanzas_sent = []
    def send(self, stanza):
        self.stanzas_sent.append(stanza)

class DummyStream(object):
    # pylint: disable=R0903
    def __init__(self, features, me):
        self.features = features
        self.me = me

EMPTY_FEATURES = "<features xmlns:stream='http://etherx.jabber.org/streams'/>"
VERSION_FEATURES = (
    "<features xmlns:stream='http://etherx.jabber.org/streams'>"
        "<ver xmlns='urn:xmpp:features:rosterver'/>"
    "</features>")

class TestRosterClient(unittest.TestCase):
    def test_get_no_version(self):
        event_queue = Queue()
        settings = XMPPSettings()
        settings["event_queue"] = event_queue
        client = RosterClient(settings)
        dispatcher = EventDispatcher(settings, [client])
        self.assertIsNone(client.roster)
        self.assertTrue(event_queue.empty())
        processor = Processor([client])
        stream = DummyStream(ElementTree.XML(EMPTY_FEATURES),
                                                JID("test@example.org/Test"))
        event = AuthorizedEvent(JID("test@example.org/Test"))
        event.stream = stream
        event_queue.put(event)
        dispatcher.dispatch()
        self.assertEqual(len(processor.stanzas_sent), 1)
        stanza = processor.stanzas_sent[0]
        self.assertEqual(stanza.stanza_type, "get")
        self.assertIsNone(stanza.to_jid, None)
        xml = stanza.as_xml()
        self.assertEqual(xml[0].tag, "{jabber:iq:roster}query")
        self.assertEqual(len(xml[0]), 0)
        payload = stanza.get_payload(RosterPayload)
        self.assertEqual(len(payload), 0)
        self.assertIsNone(payload.version, None)
        response = stanza.make_result_response()
        item1 = RosterItem(JID("item1@example.org"))
        item2 = RosterItem(JID("item2@example.org"))
        payload = RosterPayload([item1, item2], None)
        response.set_payload(payload)
        processor.uplink_receive(response)
        self.assertIsNotNone(client.roster)
        self.assertEqual(len(client.roster), 2)
        self.assertTrue(JID("item1@example.org") in client.roster)
        self.assertTrue(JID("item2@example.org") in client.roster)
        self.assertIsNone(client.roster.version)
        event = event_queue.get_nowait()
        self.assertIsInstance(event, RosterReceivedEvent)
        self.assertEqual(event.roster_client, client)
        self.assertEqual(event.roster, client.roster)

    def test_get_version(self):
        event_queue = Queue()
        settings = XMPPSettings()
        settings["event_queue"] = event_queue
        client = RosterClient(settings)
        dispatcher = EventDispatcher(settings, [client])
        self.assertIsNone(client.roster)
        self.assertTrue(event_queue.empty())
        processor = Processor([client])
        stream = DummyStream(ElementTree.XML(VERSION_FEATURES),
                                                JID("test@example.org/Test"))
        event = GotFeaturesEvent(stream.features)
        event.stream = stream
        event_queue.put(event)
        dispatcher.dispatch()
        event = AuthorizedEvent(JID("test@example.org/Test"))
        event.stream = stream
        event_queue.put(event)
        dispatcher.dispatch()
        self.assertEqual(len(processor.stanzas_sent), 1)
        stanza = processor.stanzas_sent[0]
        self.assertEqual(stanza.stanza_type, "get")
        self.assertIsNone(stanza.to_jid, None)
        payload = stanza.get_payload(RosterPayload)
        self.assertEqual(len(payload), 0)
        self.assertEqual(payload.version, u"")
        response = stanza.make_result_response()
        item1 = RosterItem(JID("item1@example.org"))
        item2 = RosterItem(JID("item2@example.org"))
        payload = RosterPayload([item1, item2], u"VERSION")
        response.set_payload(payload)
        processor.uplink_receive(response)
        self.assertIsNotNone(client.roster)
        self.assertEqual(len(client.roster), 2)
        self.assertTrue(JID("item1@example.org") in client.roster)
        self.assertTrue(JID("item2@example.org") in client.roster)
        self.assertEqual(client.roster.version, u"VERSION")
        event = event_queue.get_nowait()
        self.assertIsInstance(event, RosterReceivedEvent)
        self.assertEqual(event.roster_client, client)
        self.assertEqual(event.roster, client.roster)

    def test_get_error(self):
        event_queue = Queue()
        settings = XMPPSettings()
        settings["event_queue"] = event_queue
        client = RosterClient(settings)
        dispatcher = EventDispatcher(settings, [client])
        self.assertIsNone(client.roster)
        self.assertTrue(event_queue.empty())
        processor = Processor([client])
        stream = DummyStream(ElementTree.XML(EMPTY_FEATURES),
                                                JID("test@example.org/Test"))
        event = AuthorizedEvent(JID("test@example.org/Test"))
        event.stream = stream
        event_queue.put(event)
        dispatcher.dispatch()
        stanza = processor.stanzas_sent[0]
        response = stanza.make_error_response("item-not-found")
        processor.uplink_receive(response)
        self.assertIsNone(client.roster)
        event = event_queue.get_nowait()
        self.assertIsInstance(event, RosterNotReceivedEvent)
        self.assertEqual(event.roster_client, client)
        self.assertIsNotNone(event.stanza)
        self.assertEqual(event.stanza.stanza_id, response.stanza_id)

    def test_add_item(self):
        event_queue = Queue()
        settings = XMPPSettings()
        settings["event_queue"] = event_queue
        client = RosterClient(settings)
        processor = Processor([client])
        item1 = RosterItem(JID("item1@example.org"))
        item2 = RosterItem(JID("item2@example.org"))
        client.roster = Roster([item1, item2])

        # simple add
        client.add_item(JID("item3@example.org"))
        self.assertEqual(len(processor.stanzas_sent), 1)
        stanza = processor.stanzas_sent[0]
        payload = stanza.get_payload(RosterPayload)
        self.assertIsNotNone(payload)
        self.assertEqual(len(payload), 1)
        item = payload[0]
        self.assertEqual(item.jid, JID("item3@example.org"))
        self.assertIsNone(item.name)
        self.assertIsNone(item.subscription)
        self.assertFalse(item.approved)
        self.assertFalse(item.groups)
        response = stanza.make_result_response()
        processor.uplink_receive(response)
        self.assertEqual(len(client.roster), 2) # not added yet, push needed

        # duplicate
        processor.stanzas_sent = []
        with self.assertRaises(ValueError):
            client.add_item(JID("item2@example.org"))
        self.assertEqual(len(processor.stanzas_sent), 0)

        # add with name and groups
        processor.stanzas_sent = []
        client.add_item(JID("item4@example.org"), "NAME", ["GROUP1", "GROUP2"])
        self.assertEqual(len(processor.stanzas_sent), 1)
        stanza = processor.stanzas_sent[0]
        payload = stanza.get_payload(RosterPayload)
        self.assertIsNotNone(payload)
        self.assertEqual(len(payload), 1)
        item = payload[0]
        self.assertEqual(item.jid, JID("item4@example.org"))
        self.assertEqual(item.name, "NAME")
        self.assertEqual(item.groups, set(["GROUP1", "GROUP2"]))
        self.assertIsNone(item.subscription)
        self.assertFalse(item.approved)
        response = stanza.make_result_response()
        processor.uplink_receive(response)

        def callback(item):
            callback_calls.append(item)
        def error_callback(stanza):
            error_callback_calls.append(stanza)

        # callback
        processor.stanzas_sent = []
        callback_calls = []
        error_callback_calls = []
        client.add_item(JID("item5@example.org"),
                            callback = callback,
                            error_callback = error_callback)
        self.assertEqual(len(processor.stanzas_sent), 1)
        stanza = processor.stanzas_sent[0]
        payload = stanza.get_payload(RosterPayload)
        self.assertIsNotNone(payload)
        self.assertEqual(len(payload), 1)
        item = payload[0]
        self.assertEqual(item.jid, JID("item5@example.org"))
        response = stanza.make_result_response()
        processor.uplink_receive(response)
        self.assertEqual(len(callback_calls), 1)
        self.assertEqual(callback_calls[0].jid, JID("item5@example.org"))
        self.assertEqual(len(error_callback_calls), 0)

        # error callback
        processor.stanzas_sent = []
        callback_calls = []
        error_callback_calls = []
        client.add_item(JID("item5@example.org"),
                            callback = callback,
                            error_callback = error_callback)
        self.assertEqual(len(processor.stanzas_sent), 1)
        stanza = processor.stanzas_sent[0]
        payload = stanza.get_payload(RosterPayload)
        self.assertIsNotNone(payload)
        self.assertEqual(len(payload), 1)
        item = payload[0]
        self.assertEqual(item.jid, JID("item5@example.org"))
        response = stanza.make_error_response("not-acceptable")
        processor.uplink_receive(response)
        self.assertEqual(len(callback_calls), 0)
        self.assertEqual(len(error_callback_calls), 1)
        stanza = error_callback_calls[0]
        self.assertIsInstance(stanza, Iq)
        self.assertEqual(stanza.stanza_id, response.stanza_id)

    def test_update_item(self):
        event_queue = Queue()
        settings = XMPPSettings()
        settings["event_queue"] = event_queue
        client = RosterClient(settings)
        processor = Processor([client])
        item1 = RosterItem(JID("item1@example.org"), "ITEM1")
        item2 = RosterItem(JID("item2@example.org"), groups = [
                                                        "GROUP1", "GROUP2"])
        client.roster = Roster([item1, item2])

        # update name
        client.update_item(JID("item2@example.org"), "NEW_NAME")
        self.assertEqual(len(processor.stanzas_sent), 1)
        stanza = processor.stanzas_sent[0]
        payload = stanza.get_payload(RosterPayload)
        self.assertIsNotNone(payload)
        self.assertEqual(len(payload), 1)
        item = payload[0]
        self.assertEqual(item.jid, JID("item2@example.org"))
        self.assertEqual(item.name, "NEW_NAME")
        self.assertEqual(item.groups, set(["GROUP1", "GROUP2"]))
        self.assertIsNone(item.subscription)
        self.assertFalse(item.approved)
        response = stanza.make_result_response()
        processor.uplink_receive(response)

        # update groups
        processor.stanzas_sent = []
        client.update_item(JID("item2@example.org"), groups = ["GROUP3"])
        self.assertEqual(len(processor.stanzas_sent), 1)
        stanza = processor.stanzas_sent[0]
        payload = stanza.get_payload(RosterPayload)
        self.assertIsNotNone(payload)
        self.assertEqual(len(payload), 1)
        item = payload[0]
        self.assertEqual(item.jid, JID("item2@example.org"))
        self.assertIsNone(item.name)
        self.assertEqual(item.groups, set(["GROUP3"]))
        self.assertIsNone(item.subscription)
        self.assertFalse(item.approved)
        response = stanza.make_result_response()
        processor.uplink_receive(response)

        # clear name
        processor.stanzas_sent = []
        client.update_item(JID("item1@example.org"), name = None)
        self.assertEqual(len(processor.stanzas_sent), 1)
        stanza = processor.stanzas_sent[0]
        payload = stanza.get_payload(RosterPayload)
        self.assertIsNotNone(payload)
        self.assertEqual(len(payload), 1)
        item = payload[0]
        self.assertEqual(item.jid, JID("item1@example.org"))
        self.assertIsNone(item.name)
        self.assertEqual(item.groups, set([]))
        self.assertIsNone(item.subscription)
        self.assertFalse(item.approved)
        response = stanza.make_result_response()
        processor.uplink_receive(response)

        # clear groups
        processor.stanzas_sent = []
        client.update_item(JID("item2@example.org"), groups = None)
        self.assertEqual(len(processor.stanzas_sent), 1)
        stanza = processor.stanzas_sent[0]
        payload = stanza.get_payload(RosterPayload)
        self.assertIsNotNone(payload)
        self.assertEqual(len(payload), 1)
        item = payload[0]
        self.assertEqual(item.jid, JID("item2@example.org"))
        self.assertIsNone(item.name)
        self.assertEqual(item.groups, set([]))
        self.assertIsNone(item.subscription)
        self.assertFalse(item.approved)
        response = stanza.make_result_response()
        processor.uplink_receive(response)

        # missing item
        processor.stanzas_sent = []
        with self.assertRaises(KeyError):
            client.update_item(JID("item3@example.org"), name = "NEW_NAME")
        self.assertEqual(len(processor.stanzas_sent), 0)

        def callback(item):
            callback_calls.append(item)
        def error_callback(stanza):
            error_callback_calls.append(stanza)

        # callback
        processor.stanzas_sent = []
        callback_calls = []
        error_callback_calls = []
        client.update_item(JID("item1@example.org"),
                            name = "NEW_NAME",
                            callback = callback,
                            error_callback = error_callback)
        self.assertEqual(len(processor.stanzas_sent), 1)
        stanza = processor.stanzas_sent[0]
        payload = stanza.get_payload(RosterPayload)
        self.assertIsNotNone(payload)
        self.assertEqual(len(payload), 1)
        item = payload[0]
        self.assertEqual(item.jid, JID("item1@example.org"))
        self.assertEqual(item.name, "NEW_NAME")
        response = stanza.make_result_response()
        processor.uplink_receive(response)
        self.assertEqual(len(callback_calls), 1)
        self.assertEqual(callback_calls[0].jid, JID("item1@example.org"))
        self.assertEqual(len(error_callback_calls), 0)

        # error callback
        processor.stanzas_sent = []
        callback_calls = []
        error_callback_calls = []
        client.update_item(JID("item1@example.org"),
                            name = "NEW_NAME",
                            callback = callback,
                            error_callback = error_callback)
        self.assertEqual(len(processor.stanzas_sent), 1)
        stanza = processor.stanzas_sent[0]
        payload = stanza.get_payload(RosterPayload)
        self.assertIsNotNone(payload)
        self.assertEqual(len(payload), 1)
        item = payload[0]
        self.assertEqual(item.jid, JID("item1@example.org"))
        response = stanza.make_error_response("not-acceptable")
        processor.uplink_receive(response)
        self.assertEqual(len(callback_calls), 0)
        self.assertEqual(len(error_callback_calls), 1)
        stanza = error_callback_calls[0]
        self.assertIsInstance(stanza, Iq)
        self.assertEqual(stanza.stanza_id, response.stanza_id)

    def test_remove_item(self):
        event_queue = Queue()
        settings = XMPPSettings()
        settings["event_queue"] = event_queue
        client = RosterClient(settings)
        processor = Processor([client])
        item1 = RosterItem(JID("item1@example.org"))
        item2 = RosterItem(JID("item2@example.org"))
        client.roster = Roster([item1, item2])

        # simple remove
        client.remove_item(JID("item1@example.org"))
        self.assertEqual(len(processor.stanzas_sent), 1)
        stanza = processor.stanzas_sent[0]
        payload = stanza.get_payload(RosterPayload)
        self.assertIsNotNone(payload)
        self.assertEqual(len(payload), 1)
        item = payload[0]
        self.assertEqual(item.jid, JID("item1@example.org"))
        self.assertIsNone(item.name)
        self.assertEqual(item.subscription, "remove")
        self.assertFalse(item.approved)
        self.assertFalse(item.groups)
        response = stanza.make_result_response()
        processor.uplink_receive(response)
        self.assertEqual(len(client.roster), 2) # not added yet, push needed

        # missing
        processor.stanzas_sent = []
        with self.assertRaises(KeyError):
            client.remove_item(JID("item3@example.org"))
        self.assertEqual(len(processor.stanzas_sent), 0)

        def callback(item):
            callback_calls.append(item)
        def error_callback(stanza):
            error_callback_calls.append(stanza)

        # callback
        processor.stanzas_sent = []
        callback_calls = []
        error_callback_calls = []
        client.remove_item(JID("item1@example.org"),
                            callback = callback,
                            error_callback = error_callback)
        self.assertEqual(len(processor.stanzas_sent), 1)
        stanza = processor.stanzas_sent[0]
        payload = stanza.get_payload(RosterPayload)
        self.assertIsNotNone(payload)
        self.assertEqual(len(payload), 1)
        item = payload[0]
        self.assertEqual(item.jid, JID("item1@example.org"))
        response = stanza.make_result_response()
        processor.uplink_receive(response)
        self.assertEqual(len(callback_calls), 1)
        self.assertEqual(callback_calls[0].jid, JID("item1@example.org"))
        self.assertEqual(len(error_callback_calls), 0)

        # error callback
        processor.stanzas_sent = []
        callback_calls = []
        error_callback_calls = []
        client.remove_item(JID("item1@example.org"),
                            callback = callback,
                            error_callback = error_callback)
        self.assertEqual(len(processor.stanzas_sent), 1)
        stanza = processor.stanzas_sent[0]
        payload = stanza.get_payload(RosterPayload)
        self.assertIsNotNone(payload)
        self.assertEqual(len(payload), 1)
        item = payload[0]
        self.assertEqual(item.jid, JID("item1@example.org"))
        response = stanza.make_error_response("not-acceptable")
        processor.uplink_receive(response)
        self.assertEqual(len(callback_calls), 0)
        self.assertEqual(len(error_callback_calls), 1)
        stanza = error_callback_calls[0]
        self.assertIsInstance(stanza, Iq)
        self.assertEqual(stanza.stanza_id, response.stanza_id)

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = sasl_saslprep
#!/usr/bin/python -u
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

import unittest

from pyxmpp2.exceptions import StringprepError
from pyxmpp2.sasl.saslprep import SASLPREP

class TestSASLprep(unittest.TestCase):
    # pylint: disable=R0903
    def test_rfc_examples(self):
        for input_, output in (
                                (u"I\u00ADX",   u"IX"),
                                (u"user",       u"user"),
                                (u"USER",       u"USER"),
                                (u"\u00AA",     u"a"),
                                (u"\u2168",     u"IX"),
                                ):
            result = SASLPREP.prepare(input_)
            self.assertEqual(result, output)
        for input_ in (u"\u0007", u"\u0627\u0031"):
            with self.assertRaises(StringprepError):
                SASLPREP.prepare(input_)

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = sasl__gsasl
#!/usr/bin/python -u
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

import subprocess
import unittest
import binascii
from binascii import a2b_base64
from base64 import standard_b64encode

from pyxmpp2 import sasl
from pyxmpp2.sasl.core import CLIENT_MECHANISMS_D

from pyxmpp2.test import _support

import logging

logger = logging.getLogger("pyxmpp2.tests.sasl_gsasl")

COMPATIBLE_GSASL = [
            b"gsasl (GNU SASL) 1.6.1",
            b"gsasl (GNU SASL) 1.6.0",
            ]

gsasl_available = False # pylint: disable=C0103
gsasl_client_mechanisms = [] # pylint: disable=C0103
gsasl_server_mechanisms = [] # pylint: disable=C0103

def check_gsasl():
    # pylint: disable=W0603,E1103
    global gsasl_available
    global gsasl_client_mechanisms
    global gsasl_server_mechanisms
    try:
        pipe = subprocess.Popen(["gsasl", "--version"],
                                    stdout = subprocess.PIPE)
        stdout = pipe.communicate()[0]
        code = pipe.wait()
    except OSError:
        code = -1
    if code:
        return
    version = stdout.split(b"\n", 1)[0].strip()
    if version not in COMPATIBLE_GSASL:
        logger.debug("GSASL version '{0}' not known to be compatible"
                                                            .format(version))
        return
    if logger.isEnabledFor(logging.DEBUG):
        quiet = []
    else:
        quiet = ["--quiet"]
    try:
        pipe = subprocess.Popen(["gsasl", "--client-mechanisms"] + quiet,
                            stdout = subprocess.PIPE, stdin = subprocess.PIPE)
        stdout = pipe.communicate(b"NjY=\n")[0]
        stdout = stdout.strip().rsplit(b"\n", 1)[-1]
        code = pipe.wait()
    except OSError:
        code = -1
    if code:
        return
    gsasl_available = True
    gsasl_client_mechanisms = [s for s in stdout.decode("us-ascii").split()]
    logger.debug("client mechanisms: {0!r}".format(gsasl_client_mechanisms))
    try:
        pipe = subprocess.Popen(["gsasl", "--server-mechanisms"] + quiet,
                            stdout = subprocess.PIPE, stdin = subprocess.PIPE)
        stdout = pipe.communicate(b"abcd\n" * 4)[0]
        stdout = stdout.strip().rsplit(b"\n", 1)[-1]
        code = pipe.wait()
    except OSError:
        code = -1
    if not code:
        gsasl_server_mechanisms = [s for s in stdout.decode("us-ascii").split()]
        logger.debug("server mechanisms: {0!r}".format(gsasl_server_mechanisms))

class PasswordDatabase(sasl.PasswordDatabase):
    def __init__(self, username, password, realms = None):
        self.username = username
        self.password = password
        if realms:
            self.realms = realms
        else:
            self.realms = []
    def get_password(self, username, acceptable_formats, properties):
        if self.username == username:
            return self.password, "plain"
        else:
            return None, None

class GSASLError(Exception):
    pass

class OurSASLError(Exception):
    pass

@unittest.skipIf("gsasl" not in _support.RESOURCES, "GSASL usage disabled")
class TestSASLClientvsGSASL(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        if not gsasl_available:
            raise unittest.SkipTest("GSASL utility not available")

    def test_PLAIN_good_pass_no_authzid(self):
        if "PLAIN" not in gsasl_server_mechanisms:
            raise unittest.SkipTest( "GSASL has no PLAIN support")
        authenticator = sasl.client_authenticator_factory("PLAIN")
        auth_prop = {
                        "username": u"username",
                        "password": u"good",
                      }
        ok, props = self.try_with_gsasl("PLAIN", authenticator, auth_prop)
        self.assertTrue(ok)
        self.assertFalse(props.get("authzid"))

    def test_PLAIN_good_pass_authzid(self):
        if "PLAIN" not in gsasl_server_mechanisms:
            raise unittest.SkipTest( "GSASL has no PLAIN support")
        authenticator = sasl.client_authenticator_factory("PLAIN")
        auth_prop = {
                            "username": u"username",
                            "password": u"good",
                            "authzid": u"zid",
                          }
        ok, props = self.try_with_gsasl("PLAIN", authenticator, auth_prop)
        self.assertTrue(ok)
        self.assertEqual(props.get("authzid"), "zid")

    def test_PLAIN_bad_pass_no_authzid(self):
        if "PLAIN" not in gsasl_server_mechanisms:
            raise unittest.SkipTest( "GSASL has no PLAIN support")
        authenticator = sasl.client_authenticator_factory("PLAIN")
        auth_prop = {
                        "username": u"username",
                        "password": u"bad",
                      }
        ok, props = self.try_with_gsasl("PLAIN", authenticator, auth_prop)
        self.assertFalse(ok)
        self.assertFalse(props.get("authzid"))

    def test_DIGEST_MD5_good_pass_no_authzid(self):
        if "DIGEST-MD5" not in gsasl_server_mechanisms:
            raise unittest.SkipTest( "GSASL has no DIGEST-MD5 support")
        authenticator = sasl.client_authenticator_factory("DIGEST-MD5")
        auth_prop = {
                        "username": u"username",
                        "password": u"good",
                        "service-type": u"xmpp",
                        "service-domain": u"pyxmpp.jajcus.net",
                        "service-hostname": u"test.pyxmpp.jajcus.net",
                      }
        ok, props = self.try_with_gsasl("DIGEST-MD5", authenticator, auth_prop,
                        ["--service=xmpp", "--realm=jajcus.net",
                         "--host=test.pyxmpp.jajcus.net",
                         "--service-name=pyxmpp.jajcus.net"])
        self.assertTrue(ok)
        self.assertFalse(props.get("authzid"))

    def test_DIGEST_MD5_good_pass_authzid(self):
        if "DIGEST-MD5" not in gsasl_server_mechanisms:
            raise unittest.SkipTest( "GSASL has no DIGEST-MD5 support")
        authenticator = sasl.client_authenticator_factory("DIGEST-MD5")
        auth_prop = {
                        "username": u"username",
                        "password": u"good",
                        "service-type": u"xmpp",
                        "service-domain": u"pyxmpp.jajcus.net",
                        "service-hostname": u"test.pyxmpp.jajcus.net",
                        "authzid": u"zid",
                      }
        ok, props = self.try_with_gsasl("DIGEST-MD5", authenticator, auth_prop,
                        ["--service=xmpp", "--realm=jajcus.net",
                         "--host=test.pyxmpp.jajcus.net",
                         "--service-name=pyxmpp.jajcus.net"])
        self.assertTrue(ok)
        self.assertEqual(props.get("authzid"), u"zid")

    def test_DIGEST_MD5_bad_pass_no_authzid(self):
        if "DIGEST-MD5" not in gsasl_server_mechanisms:
            raise unittest.SkipTest( "GSASL has no DIGEST-MD5 support")
        authenticator = sasl.client_authenticator_factory("DIGEST-MD5")
        auth_prop = {
                        "username": u"username",
                        "password": u"bad",
                        "service-type": u"xmpp",
                        "service-domain": u"pyxmpp.jajcus.net",
                        "service-hostname": u"test.pyxmpp.jajcus.net",
                      }
        ok, dummy = self.try_with_gsasl("DIGEST-MD5", authenticator, auth_prop,
                        ["--service=xmpp", "--realm=jajcus.net",
                         "--host=test.pyxmpp.jajcus.net",
                         "--service-name=pyxmpp.jajcus.net"])
        self.assertFalse(ok)

    def test_SCRAM_SHA_1_good_pass_no_authzid(self):
        if "SCRAM-SHA-1" not in gsasl_server_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1 support")
        authenticator = sasl.client_authenticator_factory("SCRAM-SHA-1")
        auth_prop = {
                        "username": u"username",
                        "password": u"good",
                      }
        ok, props = self.try_with_gsasl("SCRAM-SHA-1", authenticator, auth_prop,
                                            ["--no-cb"])
        self.assertTrue(ok)
        self.assertFalse(props.get("authzid"))

    def test_SCRAM_SHA_1_good_pass_authzid(self):
        if "SCRAM-SHA-1" not in gsasl_server_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1 support")
        authenticator = sasl.client_authenticator_factory("SCRAM-SHA-1")
        auth_prop = {
                        "username": u"username",
                        "password": u"good",
                        "authzid": u"zid",
                      }
        ok, props = self.try_with_gsasl("SCRAM-SHA-1", authenticator, auth_prop,
                                            ["--no-cb"])
        self.assertTrue(ok)
        self.assertEqual(props.get("authzid"), "zid")

    def test_SCRAM_SHA_1_quoting(self):
        if "SCRAM-SHA-1" not in gsasl_server_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1 support")
        authenticator = sasl.client_authenticator_factory("SCRAM-SHA-1")
        auth_prop = {
                        "username": u"pi=3,14",
                        "password": u"good",
                        "authzid": u"e=2,72",
                      }
        ok, props = self.try_with_gsasl("SCRAM-SHA-1", authenticator, auth_prop,
                                            ["--no-cb"], username = "pi=3,14")
        self.assertTrue(ok)
        self.assertEqual(props.get("authzid"), "e=2,72")

    def test_SCRAM_SHA_1_bad_pass_no_authzid(self):
        if "SCRAM-SHA-1" not in gsasl_server_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1 support")
        authenticator = sasl.client_authenticator_factory("SCRAM-SHA-1")
        auth_prop = {
                        "username": u"username",
                        "password": u"bad",
                      }
        ok, dummy = self.try_with_gsasl("SCRAM-SHA-1", authenticator, auth_prop,
                                            ["--no-cb"])
        self.assertFalse(ok)

    def test_SCRAM_SHA_1_good_pass_downgrade(self):
        # Check protection from channel-binding downgrade.
        if "SCRAM-SHA-1-PLUS" not in gsasl_server_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1 support")
        authenticator = sasl.client_authenticator_factory("SCRAM-SHA-1")
        auth_prop = {
                        "enabled_mechanisms": ["SCRAM-SHA-1",
                                                    "SCRAM-SHA-1-PLUS"],
                        "username": u"username",
                        "password": u"good",
                      }
        cb_data = b"0123456789ab"
        ok, dummy = self.try_with_gsasl("SCRAM-SHA-1",
                                    authenticator, auth_prop,
                                    extra_data = standard_b64encode(cb_data))
        self.assertFalse(ok)

    @unittest.skipIf("SCRAM-SHA-1-PLUS" not in CLIENT_MECHANISMS_D,
                        "SCRAM-SHA-1-PLUS not available in PyXMPP2")
    def test_SCRAM_SHA_1_PLUS_good_pw_good_cb(self):
        if "SCRAM-SHA-1-PLUS" not in gsasl_server_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1-PLUS support")
        authenticator = sasl.client_authenticator_factory("SCRAM-SHA-1-PLUS")
        cb_data = b"0123456789ab"
        auth_prop = {
                        "username": u"username",
                        "password": u"good",
                        "channel-binding": {
                            "tls-unique": cb_data,
                        },
                      }
        ok, props = self.try_with_gsasl("SCRAM-SHA-1-PLUS",
                                        authenticator,
                                        auth_prop,
                                    extra_data = standard_b64encode(cb_data))
        self.assertTrue(ok)
        self.assertFalse(props.get("authzid"))

    @unittest.skipIf("SCRAM-SHA-1-PLUS" not in CLIENT_MECHANISMS_D,
                        "SCRAM-SHA-1-PLUS not available in PyXMPP2")
    def test_SCRAM_SHA_1_PLUS_bad_pw_good_cb(self):
        if "SCRAM-SHA-1-PLUS" not in gsasl_server_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1-PLUS support")
        authenticator = sasl.client_authenticator_factory("SCRAM-SHA-1-PLUS")
        cb_data = b"0123456789ab"
        auth_prop = {
                        "username": u"username",
                        "password": u"bad",
                        "channel-binding": {
                            "tls-unique": cb_data,
                        },
                      }
        ok, dummy = self.try_with_gsasl("SCRAM-SHA-1-PLUS",
                                        authenticator,
                                        auth_prop,
                                    extra_data = standard_b64encode(cb_data))
        self.assertFalse(ok)

    @unittest.skipIf("SCRAM-SHA-1-PLUS" not in CLIENT_MECHANISMS_D,
                        "SCRAM-SHA-1-PLUS not available in PyXMPP2")
    def test_SCRAM_SHA_1_PLUS_good_pw_bad_cb(self):
        if "SCRAM-SHA-1-PLUS" not in gsasl_server_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1-PLUS support")
        authenticator = sasl.client_authenticator_factory("SCRAM-SHA-1-PLUS")
        cb_data = b"0123456789ab"
        auth_prop = {
                        "username": u"username",
                        "password": u"good",
                        "channel-binding": {
                            "tls-unique": cb_data,
                        },
                      }
        cb_data = b"BAD_BAD_BAD_"
        ok, dummy = self.try_with_gsasl("SCRAM-SHA-1-PLUS",
                                        authenticator,
                                        auth_prop,
                                    extra_data = standard_b64encode(cb_data))
        self.assertFalse(ok)

    @staticmethod
    def try_with_gsasl(mechanism, authenticator, auth_properties,
                    gsasl_args = [], extra_data = None, username = "username"):
        # pylint: disable=W0102,R0914,R0912,R0915
        cmd = ["gsasl", "--server",
                "--mechanism=" + mechanism, "--password=good",
                "--authentication-id={0}".format(username)] + gsasl_args
        if logger.isEnabledFor(logging.DEBUG):
            stderr = None
            logger.debug("cmd: %r", " ".join(cmd))
        else:
            cmd.append("--quiet")
            stderr = open("/dev/null", "w")
        pipe = subprocess.Popen(cmd, bufsize = 1, stdout = subprocess.PIPE,
                        stdin = subprocess.PIPE, stderr = stderr)
        if stderr:
            stderr.close()
        if extra_data:
            data = extra_data + b"\n"
            logger.debug("OUT: %r", data)
            pipe.stdin.write(data)
            pipe.stdin.flush()
        mech = pipe.stdout.readline()
        logger.debug("IN: %r", mech)
        if extra_data and extra_data in mech:
            mech = pipe.stdout.readline()
            logger.debug("IN: %r", mech)
        mech = mech.strip().decode("utf-8")
        if mech != mechanism:
            pipe.stdin.close()
            pipe.stdout.close()
            raise GSASLError, "GSASL returned different mechanism: " + mech
        result = authenticator.start(auth_properties)
        if isinstance(result, sasl.Failure):
            pipe.stdin.close()
            pipe.stdout.close()
            raise OurSASLError, result.reason
        response = result.encode()
        if response:
            data = (response + "\n").encode("utf-8")
            logger.debug("OUT: %r", data)
            pipe.stdin.write(data)
            pipe.stdin.flush()
            ignore_empty_challenge = True
        else:
            ignore_empty_challenge = False
        while True:
            challenge = pipe.stdout.readline().strip()
            if not challenge:
                if ignore_empty_challenge:
                    logger.debug("Ignoring empty initial challenge")
                    ignore_empty_challenge = False
                    continue
                else:
                    break
            if challenge.startswith(b'Mechanism requested'):
                continue
            try:
                decoded = a2b_base64(challenge)
            except (ValueError, binascii.Error):
                logger.debug("not base64: %r", challenge)
            if challenge.startswith(b'\x1b['):
                logger.debug("echo: %r", challenge)
                # for some unknown reason gsasl echoes our data back
                response = None
                continue
            if response and a2b_base64(response.encode("utf-8")) == decoded:
                logger.debug("echo: %r", challenge)
                # for some unknown reason gsasl echoes our data back
                response = None
                continue
            logger.debug("IN: %r", challenge)
            result = authenticator.challenge(decoded)
            if isinstance(result, sasl.Failure):
                raise OurSASLError, result.reason
            response = result.encode()
            data = (response + "\n").encode("utf-8")
            logger.debug("OUT: %r", data)
            pipe.stdin.write(data)
            pipe.stdin.flush()
            if not response:
                break
        pipe.stdin.close()
        pipe.stdout.close()
        code = pipe.wait()
        if code:
            return False, {}
        result = authenticator.finish(None)
        if isinstance(result, sasl.Success):
            return True, result.properties
        else:
            return False, {}

@unittest.skipIf("gsasl" not in _support.RESOURCES, "GSASL usage disabled")
class TestSASLServervsGSASL(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        if not gsasl_available:
            raise unittest.SkipTest("GSASL utility not available")

    def test_PLAIN_good_pass_no_authzid(self):
        if "PLAIN" not in gsasl_client_mechanisms:
            raise unittest.SkipTest("GSASL has no PLAIN support")
        pwdb = PasswordDatabase("username", "good")
        authenticator = sasl.server_authenticator_factory("PLAIN", pwdb)
        ok, props = self.try_with_gsasl("PLAIN", authenticator, {})
        self.assertTrue(ok)
        self.assertFalse(props.get("authzid"))

    def test_PLAIN_bad_pass_no_authzid(self):
        if "PLAIN" not in gsasl_client_mechanisms:
            raise unittest.SkipTest("GSASL has no PLAIN support")
        pwdb = PasswordDatabase("username", "bad")
        authenticator = sasl.server_authenticator_factory("PLAIN", pwdb)
        with self.assertRaises(OurSASLError) as err:
            self.try_with_gsasl("PLAIN", authenticator, {})
        self.assertEqual(err.exception.args[0], "not-authorized")

    def test_DIGEST_MD5_good_pass_no_authzid(self):
        if "DIGEST-MD5" not in gsasl_client_mechanisms:
            raise unittest.SkipTest( "GSASL has no DIGEST-MD5 support")
        pwdb = PasswordDatabase("username", "good")
        authenticator = sasl.server_authenticator_factory("DIGEST-MD5", pwdb)
        auth_prop = {
                        "service-type": u"xmpp",
                        "service-domain": u"pyxmpp.jajcus.net",
                        "service-hostname": u"test.pyxmpp.jajcus.net",
                      }
        ok, props = self.try_with_gsasl("DIGEST-MD5", authenticator, auth_prop,
                            [ "--service=xmpp", "--realm=jajcus.net",
                                "--host=test.pyxmpp.jajcus.net",
                                "--service-name=pyxmpp.jajcus.net",
                                "--quality-of-protection=qop-auth"])
        self.assertTrue(ok)
        self.assertIsNone(props.get("authzid"))


    def test_DIGEST_MD5_good_pass_authzid(self):
        if "DIGEST-MD5" not in gsasl_client_mechanisms:
            raise unittest.SkipTest( "GSASL has no DIGEST-MD5 support")
        pwdb = PasswordDatabase("username", "good")
        authenticator = sasl.server_authenticator_factory("DIGEST-MD5", pwdb)
        auth_prop = {
                        "service-type": u"xmpp",
                        "service-domain": u"pyxmpp.jajcus.net",
                        "service-hostname": u"test.pyxmpp.jajcus.net",
                      }
        ok, props = self.try_with_gsasl("DIGEST-MD5", authenticator, auth_prop,
                            [ "--service=xmpp", "--realm=jajcus.net",
                                "--host=test.pyxmpp.jajcus.net",
                                "--service-name=pyxmpp.jajcus.net",
                                "--quality-of-protection=qop-auth",
                                "--authorization-id=zid"])
        self.assertTrue(ok)
        self.assertEqual(props.get("authzid"), "zid")

    def test_DIGEST_MD5_bad_pass_no_authzid(self):
        if "DIGEST-MD5" not in gsasl_client_mechanisms:
            raise unittest.SkipTest( "GSASL has no DIGEST-MD5 support")
        pwdb = PasswordDatabase("username", "bad")
        authenticator = sasl.server_authenticator_factory("DIGEST-MD5", pwdb)
        auth_prop = {
                        "service-type": u"xmpp",
                        "service-domain": u"pyxmpp.jajcus.net",
                        "service-hostname": u"test.pyxmpp.jajcus.net",
                      }
        with self.assertRaises(OurSASLError) as err:
            self.try_with_gsasl("DIGEST-MD5", authenticator, auth_prop,
                            [ "--service=xmpp", "--realm=jajcus.net",
                                "--host=test.pyxmpp.jajcus.net",
                                "--service-name=pyxmpp.jajcus.net",
                                "--quality-of-protection=qop-auth"])
        self.assertEqual(err.exception.args[0], "not-authorized")

    def test_SCRAM_SHA_1_good_pass_no_authzid(self):
        if "SCRAM-SHA-1" not in gsasl_client_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1 support")
        pwdb = PasswordDatabase("username", "good")
        authenticator = sasl.server_authenticator_factory("SCRAM-SHA-1", pwdb)
        auth_prop = { "enabled_mechanisms": ["SCRAM-SHA-1"]}
        ok, props = self.try_with_gsasl("SCRAM-SHA-1", authenticator, auth_prop,
                                                        [ "--no-cb"])
        self.assertTrue(ok)
        self.assertIsNone(props.get("authzid"))

    def test_SCRAM_SHA_1_good_pass_authzid(self):
        if "SCRAM-SHA-1" not in gsasl_client_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1 support")
        pwdb = PasswordDatabase("username", "good")
        authenticator = sasl.server_authenticator_factory("SCRAM-SHA-1", pwdb)
        auth_prop = { }
        ok, props = self.try_with_gsasl("SCRAM-SHA-1", authenticator, auth_prop,
                                        [ "--no-cb", "--authorization-id=zid"])
        self.assertTrue(ok)
        self.assertEqual(props.get("authzid"), "zid")

    def test_SCRAM_SHA_1_quoting(self):
        if "SCRAM-SHA-1" not in gsasl_client_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1 support")
        pwdb = PasswordDatabase("pi=3,14", "good")
        authenticator = sasl.server_authenticator_factory("SCRAM-SHA-1", pwdb)
        auth_prop = { }
        ok, props = self.try_with_gsasl("SCRAM-SHA-1", authenticator, auth_prop,
                            [ "--no-cb", "--authorization-id=e=2,72"],
                            username = "pi=3,14")
        self.assertTrue(ok)
        self.assertEqual(props.get("authzid"), "e=2,72")


    def test_SCRAM_SHA_1_bad_username(self):
        if "SCRAM-SHA-1" not in gsasl_client_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1 support")
        pwdb = PasswordDatabase("bad", "good")
        authenticator = sasl.server_authenticator_factory("SCRAM-SHA-1", pwdb)
        auth_prop = { }
        with self.assertRaises(OurSASLError) as err:
            self.try_with_gsasl("SCRAM-SHA-1", authenticator, auth_prop,
                                                                [ "--no-cb"])
        self.assertEqual(err.exception.args[0], "not-authorized")

    def test_SCRAM_SHA_1_bad_pass_no_authzid(self):
        if "SCRAM-SHA-1" not in gsasl_client_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1 support")
        pwdb = PasswordDatabase("username", "bad")
        authenticator = sasl.server_authenticator_factory("SCRAM-SHA-1", pwdb)
        auth_prop = { }
        with self.assertRaises(OurSASLError) as err:
            self.try_with_gsasl("SCRAM-SHA-1", authenticator,
                                                auth_prop, [ "--no-cb"])
        self.assertEqual(err.exception.args[0], "not-authorized")

    def test_SCRAM_SHA_1_good_pass_downgrade(self):
        if "SCRAM-SHA-1" not in gsasl_client_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1 support")
        pwdb = PasswordDatabase("username", "good")
        authenticator = sasl.server_authenticator_factory("SCRAM-SHA-1", pwdb)
        auth_prop = { "enabled_mechanisms": ["SCRAM-SHA-1", "SCRAM-SHA-1-PLUS"]}
        cb_data = b"0123456789ab"
        with self.assertRaises(OurSASLError) as err:
            self.try_with_gsasl("SCRAM-SHA-1", authenticator, auth_prop,
                                    extra_data = standard_b64encode(cb_data))
        self.assertEqual(err.exception.args[0], "not-authorized")

    def test_SCRAM_SHA_1_PLUS_good_pass_authzid(self):
        if "SCRAM-SHA-1-PLUS" not in gsasl_client_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1-PLUS support")
        pwdb = PasswordDatabase("username", "good")
        authenticator = sasl.server_authenticator_factory("SCRAM-SHA-1-PLUS",
                                                                        pwdb)
        cb_data = b"0123456789ab"
        auth_prop = { "channel-binding": {"tls-unique": cb_data} }
        ok, props = self.try_with_gsasl("SCRAM-SHA-1-PLUS", authenticator,
                                        auth_prop, ["--authorization-id=zid"],
                                    extra_data = standard_b64encode(cb_data))
        self.assertTrue(ok)
        self.assertEqual(props.get("authzid"), "zid")

    def test_SCRAM_SHA_1_PLUS_bad_pass_no_authzid(self):
        if "SCRAM-SHA-1-PLUS" not in gsasl_client_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1-PLUS support")
        pwdb = PasswordDatabase("username", "bad")
        authenticator = sasl.server_authenticator_factory("SCRAM-SHA-1-PLUS",
                                                                        pwdb)
        cb_data = b"0123456789ab"
        auth_prop = { "channel-binding": {"tls-unique": cb_data} }
        with self.assertRaises(OurSASLError) as err:
            self.try_with_gsasl("SCRAM-SHA-1-PLUS", authenticator, auth_prop,
                                    extra_data = standard_b64encode(cb_data))
        self.assertEqual(err.exception.args[0], "not-authorized")

    def test_SCRAM_SHA_1_PLUS_good_pass_bad_cb(self):
        if "SCRAM-SHA-1-PLUS" not in gsasl_client_mechanisms:
            raise unittest.SkipTest( "GSASL has no SCRAM-SHA-1-PLUS support")
        pwdb = PasswordDatabase("username", "good")
        authenticator = sasl.server_authenticator_factory("SCRAM-SHA-1-PLUS",
                                                                        pwdb)
        cb_data = b"0123456789ab"
        auth_prop = { "channel-binding": {"tls-unique": cb_data} }
        bad_cb_data = b"ab0123456789"
        with self.assertRaises(OurSASLError) as err:
            self.try_with_gsasl("SCRAM-SHA-1-PLUS", authenticator, auth_prop,
                                extra_data = standard_b64encode(bad_cb_data))
        self.assertEqual(err.exception.args[0], "not-authorized")



    @staticmethod
    def try_with_gsasl(mechanism, authenticator, auth_prop, gsasl_args = [],
                                    extra_data = None, username = "username"):
        # pylint: disable=W0102,R0914,R0912,R0915
        cmd = ["gsasl", "--client",
                "--mechanism=" + mechanism, "--password=good",
                "--authentication-id={0}".format(username)] + gsasl_args
        if logger.isEnabledFor(logging.DEBUG):
            stderr = None
            logger.debug("cmd: %r", " ".join(cmd))
        else:
            cmd.append("--quiet")
            stderr = open("/dev/null", "w")
        pipe = subprocess.Popen(cmd, bufsize = 1, stdout = subprocess.PIPE,
                                    stdin = subprocess.PIPE, stderr = stderr)
        if stderr:
            stderr.close()
        if extra_data:
            data = extra_data + b"\n"
            logger.debug("OUT: %r", data)
            pipe.stdin.write(data)
            pipe.stdin.flush()
        mech = pipe.stdout.readline()
        logger.debug("IN: %r", mech)
        if extra_data and extra_data in mech:
            mech = pipe.stdout.readline()
            logger.debug("IN: %r", mech)
        mech = mech.strip().decode("utf-8")
        logger.debug("IN: %r", mech)
        if mech != mechanism:
            raise GSASLError, "GSASL returned different mechanism: " + mech
        data = pipe.stdout.readline().strip()
        if data:
            result = authenticator.start(auth_prop, a2b_base64(data))
        else:
            result = authenticator.start(auth_prop, None)
        if isinstance(result, sasl.Failure):
            pipe.stdin.close()
            pipe.stdout.close()
            raise OurSASLError, result.reason
        if isinstance(result, sasl.Success):
            pipe.stdin.close()
            pipe.stdout.close()
            code = pipe.wait()
            if code:
                raise GSASLError, "GSASL exited with {0}".format(code)
            return True, result.properties
        challenge = result.encode()
        data = (challenge + "\n").encode("utf-8")
        logger.debug("OUT: %r", data)
        pipe.stdin.write(data)
        pipe.stdin.flush()
        success = None
        while not success:
            response = pipe.stdout.readline().strip()
            if not response:
                break
            if response.startswith(b'Mechanism requested'):
                continue
            try:
                decoded = a2b_base64(response)
            except (ValueError, binascii.Error):
                logger.debug("not base64: %r", response)
            if response.startswith(b'\x1b[') or challenge and (
                    a2b_base64(challenge.encode("utf-8")) == decoded):
                logger.debug("echo: %r", challenge)
                # for some unknown reason gsasl echoes our data back
                challenge = None
                continue
            logger.debug("IN: %r", response)
            result = authenticator.response(decoded)
            if isinstance(result, sasl.Failure):
                pipe.stdin.close()
                pipe.stdout.close()
                raise OurSASLError, result.reason
            if isinstance(result, sasl.Success):
                success = result
                if not success.data:
                    break
            challenge = result.encode()
            data = (challenge + "\n").encode("utf-8")
            logger.debug("OUT: %r", data)
            pipe.stdin.write(data)
            pipe.stdin.flush()
        pipe.communicate()
        pipe.stdin.close()
        pipe.stdout.close()
        code = pipe.wait()
        if code:
            raise GSASLError, "GSASL exited with {0}".format(code)
        if success:
            return True, success.properties
        else:
            return False, None

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    check_gsasl()
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = server_listener
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

"""Tests for pyxmpp2.server.listener"""

import unittest
import socket
import threading
import logging
import time
import select

try:
    import glib
except ImportError:
    # pylint: disable=C0103
    glib = None

from pyxmpp2.test import _support

from pyxmpp2.server.listener import TCPListener
from pyxmpp2.mainloop.select import SelectMainLoop
from pyxmpp2.mainloop.poll import PollMainLoop
from pyxmpp2.mainloop.threads import ThreadPool

logger = logging.getLogger("pyxmpp2.test.server_listener")

TEST_PORT = 10256
TIMEOUT = 30 # seconds

@unittest.skipIf("lo-network" not in _support.RESOURCES,
                                        "loopback network usage disabled")
class TestListenerSelect(unittest.TestCase):
    def setUp(self):
        self.lock = threading.RLock()
        self.connected = []
        self.accepted = []

    @staticmethod
    def make_loop(handlers):
        """Return a main loop object for use with this test suite."""
        return SelectMainLoop(None, handlers)

    def tearDown(self):
        with self.lock:
            for sock in self.connected:
                sock.close()
            for sock, _addr in self.accepted:
                sock.close()
            self.connected = None
            self.accepted = None

    def start_connections(self, target_address, number):
        """
        Start a thread which will make `number` connections to
        `target_address`.
        """
        def thread_func():
            for dummy in range(number):
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                try:
                    sock.connect(target_address)
                    with self.lock:
                        if self.connected is None:
                            return
                        self.connected.append(sock)
                except:
                    sock.close()
                    raise
        thread = threading.Thread(name = "Listener test connections",
                                                    target = thread_func)
        thread.daemon = True
        thread.start()

    def accept(self, sock, address):
        with self.lock:
            if self.accepted is None:
                return
            self.accepted.append((sock, address))

    def test_listener(self):
        listener = TCPListener(socket.AF_INET, ('127.0.0.1', TEST_PORT),
                                                                self.accept)
        loop = self.make_loop([listener])
        loop.loop_iteration(0.1)
        self.start_connections(('127.0.0.1', TEST_PORT), 10)
        timeout = time.time() + TIMEOUT
        while not loop.finished and (len(self.accepted) < 10
                                                or len(self.connected) < 10):
            loop.loop_iteration(0.1)
            if time.time() > timeout:
                break
        listener.close()
        self.assertEqual(len(self.accepted), 10)
        self.assertEqual(len(self.connected), 10)
        con_addrs = [sock.getsockname() for sock in self.connected]
        con_addrs.sort()
        acc_addrs = [acc[1] for acc in self.accepted]
        acc_addrs.sort()
        self.assertEqual(con_addrs, acc_addrs)
        self.assertEqual(self.accepted[0][0].getpeername(),
                                                        self.accepted[0][1])

@unittest.skipIf("lo-network" not in _support.RESOURCES,
                                        "loopback network usage disabled")
@unittest.skipIf(not hasattr(select, "poll"), "No poll() support")
class TestListenerPoll(TestListenerSelect):
    @staticmethod
    def make_loop(handlers):
        """Return a main loop object for use with this test suite."""
        return PollMainLoop(None, handlers)

@unittest.skip("Broken-slow")
@unittest.skipIf("lo-network" not in _support.RESOURCES,
                                        "loopback network usage disabled")
@unittest.skipIf(glib is None, "No glib module")
class TestListenerGLib(TestListenerSelect):
    @staticmethod
    def make_loop(handlers):
        """Return a main loop object for use with this test suite."""
        from pyxmpp2.mainloop.glib import GLibMainLoop
        return GLibMainLoop(None, handlers)

@unittest.skipIf("lo-network" not in _support.RESOURCES,
                                        "loopback network usage disabled")
@unittest.skipIf(not hasattr(select, "poll"), "No poll() support")
class TestListenerThread(TestListenerSelect):
    def setUp(self):
        self._loop = None
        super(TestListenerThread, self).setUp()
    def make_loop(self, handlers):
        """Return a main loop object for use with this test suite."""
        self._loop = ThreadPool(None, handlers)
        self._loop.start()
        return self._loop
    def tearDown(self):
        if self._loop:
            logger.debug("Stopping the thread pool")
            try:
                self._loop.stop(True, 2)
            except Exception: # pylint: disable=W0703
                logger.exception("self.loop.stop failed:")
            else:
                logger.debug("  done (or timed out)")
            self._loop.event_dispatcher.flush(False)
        super(TestListenerThread, self).tearDown()

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = stanza
#!/usr/bin/python -u
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

import unittest

import re

from pyxmpp2.etree import ElementTree

from pyxmpp2.interfaces import StanzaPayload
from pyxmpp2.interfaces import payload_element_name

from pyxmpp2.stanzapayload import XMLPayload

from pyxmpp2.stanza import Stanza
from pyxmpp2.jid import JID

from pyxmpp2.utils import xml_elements_equal


STANZA0 = "<presence xmlns='jabber:client' />"
STANZA1 = "<presence xmlns='jabber:server'><status>STATUS</status></presence>"
STANZA2 = "<message xmlns='jabber:client' />"
STANZA3 = """
<presence from='a@b.c/d' to='e@f.g/h' id='666' type='unavailable'
                                                xmlns='jabber:client'/>
"""
STANZA4 = """
<message from='a@b.c/d' to='e@f.g' id='666' type='chat'
                                                    xmlns='jabber:client'>
        <subject>Subject</subject>
        <body>Body</body>
</message>
"""

STANZA5 = """
<iq from='a@b.c/d' to='e@f.g/h' id='666' type='get' xmlns='jabber:client'>
    <query xmlns='jabber:iq:version' />
</iq>
"""

STANZA6 = """
<iq from='a@b.c/d' to='e@f.g/h' id='666' type='get' xmlns='jabber:client'>
    <element xmlns='http://pyxmpp.jajcus.net/test/ns' />
</iq>
"""
STANZA7 = """
<iq from='a@b.c/d' to='e@f.g/h' id='666' type='get' xmlns='jabber:client'>
    <element xmlns='http://pyxmpp.jajcus.net/test/ns'><data>Test</data></element>
</iq>
"""


@payload_element_name(u"{http://pyxmpp.jajcus.net/test/ns}element")
class TestPayload(StanzaPayload):
    def __init__(self, data = None):
        self.data = data

    @classmethod
    def from_xml(cls, element):
        data = None
        for child in element:
            if child.tag == u"{http://pyxmpp.jajcus.net/test/ns}data":
                data = child.text
        return cls(data)

    def as_xml(self):
        element = ElementTree.Element(
                                u"{http://pyxmpp.jajcus.net/test/ns}element")
        if self.data:
            ElementTree.SubElement(element,
                    u"{http://pyxmpp.jajcus.net/test/ns}data").text = self.data
        return element

class TestStanza(unittest.TestCase):
    def test_stanza_from_empty_element(self):
        stanza0 = Stanza(ElementTree.XML(STANZA0))
        self.assertEqual(stanza0.element_name, "presence")
        self.assertEqual(stanza0.from_jid, None)
        self.assertEqual(stanza0.to_jid, None)
        self.assertEqual(stanza0.stanza_type, None)
        self.assertEqual(stanza0.stanza_id, None)
        stanza1 = Stanza(ElementTree.XML(STANZA1))
        self.assertEqual(stanza1.element_name, "presence")
        self.assertEqual(stanza1.from_jid, None)
        self.assertEqual(stanza1.to_jid, None)
        self.assertEqual(stanza1.stanza_type, None)
        self.assertEqual(stanza1.stanza_id, None)
        stanza2 = Stanza(ElementTree.XML(STANZA2))
        self.assertEqual(stanza2.element_name, "message")
        self.assertEqual(stanza2.from_jid, None)
        self.assertEqual(stanza2.to_jid, None)
        self.assertEqual(stanza2.stanza_type, None)
        self.assertEqual(stanza2.stanza_id, None)
    def test_stanza_attributes(self):
        stanza3 = Stanza(ElementTree.XML(STANZA3))
        self.assertEqual(stanza3.element_name, u"presence")
        self.assertEqual(stanza3.from_jid, JID(u"a@b.c/d"))
        self.assertEqual(stanza3.to_jid, JID(u"e@f.g/h"))
        self.assertEqual(stanza3.stanza_type, u"unavailable")
        self.assertEqual(stanza3.stanza_id, u'666')
    def test_stanza_build(self):
        stanza = Stanza("presence", from_jid = JID('a@b.c/d'),
                            to_jid = JID('e@f.g/h'), stanza_id = '666',
                            stanza_type = 'unavailable')
        self.assertTrue(xml_elements_equal(stanza.as_xml(),
                                                    ElementTree.XML(STANZA3)))
    def test_serialize1(self):
        for xml in (STANZA0, STANZA1, STANZA2, STANZA3, STANZA4, STANZA5):
            stanza = Stanza(ElementTree.XML(xml))
            element1 = ElementTree.XML(re.sub(r" xmlns='jabber:[^'\":]*'",
                                                                    "", xml))
            element2 = ElementTree.XML(stanza.serialize())
            self.assertTrue(xml_elements_equal(element1, element2, True))
    def test_serialize2(self):
        stanza = Stanza("presence", from_jid = JID('a@b.c/d'),
                            to_jid = JID('e@f.g/h'), stanza_id = '666',
                            stanza_type = 'unavailable')
        xml = stanza.serialize()
        self.assertTrue(xml_elements_equal(ElementTree.XML(xml),
            ElementTree.XML(STANZA3.replace(" xmlns='jabber:client'",""))))

    def test_stanza_as_xml(self):
        # STANZA1 and STANZA2 won't match as have no namespace
        for xml in (STANZA0, STANZA3, STANZA4, STANZA5):
            stanza = Stanza(ElementTree.XML(xml))
            self.assertTrue(xml_elements_equal(stanza.as_xml(),
                                                ElementTree.XML(xml), True))
    def test_stanza_get_xml(self):
        for xml in (STANZA0, STANZA1, STANZA2, STANZA3, STANZA4, STANZA5):
            element = ElementTree.XML(xml)
            stanza = Stanza(element)
            self.assertTrue(stanza.get_xml() is element)
    def test_stanza_payload(self):
        stanza5 = Stanza(ElementTree.XML(STANZA5))
        payload = stanza5.get_all_payload()
        self.assertEqual(len(payload), 1)
        payload = payload[0]
        self.assertIsInstance(payload, StanzaPayload)
        self.assertIsInstance(payload, XMLPayload)
        self.assertEqual(payload.xml_element_name, "{jabber:iq:version}query")
        self.assertTrue(xml_elements_equal(
                            ElementTree.XML(STANZA5)[0], payload.element))

    def test_stanza_get_custom_payload(self):
        stanza6 = Stanza(ElementTree.XML(STANZA6))
        payload = stanza6.get_payload(TestPayload)
        self.assertIsInstance(payload, TestPayload)
        self.assertIsNone(payload.data) # pylint: disable=E1103
        self.assertTrue(xml_elements_equal(ElementTree.XML(STANZA6)[0],
                                                            payload.as_xml()))

    def test_stanza_set_custom_payload(self):
        stanza7 = Stanza("iq", from_jid = JID('a@b.c/d'),
                            to_jid = JID('e@f.g/h'), stanza_id = '666',
                            stanza_type='get')
        payload = TestPayload(data = u"Test")
        stanza7.set_payload(payload)
        payload1 = stanza7.get_payload(TestPayload)
        self.assertTrue(payload1 is payload)
        self.assertTrue(xml_elements_equal(ElementTree.XML(STANZA7),
                                                    stanza7.as_xml(), True))

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = stanzaprocessor
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

import unittest

from pyxmpp2.etree import ElementTree

from pyxmpp2.iq import Iq
from pyxmpp2.message import Message
from pyxmpp2.presence import Presence
from pyxmpp2.stanzaprocessor import stanza_factory, StanzaProcessor
from pyxmpp2.interfaces import XMPPFeatureHandler
from pyxmpp2.interfaces import iq_get_stanza_handler
from pyxmpp2.interfaces import iq_set_stanza_handler
from pyxmpp2.interfaces import message_stanza_handler
from pyxmpp2.interfaces import presence_stanza_handler
from pyxmpp2.stanzapayload import XMLPayload
from pyxmpp2.jid import JID
from pyxmpp2.utils import xml_elements_equal


IQ1 = """
<iq xmlns="jabber:client" from='source@example.com/res'
                                to='dest@example.com' type='get' id='1'>
<payload xmlns="http://pyxmpp.jajcus.net/xmlns/test"><abc/></payload>
</iq>"""

IQ2 = """
<iq xmlns="jabber:client" to='source@example.com/res'
                                from='dest@example.com' type='result' id='1'>
<payload xmlns="http://pyxmpp.jajcus.net/xmlns/test"><abc/></payload>
</iq>"""

IQ3 = """
<iq xmlns="jabber:client" from='source@example.com/res'
                                to='dest@example.com' type='set' id='2'>
<payload xmlns="http://pyxmpp.jajcus.net/xmlns/test"><abc/></payload>
</iq>"""

IQ4 = """
<iq xmlns="jabber:client" to='source@example.com/res'
                                from='dest@example.com' type='result' id='2'>
</iq>"""

MESSAGE1 = """
<message xmlns="jabber:client" from='source@example.com/res'
                                to='dest@example.com' type='normal' id='1'>
<subject>Subject</subject>
<body>The body</body>
<thread>thread-id</thread>
<payload xmlns="http://pyxmpp.jajcus.net/xmlns/test"><abc/></payload>
</message>"""

MESSAGE2 = """<message xmlns="jabber:client"/>"""

MESSAGE3 = """<message xmlns="jabber:client" type='chat'>
<body>Chat!</body>
</message>"""

PRESENCE1 = """
<presence xmlns="jabber:client" from='source@example.com/res'
                                            to='dest@example.com' id='1'>
<show>away</show>
<status>The Status</status>
<priority>10</priority>
<payload xmlns="http://pyxmpp.jajcus.net/xmlns/test"><abc/></payload>
</presence>"""

PRESENCE2 = """<presence xmlns="jabber:client"/>"""

PRESENCE3 = """<presence xmlns="jabber:client" from='source@example.com/res'
                                to='dest@example.com' type="subscribe" />"""
PRESENCE4 = """<presence xmlns="jabber:client" to='source@example.com/res'
                                from='dest@example.com' type="subscribed" />"""

ALL_STANZAS = (IQ1, IQ2, IQ3, IQ4, MESSAGE1, MESSAGE2, MESSAGE3,
            PRESENCE1, PRESENCE2, PRESENCE3, PRESENCE4)
NON_IQ_STANZAS = (MESSAGE1, MESSAGE2, MESSAGE3,
                    PRESENCE1, PRESENCE2, PRESENCE3, PRESENCE4)

class TestStanzaFactory(unittest.TestCase):
    def test_iq(self):
        element = ElementTree.XML(IQ1)
        stanza = stanza_factory(element)
        self.assertTrue( isinstance(stanza, Iq) )
    def test_message(self):
        element = ElementTree.XML(MESSAGE1)
        stanza = stanza_factory(element)
        self.assertTrue( isinstance(stanza, Message) )
    def test_presence(self):
        element = ElementTree.XML(PRESENCE1)
        stanza = stanza_factory(element)
        self.assertTrue( isinstance(stanza, Presence) )

class TestStanzaProcessor(unittest.TestCase):
    # pylint: disable=R0904
    def setUp(self):
        self.handlers_called = []
        self.stanzas_sent = []
        self.proc = StanzaProcessor()
        self.proc.me = JID("dest@example.com/xx")
        self.proc.peer = JID("source@example.com/yy")
        self.proc.send = self.send
        self.proc.initiator = True

    def send(self, stanza):
        self.stanzas_sent.append(stanza)

    def process_stanzas(self, xml_elements):
        for xml in xml_elements:
            stanza = stanza_factory(ElementTree.XML(xml))
            self.proc.process_stanza(stanza)

    def ignore_iq_get(self, stanza):
        self.handlers_called.append("ignore_iq_get")
        self.assertIsInstance(stanza, Iq)
        self.assertEqual(stanza.stanza_type, "get")
        return True

    def ignore_iq_set(self, stanza):
        self.handlers_called.append("ignore_iq_set")
        self.assertIsInstance(stanza, Iq)
        self.assertEqual(stanza.stanza_type, "set")
        return True

    def reply_iq_get(self, stanza):
        self.handlers_called.append("reply_iq_get")
        self.assertIsInstance(stanza, Iq)
        self.assertEqual(stanza.stanza_type, "get")
        reply = stanza.make_result_response()
        element = ElementTree.Element(
                                "{http://pyxmpp.jajcus.net/xmlns/test}payload")
        ElementTree.SubElement(element,
                                    "{http://pyxmpp.jajcus.net/xmlns/test}abc")
        reply.set_payload(element)
        return reply

    def reply_iq_set(self, stanza):
        self.handlers_called.append("reply_iq_set")
        self.assertIsInstance(stanza, Iq)
        self.assertEqual(stanza.stanza_type, "set")
        reply = stanza.make_result_response()
        return reply

    def echo_message(self, stanza):
        self.handlers_called.append("echo_message")
        self.assertIsInstance(stanza, Message)
        self.assertNotEqual(stanza.stanza_type, "error")
        message = Message(to_jid = stanza.from_jid,
                    from_jid = stanza.to_jid,
                    stanza_type = stanza.stanza_type,
                    thread = stanza.thread,
                    subject = stanza.subject,
                    body = stanza.body)
        return message

    def eat1(self, stanza):
        # pylint: disable=W0613
        self.handlers_called.append("eat1")
        return True
    def eat2(self, stanza):
        # pylint: disable=W0613
        self.handlers_called.append("eat2")
        return True
    def pass1(self, stanza):
        # pylint: disable=W0613
        self.handlers_called.append("pass1")
    def pass2(self, stanza):
        # pylint: disable=W0613
        self.handlers_called.append("pass2")

    def test_iq_ignore_handlers(self):
        parent = self
        class Handlers(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @iq_get_stanza_handler(XMLPayload,
                                "{http://pyxmpp.jajcus.net/xmlns/test}payload")
            def handler1(self, stanza):
                return parent.ignore_iq_get(stanza)
            @iq_set_stanza_handler(XMLPayload,
                                "{http://pyxmpp.jajcus.net/xmlns/test}payload")
            def handler2(self, stanza):
                return parent.ignore_iq_set(stanza)
        self.proc.setup_stanza_handlers([Handlers()], "post-auth")
        self.process_stanzas(ALL_STANZAS)
        self.assertEqual(self.handlers_called, ["ignore_iq_get",
                                                    "ignore_iq_set"])
        self.assertFalse(self.stanzas_sent)

    def test_iq_reply_handlers(self):
        parent = self
        class Handlers(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @iq_get_stanza_handler(XMLPayload,
                                "{http://pyxmpp.jajcus.net/xmlns/test}payload")
            def handler1(self, stanza):
                return parent.reply_iq_get(stanza)
            @iq_set_stanza_handler(XMLPayload,
                                "{http://pyxmpp.jajcus.net/xmlns/test}payload")
            def handler2(self, stanza):
                return parent.reply_iq_set(stanza)
        self.proc.setup_stanza_handlers([Handlers()], "post-auth")
        self.process_stanzas(ALL_STANZAS)
        self.assertEqual(self.handlers_called, ["reply_iq_get",
                                                    "reply_iq_set"])
        self.assertEqual(len(self.stanzas_sent), 2)
        stanza1 = self.stanzas_sent[0]
        self.assertTrue(xml_elements_equal(stanza1.as_xml(),
                                                    ElementTree.XML(IQ2), True))
        stanza2 = self.stanzas_sent[1]
        self.assertTrue(xml_elements_equal(stanza2.as_xml(),
                                                    ElementTree.XML(IQ4), True))

    def test_no_handlers(self):
        self.process_stanzas(ALL_STANZAS)
        self.assertEqual(self.handlers_called, [])
        self.assertFalse(self.handlers_called)
        self.assertEqual(len(self.stanzas_sent), 2)
        stanza1 = self.stanzas_sent[0]
        self.assertIsInstance(stanza1, Iq)
        self.assertEqual(stanza1.stanza_type, u"error")
        self.assertEqual(stanza1.error.condition_name, u"service-unavailable")
        self.assertEqual(stanza1.stanza_id, u"1")
        self.assertEqual(stanza1.to_jid, JID(u"source@example.com/res"))
        stanza2 = self.stanzas_sent[1]
        self.assertIsInstance(stanza2, Iq)
        self.assertEqual(stanza2.stanza_type, u"error")
        self.assertEqual(stanza2.error.condition_name, u"service-unavailable")
        self.assertEqual(stanza2.stanza_id, u"2")
        self.assertEqual(stanza2.to_jid, JID(u"source@example.com/res"))

    def test_message_handler(self):
        parent = self
        class Handlers(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @message_stanza_handler()
            def handler1(self, stanza):
                return parent.echo_message(stanza)
        self.proc.setup_stanza_handlers([Handlers()], "post-auth")
        self.process_stanzas(NON_IQ_STANZAS)
        self.assertEqual(self.handlers_called, ["echo_message", "echo_message",
                                                        "echo_message"])
        self.assertEqual(len(self.stanzas_sent), 3)
        stanza1 = self.stanzas_sent[0]
        self.assertIsInstance(stanza1, Message)
        self.assertEqual(stanza1.stanza_type, u"normal")
        stanza2 = self.stanzas_sent[1]
        self.assertIsInstance(stanza2, Message)
        self.assertEqual(stanza2.stanza_type, None)
        stanza2 = self.stanzas_sent[2]
        self.assertIsInstance(stanza2, Message)
        self.assertEqual(stanza2.stanza_type, u"chat")

    def test_message_pass1_pass2(self):
        parent = self
        class Handlers1(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @message_stanza_handler()
            def handler1(self, stanza):
                return parent.pass1(stanza)
        class Handlers2(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @message_stanza_handler()
            def handler1(self, stanza):
                return parent.pass2(stanza)
        self.proc.setup_stanza_handlers([Handlers1(), Handlers2()], "post-auth")
        self.process_stanzas(NON_IQ_STANZAS)
        self.assertEqual(self.handlers_called, ["pass1", "pass2",
                                        "pass1", "pass2", "pass1", "pass2"])
        self.assertEqual(len(self.stanzas_sent), 0)

    def test_message_pass2_pass1(self):
        parent = self
        class Handlers1(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @message_stanza_handler()
            def handler1(self, stanza):
                return parent.pass1(stanza)
        class Handlers2(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @message_stanza_handler()
            def handler1(self, stanza):
                return parent.pass2(stanza)
        self.proc.setup_stanza_handlers([Handlers2(), Handlers1()], "post-auth")
        self.process_stanzas(NON_IQ_STANZAS)
        self.assertEqual(self.handlers_called, ["pass2", "pass1",
                                        "pass2", "pass1", "pass2", "pass1"])
        self.assertEqual(len(self.stanzas_sent), 0)


    def test_message_eat1_eat2(self):
        parent = self
        class Handlers1(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @message_stanza_handler()
            def handler1(self, stanza):
                return parent.eat1(stanza)
        class Handlers2(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @message_stanza_handler()
            def handler1(self, stanza):
                return parent.eat2(stanza)
        self.proc.setup_stanza_handlers([Handlers1(), Handlers2()], "post-auth")
        self.process_stanzas(NON_IQ_STANZAS)
        self.assertEqual(self.handlers_called, ["eat1", "eat1", "eat1"])
        self.assertEqual(len(self.stanzas_sent), 0)

    def test_message_pass1_eat2(self):
        parent = self
        class Handlers1(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @message_stanza_handler()
            def handler1(self, stanza):
                return parent.pass1(stanza)
        class Handlers2(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @message_stanza_handler()
            def handler1(self, stanza):
                return parent.eat2(stanza)
        self.proc.setup_stanza_handlers([Handlers1(), Handlers2()], "post-auth")
        self.process_stanzas(NON_IQ_STANZAS)
        self.assertEqual(self.handlers_called, ["pass1", "eat2",
                                        "pass1", "eat2", "pass1", "eat2"])
        self.assertEqual(len(self.stanzas_sent), 0)

    def test_message_chat_handler(self):
        parent = self
        class Handlers(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @message_stanza_handler("chat")
            def handler1(self, stanza):
                return parent.pass1(stanza)
        self.proc.setup_stanza_handlers([Handlers()], "post-auth")
        self.process_stanzas(NON_IQ_STANZAS)
        self.assertEqual(self.handlers_called, ["pass1"])
        self.assertEqual(len(self.stanzas_sent), 0)

    def test_presence_pass1_pass2(self):
        parent = self
        class Handlers1(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @presence_stanza_handler()
            def handler1(self, stanza):
                return parent.pass1(stanza)
        class Handlers2(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @presence_stanza_handler()
            def handler1(self, stanza):
                return parent.pass2(stanza)
        self.proc.setup_stanza_handlers([Handlers1(), Handlers2()], "post-auth")
        self.process_stanzas(NON_IQ_STANZAS)
        self.assertEqual(self.handlers_called, ["pass1", "pass2",
                                                        "pass1", "pass2"])
        self.assertEqual(len(self.stanzas_sent), 0)

    def test_presence_pass2_pass1(self):
        parent = self
        class Handlers1(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @presence_stanza_handler()
            def handler1(self, stanza):
                return parent.pass1(stanza)
        class Handlers2(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @presence_stanza_handler()
            def handler1(self, stanza):
                return parent.pass2(stanza)
        self.proc.setup_stanza_handlers([Handlers2(), Handlers1()], "post-auth")
        self.process_stanzas(NON_IQ_STANZAS)
        self.assertEqual(self.handlers_called, ["pass2", "pass1",
                                                        "pass2", "pass1"])
        self.assertEqual(len(self.stanzas_sent), 0)


    def test_presence_eat1_eat2(self):
        parent = self
        class Handlers1(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @presence_stanza_handler()
            def handler1(self, stanza):
                return parent.eat1(stanza)
        class Handlers2(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @presence_stanza_handler()
            def handler1(self, stanza):
                return parent.eat2(stanza)
        self.proc.setup_stanza_handlers([Handlers1(), Handlers2()], "post-auth")
        self.process_stanzas(NON_IQ_STANZAS)
        self.assertEqual(self.handlers_called, ["eat1", "eat1"])
        self.assertEqual(len(self.stanzas_sent), 0)

    def test_presence_pass1_eat2(self):
        parent = self
        class Handlers1(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @presence_stanza_handler()
            def handler1(self, stanza):
                return parent.pass1(stanza)
        class Handlers2(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @presence_stanza_handler()
            def handler1(self, stanza):
                return parent.eat2(stanza)
        self.proc.setup_stanza_handlers([Handlers1(), Handlers2()], "post-auth")
        self.process_stanzas(NON_IQ_STANZAS)
        self.assertEqual(self.handlers_called, ["pass1", "eat2",
                                                    "pass1", "eat2"])
        self.assertEqual(len(self.stanzas_sent), 0)

    def test_presence_subscribe_handler(self):
        parent = self
        class Handlers(XMPPFeatureHandler):
            # pylint: disable=W0232,R0201,R0903
            @presence_stanza_handler("subscribe")
            def handler1(self, stanza):
                return parent.pass1(stanza)
        self.proc.setup_stanza_handlers([Handlers()], "post-auth")
        self.process_stanzas(NON_IQ_STANZAS)
        self.assertEqual(self.handlers_called, ["pass1"])
        self.assertEqual(len(self.stanzas_sent), 0)

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = streambase
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

import unittest
import re
import logging
import select

from xml.etree.ElementTree import XML

try:
    import glib
except ImportError:
    # pylint: disable=C0103
    glib = None

from pyxmpp2.streambase import StreamBase
from pyxmpp2.streamevents import * # pylint: disable=W0401,W0614
from pyxmpp2.exceptions import StreamParseError
from pyxmpp2.jid import JID
from pyxmpp2.message import Message
from pyxmpp2.settings import XMPPSettings

from pyxmpp2.interfaces import event_handler
from pyxmpp2.interfaces import StanzaRoute

from pyxmpp2.test._util import EventRecorder
from pyxmpp2.test._util import InitiatorSelectTestCase
from pyxmpp2.test._util import InitiatorPollTestMixIn
from pyxmpp2.test._util import InitiatorThreadedTestMixIn
from pyxmpp2.test._util import InitiatorGLibTestMixIn, ReceiverGLibTestMixIn
from pyxmpp2.test._util import ReceiverSelectTestCase
from pyxmpp2.test._util import ReceiverPollTestMixIn, ReceiverThreadedTestMixIn

C2S_SERVER_STREAM_HEAD = (b'<stream:stream version="1.0"'
                            b' from="127.0.0.1"'
                            b' xmlns:stream="http://etherx.jabber.org/streams"'
                            b' xmlns="jabber:client">')
C2S_CLIENT_STREAM_HEAD = (b'<stream:stream version="1.0"'
                            b' to="127.0.0.1"'
                            b' xmlns:stream="http://etherx.jabber.org/streams"'
                            b' xmlns="jabber:client">')

STREAM_TAIL = b'</stream:stream>'

PARSE_ERROR_RESPONSE = (b'<stream:error><not-well-formed'
                    b'  xmlns="urn:ietf:params:xml:ns:xmpp-streams"/>'
                                        b'</stream:error></stream:stream>')

logger = logging.getLogger("pyxmpp2.test.streambase")

class RecordingRoute(StanzaRoute):
    def __init__(self):
        self.received = []
        self.sent = []
    def send(self, stanza):
        self.sent.append(stanza)
    def uplink_receive(self, stanza):
        self.received.append(stanza)

class JustConnectEventHandler(EventRecorder):
    @event_handler(ConnectedEvent)
    def handle_connected_event(self, event):
        # pylint: disable=R0201
        event.stream.close()
        return True

class JustStreamConnectEventHandler(EventRecorder):
    @event_handler(StreamConnectedEvent)
    def handle_stream_conencted_event(self, event):
        # pylint: disable=R0201
        event.stream.disconnect()
        return True

class AuthorizedEventHandler(EventRecorder):
    @event_handler(AuthorizedEvent)
    def handle_authorized_event(self, event):
        # pylint: disable=R0201
        event.stream.close()
        return True

class IgnoreEventHandler(EventRecorder):
    pass

class TestInitiatorSelect(InitiatorSelectTestCase):
    def test_connect_close(self):
        handler = JustConnectEventHandler()
        self.stream = StreamBase(u"jabber:client", None, [])
        self.start_transport([handler])
        self.stream.initiate(self.transport)
        self.connect_transport()
        self.wait()
        self.assertFalse(self.stream.is_connected())
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [ConnectingEvent,
                                            ConnectedEvent, DisconnectedEvent])

    def test_stream_connect_disconnect(self):
        handler = JustStreamConnectEventHandler()
        self.stream = StreamBase(u"jabber:client", None, [])
        self.start_transport([handler])
        self.stream.initiate(self.transport)
        self.connect_transport()
        self.wait_short(0.25)
        self.wait_short(0.25)
        self.assertTrue(self.stream.is_connected())
        self.server.write(C2S_SERVER_STREAM_HEAD)
        self.wait(expect = re.compile(b".*(</stream:stream>)"))
        self.server.write(STREAM_TAIL)
        self.server.disconnect()
        self.wait()
        self.assertFalse(self.stream.is_connected())
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [ConnectingEvent, ConnectedEvent,
                                    StreamConnectedEvent, DisconnectedEvent])

    def test_parse_error(self):
        handler = IgnoreEventHandler()
        self.stream = StreamBase(u"jabber:client", None, [])
        self.start_transport([handler])
        self.stream.initiate(self.transport)
        self.connect_transport()
        self.server.write(C2S_SERVER_STREAM_HEAD)
        self.wait_short()
        self.server.write(b"</stream:test>")
        with self.assertRaises(StreamParseError):
            logger.debug("-- WAIT start")
            self.wait()
            logger.debug("-- WAIT end")
        self.assertFalse(self.stream.is_connected())
        self.wait_short()
        self.server.wait(1)
        self.assertTrue(self.server.eof)
        self.assertTrue(self.server.rdata.endswith(PARSE_ERROR_RESPONSE))
        self.server.disconnect()
        self.wait()
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [ConnectingEvent, ConnectedEvent,
                                    StreamConnectedEvent, DisconnectedEvent])

    def test_stanza_send(self):
        handler = IgnoreEventHandler()
        route = RecordingRoute()
        self.stream = StreamBase(u"jabber:client", route, [])
        self.start_transport([handler])
        self.stream.initiate(self.transport)
        self.connect_transport()
        self.server.write(C2S_SERVER_STREAM_HEAD)
        self.wait_short(0.25)
        self.wait_short(0.25)
        self.assertTrue(self.stream.is_connected())
        self.stream.send(Message(to_jid = JID(u"test@example.org"),
                                                            body = u"Test"))
        xml = self.wait(expect = re.compile(b".*(<message.*</message>)"))
        self.assertIsNotNone(xml)
        if b"xmlns" not in xml:
            xml = xml.replace(b"<message", b"<message xmlns='jabber:client'")
        element = XML(xml)
        stanza = Message(element)
        self.assertEqual(stanza.body, u"Test")
        self.stream.disconnect()
        self.server.write(STREAM_TAIL)
        self.server.disconnect()
        self.wait()
        self.assertEqual(route.sent, [])
        self.assertEqual(route.received, [])
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [ConnectingEvent, ConnectedEvent,
                                    StreamConnectedEvent, DisconnectedEvent])

    def test_stanza_receive(self):
        handler = IgnoreEventHandler()
        route = RecordingRoute()
        self.stream = StreamBase(u"jabber:client", route, [])
        self.start_transport([handler])
        self.stream.initiate(self.transport)
        self.connect_transport()
        logger.debug("-- waiting for connect")
        self.wait_short(0.25)
        self.wait_short(0.25)
        logger.debug("-- checking connected")
        self.assertTrue(self.stream.is_connected())
        self.server.write(C2S_SERVER_STREAM_HEAD)
        self.server.write(b"<message><body>Test</body></message>")
        self.server.write(STREAM_TAIL)
        self.server.disconnect()
        self.wait(expect = re.compile(b".*(</stream:stream>)"))
        self.stream.disconnect()
        self.wait()
        self.assertEqual(route.sent, [])
        self.assertEqual(len(route.received), 1)
        stanza = route.received[0]
        self.assertIsInstance(stanza, Message)
        self.assertEqual(stanza.body, u"Test")
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [ConnectingEvent, ConnectedEvent,
                                    StreamConnectedEvent, DisconnectedEvent])

@unittest.skipIf(not hasattr(select, "poll"), "No poll() support")
class TestInitiatorPoll(InitiatorPollTestMixIn, TestInitiatorSelect):
    pass

@unittest.skipIf(glib is None, "No glib module")
class TestInitiatorGLib(InitiatorGLibTestMixIn, TestInitiatorSelect):
    pass

class TestInitiatorThreaded(InitiatorThreadedTestMixIn, TestInitiatorSelect):
    pass

class TestReceiverSelect(ReceiverSelectTestCase):
    def test_stream_connect_disconnect(self):
        handler = JustStreamConnectEventHandler()
        self.start_transport([handler])
        self.stream = StreamBase(u"jabber:client", None, [])
        self.stream.receive(self.transport, self.addr[0])
        self.client.write(C2S_CLIENT_STREAM_HEAD)
        self.wait_short(0.25)
        self.wait_short(0.25)
        self.client.write(STREAM_TAIL)
        self.wait()
        self.assertFalse(self.stream.is_connected())
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [StreamConnectedEvent,
                                                            DisconnectedEvent])

    def test_parse_error(self):
        handler = IgnoreEventHandler()
        self.start_transport([handler])
        self.stream = StreamBase(u"jabber:client", None, [])
        self.stream.receive(self.transport, self.addr[0])
        self.client.write(C2S_CLIENT_STREAM_HEAD)
        self.wait_short(0.25)
        self.wait_short(0.25)
        self.client.write(b"</stream:test>")
        logger.debug("waiting for exception...")
        with self.assertRaises(StreamParseError):
            self.wait()
        logger.debug(" got it!")
        self.assertFalse(self.stream.is_connected())
        self.wait_short(0.1)
        logger.debug("waiting for connection close...")
        self.client.wait(1)
        logger.debug(" done")
        self.assertTrue(self.client.eof)
        self.assertTrue(self.client.rdata.endswith(PARSE_ERROR_RESPONSE))
        self.client.disconnect()
        logger.debug("final wait...")
        self.wait()
        logger.debug(" done")
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [StreamConnectedEvent,
                                                        DisconnectedEvent])

@unittest.skipIf(not hasattr(select, "poll"), "No poll() support")
class TestReceiverPoll(ReceiverPollTestMixIn, TestReceiverSelect):
    pass

class TestReceiverThreaded(ReceiverThreadedTestMixIn, TestReceiverSelect):
    pass

@unittest.skipIf(glib is None, "No glib module")
class TestReceiverGLib(ReceiverGLibTestMixIn, TestReceiverSelect):
    pass

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = streamsasl
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

import unittest
import re
import base64
import binascii
import os

import pyxmpp2.etree

if "PYXMPP2_ETREE" not in os.environ:
    # one of tests fails when xml.etree.ElementTree is used
    try:
        from xml.etree import cElementTree
        pyxmpp2.etree.ElementTree = cElementTree
    except ImportError:
        pass

from pyxmpp2.etree import ElementTree

from pyxmpp2.streambase import StreamBase
from pyxmpp2.streamsasl import StreamSASLHandler
from pyxmpp2.streamevents import * # pylint: disable=W0614,W0401
from pyxmpp2.exceptions import SASLAuthenticationFailed
from pyxmpp2.settings import XMPPSettings

from pyxmpp2.test._util import EventRecorder
from pyxmpp2.test._util import InitiatorSelectTestCase
from pyxmpp2.test._util import ReceiverSelectTestCase

C2S_SERVER_STREAM_HEAD = (b'<stream:stream version="1.0" from="127.0.0.1"'
                            b' xmlns:stream="http://etherx.jabber.org/streams"'
                            b' xmlns="jabber:client">')
C2S_CLIENT_STREAM_HEAD = (b'<stream:stream version="1.0" to="127.0.0.1"'
                            b' xmlns:stream="http://etherx.jabber.org/streams"'
                            b' xmlns="jabber:client">')

AUTH_FEATURES = b"""<stream:features>
     <mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
        <mechanism>PLAIN</mechanism>
     </mechanisms>
</stream:features>"""

BIND_FEATURES = b"""<stream:features>
     <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>
</stream:features>"""

PLAIN_AUTH = ("<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'"
                                            " mechanism='PLAIN'>{0}</auth>")

STREAM_TAIL = b'</stream:stream>'

PARSE_ERROR_RESPONSE = (b'<stream:error><xml-not-well-formed'
                    b'  xmlns="urn:ietf:params:xml:ns:xmpp-streams"/>'
                                        b'</stream:error></stream:stream>')

TIMEOUT = 1.0 # seconds

class TestInitiator(InitiatorSelectTestCase):
    def test_auth(self):
        handler = EventRecorder()
        settings = XMPPSettings({
                                u"username": u"user",
                                u"password": u"secret",
                                })
        self.stream = StreamBase(u"jabber:client", None,
                            [StreamSASLHandler(settings), handler], settings)
        self.start_transport([handler])
        self.stream.initiate(self.transport)
        self.connect_transport()
        self.server.write(C2S_SERVER_STREAM_HEAD)
        self.server.write(AUTH_FEATURES)
        xml = self.wait(expect = re.compile(br".*(<auth.*</auth>)"))
        self.assertIsNotNone(xml)
        element = ElementTree.XML(xml)
        self.assertEqual(element.tag, "{urn:ietf:params:xml:ns:xmpp-sasl}auth")
        mech = element.get("mechanism")
        self.assertEqual(mech, "PLAIN")
        data = binascii.a2b_base64(element.text.encode("utf-8"))
        self.assertEqual(data, b"\000user\000secret")
        self.server.rdata = b""
        self.server.write(
                        b"<success xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>")
        stream_start = self.wait(expect = re.compile(
                                                br"(<stream:stream[^>]*>)"))
        self.assertIsNotNone(stream_start)
        self.assertTrue(self.stream.authenticated)
        self.server.write(C2S_SERVER_STREAM_HEAD)
        self.server.write(BIND_FEATURES)
        self.server.write(b"</stream:stream>")
        self.server.disconnect()
        self.wait()
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [ConnectingEvent, ConnectedEvent,
                    StreamConnectedEvent, GotFeaturesEvent,
                    AuthenticatedEvent, StreamRestartedEvent, GotFeaturesEvent,
                    DisconnectedEvent])

    def test_auth_fail(self):
        handler = EventRecorder()
        settings = XMPPSettings({
                                u"username": u"user",
                                u"password": u"bad",
                                })
        self.stream = StreamBase(u"jabber:client", None,
                            [StreamSASLHandler(settings), handler], settings)
        self.start_transport([handler])
        self.stream.initiate(self.transport)
        self.connect_transport()
        self.server.write(C2S_SERVER_STREAM_HEAD)
        self.server.write(AUTH_FEATURES)
        xml = self.wait(expect = re.compile(br".*(<auth.*</auth>)"))
        self.assertIsNotNone(xml)
        element = ElementTree.XML(xml)
        self.assertEqual(element.tag, "{urn:ietf:params:xml:ns:xmpp-sasl}auth")
        mech = element.get("mechanism")
        self.assertEqual(mech, "PLAIN")
        data = binascii.a2b_base64(element.text.encode("utf-8"))
        self.assertNotEqual(data, b"\000user\000secret")
        self.server.write(b"""<failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
<not-authorized/></failure>""")
        with self.assertRaises(SASLAuthenticationFailed):
            self.wait()
        self.assertFalse(self.stream.authenticated)
        self.server.disconnect()
        self.wait()
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [ConnectingEvent, ConnectedEvent,
                    StreamConnectedEvent, GotFeaturesEvent, DisconnectedEvent])

class TestReceiver(ReceiverSelectTestCase):
    def test_auth(self):
        handler = EventRecorder()
        self.start_transport([handler])
        settings = XMPPSettings({
                                u"user_passwords": {
                                        u"user": u"secret",
                                    },
                                u"sasl_mechanisms": ["SCRAM-SHA-1", "PLAIN"],
                                })
        self.stream = StreamBase(u"jabber:client", None,
                            [StreamSASLHandler(settings), handler], settings)
        self.stream.receive(self.transport, self.addr[0])
        self.client.write(C2S_CLIENT_STREAM_HEAD)
        xml = self.wait(expect = re.compile(
                                br".*<stream:features>(.*)</stream:features>"))
        self.assertIsNotNone(xml)
        element = ElementTree.XML(xml)
        self.assertEqual(element.tag,
                                "{urn:ietf:params:xml:ns:xmpp-sasl}mechanisms")
        self.assertEqual(element[0].tag,
                                "{urn:ietf:params:xml:ns:xmpp-sasl}mechanism")
        self.assertEqual(element[0].text, "SCRAM-SHA-1")
        self.assertEqual(element[1].tag,
                                "{urn:ietf:params:xml:ns:xmpp-sasl}mechanism")
        self.assertEqual(element[1].text, "PLAIN")
        response = base64.standard_b64encode(b"\000user\000secret")
        self.client.write(PLAIN_AUTH.format(response.decode("utf-8"))
                                                    .encode("utf-8"))
        xml = self.wait(expect = re.compile(br".*(<success.*>)"))
        self.assertIsNotNone(xml)
        self.client.write(C2S_CLIENT_STREAM_HEAD)
        xml = self.wait(expect = re.compile(br".*(<stream:stream.*>)"))
        self.assertIsNotNone(xml)
        self.assertTrue(self.stream.peer_authenticated)
        self.client.write(b"</stream:stream>")
        self.client.disconnect()
        self.wait()
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [
                                StreamConnectedEvent, AuthenticatedEvent,
                                StreamRestartedEvent, DisconnectedEvent])

    def test_auth_fail(self):
        handler = EventRecorder()
        self.start_transport([handler])
        settings = XMPPSettings({
                                u"user_passwords": {
                                        u"user": u"secret",
                                    },
                                u"sasl_mechanisms": ["SCRAM-SHA-1", "PLAIN"],
                                })
        self.stream = StreamBase(u"jabber:client", None,
                            [StreamSASLHandler(settings), handler], settings)
        self.stream.receive(self.transport, self.addr[0])
        self.client.write(C2S_CLIENT_STREAM_HEAD)
        xml = self.wait(expect = re.compile(
                                br".*<stream:features>(.*)</stream:features>"))
        self.assertIsNotNone(xml)
        element = ElementTree.XML(xml)
        self.assertEqual(element.tag,
                                "{urn:ietf:params:xml:ns:xmpp-sasl}mechanisms")
        self.assertEqual(element[0].tag,
                                "{urn:ietf:params:xml:ns:xmpp-sasl}mechanism")
        self.assertEqual(element[0].text, "SCRAM-SHA-1")
        self.assertEqual(element[1].tag,
                                "{urn:ietf:params:xml:ns:xmpp-sasl}mechanism")
        self.assertEqual(element[1].text, "PLAIN")
        response = base64.standard_b64encode(b"\000user\000bad")
        self.client.write(PLAIN_AUTH.format(response.decode("us-ascii"))
                                                            .encode("utf-8"))
        with self.assertRaises(SASLAuthenticationFailed):
            self.wait()
        self.client.write(b"</stream:stream>")
        self.client.disconnect()
        self.wait()
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [StreamConnectedEvent,
                                                            DisconnectedEvent])

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = streamtls
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

import unittest
import re
import os

from pyxmpp2.test._support import DATA_DIR

from xml.etree.ElementTree import XML

from pyxmpp2.streambase import StreamBase
from pyxmpp2.streamtls import StreamTLSHandler
from pyxmpp2.streamevents import *  # pylint: disable=W0614,W0401
from pyxmpp2.exceptions import TLSNegotiationFailed
from pyxmpp2.settings import XMPPSettings

from pyxmpp2.test._util import EventRecorder, InitiatorSelectTestCase

C2S_SERVER_STREAM_HEAD = (b'<stream:stream version="1.0"'
                            b' from="server.example.org"'
                            b' xmlns:stream="http://etherx.jabber.org/streams"'
                            b' xmlns="jabber:client">')
C2S_CLIENT_STREAM_HEAD = (b'<stream:stream version="1.0"'
                            b' to="server.example.org"'
                            b' xmlns:stream="http://etherx.jabber.org/streams"'
                            b' xmlns="jabber:client">')

TLS_FEATURES = b"""<stream:features>
     <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls' />
</stream:features>"""
TLS_REQUIRED_FEATURES = b"""<stream:features>
     <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'>
        <required />
     </starttls>
</stream:features>"""


EMPTY_FEATURES = b"""<stream:features/>"""

PROCEED = b"<proceed xmlns='urn:ietf:params:xml:ns:xmpp-tls' />"

STREAM_TAIL = b'</stream:stream>'

class TestInitiator(InitiatorSelectTestCase):
    def test_enabled_optional(self):
        """Test TLS enabled in settings, and optional on the server."""
        settings = XMPPSettings({
                        u"starttls": True,
                        u"tls_cacert_file": os.path.join(DATA_DIR, "ca.pem"),
                                })
        handler = EventRecorder()
        handlers = [StreamTLSHandler(settings), handler]
        self.stream = StreamBase(u"jabber:client", None, handlers, settings)
        self.start_transport(handlers)
        self.stream.initiate(self.transport, to = "server.example.org")
        self.connect_transport()
        self.server.write(C2S_SERVER_STREAM_HEAD)
        self.server.write(TLS_FEATURES)
        xml = self.wait(2, expect = re.compile(br".*(<starttls.*/>)"))
        self.assertIsNotNone(xml)
        element = XML(xml)
        self.assertEqual(element.tag,
                                "{urn:ietf:params:xml:ns:xmpp-tls}starttls")
        self.server.write(PROCEED)
        self.server.starttls(self.server.sock,
                            keyfile = os.path.join(DATA_DIR, "server-key.pem"),
                            certfile = os.path.join(DATA_DIR, "server.pem"),
                            server_side = True,
                            ca_certs = os.path.join(DATA_DIR, "ca.pem"),
                                )
        stream_start = self.wait(expect = re.compile(
                                    br"(<stream:stream[^>]*>)"))
        self.assertIsNotNone(stream_start)
        self.assertTrue(self.stream.tls_established)
        self.stream.disconnect()
        self.server.write(C2S_SERVER_STREAM_HEAD)
        self.server.write(EMPTY_FEATURES)
        self.server.write(b"</stream:stream>")
        self.wait()
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [ConnectingEvent,
                    ConnectedEvent, StreamConnectedEvent, GotFeaturesEvent,
                    TLSConnectingEvent, TLSConnectedEvent, StreamRestartedEvent,
                    GotFeaturesEvent, DisconnectedEvent])

    def test_enabled_required(self):
        """Test TLS enabled in settings, and required on the server."""
        self.start_server()
        settings = XMPPSettings({
                        u"starttls": True,
                        u"tls_cacert_file": os.path.join(DATA_DIR, "ca.pem"),
                                })
        handler = EventRecorder()
        handlers = [StreamTLSHandler(settings), handler]
        self.stream = StreamBase(u"jabber:client", None, handlers, settings)
        self.start_transport(handlers)
        self.stream.initiate(self.transport, to = "server.example.org")
        self.connect_transport()
        self.server.write(C2S_SERVER_STREAM_HEAD)
        self.server.write(TLS_REQUIRED_FEATURES)
        xml = self.wait(expect = re.compile(br".*(<starttls.*/>)"))
        self.assertIsNotNone(xml)
        element = XML(xml)
        self.assertEqual(element.tag,
                                "{urn:ietf:params:xml:ns:xmpp-tls}starttls")
        self.server.write(PROCEED)
        self.server.starttls(self.server.sock,
                            keyfile = os.path.join(DATA_DIR, "server-key.pem"),
                            certfile = os.path.join(DATA_DIR, "server.pem"),
                            server_side = True,
                            ca_certs = os.path.join(DATA_DIR, "ca.pem"),
                                )
        stream_start = self.wait(expect = re.compile(
                                                    br"(<stream:stream[^>]*>)"))
        self.assertIsNotNone(stream_start)
        self.assertTrue(self.stream.tls_established)
        self.stream.disconnect()
        self.server.write(C2S_SERVER_STREAM_HEAD)
        self.server.write(EMPTY_FEATURES)
        self.server.write(b"</stream:stream>")
        self.wait()
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [ConnectingEvent,
                    ConnectedEvent, StreamConnectedEvent, GotFeaturesEvent,
                    TLSConnectingEvent, TLSConnectedEvent, StreamRestartedEvent,
                    GotFeaturesEvent, DisconnectedEvent])

    def test_enabled_missing(self):
        """Test TLS enabled in settings, and missing on the server."""
        self.start_server()
        settings = XMPPSettings({
                        u"starttls": True,
                        u"tls_cacert_file": os.path.join(DATA_DIR, "ca.pem"),
                                })
        handler = EventRecorder()
        handlers = [StreamTLSHandler(settings), handler]
        self.stream = StreamBase(u"jabber:client", None, handlers, settings)
        self.start_transport(handlers)
        self.stream.initiate(self.transport, to = "server.example.org")
        self.connect_transport()
        self.server.write(C2S_SERVER_STREAM_HEAD)
        self.server.write(EMPTY_FEATURES)
        self.server.write(b"</stream:stream>")
        self.wait(expect = re.compile(br".*(</stream:stream>)"))
        self.assertFalse(self.stream.tls_established)
        self.stream.disconnect()
        self.server.disconnect()
        self.wait()
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [ConnectingEvent,
                    ConnectedEvent, StreamConnectedEvent, GotFeaturesEvent,
                    DisconnectedEvent])

    def test_required_missing(self):
        """Test TLS required in settings, and missing on the server."""
        self.start_server()
        settings = XMPPSettings({
                        u"starttls": True,
                        u"tls_require": True,
                        u"tls_cacert_file": os.path.join(DATA_DIR, "ca.pem"),
                                })
        handler = EventRecorder()
        handlers = [StreamTLSHandler(settings), handler]
        self.stream = StreamBase(u"jabber:client", None, handlers, settings)
        self.start_transport(handlers)
        self.stream.initiate(self.transport, to = "server.example.org")
        self.connect_transport()
        self.server.write(C2S_SERVER_STREAM_HEAD)
        self.server.write(EMPTY_FEATURES)
        self.server.write(b"</stream:stream>")
        with self.assertRaises(TLSNegotiationFailed):
            self.wait()
        self.server.disconnect()
        self.wait()
        event_classes = [e.__class__ for e in handler.events_received]
        self.assertEqual(event_classes, [ConnectingEvent,
                    ConnectedEvent, StreamConnectedEvent, GotFeaturesEvent,
                    DisconnectedEvent])


# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = stream_reader
#!/usr/bin/python -u
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

import os
import logging

from pyxmpp2.test._support import DATA_DIR

logger = logging.getLogger("pyxmpp2.test.stream_reader")

import unittest
from xml.etree import ElementTree

from pyxmpp2 import xmppparser

from pyxmpp2.utils import xml_elements_equal

class EventTemplate:
    # pylint: disable=R0903
    def __init__(self, template):
        self.event, offset, xml = template.split(None, 2)
        self.offset = int(offset)
        self.xml = ElementTree.XML(eval(xml))

    def match(self, event, node):
        if self.event != event:
            return False
        if event == "end":
            return True
        if not xml_elements_equal(self.xml, node):
            return False
        return True

    def __repr__(self):
        return "<EventTemplate %r at %r: %r>" % (self.event, self.offset,
                                                    ElementTree.dump(self.xml))

class StreamHandler(xmppparser.XMLStreamHandler):
    def __init__(self, test_case):
        xmppparser.XMLStreamHandler.__init__(self)
        self.test_case = test_case
    def stream_start(self, element):
        self.test_case.event("start", element)
    def stream_end(self):
        self.test_case.event("end", None)
    def stream_element(self, element):
        self.test_case.event("node", element)

# pylint: disable=C0103
expected_events = []
# pylint: disable=C0103
whole_stream = None

def load_expected_events():
    with open(os.path.join(DATA_DIR, "stream_info.txt")) as stream_info:
        for line in stream_info:
            if line.startswith("#"):
                continue
            line = line.strip()
            expected_events.append(EventTemplate(line))

def load_whole_stream():
    # pylint: disable=W0603
    global whole_stream
    whole_stream = ElementTree.parse(os.path.join(DATA_DIR, "stream.xml"))

class TestStreamReader(unittest.TestCase):
    def setUp(self):
        self.expected_events = list(expected_events)
        self.handler = StreamHandler(self)
        self.reader = xmppparser.StreamReader(self.handler)
        self.file = open(os.path.join(DATA_DIR, "stream.xml"))
        self.chunk_start = 0
        self.chunk_end = 0
        self.whole_stream = ElementTree.ElementTree()

    def tearDown(self):
        del self.handler
        del self.reader
        del self.whole_stream

    def test_1(self):
        self.do_test(1)

    def test_2(self):
        self.do_test(2)

    def test_10(self):
        self.do_test(10)

    def test_100(self):
        self.do_test(100)

    def test_1000(self):
        self.do_test(1000)

    def do_test(self, chunk_length):
        while 1:
            data = self.file.read(chunk_length)
            if not data:
                self.reader.feed('')
                break
            self.chunk_end += len(data)
            self.reader.feed(data)
            if not data:
                self.event("end", None)
                break
            self.chunk_start = self.chunk_end
        root1 = self.whole_stream.getroot()
        self.assertIsNotNone(root1)
        root2 = whole_stream.getroot()
        if not xml_elements_equal(root1, root2, True):
            self.fail("Whole stream invalid. Got: %r, Expected: %r"
                                    % (ElementTree.tostring(root1),
                                                ElementTree.tostring(root2)))

    def event(self, event, element):
        logger.debug(" event: {0!r} element: {1!r}".format(event, element))
        expected = self.expected_events.pop(0)
        self.assertTrue(event==expected.event, "Got %r, expected %r" %
                                                    (event, expected.event))
        if expected.offset < self.chunk_start:
            self.fail("Delayed event: %r. Expected at: %i, found at %i:%i"
                    % (event, expected.offset, self.chunk_start,
                                                            self.chunk_end))
        if expected.offset > self.chunk_end:
            self.fail("Early event: %r. Expected at: %i, found at %i:%i"
                    % (event, expected.offset, self.chunk_start,
                                                            self.chunk_end))
        if not expected.match(event, element):
            self.fail("Unmatched event. Expected: %r, got: %r;%r"
                    % (expected, event, ElementTree.dump(element)))
        if event == "start":
            # pylint: disable=W0212
            self.whole_stream._setroot(element)
        elif event == "node":
            root = self.whole_stream.getroot()
            root.append(element)

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    load_expected_events()
    load_whole_stream()
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = xmppserializer
#!/usr/bin/python -u
# -*- coding: UTF-8 -*-
# pylint: disable=C0111

import unittest
from xml.etree import ElementTree

from pyxmpp2.xmppserializer import XMPPSerializer

from pyxmpp2.utils import xml_elements_equal

class TestXMPPSerializer(unittest.TestCase):
    def test_emit_head(self):
        serializer = XMPPSerializer("jabber:client")
        output = serializer.emit_head("fromX", "toY")
        self.assertTrue(output.startswith("<stream:stream "))
        self.assertTrue("xmlns='jabber:client'" in output
                            or 'xmlns="jabber:client"' in output)
        self.assertFalse("xmlns:xml" in output)
        xml = ElementTree.XML(output + "</stream:stream>")
        self.assertEqual(xml.tag,
                                "{http://etherx.jabber.org/streams}stream")
        self.assertEqual(xml.get('from'), 'fromX')
        self.assertEqual(xml.get('to'), 'toY')
        self.assertEqual(xml.get('version'), '1.0')
        self.assertEqual(len(xml), 0)

    def test_emit_head_no_from_to(self):
        serializer = XMPPSerializer("jabber:client")
        output = serializer.emit_head(None, None)
        xml = ElementTree.XML(output + "</stream:stream>")
        self.assertEqual(xml.get('from'), None)
        self.assertEqual(xml.get('to'), None)

    def test_emit_tail(self):
        serializer = XMPPSerializer("jabber:client")
        output = serializer.emit_head("fromX", "toY")
        output += serializer.emit_tail()
        xml = ElementTree.XML(output)
        self.assertEqual(len(xml), 0)

    def test_emit_stanza(self):
        serializer = XMPPSerializer("jabber:client")
        output = serializer.emit_head("from", "to")

        stanza = ElementTree.XML("<message xmlns='jabber:client'>"
                                    "<body>Body</body>"
                                    "<sub xmlns='http://example.org/ns'>"
                                        "<sub1 />"
                                    "<sub2 xmlns='http://example.org/ns2' />"
                                "</sub>"
                            "</message>")
        output += serializer.emit_stanza(stanza)
        output += serializer.emit_tail()
        xml = ElementTree.XML(output)
        self.assertEqual(len(xml), 1)
        self.assertEqual(len(xml[0]), 2)
        self.assertTrue(xml_elements_equal(xml[0], stanza))

        # no prefix for stanza elements
        self.assertTrue("<message><body>" in output)

        # no prefix for stanza child
        self.assertTrue("<sub " in output)

        # ...and its same-namespace child
        self.assertTrue("<sub1/" in output or "<sub1 " in output)

        # prefix for other namespace child
        self.assertTrue("<sub2" in output)

# pylint: disable=W0611
from pyxmpp2.test._support import load_tests, setup_logging

def setUpModule():
    setup_logging()

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = _support
"""Support functions for pyxmpp2 test suite."""

import os
import sys
import logging
import unittest

TEST_DIR = os.path.dirname(__file__)
DATA_DIR = os.path.join(TEST_DIR, "data")

RESOURCES = ['network', 'lo-network', 'gsasl']

if "TEST_USE" in os.environ:
    RESOURCES = os.environ["TEST_USE"].split()

if "TEST_STACKDUMP_FILE" in os.environ:
    import traceback
    import threading
    import time
    def stack_dumper():
        stackdump_file = open(os.environ.get("TEST_STACKDUMP_FILE"), "w")
        while True:
            time.sleep(5)
            stackdump_file.write(time.ctime() + "\n")
            frames = sys._current_frames()
            for frame in frames.values():
                traceback.print_stack(frame, file = stackdump_file)
            stackdump_file.write("\n")
            stackdump_file.flush()
    thr = threading.Thread(target = stack_dumper)
    thr.daemon = True
    thr.start()

# pylint: disable=W0602,C0103
logging_ready = False
def setup_logging():
    """Set up logging for the tests.

    Log level used depends on number of '-v' in sys.argv
    """
    # pylint: disable=W0603
    global logging_ready
    if logging_ready:
        return
    if sys.argv.count("-v") > 2:
        logging.basicConfig(level=logging.DEBUG)
    elif sys.argv.count("-v") == 2:
        logging.basicConfig(level=logging.INFO)
    else:
        logging.basicConfig(level=logging.ERROR)
    logging_ready = True

def filter_tests(suite):
    """Make a new TestSuite from `suite`, removing test classes
    with names starting with '_'."""
    result = unittest.TestSuite()
    for test in suite:
        if isinstance(test, unittest.TestSuite):
            result.addTest(filter_tests(test))
        elif not test.__class__.__name__.startswith("_"):
            result.addTest(test)
    return result

def load_tests(loader, tests, pattern):
    """Use default test list, just remove the classes which names start with
    '_'."""
    # pylint: disable=W0613
    suite = filter_tests(tests)
    return suite


########NEW FILE########
__FILENAME__ = _util
#!/usr/bin/python

"""Utilities for pyxmmp2 unit tests."""

import time
import unittest
import socket
import threading
import select
import logging
import ssl
import errno

from pyxmpp2.test import _support

from pyxmpp2.streamevents import DisconnectedEvent

from pyxmpp2.transport import TCPTransport
from pyxmpp2.mainloop.interfaces import EventHandler, event_handler, QUIT
from pyxmpp2.mainloop.select import SelectMainLoop
from pyxmpp2.mainloop.poll import PollMainLoop
from pyxmpp2.mainloop.threads import ThreadPool
from pyxmpp2.settings import XMPPSettings

logger = logging.getLogger("pyxmpp2.test._util")

socket.setdefaulttimeout(5)

TIMEOUT = 60.0 # seconds

class NetReaderWritter(object):
    """Threaded network reader/writter.

    :Ivariables:
        - `sock`: the socket
        - `wdata`: data to be sent
        - `rdata`: data received
        - `eof`: EOF flag
        - `error`: error flag
        - `peer`: address of the peer connected
    """
    # pylint: disable=R0902
    def __init__(self, sock, need_accept = False):
        self.sock = sock
        self.wdata = b""
        self.rdata = b""
        self.eof = False
        self.ready = not need_accept
        self._disconnect = False
        self.write_enabled = True
        self.lock = threading.RLock()
        self.write_cond = threading.Condition(self.lock)
        self.eof_cond = threading.Condition(self.lock)
        self.extra_on_read = None
        self.peer = None

    def start(self):
        """Start the reader and writter threads."""
        reader_thread = threading.Thread(target = self.reader_run,
                                                            name = "Reader")
        reader_thread.daemon = True
        writter_thread = threading.Thread(target = self.writter_run,
                                                            name = "Writter")
        writter_thread.daemon = True
        reader_thread.start()
        writter_thread.start()

    def _do_tls_handshake(self):
        """Do the TLS handshake. Called from the reader thread
        after `starttls` is called."""
        logger.debug("tst: starting tls handshake")
        while True:
            try:
                self.sock.do_handshake()
                break
            except ssl.SSLError, err:
                if err.args[0] == ssl.SSL_ERROR_WANT_READ:
                    select.select([self.sock], [], [])
                elif err.args[0] == ssl.SSL_ERROR_WANT_WRITE:
                    select.select([], [self.sock], [])
                else:
                    raise
        logger.debug("tst: tls handshake started, resuming normal write")
        self.extra_on_read = None
        self.write_enabled = True
        self.write_cond.notify()

    def starttls(self, *args, **kwargs):
        """Request switching to TLS.

        First waits untill all currently buffered data is sent.

        :Parameters:
            - `args`: positional arguments to :std:`ssl.wrap_socket`
            - `kwargs`: keyword arguments to :std:`ssl.wrap_socket`
        """
        kwargs['do_handshake_on_connect'] = False
        with self.lock:
            # flush write buffer
            logger.debug("tst: flushing write buffer before tls wrap")
            while self.wdata:
                self.write_cond.wait()
            self.write_enabled = False
            self.write_cond.notify()
            logger.debug("tst: wrapping the socket")
            self.sock = ssl.wrap_socket(*args, **kwargs)
            self.extra_on_read = self._do_tls_handshake
            self.rdata = b""

    def writter_run(self):
        """The writter thread function."""
        with self.write_cond:
            while self.sock is not None:
                while self.ready and self.wdata and self.write_enabled:
                    sent = self.sock.send(self.wdata)
                    logger.debug(u"tst OUT: " + repr(self.wdata[:sent]))
                    self.wdata = self.wdata[sent:]
                    self.write_cond.notify()
                if self._disconnect and not self.wdata:
                    self.sock.shutdown(socket.SHUT_WR)
                    logger.debug(u"tst OUT: EOF")
                    break
                self.write_cond.wait()

    def reader_run(self):
        """The reader thread function."""
        WSAEBADF = getattr(errno, "WSAEBADF", None)
        with self.lock:
            if not self.sock or self.eof:
                return
            while not self.eof and self.sock is not None:
                self.lock.release()
                try:
                    ret = infd, _outfd, _errfd = select.select([self.sock], [],
                                                                        [], 5)
                except select.error, err:
                    if WSAEBADF and err == WSAEBADF:
                        self.sock = None
                        break
                    raise
                finally:
                    self.lock.acquire()
                if not self.sock:
                    break
                if infd:
                    if self.extra_on_read:
                        self.extra_on_read()
                    elif self.ready:
                        data = self.sock.recv(1024)
                        if not data:
                            logger.debug(u"tst IN: EOF")
                            self.eof = True
                            self.eof_cond.notifyAll()
                        else:
                            logger.debug(u"tst IN: " + repr(data))
                            self.rdata += data
                    else:
                        sock1, self.peer = self.sock.accept()
                        logger.debug(u"tst ACCEPT: " + repr(self.peer))
                        self.sock.close()
                        self.sock = sock1
                        self.ready = True
                        self.write_cond.notify()

    def write(self, data):
        """Queue data for write."""
        with self.write_cond:
            self.wdata += data
            if self.ready:
                self.write_cond.notify()

    def disconnect(self):
        """Request disconnection."""
        with self.write_cond:
            self._disconnect = True
            self.write_cond.notify()

    def read(self):
        """Read data from input buffer (received by the reader thread)."""
        with self.lock:
            data, self.rdata = self.rdata, ""
        return data

    def close(self):
        """Close the socket and request the threads to stop."""
        with self.lock:
            if self.sock is not None:
                self.sock.close()
            self.sock = None
            self.wdata = None
            self.write_cond.notify()
            self.eof_cond.wait(0.1)

    def wait(self, timeout):
        """Wait for socket closing, an error or `timeout` seconds."""
        with self.eof_cond:
            if not self.eof:
                self.eof_cond.wait(timeout)

class NetworkTestCase(unittest.TestCase):
    """Base class for networking test cases.

    :Variables:
        - `can_do_ipv4`: `True` if IPv4 sockets are available
        - `can_do_ipv6`: `True` if IPv6 sockets are available

    :Ivariables:
        - `server`: a server for testing client connections (created by
          `start_server`)
        - `client`: a client for testing server connections (created by
          `start_client`)
    :Types:
        - `server`: `NetReaderWritter`
        - `client`: `NetReaderWritter`
    """
    can_do_ipv4 = False
    can_do_ipv6 = False
    @classmethod
    def setUpClass(cls):
        """Check if loopback networking is enabled and IPv4 and IPv6 sockets
        available."""
        if "lo-network" not in _support.RESOURCES:
            raise unittest.SkipTest("loopback network usage disabled")
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.close()
            cls.can_do_ipv4 = True
        except socket.error, err:
            logger.debug("socket error: {0} while testing IPv4".format(err))
            pass
        if socket.has_ipv6:
            try:
                sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
                sock.close()
                cls.can_do_ipv6 = True
            except socket.error, err:
                logger.debug("socket error: {0} while testing IPv6".format(err))
                pass

    def setUp(self):
        """Initialize class instance for a new test."""
        self.server = None
        self.client = None
        # pylint: disable=W0212
        # reset the event queue
        XMPPSettings._defs['event_queue'].default = None

    def tearDown(self):
        """Stop the server and client connections started."""
        if self.server:
            self.server.close()
        if self.client:
            self.client.close()
        # pylint: disable=W0212
        # reset the event queue
        XMPPSettings._defs['event_queue'].default = None

    def start_server(self, ip_version = 4):
        """Create the `server` object, start its thread and return
        assigned socket address (IP address, port)."""
        sock = self.make_listening_socket(ip_version)
        self.server = NetReaderWritter(sock, need_accept = True)
        self.server.start()
        return sock.getsockname()

    def make_listening_socket(self, ip_version = 4):
        """Create a listening socket on a random (OS-assigned) port
        on the loopback interface."""
        if ip_version == 4:
            if not self.can_do_ipv4:
                self.skipTest("Networking not available")
                return None
            family = socket.AF_INET
            addr = "127.0.0.1"
        elif ip_version == 6:
            if not self.can_do_ipv6:
                self.skipTest("IPv6 networking not available")
                return None
            family = socket.AF_INET6
            addr = "::1"
        else:
            raise ValueError, "Bad IP version"
        sock = socket.socket(family, socket.SOCK_STREAM)
        sock.bind((addr, 0))
        sock.listen(1)
        return sock

    def start_client(self, sockaddr, ip_version = 4):
        """Create the `client` object, starts its threads anc
        connect it to the provided `sockaddr`.

        :Return: its socket address"""
        if ip_version == 4:
            if not self.can_do_ipv4:
                self.skipTest("Networking not available")
                return None
            family = socket.AF_INET
        elif ip_version == 6:
            if not self.can_do_ipv6:
                self.skipTest("IPv6 networking not available")
                return None
            family = socket.AF_INET6
        else:
            raise ValueError, "Bad IP version"
        sock = socket.socket(family, socket.SOCK_STREAM)
        sock.connect(sockaddr)
        self.client = NetReaderWritter(sock)
        self.client.start()
        return sock.getsockname()

class InitiatorSelectTestCase(NetworkTestCase):
    """Base class for XMPP initiator streams tests, using the
    `SelectMainLoop`.

    :Ivariables:
        - `stream`: The stream tested (to be created by a test method)
        - `transport`: TCPTransport used by the stream
        - `loop`: the main loop
    :Types:
        - `transport`: `TCPTransport`
        - `loop`: `MainLoop`
    """
    def setUp(self):
        super(InitiatorSelectTestCase, self).setUp()
        self.stream = None
        self.transport = None
        self.loop = None

    def start_transport(self, handlers):
        """Initialize a transport and a main loop with the provided handlers"""
        self.transport = TCPTransport()
        self.make_loop(handlers + [self.transport])

    def connect_transport(self):
        """Start a test server and connect the transport to it."""
        addr, port = self.start_server()
        self.transport.connect(addr, port)

    def make_loop(self, handlers):
        """Return a main loop object for use with this test suite."""
        self.loop = SelectMainLoop(None, handlers)

    def tearDown(self):
        super(InitiatorSelectTestCase, self).tearDown()
        self.loop = None
        self.stream = None
        if self.transport:
            self.transport.close()
        self.transport = None

    def wait(self, timeout = TIMEOUT, expect = None):
        """Wait until the main loop finishes, `timeout` seconds passes
        or current server input matches `expect`."""
        timeout = time.time() + timeout
        while not self.loop.finished:
            self.loop.loop_iteration(0.1)
            if expect:
                match = expect.match(self.server.rdata)
                if match:
                    return match.group(1)
            if time.time() > timeout:
                break

    def wait_short(self, timeout = 0.1):
        """Run a single main loop iteration."""
        self.loop.loop_iteration(timeout)

class InitiatorPollTestMixIn(object):
    """Base class for XMPP initiator streams tests, using the
    `PollMainLoop`"""
    # pylint: disable=R0903
    def make_loop(self, handlers):
        """Return a main loop object for use with this test suite."""
        # pylint: disable=W0201
        self.loop = PollMainLoop(None, handlers)

class InitiatorGLibTestMixIn(object):
    """Base class for XMPP initiator streams tests, using the
    `GLibMainLoop`"""
    # pylint: disable=R0903
    def make_loop(self, handlers):
        """Return a main loop object for use with this test suite."""
        # pylint: disable=W0201,W0404
        from pyxmpp2.mainloop.glib import GLibMainLoop
        self.loop = GLibMainLoop(None, handlers)

class InitiatorThreadedTestMixIn(object):
    """Base class for XMPP initiator streams tests, using the
    `ThreadPool` instead of an asynchronous event loop."""
    def make_loop(self, handlers):
        """Return a main loop object for use with this test suite."""
        # pylint: disable=W0201
        self.loop = ThreadPool(XMPPSettings({"upoll_interval": 0.1}), handlers)

    def connect_transport(self):
        """Start a test server and connect the transport to it."""
        InitiatorSelectTestCase.connect_transport(self)
        self.loop.start()

    def tearDown(self):
        """Tear down the test case object."""
        if self.loop:
            logger.debug("Stopping the thread pool")
            try:
                self.loop.stop(True, 2)
            except Exception: # pylint: disable=W0703
                logger.exception("self.loop.stop failed:")
            else:
                logger.debug("  done (or timed out)")
            self.loop.event_dispatcher.flush(False)
        super(InitiatorThreadedTestMixIn, self).tearDown()

class ReceiverSelectTestCase(NetworkTestCase):
    """Base class for XMPP receiver streams tests, using the
    `SelectMainLoop`"""
    def setUp(self):
        super(ReceiverSelectTestCase, self).setUp()
        self.stream = None
        self.transport = None
        self.loop = None
        self.addr = None

    def start_transport(self, handlers):
        """Create a listening socket for the tested stream,
        a transport a main loop and create a client connectiong to the
        socket."""
        sock = self.make_listening_socket()
        self.addr = sock.getsockname()
        self.start_client(self.addr)
        self.transport = TCPTransport(sock = sock.accept()[0])
        sock.close()
        self.make_loop(handlers + [self.transport])

    def make_loop(self, handlers):
        """Create the main loop object."""
        self.loop = SelectMainLoop(None, handlers)

    def wait(self, timeout = TIMEOUT, expect = None):
        """Wait until the main loop finishes, `timeout` seconds passes
        or current server input matches `expect`."""
        timeout = time.time() + timeout
        while not self.loop.finished:
            self.loop.loop_iteration(0.1)
            if expect:
                match = expect.match(self.client.rdata)
                if match:
                    return match.group(1)
            if time.time() > timeout:
                break

    def wait_short(self, timeout = 0.1):
        """Run a single main loop iteration."""
        self.loop.loop_iteration(timeout)

    def tearDown(self):
        self.loop = None
        self.stream = None
        if self.transport:
            self.transport.close()
        self.transport = None
        super(ReceiverSelectTestCase, self).tearDown()

class ReceiverPollTestMixIn(object):
    """Base class for XMPP receiver streams tests, using the
    `PollMainLoop`"""
    # pylint: disable=R0903
    def make_loop(self, handlers):
        """Return a main loop object for use with this test suite."""
        # pylint: disable=W0201
        self.loop = PollMainLoop(None, handlers)

class ReceiverGLibTestMixIn(object):
    """Base class for XMPP receiver streams tests, using the
    `GLibMainLoop`"""
    # pylint: disable=R0903
    def make_loop(self, handlers):
        """Return a main loop object for use with this test suite."""
        # pylint: disable=W0201,W0404
        from pyxmpp2.mainloop.glib import GLibMainLoop
        self.loop = GLibMainLoop(None, handlers)

class ReceiverThreadedTestMixIn(object):
    """Base class for XMPP receiver streams tests, using the
    `ThreadPool`"""
    def make_loop(self, handlers):
        """Return a main loop object for use with this test suite."""
        # pylint: disable=W0201
        self.loop = ThreadPool(XMPPSettings({"upoll_interval": 0.1}), handlers)

    def start_transport(self, handlers):
        """Create a listening socket for the tested stream,
        a transport a main loop and create a client connectiong to the
        socket."""
        super(ReceiverThreadedTestMixIn, self).start_transport(handlers)
        self.loop.start()

    def tearDown(self):
        """Tear down the test case object."""
        if self.loop:
            logger.debug("Stopping the thread pool")
            try:
                self.loop.stop(True, 2)
            except Exception: # pylint: disable=W0703
                logger.exception("self.loop.stop failed:")
            else:
                logger.debug("  done (or timed out)")
            self.loop.event_dispatcher.flush(False)
        super(ReceiverThreadedTestMixIn, self).tearDown()

class EventRecorder(EventHandler):
    """An event handler which records all events received and aborts the main
    loop on the `DisconnectedEvent`.

    :Ivariables:
        - `events_received`: events received
    :Types:
        - `events_received`: `list` of `Event`
    """
    def __init__(self):
        self.events_received = []
    @event_handler()
    def handle_event(self, event):
        """Handle any event: store it in `events_received`."""
        self.events_received.append(event)
        return False
    @event_handler(DisconnectedEvent)
    def handle_disconnected_event(self, event):
        """Handle the `DisconnectedEvent`: abort the main loop."""
        # pylint: disable=R0201
        event.stream.event(QUIT)


########NEW FILE########
__FILENAME__ = __main__
"""Startup script for the whole pyxmpp test suite."""

import unittest
import pyxmpp2.test

def load_tests(loader, standard_tests, pattern):
    """Load all tests discovered in pyxmpp2.test."""
    # pylint: disable=W0613
    return pyxmpp2.test.discover()

unittest.main()

########NEW FILE########
__FILENAME__ = transport
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""XMPP transport.

This module provides the abstract base class for XMPP transports (mechanisms
used to send and receive XMPP content, not to be confused with protocol
gateways sometimes also called 'transports') and the standard TCP transport.
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import socket
import threading
import errno
import logging
import ssl

try:
    # pylint: disable=E0611
    from ssl import CHANNEL_BINDING_TYPES
except ImportError:
    CHANNEL_BINDING_TYPES = []

from functools import partial
from collections import deque

from .etree import element_to_unicode
from .mainloop.interfaces import IOHandler, HandlerReady, PrepareAgain
from .settings import XMPPSettings
from .exceptions import DNSError, PyXMPPIOError
from .streamevents import ResolvingSRVEvent, ResolvingAddressEvent
from .streamevents import ConnectedEvent, ConnectingEvent, DisconnectedEvent
from .streamevents import TLSConnectingEvent, TLSConnectedEvent
from .xmppserializer import XMPPSerializer
from .xmppparser import StreamReader
from .mainloop.wait import wait_for_write
from .interfaces import XMPPTransport
from .cert import get_certificate_from_ssl_socket

# pylint: disable=W0611
from . import resolver

logger = logging.getLogger("pyxmpp2.transport")

IN_LOGGER = logging.getLogger("pyxmpp2.IN")
OUT_LOGGER = logging.getLogger("pyxmpp2.OUT")

BLOCKING_ERRORS = set()
for __name in ['EAGAIN', 'EWOULDBLOCK', 'WSAEWOULDBLOCK', 'EINPROGRESS']:
    if hasattr(errno, __name):
        BLOCKING_ERRORS.add(getattr(errno, __name))

class WriteJob(object):
    """Base class for objects put to the `TCPTransport` write queue."""
    # pylint: disable-msg=R0903
    def __repr__(self):
        return "<WriteJob: {0}>".format(self.__class__.__name__)

class ContinueConnect(WriteJob):
    """Object to signal (via the write queue) a pending connect request.
    """
    # pylint: disable-msg=R0903
    pass

class StartTLS(WriteJob):
    """StartTLS request for the `TCPTransport` write queue."""
    # pylint: disable-msg=R0903
    def __init__(self, **kwargs):
        WriteJob.__init__(self)
        self.kwargs = kwargs
    def __repr__(self):
        args = [ "{0}={1!r}".format(k, v) for (k, v) in self.kwargs.items() ]
        return "<WriteJob: StartTLS: {0}>".format(" ".join(args))

class TLSHandshake(WriteJob):
    """Object to signal (via the write queue) a pending TLS handshake.
    """
    # pylint: disable-msg=R0903
    pass

class WriteData(WriteJob):
    """Data queued for write.
    """
    # pylint: disable-msg=R0903
    def __init__(self, data):
        WriteJob.__init__(self)
        self.data = data
    def __repr__(self):
        return "<WriteJob: WriteData: {0!r}>".format(self.data)

class TCPTransport(XMPPTransport, IOHandler):
    """XMPP over TCP with optional TLS.

    :Ivariables:
        - `lock`: the lock protecting this object
        - `settings`: settings for this object
          socket is currently open)
        - `_dst_addr`: socket address currently in use
        - `_dst_addrs`: list of (family, sockaddr) candidates to connect to
        - `_dst_family`: address family of the socket
        - `_dst_hostname`: hostname the transport is connecting to or connected
          to
        - `_dst_name`: requested domain name of the remote service
        - `_dst_nameports`: list of (hostname, port) candidates to connect to
        - `_dst_port`: requested port of the remote service
        - `_dst_service`: requested service name (e.g. 'xmpp-client')
        - `_eof`: `True` when reading side of the socket is closed
        - `_event_queue`: queue to send connection events to
        - `_hup`: `True` when the writing side of the socket is closed
        - `_reader`: parser for the data received from the socket
        - `_serializer`: XML serializer for data sent over the socket
        - `_socket`: socket currently used by the transport (`None` if no
        - `_state_cond`: condition object to synchronize threads over state
          change
        - `_state`: connection state (one of: `None`, "resolve-srv",
          "resolve-hostname", "connect", "connected", "tls-handshake",
          "closing", "closed", "aborted")
        - `_stream`: the stream associated with this transport
        - `_tls_state`: state of TLS handshake
    :Types:
        - `lock`: :std:`threading.RLock`
        - `settings`: `XMPPSettings`
        - `_dst_addr`: tuple
        - `_dst_addrs`: list of tuples
        - `_dst_family`: `int`
        - `_dst_hostname`: `unicode`
        - `_dst_name`: `unicode`
        - `_dst_nameports`: list of tuples
        - `_dst_port`: `int`
        - `_dst_service`: `unicode`
        - `_eof`: `bool`
        - `_event_queue`: :std:`Queue.Queue`
        - `_hup`: `bool`
        - `_reader`: `StreamReader`
        - `_serializer`: `XMPPSerializer`
        - `_socket`: :std:`socket.socket`
        - `_state_cond`: :std:`threading.Condition`
        - `_state`: `unicode`
        - `_stream`: `streambase.StreamBase`
        - `_tls_state`: `unicode`
    """
    # pylint: disable=R0902
    def __init__(self, settings = None, sock = None):
        """Initialize the `TCPTransport` object.

        :Parameters:
            - `settings`: XMPP settings to use
            - `sock`: existing socket, e.g. for accepted incoming connection.
        """
        if settings:
            self.settings = settings
        else:
            self.settings = XMPPSettings()
        self.lock = threading.RLock()
        self._write_queue = deque()
        self._write_queue_cond = threading.Condition(self.lock)
        self._eof = False
        self._hup = False
        self._stream = None
        self._serializer = None
        self._reader = None
        self._dst_name = None
        self._dst_port = None
        self._dst_service = None
        self._dst_nameports = None
        self._dst_hostname = None
        self._dst_addrs = None
        self._tls_state = None
        self._state_cond = threading.Condition(self.lock)
        if sock is None:
            self._socket = None
            self._dst_addr = None
            self._family = None
            self._state = None
        else:
            self._socket = sock
            self._family = sock.family
            self._dst_addr = sock.getpeername()
            self._state = "connected"
            self._socket.setblocking(False)
        self._event_queue = self.settings["event_queue"]
        self._auth_properties = {}

    def _set_state(self, state):
        """Set `_state` and notify any threads waiting for the change.
        """
        logger.debug(" _set_state({0!r})".format(state))
        self._state = state
        self._state_cond.notify()

    def connect(self, addr, port = None, service = None):
        """Start establishing TCP connection with given address.

        One of: `port` or `service` must be provided and `addr` must be
        a domain name and not an IP address if `port` is not given.

        When `service` is given try an SRV lookup for that service
        at domain `addr`. If `service` is not given or `addr` is an IP address,
        or the SRV lookup fails, connect to `port` at host `addr` directly.

        [initiating entity only]

        :Parameters:
            - `addr`: peer name or IP address
            - `port`: port number to connect to
            - `service`: service name (to be resolved using SRV DNS records)
        """
        with self.lock:
            self._connect(addr, port, service)

    def _connect(self, addr, port, service):
        """Same as `connect`, but assumes `lock` acquired.
        """
        self._dst_name = addr
        self._dst_port = port
        family = None
        try:
            res = socket.getaddrinfo(addr, port, socket.AF_UNSPEC,
                                socket.SOCK_STREAM, 0, socket.AI_NUMERICHOST)
            family = res[0][0]
            sockaddr = res[0][4]
        except socket.gaierror:
            family = None
            sockaddr = None

        if family is not None:
            if not port:
                raise ValueError("No port number given with literal IP address")
            self._dst_service = None
            self._family = family
            self._dst_addrs = [(family, sockaddr)]
            self._set_state("connect")
        elif service is not None:
            self._dst_service = service
            self._set_state("resolve-srv")
            self._dst_name = addr
        elif port:
            self._dst_nameports = [(self._dst_name, self._dst_port)]
            self._dst_service = None
            self._set_state("resolve-hostname")
        else:
            raise ValueError("No port number and no SRV service name given")

    def _resolve_srv(self):
        """Start resolving the SRV record.
        """
        resolver = self.settings["dns_resolver"] # pylint: disable=W0621
        self._set_state("resolving-srv")
        self.event(ResolvingSRVEvent(self._dst_name, self._dst_service))
        resolver.resolve_srv(self._dst_name, self._dst_service, "tcp",
                                                    callback = self._got_srv)

    def _got_srv(self, addrs):
        """Handle SRV lookup result.

        :Parameters:
            - `addrs`: properly sorted list of (hostname, port) tuples
        """
        with self.lock:
            if not addrs:
                self._dst_service = None
                if self._dst_port:
                    self._dst_nameports = [(self._dst_name, self._dst_port)]
                else:
                    self._dst_nameports = []
                    self._set_state("aborted")
                    raise DNSError("Could not resolve SRV for service {0!r}"
                            " on host {1!r} and fallback port number not given"
                                    .format(self._dst_service, self._dst_name))
            elif addrs == [(".", 0)]:
                self._dst_nameports = []
                self._set_state("aborted")
                raise DNSError("Service {0!r} not available on host {1!r}"
                                    .format(self._dst_service, self._dst_name))
            else:
                self._dst_nameports = addrs
            self._set_state("resolve-hostname")

    def _resolve_hostname(self):
        """Start hostname resolution for the next name to try.

        [called with `lock` acquired]
        """
        self._set_state("resolving-hostname")
        resolver = self.settings["dns_resolver"] # pylint: disable=W0621
        logger.debug("_dst_nameports: {0!r}".format(self._dst_nameports))
        name, port = self._dst_nameports.pop(0)
        self._dst_hostname = name
        resolver.resolve_address(name, callback = partial(
                                self._got_addresses, name, port),
                                allow_cname = self._dst_service is None)
        self.event(ResolvingAddressEvent(name))

    def _got_addresses(self, name, port, addrs):
        """Handler DNS address record lookup result.

        :Parameters:
            - `name`: the name requested
            - `port`: port number to connect to
            - `addrs`: list of (family, address) tuples
        """
        with self.lock:
            if not addrs:
                if self._dst_nameports:
                    self._set_state("resolve-hostname")
                    return
                else:
                    self._dst_addrs = []
                    self._set_state("aborted")
                    raise DNSError("Could not resolve address record for {0!r}"
                                                                .format(name))
            self._dst_addrs = [ (family, (addr, port)) for (family, addr)
                                                                    in addrs ]
            self._set_state("connect")

    def _start_connect(self):
        """Start connecting to the next address on the `_dst_addrs` list.

        [ called with `lock` acquired ]

        """
        family, addr = self._dst_addrs.pop(0)
        self._socket = socket.socket(family, socket.SOCK_STREAM)
        self._socket.setblocking(False)
        self._dst_addr = addr
        self._family  = family
        try:
            self._socket.connect(addr)
        except socket.error, err:
            logger.debug("Connect error: {0}".format(err))
            if err.args[0] in BLOCKING_ERRORS:
                self._set_state("connecting")
                self._write_queue.append(ContinueConnect())
                self._write_queue_cond.notify()
                self.event(ConnectingEvent(addr))
                return
            elif self._dst_addrs:
                self._set_state("connect")
                return
            elif self._dst_nameports:
                self._set_state("resolve-hostname")
                return
            else:
                self._socket.close()
                self._socket = None
                self._set_state("aborted")
                self._write_queue.clear()
                self._write_queue_cond.notify()
                raise
        self._connected()

    def _connected(self):
        """Handle connection success."""
        self._auth_properties['remote-ip'] = self._dst_addr[0]
        if self._dst_service:
            self._auth_properties['service-domain'] = self._dst_name
        if self._dst_hostname is not None:
            self._auth_properties['service-hostname'] = self._dst_hostname
        else:
            self._auth_properties['service-hostname'] = self._dst_addr[0]
        self._auth_properties['security-layer'] = None
        self.event(ConnectedEvent(self._dst_addr))
        self._set_state("connected")
        self._stream.transport_connected()

    def _continue_connect(self):
        """Continue connecting.

        [called with `lock` acquired]

        :Return: `True` when just connected
        """
        try:
            self._socket.connect(self._dst_addr)
        except socket.error, err:
            logger.debug("Connect error: {0}".format(err))
            if err.args[0] == errno.EISCONN:
                pass
            elif err.args[0] in BLOCKING_ERRORS:
                return None
            elif self._dst_addrs:
                self._set_state("connect")
                return None
            elif self._dst_nameports:
                self._set_state("resolve-hostname")
                return None
            else:
                self._socket.close()
                self._socket = None
                self._set_state("aborted")
                raise
        self._connected()

    def _write(self, data):
        """Write raw data to the socket.

        :Parameters:
            - `data`: data to send
        :Types:
            - `data`: `bytes`
        """
        OUT_LOGGER.debug("OUT: %r", data)
        if self._hup or not self._socket:
            raise PyXMPPIOError(u"Connection closed.")
        try:
            while data:
                try:
                    sent = self._socket.send(data)
                except ssl.SSLError, err:
                    if err.args[0] == ssl.SSL_ERROR_WANT_WRITE:
                        continue
                    else:
                        raise
                except socket.error, err:
                    if err.args[0] == errno.EINTR:
                        continue
                    if err.args[0] in BLOCKING_ERRORS:
                        wait_for_write(self._socket)
                        continue
                    raise
                data = data[sent:]
        except (IOError, OSError, socket.error), err:
            raise PyXMPPIOError(u"IO Error: {0}".format(err))

    def set_target(self, stream):
        """Make the `stream` the target for this transport instance.

        The 'stream_start', 'stream_end' and 'stream_element' methods
        of the target will be called when appropriate content is received.

        :Parameters:
            - `stream`: the stream handler to receive stream content
              from the transport
        :Types:
            - `stream`: `StreamBase`
        """
        with self.lock:
            if self._stream:
                raise ValueError("Target stream already set")
            self._stream = stream
            self._reader = StreamReader(stream)

    def send_stream_head(self, stanza_namespace, stream_from, stream_to,
                        stream_id = None, version = u'1.0', language = None):
        """
        Send stream head via the transport.

        :Parameters:
            - `stanza_namespace`: namespace of stream stanzas (e.g.
              'jabber:client')
            - `stream_from`: the 'from' attribute of the stream. May be `None`.
            - `stream_to`: the 'to' attribute of the stream. May be `None`.
            - `version`: the 'version' of the stream.
            - `language`: the 'xml:lang' of the stream
        :Types:
            - `stanza_namespace`: `unicode`
            - `stream_from`: `unicode`
            - `stream_to`: `unicode`
            - `version`: `unicode`
            - `language`: `unicode`
        """
        # pylint: disable=R0913
        with self.lock:
            self._serializer = XMPPSerializer(stanza_namespace,
                                            self.settings["extra_ns_prefixes"])
            head = self._serializer.emit_head(stream_from, stream_to,
                                                stream_id, version, language)
            self._write(head.encode("utf-8"))

    def restart(self):
        """Restart the stream after SASL or StartTLS handshake."""
        self._reader = StreamReader(self._stream)
        self._serializer = None

    def send_stream_tail(self):
        """
        Send stream tail via the transport.
        """
        with self.lock:
            if not self._socket or self._hup:
                logger.debug(u"Cannot send stream closing tag: already closed")
                return
            data = self._serializer.emit_tail()
            try:
                self._write(data.encode("utf-8"))
            except (IOError, SystemError, socket.error), err:
                logger.debug(u"Sending stream closing tag failed: {0}"
                                                                .format(err))
            self._serializer = None
            self._hup = True
            if self._tls_state is None:
                try:
                    self._socket.shutdown(socket.SHUT_WR)
                except socket.error:
                    pass
            self._set_state("closing")
            self._write_queue.clear()
            self._write_queue_cond.notify()

    def send_element(self, element):
        """
        Send an element via the transport.
        """
        with self.lock:
            if self._eof or self._socket is None or not self._serializer:
                logger.debug("Dropping element: {0}".format(
                                                element_to_unicode(element)))
                return
            data = self._serializer.emit_stanza(element)
            self._write(data.encode("utf-8"))

    def prepare(self):
        """When connecting start the next connection step and schedule
        next `prepare` call, when connected return `HandlerReady()`
        """
        result = HandlerReady()
        logger.debug("TCPTransport.prepare(): state: {0!r}".format(self._state))
        with self.lock:
            if self._state in ("connected", "closing", "closed", "aborted"):
                # no need to call prepare() .fileno() is stable
                pass
            elif self._state == "connect":
                self._start_connect()
                result = PrepareAgain(None)
            elif self._state == "resolve-hostname":
                self._resolve_hostname()
                result = PrepareAgain(0)
            elif self._state == "resolve-srv":
                self._resolve_srv()
                result = PrepareAgain(0)
            else:
                # wait for i/o, but keep calling prepare()
                result = PrepareAgain(None)
        logger.debug("TCPTransport.prepare(): new state: {0!r}"
                                                        .format(self._state))
        return result

    def fileno(self):
        """Return file descriptor to poll or select."""
        with self.lock:
            if self._socket is not None:
                return self._socket.fileno()
        return None

    def is_readable(self):
        """
        :Return: `True` when the I/O channel can be read
        """
        return self._socket is not None and not self._eof and (
                    self._state in ("connected", "closing")
                        or self._state == "tls-handshake"
                                        and self._tls_state == "want_read")

    def wait_for_readability(self):
        """
        Stop current thread until the channel is readable.

        :Return: `False` if it won't be readable (e.g. is closed)
        """
        with self.lock:
            while True:
                if self._socket is None or self._eof:
                    return False
                if self._state in ("connected", "closing"):
                    return True
                if self._state == "tls-handshake" and \
                                            self._tls_state == "want_read":
                    return True
                self._state_cond.wait()

    def is_writable(self):
        """
        :Return: `False` as currently the data is always written synchronously
        """
        with self.lock:
            return self._socket and bool(self._write_queue)

    def wait_for_writability(self):
        """
        Stop current thread until the channel is writable.

        :Return: `False` if it won't be readable (e.g. is closed)
        """
        with self.lock:
            while True:
                if self._state in ("closing", "closed", "aborted"):
                    return False
                if self._socket and bool(self._write_queue):
                    return True
                self._write_queue_cond.wait()
        return False

    def handle_write(self):
        """
        Handle the 'channel writable' state. E.g. send buffered data via a
        socket.
        """
        with self.lock:
            logger.debug("handle_write: queue: {0!r}".format(self._write_queue))
            try:
                job = self._write_queue.popleft()
            except IndexError:
                return
            if isinstance(job, WriteData):
                self._do_write(job.data) # pylint: disable=E1101
            elif isinstance(job, ContinueConnect):
                self._continue_connect()
            elif isinstance(job, StartTLS):
                self._initiate_starttls(**job.kwargs)
            elif isinstance(job, TLSHandshake):
                self._continue_tls_handshake()
            else:
                raise ValueError("Unrecognized job in the write queue: "
                                        "{0!r}".format(job))

    def starttls(self, **kwargs):
        """Request a TLS handshake on the socket ans switch
        to encrypted output.
        The handshake will start after any currently buffered data is sent.

        :Parameters:
            - `kwargs`: arguments for :std:`ssl.wrap_socket`
        """
        with self.lock:
            self.event(TLSConnectingEvent())
            self._write_queue.append(StartTLS(**kwargs))
            self._write_queue_cond.notify()

    def getpeercert(self):
        """Return the peer certificate.

        :ReturnType: `pyxmpp2.cert.Certificate`
        """
        with self.lock:
            if not self._socket or self._tls_state != "connected":
                raise ValueError("Not TLS-connected")
            return get_certificate_from_ssl_socket(self._socket)

    def _initiate_starttls(self, **kwargs):
        """Initiate starttls handshake over the socket.
        """
        if self._tls_state == "connected":
            raise RuntimeError("Already TLS-connected")
        kwargs["do_handshake_on_connect"] = False
        logger.debug("Wrapping the socket into ssl")
        self._socket = ssl.wrap_socket(self._socket, **kwargs)
        self._set_state("tls-handshake")
        self._continue_tls_handshake()

    def _continue_tls_handshake(self):
        """Continue a TLS handshake."""
        try:
            logger.debug(" do_handshake()")
            self._socket.do_handshake()
        except ssl.SSLError, err:
            if err.args[0] == ssl.SSL_ERROR_WANT_READ:
                self._tls_state = "want_read"
                logger.debug("   want_read")
                self._state_cond.notify()
                return
            elif err.args[0] == ssl.SSL_ERROR_WANT_WRITE:
                self._tls_state = "want_write"
                logger.debug("   want_write")
                self._write_queue.appendleft(TLSHandshake)
                return
            else:
                raise
        self._tls_state = "connected"
        self._set_state("connected")
        self._auth_properties['security-layer'] = "TLS"
        if "tls-unique" in CHANNEL_BINDING_TYPES:
            try:
                # pylint: disable=E1103
                tls_unique = self._socket.get_channel_binding("tls-unique")
            except ValueError:
                pass
            else:
                self._auth_properties['channel-binding'] = {
                                                    "tls-unique": tls_unique}
        try:
            cipher = self._socket.cipher()
        except AttributeError:
            # SSLSocket.cipher doesn't work on PyPy
            cipher = "unknown"
        cert = get_certificate_from_ssl_socket(self._socket)
        self.event(TLSConnectedEvent(cipher, cert))

    def handle_read(self):
        """
        Handle the 'channel readable' state. E.g. read from a socket.
        """
        with self.lock:
            logger.debug("handle_read()")
            if self._eof or self._socket is None:
                return
            if self._state == "tls-handshake":
                while True:
                    logger.debug("tls handshake read...")
                    self._continue_tls_handshake()
                    logger.debug("  state: {0}".format(self._tls_state))
                    if self._tls_state != "want_read":
                        break
            elif self._tls_state == "connected":
                while self._socket and not self._eof:
                    logger.debug("tls socket read...")
                    try:
                        data = self._socket.read(4096)
                    except ssl.SSLError, err:
                        if err.args[0] == ssl.SSL_ERROR_WANT_READ:
                            break
                        elif err.args[0] == ssl.SSL_ERROR_WANT_WRITE:
                            break
                        else:
                            raise
                    except socket.error, err:
                        if err.args[0] == errno.EINTR:
                            continue
                        elif err.args[0] in BLOCKING_ERRORS:
                            break
                        elif err.args[0] == errno.ECONNRESET:
                            logger.warning("Connection reset by peer")
                            data = None
                        else:
                            raise
                    self._feed_reader(data)
            else:
                while self._socket and not self._eof:
                    logger.debug("raw socket read...")
                    try:
                        data = self._socket.recv(4096)
                    except socket.error, err:
                        if err.args[0] == errno.EINTR:
                            continue
                        elif err.args[0] in BLOCKING_ERRORS:
                            break
                        elif err.args[0] == errno.ECONNRESET:
                            logger.warning("Connection reset by peer")
                            data = None
                        else:
                            raise
                    self._feed_reader(data)

    def handle_hup(self):
        """
        Handle the 'channel hungup' state. The handler should not be writable
        after this.
        """
        with self.lock:
            if self._state == 'connecting' and self._dst_addrs:
                self._hup = False
                self._set_state("connect")
                return
        self._hup = True

    def handle_err(self):
        """
        Handle an error reported.
        """
        with self.lock:
            if self._state == 'connecting' and self._dst_addrs:
                self._hup = False
                self._set_state("connect")
                return
            self._socket.close()
            self._socket = None
            self._set_state("aborted")
            self._write_queue.clear()
            self._write_queue_cond.notify()
        raise PyXMPPIOError("Unhandled error on socket")

    def handle_nval(self):
        """
        Handle an error reported.
        """
        if self._socket is None:
            # socket closed by other thread
            return
        self._set_state("aborted")
        raise PyXMPPIOError("Invalid file descriptor used in main event loop")

    def is_connected(self):
        """
        Check if the transport is connected.

        :Return: `True` if is connected.
        """
        return self._state in ("connected", "tls-handshake") \
                                            and not self._eof and not self._hup

    def disconnect(self):
        """Disconnect the stream gracefully."""
        logger.debug("TCPTransport.disconnect()")
        with self.lock:
            if self._socket is None:
                if self._state != "closed":
                    self.event(DisconnectedEvent(self._dst_addr))
                    self._set_state("closed")
                return
            if self._hup or not self._serializer:
                self._close()
            else:
                self.send_stream_tail()

    def close(self):
        """Close the stream immediately, so it won't expect more events."""
        with self.lock:
            self._close()

    def _close(self):
        """Same as `_close` but expects `lock` acquired.
        """
        if self._state != "closed":
            self.event(DisconnectedEvent(self._dst_addr))
            self._set_state("closed")
        if self._socket is None:
            return
        try:
            self._socket.shutdown(socket.SHUT_RDWR)
        except socket.error:
            pass
        self._socket.close()
        self._socket = None
        self._write_queue.clear()
        self._write_queue_cond.notify()

    def _feed_reader(self, data):
        """Feed the stream reader with data received.

        [ called with `lock` acquired ]

        If `data` is None or empty, then stream end (peer disconnected) is
        assumed and the stream is closed.

        `lock` is acquired during the operation.

        :Parameters:
            - `data`: data received from the stream socket.
        :Types:
            - `data`: `unicode`
        """
        IN_LOGGER.debug("IN: %r", data)
        if data:
            self.lock.release() # not to deadlock with the stream
            try:
                self._reader.feed(data)
            finally:
                self.lock.acquire()
        else:
            self._eof = True
            self.lock.release() # not to deadlock with the stream
            try:
                self._stream.stream_eof()
            finally:
                self.lock.acquire()
            if not self._serializer:
                if self._state != "closed":
                    self.event(DisconnectedEvent(self._dst_addr))
                    self._set_state("closed")

    def event(self, event):
        """Pass an event to the target stream or just log it."""
        logger.debug(u"TCP transport event: {0}".format(event))
        if self._stream:
            event.stream = self._stream
        self._event_queue.put(event)

    @property
    def auth_properties(self):
        return self._auth_properties


########NEW FILE########
__FILENAME__ = utils
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""Utility functions for the pyxmpp package."""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

def xml_elements_equal(element1, element2, ignore_level1_cdata = False):
    """Check if two XML elements are equal.

    :Parameters:
        - `element1`: the first element to compare
        - `element2`: the other element to compare
        - `ignore_level1_cdata`: if direct text children of the elements
          should be ignored for the comparision
    :Types:
        - `element1`: :etree:`ElementTree.Element`
        - `element2`: :etree:`ElementTree.Element`
        - `ignore_level1_cdata`: `bool`

    :Returntype: `bool`
    """
    # pylint: disable-msg=R0911
    if None in (element1, element2) or element1.tag != element2.tag:
        return False
    attrs1 = element1.items()
    attrs1.sort()
    attrs2 = element2.items()
    attrs2.sort()

    if not ignore_level1_cdata:
        if element1.text != element2.text:
            return False

    if attrs1 != attrs2:
        return False

    if len(element1) != len(element2):
        return False
    for child1, child2 in zip(element1, element2):
        if child1.tag != child2.tag:
            return False
        if not ignore_level1_cdata:
            if element1.text != element2.text:
                return False
        if not xml_elements_equal(child1, child2):
            return False
    return True

import time
import datetime

_MINUTE = datetime.timedelta(minutes = 1)
_NULLDELTA = datetime.timedelta()

def datetime_utc_to_local(utc):
    """
    An ugly hack to convert naive :std:`datetime.datetime` object containing
    UTC time to a naive :std:`datetime.datetime` object with local time.
    It seems standard Python 2.3 library doesn't provide any better way to
    do that.
    """
    # pylint: disable-msg=C0103
    ts = time.time()
    cur = datetime.datetime.fromtimestamp(ts)
    cur_utc = datetime.datetime.utcfromtimestamp(ts)

    offset = cur - cur_utc
    t = utc

    d = datetime.timedelta(hours = 2)
    while d > _MINUTE:
        local = t + offset
        tm = local.timetuple()
        tm = tm[0:8] + (0, )
        ts = time.mktime(tm)
        u = datetime.datetime.utcfromtimestamp(ts)
        diff = u - utc
        if diff < _MINUTE and diff > -_MINUTE:
            break
        if diff > _NULLDELTA:
            offset -= d
        else:
            offset += d
        d //= 2
    return local

def datetime_local_to_utc(local):
    """
    Simple function to convert naive :std:`datetime.datetime` object containing
    local time to a naive :std:`datetime.datetime` object with UTC time.
    """
    timestamp = time.mktime(local.timetuple())
    return datetime.datetime.utcfromtimestamp(timestamp)

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = xmppparser
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""ElementTree-based XMPP stream parserg"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import threading
import logging

from .etree import ElementTree

from .exceptions import StreamParseError

COMMON_NS = "http://pyxmpp.jajcus.net/xmlns/common"

logger = logging.getLogger("pyxmpp2.xmppparser")

class XMLStreamHandler(object):
    """Base class for stream handler, used as a target for XMPP parser
    or XMPP transports.
    """
    # pylint: disable-msg=R0201
    def stream_start(self, element):
        """Called when the start tag of root element is encountered
        in the stream.

        :Parameters:
            - `element`: the root element
        :Types:
            - `element`: :etree:`ElementTree.Element`"""
        logger.error("Unhandled stream start: {0!r}".format(element))

    def stream_end(self):
        """Called when the end tag of root element is encountered
        in the stream.
        """
        logger.error("Unhandled stream end")

    def stream_element(self, element):
        """Called when the end tag of a direct child of the root
        element is encountered in the stream.

        :Parameters:
            - `element`: the (complete) element being processed
        :Types:
            - `element`: :etree:`ElementTree.Element`"""
        logger.error("Unhandled stanza: {0!r}".format(element))

    def stream_parse_error(self, descr):
        """Called when an error is encountered in the stream.

        :Parameters:
            - `descr`: description of the error
        :Types:
            - `descr`: `unicode`"""
        raise StreamParseError(descr)

    def stream_eof(self):
        """Called when stream input ends (EOF, socket closed by peer)
        which could happen before actual stream end tag was received,
        but usually will happen just after that.

        This event is not generated by the XMPP parser, but may be generated
        by transports.
        """
        pass


class ParserTarget(object):
    """Element tree parser events handler for the XMPP stream parser."""
    def __init__(self, handler):
        """Initialize the SAX handler.

        :Parameters:
            - `handler`: Object to handle stream start, end and stanzas.
        :Types:
            - `handler`: `XMLStreamHandler`
        """
        self._handler = handler
        self._head = ""
        self._tail = ""
        self._builder = None
        self._level = 0
        self._root = None

    def data(self, data):
        """Handle XML text data.

        Ignore the data outside the root element and directly under the root,
        pass all other text to the tree builder, so it will be included in the
        stanzas."""
        if self._level > 1:
            return self._builder.data(data)

    def start(self, tag, attrs):
        """Handle the start tag.

        Call the handler's 'stream_start' methods with
        an empty root element if it is top level.

        For lower level tags use :etree:`ElementTree.TreeBuilder` to collect
        them.
        """
        if self._level == 0:
            self._root = ElementTree.Element(tag, attrs)
            self._handler.stream_start(self._root)
        if self._level < 2:
            self._builder = ElementTree.TreeBuilder()
        self._level += 1
        return self._builder.start(tag, attrs)

    def close(self):
        """Handle the stream end."""
        pass

    def end(self, tag):
        """Handle an end tag.

        Call the handler's 'stream_end' method with
        an the root element (built by the `start` method).

        On the first level below root, sent the built element tree
        to the handler via the 'stanza methods'.

        Any tag below will be just added to the tree builder.
        """
        self._level -= 1
        if self._level < 0:
            self._handler.stream_parse_error(u"Unexpected end tag for: {0!r}"
                                                                .format(tag))
            return
        if self._level == 0:
            if tag != self._root.tag:
                self._handler.stream_parse_error(u"Unexpected end tag for:"
                            " {0!r} (stream end tag expected)".format(tag))
                return
            self._handler.stream_end()
            return
        element = self._builder.end(tag)
        if self._level == 1:
            self._handler.stream_element(element)

class StreamReader(object):
    """XML stream reader.

    :Ivariables:
        - `handler`: object to receive parsed stream elements
        - `parser`: the xml parser
        - `lock`: lock to protect the object
        - `in_use`: re-entrancy protection
        - `_started`: flag set after the first byte is pushed to the parser
    :Types:
        - `handler`: `XMLStreamHandler`
        - `parser`: :etree:`ElementTree.XMLParser`
        - `lock`: :std:`threading.RLock`
        - `in_use`: `bool`
        - `_started`: `bool`
    """
    # pylint: disable-msg=R0903
    def __init__(self, handler):
        """Initialize the reader.

        :Parameters:
            - `handler`: Object to handle stream start, end and stanzas.
        :Types:
            - `handler`: `XMLStreamHandler`
        """
        self.handler = handler
        self.parser = ElementTree.XMLParser(target = ParserTarget(handler))
        self.lock = threading.RLock()
        self.in_use = False
        self._started = False

    def feed(self, data):
        """Feed the parser with a chunk of data. Apropriate methods
        of `handler` will be called whenever something interesting is
        found.

        :Parameters:
            - `data`: the chunk of data to parse.
        :Types:
            - `data`: `str`"""
        with self.lock:
            if self.in_use:
                raise StreamParseError("StreamReader.feed() is not reentrant!")
            self.in_use = True
            try:
                if not self._started:
                    # workaround for lxml bug when fed with a big chunk at once
                    if len(data) > 1:
                        self.parser.feed(data[:1])
                        data = data[1:]
                    self._started = True
                if data:
                    self.parser.feed(data)
                else:
                    self.parser.close()
            except ElementTree.ParseError, err:
                self.handler.stream_parse_error(unicode(err))
            finally:
                self.in_use = False

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = xmppserializer
#
# (C) Copyright 2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""XMPP serializer for ElementTree data.

XMPP has specific requirements for XML serialization. Predefined
namespace prefixes must be used, including no prefix for the stanza
namespace (which may be one of, at least, two different namespaces:
'jabber:client' and 'jabber:server')"""

from __future__ import absolute_import, division

import threading
import re
from xml.sax.saxutils import escape, quoteattr

from .constants import STANZA_NAMESPACES, STREAM_NS, XML_NS

__docformat__ = "restructuredtext en"

STANDARD_PREFIXES = {
        STREAM_NS: u'stream',
        XML_NS: u'xml',
    }

EVIL_CHARACTERS_RE = re.compile(r"[\000-\010\013\014\016-\037]", re.UNICODE)

def remove_evil_characters(data):
    """Remove control characters (not allowed in XML) from a string."""
    return EVIL_CHARACTERS_RE.sub(u"\ufffd", data)

class XMPPSerializer(object):
    """Implementation of the XMPP serializer.

    Single instance of this class should be used for a single stream and never
    reused. It will keep track of prefixes declared on the root element and
    used later.

    :Ivariables:
        - `stanza_namespace`: the default namespace of the stream
        - `_prefixes`: mapping (prefix -> uri) of known namespace prefixes
        - `_root_prefixes`: prefixes declared on the root element
        - `_head_emitted`: `True` if the stream start tag has been emitted
        - `_next_id`: the next sequence number to be used in auto-generated
          prefixes.
    :Types:
        - `stanza_namespace`: `unicode`
        - `_prefixes`: `dict`
        - `_root_prefixes`: `dict`
        - `_head_emitted`: `bool`
        - `_next_id`: `int`
    """
    def __init__(self, stanza_namespace, extra_prefixes = None):
        """
        :Parameters:
            - `stanza_namespace`: the default namespace used for XMPP stanzas.
              E.g. 'jabber:client' for c2s connections.
            - `extra_prefixes`: mapping of namespaces to prefixes (not the
              other way) to be used on the stream. These prefixes will be
              declared on the root element and used in all descendants. That
              may be used to optimize the stream for size.
        :Types:
            - `stanza_namespace`: `unicode`
            - `extra_prefixes`: `unicode` to `unicode` mapping.
        """
        self.stanza_namespace = stanza_namespace
        self._prefixes = {}
        if extra_prefixes:
            self._prefixes.update(extra_prefixes)
        self._root_prefixes = None
        self._head_emitted = False
        self._next_id = 1

    def add_prefix(self, namespace, prefix):
        """Add a new namespace prefix.

        If the root element has not yet been emitted the prefix will
        be declared there, otherwise the prefix will be declared on the
        top-most element using this namespace in every stanza.

        :Parameters:
            - `namespace`: the namespace URI
            - `prefix`: the prefix string
        :Types:
            - `namespace`: `unicode`
            - `prefix`: `unicode`
        """
        if prefix == "xml" and namespace != XML_NS:
            raise ValueError, "Cannot change 'xml' prefix meaning"
        self._prefixes[namespace] = prefix

    def emit_head(self, stream_from, stream_to, stream_id = None,
                                            version = u'1.0', language = None):
        """Return the opening tag of the stream root element.

        :Parameters:
            - `stream_from`: the 'from' attribute of the stream. May be `None`.
            - `stream_to`: the 'to' attribute of the stream. May be `None`.
            - `version`: the 'version' of the stream.
            - `language`: the 'xml:lang' of the stream
        :Types:
            - `stream_from`: `unicode`
            - `stream_to`: `unicode`
            - `version`: `unicode`
            - `language`: `unicode`
        """
        # pylint: disable-msg=R0913
        self._root_prefixes = dict(STANDARD_PREFIXES)
        self._root_prefixes[self.stanza_namespace] = None
        for namespace, prefix in self._root_prefixes.items():
            if not prefix or prefix == "stream":
                continue
            if namespace in STANDARD_PREFIXES or namespace in STANZA_NAMESPACES:
                continue
            self._root_prefixes[namespace] = prefix
        tag = u"<{0}:stream version={1}".format(STANDARD_PREFIXES[STREAM_NS],
                                                        quoteattr(version))
        if stream_from:
            tag += u" from={0}".format(quoteattr(stream_from))
        if stream_to:
            tag += u" to={0}".format(quoteattr(stream_to))
        if stream_id is not None:
            tag += u" id={0}".format(quoteattr(stream_id))
        if language is not None:
            tag += u" xml:lang={0}".format(quoteattr(language))
        for namespace, prefix in self._root_prefixes.items():
            if prefix == "xml":
                continue
            if prefix:
                tag += u' xmlns:{0}={1}'.format(prefix, quoteattr(namespace))
            else:
                tag += u' xmlns={1}'.format(prefix, quoteattr(namespace))
        tag += u">"
        self._head_emitted = True
        return tag

    def emit_tail(self):
        """Return the end tag of the stream root element."""
        return u"</{0}:stream>".format(self._root_prefixes[STREAM_NS])

    def _split_qname(self, name, is_element):
        """Split an element of attribute qname into namespace and local
        name.

        :Parameters:
            - `name`: element or attribute QName
            - `is_element`: `True` for an element, `False` for an attribute
        :Types:
            - `name`: `unicode`
            - `is_element`: `bool`

        :Return: namespace URI, local name
        :returntype: `unicode`, `unicode`"""
        if name.startswith(u"{"):
            namespace, name = name[1:].split(u"}", 1)
            if namespace in STANZA_NAMESPACES:
                namespace = self.stanza_namespace
        elif is_element:
            raise ValueError(u"Element with no namespace: {0!r}".format(name))
        else:
            namespace = None
        return namespace, name

    def _make_prefix(self, declared_prefixes):
        """Make up a new namespace prefix, which won't conflict
        with `_prefixes` and prefixes declared in the current scope.

        :Parameters:
            - `declared_prefixes`: namespace to prefix mapping for the current
              scope
        :Types:
            - `declared_prefixes`: `unicode` to `unicode` dictionary

        :Returns: a new prefix
        :Returntype: `unicode`
        """
        used_prefixes = set(self._prefixes.values())
        used_prefixes |= set(declared_prefixes.values())
        while True:
            prefix = u"ns{0}".format(self._next_id)
            self._next_id += 1
            if prefix not in used_prefixes:
                break
        return prefix

    def _make_prefixed(self, name, is_element, declared_prefixes, declarations):
        """Return namespace-prefixed tag or attribute name.

        Add appropriate declaration to `declarations` when neccessary.

        If no prefix for an element namespace is defined, make the elements
        namespace default (no prefix). For attributes, make up a prefix in such
        case.

        :Parameters:
            - `name`: QName ('{namespace-uri}local-name')
              to convert
            - `is_element`: `True` for element, `False` for an attribute
            - `declared_prefixes`: mapping of prefixes already declared
              at this scope
            - `declarations`: XMLNS declarations on the current element.
        :Types:
            - `name`: `unicode`
            - `is_element`: `bool`
            - `declared_prefixes`: `unicode` to `unicode` dictionary
            - `declarations`: `unicode` to `unicode` dictionary

        :Returntype: `unicode`"""
        namespace, name = self._split_qname(name, is_element)
        if namespace is None:
            prefix = None
        elif namespace in declared_prefixes:
            prefix = declared_prefixes[namespace]
        elif namespace in self._prefixes:
            prefix = self._prefixes[namespace]
            declarations[namespace] = prefix
            declared_prefixes[namespace] = prefix
        else:
            if is_element:
                prefix = None
            else:
                prefix = self._make_prefix(declared_prefixes)
            declarations[namespace] = prefix
            declared_prefixes[namespace] = prefix
        if prefix:
            return prefix + u":" + name
        else:
            return name

    @staticmethod
    def _make_ns_declarations(declarations, declared_prefixes):
        """Build namespace declarations and remove obsoleted mappings
        from `declared_prefixes`.

        :Parameters:
            - `declarations`: namespace to prefix mapping of the new
              declarations
            - `declared_prefixes`: namespace to prefix mapping of already
              declared prefixes.
        :Types:
            - `declarations`: `unicode` to `unicode` dictionary
            - `declared_prefixes`: `unicode` to `unicode` dictionary

        :Return: string of namespace declarations to be used in a start tag
        :Returntype: `unicode`
        """
        result = []
        for namespace, prefix in declarations.items():
            if prefix:
                result.append(u' xmlns:{0}={1}'.format(prefix, quoteattr(
                                                                namespace)))
            else:
                result.append(u' xmlns={1}'.format(prefix, quoteattr(
                                                                namespace)))
            for d_namespace, d_prefix in declared_prefixes.items():
                if (not prefix and not d_prefix) or d_prefix == prefix:
                    if namespace != d_namespace:
                        del declared_prefixes[d_namespace]
        return u" ".join(result)

    def _emit_element(self, element, level, declared_prefixes):
        """"Recursive XML element serializer.

        :Parameters:
            - `element`: the element to serialize
            - `level`: nest level (0 - root element, 1 - stanzas, etc.)
            - `declared_prefixes`: namespace to prefix mapping of already
              declared prefixes.
        :Types:
            - `element`: :etree:`ElementTree.Element`
            - `level`: `int`
            - `declared_prefixes`: `unicode` to `unicode` dictionary

        :Return: serialized element
        :Returntype: `unicode`
        """
        declarations = {}
        declared_prefixes = dict(declared_prefixes)
        name = element.tag
        prefixed = self._make_prefixed(name, True, declared_prefixes,
                                                                declarations)
        start_tag = u"<{0}".format(prefixed)
        end_tag = u"</{0}>".format(prefixed)
        for name, value in element.items():
            prefixed = self._make_prefixed(name, False, declared_prefixes,
                                                                declarations)
            start_tag += u' {0}={1}'.format(prefixed, quoteattr(value))

        declarations = self._make_ns_declarations(declarations,
                                                        declared_prefixes)
        if declarations:
            start_tag += u" " + declarations
        children = []
        for child in element:
            children.append(self._emit_element(child, level +1,
                                                        declared_prefixes))
        if not children and not element.text:
            start_tag += u"/>"
            end_tag = u""
            text = u""
        else:
            start_tag += u">"
            if level > 0 and element.text:
                text = escape(element.text)
            else:
                text = u""
        if level > 1 and element.tail:
            tail = escape(element.tail)
        else:
            tail = u""
        return start_tag + text + u''.join(children) + end_tag + tail

    def emit_stanza(self, element):
        """"Serialize a stanza.

        Must be called after `emit_head`.

        :Parameters:
            - `element`: the element to serialize
        :Types:
            - `element`: :etree:`ElementTree.Element`

        :Return: serialized element
        :Returntype: `unicode`
        """
        if not self._head_emitted:
            raise RuntimeError(".emit_head() must be called first.")
        string = self._emit_element(element, level = 1,
                                    declared_prefixes = self._root_prefixes)
        return remove_evil_characters(string)


# thread local data to store XMPPSerializer instance used by the `serialize`
# function
_THREAD = threading.local()

def serialize(element):
    """Serialize an XMPP element.

    Utility function for debugging or logging.

        :Parameters:
            - `element`: the element to serialize
        :Types:
            - `element`: :etree:`ElementTree.Element`

        :Return: serialized element
        :Returntype: `unicode`
    """
    if getattr(_THREAD, "serializer", None) is None:
        _THREAD.serializer = XMPPSerializer("jabber:client")
        _THREAD.serializer.emit_head(None, None)
    return _THREAD.serializer.emit_stanza(element)

# vi: sts=4 et sw=4

########NEW FILE########
__FILENAME__ = xmppstringprep
#
# (C) Copyright 2003-2011 Jacek Konieczny <jajcus@jajcus.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License Version
# 2.1 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# pylint treats "import stringprep" like depreciated "import string"
# pylint: disable-msg=W0402

"""Nodeprep and resourceprep stringprep profiles.

Normative reference:
  - `RFC 6122 <http://xmpp.org/rfcs/rfc6122.html>`__
  - `RFC 3454 <http://tools.ietf.org/html/rfc3454>`__
"""

from __future__ import absolute_import, division

__docformat__ = "restructuredtext en"

import stringprep
import unicodedata
from .exceptions import StringprepError

def b1_mapping(char):
    """Do RFC 3454 B.1 table mapping.

    :Parameters:
        - `char`: Unicode character to map.

    :returns: u"" if there is `char` code in the table, `None` otherwise.
    """
    if stringprep.in_table_b1(char):
        return u""
    else:
        return None

def c12_mapping(char):
    """Do mapping of RFC 3454 C.1.2 space characters to ' '.

    :Parameters:
        - `char`: Unicode character to map.

    :returns: u" " if there is `char` code in the table, `None` otherwise.
    """
    if stringprep.in_table_c12(char):
        return u" "
    else:
        return None

def nfkc(data):
    """Do NFKC normalization of Unicode data.

    :Parameters:
        - `data`: list of Unicode characters or Unicode string.

    :return: normalized Unicode string."""
    if isinstance(data, list):
        data = u"".join(data)
    return unicodedata.normalize("NFKC", data)

class Profile(object):
    """Base class for stringprep profiles.
    """
    cache_items = []
    def __init__(self, unassigned, mapping, normalization, prohibited,
                                                                bidi = True):
        """Initialize Profile object.

        :Parameters:
            - `unassigned`: the lookup table with unassigned codes
            - `mapping`: the lookup table with character mappings
            - `normalization`: the normalization function
            - `prohibited`: the lookup table with prohibited characters
            - `bidi`: if True then bidirectional checks should be done
        :Types:
            - `unassigned`: tuple of functions
            - `mapping`: tuple of functions
            - `normalization`: tuple of functions
            - `prohibited`: tuple of functions
            - `bidi`: `bool`
        """
        # pylint: disable-msg=R0913
        self.unassigned = unassigned
        self.mapping = mapping
        self.normalization = normalization
        self.prohibited = prohibited
        self.bidi = bidi
        self.cache = {}

    def prepare(self, data):
        """Complete string preparation procedure for 'stored' strings.
        (includes checks for unassigned codes)

        :Parameters:
            - `data`: Unicode string to prepare.

        :return: prepared string

        :raise StringprepError: if the preparation fails
        """
        ret = self.cache.get(data)
        if ret is not None:
            return ret
        result = self.map(data)
        if self.normalization:
            result = self.normalization(result)
        result = self.prohibit(result)
        result = self.check_unassigned(result)
        if self.bidi:
            result = self.check_bidi(result)
        if isinstance(result, list):
            result = u"".join()
        if len(self.cache_items) >= _stringprep_cache_size:
            remove = self.cache_items[: -_stringprep_cache_size // 2]
            for profile, key in remove:
                try:
                    del profile.cache[key]
                except KeyError:
                    pass
            self.cache_items[:] = self.cache_items[
                                                -_stringprep_cache_size // 2 :]
        self.cache_items.append((self, data))
        self.cache[data] = result
        return result

    def prepare_query(self, data):
        """Complete string preparation procedure for 'query' strings.
        (without checks for unassigned codes)

        :Parameters:
            - `data`: Unicode string to prepare.

        :return: prepared string

        :raise StringprepError: if the preparation fails
        """
        data = self.map(data)
        if self.normalization:
            data = self.normalization(data)
        data = self.prohibit(data)
        if self.bidi:
            data = self.check_bidi(data)
        if isinstance(data, list):
            data = u"".join(data)
        return data

    def map(self, data):
        """Mapping part of string preparation."""
        result = []
        for char in data:
            ret = None
            for lookup in self.mapping:
                ret = lookup(char)
                if ret is not None:
                    break
            if ret is not None:
                result.append(ret)
            else:
                result.append(char)
        return result

    def prohibit(self, data):
        """Checks for prohibited characters."""
        for char in data:
            for lookup in self.prohibited:
                if lookup(char):
                    raise StringprepError("Prohibited character: {0!r}"
                                                                .format(char))
        return data

    def check_unassigned(self, data):
        """Checks for unassigned character codes."""
        for char in data:
            for lookup in self.unassigned:
                if lookup(char):
                    raise StringprepError("Unassigned character: {0!r}"
                                                                .format(char))
        return data

    @staticmethod
    def check_bidi(data):
        """Checks if sting is valid for bidirectional printing."""
        has_l = False
        has_ral = False
        for char in data:
            if stringprep.in_table_d1(char):
                has_ral = True
            elif stringprep.in_table_d2(char):
                has_l = True
        if has_l and has_ral:
            raise StringprepError("Both RandALCat and LCat characters present")
        if has_ral and (not stringprep.in_table_d1(data[0])
                                    or not stringprep.in_table_d1(data[-1])):
            raise StringprepError("The first and the last character must"
                                                                " be RandALCat")
        return data

NODEPREP_PROHIBITED = set([u'"', u'&', u"'", u"/", u":", u"<", u">", u"@"])

NODEPREP = Profile(
    unassigned = (stringprep.in_table_a1,),
    mapping = (b1_mapping, stringprep.map_table_b2),
    normalization = nfkc,
    prohibited = (  stringprep.in_table_c11, stringprep.in_table_c12,
                    stringprep.in_table_c21, stringprep.in_table_c22,
                    stringprep.in_table_c3, stringprep.in_table_c4,
                    stringprep.in_table_c5, stringprep.in_table_c6,
                    stringprep.in_table_c7, stringprep.in_table_c8,
                    stringprep.in_table_c9,
                    lambda x: x in NODEPREP_PROHIBITED ),
    bidi = True)

RESOURCEPREP = Profile(
    unassigned = (stringprep.in_table_a1,),
    mapping = (b1_mapping,),
    normalization = nfkc,
    prohibited = (  stringprep.in_table_c12, stringprep.in_table_c21,
                    stringprep.in_table_c22, stringprep.in_table_c3,
                    stringprep.in_table_c4, stringprep.in_table_c5,
                    stringprep.in_table_c6, stringprep.in_table_c7,
                    stringprep.in_table_c8, stringprep.in_table_c9 ),
    bidi = True)

_stringprep_cache_size = 1000 # pylint: disable-msg=C0103

def set_stringprep_cache_size(size):
    """Modify stringprep cache size.

    :Parameters:
        - `size`: new cache size
    """
    # pylint: disable-msg=W0603
    global _stringprep_cache_size
    _stringprep_cache_size = size
    if len(Profile.cache_items) > size:
        remove = Profile.cache_items[:-size]
        for profile, key in remove:
            try:
                del profile.cache[key]
            except KeyError:
                pass
        Profile.cache_items = Profile.cache_items[-size:]

# vi: sts=4 et sw=4

########NEW FILE########
