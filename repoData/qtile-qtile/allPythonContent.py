__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Qtile documentation build configuration file, created by
# sphinx-quickstart on Sat Feb 11 15:20:21 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('_themes'))
sys.path.insert(0, os.path.abspath('../'))
# sys.path.insert(0, os.path.abspath('../libqtile'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Qtile'
copyright = u'2012, Aldo Cortesi and contributers'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.7.0'
# The full version, including alpha/beta/rc tags.
release = '0.7.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'friendly'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'qtile'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
html_favicon = 'favicon.png'

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    #'index': ['sidebar_intro.html', 'searchbox.html'],
    '**': ['sidebar_intro.html', 'localtoc.html', 'relations.html', 'sourcelink.html', 'searchbox.html']
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {'index': 'index.html'}

# If false, no module index is generated.
html_domain_indices = True

# If false, no index is generated.
html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Qtiledoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Qtile.tex', u'Qtile Documentation',
   u'Aldo Cortesi', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'qtile', u'Qtile Documentation',
     [u'Aldo Cortesi'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Qtile', u'Qtile Documentation',
   u'Aldo Cortesi', 'Qtile', 'A hackable tiling window manager.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = bar
# Copyright (c) 2008, Aldo Cortesi. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import command
import confreader
import drawer
import hook
import configurable
import window

import gobject

USE_BAR_DRAW_QUEUE = True

class Gap(command.CommandObject):
    """
        A gap, placed along one of the edges of the screen. If a gap has been
        defined, Qtile will avoid covering it with windows. The most probable
        reason for configuring a gap is to make space for a third-party bar or
        other static window.
    """
    def __init__(self, size):
        """
            size: The width of the gap.
        """
        self.size = size
        self.qtile = None
        self.screen = None

    def _configure(self, qtile, screen):
        self.qtile = qtile
        self.screen = screen

    def draw(self):
        pass

    @property
    def x(self):
        screen = self.screen
        if screen.right is self:
            return screen.dx + screen.dwidth
        else:
            return screen.x

    @property
    def y(self):
        screen = self.screen
        if screen.top is self:
            return screen.y
        elif screen.bottom is self:
            return screen.dy + screen.dheight
        elif screen.left is self:
            return screen.dy
        elif screen.right is self:
            return screen.y + screen.dy

    @property
    def width(self):
        screen = self.screen
        if self in [screen.top, screen.bottom]:
            return screen.width
        else:
            return self.size

    @property
    def height(self):
        screen = self.screen
        if self in [screen.top, screen.bottom]:
            return self.size
        else:
            return screen.dheight

    def geometry(self):
        return (self.x, self.y, self.width, self.height)

    def _items(self, name):
        if name == "screen":
            return (True, None)

    def _select(self, name, sel):
        if name == "screen":
            return self.screen

    @property
    def position(self):
        for i in ["top", "bottom", "left", "right"]:
            if getattr(self.screen, i) is self:
                return i

    def info(self):
        return dict(position=self.position)

    def cmd_info(self):
        """
            Info for this object.
        """
        return self.info()


class Obj:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.name


STRETCH = Obj("STRETCH")
CALCULATED = Obj("CALCULATED")
STATIC = Obj("STATIC")


class Bar(Gap, configurable.Configurable):
    """
        A bar, which can contain widgets. Note that bars can only be placed at
        the top or bottom of the screen.
    """
    defaults = [
        ("background", "#000000", "Background colour."),
        ("opacity",  1, "Bar window opacity.")
    ]

    def __init__(self, widgets, size, **config):
        """
            - widgets: A list of widget objects.
            - size: The height of the bar.
        """
        Gap.__init__(self, size)
        configurable.Configurable.__init__(self, **config)
        self.add_defaults(Bar.defaults)
        self.widgets = widgets
        self.saved_focus = None

        self.queued_draws = 0

    def _configure(self, qtile, screen):
        if not self in [screen.top, screen.bottom]:
            raise confreader.ConfigError(
                "Bars must be at the top or the bottom of the screen."
            )
        if len(filter(lambda w: w.width_type == STRETCH, self.widgets)) > 1:
            raise confreader.ConfigError("Only one STRETCH widget allowed!")

        Gap._configure(self, qtile, screen)
        self.window = window.Internal.create(
            self.qtile,
            self.x, self.y, self.width, self.height,
            self.opacity
        )

        self.drawer = drawer.Drawer(
            self.qtile,
            self.window.window.wid,
            self.width,
            self.height
        )
        self.drawer.clear(self.background)

        self.window.handle_Expose = self.handle_Expose
        self.window.handle_ButtonPress = self.handle_ButtonPress
        self.window.handle_ButtonRelease = self.handle_ButtonRelease
        qtile.windowMap[self.window.window.wid] = self.window
        self.window.unhide()

        for i in self.widgets:
            qtile.registerWidget(i)
            i._configure(qtile, self)
        self._resize(self.width, self.widgets)

        # FIXME: These should be targeted better.
        hook.subscribe.setgroup(self.draw)
        hook.subscribe.changegroup(self.draw)

    def _resize(self, width, widgets):
        stretches = [i for i in widgets if i.width_type == STRETCH]
        if stretches:
            stretchspace = width - sum(
                [i.width for i in widgets if i.width_type != STRETCH]
            )
            stretchspace = max(stretchspace, 0)
            astretch = stretchspace / len(stretches)
            for i in stretches:
                i.width = astretch
            if astretch:
                i.width += stretchspace % astretch

        offset = 0
        for i in widgets:
            i.offset = offset
            offset += i.width

    def handle_Expose(self, e):
        self.draw()

    def get_widget_in_position(self, e):
        for i in self.widgets:
            if e.event_x < i.offset + i.width:
                return i

    def handle_ButtonPress(self, e):
        widget = self.get_widget_in_position(e)
        if widget:
            widget.button_press(
                e.event_x - widget.offset,
                e.event_y,
                e.detail
            )

    def handle_ButtonRelease(self, e):
        widget = self.get_widget_in_position(e)
        if widget:
            widget.button_release(
                e.event_x - widget.offset,
                e.event_y,
                e.detail
            )

    def widget_grab_keyboard(self, widget):
        """
            A widget can call this method to grab the keyboard focus
            and receive keyboard messages. When done,
            widget_ungrab_keyboard() must be called.
        """
        self.window.handle_KeyPress = widget.handle_KeyPress
        self.saved_focus = self.qtile.currentWindow
        self.window.window.set_input_focus()

    def widget_ungrab_keyboard(self):
        """
            Removes the widget's keyboard handler.
        """
        del self.window.handle_KeyPress
        if not self.saved_focus is None:
            self.saved_focus.window.set_input_focus()

    def draw(self):
        if USE_BAR_DRAW_QUEUE:
            if self.queued_draws == 0:
                gobject.idle_add(self._actual_draw)
            self.queued_draws += 1
        else:
            self._actual_draw()

    def _actual_draw(self):
        self.queued_draws = 0
        self._resize(self.width, self.widgets)
        for i in self.widgets:
            i.draw()
        if self.widgets:
            end = i.offset + i.width
            if end < self.width:
                self.drawer.draw(end, self.width - end)

        # have to return False here to avoid getting called again
        return False

    def info(self):
        return dict(
            width=self.width,
            position=self.position,
            widgets=[i.info() for i in self.widgets],
            window=self.window.window.wid
        )

    def cmd_fake_button_press(self, screen, position, x, y, button=1):
        """
            Fake a mouse-button-press on the bar. Co-ordinates are relative
            to the top-left corner of the bar.

            :screen The integer screen offset
            :position One of "top", "bottom", "left", or "right"
        """
        class _fake:
            pass
        fake = _fake()
        fake.event_x = x
        fake.event_y = y
        fake.detail = button
        self.handle_ButtonPress(fake)

########NEW FILE########
__FILENAME__ = command
# Copyright (c) 2008, Aldo Cortesi. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import inspect
import traceback
import textwrap
import os
import ipc


class CommandError(Exception):
    pass


class CommandException(Exception):
    pass


class _SelectError(Exception):
    def __init__(self, name, sel):
        Exception.__init__(self)
        self.name = name
        self.sel = sel


SUCCESS = 0
ERROR = 1
EXCEPTION = 2

SOCKBASE = "qtilesocket.%s"


def formatSelector(lst):
    """
        Takes a list of (name, sel) tuples, and returns a formatted
        selector expression.
    """
    expr = []
    for name, sel in iter(lst):
        if expr:
            expr.append(".")
        expr.append(name)
        if sel is not None:
            expr.append("[%s]" % repr(sel))
    return "".join(expr)


class _Server(ipc.Server):
    def __init__(self, fname, qtile, conf):
        if os.path.exists(fname):
            os.unlink(fname)
        ipc.Server.__init__(self, fname, self.call)
        self.qtile = qtile
        self.widgets = {}
        for i in conf.screens:
            for j in i.gaps:
                if hasattr(j, "widgets"):
                    for w in j.widgets:
                        if w.name:
                            self.widgets[w.name] = w

    def call(self, data):
        selectors, name, args, kwargs = data
        try:
            obj = self.qtile.select(selectors)
        except _SelectError, v:
            e = formatSelector([(v.name, v.sel)])
            s = formatSelector(selectors)
            return (ERROR, "No object %s in path '%s'" % (e, s))
        cmd = obj.command(name)
        if not cmd:
            return (ERROR, "No such command.")
        self.qtile.log.info("Command: %s(%s, %s)" % (name, args, kwargs))
        try:
            return (SUCCESS, cmd(*args, **kwargs))
        except CommandError, v:
            return (ERROR, v.args[0])
        except Exception, v:
            return (EXCEPTION, traceback.format_exc())
        self.qtile.conn.flush()


class _Command:
    def __init__(self, call, selectors, name):
        """
            :command A string command name specification
            :*args Arguments to be passed to the specified command
            :*kwargs Arguments to be passed to the specified command
        """
        self.selectors = selectors
        self.name = name
        self.call = call

    def __call__(self, *args, **kwargs):
        return self.call(self.selectors, self.name, *args, **kwargs)


class _CommandTree(object):
    """
        A CommandTree a hierarchical collection of command objects.
        CommandTree objects act as containers, allowing them to be nested. The
        commands themselves appear on the object as callable attributes.
    """
    def __init__(self, call, selectors, myselector, parent):
        self.call = call
        self.selectors = selectors
        self.myselector = myselector
        self.parent = parent

    @property
    def path(self):
        s = self.selectors[:]
        if self.name:
            s += [(self.name, self.myselector)]
        return formatSelector(s)

    def __getitem__(self, select):
        if self.myselector:
            raise KeyError("No such key: %s" % select)
        return self.__class__(self.call, self.selectors, select, self)

    def __getattr__(self, name):
        nextSelector = self.selectors[:]
        if self.name:
            nextSelector.append((self.name, self.myselector))
        if name in self._contains:
            return _TreeMap[name](self.call, nextSelector, None, self)
        else:
            return _Command(self.call, nextSelector, name)


class _TLayout(_CommandTree):
    name = "layout"
    _contains = ["group", "window", "screen"]


class _TWidget(_CommandTree):
    name = "widget"
    _contains = ["bar", "screen", "group"]


class _TBar(_CommandTree):
    name = "bar"
    _contains = ["screen"]


class _TWindow(_CommandTree):
    name = "window"
    _contains = ["group", "screen", "layout"]


class _TScreen(_CommandTree):
    name = "screen"
    _contains = ["layout", "window", "bar"]


class _TGroup(_CommandTree):
    name = "group"
    _contains = ["layout", "window", "screen"]


_TreeMap = {
    "layout": _TLayout,
    "widget": _TWidget,
    "bar": _TBar,
    "window": _TWindow,
    "screen": _TScreen,
    "group": _TGroup,
}


class _CommandRoot(_CommandTree):
    name = None
    _contains = ["layout", "widget", "screen", "bar", "window", "group"]

    def __init__(self):
        """
            This method constructs the entire hierarchy of callable commands
            from a conf object.
        """
        _CommandTree.__init__(self, self.call, [], None, None)

    def __getitem__(self, select):
        raise KeyError("No such key: %s" % select)

    def call(self, selectors, name, *args, **kwargs):
        """
            This method is called for issued commands.

                :selectors A list of (name, selector) tuples.
                :name Command name.
        """
        pass


def find_sockfile(display=None):
    """
        Finds the appropriate socket file.
    """
    display = display or os.environ.get('DISPLAY') or ':0.0'
    if '.' not in display:
        display += '.0'
    cache_directory = os.path.expandvars('$XDG_CACHE_HOME')
    if cache_directory == '$XDG_CACHE_HOME':
        # if variable wasn't set
        cache_directory = os.path.expanduser("~/.cache")
    if not os.path.exists(cache_directory):
        os.makedirs(cache_directory)
    return os.path.join(cache_directory, SOCKBASE % display)


class Client(_CommandRoot):
    """
        Exposes a command tree used to communicate with a running instance of
        Qtile.
    """
    def __init__(self, fname=None):
        if not fname:
            fname = find_sockfile()
        self.client = ipc.Client(fname)
        _CommandRoot.__init__(self)

    def call(self, selectors, name, *args, **kwargs):
        state, val = self.client.call((selectors, name, args, kwargs))
        if state == SUCCESS:
            return val
        elif state == ERROR:
            raise CommandError(val)
        else:
            raise CommandException(val)


class CommandRoot(_CommandRoot):
    def __init__(self, qtile):
        self.qtile = qtile
        super(CommandRoot, self).__init__()

    def call(self, selectors, name, *args, **kwargs):
        state, val = self.qtile.server.call((selectors, name, args, kwargs))
        if state == SUCCESS:
            return val
        elif state == ERROR:
            raise CommandError(val)
        else:
            raise CommandException(val)


class _Call:
    def __init__(self, selectors, name, *args, **kwargs):
        """
            :command A string command name specification
            :*args Arguments to be passed to the specified command
            :*kwargs Arguments to be passed to the specified command
        """
        self.selectors = selectors
        self.name = name
        self.args = args
        self.kwargs = kwargs
        # Conditionals
        self.layout = None

    def when(self, layout=None, when_floating=True):
        self.layout = layout
        self.when_floating = when_floating
        return self

    def check(self, q):
        if self.layout:
            if self.layout == 'floating':
                if q.currentWindow.floating:
                    return True
                return False
            if q.currentLayout.name != self.layout:
                return False
            if q.currentWindow and q.currentWindow.floating \
                and not self.when_floating:
                return False
        return True


class _LazyTree(_CommandRoot):
    def call(self, selectors, name, *args, **kwargs):
        return _Call(selectors, name, *args, **kwargs)

lazy = _LazyTree()


class CommandObject(object):
    """
        Base class for objects that expose commands. Each command should be a
        method named cmd_X, where X is the command name.
    """
    def select(self, selectors):
        if not selectors:
            return self
        name, sel = selectors[0]
        selectors = selectors[1:]

        root, items = self.items(name)
        if (root is False and sel is None) or \
                (items is None and sel is not None) or \
                (items is not None and sel and sel not in items):
            raise _SelectError(name, sel)

        obj = self._select(name, sel)
        if obj is None:
            raise _SelectError(name, sel)
        return obj.select(selectors)

    def items(self, name):
        """
            Returns a list of contained items for this name.
        """
        ret = self._items(name)
        if ret is None:
            # Not finding information for a particular item class is OK here;
            # we don't expect layouts to have a window, etc.
            return ([], [])
        return ret

    def _items(self, name):
        """
            Return (root, items) tuple for the specified item class, with:

                root: True if this class accepts a "naked" specification
                without an item specification (i.e. "layout"), and False if it
                does not.

                items is a list of contained items, or None if this object is
                not a valid container.

            Return None if name is not a valid item class.
        """
        raise NotImplementedError

    def _select(self, name, sel, selectors):
        """
            Return a selected object, or None if no such object exists.

            This method is called with the following guarantees:
                - name is a valid selector class for this item
                - sel is a valid selector for this item
                - the name, sel tuple is not an "impossible" combination (e.g.
                  a selector is specified when this is not a containment
                  object).
        """
        raise NotImplementedError

    def command(self, name):
        return getattr(self, "cmd_" + name, None)

    def commands(self):
        lst = []
        for i in dir(self):
            if i.startswith("cmd_"):
                lst.append(i[4:])
        return lst

    def cmd_commands(self):
        """
            Returns a list of possible commands for this object.
            Used by __qsh__ for command completion and online help.
        """
        return self.commands()

    def cmd_items(self, name):
        """
            Returns a list of contained items for the specified name. Used by
            __qsh__ to allow navigation of the object graph.
        """
        return self.items(name)

    def docSig(self, name):
        args, varargs, varkw, defaults = inspect.getargspec(self.command(name))
        if args and args[0] == "self":
            args = args[1:]
        return name + inspect.formatargspec(args, varargs, varkw, defaults)

    def docText(self, name):
        return textwrap.dedent(self.command(name).__doc__ or "")

    def doc(self, name):
        spec = self.docSig(name)
        htext = self.docText(name)
        htext = "\n".join([i for i in htext.splitlines()])
        return spec + htext

    def cmd_doc(self, name):
        """
            Returns the documentation for a specified command name. Used by
            __qsh__ to provide online help.
        """
        if name in self.commands():
            return self.doc(name)
        else:
            raise CommandError("No such command: %s" % name)

########NEW FILE########
__FILENAME__ = config
import command
import hook
import sys
import utils
import xcbq


class Key:
    """
        Defines a keybinding.
    """
    def __init__(self, modifiers, key, *commands):
        """
            - modifiers: A list of modifier specifications. Modifier
            specifications are one of: "shift", "lock", "control", "mod1",
            "mod2", "mod3", "mod4", "mod5".

            - key: A key specification, e.g. "a", "Tab", "Return", "space".

            - *commands: A list of lazy command objects generated with the
            command.lazy helper. If multiple Call objects are specified, they
            are run in sequence.
        """
        self.modifiers = modifiers
        self.key = key
        self.commands = commands
        if key not in xcbq.keysyms:
            raise utils.QtileError("Unknown key: %s" % key)
        self.keysym = xcbq.keysyms[key]
        try:
            self.modmask = utils.translateMasks(self.modifiers)
        except KeyError, v:
            raise utils.QtileError(v)

    def __repr__(self):
        return "Key(%s, %s)" % (self.modifiers, self.key)


class Drag(object):
    """
        Defines binding of a mouse to some dragging action

        On each motion event command is executed
        with two extra parameters added
        x and y offset from previous move

        It focuses clicked window by default
        If you want to prevent it pass focus=None as an argument
    """
    def __init__(self, modifiers, button, *commands, **kwargs):
        self.start = kwargs.get("start", None)
        self.focus = kwargs.get("focus", "before")
        self.modifiers = modifiers
        self.button = button
        self.commands = commands
        try:
            self.button_code = int(self.button.replace('Button', ''))
            self.modmask = utils.translateMasks(self.modifiers)
        except KeyError, v:
            raise utils.QtileError(v)

    def __repr__(self):
        return "Drag(%s, %s)" % (self.modifiers, self.button)


class Click(object):
    """
        Defines binding of a mouse click

        It focuses clicked window by default
        If you want to prevent it pass focus=None as an argument
    """
    def __init__(self, modifiers, button, *commands, **kwargs):
        self.focus = kwargs.get("focus", "before")
        self.modifiers = modifiers
        self.button = button
        self.commands = commands
        try:
            self.button_code = int(self.button.replace('Button', ''))
            self.modmask = utils.translateMasks(self.modifiers)
        except KeyError, v:
            raise utils.QtileError(v)

    def __repr__(self):
        return "Click(%s, %s)" % (self.modifiers, self.button)


class ScreenRect(object):

    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = width
        self.height = height

    def __repr__(self):
        return '<%s %d,%d %d,%d>' % (
            self.__class__.__name__,
            self.x, self.y,
            self.width, self.height
        )

    def hsplit(self, columnwidth):
        assert columnwidth > 0
        assert columnwidth < self.width
        return (
            self.__class__(self.x, self.y, columnwidth, self.height),
            self.__class__(
                self.x + columnwidth, self.y,
                self.width - columnwidth, self.height
            )
        )

    def vsplit(self, rowheight):
        assert rowheight > 0
        assert rowheight < self.height
        return (
            self.__class__(self.x, self.y, self.width, rowheight),
            self.__class__(
                self.x, self.y + rowheight,
                self.width, self.height - rowheight
            )
        )


class Screen(command.CommandObject):
    """
        A physical screen, and its associated paraphernalia.
    """
    group = None
    previous_group = None

    def __init__(self, top=None, bottom=None, left=None, right=None,
                 x=None, y=None, width=None, height=None):
        """
            - top, bottom, left, right: Instances of bar objects, or None.

            Note that bar.Bar objects can only be placed at the top or the
            bottom of the screen (bar.Gap objects can be placed anywhere).

            x,y,width and height aren't specified usually unless you are
            using 'fake screens'.
        """
        self.top = top
        self.bottom = bottom
        self.left = left
        self.right = right
        self.qtile = None
        self.index = None
        # x position of upper left corner can be > 0
        # if one screen is "right" of the other
        self.x = x
        self.y = y
        self.width = width
        self.height = height

    def _configure(self, qtile, index, x, y, width, height, group):
        self.qtile = qtile
        self.index = index
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.setGroup(group)
        for i in self.gaps:
            i._configure(qtile, self)

    @property
    def gaps(self):
        lst = []
        lst.extend([
            i for i in [self.top, self.bottom, self.left, self.right] if i
        ])
        return lst

    @property
    def dx(self):
        return self.x + self.left.size if self.left else self.x

    @property
    def dy(self):
        return self.y + self.top.size if self.top else self.y

    @property
    def dwidth(self):
        val = self.width
        if self.left:
            val -= self.left.size
        if self.right:
            val -= self.right.size
        return val

    @property
    def dheight(self):
        val = self.height
        if self.top:
            val -= self.top.size
        if self.bottom:
            val -= self.bottom.size
        return val

    def get_rect(self):
        return ScreenRect(self.dx, self.dy, self.dwidth, self.dheight)

    def setGroup(self, new_group):
        """
        Put group on this screen
        """
        if new_group.screen == self:
            return

        self.previous_group = self.group

        if new_group is None:
            return

        if new_group.screen:
            # g1 <-> s1 (self)
            # g2 (new_group) <-> s2 to
            # g1 <-> s2
            # g2 <-> s1
            g1 = self.group
            s1 = self
            g2 = new_group
            s2 = new_group.screen

            s2.group = g1
            g1._setScreen(s2)
            s1.group = g2
            g2._setScreen(s1)
        else:
            old_group = self.group
            self.group = new_group

            # display clients of the new group and then hide from old group
            # to remove the screen flickering
            new_group._setScreen(self)

            if old_group is not None:
                old_group._setScreen(None)

        hook.fire("setgroup")
        hook.fire("focus_change")
        hook.fire(
            "layout_change",
            self.group.layouts[self.group.currentLayout],
            self.group
        )

    def _items(self, name):
        if name == "layout":
            return (True, range(len(self.group.layouts)))
        elif name == "window":
            return (True, [i.window.wid for i in self.group.windows])
        elif name == "bar":
            return (False, [x.position for x in self.gaps])

    def _select(self, name, sel):
        if name == "layout":
            if sel is None:
                return self.group.layout
            else:
                return utils.lget(self.group.layouts, sel)
        elif name == "window":
            if sel is None:
                return self.group.currentWindow
            else:
                for i in self.group.windows:
                    if i.window.wid == sel:
                        return i
        elif name == "bar":
            return getattr(self, sel)

    def resize(self, x=None, y=None, w=None, h=None):
        x = x or self.x
        y = y or self.y
        w = w or self.width
        h = h or self.height
        self._configure(self.qtile, self.index, x, y, w, h, self.group)
        for bar in [self.top, self.bottom, self.left, self.right]:
            if bar:
                bar.draw()
        self.group.layoutAll()

    def cmd_info(self):
        """
            Returns a dictionary of info for this screen.
        """
        return dict(
            index=self.index,
            width=self.width,
            height=self.height,
            x=self.x,
            y=self.y
        )

    def cmd_resize(self, x=None, y=None, w=None, h=None):
        """
            Resize the screen.
        """
        self.resize(x, y, w, h)

    def cmd_nextgroup(self, skip_empty=False, skip_managed=False):
        """
            Switch to the next group.
        """
        n = self.group.nextGroup(skip_empty, skip_managed)
        self.setGroup(n)
        return n.name

    def cmd_prevgroup(self, skip_empty=False, skip_managed=False):
        """
            Switch to the previous group.
        """
        n = self.group.prevGroup(skip_empty, skip_managed)
        self.setGroup(n)
        return n.name

    def cmd_togglegroup(self, groupName=None):
        """
            Switch to the selected group or to the previously active one.
        """
        group = self.qtile.groupMap.get(groupName)
        if group in (self.group, None):
            group = self.previous_group
        self.setGroup(group)


class Group(object):
    """
    Represents a "dynamic" group. These groups can spawn apps, only allow
    certain Matched windows to be on them, hide when they're not in use, etc.
    """
    def __init__(self, name, matches=None, exclusive=False,
                 spawn=None, layout=None, layouts=None, persist=True, init=True,
                 layout_opts=None, screen_affinity=None, position=sys.maxint):
        """
        :param name: the name of this group
        :type name: string
        :param matches: list of ``Match`` objects whose  windows will be assigned to this group
        :type matches: default ``None``
        :param exclusive: when other apps are started in this group, should we allow them here or not?
        :type exclusive: boolean
        :param spawn: this will be ``exec()`` d when the group is created
        :type spawn: string
        :param layout: the default layout for this group (e.g. 'max' or 'stack')
        :type layout: string
        :param layouts: the group layouts list overriding global layouts
        :type layouts: list
        :param persist: should this group stay alive with no member windows?
        :type persist: boolean
        :param init: is this group alive when qtile starts?
        :type init: boolean
        :param position: group position
        :type position: int

        """
        self.name = name
        self.exclusive = exclusive
        self.spawn = spawn
        self.layout = layout
        self.layouts = layouts or []
        self.persist = persist
        self.init = init
        self.matches = matches or []
        self.layout_opts = layout_opts or {}

        self.screen_affinity = screen_affinity
        self.position = position


class Match(object):
    """
        Match for dynamic groups
        It can match by title, class or role.
    """
    def __init__(self, title=None, wm_class=None, role=None, wm_type=None,
                 wm_instance_class=None, net_wm_pid=None):
        """

        ``Match`` supports both regular expression objects (i.e. the result of
        ``re.compile()``) or strings (match as a "include" match). If a window
        matches any of the things in any of the lists, it is considered a
        match.

        :param title: things to match against the title
        :param wm_class: things to match against the second string in
                         WM_CLASS atom
        :param role: things to match against the WM_ROLE atom
        :param wm_type: things to match against the WM_TYPE atom
        :param wm_instance_class: things to match against the first string in
               WM_CLASS atom
        :param net_wm_pid: things to match against the _NET_WM_PID atom
              (only int allowed in this rule)
        """
        if not title:
            title = []
        if not wm_class:
            wm_class = []
        if not role:
            role = []
        if not wm_type:
            wm_type = []
        if not wm_instance_class:
            wm_instance_class = []
        if not net_wm_pid:
            net_wm_pid = []

        for rule in net_wm_pid:
            if not isinstance(rule, int):
                error = 'Invalid rule for net_wm_pid: "%s" '\
                        'only ints allowed' % rule
                raise utils.QtileError(error)

        self._rules = [('title', t) for t in title]
        self._rules += [('wm_class', w) for w in wm_class]
        self._rules += [('role', r) for r in role]
        self._rules += [('wm_type', r) for r in wm_type]
        self._rules += [('wm_instance_class', w) for w in wm_instance_class]
        self._rules += [('net_wm_pid', w) for w in net_wm_pid]

    def compare(self, client):
        for _type, rule in self._rules:
            if _type == "net_wm_pid":
                match_func = lambda value: rule == value
            else:
                match_func = getattr(rule, 'match', None) or \
                    getattr(rule, 'count')

            if _type == 'title':
                value = client.name
            elif _type == 'wm_class':
                value = None
                _value = client.window.get_wm_class()
                if _value and len(_value) > 1:
                    value = _value[1]
            elif _type == 'wm_instance_class':
                value = client.window.get_wm_class()
                if value:
                    value = value[0]
            elif _type == 'wm_type':
                value = client.window.get_wm_type()
            elif _type == 'net_wm_pid':
                value = client.window.get_net_wm_pid()
            else:
                value = client.window.get_wm_window_role()

            if value and match_func(value):
                return True
        return False

    def map(self, callback, clients):
        """ Apply callback to each client that matches this Match """
        for c in clients:
            if self.compare(c):
                callback(c)


class Rule(object):
    """
        A Rule contains a Match object, and a specification about what to do
        when that object is matched.
    """
    def __init__(self, match, group=None, float=False, intrusive=False,
                 break_on_match=True):
        """
        :param match: ``Match`` object associated with this ``Rule``
        :param float: auto float this window?
        :param intrusive: override the group's exclusive setting?
        :param break_on_match: Should we stop applying rules if this rule is
               matched?
        """
        self.match = match
        self.group = group
        self.float = float
        self.intrusive = intrusive
        self.break_on_match = break_on_match

    def matches(self, w):
        return self.match.compare(w)

########NEW FILE########
__FILENAME__ = configurable
# Copyright (c) 2012, Tycho Andersen. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


class Configurable(object):
    global_defaults = {}

    def __init__(self, **config):
        self._widget_defaults = {}
        self._user_config = config

    def add_defaults(self, defaults):
        """
            Add defaults to this object, overwriting any which already exist.
        """
        self._widget_defaults.update({d[0]: d[1] for d in defaults})

    def __getattr__(self, name):
        found, value = self._find_default(name)
        if found:
            setattr(self, name, value)
            return value
        else:
            raise AttributeError("no attribute: %s" % name)

    def _find_default(self, name):
        """Returns a tuple (found, value)"""
        defaults = self._widget_defaults.copy()
        defaults.update(self.global_defaults)
        defaults.update(self._user_config)
        if name in defaults:
            return (True, defaults[name])
        else:
            return (False, None)


class ExtraFallback(object):
    """
        Adds another layer of fallback to attributes - to look up
        a different attribute name
    """

    def __init__(self, name, fallback):
        self.name = name
        self.hidden_attribute = "_" + name
        self.fallback = fallback

    def __get__(self, instance, owner=None):
        retval = getattr(instance, self.hidden_attribute, None)

        if not retval:
            _found, retval = Configurable._find_default(instance, self.name)

        if not retval:
            retval = getattr(instance, self.fallback, None)

        return retval

    def __set__(self, instance, value):
        """Set own value to a hidden attribute of the object"""
        setattr(instance, self.hidden_attribute, value)

########NEW FILE########
__FILENAME__ = confreader
#!/usr/bin/env python
# coding: utf-8
#
# Copyright (c) 2008, Aldo Cortesi <aldo@corte.si>
# Copyright (c) 2011, Andrew Grigorev <andrew@ei-grad.ru>
#
# All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import os
import sys
import utils
import traceback


class ConfigError(Exception):
    pass


class File(object):
    def __init__(self, fname=None, is_restart=False):
        if not fname:
            config_directory = os.path.expandvars('$XDG_CONFIG_HOME')
            if config_directory == '$XDG_CONFIG_HOME':
                # if variable wasn't set
                config_directory = os.path.expanduser("~/.config")
            fname = os.path.join(config_directory, "qtile", "config.py")
        elif fname == "default":
            fname = utils.data.path("resources/default_config.py")

        self.fname = fname

        if os.path.isfile(fname):
            try:
                sys.path.insert(0, os.path.dirname(self.fname))
                config = __import__(os.path.basename(self.fname)[:-3])
            except Exception, v:
                # On restart, user potentially has some windows open, but they
                # screwed up their config. So as not to lose their apps, we
                # just load the default config here.
                if is_restart:
                    traceback.print_exc()
                    config = None
                else:
                    tb = traceback.format_exc()
                    raise ConfigError(str(v) + "\n\n" + tb)
        else:
            config = None

        # if you add something here, be sure to add a reasonable default value
        # to resources/default_config.py
        config_options = [
            "keys",
            "mouse",
            "groups",
            "dgroups_key_binder",
            "dgroups_app_rules",
            "follow_mouse_focus",
            "cursor_warp",
            "layouts",
            "floating_layout",
            "screens",
            "main",
            "auto_fullscreen",
            "widget_defaults",
            "bring_front_click",
        ]

        # We delay importing here to avoid a circular import issue when
        # testing.
        from resources import default_config
        for option in config_options:
            if hasattr(config, option):
                v = getattr(config, option)
            else:
                v = getattr(default_config, option)
            if not hasattr(self, option):
                setattr(self, option, v)

########NEW FILE########
__FILENAME__ = dgroups
import itertools
import gobject

import libqtile.hook
from libqtile.config import Key
from libqtile.command import lazy
from libqtile.config import Group
from libqtile.config import Rule

def simple_key_binder(mod, keynames=None):
    """
        Bind keys to mod+group position or to the keys specified as
        second argument.
    """
    def func(dgroup):
        # unbind all
        for key in dgroup.keys[:]:
            dgroup.qtile.unmapKey(key)
            dgroup.keys.remove(key)

        if keynames:
            keys = keynames
        else:
            # keys 1 to 9 and 0
            keys = map(str, range(1, 10) + [0])

        # bind all keys
        for keyname, group in zip(keys, dgroup.qtile.groups):
            name = group.name
            key = Key([mod], keyname, lazy.group[name].toscreen())
            key_s = Key([mod, "shift"], keyname, lazy.window.togroup(name))
            key_c = Key(
                [mod, "control"],
                keyname,
                lazy.group.switch_groups(name)
            )
            dgroup.keys.append(key)
            dgroup.keys.append(key_s)
            dgroup.keys.append(key_c)
            dgroup.qtile.mapKey(key)
            dgroup.qtile.mapKey(key_s)
            dgroup.qtile.mapKey(key_c)

    return func


class DGroups(object):
    """ Dynamic Groups """
    def __init__(self, qtile, dgroups, key_binder=None, delay=1):
        self.qtile = qtile

        self.groups = dgroups
        self.groupMap = {}

        self.rules = []
        self.rules_map = {}
        self.last_rule_id = 0

        for rule in getattr(qtile.config, 'dgroups_app_rules', []):
            self.add_rule(rule)

        self.keys = []

        self.key_binder = key_binder

        self._setup_hooks()
        self._setup_groups()

        self.delay = delay

        self.timeout = {}

    def add_rule(self, rule, last=True):
        self.rules_map[self.last_rule_id] = rule
        if last:
            self.rules.append(rule)
        else:
            self.rules.insert(0, rule)
        self.last_rule_id += 1
        return self.last_rule_id

    def remove_rule(self, rule_id=None):
        rule = self.rules[rule_id]
        self.rules.remove(rule)
        del self.rules[rule_id]

    def add_dgroup(self, group, start=False):
        self.groupMap[group.name] = group
        rules = [Rule(m, group=group.name) for m in group.matches]
        self.rules.extend(rules)
        if start:
            self.qtile.addGroup(group.name, group.layout, group.layouts)

    def _setup_groups(self):
        for group in self.groups:
            self.add_dgroup(group, group.init)

            if group.spawn and not self.qtile.no_spawn:
                self.qtile.cmd_spawn(group.spawn)

    def _setup_hooks(self):
        libqtile.hook.subscribe.addgroup(self._addgroup)
        libqtile.hook.subscribe.client_new(self._add)
        libqtile.hook.subscribe.client_killed(self._del)
        if self.key_binder:
            libqtile.hook.subscribe.setgroup(
                lambda: self.key_binder(self)
            )
            libqtile.hook.subscribe.changegroup(
                lambda: self.key_binder(self)
            )

    def _addgroup(self, qtile, group_name):
        if group_name not in self.groupMap:
            self.add_dgroup(Group(group_name, persist=False))

    def _add(self, client):
        if client in self.timeout:
            self.qtile.log.info('Remove dgroup source')
            gobject.source_remove(self.timeout[client])
            del(self.timeout[client])

        # ignore static windows
        if client.defunct:
            return

        group_set = False
        intrusive = False

        for rule in self.rules:
            # Matching Rules
            if rule.matches(client):
                if rule.group:
                    try:
                        layout = self.groupMap[rule.group].layout
                    except KeyError:
                        layout = None
                    try:
                        layouts = self.groupMap[rule.group].layouts
                    except KeyError:
                        layouts = None
                    group_added = self.qtile.addGroup(rule.group, layout, layouts)
                    client.togroup(rule.group)

                    group_set = True

                    group_obj = self.qtile.groupMap[rule.group]
                    group = self.groupMap.get(rule.group)
                    if group and group_added:
                        for k, v in group.layout_opts.iteritems():
                            if callable(v):
                                v(group_obj.layout)
                            else:
                                setattr(group_obj.layout, k, v)
                        affinity = group.screen_affinity
                        if affinity and len(self.qtile.screens) > affinity:
                            self.qtile.screens[affinity].setGroup(group_obj)

                if rule.float:
                    client.enablefloating()

                if rule.intrusive:
                    intrusive = rule.intrusive

                if rule.break_on_match:
                    break

        # If app doesn't have a group
        if not group_set:
            current_group = self.qtile.currentGroup.name
            if current_group in self.groupMap and \
                    self.groupMap[current_group].exclusive and \
                    not intrusive:

                wm_class = client.window.get_wm_class()

                if wm_class:
                    if len(wm_class) > 1:
                        wm_class = wm_class[1]
                    else:
                        wm_class = wm_class[0]

                    group_name = wm_class
                else:
                    group_name = client.name or 'Unnamed'

                self.add_dgroup(Group(group_name, persist=False), start=True)
                client.togroup(group_name)
        self.sort_groups()

    def sort_groups(self):
        self.qtile.groups.sort(key=lambda g: self.groupMap[g.name].position)
        libqtile.hook.fire("setgroup")

    def _del(self, client):
        group = client.group

        def delete_client():
            # Delete group if empty and dont persist
            if group and group.name in self.groupMap and \
                    not self.groupMap[group.name].persist and \
                    len(group.windows) <= 0:
                self.qtile.delGroup(group.name)
                self.sort_groups()

        # Wait the delay until really delete the group
        self.qtile.log.info('Add dgroup timer')
        self.timeout[client] = gobject.timeout_add_seconds(
            self.delay,
            delete_client
        )

########NEW FILE########
__FILENAME__ = drawer
import collections
import utils
import math
import pangocairo
import cairo
import pango
import xcb.xproto


class TextLayout(object):
    def __init__(self, drawer, text, colour, font_family, font_size,
                 font_shadow, wrap=True, markup=False):
        self.drawer, self.colour = drawer, colour
        layout = drawer.ctx.create_layout()
        layout.set_alignment(pango.ALIGN_CENTER)
        if not wrap:  # pango wraps by default
            layout.set_ellipsize(pango.ELLIPSIZE_END)
        desc = pango.FontDescription()
        desc.set_family(font_family)
        desc.set_absolute_size(font_size * pango.SCALE)
        layout.set_font_description(desc)
        self.font_shadow = font_shadow
        self.layout = layout
        self.markup = markup
        self.text = text
        self._width = None

    @property
    def text(self):
        return self.layout.get_text()

    @text.setter
    def text(self, value):
        if self.markup:
            attrlist, value, accel_char = pango.parse_markup(value)
            self.layout.set_attributes(attrlist)
        return self.layout.set_text(utils.scrub_to_utf8(value))

    @property
    def width(self):
        if self._width is not None:
            return self._width
        else:
            return self.layout.get_pixel_size()[0]

    @width.setter
    def width(self, value):
        self._width = value
        self.layout.set_width(value * pango.SCALE)

    @width.deleter
    def width(self):
        self._width = None
        self.layout.set_width(-1)

    @property
    def height(self):
        return self.layout.get_pixel_size()[1]

    def fontdescription(self):
        return self.layout.get_font_description()

    @property
    def font_family(self):
        d = self.fontdescription()
        return d.get_family()

    @font_family.setter
    def font_family(self, font):
        d = self.fontdescription()
        d.set_family(font)
        self.layout.set_font_description(d)

    @property
    def font_size(self):
        d = self.fontdescription()
        return d.get_size()

    @font_size.setter
    def font_size(self, size):
        d = self.fontdescription()
        d.set_size(size)
        d.set_absolute_size(size * pango.SCALE)
        self.layout.set_font_description(d)

    def draw(self, x, y):
        if self.font_shadow is not None:
            self.drawer.set_source_rgb(self.font_shadow)
            self.drawer.ctx.move_to(x+1, y+1)
            self.drawer.ctx.show_layout(self.layout)

        self.drawer.set_source_rgb(self.colour)
        self.drawer.ctx.move_to(x, y)
        self.drawer.ctx.show_layout(self.layout)

    def framed(self, border_width, border_color, pad_x, pad_y):
        return TextFrame(self, border_width, border_color, pad_x, pad_y)


class TextFrame:
    def __init__(self, layout, border_width, border_color, pad_x, pad_y):
        self.layout = layout
        self.border_width = border_width
        self.border_color = border_color
        self.drawer = self.layout.drawer

        if isinstance(pad_x, collections.Iterable):
            self.pad_left = pad_x[0]
            self.pad_right = pad_x[1]
        else:
            self.pad_left = self.pad_right = pad_x

        if isinstance(pad_y, collections.Iterable):
            self.pad_top = pad_y[0]
            self.pad_bottom = pad_y[1]
        else:
            self.pad_top = self.pad_bottom = pad_y

    def draw(self, x, y, rounded=True):
        self.drawer.set_source_rgb(self.border_color)
        opts = [
            x, y,
            self.layout.width + self.pad_left + self.pad_right,
            self.layout.height + self.pad_top + self.pad_bottom,
            self.border_width
        ]
        if rounded:
            self.drawer.rounded_rectangle(*opts)
        else:
            self.drawer.rectangle(*opts)
        self.drawer.ctx.stroke()
        self.layout.draw(
            x + self.pad_left,
            y + self.pad_top
        )

    def draw_fill(self, x, y, rounded=True):
        self.drawer.set_source_rgb(self.border_color)
        opts = [
            x, y,
            self.layout.width + self.pad_left + self.pad_right,
            self.layout.height + self.pad_top + self.pad_bottom,
            self.border_width
        ]
        if rounded:
            self.drawer.rounded_fillrect(*opts)
        else:
            self.drawer.fillrect(*opts)
        self.layout.draw(
            x + self.pad_left,
            y + self.pad_top
        )

    @property
    def height(self):
        return self.layout.height + self.pad_top + self.pad_bottom

    @property
    def width(self):
        return self.layout.width + self.pad_left + self.pad_right


class Drawer:
    """
        A helper class for drawing and text layout.

        We have a drawer object for each widget in the bar. The underlying
        surface is a pixmap with the same size as the bar itself. We draw to
        the pixmap starting at offset 0, 0, and when the time comes to display
        to the window, we copy the appropriate portion of the pixmap onto the
        window.
    """
    def __init__(self, qtile, wid, width, height):
        self.qtile = qtile
        self.wid, self.width, self.height = wid, width, height

        self.pixmap = self.qtile.conn.conn.generate_id()
        self.gc = self.qtile.conn.conn.generate_id()

        self.qtile.conn.conn.core.CreatePixmap(
            self.qtile.conn.default_screen.root_depth,
            self.pixmap,
            self.wid,
            self.width,
            self.height
        )
        self.qtile.conn.conn.core.CreateGC(
            self.gc,
            self.wid,
            xcb.xproto.GC.Foreground | xcb.xproto.GC.Background,
            [
                self.qtile.conn.default_screen.black_pixel,
                self.qtile.conn.default_screen.white_pixel
            ]
        )
        self.surface = cairo.XCBSurface(
            qtile.conn.conn,
            self.pixmap,
            self.find_root_visual(),
            self.width,
            self.height,
        )
        self.ctx = self.new_ctx()
        self.clear((0, 0, 1))

    def _rounded_rect(self, x, y, width, height, linewidth):
        aspect = 1.0
        corner_radius = height / 10.0
        radius = corner_radius / aspect
        degrees = math.pi / 180.0

        self.ctx.new_sub_path()

        delta = radius + linewidth / 2
        self.ctx.arc(x + width - delta, y + delta, radius,
                     -90 * degrees, 0 * degrees)
        self.ctx.arc(x + width - delta, y + height - delta,
                     radius, 0 * degrees, 90 * degrees)
        self.ctx.arc(x + delta, y + height - delta, radius,
                     90 * degrees, 180 * degrees)
        self.ctx.arc(x + delta, y + delta, radius,
                     180 * degrees, 270 * degrees)
        self.ctx.close_path()

    def rounded_rectangle(self, x, y, width, height, linewidth):
        self._rounded_rect(x, y, width, height, linewidth)
        self.ctx.set_line_width(linewidth)
        self.ctx.stroke()

    def rounded_fillrect(self, x, y, width, height, linewidth):
        self._rounded_rect(x, y, width, height, linewidth)
        self.ctx.fill()

    def rectangle(self, x, y, width, height, linewidth=2):
        self.ctx.set_line_width(linewidth)
        self.ctx.rectangle(x, y, width, height)
        self.ctx.stroke()

    def fillrect(self, x, y, width, height, linewidth=2):
        self.ctx.set_line_width(linewidth)
        self.ctx.rectangle(x, y, width, height)
        self.ctx.fill()
        self.ctx.stroke()

    def draw(self, offset, width):
        """
            offset: the X offset to start drawing at.
            width: the portion of the canvas to draw at the starting point.
        """
        self.qtile.conn.conn.core.CopyArea(
            self.pixmap,
            self.wid,
            self.gc,
            0, 0,  # srcx, srcy
            offset, 0,  # dstx, dsty
            width, self.height
        )

    def find_root_visual(self):
        for i in self.qtile.conn.default_screen.allowed_depths:
            for v in i.visuals:
                if v.visual_id == self.qtile.conn.default_screen.root_visual:
                    return v

    def new_ctx(self):
        return pangocairo.CairoContext(cairo.Context(self.surface))

    def set_source_rgb(self, colour):
        if type(colour) == list:
            linear = cairo.LinearGradient(0.0, 0.0, 0.0, self.height)
            c1 = utils.rgb(colour[0])
            c2 = utils.rgb(colour[1])
            if len(c1) < 4:
                c1[3] = 1
            if len(c2) < 4:
                c2[3] = 1
            linear.add_color_stop_rgba(0.0, c1[0], c1[1], c1[2], c1[3])
            linear.add_color_stop_rgba(1.0, c2[0], c2[1], c2[2], c2[3])
            self.ctx.set_source(linear)
        else:
            self.ctx.set_source_rgba(*utils.rgb(colour))

    def clear(self, colour):
        if type(colour) == list:
            linear = cairo.LinearGradient(0.0, 0.0, 0.0, self.height)
            c1 = utils.rgb(colour[0])
            c2 = utils.rgb(colour[1])
            if len(c1) < 4:
                c1[3] = 1
            if len(c2) < 4:
                c2[3] = 1
            linear.add_color_stop_rgba(0.0, c1[0], c1[1], c1[2], c1[3])
            linear.add_color_stop_rgba(1.0, c2[0], c2[1], c2[2], c2[3])
            self.ctx.set_source(linear)
        else:
            self.set_source_rgb(colour)
        self.ctx.rectangle(0, 0, self.width, self.height)
        self.ctx.fill()
        self.ctx.stroke()

    def textlayout(self, text, colour, font_family, font_size, font_shadow,
                   markup=False, **kw):
        """
            Get a text layout.

            NB: the return value of this function should be saved, and reused
            to avoid a huge memory leak in the pygtk bindings. Once this has
            been repaired, we can make the semantics easier.

            https://bugzilla.gnome.org/show_bug.cgi?id=625287
        """
        return TextLayout(self, text, colour, font_family, font_size,
                          font_shadow, markup=markup, **kw)

    _sizelayout = None

    def max_layout_size(self, texts, font_family, font_size):
        # FIXME: This is incredibly clumsy, to avoid a memory leak in pygtk.
        # See comment on textlayout() for details.
        if not self._sizelayout:
            self._sizelayout = self.textlayout(
                "", "ffffff", font_family, font_size, None)
        widths, heights = [], []
        self._sizelayout.font_family = font_family
        self._sizelayout.font_size = font_size
        for i in texts:
            self._sizelayout.text = i
            widths.append(self._sizelayout.width)
            heights.append(self._sizelayout.height)
        return max(widths), max(heights)

    # Old text layout functions, to be deprectated.
    def set_font(self, fontface, size, antialias=True):
        self.ctx.select_font_face(fontface)
        self.ctx.set_font_size(size)
        fo = self.ctx.get_font_options()
        fo.set_antialias(cairo.ANTIALIAS_SUBPIXEL)

    def text_extents(self, text):
        return self.ctx.text_extents(utils.scrub_to_utf8(text))

    def font_extents(self):
        return self.ctx.font_extents()

    def fit_fontsize(self, heightlimit):
        """
            Try to find a maximum font size that fits any strings within the
            height.
        """
        self.ctx.set_font_size(heightlimit)
        asc, desc, height, _, _ = self.font_extents()
        self.ctx.set_font_size(
            int(heightlimit * (heightlimit / float(height))))
        return self.font_extents()

    def fit_text(self, strings, heightlimit):
        """
            Try to find a maximum font size that fits all strings within the
            height.
        """
        self.ctx.set_font_size(heightlimit)
        _, _, _, maxheight, _, _ = self.ctx.text_extents("".join(strings))
        if not maxheight:
            return 0, 0
        self.ctx.set_font_size(
            int(heightlimit * (heightlimit / float(maxheight))))
        maxwidth, maxheight = 0, 0
        for i in strings:
            _, _, x, y, _, _ = self.ctx.text_extents(i)
            maxwidth = max(maxwidth, x)
            maxheight = max(maxheight, y)
        return maxwidth, maxheight

    def draw_vbar(self, color, x, y1, y2, linewidth=1):
        self.set_source_rgb(color)
        self.ctx.move_to(x, y1)
        self.ctx.line_to(x, y2)
        self.ctx.set_line_width(linewidth)
        self.ctx.stroke()

    def draw_hbar(self, color, x1, x2, y, linewidth=1):
        self.set_source_rgb(color)
        self.ctx.move_to(x1, y)
        self.ctx.line_to(x2, y)
        self.ctx.set_line_width(linewidth)
        self.ctx.stroke()

########NEW FILE########
__FILENAME__ = group
import command
import hook
import window
import utils
import contextlib
import xcb
import xcb.xproto


class _Group(command.CommandObject):
    """
        A group is a container for a bunch of windows, analogous to workspaces
        in other window managers. Each client window managed by the window
        manager belongs to exactly one group.
    """
    def __init__(self, name, layout=None):
        self.name = name
        self.customLayout = layout  # will be set on _configure
        self.windows = set()
        self.qtile = None
        self.layouts = []
        self.floating_layout = None
        self.currentWindow = None
        self.screen = None
        self.currentLayout = None

    def _configure(self, layouts, floating_layout, qtile):
        self.screen = None
        self.currentLayout = 0
        self.currentWindow = None
        self.windows = set()
        self.qtile = qtile
        self.layouts = [i.clone(self) for i in layouts]
        self.floating_layout = floating_layout.clone(self)
        if self.customLayout is not None:
            self.layout = self.customLayout
            self.customLayout = None

    @property
    def layout(self):
        return self.layouts[self.currentLayout]

    @layout.setter
    def layout(self, layout):
        """
            "layout" is a string with matching the name of a Layout object.
        """
        for index, obj in enumerate(self.layouts):
            if obj.name == layout:
                self.currentLayout = index
                hook.fire(
                    "layout_change",
                    self.layouts[self.currentLayout],
                    self
                )
                self.layoutAll()
                return
        raise ValueError("No such layout: %s" % layout)

    def nextLayout(self):
        self.layout.hide()
        self.currentLayout = (self.currentLayout + 1) % (len(self.layouts))
        hook.fire("layout_change", self.layouts[self.currentLayout], self)
        self.layoutAll()
        screen = self.screen.get_rect()
        self.layout.show(screen)

    def prevLayout(self):
        self.layout.hide()
        self.currentLayout = (self.currentLayout - 1) % (len(self.layouts))
        hook.fire("layout_change", self.layouts[self.currentLayout], self)
        self.layoutAll()
        screen = self.screen.get_rect()
        self.layout.show(screen)

    def layoutAll(self, warp=False):
        """
        Layout the floating layer, then the current layout.

        If we have have a currentWindow give it focus, optionally
        moving warp to it.
        """
        if self.screen and len(self.windows):
            with self.disableMask(xcb.xproto.EventMask.EnterWindow):
                normal = [x for x in self.windows if not x.floating]
                floating = [
                    x for x in self.windows
                    if x.floating and not x.minimized
                ]
                screen = self.screen.get_rect()
                if normal:
                    self.layout.layout(normal, screen)
                if floating:
                    self.floating_layout.layout(floating, screen)
                if self.currentWindow and \
                        self.screen == self.qtile.currentScreen:
                    self.currentWindow.focus(warp)

    def _setScreen(self, screen):
        """
        Set this group's screen to new_screen
        """
        if screen == self.screen:
            return
        self.screen = screen
        if self.screen:
            # move all floating guys offset to new screen
            self.floating_layout.to_screen(self.screen)
            self.layoutAll()
            rect = self.screen.get_rect()
            self.floating_layout.show(rect)
            self.layout.show(rect)
        else:
            self.hide()

    def hide(self):
        self.screen = None
        with self.disableMask(xcb.xproto.EventMask.EnterWindow |
                              xcb.xproto.EventMask.FocusChange |
                              xcb.xproto.EventMask.LeaveWindow):
            for i in self.windows:
                i.hide()
            self.layout.hide()

    @contextlib.contextmanager
    def disableMask(self, mask):
        for i in self.windows:
            i._disableMask(mask)
        yield
        for i in self.windows:
            i._resetMask()

    def focus(self, win, warp):
        """
            if win is in the group, blur any windows and call
            ``focus`` on the layout (in case it wants to track
            anything), fire focus_change hook and invoke layoutAll.

            warp - warp pointer to win
        """
        if self.qtile._drag:
            # don't change focus while dragging windows
            return
        if win:
            if not win in self.windows:
                return
            else:
                self.currentWindow = win
                if win.floating:
                    for l in self.layouts:
                        l.blur()
                    self.floating_layout.focus(win)
                else:
                    self.floating_layout.blur()
                    for l in self.layouts:
                        l.focus(win)
        else:
            self.currentWindow = None
        hook.fire("focus_change")
        # !!! note that warp isn't hooked up now
        self.layoutAll(warp)

    def info(self):
        return dict(
            name=self.name,
            focus=self.currentWindow.name if self.currentWindow else None,
            windows=[i.name for i in self.windows],
            layout=self.layout.name,
            layouts=[l.name for l in self.layouts],
            floating_info=self.floating_layout.info(),
            screen=self.screen.index if self.screen else None
        )

    def add(self, win):
        hook.fire("group_window_add")
        self.windows.add(win)
        win.group = self
        try:
            if win.window.get_net_wm_state() == 'fullscreen' and \
                    self.qtile.config.auto_fullscreen:
                win._float_state = window.FULLSCREEN
            elif self.floating_layout.match(win):
                # !!! tell it to float, can't set floating
                # because it's too early
                # so just set the flag underneath
                win._float_state = window.FLOATING
        except (xcb.xproto.BadWindow, xcb.xproto.BadAccess):
            pass  # doesn't matter
        if win.floating:
            self.floating_layout.add(win)
        else:
            for i in self.layouts:
                i.add(win)
        self.focus(win, True)

    def remove(self, win):
        self.windows.remove(win)
        win.group = None
        nextfocus = None
        if win.floating:
            nextfocus = self.floating_layout.remove(win)
            if nextfocus is None:
                nextfocus = self.layout.focus_first()
            if nextfocus is None:
                nextfocus = self.floating_layout.focus_first()
        else:
            for i in self.layouts:
                if i is self.layout:
                    nextfocus = i.remove(win)
                else:
                    i.remove(win)
            if nextfocus is None:
                nextfocus = self.floating_layout.focus_first()
            if nextfocus is None:
                nextfocus = self.layout.focus_first()
        self.focus(nextfocus, True)
        #else: TODO: change focus

    def mark_floating(self, win, floating):
        if floating and win in self.floating_layout.clients:
            # already floating
            pass
        elif floating:
            for i in self.layouts:
                i.remove(win)
                if win is self.currentWindow:
                    i.blur()
            self.floating_layout.add(win)
            if win is self.currentWindow:
                self.floating_layout.focus(win)
        else:
            self.floating_layout.remove(win)
            self.floating_layout.blur()
            for i in self.layouts:
                i.add(win)
                if win is self.currentWindow:
                    i.focus(win)
        self.layoutAll()

    def _items(self, name):
        if name == "layout":
            return (True, range(len(self.layouts)))
        elif name == "window":
            return (True, [i.window.wid for i in self.windows])
        elif name == "screen":
            return (True, None)

    def _select(self, name, sel):
        if name == "layout":
            if sel is None:
                return self.layout
            else:
                return utils.lget(self.layouts, sel)
        elif name == "window":
            if sel is None:
                return self.currentWindow
            else:
                for i in self.windows:
                    if i.window.wid == sel:
                        return i
        elif name == "screen":
            return self.screen

    def cmd_setlayout(self, layout):
        self.layout = layout

    def cmd_info(self):
        """
            Returns a dictionary of info for this group.
        """
        return self.info()

    def cmd_toscreen(self, screen=None):
        """
            Pull a group to a specified screen.

            - screen: Screen offset. If not specified,
                      we assume the current screen.

            Pull group to the current screen:
                toscreen()

            Pull group to screen 0:
                toscreen(0)
        """
        if screen is None:
            screen = self.qtile.currentScreen
        else:
            screen = self.qtile.screens[screen]
        screen.setGroup(self)

    def _dirGroup(self, direction, skip_empty=False, skip_managed=False):
        """
        Find a group walking the groups list in the specified
        direction.

        skip_empty skips the empty groups
        skip_managed skips the groups that have a screen
        """

        def match(group):
            if group is self:
                return True
            if skip_empty and not group.windows:
                return False
            if skip_managed and group.screen:
                return False
            return True

        groups = [group for group in self.qtile.groups if match(group)]
        index = (groups.index(self) + direction) % len(groups)
        return groups[index]

    def prevGroup(self, skip_empty=False, skip_managed=False):
        return self._dirGroup(-1, skip_empty, skip_managed)

    def nextGroup(self, skip_empty=False, skip_managed=False):
        return self._dirGroup(1, skip_empty, skip_managed)

    def cmd_unminimise_all(self):
        """
            Unminimise all windows in this group.
        """
        for w in self.windows:
            w.minimised = False
        self.layoutAll()

    def cmd_next_window(self):
        if not self.windows:
            return
        if self.currentWindow.floating:
            nxt = self.floating_layout.focus_next(self.currentWindow) or \
                self.layout.focus_first() or \
                self.floating_layout.focus_first()
        else:
            nxt = self.layout.focus_next(self.currentWindow) or \
                self.floating_layout.focus_first() or \
                self.layout.focus_first()
        self.focus(nxt, True)

    def cmd_prev_window(self):
        if not self.windows:
            return
        if self.currentWindow.floating:
            nxt = self.floating_layout.focus_previous(self.currentWindow) or \
                self.layout.focus_last() or \
                self.floating_layout.focus_last()
        else:
            nxt = self.layout.focus_previous(self.currentWindow) or \
                self.floating_layout.focus_last() or \
                self.layout.focus_last()
        self.focus(nxt, True)

    def cmd_switch_groups(self, name):
        """
            Switch position of current group with name
        """
        self.qtile.cmd_switch_groups(self.name, name)

########NEW FILE########
__FILENAME__ = hook
import utils

subscriptions = {}
SKIPLOG = set()
qtile = None


def init(q):
    global qtile
    qtile = q


def clear():
    subscriptions.clear()


class Subscribe:
    def __init__(self):
        hooks = set([])
        for i in dir(self):
            if not i.startswith("_"):
                hooks.add(i)
        self.hooks = hooks

    def _subscribe(self, event, func):
        lst = subscriptions.setdefault(event, [])
        if not func in lst:
            lst.append(func)

    def startup(self, func):
        """
            Called when Qtile has initialized
        """
        return self._subscribe("startup", func)

    def setgroup(self, func):
        """
            Called when group is changed.
        """
        return self._subscribe("setgroup", func)

    def addgroup(self, func):
        """
            Called when group is added.
        """
        return self._subscribe("addgroup", func)

    def delgroup(self, func):
        """
            Called when group is deleted.
        """
        return self._subscribe("delgroup", func)

    def changegroup(self, func):
        """
            Called whenever a group change occurs.
        """
        return self._subscribe("changegroup", func)

    def focus_change(self, func):
        """
            Called when focus is changed.
        """
        return self._subscribe("focus_change", func)

    def float_change(self, func):
        """
            Called when a change in float state is made
        """
        return self._subscribe("float_change", func)

    def group_window_add(self, func):
        """
            Called when a new window is added to a group.
        """
        return self._subscribe("group_window_add", func)

    def window_name_change(self, func):
        """
            Called whenever a windows name changes.
        """
        return self._subscribe("window_name_change", func)

    def client_new(self, func):
        """
            Called before Qtile starts managing a new client. Use this hook to
            declare windows static, or add them to a group on startup. This
            hook is not called for internal windows.

            - arguments: window.Window object

            ## Example:

                def func(c):
                    if c.name == "xterm":
                        c.togroup("a")
                    elif c.name == "dzen":
                        c.static(0)
                libqtile.hook.subscribe.client_new(func)
        """
        return self._subscribe("client_new", func)

    def client_managed(self, func):
        """
            Called after Qtile starts managing a new client. That is, after a
            window is assigned to a group, or when a window is made static.
            This hook is not called for internal windows.

            - arguments: window.Window object
        """
        return self._subscribe("client_managed", func)

    def client_killed(self, func):
        """
            Called after a client has been unmanaged.

            - arguments: window.Window object of the killed window.
        """
        return self._subscribe("client_killed", func)

    def client_state_changed(self, func):
        """
            Called whenever client state changes.
        """
        return self._subscribe("client_state_changed", func)

    def client_type_changed(self, func):
        """
            Called whenever window type changes.
        """
        return self._subscribe("client_type_changed", func)

    def client_focus(self, func):
        """
            Called whenver focus changes.

            - arguments: window.Window object of the new focus.
        """
        return self._subscribe("client_focus", func)

    def client_mouse_enter(self, func):
        """
            Called when the mouse enters a client.
        """
        return self._subscribe("client_mouse_enter", func)

    def client_name_updated(self, func):
        """
            Called when the client name changes.
        """
        return self._subscribe("client_name_updated", func)

    def client_urgent_hint_changed(self, func):
        """
            Called when the client urgent hint changes.
        """
        return self._subscribe("client_urgent_hint_changed", func)

    def layout_change(self, func):
        """
            Called on layout change.
        """
        return self._subscribe("layout_change", func)

    def net_wm_icon_change(self, func):
        """
            Called on _NET_WM_ICON chance.
        """
        return self._subscribe("net_wm_icon_change", func)

    def screen_change(self, func):
        """
            Called when a screen is added or screen configuration is changed
            (via xrandr). The hook should take two arguments: the root qtile
            object and the ``xproto.randr.ScreenChangeNotify`` event. Common
            usage is simply to call ``qtile.cmd_restart()`` on each event (to
            restart qtile when there is a new monitor):

            ## Example:

                def restart_on_randr(qtile, ev):
                    qtile.cmd_restart()
        """
        return self._subscribe("screen_change", func)

subscribe = Subscribe()


class Unsubscribe(Subscribe):
    """
        This class mirrors subscribe, except the _subscribe member has been
        overridden to removed calls from hooks.
    """
    def _subscribe(self, event, func):
        lst = subscriptions.setdefault(event, [])
        try:
            lst.remove(func)
        except ValueError:
            raise utils.QtileError(
                "Tried to unsubscribe a hook that was not"
                " currently subscribed"
            )

unsubscribe = Unsubscribe()


def fire(event, *args, **kwargs):
    if event not in subscribe.hooks:
        raise utils.QtileError("Unknown event: %s" % event)
    if not event in SKIPLOG:
        qtile.log.info(
            "Internal event: %s(%s, %s)" %
            (event, args, kwargs)
        )
    for i in subscriptions.get(event, []):
        try:
            i(*args, **kwargs)
        except:
            qtile.log.exception("Error in hook %s" % (event,))

########NEW FILE########
__FILENAME__ = ipc
# Copyright (c) 2008, Aldo Cortesi. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""
    A simple IPC mechanism for communicating between two local processes. We
    use marshal to serialize data - this means that both client and server must
    run the same Python version, and that clients must be trusted (as
    un-marshalling untrusted data can result in arbitrary code execution).
"""
import marshal
import select
import logging
import os.path
import socket
import struct
import gobject
import errno
import fcntl

HDRLEN = 4
BUFSIZE = 1024 * 1024


class IPCError(Exception):
    pass


class _IPC:
    def _read(self, sock):
        try:
            size = struct.unpack("!L", sock.recv(HDRLEN))[0]
            data = ""
            while len(data) < size:
                data += sock.recv(BUFSIZE)
            return self._unpack_body(data)
        except struct.error:
            raise IPCError(
                "error reading reply!"
                " (probably the socket was disconnected)"
            )

    def _unpack_body(self, body):
        return marshal.loads(body)

    def _pack_reply(self, msg):
        msg = marshal.dumps(msg)
        size = struct.pack("!L", len(msg))
        return size + msg

    def _write(self, sock, msg):
        sock.sendall(self._pack_reply(msg))


class Client(_IPC):
    def __init__(self, fname):
        self.fname = fname

    def send(self, msg):
        sock = socket.socket(
            socket.AF_UNIX,
            socket.SOCK_STREAM,
            0
        )
        try:
            sock.connect(self.fname)
        except socket.error:
            raise IPCError("Could not open %s" % self.fname)

        self._write(sock, msg)

        while True:
            fds, _, _ = select.select([sock], [], [], 1)
            if fds:
                data = self._read(sock)
                sock.close()
                return data
            else:
                raise RuntimeError("Server not responding")

    def call(self, data):
        return self.send(data)


class Server(_IPC):
    def __init__(self, fname, handler):
        self.log = logging.getLogger('qtile')
        self.fname = fname
        self.handler = handler
        if os.path.exists(fname):
            os.unlink(fname)
        self.sock = socket.socket(
            socket.AF_UNIX,
            socket.SOCK_STREAM,
            0
        )
        flags = fcntl.fcntl(self.sock, fcntl.F_GETFD)
        fcntl.fcntl(self.sock, fcntl.F_SETFD, flags | fcntl.FD_CLOEXEC)
        self.sock.bind(self.fname)
        self.sock.listen(5)

    def close(self):
        self.log.info('Remove source on server close')
        gobject.source_remove(self.gob_tag)
        self.sock.close()

    def start(self):
        self.log.info('Add io watch on server start')
        self.gob_tag = gobject.io_add_watch(
            self.sock, gobject.IO_IN, self._connection
        )

    def _connection(self, sock, cond):
        try:
            conn, _ = self.sock.accept()
        except socket.error as er:
            if er.errno in (errno.EAGAIN, errno.EINTR):
                return True
            raise
        else:
            flags = fcntl.fcntl(conn, fcntl.F_GETFD)
            fcntl.fcntl(conn, fcntl.F_SETFD, flags | fcntl.FD_CLOEXEC)
            conn.setblocking(0)
            data = {'buffer': ''}  # object which holds connection state
            self.log.info('Add io watch on _connection')
            gobject.io_add_watch(conn, gobject.IO_IN, self._receive, data)
            return True

    def _receive(self, conn, cond, data):
        try:
            recv = conn.recv(4096)
        except socket.error as er:
            if er.errno in (errno.EAGAIN, errno.EINTR):
                return True
            raise
        else:
            if recv == '':
                self.log.info('Remove source on receive')
                gobject.source_remove(data['tag'])
                conn.close()
                return True

            data['buffer'] += recv
            if 'header' not in data and len(data['buffer']) >= HDRLEN:
                data['header'] = struct.unpack("!L", data['buffer'][:HDRLEN])
                data['buffer'] = data['buffer'][HDRLEN:]
            if 'header' in data:
                if len(data['buffer']) < data['header'][0]:
                    return True

            req = self._unpack_body(data['buffer'])
            data['result'] = self._pack_reply(self.handler(req))
            self.log.info('Add io watch on receive')
            gobject.io_add_watch(conn, gobject.IO_OUT, self._send, data)
            return False

    def _send(self, conn, cond, data):
        try:
            bytes = conn.send(data['result'])
        except socket.error as er:
            if er.errno in (errno.EAGAIN, errno.EINTR, errno.EPIPE):
                return True
            raise
        else:
            if not bytes or bytes >= len(data['result']):
                conn.close()
                return False

            data['result'] = data['result'][bytes:]
            return True

########NEW FILE########
__FILENAME__ = base
# Copyright (c) 2008, Aldo Cortesi. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import copy
from abc import ABCMeta, abstractmethod

from .. import command, configurable


class Layout(command.CommandObject, configurable.Configurable):
    """
        This class defines the API that should be exposed by all layouts.
    """
    __metaclass__ = ABCMeta

    @classmethod
    def _name(cls):
        return cls.__class__.__name__.lower()

    defaults = [(
        "name",
        None,
        "The name of this layout"
        " (usually the class' name in lowercase, e.g. 'max')"
    )]

    def __init__(self, **config):
        # name is a little odd; we can't resolve it until the class is defined
        # (i.e., we can't figure it out to define it in Layout.defaults), so
        # we resolve it here instead.
        if "name" not in config:
            config["name"] = self.__class__.__name__.lower()

        command.CommandObject.__init__(self)
        configurable.Configurable.__init__(self, **config)
        self.add_defaults(Layout.defaults)

    def layout(self, windows, screen):
        assert windows, "let's eliminate unnecessary calls"
        for i in windows:
            self.configure(i, screen)

    def clone(self, group):
        """
            :group Group to attach new layout instance to.

            Make a copy of this layout. This is done to provide each group with
            a unique instance of every layout.
        """
        c = copy.copy(self)
        c.group = group
        return c

    def _items(self, name):
        if name == "screen":
            return (True, None)
        elif name == "group":
            return (True, None)

    def _select(self, name, sel):
        if name == "screen":
            return self.group.screen
        elif name == "group":
            return self.group

    def show(self, screen):
        """
            Called when layout is being shown
        """
        pass

    def hide(self):
        """
            Called when layout is being hidden
        """
        pass

    def focus(self, client):
        """
            Called whenever the focus changes.
        """
        pass

    def blur(self):
        """
            Called whenever focus is gone from this layout.
        """
        pass

    def info(self):
        """
            Returns a dictionary of layout information.
        """
        return dict(
            name=self.name,
            group=self.group.name
        )

    def cmd_info(self):
        """
            Return a dictionary of info for this object.
        """
        return self.info()

    @abstractmethod
    def add(self, client):
        """
            Called whenever a window is added to the group, whether the layout
            is current or not. The layout should just add the window to its
            internal datastructures, without mapping or configuring.
        """
        pass

    @abstractmethod
    def remove(self, client):
        """
            Called whenever a window is removed from the group, whether the
            layout is current or not. The layout should just de-register the
            window from its data structures, without unmapping the window.

            Returns the "next" window that should gain focus or None.
        """
        pass

    @abstractmethod
    def configure(self, client, screen):
        """
            This method should:

                - Configure the dimensions and borders of a window using the
                  .place() method.
                - Call either .hide or .unhide on the window.
        """
        pass

    @abstractmethod
    def focus_first(self):
        pass

    @abstractmethod
    def focus_last(self):
        pass

    @abstractmethod
    def focus_next(self, win):
        pass

    @abstractmethod
    def focus_previous(self, win):
        pass

    @abstractmethod
    def cmd_next(self):
        pass

    @abstractmethod
    def cmd_previous(self):
        pass


class SingleWindow(Layout):
    """Base for layouts with single visible window"""

    def __init__(self, **config):
        Layout.__init__(self, **config)

    @abstractmethod
    def _get_window(self):
        """Should return either visible window or None"""
        pass

    def configure(self, win, screen):
        if win is self._get_window():
            win.place(
                screen.x, screen.y,
                screen.width, screen.height,
                0,
                None,
            )
            win.unhide()
        else:
            win.hide()

    def remove(self, win):
        cli = self.clients.pop(0)
        if cli == win:
            return self.clients[0]


class Delegate(Layout):
    """Base for all delegation layouts"""

    def __init__(self, **config):
        self.layouts = {}
        Layout.__init__(self, **config)

    def clone(self, group):
        c = Layout.clone(group)
        c.layouts = {}
        return c

    @abstractmethod
    def _get_layouts(self):
        """Returns all children layouts"""
        pass

    @abstractmethod
    def _get_active_layout(self):
        """Returns layout to which delegate commands to"""
        pass

    def delegate_layout(self, windows, mapping):
        """Delegates layouting actual windows

        :param windows: windows to layout
        :param mapping: mapping from layout to ScreenRect for each layout
        """
        grouped = {}
        for w in windows:
            lay = self.layouts[w]
            if lay in grouped:
                grouped[lay].append(w)
            else:
                grouped[lay] = [w]
        for lay, wins in grouped.iteritems():
            lay.layout(wins, mapping[lay])

    def remove(self, win):
        lay = self.layouts.pop(win)
        focus = lay.remove(win)
        if not focus:
            layouts = self._get_layouts()
            idx = layouts.index(lay)
            while idx < len(layouts) - 1 and not focus:
                idx += 1
                focus = layouts[idx].focus_first()
        return focus

    def focus_first(self):
        layouts = self._get_layouts()
        for lay in layouts:
            win = lay.focus_first()
            if win:
                return win

    def focus_last(self):
        layouts = self._get_layouts()
        for lay in reversed(layouts):
            win = lay.focus_last()
            if win:
                return win

    def focus_next(self, win):
        layouts = self._get_layouts()
        cur = self.layouts[win]
        focus = cur.focus_next(win)
        if not focus:
            idx = layouts.index(cur)
            while idx < len(layouts) - 1 and not focus:
                idx += 1
                focus = layouts[idx].focus_first()
        return focus

    def focus_previous(self, win):
        layouts = self._get_layouts()
        cur = self.layouts[win]
        focus = cur.focus_previous(win)
        if not focus:
            idx = layouts.index(cur)
            while idx > 0 and not focus:
                idx -= 1
                focus = layouts[idx].focus_last()
        return focus

    def __getattr__(self, name):
        """Delegate unimplemented command calls to active layout.

        For `cmd_`-methods that don't exist on the Delegate subclass, this
        looks for an implementation on the active layout.
        """
        if name.startswith('cmd_'):
            return getattr(self._get_active_layout(), name)
        return super(Delegate, self).__getattr__(name)

########NEW FILE########
__FILENAME__ = floating
from base import Layout
from .. import window

DEFAULT_FLOAT_WM_TYPES = set([
    'utility',
    'notification',
    'toolbar',
    'splash',
    'dialog',
])


class Floating(Layout):
    """
    Floating layout, which does nothing with windows but handles focus order
    """
    defaults = [
        ("border_focus", "#0000ff", "Border colour for the focused window."),
        ("border_normal", "#000000", "Border colour for un-focused winows."),
        ("border_width", 1, "Border width."),
        ("max_border_width", 0, "Border width for maximize."),
        ("fullscreen_border_width", 0, "Border width for fullscreen."),
        ("name", "floating", "Name of this layout."),
        (
            "auto_float_types",
            DEFAULT_FLOAT_WM_TYPES,
            "default wm types to automatically float"
        ),
    ]

    def __init__(self, float_rules=None, **config):
        """
        If you have certain apps that you always want to float you can
        provide ``float_rules`` to do so.
        ``float_rules`` is a list of dictionaries containing:

        {wname: WM_NAME, wmclass: WM_CLASS
        role: WM_WINDOW_ROLE}

        The keys must be specified as above.  You only need one, but
        you need to provide the value for it.  When a new window is
        opened it's ``match`` method is called with each of these
        rules.  If one matches, the window will float.  The following
        will float gimp and skype:

        float_rules=[dict(wmclass="skype"), dict(wmclass="gimp")]

        Specify these in the ``floating_layout`` in your config.
        """
        Layout.__init__(self, **config)
        self.clients = []
        self.focused = None
        self.float_rules = float_rules or []
        self.add_defaults(Floating.defaults)

    def match(self, win):
        """
        Used to default float some windows.
        """
        if win.window.get_wm_type() in self.auto_float_types:
            return True
        for rule_dict in self.float_rules:
            if win.match(**rule_dict):
                return True
        return False

    def to_screen(self, new_screen):
        """
        Adjust offsets of clients within current screen
        """
        for i, win in enumerate(self.clients):
            if win.maximized:
                win.enablemaximize()
                continue
            elif win.fullscreen:
                win.enablemaximize(state=window.FULLSCREEN)
                continue

            offset_x = win._float_info['x']
            offset_y = win._float_info['y']

            if offset_x > 0:
                new_x = new_screen.x + offset_x
            else:
                new_x = new_screen.x + i * 10
            if offset_y > 0:
                new_y = new_screen.y + offset_y
            else:
                new_y = new_screen.y + i * 10

            right_edge = new_screen.x + new_screen.width
            bottom_edge = new_screen.y + new_screen.height
            while new_x > right_edge:
                new_x = (new_x - new_screen.x) / 2
            while new_y > bottom_edge:
                new_y = (new_y - new_screen.y) / 2
            win.x = new_x
            win.y = new_y
            win.group = new_screen.group

    def focus_first(self):
        if self.clients:
            return self.clients[0]

    def focus_next(self, win):
        if win not in self.clients:
            return
        idx = self.clients.index(win)
        if len(self.clients) > idx + 1:
            return self.clients[idx + 1]

    def focus_last(self):
        if self.clients:
            return self.clients[-1]

    def focus_previous(self, win):
        if win not in self.clients:
            return
        idx = self.clients.index(win)
        if idx > 0:
            return self.clients[idx - 1]

    def focus(self, client):
        self.focused = client

    def blur(self):
        self.focused = None

    def configure(self, client, screen):
        if client is self.focused:
            bc = self.group.qtile.colorPixel(self.border_focus)
        else:
            bc = self.group.qtile.colorPixel(self.border_normal)
        if client.maximized:
            bw = self.max_border_width
        elif client.fullscreen:
            bw = self.fullscreen_border_width
        else:
            bw = self.border_width
        client.place(
            client.x,
            client.y,
            client.width,
            client.height,
            bw,
            bc,
            client is self.focused
        )
        client.unhide()

    def clone(self, group):
        c = Layout.clone(self, group)
        c.clients = []
        return c

    def add(self, client):
        self.clients.append(client)
        self.focused = client

    def remove(self, client):
        if client not in self.clients:
            return
        self.focused = self.focus_next(client)
        self.clients.remove(client)
        return self.focused

    def info(self):
        d = Layout.info(self)
        d["clients"] = [x.name for x in self.clients]
        return d

    def cmd_next(self):
        client = self.focus_next(self.focused) or \
                 self.focus_first()
        self.group.focus(client, False)

    def cmd_previous(self):
        client = self.focus_previous(self.focused) or \
                 self.focus_last()
        self.group.focus(client, False)

########NEW FILE########
__FILENAME__ = matrix
import math

from base import Layout


class Matrix(Layout):
    """
        This layout divides the screen into a matrix of equally sized cells
        and places one window in each cell. The number of columns is
        configurable and can also be changed interactively.
    """
    defaults = [
        ("border_focus", "#0000ff", "Border colour for the focused window."),
        ("border_normal", "#000000", "Border colour for un-focused winows."),
        ("border_width", 1, "Border width."),
        ("name", "matrix", "Name of this layout."),
    ]

    def __init__(self, columns=2, **config):
        Layout.__init__(self, **config)
        self.add_defaults(Matrix.defaults)
        self.current_window = None
        self.columns = columns
        self.clients = []

    def info(self):
        d = Layout.info(self)
        d["rows"] = [
            [win.name for win in self.get_row(i)]
            for i in xrange(self.get_num_rows())
        ]
        d["current_window"] = self.current_window
        d["clients"] = [x.name for x in self.clients]
        return d

    def clone(self, group):
        c = Layout.clone(self, group)
        c.clients = []
        return c

    def get_current_window(self):
        c, r = self.current_window
        return self.clients[r * self.columns + c]

    def get_num_rows(self):
        return int(math.ceil(float(len(self.clients)) / self.columns))

    def get_row(self, row):
        assert row < self.get_num_rows()
        return self.clients[
            row * self.columns: row * self.columns + self.columns
        ]

    def get_column(self, column):
        assert column < self.columns
        return [
            self.clients[i]
            for i in xrange(column, len(self.clients), self.columns)
        ]

    def add(self, client):
        self.clients.append(client)

    def remove(self, client):
        if client not in self.clients:
            return
        self.clients.remove(client)

    def focus(self, client):
        if client not in self.clients:
            return
        idx = self.clients.index(client)
        self.current_window = (idx % self.columns, idx / self.columns)

    def focus_first(self):
        if self.clients:
            return self.clients[0]

    def focus_last(self):
        if self.clients:
            return self.clients[-1]

    def focus_next(self, window):
        if not self.clients:
            return
        if self.get_current_window != window:
            self.focus(window)
        idx = self.clients.index(window)
        if idx + 1 < len(self.clients):
            return self.clients[idx + 1]

    def focus_previous(self, window):
        if not self.clients:
            return
        if self.get_current_window != window:
            self.focus(window)
        idx = self.clients.index(window)
        if idx > 0:
            return self.clients[idx - 1]

    def configure(self, client, screen):
        if client not in self.clients:
            return
        idx = self.clients.index(client)
        column = idx % self.columns
        row = idx / self.columns
        column_size = int(math.ceil(float(len(self.clients)) / self.columns))
        if (column, row) == self.current_window:
            px = self.group.qtile.colorPixel(self.border_focus)
        else:
            px = self.group.qtile.colorPixel(self.border_normal)
        column_width = int(screen.width / float(self.columns))
        row_height = int(screen.height / float(column_size))
        xoffset = screen.x + column * column_width
        yoffset = screen.y + row * row_height
        win_width = column_width - 2 * self.border_width
        win_height = row_height - 2 * self.border_width

        client.place(
            xoffset,
            yoffset,
            win_width,
            win_height,
            self.border_width,
            px
        )
        client.unhide()

    def cmd_next(self):
        client = self.focus_next(self.get_current_window()) or \
                 self.focus_first()
        self.group.focus(client, False)

    def cmd_previous(self):
        client = self.focus_previous(self.get_current_window()) or \
                 self.focus_last()
        self.group.focus(client, False)

    def cmd_left(self):
        """
            Switch to the next window on current row
        """
        column, row = self.current_window
        self.current_window = ((column - 1) % len(self.get_row(row)), row)
        self.group.focus(self.get_current_window(), False)

    def cmd_right(self):
        """
            Switch to the next window on current row
        """
        column, row = self.current_window
        self.current_window = ((column + 1) % len(self.get_row(row)), row)
        self.group.focus(self.get_current_window(), False)

    def cmd_down(self):
        """
            Switch to the next window in current column
        """
        column, row = self.current_window
        self.current_window = (
            column,
            (row + 1) % len(self.get_column(column))
        )
        self.group.focus(self.get_current_window(), False)

    def cmd_up(self):
        """
            Switch to the previous window in current column
        """
        column, row = self.current_window
        self.current_window = (
            column,
            (row - 1) % len(self.get_column(column))
        )
        self.group.focus(self.get_current_window(), False)

    def cmd_delete(self):
        """
            Decrease number of columns
        """
        self.columns -= 1
        self.group.layoutAll()

    def cmd_add(self):
        """
            Increase number of columns
        """
        self.columns += 1
        self.group.layoutAll()

########NEW FILE########
__FILENAME__ = max
# Copyright (c) 2008, Aldo Cortesi. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
from base import SingleWindow
from .. import utils


class Max(SingleWindow):
    """
        A simple layout that only displays one window at a time, filling the
        screen. This is suitable for use on laptops and other devices with
        small screens. Conceptually, the windows are managed as a stack, with
        commands to switch to next and previous windows in the stack.
    """
    defaults = [("name", "max", "Name of this layout."),
                ("only_focused", False, "Only draw the focused window")]

    def __init__(self, **config):
        SingleWindow.__init__(self, **config)
        self.clients = []
        self.add_defaults(Max.defaults)
        self.focused = None

    def _get_window(self):
        return self.focused

    def focus(self, client):
        self.group.layoutAll()
        self.focused = client

    def focus_first(self):
        if self.clients:
            return self.clients[0]

    def focus_last(self):
        if self.clients:
            return self.clients[-1]

    def focus_next(self, window):
        if not self.clients:
            return
        if window != self._get_window():
            self.focus(window)
        idx = self.clients.index(window)
        if idx + 1 < len(self.clients):
            return self.clients[idx + 1]

    def focus_previous(self, window):
        if not self.clients:
            return
        if window != self._get_window():
            self.focus(window)
        idx = self.clients.index(window)
        if idx > 0:
            return self.clients[idx - 1]

    def up(self):
        client = self.focus_previous(self.focused) or \
                 self.focus_last()
        self.group.focus(client, False)

    def down(self):
        client = self.focus_next(self.focused) or \
                 self.focus_first()
        self.group.focus(client, False)

    def clone(self, group):
        c = SingleWindow.clone(self, group)
        c.clients = []
        return c

    def add(self, client):
        self.clients.insert(0, client)

    def remove(self, client):
        if client not in self.clients:
            return
        self.clients.remove(client)
        if self.clients:
            return self.clients[0]

    def configure(self, client, screen):
        if self.only_focused and client is not self.focused:
            client.hide()
        else:
            client.place(
                screen.x,
                screen.y,
                screen.width,
                screen.height,
                0,
                None,
                client is self.group.currentWindow
            )
            client.unhide()

    def info(self):
        d = SingleWindow.info(self)
        d["clients"] = [x.name for x in self.clients]
        return d

    def cmd_down(self):
        """
            Switch down in the window list.
        """
        self.down()

    cmd_next = cmd_down

    def cmd_up(self):
        """
            Switch up in the window list.
        """
        self.up()

    cmd_previous = cmd_up

########NEW FILE########
__FILENAME__ = ratiotile
import math

from base import Layout
from .. import utils


ROWCOL = 1  # do rows at a time left to right top down
COLROW = 2  # do cols top to bottom, left to right

GOLDEN_RATIO = 1.618


class GridInfo(object):
    """
    Calculates sizes for grids
    >>> gi = GridInfo(.5, 5, 600, 480)
    >>> gi.calc()
    (1, 5, 1)
    >>> gi.get_sizes()
    [(0, 0, 120, 480), (120, 0, 120, 480), (240, 0, 120, 480), (360, 0, 120, 480), (480, 0, 120, 480)]
    >>> gi = GridInfo(6, 5, 600, 480)
    >>> gi.get_sizes()
    [(0, 0, 600, 96), (0, 96, 600, 96), (0, 192, 600, 96), (0, 288, 600, 96), (0, 384, 600, 96)]
    >>> gi = GridInfo(1, 5, 600, 480)
    >>> gi.get_sizes()
    [(0, 0, 200, 240), (200, 0, 200, 240), (400, 0, 200, 240), (0, 240, 300, 240), (200, 240, 200, 240)]

    >>> foo = GridInfo(1.6, 7, 400,370)
    >>> foo.get_sizes(500,580)


    """
    def __init__(self, ratio, num_windows, width, height):
        self.ratio = ratio
        self.num_windows = num_windows
        self.width = width
        self.height = height
        self.num_rows = 0
        self.num_cols = 0

    def calc(self, num_windows, width, height):
        """
        returns (rows, cols, orientation) tuple given input
        """
        best_ratio = None
        best_rows_cols_orientation = None
        for rows, cols, orientation in self._possible_grids(num_windows):

            sample_width = float(width) / cols
            sample_height = float(height) / rows
            sample_ratio = sample_width / sample_height
            diff = abs(sample_ratio - self.ratio)
            if best_ratio is None or diff < best_ratio:
                best_ratio = diff
                best_rows_cols_orientation = (rows, cols, orientation)

        return best_rows_cols_orientation

    def _possible_grids(self, num_windows):
        """
        iterates over possible grids given a number of windows
        """
        if num_windows < 2:
            end = 2
        else:
            end = num_windows / 2 + 1
        for rows in range(1, end):
            cols = int(math.ceil(float(num_windows) / rows))
            yield (rows, cols, ROWCOL)
            if rows != cols:
                # also want the reverse test
                yield (cols, rows, COLROW)

    def get_sizes_advanced(self, total_width, total_height,
                           xoffset=0, yoffset=0):
        """
        after every row/column recalculate remaining area
        """
        results = []
        width = total_width
        height = total_height
        while len(results) < self.num_windows:
            remaining = self.num_windows - len(results)
            orien, sizes = self._get_row_or_col(
                remaining, width, height, xoffset, yoffset
            )
            results.extend(sizes)
            if orien == ROWCOL:
                # adjust height/yoffset
                height -= sizes[-1][-1]
                yoffset += sizes[-1][-1]
            else:
                width -= sizes[-1][-2]
                xoffset += sizes[-1][-2]

        return results

    def _get_row_or_col(self, num_windows, width, height, xoffset, yoffset):
        """
        process one row (or col) at a time
        """
        rows, cols, orientation = self.calc(num_windows, width, height)
        results = []
        if orientation == ROWCOL:
            x = 0
            y = 0
            for i, col in enumerate(range(cols)):
                w_width = width / cols
                w_height = height / rows
                if i == cols - 1:
                    w_width = width - x
                results.append((x + xoffset, y + yoffset, w_width, w_height))
                x += w_width
        elif orientation == COLROW:
            x = 0
            y = 0
            for i, col in enumerate(range(rows)):
                w_width = width / cols
                w_height = height / rows
                if i == rows - 1:
                    w_height = height - y
                results.append((x + xoffset, y + yoffset, w_width, w_height))
                y += w_height
        return orientation, results

    def get_sizes(self, total_width, total_height, xoffset=0, yoffset=0):
        width = 0
        height = 0
        results = []
        rows, cols, orientation = self.calc(
            self.num_windows, total_width, total_height
        )
        if orientation == ROWCOL:
            y = 0
            for i, row in enumerate(range(rows)):
                x = 0
                width = total_width / cols
                for j, col in enumerate(range(cols)):
                    height = total_height / rows
                    if i == rows - 1 and j == 0:
                        # last row
                        remaining = self.num_windows - len(results)
                        width = total_width / remaining
                    elif j == cols - 1 or len(results) + 1 == self.num_windows:
                        # since we are dealing with integers,
                        # make last column (or item) take up remaining space
                        width = total_width - x

                    results.append((
                        x + xoffset,
                        y + yoffset,
                        width,
                        height
                    ))
                    if len(results) == self.num_windows:
                        return results
                    x += width
                y += height
        else:
            x = 0
            for i, col in enumerate(range(cols)):
                y = 0
                height = total_height / rows
                for j, row in enumerate(range(rows)):
                    width = total_width / cols
                    # down first
                    if i == cols - 1 and j == 0:
                        remaining = self.num_windows - len(results)
                        height = total_height / remaining
                    elif j == rows - 1 or len(results) + 1 == self.num_windows:
                        height = total_height - y
                    results.append((
                        x + xoffset,  # i * width + xoffset,
                        y + xoffset,  # j * height + yoffset,
                        width,
                        height
                    ))
                    if len(results) == self.num_windows:
                        return results
                    y += height
                x += width

        return results


class RatioTile(Layout):
    """
    Tries to tile all windows in the width/height ratio passed in
    """
    defaults = [
        ("border_focus", "#0000ff", "Border colour for the focused window."),
        ("border_normal", "#000000", "Border colour for un-focused winows."),
        ("border_width", 1, "Border width."),
        ("name", "ratiotile", "Name of this layout."),
    ]

    def __init__(self, ratio=GOLDEN_RATIO, ratio_increment=0.1,
                 fancy=False, **config):
        Layout.__init__(self, **config)
        self.add_defaults(RatioTile.defaults)
        self.clients = []
        self.ratio_increment = ratio_increment
        self.ratio = ratio
        self.focused = None
        self.dirty = True  # need to recalculate
        self.layout_info = []
        self.last_size = None
        self.last_screen = None
        self.fancy = fancy

    def clone(self, group):
        c = Layout.clone(self, group)
        c.clients = []
        return c

    def focus(self, c):
        self.focused = c

    def blur(self):
        self.focused = None

    def add(self, w):
        self.dirty = True
        self.clients.insert(0, w)

    def remove(self, w):
        self.dirty = True
        if self.focused is w:
            self.focused = None
        self.clients.remove(w)
        if self.clients:  # and w is self.focused:
            self.focused = self.clients[0]
        return self.focused

    def configure(self, win, screen):
        # force recalc
        if not self.last_screen or self.last_screen != screen:
            self.last_screen = screen
            self.dirty = True
        if self.last_size and not self.dirty:
            if screen.width != self.last_size[0] or \
                    screen.height != self.last_size[1]:
                self.dirty = True
        if self.dirty:
            gi = GridInfo(
                self.ratio,
                len(self.clients),
                screen.width,
                screen.height
            )
            self.last_size = (screen.width, screen.height)
            if self.fancy:
                method = gi.get_sizes_advanced
            else:
                method = gi.get_sizes

            self.layout_info = method(
                screen.width,
                screen.height,
                screen.x,
                screen.y
            )

            self.dirty = False
        try:
            idx = self.clients.index(win)
        except ValueError:
            win.hide()
            return
        x, y, w, h = self.layout_info[idx]
        if win is self.focused:
            bc = self.group.qtile.colorPixel(self.border_focus)
        else:
            bc = self.group.qtile.colorPixel(self.border_normal)
        win.place(
            x,
            y,
            w - self.border_width * 2,
            h - self.border_width * 2,
            self.border_width,
            bc
        )
        win.unhide()

    def info(self):
        return {
            'clients': [x.name for x in self.clients],
            'ratio': self.ratio,
            'focused': self.focused.name if self.focused else None,
            'layout_info': self.layout_info
        }

    def shuffleUp(self):
        if self.clients:
            utils.shuffleUp(self.clients)
            self.group.layoutAll()

    def shuffleDown(self):
        if self.clients:
            utils.shuffleDown(self.clients)
            self.group.layoutAll()

    def focus_first(self):
        if self.clients:
            return self.clients[0]

    def focus_next(self, win):
        idx = self.clients.index(win)
        if len(self.clients) > idx + 1:
            return self.clients[idx + 1]

    def focus_last(self):
        if self.clients:
            return self.clients[-1]

    def focus_previous(self, win):
        idx = self.clients.index(win)
        if idx > 0:
            return self.clients[idx - 1]

    def getNextClient(self):
        previndex = self.clients.index(self.focused) - 1
        if previndex < 0:
            previndex = len(self.clients) - 1
        return self.clients[previndex]

    def getPreviousClient(self):
        nextindex = self.clients.index(self.focused) + 1
        if nextindex >= len(self.clients):
            nextindex = 0
        return self.clients[nextindex]

    def next(self):
        n = self.getPreviousClient()
        self.group.focus(n, True)

    def previous(self):
        n = self.getNextClient()
        self.group.focus(n, True)

    def shuffle(self, function):
        if self.clients:
            function(self.clients)
            self.group.layoutAll()

    def cmd_down(self):
        self.previous()

    def cmd_up(self):
        self.next()

    def cmd_next(self):
        self.next()

    def cmd_previous(self):
        self.previous()

    def cmd_shuffle_down(self):
        self.shuffleDown()

    def cmd_shuffle_up(self):
        self.shuffleUp()

    def cmd_decrease_ratio(self):
        new_ratio = self.ratio - self.ratio_increment
        if new_ratio < 0:
            return
        self.ratio = new_ratio
        self.group.layoutAll()

    def cmd_increase_ratio(self):
        self.ratio += self.ratio_increment
        self.group.layoutAll()

    def cmd_info(self):
        return self.info()


if __name__ == '__main__':
    import doctest
    doctest.testmod()

########NEW FILE########
__FILENAME__ = slice
# -*- coding: utf-8 -*-
"""
Slice layout. Serves as example of delegating layouts (or sublayouts)
"""

from base import Layout, SingleWindow, Delegate
from max import Max


class Single(SingleWindow):
    """Layout with single window

    Just like Max but asserts that window is the one
    """

    def __init__(self):
        SingleWindow.__init__(self)
        self.window = None

    def add(self, window):
        assert self.window is None
        self.window = window

    def remove(self, window):
        assert self.window is window
        self.window = None

    def _get_window(self):
        return self.window

    def empty(self):
        """Is the layout empty

        Returns True if the layout empty (and is willing to accept windows)
        """
        return self.window is None

    def focus_first(self):
        return self.window

    def focus_last(self):
        return self.window

    def focus_next(self, window):
        return self.window

    def focus_previous(self, window):
        return self.window

    def cmd_next(self):
        pass

    def cmd_previous(self):
        pass


class Slice(Delegate):
    """Slice layout

    This layout cuts piece of screen and places a single window on that piece,
    and delegates other window placement to other layout
    """

    defaults = [
        ("width", 256, "Slice width"),
        ("side", "left", "Side of the slice (left, right, top, bottom)"),
        ("name", "max", "Name of this layout."),
    ]

    def __init__(self, side, width,
                 wname=None, wmclass=None, role=None,
                 fallback=Max(), **config):
        if wname is None and wmclass is None and role is None:
            wname = 'slice'
        self.match = {
            'wname': wname,
            'wmclass': wmclass,
            'role': role,
        }
        Delegate.__init__(self, width=width, side=side, **config)
        self.add_defaults(Slice.defaults)
        self._slice = Single()
        self._fallback = fallback

    def clone(self, group):
        res = Layout.clone(self, group)
        res._slice = self._slice.clone(group)
        res._fallback = self._fallback.clone(group)
        res._window = None
        return res

    def layout(self, windows, screen):
        if self.side == 'left':
            win, sub = screen.hsplit(self.width)
        elif self.side == 'right':
            sub, win = screen.hsplit(screen.width - self.width)
        elif self.side == 'top':
            win, sub = screen.vsplit(self.width)
        elif self.side == 'bottom':
            sub, win = screen.vsplit(screen.height - self.width)
        else:
            raise NotImplementedError(self.side)
        self.delegate_layout(
            windows,
            {
                self._slice: win,
                self._fallback: sub,
            }
        )

    def configure(self, win, screen):
        raise NotImplementedError("Should not be called")

    def _get_layouts(self):
        return (self._slice, self._fallback)

    def _get_active_layout(self):
        return self._fallback  # always

    def add(self, win):
        if self._slice.empty() and win.match(**self.match):
            self._slice.add(win)
            self.layouts[win] = self._slice
        else:
            self._fallback.add(win)
            self.layouts[win] = self._fallback

    def cmd_next(self):
        self._fallback.cmd_next()

    def cmd_previous(self):
        self._fallback.cmd_previous()

########NEW FILE########
__FILENAME__ = stack
# Copyright (c) 2008, Aldo Cortesi. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
from base import Layout
from .. import utils


class _WinStack(object):
    split = False
    _current = 0

    @property
    def current(self):
        return self._current

    @current.setter
    def current(self, x):
        if len(self):
            self._current = abs(x % len(self))
        else:
            self._current = 0

    @property
    def cw(self):
        if not self.lst:
            return None
        return self.lst[self.current]

    def __init__(self):
        self.lst = []

    def toggleSplit(self):
        self.split = False if self.split else True

    def join(self, ws):
        # FIXME: This buggers up window order -
        # windows should be injected BEFORE
        # the current offset.
        self.lst.extend(ws.lst)

    def focus(self, client):
        self.current = self.lst.index(client)

    def focus_first(self):
        if self.split:
            return self[0]
        else:
            return self.cw

    def focus_next(self, win):
        if self.split:
            idx = self.index(win)
            if idx + 1 < len(self):
                return self[idx + 1]

    def focus_last(self):
        if self.split:
            return self[-1]
        else:
            return self.cw

    def focus_previous(self, win):
        if self.split:
            idx = self.index(win)
            if idx > 0:
                return self[idx - 1]

    def add(self, client):
        self.lst.insert(self.current, client)

    def remove(self, client):
        if client not in self.lst:
            return
        idx = self.lst.index(client)
        self.lst.remove(client)
        if idx > self.current:
            self.current -= 1
        else:
            # This apparently nonsensical assignment caps the value using the
            # property definition.
            self.current = self.current

    def index(self, client):
        return self.lst.index(client)

    def __len__(self):
        return len(self.lst)

    def __getitem__(self, i):
        return self.lst[i]

    def __contains__(self, client):
        return client in self.lst

    def __repr__(self):
        return "_WinStack(%s, %s)" % (
            self.current, str([i.name for i in self])
        )

    def info(self):
        return dict(
            clients=[x.name for x in self],
            split=self.split,
            current=self.current,
        )


class Stack(Layout):
    """
        The stack layout divides the screen horizontally into a set of stacks.
        Commands allow you to switch between stacks, to next and previous
        windows within a stack, and to split a stack to show all windows in the
        stack, or unsplit it to show only the current window. At the moment,
        this is the most mature and flexible layout in Qtile.
    """
    defaults = [
        ("border_focus", "#0000ff", "Border colour for the focused window."),
        ("border_normal", "#000000", "Border colour for un-focused winows."),
        ("border_width", 1, "Border width."),
        ("name", "stack", "Name of this layout."),
        ("autosplit", False, "Auto split all new stacks."),
        ("num_stacks", 2, "Number of stacks."),
    ]

    def __init__(self, **config):
        Layout.__init__(self, **config)
        self.add_defaults(Stack.defaults)
        self.stacks = [_WinStack() for i in range(self.num_stacks)]
        for stack in self.stacks:
            if self.autosplit:
                stack.split = True

    @property
    def currentStack(self):
        return self.stacks[self.currentStackOffset]

    @property
    def currentStackOffset(self):
        for i, s in enumerate(self.stacks):
            if self.group.currentWindow in s:
                return i
        return 0

    @property
    def clients(self):
        client_list = []
        for stack in self.stacks:
            client_list.extend(list(stack))
        return client_list

    def clone(self, group):
        c = Layout.clone(self, group)
        # These are mutable
        c.stacks = [_WinStack() for i in self.stacks]
        for stack in c.stacks:
            if self.autosplit:
                stack.split = True
        return c

    def _findNext(self, lst, offset):
        for i in lst[offset + 1:]:
            if i:
                return i
        else:
            for i in lst[:offset]:
                if i:
                    return i

    def deleteCurrentStack(self):
        if len(self.stacks) > 1:
            off = self.currentStackOffset or 0
            s = self.stacks[off]
            self.stacks.remove(s)
            off = min(off, len(self.stacks) - 1)
            self.stacks[off].join(s)
            if self.stacks[off]:
                self.group.focus(
                    self.stacks[off].cw,
                    False
                )

    def nextStack(self):
        n = self._findNext(
            self.stacks,
            self.currentStackOffset
        )
        if n:
            self.group.focus(n.cw, True)

    def previousStack(self):
        n = self._findNext(
            list(reversed(self.stacks)),
            len(self.stacks) - self.currentStackOffset - 1
        )
        if n:
            self.group.focus(n.cw, True)

    def focus(self, client):
        for i in self.stacks:
            if client in i:
                i.focus(client)

    def focus_first(self):
        for i in self.stacks:
            if i:
                return i.focus_first()

    def focus_last(self):
        for i in reversed(self.stacks):
            if i:
                return i.focus_last()

    def focus_next(self, client):
        iterator = iter(self.stacks)
        for i in iterator:
            if client in i:
                next = i.focus_next(client)
                if next:
                    return next
                break
        else:
            return
        for i in iterator:
            if i:
                return i.focus_first()

    def focus_previous(self, client):
        iterator = iter(reversed(self.stacks))
        for i in iterator:
            if client in i:
                next = i.focus_previous(client)
                if next:
                    return next
                break
        else:
            return
        for i in iterator:
            if i:
                return i.focus_last()

    def add(self, client):
        for i in self.stacks:
            if not i:
                i.add(client)
                return
        self.currentStack.add(client)

    def remove(self, client):
        currentOffset = self.currentStackOffset
        for i in self.stacks:
            if client in i:
                i.remove(client)
                break
        if self.stacks[currentOffset].cw:
            return self.stacks[currentOffset].cw
        else:
            n = self._findNext(
                list(reversed(self.stacks)),
                len(self.stacks) - currentOffset - 1
            )
            if n:
                return n.cw

    def configure(self, client, screen):
        for i, s in enumerate(self.stacks):
            if client in s:
                break
        else:
            client.hide()

        if client is self.group.currentWindow:
            px = self.group.qtile.colorPixel(self.border_focus)
        else:
            px = self.group.qtile.colorPixel(self.border_normal)

        columnWidth = int(screen.width / float(len(self.stacks)))
        xoffset = screen.x + i * columnWidth
        winWidth = columnWidth - 2 * self.border_width

        if s.split:
            columnHeight = int(screen.height / float(len(s)))
            winHeight = columnHeight - 2 * self.border_width
            yoffset = screen.y + s.index(client) * columnHeight
            client.place(
                xoffset,
                yoffset,
                winWidth,
                winHeight,
                self.border_width,
                px
            )
            client.unhide()
        else:
            if client == s.cw:
                client.place(
                    xoffset,
                    screen.y,
                    winWidth,
                    screen.height - 2 * self.border_width,
                    self.border_width,
                    px
                )
                client.unhide()
            else:
                client.hide()

    def info(self):
        d = Layout.info(self)
        d["stacks"] = [i.info() for i in self.stacks]
        d["current_stack"] = self.currentStackOffset
        d["clients"] = [c.name for c in self.clients]
        return d

    def cmd_toggle_split(self):
        """
            Toggle vertical split on the current stack.
        """
        self.currentStack.toggleSplit()
        self.group.layoutAll()

    def cmd_down(self):
        """
            Switch to the next window in this stack.
        """
        self.currentStack.current -= 1
        self.group.focus(self.currentStack.cw, False)

    def cmd_up(self):
        """
            Switch to the previous window in this stack.
        """
        self.currentStack.current += 1
        self.group.focus(self.currentStack.cw, False)

    def cmd_shuffle_up(self):
        """
            Shuffle the order of this stack up.
        """
        utils.shuffleUp(self.currentStack.lst)
        self.currentStack.current += 1
        self.group.layoutAll()

    def cmd_shuffle_down(self):
        """
            Shuffle the order of this stack down.
        """
        utils.shuffleDown(self.currentStack.lst)
        self.currentStack.current -= 1
        self.group.layoutAll()

    def cmd_delete(self):
        """
            Delete the current stack from the layout.
        """
        self.deleteCurrentStack()

    def cmd_add(self):
        """
            Add another stack to the layout.
        """
        newstack = _WinStack()
        if self.autosplit:
            newstack.split = True
        self.stacks.append(newstack)
        self.group.layoutAll()

    def cmd_rotate(self):
        """
            Rotate order of the stacks.
        """
        utils.shuffleUp(self.stacks)
        self.group.layoutAll()

    def cmd_next(self):
        """
            Focus next stack.
        """
        return self.nextStack()

    def cmd_previous(self):
        """
            Focus previous stack.
        """
        return self.previousStack()

    def cmd_client_to_next(self):
        """
            Send the current client to the next stack.
        """
        return self.cmd_client_to_stack(self.currentStackOffset + 1)

    def cmd_client_to_previous(self):
        """
            Send the current client to the previous stack.
        """
        return self.cmd_client_to_stack(self.currentStackOffset - 1)

    def cmd_client_to_stack(self, n):
        """
            Send the current client to stack n, where n is an integer offset.
            If is too large or less than 0, it is wrapped modulo the number of
            stacks.
        """
        if not self.currentStack:
            return
        next = n % len(self.stacks)
        win = self.currentStack.cw
        self.currentStack.remove(win)
        self.stacks[next].add(win)
        self.stacks[next].focus(win)
        self.group.layoutAll()

    def cmd_info(self):
        return self.info()

########NEW FILE########
__FILENAME__ = tile
from base import Layout
from .. import utils


class Tile(Layout):
    defaults = [
        ("border_focus", "#0000ff", "Border colour for the focused window."),
        ("border_normal", "#000000", "Border colour for un-focused winows."),
        ("border_width", 1, "Border width."),
        ("name", "tile", "Name of this layout."),
        ("margin", 0, "Margin of the layout"),
    ]

    def __init__(self, ratio=0.618, masterWindows=1, expand=True,
                 ratio_increment=0.05, add_on_top=True, shift_windows=False,
                 master_match=None, **config):
        Layout.__init__(self, **config)
        self.add_defaults(Tile.defaults)
        self.clients = []
        self.ratio = ratio
        self.master = masterWindows
        self.focused = None
        self.expand = expand
        self.ratio_increment = ratio_increment
        self.add_on_top = add_on_top
        self.shift_windows = shift_windows
        self.master_match = master_match

    @property
    def master_windows(self):
        return self.clients[:self.master]

    @property
    def slave_windows(self):
        return self.clients[self.master:]

    def up(self):
        if self.shift_windows:
            self.shift_up()
        else:
            self.shuffle(utils.shuffleUp)

    def down(self):
        if self.shift_windows:
            self.shift_down()
        else:
            self.shuffle(utils.shuffleDown)

    def shift_up(self):
        if self.clients:
            currentindex = self.clients.index(self.focused)
            nextindex = self.get_next_index(currentindex)
            self.shift(currentindex, nextindex)

    def shift_down(self):
        if self.clients:
            currentindex = self.clients.index(self.focused)
            previndex = self.get_previous_index(currentindex)
            self.shift(currentindex, previndex)

    def focus_first(self):
        if self.clients:
            return self.clients[0]

    def focus_next(self, client):
        if client not in self.clients:
            return
        idx = self.clients.index(client)
        if len(self.clients) > idx + 1:
            return self.clients[idx + 1]

    def focus_last(self):
        if self.clients:
            return self.clients[-1]

    def focus_previous(self, client):
        if client not in self.clients:
            return
        idx = self.clients.index(client)
        if idx > 0:
            return self.clients[idx - 1]

    def shuffle(self, function):
        if self.clients:
            function(self.clients)
            self.group.layoutAll(True)

    def resetMaster(self, match=None):
        if not match and self.master_match:
            match = self.master_match
        else:
            return
        if self.clients:
            masters = [c for c in self.clients if match.compare(c)]
            self.clients = masters + [
                c for c in self.clients if c not in masters
            ]

    def shift(self, idx1, idx2):
        if self.clients:
            self.clients[idx1], self.clients[idx2] = \
                self.clients[idx2], self.clients[idx1]
            self.group.layoutAll(True)

    def clone(self, group):
        c = Layout.clone(self, group)
        c.clients = []
        return c

    def focus(self, client):
        self.focused = client

    def blur(self):
        self.focused = None

    def add(self, client):
        index = 0
        if not self.add_on_top and self.clients and self.focused:
            index = self.clients.index(self.focused)
        self.clients.insert(index, client)
        self.resetMaster()

    def remove(self, client):
        if client not in self.clients:
            return

        if self.focused is client:
            self.focused = None

        self.clients.remove(client)
        if self.clients and client is self.focused:
            self.focused = self.clients[0]
        return self.focused

    def configure(self, client, screen):
        screenWidth = screen.width
        screenHeight = screen.height
        x = 0
        y = 0
        w = 0
        h = 0
        borderWidth = self.border_width
        margin = self.margin
        if self.clients and client in self.clients:
            pos = self.clients.index(client)
            if client in self.master_windows:
                w = int(screenWidth * self.ratio) \
                    if len(self.slave_windows) or not self.expand \
                    else screenWidth
                h = screenHeight / self.master
                x = screen.x
                y = screen.y + pos * h
            else:
                w = screenWidth - int(screenWidth * self.ratio)
                h = screenHeight / (len(self.slave_windows))
                x = screen.x + int(screenWidth * self.ratio)
                y = screen.y + self.clients[self.master:].index(client) * h
            if client is self.focused:
                bc = self.group.qtile.colorPixel(self.border_focus)
            else:
                bc = self.group.qtile.colorPixel(self.border_normal)
            client.place(
                x + margin,
                y + margin,
                w - margin * 2 - borderWidth * 2,
                h - margin * 2 - borderWidth * 2,
                borderWidth,
                bc,
            )
            client.unhide()
        else:
            client.hide()

    def info(self):
        return dict(
            clients=[c.name for c in self.clients],
            master=[c.name for c in self.master_windows],
            slave=[c.name for c in self.slave_windows],
        )

    def cmd_down(self):
        self.down()

    def cmd_up(self):
        self.up()

    def cmd_next(self):
        client = self.focus_next(self.focused) or \
                 self.focus_first()
        self.group.focus(client, False)

    def cmd_previous(self):
        client = self.focus_previous(self.focused) or \
                 self.focus_last()
        self.group.focus(client, False)

    def cmd_decrease_ratio(self):
        self.ratio -= self.ratio_increment
        self.group.layoutAll()

    def cmd_increase_ratio(self):
        self.ratio += self.ratio_increment
        self.group.layoutAll()

    def cmd_decrease_nmaster(self):
        self.master -= 1
        if self.master <= 0:
            self.master = 1
        self.group.layoutAll()

    def cmd_increase_nmaster(self):
        self.master += 1
        self.group.layoutAll()

########NEW FILE########
__FILENAME__ = tree
# -*- coding: utf-8 -*-
from base import SingleWindow
from .. import window
from .. import drawer
from .. import hook

to_superscript = dict(zip(map(ord, u'0123456789'), map(ord, u'')))


class TreeNode(object):

    def __init__(self):
        self.children = []
        self.expanded = True

    def add(self, node, hint=None):
        node.parent = self
        if hint:
            try:
                idx = self.children.index(hint)
            except ValueError:
                self.children.append(node)
            else:
                self.children.insert(idx + 1, node)
        else:
            self.children.append(node)

    def draw(self, layout, top, level=0):
        self._children_start = top
        for i in self.children:
            top = i.draw(layout, top, level)
        self._children_stop = top
        return top

    def button_press(self, x, y):
        """Returns self or sibling which got the click"""
        if y >= self._children_stop or y < self._children_start:
            return
        for i in self.children:
            res = i.button_press(x, y)
            if res is not None:
                return res

    def add_superscript(self, title):
        if not self.expanded and self.children:
            return unicode(
                len(self.children)
            ).translate(to_superscript).encode('utf-8') + title
        return title

    def get_first_window(self):
        if isinstance(self, Window):
            return self
        for i in self.children:
            node = i.get_first_window()
            if node:
                return node

    def get_last_window(self):
        for i in reversed(self.children):
            node = i.get_last_window()
            if node:
                return node
        if isinstance(self, Window):
            return self

    def get_next_window(self):
        if self.children and self.expanded:
            return self.children[0]
        node = self
        while not isinstance(node, Root):
            parent = node.parent
            idx = parent.children.index(node)
            for i in xrange(idx + 1, len(parent.children)):
                res = parent.children[i].get_first_window()
                if res:
                    return res
            node = parent

    def get_prev_window(self):
        node = self
        while not isinstance(node, Root):
            parent = node.parent
            idx = parent.children.index(node)
            if idx == 0 and isinstance(parent, Window):
                return parent
            for i in xrange(idx - 1, -1, -1):
                res = parent.children[i].get_last_window()
                if res:
                    return res
            node = parent


class Root(TreeNode):

    def __init__(self, sections, default_section=None):
        super(Root, self).__init__()
        self.sections = {}
        for s in sections:
            self.add_section(s)
        if default_section is None:
            self.def_section = self.children[0]
        else:
            self.def_section = self.sections[default_section]

    def add(self, win, hint=None):
        sect = None
        parent = None
        if hint is not None:
            parent = hint.parent
        if parent is None:
            sect = getattr(win, 'tree_section', None)
        if sect is None:
            parent = self.sections.get(sect)
        if parent is None:
            parent = self.def_section
        node = Window(win)
        parent.add(node, hint=hint)
        return node

    def add_section(self, name):
        if name in self.sections:
            raise ValueError("Duplicate section name")
        node = Section(name)
        node.parent = self
        self.sections[name] = node
        self.children.append(node)

    def del_section(self, name):
        sec = self.sections[name]
        idx = self.children.index(sec)
        if idx == 0:
            if len(self.children) == 1:
                raise ValueError("Can't delete last section")
            else:
                nsec = self.children[1]
        else:
            nsec = self.children[idx - 1]
        del self.children[idx]
        nsec.children.extend(sec.children)
        for i in sec.children:
            i.parent = nsec


class Section(TreeNode):

    def __init__(self, title):
        super(Section, self).__init__()
        self.title = title

    def draw(self, layout, top, level=0):
        layout._layout.font_size = layout.section_fontsize
        layout._layout.text = self.add_superscript(self.title)
        layout._layout.colour = layout.section_fg
        del layout._layout.width  # no centering
        layout._drawer.draw_hbar(
            layout.section_fg,
            0,
            layout.panel_width,
            top,
            linewidth=1
        )
        layout._layout.draw(layout.section_left, top + layout.section_top)
        top += layout._layout.height + \
            layout.section_top + \
            layout.section_padding
        if self.expanded:
            top = super(Section, self).draw(layout, top, level)
        return top + layout.section_bottom


class Window(TreeNode):

    def __init__(self, win):
        super(Window, self).__init__()
        self.window = win

    def draw(self, layout, top, level=0):
        self._title_start = 0
        left = layout.padding_left + level * layout.level_shift
        layout._layout.font_size = layout.fontsize
        layout._layout.text = self.add_superscript(self.window.name)
        if self.window is layout._focused:
            fg = layout.active_fg
            bg = layout.active_bg
        else:
            fg = layout.inactive_fg
            bg = layout.inactive_bg
        layout._layout.colour = fg
        layout._layout.width = layout.panel_width - left
        framed = layout._layout.framed(
            layout.border_width,
            bg,
            layout.padding_x,
            layout.padding_y
        )
        framed.draw_fill(left, top)
        top += framed.height + layout.vspace + layout.border_width
        if self.expanded:
            return super(Window, self).draw(layout, top, level + 1)
        return top

    def button_press(self, x, y):
        """Returns self if clicked on title else returns sibling"""
        if y >= self._title_start and y < self._children_start:
            return self
        return super(Window, self).button_press(x, y)

    def remove(self):
        self.parent.children.remove(self)
        if len(self.children) == 1:
            self.parent.add(self.children[0])
        elif self.children:
            head = self.children[0]
            self.parent.add(head)
            for i in self.children[1:]:
                head.add(i)
        del self.children


class TreeTab(SingleWindow):
    """Tree Tab Layout

    This layout works just like Max but displays tree of the windows at the
    left border of the screen, which allows you to overview all opened windows.
    It's designed to work with ``uzbl-browser`` but works with other windows
    too.
    """

    defaults = [
        ("bg_color", "000000", "Background color of tabs"),
        ("active_bg", "000080", "Background color of active tab"),
        ("active_fg", "ffffff", "Foreground color of active tab"),
        ("inactive_bg", "606060", "Background color of inactive tab"),
        ("inactive_fg", "ffffff", "Foreground color of inactive tab"),
        ("margin_left", 6, "Left margin of tab panel"),
        ("margin_y", 6, "Vertical margin of tab panel"),
        ("padding_left", 6, "Left padding for tabs"),
        ("padding_x", 6, "Left padding for tab label"),
        ("padding_y", 2, "Top padding for tab label"),
        ("border_width", 2, "Width of the border"),
        ("vspace", 2, "Space between tabs"),
        ("level_shift", 8, "Shift for children tabs"),
        ("font", "Arial", "Font"),
        ("fontsize", 14, "Font pixel size."),
        ("fontshadow", None, "font shadow color, default is None (no shadow)"),
        ("section_fontsize", 11, "Font pixel size of section label"),
        ("section_fg", "ffffff", "Color of section label"),
        ("section_top", 4, "Top margin of section label"),
        ("section_bottom", 6, "Bottom margin of section"),
        ("section_padding", 4, "Bottom of magin section label"),
        ("section_left", 4, "Left margin of section label"),
        ("panel_width", 150, "Width of the left panel"),
        ("sections", ['Default'], "Foreground color of inactive tab"),
        ("name", "treetab", "Name of this layout."),
        ("previous_on_rm", False,
            "Focus previous window on close instead of first."),
    ]

    def __init__(self, **config):
        SingleWindow.__init__(self, **config)
        self.add_defaults(TreeTab.defaults)
        self._focused = None
        self._panel = None
        self._tree = Root(self.sections)
        self._nodes = {}

    def clone(self, group):
        c = SingleWindow.clone(self, group)
        c._focused = None
        c._panel = None
        c._tree = Root(self.sections)
        return c

    def _get_window(self):
        return self._focused

    def focus(self, win):
        self._focused = win

    def focus_first(self):
        win = self._tree.get_first_window()
        if win:
            return win.window

    def focus_last(self):
        win = self._tree.get_last_window()
        if win:
            return win.window

    def focus_next(self, client):
        win = self._nodes[client].get_next_window()
        if win:
            return win.window

    def focus_previous(self, client):
        win = self._nodes[client].get_prev_window()
        if win:
            return win.window

    def blur(self):
        # Does not clear current window, will change if new one
        # will be focused. This works better when floating window
        # will be next focused one
        pass

    def add(self, win):
        if self._focused:
            node = self._tree.add(win, hint=self._nodes[self._focused])
        else:
            node = self._tree.add(win)
        self._nodes[win] = node

    def remove(self, win):
        if self._focused is win:
            if self.previous_on_rm:
                # select previous window in the list
                self.cmd_up()
                if self._focused is win:
                    self._focused = None
            else:
                self._focused = None
        self._nodes[win].remove()
        del self._nodes[win]
        self.draw_panel()

        # select first window in the list
        if not self.previous_on_rm:
            self.cmd_down()

    def _create_panel(self):
        self._panel = window.Internal.create(
            self.group.qtile,
            0,
            0,
            self.panel_width,
            100
        )
        self._create_drawer()
        self._panel.handle_Expose = self._panel_Expose
        self._panel.handle_ButtonPress = self._panel_ButtonPress
        self.group.qtile.windowMap[self._panel.window.wid] = self._panel
        hook.subscribe.window_name_change(self.draw_panel)
        hook.subscribe.focus_change(self.draw_panel)

    def _panel_Expose(self, e):
        self.draw_panel()

    def draw_panel(self):
        if not self._panel:
            return
        self._drawer.clear(self.bg_color)
        self._tree.draw(self, 0)
        self._drawer.draw(0, self.panel_width)

    def _panel_ButtonPress(self, event):
        node = self._tree.button_press(event.event_x, event.event_y)
        if node:
            self.group.focus(node.window, False)

    def configure(self, client, screen):
        if self._nodes and client is self._focused:
            client.place(
                screen.x, screen.y,
                screen.width, screen.height,
                0,
                None
            )
            client.unhide()
        else:
            client.hide()

    def info(self):
        d = SingleWindow.info(self)
        d["clients"] = [x.name for x in self._nodes]
        d["sections"] = [x.title for x in self._tree.children]
        return d

    def show(self, screen):
        if not self._panel:
            self._create_panel()
        panel, body = screen.hsplit(self.panel_width)
        self._resize_panel(panel)
        self._panel.unhide()

    def hide(self):
        if self._panel:
            self._panel.hide()

    def cmd_down(self):
        """
            Switch down in the window list
        """
        win = None
        if self._focused:
            win = self._nodes[self._focused].get_next_window()
        if not win:
            win = self._tree.get_first_window()
        if win:
            self.group.focus(win.window, False)

    cmd_next = cmd_down

    def cmd_up(self):
        """
            Switch up in the window list
        """
        win = None
        if self._focused:
            win = self._nodes[self._focused].get_prev_window()
        if not win:
            win = self._tree.get_last_window()
        if win:
            self.group.focus(win.window, False)

    cmd_previous = cmd_up

    def cmd_move_up(self):
        win = self._focused
        if not win:
            return
        node = self._nodes[win]
        p = node.parent.children
        idx = p.index(node)
        if idx > 0:
            p[idx] = p[idx - 1]
            p[idx - 1] = node
        self.draw_panel()

    def cmd_move_down(self):
        win = self._focused
        if not win:
            return
        node = self._nodes[win]
        p = node.parent.children
        idx = p.index(node)
        if idx < len(p) - 1:
            p[idx] = p[idx + 1]
            p[idx + 1] = node
        self.draw_panel()

    def cmd_move_left(self):
        win = self._focused
        if not win:
            return
        node = self._nodes[win]
        if not isinstance(node.parent, Section):
            node.parent.children.remove(node)
            node.parent.parent.add(node)
        self.draw_panel()

    def cmd_add_section(self, name):
        """Add named section to tree"""
        self._tree.add_section(name)
        self.draw_panel()

    def cmd_del_section(self, name):
        """Add named section to tree"""
        self._tree.del_section(name)
        self.draw_panel()

    def cmd_section_up(self):
        win = self._focused
        if not win:
            return
        node = self._nodes[win]
        snode = node
        while not isinstance(snode, Section):
            snode = snode.parent
        idx = snode.parent.children.index(snode)
        if idx > 0:
            node.parent.children.remove(node)
            snode.parent.children[idx - 1].add(node)
        self.draw_panel()

    def cmd_section_down(self):
        win = self._focused
        if not win:
            return
        node = self._nodes[win]
        snode = node
        while not isinstance(snode, Section):
            snode = snode.parent
        idx = snode.parent.children.index(snode)
        if idx < len(snode.parent.children) - 1:
            node.parent.children.remove(node)
            snode.parent.children[idx + 1].add(node)
        self.draw_panel()

    def cmd_sort_windows(self, sorter, create_sections=True):
        """Sorts window to sections using sorter function

        :param sorter: returns name of the section where window should be
        :type sorter: function with single arg returning string
        :param create_sections: if this parameter is True (default), if sorter
          returns unknown section name it will be created dynamically
        """
        for sec in self._tree.children:
            for win in sec.children[:]:
                nname = sorter(win.window)
                if nname is None or nname == sec.title:
                    continue
                try:
                    nsec = self._tree.sections[nname]
                except KeyError:
                    if create_sections:
                        self._tree.add_section(nname)
                        nsec = self._tree.sections[nname]
                    else:
                        continue
                sec.children.remove(win)
                nsec.children.append(win)
                win.parent = nsec
        self.draw_panel()

    def cmd_move_right(self):
        win = self._focused
        if not win:
            return
        node = self._nodes[win]
        idx = node.parent.children.index(node)
        if idx > 0:
            node.parent.children.remove(node)
            node.parent.children[idx - 1].add(node)
        self.draw_panel()

    def cmd_expand_branch(self):
        if not self._focused:
            return
        self._nodes[self._focused].expanded = True
        self.draw_panel()

    def cmd_collapse_branch(self):
        if not self._focused:
            return
        self._nodes[self._focused].expanded = False
        self.draw_panel()

    def cmd_increase_ratio(self):
        self.panel_width += 10
        self.group.layoutAll()

    def cmd_decrease_ratio(self):
        self.panel_width -= 10
        self.group.layoutAll()

    def _create_drawer(self):
        self._drawer = drawer.Drawer(
            self.group.qtile,
            self._panel.window.wid,
            self.panel_width,
            self.group.screen.dheight
        )
        self._drawer.clear(self.bg_color)
        self._layout = self._drawer.textlayout(
            "",
            "ffffff",
            self.font,
            self.fontsize,
            self.fontshadow,
            wrap=False
        )

    def layout(self, windows, screen):
        panel, body = screen.hsplit(self.panel_width)
        self._resize_panel(panel)
        SingleWindow.layout(self, windows, body)

    def _resize_panel(self, rect):
        if self._panel:
            self._panel.place(
                rect.x, rect.y,
                rect.width, rect.height,
                0,
                None
            )
            self._create_drawer()
            self.draw_panel()

########NEW FILE########
__FILENAME__ = xmonad
from base import SingleWindow
import math


class MonadTall(SingleWindow):
    """
    This layout attempts to emulate the behavior of XMonad's default
    tiling scheme.

    Main-Pane:

    A main pane that contains a single window takes up a vertical
    portion of the screen based on the ratio setting. This ratio can
    be adjusted with the `cmd_grow' and `cmd_shrink' methods while
    the main pane is in focus.

        ---------------------
        |            |      |
        |            |      |
        |            |      |
        |            |      |
        |            |      |
        |            |      |
        ---------------------

    Using the `cmd_flip' method will switch which horizontal side the
    main pane will occupy. The main pane is considered the "top" of
    the stack.

        ---------------------
        |      |            |
        |      |            |
        |      |            |
        |      |            |
        |      |            |
        |      |            |
        ---------------------

    Secondary-panes:

    Occupying the rest of the screen are one or more secondary panes.
    The secondary panes will share the vertical space of the screen
    however they can be resized at will with the `cmd_grow' and
    `cmd_shrink' methods. The other secondary panes will adjust their
    sizes to smoothly fill all of the space.

        ---------------------          ---------------------
        |            |      |          |            |______|
        |            |______|          |            |      |
        |            |      |          |            |      |
        |            |______|          |            |      |
        |            |      |          |            |______|
        |            |      |          |            |      |
        ---------------------          ---------------------

    Panes can be moved with the `cmd_shuffle_up' and `cmd_shuffle_down'
    methods. As mentioned the main pane is considered the top of the
    stack; moving up is counter-clockwise and moving down is clockwise.

    The opposite is true if the layout is "flipped".

        ---------------------          ---------------------
        |            |  2   |          |   2   |           |
        |            |______|          |_______|           |
        |            |  3   |          |   3   |           |
        |     1      |______|          |_______|     1     |
        |            |  4   |          |   4   |           |
        |            |      |          |       |           |
        ---------------------          ---------------------


    Normalizing:

    To restore all client windows to their default size ratios simply
    use the `cmd_normalize' method.


    Maximizing:

    To toggle a client window between its minimum and maximum sizes
    simply use the `cmd_maximize' on a focused client.

    Suggested Bindings:

    Key([modkey], "h", lazy.layout.left()),
    Key([modkey], "l", lazy.layout.right()),
    Key([modkey], "j", lazy.layout.down()),
    Key([modkey], "k", lazy.layout.up()),
    Key([modkey, "shift"], "h", lazy.layout.swap_left()),
    Key([modkey, "shift"], "l", lazy.layout.swap_right()),
    Key([modkey, "shift"], "j", lazy.layout.shuffle_down()),
    Key([modkey, "shift"], "k", lazy.layout.shuffle_up()),
    Key([modkey], "i", lazy.layout.grow()),
    Key([modkey], "m", lazy.layout.shrink()),
    Key([modkey], "n", lazy.layout.normalize()),
    Key([modkey], "o", lazy.layout.maximize()),
    Key([modkey, "shift"], "space", lazy.layout.flip()),

    """

    _left = 0
    _right = 1
    _min_height = 85
    _min_ratio = .25
    _med_ratio = .5
    _max_ratio = .75

    defaults = [
        ("border_focus", "#ff0000", "Border colour for the focused window."),
        ("border_normal", "#000000", "Border colour for un-focused winows."),
        ("border_width", 2, "Border width."),
        ("name", "xmonad-tall", "Name of this layout."),
    ]

    def __init__(self, ratio=_med_ratio, align=_left, change_ratio=.05,
                 change_size=20, **config):
        """
            - ratio       : The percent of the screen-space the
                            master pane should occupy by default.

            - align       : Which side the master pane will be placed.

            - change_size : Resize change in pixels
        """
        SingleWindow.__init__(self, **config)
        self.add_defaults(MonadTall.defaults)
        self.clients = []
        self.relative_sizes = []
        self.ratio = ratio
        self.align = align
        self.change_size = change_size
        self.change_ratio = change_ratio
        self._focus = 0

    # track client that has 'focus'
    def _get_focus(self):
        return self._focus

    def _set_focus(self, x):
        if len(self.clients) > 0:
            self._focus = abs(x % len(self.clients))
        else:
            self._focus = 0
    focused = property(_get_focus, _set_focus)

    def _get_relative_size_from_absolute(self, absolute_size):
        return float(absolute_size) / self.group.screen.dheight

    def _get_absolute_size_from_relative(self, relative_size):
        return int(relative_size * self.group.screen.dheight)

    def _get_window(self):
        "Get currently focused client"
        if self.clients:
            return self.clients[self.focused]

    def focus(self, client):
        "Set focus to specified client"
        self.focused = self.clients.index(client)

    def clone(self, group):
        "Clone layout for other groups"
        c = SingleWindow.clone(self, group)
        c.clients = []
        c.sizes = []
        c.relative_sizes = []
        c.ratio = self.ratio
        c.align = self.align
        c._focus = 0
        return c

    def add(self, client):
        "Add client to layout"
        self.clients.insert(self.focused + 1, client)
        self.do_normalize = True

    def remove(self, client):
        "Remove client from layout"
        if client not in self.clients:
            return
        # get index of removed client
        idx = self.clients.index(client)
        # remove the client
        self.clients.remove(client)
        # move focus pointer
        self.focused = max(0, idx - 1)
        self.do_normalize = True
        if self.clients:
            return self.clients[self.focused]

    def cmd_normalize(self, redraw=True):
        "Evenly distribute screen-space among secondary clients"
        n = len(self.clients) - 1  # exclude main client, 0
        # if secondary clients exist
        if n > 0 and self.group.screen is not None:
            self.relative_sizes = [1.0 / n] * n
        # reset main pane ratio
        if redraw:
            self.group.layoutAll()
        self.do_normalize = False

    def _maximize_main(self):
        "Toggle the main pane between min and max size"
        if self.ratio <= self._med_ratio:
            self.ratio = self._max_ratio
        else:
            self.ratio = self._min_ratio
        self.group.layoutAll()

    def _maximize_secondary(self):
        "Toggle the focused secondary pane between min and max size"
        n = len(self.clients) - 2  # total shrinking clients
        # total height of collapsed secondaries
        collapsed_height = self._min_height * n
        nidx = self.focused - 1  # focused size index
        # total height of maximized secondary
        maxed_size = self.group.screen.dheight - collapsed_height
        # if maximized or nearly maximized
        if abs(
            self._get_absolute_size_from_relative(self.relative_sizes[nidx]) -
            maxed_size
        ) < self.change_size:
            # minimize
            self._shrink_secondary(
                self._get_absolute_size_from_relative(
                    self.relative_sizes[nidx]
                ) - self._min_height
            )
        # otherwise maximize
        else:
            self._grow_secondary(maxed_size)

    def cmd_maximize(self):
        "Grow the currently focused client to the max size"
        # if we have 1 or 2 panes or main pane is focused
        if len(self.clients) < 3 or self.focused == 0:
            self._maximize_main()
        # secondary is focused
        else:
            self._maximize_secondary()
        self.group.layoutAll()

    def configure(self, client, screen):
        "Position client based on order and sizes"
        # if no sizes or normalize flag is set, normalize
        if not self.relative_sizes or self.do_normalize:
            self.cmd_normalize(False)

        # if client not in this layout
        if not self.clients or client not in self.clients:
            client.hide()
            return

        # single client - fullscreen
        if len(self.clients) == 1:
            px = self.group.qtile.colorPixel(self.border_focus)
            client.place(
                self.group.screen.dx,
                self.group.screen.dy,
                self.group.screen.dwidth,
                self.group.screen.dheight,
                0,
                px
            )
            client.unhide()
            return

        cidx = self.clients.index(client)

        # determine focus border-color
        if cidx == self.focused:
            px = self.group.qtile.colorPixel(self.border_focus)
        else:
            px = self.group.qtile.colorPixel(self.border_normal)

        # calculate main/secondary column widths
        width_main = int(self.group.screen.dwidth * self.ratio)
        width_shared = self.group.screen.dwidth - width_main

        # calculate client's x offset
        if self.align == self._left:  # left orientation
            if cidx == 0:
                # main client
                xpos = self.group.screen.dx
            else:
                # secondary client
                xpos = self.group.screen.dx + width_main
        else:  # right orientation
            if cidx == 0:
                # main client
                xpos = self.group.screen.dx + width_shared
            else:
                # secondary client
                xpos = self.group.screen.dx

        # calculate client height and place
        if cidx > 0:
            # secondary client
            width = width_shared - 2 * self.border_width
            # ypos is the sum of all clients above it
            ypos = self.group.screen.dy + \
                self._get_absolute_size_from_relative(
                    sum(self.relative_sizes[:cidx - 1])
                )
            # get height from precalculated height list
            height = self._get_absolute_size_from_relative(
                self.relative_sizes[cidx - 1]
            )
            # place client based on calculated dimensions
            client.place(
                xpos,
                ypos,
                width,
                height - 2 * self.border_width,
                self.border_width,
                px
            )
            client.unhide()
        else:
            # main client
            width = width_main - 2 * self.border_width
            client.place(
                xpos, self.group.screen.dy,
                width,
                self.group.screen.dheight - 2 * self.border_width,
                self.border_width,
                px
            )
            client.unhide()

    def get_shrink_margin(self, cidx):
        "Return how many remaining pixels a client can shrink"
        return max(
            0,
            self._get_absolute_size_from_relative(
                self.relative_sizes[cidx]
            ) - self._min_height
        )

    def shrink(self, cidx, amt):
        """
        Reduce the size of a client. Will only shrink the client
        until it reaches the configured minimum size. Any amount
        that was prevented in the resize is returned.
        """
        # get max resizable amount
        margin = self.get_shrink_margin(cidx)
        if amt > margin:  # too much
            self.relative_sizes[cidx] -= \
                self._get_relative_size_from_absolute(margin)
            return amt - margin
        else:
            self.relative_sizes[cidx] -= \
                self._get_relative_size_from_absolute(amt)
            return 0

    def shrink_up(self, cidx, amt):
        """
        Will shrink all secondary clients above the specified
        index in order. Each client will attempt to shrink as
        much as it is able before the next client is resized.

        Any amount that was unable to be applied to the
        clients is returned.
        """
        left = amt  # track unused shrink amount
        # for each client before specified index
        for idx in range(0, cidx):
            # shrink by whatever is left-over of original amount
            left -= left - self.shrink(idx, left)
        # return unused shrink amount
        return left

    def shrink_up_shared(self, cidx, amt):
        """
        Will shrink all secondary clients above the specified
        index by an equal share of the provided amount. After
        applying the shared amount to all affected clients,
        any amount left over will be applied in a
        non-equal manner with `shrink_up'.

        Any amount that was unable to be applied to the
        clients is returned.
        """
        # split shrink amount among number of clients
        per_amt = amt / cidx
        left = amt  # track unused shrink amount
        # for each client before specified index
        for idx in range(0, cidx):
            # shrink by equal amount and track left-over
            left -= per_amt - self.shrink(idx, per_amt)
        # apply non-equal shrinkage secondary pass
        # in order to use up any left over shrink amounts
        left = self.shrink_up(cidx, left)
        # return whatever could not be applied
        return left

    def shrink_down(self, cidx, amt):
        """
        Will shrink all secondary clients below the specified
        index in order. Each client will attempt to shrink as
        much as it is able before the next client is resized.

        Any amount that was unable to be applied to the
        clients is returned.
        """
        left = amt  # track unused shrink amount
        # for each client after specified index
        for idx in range(cidx + 1, len(self.relative_sizes)):
            # shrink by current total left-over amount
            left -= left - self.shrink(idx, left)
        # return unused shrink amount
        return left

    def shrink_down_shared(self, cidx, amt):
        """
        Will shrink all secondary clients below the specified
        index by an equal share of the provided amount. After
        applying the shared amount to all affected clients,
        any amount left over will be applied in a
        non-equal manner with `shrink_down'.

        Any amount that was unable to be applied to the
        clients is returned.
        """
        # split shrink amount among number of clients
        per_amt = amt / (len(self.relative_sizes) - 1 - cidx)
        left = amt  # track unused shrink amount
        # for each client after specified index
        for idx in range(cidx + 1, len(self.relative_sizes)):
            # shrink by equal amount and track left-over
            left -= per_amt - self.shrink(idx, per_amt)
        # apply non-equal shinkage secondary pass
        # in order to use up any left over shrink amounts
        left = self.shrink_down(cidx, left)
        # return whatever could not be applied
        return left

    def _grow_main(self, amt):
        """
        Will grow the client that is currently
        in the main pane.
        """
        self.ratio += amt
        self.ratio = min(self._max_ratio, self.ratio)

    def _grow_solo_secondary(self, amt):
        """
        Will grow the solitary client in the
        secondary pane.
        """
        self.ratio -= amt
        self.ratio = max(self._min_ratio, self.ratio)

    def _grow_secondary(self, amt):
        """
        Will grow the focused client in the
        secondary pane.
        """
        half_change_size = amt / 2
        # track unshrinkable amounts
        left = amt
        # first secondary (top)
        if self.focused == 1:
            # only shrink downwards
            left -= amt - self.shrink_down_shared(0, amt)
        # last secondary (bottom)
        elif self.focused == len(self.clients) - 1:
            # only shrink upwards
            left -= amt - self.shrink_up(len(self.relative_sizes) - 1, amt)
        # middle secondary
        else:
            # get size index
            idx = self.focused - 1
            # shrink up and down
            left -= half_change_size - self.shrink_up_shared(
                idx,
                half_change_size
            )
            left -= half_change_size - self.shrink_down_shared(
                idx,
                half_change_size
            )
            left -= half_change_size - self.shrink_up_shared(
                idx,
                half_change_size
            )
            left -= half_change_size - self.shrink_down_shared(
                idx,
                half_change_size
            )
        # calculate how much shrinkage took place
        diff = amt - left
        # grow client by diff amount
        self.relative_sizes[self.focused - 1] += \
            self._get_relative_size_from_absolute(diff)

    def cmd_grow(self):
        """
        Will grow the currently focused client reducing the
        size of those around it. Growing will stop when no
        other secondary clients can reduce their size any
        further.
        """
        # get currently focused client
        self.clients[self.focused]
        if self.focused == 0:
            self._grow_main(self.change_ratio)
        elif len(self.clients) == 2:
            self._grow_solo_secondary(self.change_ratio)
        else:
            self._grow_secondary(self.change_size)
        self.group.layoutAll()

    def grow(self, cidx, amt):
        "Grow secondary client by specified amount"
        self.relative_sizes[cidx] += self._get_relative_size_from_absolute(amt)

    def grow_up_shared(self, cidx, amt):
        """
        Will grow all secondary clients above the specified
        index by an equal share of the provided amount.
        """
        # split grow amount among number of clients
        per_amt = amt / cidx
        for idx in range(0, cidx):
            self.grow(idx, per_amt)

    def grow_down_shared(self, cidx, amt):
        """
        Will grow all secondary clients below the specified
        index by an equal share of the provided amount.
        """
        # split grow amount among number of clients
        per_amt = amt / (len(self.relative_sizes) - 1 - cidx)
        for idx in range(cidx + 1, len(self.relative_sizes)):
            self.grow(idx, per_amt)

    def _shrink_main(self, amt):
        """
        Will shrink the client that currently
        in the main pane.
        """
        self.ratio -= amt
        self.ratio = max(self._min_ratio, self.ratio)

    def _shrink_solo_secondary(self, amt):
        """
        Will shrink the solitary client in the
        secondary pane.
        """
        self.ratio += amt
        self.ratio = min(self._max_ratio, self.ratio)

    def _shrink_secondary(self, amt):
        """
        Will shrink the focused client in the
        secondary pane.
        """
        # get focused client
        client = self.clients[self.focused]

        # get default change size
        change = amt

        # get left-over height after change
        left = client.height - amt
        # if change would violate min_height
        if left < self._min_height:
            # just reduce to min_height
            change = client.height - self._min_height

        # calculate half of that change
        half_change = change / 2

        # first secondary (top)
        if self.focused == 1:
            # only grow downwards
            self.grow_down_shared(0, change)
        # last secondary (bottom)
        elif self.focused == len(self.clients) - 1:
            # only grow upwards
            self.grow_up_shared(len(self.relative_sizes) - 1, change)
        # middle secondary
        else:
            idx = self.focused - 1
            # grow up and down
            self.grow_up_shared(idx, half_change)
            self.grow_down_shared(idx, half_change)
        # shrink client by total change
        self.relative_sizes[self.focused - 1] -= \
            self._get_relative_size_from_absolute(change)

    def focus_first(self):
        if self.clients:
            return self.clients[0]

    def focus_last(self):
        if self.clients:
            return self.clients[-1]

    def focus_next(self, window):
        if not self.clients:
            return
        if self.focused != self.clients.index(window):
            self.focus(window)
        if self.focused + 1 < len(self.clients):
            return self.clients[self.focused + 1]

    def focus_previous(self, window):
        if not self.clients:
            return
        if self.focused != self.clients.index(window):
            self.focus(window)
        if self.focused > 0:
            return self.clients[self.focused - 1]

    def cmd_next(self):
        client = self.focus_next(self.clients[self.focused]) or \
                 self.focus_first()
        self.group.focus(client, False)

    def cmd_previous(self):
        client = self.focus_previous(self.clients[self.focused]) or \
                 self.focus_last()
        self.group.focus(client, False)

    def cmd_shrink(self):
        """
        Will shrink the currently focused client reducing the
        size of those around it. Shrinking will stop when the
        client has reached the minimum size.
        """
        self.clients[self.focused]
        if self.focused == 0:
            self._shrink_main(self.change_ratio)
        elif len(self.clients) == 2:
            self._shrink_solo_secondary(self.change_ratio)
        else:
            self._shrink_secondary(self.change_size)
        self.group.layoutAll()

    def cmd_up(self):
        "Focus on the next more prominent client on the stack"
        self.focused -= 1
        self.group.focus(self.clients[self.focused], False)

    def cmd_down(self):
        "Focus on the less prominent client on the stack"
        self.focused += 1
        self.group.focus(self.clients[self.focused], False)

    def cmd_shuffle_up(self):
        "Shuffle the client up the stack."
        _oldf = self.focused
        self.focused -= 1
        self.clients[_oldf], self.clients[self.focused] = \
            self.clients[self.focused], self.clients[_oldf]
        self.group.layoutAll()
        self.group.focus(self.clients[self.focused], False)

    def cmd_shuffle_down(self):
        "Shuffle the client down the stack."
        _oldf = self.focused
        self.focused += 1
        self.clients[_oldf], self.clients[self.focused] = \
            self.clients[self.focused], self.clients[_oldf]
        self.group.layoutAll()
        self.group.focus(self.clients[self.focused], False)

    def cmd_flip(self):
        "Flip the layout horizontally."
        self.align = self._left if self.align == self._right else self._right
        self.group.layoutAll()

    def _get_closest(self, x, y, clients):
        "Get closest window to a point x,y"
        target = min(
            clients,
            key=lambda c: math.hypot(c.info()['x'] - x, c.info()['y'] - y)
        )
        return target

    def cmd_swap(self, window1, window2):
        "Swap two windows."
        index1 = self.clients.index(window1)
        index2 = self.clients.index(window2)
        self.clients[index1], self.clients[index2] = \
            self.clients[index2], self.clients[index1]
        self.group.layoutAll()
        self.focused = index1
        self.group.focus(window1, False)

    def cmd_swap_left(self):
        "Swap current window with closest window to the left."
        x = self._get_window().x
        y = self._get_window().y
        candidates = [c for c in self.clients if c.info()['x'] < x]
        target = self._get_closest(x, y, candidates)
        self.cmd_swap(self._get_window(), target)

    def cmd_swap_right(self):
        "Swap current window with closest window to the right."
        x = self._get_window().x
        y = self. _get_window().y
        candidates = [c for c in self.clients if c.info()['x'] > x]
        target = self._get_closest(x, y, candidates)
        self.cmd_swap(self._get_window(), target)

    def cmd_left(self):
        "Focus on the closest window to the left of the current window."
        x = self._get_window().x
        y = self._get_window().y
        candidates = [c for c in self.clients if c.info()['x'] < x]
        target = self._get_closest(x, y, candidates)
        self.focused = self.clients.index(target)
        self.group.focus(self.clients[self.focused], False)

    def cmd_right(self):
        "Focus on the closest window to the right of the current window."
        x = self._get_window().x
        y = self._get_window().y
        candidates = [c for c in self.clients if c.info()['x'] > x]
        target = self._get_closest(x, y, candidates)
        self.focused = self.clients.index(target)
        self.group.focus(self.clients[self.focused], False)

########NEW FILE########
__FILENAME__ = zoomy
from base import SingleWindow
from .. import utils


class Zoomy(SingleWindow):
    """
        A layout with single active windows, and few other previews at the
        right
    """
    defaults = [
        ("columnwidth", 150, "Width of the right column"),
        ("property_name", "ZOOM", "Property to set on zoomed window"),
        ("property_small", "0.1", "Property value to set on zoomed window"),
        ("property_big", "1.0", "Property value to set on normal window"),
    ]

    def __init__(self, **config):
        SingleWindow.__init__(self, **config)
        self.add_defaults(Zoomy.defaults)
        self.clients = []
        self.focused = None

    def _get_window(self):
        return self.focused

    def focus_first(self):
        if self.clients:
            return self.clients[0]

    def focus_last(self):
        if self.clients:
            return self.clients[len(self.clients) - 1]

    def focus_next(self, client):
        if client not in self.clients:
            return
        idx = self.clients.index(client)
        if len(self.clients) > idx + 1:
            return self.clients[idx + 1]

    def focus_previous(self, client):
        if not self.clients:
            return
        idx = self.clients.index(client)
        if idx > 0:
            return self.clients[idx - 1]

    def clone(self, group):
        c = SingleWindow.clone(self, group)
        c.clients = []
        return c

    def add(self, client):
        self.clients.insert(0, client)
        self.focus(client)

    def remove(self, client):
        if client not in self.clients:
            return
        if self.focused == client:
            self.cmd_previous()
        self.clients.remove(client)
        return self.focused

    def configure(self, client, screen):
        left, right = screen.hsplit(screen.width - self.columnwidth)
        if client is self.focused:
            client.place(
                left.x,
                left.y,
                left.width,
                left.height,
                0,
                None
            )
        else:
            h = int(right.width * left.height / left.width)
            client_index = self.clients.index(client)
            focused_index = self.clients.index(self.focused)
            offset = client_index - focused_index - 1
            if offset < 0:
                offset += len(self.clients)
            if h * (len(self.clients) - 1) < right.height:
                client.place(
                    right.x,
                    right.y + h * offset,
                    right.width,
                    h,
                    0,
                    None
                )
            else:
                hh = int((right.height - h) / (len(self.clients) - 1))
                client.place(
                    right.x,
                    right.y + hh * offset,
                    right.width,
                    h,
                    0,
                    None
                )
        client.unhide()

    def info(self):
        d = SingleWindow.info(self)
        d["clients"] = [x.name for x in self.clients]
        return d

    def focus(self, win):
        if self.focused and self.property_name:
            self.focused.window.set_property(
                self.property_name,
                self.property_small,
                "STRING",
                format=8
            )
        SingleWindow.focus(self, win)
        if self.property_name:
            self.focused = win
            win.window.set_property(
                self.property_name,
                self.property_big,
                "STRING",
                format=8
            )

    def cmd_next(self):
        client = self.focus_next(self.focused) or \
                 self.focus_first()
        self.group.focus(client, False)

    cmd_down = cmd_next

    def cmd_previous(self):
        client = self.focus_previous(self.focused) or \
                 self.focus_last()
        self.group.focus(client, False)

    cmd_up = cmd_previous

########NEW FILE########
__FILENAME__ = log_utils
import logging
import os
import sys
from logging import getLogger, StreamHandler


class ColorFormatter(logging.Formatter):
    """Logging formatter adding console colors to the output."""
    black, red, green, yellow, blue, magenta, cyan, white = range(8)
    colors = {
        'WARNING': yellow,
        'INFO': green,
        'DEBUG': blue,
        'CRITICAL': yellow,
        'ERROR': red,
        'RED': red,
        'GREEN': green,
        'YELLOW': yellow,
        'BLUE': blue,
        'MAGENTA': magenta,
        'CYAN': cyan,
        'WHITE': white
    }
    reset_seq = '\033[0m'
    color_seq = '\033[%dm'
    bold_seq = '\033[1m'

    def format(self, record):
        """Format the record with colors."""
        color = self.color_seq % (30 + self.colors[record.levelname])
        message = logging.Formatter.format(self, record)
        message = message.replace('$RESET', self.reset_seq)\
            .replace('$BOLD', self.bold_seq)\
            .replace('$COLOR', color)
        for color, value in self.colors.items():
            message = message.replace(
                '$' + color, self.color_seq % (value + 30))\
                .replace('$BG' + color, self.color_seq % (value + 40))\
                .replace('$BG-' + color, self.color_seq % (value + 40))
        return message + self.reset_seq


def init_log(log_level=logging.ERROR, logger='qtile'):
    handler = logging.FileHandler(
        os.path.expanduser('~/.%s.log' % logger)
    )
    handler.setFormatter(
        logging.Formatter(
            "%(asctime)s %(levelname)s %(funcName)s:%(lineno)d %(message)s"
        )
    )
    log = getLogger(logger)
    log.setLevel(log_level)
    log.addHandler(handler)
    log.warning('Starting %s' % logger.title())
    handler = StreamHandler(sys.stderr)
    handler.setFormatter(
        ColorFormatter(
            '$RESET$COLOR%(asctime)s $BOLD$COLOR%(name)s'
            ' %(funcName)s:%(lineno)d $RESET %(message)s'
        )
    )
    log.addHandler(handler)
    return log

########NEW FILE########
__FILENAME__ = manager
# vim: tabstop=4 shiftwidth=4 expandtab
# Copyright (c) 2008, Aldo Cortesi. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from config import Drag, Click, Screen, Match, Rule
from utils import QtileError
from libqtile.log_utils import init_log
from libqtile.dgroups import DGroups
from state import QtileState
from group import _Group
from StringIO import StringIO
from xcb.xproto import EventMask, BadWindow, BadAccess, BadDrawable
import atexit
import command
import gobject
import hook
import logging
import os
import os.path
import pickle
import sys
import traceback
import utils
import window
import xcb
import xcb.xinerama
import xcb.xproto
import xcbq

from widget.base import _Widget


class Qtile(command.CommandObject):
    """
        This object is the __root__ of the command graph.
    """
    _exit = False

    def __init__(self, config,
                 displayName=None, fname=None, no_spawn=False, log=None,
                 state=None):
        gobject.threads_init()
        self.log = log or init_log()
        if hasattr(config, "log_level"):
            self.log.setLevel(config.log_level)

        self.no_spawn = no_spawn

        if not displayName:
            displayName = os.environ.get("DISPLAY")
            if not displayName:
                raise QtileError("No DISPLAY set.")

        if not fname:
            # Dots might appear in the host part of the display name
            # during remote X sessions. Let's strip the host part first.
            displayNum = displayName.partition(":")[2]
            if not "." in displayNum:
                displayName = displayName + ".0"
            fname = command.find_sockfile(displayName)

        self.conn = xcbq.Connection(displayName)
        self.config = config
        self.fname = fname
        hook.init(self)

        self.keyMap = {}
        self.windowMap = {}
        self.widgetMap = {}
        self.groupMap = {}
        self.groups = []
        self.keyMap = {}

        # Find the modifier mask for the numlock key, if there is one:
        nc = self.conn.keysym_to_keycode(xcbq.keysyms["Num_Lock"])
        self.numlockMask = xcbq.ModMasks[self.conn.get_modifier(nc)]
        self.validMask = ~(self.numlockMask | xcbq.ModMasks["lock"])

        # Because we only do Xinerama multi-screening,
        # we can assume that the first
        # screen's root is _the_ root.
        self.root = self.conn.default_screen.root
        self.root.set_attribute(
            eventmask=(
                EventMask.StructureNotify |
                EventMask.SubstructureNotify |
                EventMask.SubstructureRedirect |
                EventMask.EnterWindow |
                EventMask.LeaveWindow
            )
        )

        self.root.set_property(
            '_NET_SUPPORTED',
            [self.conn.atoms[x] for x in xcbq.SUPPORTED_ATOMS]
        )

        self.supporting_wm_check_window = self.conn.create_window(-1, -1, 1, 1)
        self.root.set_property(
            '_NET_SUPPORTING_WM_CHECK',
            self.supporting_wm_check_window.wid
        )

        # TODO: maybe allow changing the name without external tools?
        self.supporting_wm_check_window.set_property('_NET_WM_NAME', "qtile")
        self.supporting_wm_check_window.set_property(
            '_NET_SUPPORTING_WM_CHECK',
            self.supporting_wm_check_window.wid
        )

        if config.main:
            config.main(self)

        self.dgroups = None
        if self.config.groups:
            key_binder = None
            if hasattr(self.config, 'dgroups_key_binder'):
                key_binder = self.config.dgroups_key_binder
            self.dgroups = DGroups(self, self.config.groups, key_binder)

        if hasattr(config, "widget_defaults") and config.widget_defaults:
            _Widget.global_defaults = config.widget_defaults
        else:
            _Widget.global_defaults = {}

        for i in self.groups:
            self.groupMap[i.name] = i

        self.currentScreen = None
        self.screens = []
        self._process_screens()
        self.currentScreen = self.screens[0]
        self._drag = None

        self.ignoreEvents = set([
            xcb.xproto.KeyReleaseEvent,
            xcb.xproto.ReparentNotifyEvent,
            xcb.xproto.CreateNotifyEvent,
            # DWM handles this to help "broken focusing windows".
            xcb.xproto.MapNotifyEvent,
            xcb.xproto.LeaveNotifyEvent,
            xcb.xproto.FocusOutEvent,
            xcb.xproto.FocusInEvent,
            xcb.xproto.NoExposureEvent
        ])

        self.conn.flush()
        self.conn.xsync()
        self._xpoll()

        self.server = command._Server(self.fname, self, config)

        # Map and Grab keys
        for key in self.config.keys:
            self.mapKey(key)

        # It fixes problems with focus when clicking windows of some specific clients like xterm
        def noop(qtile):
            pass
        self.config.mouse += (Click([], "Button1", command.lazy.function(noop), focus="after"),)

        self.mouseMap = {}
        for i in self.config.mouse:
            if self.mouseMap.get(i.button_code) is None:
                self.mouseMap[i.button_code] = []
            self.mouseMap[i.button_code].append(i)

        self.grabMouse()

        hook.fire("startup")

        self.scan()
        self.update_net_desktops()
        hook.subscribe.setgroup(self.update_net_desktops)

        if state:
            st = pickle.load(StringIO(state))
            st.apply(self)

    def _process_fake_screens(self):
        """
        Since Xephyr, Xnest don't really support offset screens,
        we'll fake it here for testing, (or if you want to partition
        a physical monitor into separate screens)
        """
        for i, s in enumerate(self.config.fake_screens):
            # should have x,y, width and height set
            s._configure(self, i, s.x, s.y, s.width, s.height, self.groups[i])
            if not self.currentScreen:
                self.currentScreen = s
            self.screens.append(s)

    def _process_screens(self):
        if hasattr(self.config, 'fake_screens'):
            self._process_fake_screens()
            return

        xywh = {}
        for s in self.conn.pseudoscreens:
            pos = (s.x, s.y)
            (w, h) = xywh.get(pos, (0, 0))
            xywh[pos] = (max(s.width, w), max(s.height, h))

        for i, ((x, y), (w, h)) in enumerate(sorted(xywh.items())):
            if i + 1 > len(self.config.screens):
                scr = Screen()
            else:
                scr = self.config.screens[i]
            if not self.currentScreen:
                self.currentScreen = scr
            scr._configure(
                self,
                i,
                x,
                y,
                w,
                h,
                self.groups[i],
            )
            self.screens.append(scr)

        if not self.screens:
            if self.config.screens:
                s = self.config.screens[0]
            else:
                s = Screen()
            self.currentScreen = s
            s._configure(
                self,
                0, 0, 0,
                self.conn.default_screen.width_in_pixels,
                self.conn.default_screen.height_in_pixels,
                self.groups[0],
            )
            self.screens.append(s)

    def mapKey(self, key):
        self.keyMap[(key.keysym, key.modmask & self.validMask)] = key
        code = self.conn.keysym_to_keycode(key.keysym)
        self.root.grab_key(
            code,
            key.modmask,
            True,
            xcb.xproto.GrabMode.Async,
            xcb.xproto.GrabMode.Async,
        )
        if self.numlockMask:
            self.root.grab_key(
                code,
                key.modmask | self.numlockMask,
                True,
                xcb.xproto.GrabMode.Async,
                xcb.xproto.GrabMode.Async,
            )
            self.root.grab_key(
                code,
                key.modmask | self.numlockMask | xcbq.ModMasks["lock"],
                True,
                xcb.xproto.GrabMode.Async,
                xcb.xproto.GrabMode.Async,
            )

    def unmapKey(self, key):
        key_index = (key.keysym, key.modmask & self.validMask)
        if not key_index in self.keyMap:
            return

        code = self.conn.keysym_to_keycode(key.keysym)
        self.root.ungrab_key(code, key.modmask)
        if self.numlockMask:
            self.root.ungrab_key(code, key.modmask | self.numlockMask)
            self.root.ungrab_key(
                code,
                key.modmask | self.numlockMask | xcbq.ModMasks["lock"]
            )
        del(self.keyMap[key_index])

    def update_net_desktops(self):
        try:
            index = self.groups.index(self.currentGroup)
        except:
            index = 0

        self.root.set_property("_NET_NUMBER_OF_DESKTOPS", len(self.groups))
        self.root.set_property(
            "_NET_DESKTOP_NAMES", "\0".join([i.name for i in self.groups])
        )
        self.root.set_property("_NET_CURRENT_DESKTOP", index)

    def addGroup(self, name, layout=None, layouts=None):
        if name not in self.groupMap.keys():
            g = _Group(name, layout)
            self.groups.append(g)
            if not layouts:
                layouts = self.config.layouts
            g._configure(layouts, self.config.floating_layout, self)
            self.groupMap[name] = g
            hook.fire("addgroup", self, name)
            hook.fire("changegroup")
            self.update_net_desktops()

            return True
        return False

    def delGroup(self, name):
        # one group per screen is needed
        if len(self.groups) == len(self.screens):
            raise ValueError("Can't delete all groups.")
        if name in self.groupMap.keys():
            group = self.groupMap[name]
            if group.screen and group.screen.previous_group:
                target = group.screen.previous_group
            else:
                target = group.prevGroup()

            # Find a group that's not currently on a screen to bring to the
            # front. This will terminate because of our check above.
            while target.screen:
                target = target.prevGroup()
            for i in list(group.windows):
                i.togroup(target.name)
            if self.currentGroup.name == name:
                self.currentScreen.setGroup(target)
            self.groups.remove(group)
            del(self.groupMap[name])
            hook.fire("delgroup", self, name)
            hook.fire("changegroup")
            self.update_net_desktops()

    def registerWidget(self, w):
        """
            Register a bar widget. If a widget with the same name already
            exists, this will silently ignore that widget. However, this is
            not necessarily a bug. By default a widget's name is just
            self.__class__.lower(), so putting multiple widgets of the same
            class will alias and one will be inaccessable. Since more than one
            groupbox widget is useful when you have more than one screen, this
            is a not uncommon occurrence. If you want to use the debug
            info for widgets with the same name, set the name yourself.
        """
        if w.name:
            if w.name in self.widgetMap:
                return
            self.widgetMap[w.name] = w

    @utils.LRUCache(200)
    def colorPixel(self, name):
        return self.conn.screens[0].default_colormap.alloc_color(name).pixel

    @property
    def currentLayout(self):
        return self.currentGroup.layout

    @property
    def currentGroup(self):
        return self.currentScreen.group

    @property
    def currentWindow(self):
        return self.currentScreen.group.currentWindow

    def scan(self):
        _, _, children = self.root.query_tree()
        for item in children:
            try:
                attrs = item.get_attributes()
                state = item.get_wm_state()
            except (xcb.xproto.BadWindow, xcb.xproto.BadAccess):
                continue

            if attrs and attrs.map_state == xcb.xproto.MapState.Unmapped:
                continue
            if state and state[0] == window.WithdrawnState:
                continue
            self.manage(item)

    def unmanage(self, win):
        c = self.windowMap.get(win)
        if c:
            hook.fire("client_killed", c)
            self.reset_gaps(c)
            if getattr(c, "group", None):
                c.window.unmap()
                c.state = window.WithdrawnState
                c.group.remove(c)
            del self.windowMap[win]
            self.update_client_list()

    def reset_gaps(self, c):
        if c.strut:
            self.update_gaps((0, 0, 0, 0), c.strut)

    def update_gaps(self, strut, old_strut=None):
        from libqtile.bar import Gap

        (left, right, top, bottom) = strut[:4]
        if old_strut:
            (old_left, old_right, old_top, old_bottom) = old_strut[:4]
            if not left and old_left:
                self.currentScreen.left = None
            elif not right and old_right:
                self.currentScreen.right = None
            elif not top and old_top:
                self.currentScreen.top = None
            elif not bottom and old_bottom:
                self.currentScreen.bottom = None

        if top:
            self.currentScreen.top = Gap(top)
        elif bottom:
            self.currentScreen.bottom = Gap(bottom)
        elif left:
            self.currentScreen.left = Gap(left)
        elif right:
            self.currentScreen.right = Gap(right)
        self.currentScreen.resize()

    def manage(self, w):
        try:
            attrs = w.get_attributes()
            internal = w.get_property("QTILE_INTERNAL")
        except (xcb.xproto.BadWindow, xcb.xproto.BadAccess):
            return
        if attrs and attrs.override_redirect:
            return

        if not w.wid in self.windowMap:
            if internal:
                try:
                    c = window.Internal(w, self)
                except (xcb.xproto.BadWindow, xcb.xproto.BadAccess):
                    return
                self.windowMap[w.wid] = c
            else:
                try:
                    c = window.Window(w, self)
                except (xcb.xproto.BadWindow, xcb.xproto.BadAccess):
                    return

                if w.get_wm_type() == "dock" or c.strut:
                    c.static(self.currentScreen.index)
                else:
                    hook.fire("client_new", c)

                # Window may be defunct because
                # it's been declared static in hook.
                if c.defunct:
                    return
                self.windowMap[w.wid] = c
                # Window may have been bound to a group in the hook.
                if not c.group:
                    self.currentScreen.group.add(c)
                self.update_client_list()
                hook.fire("client_managed", c)
            return c
        else:
            return self.windowMap[w.wid]

    def update_client_list(self):
        """
        Updates the client stack list
        this is needed for third party tasklists
        and drag and drop of tabs in chrome
        """

        windows = [wid for wid, c in self.windowMap.iteritems() if c.group]
        self.root.set_property("_NET_CLIENT_LIST", windows)
        # TODO: check stack order
        self.root.set_property("_NET_CLIENT_LIST_STACKING", windows)

    def grabMouse(self):
        self.root.ungrab_button(None, None)
        for i in self.config.mouse:
            if isinstance(i, Click) and i.focus:
                # Make a freezing grab on mouse button to gain focus
                # Event will propagate to target window
                grabmode = xcb.xproto.GrabMode.Sync
            else:
                grabmode = xcb.xproto.GrabMode.Async
            eventmask = EventMask.ButtonPress
            if isinstance(i, Drag):
                eventmask |= EventMask.ButtonRelease
            self.root.grab_button(
                i.button_code,
                i.modmask,
                True,
                eventmask,
                grabmode,
                xcb.xproto.GrabMode.Async,
            )
            if self.numlockMask:
                self.root.grab_button(
                    i.button_code,
                    i.modmask | self.numlockMask,
                    True,
                    eventmask,
                    grabmode,
                    xcb.xproto.GrabMode.Async,
                )
                self.root.grab_button(
                    i.button_code,
                    i.modmask | self.numlockMask | xcbq.ModMasks["lock"],
                    True,
                    eventmask,
                    grabmode,
                    xcb.xproto.GrabMode.Async,
                )

    def grabKeys(self):
        self.root.ungrab_key(None, None)
        for key in self.keyMap.values():
            self.mapKey(key)

    def get_target_chain(self, ename, e):
        """
            Returns a chain of targets that can handle this event. The event
            will be passed to each target in turn for handling, until one of
            the handlers returns False or the end of the chain is reached.
        """
        chain = []
        handler = "handle_%s" % ename
        # Certain events expose the affected window id as an "event" attribute.
        eventEvents = [
            "EnterNotify",
            "ButtonPress",
            "ButtonRelease",
            "KeyPress",
        ]
        c = None
        if hasattr(e, "window"):
            c = self.windowMap.get(e.window)
        elif hasattr(e, "drawable"):
            c = self.windowMap.get(e.drawable)
        elif ename in eventEvents:
            c = self.windowMap.get(e.event)

        if c and hasattr(c, handler):
            chain.append(getattr(c, handler))
        if hasattr(self, handler):
            chain.append(getattr(self, handler))
        if not chain:
            self.log.info("Unknown event: %r" % ename)
        return chain

    def _xpoll(self, conn=None, cond=None):
        while True:
            try:
                e = self.conn.conn.poll_for_event()
                if not e:
                    break
                # This should be done in xpyb
                # client mesages start at 128
                if e.response_type >= 128:
                    e = xcb.xproto.ClientMessageEvent(e)

                ename = e.__class__.__name__

                if ename.endswith("Event"):
                    ename = ename[:-5]
                if not e.__class__ in self.ignoreEvents:
                    self.log.debug(ename)
                    for h in self.get_target_chain(ename, e):
                        self.log.info("Handling: %s" % ename)
                        r = h(e)
                        if not r:
                            break
            except Exception as e:
                error_code = self.conn.conn.has_error()
                if error_code:
                    error_string = xcbq.XCB_CONN_ERRORS[error_code]
                    self.log.exception("Shutting down due to X connection error %s (%s)" %
                        (error_string, error_code))
                    self.conn.disconnect()
                    self._exit = True
                    return False

                self.log.exception("Got an exception in poll loop")
        return True

    def loop(self):

        self.server.start()
        self.log.info('Adding io watch')
        display_tag = gobject.io_add_watch(
            self.conn.conn.get_file_descriptor(),
            gobject.IO_IN, self._xpoll
        )
        try:
            context = gobject.main_context_default()
            while True:
                if context.iteration(True):
                    try:
                        # this seems to be crucial part
                        self.conn.flush()

                    # Catch some bad X exceptions. Since X is event based, race
                    # conditions can occur almost anywhere in the code. For
                    # example, if a window is created and then immediately
                    # destroyed (before the event handler is evoked), when the
                    # event handler tries to examine the window properties, it
                    # will throw a BadWindow exception. We can essentially
                    # ignore it, since the window is already dead and we've got
                    # another event in the queue notifying us to clean it up.
                    except (BadWindow, BadAccess, BadDrawable):
                        pass
                if self._exit:
                    self.log.info('Got shutdown, Breaking main loop cleanly')
                    break
        finally:
            self.log.info('Removing source')
            gobject.source_remove(display_tag)

    def find_screen(self, x, y):
        """
            Find a screen based on the x and y offset.
        """
        result = []
        for i in self.screens:
            if x >= i.x and x <= i.x + i.width and \
                    y >= i.y and y <= i.y + i.height:
                result.append(i)
        if len(result) == 1:
            return result[0]
        return None

    def find_closest_screen(self, x, y):
        """
        If find_screen returns None, then this basically extends a
        screen vertically and horizontally and see if x,y lies in the
        band.

        Only works if it can find a SINGLE closest screen, else we
        revert to _find_closest_closest.

        Useful when dragging a window out of a screen onto another but
        having leftmost corner above viewport.
        """
        normal = self.find_screen(x, y)
        if normal is not None:
            return normal
        x_match = []
        y_match = []
        for i in self.screens:
            if x >= i.x and x <= i.x + i.width:
                x_match.append(i)
            if y >= i.y and y <= i.y + i.height:
                y_match.append(i)
        if len(x_match) == 1:
            return x_match[0]
        if len(y_match) == 1:
            return y_match[0]
        return self._find_closest_closest(x, y, x_match + y_match)

    def _find_closest_closest(self, x, y, candidate_screens):
        """
        if find_closest_screen can't determine one, we've got multiple
        screens, so figure out who is closer.  We'll calculate using
        the square of the distance from the center of a screen.

        Note that this could return None if x, y is right/below all
        screens (shouldn't happen but we don't do anything about it
        here other than returning None)
        """
        closest_distance = None
        closest_screen = None
        if not candidate_screens:
            # try all screens
            candidate_screens = self.screens
        # if left corner is below and right of screen
        # it can't really be a candidate
        candidate_screens = [
            s for s in candidate_screens
            if x < s.x + s.width and y < s.y + s.width
        ]
        for s in candidate_screens:
            middle_x = s.x + s.width / 2
            middle_y = s.y + s.height / 2
            distance = (x - middle_x) ** 2 + (y - middle_y) ** 2
            if closest_distance is None or distance < closest_distance:
                closest_distance = distance
                closest_screen = s
        return closest_screen

    def handle_EnterNotify(self, e):
        if e.event in self.windowMap:
            return True
        s = self.find_screen(e.root_x, e.root_y)
        if s:
            self.toScreen(s.index)

    def handle_ClientMessage(self, event):
        atoms = self.conn.atoms

        opcode = xcb.xproto.ClientMessageData(event, 0, 20).data32[2]
        data = xcb.xproto.ClientMessageData(event, 12, 20)

        # handle change of desktop
        if atoms["_NET_CURRENT_DESKTOP"] == opcode:
            index = data.data32[0]
            try:
                self.currentScreen.setGroup(self.groups[index])
            except IndexError:
                self.log.info("Invalid Desktop Index: %s" % index)

    def handle_KeyPress(self, e):
        keysym = self.conn.code_to_syms[e.detail][0]
        state = e.state
        if self.numlockMask:
            state = e.state | self.numlockMask
        k = self.keyMap.get((keysym, state & self.validMask))
        if not k:
            self.log.info("Ignoring unknown keysym: %s" % keysym)
            return
        for i in k.commands:
            if i.check(self):
                status, val = self.server.call(
                    (i.selectors, i.name, i.args, i.kwargs)
                )
                if status in (command.ERROR, command.EXCEPTION):
                    self.log.error("KB command error %s: %s" % (i.name, val))
        else:
            return

    def cmd_focus_by_click(self, e):
        wnd = e.child or e.root

        # Additional option for config.py
        # Brings clicked window to front
        if self.config.bring_front_click:
            self.conn.conn.core.ConfigureWindow(
                wnd,
                xcb.xproto.ConfigWindow.StackMode,
                [xcb.xproto.StackMode.Above]
            )

        if self.windowMap.get(wnd):
            self.currentGroup.focus(self.windowMap.get(wnd), False)
            self.windowMap.get(wnd).focus(False)

        self.conn.conn.core.AllowEvents(xcb.xproto.Allow.ReplayPointer, e.time)
        self.conn.conn.flush()

    def handle_ButtonPress(self, e):
        button_code = e.detail
        state = e.state
        if self.numlockMask:
            state = e.state | self.numlockMask

        k = self.mouseMap.get(button_code)
        for m in k:
            if not m or m.modmask & self.validMask != state & self.validMask:
                self.log.info("Ignoring unknown button: %s" % button_code)
                continue
            if isinstance(m, Click):
                for i in m.commands:
                    if i.check(self):
                        if m.focus == "before":
                            self.cmd_focus_by_click(e)
                        status, val = self.server.call(
                            (i.selectors, i.name, i.args, i.kwargs))
                        if m.focus == "after":
                            self.cmd_focus_by_click(e)
                        if status in (command.ERROR, command.EXCEPTION):
                            self.log.error(
                                "Mouse command error %s: %s" % (i.name, val)
                            )
            elif isinstance(m, Drag):
                x = e.event_x
                y = e.event_y
                if m.start:
                    i = m.start
                    if m.focus == "before":
                        self.cmd_focus_by_click(e)
                    status, val = self.server.call(
                        (i.selectors, i.name, i.args, i.kwargs))
                    if status in (command.ERROR, command.EXCEPTION):
                        self.log.error(
                            "Mouse command error %s: %s" % (i.name, val)
                        )
                        continue
                else:
                    val = (0, 0)
                if m.focus == "after":
                    self.cmd_focus_by_click(e)
                self._drag = (x, y, val[0], val[1], m.commands)
                self.root.grab_pointer(
                    True,
                    xcbq.ButtonMotionMask |
                    xcbq.AllButtonsMask |
                    xcbq.ButtonReleaseMask,
                    xcb.xproto.GrabMode.Async,
                    xcb.xproto.GrabMode.Async,
                )


    def handle_ButtonRelease(self, e):
        button_code = e.detail
        state = e.state & ~xcbq.AllButtonsMask
        if self.numlockMask:
            state = state | self.numlockMask
        k = self.mouseMap.get(button_code)
        for m in k:
            if not m:
                self.log.info(
                    "Ignoring unknown button release: %s" % button_code
                )
                continue
            if isinstance(m, Drag):
                self._drag = None
                self.root.ungrab_pointer()

    def handle_MotionNotify(self, e):
        if self._drag is None:
            return
        ox, oy, rx, ry, cmd = self._drag
        dx = e.event_x - ox
        dy = e.event_y - oy
        if dx or dy:
            for i in cmd:
                if i.check(self):
                    status, val = self.server.call((
                        i.selectors,
                        i.name,
                        i.args + (rx + dx, ry + dy, e.event_x, e.event_y),
                        i.kwargs
                    ))
                    if status in (command.ERROR, command.EXCEPTION):
                        self.log.error(
                            "Mouse command error %s: %s" % (i.name, val)
                        )

    def handle_ConfigureNotify(self, e):
        """
            Handle xrandr events.
        """
        screen = self.currentScreen
        if e.window == self.root.wid and \
                e.width != screen.width and \
                e.height != screen.height:
            screen.resize(0, 0, e.width, e.height)

    def handle_ConfigureRequest(self, e):
        # It's not managed, or not mapped, so we just obey it.
        cw = xcb.xproto.ConfigWindow
        args = {}
        if e.value_mask & cw.X:
            args["x"] = max(e.x, 0)
        if e.value_mask & cw.Y:
            args["y"] = max(e.y, 0)
        if e.value_mask & cw.Height:
            args["height"] = max(e.height, 0)
        if e.value_mask & cw.Width:
            args["width"] = max(e.width, 0)
        if e.value_mask & cw.BorderWidth:
            args["borderwidth"] = max(e.border_width, 0)
        w = xcbq.Window(self.conn, e.window)
        w.configure(**args)

    def handle_MappingNotify(self, e):
        self.conn.refresh_keymap()
        if e.request == xcb.xproto.Mapping.Keyboard:
            self.grabKeys()

    def handle_MapRequest(self, e):
        w = xcbq.Window(self.conn, e.window)
        c = self.manage(w)
        if c and (not c.group or not c.group.screen):
            return
        w.map()

    def handle_DestroyNotify(self, e):
        self.unmanage(e.window)

    def handle_UnmapNotify(self, e):
        if e.event != self.root.wid:
            self.unmanage(e.window)

    def handle_ScreenChangeNotify(self, e):
        hook.fire("screen_change", self, e)

    def toScreen(self, n):
        """
        Have Qtile move to screen and put focus there
        """
        if len(self.screens) < n - 1:
            return
        self.currentScreen = self.screens[n]
        self.currentGroup.focus(self.currentWindow, True)

    def moveToGroup(self, group):
        """
            Create a group if it doesn't exist and move a windows there
        """
        if self.currentWindow and group:
            self.addGroup(group)
            self.currentWindow.togroup(group)

    def _items(self, name):
        if name == "group":
            return True, self.groupMap.keys()
        elif name == "layout":
            return True, range(len(self.currentGroup.layouts))
        elif name == "widget":
            return False, self.widgetMap.keys()
        elif name == "bar":
            return False, [x.position for x in self.currentScreen.gaps]
        elif name == "window":
            return True, self.listWID()
        elif name == "screen":
            return True, range(len(self.screens))

    def _select(self, name, sel):
        if name == "group":
            if sel is None:
                return self.currentGroup
            else:
                return self.groupMap.get(sel)
        elif name == "layout":
            if sel is None:
                return self.currentGroup.layout
            else:
                return utils.lget(self.currentGroup.layouts, sel)
        elif name == "widget":
            return self.widgetMap.get(sel)
        elif name == "bar":
            return getattr(self.currentScreen, sel)
        elif name == "window":
            if sel is None:
                return self.currentWindow
            else:
                return self.clientFromWID(sel)
        elif name == "screen":
            if sel is None:
                return self.currentScreen
            else:
                return utils.lget(self.screens, sel)

    def listWID(self):
        return [i.window.wid for i in self.windowMap.values()]

    def clientFromWID(self, wid):
        for i in self.windowMap.values():
            if i.window.wid == wid:
                return i
        return None

    def cmd_debug(self):
        """Set log level to DEBUG"""
        self.log.setLevel(logging.DEBUG)
        self.log.debug('Switching to DEBUG threshold')

    def cmd_info(self):
        """Set log level to INFO"""
        self.log.setLevel(logging.INFO)
        self.log.info('Switching to INFO threshold')

    def cmd_warning(self):
        """Set log level to WARNING"""
        self.log.setLevel(logging.WARNING)
        self.log.warning('Switching to WARNING threshold')

    def cmd_error(self):
        """Set log level to ERROR"""
        self.log.setLevel(logging.ERROR)
        self.log.error('Switching to ERROR threshold')

    def cmd_critical(self):
        """Set log level to CRITICAL"""
        self.log.setLevel(logging.CRITICAL)
        self.log.critical('Switching to CRITICAL threshold')

    def cmd_pause(self):
        """Drops into pdb"""
        import pdb
        pdb.set_trace()

    def cmd_groups(self):
        """
            Return a dictionary containing information for all groups.

            Example:

                groups()
        """
        return dict({i.name: i.info() for i in self.groups})

    def cmd_list_widgets(self):
        """
            List of all addressible widget names.
        """
        return self.widgetMap.keys()

    def cmd_nextlayout(self, group=None):
        """
            Switch to the next layout.

            :group Group name. If not specified, the current group is assumed.
        """
        if group:
            group = self.groupMap.get(group)
        else:
            group = self.currentGroup
        group.nextLayout()

    def cmd_prevlayout(self, group=None):
        """
            Switch to the prev layout.

            :group Group name. If not specified, the current group is assumed.
        """
        if group:
            group = self.groupMap.get(group)
        else:
            group = self.currentGroup
        group.prevLayout()

    def cmd_screens(self):
        """
            Return a list of dictionaries providing information on all screens.
        """
        lst = []
        for i in self.screens:
            lst.append(dict(
                index=i.index,
                group=i.group.name if i.group is not None else None,
                x=i.x,
                y=i.y,
                width=i.width,
                height=i.height,
                gaps=dict(
                    top=i.top.geometry() if i.top else None,
                    bottom=i.bottom.geometry() if i.bottom else None,
                    left=i.left.geometry() if i.left else None,
                    right=i.right.geometry() if i.right else None,
                )
            ))
        return lst

    def cmd_simulate_keypress(self, modifiers, key):
        """
            Simulates a keypress on the focused window.

            :modifiers A list of modifier specification strings. Modifiers can
            be one of "shift", "lock", "control" and "mod1" - "mod5".
            :key Key specification.

            Examples:

                simulate_keypress(["control", "mod2"], "k")
        """
        # FIXME: This needs to be done with sendevent, once we have that fixed.
        keysym = xcbq.keysyms.get(key)
        if keysym is None:
            raise command.CommandError("Unknown key: %s" % key)
        keycode = self.conn.first_sym_to_code[keysym]

        class DummyEv:
            pass

        d = DummyEv()
        d.detail = keycode
        try:
            d.state = utils.translateMasks(modifiers)
        except KeyError, v:
            return v.args[0]
        self.handle_KeyPress(d)

    def cmd_execute(self, cmd, args):
        """
            Executes the specified command, replacing the current process.
        """
        atexit._run_exitfuncs()
        os.execv(cmd, args)

    def cmd_restart(self):
        """
            Restart qtile using the execute command.
        """
        argv = [sys.executable] + sys.argv
        if '--no-spawn' not in argv:
            argv.append('--no-spawn')

        buf = StringIO()
        pickle.dump(QtileState(self), buf)
        argv = filter(lambda s: not s.startswith('--with-state'), argv)
        argv.append('--with-state=' + buf.getvalue())

        self.cmd_execute(sys.executable, argv)

    def cmd_spawn(self, cmd):
        """
            Run cmd in a shell.

            Example:

                spawn("firefox")
        """
        gobject.spawn_async([os.environ['SHELL'], '-c', cmd])

    def cmd_status(self):
        """
            Return "OK" if Qtile is running.
        """
        return "OK"

    def cmd_sync(self):
        """
            Sync the X display. Should only be used for development.
        """
        self.conn.flush()

    def cmd_to_screen(self, n):
        """
            Warp focus to screen n, where n is a 0-based screen number.

            Example:

                to_screen(0)
        """
        return self.toScreen(n)

    def cmd_to_next_screen(self):
        """
            Move to next screen
        """
        return self.toScreen(
            (self.screens.index(self.currentScreen) + 1) % len(self.screens)
        )

    def cmd_to_prev_screen(self):
        """
            Move to the previous screen
        """
        return self.toScreen(
            (self.screens.index(self.currentScreen) - 1) % len(self.screens)
        )

    def cmd_windows(self):
        """
            Return info for each client window.
        """
        return [
            i.info() for i in self.windowMap.values()
            if not isinstance(i, window.Internal)
        ]

    def cmd_internal_windows(self):
        """
            Return info for each internal window (bars, for example).
        """
        return [
            i.info() for i in self.windowMap.values()
            if isinstance(i, window.Internal)
        ]

    def cmd_qtile_info(self):
        """
            Returns a dictionary of info on the Qtile instance.
        """
        return dict(socketname=self.fname)

    def cmd_shutdown(self):
        """
            Quit Qtile.
        """
        self._exit = True

    def cmd_switch_groups(self, groupa, groupb):
        """
            Switch position of groupa to groupb
        """
        if groupa not in self.groupMap or groupb not in self.groupMap:
            return

        indexa = self.groups.index(self.groupMap[groupa])
        indexb = self.groups.index(self.groupMap[groupb])

        self.groups[indexa], self.groups[indexb] = \
            self.groups[indexb], self.groups[indexa]
        hook.fire("setgroup")

        # update window _NET_WM_DESKTOP
        for group in (self.groups[indexa], self.groups[indexb]):
            for window in group.windows:
                window.group = group

    def find_window(self, wid):
        window = self.windowMap.get(wid)
        if window:
            if not window.group.screen:
                self.currentScreen.setGroup(window.group)
            window.group.focus(window, False)

    def cmd_findwindow(self, prompt="window", widget="prompt"):
        mb = self.widgetMap.get(widget)
        if not mb:
            self.log.error("No widget named '%s' present." % widget)
            return

        mb.startInput(
            prompt,
            self.find_window,
            "window",
            strict_completer=True
        )

    def cmd_next_urgent(self):
        try:
            nxt = filter(lambda w: w.urgent, self.windowMap.values())[0]
            nxt.group.cmd_toscreen()
            nxt.group.focus(nxt, False)
        except IndexError:
            pass  # no window had urgent set

    def cmd_togroup(self, prompt="group", widget="prompt"):
        """
            Move current window to the selected group in a propmt widget

            prompt: Text with which to prompt user.
            widget: Name of the prompt widget (default: "prompt").
        """
        if not self.currentWindow:
            self.log.warning("No window to move")
            return

        mb = self.widgetMap.get(widget)
        if not mb:
            self.log.error("No widget named '%s' present." % widget)
            return

        mb.startInput(prompt, self.moveToGroup, "group", strict_completer=True)

    def cmd_switchgroup(self, prompt="group", widget="prompt"):
        def f(group):
            if group:
                try:
                    self.groupMap[group].cmd_toscreen()
                except KeyError:
                    self.log.info("No group named '%s' present." % group)
                    pass

        mb = self.widgetMap.get(widget)
        if not mb:
            self.log.warning("No widget named '%s' present." % widget)
            return

        mb.startInput(prompt, f, "group", strict_completer=True)

    def cmd_spawncmd(self, prompt="spawn", widget="prompt",
                     command="%s", complete="cmd"):
        """
            Spawn a command using a prompt widget, with tab-completion.

            prompt: Text with which to prompt user (default: "spawn: ").
            widget: Name of the prompt widget (default: "prompt").
            command: command template (default: "%s").
            complete: Tab completion function (default: "cmd")
        """
        def f(args):
            if args:
                self.cmd_spawn(command % args)
        try:
            mb = self.widgetMap[widget]
            mb.startInput(prompt, f, complete)
        except:
            self.log.error("No widget named '%s' present." % widget)

    def cmd_qtilecmd(self, prompt="command",
                     widget="prompt", messenger="xmessage"):
        """
            Execute a Qtile command using the client syntax.
            Tab completeion aids navigation of the command tree.

            prompt: Text to display at the prompt (default: "command: ").
            widget: Name of the prompt widget (default: "prompt").
            messenger: command to display output (default: "xmessage").
                Set this to None to disable.
        """
        def f(cmd):
            if cmd:
                c = command.CommandRoot(self)
                try:
                    cmd_arg = str(cmd).split(' ')
                except AttributeError:
                    return
                cmd_len = len(cmd_arg)
                if cmd_len == 0:
                    self.log.info('No command entered.')
                    return
                try:
                    result = eval('c.%s' % (cmd))
                except (
                        command.CommandError,
                        command.CommandException,
                        AttributeError) as err:
                    self.log.error(err.message)
                    result = None
                if not result is None:
                    from pprint import pformat
                    message = pformat(result)
                    if messenger:
                        self.cmd_spawn('%s "%s"' % (messenger, message))
                    self.log.info(result)

        mb = self.widgetMap[widget]
        if not mb:
            self.log.error("No widget named %s present." % widget)
            return
        mb.startInput(prompt, f, "qsh")

    def cmd_addgroup(self, group):
        return self.addGroup(group)

    def cmd_delgroup(self, group):
        return self.delGroup(group)

    def cmd_eval(self, code):
        """
            Evaluates code in the same context as this function.
            Return value is (success, result), success being a boolean and
            result being a string representing the return value of eval, or
            None if exec was used instead.
        """
        try:
            try:
                return (True, str(eval(code)))
            except SyntaxError:
                exec code
                return (True, None)
        except:
            error = traceback.format_exc().strip().split("\n")[-1]
            return (False, error)

    def cmd_function(self, function):
        """ Call a function with qtile instance as argument """
        try:
            function(self)
        except Exception:
            error = traceback.format_exc()
            self.log.error('Exception calling "%s":\n%s' % (function, error))

    def cmd_add_rule(self, match_args, rule_args, min_priorty=False):
        """
            Add a dgroup rule, returns rule_id needed to remove it
            param: match_args (config.Match arguments)
            param: rule_args (config.Rule arguments)
            param: min_priorty if the rule is added with minimun prioriry(last)
        """
        if not self.dgroups:
            self.log.warning('No dgroups created')
            return

        match = Match(**match_args)
        rule = Rule(match, **rule_args)
        return self.dgroups.add_rule(rule, min_priorty)

    def cmd_remove_rule(self, rule_id):
        self.dgroups.remove_rule(rule_id)

########NEW FILE########
__FILENAME__ = notify
"""
    If dbus is available, this module implements a
    org.freedesktop.Notifications service.
"""
import logging

try:
    import dbus
    from dbus import service
    from dbus.mainloop.glib import DBusGMainLoop
except ImportError:
    dbus = None

BUS_NAME = 'org.freedesktop.Notifications'
SERVICE_PATH = '/org/freedesktop/Notifications'

if dbus:
    class NotificationService(service.Object):
        def __init__(self, manager):
            bus_name = service.BusName(BUS_NAME, bus=dbus.SessionBus())
            service.Object.__init__(self, bus_name, SERVICE_PATH)
            self.manager = manager

        @service.method(BUS_NAME, in_signature='', out_signature='as')
        def GetCapabilities(self):
            return ('body')

        @service.method(
            BUS_NAME, in_signature='susssasa{sv}i', out_signature='u'
        )
        def Notify(self, app_name, replaces_id, app_icon, summary,
                   body, actions, hints, timeout):
            notif = Notification(summary, body, timeout, hints)
            return self.manager.add(notif)

        @service.method(BUS_NAME, in_signature='u', out_signature='')
        def CloseNotification(self, id):
            pass

        @service.signal(BUS_NAME, signature='uu')
        def NotificationClosed(self, id_in, reason_in):
            pass

        @service.method(BUS_NAME, in_signature='', out_signature='ssss')
        def GetServerInformation(self):
            return ("qtile-notify-daemon", "qtile", "1.0", "1")


class Notification(object):
    def __init__(self, summary, body='', timeout=-1, hints=None):
        self.summary = summary
        self.hints = hints or {}
        self.body = body
        self.timeout = timeout


class NotificationManager(object):
    def __init__(self):
        self.notifications = []
        self.callbacks = []
        self._service = None

    @property
    def service(self):
        if dbus and self._service is None:
            try:
                DBusGMainLoop(set_as_default=True)
                self._service = NotificationService(self)
            except Exception:
                logging.getLogger('qtile').exception('Dbus connection failed')
                self._service = None
        return self._service

    def register(self, callback):
        if not self.service:
            logging.getLogger('qtile').warning(
                'Registering %s without any dbus connection existing',
                callback.__name__,
            )
        self.callbacks.append(callback)

    def add(self, notif):
        self.notifications.append(notif)
        notif.id = len(self.notifications)
        for callback in self.callbacks:
            callback(notif)
        return len(self.notifications)

    def show(self, *args, **kwargs):
        notif = Notification(*args, **kwargs)
        return (notif, self.add(notif))


notifier = NotificationManager()

########NEW FILE########
__FILENAME__ = default_config
from libqtile.config import Key, Screen, Group
from libqtile.command import lazy
from libqtile import layout, bar, widget

mod = "mod4"

keys = [
    # Switch between windows in current stack pane
    Key(
        [mod], "k",
        lazy.layout.down()
    ),
    Key(
        [mod], "j",
        lazy.layout.up()
    ),

    # Move windows up or down in current stack
    Key(
        [mod, "control"], "k",
        lazy.layout.shuffle_down()
    ),
    Key(
        [mod, "control"], "j",
        lazy.layout.shuffle_up()
    ),

    # Switch window focus to other pane(s) of stack
    Key(
        [mod], "space",
        lazy.layout.next()
    ),

    # Swap panes of split stack
    Key(
        [mod, "shift"], "space",
        lazy.layout.rotate()
    ),

    # Toggle between split and unsplit sides of stack.
    # Split = all windows displayed
    # Unsplit = 1 window displayed, like Max layout, but still with
    # multiple stack panes
    Key(
        [mod, "shift"], "Return",
        lazy.layout.toggle_split()
    ),
    Key([mod], "Return", lazy.spawn("xterm")),

    # Toggle between different layouts as defined below
    Key([mod], "Tab",    lazy.nextlayout()),
    Key([mod], "w",      lazy.window.kill()),

    Key([mod, "control"], "r", lazy.restart()),
    Key([mod, "control"], "q", lazy.shutdown()),
    Key([mod], "r", lazy.spawncmd()),
]

groups = [
    Group("a"),
    Group("s"),
    Group("d"),
    Group("f"),
    Group("u"),
    Group("i"),
    Group("o"),
    Group("p"),
]
for i in groups:
    # mod1 + letter of group = switch to group
    keys.append(
        Key([mod], i.name, lazy.group[i.name].toscreen())
    )

    # mod1 + shift + letter of group = switch to & move focused window to group
    keys.append(
        Key([mod, "shift"], i.name, lazy.window.togroup(i.name))
    )

dgroups_key_binder = None
dgroups_app_rules = []

layouts = [
    layout.Max(),
    layout.Stack(stacks=2)
]

screens = [
    Screen(
        bottom=bar.Bar(
            [
                widget.GroupBox(),
                widget.Prompt(),
                widget.WindowName(),
                widget.TextBox("default config", name="default"),
                widget.Systray(),
                widget.Clock(format='%Y-%m-%d %a %I:%M %p'),
            ],
            30,
        ),
    ),
]

main = None
follow_mouse_focus = True
bring_front_click = False
cursor_warp = False
floating_layout = layout.Floating()
mouse = ()
auto_fullscreen = True
widget_defaults = {}

########NEW FILE########
__FILENAME__ = sh
# Copyright (c) 2008, Aldo Cortesi. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
"""
    A command shell for Qtile.
"""
import readline
import sys
import pprint
import re
import textwrap
import fcntl
import termios
import struct
import command
import ipc


def terminalWidth():
    width = None
    try:
        cr = struct.unpack('hh', fcntl.ioctl(0, termios.TIOCGWINSZ, '1234'))
        width = int(cr[1])
    except (IOError, ImportError):
        pass
    return width or 80


class QSh:

    def __init__(self, client, completekey="tab"):
        self.clientroot = client
        self.current = client
        self.completekey = completekey
        self.termwidth = terminalWidth()
        readline.set_completer(self.complete)
        readline.parse_and_bind(self.completekey + ": complete")
        readline.set_completer_delims(" ()|")
        self.builtins = [i[3:] for i in dir(self) if i.startswith("do_")]

    def _complete(self, buf, arg, state):
        if not re.search(r" |\(", buf) or buf.startswith("help "):
            options = self.builtins + self._commands()
            lst = [i for i in options if i.startswith(arg)]
            if lst and state < len(lst):
                return lst[state]
        elif buf.startswith("cd ") or buf.startswith("ls "):
            path = [i for i in arg.split("/") if i]
            if arg.endswith("/"):
                last = ""
            else:
                last = path[-1]
                path = path[:-1]
            node = self._findNode(self.current, *path)
            options = [str(i) for i in self._ls(node)]
            lst = []
            path = "/".join(path)
            if path:
                path += "/"
            for i in options:
                if i.startswith(last):
                    lst.append(path + i)
            if lst and state < len(lst):
                return lst[state]

    def complete(self, arg, state):
        buf = readline.get_line_buffer()
        return self._complete(buf, arg, state)

    @property
    def prompt(self):
        return "%s> " % self.current.path

    def columnize(self, lst):
        ret = []
        if lst:
            lst = [str(i) for i in lst]
            mx = max([len(i) for i in lst])
            cols = self.termwidth / (mx + 2) or 1
            for i in range(len(lst) / cols):
                sl = lst[i * cols: (i + 1) * cols]
                sl = [x + " " * (mx - len(x)) for x in sl]
                ret.append("  ".join(sl))
            if len(lst) % cols:
                sl = lst[-(len(lst) % cols):]
                sl = [x + " " * (mx - len(x)) for x in sl]
                ret.append("  ".join(sl))
        return "\n".join(ret)

    def _inspect(self, obj):
        """
            Returns an (attrs, keys) tuple.
        """
        if obj.parent and obj.myselector is None:
            t, itms = obj.parent.items(obj.name)
            attrs = obj._contains if t else None
            return (attrs, itms)
        else:
            return (obj._contains, [])

    def _ls(self, obj):
        attrs, itms = self._inspect(obj)
        all = []
        if attrs:
            all.extend(attrs)
        if itms:
            all.extend(itms)
        return all

    def _commands(self):
        try:
            return self.current.commands()
        except command.CommandError:
            return []

    def _findNode(self, src, *path):
        """
            Returns a node, or None if no such node exists.
        """
        if not path:
            return src

        attrs, itms = self._inspect(src)
        next = None
        if path[0] == "..":
            next = src.parent or src
        else:
            for trans in [str, int]:
                try:
                    tpath = trans(path[0])
                except ValueError:
                    continue
                if attrs and tpath in attrs:
                    next = getattr(src, tpath)
                elif itms and tpath in itms:
                    next = src[tpath]
        if next:
            if path[1:]:
                return self._findNode(next, *path[1:])
            else:
                return next
        else:
            return None

    def do_cd(self, arg):
        """
            Change to another path.

            Examples:

                cd layout/0

                cd ../layout
        """
        next = self._findNode(self.current, *[i for i in arg.split("/") if i])
        if next:
            self.current = next
        else:
            return "No such path."

    def do_ls(self, arg):
        """
            List contained items on a node.

            Examples:

                ls

                ls ../layout
        """
        l = self._ls(self.current)
        l = ["%s/" % i for i in l]
        return self.columnize(l)

    def do_help(self, arg):
        """
            Provide an overview of all commands or detailed
            help on a specific command or builtin.

            Examples:

                help

                help command
        """
        cmds = self._commands()
        if not arg:
            lst = [
                "help command   -- Help for a specific command.",
                "",
                "Builtins:",
                "=========",
                self.columnize(self.builtins),
            ]
            if cmds:
                lst += [
                    "",
                    "Commands for this object:",
                    "=========================",
                    self.columnize(cmds),
                ]
            return "\n".join(lst)
        elif arg in cmds:
            return self._call("doc", "(\"%s\")" % arg)
        elif arg in self.builtins:
            c = getattr(self, "do_" + arg)
            return textwrap.dedent(c.__doc__).lstrip()
        else:
            return "No such command: %s" % arg

    def do_exit(self, args):
        """
            Exit qsh.
        """
        sys.exit(0)
    do_quit = do_exit
    do_q = do_exit

    def _call(self, cmd_name, args):
        cmds = self._commands()
        if cmd_name not in cmds:
            return "No such command: %s" % cmd_name

        cmd = getattr(self.current, cmd_name)
        if args:
            args = "".join(args)
        else:
            args = "()"
        try:
            val = eval(
                "cmd%s" % args,
                {},
                dict(cmd=cmd)
            )
            return val
        except SyntaxError, v:
            return "Syntax error in expression: %s" % v.text
        except command.CommandException, val:
            return "Command exception: %s\n" % val
        except ipc.IPCError:
            # on restart, try to reconnect
            if cmd_name == 'restart':
                client = command.Client(self.clientroot.client.fname)
                self.clientroot = client
                self.current = client
            else:
                raise

    def loop(self):
        while True:
            try:
                line = raw_input(self.prompt)
            except (EOFError, KeyboardInterrupt):
                print
                return
            if not line:
                continue

            match = re.search(r"\W", line)
            if match:
                cmd = line[:match.start()].strip()
                args = line[match.start():].strip()
            else:
                cmd = line
                args = ''

            builtin = getattr(self, "do_" + cmd, None)
            if builtin:
                val = builtin(args)
            else:
                val = self._call(cmd, args)
            if isinstance(val, basestring):
                print val
            elif val:
                pprint.pprint(val)

########NEW FILE########
__FILENAME__ = state
# Copyright (c) 2012, Tycho Andersen. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from collections import defaultdict

import command
import hook


class QtileState(object):
    """
        Represents the state of the qtile object. Primarily used for restoring
        state across restarts; any additional state which doesn't fit nicely
        into X atoms can go here.
    """
    def __init__(self, qtile):
        # Note: window state is saved and restored via _NET_WM_STATE, so
        # the only thing we need to restore here is the layout and screen
        # configurations.
        self.groups = {}
        self.screens = {}

        for group in qtile.groups:
            self.groups[group.name] = group.layout.name
        for index, screen in enumerate(qtile.screens):
            self.screens[index] = screen.group.name

    def apply(self, qtile):
        """
            Rearrange the windows in the specified Qtile object according to
            this QtileState.
        """
        for (group, layout) in self.groups.iteritems():
            try:
                qtile.groupMap[group].layout = layout
            except KeyError:
                pass  # group missing

        for (screen, group) in self.screens.iteritems():
            try:
                group = qtile.groupMap[group]
                qtile.screens[screen].setGroup(group)
            except (KeyError, IndexError):
                pass  # group or screen missing

########NEW FILE########
__FILENAME__ = utils
# Copyright (c) 2008, Aldo Cortesi. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import operator
import functools
import gobject
import logging
import os
import xcbq


class QtileError(Exception):
    pass


def lget(o, v):
    try:
        return o[v]
    except (IndexError, TypeError):
        return None


def translateMasks(modifiers):
    """
    Translate a modifier mask specified as a list of strings into an or-ed
    bit representation.
    """
    masks = []
    for i in modifiers:
        try:
            masks.append(xcbq.ModMasks[i])
        except KeyError:
            raise KeyError("Unknown modifier: %s" % i)
    if masks:
        return reduce(operator.or_, masks)
    else:
        return 0


def shuffleUp(lst):
    if len(lst) > 1:
        c = lst[-1]
        lst.remove(c)
        lst.insert(0, c)


def shuffleDown(lst):
    if len(lst) > 1:
        c = lst[0]
        lst.remove(c)
        lst.append(c)


class LRUCache:
    """
        A decorator that implements a self-expiring LRU cache for class
        methods (not functions!).

        Cache data is tracked as attributes on the object itself. There is
        therefore a separate cache for each object instance.
    """
    def __init__(self, size=100):
        self.size = size

    def __call__(self, f):
        cacheName = "_cached_%s" % f.__name__
        cacheListName = "_cachelist_%s" % f.__name__
        size = self.size

        @functools.wraps(f)
        def wrap(self, *args):
            if not hasattr(self, cacheName):
                setattr(self, cacheName, {})
                setattr(self, cacheListName, [])
            cache = getattr(self, cacheName)
            cacheList = getattr(self, cacheListName)
            if args in cache:
                cacheList.remove(args)
                cacheList.insert(0, args)
                return cache[args]
            else:
                ret = f(self, *args)
                cacheList.insert(0, args)
                cache[args] = ret
                if len(cacheList) > size:
                    d = cacheList.pop()
                    cache.pop(d)
                return ret
        return wrap


def isStringLike(anobj):
    try:
        # Avoid succeeding expensively if anobj is large.
        anobj[:0] + ''
    except:
        return 0
    else:
        return 1


def isSequenceLike(anobj):
    """
        Is anobj a non-string sequence type (list, tuple, iterator, or
        similar)?  Crude, but mostly effective.
    """
    if not hasattr(anobj, "next"):
        if isStringLike(anobj):
            return 0
        try:
            anobj[:0]
        except:
            return 0
    return 1


def rgb(x):
    """
        Returns a valid RGBA tuple.

        Here are some valid specifcations:
            #ff0000
            ff0000
            with alpha: ff0000.5
            (255, 0, 0)
            (255, 0, 0, 0.5)
    """
    if isinstance(x, tuple) or isinstance(x, list):
        if len(x) == 4:
            alpha = x[3]
        else:
            alpha = 1
        return (x[0] / 255.0, x[1] / 255.0, x[2] / 255.0, alpha)
    elif isinstance(x, basestring):
        if x.startswith("#"):
            x = x[1:]
        if "." in x:
            x, alpha = x.split(".")
            alpha = float("0." + alpha)
        else:
            alpha = 1
        if len(x) != 6:
            raise ValueError("RGB specifier must be 6 characters long.")
        vals = [int(i, 16) for i in (x[0:2], x[2:4], x[4:6])]
        vals.append(alpha)
        return rgb(vals)
    raise ValueError("Invalid RGB specifier.")


def hex(x):
    r, g, b, _ = rgb(x)
    return '#%02x%02x%02x' % (r * 255, g * 255, b * 255)


class Data:
    def __init__(self, name):
        m = __import__(name)
        dirname, _ = os.path.split(m.__file__)
        self.dirname = os.path.abspath(dirname)

    def path(self, path):
        """
            Returns a path to the package data housed at 'path' under this
            module.Path can be a path to a file, or to a directory.

            This function will raise ValueError if the path does not exist.
        """
        fullpath = os.path.join(self.dirname, path)
        if not os.path.exists(fullpath):
            raise ValueError("dataPath: %s does not exist." % fullpath)
        return fullpath

data = Data(__name__)


def scrub_to_utf8(text):
    if not text:
        return ""
    elif isinstance(text, unicode):
        return text
    else:
        return text.decode("utf-8", "ignore")


def escape(text):
    # logging.getLogger('qtile').info('Escaping %s' % text)
    return gobject.markup_escape_text(text)

########NEW FILE########
__FILENAME__ = backlight
import os
import base

BACKLIGHT_DIR = '/sys/class/backlight'

FORMAT = '{percent: 2.0%}'


class Backlight(base.InLoopPollText):
    """
        A simple widget to show the current brightness of a monitor.
    """

    filenames = {}

    defaults = [
        ('backlight_name', 'acpi_video0', 'ACPI name of a backlight device'),
        (
            'brightness_file',
            'brightness',
            'Name of file with the '
            'current brightness in /sys/class/backlight/backlight_name'
        ),
        (
            'max_brightness_file',
            'max_brightness',
            'Name of file with the '
            'maximum brightness in /sys/class/backlight/backlight_name'
        ),
        ('update_interval', .2, 'The delay in seconds between updates'),
    ]

    def __init__(self, **config):
        base.InLoopPollText.__init__(self, **config)
        self.add_defaults(Backlight.defaults)

    def _load_file(self, name):
        try:
            path = os.path.join(BACKLIGHT_DIR, self.backlight_name, name)
            with open(path, 'r') as f:
                return f.read().strip()
        except IOError:
            return False
        except Exception:
            self.log.exception("Failed to get %s" % name)

    def _get_info(self):
        try:
            info = {
                'brightness': float(self._load_file(self.brightness_file)),
                'max': float(self._load_file(self.max_brightness_file)),
            }
        except TypeError:
            return False
        return info

    def poll(self):
        info = self._get_info()
        if info is False:
            return 'Error'

        percent = info['brightness'] / info['max']
        return FORMAT.format(percent=percent)

########NEW FILE########
__FILENAME__ = base
from .. import command, bar, configurable, drawer
import gobject
import logging
import threading


LEFT = object()
CENTER = object()


class _Widget(command.CommandObject, configurable.Configurable):
    """
        If width is set to the special value bar.STRETCH, the bar itself
        will set the width to the maximum remaining space, after all other
        widgets have been configured. Only ONE widget per bar can have the
        bar.STRETCH width set.

        The offset attribute is set by the Bar after all widgets have been
        configured.
    """
    offset = None
    defaults = [("background", None, "Widget background color")]

    def __init__(self, width, **config):
        """
            width: bar.STRETCH, bar.CALCULATED, or a specified width.
        """
        command.CommandObject.__init__(self)
        self.name = self.__class__.__name__.lower()
        if "name" in config:
            self.name = config["name"]

        self.log = logging.getLogger('qtile')

        configurable.Configurable.__init__(self, **config)
        self.add_defaults(_Widget.defaults)

        if width in (bar.CALCULATED, bar.STRETCH):
            self.width_type = width
            self.width = 0
        else:
            self.width_type = bar.STATIC
            self.width = width
        self.configured = False

    @property
    def width(self):
        if self.width_type == bar.CALCULATED:
            return int(self.calculate_width())
        return self._width

    @width.setter
    def width(self, value):
        self._width = value

    @property
    def win(self):
        return self.bar.window.window

    def _configure(self, qtile, bar):
        self.qtile = qtile
        self.bar = bar
        self.drawer = drawer.Drawer(
            qtile,
            self.win.wid,
            self.bar.width,
            self.bar.height
        )
        self.configured = True

    def clear(self):
        self.drawer.set_source_rgb(self.bar.background)
        self.drawer.fillrect(self.offset, 0, self.width, self.bar.size)

    def info(self):
        return dict(
            name=self.__class__.__name__,
            offset=self.offset,
            width=self.width,
        )

    def button_press(self, x, y, button):
        pass

    def button_release(self, x, y, button):
        pass

    def get(self, q, name):
        """
            Utility function for quick retrieval of a widget by name.
        """
        w = q.widgetMap.get(name)
        if not w:
            raise command.CommandError("No such widget: %s" % name)
        return w

    def _items(self, name):
        if name == "bar":
            return (True, None)

    def _select(self, name, sel):
        if name == "bar":
            return self.bar

    def cmd_info(self):
        """
            Info for this object.
        """
        return dict(name=self.name)

    def draw(self):
        """
            Method that draws the widget. You may call this explicitly to
            redraw the widget, but only if the width of the widget hasn't
            changed. If it has, you must call bar.draw instead.
        """
        raise NotImplementedError

    def calculate_width(self):
        """
            Must be implemented if the widget can take CALCULATED for width.
        """
        raise NotImplementedError

    def timeout_add(self, seconds, method, method_args=()):
        """
            This method calls either ``gobject.timeout_add`` or
            ``gobject.timeout_add_seconds`` with same arguments. Latter is
            better for battery usage, but works only with integer timeouts.
        """
        self.log.debug('Adding timer for %r in %.2fs', method, seconds)
        if int(seconds) == seconds:
            return gobject.timeout_add_seconds(
                int(seconds), method, *method_args
            )
        else:
            return gobject.timeout_add(
                int(seconds * 1000), method, *method_args
            )


UNSPECIFIED = bar.Obj("UNSPECIFIED")


class _TextBox(_Widget):
    """
        Base class for widgets that are just boxes containing text.
    """
    defaults = [
        ("font", "Arial", "Default font"),
        ("fontsize", None, "Font size. Calculated if None."),
        ("padding", None, "Padding. Calculated if None."),
        ("foreground", "ffffff", "Foreground colour"),
        (
            "fontshadow",
            None,
            "font shadow color, default is None(no shadow)"
        ),
    ]

    def __init__(self, text=" ", width=bar.CALCULATED, **config):
        self.layout = None
        _Widget.__init__(self, width, **config)
        self.text = text
        self.add_defaults(_TextBox.defaults)

    @property
    def text(self):
        return self._text

    @text.setter
    def text(self, value):
        self._text = value
        if self.layout:
            self.layout.text = value

    @property
    def font(self):
        return self._font

    @font.setter
    def font(self, value):
        self._font = value
        if self.layout:
            self.layout.font = value

    @property
    def fontshadow(self):
        return self._fontshadow

    @fontshadow.setter
    def fontshadow(self, value):
        self._fontshadow = value
        if self.layout:
            self.layout.font_shadow = value

    @property
    def actual_padding(self):
        if self.padding is None:
            return self.fontsize / 2
        else:
            return self.padding

    def _configure(self, qtile, bar):
        _Widget._configure(self, qtile, bar)
        if self.fontsize is None:
            self.fontsize = self.bar.height - self.bar.height / 5
        self.layout = self.drawer.textlayout(
            self.text,
            self.foreground,
            self.font,
            self.fontsize,
            self.fontshadow,
        )

    def calculate_width(self):
        if self.text:
            return min(
                self.layout.width,
                self.bar.width
            ) + self.actual_padding * 2
        else:
            return 0

    def draw(self):
        self.drawer.clear(self.background or self.bar.background)
        self.layout.draw(
            self.actual_padding or 0,
            int(self.bar.height / 2.0 - self.layout.height / 2.0) + 1
        )
        self.drawer.draw(self.offset, self.width)

    def cmd_set_font(self, font=UNSPECIFIED, fontsize=UNSPECIFIED,
                     fontshadow=UNSPECIFIED):
        """
            Change the font used by this widget. If font is None, the current
            font is used.
        """
        if font is not UNSPECIFIED:
            self.font = font
        if fontsize is not UNSPECIFIED:
            self.fontsize = fontsize
        if fontshadow is not UNSPECIFIED:
            self.fontshadow = fontshadow
        self.bar.draw()


class InLoopPollText(_TextBox):
    """ A common interface for polling some 'fast' information, munging it, and
    rendering the result in a text box. You probably want to use
    ThreadedPollText instead.

    ('fast' here means that this runs /in/ the event loop, so don't block! If
    you want to run something nontrivial, use ThreadedPollWidget.) """

    defaults = [
        ("update_interval", 600, "Update interval in seconds, if none, the "
            "widget updates whenever the event loop is idle."),
    ]

    def __init__(self, **config):
        _TextBox.__init__(self, 'N/A', width=bar.CALCULATED, **config)
        self.add_defaults(InLoopPollText.defaults)

    def _configure(self, qtile, bar):
        self.qtile = qtile
        if not self.configured:
            if self.update_interval is None:
                gobject.idle_add(self.tick)
            else:
                self.timeout_add(self.update_interval, self.tick)
        _TextBox._configure(self, qtile, bar)

        # Update when we are configured.
        self.tick()

    def button_press(self, x, y, button):
        self.tick()

    def poll(self):
        return 'N/A'

    def _poll(self):
        try:
            return self.poll()
        except:
            self.log.exception('got exception while polling')

    def tick(self):
        text = self._poll()
        self.update(text)
        return True

    def update(self, text):
        old_width = self.layout.width
        if self.text != text:
            self.text = text
            # If our width hasn't changed, we just draw ourselves. Otherwise,
            # we draw the whole bar.
            if self.layout.width == old_width:
                self.draw()
            else:
                self.bar.draw()
        return False


class ThreadedPollText(InLoopPollText):
    """ A common interface for polling some REST URL, munging the data, and
    rendering the result in a text box. """
    def __init__(self, **config):
        InLoopPollText.__init__(self, **config)

    def tick(self):
        def worker():
            text = self._poll()
            gobject.idle_add(self.update, text)
        threading.Thread(target=worker).start()
        return True

# these two classes below look SUSPICIOUSLY similar

class PaddingMixin(object):
    """
        Mixin that provides padding(_x|_y|)

        To use it, subclass and add this to __init__:

            self.add_defaults(base.PaddingMixin.defaults)
    """

    defaults = [
        ("padding", 3, "Padding inside the box"),
        ("padding_x", None, "X Padding. Overrides 'padding' if set"),
        ("padding_y", None, "Y Padding. Overrides 'padding' if set"),
    ]

    padding_x = configurable.ExtraFallback('padding_x', 'padding')
    padding_y = configurable.ExtraFallback('padding_y', 'padding')


class MarginMixin(object):
    """
        Mixin that provides margin(_x|_y|)

        To use it, subclass and add this to __init__:

            self.add_defaults(base.MarginMixin.defaults)
    """

    defaults = [
        ("margin", 3, "Margin inside the box"),
        ("margin_x", None, "X Margin. Overrides 'margin' if set"),
        ("margin_y", None, "Y Margin. Overrides 'margin' if set"),
    ]

    margin_x = configurable.ExtraFallback('margin_x', 'margin')
    margin_y = configurable.ExtraFallback('margin_y', 'margin')

########NEW FILE########
__FILENAME__ = battery
import cairo
import os
from libqtile import bar
import base

BAT_DIR = '/sys/class/power_supply'
CHARGED = 'Full'
CHARGING = 'Charging'
DISCHARGING = 'Discharging'
UNKNOWN = 'Unknown'

BATTERY_INFO_FILES = {
    'energy_now_file': ['energy_now', 'charge_now'],
    'energy_full_file': ['energy_full', 'charge_full'],
    'power_now_file': ['power_now', 'current_now'],
    'status_file': ['status'],
}


def default_icon_path():
    # default icons are in libqtile/resources/battery-icons
    root = os.sep.join(os.path.abspath(__file__).split(os.sep)[:-2])
    return os.path.join(root, 'resources', 'battery-icons')


class _Battery(base._TextBox):
    ''' Base battery class '''

    filenames = {}

    defaults = [
        ('battery_name', 'BAT0', 'ACPI name of a battery, usually BAT0'),
        (
            'status_file',
            'status',
            'Name of status file in'
            ' /sys/class/power_supply/battery_name'
        ),
        (
            'energy_now_file',
            None,
            'Name of file with the '
            'current energy in /sys/class/power_supply/battery_name'
        ),
        (
            'energy_full_file',
            None,
            'Name of file with the maximum'
            ' energy in /sys/class/power_supply/battery_name'
        ),
        (
            'power_now_file',
            None,
            'Name of file with the current'
            ' power draw in /sys/class/power_supply/battery_name'
        ),
        ('update_delay', 1, 'The delay in seconds between updates'),
    ]

    def __init__(self, **config):
        base._TextBox.__init__(self, "BAT", bar.CALCULATED, **config)
        self.add_defaults(_Battery.defaults)

    def _load_file(self, name):
        try:
            path = os.path.join(BAT_DIR, self.battery_name, name)
            with open(path, 'r') as f:
                return f.read().strip()
        except IOError:
            if name == 'current_now':
                return 0
            return False
        except Exception:
            self.log.exception("Failed to get %s" % name)

    def _get_param(self, name):
        if name in self.filenames:
            return self._load_file(self.filenames[name])
        else:
            ## Don't have the file name cached, figure it out
            file_list = BATTERY_INFO_FILES.get(name, [])
            if getattr(self, name, None):
                ## If a file is manually specified, check it first
                file_list.insert(0, getattr(self, name))

            ## Iterate over the possibilities, and return the first valid value
            for file in file_list:
                value = self._load_file(file)
                if not (value in (False, None)):
                    self.filenames[name] = file
                    return value

        ## If we made it this far, we don't have a valid file. Just return None.
        return None

    def _get_info(self):
        try:
            info = {
                'stat': self._get_param('status_file'),
                'now': float(self._get_param('energy_now_file')),
                'full': float(self._get_param('energy_full_file')),
                'power': float(self._get_param('power_now_file')),
            }
        except TypeError:
            return False
        return info


class Battery(_Battery):
    """
        A simple but flexible text-based battery widget.
    """
    defaults = [
        ('low_foreground', 'FF0000', 'font color when battery is low'),
        (
            'format',
            '{char} {percent:2.0%} {hour:d}:{min:02d}',
            'Display format'
        ),
        ('charge_char', '^', 'Character to indicate the battery is charging'),
        (
            'discharge_char',
            'V',
            'Character to indicate the battery'
            ' is discharging'
        ),
        (
            'low_percentage',
            0.10,
            "0 < x < 1 at which to indicate battery is low with low_foreground"
        ),
        ('hide_threshold', None, 'Hide the text when there is enough energy'),
    ]

    def __init__(self, **config):
        _Battery.__init__(self, **config)
        self.add_defaults(Battery.defaults)
        self.timeout_add(self.update_delay, self.update)
        self.update()

    def _get_text(self):
        info = self._get_info()
        if info is False:
            return 'Error'

        ## Set the charging character
        try:
            # hide the text when it's higher than threshold, but still
            # display `full` when the battery is fully charged.
            if self.hide_threshold and \
                    info['now'] / info['full'] * 100.0 >= \
                    self.hide_threshold and \
                    info['stat'] != CHARGED:
                return ''
            elif info['stat'] == DISCHARGING:
                char = self.discharge_char
                time = info['now'] / info['power']
            elif info['stat'] == CHARGING:
                char = self.charge_char
                time = (info['full'] - info['now']) / info['power']
            else:
                return 'Full'
        except ZeroDivisionError:
            time = -1

        ## Calculate the battery percentage and time left
        if time >= 0:
            hour = int(time)
            min = int(time * 60) % 60
        else:
            hour = -1
            min = -1
        percent = info['now'] / info['full']
        if info['stat'] == DISCHARGING and percent < self.low_percentage:
            self.layout.colour = self.low_foreground
        else:
            self.layout.colour = self.foreground

        return self.format.format(
            char=char,
            percent=percent,
            hour=hour,
            min=min
        )

    def update(self):
        if self.configured:
            ntext = self._get_text()
            if ntext != self.text:
                self.text = ntext
                self.bar.draw()
        return True


class BatteryIcon(_Battery):
    ''' Battery life indicator widget '''

    defaults = [
        ('theme_path', default_icon_path(), 'Path of the icons'),
        ('custom_icons', {}, 'dict containing key->filename icon map'),
    ]

    def __init__(self, **config):
        _Battery.__init__(self, **config)
        self.add_defaults(BatteryIcon.defaults)

        if self.theme_path:
            self.width_type = bar.STATIC
            self.width = 0
        self.surfaces = {}
        self.current_icon = 'battery-missing'
        self.icons = dict([(x, '{0}.png'.format(x)) for x in (
            'battery-missing',
            'battery-caution',
            'battery-low',
            'battery-good',
            'battery-full',
            'battery-caution-charging',
            'battery-low-charging',
            'battery-good-charging',
            'battery-full-charging',
            'battery-full-charged',
        )])
        self.icons.update(self.custom_icons)
        self.timeout_add(self.update_delay, self.update)

    def _configure(self, qtile, bar):
        base._TextBox._configure(self, qtile, bar)
        self.setup_images()

    def _get_icon_key(self):
        key = 'battery'
        info = self._get_info()
        if info is False or not info.get('full'):
            key += '-missing'
        else:
            percent = info['now'] / info['full']
            if percent < .2:
                key += '-caution'
            elif percent < .4:
                key += '-low'
            elif percent < .8:
                key += '-good'
            else:
                key += '-full'

            if info['stat'] == CHARGING:
                key += '-charging'
            elif info['stat'] == CHARGED:
                key += '-charged'
        return key

    def update(self):
        if self.configured:
            icon = self._get_icon_key()
            if icon != self.current_icon:
                self.current_icon = icon
                self.draw()
        return True

    def draw(self):
        if self.theme_path:
            self.drawer.clear(self.background or self.bar.background)
            self.drawer.ctx.set_source(self.surfaces[self.current_icon])
            self.drawer.ctx.paint()
            self.drawer.draw(self.offset, self.width)
        else:
            self.text = self.current_icon[8:]
            base._TextBox.draw(self)

    def setup_images(self):
        for key, name in self.icons.iteritems():
            try:
                path = os.path.join(self.theme_path, name)
                img = cairo.ImageSurface.create_from_png(path)
            except cairo.Error:
                self.theme_path = None
                self.qtile.log.warning('Battery Icon switching to text mode')
                return
            input_width = img.get_width()
            input_height = img.get_height()

            sp = input_height / float(self.bar.height - 1)

            width = input_width / sp
            if width > self.width:
                self.width = int(width) + self.actual_padding * 2

            imgpat = cairo.SurfacePattern(img)

            scaler = cairo.Matrix()

            scaler.scale(sp, sp)
            scaler.translate(self.actual_padding * -1, 0)
            imgpat.set_matrix(scaler)

            imgpat.set_filter(cairo.FILTER_BEST)
            self.surfaces[key] = imgpat

########NEW FILE########
__FILENAME__ = bitcoin_ticker
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import base
import locale
import urllib2

try:
    import json
except ImportError:
    import simplejson as json


class BitcoinTicker(base.ThreadedPollText):
    ''' A bitcoin ticker widget, data provided by the btc-e.com API. Defaults to
        displaying currency in whatever the current locale is.
    '''

    QUERY_URL = "https://btc-e.com/api/2/btc_%s/ticker"

    defaults = [
        ('currency', locale.localeconv()['int_curr_symbol'].strip(),
            'The currency the value of bitcoin is displayed in'),
        ('format', 'BTC Buy: {buy}, Sell: {sell}',
            'Display format, allows buy, sell, high, low, avg, '
            'vol, vol_cur, last, variables.'),
    ]

    def __init__(self, **config):
        base.ThreadedPollText.__init__(self, **config)
        self.add_defaults(BitcoinTicker.defaults)

    def poll(self):
        res = urllib2.urlopen(self.QUERY_URL % self.currency.lower())
        formatted = {}
        for k, v in json.loads(res.read())[u'ticker'].iteritems():
            formatted[k.encode('ascii')] = locale.currency(v)
        return self.format.format(**formatted)

########NEW FILE########
__FILENAME__ = canto
# -*- coding: utf-8 -*-

import base
from subprocess import check_output, call


class Canto(base.ThreadedPollText):
    defaults = [
        ("fetch", False, "Whether to fetch new items on update"),
        ("feeds", [], "List of feeds to display, empty for all"),
        ("one_format", "{name}: {number}", "One feed display format"),
        ("all_format", "{number}", "All feeds display format"),
    ]

    def __init__(self, **config):
        base.ThreadedPollText.__init__(self, **config)
        self.add_defaults(Canto.defaults)

    def poll(self):
        if not self.feeds:
            arg = "-a"
            if self.fetch:
                arg += "u"
            return self.all_format.format(
                number=check_output(["canto", arg])[:-1])
        else:
            if self.fetch:
                call(["canto", "-u"])
            return "".join([self.one_format.format(
                name=feed,
                number=check_output(["canto", "-n", feed])[:-1]
            ) for feed in self.feeds])

########NEW FILE########
__FILENAME__ = clock
from time import time
from datetime import datetime

import base
import warnings
import exceptions

class Clock(base.InLoopPollText):
    """
        A simple but flexible text-based clock.
    """
    defaults = [
        ('format', '%H:%M', 'A Python datetime format string'),

        ('update_interval', 1., 'Update interval for the clock'),
    ]
    def __init__(self, fmt=None, **config):
        base.InLoopPollText.__init__(self, **config)
        self.add_defaults(Clock.defaults)
        if fmt is not None:
            warnings.warn('fmt kwarg or positional argument is deprecated. '
                          'Please use format.', exceptions.DeprecationWarning)
            self.format = fmt

    def tick(self):
        ts = time()
        self.timeout_add(self.update_interval - ts % self.update_interval,
                         self.tick)
        self.update(self.poll())
        return False

    def poll(self):
        ts = time()
        # adding .5 to get a proper seconds value because glib could
        # theoreticaly call our method too early and we could get something
        # like (x-1).999 instead of x.000
        return datetime.fromtimestamp(int(ts + .5)).strftime(self.format)

########NEW FILE########
__FILENAME__ = crashme
# -*- coding: utf-8 -*-
from .. import bar
import base


class _CrashMe(base._TextBox):
    """
        A developper widget to force a crash in qtile
    """
    def __init__(self, width=bar.CALCULATED, **config):
        """
            - width: A fixed width, or bar.CALCULATED to calculate the width
            automatically (which is recommended).
        """
        base._TextBox.__init__(self, "Crash me !", width, **config)

    def _configure(self, qtile, bar):
        base._Widget._configure(self, qtile, bar)
        self.layout = self.drawer.textlayout(
            self.text,
            self.foreground,
            self.font,
            self.fontsize,
            self.fontshadow,
            markup=True
        )

    def button_press(self, x, y, button):
        if button == 1:
            1 / 0
        elif button == 3:
            self.text = '<span>\xC3GError'
            self.bar.draw()

########NEW FILE########
__FILENAME__ = currentlayout
import base
from .. import bar, hook


class CurrentLayout(base._TextBox):
    def __init__(self, width=bar.CALCULATED, **config):
        base._TextBox.__init__(self, "", width, **config)

    def _configure(self, qtile, bar):
        base._TextBox._configure(self, qtile, bar)
        self.text = self.bar.screen.group.layouts[0].name
        self.setup_hooks()

    def setup_hooks(self):
        def hook_response(layout, group):
            if group.screen is not None and group.screen == self.bar.screen:
                self.text = layout.name
                self.bar.draw()
        hook.subscribe.layout_change(hook_response)

    def button_press(self, x, y, button):
        if button == 1:
            self.qtile.cmd_nextlayout()
        elif button == 2:
            self.qtile.cmd_prevlayout()

########NEW FILE########
__FILENAME__ = debuginfo
from .. import hook, bar, group, layout
import base
import logging

class DebugInfo(base._TextBox):
    """
        Displays debugging infos about selected window
    """
    def __init__(self, width=bar.CALCULATED, **config):
        """
           - width: A fixed width, or bar.CALCULATED to calculate the width
           automatically (wich is recommended).
        """
        self.log = logging.getLogger('qtile')
        base._TextBox.__init__(self, " ", width, **config)

    def _configure(self, qtile, bar):
        base._TextBox._configure(self, qtile, bar)
        hook.subscribe.focus_change(self.update)
        hook.subscribe.layout_change(self.update)
        hook.subscribe.float_change(self.update)

    def update(self, *args):
        old_layout_width = self.layout.width

        w = self.bar.screen.group.currentWindow

        if isinstance(w.group.layout, layout.Stack):
            stack = w.group.layout.currentStack
            stackOffset = w.group.layout.currentStackOffset
            idx = stack.lst.index(w)
            current = stack.current
            self.text = "Stack: %s Idx: %s Cur: %s" % (stackOffset,
                                                       idx,
                                                       current)
        elif isinstance(w.group.layout, layout.TreeTab):
            node = w.group.layout._nodes[w]
            tree = w.group.layout._tree
            nodeIdx = node.parent.children.index(node)
            snode = node
            level = 1
            while not isinstance(snode, layout.tree.Section):
                snode = snode.parent
                level +=1
            sectionIdx = snode.parent.children.index(snode)
            self.text = "Level: %s SectionIdx: %s NodeIdx: %s" % (level,
                                                                  sectionIdx,
                                                                  nodeIdx)

        if self.layout.width != old_layout_width:
            self.bar.draw()
        else:
            self.draw()


########NEW FILE########
__FILENAME__ = df
# -*- coding:utf-8 -*-
#
# Copyright (C) 2013, Roger Duran <rogerduran@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

import os
import base

class DF(base.ThreadedPollText):
    """
    Disk Free Widget

    By default the widget only displays if the space is less than warn_space
    """
    defaults = [
        ('partition', '/', 'the partition to check space'),
        ('warn_color', 'ff0000', 'Warning color'),
        ('warn_space', 2, 'Warning space'),
        ('visible_on_warn', True, 'Only display if warning'),
        ('measure', "G", "Measurement (G, M, B)"),
        ('format', '{p} ({uf}{m})',
                    'String format (p: partition, s: size, '\
                    'f: free space, uf: user free space, m: measure)'),
        ('update_interval', 60, 'The update inteval.'),
    ]

    measures = {"G": 1024*1024*1024,
                "M": 1024*1024,
                "B": 1024}
    def __init__(self, **config):
        base.ThreadedPollText.__init__(self, **config)
        self.add_defaults(DF.defaults)
        self.user_free = 0
        self.calc = self.measures[self.measure]

    def draw(self):
        if self.user_free <= self.warn_space:
            self.layout.colour = self.warn_color
        else:
            self.layout.colour = self.foreground

        base.ThreadedPollText.draw(self)

    def poll(self):
        statvfs = os.statvfs(self.partition)

        size = statvfs.f_frsize * statvfs.f_blocks / self.calc
        free = statvfs.f_frsize * statvfs.f_bfree / self.calc
        self.user_free = statvfs.f_frsize * statvfs.f_bavail / self.calc

        if self.visible_on_warn and self.user_free >= self.warn_space:
            text = ""
        else:
            text = self.format.format(p=self.partition, s=size, f=free,
                    uf=self.user_free, m=self.measure)

        return text

########NEW FILE########
__FILENAME__ = gmail_checker
import base
import imaplib
import re
import logging


_logger = logging.getLogger('qtile')


class GmailChecker(base.ThreadedPollText):
    """
        A simple gmail checker.
        settings = {
            'username': username,
            'password': password,
            'email_path': valide email path,
            'fmt': "format string fot textbox widget",
            #if status_only_unseen is True
            #example "my unseen[%s]",
            #if status_only_unseen is False
            #example "messages: %s, unseen: %s"
            status_only_unseen: True or False
        }
    """
    defaults = [
        ("update_interval", 30, "Update time in seconds."),
    ]

    def __init__(self, settings, **config):
        base._TextBox.__init__(self, **config)
        # TODO: make this use our settings framework
        self.settings = settings
        self.add_defaults(GmailChecker.defaults)

    def validate_settings(self):
        self.not_validate = {}
        self.not_validate['status'] = False
        self.not_validate['messages'] = []
        _settings = self.settings
        _username = _settings.get('username', None)
        _password = _settings.get('password', None)
        _email_path = _settings.get('email_path', None)
        _fmt = _settings.get('fmt', None)
        _status_only_unseen = _settings.get('status_only_unseen', None)
        if(_username is None):
            self.not_validate['status'] = True
            _message = "not find username!"
            self.not_validate['messages'].append(_message)
        if(_password is None):
            self.not_validate['status'] = True
            _message = "not find password!"
            self.not_validate['messages'].append(_message)
        if(_email_path is None):
            self.settings['email_path'] = "INBOX"
        if(_fmt is None):
            self.settings['fmt'] = "inbox[%s],unseen[%s]"
            self.settings['status_only_unseen'] = False
        if(_status_only_unseen is None):
            self.settings['status_only_unseen'] = False

    def poll(self):
        self.validate_settings()
        if(self.not_validate['status']):
            for _error in self.not_validate['messages']:
                _logger.exception('GmailChecker error: %s' % str(_error))
            return "BAD SETTINGS!"
        else:
            self.gmail = imaplib.IMAP4_SSL('imap.gmail.com')
            try:
                self.gmail.login(self.settings['username'], self.settings['password'])
                answer, raw_data = \
                    self.gmail.status(
                        self.settings['email_path'],
                        '(MESSAGES UNSEEN)'
                    )
                if(answer == "OK"):
                    messages = int(re.search('MESSAGES\s+(\d+)', raw_data[0]).group(1))
                    unseen = int(re.search('UNSEEN\s+(\d+)', raw_data[0]).group(1))
                    if(self.settings['status_only_unseen']):
                        return self.settings['fmt'] % unseen
                    else:
                        return self.settings['fmt'] % (messages, unseen)
                else:
                    _logger.exception(
                        'GmailChecker UNKNOWN error, answer: %s, raw_data: %s'
                        % (str(answer), str(raw_data)))
                    return "UNKNOWN ERROR"
            except Exception, _error:
                _logger.exception('GmailChecker error: %s' % str(_error))
                return "ERROR"

########NEW FILE########
__FILENAME__ = google_calendar
# -*- coding: utf-8 -*-
#
###################################################################
# Some of this code is ...
#
# Copyright (C) 2012 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
###################################################################
# INSTRUCTIONS:
#
# This widget will display the next appointment on your calendar in
# the qtile status bar. Appointments within the "reminder" time will be
# highlighted. Authentication credentials can be stored in a
# keyring or on disk depending on the setting of the 'keyring'
# parameter (default is to store in the keyring).
#
# To use this widget, you will need to install the Google API oauth2
# dependencies. This can be accomplished by executing the following
# command:
#
# easy_install --upgrade google-api-python-client
#
# Installing the Google API oauth2 dependencies should be done before
# running the widget.
#
# This widget also requires the dateutil.parser module.
# If you get a strange "AttributeError: 'module' object has no attribute
# GoogleCalendar" error, you are probably missing a module. Check
# carefully.
#
# Also, note that the first time you run the widget, you will need to
# authenticate. The widget will automatically pop an authentication  web
# page. Add your calendar login/password and authorize the widget to
# access your calendar data and you are good to go. Depending on the
# lifetime of the Google refresh_token, you may be required to
# re-authenticate periodically (shouldn't be more than every two weeks
# or so). After you are authenticated, the calendar data will be
# refreshed every 'update_interval' seconds.
#
# Thanks to the creator of the YahooWeather widget (dmpayton). This code
# borrows liberally from that one.
###################################################################

import base
import httplib2
import datetime
import re
import dateutil.parser
import threading
import gobject

from apiclient.discovery import build
from oauth2client.client import OAuth2WebServerFlow
from oauth2client.tools import run
import oauth2client.file

from libqtile import utils

class GoogleCalendar(base.ThreadedPollText):
    ''' This widget will display the next appointment on your Google calendar
        in the qtile status bar. Appointments within the "reminder" time will
        be highlighted. Authentication credentials are stored in a file on
        disk.
    '''

    defaults = [
        ('calendar', 'primary', 'calendar to use'),
        (
            'format',
            ' {next_event} ',
            'calendar output - leave this at the default for now...'
        ),
        (
            'storage_file',
            None,
            'absolute path of secrets file - must be set'
        ),
        (
            'reminder_color',
            'FF0000',
            'color of calendar entries during reminder time'
        ),
        ('www_group', 'www', 'group to open browser into'),
        ('www_screen', 0, 'screen to open group on'),
        (
            'browser_cmd',
            '/usr/bin/firefox -url calendar.google.com',
            'command or script to execute on click'
        ),
    ]

    def __init__(self, **config):
        base.ThreadedPollText.__init__(self, **config)
        self.text = 'Calendar not initialized.'
        self.cred_init()
        # confirm credentials every hour
        self.timeout_add(3600, self.cred_init)

    def _configure(self, qtile, bar):
        base.ThreadedPollText._configure(self, qtile, bar)
        self.add_defaults(GoogleCalendar.defaults)
        self.layout = self.drawer.textlayout(
            self.text,
            self.foreground,
            self.font,
            self.fontsize,
            self.fontshadow,
            markup=True
        )

    def cred_init(self):
        #this is the main method for obtaining credentials
        self.log.info('refreshing GC credentials')

        # Set up a Flow object to be used for authentication.
        FLOW = OAuth2WebServerFlow(
            client_id='196949979762-5m3j4orcn9heesoh6td942gb2bph424q.'
            'apps.googleusercontent.com',
            client_secret='3H1-w_9gX4DFx3bC9c-whEBs',
            scope='https://www.googleapis.com/auth/calendar',
            user_agent='Qtile Google Calendar Widget/Version 0.3'
        )

        # storage is the location of our authentication credentials
        storage = oauth2client.file.Storage(self.storage_file)

        # get the credentials, and update if necessary
        # this method will write the new creds back to disk if they are updated
        self.credentials = storage.get()

        # if the credentials don't exist or are invalid, get new ones from FLOW
        # FLOW must be run in a different thread or it blocks qtile
        # when it tries to pop the authentication web page
        def get_from_flow(creds, storage):
            if creds is None or creds.invalid:
                self.credentials = run(FLOW, storage)
        threading.Thread(
            target=get_from_flow,
            args=(self.credentials, storage)
        ).start()

        return True

    def cal_updater(self):
        self.log.info('adding GC widget timer')

        def cal_getter():  # get cal data in thread, write it in main loop
            data = self.fetch_calendar()
            gobject.idle_add(self.update, data)
        threading.Thread(target=cal_getter).start()
        return True

    def button_press(self, x, y, button):
        base.ThreadedPollText.button_press(self, x, y, button)
        if hasattr(self, 'credentials'):
            self.qtile.addGroup(self.www_group)
            self.qtile.groupMap[self.www_group].cmd_toscreen(self.www_screen)
            self.qtile.cmd_spawn(self.browser_cmd)

    def poll(self):
        # if we don't have valid credentials, update them
        if not hasattr(self, 'credentials') or self.credentials.invalid:
            self.cred_init()
            data = {'next_event': 'Credentials updating'}
            return data

        # Create an httplib2.Http object to handle our HTTP requests and
        # authorize it with our credentials from self.cred_init
        http = httplib2.Http()
        http = self.credentials.authorize(http)

        service = build('calendar', 'v3', http=http)

        # current timestamp
        now = datetime.datetime.utcnow().isoformat('T')+'Z'
        data = {}

        # grab the next event
        events = service.events().list(
            calendarId=self.calendar,
            singleEvents=True,
            timeMin=now,
            maxResults='1',
            orderBy='startTime'
        ).execute()

        # get items list
        try:
            event = events.get('items', [])[0]
        except IndexError:
            data = {'next_event': 'No appointments scheduled'}
            return data

        # get reminder time
        try:
            remindertime = datetime.timedelta(
                0,
                int(
                    event.get('reminders').get('overrides')[0].get('minutes')
                ) * 60
            )
        except:
            remindertime = datetime.timedelta(0, 0)

        #format the data
        data = {
            'next_event': event['summary'] +
            ' ' +
            re.sub(
                ':.{2}-.*$',
                '',
                event['start']['dateTime'].replace('T', ' ')
            )
        }
        if dateutil.parser.parse(
                event['start']['dateTime'],
                ignoretz=True
                ) - remindertime <= datetime.datetime.now():
            data = {
                'next_event': '<span color="' +
                utils.hex(self.reminder_color) +
                '">' +
                data['next_event'] +
                '</span>'
            }

        # return the data
        return data

########NEW FILE########
__FILENAME__ = graph
import cairo

from . import base
from os import statvfs
import time

__all__ = [
    'CPUGraph',
    'MemoryGraph',
    'SwapGraph',
    'NetGraph',
    'HDDGraph',
    'HDDBusyGraph',
]


class _Graph(base._Widget):
    fixed_upper_bound = False
    defaults = [
        ("graph_color", "18BAEB", "Graph color"),
        ("fill_color", "1667EB.3", "Fill color for linefill graph"),
        ("border_color", "215578", "Widget border color"),
        ("border_width", 2, "Widget border width"),
        ("margin_x", 3, "Margin X"),
        ("margin_y", 3, "Margin Y"),
        ("samples", 100, "Count of graph samples."),
        ("frequency", 1, "Update frequency in seconds"),
        ("type", "linefill", "'box', 'line', 'linefill'"),
        ("line_width", 3, "Line width"),
        ("start_pos", "bottom", "Drawer starting position ('bottom'/'top')"),
    ]

    def __init__(self, width=100, **config):
        base._Widget.__init__(self, width, **config)
        self.add_defaults(_Graph.defaults)
        self.values = [0] * self.samples
        self.maxvalue = 0
        self.timeout_add(self.frequency, self.update)
        self.oldtime = time.time()
        self.lag_cycles = 0

    @property
    def graphwidth(self):
        return self.width - self.border_width * 2 - self.margin_x * 2

    @property
    def graphheight(self):
        return self.bar.height - self.margin_y * 2 - self.border_width * 2

    def draw_box(self, x, y, values):
        step = self.graphwidth / float(self.samples)
        self.drawer.set_source_rgb(self.graph_color)
        for val in values:
            val = self.val(val)
            self.drawer.fillrect(x, y - val, step, val)
            x += step

    def draw_line(self, x, y, values):
        step = self.graphwidth / float(self.samples - 1)
        self.drawer.ctx.set_line_join(cairo.LINE_JOIN_ROUND)
        self.drawer.set_source_rgb(self.graph_color)
        self.drawer.ctx.set_line_width(self.line_width)
        for val in values:
            self.drawer.ctx.line_to(x, y - self.val(val))
            x += step
        self.drawer.ctx.stroke()

    def draw_linefill(self, x, y, values):
        step = self.graphwidth / float(self.samples - 2)
        self.drawer.ctx.set_line_join(cairo.LINE_JOIN_ROUND)
        self.drawer.set_source_rgb(self.graph_color)
        self.drawer.ctx.set_line_width(self.line_width)
        for index, val in enumerate(values):
            self.drawer.ctx.line_to(x + index * step, y - self.val(val))
        self.drawer.ctx.stroke_preserve()
        self.drawer.ctx.line_to(
            x + (len(values) - 1) * step,
            y - 1 + self.line_width / 2.0
        )
        self.drawer.ctx.line_to(x, y - 1 + self.line_width / 2.0)
        self.drawer.set_source_rgb(self.fill_color)
        self.drawer.ctx.fill()

    def val(self, val):
        if self.start_pos == 'bottom':
            return val
        elif self.start_pos == 'top':
            return -val
        else:
            raise ValueError("Unknown starting position: %s." % self.start_pos)

    def draw(self):
        self.drawer.clear(self.background or self.bar.background)
        if self.border_width:
            self.drawer.set_source_rgb(self.border_color)
            self.drawer.ctx.set_line_width(self.border_width)
            self.drawer.ctx.rectangle(
                self.margin_x + self.border_width / 2.0,
                self.margin_y + self.border_width / 2.0,
                self.graphwidth + self.border_width,
                self.bar.height - self.margin_y * 2 - self.border_width,
            )
            self.drawer.ctx.stroke()
        x = self.margin_x + self.border_width
        y = self.margin_y + self.border_width
        if self.start_pos == 'bottom':
            y += self.graphheight
        elif not self.start_pos == 'top':
            raise ValueError("Unknown starting position: %s." % self.start_pos)
        k = 1.0 / (self.maxvalue or 1)
        scaled = [self.graphheight * val * k for val in reversed(self.values)]

        if self.type == "box":
            self.draw_box(x, y, scaled)
        elif self.type == "line":
            self.draw_line(x, y, scaled)
        elif self.type == "linefill":
            self.draw_linefill(x, y, scaled)
        else:
            raise ValueError("Unknown graph type: %s." % self.type)

        self.drawer.draw(self.offset, self.width)

    def push(self, value):
        if self.lag_cycles > self.samples:
            # compensate lag by sending the same value up to
            # the graph samples limit
            self.lag_cycles = 1

        self.values = ([value] * min(self.samples, self.lag_cycles)) + self.values
        self.values = self.values[:self.samples]

        if not self.fixed_upper_bound:
            self.maxvalue = max(self.values)
        self.draw()

    def update(self):
        # lag detection
        newtime = time.time()
        self.lag_cycles = int((newtime - self.oldtime) / self.frequency)
        self.oldtime = newtime

        if self.configured:
            self.update_graph()
        return True

    def fullfill(self, value):
        self.values = [value] * len(self.values)


class CPUGraph(_Graph):
    defaults = [
        ("core", "all", "Which core to show (all/0/1/2/...)"),
    ]

    fixed_upper_bound = True

    def __init__(self, **config):
        _Graph.__init__(self, **config)
        self.add_defaults(CPUGraph.defaults)
        self.maxvalue = 100
        self.oldvalues = self._getvalues()

    def _getvalues(self):
        with open('/proc/stat') as file:
            lines = file.readlines()

            # default to all cores (first line)
            line = lines.pop(0)

            # core specified, grab the corresponding line
            if isinstance(self.core, int):
                # we already removed the first line from the list,
                # so it's 0 indexed now :D
                line = lines[self.core]

                if not line.startswith("cpu%s" % self.core):
                    raise ValueError("No such core: %s" % self.core)

            name, user, nice, sys, idle, iowait, tail = line.split(None, 6)

            return (int(user), int(nice), int(sys), int(idle))

    def update_graph(self):
        nval = self._getvalues()
        oval = self.oldvalues
        busy = nval[0] + nval[1] + nval[2] - oval[0] - oval[1] - oval[2]
        total = busy + nval[3] - oval[3]
        # sometimes this value is zero for unknown reason (time shift?)
        # we just sent the previous value, because it gives us no info about
        # cpu load, if it's zero.

        if total:
            push_value = busy * 100.0 / total
            self.push(push_value)
        else:
            self.push(self.values[0])
        self.oldvalues = nval


def get_meminfo():
    with open('/proc/meminfo') as file:
        val = {}
        for line in file:
            key, tail = line.split(':')
            uv = tail.split()
            val[key] = int(uv[0])
    return val


class MemoryGraph(_Graph):
    fixed_upper_bound = True

    def __init__(self, **config):
        _Graph.__init__(self, **config)
        val = self._getvalues()
        self.maxvalue = val['MemTotal']

        mem = val['MemTotal'] - val['MemFree'] - val['Buffers'] - val['Cached']
        self.fullfill(mem)

    def _getvalues(self):
        return get_meminfo()

    def update_graph(self):
        val = self._getvalues()
        self.push(
            val['MemTotal'] - val['MemFree'] - val['Buffers'] - val['Cached']
        )


class SwapGraph(_Graph):
    fixed_upper_bound = True

    def __init__(self, **config):
        _Graph.__init__(self, **config)
        val = self._getvalues()
        self.maxvalue = val['SwapTotal']
        swap = val['SwapTotal'] - val['SwapFree'] - val['SwapCached']
        self.fullfill(swap)

    def _getvalues(self):
        return get_meminfo()

    def update_graph(self):
        val = self._getvalues()

        swap = val['SwapTotal'] - val['SwapFree'] - val['SwapCached']

        # can change, swapon/off
        if self.maxvalue != val['SwapTotal']:
            self.maxvalue = val['SwapTotal']
            self.fullfill(swap)
        self.push(swap)


class NetGraph(_Graph):
    defaults = [
        (
            "interface",
            "auto",
            "Interface to display info for ('auto' for detection)"
        ),
        ("bandwidth_type", "down", "down(load)/up(load)"),
    ]

    def __init__(self, **config):
        _Graph.__init__(self, **config)
        self.add_defaults(NetGraph.defaults)
        if self.interface == "auto":
            try:
                self.interface = self.get_main_iface()
            except RuntimeError:
                self.log.warning(
                    "NetGraph - Automatic interface detection failed, "
                    "falling back to 'eth0'"
                )
                self.interface = "eth0"
        self.filename = '/sys/class/net/{interface}/statistics/{type}'.format(
            interface=self.interface,
            type=self.bandwidth_type == 'down' and 'rx_bytes' or 'tx_bytes'
        )
        self.bytes = 0
        self.bytes = self._getValues()

    def _getValues(self):
        try:
            with open(self.filename) as file:
                val = int(file.read())
                rval = val - self.bytes
                self.bytes = val
                return rval
        except IOError:
            return 0

    def update_graph(self):
        val = self._getValues()
        self.push(val)

    @staticmethod
    def get_main_iface():
        filename = "/proc/net/route"
        make_route = lambda line: dict(zip(['iface', 'dest'], line.split()))
        routes = [make_route(line) for line in list(open(filename))[1:]]
        try:
            return next(
                (r for r in routes if not int(r['dest'], 16)),
                routes[0]
            )['iface']
        except:
            raise RuntimeError('No valid interfaces available')


class HDDGraph(_Graph):
    fixed_upper_bound = True
    defaults = [
        ("path", "/", "Partition mount point."),
        ("space_type", "used", "free/used")
    ]

    def __init__(self, **config):
        _Graph.__init__(self, **config)
        self.add_defaults(HDDGraph.defaults)
        stats = statvfs(self.path)
        self.maxvalue = stats.f_blocks * stats.f_frsize
        values = self._getValues()
        self.fullfill(values)

    def _getValues(self):
        stats = statvfs(self.path)
        if self.space_type == 'used':
            return (stats.f_blocks - stats.f_bfree) * stats.f_frsize
        else:
            return stats.f_bavail * stats.f_frsize

    def update_graph(self):
        val = self._getValues()
        self.push(val)


class HDDBusyGraph(_Graph):
    """
    Parses /sys/block/<dev>/stat file and extracts overall device
    IO usage, based on `io_ticks`'s value.
    See https://www.kernel.org/doc/Documentation/block/stat.txt
    """
    defaults = [
        ("device", "sda", "Block device to display info for")
    ]

    def __init__(self, **config):
        _Graph.__init__(self, **config)
        self.add_defaults(HDDBusyGraph.defaults)
        self.path = '/sys/block/{dev}/stat'.format(
            dev=self.device
        )
        self._prev = 0

    def _getActivity(self):
        try:
            # io_ticks is field number 9
            io_ticks = int(open(self.path).read().split()[9])
        except IOError:
            return 0
        activity = io_ticks - self._prev
        self._prev = io_ticks
        return activity

    def update_graph(self):
        self.push(self._getActivity())

########NEW FILE########
__FILENAME__ = groupbox
from .. import bar, hook, utils
import base


class _GroupBase(base._TextBox, base.PaddingMixin, base.MarginMixin):
    defaults = [
        ("borderwidth", 3, "Current group border width"),
    ]

    def __init__(self, **config):
        base._TextBox.__init__(self, bar.CALCULATED, **config)
        self.add_defaults(_GroupBase.defaults)
        self.add_defaults(base.PaddingMixin.defaults)
        self.add_defaults(base.MarginMixin.defaults)

    def box_width(self, groups):
        width, height = self.drawer.max_layout_size(
            [i.name for i in groups],
            self.font,
            self.fontsize
        )
        return width + self.padding_x * 2 + self.margin_x * 2 + \
            self.borderwidth * 2

    def _configure(self, qtile, bar):
        base._Widget._configure(self, qtile, bar)

        if self.fontsize is None:
            calc = self.bar.height - self.margin_y * 2 - \
                self.borderwidth * 2 - self.padding_y * 2
            self.fontsize = max(calc, 1)

        self.layout = self.drawer.textlayout(
            "",
            "ffffff",
            self.font,
            self.fontsize,
            self.fontshadow
        )
        self.setup_hooks()

    def setup_hooks(self):
        def hook_response(*args, **kwargs):
            self.bar.draw()
        hook.subscribe.client_managed(hook_response)
        hook.subscribe.client_urgent_hint_changed(hook_response)
        hook.subscribe.client_killed(hook_response)
        hook.subscribe.setgroup(hook_response)
        hook.subscribe.group_window_add(hook_response)

    def drawbox(self, offset, text, bordercolor, textcolor, rounded=False,
                block=False, width=None):
        self.layout.text = text
        self.layout.font_family = self.font
        self.layout.font_size = self.fontsize
        self.layout.colour = textcolor
        if width is not None:
            self.layout.width = width
        framed = self.layout.framed(
            self.borderwidth,
            bordercolor,
            self.padding_x,
            self.padding_y
        )
        if block:
            framed.draw_fill(offset, self.margin_y, rounded)
        else:
            framed.draw(offset, self.margin_y, rounded)


class AGroupBox(_GroupBase):
    """
        A widget that graphically displays the current group.
    """
    defaults = [("border", "000000", "group box border color")]

    def __init__(self, **config):
        _GroupBase.__init__(self, **config)
        self.add_defaults(AGroupBox.defaults)

    def button_press(self, x, y, button):
        self.bar.screen.cmd_nextgroup()

    def calculate_width(self):
        return self.box_width(self.qtile.groups)

    def draw(self):
        self.drawer.clear(self.background or self.bar.background)
        e = (
            i for i in self.qtile.groups
            if i.name == self.bar.screen.group.name
        ).next()
        self.drawbox(self.margin_x, e.name, self.border, self.foreground)
        self.drawer.draw(self.offset, self.width)


class GroupBox(_GroupBase):
    """
        A widget that graphically displays the current group.
    """
    defaults = [
        ("active", "FFFFFF", "Active group font colour"),
        ("inactive", "404040", "Inactive group font colour"),
        ("urgent_text", "FF0000", "Urgent group font color"),
        (
            "highlight_method",
            "border",
            "Method of highlighting (one of 'border' or 'block') "
            "Uses *_border color settings"
        ),
        ("rounded", True, "To round or not to round borders"),
        (
            "this_current_screen_border",
            "215578",
            "Border colour for group on this screen when focused."
        ),
        (
            "urgent_alert_method",
            "border",
            "Method for alerting you of WM urgent "
            "hints (one of 'border', 'text' or 'block')"
        ),
        (
            "disable_drag",
            False,
            "Disable dragging and dropping of group names on widget"
        ),
        (
            "this_screen_border",
            "215578",
            "Border colour for group on this screen."
        ),
        (
            "other_screen_border",
            "404040",
            "Border colour for group on other screen."
        ),
        ("urgent_border", "FF0000", "Urgent border color"),
        ("invert_mouse_wheel", False, "Whether to invert mouse wheel group movement")
    ]

    def __init__(self, **config):
        _GroupBase.__init__(self, **config)
        self.add_defaults(GroupBox.defaults)
        self.clicked = None

    def get_clicked_group(self, x, y):
        group = None
        new_width = 0
        width = 0
        for g in self.qtile.groups:
            new_width += self.box_width([g])
            if x >= width and x <= new_width:
                group = g
                break
            width = new_width
        return group

    def button_press(self, x, y, button):
        self.clicked = None
        group = None
        curGroup = self.qtile.currentGroup

        if button == (5 if not self.invert_mouse_wheel else 4):
            group = curGroup.prevGroup()
        elif button == (4 if not self.invert_mouse_wheel else 5):
            group = curGroup.nextGroup()
        else:
            group = self.get_clicked_group(x, y)
            if not self.disable_drag:
                self.clicked = group

        if group:
            self.bar.screen.setGroup(group)

    def button_release(self, x, y, button):
        if button not in (5, 4):
            group = self.get_clicked_group(x, y)
            if group and self.clicked:
                group.cmd_switch_groups(self.clicked.name)
                self.clicked = None

    def calculate_width(self):
        width = 0
        for g in self.qtile.groups:
            width += self.box_width([g])
        return width

    def group_has_urgent(self, group):
        return len([w for w in group.windows if w.urgent]) > 0

    def draw(self):
        self.drawer.clear(self.background or self.bar.background)

        offset = 0
        for i, g in enumerate(self.qtile.groups):
            is_block = (self.highlight_method == 'block')

            bw = self.box_width([g])
            if g.screen:
                if self.bar.screen.group.name == g.name:
                    if self.qtile.currentScreen == self.bar.screen:
                        border = self.this_current_screen_border
                    else:
                        border = self.this_screen_border
                else:
                    border = self.other_screen_border
            elif self.group_has_urgent(g) and \
                    self.urgent_alert_method in ('border', 'block'):
                border = self.urgent_border
                if self.urgent_alert_method == 'block':
                    is_block = True
            else:
                border = self.background or self.bar.background

            if self.group_has_urgent(g) and self.urgent_alert_method == "text":
                text = self.urgent_text
            elif g.windows:
                text = self.active
            else:
                text = self.inactive

            self.drawbox(
                self.margin_x + offset,
                g.name,
                border,
                text,
                self.rounded,
                is_block,
                bw - self.margin_x * 2 - self.padding_x * 2
            )
            offset += bw
        self.drawer.draw(self.offset, self.width)

########NEW FILE########
__FILENAME__ = image
import os
import cairo

import base
from .. import bar

class Image(base._Widget, base.MarginMixin):

    defaults = [
        ("scale", True, "Enable/Disable image scaling"),
        ("filename", None, "PNG Image filename. Can contain '~'"),
    ]

    def __init__(self, width=bar.CALCULATED, **config):
        base._Widget.__init__(self, width, **config)
        self.add_defaults(Image.defaults)
        self.add_defaults(base.MarginMixin.defaults)

        # make the default 0 instead
        self._widget_defaults["margin"] = 0

    def _configure(self, qtile, bar):
        base._Widget._configure(self, qtile, bar)

        if not self.filename:
            raise ValueError("Filename not set!")

        self.filename = os.path.expanduser(self.filename)

        try:
            self.image = cairo.ImageSurface.create_from_png(self.filename)
        except MemoryError:
            raise ValueError("The image '%s' doesn't seem to be a valid PNG"
                % (self.filename))

        self.pattern = cairo.SurfacePattern(self.image)

        self.image_width = self.image.get_width()
        self.image_height = self.image.get_height()

        if self.scale:
            new_height = self.bar.height - (self.margin_y * 2)

            if new_height and self.image_height != new_height:
                scaler = cairo.Matrix()
                sp = self.image_height / float(new_height)
                self.image_height = new_height
                self.image_width = int(self.image_width / sp)
                scaler.scale(sp, sp)
                self.pattern.set_matrix(scaler)

    def draw(self):
        self.drawer.clear(self.bar.background)
        self.drawer.ctx.save()
        self.drawer.ctx.translate(self.margin_x, self.margin_y)
        self.drawer.ctx.set_source(self.pattern)
        self.drawer.ctx.paint()
        self.drawer.ctx.restore()

        self.drawer.draw(self.offset, self.width)

    def calculate_width(self):
        return self.image_width + (self.margin_x * 2)

########NEW FILE########
__FILENAME__ = keyboardlayout
import subprocess
from subprocess import CalledProcessError
import base
import re


class KeyboardLayout(base.InLoopPollText):
    """
        Widget for changing and displaying the current keyboard layout.
        It requires setxkbmap to be available in the sytem.
    """
    defaults = [
        ("update_interval", 1, "Update time in seconds."),
        ("configured_keyboards", "us", "A list of predefined keyboard layouts "
            "represented as strings. For example: "
            "['us', 'us colemak', 'es', 'fr']."),
    ]

    def __init__(self, **config):
        base.InLoopPollText.__init__(self, **config)
        self.add_defaults(KeyboardLayout.defaults)

    def button_press(self, x, y, button):
        if button == 1:
            self.next_keyboard()

    def next_keyboard(self):
        """
            Set the next layout in the list of configured keyboard layouts as
            new current layout in use.
            If the current keyboard layout is not in the list, it will set as
            new layout the first one in the list.
        """

        current_keyboard = self.poll()
        if current_keyboard in self.configured_keyboards:
            # iterate the list circularly
            next_keyboard = self.configured_keyboards[
                (self.configured_keyboards.index(current_keyboard) + 1) %
                len(self.configured_keyboards)]
        else:
            next_keyboard = self.configured_keyboards[0]
        self._set_keyboard(next_keyboard)

    def poll(self):
        """
            Return the currently used keyboard layout as a string.
            Examples: "us", "us dvorak".
            In case of error returns "unknown".
        """
        try:
            xset_output = subprocess.check_output(["xset", "-q"])
            keyboard = _Keyboard(self.configured_keyboards).get_keyboard_layout(xset_output).upper()
            return str(keyboard)
        except CalledProcessError as e:
            self.log.error('Can not change the keyboard layout: {0}'
                           .format(e))
        except OSError as e:
            self.log.error('Please, check that setxkbmap is available: {0}'
                           .format(e))
        return "unknown"

    def _set_keyboard(self, keyboard):
        command = ['setxkbmap']
        command.extend(keyboard.split(" "))
        try:
            subprocess.check_call(command)
        except CalledProcessError as e:
            self.log.error('Can not change the keyboard layout: {0}'
                           .format(e))
        except OSError as e:
            self.log.error('Please, check that setxkbmap is available: {0}'
                           .format(e))


class _Keyboard(object):

    def __init__(self, configured_keyboards):
        if len(configured_keyboards) == 1:
            self.languages = {
                'first': configured_keyboards[0],
                'second': 'None',
            }
        else:
            self.languages = {
                'first': configured_keyboards[0],
                'second': configured_keyboards[1],
            }
        self.regular_strings = {
            'hexadecimal': {
                'first': """\w{4}e\w{3}""",
                'second': """\w{4}f\w{3}""",
            },
            'binary': {
                'first': """\w{4}0\w{3}""",
                'second': """\w{4}1\w{3}""",
            },
            "inetger": "\d{8}",
            "led_mask": """LED mask:\s\s\w{8}""",
        }

    def get_keyboard_layout(self, xset_output):
        raw_list = []

        for item in xset_output.strip().splitlines():
            if re.search(self.regular_strings['led_mask'], item):
                raw_led_mask = re.search(self.regular_strings['led_mask'], item).group()
                raw_list = raw_led_mask.split(':')
                led_mask = raw_list[1].strip()
                break

        if not re.search(self.regular_strings['inetger'], led_mask):
            cur_regular_strings = self.regular_strings['hexadecimal']
        else:
            cur_regular_strings = self.regular_strings['binary']

        if re.search(cur_regular_strings['first'], led_mask):
            result = self.languages['first']
        elif re.search(cur_regular_strings['second'], led_mask):
            result = self.languages['second']
        else:
            result = "ERR"
        return result

########NEW FILE########
__FILENAME__ = launchbar
"""
This module define a widget that displays icons to launch softwares or commands
when clicked -- a launchbar.
Only png icon files are displayed, not xpm because cairo doesn't support
loading of xpm file.

To execute a software:
 - ('thunderbird', 'thunderbird -safe-mode', 'launch thunderbird in safe mode')
To execute a python command in qtile, begin with by 'qsh:'
 - ('logout', 'qsh:self.qtile.cmd_shutdown()', 'logout from qtile')


"""

from libqtile import bar
from libqtile.widget import base
import os.path
import cairo
import gobject
from xdg.IconTheme import getIconPath


class LaunchBar(base._Widget):
    """
    A widget that display icons to launch the associated command
    """

    defaults = [
        ('padding', 2, 'Padding between icons'),
        ('default_icon', '/usr/share/icons/oxygen/256x256/mimetypes/\
        application-x-executable.png', 'Default icon not found'),
    ]

    def __init__(self, progs=None, width=bar.CALCULATED, **config):
        """
        @progs: a list of tuple (software_name, command_to_execute, comment)
        for example:
        ('thunderbird', 'thunderbird -safe-mode', 'launch thunderbird in safe\
        mode')
        ('logout', 'qsh:self.qtile.cmd_shutdown()', 'logout from qtile')
        """
        base._Widget.__init__(self, width, *config)
        if progs is None:
            progs = []
        self.add_defaults(LaunchBar.defaults)
        self.surfaces = {}
        self.icons_files = {}
        self.icons_widths = {}
        self.icons_offsets = {}
        # For now, ignore the comments but may be one day it will be useful
        self.commands = {prg[0]: prg[1] for prg in progs}

    def _configure(self, qtile, pbar):
        base._Widget._configure(self, qtile, pbar)
        self.lookup_icons()
        self.setup_images()
        self.width = self.calculate_width()

    def setup_images(self):
        """ Create image structures for each icon files. """
        for img_name, iconfile in self.icons_files.iteritems():
            try:
                img = cairo.ImageSurface.create_from_png(iconfile)
            except cairo.Error:
                self.qtile.log.exception('No icon found for application ' +
                                         img_name + '(' + iconfile + ')')
                return

            input_width = img.get_width()
            input_height = img.get_height()

            sp = input_height / float(self.bar.height - 4)

            width = input_width / sp
            if width > self.width:
                self.width = int(width) + self.padding * 2

            imgpat = cairo.SurfacePattern(img)

            scaler = cairo.Matrix()

            scaler.scale(sp, sp)
            scaler.translate(self.padding * -1, -2)
            imgpat.set_matrix(scaler)

            imgpat.set_filter(cairo.FILTER_BEST)
            self.surfaces[img_name] = imgpat
            self.icons_widths[img_name] = width

    def _lookup_icon(self, name):
        """ Search for the icon corresponding to one command. """

        # if the software_name is directly an abslolute path icon file
        if os.path.isabs(name):
            # name start with '/' thus it's an absolute path
            root, ext = os.path.splitext(name)
            if ext == '.png':
                self.icons_files[name] = name if os.path.isfile(name) else None
            else:
                # try to add the extension
                self.icons_files[name] = name + '.png' if os.path.isfile(name +
                                                '.png') else None
        else:
            self.icons_files[name] = getIconPath(name)

        if self.icons_files[name] is None:
            self.icons_files[name] = self.default_icon

    def lookup_icons(self):
        """ Search for the icons corresponding to the commands to execute. """
        if not os.path.isfile(self.default_icon):
            self.default_icon = None
        for name in self.commands:
            self._lookup_icon(name)

    def get_icon_in_position(self, x, y):
        """ Retreive the wich icon is clicked according to its position. """
        for i in self.commands:
            if x < self.icons_offsets[i] + self.icons_widths[i] + self.padding\
               / 2:
                return i

    def button_press(self, x, y, button):
        """ Launch the associated command to the clicked icon. """
        if button == 1:
            icon = self.get_icon_in_position(x, y)
            if icon:
                cmd = self.commands[icon]
                if cmd.startswith('qsh:'):
                    eval(cmd[4:])
                else:
                    gobject.spawn_async([os.environ['SHELL'], '-c', cmd])
            self.draw()

    def draw(self):
        """ Draw the icons in the widget. """
        width = self.calculate_width()
        self.width = width
        self.drawer.clear(self.background or self.bar.background)
        xoffset = 0
        for i in self.commands:
            self.icons_offsets[i] = xoffset+self.padding
            self.drawer.ctx.move_to(self.offset + xoffset,
                                    self.icons_widths[i])
            self.drawer.clear(self.background or self.bar.background)
            self.drawer.ctx.set_source(self.surfaces[i])
            self.drawer.ctx.paint()
            self.drawer.draw(self.offset + xoffset,
                             self.icons_widths[i] + self.padding)
            xoffset += self.icons_widths[i] + self.padding

    def calculate_width(self):
        """ Compute the width of the widget according to each icon width. """
        return sum(self.icons_widths.values()) + self.padding * (
            len(self.icons_files.values()) + 1)

########NEW FILE########
__FILENAME__ = maildir
# -*- coding: utf-8 -*-
# vim: set sw=4 et tw=80:

import base

import os.path
import mailbox


class Maildir(base.ThreadedPollText):
    """
    A simple widget showing the number of new mails in maildir mailboxes.
    """

    # TODO: make this use our settings framework
    def __init__(self, maildirPath, subFolders, separator=" ", **config):
        """
        Constructor.

        @param maildirPath: the path to the Maildir (e.g. "~/Mail").
        @param subFolders: the subfolders to scan (e.g. [{"path": "INBOX", "label": "Home mail"}, {"path": "spam", "label": "Home junk"}]).
        @param separator: the string to put between the subfolder strings.
        @param timeout: the refresh timeout in seconds.
        """
        base.ThreadedPollText.__init__(self, **config)
        self._maildirPath = os.path.expanduser(maildirPath)
        self._separator = separator
        self._subFolders = []

        # if it looks like a list of strings then we just convert them
        # and use the name as the label
        if isinstance(subFolders[0], basestring):
            self._subFolders = [
                {"path": folder, "label": folder}
                for folder in subFolders
            ]
        else:
            self._subFolders = subFolders

    def poll(self):
        """
        Scans the mailbox for new messages.

        @return: A string representing the current mailbox state.
        """
        state = {}

        def to_maildir_fmt(paths):
            for path in iter(paths):
                yield path.rsplit(":")[0]

        for subFolder in self._subFolders:
            path = os.path.join(self._maildirPath, subFolder["path"])
            maildir = mailbox.Maildir(path)
            state[subFolder["label"]] = 0

            for file in to_maildir_fmt(os.listdir(os.path.join(path, "new"))):
                if file in maildir:
                    state[subFolder["label"]] += 1

        return self.format_text(state)

    def format_text(self, state):
        """
        Converts the state of the subfolders to a string.

        @param state: a dictionary as returned by mailbox_state.
        @return: a string representation of the given state.
        """
        return self._separator.join(
            "{}: {}".format(*item) for item in state.iteritems()
        )

########NEW FILE########
__FILENAME__ = mpdwidget
# -*- coding: utf-8 -*-
# depends on python-mpd


# TODO: check if UI hangs in case of network issues and such
# TODO: python-mpd supports idle proto, can widgets be push instead of pull?
# TODO: a teardown hook so I can client.disconnect() ?
# TODO: some kind of templating to make shown info configurable
# TODO: best practice to handle failures? just write to stderr?

from .. import utils
from mpd import MPDClient, CommandError
import atexit
import base
import re


class Mpd(base.ThreadedPollText):
    """
        An mpd widget
    """
    defaults = [
        ("foreground_progress", "ffffff", "Foreground progress colour"),
        (
            "reconnect",
            False,
            "Choose if the widget should try to keep reconnecting."
        )
    ]

    # TODO: have this use our config framework
    def __init__(self, host='localhost', port=6600,
                 password=False, fmt_playing="%a - %t [%v%%]",
                 fmt_stopped="Stopped [%v%%]", msg_nc='Mpd off',
                 do_color_progress=True, **config):
        """
            - host: host to connect to
            - port: port to connect to
            - password: password to use
            - fmt_playing, fmt_stopped: format strings to display when playing/paused and when stopped, respectively
            - msg_nc: which message to show when we're not connected
            - do_color_progress: whether to indicate progress in song by altering message color
            - width: A fixed width, or bar.CALCULATED to calculate the width
            automatically (which is recommended).
        """
        self.host = host
        self.port = port
        self.password = password
        self.fmt_playing, self.fmt_stopped = fmt_playing, fmt_stopped
        self.msg_nc = msg_nc
        self.do_color_progress = do_color_progress
        self.inc = 2
        base.ThreadedPollText.__init__(self, **config)
        self.add_defaults(Mpd.defaults)
        self.client = MPDClient()
        self.connected = False
        self.connect()

    def connect(self, ifneeded=False):
        if self.connected:
            if not ifneeded:
                self.log.warning(
                    'Already connected. '
                    'No need to connect again. '
                    'Maybe you want to disconnect first.'
                )
            return True
        CON_ID = {'host': self.host, 'port': self.port}
        if not self.mpdConnect(CON_ID):
            self.log.error('Cannot connect to MPD server.')
        if self.password:
            if not self.mpdAuth(self.password):
                self.log.warning('Authentication failed.  Disconnecting')
                try:
                    self.client.disconnect()
                except Exception:
                    self.log.exception('Error disconnecting mpd')
        return self.connected

    def mpdConnect(self, con_id):
        """
            Simple wrapper to connect MPD.
        """
        try:
            self.client.connect(**con_id)
        except Exception:
            self.log.exception('Error connecting mpd')
            return False
        self.connected = True
        return True

    def mpdDisconnect(self):
        """
            Simple wrapper to disconnect MPD.
        """
        try:
            self.client.disconnect()
        except Exception:
            self.log.exception('Error disconnecting mpd')
            return False
        self.connected = False
        return True

    def mpdAuth(self, secret):
        """
            Authenticate
        """
        try:
            self.client.password(secret)
        except CommandError:
            return False
        return True

    def _configure(self, qtile, bar):
        base.ThreadedPollText._configure(self, qtile, bar)
        self.layout = self.drawer.textlayout(
            self.text,
            self.foreground,
            self.font,
            self.fontsize,
            self.fontshadow,
            markup=True
        )
        atexit.register(self.mpdDisconnect)

    def to_minutes_seconds(self, stime):
        """Takes an integer time in seconds, transforms it into
        (HH:)?MM:SS. HH portion is only visible if total time is greater
        than an hour.
        """
        if type(stime) != int:
            stime = int(stime)
        mm = stime // 60
        ss = stime % 60
        if mm >= 60:
            hh = mm // 60
            mm = mm % 60
            rv = "{}:{:02}:{:02}".format(hh, mm, ss)
        else:
            rv = "{}:{:02}".format(mm, ss)
        return rv

    def get_artist(self):
        return self.song['artist']

    def get_album(self):
        return self.song['album']

    def get_elapsed(self):
        elapsed = self.status['time'].split(':')[0]
        return self.to_minutes_seconds(elapsed)

    def get_file(self):
        return self.song['file']

    def get_length(self):
        return self.to_minutes_seconds(self.song['time'])

    def get_number(self):
        return str(int(self.status['song'])+1)

    def get_playlistlength(self):
        return self.status['playlistlength']

    def get_status(self):
        n = self.status['state']
        if n == "play":
            return "->"
        elif n == "pause":
            return "||"
        elif n == "stop":
            return "[]"

    def get_longstatus(self):
        n = self.status['state']
        if n == "play":
            return "Playing"
        elif n == "pause":
            return "Paused"
        elif n == "stop":
            return "Stopped"

    def get_title(self):
        return self.song['title']

    def get_track(self):
        # This occasionally has leading zeros we don't want.
        return str(int(self.song['track'].split('/')[0]))

    def get_volume(self):
        return self.status['volume']

    def get_single(self):
        if self.status['single'] == '1':
            return '1'
        else:
            return '_'

    def get_repeat(self):
        if self.status['repeat'] == '1':
            return 'R'
        else:
            return '_'

    def get_shuffle(self):
        if self.status['random'] == '1':
            return 'S'
        else:
            return '_'

    formats = {
        'a': get_artist, 'A': get_album, 'e': get_elapsed,
        'f': get_file, 'l': get_length, 'n': get_number,
        'p': get_playlistlength, 's': get_status, 'S': get_longstatus,
        't': get_title, 'T': get_track, 'v': get_volume, '1': get_single,
        'r': get_repeat, 'h': get_shuffle, '%': lambda x: '%',
    }

    def match_check(self, m):
        try:
            return self.formats[m.group(1)](self)
        except KeyError:
            return "(nil)"

    def do_format(self, string):
        return re.sub("%(.)", self.match_check, string)

    def poll(self):
        # If we're already connected, or if users want to reconnect and we can
        # successfully reconnect...
        if self.connected or (self.reconnect and self.connect(True)):
            try:
                self.status = self.client.status()
                self.song = self.client.currentsong()
                if self.status['state'] != 'stop':
                    playing = self.do_format(self.fmt_playing)

                    if self.do_color_progress and \
                            self.status and \
                            self.status.get('time', None):
                        elapsed, total = self.status['time'].split(':')
                        percent = float(elapsed) / float(total)
                        progress = int(percent * len(playing))
                        playing = '<span color="%s">%s</span>%s' % (
                            utils.hex(self.foreground_progress),
                            utils.escape(playing[:progress]),
                            utils.escape(playing[progress:])
                        )
                    else:
                        playing = utils.escape(playing)
                else:
                    playing = self.do_format(self.fmt_stopped)

            except Exception:
                self.log.exception('Mpd error on update')
                playing = self.msg_nc
                self.mpdDisconnect()
        else:
            if self.reconnect:
                playing = self.msg_nc
            else:
                playing = ''

        return playing

    def button_press(self, x, y, button):
        if not self.connect(True):
            return False
        try:
            status = self.client.status()
            if button == 3:
                if not status:
                    self.client.play()
                else:
                    self.client.pause()
            elif button == 4:
                self.client.previous()
            elif button == 5:
                self.client.next()
            elif button == 8:
                if status:
                    self.client.setvol(
                        max(int(status['volume']) - self.inc, 0)
                    )
            elif button == 9:
                if status:
                    self.client.setvol(
                        min(int(status['volume']) + self.inc, 100)
                    )
        except Exception:
            self.log.exception('Mpd error on click')

########NEW FILE########
__FILENAME__ = mpriswidget
import dbus

from dbus.mainloop.glib import DBusGMainLoop

import base
from .. import bar


class Mpris(base._TextBox):
    """
    A widget which displays the current track/artist of your favorite MPRIS
    player. It should work with all players which implement a reasonably
    correct version of MPRIS, though I have only tested it with clementine.
    """

    def __init__(self, name="clementine", width=bar.CALCULATED,
                 objname='org.mpris.clementine', **config):
        base._TextBox.__init__(self, " ", width, **config)

        # we need a main loop to get event signals
        # we just piggyback on qtile's main loop
        self.dbus_loop = DBusGMainLoop()
        self.bus = dbus.SessionBus(mainloop=self.dbus_loop)

        # watch for our player to start up
        deebus = self.bus.get_object(
            'org.freedesktop.DBus',
            '/org/freedesktop/DBus'
        )
        deebus.connect_to_signal(
            "NameOwnerChanged",
            self.handle_name_owner_change
        )

        self.objname = objname
        self.connected = False
        self.name = name

        # try to connect for grins
        self._connect()
        self.timeout_add(1, self.update)

    def _connect(self):
        """ Try to connect to the player if it exists. """
        try:
            self.player = self.bus.get_object(self.objname, '/Player')
            self.iface = dbus.Interface(
                self.player,
                dbus_interface='org.freedesktop.MediaPlayer'
            )
            # See: http://xmms2.org/wiki/MPRIS for info on signals
            # and what they mean.
            self.iface.connect_to_signal(
                "TrackChange",
                self.handle_track_change
            )
            self.iface.connect_to_signal(
                "StatusChange",
                self.handle_status_change
            )
            self.connected = True
        except dbus.exceptions.DBusException:
            self.connected = False

    def handle_track_change(self, metadata):
        self.update()

    def handle_status_change(self, *args):
        self.update()

    def handle_name_owner_change(self, name, old_owner, new_owner):
        if name == self.objname:
            if old_owner == '':
                # Our player started, so connect to it
                self._connect()
            elif new_owner == '':
                # It disconnected :-(
                self.connected = False
            self.update()

    def ensure_connected(f):
        """
        Tries to connect to the player. It *should* be succesful if the player
        is alive. """
        def wrapper(*args, **kwargs):
            self = args[0]
            try:
                self.iface.GetMetadata()
            except (dbus.exceptions.DBusException, AttributeError):
                # except AttributeError because
                # self.iface won't exist if we haven't
                # _connect()ed yet
                self._connect()
            return f(*args, **kwargs)
        return wrapper

    @ensure_connected
    def update(self):
        if not self.configured:
            return True
        if not self.connected:
            playing = ''
        elif not self.is_playing():
            playing = 'Stopped'
        else:
            try:
                metadata = self.iface.GetMetadata()

                # TODO: Make this configurable?
                playing = metadata["title"] + ' - ' + metadata["artist"]
            except dbus.exceptions.DBusException:
                self.connected = False
                playing = ''

        if playing != self.text:
            self.text = playing
            self.bar.draw()

    @ensure_connected
    def is_playing(self):
        """ Returns true if we are connected to the player and it is playing
        something, false otherwise. """
        if self.connected:
            (playing, random, repeat, stop_after_last) = self.iface.GetStatus()
            return playing == 0
        else:
            return False

    def cmd_info(self):
        """ What's the current state of the widget? """
        return dict(
            connected=self.connected,
            nowplaying=self.text,
            isplaying=self.is_playing(),
        )

    def cmd_update(self):
        """ Force the widget to update. Mostly used for testing. """
        self.update()

# vim: tabstop=4 shiftwidth=4 expandtab

########NEW FILE########
__FILENAME__ = notify
# -*- coding: utf-8 -*-
import sys

from .. import bar, drawer, utils
from libqtile.notify import notifier
import base


class Notify(base._TextBox):
    """
        An notify widget
    """
    defaults = [
        ("foreground_urgent", "ff0000", "Foreground urgent priority colour"),
        ("foreground_low", "dddddd", "Foreground low priority  colour"),
        (
            "default_timeout",
            None,
            "Default timeout (seconds) for notifications"
        ),
    ]

    def __init__(self, width=bar.CALCULATED, **config):
        base._TextBox.__init__(self, "", width, **config)
        self.add_defaults(Notify.defaults)
        notifier.register(self.update)
        self.current_id = 0

    def _configure(self, qtile, bar):
        base._TextBox._configure(self, qtile, bar)
        self.layout = self.drawer.textlayout(
            self.text,
            self.foreground,
            self.font,
            self.fontsize,
            self.fontshadow,
            markup=True
        )

    def set_notif_text(self, notif):
        self.text = utils.escape(notif.summary)
        urgency = notif.hints.get('urgency', 1)
        if urgency != 1:
            self.text = '<span color="%s">%s</span>' % (
                utils.hex(
                    self.foreground_urgent if urgency == 2
                    else self.foreground_low
                ),
                self.text
            )
        if notif.body:
            self.text = '<span weight="bold">%s</span> - %s' % (
                self.text, utils.escape(notif.body)
            )

    def update(self, notif):
        self.set_notif_text(notif)
        self.current_id = notif.id - 1
        if notif.timeout and notif.timeout > 0:
            self.timeout_add(notif.timeout / 1000, self.clear)
        elif self.default_timeout:
            self.timeout_add(self.default_timeout, self.clear)
        self.bar.draw()
        return True

    def display(self):
        self.set_notif_text(notifier.notifications[self.current_id])
        self.bar.draw()

    def clear(self):
        self.text = ''
        self.current_id = len(notifier.notifications) - 1
        self.bar.draw()

    def prev(self):
        if self.current_id > 0:
            self.current_id -= 1
        self.display()

    def next(self):
        if self.current_id < len(notifier.notifications) - 1:
            self.current_id += 1
            self.display()

    def button_press(self, x, y, button):
        if button == 1:
            self.clear()
        elif button == 4:
            self.prev()
        elif button == 5:
            self.next()

    def cmd_display(self):
        self.display()

    def cmd_clear(self):
        self.clear()

    def cmd_toggle(self):
        if self.text == '':
            self.display()
        else:
            self.clear()

    def cmd_prev(self):
        self.prev()

    def cmd_next(self):
        self.next()

########NEW FILE########
__FILENAME__ = pacman
# -*- coding:utf-8 -*-
#
# Copyright (C) 2012, Maximilian Khl <linuxmaxi@googlemail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

import base

import subprocess


class Pacman(base.ThreadedPollText):
    """
    Shows number of available updates.
    """
    defaults = [
        ('unavailable', 'ffffff', 'Unavailable Color - no updates.'),
        ('execute', None, 'Command to execute on click'),
        ('update_interval', 60, "The update interval."),
    ]

    def __init__(self, **config):
        base.ThreadedPollText.__init__(self, **config)
        self.add_defaults(Pacman.defaults)

    def draw(self):
        if self.text == '0':
            self.layout.colour = self.unavailable
        else:
            self.layout.colour = self.foreground
        base.ThreadedPollText.draw(self)

    def poll(self):
        pacman = subprocess.Popen(['checkupdates'], stdout=subprocess.PIPE)
        return str(len(pacman.stdout.readlines()))

    def button_press(self, x, y, button):
        base.ThreadedPollText.button_press(self, x, y, button)
        if button == 1 and self.execute is not None:
            subprocess.Popen([self.execute], shell=True)

########NEW FILE########
__FILENAME__ = prompt
import glob
import os
import string
from .. import bar, xkeysyms, xcbq, command
import base


class NullCompleter:
    def __init__(self, qtile):
        self.qtile = qtile
        self.thisfinal = ""

    def actual(self):
        return self.thisfinal

    def reset(self):
        pass

    def complete(self, txt):
        return txt


class FileCompleter:
    def __init__(self, qtile, _testing=False):
        self._testing = _testing
        self.qtile = qtile
        self.thisfinal = None
        self.reset()

    def actual(self):
        return self.thisfinal

    def reset(self):
        self.lookup = None

    def complete(self, txt):
        """
        Returns the next completion for txt, or None if there is no completion.
        """
        if not self.lookup:
            self.lookup = []
            if txt == "" or txt[0] not in "~/":
                txt = "~/" + txt
            path = os.path.expanduser(txt)
            if os.path.isdir(path):
                files = glob.glob(os.path.join(path, "*"))
                prefix = txt
            else:
                files = glob.glob(path + "*")
                prefix = os.path.dirname(txt)
                prefix = prefix.rstrip("/") or "/"
            for f in files:
                display = os.path.join(prefix, os.path.basename(f))
                if os.path.isdir(f):
                    display += "/"
                self.lookup.append((display, f))
                self.lookup.sort()
            self.offset = -1
            self.lookup.append((txt, txt))
        self.offset += 1
        if self.offset >= len(self.lookup):
            self.offset = 0
        ret = self.lookup[self.offset]
        self.thisfinal = ret[1]
        return ret[0]


class QshCompleter:
    def __init__(self, qtile):
        self.qtile = qtile
        self.client = command.CommandRoot(self.qtile)
        self.thisfinal = None
        self.reset()

    def actual(self):
        return self.thisfinal

    def reset(self):
        self.lookup = None
        self.path = ''
        self.offset = -1

    def complete(self, txt):
        txt = txt.lower()
        if not self.lookup:
            self.lookup = []
            path = txt.split('.')[:-1]
            self.path = '.'.join(path)
            term = txt.split('.')[-1]
            if len(self.path) > 0:
                self.path += '.'

            contains_cmd = 'self.client.%s_contains' % self.path
            try:
                contains = eval(contains_cmd)
            except AttributeError:
                contains = []
            for obj in contains:
                if obj.lower().startswith(term):
                    self.lookup.append((obj, obj))

            commands_cmd = 'self.client.%scommands()' % self.path
            try:
                commands = eval(commands_cmd)
            except (command.CommandError, AttributeError):
                commands = []
            for cmd in commands:
                if cmd.lower().startswith(term):
                    self.lookup.append((cmd + '()', cmd + '()'))

            self.offset = -1
            self.lookup.append((term, term))

        self.offset += 1
        if self.offset >= len(self.lookup):
            self.offset = 0
        ret = self.lookup[self.offset]
        self.thisfinal = self.path + ret[0]
        return self.path + ret[0]


class GroupCompleter:
    def __init__(self, qtile):
        self.qtile = qtile
        self.thisfinal = None
        self.lookup = None
        self.offset = None

    def actual(self):
        """
            Returns the current actual value.
        """
        return self.thisfinal

    def reset(self):
        self.lookup = None
        self.offset = -1

    def complete(self, txt):
        """
        Returns the next completion for txt, or None if there is no completion.
        """
        txt = txt.lower()
        if not self.lookup:
            self.lookup = []
            for group in self.qtile.groupMap.keys():
                if group.lower().startswith(txt):
                    self.lookup.append((group, group))

            self.lookup.sort()
            self.offset = -1
            self.lookup.append((txt, txt))

        self.offset += 1
        if self.offset >= len(self.lookup):
            self.offset = 0
        ret = self.lookup[self.offset]
        self.thisfinal = ret[1]
        return ret[0]


class WindowCompleter:
    def __init__(self, qtile):
        self.qtile = qtile
        self.thisfinal = None
        self.lookup = None
        self.offset = None

    def actual(self):
        """
            Returns the current actual value.
        """
        return self.thisfinal

    def reset(self):
        self.lookup = None
        self.offset = -1

    def complete(self, txt):
        """
        Returns the next completion for txt, or None if there is no completion.
        """
        if not self.lookup:
            self.lookup = []
            for wid, window in self.qtile.windowMap.iteritems():
                if window.group and window.name.lower().startswith(txt):
                    self.lookup.append((window.name, wid))

            self.lookup.sort()
            self.offset = -1
            self.lookup.append((txt, txt))

        self.offset += 1
        if self.offset >= len(self.lookup):
            self.offset = 0
        ret = self.lookup[self.offset]
        self.thisfinal = ret[1]
        return ret[0]


class CommandCompleter:
    DEFAULTPATH = "/bin:/usr/bin:/usr/local/bin"

    def __init__(self, qtile, _testing=False):
        """
        _testing: disables reloading of the lookup table
                  to make testing possible.
        """
        self.lookup = None
        self.offset = None
        self.thisfinal = None
        self._testing = _testing

    def actual(self):
        """
            Returns the current actual value.
        """
        return self.thisfinal

    def executable(self, fpath):
        return os.access(fpath, os.X_OK)

    def reset(self):
        self.lookup = None
        self.offset = -1

    def complete(self, txt):
        """
        Returns the next completion for txt, or None if there is no completion.
        """
        if not self.lookup:
            if not self._testing:
                # Lookup is a set of (display value, actual value) tuples.
                self.lookup = []
                if txt and txt[0] in "~/":
                    path = os.path.expanduser(txt)
                    if os.path.isdir(path):
                        files = glob.glob(os.path.join(path, "*"))
                        prefix = txt
                    else:
                        files = glob.glob(path + "*")
                        prefix = os.path.dirname(txt)
                    prefix = prefix.rstrip("/") or "/"
                    for f in files:
                        if self.executable(f):
                            display = os.path.join(prefix, os.path.basename(f))
                            if os.path.isdir(f):
                                display += "/"
                            self.lookup.append((display, f))
                else:
                    dirs = os.environ.get("PATH", self.DEFAULTPATH).split(":")
                    for didx, d in enumerate(dirs):
                        try:
                            for cmd in glob.glob(os.path.join(d, "%s*" % txt)):
                                if self.executable(cmd):
                                    self.lookup.append(
                                        (
                                            os.path.basename(cmd),
                                            cmd
                                        ),
                                    )
                        except OSError:
                            pass
            self.lookup.sort()
            self.offset = -1
            self.lookup.append((txt, txt))
        self.offset += 1
        if self.offset >= len(self.lookup):
            self.offset = 0
        ret = self.lookup[self.offset]
        self.thisfinal = ret[1]
        return ret[0]


class Prompt(base._TextBox):
    """
        A widget that prompts for user input. Input should be started using the
        .startInput method on this class.
    """
    completers = {
        "file": FileCompleter,
        "qsh": QshCompleter,
        "cmd": CommandCompleter,
        "group": GroupCompleter,
        "window": WindowCompleter,
        None: NullCompleter
    }
    defaults = [("cursorblink", 0.5, "Cursor blink rate. 0 to disable."),
                ("prompt", "{prompt}: ", "Text displayed at the prompt")]

    def __init__(self, name="prompt", **config):
        base._TextBox.__init__(self, "", bar.CALCULATED, **config)
        self.add_defaults(Prompt.defaults)
        self.name = name
        self.active = False
        self.blink = False
        self.completer = None

    def _configure(self, qtile, bar):
        base._TextBox._configure(self, qtile, bar)

    def startInput(self, prompt, callback,
                   complete=None, strict_completer=False):
        """
            complete: Tab-completion. Can be None, or "cmd".

            Displays a prompt and starts to take one line of keyboard input
            from the user. When done, calls the callback with the input string
            as argument.

            prompt = text displayed at the prompt, e.g. "spawn: "
            callback = function to call with returned value.
            complete = completer to use.
            strict_completer = When True the retuen value wil be the exact
                               completer result where available.
        """

        if self.cursorblink and not self.active:
            self.timeout_add(self.cursorblink, self._blink)
        if prompt:
            self.prompt = self.prompt.format(prompt=prompt)
        self.active = True
        self.userInput = ""
        self.callback = callback
        self.completer = self.completers[complete](self.qtile)
        self.strict_completer = strict_completer
        self._update()
        self.bar.widget_grab_keyboard(self)

    def _calculate_real_width(self):
        if self.blink:
            return min(
                self.layout.width,
                self.bar.width
            ) + self.actual_padding * 2
        else:
            _text = self.text
            self.text = _text + "_"
            width = min(
                self.layout.width,
                self.bar.width
            ) + self.actual_padding * 2
            self.text = _text
            return width

    def calculate_width(self):
        if self.text:
            return self._calculate_real_width()
        else:
            return 0

    def _blink(self):
        self.blink = not self.blink
        self._update()
        if not self.active:
            return False
        return True

    def _update(self):
        if self.active:
            self.text = "%s%s" % (self.prompt, self.userInput)
            if self.blink:
                self.text = self.text + "_"
            else:
                self.text = self.text
        else:
            self.text = ""
        self.bar.draw()

    def handle_KeyPress(self, e):
        """
            KeyPress handler for the minibuffer.
            Currently only supports ASCII characters.
        """
        state = e.state & ~(self.qtile.numlockMask)
        keysym = self.qtile.conn.keycode_to_keysym(e.detail, state)
        if keysym == xkeysyms.keysyms['Tab']:
            self.userInput = self.completer.complete(self.userInput)
        else:
            actual_value = self.completer.actual()
            self.completer.reset()
            if keysym < 127 and chr(keysym) in string.printable:
                # No LookupString in XCB... oh,
                # the shame! Unicode users beware!
                self.userInput += chr(keysym)
            elif (keysym == xkeysyms.keysyms['BackSpace'] and
                  len(self.userInput) > 0):
                self.userInput = self.userInput[:-1]
            elif keysym == xkeysyms.keysyms['Escape']:
                self.active = False
                self.bar.widget_ungrab_keyboard()
            elif keysym == xkeysyms.keysyms['Return']:
                self.active = False
                self.bar.widget_ungrab_keyboard()
                if self.strict_completer:
                    self.callback(actual_value or self.userInput)
                else:
                    self.callback(self.userInput)
        self._update()

    def cmd_fake_keypress(self, key):
        class Dummy:
            pass
        d = Dummy()
        keysym = xcbq.keysyms[key]
        d.detail = self.qtile.conn.keysym_to_keycode(keysym)
        d.state = 0
        self.handle_KeyPress(d)

    def cmd_info(self):
        """
            Returns a dictionary of info for this object.
        """
        return dict(
            name=self.name,
            width=self.width,
            text=self.text,
            active=self.active,
        )

########NEW FILE########
__FILENAME__ = sensors
#!/usr/bin/env python
# coding: utf-8

import base
from subprocess import Popen, PIPE
import re


class ThermalSensor(base.InLoopPollText):
    '''
    For using the thermal sensor widget you need to have lm-sensors installed.
    You can get a list of the tag_sensors executing "sensors" in your terminal.
    Then you can choose which you want, otherwise it will display the first
    available.
    '''
    defaults = [
        ('metric', True, 'True to use metric/C, False to use imperial/F'),
        ('show_tag', False, 'Show tag sensor'),
        ('update_interval', 2, 'Update interval in seconds'),
        ('tag_sensor', None, 'Tag of the temperature sensor'),
        (
            'threshold',
            70,
            'If the current temperature value is above, '
            'then change to foreground_alert colour'
        ),
        ('foreground_alert', 'ff0000', 'Foreground colour alert'),
    ]

    def __init__(self, **config):
        base.InLoopPollText.__init__(self, **config)
        self.add_defaults(ThermalSensor.defaults)
        self.sensors_temp = re.compile(
            ur"""
            ([a-zA-Z]+        #Tag
            \s?[0-9]+):       #Tag number
            \s+[+-]           #Temp signed
            ([0-9]+\.[0-9]+)  #Temp value
            (\xc2\xb0         # match
            [CF])             #Celsius or Fahrenheit
            """,
            re.UNICODE | re.VERBOSE
        )
        self.value_temp = re.compile("[0-9]+\.[0-9]+")
        temp_values = self.get_temp_sensors()
        self.foreground_normal = self.foreground
        if temp_values is None:
            self.data = "sensors command not found"
        elif len(temp_values) == 0:
            self.data = "Temperature sensors not found"
        elif self.tag_sensor is None:
            for k in temp_values:
                self.tag_sensor = k
                break

    def get_temp_sensors(self):
        fahrenheit = []
        if not self.metric:
            fahrenheit = ["-f"]
        try:
            cmd_sensors = Popen(["sensors", ] + fahrenheit, stdout=PIPE)
        except OSError:
            return None
        cmd_sensors.wait()
        (stdout, stderr) = cmd_sensors.communicate()
        temp_values = {}
        for value in re.findall(self.sensors_temp, stdout):
            temp_values[value[0]] = value[1:]
        return temp_values

    def poll(self):
        temp_values = self.get_temp_sensors()
        if temp_values is None:
            return False
        text = ""
        if self.show_tag and self.tag_sensor is not None:
            text = self.tag_sensor + ": "
        text += "".join(temp_values.get(self.tag_sensor, ['N/A']))
        temp_value = float(temp_values.get(self.tag_sensor, [0])[0])
        if temp_value > self.threshold:
            self.layout.colour = self.foreground_alert
        else:
            self.layout.colour = self.foreground_normal
        return text

########NEW FILE########
__FILENAME__ = sep
from .. import bar
import base


class Sep(base._Widget):
    """
        A visible widget separator.
    """
    defaults = [
        ("padding", 2, "Padding on either side of separator."),
        ("linewidth", 1, "Width of separator line."),
        ("foreground", "888888", "Separator line colour."),
        (
            "height_percent",
            80,
            "Height as a percentage of bar height (0-100)."
        ),
    ]

    def __init__(self, **config):
        base._Widget.__init__(self, bar.STATIC, **config)
        self.add_defaults(Sep.defaults)
        self.width = self.padding + self.linewidth

    def draw(self):
        self.drawer.clear(self.background or self.bar.background)
        margin_top = (
            self.bar.height / float(100) * (100 - self.height_percent)) / 2.0
        self.drawer.draw_vbar(
            self.foreground,
            float(self.width) / 2,
            margin_top,
            self.bar.height - margin_top,
            linewidth=self.linewidth
        )
        self.drawer.draw(self.offset, self.width)

########NEW FILE########
__FILENAME__ = she
from libqtile.widget import base

__all__ = ['She']


class She(base.InLoopPollText):
    ''' Widget to display the Super Hybrid Engine status.
    can display either the mode or CPU speed on eeepc computers.'''

    defaults = [
        ('device', '/sys/devices/platform/eeepc/cpufv', 'sys path to cpufv'),
        ('format', 'speed', 'Type of info to display "speed" or "name"'),
        ('update_interval', 0.5, 'Update Time in seconds.'),
    ]

    def __init__(self, **config):
        base.InLoopPollText.__init__(self, 'CPU', **config)
        self.add_defaults(She.defaults)
        self.modes = {
            '0x300': {'name': 'Performance', 'speed': '1.6GHz'},
            '0x301': {'name': 'Normal', 'speed': '1.2GHz'},
            '0x302': {'name': 'PoswerSave', 'speed': '800MHz'}
        }

    def poll(self):
        with open(self.device) as f:
            mode = f.read().strip()
        if self.mode in self.modes:
            return self.modes[mode][self.format]
        else:
            return mode

########NEW FILE########
__FILENAME__ = spacer
from .. import bar
import base


class Spacer(base._Widget):
    """
        Just an empty space on the bar. Often used with width equal to
        bar.STRETCH to push bar widgets to the right edge of the screen.
    """
    def __init__(self, width=bar.STRETCH):
        """
            - width: bar.STRETCH, or a pixel width.
        """
        base._Widget.__init__(self, width)

    def draw(self):
        self.drawer.clear(self.bar.background)
        self.drawer.draw(self.offset, self.width)

########NEW FILE########
__FILENAME__ = systray
from .. import bar, xcbq, window
import base

import xcb
from xcb.xproto import EventMask, SetMode
import atexit
import struct


class Icon(window._Window):
    _windowMask = EventMask.StructureNotify | \
        EventMask.Exposure

    def __init__(self, win, qtile, systray):
        window._Window.__init__(self, win, qtile)
        self.systray = systray
        self.width = systray.icon_size
        self.height = systray.icon_size

    def handle_ConfigureNotify(self, event):
        icon_size = self.systray.icon_size
        self.updateHints()

        try:
            width = self.hints["min_width"]
            height = self.hints["min_height"]
        except KeyError:
            width = icon_size
            height = icon_size

        if height > icon_size:
            new_width = width / height * icon_size
            height = icon_size
            width = new_width
        if height <= 0:
            width = icon_size
            height = icon_size

        self.width = width
        self.height = height
        self.window.set_attribute(backpixmap=self.systray.drawer.pixmap)
        self.systray.draw()
        return False

    def handle_DestroyNotify(self, event):
        wid = event.window
        del(self.qtile.windowMap[wid])
        del(self.systray.icons[wid])
        self.systray.draw()
        return False

    handle_UnmapNotify = handle_DestroyNotify


class TrayWindow(window._Window):
    _windowMask = EventMask.StructureNotify | \
        EventMask.Exposure

    def __init__(self, win, qtile, systray):
        window._Window.__init__(self, win, qtile)
        self.systray = systray

    def handle_ClientMessage(self, event):
        atoms = self.qtile.conn.atoms

        opcode = xcb.xproto.ClientMessageData(event, 0, 20).data32[2]
        data = xcb.xproto.ClientMessageData(event, 12, 20)
        task = data.data32[2]

        conn = self.qtile.conn.conn
        parent = self.systray.bar.window.window

        if opcode == atoms['_NET_SYSTEM_TRAY_OPCODE']:
            try:
                w = xcbq.Window(self.qtile.conn, task)
                icon = Icon(w, self.qtile, self.systray)
                self.systray.icons[task] = icon
                self.qtile.windowMap[task] = icon

                # add icon window to the save-set, so it gets reparented
                # to the root window when qtile dies
                conn.core.ChangeSaveSet(SetMode.Insert, task)

                conn.core.ReparentWindow(task, parent.wid, 0, 0)
                conn.flush()
                w.map()
            except xcb.xproto.DrawableError:
                # The icon wasn't ready to be drawn yet... (NetworkManager does
                # this sometimes), so we just forget about it and wait for the
                # next event.
                pass
        return False


class Systray(base._Widget):
    """
        A widget that manage system tray
    """
    defaults = [
        ('icon_size', 20, 'Icon width'),
        ('padding', 5, 'Padding between icons'),
    ]

    def __init__(self, **config):
        base._Widget.__init__(self, bar.CALCULATED, **config)
        self.add_defaults(Systray.defaults)
        self.traywin = None
        self.icons = {}

    def button_press(self, x, y, button):
        pass

    def calculate_width(self):
        width = sum([i.width for i in self.icons.values()])
        width += self.padding * len(self.icons)
        return width

    def _configure(self, qtile, bar):
        base._Widget._configure(self, qtile, bar)
        self.qtile = qtile
        self.bar = bar
        atoms = qtile.conn.atoms
        win = qtile.conn.create_window(-1, -1, 1, 1)
        self.traywin = TrayWindow(win, self.qtile, self)
        qtile.windowMap[win.wid] = self.traywin
        qtile.conn.conn.core.SetSelectionOwner(
            win.wid,
            atoms['_NET_SYSTEM_TRAY_S0'],
            xcb.CurrentTime
        )
        event = struct.pack(
            'BBHII5I', 33, 32, 0, qtile.root.wid,
            atoms['MANAGER'],
            xcb.CurrentTime, atoms['_NET_SYSTEM_TRAY_S0'],
            win.wid, 0, 0
        )
        qtile.root.send_event(event, mask=EventMask.StructureNotify)

        # cleanup before exit
        atexit.register(self.cleanup)

    def draw(self):
        self.drawer.clear(self.background or self.bar.background)
        self.drawer.draw(self.offset, self.calculate_width())
        xoffset = self.padding
        for pos, icon in enumerate(self.icons.values()):
            icon.place(
                self.offset + xoffset,
                self.bar.height / 2 - self.icon_size / 2,
                icon.width, self.icon_size,
                0,
                None
            )
            xoffset += icon.width + self.padding

    def cleanup(self):
        atoms = self.qtile.conn.atoms
        self.qtile.conn.conn.core.SetSelectionOwner(
            0,
            atoms['_NET_SYSTEM_TRAY_S0'],
            xcb.CurrentTime,
        )
        self.traywin.hide()

########NEW FILE########
__FILENAME__ = tasklist
import cairo
from .. import bar, hook
import base


class TaskList(base._Widget, base.PaddingMixin, base.MarginMixin):
    defaults = [
        ("font", "Arial", "Default font"),
        ("fontsize", None, "Font size. Calculated if None."),
        ("foreground", "ffffff", "Foreground colour"),
        (
            "fontshadow",
            None,
            "font shadow color, default is None(no shadow)"
        ),
        ("borderwidth", 2, "Current group border width"),
        ("border", "215578", "Border colour"),
        ("rounded", True, "To round or not to round borders"),
        (
            "highlight_method",
            "border",
            "Method of highlighting (one of 'border' or 'block') "
            "Uses *_border color settings"
        ),
        ("urgent_border", "FF0000", "Urgent border color"),
        (
            "urgent_alert_method",
            "border",
            "Method for alerting you of WM urgent "
            "hints (one of 'border' or 'text')"
        ),
        ("max_title_width", 200, "size in pixels of task title")
    ]

    def __init__(self, **config):
        base._Widget.__init__(self, bar.STRETCH, **config)
        self.add_defaults(TaskList.defaults)
        self.add_defaults(base.PaddingMixin.defaults)
        self.add_defaults(base.MarginMixin.defaults)
        self._icons_cache = {}

    def box_width(self, text):
        width, _ = self.drawer.max_layout_size(
            [text],
            self.font,
            self.fontsize
        )
        width = width + self.padding_x * 2 + \
            self.margin_x * 2 + self.borderwidth * 2
        if width > self.max_title_width:
            width = self.max_title_width
        return width

    def _configure(self, qtile, bar):
        base._Widget._configure(self, qtile, bar)
        self.icon_size = self.bar.height - (self.borderwidth + 2) * 2

        if self.fontsize is None:
            calc = self.bar.height - self.margin_y * 2 - \
                self.borderwidth * 2 - self.padding_y * 2
            self.fontsize = max(calc, 1)
        self.layout = self.drawer.textlayout(
            "",
            "ffffff",
            self.font,
            self.fontsize,
            self.fontshadow,
            wrap=False
        )
        self.setup_hooks()

    def update(self, window=None):
        group = self.bar.screen.group
        if not window or window and window.group is group:
            self.bar.draw()

    def remove_icon_cache(self, window):
        wid = window.window.wid
        if wid in self._icons_cache:
            self._icons_cache.pop(wid)

    def invalidate_cache(self, window):
        self.remove_icon_cache(window)
        self.update(window)

    def setup_hooks(self):
        hook.subscribe.window_name_change(self.update)
        hook.subscribe.focus_change(self.update)
        hook.subscribe.float_change(self.update)
        hook.subscribe.client_urgent_hint_changed(self.update)

        hook.subscribe.net_wm_icon_change(self.invalidate_cache)
        hook.subscribe.client_killed(self.remove_icon_cache)

    def drawtext(self, text, textcolor, width):
        self.layout.text = text
        self.layout.font_family = self.font
        self.layout.font_size = self.fontsize
        self.layout.colour = textcolor
        if width is not None:
            self.layout.width = width

    def drawbox(self, offset, text, bordercolor, textcolor, rounded=False,
                block=False, width=None):
        self.drawtext(text, textcolor, width)
        padding_x = [self.padding_x + self.icon_size + 4, self.padding_x]
        framed = self.layout.framed(
            self.borderwidth,
            bordercolor,
            padding_x,
            self.padding_y
        )
        if block:
            framed.draw_fill(offset, self.margin_y, rounded)
        else:
            framed.draw(offset, self.margin_y, rounded)

    def get_clicked(self, x, y):
        window = None
        new_width = width = 0
        for w in self.bar.screen.group.windows:
            new_width += self.icon_size+self.box_width(w.name)
            if x >= width and x <= new_width:
                window = w
                break
            width = new_width
        return window

    def button_press(self, x, y, button):
        window = None
        current_win = self.bar.screen.group.currentWindow

        # TODO: support scroll
        if button == 1:
            window = self.get_clicked(x, y)

        if window and window is not current_win:
            window.group.focus(window, False)
            if window.floating:
                window.cmd_bring_to_front()

    def get_window_icon(self, window):
        cache = self._icons_cache.get(window.window.wid)
        if cache:
            return cache

        icons = sorted(
            window.icons.iteritems(),
            key=lambda x: abs(self.icon_size-int(x[0].split("x")[0]))
        )
        icon = icons[0]
        width, height = map(int, icon[0].split("x"))

        img = cairo.ImageSurface.create_for_data(
            icon[1],
            cairo.FORMAT_ARGB32,
            width,
            height
        )

        surface = cairo.SurfacePattern(img)

        scaler = cairo.Matrix()

        if height != self.icon_size:
            sp = height / float(self.icon_size)
            height = self.icon_size
            width = width / sp
            scaler.scale(sp, sp)
        surface.set_matrix(scaler)
        self._icons_cache[window.window.wid] = surface
        return surface

    def draw_icon(self, window, offset):
        if not window.icons:
            return

        x = offset + self.padding_x + self.borderwidth + 2 + self.margin_x
        y = self.padding_y + self.borderwidth

        surface = self.get_window_icon(window)

        self.drawer.ctx.save()
        self.drawer.ctx.translate(x, y)
        self.drawer.ctx.set_source(surface)
        self.drawer.ctx.paint()
        self.drawer.ctx.restore()

    def draw(self):
        self.drawer.clear(self.background or self.bar.background)
        offset = 0

        for w in self.bar.screen.group.windows:
            state = ''
            if w is None:
                pass
            elif w.maximized:
                state = '[] '
            elif w.minimized:
                state = '_ '
            elif w.floating:
                state = 'V '
            task = "%s%s" % (state,  w.name if w and w.name else " ")

            if w.urgent:
                border = self.urgent_border
            elif w is w.group.currentWindow:
                border = self.border
            else:
                border = self.background or self.bar.background

            bw = self.box_width(task)
            self.drawbox(
                self.margin_x + offset,
                task,
                border,
                self.foreground,
                self.rounded,
                self.highlight_method == 'block',
                bw - self.margin_x * 2 - self.padding_x * 2
            )
            self.draw_icon(w, offset)

            offset += bw + self.icon_size
        self.drawer.draw(self.offset, self.width)

########NEW FILE########
__FILENAME__ = textbox
from .. import bar
import base


class TextBox(base._TextBox):
    """
        A flexible textbox that can be updated from bound keys, scripts and
        qsh.
    """
    defaults = [
        ("font", "Arial", "Text font"),
        ("fontsize", None, "Font pixel size. Calculated if None."),
        ("fontshadow", None, "font shadow color, default is None(no shadow)"),
        ("padding", None, "Padding left and right. Calculated if None."),
        ("foreground", "#ffffff", "Foreground colour.")
    ]

    def __init__(self, text=" ", width=bar.CALCULATED, **config):
        """
            - text: Initial widget text.
            - width: An integer width, bar.STRETCH, or bar.CALCULATED .
        """
        base._TextBox.__init__(self, text, width, **config)

    def update(self, text):
        self.text = text
        self.bar.draw()

    def cmd_update(self, text):
        """
            Update the text in a TextBox widget.
        """
        self.update(text)

    def cmd_get(self):
        """
            Retrieve the text in a TextBox widget.
        """
        return self.text

########NEW FILE########
__FILENAME__ = volume
import os
import re
import subprocess

import cairo

import base
from .. import bar

__all__ = [
    'Volume',
]

re_vol = re.compile('\[(\d?\d?\d?)%\]')


class Volume(base._TextBox):
    ''' Widget that display and change volume
        if theme_path is set it draw widget as
        icons '''
    defaults = [
        ("cardid", 0, "Card Id"),
        ("channel", "Master", "Channel"),
        ("padding", 3, "Padding left and right. Calculated if None."),
        ("theme_path", None, "Path of the icons"),
        ("update_interval", 0.2, "Update time in seconds."),
    ]

    def __init__(self, **config):
        base._TextBox.__init__(self, '0', width=bar.CALCULATED, **config)
        self.add_defaults(Volume.defaults)
        if self.theme_path:
            self.width_type = bar.STATIC
            self.width = 0
        self.surfaces = {}
        self.volume = None
        self.timeout_add(self.update_interval, self.update)

    def _configure(self, qtile, bar):
        base._TextBox._configure(self, qtile, bar)
        if self.theme_path:
            self.setup_images()

    def button_press(self, x, y, button):
        if button == 5:
            subprocess.call([
                'amixer',
                '-q',
                '-c',
                str(self.cardid),
                'sset',
                self.channel,
                '2dB-'
            ])
        elif button == 4:
            subprocess.call([
                'amixer',
                '-q',
                '-c',
                str(self.cardid),
                'sset',
                self.channel,
                '2dB+'
            ])
        elif button == 1:
            subprocess.call([
                'amixer',
                '-q',
                '-c',
                str(self.cardid),
                'sset',
                self.channel,
                'toggle'
            ])
        self.draw()

    def update(self):
        if self.configured:
            vol = self.get_volume()
            if vol != self.volume:
                self.volume = vol
                # Update the underlying canvas size before actually attempting
                # to figure out how big it is and draw it.
                self._update_drawer()
                self.bar.draw()
        return True

    def _update_drawer(self):
        if self.theme_path:
            self.drawer.clear(self.background or self.bar.background)
            if self.volume <= 0:
                img_name = 'audio-volume-muted'
            elif self.volume <= 30:
                img_name = 'audio-volume-low'
            elif self.volume < 80:
                img_name = 'audio-volume-medium'
            elif self.volume >= 80:
                img_name = 'audio-volume-high'

            self.drawer.ctx.set_source(self.surfaces[img_name])
            self.drawer.ctx.paint()
        else:
            if self.volume == -1:
                self.text = 'M'
            else:
                self.text = '%s%%' % self.volume

    def setup_images(self):
        for img_name in (
            'audio-volume-high',
            'audio-volume-low',
            'audio-volume-medium',
            'audio-volume-muted'
        ):

            try:
                img = cairo.ImageSurface.create_from_png(
                    os.path.join(self.theme_path, '%s.png' % img_name)
                )
            except cairo.Error:
                self.theme_path = None
                self.width_type = bar.CALCULATED
                self.qtile.log.exception('Volume switching to text mode')
                return
            input_width = img.get_width()
            input_height = img.get_height()

            sp = input_height / float(self.bar.height - 1)

            width = input_width / sp
            if width > self.width:
                self.width = int(width) + self.actual_padding * 2

            imgpat = cairo.SurfacePattern(img)

            scaler = cairo.Matrix()

            scaler.scale(sp, sp)
            scaler.translate(self.actual_padding * -1, 0)
            imgpat.set_matrix(scaler)

            imgpat.set_filter(cairo.FILTER_BEST)
            self.surfaces[img_name] = imgpat

    def get_volume(self):
        mixerprocess = subprocess.Popen(
            [
                'amixer',
                '-c',
                str(self.cardid),
                'sget',
                self.channel
            ],
            stdout=subprocess.PIPE
        )
        mixer_out = mixerprocess.communicate()[0]
        if mixerprocess.returncode:
            return -1

        if '[off]' in mixer_out:
            return -1

        volgroups = re_vol.search(mixer_out)
        if volgroups:
            return int(volgroups.groups()[0])
        else:
            # this shouldn't happend
            return -1

    def draw(self):
        if self.theme_path:
            self.drawer.draw(self.offset, self.width)
        else:
            base._TextBox.draw(self)

########NEW FILE########
__FILENAME__ = windowname
from .. import hook, bar
import base


class WindowName(base._TextBox):
    """
        Displays the name of the window that currently has focus.
    """
    def __init__(self, width=bar.STRETCH, **config):
        base._TextBox.__init__(self, width=width, **config)

    def _configure(self, qtile, bar):
        base._TextBox._configure(self, qtile, bar)
        hook.subscribe.window_name_change(self.update)
        hook.subscribe.focus_change(self.update)
        hook.subscribe.float_change(self.update)

    def update(self):
        w = self.bar.screen.group.currentWindow
        state = ''
        if w is None:
            pass
        elif w.maximized:
            state = '[] '
        elif w.minimized:
            state = '_ '
        elif w.floating:
            state = 'V '
        self.text = "%s%s" % (state,  w.name if w and w.name else " ")
        self.bar.draw()

########NEW FILE########
__FILENAME__ = windowtabs
from .. import hook, bar
import base


class WindowTabs(base._TextBox):
    """
        Displays the name of each window in the current group.
        The window that currently has focus is highlighted.
    """
    defaults = [
        ("separator", " | ", "Task separator text."),
        ("selected", ("<", ">"), "Selected task indicator"),
    ]

    def __init__(self, **config):
        base._TextBox.__init__(self, width=bar.STRETCH, **config)
        self.add_defaults(WindowTabs.defaults)
        if not isinstance(self.selected, (tuple, list)):
            self.selected = (self.selected, self.selected)

    def _configure(self, qtile, bar):
        base._TextBox._configure(self, qtile, bar)
        hook.subscribe.window_name_change(self.update)
        hook.subscribe.focus_change(self.update)
        hook.subscribe.float_change(self.update)

    def button_press(self, x, y, button):
        self.bar.screen.group.cmd_next_window()

    def update(self):
        names = []
        for w in self.bar.screen.group.windows:
            state = ''
            if w is None:
                pass
            elif w.maximized:
                state = '[] '
            elif w.minimized:
                state = '_ '
            elif w.floating:
                state = 'V '
            task = "%s%s" % (state,  w.name if w and w.name else " ")
            if w is self.bar.screen.group.currentWindow:
                task = task.join(self.selected)
            names.append(task)
        self.text = self.separator.join(names)
        self.bar.draw()

########NEW FILE########
__FILENAME__ = wlan
import base
from pythonwifi.iwlibs import Wireless, Iwstats


class Wlan(base.InLoopPollText):
    """
        Displays Wifi ssid and quality.
    """
    defaults = [
        ('interface', 'wlan0', 'The interface to monitor'),
        ('update_interval', 1, 'The update interval.'),
    ]
    def __init__(self, **config):
        base.InLoopPollText.__init__(self, **config)

    def _configure(self, qtile, bar):
        base.InLoopPollText._configure(self, qtile, bar)

    def poll(self):
        interface = Wireless(self.interface)
        stats = Iwstats(self.interface)
        quality = stats.qual.quality
        essid = interface.getEssid()
        return "{} {}/70".format(essid, quality)

########NEW FILE########
__FILENAME__ = yahoo_weather
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import base
import urllib
import urllib2
from xml.dom import minidom

try:
    import json
except ImportError:
    import simplejson as json

QUERY_URL = 'http://query.yahooapis.com/v1/public/yql?'
WEATHER_URL = 'http://weather.yahooapis.com/forecastrss?'
WEATHER_NS = 'http://xml.weather.yahoo.com/ns/rss/1.0'


class YahooWeather(base.ThreadedPollText):
    ''' A weather widget, data provided by the Yahoo! Weather API
        Format options:
            astronomy_sunrise, astronomy_sunset
            atmosphere_humidity, atmosphere_visibility,
            atmosphere_pressure, atmosphere_rising
            condition_text, condition_code, condition_temp, condition_date
            location_city. location_region, location_country
            units_temperature, units_distance, units_pressure, units_speed
            wind_chill, wind_direction, wind_speed
    '''

    defaults = [
        ## One of (location, woeid) must be set.
        (
            'location',
            None,
            'Location to fetch weather for. Ignored if woeid is set.'
        ),
        (
            'woeid',
            None,
            'Where On Earth ID. Auto-calculated if location is set.'
        ),
        (
            'format',
            '{location_city}: {condition_temp} {units_temperature}',
            'Display format'
        ),
        ('metric', True, 'True to use metric/C, False to use imperial/F'),
        ('up', '^', 'symbol for rising atmospheric pressure'),
        ('down', 'v', 'symbol for falling atmospheric pressure'),
        ('steady', 's', 'symbol for steady atmospheric pressure'),
    ]

    def __init__(self, **config):
        base.ThreadedPollText.__init__(self, **config)
        self.add_defaults(YahooWeather.defaults)

    def fetch_woeid(self, location):
        url = QUERY_URL + urllib.urlencode({
            'q': 'select woeid from geo.places where text="%s"' % location,
            'format': 'json'
        })
        try:
            response = urllib2.urlopen(url)
            data = json.loads(response.read())
            if data['query']['count'] > 1:
                return data['query']['results']['place'][0]['woeid']
            return data['query']['results']['place']['woeid']
        except Exception:
            ## HTTPError? JSON Error? KeyError? Doesn't matter, return None
            return None

    def poll(self):
        if not self.woeid:
            if self.location:
                self.woeid = self.fetch_woeid(self.location)
            if not self.woeid:
                return None
        format = 'c' if self.metric else 'f'
        url = WEATHER_URL + urllib.urlencode({'w': self.woeid, 'u': format})

        try:
            response = urllib2.urlopen(url).read()
            dom = minidom.parseString(response)
        except Exception:
            ## Invalid response or couldn't parse XML.
            return None

        structure = (
            ('location', ('city', 'region', 'country')),
            ('units', ('temperature', 'distance', 'pressure', 'speed')),
            ('wind', ('chill', 'direction', 'speed')),
            ('atmosphere', ('humidity', 'visibility', 'pressure', 'rising')),
            ('astronomy', ('sunrise', 'sunset')),
            ('condition', ('text', 'code', 'temp', 'date'))
        )

        data = {}
        for tag, attrs in structure:
            element = dom.getElementsByTagNameNS(WEATHER_NS, tag)[0]
            for attr in attrs:
                data['%s_%s' % (tag, attr)] = element.getAttribute(attr)

        if data['atmosphere_rising'] == '0':
            data['atmosphere_rising'] = self.steady
        elif data['atmosphere_rising'] == '1':
            data['atmosphere_rising'] = self.up
        elif data['atmosphere_rising'] == '2':
            data['atmosphere_rising'] = self.down

        return self.format.format(**data)

########NEW FILE########
__FILENAME__ = window
# Copyright (c) 2008, Aldo Cortesi. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import array
import struct
import contextlib
import xcb.xcb
from xcb.xproto import EventMask, StackMode, SetMode
import xcb.xproto
import command
import utils
import hook


# ICCM Constants
NoValue = 0x0000
XValue = 0x0001
YValue = 0x0002
WidthValue = 0x0004
HeightValue = 0x0008
AllValues = 0x000F
XNegative = 0x0010
YNegative = 0x0020
USPosition = (1 << 0)
USSize = (1 << 1)
PPosition = (1 << 2)
PSize = (1 << 3)
PMinSize = (1 << 4)
PMaxSize = (1 << 5)
PResizeInc = (1 << 6)
PAspect = (1 << 7)
PBaseSize = (1 << 8)
PWinGravity = (1 << 9)
PAllHints = (PPosition | PSize | PMinSize | PMaxSize | PResizeInc | PAspect)
InputHint = (1 << 0)
StateHint = (1 << 1)
IconPixmapHint = (1 << 2)
IconWindowHint = (1 << 3)
IconPositionHint = (1 << 4)
IconMaskHint = (1 << 5)
WindowGroupHint = (1 << 6)
MessageHint = (1 << 7)
UrgencyHint = (1 << 8)
AllHints = (InputHint | StateHint | IconPixmapHint | IconWindowHint |
            IconPositionHint | IconMaskHint | WindowGroupHint | MessageHint |
            UrgencyHint)
WithdrawnState = 0

DontCareState = 0
NormalState = 1
ZoomState = 2
IconicState = 3
InactiveState = 4

RectangleOut = 0
RectangleIn = 1
RectanglePart = 2
VisualNoMask = 0x0
VisualIDMask = 0x1
VisualScreenMask = 0x2
VisualDepthMask = 0x4
VisualClassMask = 0x8
VisualRedMaskMask = 0x10
VisualGreenMaskMask = 0x20
VisualBlueMaskMask = 0x40
VisualColormapSizeMask = 0x80
VisualBitsPerRGBMask = 0x100
VisualAllMask = 0x1FF
ReleaseByFreeingColormap = 1
BitmapSuccess = 0
BitmapOpenFailed = 1
BitmapFileInvalid = 2
BitmapNoMemory = 3
XCSUCCESS = 0
XCNOMEM = 1
XCNOENT = 2

# float states
NOT_FLOATING = 1  # not floating
FLOATING = 2
MAXIMIZED = 3
FULLSCREEN = 4
TOP = 5
MINIMIZED = 6

_NET_WM_STATE_REMOVE = 0
_NET_WM_STATE_ADD = 1
_NET_WM_STATE_TOGGLE = 2


class _Window(command.CommandObject):
    def __init__(self, window, qtile):
        self.window, self.qtile = window, qtile
        self.hidden = True
        self.group = None
        self.icons = {}
        window.set_attribute(eventmask=self._windowMask)
        try:
            g = self.window.get_geometry()
            self._x = g.x
            self._y = g.y
            self._width = g.width
            self._height = g.height
            # note that _float_info x and y are
            # really offsets, relative to screen x,y
            self._float_info = {
                'x': g.x,
                'y': g.y,
                'w': g.width,
                'h': g.height,
            }
        except xcb.xproto.BadDrawable:
            # Whoops, we were too early, so let's ignore it for now and get the
            # values on demand.
            self._x = None
            self._y = None
            self._width = None
            self._height = None
            self._float_info = None
        self.borderwidth = 0
        self.bordercolor = None
        self.name = "<no name>"
        self.strut = None
        self.state = NormalState
        self.window_type = "normal"
        self._float_state = NOT_FLOATING

        self.hints = {
            'input': True,
            'icon_pixmap': None,
            'icon_window': None,
            'icon_x': 0,
            'icon_y': 0,
            'icon_mask': 0,
            'window_group': None,
            'urgent': False,
            # normal or size hints
            'width_inc': None,
            'height_inc': None,
            'base_width': 0,
            'base_height': 0,
        }
        self.updateHints()

    def _geometry_getter(attr):
        def get_attr(self):
            if getattr(self, "_" + attr) is None:
                g = self.window.get_geometry()
                self._x = g.x
                self._y = g.y
                self._width = g.width
                self.height = g.height
                # note that _float_info x and y are
                # really offsets, relative to screen x,y
                self._float_info = {
                    'x': g.x, 'y': g.y,
                    'w': g.width, 'h': g.height
                }

            return getattr(self, "_" + attr)
        return get_attr

    def _geometry_setter(attr):
        return lambda self, value: setattr(self, "_" + attr, value)

    x = property(fset=_geometry_setter("x"), fget=_geometry_getter("x"))
    y = property(fset=_geometry_setter("y"), fget=_geometry_getter("y"))
    width = property(
        fset=_geometry_setter("width"),
        fget=_geometry_getter("width")
    )
    height = property(
        fset=_geometry_setter("height"),
        fget=_geometry_getter("height")
    )
    _float_info = property(
        fset=_geometry_setter("_float_info"),
        fget=_geometry_getter("_float_info")
    )

    def updateName(self):
        try:
            self.name = self.window.get_name()
        except (xcb.xproto.BadWindow, xcb.xproto.BadAccess):
            return
        hook.fire("window_name_change")

    def updateHints(self):
        """
            update the local copy of the window's WM_HINTS
            http://tronche.com/gui/x/icccm/sec-4.html#WM_HINTS
        """
        try:
            h = self.window.get_wm_hints()
            normh = self.window.get_wm_normal_hints()
        except (xcb.xproto.BadWindow, xcb.xproto.BadAccess):
            return

        # FIXME
        # h values
        #{
        #    'icon_pixmap': 4194337,
        #    'icon_window': 0,
        #    'icon_mask': 4194340,
        #    'icon_y': 0,
        #    'input': 1,
        #    'icon_x': 0,
        #    'window_group': 4194305
        #    'initial_state': 1,
        #    'flags': set(['StateHint',
        #                  'IconMaskHint',
        #                  'WindowGroupHint',
        #                  'InputHint',
        #                  'UrgencyHint',
        #                  'IconPixmapHint']),
        #}

        if normh:
            normh.pop('flags')
            normh['min_width'] = max(0, normh.get('min_width', 0))
            normh['min_height'] = max(0, normh.get('min_height', 0))
            if not normh['base_width'] and \
                    normh['min_width'] and \
                    normh['width_inc']:
                # seems xcb does ignore base width :(
                normh['base_width'] = (
                    normh['min_width'] % normh['width_inc']
                )
            if not normh['base_height'] and \
                    normh['min_height'] and \
                    normh['height_inc']:
                # seems xcb does ignore base height :(
                normh['base_height'] = (
                    normh['min_height'] % normh['height_inc']
                )
            self.hints.update(normh)

        if h and 'UrgencyHint' in h['flags']:
            if self.qtile.currentWindow != self:
                self.hints['urgent'] = True
                hook.fire('client_urgent_hint_changed', self)
        elif self.urgent:
            self.hints['urgent'] = False
            hook.fire('client_urgent_hint_changed', self)

        if getattr(self, 'group', None):
            self.group.layoutAll()

        return

    def updateState(self):
        if not self.qtile.config.auto_fullscreen:
            return
        state = self.window.get_net_wm_state()
        self.qtile.log.debug('_NET_WM_STATE: %s' % state)
        if state == 'fullscreen':
            self.fullscreen = True
        else:
            self.fullscreen = False

    @property
    def urgent(self):
        return self.hints['urgent']

    def info(self):
        if self.group:
            group = self.group.name
        else:
            group = None
        return dict(
            name=self.name,
            x=self.x,
            y=self.y,
            width=self.width,
            height=self.height,
            group=group,
            id=self.window.wid,
            floating=self._float_state != NOT_FLOATING,
            float_info=self._float_info,
            maximized=self._float_state == MAXIMIZED,
            minimized=self._float_state == MINIMIZED,
            fullscreen=self._float_state == FULLSCREEN
        )

    @property
    def state(self):
        return self.window.get_wm_state()[0]

    @state.setter
    def state(self, val):
        if val in (WithdrawnState, NormalState, IconicState):
            self.window.set_property('WM_STATE', [val, 0])

    def setOpacity(self, opacity):
        if 0.0 <= opacity <= 1.0:
            real_opacity = int(opacity * 0xffffffff)
            self.window.set_property('_NET_WM_WINDOW_OPACITY', real_opacity)
        else:
            return

    def getOpacity(self):
        opacity = self.window.get_property(
            "_NET_WM_WINDOW_OPACITY", unpack="I"
        )
        if not opacity:
            return 1.0
        else:
            value = opacity[0]
            # 2 decimal places
            as_float = round((float(value) / 0xffffffff), 2)
            return as_float

    opacity = property(getOpacity, setOpacity)

    def kill(self):
        if "WM_DELETE_WINDOW" in self.window.get_wm_protocols():
            #e = event.ClientMessage(
            #        window = self.window,
            #        client_type = self.qtile.display.intern_atom(
            #             "WM_PROTOCOLS"),
            #        data = [
            #            # Use 32-bit format:
            #            32,
            #            # Must be exactly 20 bytes long:
            #            [
            #                self.qtile.display.intern_atom(
            #                        "WM_DELETE_WINDOW"),
            #                X.CurrentTime,
            #                0,
            #                0,
            #                0
            #            ]
            #        ]
            #)
            vals = [
                33,  # ClientMessageEvent
                32,  # Format
                0,
                self.window.wid,
                self.qtile.conn.atoms["WM_PROTOCOLS"],
                self.qtile.conn.atoms["WM_DELETE_WINDOW"],
                xcb.xproto.Time.CurrentTime,
                0,
                0,
                0,
            ]
            e = struct.pack('BBHII5I', *vals)
            self.window.send_event(e)
        else:
            self.window.kill_client()

    def hide(self):
        # We don't want to get the UnmapNotify for this unmap
        with self.disableMask(xcb.xproto.EventMask.StructureNotify):
            self.window.unmap()
        self.hidden = True

    def unhide(self):
        self.window.map()
        self.state = NormalState
        self.hidden = False

    @contextlib.contextmanager
    def disableMask(self, mask):
        self._disableMask(mask)
        yield
        self._resetMask()

    def _disableMask(self, mask):
        self.window.set_attribute(
            eventmask=self._windowMask & (~mask)
        )

    def _resetMask(self):
        self.window.set_attribute(
            eventmask=self._windowMask
        )

    def place(self, x, y, width, height, borderwidth, bordercolor,
              above=False, force=False):
        """
            Places the window at the specified location with the given size.

            if force is false, than it tries to obey hints
        """

        # TODO: self.x/y/height/width are updated BEFORE
        # place is called, so there's no way to know if only
        # the position is changed, so we are sending
        # the ConfigureNotify every time place is called
        #
        ## if position change and size don't
        ## send a configure notify. See ICCCM 4.2.3
        #send_notify = False
        #if (self.x != x or self.y != y) and \
        #   (self.width == width and self.height == height):
        #    send_notify = True
        ##for now, we just:
        send_notify = True

        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.borderwidth = borderwidth
        self.bordercolor = bordercolor

        # save x and y float offset
        if self.group is not None and self.group.screen is not None:
            self._float_info['x'] = x - self.group.screen.x
            self._float_info['y'] = y - self.group.screen.y

        kwarg = dict(
            x=x,
            y=y,
            width=width,
            height=height,
            borderwidth=borderwidth,
        )
        if above:
            kwarg['stackmode'] = StackMode.Above

        self.window.configure(**kwarg)

        if send_notify:
            self.send_configure_notify(x, y, width, height)

        if bordercolor is not None:
            self.window.set_attribute(borderpixel=bordercolor)

    def send_configure_notify(self, x, y, width, height):
        """
        Send a synthetic ConfigureNotify
        """

        window = self.window.wid
        above_sibling = False
        override_redirect = False
        event_type = 22  # ConfigureNotify

        event = struct.pack('bx2xIIIhhHHHB5x', event_type,
                            window, window, above_sibling,
                            x, y, width, height, self.borderwidth,
                            override_redirect)

        self.window.send_event(event, mask=EventMask.StructureNotify)

    def focus(self, warp):

        # Workaround for misbehaving java applications (actually it might be
        # qtile who misbehaves by not implementing some X11 protocol correctly)
        #
        # See this xmonad issue for more information on the problem:
        # http://code.google.com/p/xmonad/issues/detail?id=177
        #
        # 'sun-awt-X11-XFramePeer' is a main window of a java application.
        # Only send WM_TAKE_FOCUS not FocusIn
        # 'sun-awt-X11-XDialogPeer' is a dialog of a java application. Do not
        # send any event.

        cls = self.window.get_wm_class() or ''
        is_java_main = 'sun-awt-X11-XFramePeer' in cls
        is_java_dialog = 'sun-awt-X11-XDialogPeer' in cls
        is_java = is_java_main or is_java_dialog

        if not self.hidden:
            # Never send TAKE_FOCUS on java *dialogs*
            if not is_java_dialog and \
                    "WM_TAKE_FOCUS" in self.window.get_wm_protocols():
                vals = [
                    33,
                    32,
                    0,
                    self.window.wid,
                    self.qtile.conn.atoms["WM_PROTOCOLS"],
                    self.qtile.conn.atoms["WM_TAKE_FOCUS"],
                    xcb.xproto.Time.CurrentTime,
                    0,
                    0,
                    0,
                ]
                e = struct.pack('BBHII5I', *vals)
                self.window.send_event(e)

            # Never send FocusIn to java windows
            if not is_java and self.hints['input']:
                self.window.set_input_focus()
            try:
                if warp and self.qtile.config.cursor_warp:
                    self.window.warp_pointer(self.width // 2, self.height // 2)
            except AttributeError:
                pass
        self.qtile.root.set_property("_NET_ACTIVE_WINDOW", self.window.wid)
        hook.fire("client_focus", self)

    def _items(self, name, sel):
        return None

    def _select(self, name, sel):
        return None

    def cmd_info(self):
        """
            Returns a dictionary of info for this object.
        """
        return self.info()

    def cmd_inspect(self):
        """
            Tells you more than you ever wanted to know about a window.
        """
        a = self.window.get_attributes()
        attrs = {
            "backing_store": a.backing_store,
            "visual": a.visual,
            "class": a._class,
            "bit_gravity": a.bit_gravity,
            "win_gravity": a.win_gravity,
            "backing_planes": a.backing_planes,
            "backing_pixel": a.backing_pixel,
            "save_under": a.save_under,
            "map_is_installed": a.map_is_installed,
            "map_state": a.map_state,
            "override_redirect": a.override_redirect,
            #"colormap": a.colormap,
            "all_event_masks": a.all_event_masks,
            "your_event_mask": a.your_event_mask,
            "do_not_propagate_mask": a.do_not_propagate_mask
        }
        props = self.window.list_properties()
        normalhints = self.window.get_wm_normal_hints()
        hints = self.window.get_wm_hints()
        protocols = []
        for i in self.window.get_wm_protocols():
            protocols.append(i)

        state = self.window.get_wm_state()

        return dict(
            attributes=attrs,
            properties=props,
            name=self.window.get_name(),
            wm_class=self.window.get_wm_class(),
            wm_window_role=self.window.get_wm_window_role(),
            wm_type=self.window.get_wm_type(),
            wm_transient_for=self.window.get_wm_transient_for(),
            protocols=protocols,
            wm_icon_name=self.window.get_wm_icon_name(),
            wm_client_machine=self.window.get_wm_client_machine(),
            normalhints=normalhints,
            hints=hints,
            state=state,
            float_info=self._float_info
        )


class Internal(_Window):
    """
        An internal window, that should not be managed by qtile.
    """
    _windowMask = EventMask.StructureNotify | \
        EventMask.PropertyChange | \
        EventMask.EnterWindow | \
        EventMask.FocusChange | \
        EventMask.Exposure | \
        EventMask.ButtonPress | \
        EventMask.ButtonRelease | \
        EventMask.KeyPress

    @classmethod
    def create(klass, qtile, x, y, width, height, opacity=1.0):
        win = qtile.conn.create_window(x, y, width, height)
        win.set_property("QTILE_INTERNAL", 1)
        i = Internal(win, qtile)
        i.place(x, y, width, height, 0, None)
        i.opacity = opacity
        return i

    def __repr__(self):
        return "Internal(%s, %s)" % (self.name, self.window.wid)

    def kill(self):
        self.qtile.conn.conn.core.DestroyWindow(self.window.wid)

    def cmd_kill(self):
        self.kill()


class Static(_Window):
    """
        An internal window, that should not be managed by qtile.
    """
    _windowMask = EventMask.StructureNotify | \
        EventMask.PropertyChange | \
        EventMask.EnterWindow | \
        EventMask.FocusChange | \
        EventMask.Exposure

    def __init__(self, win, qtile, screen,
                 x=None, y=None, width=None, height=None):
        _Window.__init__(self, win, qtile)
        self.updateName()
        self.conf_x = x
        self.conf_y = y
        self.conf_width = width
        self.conf_height = height
        self.x = x or 0
        self.y = y or 0
        self.width = width or 0
        self.height = height or 0
        self.screen = screen
        if None not in (x, y, width, height):
            self.place(x, y, width, height, 0, 0)
        self.update_strut()

    def handle_ConfigureRequest(self, e):
        cw = xcb.xproto.ConfigWindow
        if self.conf_x is None and e.value_mask & cw.X:
            self.x = e.x
        if self.conf_y is None and e.value_mask & cw.Y:
            self.y = e.y
        if self.conf_width is None and e.value_mask & cw.Width:
            self.width = e.width
        if self.conf_height is None and e.value_mask & cw.Height:
            self.height = e.height

        self.place(
            self.screen.x + self.x,
            self.screen.y + self.y,
            self.width,
            self.height,
            self.borderwidth,
            self.bordercolor
        )
        return False

    def update_strut(self):
        strut = self.window.get_property(
            "_NET_WM_STRUT_PARTIAL",
            unpack="I" * 12
        )
        strut = strut or self.window.get_property(
            "_NET_WM_STRUT",
            unpack="I" * 4
        )
        strut = strut or (0, 0, 0, 0)
        self.qtile.update_gaps(strut, self.strut)
        self.strut = strut

    def handle_PropertyNotify(self, e):
        name = self.qtile.conn.atoms.get_name(e.atom)
        if name in ("_NET_WM_STRUT_PARTIAL", "_NET_WM_STRUT"):
            self.update_strut()

    def __repr__(self):
        return "Static(%s)" % self.name


class Window(_Window):
    _windowMask = EventMask.StructureNotify | \
        EventMask.PropertyChange | \
        EventMask.EnterWindow | \
        EventMask.FocusChange
    # Set when this object is being retired.
    defunct = False
    _group = None

    def __init__(self, window, qtile):
        _Window.__init__(self, window, qtile)
        self.updateName()
        # add to group by position according to _NET_WM_DESKTOP property
        index = window.get_wm_desktop()
        if index and index < len(qtile.groups):
            group = qtile.groups[index]
            group.add(self)
            if group != qtile.currentScreen.group:
                self.hide()

        # add window to the save-set, so it gets mapped when qtile dies
        qtile.conn.conn.core.ChangeSaveSet(SetMode.Insert, self.window.wid)
        self.update_wm_net_icon()

    @property
    def group(self):
        return self._group

    @group.setter
    def group(self, group):
        if group:
            self.window.set_property(
                "_NET_WM_DESKTOP",
                self.qtile.groups.index(group)
            )
        self._group = group

    @property
    def edges(self):
        return (self.x, self.y, self.x + self.width, self.y + self.height)

    @property
    def floating(self):
        return self._float_state != NOT_FLOATING

    @floating.setter
    def floating(self, do_float):
        if do_float and self._float_state == NOT_FLOATING:
            self.enablefloating()

    @property
    def fullscreen(self):
        return self._float_state == FULLSCREEN

    @fullscreen.setter
    def fullscreen(self, do_full):
        if do_full:
            if self._float_state != FULLSCREEN:
                self.enablemaximize(state=FULLSCREEN)
        else:
            if self._float_state == FULLSCREEN:
                self.disablefloating()

    @property
    def maximized(self):
        return self._float_state == MAXIMIZED

    @maximized.setter
    def maximized(self, do_maximize):
        if do_maximize:
            if self._float_state != MAXIMIZED:
                self.enablemaximize()
        else:
            if self._float_state == MAXIMIZED:
                self.disablefloating()

    @property
    def minimized(self):
        return self._float_state == MINIMIZED

    @minimized.setter
    def minimized(self, do_minimize):
        if do_minimize:
            if self._float_state != MINIMIZED:
                self.enableminimize()
        else:
            if self._float_state == MINIMIZED:
                self.disablefloating()

    def static(self, screen, x=None, y=None, width=None, height=None):
        """
            Makes this window a static window, attached to a Screen. If any of
            the arguments are left unspecified, the values given by the window
            itself are used instead. So, for a window that's aware of its
            appropriate size and location (like dzen), you don't have to
            specify anything.
        """
        self.defunct = True
        screen = self.qtile.screens[screen]
        if self.group:
            self.group.remove(self)
        s = Static(self.window, self.qtile, screen, x, y, width, height)
        self.qtile.windowMap[self.window.wid] = s
        hook.fire("client_managed", s)
        return s

    def tweak_float(self, x=None, y=None, dx=0, dy=0,
                    w=None, h=None, dw=0, dh=0):
        if x is not None:
            self.x = x
        self.x += dx

        if y is not None:
            self.y = y
        self.y += dy

        if w is not None:
            self.width = w
        self.width += dw

        if h is not None:
            self.height = h
        self.height += dh

        if self.height < 0:
            self.height = 0
        if self.width < 0:
            self.width = 0

        screen = self.qtile.find_closest_screen(self.x, self.y)
        if self.group and screen is not None and screen != self.group.screen:
            self.group.remove(self)
            screen.group.add(self)
            self.qtile.toScreen(screen.index)
            # TODO - need to kick boxes to update

        self._reconfigure_floating()

    def getsize(self):
        return (self.width, self.height)

    def getposition(self):
        return (self.x, self.y)

    def toggleminimize(self):
        if self.minimized:
            self.disablefloating()
        else:
            self.enableminimize()

    def enableminimize(self):
        self._enablefloating(new_float_state=MINIMIZED)

    def togglemaximize(self, state=MAXIMIZED):
        if self._float_state == state:
            self.disablefloating()
        else:
            self.enablemaximize(state)

    def enablemaximize(self, state=MAXIMIZED):
        screen = self.group.screen or self.qtile.find_closest_screen(
            self.x,
            self.y
        )

        if state == MAXIMIZED:
            self._enablefloating(
                screen.dx,
                screen.dy,
                screen.dwidth,
                screen.dheight,
                new_float_state=state
            )
        elif state == FULLSCREEN:
            self._enablefloating(
                screen.x,
                screen.y,
                screen.width,
                screen.height,
                new_float_state=state
            )

    def togglefloating(self):
        if self.floating:
            self.disablefloating()
        else:
            self.enablefloating()

    def _reconfigure_floating(self, new_float_state=FLOATING):
        if new_float_state == MINIMIZED:
            self.state = IconicState
            self.hide()
        else:
            # make sure x, y is on the screen
            screen = self.qtile.find_closest_screen(self.x, self.y)
            if not screen is None and \
                    not self.group is None and \
                    not self.group.screen is None and \
                    screen != self.group.screen:
                self.x = self.group.screen.x
                self.y = self.group.screen.y

            if self.width < self.hints.get('min_width', 0):
                self.width = self.hints['min_width']

            if self.height < self.hints.get('min_height', 0):
                self.height = self.hints['min_height']

            width = self.width
            if self.hints.get('width_inc', 0):
                width = (width -
                    ((width - self.hints['base_width']) %
                    self.hints['width_inc']))

            height = self.height
            if self.hints.get('height_inc', 0):
                height = (height -
                    ((height - self.hints['base_height'])
                    % self.hints['height_inc']))


            self.place(
                self.x,
                self.y,
                width,
                height,
                self.borderwidth,
                self.bordercolor,
                above=True,
            )
        if self._float_state != new_float_state:
            self._float_state = new_float_state
            if self.group:  # may be not, if it's called from hook
                self.group.mark_floating(self, True)
            hook.fire('float_change')

    def _enablefloating(self, x=None, y=None, w=None, h=None,
                        new_float_state=FLOATING):
        if new_float_state != MINIMIZED:
            self.x = x
            self.y = y
            self.width = w
            self.height = h
        self._reconfigure_floating(new_float_state=new_float_state)

    def enablefloating(self):
        fi = self._float_info
        self._enablefloating(fi['x'], fi['y'], fi['w'], fi['h'])

    def disablefloating(self):
        if self._float_state != NOT_FLOATING:
            if self._float_state == FLOATING:
                # store last size
                fi = self._float_info
                fi['w'] = self.width
                fi['h'] = self.height
            self._float_state = NOT_FLOATING
            self.group.mark_floating(self, False)
            hook.fire('float_change')

    def togroup(self, groupName):
        """
            Move window to a specified group.
        """
        group = self.qtile.groupMap.get(groupName)
        if group is None:
            raise command.CommandError("No such group: %s" % groupName)

        if self.group is not group:
            self.hide()
            if self.group:
                if self.group.screen:
                    # for floats remove window offset
                    self.x -= self.group.screen.x
                self.group.remove(self)

            if group.screen and self.x < group.screen.x:
                self.x += group.screen.x
            group.add(self)

    def match(self, wname=None, wmclass=None, role=None):
        """
            Match window against given attributes.

            - wname matches against the window name or title, that is,
            either `_NET_WM_VISIBLE_NAME`, `_NET_WM_NAME`, `WM_NAME`.

            - wmclass matches against any of the two values in the
            `WM_CLASS` property

            - role matches against the `WM_WINDOW_ROLE` property
        """
        if not (wname or wmclass or role):
            raise TypeError(
                "Either a name, a wmclass or a role must be specified"
            )
        if wname and wname == self.name:
            return True

        try:
            cliclass = self.window.get_wm_class()
            if wmclass and cliclass and wmclass in cliclass:
                return True

            clirole = self.window.get_wm_window_role()
            if role and clirole and role == clirole:
                return True
        except (xcb.xproto.BadWindow, xcb.xproto.BadAccess):
            return False

        return False

    def handle_EnterNotify(self, e):
        hook.fire("client_mouse_enter", self)
        if self.qtile.config.follow_mouse_focus and \
                self.group.currentWindow != self:
            self.group.focus(self, False)
        if self.group.screen and \
                self.qtile.currentScreen != self.group.screen and \
                self.qtile.config.follow_mouse_focus:
            self.qtile.toScreen(self.group.screen.index)
        return True

    def handle_ConfigureRequest(self, e):
        if self.qtile._drag and self.qtile.currentWindow == self:
            # ignore requests while user is dragging window
            return
        if getattr(self, 'floating', False):
            # only obey resize for floating windows
            cw = xcb.xproto.ConfigWindow
            if e.value_mask & cw.Width:
                self.width = e.width
            if e.value_mask & cw.Height:
                self.height = e.height
            if e.value_mask & cw.X:
                self.x = e.x
            if e.value_mask & cw.Y:
                self.y = e.y

        if self.group and self.group.screen:
            self.place(
                self.x,
                self.y,
                self.width,
                self.height,
                self.borderwidth,
                self.bordercolor,
            )
        self.updateState()
        return False

    def update_wm_net_icon(self):
        """
            Set a dict with the icons of the window
        """

        ret = self.window.get_property('_NET_WM_ICON', 'CARDINAL')
        if not ret:
            return
        icon = ret.value

        icons = {}
        while True:
            if not icon:
                break
            size = icon[:8]
            if len(size) != 8 or not size[0] or not size[4]:
                break

            icon = icon[8:]

            width = size[0]
            height = size[4]

            next_pix = width*height*4
            data = icon[:next_pix]

            arr = array.array("B", data)
            for i in range(0, len(arr), 4):
                mult = (arr[i+3]) / 255.
                arr[i+0] = int(arr[i+0] * mult)
                arr[i+1] = int(arr[i+1] * mult)
                arr[i+2] = int(arr[i+2] * mult)
            icon = icon[next_pix:]
            icons["%sx%s" % (width, height)] = arr
        self.icons = icons
        hook.fire("net_wm_icon_change", self)

    def handle_ClientMessage(self, event):
        atoms = self.qtile.conn.atoms

        opcode = xcb.xproto.ClientMessageData(event, 0, 20).data32[2]
        data = xcb.xproto.ClientMessageData(event, 12, 20)
        if atoms["_NET_WM_STATE"] == opcode and \
                self.qtile.config.auto_fullscreen:
            fullscreen_atom = atoms["_NET_WM_STATE_FULLSCREEN"]

            prev_state = self.window.get_property(
                '_NET_WM_STATE',
                'ATOM',
                unpack='I'
            )
            if not prev_state:
                prev_state = []
                if self.fullscreen:
                    prev_state.append(fullscreen_atom)

            current_state = set(prev_state)

            action = data.data32[0]
            for prop in (data.data32[1], data.data32[2]):
                if not prop:
                    # skip 0
                    continue

                prop_name = atoms.get_name(prop)

                if action == _NET_WM_STATE_REMOVE:
                    current_state.discard(prop)
                elif action == _NET_WM_STATE_ADD:
                    current_state.add(prop)
                elif action == _NET_WM_STATE_TOGGLE:
                    current_state ^= set([prop])  # toggle :D

            # add support for additional flags here
            self.fullscreen = (fullscreen_atom in current_state)

            self.window.set_property('_NET_WM_STATE', list(current_state))

    def handle_PropertyNotify(self, e):
        name = self.qtile.conn.atoms.get_name(e.atom)
        self.qtile.log.debug("PropertyNotifyEvent: %s" % name)
        if name == "WM_TRANSIENT_FOR":
            pass
        elif name == "WM_HINTS":
            self.updateHints()
        elif name == "WM_NORMAL_HINTS":
            self.updateHints()
        elif name == "WM_NAME":
            self.updateName()
        elif name == "_NET_WM_NAME":
            self.updateName()
        elif name == "_NET_WM_VISIBLE_NAME":
            self.updateName()
        elif name == "WM_ICON_NAME":
            pass
        elif name == "_NET_WM_ICON_NAME":
            pass
        elif name == "_NET_WM_ICON":
            self.update_wm_net_icon()
        elif name == "ZOOM":
            pass
        elif name == "_NET_WM_WINDOW_OPACITY":
            pass
        elif name == "WM_STATE":
            pass
        elif name == "_NET_WM_STATE":
            self.updateState()
        elif name == "WM_PROTOCOLS":
            pass
        elif name == "_NET_WM_DESKTOP":
            # Some windows set the state(fullscreen) when starts,
            # updateState is here because the group and the screen
            # are set when the property is emitted
            #self.updateState()
            self.updateState()
        elif name == "_NET_WM_USER_TIME":
            if not self.qtile.config.follow_mouse_focus and \
                    self.group.currentWindow != self:
                self.group.focus(self, False)
        else:
            self.qtile.log.info("Unknown window property: %s" % name)
        return False

    def _items(self, name):
        if name == "group":
            return (True, None)
        elif name == "layout":
            return (True, range(len(self.group.layouts)))
        elif name == "screen":
            return (True, None)

    def _select(self, name, sel):
        if name == "group":
            return self.group
        elif name == "layout":
            if sel is None:
                return self.group.layout
            else:
                return utils.lget(self.group.layouts, sel)
        elif name == "screen":
            return self.group.screen

    def __repr__(self):
        return "Window(%s)" % self.name

    def cmd_static(self, screen, x, y, width, height):
        self.static(screen, x, y, width, height)

    def cmd_kill(self):
        """
            Kill this window. Try to do this politely if the client support
            this, otherwise be brutal.
        """
        self.kill()

    def cmd_togroup(self, groupName):
        """
            Move window to a specified group.

            Examples:

                togroup("a")
        """
        self.togroup(groupName)

    def cmd_move_floating(self, dx, dy, curx, cury):
        """
            Move window by dx and dy
        """
        self.tweak_float(dx=dx, dy=dy)

    def cmd_resize_floating(self, dw, dh, curx, cury):
        """
            Add dw and dh to size of window
        """
        self.tweak_float(dw=dw, dh=dh)

    def cmd_set_position_floating(self, x, y, curx, cury):
        """
            Move window to x and y
        """
        self.tweak_float(x=x, y=y)

    def cmd_set_size_floating(self, w, h, curx, cury):
        """
            Set window dimensions to w and h
        """
        self.tweak_float(w=w, h=h)

    def cmd_get_position(self):
        return self.getposition()

    def cmd_get_size(self):
        return self.getsize()

    def cmd_toggle_floating(self):
        self.togglefloating()

    def cmd_disable_floating(self):
        self.disablefloating()

    def cmd_enable_floating(self):
        self.enablefloating()

    def cmd_toggle_maximize(self):
        self.togglemaximize()

    def cmd_disable_maximimize(self):
        self.disablefloating()

    def cmd_enable_maximize(self):
        self.enablemaximize()

    def cmd_toggle_fullscreen(self):
        self.togglemaximize(state=FULLSCREEN)

    def cmd_enable_fullscreen(self):
        self.enablemaximize(state=FULLSCREEN)

    def cmd_disable_fullscreen(self):
        self.disablefloating()

    def cmd_toggle_minimize(self):
        self.toggleminimize()

    def cmd_enable_minimize(self):
        self.enableminimize()

    def cmd_disable_minimize(self):
        self.disablefloating()

    def cmd_bring_to_front(self):
        if self.floating:
            self.window.configure(stackmode=StackMode.Above)
        else:
            self._reconfigure_floating()  # atomatically above

    def cmd_match(self, *args, **kwargs):
        return self.match(*args, **kwargs)

    def cmd_opacity(self, opacity):
        if opacity < .1:
            self.opacity = .1
        elif opacity > 1:
            self.opacity = 1
        else:
            self.opacity = opacity

    def cmd_down_opacity(self):
        if self.opacity > .2:
            # don't go completely clear
            self.opacity -= .1
        else:
            self.opacity = .1

    def cmd_up_opacity(self):
        if self.opacity < .9:
            self.opacity += .1
        else:
            self.opacity = 1

    def _is_in_window(self, x, y, window):
        return (window.edges[0] <= x <= window.edges[2] and
                window.edges[1] <= y <= window.edges[3])

    def cmd_set_position(self, dx, dy, curx, cury):
        if self.floating:
            self.tweak_float(dx, dy)
            return
        for window in self.group.windows:
            if window == self or window.floating:
                continue
            if self._is_in_window(curx, cury, window):
                clients = self.group.layout.clients
                index1 = clients.index(self)
                index2 = clients.index(window)
                clients[index1], clients[index2] = clients[index2], clients[index1]
                self.group.layout.focused = index2
                self.group.layoutAll()
                break

########NEW FILE########
__FILENAME__ = xcbq
"""
    A minimal EWMH-aware OO layer over xpyb. This is NOT intended to be
    complete - it only implements the subset of functionalty needed by qtile.
"""
from xcb.xproto import CW, WindowClass, EventMask
import struct
import utils
import xcb.randr
import xcb.xcb
import xcb.xinerama
import xcb.xproto
import xkeysyms


# hack xcb.xproto for negative numbers
def ConfigureWindow(self, window, value_mask, value_list):
    import cStringIO
    from struct import pack
    from array import array
    buf = cStringIO.StringIO()
    buf.write(pack('xx2xIH2x', window, value_mask))
    buf.write(str(buffer(array('i', value_list))))
    return self.send_request(
        xcb.Request(buf.getvalue(), 12, True, False),
        xcb.VoidCookie()
    )
xcb.xproto.xprotoExtension.ConfigureWindow = ConfigureWindow

keysyms = xkeysyms.keysyms

# These should be in xpyb:
ModMasks = {
    "shift": 1 << 0,
    "lock":  1 << 1,
    "control": 1 << 2,
    "mod1": 1 << 3,
    "mod2": 1 << 4,
    "mod3": 1 << 5,
    "mod4": 1 << 6,
    "mod5": 1 << 7,
}
ModMapOrder = [
    "shift",
    "lock",
    "control",
    "mod1",
    "mod2",
    "mod3",
    "mod4",
    "mod5"
]

AllButtonsMask = 0b11111 << 8
ButtonMotionMask = 1 << 13
ButtonReleaseMask = 1 << 3

NormalHintsFlags = {
    "USPosition": 1,     # User-specified x, y
    "USSize": 2,         # User-specified width, height
    "PPosition": 4,      # Program-specified position
    "PSize": 8,          # Program-specified size
    "PMinSize": 16,      # Program-specified minimum size
    "PMaxSize": 32,      # Program-specified maximum size
    "PResizeInc": 64,    # Program-specified resize increments
    "PAspect": 128,      # Program-specified min and max aspect ratios
    "PBaseSize": 256,    # Program-specified base size
    "PWinGravity": 512,  # Program-specified window gravity
}

HintsFlags = {
    "InputHint": 1,          # input
    "StateHint": 2,          # initial_state
    "IconPixmapHint": 4,     # icon_pixmap
    "IconWindowHint": 8,     # icon_window
    "IconPositionHint": 16,  # icon_x & icon_y
    "IconMaskHint": 32,      # icon_mask
    "WindowGroupHint": 64,   # window_group
    "MessageHint": 128,      # (this bit is obsolete)
    "UrgencyHint": 256,      # urgency
}

WindowTypes = {
    '_NET_WM_WINDOW_TYPE_DESKTOP': "desktop",
    '_NET_WM_WINDOW_TYPE_DOCK': "dock",
    '_NET_WM_WINDOW_TYPE_TOOLBAR': "toolbar",
    '_NET_WM_WINDOW_TYPE_MENU': "menu",
    '_NET_WM_WINDOW_TYPE_UTILITY': "utility",
    '_NET_WM_WINDOW_TYPE_SPLASH': "splash",
    '_NET_WM_WINDOW_TYPE_DIALOG': "dialog",
    '_NET_WM_WINDOW_TYPE_DROPDOWN_MENU': "dropdown",
    '_NET_WM_WINDOW_TYPE_POPUP_MENU': "menu",
    '_NET_WM_WINDOW_TYPE_TOOLTIP': "tooltip",
    '_NET_WM_WINDOW_TYPE_NOTIFICATION': "notification",
    '_NET_WM_WINDOW_TYPE_COMBO': "combo",
    '_NET_WM_WINDOW_TYPE_DND': "dnd",
    '_NET_WM_WINDOW_TYPE_NORMAL': "normal",
}

WindowStates = {
    None: 'normal',
    '_NET_WM_STATE_FULLSCREEN': 'fullscreen',
    }

# Maps property names to types and formats.
PropertyMap = {
    # ewmh properties
    "_NET_DESKTOP_GEOMETRY": ("CARDINAL", 32),
    "_NET_SUPPORTED": ("ATOM", 32),
    "_NET_SUPPORTING_WM_CHECK": ("WINDOW", 32),
    "_NET_WM_NAME": ("UTF8_STRING", 8),
    "_NET_WM_PID": ("CARDINAL", 32),
    "_NET_CLIENT_LIST": ("WINDOW", 32),
    "_NET_CLIENT_LIST_STACKING": ("WINDOW", 32),
    "_NET_NUMBER_OF_DESKTOPS": ("CARDINAL", 32),
    "_NET_CURRENT_DESKTOP": ("CARDINAL", 32),
    "_NET_DESKTOP_NAMES": ("UTF8_STRING", 8),
    "_NET_WORKAREA": ("CARDINAL", 32),
    "_NET_ACTIVE_WINDOW": ("WINDOW", 32),
    "_NET_WM_DESKTOP": ("CARDINAL", 32),
    "_NET_WM_STRUT": ("CARDINAL", 32),
    "_NET_WM_STRUT_PARTIAL": ("CARDINAL", 32),
    "_NET_WM_WINDOW_OPACITY": ("CARDINAL", 32),
    "_NET_WM_WINDOW_TYPE": ("CARDINAL", 32),
    # Net State
    "_NET_WM_STATE": ("ATOM", 32),
    "_NET_WM_STATE_STICKY": ("ATOM", 32),
    "_NET_WM_STATE_SKIP_TASKBAR": ("ATOM", 32),
    "_NET_WM_STATE_FULLSCREEN": ("ATOM", 32),
    "_NET_WM_STATE_MAXIMIZED_HORZ": ("ATOM", 32),
    "_NET_WM_STATE_MAXIMIZED_VERT": ("ATOM", 32),
    "_NET_WM_STATE_ABOVE": ("ATOM", 32),
    "_NET_WM_STATE_BELOW": ("ATOM", 32),
    "_NET_WM_STATE_MODAL": ("ATOM", 32),
    "_NET_WM_STATE_HIDDEN": ("ATOM", 32),
    "_NET_WM_STATE_DEMANDS_ATTENTION": ("ATOM", 32),

    # ICCCM
    "WM_STATE": ("WM_STATE", 32),
    # Qtile-specific properties
    "QTILE_INTERNAL": ("CARDINAL", 32)
}

# TODO add everything required here
# http://standards.freedesktop.org/wm-spec/1.4/ar01s03.html
SUPPORTED_ATOMS = [
    '_NET_SUPPORTED',
    '_NET_WM_STATE',
    '_NET_WM_STATE_FULLSCREEN',
    '_NET_SUPPORTING_WM_CHECK',
    '_NET_WM_NAME',
    '_NET_WM_STRUT',
    '_NET_WM_STRUT_PARTIAL',
]

XCB_CONN_ERRORS = {
    1: 'XCB_CONN_ERROR',
    2: 'XCB_CONN_CLOSED_EXT_NOTSUPPORTED',
    3: 'XCB_CONN_CLOSED_MEM_INSUFFICIENT',
    4: 'XCB_CONN_CLOSED_REQ_LEN_EXCEED',
    5: 'XCB_CONN_CLOSED_PARSE_ERR',
    6: 'XCB_CONN_CLOSED_INVALID_SCREEN',
    7: 'XCB_CONN_CLOSED_FDPASSING_FAILED',
}

def toStr(s):
    return "".join([chr(i) for i in s.name])


class MaskMap:
    """
        A general utility class that encapsulates the way the mask/value idiom
        works in xpyb. It understands a special attribute _maskvalue on
        objects, which will be used instead of the object value if present.
        This lets us passin a Font object, rather than Font.fid, for example.
    """
    def __init__(self, obj):
        self.mmap = []
        for i in dir(obj):
            if not i.startswith("_"):
                self.mmap.append((getattr(obj, i), i.lower()))
        self.mmap.sort()

    def __call__(self, **kwargs):
        """
            kwargs: keys should be in the mmap name set

            Returns a (mask, values) tuple.
        """
        mask = 0
        values = []
        for m, s in self.mmap:
            if s in kwargs:
                val = kwargs.get(s)
                if val is not None:
                    mask |= m
                    values.append(getattr(val, "_maskvalue", val))
                del kwargs[s]
        if kwargs:
            raise ValueError("Unknown mask names: %s" % kwargs.keys())
        return mask, values

ConfigureMasks = MaskMap(xcb.xproto.ConfigWindow)
AttributeMasks = MaskMap(CW)
GCMasks = MaskMap(xcb.xproto.GC)


class AtomCache:
    def __init__(self, conn):
        self.conn = conn
        self.atoms = {}
        self.reverse = {}

        # We can change the pre-loads not to wait for a return
        for name in WindowTypes.keys():
            self.insert(name=name)

        for i in dir(xcb.xproto.Atom):
            if not i.startswith("_"):
                self.insert(name=i, atom=getattr(xcb.xproto.Atom, i))

    def insert(self, name=None, atom=None):
        assert name or atom
        if atom is None:
            c = self.conn.conn.core.InternAtom(False, len(name), name)
            atom = c.reply().atom
        if name is None:
            c = self.conn.conn.core.GetAtomName(atom)
            name = str(c.reply().name.buf())
        self.atoms[name] = atom
        self.reverse[atom] = name

    def get_name(self, atom):
        if atom not in self.reverse:
            self.insert(atom=atom)
        return self.reverse[atom]

    def __getitem__(self, key):
        if key not in self.atoms:
            self.insert(name=key)
        return self.atoms[key]


class _Wrapper:
    def __init__(self, wrapped):
        self.wrapped = wrapped

    def __getattr__(self, x):
        return getattr(self.wrapped, x)


class Screen(_Wrapper):
    """
        This represents an actual X screen.
    """
    def __init__(self, conn, screen):
        _Wrapper.__init__(self, screen)
        self.default_colormap = Colormap(conn, screen.default_colormap)
        self.root = Window(conn, self.root)
        # FIXME: Where is the right place to set the cursor?
        #self.root.set_cursor("Normal")


class PseudoScreen:
    """
        This may be a Xinerama screen or a RandR CRTC, both of which are
        rectagular sections of an actual Screen.
    """
    def __init__(self, conn, x, y, width, height):
        self.conn = conn
        self.x = x
        self.y = y
        self.width = width
        self.height = height


class Colormap:
    def __init__(self, conn, cid):
        self.conn = conn
        self.cid = cid

    def alloc_color(self, color):
        """
            Flexible color allocation.
        """
        if color.startswith("#"):
            if len(color) != 7:
                raise ValueError("Invalid color: %s" % color)

            def x8to16(i):
                return 0xffff * (i & 0xff) / 0xff
            r = x8to16(int(color[1] + color[2], 16))
            g = x8to16(int(color[3] + color[4], 16))
            b = x8to16(int(color[5] + color[6], 16))
            return self.conn.conn.core.AllocColor(self.cid, r, g, b).reply()
        else:
            return self.conn.conn.core.AllocNamedColor(
                self.cid, len(color), color
            ).reply()


class Xinerama:
    def __init__(self, conn):
        self.ext = conn.conn(xcb.xinerama.key)

    def query_screens(self):
        r = self.ext.QueryScreens().reply()
        return r.screen_info


class RandR:
    def __init__(self, conn):
        self.ext = conn.conn(xcb.randr.key)
        self.ext.SelectInput(
            conn.default_screen.root.wid,
            xcb.randr.NotifyMask.ScreenChange
        )

    def query_crtcs(self, root):
        l = []
        for i in self.ext.GetScreenResources(root).reply().crtcs:
            info = self.ext.GetCrtcInfo(i, xcb.xcb.CurrentTime).reply()
            d = dict(
                x=info.x,
                y=info.y,
                width=info.width,
                height=info.height
            )
            l.append(d)
        return l


class GC:
    def __init__(self, conn, gid):
        self.conn = conn
        self.gid = gid

    def change(self, **kwargs):
        mask, values = GCMasks(**kwargs)
        self.conn.conn.core.ChangeGC(self.gid, mask, values)


class Window:
    def __init__(self, conn, wid):
        self.conn = conn
        self.wid = wid

    def _propertyString(self, r):
        """
            Extract a string from a window property reply message.
        """
        return "".join(chr(i) for i in r.value)

    def send_event(self, eventbuf, mask=EventMask.NoEvent):
        self.conn.conn.core.SendEvent(False, self.wid, mask, eventbuf)

    def kill_client(self):
        self.conn.conn.core.KillClient(self.wid)

    def set_input_focus(self):
        self.conn.conn.core.SetInputFocus(
            xcb.xproto.InputFocus.PointerRoot,
            self.wid,
            xcb.xproto.Time.CurrentTime
        )

    def warp_pointer(self, x, y):
        self.conn.conn.core.WarpPointer(
            0,
            self.wid,
            0,
            0,
            0,
            0,
            x,
            y
        )

    def get_name(self):
        """
            Tries to retrieve a canonical window name. We test the following
            properties in order of preference: _NET_WM_VISIBLE_NAME,
            _NET_WM_NAME, WM_NAME.
        """
        r = self.get_property(
            "_NET_WM_VISIBLE_NAME",
            xcb.xproto.GetPropertyType.Any
        )
        if r:
            return self._propertyString(r)

        r = self.get_property("_NET_WM_NAME", xcb.xproto.GetPropertyType.Any)
        if r:
            return self._propertyString(r)

        r = self.get_property(
            xcb.xproto.Atom.WM_NAME,
            xcb.xproto.GetPropertyType.Any
        )
        if r:
            return self._propertyString(r)

    def get_wm_hints(self):
        r = self.get_property("WM_HINTS", xcb.xproto.GetPropertyType.Any)
        if r:
            data = struct.pack("B" * len(r.value), *(list(r.value)))
            l = struct.unpack_from("=IIIIIIIII", data)
            flags = set()
            for k, v in HintsFlags.items():
                if l[0] & v:
                    flags.add(k)
            return dict(
                flags=flags,
                input=l[1],
                initial_state=l[2],
                icon_pixmap=l[3],
                icon_window=l[4],
                icon_x=l[5],
                icon_y=l[6],
                icon_mask=l[7],
                window_group=l[8]
            )

    def get_wm_normal_hints(self):
        r = self.get_property(
            "WM_NORMAL_HINTS",
            xcb.xproto.GetPropertyType.Any
        )
        if r:
            data = struct.pack("B" * len(r.value), *(list(r.value)))
            l = struct.unpack_from("=IIIIIIIIIIIIII", data)
            flags = set()
            for k, v in NormalHintsFlags.items():
                if l[0] & v:
                    flags.add(k)
            return dict(
                flags=flags,
                min_width=l[1 + 4],
                min_height=l[2 + 4],
                max_width=l[3 + 4],
                max_height=l[4 + 4],
                width_inc=l[5 + 4],
                height_inc=l[6 + 4],
                min_aspect=l[7 + 4],
                max_aspect=l[8 + 4],
                base_width=l[9 + 4],
                base_height=l[9 + 4],
                win_gravity=l[9 + 4],
            )

    def get_wm_protocols(self):
        r = self.get_property("WM_PROTOCOLS", xcb.xproto.GetPropertyType.Any)
        if r:
            data = struct.pack("B" * len(r.value), *(list(r.value)))
            l = struct.unpack_from("=" + "L" * r.value_len, data)
            return set([self.conn.atoms.get_name(i) for i in l])
        else:
            return set()

    def get_wm_state(self):
        r = self.get_property("WM_STATE", xcb.xproto.GetPropertyType.Any)
        if r:
            return struct.unpack('=LL', r.value.buf())

    def get_wm_class(self):
        """
            Return an (instance, class) tuple if WM_CLASS exists, or None.
        """
        r = self.get_property("WM_CLASS", "STRING")
        if r:
            s = self._propertyString(r)
            return tuple(s.strip("\0").split("\0"))

    def get_wm_window_role(self):
        r = self.get_property("WM_WINDOW_ROLE", "STRING")
        if r:
            return self._propertyString(r)

    def get_wm_transient_for(self):
        r = self.get_property("WM_TRANSIENT_FOR", "ATOM")
        if r:
            return list(r.value)

    def get_wm_icon_name(self):
        r = self.get_property("WM_ICON_NAME", "UTF8_STRING")
        if r:
            return self._propertyString(r)

    def get_wm_client_machine(self):
        r = self.get_property("WM_CLIENT_MACHINE", "UTF8_STRING")
        if r:
            return self._propertyString(r)

    def get_geometry(self):
        q = self.conn.conn.core.GetGeometry(self.wid)
        return q.reply()

    def get_wm_desktop(self):
        r = self.get_property("_NET_WM_DESKTOP", "CARDINAL")
        if r:
            return r.value[0]

    def get_wm_type(self):
        """
        http://standards.freedesktop.org/wm-spec/wm-spec-latest.html#id2551529
        """
        r = self.get_property('_NET_WM_WINDOW_TYPE', "ATOM", unpack='I')
        if r:
            name = self.conn.atoms.get_name(r[0])
            return WindowTypes.get(name, name)

    def get_net_wm_state(self):
        # TODO: _NET_WM_STATE is a *list* of atoms
        # We're returning only the first one, but we don't need anything
        # other than _NET_WM_STATE_FULLSCREEN (at least for now)
        # Fixing this requires refactoring each call to use a list instead
        r = self.get_property('_NET_WM_STATE', "ATOM", unpack='I')
        if r:
            name = self.conn.atoms.get_name(r[0])
            return WindowStates.get(name, name)

    def get_net_wm_pid(self):
        r = self.get_property("_NET_WM_PID", unpack="I")
        if r:
            return r[0]

    def configure(self, **kwargs):
        """
            Arguments can be: x, y, width, height, border, sibling, stackmode
        """
        mask, values = ConfigureMasks(**kwargs)
        return self.conn.conn.core.ConfigureWindow(self.wid, mask, values)

    def set_attribute(self, **kwargs):
        mask, values = AttributeMasks(**kwargs)
        self.conn.conn.core.ChangeWindowAttributesChecked(
            self.wid, mask, values
        )

    def set_cursor(self, name):
        cursorId = self.conn.cursors[name]
        mask, values = AttributeMasks(cursor=cursorId)
        self.conn.conn.core.ChangeWindowAttributesChecked(
            self.wid, mask, values
        )

    def set_property(self, name, value, type=None, format=None):
        """
            name: String Atom name
            type: String Atom name
            format: 8, 16, 32
        """
        if name in PropertyMap:
            if type or format:
                raise ValueError(
                    "Over-riding default type or format for property."
                )
            type, format = PropertyMap[name]
        else:
            if None in (type, format):
                raise ValueError(
                    "Must specify type and format for unknown property."
                )

        if not utils.isSequenceLike(value):
            value = [value]

        buf = []
        for i in value:
            # We'll expand these conversions as we need them
            if format == 32:
                buf.append(struct.pack("=L", i))
            elif format == 16:
                buf.append(struct.pack("=H", i))
            elif format == 8:
                if utils.isStringLike(i):
                    # FIXME: Unicode -> bytes conversion needed here
                    buf.append(i)
                else:
                    buf.append(struct.pack("=B", i))
        buf = "".join(buf)

        length = len(buf) / (format / 8)

        # This is a real balls-up interface-wise. As I understand it, each type
        # can have a different associated size.
        #  - value is a string of bytes.
        #  - length is the length of the data in terms of the specified format.
        self.conn.conn.core.ChangeProperty(
            xcb.xproto.PropMode.Replace,
            self.wid,
            self.conn.atoms[name],
            self.conn.atoms[type],
            format,  # Format - 8, 16, 32
            length,
            buf
        )

    def get_property(self, prop, type=None, unpack=None):
        """
            Return the contents of a property as a GetPropertyReply, or
            a tuple of values if unpack is specified, which is a format
            string to be used with the struct module.
        """
        if type is None:
            if not prop in PropertyMap:
                raise ValueError(
                    "Must specify type for unknown property."
                )
            else:
                type, _ = PropertyMap[prop]
        try:
            r = self.conn.conn.core.GetProperty(
                False, self.wid,
                self.conn.atoms[prop]
                if isinstance(prop, basestring)
                else prop,
                self.conn.atoms[type]
                if isinstance(type, basestring)
                else type,
                0, (2 ** 32) - 1
            ).reply()

            if not r.value_len:
                return None
            elif unpack is not None:
                return struct.unpack_from(unpack, r.value.buf())
            else:
                return r
        except xcb.xproto.BadWindow:
            return None

    def list_properties(self):
        r = self.conn.conn.core.ListProperties(self.wid).reply()
        return [self.conn.atoms.get_name(i) for i in r.atoms]

    def map(self):
        self.conn.conn.core.MapWindow(self.wid)

    def unmap(self):
        self.conn.conn.core.UnmapWindow(self.wid)

    def get_attributes(self):
        return self.conn.conn.core.GetWindowAttributes(self.wid).reply()

    def create_gc(self, **kwargs):
        gid = self.conn.conn.generate_id()
        mask, values = GCMasks(**kwargs)
        self.conn.conn.core.CreateGC(gid, self.wid, mask, values)
        return GC(self.conn, gid)

    def ungrab_key(self, key, modifiers):
        """
            Passing None means any key, or any modifier.
        """
        if key is None:
            key = xcb.xproto.Atom.Any
        if modifiers is None:
            modifiers = xcb.xproto.ModMask.Any
        self.conn.conn.core.UngrabKey(key, self.wid, modifiers)

    def grab_key(self, key, modifiers, owner_events,
                 pointer_mode, keyboard_mode):
        self.conn.conn.core.GrabKey(
            owner_events,
            self.wid,
            modifiers,
            key,
            pointer_mode,
            keyboard_mode
        )

    def ungrab_button(self, button, modifiers):
        """
            Passing None means any key, or any modifier.
        """
        if button is None:
            button = xcb.xproto.Atom.Any
        if modifiers is None:
            modifiers = xcb.xproto.ModMask.Any
        self.conn.conn.core.UngrabButton(button, self.wid, modifiers)

    def grab_button(self, button, modifiers, owner_events,
                    event_mask, pointer_mode, keyboard_mode):
        self.conn.conn.core.GrabButton(
            owner_events,
            self.wid,
            event_mask,
            pointer_mode,
            keyboard_mode,
            xcb.xproto.Atom._None,
            xcb.xproto.Atom._None,
            button,
            modifiers,
        )

    def grab_pointer(self, owner_events, event_mask, pointer_mode,
                     keyboard_mode, cursor=None):
        self.conn.conn.core.GrabPointer(
            owner_events,
            self.wid,
            event_mask,
            pointer_mode,
            keyboard_mode,
            xcb.xproto.Atom._None,
            cursor or xcb.xproto.Atom._None,
            xcb.xproto.Atom._None,
        )

    def ungrab_pointer(self):
        self.conn.conn.core.UngrabPointer(xcb.xproto.Atom._None)

    def query_tree(self):
        q = self.conn.conn.core.QueryTree(self.wid).reply()
        root = None
        parent = None
        if q.root:
            root = Window(self.conn, q.root)
        if q.parent:
            parent = Window(self.conn, q.root)
        return root, parent, [Window(self.conn, i) for i in q.children]


class Font:
    def __init__(self, conn, fid):
        self.conn = conn
        self.fid = fid

    @property
    def _maskvalue(self):
        return self.fid

    def text_extents(self, s):
        s = s + "aaa"
        print s
        x = self.conn.conn.core.QueryTextExtents(self.fid, len(s), s).reply()
        print x
        return x


class Connection:
    _extmap = {
        "xinerama": Xinerama,
        "randr": RandR,
    }

    def __init__(self, display):
        self.conn = xcb.xcb.connect(display=display)
        self._connected = True
        self.cursors = Cursors(self)
        self.setup = self.conn.get_setup()
        extensions = self.extensions()
        self.screens = [Screen(self, i) for i in self.setup.roots]
        self.default_screen = self.screens[self.conn.pref_screen]
        for i in extensions:
            if i in self._extmap:
                setattr(self, i, self._extmap[i](self))

        self.pseudoscreens = []
        if "xinerama" in extensions:
            for i, s in enumerate(self.xinerama.query_screens()):
                scr = PseudoScreen(
                    self,
                    s.x_org,
                    s.y_org,
                    s.width,
                    s.height,
                )
                self.pseudoscreens.append(scr)
        elif "randr" in extensions:
            for i in self.randr.query_crtcs(self.screens[0].root.wid):
                scr = PseudoScreen(
                    self,
                    i["x"],
                    i["y"],
                    i["width"],
                    i["height"],
                )
                self.pseudoscreens.append(scr)

        self.atoms = AtomCache(self)

        self.code_to_syms = {}
        self.first_sym_to_code = None
        self.refresh_keymap()

        self.modmap = None
        self.refresh_modmap()

    def refresh_keymap(self, first=None, count=None):
        if first is None:
            first = self.setup.min_keycode
            count = self.setup.max_keycode - self.setup.min_keycode + 1
        q = self.conn.core.GetKeyboardMapping(first, count).reply()

        l = []
        for i, v in enumerate(q.keysyms):
            if not i % q.keysyms_per_keycode:
                if l:
                    self.code_to_syms[
                        (i / q.keysyms_per_keycode) + first - 1
                    ] = l
                l = []
                l.append(v)
            else:
                l.append(v)
        assert len(l) == q.keysyms_per_keycode
        self.code_to_syms[first + count - 1] = l

        first_sym_to_code = {}
        for k, s in self.code_to_syms.items():
            if s[0] and not s[0] in first_sym_to_code:
                first_sym_to_code[s[0]] = k

        self.first_sym_to_code = first_sym_to_code

    def refresh_modmap(self):
        q = self.conn.core.GetModifierMapping().reply()
        modmap = {}
        for i, k in enumerate(q.keycodes):
            l = modmap.setdefault(ModMapOrder[i / q.keycodes_per_modifier], [])
            l.append(k)
        self.modmap = modmap

    def get_modifier(self, keycode):
        """
            Return the modifier matching keycode.
        """
        for n, l in self.modmap.items():
            if keycode in l:
                return n
        return None

    def keysym_to_keycode(self, keysym):
        return self.first_sym_to_code.get(keysym, 0)

    def keycode_to_keysym(self, keycode, modifier):
        if keycode >= len(self.code_to_syms) or \
                modifier >= len(self.code_to_syms[keycode]):
            return 0
        return self.code_to_syms[keycode][modifier]

    def create_window(self, x, y, width, height):
        wid = self.conn.generate_id()
        self.conn.core.CreateWindow(
            self.default_screen.root_depth,
            wid,
            self.default_screen.root.wid,
            x, y, width, height, 0,
            WindowClass.InputOutput,
            self.default_screen.root_visual,
            CW.BackPixel | CW.EventMask,
            [
                self.default_screen.black_pixel,
                EventMask.StructureNotify | EventMask.Exposure
            ]
        )
        return Window(self, wid)

    def disconnect(self):
        self.conn.disconnect()
        self._connected = False

    def flush(self):
        if self._connected:
            return self.conn.flush()

    def xsync(self):
        # The idea here is that pushing an innocuous request through
        # the queue and waiting for a response "syncs" the connection, since
        # requests are serviced in order.
        self.conn.core.GetInputFocus().reply()

    def grab_server(self):
        return self.conn.core.GrabServer()

    def get_setup(self):
        return self.conn.get_setup()

    def open_font(self, name):
        fid = self.conn.generate_id()
        self.conn.core.OpenFont(fid, len(name), name)
        return Font(self, fid)

    def extensions(self):
        return set([
            toStr(i).lower()
            for i in self.conn.core.ListExtensions().reply().names
        ])


# Stolen from samurai-x
# (Don't know where to put it, so I'll put it here)
# XCB cursors doesn't want to be themed, libxcursor
# would be better choice I think
# and we (indirectly) depend on it anyway...
class Cursors(dict):
    def __init__(self, conn):
        self.conn = conn

        FLEUR = 52
        LEFT_PTR = 68
        SIZING = 120
        BOTTOM_LEFT_CORNER = 12
        BOTTOM_RIGHT_CORNER = 14
        TOP_LEFT_CORNER = 134
        TOP_RIGHT_CORNER = 136
        DOUBLE_ARROW_HORIZ = 108
        DOUBLE_ARROW_VERT = 116

        cursors = (
            ('Normal', LEFT_PTR),
            ('Resize', SIZING),
            ('ResizeH', DOUBLE_ARROW_HORIZ),
            ('ResizeV', DOUBLE_ARROW_VERT),
            ('Move', FLEUR),
            ('TopRight', TOP_RIGHT_CORNER),
            ('TopLeft', TOP_LEFT_CORNER),
            ('BotRight', BOTTOM_RIGHT_CORNER),
            ('BotLeft', BOTTOM_LEFT_CORNER),
        )

        for name, cursor_font in cursors:
            self._new(name, cursor_font)

    def _new(self, name, cursor_font):
        fid = self.conn.conn.generate_id()
        self.conn.conn.core.OpenFont(fid, len("cursor"), "cursor")
        cursor = self.conn.conn.generate_id()
        self.conn.conn.core.CreateGlyphCursor(
            cursor, fid, fid,
            cursor_font, cursor_font + 1,
            0, 0, 0,
            65535, 65535, 65535
        )
        self[name] = cursor

########NEW FILE########
__FILENAME__ = xkeysyms
keysyms = {
    'XF86ModeLock': 0x1008FF01,
    'XF86MonBrightnessUp': 0x1008FF02,
    'XF86MonBrightnessDown': 0x1008FF03,
    'XF86KbdLightOnOff': 0x1008FF04,
    'XF86KbdBrightnessUp': 0x1008FF05,
    'XF86KbdBrightnessDown': 0x1008FF06,
    'XF86Standby': 0x1008FF10,
    'XF86AudioLowerVolume': 0x1008FF11,
    'XF86AudioMute': 0x1008FF12,
    'XF86AudioRaiseVolume': 0x1008FF13,
    'XF86AudioPlay': 0x1008FF14,
    'XF86AudioStop': 0x1008FF15,
    'XF86AudioPrev': 0x1008FF16,
    'XF86AudioNext': 0x1008FF17,
    'XF86HomePage': 0x1008FF18,
    'XF86Mail': 0x1008FF19,
    'XF86Start': 0x1008FF1A,
    'XF86Search': 0x1008FF1B,
    'XF86AudioRecord': 0x1008FF1C,
    'XF86Calculator': 0x1008FF1D,
    'XF86Memo': 0x1008FF1E,
    'XF86ToDoList': 0x1008FF1F,
    'XF86Calendar': 0x1008FF20,
    'XF86PowerDown': 0x1008FF21,
    'XF86ContrastAdjust': 0x1008FF22,
    'XF86RockerUp': 0x1008FF23,
    'XF86RockerDown': 0x1008FF24,
    'XF86RockerEnter': 0x1008FF25,
    'XF86Back': 0x1008FF26,
    'XF86Forward': 0x1008FF27,
    'XF86Stop': 0x1008FF28,
    'XF86Refresh': 0x1008FF29,
    'XF86PowerOff': 0x1008FF2A,
    'XF86WakeUp': 0x1008FF2B,
    'XF86Eject': 0x1008FF2C,
    'XF86ScreenSaver': 0x1008FF2D,
    'XF86WWW': 0x1008FF2E,
    'XF86Sleep': 0x1008FF2F,
    'XF86Favorites': 0x1008FF30,
    'XF86AudioPause': 0x1008FF31,
    'XF86AudioMedia': 0x1008FF32,
    'XF86MyComputer': 0x1008FF33,
    'XF86VendorHome': 0x1008FF34,
    'XF86LightBulb': 0x1008FF35,
    'XF86Shop': 0x1008FF36,
    'XF86History': 0x1008FF37,
    'XF86OpenURL': 0x1008FF38,
    'XF86AddFavorite': 0x1008FF39,
    'XF86HotLinks': 0x1008FF3A,
    'XF86BrightnessAdjust': 0x1008FF3B,
    'XF86Finance': 0x1008FF3C,
    'XF86Community': 0x1008FF3D,
    'XF86AudioRewind': 0x1008FF3E,
    'XF86BackForward': 0x1008FF3F,
    'XF86Launch0': 0x1008FF40,
    'XF86Launch1': 0x1008FF41,
    'XF86Launch2': 0x1008FF42,
    'XF86Launch3': 0x1008FF43,
    'XF86Launch4': 0x1008FF44,
    'XF86Launch5': 0x1008FF45,
    'XF86Launch6': 0x1008FF46,
    'XF86Launch7': 0x1008FF47,
    'XF86Launch8': 0x1008FF48,
    'XF86Launch9': 0x1008FF49,
    'XF86LaunchA': 0x1008FF4A,
    'XF86LaunchB': 0x1008FF4B,
    'XF86LaunchC': 0x1008FF4C,
    'XF86LaunchD': 0x1008FF4D,
    'XF86LaunchE': 0x1008FF4E,
    'XF86LaunchF': 0x1008FF4F,
    'XF86ApplicationLeft': 0x1008FF50,
    'XF86ApplicationRight': 0x1008FF51,
    'XF86Book': 0x1008FF52,
    'XF86CD': 0x1008FF53,
    'XF86Calculater': 0x1008FF54,
    'XF86Clear': 0x1008FF55,
    'XF86Close': 0x1008FF56,
    'XF86Copy': 0x1008FF57,
    'XF86Cut': 0x1008FF58,
    'XF86Display': 0x1008FF59,
    'XF86DOS': 0x1008FF5A,
    'XF86Documents': 0x1008FF5B,
    'XF86Excel': 0x1008FF5C,
    'XF86Explorer': 0x1008FF5D,
    'XF86Game': 0x1008FF5E,
    'XF86Go': 0x1008FF5F,
    'XF86iTouch': 0x1008FF60,
    'XF86LogOff': 0x1008FF61,
    'XF86Market': 0x1008FF62,
    'XF86Meeting': 0x1008FF63,
    'XF86MenuKB': 0x1008FF65,
    'XF86MenuPB': 0x1008FF66,
    'XF86MySites': 0x1008FF67,
    'XF86New': 0x1008FF68,
    'XF86News': 0x1008FF69,
    'XF86OfficeHome': 0x1008FF6A,
    'XF86Open': 0x1008FF6B,
    'XF86Option': 0x1008FF6C,
    'XF86Paste': 0x1008FF6D,
    'XF86Phone': 0x1008FF6E,
    'XF86Q': 0x1008FF70,
    'XF86Reply': 0x1008FF72,
    'XF86Reload': 0x1008FF73,
    'XF86RotateWindows': 0x1008FF74,
    'XF86RotationPB': 0x1008FF75,
    'XF86RotationKB': 0x1008FF76,
    'XF86Save': 0x1008FF77,
    'XF86ScrollUp': 0x1008FF78,
    'XF86ScrollDown': 0x1008FF79,
    'XF86ScrollClick': 0x1008FF7A,
    'XF86Send': 0x1008FF7B,
    'XF86Spell': 0x1008FF7C,
    'XF86SplitScreen': 0x1008FF7D,
    'XF86Support': 0x1008FF7E,
    'XF86TaskPane': 0x1008FF7F,
    'XF86Terminal': 0x1008FF80,
    'XF86Tools': 0x1008FF81,
    'XF86Travel': 0x1008FF82,
    'XF86UserPB': 0x1008FF84,
    'XF86User1KB': 0x1008FF85,
    'XF86User2KB': 0x1008FF86,
    'XF86Video': 0x1008FF87,
    'XF86WheelButton': 0x1008FF88,
    'XF86Word': 0x1008FF89,
    'XF86Xfer': 0x1008FF8A,
    'XF86ZoomIn': 0x1008FF8B,
    'XF86ZoomOut': 0x1008FF8C,
    'XF86Away': 0x1008FF8D,
    'XF86Messenger': 0x1008FF8E,
    'XF86WebCam': 0x1008FF8F,
    'XF86MailForward': 0x1008FF90,
    'XF86Pictures': 0x1008FF91,
    'XF86Music': 0x1008FF92,
    'XF86Battery': 0x1008FF93,
    'XF86Bluetooth': 0x1008FF94,
    'XF86WLAN': 0x1008FF95,
    'XF86UWB': 0x1008FF96,
    'XF86AudioForward': 0x1008FF97,
    'XF86AudioRepeat': 0x1008FF98,
    'XF86AudioRandomPlay': 0x1008FF99,
    'XF86Subtitle': 0x1008FF9A,
    'XF86AudioCycleTrack': 0x1008FF9B,
    'XF86CycleAngle': 0x1008FF9C,
    'XF86FrameBack': 0x1008FF9D,
    'XF86FrameForward': 0x1008FF9E,
    'XF86Time': 0x1008FF9F,
    'XF86Select': 0x1008FFA0,
    'XF86View': 0x1008FFA1,
    'XF86TopMenu': 0x1008FFA2,
    'XF86Red': 0x1008FFA3,
    'XF86Green': 0x1008FFA4,
    'XF86Yellow': 0x1008FFA5,
    'XF86Blue': 0x1008FFA6,
    'XF86Suspend': 0x1008FFA7,
    'XF86Hibernate': 0x1008FFA8,
    'XF86TouchpadToggle': 0x1008FFA9,
    'XF86TouchpadOn': 0x1008FFB0,
    'XF86TouchpadOff': 0x1008FFB1,
    'XF86Switch_VT_1': 0x1008FE01,
    'XF86Switch_VT_2': 0x1008FE02,
    'XF86Switch_VT_3': 0x1008FE03,
    'XF86Switch_VT_4': 0x1008FE04,
    'XF86Switch_VT_5': 0x1008FE05,
    'XF86Switch_VT_6': 0x1008FE06,
    'XF86Switch_VT_7': 0x1008FE07,
    'XF86Switch_VT_8': 0x1008FE08,
    'XF86Switch_VT_9': 0x1008FE09,
    'XF86Switch_VT_10': 0x1008FE0A,
    'XF86Switch_VT_11': 0x1008FE0B,
    'XF86Switch_VT_12': 0x1008FE0C,
    'XF86Ungrab': 0x1008FE20,
    'XF86ClearGrab': 0x1008FE21,
    'XF86Next_VMode': 0x1008FE22,
    'XF86Prev_VMode': 0x1008FE23,
    'XF86LogWindowTree': 0x1008FE24,
    'XF86LogGrabInfo': 0x1008FE25,
    'VoidSymbol': 0xffffff,
    'BackSpace': 0xff08,
    'Tab': 0xff09,
    'Linefeed': 0xff0a,
    'Clear': 0xff0b,
    'Return': 0xff0d,
    'Pause': 0xff13,
    'Scroll_Lock': 0xff14,
    'Sys_Req': 0xff15,
    'Escape': 0xff1b,
    'Delete': 0xffff,
    'Multi_key': 0xff20,
    'Codeinput': 0xff37,
    'SingleCandidate': 0xff3c,
    'MultipleCandidate': 0xff3d,
    'PreviousCandidate': 0xff3e,
    'Kanji': 0xff21,
    'Muhenkan': 0xff22,
    'Henkan_Mode': 0xff23,
    'Henkan': 0xff23,
    'Romaji': 0xff24,
    'Hiragana': 0xff25,
    'Katakana': 0xff26,
    'Hiragana_Katakana': 0xff27,
    'Zenkaku': 0xff28,
    'Hankaku': 0xff29,
    'Zenkaku_Hankaku': 0xff2a,
    'Touroku': 0xff2b,
    'Massyo': 0xff2c,
    'Kana_Lock': 0xff2d,
    'Kana_Shift': 0xff2e,
    'Eisu_Shift': 0xff2f,
    'Eisu_toggle': 0xff30,
    'Kanji_Bangou': 0xff37,
    'Zen_Koho': 0xff3d,
    'Mae_Koho': 0xff3e,
    'Home': 0xff50,
    'Left': 0xff51,
    'Up': 0xff52,
    'Right': 0xff53,
    'Down': 0xff54,
    'Prior': 0xff55,
    'Page_Up': 0xff55,
    'Next': 0xff56,
    'Page_Down': 0xff56,
    'End': 0xff57,
    'Begin': 0xff58,
    'Select': 0xff60,
    'Print': 0xff61,
    'Execute': 0xff62,
    'Insert': 0xff63,
    'Undo': 0xff65,
    'Redo': 0xff66,
    'Menu': 0xff67,
    'Find': 0xff68,
    'Cancel': 0xff69,
    'Help': 0xff6a,
    'Break': 0xff6b,
    'Mode_switch': 0xff7e,
    'script_switch': 0xff7e,
    'Num_Lock': 0xff7f,
    'KP_Space': 0xff80,
    'KP_Tab': 0xff89,
    'KP_Enter': 0xff8d,
    'KP_F1': 0xff91,
    'KP_F2': 0xff92,
    'KP_F3': 0xff93,
    'KP_F4': 0xff94,
    'KP_Home': 0xff95,
    'KP_Left': 0xff96,
    'KP_Up': 0xff97,
    'KP_Right': 0xff98,
    'KP_Down': 0xff99,
    'KP_Prior': 0xff9a,
    'KP_Page_Up': 0xff9a,
    'KP_Next': 0xff9b,
    'KP_Page_Down': 0xff9b,
    'KP_End': 0xff9c,
    'KP_Begin': 0xff9d,
    'KP_Insert': 0xff9e,
    'KP_Delete': 0xff9f,
    'KP_Equal': 0xffbd,
    'KP_Multiply': 0xffaa,
    'KP_Add': 0xffab,
    'KP_Separator': 0xffac,
    'KP_Subtract': 0xffad,
    'KP_Decimal': 0xffae,
    'KP_Divide': 0xffaf,
    'KP_0': 0xffb0,
    'KP_1': 0xffb1,
    'KP_2': 0xffb2,
    'KP_3': 0xffb3,
    'KP_4': 0xffb4,
    'KP_5': 0xffb5,
    'KP_6': 0xffb6,
    'KP_7': 0xffb7,
    'KP_8': 0xffb8,
    'KP_9': 0xffb9,
    'F1': 0xffbe,
    'F2': 0xffbf,
    'F3': 0xffc0,
    'F4': 0xffc1,
    'F5': 0xffc2,
    'F6': 0xffc3,
    'F7': 0xffc4,
    'F8': 0xffc5,
    'F9': 0xffc6,
    'F10': 0xffc7,
    'F11': 0xffc8,
    'L1': 0xffc8,
    'F12': 0xffc9,
    'L2': 0xffc9,
    'F13': 0xffca,
    'L3': 0xffca,
    'F14': 0xffcb,
    'L4': 0xffcb,
    'F15': 0xffcc,
    'L5': 0xffcc,
    'F16': 0xffcd,
    'L6': 0xffcd,
    'F17': 0xffce,
    'L7': 0xffce,
    'F18': 0xffcf,
    'L8': 0xffcf,
    'F19': 0xffd0,
    'L9': 0xffd0,
    'F20': 0xffd1,
    'L10': 0xffd1,
    'F21': 0xffd2,
    'R1': 0xffd2,
    'F22': 0xffd3,
    'R2': 0xffd3,
    'F23': 0xffd4,
    'R3': 0xffd4,
    'F24': 0xffd5,
    'R4': 0xffd5,
    'F25': 0xffd6,
    'R5': 0xffd6,
    'F26': 0xffd7,
    'R6': 0xffd7,
    'F27': 0xffd8,
    'R7': 0xffd8,
    'F28': 0xffd9,
    'R8': 0xffd9,
    'F29': 0xffda,
    'R9': 0xffda,
    'F30': 0xffdb,
    'R10': 0xffdb,
    'F31': 0xffdc,
    'R11': 0xffdc,
    'F32': 0xffdd,
    'R12': 0xffdd,
    'F33': 0xffde,
    'R13': 0xffde,
    'F34': 0xffdf,
    'R14': 0xffdf,
    'F35': 0xffe0,
    'R15': 0xffe0,
    'Shift_L': 0xffe1,
    'Shift_R': 0xffe2,
    'Control_L': 0xffe3,
    'Control_R': 0xffe4,
    'Caps_Lock': 0xffe5,
    'Shift_Lock': 0xffe6,
    'Meta_L': 0xffe7,
    'Meta_R': 0xffe8,
    'Alt_L': 0xffe9,
    'Alt_R': 0xffea,
    'Super_L': 0xffeb,
    'Super_R': 0xffec,
    'Hyper_L': 0xffed,
    'Hyper_R': 0xffee,
    'ISO_Lock': 0xfe01,
    'ISO_Level2_Latch': 0xfe02,
    'ISO_Level3_Shift': 0xfe03,
    'ISO_Level3_Latch': 0xfe04,
    'ISO_Level3_Lock': 0xfe05,
    'ISO_Level5_Shift': 0xfe11,
    'ISO_Level5_Latch': 0xfe12,
    'ISO_Level5_Lock': 0xfe13,
    'ISO_Group_Shift': 0xff7e,
    'ISO_Group_Latch': 0xfe06,
    'ISO_Group_Lock': 0xfe07,
    'ISO_Next_Group': 0xfe08,
    'ISO_Next_Group_Lock': 0xfe09,
    'ISO_Prev_Group': 0xfe0a,
    'ISO_Prev_Group_Lock': 0xfe0b,
    'ISO_First_Group': 0xfe0c,
    'ISO_First_Group_Lock': 0xfe0d,
    'ISO_Last_Group': 0xfe0e,
    'ISO_Last_Group_Lock': 0xfe0f,
    'ISO_Left_Tab': 0xfe20,
    'ISO_Move_Line_Up': 0xfe21,
    'ISO_Move_Line_Down': 0xfe22,
    'ISO_Partial_Line_Up': 0xfe23,
    'ISO_Partial_Line_Down': 0xfe24,
    'ISO_Partial_Space_Left': 0xfe25,
    'ISO_Partial_Space_Right': 0xfe26,
    'ISO_Set_Margin_Left': 0xfe27,
    'ISO_Set_Margin_Right': 0xfe28,
    'ISO_Release_Margin_Left': 0xfe29,
    'ISO_Release_Margin_Right': 0xfe2a,
    'ISO_Release_Both_Margins': 0xfe2b,
    'ISO_Fast_Cursor_Left': 0xfe2c,
    'ISO_Fast_Cursor_Right': 0xfe2d,
    'ISO_Fast_Cursor_Up': 0xfe2e,
    'ISO_Fast_Cursor_Down': 0xfe2f,
    'ISO_Continuous_Underline': 0xfe30,
    'ISO_Discontinuous_Underline': 0xfe31,
    'ISO_Emphasize': 0xfe32,
    'ISO_Center_Object': 0xfe33,
    'ISO_Enter': 0xfe34,
    'dead_grave': 0xfe50,
    'dead_acute': 0xfe51,
    'dead_circumflex': 0xfe52,
    'dead_tilde': 0xfe53,
    'dead_perispomeni': 0xfe53,
    'dead_macron': 0xfe54,
    'dead_breve': 0xfe55,
    'dead_abovedot': 0xfe56,
    'dead_diaeresis': 0xfe57,
    'dead_abovering': 0xfe58,
    'dead_doubleacute': 0xfe59,
    'dead_caron': 0xfe5a,
    'dead_cedilla': 0xfe5b,
    'dead_ogonek': 0xfe5c,
    'dead_iota': 0xfe5d,
    'dead_voiced_sound': 0xfe5e,
    'dead_semivoiced_sound': 0xfe5f,
    'dead_belowdot': 0xfe60,
    'dead_hook': 0xfe61,
    'dead_horn': 0xfe62,
    'dead_stroke': 0xfe63,
    'dead_abovecomma': 0xfe64,
    'dead_psili': 0xfe64,
    'dead_abovereversedcomma': 0xfe65,
    'dead_dasia': 0xfe65,
    'dead_doublegrave': 0xfe66,
    'dead_belowring': 0xfe67,
    'dead_belowmacron': 0xfe68,
    'dead_belowcircumflex': 0xfe69,
    'dead_belowtilde': 0xfe6a,
    'dead_belowbreve': 0xfe6b,
    'dead_belowdiaeresis': 0xfe6c,
    'dead_invertedbreve': 0xfe6d,
    'dead_belowcomma': 0xfe6e,
    'dead_currency': 0xfe6f,
    'dead_a': 0xfe80,
    'dead_A': 0xfe81,
    'dead_e': 0xfe82,
    'dead_E': 0xfe83,
    'dead_i': 0xfe84,
    'dead_I': 0xfe85,
    'dead_o': 0xfe86,
    'dead_O': 0xfe87,
    'dead_u': 0xfe88,
    'dead_U': 0xfe89,
    'dead_small_schwa': 0xfe8a,
    'dead_capital_schwa': 0xfe8b,
    'First_Virtual_Screen': 0xfed0,
    'Prev_Virtual_Screen': 0xfed1,
    'Next_Virtual_Screen': 0xfed2,
    'Last_Virtual_Screen': 0xfed4,
    'Terminate_Server': 0xfed5,
    'AccessX_Enable': 0xfe70,
    'AccessX_Feedback_Enable': 0xfe71,
    'RepeatKeys_Enable': 0xfe72,
    'SlowKeys_Enable': 0xfe73,
    'BounceKeys_Enable': 0xfe74,
    'StickyKeys_Enable': 0xfe75,
    'MouseKeys_Enable': 0xfe76,
    'MouseKeys_Accel_Enable': 0xfe77,
    'Overlay1_Enable': 0xfe78,
    'Overlay2_Enable': 0xfe79,
    'AudibleBell_Enable': 0xfe7a,
    'Pointer_Left': 0xfee0,
    'Pointer_Right': 0xfee1,
    'Pointer_Up': 0xfee2,
    'Pointer_Down': 0xfee3,
    'Pointer_UpLeft': 0xfee4,
    'Pointer_UpRight': 0xfee5,
    'Pointer_DownLeft': 0xfee6,
    'Pointer_DownRight': 0xfee7,
    'Pointer_Button_Dflt': 0xfee8,
    'Pointer_Button1': 0xfee9,
    'Pointer_Button2': 0xfeea,
    'Pointer_Button3': 0xfeeb,
    'Pointer_Button4': 0xfeec,
    'Pointer_Button5': 0xfeed,
    'Pointer_DblClick_Dflt': 0xfeee,
    'Pointer_DblClick1': 0xfeef,
    'Pointer_DblClick2': 0xfef0,
    'Pointer_DblClick3': 0xfef1,
    'Pointer_DblClick4': 0xfef2,
    'Pointer_DblClick5': 0xfef3,
    'Pointer_Drag_Dflt': 0xfef4,
    'Pointer_Drag1': 0xfef5,
    'Pointer_Drag2': 0xfef6,
    'Pointer_Drag3': 0xfef7,
    'Pointer_Drag4': 0xfef8,
    'Pointer_Drag5': 0xfefd,
    'Pointer_EnableKeys': 0xfef9,
    'Pointer_Accelerate': 0xfefa,
    'Pointer_DfltBtnNext': 0xfefb,
    'Pointer_DfltBtnPrev': 0xfefc,
    '3270_Duplicate': 0xfd01,
    '3270_FieldMark': 0xfd02,
    '3270_Right2': 0xfd03,
    '3270_Left2': 0xfd04,
    '3270_BackTab': 0xfd05,
    '3270_EraseEOF': 0xfd06,
    '3270_EraseInput': 0xfd07,
    '3270_Reset': 0xfd08,
    '3270_Quit': 0xfd09,
    '3270_PA1': 0xfd0a,
    '3270_PA2': 0xfd0b,
    '3270_PA3': 0xfd0c,
    '3270_Test': 0xfd0d,
    '3270_Attn': 0xfd0e,
    '3270_CursorBlink': 0xfd0f,
    '3270_AltCursor': 0xfd10,
    '3270_KeyClick': 0xfd11,
    '3270_Jump': 0xfd12,
    '3270_Ident': 0xfd13,
    '3270_Rule': 0xfd14,
    '3270_Copy': 0xfd15,
    '3270_Play': 0xfd16,
    '3270_Setup': 0xfd17,
    '3270_Record': 0xfd18,
    '3270_ChangeScreen': 0xfd19,
    '3270_DeleteWord': 0xfd1a,
    '3270_ExSelect': 0xfd1b,
    '3270_CursorSelect': 0xfd1c,
    '3270_PrintScreen': 0xfd1d,
    '3270_Enter': 0xfd1e,
    'space': 0x0020,
    'exclam': 0x0021,
    'quotedbl': 0x0022,
    'numbersign': 0x0023,
    'dollar': 0x0024,
    'percent': 0x0025,
    'ampersand': 0x0026,
    'apostrophe': 0x0027,
    'quoteright': 0x0027,
    'parenleft': 0x0028,
    'parenright': 0x0029,
    'asterisk': 0x002a,
    'plus': 0x002b,
    'comma': 0x002c,
    'minus': 0x002d,
    'period': 0x002e,
    'slash': 0x002f,
    '0': 0x0030,
    '1': 0x0031,
    '2': 0x0032,
    '3': 0x0033,
    '4': 0x0034,
    '5': 0x0035,
    '6': 0x0036,
    '7': 0x0037,
    '8': 0x0038,
    '9': 0x0039,
    'colon': 0x003a,
    'semicolon': 0x003b,
    'less': 0x003c,
    'equal': 0x003d,
    'greater': 0x003e,
    'question': 0x003f,
    'at': 0x0040,
    'A': 0x0041,
    'B': 0x0042,
    'C': 0x0043,
    'D': 0x0044,
    'E': 0x0045,
    'F': 0x0046,
    'G': 0x0047,
    'H': 0x0048,
    'I': 0x0049,
    'J': 0x004a,
    'K': 0x004b,
    'L': 0x004c,
    'M': 0x004d,
    'N': 0x004e,
    'O': 0x004f,
    'P': 0x0050,
    'Q': 0x0051,
    'R': 0x0052,
    'S': 0x0053,
    'T': 0x0054,
    'U': 0x0055,
    'V': 0x0056,
    'W': 0x0057,
    'X': 0x0058,
    'Y': 0x0059,
    'Z': 0x005a,
    'bracketleft': 0x005b,
    'backslash': 0x005c,
    'bracketright': 0x005d,
    'asciicircum': 0x005e,
    'underscore': 0x005f,
    'grave': 0x0060,
    'quoteleft': 0x0060,
    'a': 0x0061,
    'b': 0x0062,
    'c': 0x0063,
    'd': 0x0064,
    'e': 0x0065,
    'f': 0x0066,
    'g': 0x0067,
    'h': 0x0068,
    'i': 0x0069,
    'j': 0x006a,
    'k': 0x006b,
    'l': 0x006c,
    'm': 0x006d,
    'n': 0x006e,
    'o': 0x006f,
    'p': 0x0070,
    'q': 0x0071,
    'r': 0x0072,
    's': 0x0073,
    't': 0x0074,
    'u': 0x0075,
    'v': 0x0076,
    'w': 0x0077,
    'x': 0x0078,
    'y': 0x0079,
    'z': 0x007a,
    'braceleft': 0x007b,
    'bar': 0x007c,
    'braceright': 0x007d,
    'asciitilde': 0x007e,
    'nobreakspace': 0x00a0,
    'exclamdown': 0x00a1,
    'cent': 0x00a2,
    'sterling': 0x00a3,
    'currency': 0x00a4,
    'yen': 0x00a5,
    'brokenbar': 0x00a6,
    'section': 0x00a7,
    'diaeresis': 0x00a8,
    'copyright': 0x00a9,
    'ordfeminine': 0x00aa,
    'guillemotleft': 0x00ab,
    'notsign': 0x00ac,
    'hyphen': 0x00ad,
    'registered': 0x00ae,
    'macron': 0x00af,
    'degree': 0x00b0,
    'plusminus': 0x00b1,
    'twosuperior': 0x00b2,
    'threesuperior': 0x00b3,
    'acute': 0x00b4,
    'mu': 0x00b5,
    'paragraph': 0x00b6,
    'periodcentered': 0x00b7,
    'cedilla': 0x00b8,
    'onesuperior': 0x00b9,
    'masculine': 0x00ba,
    'guillemotright': 0x00bb,
    'onequarter': 0x00bc,
    'onehalf': 0x00bd,
    'threequarters': 0x00be,
    'questiondown': 0x00bf,
    'Agrave': 0x00c0,
    'Aacute': 0x00c1,
    'Acircumflex': 0x00c2,
    'Atilde': 0x00c3,
    'Adiaeresis': 0x00c4,
    'Aring': 0x00c5,
    'AE': 0x00c6,
    'Ccedilla': 0x00c7,
    'Egrave': 0x00c8,
    'Eacute': 0x00c9,
    'Ecircumflex': 0x00ca,
    'Ediaeresis': 0x00cb,
    'Igrave': 0x00cc,
    'Iacute': 0x00cd,
    'Icircumflex': 0x00ce,
    'Idiaeresis': 0x00cf,
    'ETH': 0x00d0,
    'Eth': 0x00d0,
    'Ntilde': 0x00d1,
    'Ograve': 0x00d2,
    'Oacute': 0x00d3,
    'Ocircumflex': 0x00d4,
    'Otilde': 0x00d5,
    'Odiaeresis': 0x00d6,
    'multiply': 0x00d7,
    'Oslash': 0x00d8,
    'Ooblique': 0x00d8,
    'Ugrave': 0x00d9,
    'Uacute': 0x00da,
    'Ucircumflex': 0x00db,
    'Udiaeresis': 0x00dc,
    'Yacute': 0x00dd,
    'THORN': 0x00de,
    'Thorn': 0x00de,
    'ssharp': 0x00df,
    'agrave': 0x00e0,
    'aacute': 0x00e1,
    'acircumflex': 0x00e2,
    'atilde': 0x00e3,
    'adiaeresis': 0x00e4,
    'aring': 0x00e5,
    'ae': 0x00e6,
    'ccedilla': 0x00e7,
    'egrave': 0x00e8,
    'eacute': 0x00e9,
    'ecircumflex': 0x00ea,
    'ediaeresis': 0x00eb,
    'igrave': 0x00ec,
    'iacute': 0x00ed,
    'icircumflex': 0x00ee,
    'idiaeresis': 0x00ef,
    'eth': 0x00f0,
    'ntilde': 0x00f1,
    'ograve': 0x00f2,
    'oacute': 0x00f3,
    'ocircumflex': 0x00f4,
    'otilde': 0x00f5,
    'odiaeresis': 0x00f6,
    'division': 0x00f7,
    'oslash': 0x00f8,
    'ooblique': 0x00f8,
    'ugrave': 0x00f9,
    'uacute': 0x00fa,
    'ucircumflex': 0x00fb,
    'udiaeresis': 0x00fc,
    'yacute': 0x00fd,
    'thorn': 0x00fe,
    'ydiaeresis': 0x00ff,
    'Aogonek': 0x01a1,
    'breve': 0x01a2,
    'Lstroke': 0x01a3,
    'Lcaron': 0x01a5,
    'Sacute': 0x01a6,
    'Scaron': 0x01a9,
    'Scedilla': 0x01aa,
    'Tcaron': 0x01ab,
    'Zacute': 0x01ac,
    'Zcaron': 0x01ae,
    'Zabovedot': 0x01af,
    'aogonek': 0x01b1,
    'ogonek': 0x01b2,
    'lstroke': 0x01b3,
    'lcaron': 0x01b5,
    'sacute': 0x01b6,
    'caron': 0x01b7,
    'scaron': 0x01b9,
    'scedilla': 0x01ba,
    'tcaron': 0x01bb,
    'zacute': 0x01bc,
    'doubleacute': 0x01bd,
    'zcaron': 0x01be,
    'zabovedot': 0x01bf,
    'Racute': 0x01c0,
    'Abreve': 0x01c3,
    'Lacute': 0x01c5,
    'Cacute': 0x01c6,
    'Ccaron': 0x01c8,
    'Eogonek': 0x01ca,
    'Ecaron': 0x01cc,
    'Dcaron': 0x01cf,
    'Dstroke': 0x01d0,
    'Nacute': 0x01d1,
    'Ncaron': 0x01d2,
    'Odoubleacute': 0x01d5,
    'Rcaron': 0x01d8,
    'Uring': 0x01d9,
    'Udoubleacute': 0x01db,
    'Tcedilla': 0x01de,
    'racute': 0x01e0,
    'abreve': 0x01e3,
    'lacute': 0x01e5,
    'cacute': 0x01e6,
    'ccaron': 0x01e8,
    'eogonek': 0x01ea,
    'ecaron': 0x01ec,
    'dcaron': 0x01ef,
    'dstroke': 0x01f0,
    'nacute': 0x01f1,
    'ncaron': 0x01f2,
    'odoubleacute': 0x01f5,
    'udoubleacute': 0x01fb,
    'rcaron': 0x01f8,
    'uring': 0x01f9,
    'tcedilla': 0x01fe,
    'abovedot': 0x01ff,
    'Hstroke': 0x02a1,
    'Hcircumflex': 0x02a6,
    'Iabovedot': 0x02a9,
    'Gbreve': 0x02ab,
    'Jcircumflex': 0x02ac,
    'hstroke': 0x02b1,
    'hcircumflex': 0x02b6,
    'idotless': 0x02b9,
    'gbreve': 0x02bb,
    'jcircumflex': 0x02bc,
    'Cabovedot': 0x02c5,
    'Ccircumflex': 0x02c6,
    'Gabovedot': 0x02d5,
    'Gcircumflex': 0x02d8,
    'Ubreve': 0x02dd,
    'Scircumflex': 0x02de,
    'cabovedot': 0x02e5,
    'ccircumflex': 0x02e6,
    'gabovedot': 0x02f5,
    'gcircumflex': 0x02f8,
    'ubreve': 0x02fd,
    'scircumflex': 0x02fe,
    'kra': 0x03a2,
    'kappa': 0x03a2,
    'Rcedilla': 0x03a3,
    'Itilde': 0x03a5,
    'Lcedilla': 0x03a6,
    'Emacron': 0x03aa,
    'Gcedilla': 0x03ab,
    'Tslash': 0x03ac,
    'rcedilla': 0x03b3,
    'itilde': 0x03b5,
    'lcedilla': 0x03b6,
    'emacron': 0x03ba,
    'gcedilla': 0x03bb,
    'tslash': 0x03bc,
    'ENG': 0x03bd,
    'eng': 0x03bf,
    'Amacron': 0x03c0,
    'Iogonek': 0x03c7,
    'Eabovedot': 0x03cc,
    'Imacron': 0x03cf,
    'Ncedilla': 0x03d1,
    'Omacron': 0x03d2,
    'Kcedilla': 0x03d3,
    'Uogonek': 0x03d9,
    'Utilde': 0x03dd,
    'Umacron': 0x03de,
    'amacron': 0x03e0,
    'iogonek': 0x03e7,
    'eabovedot': 0x03ec,
    'imacron': 0x03ef,
    'ncedilla': 0x03f1,
    'omacron': 0x03f2,
    'kcedilla': 0x03f3,
    'uogonek': 0x03f9,
    'utilde': 0x03fd,
    'umacron': 0x03fe,
    'Babovedot': 0x1001e02,
    'babovedot': 0x1001e03,
    'Dabovedot': 0x1001e0a,
    'Wgrave': 0x1001e80,
    'Wacute': 0x1001e82,
    'dabovedot': 0x1001e0b,
    'Ygrave': 0x1001ef2,
    'Fabovedot': 0x1001e1e,
    'fabovedot': 0x1001e1f,
    'Mabovedot': 0x1001e40,
    'mabovedot': 0x1001e41,
    'Pabovedot': 0x1001e56,
    'wgrave': 0x1001e81,
    'pabovedot': 0x1001e57,
    'wacute': 0x1001e83,
    'Sabovedot': 0x1001e60,
    'ygrave': 0x1001ef3,
    'Wdiaeresis': 0x1001e84,
    'wdiaeresis': 0x1001e85,
    'sabovedot': 0x1001e61,
    'Wcircumflex': 0x1000174,
    'Tabovedot': 0x1001e6a,
    'Ycircumflex': 0x1000176,
    'wcircumflex': 0x1000175,
    'tabovedot': 0x1001e6b,
    'ycircumflex': 0x1000177,
    'OE': 0x13bc,
    'oe': 0x13bd,
    'Ydiaeresis': 0x13be,
    'overline': 0x047e,
    'kana_fullstop': 0x04a1,
    'kana_openingbracket': 0x04a2,
    'kana_closingbracket': 0x04a3,
    'kana_comma': 0x04a4,
    'kana_conjunctive': 0x04a5,
    'kana_middledot': 0x04a5,
    'kana_WO': 0x04a6,
    'kana_a': 0x04a7,
    'kana_i': 0x04a8,
    'kana_u': 0x04a9,
    'kana_e': 0x04aa,
    'kana_o': 0x04ab,
    'kana_ya': 0x04ac,
    'kana_yu': 0x04ad,
    'kana_yo': 0x04ae,
    'kana_tsu': 0x04af,
    'kana_tu': 0x04af,
    'prolongedsound': 0x04b0,
    'kana_A': 0x04b1,
    'kana_I': 0x04b2,
    'kana_U': 0x04b3,
    'kana_E': 0x04b4,
    'kana_O': 0x04b5,
    'kana_KA': 0x04b6,
    'kana_KI': 0x04b7,
    'kana_KU': 0x04b8,
    'kana_KE': 0x04b9,
    'kana_KO': 0x04ba,
    'kana_SA': 0x04bb,
    'kana_SHI': 0x04bc,
    'kana_SU': 0x04bd,
    'kana_SE': 0x04be,
    'kana_SO': 0x04bf,
    'kana_TA': 0x04c0,
    'kana_CHI': 0x04c1,
    'kana_TI': 0x04c1,
    'kana_TSU': 0x04c2,
    'kana_TU': 0x04c2,
    'kana_TE': 0x04c3,
    'kana_TO': 0x04c4,
    'kana_NA': 0x04c5,
    'kana_NI': 0x04c6,
    'kana_NU': 0x04c7,
    'kana_NE': 0x04c8,
    'kana_NO': 0x04c9,
    'kana_HA': 0x04ca,
    'kana_HI': 0x04cb,
    'kana_FU': 0x04cc,
    'kana_HU': 0x04cc,
    'kana_HE': 0x04cd,
    'kana_HO': 0x04ce,
    'kana_MA': 0x04cf,
    'kana_MI': 0x04d0,
    'kana_MU': 0x04d1,
    'kana_ME': 0x04d2,
    'kana_MO': 0x04d3,
    'kana_YA': 0x04d4,
    'kana_YU': 0x04d5,
    'kana_YO': 0x04d6,
    'kana_RA': 0x04d7,
    'kana_RI': 0x04d8,
    'kana_RU': 0x04d9,
    'kana_RE': 0x04da,
    'kana_RO': 0x04db,
    'kana_WA': 0x04dc,
    'kana_N': 0x04dd,
    'voicedsound': 0x04de,
    'semivoicedsound': 0x04df,
    'kana_switch': 0xff7e,
    'Farsi_0': 0x10006f0,
    'Farsi_1': 0x10006f1,
    'Farsi_2': 0x10006f2,
    'Farsi_3': 0x10006f3,
    'Farsi_4': 0x10006f4,
    'Farsi_5': 0x10006f5,
    'Farsi_6': 0x10006f6,
    'Farsi_7': 0x10006f7,
    'Farsi_8': 0x10006f8,
    'Farsi_9': 0x10006f9,
    'Arabic_percent': 0x100066a,
    'Arabic_superscript_alef': 0x1000670,
    'Arabic_tteh': 0x1000679,
    'Arabic_peh': 0x100067e,
    'Arabic_tcheh': 0x1000686,
    'Arabic_ddal': 0x1000688,
    'Arabic_rreh': 0x1000691,
    'Arabic_comma': 0x05ac,
    'Arabic_fullstop': 0x10006d4,
    'Arabic_0': 0x1000660,
    'Arabic_1': 0x1000661,
    'Arabic_2': 0x1000662,
    'Arabic_3': 0x1000663,
    'Arabic_4': 0x1000664,
    'Arabic_5': 0x1000665,
    'Arabic_6': 0x1000666,
    'Arabic_7': 0x1000667,
    'Arabic_8': 0x1000668,
    'Arabic_9': 0x1000669,
    'Arabic_semicolon': 0x05bb,
    'Arabic_question_mark': 0x05bf,
    'Arabic_hamza': 0x05c1,
    'Arabic_maddaonalef': 0x05c2,
    'Arabic_hamzaonalef': 0x05c3,
    'Arabic_hamzaonwaw': 0x05c4,
    'Arabic_hamzaunderalef': 0x05c5,
    'Arabic_hamzaonyeh': 0x05c6,
    'Arabic_alef': 0x05c7,
    'Arabic_beh': 0x05c8,
    'Arabic_tehmarbuta': 0x05c9,
    'Arabic_teh': 0x05ca,
    'Arabic_theh': 0x05cb,
    'Arabic_jeem': 0x05cc,
    'Arabic_hah': 0x05cd,
    'Arabic_khah': 0x05ce,
    'Arabic_dal': 0x05cf,
    'Arabic_thal': 0x05d0,
    'Arabic_ra': 0x05d1,
    'Arabic_zain': 0x05d2,
    'Arabic_seen': 0x05d3,
    'Arabic_sheen': 0x05d4,
    'Arabic_sad': 0x05d5,
    'Arabic_dad': 0x05d6,
    'Arabic_tah': 0x05d7,
    'Arabic_zah': 0x05d8,
    'Arabic_ain': 0x05d9,
    'Arabic_ghain': 0x05da,
    'Arabic_tatweel': 0x05e0,
    'Arabic_feh': 0x05e1,
    'Arabic_qaf': 0x05e2,
    'Arabic_kaf': 0x05e3,
    'Arabic_lam': 0x05e4,
    'Arabic_meem': 0x05e5,
    'Arabic_noon': 0x05e6,
    'Arabic_ha': 0x05e7,
    'Arabic_heh': 0x05e7,
    'Arabic_waw': 0x05e8,
    'Arabic_alefmaksura': 0x05e9,
    'Arabic_yeh': 0x05ea,
    'Arabic_fathatan': 0x05eb,
    'Arabic_dammatan': 0x05ec,
    'Arabic_kasratan': 0x05ed,
    'Arabic_fatha': 0x05ee,
    'Arabic_damma': 0x05ef,
    'Arabic_kasra': 0x05f0,
    'Arabic_shadda': 0x05f1,
    'Arabic_sukun': 0x05f2,
    'Arabic_madda_above': 0x1000653,
    'Arabic_hamza_above': 0x1000654,
    'Arabic_hamza_below': 0x1000655,
    'Arabic_jeh': 0x1000698,
    'Arabic_veh': 0x10006a4,
    'Arabic_keheh': 0x10006a9,
    'Arabic_gaf': 0x10006af,
    'Arabic_noon_ghunna': 0x10006ba,
    'Arabic_heh_doachashmee': 0x10006be,
    'Farsi_yeh': 0x10006cc,
    'Arabic_farsi_yeh': 0x10006cc,
    'Arabic_yeh_baree': 0x10006d2,
    'Arabic_heh_goal': 0x10006c1,
    'Arabic_switch': 0xff7e,
    'Cyrillic_GHE_bar': 0x1000492,
    'Cyrillic_ghe_bar': 0x1000493,
    'Cyrillic_ZHE_descender': 0x1000496,
    'Cyrillic_zhe_descender': 0x1000497,
    'Cyrillic_KA_descender': 0x100049a,
    'Cyrillic_ka_descender': 0x100049b,
    'Cyrillic_KA_vertstroke': 0x100049c,
    'Cyrillic_ka_vertstroke': 0x100049d,
    'Cyrillic_EN_descender': 0x10004a2,
    'Cyrillic_en_descender': 0x10004a3,
    'Cyrillic_U_straight': 0x10004ae,
    'Cyrillic_u_straight': 0x10004af,
    'Cyrillic_U_straight_bar': 0x10004b0,
    'Cyrillic_u_straight_bar': 0x10004b1,
    'Cyrillic_HA_descender': 0x10004b2,
    'Cyrillic_ha_descender': 0x10004b3,
    'Cyrillic_CHE_descender': 0x10004b6,
    'Cyrillic_che_descender': 0x10004b7,
    'Cyrillic_CHE_vertstroke': 0x10004b8,
    'Cyrillic_che_vertstroke': 0x10004b9,
    'Cyrillic_SHHA': 0x10004ba,
    'Cyrillic_shha': 0x10004bb,
    'Cyrillic_SCHWA': 0x10004d8,
    'Cyrillic_schwa': 0x10004d9,
    'Cyrillic_I_macron': 0x10004e2,
    'Cyrillic_i_macron': 0x10004e3,
    'Cyrillic_O_bar': 0x10004e8,
    'Cyrillic_o_bar': 0x10004e9,
    'Cyrillic_U_macron': 0x10004ee,
    'Cyrillic_u_macron': 0x10004ef,
    'Serbian_dje': 0x06a1,
    'Macedonia_gje': 0x06a2,
    'Cyrillic_io': 0x06a3,
    'Ukrainian_ie': 0x06a4,
    'Ukranian_je': 0x06a4,
    'Macedonia_dse': 0x06a5,
    'Ukrainian_i': 0x06a6,
    'Ukranian_i': 0x06a6,
    'Ukrainian_yi': 0x06a7,
    'Ukranian_yi': 0x06a7,
    'Cyrillic_je': 0x06a8,
    'Serbian_je': 0x06a8,
    'Cyrillic_lje': 0x06a9,
    'Serbian_lje': 0x06a9,
    'Cyrillic_nje': 0x06aa,
    'Serbian_nje': 0x06aa,
    'Serbian_tshe': 0x06ab,
    'Macedonia_kje': 0x06ac,
    'Ukrainian_ghe_with_upturn': 0x06ad,
    'Byelorussian_shortu': 0x06ae,
    'Cyrillic_dzhe': 0x06af,
    'Serbian_dze': 0x06af,
    'numerosign': 0x06b0,
    'Serbian_DJE': 0x06b1,
    'Macedonia_GJE': 0x06b2,
    'Cyrillic_IO': 0x06b3,
    'Ukrainian_IE': 0x06b4,
    'Ukranian_JE': 0x06b4,
    'Macedonia_DSE': 0x06b5,
    'Ukrainian_I': 0x06b6,
    'Ukranian_I': 0x06b6,
    'Ukrainian_YI': 0x06b7,
    'Ukranian_YI': 0x06b7,
    'Cyrillic_JE': 0x06b8,
    'Serbian_JE': 0x06b8,
    'Cyrillic_LJE': 0x06b9,
    'Serbian_LJE': 0x06b9,
    'Cyrillic_NJE': 0x06ba,
    'Serbian_NJE': 0x06ba,
    'Serbian_TSHE': 0x06bb,
    'Macedonia_KJE': 0x06bc,
    'Ukrainian_GHE_WITH_UPTURN': 0x06bd,
    'Byelorussian_SHORTU': 0x06be,
    'Cyrillic_DZHE': 0x06bf,
    'Serbian_DZE': 0x06bf,
    'Cyrillic_yu': 0x06c0,
    'Cyrillic_a': 0x06c1,
    'Cyrillic_be': 0x06c2,
    'Cyrillic_tse': 0x06c3,
    'Cyrillic_de': 0x06c4,
    'Cyrillic_ie': 0x06c5,
    'Cyrillic_ef': 0x06c6,
    'Cyrillic_ghe': 0x06c7,
    'Cyrillic_ha': 0x06c8,
    'Cyrillic_i': 0x06c9,
    'Cyrillic_shorti': 0x06ca,
    'Cyrillic_ka': 0x06cb,
    'Cyrillic_el': 0x06cc,
    'Cyrillic_em': 0x06cd,
    'Cyrillic_en': 0x06ce,
    'Cyrillic_o': 0x06cf,
    'Cyrillic_pe': 0x06d0,
    'Cyrillic_ya': 0x06d1,
    'Cyrillic_er': 0x06d2,
    'Cyrillic_es': 0x06d3,
    'Cyrillic_te': 0x06d4,
    'Cyrillic_u': 0x06d5,
    'Cyrillic_zhe': 0x06d6,
    'Cyrillic_ve': 0x06d7,
    'Cyrillic_softsign': 0x06d8,
    'Cyrillic_yeru': 0x06d9,
    'Cyrillic_ze': 0x06da,
    'Cyrillic_sha': 0x06db,
    'Cyrillic_e': 0x06dc,
    'Cyrillic_shcha': 0x06dd,
    'Cyrillic_che': 0x06de,
    'Cyrillic_hardsign': 0x06df,
    'Cyrillic_YU': 0x06e0,
    'Cyrillic_A': 0x06e1,
    'Cyrillic_BE': 0x06e2,
    'Cyrillic_TSE': 0x06e3,
    'Cyrillic_DE': 0x06e4,
    'Cyrillic_IE': 0x06e5,
    'Cyrillic_EF': 0x06e6,
    'Cyrillic_GHE': 0x06e7,
    'Cyrillic_HA': 0x06e8,
    'Cyrillic_I': 0x06e9,
    'Cyrillic_SHORTI': 0x06ea,
    'Cyrillic_KA': 0x06eb,
    'Cyrillic_EL': 0x06ec,
    'Cyrillic_EM': 0x06ed,
    'Cyrillic_EN': 0x06ee,
    'Cyrillic_O': 0x06ef,
    'Cyrillic_PE': 0x06f0,
    'Cyrillic_YA': 0x06f1,
    'Cyrillic_ER': 0x06f2,
    'Cyrillic_ES': 0x06f3,
    'Cyrillic_TE': 0x06f4,
    'Cyrillic_U': 0x06f5,
    'Cyrillic_ZHE': 0x06f6,
    'Cyrillic_VE': 0x06f7,
    'Cyrillic_SOFTSIGN': 0x06f8,
    'Cyrillic_YERU': 0x06f9,
    'Cyrillic_ZE': 0x06fa,
    'Cyrillic_SHA': 0x06fb,
    'Cyrillic_E': 0x06fc,
    'Cyrillic_SHCHA': 0x06fd,
    'Cyrillic_CHE': 0x06fe,
    'Cyrillic_HARDSIGN': 0x06ff,
    'Greek_ALPHAaccent': 0x07a1,
    'Greek_EPSILONaccent': 0x07a2,
    'Greek_ETAaccent': 0x07a3,
    'Greek_IOTAaccent': 0x07a4,
    'Greek_IOTAdieresis': 0x07a5,
    'Greek_IOTAdiaeresis': 0x07a5,
    'Greek_OMICRONaccent': 0x07a7,
    'Greek_UPSILONaccent': 0x07a8,
    'Greek_UPSILONdieresis': 0x07a9,
    'Greek_OMEGAaccent': 0x07ab,
    'Greek_accentdieresis': 0x07ae,
    'Greek_horizbar': 0x07af,
    'Greek_alphaaccent': 0x07b1,
    'Greek_epsilonaccent': 0x07b2,
    'Greek_etaaccent': 0x07b3,
    'Greek_iotaaccent': 0x07b4,
    'Greek_iotadieresis': 0x07b5,
    'Greek_iotaaccentdieresis': 0x07b6,
    'Greek_omicronaccent': 0x07b7,
    'Greek_upsilonaccent': 0x07b8,
    'Greek_upsilondieresis': 0x07b9,
    'Greek_upsilonaccentdieresis': 0x07ba,
    'Greek_omegaaccent': 0x07bb,
    'Greek_ALPHA': 0x07c1,
    'Greek_BETA': 0x07c2,
    'Greek_GAMMA': 0x07c3,
    'Greek_DELTA': 0x07c4,
    'Greek_EPSILON': 0x07c5,
    'Greek_ZETA': 0x07c6,
    'Greek_ETA': 0x07c7,
    'Greek_THETA': 0x07c8,
    'Greek_IOTA': 0x07c9,
    'Greek_KAPPA': 0x07ca,
    'Greek_LAMDA': 0x07cb,
    'Greek_LAMBDA': 0x07cb,
    'Greek_MU': 0x07cc,
    'Greek_NU': 0x07cd,
    'Greek_XI': 0x07ce,
    'Greek_OMICRON': 0x07cf,
    'Greek_PI': 0x07d0,
    'Greek_RHO': 0x07d1,
    'Greek_SIGMA': 0x07d2,
    'Greek_TAU': 0x07d4,
    'Greek_UPSILON': 0x07d5,
    'Greek_PHI': 0x07d6,
    'Greek_CHI': 0x07d7,
    'Greek_PSI': 0x07d8,
    'Greek_OMEGA': 0x07d9,
    'Greek_alpha': 0x07e1,
    'Greek_beta': 0x07e2,
    'Greek_gamma': 0x07e3,
    'Greek_delta': 0x07e4,
    'Greek_epsilon': 0x07e5,
    'Greek_zeta': 0x07e6,
    'Greek_eta': 0x07e7,
    'Greek_theta': 0x07e8,
    'Greek_iota': 0x07e9,
    'Greek_kappa': 0x07ea,
    'Greek_lamda': 0x07eb,
    'Greek_lambda': 0x07eb,
    'Greek_mu': 0x07ec,
    'Greek_nu': 0x07ed,
    'Greek_xi': 0x07ee,
    'Greek_omicron': 0x07ef,
    'Greek_pi': 0x07f0,
    'Greek_rho': 0x07f1,
    'Greek_sigma': 0x07f2,
    'Greek_finalsmallsigma': 0x07f3,
    'Greek_tau': 0x07f4,
    'Greek_upsilon': 0x07f5,
    'Greek_phi': 0x07f6,
    'Greek_chi': 0x07f7,
    'Greek_psi': 0x07f8,
    'Greek_omega': 0x07f9,
    'Greek_switch': 0xff7e,
    'leftradical': 0x08a1,
    'topleftradical': 0x08a2,
    'horizconnector': 0x08a3,
    'topintegral': 0x08a4,
    'botintegral': 0x08a5,
    'vertconnector': 0x08a6,
    'topleftsqbracket': 0x08a7,
    'botleftsqbracket': 0x08a8,
    'toprightsqbracket': 0x08a9,
    'botrightsqbracket': 0x08aa,
    'topleftparens': 0x08ab,
    'botleftparens': 0x08ac,
    'toprightparens': 0x08ad,
    'botrightparens': 0x08ae,
    'leftmiddlecurlybrace': 0x08af,
    'rightmiddlecurlybrace': 0x08b0,
    'topleftsummation': 0x08b1,
    'botleftsummation': 0x08b2,
    'topvertsummationconnector': 0x08b3,
    'botvertsummationconnector': 0x08b4,
    'toprightsummation': 0x08b5,
    'botrightsummation': 0x08b6,
    'rightmiddlesummation': 0x08b7,
    'lessthanequal': 0x08bc,
    'notequal': 0x08bd,
    'greaterthanequal': 0x08be,
    'integral': 0x08bf,
    'therefore': 0x08c0,
    'variation': 0x08c1,
    'infinity': 0x08c2,
    'nabla': 0x08c5,
    'approximate': 0x08c8,
    'similarequal': 0x08c9,
    'ifonlyif': 0x08cd,
    'implies': 0x08ce,
    'identical': 0x08cf,
    'radical': 0x08d6,
    'includedin': 0x08da,
    'includes': 0x08db,
    'intersection': 0x08dc,
    'union': 0x08dd,
    'logicaland': 0x08de,
    'logicalor': 0x08df,
    'partialderivative': 0x08ef,
    'function': 0x08f6,
    'leftarrow': 0x08fb,
    'uparrow': 0x08fc,
    'rightarrow': 0x08fd,
    'downarrow': 0x08fe,
    'blank': 0x09df,
    'soliddiamond': 0x09e0,
    'checkerboard': 0x09e1,
    'ht': 0x09e2,
    'ff': 0x09e3,
    'cr': 0x09e4,
    'lf': 0x09e5,
    'nl': 0x09e8,
    'vt': 0x09e9,
    'lowrightcorner': 0x09ea,
    'uprightcorner': 0x09eb,
    'upleftcorner': 0x09ec,
    'lowleftcorner': 0x09ed,
    'crossinglines': 0x09ee,
    'horizlinescan1': 0x09ef,
    'horizlinescan3': 0x09f0,
    'horizlinescan5': 0x09f1,
    'horizlinescan7': 0x09f2,
    'horizlinescan9': 0x09f3,
    'leftt': 0x09f4,
    'rightt': 0x09f5,
    'bott': 0x09f6,
    'topt': 0x09f7,
    'vertbar': 0x09f8,
    'emspace': 0x0aa1,
    'enspace': 0x0aa2,
    'em3space': 0x0aa3,
    'em4space': 0x0aa4,
    'digitspace': 0x0aa5,
    'punctspace': 0x0aa6,
    'thinspace': 0x0aa7,
    'hairspace': 0x0aa8,
    'emdash': 0x0aa9,
    'endash': 0x0aaa,
    'signifblank': 0x0aac,
    'ellipsis': 0x0aae,
    'doubbaselinedot': 0x0aaf,
    'onethird': 0x0ab0,
    'twothirds': 0x0ab1,
    'onefifth': 0x0ab2,
    'twofifths': 0x0ab3,
    'threefifths': 0x0ab4,
    'fourfifths': 0x0ab5,
    'onesixth': 0x0ab6,
    'fivesixths': 0x0ab7,
    'careof': 0x0ab8,
    'figdash': 0x0abb,
    'leftanglebracket': 0x0abc,
    'decimalpoint': 0x0abd,
    'rightanglebracket': 0x0abe,
    'marker': 0x0abf,
    'oneeighth': 0x0ac3,
    'threeeighths': 0x0ac4,
    'fiveeighths': 0x0ac5,
    'seveneighths': 0x0ac6,
    'trademark': 0x0ac9,
    'signaturemark': 0x0aca,
    'trademarkincircle': 0x0acb,
    'leftopentriangle': 0x0acc,
    'rightopentriangle': 0x0acd,
    'emopencircle': 0x0ace,
    'emopenrectangle': 0x0acf,
    'leftsinglequotemark': 0x0ad0,
    'rightsinglequotemark': 0x0ad1,
    'leftdoublequotemark': 0x0ad2,
    'rightdoublequotemark': 0x0ad3,
    'prescription': 0x0ad4,
    'minutes': 0x0ad6,
    'seconds': 0x0ad7,
    'latincross': 0x0ad9,
    'hexagram': 0x0ada,
    'filledrectbullet': 0x0adb,
    'filledlefttribullet': 0x0adc,
    'filledrighttribullet': 0x0add,
    'emfilledcircle': 0x0ade,
    'emfilledrect': 0x0adf,
    'enopencircbullet': 0x0ae0,
    'enopensquarebullet': 0x0ae1,
    'openrectbullet': 0x0ae2,
    'opentribulletup': 0x0ae3,
    'opentribulletdown': 0x0ae4,
    'openstar': 0x0ae5,
    'enfilledcircbullet': 0x0ae6,
    'enfilledsqbullet': 0x0ae7,
    'filledtribulletup': 0x0ae8,
    'filledtribulletdown': 0x0ae9,
    'leftpointer': 0x0aea,
    'rightpointer': 0x0aeb,
    'club': 0x0aec,
    'diamond': 0x0aed,
    'heart': 0x0aee,
    'maltesecross': 0x0af0,
    'dagger': 0x0af1,
    'doubledagger': 0x0af2,
    'checkmark': 0x0af3,
    'ballotcross': 0x0af4,
    'musicalsharp': 0x0af5,
    'musicalflat': 0x0af6,
    'malesymbol': 0x0af7,
    'femalesymbol': 0x0af8,
    'telephone': 0x0af9,
    'telephonerecorder': 0x0afa,
    'phonographcopyright': 0x0afb,
    'caret': 0x0afc,
    'singlelowquotemark': 0x0afd,
    'doublelowquotemark': 0x0afe,
    'cursor': 0x0aff,
    'leftcaret': 0x0ba3,
    'rightcaret': 0x0ba6,
    'downcaret': 0x0ba8,
    'upcaret': 0x0ba9,
    'overbar': 0x0bc0,
    'downtack': 0x0bc2,
    'upshoe': 0x0bc3,
    'downstile': 0x0bc4,
    'underbar': 0x0bc6,
    'jot': 0x0bca,
    'quad': 0x0bcc,
    'uptack': 0x0bce,
    'circle': 0x0bcf,
    'upstile': 0x0bd3,
    'downshoe': 0x0bd6,
    'rightshoe': 0x0bd8,
    'leftshoe': 0x0bda,
    'lefttack': 0x0bdc,
    'righttack': 0x0bfc,
    'hebrew_doublelowline': 0x0cdf,
    'hebrew_aleph': 0x0ce0,
    'hebrew_bet': 0x0ce1,
    'hebrew_beth': 0x0ce1,
    'hebrew_gimel': 0x0ce2,
    'hebrew_gimmel': 0x0ce2,
    'hebrew_dalet': 0x0ce3,
    'hebrew_daleth': 0x0ce3,
    'hebrew_he': 0x0ce4,
    'hebrew_waw': 0x0ce5,
    'hebrew_zain': 0x0ce6,
    'hebrew_zayin': 0x0ce6,
    'hebrew_chet': 0x0ce7,
    'hebrew_het': 0x0ce7,
    'hebrew_tet': 0x0ce8,
    'hebrew_teth': 0x0ce8,
    'hebrew_yod': 0x0ce9,
    'hebrew_finalkaph': 0x0cea,
    'hebrew_kaph': 0x0ceb,
    'hebrew_lamed': 0x0cec,
    'hebrew_finalmem': 0x0ced,
    'hebrew_mem': 0x0cee,
    'hebrew_finalnun': 0x0cef,
    'hebrew_nun': 0x0cf0,
    'hebrew_samech': 0x0cf1,
    'hebrew_samekh': 0x0cf1,
    'hebrew_ayin': 0x0cf2,
    'hebrew_finalpe': 0x0cf3,
    'hebrew_pe': 0x0cf4,
    'hebrew_finalzade': 0x0cf5,
    'hebrew_finalzadi': 0x0cf5,
    'hebrew_zade': 0x0cf6,
    'hebrew_zadi': 0x0cf6,
    'hebrew_qoph': 0x0cf7,
    'hebrew_kuf': 0x0cf7,
    'hebrew_resh': 0x0cf8,
    'hebrew_shin': 0x0cf9,
    'hebrew_taw': 0x0cfa,
    'hebrew_taf': 0x0cfa,
    'Hebrew_switch': 0xff7e,
    'Thai_kokai': 0x0da1,
    'Thai_khokhai': 0x0da2,
    'Thai_khokhuat': 0x0da3,
    'Thai_khokhwai': 0x0da4,
    'Thai_khokhon': 0x0da5,
    'Thai_khorakhang': 0x0da6,
    'Thai_ngongu': 0x0da7,
    'Thai_chochan': 0x0da8,
    'Thai_choching': 0x0da9,
    'Thai_chochang': 0x0daa,
    'Thai_soso': 0x0dab,
    'Thai_chochoe': 0x0dac,
    'Thai_yoying': 0x0dad,
    'Thai_dochada': 0x0dae,
    'Thai_topatak': 0x0daf,
    'Thai_thothan': 0x0db0,
    'Thai_thonangmontho': 0x0db1,
    'Thai_thophuthao': 0x0db2,
    'Thai_nonen': 0x0db3,
    'Thai_dodek': 0x0db4,
    'Thai_totao': 0x0db5,
    'Thai_thothung': 0x0db6,
    'Thai_thothahan': 0x0db7,
    'Thai_thothong': 0x0db8,
    'Thai_nonu': 0x0db9,
    'Thai_bobaimai': 0x0dba,
    'Thai_popla': 0x0dbb,
    'Thai_phophung': 0x0dbc,
    'Thai_fofa': 0x0dbd,
    'Thai_phophan': 0x0dbe,
    'Thai_fofan': 0x0dbf,
    'Thai_phosamphao': 0x0dc0,
    'Thai_moma': 0x0dc1,
    'Thai_yoyak': 0x0dc2,
    'Thai_rorua': 0x0dc3,
    'Thai_ru': 0x0dc4,
    'Thai_loling': 0x0dc5,
    'Thai_lu': 0x0dc6,
    'Thai_wowaen': 0x0dc7,
    'Thai_sosala': 0x0dc8,
    'Thai_sorusi': 0x0dc9,
    'Thai_sosua': 0x0dca,
    'Thai_hohip': 0x0dcb,
    'Thai_lochula': 0x0dcc,
    'Thai_oang': 0x0dcd,
    'Thai_honokhuk': 0x0dce,
    'Thai_paiyannoi': 0x0dcf,
    'Thai_saraa': 0x0dd0,
    'Thai_maihanakat': 0x0dd1,
    'Thai_saraaa': 0x0dd2,
    'Thai_saraam': 0x0dd3,
    'Thai_sarai': 0x0dd4,
    'Thai_saraii': 0x0dd5,
    'Thai_saraue': 0x0dd6,
    'Thai_sarauee': 0x0dd7,
    'Thai_sarau': 0x0dd8,
    'Thai_sarauu': 0x0dd9,
    'Thai_phinthu': 0x0dda,
    'Thai_maihanakat_maitho': 0x0dde,
    'Thai_baht': 0x0ddf,
    'Thai_sarae': 0x0de0,
    'Thai_saraae': 0x0de1,
    'Thai_sarao': 0x0de2,
    'Thai_saraaimaimuan': 0x0de3,
    'Thai_saraaimaimalai': 0x0de4,
    'Thai_lakkhangyao': 0x0de5,
    'Thai_maiyamok': 0x0de6,
    'Thai_maitaikhu': 0x0de7,
    'Thai_maiek': 0x0de8,
    'Thai_maitho': 0x0de9,
    'Thai_maitri': 0x0dea,
    'Thai_maichattawa': 0x0deb,
    'Thai_thanthakhat': 0x0dec,
    'Thai_nikhahit': 0x0ded,
    'Thai_leksun': 0x0df0,
    'Thai_leknung': 0x0df1,
    'Thai_leksong': 0x0df2,
    'Thai_leksam': 0x0df3,
    'Thai_leksi': 0x0df4,
    'Thai_lekha': 0x0df5,
    'Thai_lekhok': 0x0df6,
    'Thai_lekchet': 0x0df7,
    'Thai_lekpaet': 0x0df8,
    'Thai_lekkao': 0x0df9,
    'Hangul': 0xff31,
    'Hangul_Start': 0xff32,
    'Hangul_End': 0xff33,
    'Hangul_Hanja': 0xff34,
    'Hangul_Jamo': 0xff35,
    'Hangul_Romaja': 0xff36,
    'Hangul_Codeinput': 0xff37,
    'Hangul_Jeonja': 0xff38,
    'Hangul_Banja': 0xff39,
    'Hangul_PreHanja': 0xff3a,
    'Hangul_PostHanja': 0xff3b,
    'Hangul_SingleCandidate': 0xff3c,
    'Hangul_MultipleCandidate': 0xff3d,
    'Hangul_PreviousCandidate': 0xff3e,
    'Hangul_Special': 0xff3f,
    'Hangul_switch': 0xff7e,
    'Hangul_Kiyeog': 0x0ea1,
    'Hangul_SsangKiyeog': 0x0ea2,
    'Hangul_KiyeogSios': 0x0ea3,
    'Hangul_Nieun': 0x0ea4,
    'Hangul_NieunJieuj': 0x0ea5,
    'Hangul_NieunHieuh': 0x0ea6,
    'Hangul_Dikeud': 0x0ea7,
    'Hangul_SsangDikeud': 0x0ea8,
    'Hangul_Rieul': 0x0ea9,
    'Hangul_RieulKiyeog': 0x0eaa,
    'Hangul_RieulMieum': 0x0eab,
    'Hangul_RieulPieub': 0x0eac,
    'Hangul_RieulSios': 0x0ead,
    'Hangul_RieulTieut': 0x0eae,
    'Hangul_RieulPhieuf': 0x0eaf,
    'Hangul_RieulHieuh': 0x0eb0,
    'Hangul_Mieum': 0x0eb1,
    'Hangul_Pieub': 0x0eb2,
    'Hangul_SsangPieub': 0x0eb3,
    'Hangul_PieubSios': 0x0eb4,
    'Hangul_Sios': 0x0eb5,
    'Hangul_SsangSios': 0x0eb6,
    'Hangul_Ieung': 0x0eb7,
    'Hangul_Jieuj': 0x0eb8,
    'Hangul_SsangJieuj': 0x0eb9,
    'Hangul_Cieuc': 0x0eba,
    'Hangul_Khieuq': 0x0ebb,
    'Hangul_Tieut': 0x0ebc,
    'Hangul_Phieuf': 0x0ebd,
    'Hangul_Hieuh': 0x0ebe,
    'Hangul_A': 0x0ebf,
    'Hangul_AE': 0x0ec0,
    'Hangul_YA': 0x0ec1,
    'Hangul_YAE': 0x0ec2,
    'Hangul_EO': 0x0ec3,
    'Hangul_E': 0x0ec4,
    'Hangul_YEO': 0x0ec5,
    'Hangul_YE': 0x0ec6,
    'Hangul_O': 0x0ec7,
    'Hangul_WA': 0x0ec8,
    'Hangul_WAE': 0x0ec9,
    'Hangul_OE': 0x0eca,
    'Hangul_YO': 0x0ecb,
    'Hangul_U': 0x0ecc,
    'Hangul_WEO': 0x0ecd,
    'Hangul_WE': 0x0ece,
    'Hangul_WI': 0x0ecf,
    'Hangul_YU': 0x0ed0,
    'Hangul_EU': 0x0ed1,
    'Hangul_YI': 0x0ed2,
    'Hangul_I': 0x0ed3,
    'Hangul_J_Kiyeog': 0x0ed4,
    'Hangul_J_SsangKiyeog': 0x0ed5,
    'Hangul_J_KiyeogSios': 0x0ed6,
    'Hangul_J_Nieun': 0x0ed7,
    'Hangul_J_NieunJieuj': 0x0ed8,
    'Hangul_J_NieunHieuh': 0x0ed9,
    'Hangul_J_Dikeud': 0x0eda,
    'Hangul_J_Rieul': 0x0edb,
    'Hangul_J_RieulKiyeog': 0x0edc,
    'Hangul_J_RieulMieum': 0x0edd,
    'Hangul_J_RieulPieub': 0x0ede,
    'Hangul_J_RieulSios': 0x0edf,
    'Hangul_J_RieulTieut': 0x0ee0,
    'Hangul_J_RieulPhieuf': 0x0ee1,
    'Hangul_J_RieulHieuh': 0x0ee2,
    'Hangul_J_Mieum': 0x0ee3,
    'Hangul_J_Pieub': 0x0ee4,
    'Hangul_J_PieubSios': 0x0ee5,
    'Hangul_J_Sios': 0x0ee6,
    'Hangul_J_SsangSios': 0x0ee7,
    'Hangul_J_Ieung': 0x0ee8,
    'Hangul_J_Jieuj': 0x0ee9,
    'Hangul_J_Cieuc': 0x0eea,
    'Hangul_J_Khieuq': 0x0eeb,
    'Hangul_J_Tieut': 0x0eec,
    'Hangul_J_Phieuf': 0x0eed,
    'Hangul_J_Hieuh': 0x0eee,
    'Hangul_RieulYeorinHieuh': 0x0eef,
    'Hangul_SunkyeongeumMieum': 0x0ef0,
    'Hangul_SunkyeongeumPieub': 0x0ef1,
    'Hangul_PanSios': 0x0ef2,
    'Hangul_KkogjiDalrinIeung': 0x0ef3,
    'Hangul_SunkyeongeumPhieuf': 0x0ef4,
    'Hangul_YeorinHieuh': 0x0ef5,
    'Hangul_AraeA': 0x0ef6,
    'Hangul_AraeAE': 0x0ef7,
    'Hangul_J_PanSios': 0x0ef8,
    'Hangul_J_KkogjiDalrinIeung': 0x0ef9,
    'Hangul_J_YeorinHieuh': 0x0efa,
    'Korean_Won': 0x0eff,
    'Armenian_ligature_ew': 0x1000587,
    'Armenian_full_stop': 0x1000589,
    'Armenian_verjaket': 0x1000589,
    'Armenian_separation_mark': 0x100055d,
    'Armenian_but': 0x100055d,
    'Armenian_hyphen': 0x100058a,
    'Armenian_yentamna': 0x100058a,
    'Armenian_exclam': 0x100055c,
    'Armenian_amanak': 0x100055c,
    'Armenian_accent': 0x100055b,
    'Armenian_shesht': 0x100055b,
    'Armenian_question': 0x100055e,
    'Armenian_paruyk': 0x100055e,
    'Armenian_AYB': 0x1000531,
    'Armenian_ayb': 0x1000561,
    'Armenian_BEN': 0x1000532,
    'Armenian_ben': 0x1000562,
    'Armenian_GIM': 0x1000533,
    'Armenian_gim': 0x1000563,
    'Armenian_DA': 0x1000534,
    'Armenian_da': 0x1000564,
    'Armenian_YECH': 0x1000535,
    'Armenian_yech': 0x1000565,
    'Armenian_ZA': 0x1000536,
    'Armenian_za': 0x1000566,
    'Armenian_E': 0x1000537,
    'Armenian_e': 0x1000567,
    'Armenian_AT': 0x1000538,
    'Armenian_at': 0x1000568,
    'Armenian_TO': 0x1000539,
    'Armenian_to': 0x1000569,
    'Armenian_ZHE': 0x100053a,
    'Armenian_zhe': 0x100056a,
    'Armenian_INI': 0x100053b,
    'Armenian_ini': 0x100056b,
    'Armenian_LYUN': 0x100053c,
    'Armenian_lyun': 0x100056c,
    'Armenian_KHE': 0x100053d,
    'Armenian_khe': 0x100056d,
    'Armenian_TSA': 0x100053e,
    'Armenian_tsa': 0x100056e,
    'Armenian_KEN': 0x100053f,
    'Armenian_ken': 0x100056f,
    'Armenian_HO': 0x1000540,
    'Armenian_ho': 0x1000570,
    'Armenian_DZA': 0x1000541,
    'Armenian_dza': 0x1000571,
    'Armenian_GHAT': 0x1000542,
    'Armenian_ghat': 0x1000572,
    'Armenian_TCHE': 0x1000543,
    'Armenian_tche': 0x1000573,
    'Armenian_MEN': 0x1000544,
    'Armenian_men': 0x1000574,
    'Armenian_HI': 0x1000545,
    'Armenian_hi': 0x1000575,
    'Armenian_NU': 0x1000546,
    'Armenian_nu': 0x1000576,
    'Armenian_SHA': 0x1000547,
    'Armenian_sha': 0x1000577,
    'Armenian_VO': 0x1000548,
    'Armenian_vo': 0x1000578,
    'Armenian_CHA': 0x1000549,
    'Armenian_cha': 0x1000579,
    'Armenian_PE': 0x100054a,
    'Armenian_pe': 0x100057a,
    'Armenian_JE': 0x100054b,
    'Armenian_je': 0x100057b,
    'Armenian_RA': 0x100054c,
    'Armenian_ra': 0x100057c,
    'Armenian_SE': 0x100054d,
    'Armenian_se': 0x100057d,
    'Armenian_VEV': 0x100054e,
    'Armenian_vev': 0x100057e,
    'Armenian_TYUN': 0x100054f,
    'Armenian_tyun': 0x100057f,
    'Armenian_RE': 0x1000550,
    'Armenian_re': 0x1000580,
    'Armenian_TSO': 0x1000551,
    'Armenian_tso': 0x1000581,
    'Armenian_VYUN': 0x1000552,
    'Armenian_vyun': 0x1000582,
    'Armenian_PYUR': 0x1000553,
    'Armenian_pyur': 0x1000583,
    'Armenian_KE': 0x1000554,
    'Armenian_ke': 0x1000584,
    'Armenian_O': 0x1000555,
    'Armenian_o': 0x1000585,
    'Armenian_FE': 0x1000556,
    'Armenian_fe': 0x1000586,
    'Armenian_apostrophe': 0x100055a,
    'Georgian_an': 0x10010d0,
    'Georgian_ban': 0x10010d1,
    'Georgian_gan': 0x10010d2,
    'Georgian_don': 0x10010d3,
    'Georgian_en': 0x10010d4,
    'Georgian_vin': 0x10010d5,
    'Georgian_zen': 0x10010d6,
    'Georgian_tan': 0x10010d7,
    'Georgian_in': 0x10010d8,
    'Georgian_kan': 0x10010d9,
    'Georgian_las': 0x10010da,
    'Georgian_man': 0x10010db,
    'Georgian_nar': 0x10010dc,
    'Georgian_on': 0x10010dd,
    'Georgian_par': 0x10010de,
    'Georgian_zhar': 0x10010df,
    'Georgian_rae': 0x10010e0,
    'Georgian_san': 0x10010e1,
    'Georgian_tar': 0x10010e2,
    'Georgian_un': 0x10010e3,
    'Georgian_phar': 0x10010e4,
    'Georgian_khar': 0x10010e5,
    'Georgian_ghan': 0x10010e6,
    'Georgian_qar': 0x10010e7,
    'Georgian_shin': 0x10010e8,
    'Georgian_chin': 0x10010e9,
    'Georgian_can': 0x10010ea,
    'Georgian_jil': 0x10010eb,
    'Georgian_cil': 0x10010ec,
    'Georgian_char': 0x10010ed,
    'Georgian_xan': 0x10010ee,
    'Georgian_jhan': 0x10010ef,
    'Georgian_hae': 0x10010f0,
    'Georgian_he': 0x10010f1,
    'Georgian_hie': 0x10010f2,
    'Georgian_we': 0x10010f3,
    'Georgian_har': 0x10010f4,
    'Georgian_hoe': 0x10010f5,
    'Georgian_fi': 0x10010f6,
    'Xabovedot': 0x1001e8a,
    'Ibreve': 0x100012c,
    'Zstroke': 0x10001b5,
    'Gcaron': 0x10001e6,
    'Ocaron': 0x10001d1,
    'Obarred': 0x100019f,
    'xabovedot': 0x1001e8b,
    'ibreve': 0x100012d,
    'zstroke': 0x10001b6,
    'gcaron': 0x10001e7,
    'ocaron': 0x10001d2,
    'obarred': 0x1000275,
    'SCHWA': 0x100018f,
    'schwa': 0x1000259,
    'Lbelowdot': 0x1001e36,
    'lbelowdot': 0x1001e37,
    'Abelowdot': 0x1001ea0,
    'abelowdot': 0x1001ea1,
    'Ahook': 0x1001ea2,
    'ahook': 0x1001ea3,
    'Acircumflexacute': 0x1001ea4,
    'acircumflexacute': 0x1001ea5,
    'Acircumflexgrave': 0x1001ea6,
    'acircumflexgrave': 0x1001ea7,
    'Acircumflexhook': 0x1001ea8,
    'acircumflexhook': 0x1001ea9,
    'Acircumflextilde': 0x1001eaa,
    'acircumflextilde': 0x1001eab,
    'Acircumflexbelowdot': 0x1001eac,
    'acircumflexbelowdot': 0x1001ead,
    'Abreveacute': 0x1001eae,
    'abreveacute': 0x1001eaf,
    'Abrevegrave': 0x1001eb0,
    'abrevegrave': 0x1001eb1,
    'Abrevehook': 0x1001eb2,
    'abrevehook': 0x1001eb3,
    'Abrevetilde': 0x1001eb4,
    'abrevetilde': 0x1001eb5,
    'Abrevebelowdot': 0x1001eb6,
    'abrevebelowdot': 0x1001eb7,
    'Ebelowdot': 0x1001eb8,
    'ebelowdot': 0x1001eb9,
    'Ehook': 0x1001eba,
    'ehook': 0x1001ebb,
    'Etilde': 0x1001ebc,
    'etilde': 0x1001ebd,
    'Ecircumflexacute': 0x1001ebe,
    'ecircumflexacute': 0x1001ebf,
    'Ecircumflexgrave': 0x1001ec0,
    'ecircumflexgrave': 0x1001ec1,
    'Ecircumflexhook': 0x1001ec2,
    'ecircumflexhook': 0x1001ec3,
    'Ecircumflextilde': 0x1001ec4,
    'ecircumflextilde': 0x1001ec5,
    'Ecircumflexbelowdot': 0x1001ec6,
    'ecircumflexbelowdot': 0x1001ec7,
    'Ihook': 0x1001ec8,
    'ihook': 0x1001ec9,
    'Ibelowdot': 0x1001eca,
    'ibelowdot': 0x1001ecb,
    'Obelowdot': 0x1001ecc,
    'obelowdot': 0x1001ecd,
    'Ohook': 0x1001ece,
    'ohook': 0x1001ecf,
    'Ocircumflexacute': 0x1001ed0,
    'ocircumflexacute': 0x1001ed1,
    'Ocircumflexgrave': 0x1001ed2,
    'ocircumflexgrave': 0x1001ed3,
    'Ocircumflexhook': 0x1001ed4,
    'ocircumflexhook': 0x1001ed5,
    'Ocircumflextilde': 0x1001ed6,
    'ocircumflextilde': 0x1001ed7,
    'Ocircumflexbelowdot': 0x1001ed8,
    'ocircumflexbelowdot': 0x1001ed9,
    'Ohornacute': 0x1001eda,
    'ohornacute': 0x1001edb,
    'Ohorngrave': 0x1001edc,
    'ohorngrave': 0x1001edd,
    'Ohornhook': 0x1001ede,
    'ohornhook': 0x1001edf,
    'Ohorntilde': 0x1001ee0,
    'ohorntilde': 0x1001ee1,
    'Ohornbelowdot': 0x1001ee2,
    'ohornbelowdot': 0x1001ee3,
    'Ubelowdot': 0x1001ee4,
    'ubelowdot': 0x1001ee5,
    'Uhook': 0x1001ee6,
    'uhook': 0x1001ee7,
    'Uhornacute': 0x1001ee8,
    'uhornacute': 0x1001ee9,
    'Uhorngrave': 0x1001eea,
    'uhorngrave': 0x1001eeb,
    'Uhornhook': 0x1001eec,
    'uhornhook': 0x1001eed,
    'Uhorntilde': 0x1001eee,
    'uhorntilde': 0x1001eef,
    'Uhornbelowdot': 0x1001ef0,
    'uhornbelowdot': 0x1001ef1,
    'Ybelowdot': 0x1001ef4,
    'ybelowdot': 0x1001ef5,
    'Yhook': 0x1001ef6,
    'yhook': 0x1001ef7,
    'Ytilde': 0x1001ef8,
    'ytilde': 0x1001ef9,
    'Ohorn': 0x10001a0,
    'ohorn': 0x10001a1,
    'Uhorn': 0x10001af,
    'uhorn': 0x10001b0,
    'EcuSign': 0x10020a0,
    'ColonSign': 0x10020a1,
    'CruzeiroSign': 0x10020a2,
    'FFrancSign': 0x10020a3,
    'LiraSign': 0x10020a4,
    'MillSign': 0x10020a5,
    'NairaSign': 0x10020a6,
    'PesetaSign': 0x10020a7,
    'RupeeSign': 0x10020a8,
    'WonSign': 0x10020a9,
    'NewSheqelSign': 0x10020aa,
    'DongSign': 0x10020ab,
    'EuroSign': 0x20ac,
    'zerosuperior': 0x1002070,
    'foursuperior': 0x1002074,
    'fivesuperior': 0x1002075,
    'sixsuperior': 0x1002076,
    'sevensuperior': 0x1002077,
    'eightsuperior': 0x1002078,
    'ninesuperior': 0x1002079,
    'zerosubscript': 0x1002080,
    'onesubscript': 0x1002081,
    'twosubscript': 0x1002082,
    'threesubscript': 0x1002083,
    'foursubscript': 0x1002084,
    'fivesubscript': 0x1002085,
    'sixsubscript': 0x1002086,
    'sevensubscript': 0x1002087,
    'eightsubscript': 0x1002088,
    'ninesubscript': 0x1002089,
    'partdifferential': 0x1002202,
    'emptyset': 0x1002205,
    'elementof': 0x1002208,
    'notelementof': 0x1002209,
    'containsas': 0x100220B,
    'squareroot': 0x100221A,
    'cuberoot': 0x100221B,
    'fourthroot': 0x100221C,
    'dintegral': 0x100222C,
    'tintegral': 0x100222D,
    'because': 0x1002235,
    'approxeq': 0x1002248,
    'notapproxeq': 0x1002247,
    'notidentical': 0x1002262,
    'stricteq': 0x1002263,
    'braille_dot_1': 0xfff1,
    'braille_dot_2': 0xfff2,
    'braille_dot_3': 0xfff3,
    'braille_dot_4': 0xfff4,
    'braille_dot_5': 0xfff5,
    'braille_dot_6': 0xfff6,
    'braille_dot_7': 0xfff7,
    'braille_dot_8': 0xfff8,
    'braille_dot_9': 0xfff9,
    'braille_dot_10': 0xfffa,
    'braille_blank': 0x1002800,
    'braille_dots_1': 0x1002801,
    'braille_dots_2': 0x1002802,
    'braille_dots_12': 0x1002803,
    'braille_dots_3': 0x1002804,
    'braille_dots_13': 0x1002805,
    'braille_dots_23': 0x1002806,
    'braille_dots_123': 0x1002807,
    'braille_dots_4': 0x1002808,
    'braille_dots_14': 0x1002809,
    'braille_dots_24': 0x100280a,
    'braille_dots_124': 0x100280b,
    'braille_dots_34': 0x100280c,
    'braille_dots_134': 0x100280d,
    'braille_dots_234': 0x100280e,
    'braille_dots_1234': 0x100280f,
    'braille_dots_5': 0x1002810,
    'braille_dots_15': 0x1002811,
    'braille_dots_25': 0x1002812,
    'braille_dots_125': 0x1002813,
    'braille_dots_35': 0x1002814,
    'braille_dots_135': 0x1002815,
    'braille_dots_235': 0x1002816,
    'braille_dots_1235': 0x1002817,
    'braille_dots_45': 0x1002818,
    'braille_dots_145': 0x1002819,
    'braille_dots_245': 0x100281a,
    'braille_dots_1245': 0x100281b,
    'braille_dots_345': 0x100281c,
    'braille_dots_1345': 0x100281d,
    'braille_dots_2345': 0x100281e,
    'braille_dots_12345': 0x100281f,
    'braille_dots_6': 0x1002820,
    'braille_dots_16': 0x1002821,
    'braille_dots_26': 0x1002822,
    'braille_dots_126': 0x1002823,
    'braille_dots_36': 0x1002824,
    'braille_dots_136': 0x1002825,
    'braille_dots_236': 0x1002826,
    'braille_dots_1236': 0x1002827,
    'braille_dots_46': 0x1002828,
    'braille_dots_146': 0x1002829,
    'braille_dots_246': 0x100282a,
    'braille_dots_1246': 0x100282b,
    'braille_dots_346': 0x100282c,
    'braille_dots_1346': 0x100282d,
    'braille_dots_2346': 0x100282e,
    'braille_dots_12346': 0x100282f,
    'braille_dots_56': 0x1002830,
    'braille_dots_156': 0x1002831,
    'braille_dots_256': 0x1002832,
    'braille_dots_1256': 0x1002833,
    'braille_dots_356': 0x1002834,
    'braille_dots_1356': 0x1002835,
    'braille_dots_2356': 0x1002836,
    'braille_dots_12356': 0x1002837,
    'braille_dots_456': 0x1002838,
    'braille_dots_1456': 0x1002839,
    'braille_dots_2456': 0x100283a,
    'braille_dots_12456': 0x100283b,
    'braille_dots_3456': 0x100283c,
    'braille_dots_13456': 0x100283d,
    'braille_dots_23456': 0x100283e,
    'braille_dots_123456': 0x100283f,
    'braille_dots_7': 0x1002840,
    'braille_dots_17': 0x1002841,
    'braille_dots_27': 0x1002842,
    'braille_dots_127': 0x1002843,
    'braille_dots_37': 0x1002844,
    'braille_dots_137': 0x1002845,
    'braille_dots_237': 0x1002846,
    'braille_dots_1237': 0x1002847,
    'braille_dots_47': 0x1002848,
    'braille_dots_147': 0x1002849,
    'braille_dots_247': 0x100284a,
    'braille_dots_1247': 0x100284b,
    'braille_dots_347': 0x100284c,
    'braille_dots_1347': 0x100284d,
    'braille_dots_2347': 0x100284e,
    'braille_dots_12347': 0x100284f,
    'braille_dots_57': 0x1002850,
    'braille_dots_157': 0x1002851,
    'braille_dots_257': 0x1002852,
    'braille_dots_1257': 0x1002853,
    'braille_dots_357': 0x1002854,
    'braille_dots_1357': 0x1002855,
    'braille_dots_2357': 0x1002856,
    'braille_dots_12357': 0x1002857,
    'braille_dots_457': 0x1002858,
    'braille_dots_1457': 0x1002859,
    'braille_dots_2457': 0x100285a,
    'braille_dots_12457': 0x100285b,
    'braille_dots_3457': 0x100285c,
    'braille_dots_13457': 0x100285d,
    'braille_dots_23457': 0x100285e,
    'braille_dots_123457': 0x100285f,
    'braille_dots_67': 0x1002860,
    'braille_dots_167': 0x1002861,
    'braille_dots_267': 0x1002862,
    'braille_dots_1267': 0x1002863,
    'braille_dots_367': 0x1002864,
    'braille_dots_1367': 0x1002865,
    'braille_dots_2367': 0x1002866,
    'braille_dots_12367': 0x1002867,
    'braille_dots_467': 0x1002868,
    'braille_dots_1467': 0x1002869,
    'braille_dots_2467': 0x100286a,
    'braille_dots_12467': 0x100286b,
    'braille_dots_3467': 0x100286c,
    'braille_dots_13467': 0x100286d,
    'braille_dots_23467': 0x100286e,
    'braille_dots_123467': 0x100286f,
    'braille_dots_567': 0x1002870,
    'braille_dots_1567': 0x1002871,
    'braille_dots_2567': 0x1002872,
    'braille_dots_12567': 0x1002873,
    'braille_dots_3567': 0x1002874,
    'braille_dots_13567': 0x1002875,
    'braille_dots_23567': 0x1002876,
    'braille_dots_123567': 0x1002877,
    'braille_dots_4567': 0x1002878,
    'braille_dots_14567': 0x1002879,
    'braille_dots_24567': 0x100287a,
    'braille_dots_124567': 0x100287b,
    'braille_dots_34567': 0x100287c,
    'braille_dots_134567': 0x100287d,
    'braille_dots_234567': 0x100287e,
    'braille_dots_1234567': 0x100287f,
    'braille_dots_8': 0x1002880,
    'braille_dots_18': 0x1002881,
    'braille_dots_28': 0x1002882,
    'braille_dots_128': 0x1002883,
    'braille_dots_38': 0x1002884,
    'braille_dots_138': 0x1002885,
    'braille_dots_238': 0x1002886,
    'braille_dots_1238': 0x1002887,
    'braille_dots_48': 0x1002888,
    'braille_dots_148': 0x1002889,
    'braille_dots_248': 0x100288a,
    'braille_dots_1248': 0x100288b,
    'braille_dots_348': 0x100288c,
    'braille_dots_1348': 0x100288d,
    'braille_dots_2348': 0x100288e,
    'braille_dots_12348': 0x100288f,
    'braille_dots_58': 0x1002890,
    'braille_dots_158': 0x1002891,
    'braille_dots_258': 0x1002892,
    'braille_dots_1258': 0x1002893,
    'braille_dots_358': 0x1002894,
    'braille_dots_1358': 0x1002895,
    'braille_dots_2358': 0x1002896,
    'braille_dots_12358': 0x1002897,
    'braille_dots_458': 0x1002898,
    'braille_dots_1458': 0x1002899,
    'braille_dots_2458': 0x100289a,
    'braille_dots_12458': 0x100289b,
    'braille_dots_3458': 0x100289c,
    'braille_dots_13458': 0x100289d,
    'braille_dots_23458': 0x100289e,
    'braille_dots_123458': 0x100289f,
    'braille_dots_68': 0x10028a0,
    'braille_dots_168': 0x10028a1,
    'braille_dots_268': 0x10028a2,
    'braille_dots_1268': 0x10028a3,
    'braille_dots_368': 0x10028a4,
    'braille_dots_1368': 0x10028a5,
    'braille_dots_2368': 0x10028a6,
    'braille_dots_12368': 0x10028a7,
    'braille_dots_468': 0x10028a8,
    'braille_dots_1468': 0x10028a9,
    'braille_dots_2468': 0x10028aa,
    'braille_dots_12468': 0x10028ab,
    'braille_dots_3468': 0x10028ac,
    'braille_dots_13468': 0x10028ad,
    'braille_dots_23468': 0x10028ae,
    'braille_dots_123468': 0x10028af,
    'braille_dots_568': 0x10028b0,
    'braille_dots_1568': 0x10028b1,
    'braille_dots_2568': 0x10028b2,
    'braille_dots_12568': 0x10028b3,
    'braille_dots_3568': 0x10028b4,
    'braille_dots_13568': 0x10028b5,
    'braille_dots_23568': 0x10028b6,
    'braille_dots_123568': 0x10028b7,
    'braille_dots_4568': 0x10028b8,
    'braille_dots_14568': 0x10028b9,
    'braille_dots_24568': 0x10028ba,
    'braille_dots_124568': 0x10028bb,
    'braille_dots_34568': 0x10028bc,
    'braille_dots_134568': 0x10028bd,
    'braille_dots_234568': 0x10028be,
    'braille_dots_1234568': 0x10028bf,
    'braille_dots_78': 0x10028c0,
    'braille_dots_178': 0x10028c1,
    'braille_dots_278': 0x10028c2,
    'braille_dots_1278': 0x10028c3,
    'braille_dots_378': 0x10028c4,
    'braille_dots_1378': 0x10028c5,
    'braille_dots_2378': 0x10028c6,
    'braille_dots_12378': 0x10028c7,
    'braille_dots_478': 0x10028c8,
    'braille_dots_1478': 0x10028c9,
    'braille_dots_2478': 0x10028ca,
    'braille_dots_12478': 0x10028cb,
    'braille_dots_3478': 0x10028cc,
    'braille_dots_13478': 0x10028cd,
    'braille_dots_23478': 0x10028ce,
    'braille_dots_123478': 0x10028cf,
    'braille_dots_578': 0x10028d0,
    'braille_dots_1578': 0x10028d1,
    'braille_dots_2578': 0x10028d2,
    'braille_dots_12578': 0x10028d3,
    'braille_dots_3578': 0x10028d4,
    'braille_dots_13578': 0x10028d5,
    'braille_dots_23578': 0x10028d6,
    'braille_dots_123578': 0x10028d7,
    'braille_dots_4578': 0x10028d8,
    'braille_dots_14578': 0x10028d9,
    'braille_dots_24578': 0x10028da,
    'braille_dots_124578': 0x10028db,
    'braille_dots_34578': 0x10028dc,
    'braille_dots_134578': 0x10028dd,
    'braille_dots_234578': 0x10028de,
    'braille_dots_1234578': 0x10028df,
    'braille_dots_678': 0x10028e0,
    'braille_dots_1678': 0x10028e1,
    'braille_dots_2678': 0x10028e2,
    'braille_dots_12678': 0x10028e3,
    'braille_dots_3678': 0x10028e4,
    'braille_dots_13678': 0x10028e5,
    'braille_dots_23678': 0x10028e6,
    'braille_dots_123678': 0x10028e7,
    'braille_dots_4678': 0x10028e8,
    'braille_dots_14678': 0x10028e9,
    'braille_dots_24678': 0x10028ea,
    'braille_dots_124678': 0x10028eb,
    'braille_dots_34678': 0x10028ec,
    'braille_dots_134678': 0x10028ed,
    'braille_dots_234678': 0x10028ee,
    'braille_dots_1234678': 0x10028ef,
    'braille_dots_5678': 0x10028f0,
    'braille_dots_15678': 0x10028f1,
    'braille_dots_25678': 0x10028f2,
    'braille_dots_125678': 0x10028f3,
    'braille_dots_35678': 0x10028f4,
    'braille_dots_135678': 0x10028f5,
    'braille_dots_235678': 0x10028f6,
    'braille_dots_1235678': 0x10028f7,
    'braille_dots_45678': 0x10028f8,
    'braille_dots_145678': 0x10028f9,
    'braille_dots_245678': 0x10028fa,
    'braille_dots_1245678': 0x10028fb,
    'braille_dots_345678': 0x10028fc,
    'braille_dots_1345678': 0x10028fd,
    'braille_dots_2345678': 0x10028fe,
    'braille_dots_12345678': 0x10028ff,
}

########NEW FILE########
__FILENAME__ = basic
from libqtile import config

keys = [
    config.Key(["control"], "k", "focusnext")
]

screens = []
layouts = []
groups = []

########NEW FILE########
__FILENAME__ = syntaxerr


sdf [

########NEW FILE########
__FILENAME__ = window
#!/usr/bin/env python2
"""
    This program is carefully crafted to exercise a number of corner-cases in
    Qtile.
"""
import sys
import time
from Xlib import display, error, X, protocol
from StringIO import StringIO


def configure(window):
    window.configure(
        width=100,
        height=100,
        x=0,
        y=0,
        border_width=1,
    )

for i in range(20):
    try:
        # Remove useless lib print
        stdout, sys.stdout = sys.stdout, StringIO()
        d = display.Display(sys.argv[1])
        sys.stdout = stdout

    except error.DisplayConnectionError:
        time.sleep(0.1)
        continue
    except Exception as v:
        print >> sys.stderr, "Error opening test window: ", type(v), v
        sys.exit(1)
    break
else:
    print >> sys.stderr, "Could not open window on display %s" % (sys.argv[1])
    sys.exit(1)


root = d.screen().root
colormap = d.screen().default_colormap
background = colormap.alloc_named_color("#2883CE").pixel
window = root.create_window(100, 100, 100, 100, 1,
                            X.CopyFromParent, X.InputOutput,
                            X.CopyFromParent,
                            background_pixel=background,
                            event_mask=X.StructureNotifyMask | X.ExposureMask)
window.set_wm_name(sys.argv[2])
window.set_wm_protocols([d.intern_atom("WM_DELETE_WINDOW")])

configure(window)
window.map()
d.sync()
configure(window)


try:
    while 1:
        event = d.next_event()
        if event.__class__ == protocol.event.ClientMessage:
            if d.get_atom_name(event.data[1][0]) == "WM_DELETE_WINDOW":
                sys.exit(1)
except error.ConnectionClosedError:
    pass

########NEW FILE########
__FILENAME__ = test_bar
import time
import libqtile.layout
import libqtile.bar
import libqtile.widget
import libqtile.manager
import libqtile.config
import libqtile.confreader
from utils import Xephyr


class GBConfig:
    auto_fullscreen = True
    keys = []
    mouse = []
    groups = [
        libqtile.config.Group("a"),
        libqtile.config.Group("bb"),
        libqtile.config.Group("ccc"),
        libqtile.config.Group("dddd"),
        libqtile.config.Group("Pppy")
    ]
    layouts = [libqtile.layout.stack.Stack(num_stacks=1)]
    floating_layout = libqtile.layout.floating.Floating()
    screens = [
        libqtile.config.Screen(
            top=libqtile.bar.Bar(
                    [
                        libqtile.widget.CPUGraph(
                            width=libqtile.bar.STRETCH,
                            type="linefill",
                            border_width=20,
                            margin_x=1,
                            margin_y=1
                        ),
                        libqtile.widget.MemoryGraph(type="line"),
                        libqtile.widget.SwapGraph(type="box"),
                        libqtile.widget.TextBox(name="text", background="333333"),
                    ],
                    50,
                ),
            bottom=libqtile.bar.Bar(
                        [
                            libqtile.widget.GroupBox(),
                            libqtile.widget.AGroupBox(),
                            libqtile.widget.Prompt(),
                            libqtile.widget.WindowName(),
                            libqtile.widget.Sep(),
                            libqtile.widget.Clock(),
                        ],
                        50
                    ),
        )
    ]
    main = None


def test_completion():
    c = libqtile.widget.prompt.CommandCompleter(None, True)
    c.reset()
    c.lookup = [
        ("a", "x/a"),
        ("aa", "x/aa"),
    ]
    assert c.complete("a") == "a"
    assert c.actual() == "x/a"
    assert c.complete("a") == "aa"
    assert c.complete("a") == "a"

    c = libqtile.widget.prompt.CommandCompleter(None)
    r = c.complete("l")
    assert c.actual().endswith(r)

    c.reset()
    assert c.complete("/bi") == "/bin/"
    c.reset()
    assert c.complete("/bin") != "/bin/"
    c.reset()
    assert c.complete("~") != "~"

    c.reset()
    s = "thisisatotallynonexistantpathforsure"
    assert c.complete(s) == s
    assert c.actual() == s


@Xephyr(True, GBConfig())
def test_draw(self):
    self.testWindow("one")
    b = self.c.bar["bottom"].info()
    assert b["widgets"][0]["name"] == "GroupBox"


@Xephyr(True, GBConfig())
def test_prompt(self):
    assert self.c.widget["prompt"].info()["width"] == 0
    self.c.spawncmd(":")
    self.c.widget["prompt"].fake_keypress("a")
    self.c.widget["prompt"].fake_keypress("Tab")

    self.c.spawncmd(":")
    self.c.widget["prompt"].fake_keypress("slash")
    self.c.widget["prompt"].fake_keypress("Tab")


@Xephyr(True, GBConfig())
def test_event(self):
    self.c.group["bb"].toscreen()


@Xephyr(True, GBConfig())
def test_textbox(self):
    assert "text" in self.c.list_widgets()
    s = "some text"
    self.c.widget["text"].update(s)
    assert self.c.widget["text"].get() == s
    s = "Aye, much longer string than the initial one"
    self.c.widget["text"].update(s)
    assert self.c.widget["text"].get() == s
    self.c.group["Pppy"].toscreen()
    self.c.widget["text"].set_font(fontsize=12)
    time.sleep(3)


@Xephyr(True, GBConfig())
def test_textbox_errors(self):
    self.c.widget["text"].update(None)
    self.c.widget["text"].update("".join(chr(i) for i in range(255)))
    self.c.widget["text"].update("V\xE2r\xE2na\xE7\xEE")
    self.c.widget["text"].update(u"\ua000")


@Xephyr(True, GBConfig())
def test_groupbox_button_press(self):
    self.c.group["ccc"].toscreen()
    assert self.c.groups()["a"]["screen"] == None
    self.c.bar["bottom"].fake_button_press(0, "bottom", 10, 10, 1)
    assert self.c.groups()["a"]["screen"] == 0


class GeomConf:
    auto_fullscreen = False
    main = None
    keys = []
    mouse = []
    groups = [
        libqtile.config.Group("a"),
        libqtile.config.Group("b"),
        libqtile.config.Group("c"),
        libqtile.config.Group("d")
    ]
    layouts = [libqtile.layout.stack.Stack(num_stacks=1)]
    floating_layout = libqtile.layout.floating.Floating()
    screens = [
        libqtile.config.Screen(
            left=libqtile.bar.Gap(10),
            right=libqtile.bar.Gap(10),
            top=libqtile.bar.Bar([], 10),
            bottom=libqtile.bar.Bar([], 10),
        )
    ]


class DWidget:
    def __init__(self, width, width_type):
        self.width, self.width_type = width, width_type


@Xephyr(True, GeomConf())
def test_geometry(self):
    self.testXeyes()
    g = self.c.screens()[0]["gaps"]
    assert g["top"] == (0, 0, 800, 10)
    assert g["bottom"] == (0, 590, 800, 10)
    assert g["left"] == (0, 10, 10, 580)
    assert g["right"] == (790, 10, 10, 580)
    assert len(self.c.windows()) == 1
    geom = self.c.windows()[0]
    assert geom["x"] == 10
    assert geom["y"] == 10
    assert geom["width"] == 778
    assert geom["height"] == 578
    internal = self.c.internal_windows()
    assert len(internal) == 2
    wid = self.c.bar["bottom"].info()["window"]
    assert self.c.window[wid].inspect()


@Xephyr(True, GeomConf())
def test_resize(self):
    def wd(l):
        return [i.width for i in l]

    def off(l):
        return [i.offset for i in l]

    b = libqtile.bar.Bar([], 100)

    l = [
        DWidget(10, libqtile.bar.CALCULATED),
        DWidget(None, libqtile.bar.STRETCH),
        DWidget(None, libqtile.bar.STRETCH),
        DWidget(10, libqtile.bar.CALCULATED),
    ]
    b._resize(100, l)
    assert wd(l) == [10, 40, 40, 10]

    b._resize(101, l)
    assert wd(l) == [10, 40, 41, 10]

    l = [
        DWidget(10, libqtile.bar.CALCULATED)
    ]
    b._resize(100, l)
    assert wd(l) == [10]
    assert off(l) == [0]

    l = [
        DWidget(10, libqtile.bar.CALCULATED),
        DWidget(None, libqtile.bar.STRETCH)
    ]
    b._resize(100, l)
    assert wd(l) == [10, 90]
    assert off(l) == [0, 10]

    l = [
        DWidget(None, libqtile.bar.STRETCH),
        DWidget(10, libqtile.bar.CALCULATED),
    ]
    b._resize(100, l)
    assert wd(l) == [90, 10]
    assert off(l) == [0, 90]

    l = [
        DWidget(10, libqtile.bar.CALCULATED),
        DWidget(None, libqtile.bar.STRETCH),
        DWidget(10, libqtile.bar.CALCULATED),
    ]
    b._resize(100, l)
    assert wd(l) == [10, 80, 10]
    assert off(l) == [0, 10, 90]


class TopBottomConf(GeomConf):
    screens = [
        libqtile.config.Screen(left=libqtile.bar.Bar([], 10))
    ]

class MultiStretchConf(GeomConf):
    screens = [
        libqtile.config.Screen(top=libqtile.bar.Bar([
          libqtile.widget.TextBox(name=txt, width=libqtile.bar.STRETCH)
          for txt in ["text1", "text2"]
        ], 10))
    ]

class ErrConf:
    main = None
    keys = []
    mouse = []
    groups = [libqtile.config.Group("a")]
    layouts = [libqtile.layout.stack.Stack(num_stacks=1)]
    floating_layout = libqtile.layout.floating.Floating()
    screens = [
        libqtile.config.Screen(
            left=libqtile.bar.Bar([], 10),
        )
    ]


@Xephyr(True, ErrConf(), False)
def test_err(self):
    self.qtileRaises(libqtile.confreader.ConfigError, ErrConf())


class TestWidget(libqtile.widget.base._Widget):
    def __init__(self):
        libqtile.widget.base._Widget.__init__(self, 10)

    def _configure(self, qtile, bar):
        libqtile.widget.base._Widget._configure(self, qtile, bar)

    def draw(self):
        pass


@Xephyr(True, GeomConf(), False)
def test_basic(self):
    self.config.screens = [
        libqtile.config.Screen(
            bottom=libqtile.bar.Bar(
                [
                    TestWidget(),
                    libqtile.widget.Spacer(libqtile.bar.STRETCH),
                    TestWidget()
                ],
                10
            )
        )
    ]
    self.startQtile(self.config)
    i = self.c.bar["bottom"].info()
    assert i["widgets"][0]["offset"] == 0
    assert i["widgets"][1]["offset"] == 10
    assert i["widgets"][1]["width"] == 780
    assert i["widgets"][2]["offset"] == 790
    libqtile.hook.clear()
    self.stopQtile()


@Xephyr(True, GeomConf(), False)
def test_singlespacer(self):
    self.config.screens = [
        libqtile.config.Screen(
            bottom=libqtile.bar.Bar(
                [
                    libqtile.widget.Spacer(libqtile.bar.STRETCH),
                ],
                10
            )
        )
    ]
    self.startQtile(self.config)
    i = self.c.bar["bottom"].info()
    assert i["widgets"][0]["offset"] == 0
    assert i["widgets"][0]["width"] == 800
    libqtile.hook.clear()
    self.stopQtile()


@Xephyr(True, GeomConf(), False)
def test_nospacer(self):
    self.config.screens = [
        libqtile.config.Screen(
            bottom=libqtile.bar.Bar(
                [
                    TestWidget(),
                    TestWidget()
                ],
                10
            )
        )
    ]
    self.startQtile(self.config)
    i = self.c.bar["bottom"].info()
    assert i["widgets"][0]["offset"] == 0
    assert i["widgets"][1]["offset"] == 10
    libqtile.hook.clear()
    self.stopQtile()

########NEW FILE########
__FILENAME__ = test_command
import libqtile
import libqtile.confreader
import libqtile.manager
import libqtile.config
import libqtile.layout
import libqtile.bar
import libqtile.widget
from utils import Xephyr
from nose.tools import assert_raises


class CallConfig(object):
    keys = [
        libqtile.config.Key(
            ["control"], "j",
            libqtile.command._Call([("layout", None)], "down")
        ),
        libqtile.config.Key(
            ["control"], "k",
            libqtile.command._Call([("layout", None)], "up"),
        ),
    ]
    mouse = []
    groups = [
        libqtile.config.Group("a"),
        libqtile.config.Group("b"),
    ]
    layouts = [
        libqtile.layout.Stack(num_stacks=1),
        libqtile.layout.Max(),
    ]
    floating_layout = libqtile.layout.floating.Floating()
    screens = [
        libqtile.config.Screen(
            bottom=libqtile.bar.Bar(
                        [
                            libqtile.widget.GroupBox(),
                        ],
                        20
                    ),
        )
    ]
    main = None
    auto_fullscreen = True


@Xephyr(True, CallConfig())
def test_layout_filter(self):
    self.testWindow("one")
    self.testWindow("two")
    assert self.c.groups()["a"]["focus"] == "two"
    self.c.simulate_keypress(["control"], "j")
    assert self.c.groups()["a"]["focus"] == "one"
    self.c.simulate_keypress(["control"], "k")
    assert self.c.groups()["a"]["focus"] == "two"


class TestCommands(libqtile.command.CommandObject):
    @staticmethod
    def cmd_one():
        pass

    def cmd_one_self(self):
        pass

    def cmd_two(self, a):
        pass

    def cmd_three(self, a, b=99):
        pass


def test_doc():
    c = TestCommands()
    assert "one()" in c.doc("one")
    assert "one_self()" in c.doc("one_self")
    assert "two(a)" in c.doc("two")
    assert "three(a, b=99)" in c.doc("three")


def test_commands():
    c = TestCommands()
    assert len(c.commands()) == 7


def test_command():
    c = TestCommands()
    assert c.command("one")
    assert not c.command("nonexistent")


class TestCmdRoot(libqtile.command._CommandRoot):
    def call(self, *args):
        return args


def test_selectors():
    c = libqtile.command._CommandRoot()

    s = c.layout.screen.info
    assert s.selectors == [('layout', None), ('screen', None)]

    assert isinstance(c.info, libqtile.command._Command)

    g = c.group
    assert isinstance(g, libqtile.command._TGroup)
    assert g.myselector == None

    g = c.group["one"]
    assert isinstance(g, libqtile.command._TGroup)
    assert g.myselector == "one"

    cmd = c.group["one"].foo
    assert cmd.name == "foo"
    assert cmd.selectors == [('group', 'one')]

    g = c.group["two"].layout["three"].screen
    assert g.selectors == [('group', 'two'), ('layout', 'three')]

    g = c.one
    assert g.selectors == []


class ServerConfig(object):
    auto_fullscreen = True
    keys = []
    mouse = []
    groups = [
        libqtile.config.Group("a"),
        libqtile.config.Group("b"),
        libqtile.config.Group("c"),
    ]
    layouts = [
        libqtile.layout.Stack(num_stacks=1),
        libqtile.layout.Stack(num_stacks=2),
        libqtile.layout.Stack(num_stacks=3),
    ]
    floating_layout = libqtile.layout.floating.Floating()
    screens = [
        libqtile.config.Screen(
            bottom=libqtile.bar.Bar(
                        [
                            libqtile.widget.TextBox(name="one"),
                        ],
                        20
                    ),
        ),
        libqtile.config.Screen(
            bottom=libqtile.bar.Bar(
                        [
                            libqtile.widget.TextBox(name="two"),
                        ],
                        20
                    ),
        )
    ]
    main = None


@Xephyr(True, ServerConfig())
def test_cmd_commands(self):
    assert self.c.commands()
    assert self.c.layout.commands()
    assert self.c.screen.bar["bottom"].commands()


@Xephyr(True, ServerConfig())
def test_call_unknown(self):
    assert_raises(libqtile.command.CommandError, self.c.nonexistent)
    assert_raises(libqtile.command.CommandError, self.c.layout.nonexistent)


@Xephyr(True, ServerConfig())
def test_items_qtile(self):
    v = self.c.items("group")
    assert v[0]
    assert sorted(v[1]) == ["a", "b", "c"]

    assert self.c.items("layout") == (True, [0, 1, 2])

    v = self.c.items("widget")
    assert not v[0]
    assert sorted(v[1]) == ['one', 'two']

    assert self.c.items("bar") == (False, ["bottom"])
    t, lst = self.c.items("window")
    assert t
    assert len(lst) == 2
    assert self.c.window[lst[0]]
    assert self.c.items("screen") == (True, [0, 1])


@Xephyr(True, ServerConfig())
def test_select_qtile(self):
    assert self.c.foo.selectors == []
    assert self.c.layout.info()["group"] == "a"
    assert len(self.c.layout.info()["stacks"]) == 1
    assert len(self.c.layout[2].info()["stacks"]) == 3
    assert_raises(libqtile.command.CommandError, self.c.layout[99].info)

    assert self.c.group.info()["name"] == "a"
    assert self.c.group["c"].info()["name"] == "c"
    assert_raises(
        libqtile.command.CommandError, self.c.group["nonexistent"].info)

    assert self.c.widget["one"].info()["name"] == "one"
    assert_raises(libqtile.command.CommandError, self.c.widget.info)

    assert self.c.bar["bottom"].info()["position"] == "bottom"

    win = self.testWindow("one")
    wid = self.c.window.info()["id"]
    assert self.c.window[wid].info()["id"] == wid

    assert self.c.screen.info()["index"] == 0
    assert self.c.screen[1].info()["index"] == 1
    assert_raises(libqtile.command.CommandError, self.c.screen[22].info)
    assert_raises(libqtile.command.CommandError, self.c.screen["foo"].info)


@Xephyr(True, ServerConfig())
def test_items_group(self):
    g = self.c.group
    assert g.items("layout") == (True, [0, 1, 2])

    win = self.testWindow("test")
    wid = self.c.window.info()["id"]
    assert g.items("window") == (True, [wid])

    assert g.items("screen") == (True, None)


@Xephyr(True, ServerConfig())
def test_select_group(self):
    g = self.c.group
    assert g.layout.info()["group"] == "a"
    assert len(g.layout.info()["stacks"]) == 1
    assert len(g.layout[2].info()["stacks"]) == 3

    assert_raises(libqtile.command.CommandError, self.c.group.window.info)
    win = self.testWindow("test")
    wid = self.c.window.info()["id"]

    assert g.window.info()["id"] == wid
    assert g.window[wid].info()["id"] == wid
    assert_raises(libqtile.command.CommandError, g.window["foo"].info)

    assert g.screen.info()["index"] == 0
    assert g["b"].screen.info()["index"] == 1
    assert_raises(libqtile.command.CommandError, g["b"].screen[0].info)


@Xephyr(True, ServerConfig())
def test_items_screen(self):
    s = self.c.screen
    assert s.items("layout") == (True, [0, 1, 2])

    win = self.testWindow("test")
    wid = self.c.window.info()["id"]
    assert s.items("window") == (True, [wid])

    assert s.items("bar") == (False, ["bottom"])


@Xephyr(True, ServerConfig())
def test_select_screen(self):
    s = self.c.screen
    assert s.layout.info()["group"] == "a"
    assert len(s.layout.info()["stacks"]) == 1
    assert len(s.layout[2].info()["stacks"]) == 3

    assert_raises(libqtile.command.CommandError, self.c.window.info)
    assert_raises(libqtile.command.CommandError, self.c.window[2].info)
    win = self.testWindow("test")
    wid = self.c.window.info()["id"]
    assert s.window.info()["id"] == wid
    assert s.window[wid].info()["id"] == wid

    assert_raises(libqtile.command.CommandError, s.bar.info)
    assert_raises(libqtile.command.CommandError, s.bar["top"].info)
    assert s.bar["bottom"].info()["position"] == "bottom"


@Xephyr(True, ServerConfig())
def test_items_bar(self):
    assert self.c.bar["bottom"].items("screen") == (True, None)


@Xephyr(True, ServerConfig())
def test_select_bar(self):
    assert self.c.screen[1].bar["bottom"].screen.info()["index"] == 1
    b = self.c.bar
    assert b["bottom"].screen.info()["index"] == 0
    assert_raises(libqtile.command.CommandError, b.screen.info)


@Xephyr(True, ServerConfig())
def test_items_layout(self):
    assert self.c.layout.items("screen") == (True, None)
    assert self.c.layout.items("group") == (True, None)


@Xephyr(True, ServerConfig())
def test_select_layout(self):
    assert self.c.layout.screen.info()["index"] == 0
    assert_raises(libqtile.command.CommandError, self.c.layout.screen[0].info)

    assert self.c.layout.group.info()["name"] == "a"
    assert_raises(libqtile.command.CommandError, self.c.layout.group["a"].info)


@Xephyr(True, ServerConfig())
def test_items_window(self):
    win = self.testWindow("test")
    wid = self.c.window.info()["id"]

    assert self.c.window.items("group") == (True, None)
    assert self.c.window.items("layout") == (True, [0, 1, 2])
    assert self.c.window.items("screen") == (True, None)


@Xephyr(True, ServerConfig())
def test_select_window(self):
    win = self.testWindow("test")
    wid = self.c.window.info()["id"]

    assert self.c.window.group.info()["name"] == "a"
    assert_raises(libqtile.command.CommandError, self.c.window.group["a"].info)

    assert len(self.c.window.layout.info()["stacks"]) == 1
    assert len(self.c.window.layout[1].info()["stacks"]) == 2

    assert self.c.window.screen.info()["index"] == 0
    assert_raises(libqtile.command.CommandError, self.c.window.screen[0].info)


@Xephyr(True, ServerConfig())
def test_items_widget(self):
    assert self.c.widget["one"].items("bar") == (True, None)


@Xephyr(True, ServerConfig())
def test_select_widget(self):
    w = self.c.widget["one"]
    assert w.bar.info()["position"] == "bottom"
    assert_raises(libqtile.command.CommandError, w.bar["bottom"].info)

########NEW FILE########
__FILENAME__ = test_config
from libqtile import confreader
from nose.tools import raises

import os
tests_dir = os.path.dirname(os.path.realpath(__file__))

@raises(confreader.ConfigError)
def test_syntaxerr():
    confreader.File(os.path.join(tests_dir, "configs", "syntaxerr.py"))


def test_basic():
    f = confreader.File(os.path.join(tests_dir, "configs", "basic.py"))
    assert f.keys

########NEW FILE########
__FILENAME__ = test_fakescreen
import libqtile.manager
import libqtile.config
from libqtile import layout, bar, widget
from libqtile.config import Screen
from utils import Xephyr

LEFT_ALT = 'mod1'
WINDOWS = 'mod4'
FONTSIZE = 13
CHAM1 = '8AE234'
CHAM3 = '4E9A06'
GRAPH_KW = dict(line_width=1,
                graph_color=CHAM3,
                fill_color=CHAM3 + '.3',
                border_width=1,
                border_color=CHAM3
                )

# screens look like this
#     600         300
#  |-------------|-----|
#  |          480|     |580
#  |   A         |  B  |
#  |----------|--|     |
#  |       400|--|-----|
#  |   C      |        |400
#  |----------|   D    |
#     500     |--------|
#                 400
#
# Notice there is hole in the middle
# also that D goes down below the others


class FakeScreenConfig:
    auto_fullscreen = True
    main = None
    groups = [
        libqtile.config.Group("a"),
        libqtile.config.Group("b"),
        libqtile.config.Group("c"),
        libqtile.config.Group("d")
    ]
    layouts = [
        layout.Max(),
        layout.RatioTile(),
        layout.Tile(),
    ]
    floating_layout = libqtile.layout.floating.Floating()
    keys = []
    mouse = []
    fake_screens = [Screen(
        bottom=bar.Bar(
            [
                widget.GroupBox(this_screen_border=CHAM3,
                                borderwidth=1,
                                fontsize=FONTSIZE,
                                padding=1, margin_x=1, margin_y=1),
                widget.AGroupBox(),
                widget.Prompt(),
                widget.Sep(),
                widget.WindowName(
                    fontsize=FONTSIZE, margin_x=6),
                widget.Sep(),
                widget.CPUGraph(**GRAPH_KW),
                widget.MemoryGraph(**GRAPH_KW),
                widget.SwapGraph(foreground='20C020', **GRAPH_KW),
                widget.Sep(),
                widget.Systray(),
                widget.Sep(),
                widget.Clock('%H:%M:%S %d.%m.%Y',
                             fontsize=FONTSIZE, padding=6),
            ],
                    24,
            background="#555555"
        ),
        x=0, y=0, width=600, height=480
    ),
    Screen(
        top=bar.Bar(
            [
                        widget.GroupBox(),
                widget.WindowName(),
                widget.Clock()
            ],
                    30,
        ),
        x=600, y=0, width=300, height=580
    ),
    Screen(
        top=bar.Bar(
            [
                        widget.GroupBox(),
                widget.WindowName(),
                widget.Clock()
            ],
                    30,
        ),
           x=0, y=480, width=500, height=400),
                    Screen(
                        bottom=bar.Bar(
                            [
                        widget.GroupBox(),
                                widget.WindowName(),
                                widget.Clock()
                            ],
                    30,
                        ),
           x=500, y=580, width=400, height=400),
    ]

    screens = fake_screens


@Xephyr(False, FakeScreenConfig(), two_screens=False, width=900, height=980)
def test_basic(self):
    self.testWindow("zero")
    assert self.c.layout.info()["clients"] == ["zero"]
    assert self.c.screen.info() == {
        'y': 0, 'x': 0, 'index': 0, 'width': 600, 'height': 480}
    self.c.to_screen(1)
    self.testWindow("one")
    assert self.c.layout.info()["clients"] == ["one"]
    assert self.c.screen.info() == {
        'y': 0, 'x': 600, 'index': 1, 'width': 300, 'height': 580}
    self.c.to_screen(2)
    self.testXeyes()
    assert self.c.screen.info() == {
        'y': 480, 'x': 0, 'index': 2, 'width': 500, 'height': 400}
    self.c.to_screen(3)
    self.testXclock()
    assert self.c.screen.info() == {
        'y': 580, 'x': 500, 'index': 3, 'width': 400, 'height': 400}


@Xephyr(False, FakeScreenConfig(), two_screens=False, width=900, height=980)
def test_maximize_with_move_to_screen(self):
    """
    Ensure that maximize respects bars
    """
    self.testXclock()
    self.c.window.toggle_maximize()
    assert self.c.window.info()['width'] == 600
    assert self.c.window.info()['height'] == 456
    assert self.c.window.info()['x'] == 0
    assert self.c.window.info()['y'] == 0
    assert self.c.window.info()['group'] == 'a'

    # go to second screen
    self.c.to_screen(1)
    assert self.c.screen.info() == {
        'y': 0, 'x': 600, 'index': 1, 'width': 300, 'height': 580}
    assert self.c.group.info()['name'] == 'b'
    self.c.group['a'].toscreen()

    assert self.c.window.info()['width'] == 300
    assert self.c.window.info()['height'] == 550
    assert self.c.window.info()['x'] == 600
    assert self.c.window.info()['y'] == 30
    assert self.c.window.info()['group'] == 'a'


@Xephyr(False, FakeScreenConfig(), two_screens=False, width=900, height=980)
def test_float_first_on_second_screen(self):
    self.c.to_screen(1)
    assert self.c.screen.info() == {
        'y': 0, 'x': 600, 'index': 1, 'width': 300, 'height': 580}

    self.testXclock()
    self.c.window.toggle_floating()
    assert self.c.window.info()['width'] == 164
    assert self.c.window.info()['height'] == 164
    assert self.c.window.info()['x'] == 600
    assert self.c.window.info()['y'] == 0
    assert self.c.window.info()['group'] == 'b'
    assert self.c.window.info()['float_info'] == {
        'y': 0, 'x': 0, 'w': 164, 'h': 164}


@Xephyr(False, FakeScreenConfig(), two_screens=False, width=900, height=980)
def test_float_change_screens(self):
    #add some eyes, and float clock
    self.testXeyes()
    self.testXclock()
    self.c.window.toggle_floating()
    assert set(self.c.group.info()['windows']) == {'xeyes', 'xclock'}
    assert self.c.group.info()['floating_info']['clients'] == ['xclock']
    assert self.c.window.info()['width'] == 164
    assert self.c.window.info()['height'] == 164
    assert self.c.window.info()['x'] == 0
    assert self.c.window.info()['y'] == 0
    assert self.c.window.info()['group'] == 'a'

    #put on group b
    assert self.c.screen.info() == {
        'y': 0, 'x': 0, 'index': 0, 'width': 600, 'height': 480}
    assert self.c.group.info()['name'] == 'a'
    self.c.to_screen(1)
    assert self.c.group.info()['name'] == 'b'
    assert self.c.screen.info() == {
        'y': 0, 'x': 600, 'index': 1, 'width': 300, 'height': 580}
    self.c.group['a'].toscreen()
    assert self.c.group.info()['name'] == 'a'
    assert set(self.c.group.info()['windows']) == {'xeyes', 'xclock'}
    assert self.c.window.info()['name'] == 'xclock'
    assert self.c.window.info()['width'] == 164
    assert self.c.window.info()['height'] == 164
    assert self.c.window.info()['x'] == 600
    assert self.c.window.info()['y'] == 0
    assert self.c.window.info()['group'] == 'a'
    assert self.c.group.info()['floating_info']['clients'] == ['xclock']

    # move to screen 3
    self.c.to_screen(2)
    assert self.c.screen.info() == {
        'y': 480, 'x': 0, 'index': 2, 'width': 500, 'height': 400}
    assert self.c.group.info()['name'] == 'c'
    self.c.group['a'].toscreen()
    assert self.c.group.info()['name'] == 'a'
    assert set(self.c.group.info()['windows']) == {'xeyes', 'xclock'}
    assert self.c.window.info()['name'] == 'xclock'
    assert self.c.window.info()['width'] == 164
    assert self.c.window.info()['height'] == 164
    assert self.c.window.info()['x'] == 0
    assert self.c.window.info()['y'] == 480

    # now screen 4 for fun
    self.c.to_screen(3)
    assert self.c.screen.info() == {
        'y': 580, 'x': 500, 'index': 3, 'width': 400, 'height': 400}
    assert self.c.group.info()['name'] == 'd'
    self.c.group['a'].toscreen()
    assert self.c.group.info()['name'] == 'a'
    assert set(self.c.group.info()['windows']) == {'xeyes', 'xclock'}
    assert self.c.window.info()['name'] == 'xclock'
    assert self.c.window.info()['width'] == 164
    assert self.c.window.info()['height'] == 164
    assert self.c.window.info()['x'] == 500
    assert self.c.window.info()['y'] == 580

    # and back to one
    self.c.to_screen(0)
    assert self.c.screen.info() == {
        'y': 0, 'x': 0, 'index': 0, 'width': 600, 'height': 480}
    assert self.c.group.info()['name'] == 'b'
    self.c.group['a'].toscreen()
    assert self.c.group.info()['name'] == 'a'
    assert set(self.c.group.info()['windows']) == {'xeyes', 'xclock'}
    assert self.c.window.info()['name'] == 'xclock'
    assert self.c.window.info()['width'] == 164
    assert self.c.window.info()['height'] == 164
    assert self.c.window.info()['x'] == 0
    assert self.c.window.info()['y'] == 0


@Xephyr(False, FakeScreenConfig(), two_screens=False, width=900, height=980)
def test_float_outside_edges(self):
    self.testXclock()
    self.c.window.toggle_floating()
    assert self.c.window.info()['width'] == 164
    assert self.c.window.info()['height'] == 164
    assert self.c.window.info()['x'] == 0
    assert self.c.window.info()['y'] == 0
    # empty because window is floating
    assert self.c.layout.info() == {
        'clients': [], 'group': 'a', 'name': 'max'}

    # move left, but some still on screen 0
    self.c.window.move_floating(-10, 20, 42, 42)
    assert self.c.window.info()['width'] == 164
    assert self.c.window.info()['height'] == 164
    assert self.c.window.info()['x'] == -10
    assert self.c.window.info()['y'] == 20
    assert self.c.window.info()['group'] == 'a'

    # move up, but some still on screen 0
    self.c.window.set_position_floating(-10, -20, 42, 42)
    assert self.c.window.info()['width'] == 164
    assert self.c.window.info()['height'] == 164
    assert self.c.window.info()['x'] == -10
    assert self.c.window.info()['y'] == -20
    assert self.c.window.info()['group'] == 'a'

    # move above a
    self.c.window.set_position_floating(50, -20, 42, 42)
    assert self.c.window.info()['width'] == 164
    assert self.c.window.info()['height'] == 164
    assert self.c.window.info()['x'] == 50
    assert self.c.window.info()['y'] == -20
    assert self.c.window.info()['group'] == 'a'

    # move down so still left, but next to screen c
    self.c.window.set_position_floating(-10, 520, 42, 42)
    assert self.c.window.info()['height'] == 164
    assert self.c.window.info()['x'] == -10
    assert self.c.window.info()['y'] == 520
    assert self.c.window.info()['group'] == 'c'

    # move above b
    self.c.window.set_position_floating(700, -10, 42, 42)
    assert self.c.window.info()['width'] == 164
    assert self.c.window.info()['height'] == 164
    assert self.c.window.info()['x'] == 700
    assert self.c.window.info()['y'] == -10
    assert self.c.window.info()['group'] == 'b'


@Xephyr(False, FakeScreenConfig(), two_screens=False, width=900, height=980)
def test_hammer_tile(self):
    # change to tile layout
    self.c.nextlayout()
    self.c.nextlayout()
    for i in range(7):
        self.testXclock()
    for i in range(30):
        old_group = (i + 1) % 4
        if old_group == 0:
            name = 'a'
        elif old_group == 1:
            name = 'b'
        elif old_group == 2:
            name = 'c'
        elif old_group == 3:
            name = 'd'

        self.c.to_screen((i + 1) % 4)
        self.c.group['a'].toscreen()
    assert self.c.group['a'].info()['windows'] == [
        'xclock', 'xclock', 'xclock', 'xclock',
        'xclock', 'xclock', 'xclock']


@Xephyr(False, FakeScreenConfig(), two_screens=False, width=900, height=980)
def test_hammer_ratio_tile(self):
    # change to ratio tile layout
    self.c.nextlayout()
    for i in range(7):
        self.testXclock()
    for i in range(30):
        old_group = (i + 1) % 4
        if old_group == 0:
            name = 'a'
        elif old_group == 1:
            name = 'b'
        elif old_group == 2:
            name = 'c'
        elif old_group == 3:
            name = 'd'

        self.c.to_screen((i + 1) % 4)
        self.c.group['a'].toscreen()
    assert self.c.group['a'].info()['windows'] == [
        'xclock', 'xclock', 'xclock', 'xclock',
        'xclock', 'xclock', 'xclock']


@Xephyr(False, FakeScreenConfig(), two_screens=False, width=900, height=980)
def test_ratio_to_fourth_screen(self):
    # change to ratio tile layout
    self.c.nextlayout()
    for i in range(7):
        self.testXclock()
    self.c.to_screen(1)
    self.c.group['a'].toscreen()
    assert self.c.group['a'].info()['windows'] == [
        'xclock', 'xclock', 'xclock', 'xclock',
        'xclock', 'xclock', 'xclock']

    # now move to 4th, fails...
    self.c.to_screen(3)
    self.c.group['a'].toscreen()
    assert self.c.group['a'].info()['windows'] == [
        'xclock', 'xclock', 'xclock', 'xclock',
        'xclock', 'xclock', 'xclock']

########NEW FILE########
__FILENAME__ = test_hook
import cStringIO
import libqtile.manager
import libqtile.utils
import libqtile.hook
import logging
from nose.tools import with_setup, raises

# TODO: more tests required.
# 1. Check all hooks that can be fired

class TestCall(object):
    def __init__(self, val):
        self.val = val

    def __call__(self, val):
        self.val = val

def setup():
    class Dummy:
        pass

    dummy = Dummy()
    dummy.log = libqtile.manager.init_log(logging.CRITICAL)
    libqtile.hook.init(dummy)


def teardown():
    libqtile.hook.clear()


@raises(libqtile.utils.QtileError)
def test_cannot_fire_unknown_event():
    libqtile.hook.fire("unknown")


@with_setup(setup, teardown)
def test_hook_calls_subscriber():
    test = TestCall(0)
    libqtile.manager.hook.subscribe.group_window_add(test)
    libqtile.manager.hook.fire("group_window_add", 8)
    assert test.val == 8


@with_setup(setup, teardown)
def test_subscribers_can_be_added_removed():
    test = TestCall(0)
    libqtile.manager.hook.subscribe.group_window_add(test)
    assert libqtile.manager.hook.subscriptions
    libqtile.manager.hook.clear()
    assert not libqtile.manager.hook.subscriptions


@with_setup(setup, teardown)
def test_can_unsubscribe_from_hook():
    test = TestCall(0)

    libqtile.manager.hook.subscribe.group_window_add(test)
    libqtile.manager.hook.fire("group_window_add", 3)
    assert test.val == 3

    libqtile.manager.hook.unsubscribe.group_window_add(test)
    libqtile.manager.hook.fire("group_window_add", 4)
    assert test.val == 3

########NEW FILE########
__FILENAME__ = test_ipc
# import thread
# import socket
# import Queue
# from libqtile import ipc as ipc

# Fix this apparently

# class TestServer(ipc.Server):
#     last = None

#     def __init__(self, fname):
#         ipc.Server.__init__(self, fname, self.command)

#     def command(self, data):
#         self.last = data
#         return "OK"


# def send(fname, data, q):
#     c = ipc.Client(fname)
#     while 1:
#         try:
#             d = c.send(data)
#         except socket.error:
#             continue
#         q.put(d)
#         return


# def response(s, data):
#     """
#         Returns serverData, clientData
#     """
#     q = Queue.Queue()
#     thread.start_new_thread(send, (s.fname, data, q))
#     while 1:
#         d = s.receive()
#         if s.last:
#             ret = s.last
#             break
#     s.last = None
#     return ret, q.get()


# def test_basic():
#     fname = "/tmp/testpath"
#     server = TestServer(fname)
#     assert response(server, "foo") == ("foo", "OK")

#     expected = {
#         "one": [1, 2, 3]
#     }
#     assert response(server, expected) == (expected, "OK")


# def test_big():
#     fname = "/tmp/testpath"
#     server = TestServer(fname)
#     expected = {
#         "one": [1, 2, 3] * 1024 * 5
#     }
#     assert response(server, expected) == (expected, "OK")


# def test_read_nodata():
#     fname = "/tmp/testpath"
#     s = TestServer(fname)
#     assert s.receive() == None


# def test_close():
#     fname = "/tmp/testpath"
#     s = TestServer(fname)
#     s.close()

########NEW FILE########
__FILENAME__ = test_layout
from libqtile import layout
import libqtile.manager
import libqtile.config
from time import sleep
from utils import Xephyr


def assertFocused(self, name):
    """Asserts that window with specified name is currently focused"""
    info = self.c.window.info()
    assert info['name']


def assertDimensions(self, x, y, w, h, win=None):
    """Asserts dimensions of window"""
    if win is None:
        win = self.c.window
    info = win.info()
    assert info['x'] == x, info
    assert info['y'] == y, info
    assert info['width'] == w, info  # why?
    assert info['height'] == h, info


def assertFocusPath(self, *names):
    for i in names:
        self.c.group.next_window()
        assertFocused(self, i)
    # let's check twice for sure
    for i in names:
        self.c.group.next_window()
        assertFocused(self, i)
    # Ok, let's check backwards now
    for i in reversed(names):
        assertFocused(self, i)
        self.c.group.prev_window()
    # and twice for sure
    for i in reversed(names):
        assertFocused(self, i)
        self.c.group.prev_window()


class MatrixConfig:
    auto_fullscreen = True
    main = None
    groups = [
        libqtile.config.Group("a"),
        libqtile.config.Group("b"),
        libqtile.config.Group("c"),
        libqtile.config.Group("d")
    ]
    layouts = [
        layout.Matrix(columns=2)
    ]
    floating_layout = libqtile.layout.floating.Floating()
    keys = []
    mouse = []
    screens = []


@Xephyr(False, MatrixConfig())
def test_matrix_simple(self):
    self.testWindow("one")
    assert self.c.layout.info()["rows"] == [["one"]]
    self.testWindow("two")
    assert self.c.layout.info()["rows"] == [["one", "two"]]
    self.testWindow("three")
    assert self.c.layout.info()["rows"] == [["one", "two"],
                                            ["three"]]


@Xephyr(False, MatrixConfig())
def test_matrix_navigation(self):
    self.testWindow("one")
    self.testWindow("two")
    self.testWindow("three")
    self.testWindow("four")
    self.testWindow("five")
    self.c.layout.right()
    assert self.c.layout.info()["current_window"] == (0, 2)
    self.c.layout.up()
    assert self.c.layout.info()["current_window"] == (0, 1)
    self.c.layout.up()
    assert self.c.layout.info()["current_window"] == (0, 0)
    self.c.layout.up()
    assert self.c.layout.info()["current_window"] == (0, 2)
    self.c.layout.down()
    assert self.c.layout.info()["current_window"] == (0, 0)
    self.c.layout.down()
    assert self.c.layout.info()["current_window"] == (0, 1)
    self.c.layout.right()
    assert self.c.layout.info()["current_window"] == (1, 1)
    self.c.layout.right()
    assert self.c.layout.info()["current_window"] == (0, 1)


@Xephyr(False, MatrixConfig())
def test_matrix_add_remove_columns(self):
    self.testWindow("one")
    self.testWindow("two")
    self.testWindow("three")
    self.testWindow("four")
    self.testWindow("five")
    self.c.layout.add()
    assert self.c.layout.info()["rows"] == [["one", "two", "three"],
                                            ["four", "five"]]
    self.c.layout.delete()
    assert self.c.layout.info()["rows"] == [["one", "two"],
                                            ["three", "four"],
                                            ["five"]]


class MaxConfig:
    auto_fullscreen = True
    main = None
    groups = [
        libqtile.config.Group("a"),
        libqtile.config.Group("b"),
        libqtile.config.Group("c"),
        libqtile.config.Group("d")
    ]
    layouts = [
        layout.Max()
    ]
    floating_layout = libqtile.layout.floating.Floating()
    keys = []
    mouse = []
    screens = []


@Xephyr(False, MaxConfig())
def test_max_simple(self):
    self.testWindow("one")
    assert self.c.layout.info()["clients"] == ["one"]
    self.testWindow("two")
    assert self.c.layout.info()["clients"] == ["two", "one"]


@Xephyr(False, MaxConfig())
def test_max_updown(self):
    self.testWindow("one")
    self.testWindow("two")
    self.testWindow("three")
    assert self.c.layout.info()["clients"] == ["three", "two", "one"]
    self.c.layout.down()
    assert self.c.groups()["a"]["focus"] == "two"
    self.c.layout.up()
    assert self.c.groups()["a"]["focus"] == "three"


@Xephyr(False, MaxConfig())
def test_max_remove(self):
    self.testWindow("one")
    two = self.testWindow("two")
    assert self.c.layout.info()["clients"] == ["two", "one"]
    self.kill(two)
    assert self.c.layout.info()["clients"] == ["one"]


class StackConfig:
    auto_fullscreen = True
    main = None
    groups = [
        libqtile.config.Group("a"),
        libqtile.config.Group("b"),
        libqtile.config.Group("c"),
        libqtile.config.Group("d")
    ]
    layouts = [
        layout.Stack(num_stacks=2),
        layout.Stack(num_stacks=1),
    ]
    floating_layout = libqtile.layout.floating.Floating()
    keys = []
    mouse = []
    screens = []
    follow_mouse_focus = False


def _stacks(self):
    stacks = []
    for i in self.c.layout.info()["stacks"]:
        windows = i["clients"]
        current = i["current"]
        stacks.append(windows[current:] + windows[:current])
    return stacks


@Xephyr(False, StackConfig())
def test_stack_commands(self):
    assert self.c.layout.info()["current_stack"] == 0
    self.testWindow("one")
    assert _stacks(self) == [["one"], []]
    assert self.c.layout.info()["current_stack"] == 0
    self.testWindow("two")
    assert _stacks(self) == [["one"], ["two"]]
    assert self.c.layout.info()["current_stack"] == 1
    self.testWindow("three")
    assert _stacks(self) == [["one"], ["three", "two"]]
    assert self.c.layout.info()["current_stack"] == 1

    self.c.layout.delete()
    assert _stacks(self) == [["one", "three", "two"]]
    info = self.c.groups()["a"]
    assert info["focus"] == "one"
    self.c.layout.delete()
    assert len(_stacks(self)) == 1

    self.c.layout.add()
    assert _stacks(self) == [["one", "three", "two"], []]

    self.c.layout.rotate()
    assert _stacks(self) == [[], ["one", "three", "two"]]


@Xephyr(False, StackConfig())
def test_stack_cmd_down(self):
    self.c.layout.down()


@Xephyr(False, StackConfig())
def test_stack_addremove(self):
    one = self.testWindow("one")
    self.c.layout.next()
    two = self.testWindow("two")
    three = self.testWindow("three")
    assert _stacks(self) == [['one'], ['three', 'two']]
    assert self.c.layout.info()["current_stack"] == 1
    self.kill(three)
    assert self.c.layout.info()["current_stack"] == 1
    self.kill(two)
    assert self.c.layout.info()["current_stack"] == 0
    self.c.layout.next()
    two = self.testWindow("two")
    self.c.layout.next()
    assert self.c.layout.info()["current_stack"] == 0
    self.kill(one)
    assert self.c.layout.info()["current_stack"] == 1


@Xephyr(False, StackConfig())
def test_stack_rotation(self):
    self.c.layout.delete()
    self.testWindow("one")
    self.testWindow("two")
    self.testWindow("three")
    assert _stacks(self) == [["three", "two", "one"]]
    self.c.layout.down()
    assert _stacks(self) == [["one", "three", "two"]]
    self.c.layout.up()
    assert _stacks(self) == [["three", "two", "one"]]
    self.c.layout.down()
    self.c.layout.down()
    assert _stacks(self) == [["two", "one", "three"]]


@Xephyr(False, StackConfig())
def test_stack_nextprev(self):
    self.c.layout.add()
    one = self.testWindow("one")
    two = self.testWindow("two")
    three = self.testWindow("three")

    assert self.c.groups()["a"]["focus"] == "three"
    self.c.layout.next()
    assert self.c.groups()["a"]["focus"] == "one"

    self.c.layout.previous()
    assert self.c.groups()["a"]["focus"] == "three"
    self.c.layout.previous()
    assert self.c.groups()["a"]["focus"] == "two"

    self.c.layout.next()
    self.c.layout.next()
    self.c.layout.next()
    assert self.c.groups()["a"]["focus"] == "two"

    self.kill(three)
    self.c.layout.next()
    assert self.c.groups()["a"]["focus"] == "one"
    self.c.layout.previous()
    assert self.c.groups()["a"]["focus"] == "two"
    self.c.layout.next()
    self.kill(two)
    self.c.layout.next()
    assert self.c.groups()["a"]["focus"] == "one"

    self.kill(one)
    self.c.layout.next()
    assert self.c.groups()["a"]["focus"] == None
    self.c.layout.previous()
    assert self.c.groups()["a"]["focus"] == None


@Xephyr(False, StackConfig())
def test_stack_window_removal(self):
    self.c.layout.next()
    one = self.testWindow("one")
    two = self.testWindow("two")
    self.c.layout.down()
    self.kill(two)


@Xephyr(False, StackConfig())
def test_stack_split(self):
    one = self.testWindow("one")
    two = self.testWindow("two")
    three = self.testWindow("three")
    stacks = self.c.layout.info()["stacks"]
    assert not stacks[1]["split"]
    self.c.layout.toggle_split()
    stacks = self.c.layout.info()["stacks"]
    assert stacks[1]["split"]


@Xephyr(False, StackConfig())
def test_stack_shuffle(self):
    self.c.nextlayout()
    one = self.testWindow("one")
    two = self.testWindow("two")
    three = self.testWindow("three")

    stack = self.c.layout.info()["stacks"][0]
    assert stack["clients"][stack["current"]] == "three"
    for i in range(5):
        self.c.layout.shuffle_up()
        stack = self.c.layout.info()["stacks"][0]
        assert stack["clients"][stack["current"]] == "three"
    for i in range(5):
        self.c.layout.shuffle_down()
        stack = self.c.layout.info()["stacks"][0]
        assert stack["clients"][stack["current"]] == "three"


@Xephyr(False, StackConfig())
def test_stack_client_to(self):
    one = self.testWindow("one")
    two = self.testWindow("two")
    assert self.c.layout.info()["stacks"][0]["clients"] == ["one"]
    self.c.layout.client_to_previous()
    assert self.c.layout.info()["stacks"][0]["clients"] == ["two", "one"]
    self.c.layout.client_to_previous()
    assert self.c.layout.info()["stacks"][0]["clients"] == ["one"]
    assert self.c.layout.info()["stacks"][1]["clients"] == ["two"]
    self.c.layout.client_to_next()
    assert self.c.layout.info()["stacks"][0]["clients"] == ["two", "one"]


@Xephyr(False, StackConfig())
def test_stack_info(self):
    one = self.testWindow("one")
    assert self.c.layout.info()["stacks"]


class RatioTileConfig:
    auto_fullscreen = True
    main = None
    groups = [
        libqtile.config.Group("a"),
        libqtile.config.Group("b"),
        libqtile.config.Group("c"),
        libqtile.config.Group("d")
    ]
    layouts = [
        layout.RatioTile(ratio=.5),
        layout.RatioTile(),
        ]
    floating_layout = libqtile.layout.floating.Floating()
    keys = []
    mouse = []
    screens = []
    follow_mouse_focus = False


@Xephyr(False, RatioTileConfig())
def test_ratiotile_add_windows(self):
    for i in range(12):
        self.testWindow(str(i))
        if i == 0:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 800, 600)]
        elif i == 1:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 400, 600), (400, 0, 400, 600)]
        elif i == 2:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 266, 600), (266, 0, 266, 600), (532, 0, 268, 600)]
        elif i == 3:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 200, 600), (200, 0, 200, 600), (400, 0, 200, 600),
                (600, 0, 200, 600)]
        elif i == 4:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 160, 600), (160, 0, 160, 600), (320, 0, 160, 600),
                (480, 0, 160, 600), (640, 0, 160, 600)]
        elif i == 5:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 133, 600), (133, 0, 133, 600), (266, 0, 133, 600),
                (399, 0, 133, 600), (532, 0, 133, 600), (665, 0, 135, 600)]
        elif i == 6:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 200, 300), (200, 0, 200, 300), (400, 0, 200, 300),
                (600, 0, 200, 300), (0, 300, 266, 300),
                (266, 300, 266, 300), (532, 300, 268, 300)]
        elif i == 7:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 200, 300), (200, 0, 200, 300), (400, 0, 200, 300),
                (600, 0, 200, 300), (0, 300, 200, 300),
                (200, 300, 200, 300), (400, 300, 200, 300),
                (600, 300, 200, 300)]
        elif i == 8:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 160, 300), (160, 0, 160, 300), (320, 0, 160, 300),
                (480, 0, 160, 300), (640, 0, 160, 300), (0, 300, 200, 300),
                (200, 300, 200, 300), (400, 300, 200, 300),
                (600, 300, 200, 300)]
        elif i == 9:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 160, 300), (160, 0, 160, 300), (320, 0, 160, 300),
                (480, 0, 160, 300), (640, 0, 160, 300), (0, 300, 160, 300),
                (160, 300, 160, 300), (320, 300, 160, 300),
                (480, 300, 160, 300), (640, 300, 160, 300)]
        elif i == 10:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 133, 300), (133, 0, 133, 300), (266, 0, 133, 300),
                (399, 0, 133, 300), (532, 0, 133, 300), (665, 0, 135, 300),
                (0, 300, 160, 300), (160, 300, 160, 300),
                (320, 300, 160, 300), (480, 300, 160, 300),
                (640, 300, 160, 300)]
        elif i == 11:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 133, 300), (133, 0, 133, 300), (266, 0, 133, 300),
                (399, 0, 133, 300), (532, 0, 133, 300), (665, 0, 135, 300),
                (0, 300, 133, 300), (133, 300, 133, 300),
                (266, 300, 133, 300), (399, 300, 133, 300),
                (532, 300, 133, 300), (665, 300, 135, 300)]
        else:
            assert False


@Xephyr(False, RatioTileConfig())
def test_ratiotile_add_windows_golden_ratio(self):
    self.c.nextlayout()
    for i in range(12):
        self.testWindow(str(i))
        if i == 0:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 800, 600)]
        elif i == 4:
            # the rest test col order
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 400, 200), (0, 200, 400, 200), (0, 400, 400, 200),
                (400, 0, 400, 300), (400, 300, 400, 300)]
        elif i == 5:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 400, 200), (0, 200, 400, 200), (0, 400, 400, 200),
                (400, 0, 400, 200), (400, 200, 400, 200),
                (400, 400, 400, 200)]

        elif i == 9:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 266, 150), (0, 150, 266, 150), (0, 300, 266, 150),
                (0, 450, 266, 150), (266, 0, 266, 150),
                (266, 150, 266, 150), (266, 300, 266, 150),
                (266, 450, 266, 150), (532, 0, 266, 300),
                (532, 300, 266, 300)]
        elif i == 10:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 266, 150), (0, 150, 266, 150), (0, 300, 266, 150),
                (0, 450, 266, 150), (266, 0, 266, 150),
                (266, 150, 266, 150), (266, 300, 266, 150),
                (266, 450, 266, 150), (532, 0, 266, 200),
                (532, 200, 266, 200), (532, 400, 266, 200)]
        elif i == 11:
            assert self.c.layout.info()['layout_info'] == [
                (0, 0, 266, 150), (0, 150, 266, 150), (0, 300, 266, 150),
                (0, 450, 266, 150), (266, 0, 266, 150),
                (266, 150, 266, 150), (266, 300, 266, 150),
                (266, 450, 266, 150), (532, 0, 266, 150),
                (532, 150, 266, 150), (532, 300, 266, 150),
                (532, 450, 266, 150)]


@Xephyr(False, RatioTileConfig())
def test_ratiotile_basic(self):
    self.testWindow("one")
    self.testWindow("two")
    self.testWindow("three")
    sleep(0.1)
    assert self.c.window.info()['width'] == 264
    assert self.c.window.info()['height'] == 598
    assert self.c.window.info()['x'] == 0
    assert self.c.window.info()['y'] == 0
    assert self.c.window.info()['name'] == 'three'

    self.c.group.next_window()
    assert self.c.window.info()['width'] == 264
    assert self.c.window.info()['height'] == 598
    assert self.c.window.info()['x'] == 266
    assert self.c.window.info()['y'] == 0
    assert self.c.window.info()['name'] == 'two'

    self.c.group.next_window()
    assert self.c.window.info()['width'] == 266
    assert self.c.window.info()['height'] == 598
    assert self.c.window.info()['x'] == 532
    assert self.c.window.info()['y'] == 0
    assert self.c.window.info()['name'] == 'one'


class TileConfig:
    auto_fullscreen = True
    main = None
    groups = [
        libqtile.config.Group("a"),
        libqtile.config.Group("b"),
        libqtile.config.Group("c"),
        libqtile.config.Group("d")
    ]
    layouts = [
        layout.Tile(),
        layout.Tile(masterWindows=2)
        ]
    floating_layout = libqtile.layout.floating.Floating()
    keys = []
    mouse = []
    screens = []
    follow_mouse_focus = False


@Xephyr(False, TileConfig())
def test_tile_updown(self):
    self.testWindow("one")
    self.testWindow("two")
    self.testWindow("three")
    assert self.c.layout.info()["clients"] == ["three", "two", "one"]
    self.c.layout.down()
    assert self.c.layout.info()["clients"] == ["two", "one", "three"]
    self.c.layout.up()
    assert self.c.layout.info()["clients"] == ["three", "two", "one"]


@Xephyr(False, TileConfig())
def test_tile_nextprev(self):
    self.testWindow("one")
    self.testWindow("two")
    self.testWindow("three")

    assert self.c.layout.info()["clients"] == ["three", "two", "one"]
    assert self.c.groups()["a"]["focus"] == "three"

    self.c.layout.next()
    assert self.c.groups()["a"]["focus"] == "two"

    self.c.layout.previous()
    assert self.c.groups()["a"]["focus"] == "three"

    self.c.layout.previous()
    assert self.c.groups()["a"]["focus"] == "one"

    self.c.layout.next()
    self.c.layout.next()
    self.c.layout.next()
    assert self.c.groups()["a"]["focus"] == "one"


@Xephyr(False, TileConfig())
def test_tile_master_and_slave(self):
    self.testWindow("one")
    self.testWindow("two")
    self.testWindow("three")

    assert self.c.layout.info()["master"] == ["three"]
    assert self.c.layout.info()["slave"] == ["two", "one"]

    self.c.nextlayout()
    assert self.c.layout.info()["master"] == ["three", "two"]
    assert self.c.layout.info()["slave"] == ["one"]


@Xephyr(False, TileConfig())
def test_tile_remove(self):
    one = self.testWindow("one")
    self.testWindow("two")
    three = self.testWindow("three")

    assert self.c.layout.info()["master"] == ["three"]
    self.kill(one)
    assert self.c.layout.info()["master"] == ["three"]
    self.kill(three)
    assert self.c.layout.info()["master"] == ["two"]


class SliceConfig:
    auto_fullscreen = True
    main = None
    groups = [
        libqtile.config.Group("a"),
    ]
    layouts = [
        layout.Slice(side='left', width=200, wname='slice',
            fallback=layout.Stack(num_stacks=1, border_width=0)),
        layout.Slice(side='right', width=200, wname='slice',
            fallback=layout.Stack(num_stacks=1, border_width=0)),
        layout.Slice(side='top', width=200, wname='slice',
            fallback=layout.Stack(num_stacks=1, border_width=0)),
        layout.Slice(side='bottom', width=200, wname='slice',
            fallback=layout.Stack(num_stacks=1, border_width=0)),
        ]
    floating_layout = libqtile.layout.floating.Floating()
    keys = []
    mouse = []
    screens = []
    follow_mouse_focus = False


@Xephyr(False, SliceConfig())
def test_no_slice(self):
    self.testWindow('one')
    assertDimensions(self, 200, 0, 600, 600)
    self.testWindow('two')
    assertDimensions(self, 200, 0, 600, 600)


@Xephyr(False, SliceConfig())
def test_slice_first(self):
    self.testWindow('slice')
    assertDimensions(self, 0, 0, 200, 600)
    self.testWindow('two')
    assertDimensions(self, 200, 0, 600, 600)


@Xephyr(False, SliceConfig())
def test_slice_last(self):
    self.testWindow('one')
    assertDimensions(self, 200, 0, 600, 600)
    self.testWindow('slice')
    assertDimensions(self, 0, 0, 200, 600)


@Xephyr(False, SliceConfig())
def test_slice_focus(self):
    one = self.testWindow('one')
    assertFocused(self, 'one')
    two = self.testWindow('two')
    assertFocused(self, 'two')
    slice = self.testWindow('slice')
    assertFocused(self, 'slice')
    assertFocusPath(self, 'one', 'two', 'slice')
    three = self.testWindow('three')
    assertFocusPath(self, 'one', 'two', 'three', 'slice')
    self.kill(two)
    assertFocusPath(self, 'one', 'three', 'slice')
    self.kill(slice)
    assertFocusPath(self, 'one', 'three')
    slice = self.testWindow('slice')
    assertFocusPath(self, 'one', 'three', 'slice')


@Xephyr(False, SliceConfig())
def test_all_slices(self):
    self.testWindow('slice')  # left
    assertDimensions(self, 0, 0, 200, 600)
    self.c.nextlayout()  # right
    assertDimensions(self, 600, 0, 200, 600)
    self.c.nextlayout()  # top
    assertDimensions(self, 0, 0, 800, 200)
    self.c.nextlayout()  # bottom
    assertDimensions(self, 0, 400, 800, 200)
    self.c.nextlayout()  # left again
    self.testWindow('one')
    assertDimensions(self, 200, 0, 600, 600)
    self.c.nextlayout()  # right
    assertDimensions(self, 0, 0, 600, 600)
    self.c.nextlayout()  # top
    assertDimensions(self, 0, 200, 800, 400)
    self.c.nextlayout()  # bottom
    assertDimensions(self, 0, 0, 800, 400)


@Xephyr(False, SliceConfig())
def test_command_propagation(self):
    self.testWindow('slice')
    self.testWindow('one')
    self.testWindow('two')
    info = self.c.layout.info()
    assert info['name'] == 'slice', info['name']
    org_height = self.c.window.info()['height']
    self.c.layout.toggle_split()
    assert self.c.window.info()['height'] != org_height


class ZoomyConfig:
    auto_fullscreen = True
    main = None
    groups = [
        libqtile.config.Group("a"),
    ]
    layouts = [
        layout.Zoomy(columnwidth=200),
        ]
    floating_layout = libqtile.layout.floating.Floating()
    keys = []
    mouse = []
    screens = []


@Xephyr(False, ZoomyConfig())
def test_zoomy_one(self):
    self.testWindow('one')
    assertDimensions(self, 0, 0, 600, 600)
    self.testWindow('two')
    assertDimensions(self, 0, 0, 600, 600)
    self.testWindow('three')
    assertDimensions(self, 0, 0, 600, 600)
    assertFocusPath(self, 'one', 'two', 'three')
    # TODO(pc) find a way to check size of inactive windows

########NEW FILE########
__FILENAME__ = test_manager
import os
import time
import cStringIO
import subprocess
import signal
import libqtile
import libqtile.layout
import libqtile.bar
import libqtile.command
import libqtile.widget
import libqtile.manager
import libqtile.config
import libqtile.hook
import libqtile.confreader
import utils
from utils import Xephyr
from nose.tools import assert_raises
from nose.plugins.attrib import attr


class TestConfig:
    auto_fullscreen = True
    groups = [
        libqtile.config.Group("a"),
        libqtile.config.Group("b"),
        libqtile.config.Group("c"),
        libqtile.config.Group("d")
    ]
    layouts = [
                libqtile.layout.stack.Stack(num_stacks=1),
                libqtile.layout.stack.Stack(num_stacks=2),
                libqtile.layout.max.Max()
            ]
    floating_layout = libqtile.layout.floating.Floating(
        float_rules=[dict(wmclass="xclock")])
    keys = [
        libqtile.config.Key(
            ["control"],
            "k",
            libqtile.command._Call([("layout", None)], "up")
        ),
        libqtile.config.Key(
            ["control"],
            "j",
            libqtile.command._Call([("layout", None)], "down")
        ),
    ]
    mouse = []
    screens = [libqtile.config.Screen(
            bottom=libqtile.bar.Bar(
                        [
                            libqtile.widget.GroupBox(),
                        ],
                        20
                    ),
    )]
    main = None
    follow_mouse_focus = True


class BareConfig:
    auto_fullscreen = True
    groups = [
        libqtile.config.Group("a"),
        libqtile.config.Group("b"),
        libqtile.config.Group("c"),
        libqtile.config.Group("d")
    ]
    layouts = [
                libqtile.layout.stack.Stack(num_stacks=1),
                libqtile.layout.stack.Stack(num_stacks=2)
            ]
    floating_layout = libqtile.layout.floating.Floating()
    keys = [
        libqtile.config.Key(
            ["control"],
            "k",
            libqtile.command._Call([("layout", None)], "up")
        ),
        libqtile.config.Key(
            ["control"],
            "j",
            libqtile.command._Call([("layout", None)], "down")
        ),
    ]
    mouse = []
    screens = [libqtile.config.Screen()]
    main = None
    follow_mouse_focus = False


@Xephyr(True, TestConfig())
def test_screen_dim(self):
    #self.c.restart()
    self.testXclock()
    assert self.c.screen.info()["index"] == 0
    assert self.c.screen.info()["x"] == 0
    assert self.c.screen.info()["width"] == 800
    assert self.c.group.info()["name"] == 'a'
    assert self.c.group.info()["focus"] == 'xclock'

    self.c.to_screen(1)
    self.testXeyes()
    assert self.c.screen.info()["index"] == 1
    assert self.c.screen.info()["x"] == 800
    assert self.c.screen.info()["width"] == 640
    assert self.c.group.info()["name"] == 'b'
    assert self.c.group.info()["focus"] == 'xeyes'

    self.c.to_screen(0)
    assert self.c.screen.info()["index"] == 0
    assert self.c.screen.info()["x"] == 0
    assert self.c.screen.info()["width"] == 800
    assert self.c.group.info()["name"] == 'a'
    assert self.c.group.info()["focus"] == 'xclock'


@Xephyr(True, TestConfig(), xoffset=0)
def test_clone_dim(self):
    self.testXclock()
    assert self.c.screen.info()["index"] == 0
    assert self.c.screen.info()["x"] == 0
    assert self.c.screen.info()["width"] == 800
    assert self.c.group.info()["name"] == 'a'
    assert self.c.group.info()["focus"] == 'xclock'

    assert len(self.c.screens()) == 1


@Xephyr(True, TestConfig())
def test_to_screen(self):
    assert self.c.screen.info()["index"] == 0
    self.c.to_screen(1)
    assert self.c.screen.info()["index"] == 1
    self.testWindow("one")
    self.c.to_screen(0)
    self.testWindow("two")

    ga = self.c.groups()["a"]
    assert ga["windows"] == ["two"]

    gb = self.c.groups()["b"]
    assert gb["windows"] == ["one"]

    assert self.c.window.info()["name"] == "two"
    self.c.to_next_screen()
    assert self.c.window.info()["name"] == "one"
    self.c.to_next_screen()
    assert self.c.window.info()["name"] == "two"
    self.c.to_prev_screen()
    assert self.c.window.info()["name"] == "one"


@Xephyr(True, TestConfig())
def test_togroup(self):
    self.testWindow("one")
    assert_raises(libqtile.command.CommandError,
                  self.c.window.togroup, "nonexistent")
    assert self.c.groups()["a"]["focus"] == "one"
    self.c.window.togroup("a")
    assert self.c.groups()["a"]["focus"] == "one"
    self.c.window.togroup("b")
    assert self.c.groups()["b"]["focus"] == "one"
    assert self.c.groups()["a"]["focus"] == None
    self.c.to_screen(1)
    self.c.window.togroup("c")
    assert self.c.groups()["c"]["focus"] == "one"


@Xephyr(True, TestConfig())
def test_resize(self):
    self.c.screen[0].resize(x=10, y=10, w=100, h=100)
    d = self.c.screen[0].info()
    assert d["width"] == d["height"] == 100
    assert d["x"] == d["y"] == 10


@Xephyr(False, BareConfig())
def test_minimal(self):
    assert self.c.status() == "OK"


@Xephyr(False, TestConfig())
def test_events(self):
    assert self.c.status() == "OK"


# FIXME: failing test disabled. For some reason we don't seem
# to have a keymap in Xnest or Xephyr 99% of the time.
@Xephyr(False, TestConfig())
def test_keypress(self):
    self.testWindow("one")
    self.testWindow("two")
    v = self.c.simulate_keypress(["unknown"], "j")
    assert v.startswith("Unknown modifier")
    assert self.c.groups()["a"]["focus"] == "two"
    self.c.simulate_keypress(["control"], "j")
    assert self.c.groups()["a"]["focus"] == "one"


@Xephyr(False, TestConfig())
def test_spawn(self):
    assert self.c.spawn("true") == None


@Xephyr(False, TestConfig())
def test_kill(self):
    self.testWindow("one")
    self.testwindows = []
    self.c.window[self.c.window.info()["id"]].kill()
    self.c.sync()
    for i in range(20):
        if len(self.c.windows()) == 0:
            break
        time.sleep(0.1)
    else:
        raise AssertionError("Window did not die...")


@Xephyr(False, TestConfig())
def test_regression_groupswitch(self):
    self.c.group["c"].toscreen()
    self.c.group["d"].toscreen()
    assert self.c.groups()["c"]["screen"] == None


@Xephyr(False, TestConfig())
def test_nextlayout(self):
    self.testWindow("one")
    self.testWindow("two")
    assert len(self.c.layout.info()["stacks"]) == 1
    self.c.nextlayout()
    assert len(self.c.layout.info()["stacks"]) == 2
    self.c.nextlayout()
    self.c.nextlayout()
    assert len(self.c.layout.info()["stacks"]) == 1


@Xephyr(False, TestConfig())
def test_setlayout(self):
    assert not self.c.layout.info()["name"] == "max"
    self.c.group.setlayout("max")
    assert self.c.layout.info()["name"] == "max"


@Xephyr(False, TestConfig())
def test_adddelgroup(self):
    self.testWindow("one")
    self.c.addgroup("dummygroup")
    self.c.addgroup("testgroup")
    assert "testgroup" in self.c.groups().keys()
    self.c.window.togroup("testgroup")
    self.c.delgroup("testgroup")
    assert not "testgroup" in self.c.groups().keys()
    # Assert that the test window is still a member of some group.
    assert sum([len(i["windows"]) for i in self.c.groups().values()])
    for i in self.c.groups().keys()[:len(self.c.groups())-1]:
        self.c.delgroup(i)
    assert_raises(libqtile.command.CommandException,
                  self.c.delgroup, self.c.groups().keys()[0])


@Xephyr(False, TestConfig())
def test_nextprevgroup(self):
    start = self.c.group.info()["name"]
    ret = self.c.screen.nextgroup()
    assert self.c.group.info()["name"] != start
    assert self.c.group.info()["name"] == ret
    ret = self.c.screen.prevgroup()
    assert self.c.group.info()["name"] == start


@Xephyr(False, TestConfig())
def test_togglegroup(self):
    self.c.group["a"].toscreen()
    self.c.group["b"].toscreen()
    self.c.screen.togglegroup("c")
    assert self.c.group.info()["name"] == "c"
    self.c.screen.togglegroup("c")
    assert self.c.group.info()["name"] == "b"
    self.c.screen.togglegroup()
    assert self.c.group.info()["name"] == "c"


@Xephyr(False, TestConfig())
def test_inspect_xeyes(self):
    self.testXeyes()
    assert self.c.window.inspect()


@Xephyr(False, TestConfig())
def test_inspect_xterm(self):
    self.testXterm()
    assert self.c.window.inspect()["wm_class"]


@Xephyr(False, TestConfig())
def test_static(self):
    self.testXeyes()
    self.testWindow("one")
    self.c.window[self.c.window.info()["id"]].static(0, 0, 0, 100, 100)


@Xephyr(False, TestConfig())
def test_match(self):
    self.testXeyes()
    assert self.c.window.match(wname="xeyes")
    assert not self.c.window.match(wname="nonexistent")


@Xephyr(False, TestConfig())
def test_default_float(self):
    # change to 2 col stack
    self.c.nextlayout()
    assert len(self.c.layout.info()["stacks"]) == 2
    self.testXclock()

    assert self.c.group.info()['focus'] == 'xclock'
    assert self.c.window.info()['width'] == 164
    assert self.c.window.info()['height'] == 164
    assert self.c.window.info()['x'] == 0
    assert self.c.window.info()['y'] == 0
    assert self.c.window.info()['floating'] == True

    self.c.window.move_floating(10, 20, 42, 42)
    assert self.c.window.info()['width'] == 164
    assert self.c.window.info()['height'] == 164
    assert self.c.window.info()['x'] == 10
    assert self.c.window.info()['y'] == 20
    assert self.c.window.info()['floating'] == True


@Xephyr(False, TestConfig())
def test_last_float_size(self):
    """
    When you re-float something it would be preferable to have it
    use the previous float size
    """
    self.testXeyes()
    assert self.c.window.info()['name'] == 'xeyes'
    assert self.c.window.info()['width'] == 798
    assert self.c.window.info()['height'] == 578
    self.c.window.toggle_floating()
    assert self.c.window.info()['width'] == 150
    assert self.c.window.info()['height'] == 100
    # resize
    self.c.window.set_size_floating(50, 90, 42, 42)
    assert self.c.window.info()['width'] == 50
    assert self.c.window.info()['height'] == 90
    self.c.window.toggle_floating()
    assert self.c.window.info()['width'] == 798
    assert self.c.window.info()['height'] == 578
    # float again, should use last float size
    self.c.window.toggle_floating()
    assert self.c.window.info()['width'] == 50
    assert self.c.window.info()['height'] == 90

    # make sure it works through min and max
    self.c.window.toggle_maximize()
    self.c.window.toggle_minimize()
    self.c.window.toggle_minimize()
    self.c.window.toggle_floating()
    assert self.c.window.info()['width'] == 50
    assert self.c.window.info()['height'] == 90


@Xephyr(False, TestConfig())
def test_float_max_min_combo(self):
    # change to 2 col stack
    self.c.nextlayout()
    assert len(self.c.layout.info()["stacks"]) == 2
    self.testXterm()
    self.testXeyes()

    assert self.c.group.info()['focus'] == 'xeyes'
    assert self.c.window.info()['width'] == 398
    assert self.c.window.info()['height'] == 578
    assert self.c.window.info()['x'] == 400
    assert self.c.window.info()['y'] == 0
    assert self.c.window.info()['floating'] == False

    self.c.window.toggle_maximize()
    assert self.c.window.info()['floating'] == True
    assert self.c.window.info()['maximized'] == True
    assert self.c.window.info()['width'] == 800
    assert self.c.window.info()['height'] == 580
    assert self.c.window.info()['x'] == 0
    assert self.c.window.info()['y'] == 0

    self.c.window.toggle_minimize()
    assert self.c.group.info()['focus'] == 'xeyes'
    assert self.c.window.info()['floating'] == True
    assert self.c.window.info()['minimized'] == True
    assert self.c.window.info()['width'] == 800
    assert self.c.window.info()['height'] == 580
    assert self.c.window.info()['x'] == 0
    assert self.c.window.info()['y'] == 0

    self.c.window.toggle_floating()
    assert self.c.group.info()['focus'] == 'xeyes'
    assert self.c.window.info()['floating'] == False
    assert self.c.window.info()['minimized'] == False
    assert self.c.window.info()['maximized'] == False
    assert self.c.window.info()['width'] == 398
    assert self.c.window.info()['height'] == 578
    assert self.c.window.info()['x'] == 400
    assert self.c.window.info()['y'] == 0


@Xephyr(False, TestConfig())
def test_toggle_fullscreen(self):
    # change to 2 col stack
    self.c.nextlayout()
    assert len(self.c.layout.info()["stacks"]) == 2
    self.testXterm()
    self.testXeyes()

    assert self.c.group.info()['focus'] == 'xeyes'
    assert self.c.window.info()['width'] == 398
    assert self.c.window.info()['height'] == 578
    assert self.c.window.info()['float_info'] == {
        'y': 0, 'x': 400, 'w': 150, 'h': 100}
    assert self.c.window.info()['x'] == 400
    assert self.c.window.info()['y'] == 0

    self.c.window.toggle_fullscreen()
    assert self.c.window.info()['floating'] == True
    assert self.c.window.info()['maximized'] == False
    assert self.c.window.info()['fullscreen'] == True
    assert self.c.window.info()['width'] == 800
    assert self.c.window.info()['height'] == 600
    assert self.c.window.info()['x'] == 0
    assert self.c.window.info()['y'] == 0

    self.c.window.toggle_fullscreen()
    assert self.c.window.info()['floating'] == False
    assert self.c.window.info()['maximized'] == False
    assert self.c.window.info()['fullscreen'] == False
    assert self.c.window.info()['width'] == 398
    assert self.c.window.info()['height'] == 578
    assert self.c.window.info()['x'] == 400
    assert self.c.window.info()['y'] == 0


@Xephyr(False, TestConfig())
def test_toggle_max(self):
    # change to 2 col stack
    self.c.nextlayout()
    assert len(self.c.layout.info()["stacks"]) == 2
    self.testXterm()
    self.testXeyes()

    assert self.c.group.info()['focus'] == 'xeyes'
    assert self.c.window.info()['width'] == 398
    assert self.c.window.info()['height'] == 578
    assert self.c.window.info()['float_info'] == {
        'y': 0, 'x': 400, 'w': 150, 'h': 100}
    assert self.c.window.info()['x'] == 400
    assert self.c.window.info()['y'] == 0

    self.c.window.toggle_maximize()
    assert self.c.window.info()['floating'] == True
    assert self.c.window.info()['maximized'] == True
    assert self.c.window.info()['width'] == 800
    assert self.c.window.info()['height'] == 580
    assert self.c.window.info()['x'] == 0
    assert self.c.window.info()['y'] == 0

    self.c.window.toggle_maximize()
    assert self.c.window.info()['floating'] == False
    assert self.c.window.info()['maximized'] == False
    assert self.c.window.info()['width'] == 398
    assert self.c.window.info()['height'] == 578
    assert self.c.window.info()['x'] == 400
    assert self.c.window.info()['y'] == 0


@Xephyr(False, TestConfig())
def test_toggle_min(self):
    # change to 2 col stack
    self.c.nextlayout()
    assert len(self.c.layout.info()["stacks"]) == 2
    self.testXterm()
    self.testXeyes()

    assert self.c.group.info()['focus'] == 'xeyes'
    assert self.c.window.info()['width'] == 398
    assert self.c.window.info()['height'] == 578
    assert self.c.window.info()['float_info'] == {
        'y': 0, 'x': 400, 'w': 150, 'h': 100}
    assert self.c.window.info()['x'] == 400
    assert self.c.window.info()['y'] == 0

    self.c.window.toggle_minimize()
    assert self.c.group.info()['focus'] == 'xeyes'
    assert self.c.window.info()['floating'] == True
    assert self.c.window.info()['minimized'] == True
    assert self.c.window.info()['width'] == 398
    assert self.c.window.info()['height'] == 578
    assert self.c.window.info()['x'] == 400
    assert self.c.window.info()['y'] == 0

    self.c.window.toggle_minimize()
    assert self.c.group.info()['focus'] == 'xeyes'
    assert self.c.window.info()['floating'] == False
    assert self.c.window.info()['minimized'] == False
    assert self.c.window.info()['width'] == 398
    assert self.c.window.info()['height'] == 578
    assert self.c.window.info()['x'] == 400
    assert self.c.window.info()['y'] == 0


@Xephyr(False, TestConfig())
def test_toggle_floating(self):
    self.testXeyes()
    assert self.c.window.info()['floating'] == False
    self.c.window.toggle_floating()
    assert self.c.window.info()['floating'] == True
    self.c.window.toggle_floating()
    assert self.c.window.info()['floating'] == False
    self.c.window.toggle_floating()
    assert self.c.window.info()['floating'] == True

    #change layout (should still be floating)
    self.c.nextlayout()
    assert self.c.window.info()['floating'] == True


@Xephyr(False, TestConfig())
def test_floating_focus(self):
    # change to 2 col stack
    self.c.nextlayout()
    assert len(self.c.layout.info()["stacks"]) == 2
    self.testXterm()
    self.testXeyes()
    #self.testWindow("one")
    assert self.c.window.info()['width'] == 398
    assert self.c.window.info()['height'] == 578
    self.c.window.toggle_floating()
    self.c.window.move_floating(10, 20, 42, 42)
    assert self.c.window.info()['name'] == 'xeyes'
    assert self.c.group.info()['focus'] == 'xeyes'
    # check what stack thinks is focus
    assert [x['current'] for x in self.c.layout.info()['stacks']] == [0, 0]

    # change focus to xterm
    self.c.group.next_window()
    assert self.c.window.info()['width'] == 398
    assert self.c.window.info()['height'] == 578
    assert self.c.window.info()['name'] != 'xeyes'
    assert self.c.group.info()['focus'] != 'xeyes'
    # check what stack thinks is focus
    # check what stack thinks is focus
    assert [x['current'] for x in self.c.layout.info()['stacks']] == [0, 0]

    # focus back to xeyes
    self.c.group.next_window()
    assert self.c.window.info()['name'] == 'xeyes'
    # check what stack thinks is focus
    assert [x['current'] for x in self.c.layout.info()['stacks']] == [0, 0]

    # now focusing via layout is borked (won't go to float)
    self.c.layout.up()
    assert self.c.window.info()['name'] != 'xeyes'
    self.c.layout.up()
    assert self.c.window.info()['name'] != 'xeyes'
    # check what stack thinks is focus
    assert [x['current'] for x in self.c.layout.info()['stacks']] == [0, 0]

    # focus back to xeyes
    self.c.group.next_window()
    assert self.c.window.info()['name'] == 'xeyes'
    # check what stack thinks is focus
    assert [x['current'] for x in self.c.layout.info()['stacks']] == [0, 0]


@Xephyr(False, TestConfig())
def test_move_floating(self):
    self.testXeyes()
    #self.testWindow("one")
    assert self.c.window.info()['width'] == 798
    assert self.c.window.info()['height'] == 578

    assert self.c.window.info()['x'] == 0
    assert self.c.window.info()['y'] == 0
    self.c.window.toggle_floating()
    assert self.c.window.info()['floating'] == True

    self.c.window.move_floating(10, 20, 42, 42)
    assert self.c.window.info()['width'] == 150
    assert self.c.window.info()['height'] == 100
    assert self.c.window.info()['x'] == 10
    assert self.c.window.info()['y'] == 20

    self.c.window.set_size_floating(50, 90, 42, 42)
    assert self.c.window.info()['width'] == 50
    assert self.c.window.info()['height'] == 90
    assert self.c.window.info()['x'] == 10
    assert self.c.window.info()['y'] == 20

    self.c.window.resize_floating(10, 20, 42, 42)
    assert self.c.window.info()['width'] == 60
    assert self.c.window.info()['height'] == 110
    assert self.c.window.info()['x'] == 10
    assert self.c.window.info()['y'] == 20

    self.c.window.set_size_floating(10, 20, 42, 42)
    assert self.c.window.info()['width'] == 10
    assert self.c.window.info()['height'] == 20
    assert self.c.window.info()['x'] == 10
    assert self.c.window.info()['y'] == 20

    #change layout (x, y should be same)
    self.c.nextlayout()
    assert self.c.window.info()['width'] == 10
    assert self.c.window.info()['height'] == 20
    assert self.c.window.info()['x'] == 10
    assert self.c.window.info()['y'] == 20


@Xephyr(False, TestConfig(), randr=True)
def test_screens(self):
    assert len(self.c.screens())


@Xephyr(False, TestConfig(), randr=True)
def test_rotate(self):
    self.testWindow("one")
    s = self.c.screens()[0]
    height, width = s["height"], s["width"]
    subprocess.call(
        [
            "xrandr",
            "--output", "default",
            "-display", utils.DISPLAY,
            "--rotate", "left"
        ],
        stderr=subprocess.PIPE,
        stdout=subprocess.PIPE
    )
    s = self.c.screens()[0]
    assert s["height"] == width
    assert s["width"] == height


@Xephyr(False, TestConfig(), randr=True)
def test_resize_(self):
    self.testWindow("one")
    subprocess.call(
        [
            "xrandr",
            "-s", "480x640",
            "-display", utils.DISPLAY
        ]
    )
    d = self.c.screen.info()
    assert d["width"] == 480
    assert d["height"] == 640


# Due to https://github.com/nose-devs/nose/issues/478, nose 1.1.2 ignores
# attributes on yielded functions. Workaround is to attach the attribute
# to the generator function. Can be removed once the issue is resolved.
@attr('xephyr')
def qtile_tests():
    for config in (BareConfig, TestConfig):
        for xinerama in (True, False):
            @Xephyr(xinerama, config)
            def test_xeyes(self):
                self.testXeyes()
            yield test_xeyes

            @Xephyr(xinerama, config)
            def test_xterm(self):
                self.testXterm()
            yield test_xterm

            @Xephyr(xinerama, config)
            def test_xterm_kill(self):
                self.testXterm()
                self.c.window.kill()
                self.c.sync()
                time.sleep(0.1)
                assert not self.c.windows()
            yield test_xterm_kill

            @Xephyr(xinerama, config)
            def test_mapRequest(self):
                self.testWindow("one")
                info = self.c.groups()["a"]
                assert "one" in info["windows"]
                assert info["focus"] == "one"

                self.testWindow("two")
                info = self.c.groups()["a"]
                assert "two" in info["windows"]
                assert info["focus"] == "two"
            yield test_mapRequest

            @Xephyr(xinerama, config)
            def test_unmap(self):
                one = self.testWindow("one")
                two = self.testWindow("two")
                three = self.testWindow("three")
                info = self.c.groups()["a"]
                assert info["focus"] == "three"

                assert len(self.c.windows()) == 3
                self.kill(three)

                assert len(self.c.windows()) == 2
                info = self.c.groups()["a"]
                assert info["focus"] == "two"

                self.kill(two)
                assert len(self.c.windows()) == 1
                info = self.c.groups()["a"]
                assert info["focus"] == "one"

                self.kill(one)
                assert len(self.c.windows()) == 0
                info = self.c.groups()["a"]
                assert info["focus"] == None
            yield test_unmap

            @Xephyr(xinerama, config)
            def test_setgroup(self):
                self.testWindow("one")
                self.c.group["b"].toscreen()
                self._groupconsistency()
                if len(self.c.screens()) == 1:
                    assert self.c.groups()["a"]["screen"] == None
                else:
                    assert self.c.groups()["a"]["screen"] == 1
                assert self.c.groups()["b"]["screen"] == 0
                self.c.group["c"].toscreen()
                self._groupconsistency()
                assert self.c.groups()["c"]["screen"] == 0
            yield test_setgroup

            @Xephyr(xinerama, config)
            def test_unmap_noscreen(self):
                self.testWindow("one")
                pid = self.testWindow("two")
                assert len(self.c.windows()) == 2
                self.c.group["c"].toscreen()
                self._groupconsistency()
                self.c.status()
                assert len(self.c.windows()) == 2
                self.kill(pid)
                assert len(self.c.windows()) == 1
                assert self.c.groups()["a"]["focus"] == "one"
            yield test_unmap_noscreen


def test_init():
    assert_raises(
        libqtile.manager.QtileError,
        libqtile.config.Key,
        [], "unknown", libqtile.command._Call("base", None, "foo")
    )
    assert_raises(
        libqtile.manager.QtileError,
        libqtile.config.Key,
        ["unknown"], "x", libqtile.command._Call("base", None, "foo")
    )


class TScreen(libqtile.config.Screen):
    def setGroup(self, x):
        pass


def test_dx():
    s = TScreen(left=libqtile.bar.Gap(10))
    s._configure(None, 0, 0, 0, 100, 100, None)
    assert s.dx == 10


def test_dwidth():
    s = TScreen(left=libqtile.bar.Gap(10))
    s._configure(None, 0, 0, 0, 100, 100, None)
    assert s.dwidth == 90
    s.right = libqtile.bar.Gap(10)
    assert s.dwidth == 80


def test_dy():
    s = TScreen(top=libqtile.bar.Gap(10))
    s._configure(None, 0, 0, 0, 100, 100, None)
    assert s.dy == 10


def test_dheight():
    s = TScreen(top=libqtile.bar.Gap(10))
    s._configure(None, 0, 0, 0, 100, 100, None)
    assert s.dheight == 90
    s.bottom = libqtile.bar.Gap(10)
    assert s.dheight == 80


class _Config:
    groups = [
        libqtile.config.Group("a"),
        libqtile.config.Group("b"),
        libqtile.config.Group("c"),
        libqtile.config.Group("d")
    ]
    layouts = [
                libqtile.layout.stack.Stack(num_stacks=1),
                libqtile.layout.stack.Stack(num_stacks=2)
            ]
    floating_layout = libqtile.layout.floating.Floating()
    keys = [
        libqtile.config.Key(
            ["control"],
            "k",
            libqtile.command._Call([("layout", None)], "up")
        ),
        libqtile.config.Key(
            ["control"],
            "j",
            libqtile.command._Call([("layout", None)], "down")
        ),
    ]
    mouse = []
    screens = [libqtile.config.Screen(
            bottom=libqtile.bar.Bar(
                        [
                            libqtile.widget.GroupBox(),
                        ],
                        20
                    ),
    )]
    auto_fullscreen = True


class ClientNewStaticConfig(_Config):
    @staticmethod
    def main(c):
        def client_new(c):
            c.static(0)
        libqtile.hook.subscribe.client_new(client_new)


@Xephyr(False, ClientNewStaticConfig())
def test_minimal_(self):
    a = self.testWindow("one")
    self.kill(a)

if utils.whereis("gkrellm"):
    @Xephyr(False, ClientNewStaticConfig())
    def test_gkrellm(self):
        self.testGkrellm()
        time.sleep(0.1)


class ToGroupConfig(_Config):
    @staticmethod
    def main(c):
        def client_new(c):
            c.togroup("d")
        libqtile.hook.subscribe.client_new(client_new)


@Xephyr(False, ToGroupConfig())
def test_minimal__(self):
    self.c.group["d"].toscreen()
    self.c.group["a"].toscreen()
    a = self.testWindow("one")
    assert len(self.c.group["d"].info()["windows"]) == 1
    self.kill(a)

########NEW FILE########
__FILENAME__ = test_sh
import libqtile
import libqtile.sh
import libqtile.confreader
import libqtile.layout
import libqtile.manager
import libqtile.config
from utils import Xephyr


class ShConfig(object):
    keys = []
    mouse = []
    groups = [
        libqtile.config.Group("a"),
        libqtile.config.Group("b"),
    ]
    layouts = [
        libqtile.layout.Max(),
    ]
    floating_layout = libqtile.layout.floating.Floating()
    screens = [
        libqtile.config.Screen()
    ]
    main = None


@Xephyr(True, ShConfig())
def test_columnize(self):
    self.sh = libqtile.sh.QSh(self.c)
    assert self.sh.columnize(["one", "two"]) == "one  two"

    self.sh.termwidth = 1
    assert self.sh.columnize(["one", "two"]) == "one\ntwo"

    self.sh.termwidth = 15
    v = self.sh.columnize(["one", "two", "three", "four", "five"])
    assert v == 'one    two  \nthree  four \nfive '


@Xephyr(True, ShConfig())
def test_ls(self):
    self.sh = libqtile.sh.QSh(self.c)
    self.sh.do_cd("layout")
    self.sh.do_ls("")


@Xephyr(True, ShConfig())
def test_findNode(self):
    self.sh = libqtile.sh.QSh(self.c)
    n = self.sh._findNode(self.sh.current, "layout")
    assert n.path == "layout"
    assert n.parent

    n = self.sh._findNode(n, "0")
    assert n.path == "layout[0]"

    n = self.sh._findNode(n, "..")
    assert n.path == "layout"

    n = self.sh._findNode(n, "0", "..")
    assert n.path == "layout"

    n = self.sh._findNode(n, "..", "layout", 0)
    assert n.path == "layout[0]"

    assert not self.sh._findNode(n, "wibble")
    assert not self.sh._findNode(n, "..", "0", "wibble")


@Xephyr(True, ShConfig())
def test_do_cd(self):
    self.sh = libqtile.sh.QSh(self.c)
    assert not self.sh.do_cd("layout")
    assert self.sh.do_cd("0/wibble")
    assert not self.sh.do_cd("0/")


@Xephyr(True, ShConfig())
def test_call(self):
    self.sh = libqtile.sh.QSh(self.c)
    assert self.sh._call("status", []) == "OK"

    v = self.sh._call("nonexistent", "")
    assert "No such command" in v

    v = self.sh._call("status", "(((")
    assert "Syntax error" in v

    v = self.sh._call("status", "(1)")
    assert "Command exception" in v


@Xephyr(True, ShConfig())
def test_complete(self):
    self.sh = libqtile.sh.QSh(self.c)
    assert self.sh._complete("c", "c", 0) == "cd"
    assert self.sh._complete("c", "c", 1) == "commands"
    assert self.sh._complete("c", "c", 2) == "critical"
    assert self.sh._complete("c", "c", 3) is None

    assert self.sh._complete("cd l", "l", 0) == "layout"
    assert self.sh._complete("cd layout/", "layout/", 0) == "layout/group"
    assert self.sh._complete("cd layout/", "layout/g", 0) == "layout/group"


@Xephyr(True, ShConfig())
def test_help(self):
    self.sh = libqtile.sh.QSh(self.c)
    assert self.sh.do_help("nonexistent").startswith("No such command")
    assert self.sh.do_help("help")

########NEW FILE########
__FILENAME__ = test_utils
import libqtile.utils as utils

# TODO: more tests are required here. Several of the utilities are untested.


class Foo:
    ran = False

    @utils.LRUCache(2)
    def one(self, x):
        self.ran = True
        return x


def test_translate_masks():
    assert utils.translateMasks(["shift", "control"])
    assert utils.translateMasks([]) == 0


def test_lrucache_works_as_decorator():
    f = Foo()
    assert f.one(1) == 1
    assert f.one('test') == 'test'


def test_lrucache_caches():
    f = Foo()
    f.one(1)
    f.one(2)
    f.ran = False
    f.one(1)
    assert not f.ran
    f.one(2)
    assert not f.ran


def test_lrucache_discards_lru_item():
    f = Foo()
    f.one(1)
    assert f.ran
    f.ran = False
    f.one(1)
    assert not f.ran
    f.one(2)
    f.one(3)
    f.one(1)
    assert f.ran


def test_lrucache_maintains_size():
    f = Foo()
    f.one(1)
    f.one(2)
    f.one(3)
    assert len(f._cached_one) == 2
    assert len(f._cachelist_one) == 2


def test_rgb_from_hex_number():
    assert utils.rgb("ff00ff") == (1, 0, 1, 1)


def test_rgb_from_hex_string():
    assert utils.rgb("#00ff00") == (0, 1, 0, 1)


def test_rgb_from_hex_number_with_alpha():
    assert utils.rgb("ff0000.3") == (1, 0, 0, 0.3)


def test_rgb_from_hex_string_with_alpha():
    assert utils.rgb("#ff0000.5") == (1, 0, 0, 0.5)


def test_rgb_from_base10_tuple():
    assert utils.rgb([255, 255, 0]) == (1, 1, 0, 1)


def test_rgb_from_base10_tuple_with_alpha():
    assert utils.rgb([255, 255, 0, 0.5]) == (1, 1, 0, 0.5)

# TODO: test scrub to utf8
# TODO: test Data
# TODO: test issequencelike
# TODO: test isstringlike
# TODO: test shuffleUp, shuffleDown
# Probably do not require a whole lot of tests, but at least one for each
# function so that we can refactor with confidence.

########NEW FILE########
__FILENAME__ = utils
import libqtile
import libqtile.hook
import libqtile.ipc
import logging
import os
import subprocess
import sys
import time
import traceback
import Xlib.X
import Xlib.display
from nose.tools import with_setup, assert_raises
from nose.plugins.attrib import attr
from functools import wraps
WIDTH = 800
HEIGHT = 600
SECOND_WIDTH = 640
SECOND_HEIGHT = 480


def _find_display():
    """
        Returns the next available display
    """
    display = 1
    while os.path.exists("/tmp/.X%s-lock" % display):
        display += 1
    return display

DISPLAY = ":%s" % _find_display()


def whereis(program):
    for path in os.environ.get('PATH', '').split(':'):
        if os.path.exists(os.path.join(path, program)) and \
           not os.path.isdir(os.path.join(path, program)):
            return os.path.join(path, program)
    return None


class Xephyr(object):
    def __init__(self, xinerama, config, start_qtile=True,
                 randr=False, two_screens=True, xoffset=WIDTH,
                 width=WIDTH, height=HEIGHT):
        self.xinerama, self.randr = xinerama, randr
        self.config = config
        self.start_qtile = start_qtile
        self.name = "xephyr"
        if xinerama:
            self.name += "_xinerama"
        if randr:
            self.name += "_randr"
        self.two_screens = two_screens
        self.xoffset = xoffset
        self.display = DISPLAY
        self.xinerama = xinerama
        self.width = width
        self.height = height
        self.fname = '/tmp/qtilesocket'

    def __call__(self, function):
        def setup():
            args = [
                "Xephyr", "-keybd", "evdev",
                "-name", "qtile_test",
                self.display, "-ac",
                "-screen", "%sx%s" % (self.width, self.height)]
            if self.two_screens:
                args.extend(["-origin", "%s,0" % self.xoffset, "-screen",
                    "%sx%s" % (SECOND_WIDTH, SECOND_HEIGHT)])

            if self.xinerama:
                args.extend(["+xinerama"])
            if self.randr:
                args.extend(["+extension", "RANDR"])
            self.sub = subprocess.Popen(
                            args,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                        )
            time.sleep(0.05)
            self.testwindows = []
            if self.start_qtile:
                self.startQtile(self.config)

        def teardown():
            if self.start_qtile:
                libqtile.hook.clear()
                self.stopQtile()
            os.kill(self.sub.pid, 9)
            os.waitpid(self.sub.pid, 0)

        @wraps(function)
        def wrapped_fun():
            return function(self)

        return attr('xephyr')(with_setup(setup, teardown)(wrapped_fun))

    def _groupconsistency(self):
        groups = self.c.groups()
        screens = self.c.screens()
        seen = set()
        for g in groups.values():
            scrn = g["screen"]
            if scrn is not None:
                if scrn in seen:
                    raise AssertionError(
                        "Screen referenced from more than one group.")
                seen.add(scrn)
                assert screens[scrn]["group"] == g["name"]
        assert len(seen) == len(screens), "Not all screens \
        had an attached group."

    def _waitForXephyr(self):
        # Try until Xephyr is up
        for i in range(50):
            try:
                d = Xlib.display.Display(self.display)
                break
            except (Xlib.error.DisplayConnectionError,
                    Xlib.error.ConnectionClosedError):
                time.sleep(0.1)
        else:
            raise AssertionError("Could not connect to display.")
        d.close()
        del d

    def _waitForQtile(self):
        for i in range(20):
            try:
                if self.c.status() == "OK":
                    break
            except libqtile.ipc.IPCError:
                pass
            time.sleep(0.1)
        else:
            raise AssertionError("Timeout waiting for Qtile")

    def startQtile(self, config):
        self._waitForXephyr()
        pid = os.fork()
        if pid == 0:
            try:
                q = libqtile.manager.Qtile(
                    config, self.display, self.fname,
                    log=libqtile.manager.init_log(logging.CRITICAL))
                q.loop()
            except Exception:
                traceback.print_exc(file=sys.stderr)
            sys.exit(0)
        else:
            self.qtilepid = pid
            self.c = libqtile.command.Client(self.fname)
            self._waitForQtile()

    def stopQtile(self):
        assert self.c.status()
        if self.qtilepid:
            try:
                self._kill(self.qtilepid)
            except OSError:
                # The process may have died due to some other error
                pass
        for pid in self.testwindows[:]:
            self._kill(pid)

    def _testProc(self, path, args):
        if path is None:
            raise AssertionError("Trying to run None! (missing executable)")
        start = len(self.c.windows())
        pid = os.fork()
        if pid == 0:
            os.putenv("DISPLAY", self.display)
            os.execv(path, args)
        for i in range(20):
            if len(self.c.windows()) > start:
                break
            time.sleep(0.1)
        else:
            raise AssertionError("Window never appeared...")
        self.testwindows.append(pid)
        return pid

    def qtileRaises(self, exc, config):
        self._waitForXephyr()
        assert_raises(exc, libqtile.manager.Qtile,
                      config, self.display, self.fname)

    def testWindow(self, name):
        d = os.path.dirname(os.path.realpath(__file__))
        path = os.path.join(d, "scripts", "window.py")
        return self._testProc(
                    path,
                    [path, self.display, name]
                )

    def testXclock(self):
        path = whereis("xclock")
        return self._testProc(
                    path,
                    [path, "-display", self.display]
                )

    def testXeyes(self):
        path = whereis("xeyes")
        return self._testProc(
                    path,
                    [path, "-display", self.display]
                )

    def testGkrellm(self):
        path = whereis("gkrellm")
        return self._testProc(
                    path,
                    [path]
                )

    def testXterm(self):
        path = whereis("xterm")
        return self._testProc(
                    path,
                    [path, "-display", self.display]
                )

    def _kill(self, pid):
        os.kill(pid, 9)
        os.waitpid(pid, 0)
        if pid in self.testwindows:
            self.testwindows.remove(pid)

    def kill(self, pid):
        start = len(self.c.windows())
        self._kill(pid)
        for i in range(20):
            if len(self.c.windows()) < start:
                break
            time.sleep(0.1)
        else:
            raise AssertionError("Window could not be killed...")

########NEW FILE########
