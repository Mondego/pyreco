__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# GeoPy documentation build configuration file, created by
# sphinx-quickstart on Thu Oct 24 19:28:11 2013.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.intersphinx',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'GeoPy'
copyright = u'2013, GeoPy Contributors'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.96.0'
# The full version, including alpha/beta/rc tags.
release = '0.96.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'GeoPydoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
  ('index', 'GeoPy.tex', u'GeoPy Documentation',
   u'GeoPy Contributors', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'geopy', u'GeoPy Documentation',
     [u'GeoPy Contributors'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'GeoPy', u'GeoPy Documentation',
   u'GeoPy Contributors', 'GeoPy', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = compat
"""
Compatibility...
"""

import sys

py3k = sys.version_info >= (3, 0)

if py3k: # pragma: no cover
    string_compare = str
else: # pragma: no cover
    string_compare = (str, unicode)

if py3k: # pragma: no cover
    from urllib.parse import urlencode, quote # pylint: disable=W0611,F0401,W0611,E0611
    from urllib.request import (Request, urlopen, # pylint: disable=W0611,F0401,W0611,E0611
        build_opener, ProxyHandler, URLError, install_opener)
    from urllib.error import HTTPError # pylint: disable=W0611,F0401,W0611,E0611
else: # pragma: no cover
    from urllib import urlencode as original_urlencode, quote # pylint: disable=W0611,F0401,W0611,E0611
    from urllib2 import (Request, HTTPError,   # pylint: disable=W0611,F0401,W0611,E0611
        ProxyHandler, URLError, urlopen, build_opener, install_opener)

    def force_str(str_or_unicode):
        """
        Python2-only, ensures that a string is encoding to a str.
        """
        if isinstance(str_or_unicode, unicode):
            return str_or_unicode.encode('utf-8')
        else:
            return str_or_unicode

    def urlencode(query, doseq=0):
        """
        A version of Python's urllib.urlencode() function that can operate on
        unicode strings. The parameters are first cast to UTF-8 encoded strings
        and then encoded as per normal.

        Based on the urlencode from django.utils.http
        """
        if hasattr(query, 'items'):
            query = query.items()
        return original_urlencode(
            [(force_str(k),
              [force_str(i) for i in v]
              if isinstance(v, (list, tuple)) else force_str(v))
             for k, v in query],
            doseq)

########NEW FILE########
__FILENAME__ = distance
"""
.. versionadded:: 0.93

Geopy can calculate geodesic distance between two points using the
[Vincenty distance](https://en.wikipedia.org/wiki/Vincenty's_formulae) or
[great-circle distance](https://en.wikipedia.org/wiki/Great-circle_distance)
formulas, with a default of Vincenty available as the function
`geopy.distance.distance`.

Great-circle distance (:class:`.great_circle`) uses a spherical model of
the earth, using the average great-circle radius of 6372.795 kilometers,
resulting in an error of up to about 0.5%. The radius value is stored in
:const:`distance.EARTH_RADIUS`, so it can be customized
(it should always be in kilometers, however).

Vincenty distance (:class:`.vincenty`) uses a more accurate ellipsoidal model
of the earth. This is the default distance formula, and is thus aliased as
``distance.distance``. There are multiple popular ellipsoidal models, and
which one will be the most accurate depends on where your points are located
on the earth. The default is the WGS-84 ellipsoid, which is the most globally
accurate. geopy includes a few other
models in the distance.ELLIPSOIDS dictionary::

                  model             major (km)   minor (km)     flattening
    ELLIPSOIDS = {'WGS-84':        (6378.137,    6356.7523142,  1 / 298.257223563),
                  'GRS-80':        (6378.137,    6356.7523141,  1 / 298.257222101),
                  'Airy (1830)':   (6377.563396, 6356.256909,   1 / 299.3249646),
                  'Intl 1924':     (6378.388,    6356.911946,   1 / 297.0),
                  'Clarke (1880)': (6378.249145, 6356.51486955, 1 / 293.465),
                  'GRS-67':        (6378.1600,   6356.774719,   1 / 298.25),
                  }

Here's an example usage of distance.vincenty::

    >>> from geopy.distance import vincenty
    >>> newport_ri = (41.49008, -71.312796)
    >>> cleveland_oh = (41.499498, -81.695391)
    >>> vincenty(newport_ri, cleveland_oh).miles
    538.3904451566326

Using great-circle distance::

    >>> from geopy.distance import great_circle
    >>> newport_ri = (41.49008, -71.312796)
    >>> cleveland_oh = (41.499498, -81.695391)
    >>> great_circle(newport_ri, cleveland_oh).miles
    537.1485284062816

You can change the ellipsoid model used by the Vincenty formula like so::

    >>> distance.vincenty(ne, cl, ellipsoid='GRS-80').miles

The above model name will automatically be retrieved from the ELLIPSOIDS dictionary.
Alternatively, you can specify the model values directly::

    >>> distance.vincenty(ne, cl, ellipsoid=(6377., 6356., 1 / 297.)).miles

Distances support simple arithmetic, making it easy to do things like
calculate the length of a path::

    >>> d = distance.distance
    >>> _, wa = g.geocode('Washington, DC')
    >>> _, pa = g.geocode('Palo Alto, CA')
    >>> (d(ne, cl) + d(cl, wa) + d(wa, pa)).miles
    3276.157156868931

"""
from __future__ import division

from math import atan, tan, sin, cos, pi, sqrt, atan2, asin
from geopy.units import radians
from geopy import units, util
from geopy.point import Point
from geopy.compat import string_compare

# Average great-circle radius in kilometers, from Wikipedia.
# Using a sphere with this radius results in an error of up to about 0.5%.
EARTH_RADIUS = 6372.795

# From http://www.movable-type.co.uk/scripts/LatLongVincenty.html:
#   The most accurate and widely used globally-applicable model for the earth
#   ellipsoid is WGS-84, used in this script. Other ellipsoids offering a
#   better fit to the local geoid include Airy (1830) in the UK, International
#   1924 in much of Europe, Clarke (1880) in Africa, and GRS-67 in South
#   America. America (NAD83) and Australia (GDA) use GRS-80, functionally
#   equivalent to the WGS-84 ellipsoid.
ELLIPSOIDS = {
    # model           major (km)   minor (km)     flattening
    'WGS-84':        (6378.137,    6356.7523142,  1 / 298.257223563),
    'GRS-80':        (6378.137,    6356.7523141,  1 / 298.257222101),
    'Airy (1830)':   (6377.563396, 6356.256909,   1 / 299.3249646),
    'Intl 1924':     (6378.388,    6356.911946,   1 / 297.0),
    'Clarke (1880)': (6378.249145, 6356.51486955, 1 / 293.465),
    'GRS-67':        (6378.1600,   6356.774719,   1 / 298.25)
}

class Distance(object):
    """
    Base for :class:`.great_circle` and :class:`.vincenty`.
    """

    def __init__(self, *args, **kwargs):
        kilometers = kwargs.pop('kilometers', 0)
        if len(args) == 1:
            # if we only get one argument we assume
            # it's a known distance instead of
            # calculating it first
            kilometers += args[0]
        elif len(args) > 1:
            for a, b in util.pairwise(args):
                kilometers += self.measure(a, b)

        kilometers += units.kilometers(**kwargs)
        self.__kilometers = kilometers

    def __add__(self, other):
        if isinstance(other, Distance):
            return self.__class__(self.kilometers + other.kilometers)
        else:
            raise TypeError(
                "Distance instance must be added with Distance instance."
            )

    def __neg__(self):
        return self.__class__(-self.kilometers)

    def __sub__(self, other):
        return self + -other

    def __mul__(self, other):
        return self.__class__(self.kilometers * other)

    def __div__(self, other):
        if isinstance(other, Distance):
            return self.kilometers / other.kilometers
        else:
            return self.__class__(self.kilometers / other)

    __truediv__ = __div__

    def __abs__(self):
        return self.__class__(abs(self.kilometers))

    def __nonzero__(self):
        return bool(self.kilometers)

    __bool__ = __nonzero__

    def measure(self, a, b):
        raise NotImplementedError()

    def __repr__(self): # pragma: no cover
        return 'Distance(%s)' % self.kilometers

    def __str__(self): # pragma: no cover
        return '%s km' % self.__kilometers

    def __cmp__(self, other):
        if isinstance(other, Distance):
            return cmp(self.kilometers, other.kilometers)
        else:
            return cmp(self.kilometers, other)

    @property
    def kilometers(self): # pylint: disable=C0111
        return self.__kilometers

    @property
    def km(self): # pylint: disable=C0111
        return self.kilometers

    @property
    def meters(self): # pylint: disable=C0111
        return units.meters(kilometers=self.kilometers)

    @property
    def m(self): # pylint: disable=C0111
        return self.meters

    @property
    def miles(self): # pylint: disable=C0111
        return units.miles(kilometers=self.kilometers)

    @property
    def mi(self): # pylint: disable=C0111
        return self.miles

    @property
    def feet(self): # pylint: disable=C0111
        return units.feet(kilometers=self.kilometers)

    @property
    def ft(self): # pylint: disable=C0111
        return self.feet

    @property
    def nautical(self): # pylint: disable=C0111
        return units.nautical(kilometers=self.kilometers)

    @property
    def nm(self): # pylint: disable=C0111
        return self.nautical


class great_circle(Distance):
    """
    Use spherical geometry to calculate the surface distance between two
    geodesic points. This formula can be written many different ways,
    including just the use of the spherical law of cosines or the haversine
    formula.

    Set which radius of the earth to use by specifying a 'radius' keyword
    argument. It must be in kilometers. The default is to use the module
    constant `EARTH_RADIUS`, which uses the average great-circle radius.

    Example::

        >>> from geopy.distance import great_circle
        >>> newport_ri = (41.49008, -71.312796)
        >>> cleveland_oh = (41.499498, -81.695391)
        >>> great_circle(newport_ri, cleveland_oh).miles
        537.1485284062816

    """

    def __init__(self, *args, **kwargs):
        self.RADIUS = kwargs.pop('radius', EARTH_RADIUS)
        super(great_circle, self).__init__(*args, **kwargs)

    def measure(self, a, b):
        a, b = Point(a), Point(b)

        lat1, lng1 = radians(degrees=a.latitude), radians(degrees=a.longitude)
        lat2, lng2 = radians(degrees=b.latitude), radians(degrees=b.longitude)

        sin_lat1, cos_lat1 = sin(lat1), cos(lat1)
        sin_lat2, cos_lat2 = sin(lat2), cos(lat2)

        delta_lng = lng2 - lng1
        cos_delta_lng, sin_delta_lng = cos(delta_lng), sin(delta_lng)

        d = atan2(sqrt((cos_lat2 * sin_delta_lng) ** 2 +
                       (cos_lat1 * sin_lat2 -
                        sin_lat1 * cos_lat2 * cos_delta_lng) ** 2),
                  sin_lat1 * sin_lat2 + cos_lat1 * cos_lat2 * cos_delta_lng)

        return self.RADIUS * d

    def destination(self, point, bearing, distance=None): # pylint: disable=W0621
        """
        TODO docs.
        """
        point = Point(point)
        lat1 = units.radians(degrees=point.latitude)
        lng1 = units.radians(degrees=point.longitude)
        bearing = units.radians(degrees=bearing)

        if distance is None:
            distance = self
        if isinstance(distance, Distance):
            distance = distance.kilometers

        d_div_r = float(distance) / self.RADIUS

        lat2 = asin(
            sin(lat1) * cos(d_div_r) +
            cos(lat1) * sin(d_div_r) * cos(bearing)
        )

        lng2 = lng1 + atan2(
            sin(bearing) * sin(d_div_r) * cos(lat1),
            cos(d_div_r) - sin(lat1) * sin(lat2)
        )

        return Point(units.degrees(radians=lat2), units.degrees(radians=lng2))


class vincenty(Distance):
    """
    Calculate the geodesic distance between two points using the formula
    devised by Thaddeus Vincenty, with an accurate ellipsoidal model of the
    earth.

    Set which ellipsoidal model of the earth to use by specifying an
    ``ellipsoid`` keyword argument. The default is 'WGS-84', which is the
    most globally accurate model.  If ``ellipsoid`` is a string, it is
    looked up in the `ELLIPSOIDS` dictionary to obtain the major and minor
    semiaxes and the flattening. Otherwise, it should be a tuple with those
    values.  See the comments above the `ELLIPSOIDS` dictionary for
    more information.

    Example::

        >>> from geopy.distance import vincenty
        >>> newport_ri = (41.49008, -71.312796)
        >>> cleveland_oh = (41.499498, -81.695391)
        >>> vincenty(newport_ri, cleveland_oh).miles
        538.3904451566326

    Note: This implementation of Vincenty distance fails to converge for
    some valid points. In some cases, a result can be obtained by increasing
    the number of iterations (`iterations` keyword argument, given in the
    class `__init__`, with a default of 20). It may be preferable to use
    :class:`.great_circle`, which is marginally less accurate, but always
    produces a result.
    """

    ellipsoid_key = None
    ELLIPSOID = None

    def __init__(self, *args, **kwargs):
        self.set_ellipsoid(kwargs.pop('ellipsoid', 'WGS-84'))
        self.iterations = kwargs.pop('iterations', 20)
        major, minor, f = self.ELLIPSOID # pylint: disable=W0612
        super(vincenty, self).__init__(*args, **kwargs)

    def set_ellipsoid(self, ellipsoid):
        """
        Change the ellipsoid used in the calculation.
        """
        if not isinstance(ellipsoid, (list, tuple)):
            try:
                self.ELLIPSOID = ELLIPSOIDS[ellipsoid]
                self.ellipsoid_key = ellipsoid
            except KeyError:
                raise Exception(
                    "Invalid ellipsoid. See geopy.distance.ELIPSOIDS"
                )
        else:
            self.ELLIPSOID = ellipsoid
            self.ellipsoid_key = None
        return

    def measure(self, a, b):
        a, b = Point(a), Point(b)
        lat1, lng1 = radians(degrees=a.latitude), radians(degrees=a.longitude)
        lat2, lng2 = radians(degrees=b.latitude), radians(degrees=b.longitude)

        if isinstance(self.ELLIPSOID, string_compare):
            major, minor, f = ELLIPSOIDS[self.ELLIPSOID]
        else:
            major, minor, f = self.ELLIPSOID

        delta_lng = lng2 - lng1

        reduced_lat1 = atan((1 - f) * tan(lat1))
        reduced_lat2 = atan((1 - f) * tan(lat2))

        sin_reduced1, cos_reduced1 = sin(reduced_lat1), cos(reduced_lat1)
        sin_reduced2, cos_reduced2 = sin(reduced_lat2), cos(reduced_lat2)

        lambda_lng = delta_lng
        lambda_prime = 2 * pi

        iter_limit = self.iterations

        i = 0
        while abs(lambda_lng - lambda_prime) > 10e-12 and i <= iter_limit:
            i += 1

            sin_lambda_lng, cos_lambda_lng = sin(lambda_lng), cos(lambda_lng)

            sin_sigma = sqrt(
                (cos_reduced2 * sin_lambda_lng) ** 2 +
                (cos_reduced1 * sin_reduced2 -
                 sin_reduced1 * cos_reduced2 * cos_lambda_lng) ** 2
            )

            if sin_sigma == 0:
                return 0 # Coincident points

            cos_sigma = (
                sin_reduced1 * sin_reduced2 +
                cos_reduced1 * cos_reduced2 * cos_lambda_lng
            )

            sigma = atan2(sin_sigma, cos_sigma)

            sin_alpha = (
                cos_reduced1 * cos_reduced2 * sin_lambda_lng / sin_sigma
            )
            cos_sq_alpha = 1 - sin_alpha ** 2

            if cos_sq_alpha != 0:
                cos2_sigma_m = cos_sigma - 2 * (
                    sin_reduced1 * sin_reduced2 / cos_sq_alpha
                )
            else:
                cos2_sigma_m = 0.0 # Equatorial line

            C = f / 16. * cos_sq_alpha * (4 + f * (4 - 3 * cos_sq_alpha))

            lambda_prime = lambda_lng
            lambda_lng = (
                delta_lng + (1 - C) * f * sin_alpha * (
                    sigma + C * sin_sigma * (
                        cos2_sigma_m + C * cos_sigma * (
                            -1 + 2 * cos2_sigma_m ** 2
                        )
                    )
                )
            )

        if i > iter_limit:
            raise ValueError("Vincenty formula failed to converge!")

        u_sq = cos_sq_alpha * (major ** 2 - minor ** 2) / minor ** 2

        A = 1 + u_sq / 16384. * (
            4096 + u_sq * (-768 + u_sq * (320 - 175 * u_sq))
        )

        B = u_sq / 1024. * (256 + u_sq * (-128 + u_sq * (74 - 47 * u_sq)))

        delta_sigma = (
            B * sin_sigma * (
                cos2_sigma_m + B / 4. * (
                    cos_sigma * (
                        -1 + 2 * cos2_sigma_m ** 2
                    ) - B / 6. * cos2_sigma_m * (
                        -3 + 4 * sin_sigma ** 2
                    ) * (
                        -3 + 4 * cos2_sigma_m ** 2
                    )
                )
            )
        )

        s = minor * A * (sigma - delta_sigma)
        return s

    def destination(self, point, bearing, distance=None): # pylint: disable=W0621
        """
        TODO docs.
        """
        point = Point(point)
        lat1 = units.radians(degrees=point.latitude)
        lng1 = units.radians(degrees=point.longitude)
        bearing = units.radians(degrees=bearing)

        if distance is None:
            distance = self
        if isinstance(distance, Distance):
            distance = distance.kilometers

        ellipsoid = self.ELLIPSOID
        if isinstance(ellipsoid, string_compare):
            ellipsoid = ELLIPSOIDS[ellipsoid]

        major, minor, f = ellipsoid

        tan_reduced1 = (1 - f) * tan(lat1)
        cos_reduced1 = 1 / sqrt(1 + tan_reduced1 ** 2)
        sin_reduced1 = tan_reduced1 * cos_reduced1
        sin_bearing, cos_bearing = sin(bearing), cos(bearing)
        sigma1 = atan2(tan_reduced1, cos_bearing)
        sin_alpha = cos_reduced1 * sin_bearing
        cos_sq_alpha = 1 - sin_alpha ** 2
        u_sq = cos_sq_alpha * (major ** 2 - minor ** 2) / minor ** 2

        A = 1 + u_sq / 16384. * (
            4096 + u_sq * (-768 + u_sq * (320 - 175 * u_sq))
        )
        B = u_sq / 1024. * (256 + u_sq * (-128 + u_sq * (74 - 47 * u_sq)))

        sigma = distance / (minor * A)
        sigma_prime = 2 * pi

        while abs(sigma - sigma_prime) > 10e-12:
            cos2_sigma_m = cos(2 * sigma1 + sigma)
            sin_sigma, cos_sigma = sin(sigma), cos(sigma)
            delta_sigma = B * sin_sigma * (
                cos2_sigma_m + B / 4. * (
                    cos_sigma * (
                        -1 + 2 * cos2_sigma_m
                    ) - B / 6. * cos2_sigma_m * (
                        -3 + 4 * sin_sigma ** 2) * (
                        -3 + 4 * cos2_sigma_m ** 2
                    )
                )
            )
            sigma_prime = sigma
            sigma = distance / (minor * A) + delta_sigma

        sin_sigma, cos_sigma = sin(sigma), cos(sigma)

        lat2 = atan2(
            sin_reduced1 * cos_sigma + cos_reduced1 * sin_sigma * cos_bearing,
            (1 - f) * sqrt(
                sin_alpha ** 2 + (
                    sin_reduced1 * sin_sigma -
                    cos_reduced1 * cos_sigma * cos_bearing
                ) ** 2
            )
        )

        lambda_lng = atan2(
            sin_sigma * sin_bearing,
            cos_reduced1 * cos_sigma - sin_reduced1 * sin_sigma * cos_bearing
        )

        C = f / 16. * cos_sq_alpha * (4 + f * (4 - 3 * cos_sq_alpha))

        delta_lng = (
            lambda_lng - (1 - C) * f * sin_alpha * (
                sigma + C * sin_sigma * (
                    cos2_sigma_m + C * cos_sigma * (
                        -1 + 2 * cos2_sigma_m ** 2
                    )
                )
            )
        )

        lng2 = lng1 + delta_lng

        return Point(units.degrees(radians=lat2), units.degrees(radians=lng2))


# Set the default distance formula to the most generally accurate.

distance = VincentyDistance = vincenty
GreatCircleDistance = great_circle

########NEW FILE########
__FILENAME__ = exc
"""
Exceptions raised by geopy.
"""

class GeopyError(Exception):
    """
    Geopy-specific exceptions are all inherited from GeopyError.
    """

class ConfigurationError(GeopyError):
    """
    When instantiating a geocoder, the arguments given were invalid. See
    the documentation of each geocoder's `__init__` for more details.
    """

class GeocoderServiceError(GeopyError):
    """
    There was an exception caused when calling the remote geocoding service,
    and no more specific exception could be raised by geopy. When calling
    geocoders' `geocode` or `reverse` methods, this is the most general
    exception that can be raised, and any non-geopy exception will be caught
    and turned into this. The exception's message will be that of the
    original exception.
    """

class GeocoderQueryError(GeocoderServiceError):
    """
    The remote geocoding service raised a bad request over the user's input.
    """

class GeocoderQuotaExceeded(GeocoderServiceError):
    """
    The remote geocoding service refused to fulfill the request
    because the client has used its quota.
    """

class GeocoderAuthenticationFailure(GeocoderServiceError):
    """
    The remote geocoding service rejects the API key or account
    credentials this geocoder was instantiated with.
    """

class GeocoderInsufficientPrivileges(GeocoderServiceError):
    """
    The remote geocoding service refused to fulfill a request using the
    account credentials given.
    """

class GeocoderTimedOut(GeocoderServiceError):
    """
    The call to the geocoding service was aborted because no response
    was receiving within the `timeout` argument of either the geocoding class
    or, if specified, the method call. Some services are just consistently
    slow, and a higher timeout may be needed to use them.
    """

class GeocoderParseError(GeocoderServiceError):
    """
    Geopy could not parse the service's response. This is a bug in geopy.
    """

########NEW FILE########
__FILENAME__ = format
"""
Formatting...
"""

from geopy import units
from geopy.compat import py3k

if py3k:
    unichr = chr # pylint: disable=W0622

# Unicode characters for symbols that appear in coordinate strings.
DEGREE = unichr(176)
PRIME = unichr(8242)
DOUBLE_PRIME = unichr(8243)
ASCII_DEGREE = ''
ASCII_PRIME = "'"
ASCII_DOUBLE_PRIME = '"'
LATIN1_DEGREE = chr(176)
HTML_DEGREE = '&deg;'
HTML_PRIME = '&prime;'
HTML_DOUBLE_PRIME = '&Prime;'
XML_DECIMAL_DEGREE = '&#176;'
XML_DECIMAL_PRIME = '&#8242;'
XML_DECIMAL_DOUBLE_PRIME = '&#8243;'
XML_HEX_DEGREE = '&xB0;'
XML_HEX_PRIME = '&x2032;'
XML_HEX_DOUBLE_PRIME = '&x2033;'
ABBR_DEGREE = 'deg'
ABBR_ARCMIN = 'arcmin'
ABBR_ARCSEC = 'arcsec'

DEGREES_FORMAT = "%(degrees)d%(deg)s %(minutes)d%(arcmin)s %(seconds)s%(arcsec)s"

UNICODE_SYMBOLS = {
    'deg': DEGREE,
    'arcmin': PRIME,
    'arcsec': DOUBLE_PRIME
}
ASCII_SYMBOLS = {
    'deg': ASCII_DEGREE,
    'arcmin': ASCII_PRIME,
    'arcsec': ASCII_DOUBLE_PRIME
}
LATIN1_SYMBOLS = {
    'deg': LATIN1_DEGREE,
    'arcmin': ASCII_PRIME,
    'arcsec': ASCII_DOUBLE_PRIME
}
HTML_SYMBOLS = {
    'deg': HTML_DEGREE,
    'arcmin': HTML_PRIME,
    'arcsec': HTML_DOUBLE_PRIME
}
XML_SYMBOLS = {
    'deg': XML_DECIMAL_DEGREE,
    'arcmin': XML_DECIMAL_PRIME,
    'arcsec': XML_DECIMAL_DOUBLE_PRIME
}
ABBR_SYMBOLS = {
    'deg': ABBR_DEGREE,
    'arcmin': ABBR_ARCMIN,
    'arcsec': ABBR_ARCSEC
}

def format_degrees(degrees, fmt=DEGREES_FORMAT, symbols=None):
    """
    TODO docs.
    """
    symbols = symbols or ASCII_SYMBOLS
    arcminutes = round(units.arcminutes(degrees=degrees - int(degrees)))
    arcseconds = units.arcseconds(arcminutes=arcminutes - int(arcminutes))
    format_dict = dict(
        symbols,
        degrees=degrees,
        minutes=abs(arcminutes),
        seconds=abs(arcseconds)
    )
    return fmt % format_dict

DISTANCE_FORMAT = "%(magnitude)s%(unit)s"
DISTANCE_UNITS = {
    'km': lambda d: d,
    'm': lambda d: units.meters(kilometers=d),
    'mi': lambda d: units.miles(kilometers=d),
    'ft': lambda d: units.feet(kilometers=d),
    'nm': lambda d: units.nautical(kilometers=d),
    'nmi': lambda d: units.nautical(kilometers=d)
}
def format_distance(kilometers, fmt=DISTANCE_FORMAT, unit='km'):
    """
    TODO docs.
    """
    magnitude = DISTANCE_UNITS[unit](kilometers)
    return fmt % {'magnitude': magnitude, 'unit': unit}

_DIRECTIONS = [
    ('north', 'N'),
    ('north by east', 'NbE'),
    ('north-northeast', 'NNE'),
    ('northeast by north', 'NEbN'),
    ('northeast', 'NE'),
    ('northeast by east', 'NEbE'),
    ('east-northeast', 'ENE'),
    ('east by north', 'EbN'),
    ('east', 'E'),
    ('east by south', 'EbS'),
    ('east-southeast', 'ESE'),
    ('southeast by east', 'SEbE'),
    ('southeast', 'SE'),
    ('southeast by south', 'SEbS'),
]
DIRECTIONS, DIRECTIONS_ABBR = zip(*_DIRECTIONS)
ANGLE_DIRECTIONS = dict((n * 11.25, d) for n, d in enumerate(DIRECTIONS))
ANGLE_DIRECTIONS_ABBR = dict((n * 11.25, d) for n, d in enumerate(DIRECTIONS_ABBR))

########NEW FILE########
__FILENAME__ = arcgis
"""
:class:`.ArcGIS` geocoder.
"""

import json
from time import time
from geopy.compat import urlencode, Request

from geopy.geocoders.base import Geocoder, DEFAULT_SCHEME, DEFAULT_TIMEOUT, \
    DEFAULT_WKID
from geopy.exc import GeocoderServiceError, GeocoderAuthenticationFailure
from geopy.exc import ConfigurationError
from geopy.location import Location
from geopy.util import logger


class ArcGIS(Geocoder): # pylint: disable=R0921,R0902
    """
    Geocoder using the ERSI ArcGIS API. Documentation at:
        http://resources.arcgis.com/en/help/arcgis-rest-api
    """

    _TOKEN_EXPIRED = 498
    _MAX_RETRIES = 3
    auth_api = 'https://www.arcgis.com/sharing/generateToken'

    def __init__(self, username=None, password=None, referer=None, # pylint: disable=R0913
                 token_lifetime=60, scheme=DEFAULT_SCHEME,
                 timeout=DEFAULT_TIMEOUT, proxies=None):
        """
        Create a ArcGIS-based geocoder.

            .. versionadded:: 0.97

        :param string username: ArcGIS username. Required if authenticated
            mode is desired.

        :param string password: ArcGIS password. Required if authenticated
            mode is desired.

        :param string referer: Required if authenticated mode is desired.
            'Referer' HTTP header to send with each request,
            e.g., 'http://www.example.com'. This is tied to an issued token,
            so fielding queries for multiple referrers should be handled by
            having multiple ArcGIS geocoder instances.

        :param int token_lifetime: Desired lifetime, in minutes, of an
            ArcGIS-issued token.

        :param string scheme: Desired scheme. If authenticated mode is in use,
            it must be 'https'.

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception.

        :param dict proxies: If specified, routes this geocoder's requests
            through the specified proxy. E.g., {"https": "192.0.2.0"}. For
            more information, see documentation on
            :class:`urllib2.ProxyHandler`.
        """
        super(ArcGIS, self).__init__(scheme=scheme, timeout=timeout, proxies=proxies)
        if (username or password or referer):
            if not (username and password and referer):
                raise ConfigurationError(
                    "Authenticated mode requires username, password, and referer"
                )
            if self.scheme != 'https':
                raise ConfigurationError(
                    "Authenticated mode requires scheme of 'https'"
                )
            self._base_call_geocoder = self._call_geocoder
            self._call_geocoder = self._authenticated_call_geocoder

        self.username = username
        self.password = password
        self.referer = referer

        self.token = None
        self.token_lifetime = token_lifetime * 60 # store in seconds
        self.token_expiry = None
        self.retry = 1

        self.api = '%s://geocode.arcgis.com' \
                    '/arcgis/rest/services/World/GeocodeServer/find' % self.scheme
        self.reverse_api = '%s://geocode.arcgis.com' \
                    '/arcgis/rest/services/World/GeocodeServer/reverseGeocode' % self.scheme

    def _authenticated_call_geocoder(self, url, timeout=None):
        """
        Wrap self._call_geocoder, handling tokens.
        """
        if self.token is None or int(time()) > self.token_expiry:
            self._refresh_authentication_token()
        request = Request(
            "&token=".join((url, self.token)), # no urlencoding
            headers={"Referer": self.referer}
        )
        return self._base_call_geocoder(request, timeout=timeout)

    def geocode(self, query, exactly_one=True, timeout=None):
        """
        Geocode a location query.

        :param string query: The address or query you wish to geocode.

        :param bool exactly_one: Return one result or a list of results, if
            available.

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception. Set this only if you wish to override, on this call only,
            the value set during the geocoder's initialization.
        """
        # TODO: dict as query for parameterized query
        # TODO: SRID
        params = {'text': query, 'f': 'json'}
        if exactly_one is True:
            params['maxLocations'] = 1
        url = "?".join((self.api, urlencode(params)))
        logger.debug("%s.geocode: %s", self.__class__.__name__, url)
        response = self._call_geocoder(url, timeout=timeout)

        # Handle any errors; recursing in the case of an expired token.
        if 'error' in response:
            if response['error']['code'] == self._TOKEN_EXPIRED:
                self.retry += 1
                self._refresh_authentication_token()
                return self.geocode(query, exactly_one=exactly_one, timeout=timeout)
            raise GeocoderServiceError(str(response['error']))

        # Success; convert from the ArcGIS JSON format.
        if not len(response['locations']):
            return None
        geocoded = []
        for resource in response['locations']:
            geometry = resource['feature']['geometry']
            geocoded.append(
                Location(
                    resource['name'], (geometry['y'], geometry['x']), resource
                )
            )
        if exactly_one is True:
            return geocoded[0]
        return geocoded

    def reverse(self, query, exactly_one=True, timeout=None, # pylint: disable=R0913,W0221
                        distance=None, wkid=DEFAULT_WKID):
        """
        Given a point, find an address.

        :param query: The coordinates for which you wish to obtain the
            closest human-readable addresses.
        :type query: :class:`geopy.point.Point`, list or tuple of (latitude,
            longitude), or string as "%(latitude)s, %(longitude)s".

        :param bool exactly_one: Return one result, or a list?

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception. Set this only if you wish to override, on this call only,
            the value set during the geocoder's initialization.

        :param int distance: Distance from the query location, in meters,
            within which to search. ArcGIS has a default of 100 meters, if not
            specified.

        :param string wkid: WKID to use for both input and output coordinates.
        """
         # ArcGIS is lon,lat; maintain lat,lon convention of geopy
        point = self._coerce_point_to_string(query).split(",")
        if wkid != DEFAULT_WKID:
            location = {"x": point[1], "y": point[0], "spatialReference": wkid}
        else:
            location = ",".join((point[1], point[0]))
        params = {'location': location, 'f': 'json', 'outSR': wkid}
        if distance is not None:
            params['distance'] = distance
        url = "?".join((self.reverse_api, urlencode(params)))
        logger.debug("%s.reverse: %s", self.__class__.__name__, url)
        response = self._call_geocoder(url, timeout=timeout)
        if not len(response):
            return None
        if 'error' in response:
            if response['error']['code'] == self._TOKEN_EXPIRED:
                self.retry += 1
                self._refresh_authentication_token()
                return self.reverse(query, exactly_one=exactly_one,
                        timeout=timeout, distance=distance, wkid=wkid)
            raise GeocoderServiceError(str(response['error']))
        address = "%(Address)s, %(City)s, %(Region)s %(Postal)s, %(CountryCode)s" % \
            response['address']
        return Location(
            address,
            (response['location']['y'], response['location']['x']),
            response['address']
        )

    def _refresh_authentication_token(self):
        """
        POST to ArcGIS requesting a new token.
        """
        if self.retry == self._MAX_RETRIES:
            logger.debug('Maximum retries (%s) reached; giving up.', self._MAX_RETRIES)
            raise GeocoderAuthenticationFailure(
                'Too many retries for auth: %s' % self.retry
            )
        token_request_arguments = {
            'username': self.username,
            'password': self.password,
            'expiration': self.token_lifetime,
            'f': 'json'
        }
        token_request_arguments = "&".join(
            ["%s=%s" % (key, val) for key, val in token_request_arguments.items()]
        )
        url = "&".join((
            "?".join((self.auth_api, token_request_arguments)),
            urlencode({'referer': self.referer})
        ))
        logger.debug(
            "%s._refresh_authentication_token: %s", self.__class__.__name__, url
        )
        self.token_expiry = int(time()) + self.token_lifetime
        response = self._base_call_geocoder(url)
        if not 'token' in response:
            raise GeocoderAuthenticationFailure(
                'Missing token in auth request.'
                'Request URL: %s; response JSON: %s' %
                (url, json.dumps(response))
            )
        self.retry = 0
        self.token = response['token']

########NEW FILE########
__FILENAME__ = base
"""
:class:`.GeoCoder` base object from which other geocoders are templated.
"""

from ssl import SSLError
from socket import timeout as SocketTimeout
import json

from geopy.compat import string_compare, HTTPError, py3k, \
    urlopen as urllib_urlopen, build_opener, ProxyHandler, URLError, \
    install_opener
from geopy.point import Point
from geopy.exc import (GeocoderServiceError, ConfigurationError,
    GeocoderTimedOut, GeocoderAuthenticationFailure, GeocoderQuotaExceeded,
    GeocoderQueryError, GeocoderInsufficientPrivileges)
from geopy.util import decode_page

DEFAULT_FORMAT_STRING = '%s'
DEFAULT_SCHEME = 'https'
DEFAULT_TIMEOUT = 1
DEFAULT_WKID = 4326

ERROR_CODE_MAP = {
    400: GeocoderQueryError,
    401: GeocoderAuthenticationFailure,
    402: GeocoderQuotaExceeded,
    403: GeocoderInsufficientPrivileges,
    407: GeocoderAuthenticationFailure,
    412: GeocoderQueryError,
    413: GeocoderQueryError,
    414: GeocoderQueryError,
    502: GeocoderServiceError,
    503: GeocoderTimedOut,
    504: GeocoderTimedOut
}


class Geocoder(object): # pylint: disable=R0921
    """
    Template object for geocoders.
    """

    def __init__(self, format_string=DEFAULT_FORMAT_STRING, scheme=DEFAULT_SCHEME,
                        timeout=DEFAULT_TIMEOUT, proxies=None):
        """
        Mostly-common geocoder validation, proxies, &c. Not all geocoders
        specify format_string and such.
        """
        self.format_string = format_string
        self.scheme = scheme
        if self.scheme not in ('http', 'https'): # pragma: no cover
            raise ConfigurationError(
                'Supported schemes are `http` and `https`.'
            )
        self.proxies = proxies
        self.timeout = timeout

        if self.proxies:
            install_opener(
                build_opener(
                    ProxyHandler(self.proxies)
                )
            )
        self.urlopen = urllib_urlopen

    @staticmethod
    def _coerce_point_to_string(point):
        """
        Do the right thing on "point" input. For geocoders with reverse
        methods.
        """
        if isinstance(point, Point):
            return ",".join((str(point.latitude), str(point.longitude)))
        elif isinstance(point, (list, tuple)):
            return ",".join((str(point[0]), str(point[1]))) # -altitude
        elif isinstance(point, string_compare):
            return point
        else: # pragma: no cover
            raise ValueError("Invalid point")

    def _parse_json(self, page, exactly_one): # pragma: no cover
        """
        Template for subclasses
        """
        raise NotImplementedError()

    def _call_geocoder(self, url, timeout=None, raw=False):
        """
        For a generated query URL, get the results.
        """
        try:
            page = self.urlopen(url, timeout=timeout or self.timeout)
        except Exception as error: # pylint: disable=W0703
            message = (
                str(error) if not py3k
                else (
                    str(error.args[0])
                    if len(error.args)
                    else str(error)
                )
            )
            if hasattr(self, '_geocoder_exception_handler'):
                self._geocoder_exception_handler(error, message) # pylint: disable=E1101
            if isinstance(error, HTTPError):
                code = error.getcode()
                try:
                    raise ERROR_CODE_MAP[code](message)
                except KeyError:
                    raise GeocoderServiceError(message)
            elif isinstance(error, URLError):
                if "timed out" in message:
                    raise GeocoderTimedOut('Service timed out')
            elif isinstance(error, SocketTimeout):
                raise GeocoderTimedOut('Service timed out')
            elif isinstance(error, SSLError):
                if "timed out" in message:
                    raise GeocoderTimedOut('Service timed out')
            raise GeocoderServiceError(message)
        if raw:
            return page
        return json.loads(decode_page(page))

    def geocode(self, query, exactly_one=True, timeout=None): # pylint: disable=R0201,W0613
        """
        Implemented in subclasses.
        """
        raise NotImplementedError()

    def reverse(self, query, exactly_one=True, timeout=None): # pragma: no cover
        """
        Implemented in subclasses.
        """
        raise NotImplementedError()

########NEW FILE########
__FILENAME__ = bing
"""
:class:`.Bing` geocoder.
"""

from geopy.compat import urlencode
from geopy.geocoders.base import Geocoder, DEFAULT_FORMAT_STRING, \
    DEFAULT_TIMEOUT, DEFAULT_SCHEME
from geopy.location import Location
from geopy.util import logger, join_filter


class Bing(Geocoder):
    """
    Geocoder using the Bing Maps Locations API. Documentation at:
        https://msdn.microsoft.com/en-us/library/ff701715.aspx
    """

    def __init__(self, api_key, format_string=DEFAULT_FORMAT_STRING, # pylint: disable=R0913
                        scheme=DEFAULT_SCHEME, timeout=DEFAULT_TIMEOUT, proxies=None):
        """Initialize a customized Bing geocoder with location-specific
        address information and your Bing Maps API key.

        :param string api_key: Should be a valid Bing Maps API key.

        :param string format_string: String containing '%s' where the
            string to geocode should be interpolated before querying the
            geocoder. For example: '%s, Mountain View, CA'. The default
            is just '%s'.

        :param string scheme: Use 'https' or 'http' as the API URL's scheme.
            Default is https. Note that SSL connections' certificates are not
            verified.

            .. versionadded:: 0.97

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception.

            .. versionadded:: 0.97

        :param dict proxies: If specified, routes this geocoder's requests
            through the specified proxy. E.g., {"https": "192.0.2.0"}. For
            more information, see documentation on
            :class:`urllib2.ProxyHandler`.

            .. versionadded:: 0.96
        """
        super(Bing, self).__init__(format_string, scheme, timeout, proxies)
        self.api_key = api_key
        self.api = "%s://dev.virtualearth.net/REST/v1/Locations" % self.scheme

    def geocode(self, query, exactly_one=True, user_location=None, timeout=None):
        """
        Geocode an address.

        :param string query: The address or query you wish to geocode.

        :param bool exactly_one: Return one result or a list of results, if
            available.

        :param user_location: Prioritize results closer to
            this location.

            .. versionadded:: 0.96

        :type user_location: :class:`geopy.point.Point`

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception. Set this only if you wish to override, on this call only,
            the value set during the geocoder's initialization.

            .. versionadded:: 0.97
        """
        params = {
            'query': self.format_string % query,
            'key': self.api_key
        }
        if user_location:
            params['userLocation'] = ",".join(
                (str(user_location.latitude), str(user_location.longitude))
            )
        if exactly_one is True:
            params['maxResults'] = 1

        url = "?".join((self.api, urlencode(params)))
        logger.debug("%s.geocode: %s", self.__class__.__name__, url)
        return self._parse_json(self._call_geocoder(url, timeout=timeout), exactly_one)

    def reverse(self, query, exactly_one=True, timeout=None): # pylint: disable=W0221
        """
        Reverse geocode a point.

        :param query: The coordinates for which you wish to obtain the
            closest human-readable addresses.
        :type query: :class:`geopy.point.Point`, list or tuple of (latitude,
            longitude), or string as "%(latitude)s, %(longitude)s".

        :param bool exactly_one: Return one result, or a list?

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception. Set this only if you wish to override, on this call only,
            the value set during the geocoder's initialization.

            .. versionadded:: 0.97
        """
        point = self._coerce_point_to_string(query)
        params = {'key': self.api_key}
        url = "%s/%s?%s" % (
            self.api, point, urlencode(params))

        logger.debug("%s.reverse: %s", self.__class__.__name__, url)
        return self._parse_json(self._call_geocoder(url, timeout=timeout), exactly_one)

    @staticmethod
    def _parse_json(doc, exactly_one=True): # pylint: disable=W0221
        """
        Parse a location name, latitude, and longitude from an JSON response.
        """
        resources = doc['resourceSets'][0]['resources']
        if resources is None or not len(resources): # pragma: no cover
            return None

        def parse_resource(resource):
            """
            Parse each return object.
            """
            stripchars = ", \n"
            addr = resource['address']

            address = addr.get('addressLine', '').strip(stripchars)
            city = addr.get('locality', '').strip(stripchars)
            state = addr.get('adminDistrict', '').strip(stripchars)
            zipcode = addr.get('postalCode', '').strip(stripchars)
            country = addr.get('countryRegion', '').strip(stripchars)

            city_state = join_filter(", ", [city, state])
            place = join_filter(" ", [city_state, zipcode])
            location = join_filter(", ", [address, place, country])

            latitude = resource['point']['coordinates'][0] or None
            longitude = resource['point']['coordinates'][1] or None
            if latitude and longitude:
                latitude = float(latitude)
                longitude = float(longitude)

            return Location(location, (latitude, longitude), resource)

        if exactly_one:
            return parse_resource(resources[0])
        else:
            return [parse_resource(resource) for resource in resources]

########NEW FILE########
__FILENAME__ = dot_us
"""
:class:`GeocoderDotUS` geocoder.
"""

import csv
from base64 import encodestring
from geopy.compat import urlencode, py3k, Request
from geopy.geocoders.base import Geocoder, DEFAULT_FORMAT_STRING, \
    DEFAULT_TIMEOUT
from geopy.location import Location
from geopy.exc import ConfigurationError
from geopy.util import logger, join_filter


class GeocoderDotUS(Geocoder): # pylint: disable=W0223
    """
    GeocoderDotUS geocoder, documentation at:
        http://geocoder.us/

    Note that GeocoderDotUS does not support SSL.
    """

    def __init__(self, username=None, password=None, # pylint: disable=R0913
                        format_string=DEFAULT_FORMAT_STRING,
                        timeout=DEFAULT_TIMEOUT, proxies=None):
        """
        :param string username:

        :param string password:

        :param string format_string: String containing '%s' where the
            string to geocode should be interpolated before querying the
            geocoder. For example: '%s, Mountain View, CA'. The default
            is just '%s'.

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising an :class:`geopy.exc.GeocoderTimedOut`
            exception.

            .. versionadded:: 0.97

        :param dict proxies: If specified, routes this geocoder's requests
            through the specified proxy. E.g., {"https": "192.0.2.0"}. For
            more information, see documentation on
            :class:`urllib2.ProxyHandler`.

            .. versionadded:: 0.96
        """
        super(GeocoderDotUS, self).__init__(
            format_string=format_string, timeout=timeout, proxies=proxies
        )
        if username or password:
            if not (username and password):
                raise ConfigurationError(
                    "Username and password must both specified"
                )
            self.authenticated = True
            self.api = "http://geocoder.us/member/service/namedcsv"
        else:
            self.authenticated = False
            self.api = "http://geocoder.us/service/namedcsv"
        self.username = username
        self.password = password

    def geocode(self, query, exactly_one=True, timeout=None): # pylint: disable=W0613,W0221
        """
        Geocode a location query.

        :param string query: The address or query you wish to geocode.

        :param bool exactly_one: Return one result or a list of results, if
            available.

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception. Set this only if you wish to override, on this call only,
            the value set during the geocoder's initialization.

            .. versionadded:: 0.97
        """
        query_str = self.format_string % query

        url = "?".join((self.api, urlencode({'address':query_str})))
        logger.debug("%s.geocode: %s", self.__class__.__name__, url)
        if self.authenticated is True:
            auth = " ".join((
                "Basic",
                encodestring(":".join((self.username, self.password))\
                    .encode('utf-8')).strip().decode('utf-8')
            ))
            url = Request(url, headers={"Authorization": auth})
        page = self._call_geocoder(url, timeout=timeout, raw=True)
        content = page.read().decode("utf-8") if py3k else page.read()
        places = [
            r for r in csv.reader(
                [content, ] if not isinstance(content, list)
                else content
            )
        ]
        if not len(places):
            return None
        if exactly_one is True:
            return self._parse_result(places[0])
        else:
            result = [self._parse_result(res) for res in places]
            if None in result: # todo
                return None
            return result

    @staticmethod
    def _parse_result(result):
        """
        Parse individual results. Different, but lazy actually, so... ok.
        """
        # turn x=y pairs ("lat=47.6", "long=-117.426") into dict key/value pairs:
        place = dict(
            [x.split('=') for x in result if len(x.split('=')) > 1]
        )
        if 'error' in place:
            if "couldn't find" in place['error']:
                return None

        address = [
            place.get('number', None),
            place.get('prefix', None),
            place.get('street', None),
            place.get('type', None),
            place.get('suffix', None)
        ]
        city = place.get('city', None)
        state = place.get('state', None)
        zip_code = place.get('zip', None)

        name = join_filter(", ", [
            join_filter(" ", address),
            city,
            join_filter(" ", [state, zip_code])
        ])

        latitude = place.get('lat', None)
        longitude = place.get('long', None)
        if latitude and longitude:
            latlon = float(latitude), float(longitude)
        else:
            return None
        return Location(name, latlon, place)

########NEW FILE########
__FILENAME__ = geocodefarm
"""
:class:`.GeocodeFarm` geocoder.
"""

from geopy.geocoders.base import Geocoder, DEFAULT_FORMAT_STRING, \
    DEFAULT_TIMEOUT
from geopy.location import Location
from geopy.util import logger
from geopy.exc import GeocoderAuthenticationFailure, GeocoderQuotaExceeded, \
    GeocoderServiceError
from geopy.compat import quote


class GeocodeFarm(Geocoder):
    """
    Geocoder using the GeocodeFarm API. Documentation at:
        https://www.geocodefarm.com/dashboard/documentation/
    """

    def __init__(self, api_key, format_string=DEFAULT_FORMAT_STRING, # pylint: disable=R0913
                        timeout=DEFAULT_TIMEOUT, proxies=None):
        """
        Create a geocoder for GeocodeFarm.

            .. versionadded:: 0.99

        :param string api_key: The API key required by GeocodeFarm to perform
            geocoding requests.

        :param string format_string: String containing '%s' where the
            string to geocode should be interpolated before querying the
            geocoder. For example: '%s, Mountain View, CA'. The default
            is just '%s'.

        :param dict proxies: If specified, routes this geocoder's requests
            through the specified proxy. E.g., {"https": "192.0.2.0"}. For
            more information, see documentation on
            :class:`urllib2.ProxyHandler`.

        Note that the GeocodeFarm geocoder does not support SSL.
        """
        super(GeocodeFarm, self).__init__(format_string, 'http', timeout, proxies)
        self.api_key = api_key
        self.format_string = format_string
        self.api = (
            "%s://www.geocodefarm.com/api/forward/json/%s/" %
            (self.scheme, self.api_key)
        )
        self.reverse_api = (
            "%s://www.geocodefarm.com/api/reverse/json/%s/" %
            (self.scheme, self.api_key)
        )

    def geocode(self, query, exactly_one=True, timeout=None):
        """
        Geocode a location query.

        :param string query: The address or query you wish to geocode.

        :param bool exactly_one: Return one result or a list of results, if
            available. GeocodeFarm's API will always return at most one
            result.

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception. Set this only if you wish to override, on this call only,
            the value set during the geocoder's initialization.
        """
        url = "".join((
            self.api,
            quote((self.format_string % query).encode('utf8'))
        ))
        logger.debug("%s.geocode: %s", self.__class__.__name__, url)
        return self._parse_json(
            self._call_geocoder(url, timeout=timeout), exactly_one
        )

    def reverse(self, query, exactly_one=True, timeout=None):
        """
        Returns a reverse geocoded location.

        :param query: The coordinates for which you wish to obtain the
            closest human-readable addresses.
        :type query: :class:`geopy.point.Point`, list or tuple of (latitude,
            longitude), or string as "%(latitude)s, %(longitude)s"

        :param bool exactly_one: Return one result or a list of results, if
            available. GeocodeFarm's API will always return at most one
            result.

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception. Set this only if you wish to override, on this call only,
            the value set during the geocoder's initialization.
        """
        lat, lon = self._coerce_point_to_string(query).split(',')
        url = "".join((
            self.reverse_api,
            quote(("%s/%s" % (lat, lon)).encode('utf8'))
        ))
        logger.debug("%s.reverse: %s", self.__class__.__name__, url)
        return self._parse_json(
            self._call_geocoder(url, timeout=timeout), exactly_one
        )

    @staticmethod
    def parse_code(place):
        """
        Parse each resource.
        """
        coordinates = place.get('COORDINATES', {})
        address = place.get('ADDRESS', {})
        latitude = coordinates.get('latitude', None)
        longitude = coordinates.get('longitude', None)
        placename = address.get('address_returned', None)
        if placename is None:
            placename = address.get('address', None)
        if latitude and longitude:
            latitude = float(latitude)
            longitude = float(longitude)
        return Location(placename, (latitude, longitude), place)

    def _parse_json(self, api_result, exactly_one):
        if api_result is None:
            return None
        geocoding_results = api_result["geocoding_results"]
        self._check_for_api_errors(geocoding_results)

        place = self.parse_code(geocoding_results)
        if exactly_one is True:
            return place
        else:
            return [place]  # GeocodeFarm always only returns one result

    @staticmethod
    def _check_for_api_errors(geocoding_results):
        """
        Raise any exceptions if there were problems reported
        in the api response.
        """
        status_result = geocoding_results.get("STATUS", {})
        api_call_success = status_result.get("status", "") == "SUCCESS"
        if not api_call_success:
            access_error = status_result.get("access")
            access_error_to_exception = {
                'API_KEY_INVALID': GeocoderAuthenticationFailure,
                'OVER_QUERY_LIMIT': GeocoderQuotaExceeded,
            }
            exception_cls = access_error_to_exception.get(
                access_error, GeocoderServiceError
            )
            raise exception_cls(access_error)

########NEW FILE########
__FILENAME__ = geonames
"""
:class:`GeoNames` geocoder.
"""

from geopy.compat import urlencode

from geopy.geocoders.base import Geocoder, DEFAULT_TIMEOUT
from geopy.location import Location
from geopy.exc import (
    GeocoderInsufficientPrivileges,
    GeocoderServiceError,
    ConfigurationError
)
from geopy.util import logger


class GeoNames(Geocoder): # pylint: disable=W0223
    """
    GeoNames geocoder, documentation at:
        http://www.geonames.org/export/geonames-search.html

    Reverse geocoding also available, but not yet implemented. Documentation at:
        http://www.geonames.org/maps/us-reverse-geocoder.html
    """

    def __init__(self, country_bias=None, username=None, timeout=DEFAULT_TIMEOUT, proxies=None):
        """
        :param string country_bias:

        :param string username:

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception.

            .. versionadded:: 0.97

        :param dict proxies: If specified, routes this geocoder's requests
            through the specified proxy. E.g., {"https": "192.0.2.0"}. For
            more information, see documentation on
            :class:`urllib2.ProxyHandler`.

            .. versionadded:: 0.96
        """
        super(GeoNames, self).__init__(scheme='http', timeout=timeout, proxies=proxies)
        if username == None:
            raise ConfigurationError(
                'No username given, required for api access.  If you do not '
                'have a GeoNames username, sign up here: '
                'http://www.geonames.org/login'
            )
        self.username = username
        self.country_bias = country_bias
        self.api = "%s://api.geonames.org/searchJSON" % self.scheme

    def geocode(self, query, exactly_one=True, timeout=None): # pylint: disable=W0221
        """
        Geocode a location query.

        :param string query: The address or query you wish to geocode.

        :param bool exactly_one: Return one result or a list of results, if
            available.

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception. Set this only if you wish to override, on this call only,
            the value set during the geocoder's initialization.

            .. versionadded:: 0.97
        """
        params = {
            'q': query,
            'username': self.username
        }
        if self.country_bias:
            params['countryBias'] = self.country_bias
        if exactly_one is True:
            params['maxRows'] = 1
        url = "?".join((self.api, urlencode(params)))
        logger.debug("%s.geocode: %s", self.__class__.__name__, url)
        return self._parse_json(self._call_geocoder(url, timeout=timeout), exactly_one)

    def _parse_json(self, doc, exactly_one):
        """
        Parse JSON response body.
        """
        places = doc.get('geonames', [])
        err = doc.get('status', None)
        if err and 'message' in err:
            if err['message'].startswith("user account not enabled to use"):
                raise GeocoderInsufficientPrivileges(err['message'])
            else:
                raise GeocoderServiceError(err['message'])
        if not len(places):
            return None

        def parse_code(place):
            """
            Parse each record.
            """
            latitude = place.get('lat', None)
            longitude = place.get('lng', None)
            if latitude and longitude:
                latitude = float(latitude)
                longitude = float(longitude)
            else:
                return None

            placename = place.get('name')
            state = place.get('adminCode1', None)
            country = place.get('countryCode', None)

            location = ', '.join(
                [x for x in [placename, state, country] if x]
            )

            return Location(location, (latitude, longitude), place)

        if exactly_one:
            return parse_code(places[0])
        else:
            return [parse_code(place) for place in places]

########NEW FILE########
__FILENAME__ = googlev3
"""
:class:`.GoogleV3` is the Google Maps V3 geocoder.
"""

import base64
import hashlib
import hmac
from geopy.compat import urlencode
from geopy.geocoders.base import Geocoder, DEFAULT_TIMEOUT, DEFAULT_SCHEME
from geopy.exc import (
    GeocoderQueryError,
    GeocoderQuotaExceeded,
    ConfigurationError
)
from geopy.location import Location
from geopy.util import logger


class GoogleV3(Geocoder):
    """
    Geocoder using the Google Maps v3 API. Documentation at:
        https://developers.google.com/maps/documentation/geocoding/
    """

    def __init__(self, api_key=None, domain='maps.googleapis.com', scheme=DEFAULT_SCHEME, # pylint: disable=R0913
                 client_id=None, secret_key=None, timeout=DEFAULT_TIMEOUT,
                 proxies=None):
        """
        Initialize a customized Google geocoder.

        API authentication is only required for Google Maps Premier customers.

        :param string api_key: The API key required by Google to perform
            geocoding requests. API keys are managed through the Google APIs
            console (https://code.google.com/apis/console).

            .. versionadded:: 0.98.2

        :param string domain: Should be the localized Google Maps domain to
            connect to. The default is 'maps.google.com', but if you're
            geocoding address in the UK (for example), you may want to set it
            to 'maps.google.co.uk' to properly bias results.

        :param string scheme: Use 'https' or 'http' as the API URL's scheme.
            Default is https. Note that SSL connections' certificates are not
            verified.

            .. versionadded:: 0.97

        :param string client_id: If using premier, the account client id.

        :param string secret_key: If using premier, the account secret key.

        :param dict proxies: If specified, routes this geocoder's requests
            through the specified proxy. E.g., {"https": "192.0.2.0"}. For
            more information, see documentation on
            :class:`urllib2.ProxyHandler`.

            .. versionadded:: 0.96
        """
        super(GoogleV3, self).__init__(
            scheme=scheme, timeout=timeout, proxies=proxies
        )
        if client_id and not secret_key:
            raise ConfigurationError('Must provide secret_key with client_id.')
        if secret_key and not client_id:
            raise ConfigurationError('Must provide client_id with secret_key.')

        self.api_key = api_key
        self.domain = domain.strip('/')
        self.scheme = scheme
        self.doc = {}

        if client_id and secret_key:
            self.premier = True
            self.client_id = client_id
            self.secret_key = secret_key
        else:
            self.premier = False
            self.client_id = None
            self.secret_key = None

        self.api = '%s://%s/maps/api/geocode/json' % (self.scheme, self.domain)

    def _get_signed_url(self, params):
        """
        Returns a Premier account signed url. Docs on signature:
        https://developers.google.com/maps/documentation/business/webservices/auth#digital_signatures
        """
        params['client'] = self.client_id
        path = "?".join(('/maps/api/geocode/json', urlencode(params)))
        signature = hmac.new(
            base64.urlsafe_b64decode(self.secret_key),
            path.encode('utf-8'),
            hashlib.sha1
        )
        signature = base64.urlsafe_b64encode(signature.digest()).decode('utf-8')
        return '%s://%s%s&signature=%s' % (
            self.scheme, self.domain, path, signature
        )

    @staticmethod
    def _format_components_param(components):
        """
        Format the components dict to something Google understands.
        """
        return "|".join(
            (":".join(item)
             for item in components.items()
            )
        )

    def geocode(self, query, bounds=None, region=None, # pylint: disable=W0221,R0913
                components=None,
                language=None, sensor=False, exactly_one=True, timeout=None):
        """
        Geocode a location query.

        :param string query: The address or query you wish to geocode.

        :param bounds: The bounding box of the viewport within which
            to bias geocode results more prominently.
        :type bounds: list or tuple

        :param string region: The region code, specified as a ccTLD
            ("top-level domain") two-character value.

        :param dict components: Restricts to an area. Can use any combination
            of: route, locality, administrative_area, postal_code, country.

            .. versionadded:: 0.97.1

        :param string language: The language in which to return results.

        :param bool sensor: Whether the geocoding request comes from a
            device with a location sensor.

        :param bool exactly_one: Return one result or a list of results, if
            available.

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception. Set this only if you wish to override, on this call only,
            the value set during the geocoder's initialization.

            .. versionadded:: 0.97
        """
        params = {
            'address': self.format_string % query,
            'sensor': str(sensor).lower()
        }
        if self.api_key:
            params['key'] = self.api_key
        if bounds:
            params['bounds'] = bounds
        if region:
            params['region'] = region
        if components:
            params['components'] = self._format_components_param(components)
        if language:
            params['language'] = language

        if self.premier is False:
            url = "?".join((self.api, urlencode(params)))
        else:
            url = self._get_signed_url(params)

        logger.debug("%s.geocode: %s", self.__class__.__name__, url)
        return self._parse_json(
            self._call_geocoder(url, timeout=timeout), exactly_one
        )

    def reverse(self, query, language=None, # pylint: disable=W0221,R0913
                    sensor=False, exactly_one=False, timeout=None):
        """
        Given a point, find an address.

        :param query: The coordinates for which you wish to obtain the
            closest human-readable addresses.
        :type query: :class:`geopy.point.Point`, list or tuple of (latitude,
            longitude), or string as "%(latitude)s, %(longitude)s"

        :param string language: The language in which to return results.

        :param boolean sensor: Whether the geocoding request comes from a
            device with a location sensor.

        :param boolean exactly_one: Return one result or a list of results, if
            available.

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception.

            .. versionadded:: 0.97
        """
        params = {
            'latlng': self._coerce_point_to_string(query),
            'sensor': str(sensor).lower()
        }
        if language:
            params['language'] = language

        if not self.premier:
            url = "?".join((self.api, urlencode(params)))
        else:
            url = self._get_signed_url(params)

        logger.debug("%s.reverse: %s", self.__class__.__name__, url)
        return self._parse_json(
            self._call_geocoder(url, timeout=timeout), exactly_one
        )

    def _parse_json(self, page, exactly_one=True):
        '''Returns location, (latitude, longitude) from json feed.'''

        places = page.get('results', [])
        if not len(places):
            self._check_status(page.get('status'))
            return None

        def parse_place(place):
            '''Get the location, lat, lng from a single json place.'''
            location = place.get('formatted_address')
            latitude = place['geometry']['location']['lat']
            longitude = place['geometry']['location']['lng']
            return Location(location, (latitude, longitude), place)

        if exactly_one:
            return parse_place(places[0])
        else:
            return [parse_place(place) for place in places]

    @staticmethod
    def _check_status(status):
        """
        Validates error statuses.
        """
        if status == 'ZERO_RESULTS':
            # When there are no results, just return.
            return
        if status == 'OVER_QUERY_LIMIT':
            raise GeocoderQuotaExceeded(
                'The given key has gone over the requests limit in the 24'
                ' hour period or has submitted too many requests in too'
                ' short a period of time.'
            )
        elif status == 'REQUEST_DENIED':
            raise GeocoderQueryError(
                'Your request was denied.'
            )
        elif status == 'INVALID_REQUEST':
            raise GeocoderQueryError('Probably missing address or latlng.')
        else:
            raise GeocoderQueryError('Unknown error.')


########NEW FILE########
__FILENAME__ = mapquest
"""
:class:`.MapQuest` geocoder.
"""

from geopy.compat import urlencode
from geopy.geocoders.base import (
    Geocoder,
    DEFAULT_FORMAT_STRING,
    DEFAULT_TIMEOUT,
    DEFAULT_SCHEME
)
from geopy.location import Location
from geopy.util import logger, join_filter
from geopy import exc


class MapQuest(Geocoder): # pylint: disable=W0223
    """
    MapQuest geocoder, documentation at:
        http://www.mapquestapi.com/geocoding/
    """

    def __init__(self, api_key, format_string=DEFAULT_FORMAT_STRING, # pylint: disable=R0913
                        scheme=DEFAULT_SCHEME,
                        timeout=DEFAULT_TIMEOUT, proxies=None):
        """
        Initialize a MapQuest geocoder with address information and
        MapQuest API key.

        :param string api_key: Key provided by MapQuest.

        :param string format_string: String containing '%s' where the
            string to geocode should be interpolated before querying the
            geocoder. For example: '%s, Mountain View, CA'. The default
            is just '%s'.

        :param string scheme: Use 'https' or 'http' as the API URL's scheme.
            Default is https. Note that SSL connections' certificates are not
            verified.

            .. versionadded:: 0.97

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception.

            .. versionadded:: 0.97

        :param dict proxies: If specified, routes this geocoder's requests
            through the specified proxy. E.g., {"https": "192.0.2.0"}. For
            more information, see documentation on
            :class:`urllib2.ProxyHandler`.
        """
        super(MapQuest, self).__init__(format_string, scheme, timeout, proxies)
        self.api_key = api_key
        self.api = "%s://www.mapquestapi.com/geocoding/v1/address" % self.scheme

    def geocode(self, query, exactly_one=True, timeout=None): # pylint: disable=W0221
        """
        Geocode a location query.

        :param string query: The address or query you wish to geocode.

        :param bool exactly_one: Return one result or a list of results, if
            available.

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception. Set this only if you wish to override, on this call only,
            the value set during the geocoder's initialization.

            .. versionadded:: 0.97
        """
        params = {
            'location' : self.format_string % query
        }
        if exactly_one:
            params['maxResults'] = 1
        # don't urlencode MapQuest API keys
        url = "?".join((
            self.api,
            "&".join(("=".join(('key', self.api_key)), urlencode(params)))
        ))
        logger.debug("%s.geocode: %s", self.__class__.__name__, url)
        return self._parse_json(self._call_geocoder(url, timeout=timeout), exactly_one)

    def _parse_json(self, resources, exactly_one=True):
        """
        Parse display name, latitude, and longitude from an JSON response.
        """
        if resources.get('info').get('statuscode') == 403:
            raise exc.GeocoderAuthenticationFailure()

        resources = resources.get('results')[0].get('locations', [])
        if not len(resources):
            return None

        def parse_resource(resource):
            """
            Parse each record.
            """
            city = resource['adminArea5']
            county = resource['adminArea4']
            state = resource['adminArea3']
            country = resource['adminArea1']
            latLng = resource['latLng']
            latitude, longitude = latLng.get('lat'), latLng.get('lng')

            location = join_filter(", ", [city, county, state, country])
            if latitude and longitude:
                latitude = float(latitude)
                longitude = float(longitude)

            return Location(location, (latitude, longitude), resource)

        if exactly_one:
            return parse_resource(resources[0])
        else:
            return [parse_resource(resource) for resource in resources]

########NEW FILE########
__FILENAME__ = openmapquest
"""
:class:`.OpenMapQuest` geocoder.
"""

from geopy.compat import urlencode
from geopy.geocoders.base import (
    Geocoder,
    DEFAULT_FORMAT_STRING,
    DEFAULT_TIMEOUT,
    DEFAULT_SCHEME
)
from geopy.location import Location
from geopy.util import logger


class OpenMapQuest(Geocoder): # pylint: disable=W0223
    """
    Geocoder using MapQuest Open Platform Web Services. Documentation at:
        http://developer.mapquest.com/web/products/open/geocoding-service
    """

    def __init__(self, api_key=None, format_string=DEFAULT_FORMAT_STRING, # pylint: disable=R0913
                        scheme=DEFAULT_SCHEME, timeout=DEFAULT_TIMEOUT, proxies=None):
        """
        Initialize an Open MapQuest geocoder with location-specific
        address information. No API Key is needed by the Nominatim based
        platform.

        :param string format_string: String containing '%s' where
            the string to geocode should be interpolated before querying
            the geocoder. For example: '%s, Mountain View, CA'. The default
            is just '%s'.

        :param string scheme: Use 'https' or 'http' as the API URL's scheme.
            Default is https. Note that SSL connections' certificates are not
            verified.

            .. versionadded:: 0.97

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception.

            .. versionadded:: 0.97

        :param dict proxies: If specified, routes this geocoder's requests
            through the specified proxy. E.g., {"https": "192.0.2.0"}. For
            more information, see documentation on
            :class:`urllib2.ProxyHandler`.

            .. versionadded:: 0.96
        """
        super(OpenMapQuest, self).__init__(format_string, scheme, timeout, proxies)
        self.api_key = api_key or ''
        self.api = "%s://open.mapquestapi.com/nominatim/v1/search" \
                    "?format=json" % self.scheme

    def geocode(self, query, exactly_one=True, timeout=None): # pylint: disable=W0221
        """
        Geocode a location query.

        :param string query: The address or query you wish to geocode.

        :param bool exactly_one: Return one result or a list of results, if
            available.

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception. Set this only if you wish to override, on this call only,
            the value set during the geocoder's initialization.

            .. versionadded:: 0.97
        """
        params = {
            'q': self.format_string % query
        }
        if exactly_one:
            params['maxResults'] = 1
        url = "&".join((self.api, urlencode(params)))

        logger.debug("%s.geocode: %s", self.__class__.__name__, url)
        return self._parse_json(self._call_geocoder(url, timeout=timeout), exactly_one)

    @classmethod
    def _parse_json(cls, resources, exactly_one=True):
        """
        Parse display name, latitude, and longitude from an JSON response.
        """
        if not len(resources): # pragma: no cover
            return None
        if exactly_one:
            return cls.parse_resource(resources[0])
        else:
            return [cls.parse_resource(resource) for resource in resources]

    @classmethod
    def parse_resource(cls, resource):
        """
        Return location and coordinates tuple from dict.
        """
        location = resource['display_name']

        latitude = resource['lat'] or None
        longitude = resource['lon'] or None
        if latitude and longitude:
            latitude = float(latitude)
            longitude = float(longitude)

        return Location(location, (latitude, longitude), resource)

########NEW FILE########
__FILENAME__ = osm
"""
OpenStreetMaps geocoder, contributed by Alessandro Pasotti of ItOpen.
"""

from geopy.geocoders.base import Geocoder, DEFAULT_FORMAT_STRING, \
    DEFAULT_TIMEOUT
from geopy.compat import urlencode
from geopy.location import Location
from geopy.util import logger


class Nominatim(Geocoder):
    """
    Nominatim geocoder for OpenStreetMap servers. Documentation at:
        https://wiki.openstreetmap.org/wiki/Nominatim

    Note that Nominatim does not support SSL.
    """

    def __init__(self, format_string=DEFAULT_FORMAT_STRING, # pylint: disable=R0913
                        view_box=(-180, -90, 180, 90), country_bias=None,
                        timeout=DEFAULT_TIMEOUT, proxies=None):
        """
        :param string format_string: String containing '%s' where the
            string to geocode should be interpolated before querying the
            geocoder. For example: '%s, Mountain View, CA'. The default
            is just '%s'.

        :param tuple view_box: Coordinates to restrict search within.

        :param string country_bias: Bias results to this country.

        :param dict proxies: If specified, routes this geocoder's requests
            through the specified proxy. E.g., {"https": "192.0.2.0"}. For
            more information, see documentation on
            :class:`urllib2.ProxyHandler`.

            .. versionadded:: 0.96
        """
        super(Nominatim, self).__init__(format_string, 'http', timeout, proxies)
        # XML needs all sorts of conditionals because of API differences
        # between geocode and reverse, so only implementing JSON format
        self.country_bias = country_bias
        self.format_string = format_string
        self.view_box = view_box
        self.country_bias = country_bias

        self.api = "%s://nominatim.openstreetmap.org/search" % self.scheme
        self.reverse_api = "%s://nominatim.openstreetmap.org/reverse" % self.scheme

    def geocode(self, query, exactly_one=True, timeout=None):
        """
        Geocode a location query.

        :param string query: The address or query you wish to geocode.

        :param bool exactly_one: Return one result or a list of results, if
            available.

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception. Set this only if you wish to override, on this call only,
            the value set during the geocoder's initialization.

            .. versionadded:: 0.97
        """
        params = {
            'q': self.format_string % query,
            'view_box' : self.view_box,
            'format' : 'json',
        }

        if self.country_bias:
            params['countrycodes'] = self.country_bias

        url = "?".join((self.api, urlencode(params)))
        logger.debug("%s.geocode: %s", self.__class__.__name__, url)
        return self._parse_json(
            self._call_geocoder(url, timeout=timeout), exactly_one
        )

    def reverse(self, query, exactly_one=True, timeout=None):
        """
        Returns a reverse geocoded location.

        :param query: The coordinates for which you wish to obtain the
            closest human-readable addresses.
        :type query: :class:`geopy.point.Point`, list or tuple of (latitude,
            longitude), or string as "%(latitude)s, %(longitude)s"

        :param bool exactly_one: Return one result or a list of results, if
            available.

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception. Set this only if you wish to override, on this call only,
            the value set during the geocoder's initialization.

            .. versionadded:: 0.97
        """
        lat, lon = [
            x.strip() for x in
            self._coerce_point_to_string(query).split(',')
        ] # doh
        params = {
            'lat': lat,
            'lon' : lon,
            'format' : 'json',
        }
        url = "?".join((self.reverse_api, urlencode(params)))
        logger.debug("%s.reverse: %s", self.__class__.__name__, url)
        return self._parse_json(
            self._call_geocoder(url, timeout=timeout), exactly_one
        )

    @staticmethod
    def parse_code(place):
        """
        Parse each resource.
        """
        latitude = place.get('lat', None)
        longitude = place.get('lon', None)
        placename = place.get('display_name', None)
        if latitude and longitude:
            latitude = float(latitude)
            longitude = float(longitude)
        return Location(placename, (latitude, longitude), place)

    def _parse_json(self, places, exactly_one):
        if places is None:
            return None
        if not isinstance(places, list):
            places = [places]
        if not len(places):
            return None
        if exactly_one is True:
            return self.parse_code(places[0])
        else:
            return [self.parse_code(place) for place in places]

########NEW FILE########
__FILENAME__ = placefinder
"""
:class:`.YahooPlaceFinder` geocoder.
support.
"""

import json

try:
    import requests
    import requests_oauthlib
    requests_missing = False
except ImportError:
    requests_missing = True

from geopy.geocoders.base import Geocoder, DEFAULT_TIMEOUT
from geopy.exc import GeocoderParseError
from geopy.location import Location
from geopy.compat import quote


class YahooPlaceFinder(Geocoder): # pylint: disable=W0223
    """
    Geocoder that utilizes the Yahoo! BOSS PlaceFinder API. Documentation at:
        https://developer.yahoo.com/boss/geo/docs/
    """

    def __init__(self, consumer_key, consumer_secret, # pylint: disable=R0913
                        timeout=DEFAULT_TIMEOUT, proxies=None):
        """
        :param string consumer_key: Key provided by Yahoo.

        :param string consumer_secret: Secret corresponding to the key
            provided by Yahoo.

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising a :class:`geopy.exc.GeocoderTimedOut`
            exception.

        :param dict proxies: If specified, routes this geocoder's requests
            through the specified proxy. E.g., {"https": "192.0.2.0"}. For
            more information, see documentation on
            :class:`urllib2.ProxyHandler`.

            .. versionadded:: 0.96
        """
        if requests_missing:
            raise ImportError(
                'requests-oauthlib is needed for YahooPlaceFinder'
            )
        super(YahooPlaceFinder, self).__init__(timeout=timeout, proxies=proxies)
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret
        self.api = 'https://yboss.yahooapis.com/geo/placefinder'

    def _call_yahoo(self, query, reverse, exactly_one, timeout):
        """
        Returns a response for the given query
        """
        # we quote the location, because spaces must be encoded as "%20"
        # instead of "+". this also means we can't later call urlencode on
        # this value.
        params = {'location': quote(query), 'flags': 'J'}

        if reverse is True:
            params['gflags'] = 'R'
        if exactly_one is True:
            params['count'] = '1'

        auth = requests_oauthlib.OAuth1(
            self.consumer_key, self.consumer_secret)

        url = u'?'.join((
            self.api,
            u'&'.join(u'='.join(item) for item in params.items())
        ))

        return requests.get(url, auth=auth, timeout=timeout)

    @staticmethod
    def _filtered_results(results, min_quality, valid_country_codes):
        """
        Returns only the results that meet the minimum quality threshold
        and are located in expected countries.
        """
        results = [
            (place, point)
            for (place, point) in results
            if int(place['quality']) > min_quality
        ]

        if valid_country_codes:
            results = [
                (place, point)
                for (place, point) in results
                if place['countrycode'] in valid_country_codes
            ]

        return results

    @staticmethod
    def _parse_response(response):
        """
        Returns the parsed result of a PlaceFinder API call.
        """
        try:
            placefinder = json.loads(response.content)['bossresponse']['placefinder']
            if not len(placefinder) or not len(placefinder.get('results', [])):
                return None
            results = [
                Location(
                    place['name'],
                    (float(place['latitude']), float(place['longitude'])),
                    place
                )
                for place in placefinder['results']
            ]
        except (KeyError, ValueError):
            raise GeocoderParseError('Error parsing PlaceFinder result')

        return results

    @staticmethod
    def humanize(location):
        """
        Returns a human readable representation of a raw PlaceFinder location
        """
        return ', '.join([
            location[line]
            for line in ['line1', 'line2', 'line3', 'line4']
            if location[line]
        ])

    def geocode(self, query, exactly_one=True, timeout=None, # pylint: disable=W0221,R0913
                        min_quality=0, raw=False,
                        reverse=False, valid_country_codes=None):
        """
        Geocode a location query.

        :param string query: The address or query you wish to geocode.

        :param bool exactly_one: Return one result or a list of results, if
            available.

        :param int min_quality:

        :param bool raw:

        :param bool reverse:

        :param valid_country_codes:
        :type valid_country_codes: list or tuple
        """
        response = self._call_yahoo(query, reverse, exactly_one, timeout)
        results = self._parse_response(response)
        if results is None:
            return None

        results = self._filtered_results(
            results,
            min_quality,
            valid_country_codes,
        )

        if not raw:
            results = [
                (self.humanize(place), point)
                for (place, point) in results
            ]

        if exactly_one:
            return results[0]
        else:
            return results

    def reverse(self, query, exactly_one=True, timeout=None):
        """
        Returns a reverse geocoded location using Yahoo's PlaceFinder API.

        :param query: The coordinates for which you wish to obtain the
            closest human-readable addresses.
        :type query: :class:`geopy.point.Point`, list or tuple of (latitude,
            longitude), or string as "%(latitude)s, %(longitude)s"

        :param bool exactly_one: Return one result or a list of results, if
            available.
        """
        return self.geocode(
            self._coerce_point_to_string(query),
            exactly_one=exactly_one,
            timeout=timeout,
            reverse=True
        )

########NEW FILE########
__FILENAME__ = smartystreets
"""
:class:`.LiveAddress` geocoder.
"""

from geopy.geocoders.base import Geocoder, DEFAULT_TIMEOUT, DEFAULT_SCHEME
from geopy.compat import urlencode
from geopy.location import Location
from geopy.exc import GeocoderQuotaExceeded
from geopy.util import logger


class LiveAddress(Geocoder): # pylint: disable=W0223
    """
    Initialize a customized LiveAddress geocoder provided by SmartyStreets.
    More information regarding the LiveAddress API can be found here:
        https://smartystreets.com/products/liveaddress-api
    """
    def __init__(self, auth_token, candidates=1, scheme=DEFAULT_SCHEME, # pylint: disable=R0913
                        timeout=DEFAULT_TIMEOUT, proxies=None):
        """
        Initialize a customized SmartyStreets LiveAddress geocoder.


        :param string auth_token: Valid authentication token. Tokens can be
            administered here:
                https://smartystreets.com/account/keys/secret

        :param int candidates: An integer between 1 and 10 indicating the max
            number of candidate addresses to return if a valid address
            could be found.

        :param string scheme: Use 'https' or 'http' as the API URL's scheme.
            Default is https. Note that SSL connections' certificates are not
            verified.

            .. versionadded:: 0.97

        :param int timeout: Time, in seconds, to wait for the geocoding service
            to respond before raising an :class:`geopy.exc.GeocoderTimedOut`
            exception.

            .. versionadded:: 0.97

        :param dict proxies: If specified, routes this geocoder's requests
            through the specified proxy. E.g., {"https": "192.0.2.0"}. For
            more information, see documentation on
            :class:`urllib2.ProxyHandler`.

            .. versionadded:: 0.96
        """
        super(LiveAddress, self).__init__(scheme=scheme, timeout=timeout, proxies=proxies)
        self.auth_token = auth_token
        if candidates:
            if not 1 <= candidates <= 10:
                raise ValueError('candidates must be between 1 and 10')
        self.candidates = candidates
        self.api = '%s://api.qualifiedaddress.com/street-address' % self.scheme

    def geocode(self, query, exactly_one=True):
        """
        Geocode a location query.

        :param string query: The address or query you wish to geocode.

        :param bool exactly_one: Return one result or a list of results, if
            available.
        """
        url = self._compose_url(query)
        logger.debug("%s.geocode: %s", self.__class__.__name__, url)
        return self._parse_json(self._call_geocoder(url), exactly_one)

    def _geocoder_exception_handler(self, error, message): # pylint: disable=R0201
        """
        LiveStreets-specific exceptions.
        """
        if "no active subscriptions found" in message.lower():
            raise GeocoderQuotaExceeded(message)

    def _compose_url(self, location):
        """
        Generate API URL.
        """
        query = {
            'street': location,
            'candidates': self.candidates
        }
        # don't urlencode the api token
        return '?'.join((
            self.api,
            "&".join(("=".join((
                'auth-token', self.auth_token)), urlencode(query)
            ))
    ))

    def _parse_json(self, response, exactly_one=True):
        """
        Parse responses as JSON objects.
        """
        if not len(response):
            return None
        if exactly_one is True:
            return self._format_structured_address(response[0])
        else:
            return [self._format_structured_address(c) for c in response]

    @staticmethod
    def _format_structured_address(address):
        """
        Pretty-print address and return lat, lon tuple.
        """
        latitude = address['metadata'].get('latitude')
        longitude = address['metadata'].get('longitude')
        return Location(
            ", ".join((address['delivery_line_1'], address['last_line'])),
            (latitude, longitude) if latitude and longitude else None,
            address
        )

########NEW FILE########
__FILENAME__ = location
"""
:class:`.Location` returns geocoder results.
"""

from geopy.point import Point
from geopy.compat import string_compare


class Location(object): # pylint: disable=R0903,R0921
    """
    Contains a parsed geocoder response. Can be iterated over as
    (location<String>, (latitude<float>, longitude<Float)). Or one can access
    the properties `address`, `latitude`, `longitude`, or `raw`. The last
    is a dictionary of the geocoder's response for this item.

    .. versionadded:: 0.98
    """

    __slots__ = ("_address", "_point", "_tuple", "_raw")

    def __init__(self, address="", point=None, raw=None):
        self._address = address
        if point is None:
            self._point = (None, None, None)
        elif isinstance(point, Point):
            self._point = point
        elif isinstance(point, string_compare):
            self._point = Point(point)
        elif isinstance(point, (tuple, list)):
            self._point = Point(point)
        else:
            raise TypeError(
                "point an unsupported type: %r; use %r or Point",
                type(point), type(string_compare)
            )
        self._tuple = (self._address, (self._point[0], self._point[1]))
        self._raw = raw

    @property
    def address(self):
        """
        Location as a formatted string returned by the geocoder or constructed
        by geopy, depending on the service.

        :rtype: unicode
        """
        return self._address

    @property
    def latitude(self):
        """
        Location's latitude.

        :rtype: float or None
        """
        return self._point[0]

    @property
    def longitude(self):
        """
        Location's longitude.

        :rtype: float or None
        """
        return self._point[1]

    @property
    def altitude(self):
        """
        Location's altitude.

        :rtype: float or None
        """
        return self._point[2]

    @property
    def point(self):
        """
        :class:`geopy.point.Point` instance representing the location's
        latitude, longitude, and altitude.

        :rtype: :class:`geopy.point.Point` or None
        """
        return self._point if self._point != (None, None, None) else None

    @property
    def raw(self):
        """
        Location's raw, unparsed geocoder response. For details on this,
        consult the service's documentation.

        :rtype: dict or None
        """
        return self._raw

    def __getitem__(self, index):
        """
        Backwards compatibility with geopy<0.98 tuples.
        """
        return self._tuple[index]

    def __str__(self):
        return self._address

    __unicode__ = __str__

    def __repr__(self): # pragma: no cover
        return "".join((
            "Location(", self._address, " ", str(self._point), ")"
        ))

    def __iter__(self):
        return iter(self._tuple)

    def __eq__(self, other):
        return (
            isinstance(other, Location) and
            self._address == other._address and
            self._point == other._point and
            self.raw == other.raw
        )

    def __ne__(self, other):
        return not self.__eq__(other)

    def __len__(self): # pragma: no cover
        return len(self._tuple)


########NEW FILE########
__FILENAME__ = point
# encoding: utf-8
"""
:class:`.Point` data structure.
"""

import re
from itertools import islice
from geopy import util, units, format # pylint: disable=W0622
from geopy.compat import string_compare


POINT_PATTERN = re.compile(r"""
    .*?
    (?P<latitude>
      (?P<latitude_direction_front>[NS])?[ ]*
        (?P<latitude_degrees>-?%(FLOAT)s)(?:[%(DEGREE)sD\*\u00B0\s][ ]*
        (?:(?P<latitude_arcminutes>%(FLOAT)s)[%(PRIME)s'm][ ]*)?
        (?:(?P<latitude_arcseconds>%(FLOAT)s)[%(DOUBLE_PRIME)s"s][ ]*)?
        )?(?P<latitude_direction_back>[NS])?)
    %(SEP)s
    (?P<longitude>
      (?P<longitude_direction_front>[EW])?[ ]*
      (?P<longitude_degrees>-?%(FLOAT)s)(?:[%(DEGREE)sD\*\u00B0\s][ ]*
      (?:(?P<longitude_arcminutes>%(FLOAT)s)[%(PRIME)s'm][ ]*)?
      (?:(?P<longitude_arcseconds>%(FLOAT)s)[%(DOUBLE_PRIME)s"s][ ]*)?
      )?(?P<longitude_direction_back>[EW])?)(?:
    %(SEP)s
      (?P<altitude>
        (?P<altitude_distance>-?%(FLOAT)s)[ ]*
        (?P<altitude_units>km|m|mi|ft|nm|nmi)))?
    .*?$
""" % {
    "FLOAT": r'\d+(?:\.\d+)?',
    "DEGREE": format.DEGREE,
    "PRIME": format.PRIME,
    "DOUBLE_PRIME": format.DOUBLE_PRIME,
    "SEP": r'\s*[,;/\s]\s*',
}, re.X)


class Point(object):
    """
    A geodetic point with latitude, longitude, and altitude.

    Latitude and longitude are floating point values in degrees.
    Altitude is a floating point value in kilometers. The reference level
    is never considered and is thus application dependent, so be consistent!
    The default for all values is 0.

    Points can be created in a number of ways...

    With longitude, latitude, and altitude::

        >>> p1 = Point(41.5, -81, 0)
        >>> p2 = Point(latitude=41.5, longitude=-81)

    With a sequence of 0 to 3 values (longitude, latitude, altitude)::

        >>> p1 = Point([41.5, -81, 0])
        >>> p2 = Point((41.5, -81))

    Copy another `Point` instance::

        >>> p2 = Point(p1)
        >>> p2 == p1
        True
        >>> p2 is p1
        False

    Give a string containing at least latitude and longitude::

        >>> p1 = Point('41.5,-81.0')
        >>> p2 = Point('41.5 N -81.0 W')
        >>> p3 = Point('-41.5 S, 81.0 E, 2.5km')
        >>> p4 = Point('23 26m 22s N 23 27m 30s E 21.0mi')
        >>> p5 = Point('''3 26' 22" N 23 27' 30" E''')

    Point values can be accessed by name or by index::

        >>> p = Point(41.5, -81.0, 0)
        >>> p.latitude == p[0]
        True
        >>> p.longitude == p[1]
        True
        >>> p.altitude == p[2]
        True

    When unpacking (or iterating), a (latitude, longitude, altitude) tuple is
    returned::

        >>> latitude, longitude, altitude = p

    """

    __slots__ = ("latitude", "longitude", "altitude", "_items")

    POINT_PATTERN = POINT_PATTERN

    def __new__(cls, latitude=None, longitude=None, altitude=None):
        """
        :param float latitude: Latitude of point.
        :param float longitude: Longitude of point.
        :param float altitude: Altitude of point.
        """
        single_arg = longitude is None and altitude is None
        if single_arg and not isinstance(latitude, util.NUMBER_TYPES):
            arg = latitude
            if arg is None: # pragma: no cover
                pass
            elif isinstance(arg, Point):
                return cls.from_point(arg)
            elif isinstance(arg, string_compare):
                return cls.from_string(arg)
            else:
                try:
                    seq = iter(arg)
                except TypeError: # pragma: no cover
                    raise TypeError(
                        "Failed to create Point instance from %r." % (arg,)
                    )
                else:
                    return cls.from_sequence(seq)

        latitude = float(latitude or 0.0)
        if abs(latitude) > 90:
            latitude = ((latitude + 90) % 180) - 90

        longitude = float(longitude or 0.0)
        if abs(longitude) > 180:
            longitude = ((longitude + 180) % 360) - 180

        altitude = float(altitude or 0.0)

        self = super(Point, cls).__new__(cls)
        self.latitude = latitude
        self.longitude = longitude
        self.altitude = altitude
        self._items = [self.latitude, self.longitude, self.altitude]
        return self

    def __getitem__(self, index):
        return self._items[index]

    def __setitem__(self, index, value):
        self._items[index] = value

    def __iter__(self):
        return iter((self.latitude, self.longitude, self.altitude))

    def __repr__(self):
        return "Point(%r, %r, %r)" % (tuple(self._items))

    def format(self, altitude=None, deg_char='', min_char='m', sec_char='s'):
        latitude = "%s %s" % (
            format.format_degrees(abs(self.latitude), symbols={
                'deg': deg_char, 'arcmin': min_char, 'arcsec': sec_char
            }),
            self.latitude >= 0 and 'N' or 'S'
        )
        longitude = "%s %s" % (
            format.format_degrees(abs(self.longitude), symbols={
                'deg': deg_char, 'arcmin': min_char, 'arcsec': sec_char
            }),
            self.longitude >= 0 and 'E' or 'W'
        )
        coordinates = [latitude, longitude]

        if altitude is None:
            altitude = bool(self.altitude)
        if altitude:
            if not isinstance(altitude, string_compare):
                altitude = 'km'
            coordinates.append(self.format_altitude(altitude))

        return ", ".join(coordinates)

    def format_decimal(self, altitude=None):
        coordinates = [str(self.latitude), str(self.longitude)]

        if altitude is None:
            altitude = bool(self.altitude)
        if altitude is True:
            if not isinstance(altitude, string_compare):
                altitude = 'km'
            coordinates.append(self.format_altitude(altitude))

        return ", ".join(coordinates)

    def format_altitude(self, unit='km'):
        return format.format_distance(self.altitude, unit)

    def __str__(self):
        return self.format()

    def __unicode__(self):
        return self.format(
            None, format.DEGREE, format.PRIME, format.DOUBLE_PRIME
        )

    def __eq__(self, other):
        return tuple(self) == tuple(other)

    def __ne__(self, other):
        return tuple(self) != tuple(other)

    @classmethod
    def parse_degrees(cls, degrees, arcminutes, arcseconds, direction=None):
        degrees = float(degrees)
        negative = degrees < 0
        arcminutes = float(arcminutes)
        arcseconds = float(arcseconds)

        if arcminutes or arcseconds:
            more = units.degrees(arcminutes=arcminutes, arcseconds=arcseconds)
            if negative:
                degrees -= more
            else:
                degrees += more

        if direction in [None, 'N', 'E']:
            return degrees
        elif direction in ['S', 'W']:
            return -degrees
        else:
            raise ValueError("Invalid direction! Should be one of [NSEW].")

    @classmethod
    def parse_altitude(cls, distance, unit):
        if distance is not None:
            distance = float(distance)
            CONVERTERS = {
                'km': lambda d: d,
                'm': lambda d: units.kilometers(meters=d),
                'mi': lambda d: units.kilometers(miles=d),
                'ft': lambda d: units.kilometers(feet=d),
                'nm': lambda d: units.kilometers(nautical=d),
                'nmi': lambda d: units.kilometers(nautical=d)
            }
            try:
                return CONVERTERS[unit](distance)
            except KeyError: # pragma: no cover
                raise NotImplementedError(
                    'Bad distance unit specified, valid are: %r' % CONVERTERS.keys()
                )
        else:
            return distance

    @classmethod
    def from_string(cls, string):
        """
        Create and return a ``Point`` instance from a string containing latitude
        and longitude, and optionally, altitude.

        Latitude and longitude must be in degrees and may be in decimal form
        or indicate arcminutes and arcseconds (labeled with Unicode prime and
        double prime, ASCII quote and double quote or 'm' and 's'). The degree
        symbol is optional and may be included after the decimal places (in
        decimal form) and before the arcminutes and arcseconds otherwise.
        Coordinates given from south and west (indicated by S and W suffixes)
        will be converted to north and east by switching their signs. If no
        (or partial) cardinal directions are given, north and east are the
        assumed directions. Latitude and longitude must be separated by at
        least whitespace, a comma, or a semicolon (each with optional
        surrounding whitespace).

        Altitude, if supplied, must be a decimal number with given units.
        The following unit abbrevations (case-insensitive) are supported:

            - ``km`` (kilometers)
            - ``m`` (meters)
            - ``mi`` (miles)
            - ``ft`` (feet)
            - ``nm``, ``nmi`` (nautical miles)

        Some example strings the will work include:

            - 41.5;-81.0
            - 41.5,-81.0
            - 41.5 -81.0
            - 41.5 N -81.0 W
            - -41.5 S;81.0 E
            - 23 26m 22s N 23 27m 30s E
            - 23 26' 22" N 23 27' 30" E
            - UT: N 3920' 0'' / W 7435' 0''

        """
        match = re.match(cls.POINT_PATTERN, re.sub(r"''", r'"', string))
        if match:
            latitude_direction = None
            if match.group("latitude_direction_front"):
                latitude_direction = match.group("latitude_direction_front")
            elif match.group("latitude_direction_back"):
                latitude_direction = match.group("latitude_direction_back")

            longitude_direction = None
            if match.group("longitude_direction_front"):
                longitude_direction = match.group("longitude_direction_front")
            elif match.group("longitude_direction_back"):
                longitude_direction = match.group("longitude_direction_back")
            latitude = cls.parse_degrees(
                match.group('latitude_degrees') or 0.0,
                match.group('latitude_arcminutes') or 0.0,
                match.group('latitude_arcseconds') or 0.0,
                latitude_direction
            )
            longitude = cls.parse_degrees(
                match.group('longitude_degrees') or 0.0,
                match.group('longitude_arcminutes') or 0.0,
                match.group('longitude_arcseconds') or 0.0,
                longitude_direction
            )
            altitude = cls.parse_altitude(
                match.group('altitude_distance'),
                match.group('altitude_units')
            )
            return cls(latitude, longitude, altitude)
        else:
            raise ValueError(
                "Failed to create Point instance from string: unknown format."
            )

    @classmethod
    def from_sequence(cls, seq):
        """
        Create and return a new ``Point`` instance from any iterable with 0 to
        3 elements.  The elements, if present, must be latitude, longitude,
        and altitude, respectively.
        """
        args = tuple(islice(seq, 4))
        return cls(*args)

    @classmethod
    def from_point(cls, point):
        """
        Create and return a new ``Point`` instance from another ``Point`` instance.
        """
        return cls(point.latitude, point.longitude, point.altitude)

########NEW FILE########
__FILENAME__ = units
"""
Convert units.
"""

import math


# Angles

def degrees(radians=0, arcminutes=0, arcseconds=0): # pylint: disable=W0621
    """
    TODO docs.
    """
    deg = 0.
    if radians:
        deg = math.degrees(radians)
    if arcminutes:
        deg += arcminutes / arcmin(degrees=1.)
    if arcseconds:
        deg += arcseconds / arcsec(degrees=1.)
    return deg

def radians(degrees=0, arcminutes=0, arcseconds=0): # pylint: disable=W0621
    """
    TODO docs.
    """
    if arcminutes:
        degrees += arcminutes / arcmin(degrees=1.)
    if arcseconds:
        degrees += arcseconds / arcsec(degrees=1.)
    return math.radians(degrees)

def arcminutes(degrees=0, radians=0, arcseconds=0): # pylint: disable=W0621
    """
    TODO docs.
    """
    if radians:
        degrees += math.degrees(radians)
    if arcseconds:
        degrees += arcseconds / arcsec(degrees=1.)
    return degrees * 60.

def arcseconds(degrees=0, radians=0, arcminutes=0): # pylint: disable=W0621
    """
    TODO docs.
    """
    if radians:
        degrees += math.degrees(radians)
    if arcminutes:
        degrees += arcminutes / arcmin(degrees=1.)
    return degrees * 3600.


# Lengths

def kilometers(meters=0, miles=0, feet=0, nautical=0): # pylint: disable=W0621
    """
    TODO docs.
    """
    ret = 0.
    if meters:
        ret += meters / 1000.
    if feet:
        miles += feet / ft(1.)
    if nautical:
        ret += nautical / nm(1.)
    ret += miles * 1.609344
    return ret

def meters(kilometers=0, miles=0, feet=0, nautical=0): # pylint: disable=W0621
    """
    TODO docs.
    """
    return (kilometers + km(nautical=nautical, miles=miles, feet=feet)) * 1000

def miles(kilometers=0, meters=0, feet=0, nautical=0): # pylint: disable=W0621
    """
    TODO docs.
    """
    ret = 0.
    if nautical:
        kilometers += nautical / nm(1.)
    if feet:
        ret += feet / ft(1.)
    if meters:
        kilometers += meters / 1000.
    ret += kilometers * 0.621371192
    return ret

def feet(kilometers=0, meters=0, miles=0, nautical=0): # pylint: disable=W0621
    """
    TODO docs.
    """
    ret = 0.
    if nautical:
        kilometers += nautical / nm(1.)
    if meters:
        kilometers += meters / 1000.
    if kilometers:
        miles += mi(kilometers=kilometers)
    ret += miles * 5280
    return ret

def nautical(kilometers=0, meters=0, miles=0, feet=0): # pylint: disable=W0621
    """
    TODO docs.
    """
    ret = 0.
    if feet:
        miles += feet / ft(1.)
    if miles:
        kilometers += km(miles=miles)
    if meters:
        kilometers += meters / 1000.
    ret += kilometers / 1.852
    return ret


# Compatible names

rad = radians # pylint: disable=C0103
arcmin = arcminutes # pylint: disable=C0103
arcsec = arcseconds # pylint: disable=C0103
km = kilometers # pylint: disable=C0103
m = meters # pylint: disable=C0103
mi = miles # pylint: disable=C0103
ft = feet # pylint: disable=C0103
nm = nautical # pylint: disable=C0103

########NEW FILE########
__FILENAME__ = util
"""
Utils.
"""

import logging
from geopy.compat import py3k

if not py3k: # pragma: no cover
    NUMBER_TYPES = (int, long, float)
else: # pragma: no cover
    NUMBER_TYPES = (int, float) # long -> int in Py3k
try:
    from decimal import Decimal
    NUMBER_TYPES = NUMBER_TYPES + (Decimal, )
except ImportError: # pragma: no cover
    pass


class NullHandler(logging.Handler):
    """
    No output.
    """

    def emit(self, record):
        pass

logger = logging.getLogger('geopy') # pylint: disable=C0103


def pairwise(seq):
    """
    Pair an iterable, e.g., (1, 2, 3, 4) -> ((1, 2), (3, 4))
    """
    for i in range(0, len(seq) - 1):
        yield (seq[i], seq[i + 1])


if not py3k:
    def join_filter(sep, seq, pred=bool):
        """
        Join with a filter.
        """
        return sep.join([unicode(i) for i in seq if pred(i)])
else:
    def join_filter(sep, seq, pred=bool):
        """
        Join with a filter.
        """
        return sep.join([str(i) for i in seq if pred(i)])


if not py3k:
    def decode_page(page):
        """
        Return unicode string of geocoder results.
        """
        encoding = page.headers.getparam("charset") or "iso-8859-1"
        return unicode(page.read(), encoding=encoding).encode('utf-8')
else:
    def decode_page(page):
        """
        Return unicode string of geocoder results.
        """
        encoding = page.headers.get_param("charset") or "iso-8859-1"
        return str(page.read(), encoding=encoding)

########NEW FILE########
__FILENAME__ = daemon
#! /bin/env python
#
# Routine to daemonize a process on unix
#
#
DAEMON_HOME = '/'

class NullDevice:
    def write(self, s):
        pass

def daemonize(homeDir = DAEMON_HOME):
    import os
    import sys

    if os.fork() != 0:                   # Parent
        os._exit(0)                        # Kill parent


    os.chdir(homeDir)                    # Detach from parent tty
    os.setsid()                            # and start new session
    os.umask(0)

    sys.stdin.close()                    # Close stdin, stdout
    sys.stdout.close()
    sys.stdin = NullDevice()
    sys.stdout = NullDevice()

    for n in range(3, 256):                # Close any remaining file
        try:                             # descriptors
            os.close(n)
        except:
            pass

    if os.fork() != 0:                    # finally fork again
        os._exit(0)                        # to fully daemonize



def spawn(cmd, args):
    import string
    import os
    import sys
    import signal

    # Prevent zombie orphans by ignoring SIGCHLD signal
    signal.signal(signal.SIGCHLD, signal.SIG_IGN)

    args = string.split(args)
    if os.fork() != 0:                    # Calling Parent
        return                            # allow this parent to continue running

    os.chdir(DAEMON_HOME)                # Temp Parent
    os.setsid()                            # Detach from calling parent
    os.umask(0)

    if os.fork() != 0:                    # Kill temp parent
        os._exit(0)                        # Run cmd in new child

    os.execvpe(cmd, [cmd] + args, os.environ)


def createPid(pidPath='/var/run'):
    '''Creates PID file for process'''

    import os
    import sys

    currentPid = os.getpid() #Gets PID number
    if not currentPid:
        print 'Could not find PID'
        sys.exit()

    scriptFilename, ext = os.path.splitext(os.path.basename(sys.argv[0]))

    pidFile = '%s.pid' % (scriptFilename) #Creates PIDfile  filename
    pidFilePath = os.path.join(pidPath, pidFile)

    f = file(pidFilePath, 'w') #Writes PIDfile name
    print >> f, currentPid
    f.close()

if __name__ == "__main__":
        while True:
                daemonize()
                print "hello world"


########NEW FILE########
__FILENAME__ = proxy_server
try:
    import SimpleHTTPServer
    import SocketServer
except ImportError:
    import socketserver as SockServer
    import http.server as SimpleHTTPServer

import urllib

class Proxy(SimpleHTTPServer.SimpleHTTPRequestHandler):
    def do_GET(self):
        self.copyfile(urllib.urlopen(self.path), self.wfile)

class ProxyServer():
    '''Class used to invoke a simple test HTTP Proxy server'''
    def __init__(self):
        self.proxy_port = 1337
        self.proxy_host = 'localhost'

        self.proxyd = None

    def run_proxy(self):
        '''Starts Instance of Proxy in a TCPServer'''
        #Setup Proxy in thread
        self.proxyd = SocketServer.TCPServer((self.proxy_host, self.proxy_port), Proxy).serve_forever()
        # Start Proxy Process
        print("serving at port %s on PID %s " % (self.proxy_port, self.proxyd.pid))

    def get_proxy_url(self):
        return "http://%s:%s" % (self.proxy_host, self.proxy_port)


if __name__ == '__main__':
    import daemon

    daemon.daemonize()
    daemon.createPid()

    proxy = ProxyServer()
    proxy.run_proxy()




########NEW FILE########
__FILENAME__ = test_backends
"""
Full tests of geocoders including HTTP access.
"""

import os
import unittest
import json
import base64
import types

from geopy.geocoders.base import Geocoder, DEFAULT_TIMEOUT
from geopy.geocoders import * # pylint: disable=W0401
from geopy import exc
from geopy.point import Point
from geopy.compat import py3k
from geopy.exc import GeocoderAuthenticationFailure, GeocoderQuotaExceeded, \
    GeocoderServiceError
from collections import defaultdict

if py3k:
    str_coerce = str
else:
    str_coerce = unicode

try:
    env = defaultdict(lambda: None)
    with open(".test_keys") as fp:
        env.update(json.loads(fp.read()))
except IOError:
    keys = (
        'YAHOO_KEY',
        'YAHOO_SECRET',
        'BING_KEY',
        'MAPQUEST_KEY',
        'GEONAMES_USERNAME',
        'LIVESTREETS_AUTH_KEY',
        'GEOCODERDOTUS_USERNAME',
        'GEOCODERDOTUS_PASSWORD',
        'GEOCODEFARM_KEY',
    )
    env = {key: os.environ.get(key, None) for key in keys}


class BaseLocalTestCase(unittest.TestCase):

    def test_init(self):
        """
        Geocoder()
        """
        format_string = '%s Los Angeles, CA USA'
        scheme = 'http'
        timeout = DEFAULT_TIMEOUT + 1
        proxies = {'https': '192.0.2.0'}
        geocoder = Geocoder(
            format_string=format_string,
            scheme=scheme,
            timeout=timeout,
            proxies=proxies
        )
        for attr in ('format_string', 'scheme', 'timeout', 'proxies'):
            self.assertEqual(locals()[attr], getattr(geocoder, attr))

    def test_point_coercion(self):
        """
        Geocoder._coerce_point_to_string
        """
        ok = "40.74113,-73.989656"
        coords = (40.74113, -73.989656)
        geocoder = Geocoder()
        self.assertEqual(geocoder._coerce_point_to_string(coords), ok) # pylint: disable=W0212
        self.assertEqual(geocoder._coerce_point_to_string( # pylint: disable=W0212
            Point(*coords)),
            ok
        )


class GoogleV3LocalTestCase(unittest.TestCase): # pylint: disable=R0904,C0111
    def setUp(self):
        self.geocoder = GoogleV3()

    def test_configuration_error(self):
        """
        GoogleV3 raises configuration errors on invalid auth params
        """
        with self.assertRaises(exc.ConfigurationError):
            GoogleV3(client_id='a')
        with self.assertRaises(exc.ConfigurationError):
            GoogleV3(secret_key='a')

    def test_check_status(self):
        """
        GoogleV3 raises correctly on Google-specific API status flags
        """
        self.assertEqual(self.geocoder._check_status("ZERO_RESULTS"), None)
        with self.assertRaises(exc.GeocoderQuotaExceeded):
            self.geocoder._check_status("OVER_QUERY_LIMIT")
        with self.assertRaises(exc.GeocoderQueryError):
            self.geocoder._check_status("REQUEST_DENIED")
        with self.assertRaises(exc.GeocoderQueryError):
            self.geocoder._check_status("INVALID_REQUEST")
        with self.assertRaises(exc.GeocoderQueryError):
            self.geocoder._check_status("_")

    def test_get_signed_url(self):
        """
        GoogleV3._get_signed_url
        """
        geocoder = GoogleV3(
            client_id='my_client_id',
            secret_key=base64.urlsafe_b64encode('my_secret_key'.encode('utf8'))
        )
        self.assertTrue(geocoder.premier)
        # the two possible URLs handle both possible orders of the request
        # params; because it's unordered, either is possible, and each has
        # its own hash
        self.assertTrue(
            geocoder._get_signed_url({'address': '1 5th Ave New York, NY'}) in (
            "https://maps.googleapis.com/maps/api/geocode/json?"
            "address=1+5th+Ave+New+York%2C+NY&client=my_client_id&"
            "signature=Z_1zMBa3Xu0W4VmQfaBR8OQMnDM=",
            "https://maps.googleapis.com/maps/api/geocode/json?"
            "client=my_client_id&address=1+5th+Ave+New+York%2C+NY&"
            "signature=D3PL0cZJrJYfveGSNoGqrrMsz0M="
            )
        )

    def test_format_components_param(self):
        """
        GoogleV3._format_components_param
        """
        f = GoogleV3._format_components_param
        self.assertEqual(f({}), '')
        self.assertEqual(f({'country': 'FR'}), 'country:FR')
        output = f({'administrative_area': 'CA', 'country': 'FR'})
        # the order the dict is iterated over is not important
        self.assertTrue(
            output in (
                'administrative_area:CA|country:FR',
                'country:FR|administrative_area:CA'
            ), output
        )

        with self.assertRaises(AttributeError):
            f(None)

        with self.assertRaises(AttributeError):
            f([])

        with self.assertRaises(AttributeError):
            f('administrative_area:CA|country:FR')


class _BackendTestCase(unittest.TestCase): # pylint: disable=R0904
    """
    Base for geocoder-specific test cases.
    """

    geocoder = None
    delta_exact = 0.002
    delta_inexact = 0.02

    def skip_known_failure(self, classes):
        """
        When a Geocoder gives no value for a query, skip the test.
        """
        if self.geocoder.__class__.__name__ in classes:
            raise unittest.SkipTest("Known no result")

    def test_basic_address(self):
        self.skip_known_failure(('GeoNames', ))

        address = '435 north michigan ave, chicago il 60611'
        try:
            result = self.geocoder.geocode(address, exactly_one=False)
        except exc.GeocoderQuotaExceeded:
            raise unittest.SkipTest("Quota exceeded")
        if result is None:
            self.fail('No result found')
        clean_address, latlon = result[0] # pylint: disable=W0612

        self.assertTrue(result[0].raw is not None)
        self.assertAlmostEqual(latlon[0], 41.890, delta=self.delta_exact)
        self.assertAlmostEqual(latlon[1], -87.624, delta=self.delta_exact)

    def test_partial_address(self):
        self.skip_known_failure(('GeoNames', 'GeocoderDotUS', 'Nominatim'))

        address = '435 north michigan, chicago 60611'
        try:
            result = self.geocoder.geocode(address, exactly_one=True)
        except exc.GeocoderQuotaExceeded:
            raise unittest.SkipTest("Quota exceeded")
        if result is None:
            self.fail('No result found')
        clean_address, latlon = result # pylint: disable=W0612

        self.assertTrue(result.raw is not None)
        self.assertAlmostEqual(latlon[0], 41.890, delta=self.delta_exact)
        self.assertAlmostEqual(latlon[1], -87.624, delta=self.delta_exact)

    def test_intersection(self):
        self.skip_known_failure(
            ('OpenMapQuest', 'GeoNames', 'LiveAddress', 'Nominatim')
        )

        address = 'e. 161st st and river ave, new york, ny'
        try:
            result = self.geocoder.geocode(address, exactly_one=True)
        except exc.GeocoderQuotaExceeded:
            raise unittest.SkipTest("Quota exceeded")
        if result is None:
            self.fail('No result found')
        clean_address, latlon = result # pylint: disable=W0612

        self.assertTrue(result.raw is not None)
        self.assertAlmostEqual(latlon[0], 40.828, delta=self.delta_exact)
        self.assertAlmostEqual(latlon[1], -73.926, delta=self.delta_exact)

    def test_placename(self):
        self.skip_known_failure(('GeocoderDotUS', 'LiveAddress'))

        address = 'Mount St. Helens'

        try:
            result = self.geocoder.geocode(address, exactly_one=True)
        except exc.GeocoderQuotaExceeded:
            raise unittest.SkipTest("Quota exceeded")
        if result is None:
            self.fail('No result found')

        clean_address, latlon = result # pylint: disable=W0612
        self.assertTrue(result.raw is not None)
        self.assertAlmostEqual(latlon[0], 46.1912, delta=self.delta_inexact)
        self.assertAlmostEqual(latlon[1], -122.1944, delta=self.delta_inexact)

    def test_unicode_name(self):
        self.skip_known_failure(('GeoNames', 'LiveAddress', 'MapQuest'))
        # The Forbidden City in Beijing
        address = u'\u6545\u5bab'

        try:
            result = self.geocoder.geocode(address, exactly_one=True)
        except exc.GeocoderQuotaExceeded:
            raise unittest.SkipTest("Quota exceeded")
        if result is None:
            self.fail('No result found')
        clean_address, latlon = result # pylint: disable=W0612

        self.assertTrue(result.raw is not None)
        self.assertAlmostEqual(latlon[0], 39.916, delta=self.delta_inexact)
        self.assertAlmostEqual(latlon[1], 116.390, delta=self.delta_inexact)


class GoogleV3TestCase(_BackendTestCase): # pylint: disable=R0904,C0111
    def setUp(self):
        self.geocoder = GoogleV3(scheme='http')

    def test_geocode_components(self):
        known_addr = 'santa cruz'
        # providing conflicting components should return no results
        result = self.geocoder.geocode(known_addr, components={
            'administrative_area': 'CA',
            'country': 'FR',
        })
        self.assertIsNone(result)

        known_coords = (28.4636296, -16.2518467)
        _, coords = self.geocoder.geocode(known_addr, components={
            'country': 'ES',
        })
        self.assertAlmostEqual(coords[0], known_coords[0], delta=self.delta_exact)
        self.assertAlmostEqual(coords[1], known_coords[1], delta=self.delta_exact)

    def test_reverse(self):
        known_addr = '1060-1078 Avenue of the Americas, New York, NY 10018, USA'
        known_coords = (40.75376406311989, -73.98489005863667)
        result = self.geocoder.reverse(
            "40.75376406311989, -73.98489005863667",
            exactly_one=True
        )
        addr, coords = result
        self.assertTrue(result.raw is not None)
        self.assertEqual(str_coerce(addr), known_addr)
        self.assertAlmostEqual(coords[0], known_coords[0], delta=self.delta_exact)
        self.assertAlmostEqual(coords[1], known_coords[1], delta=self.delta_exact)

    def test_zero_results(self):
        """
        GoogleV3.geocode returns None for no result
        """
        result = self.geocoder.geocode('')
        self.assertIsNone(result)


@unittest.skipUnless( # pylint: disable=R0904,C0111
    env['BING_KEY'] is not None,
    "No BING_KEY env variable set"
)
class BingTestCase(_BackendTestCase):
    def setUp(self):
        self.geocoder = Bing(
            format_string='%s',
            scheme='http',
            api_key=env['BING_KEY']
        )

    def test_reverse(self):
        known_addr = '1067 6th Ave, New York, NY 10018, United States'
        known_coords = (40.75376406311989, -73.98489005863667)
        result = self.geocoder.reverse(Point(40.753898, -73.985071))
        addr, coords = result
        self.assertTrue(result.raw is not None)
        self.assertEqual(str_coerce(addr), known_addr)
        self.assertAlmostEqual(coords[0], known_coords[0], delta=self.delta_exact)
        self.assertAlmostEqual(coords[1], known_coords[1], delta=self.delta_exact)

    def test_user_location(self):
        pensylvania = "20 Main St, Bally, PA 19503, United States"
        colorado = "20 Main St, Broomfield, CO 80020, United States"

        pennsylvania_bias = (40.922351, -75.096562)
        colorado_bias = (39.914231, -105.070104)
        for each in ((pensylvania, pennsylvania_bias), (colorado, colorado_bias)):
            self.assertEqual(
                self.geocoder.geocode(
                    "20 Main Street", user_location=Point(each[1])
                )[0],
                each[0]
            )


class ArcGISTestCase(_BackendTestCase):
    def setUp(self):
        self.geocoder = ArcGIS(timeout=3)

    def test_config_error(self):
        """
        ArcGIS.__init__ invalid authentication
        """
        with self.assertRaises(exc.ConfigurationError):
            ArcGIS(username='a')

    def test_scheme_config_error(self):
        """
        ArcGIS.__init__ invalid scheme
        """
        with self.assertRaises(exc.ConfigurationError):
            ArcGIS(username='a', password='b', referer='http://www.example.com', scheme='http')

    def test_reverse(self):
        """
        ArcGIS.reverse
        """
        known_addr = '1065 6th Ave, New York, New York 10018, USA'
        known_coords = (40.75376406311989, -73.98489005863667)
        result = self.geocoder.reverse(Point(40.753898, -73.985071))
        addr, coords = result
        self.assertTrue(result.raw is not None)
        self.assertEqual(str_coerce(addr), known_addr)
        self.assertAlmostEqual(coords[0], known_coords[0], delta=self.delta_exact)
        self.assertAlmostEqual(coords[1], known_coords[1], delta=self.delta_exact)

    def test_reverse_wkid(self):
        """
        ArcGIS.reverse with non-default WKID
        """
        known_addr = '1065 6th Ave, New York, New York 10018, USA'
        known_coords = (4976084.454557315, -8235967.638346817)
        addr, coords = self.geocoder.reverse(Point(40.753898, -73.985071), wkid=102100)
        self.assertEqual(str_coerce(addr), known_addr)
        self.assertAlmostEqual(coords[0], known_coords[0], delta=self.delta_inexact)
        self.assertAlmostEqual(coords[1], known_coords[1], delta=self.delta_inexact)


@unittest.skipUnless(  # pylint: disable=R0904,C0111
    env.get('ARCGIS_USERNAME') is not None \
    or env.get('ARCGIS_PASSWORD') is not None\
    or env.get('ARCGIS_REFERER') is not None,
    "No ARCGIS_USERNAME or ARCGIS_PASSWORD or ARCGIS_REFERER env variable set"
)
class ArcGISAuthenticatedTestCase(unittest.TestCase):

    delta_exact = 0.002

    def setUp(self):
        self.geocoder = ArcGIS(username=env['ARCGIS_USERNAME'],
                               password=env['ARCGIS_PASSWORD'],
                               referer=env['ARCGIS_REFERER'],
                               timeout=3)

    def test_basic_address(self):
        address = '999 W. Riverside Ave., Spokane, WA 99201'
        result = self.geocoder.geocode(address, exactly_one=True)
        if result is None:
            self.fail('No result found')
        clean_address, latlon = result # pylint: disable=W0612
        self.assertAlmostEqual(latlon[0], 47.658, delta=self.delta_exact)
        self.assertAlmostEqual(latlon[1], -117.426, delta=self.delta_exact)



@unittest.skipUnless( # pylint: disable=R0904,C0111
    env['GEOCODERDOTUS_USERNAME'] is not None and \
    env['GEOCODERDOTUS_PASSWORD'] is not None,
    "No GEOCODERDOTUS_USERNAME and GEOCODERDOTUS_PASSWORD env variables set"
)
class GeocoderDotUSTestCase(_BackendTestCase): # pylint: disable=R0904,C0111
    def setUp(self):
        self.geocoder = GeocoderDotUS(
            username=env['GEOCODERDOTUS_USERNAME'],
            password=env['GEOCODERDOTUS_PASSWORD'],
            timeout=3
        )

    def test_dot_us_auth(self):
        """
        GeocoderDotUS Authorization header
        """
        geocoder = GeocoderDotUS(username='username', password='password')
        # this is a useful/shameful hack; we want to abort at call time, and
        # just get the Request obj
        def _print_call_geocoder(query, timeout, raw):
            raise Exception(query)
        geocoder._call_geocoder = _print_call_geocoder
        exc_raised = False
        try:
            geocoder.geocode("1 5th Ave NYC")
        except Exception as err:
            exc_raised = True
            request = err.message if not py3k else err.args[0]
            self.assertEqual(request.get_header('Authorization'), 'Basic dXNlcm5hbWU6cGFzc3dvcmQ=')
        self.assertTrue(exc_raised)


class OpenMapQuestTestCase(_BackendTestCase): # pylint: disable=R0904,C0111
    def setUp(self):
        self.geocoder = OpenMapQuest(scheme='http', timeout=3)
        self.delta_exact = 0.04
        self.delta_inexact = 0.04


@unittest.skipUnless( # pylint: disable=R0904,C0111
    env['MAPQUEST_KEY'] is not None,
    "No MAPQUEST_KEY env variable set"
)
class MapQuestTestCase(_BackendTestCase):
    def setUp(self):
        self.geocoder = MapQuest(env['MAPQUEST_KEY'], scheme='http', timeout=3)
        self.delta_inexact = 0.04


@unittest.skipUnless( # pylint: disable=R0904,C0111
    env['GEONAMES_USERNAME'] is not None,
    "No GEONAMES_USERNAME env variable set"
)
class GeoNamesTestCase(_BackendTestCase):
    def setUp(self):
        self.geocoder = GeoNames(username=env['GEONAMES_USERNAME'])
        self.delta_inexact = 0.04


@unittest.skipUnless( # pylint: disable=R0904,C0111
    env['LIVESTREETS_AUTH_KEY'] is not None,
    "No LIVESTREETS_AUTH_KEY env variable set"
)
class LiveAddressTestCase(_BackendTestCase):
    def setUp(self):
        self.geocoder = LiveAddress(
            auth_token=env['LIVESTREETS_AUTH_KEY'],
            scheme='http'
        )
        self.delta_inexact = 0.04


class NominatimTestCase(_BackendTestCase): # pylint: disable=R0904,C0111
    def setUp(self):
        self.delta_exact = 0.04
        self.geocoder = Nominatim()

    def test_reverse(self):
        known_addr = "Jose Bonifacio de Andrada e Silva, 6th Avenue, Diamond "\
            "District, Hell's Kitchen, NYC, New York, 10020, United States of America"
        known_coords = (40.75376406311989, -73.98489005863667)
        result = self.geocoder.reverse(
            "40.75376406311989, -73.98489005863667",
            exactly_one=True
        )
        self.assertTrue(result.raw is not None)
        addr, coords = result
        self.assertEqual(str_coerce(addr), known_addr)
        self.assertAlmostEqual(coords[0], known_coords[0], delta=self.delta_exact)
        self.assertAlmostEqual(coords[1], known_coords[1], delta=self.delta_exact)


@unittest.skipUnless( # pylint: disable=R0904,C0111
    env['YAHOO_KEY'] is not None and env['YAHOO_SECRET'] is not None,
    "YAHOO_KEY and YAHOO_SECRET env variables not set"
)
class YahooPlaceFinderTestCase(_BackendTestCase): # pylint: disable=R0904,C0111
    def setUp(self):
        self.geocoder = YahooPlaceFinder(env['YAHOO_KEY'], env['YAHOO_SECRET'])


@unittest.skipUnless( # pylint: disable=R0904,C0111
    env['GEOCODEFARM_KEY'] is not None,
    "GEOCODEFARM_KEY env variable not set"
)
class GeocodeFarmTestCase(_BackendTestCase): # pylint: disable=R0904,C0111
    def setUp(self):
        self.delta_exact = 0.04
        self.geocoder = GeocodeFarm(api_key=env['GEOCODEFARM_KEY'], format_string="%s US")

    def test_reverse(self):
        known_addr = '1075 6 Avenue, New York, NY 10018, USA'
        known_coords = (40.75376406311989, -73.98489005863667)
        try:
            result = self.geocoder.reverse(Point(40.753898, -73.985071))
        except exc.GeocoderQuotaExceeded:
            raise unittest.SkipTest("Quota exceeded")
        addr, coords = result
        self.assertTrue(result.raw is not None)
        self.assertEqual(str_coerce(addr), known_addr)
        self.assertAlmostEqual(coords[0], known_coords[0], delta=self.delta_exact)
        self.assertAlmostEqual(coords[1], known_coords[1], delta=self.delta_exact)

    def test_GeocoderAuthenticationFailure(self):
        self.geocoder = GeocodeFarm(api_key="Failbear", format_string="%s US")
        with self.assertRaises(GeocoderAuthenticationFailure):
            address = '435 north michigan ave, chicago il 60611'
            self.geocoder.geocode(address)

    def test_GeocoderQuotaExceeded(self):
        # mock API call to return bad response
        def mock_call_geocoder(self, url, timeout=None, raw=False):
            return {
                "geocoding_results": {
                    "STATUS": {
                        "access": "OVER_QUERY_LIMIT",
                        "status": "FAILED, ACCESS_DENIED"
                    }
                }
            }
        self.geocoder._call_geocoder = types.MethodType(mock_call_geocoder, self.geocoder)

        with self.assertRaises(GeocoderQuotaExceeded):
            address = '435 north michigan ave, chicago il 60611'
            self.geocoder.geocode(address)

    def test_unhandled_api_error(self):
        # mock API call to return bad response
        def mock_call_geocoder(self, url, timeout=None, raw=False):
            return {
                "geocoding_results": {
                    "STATUS": {
                        "access": "BILL_PAST_DUE",
                        "status": "FAILED, ACCESS_DENIED"
                    }
                }
            }
        self.geocoder._call_geocoder = types.MethodType(mock_call_geocoder, self.geocoder)

        with self.assertRaises(GeocoderServiceError):
            address = '435 north michigan ave, chicago il 60611'
            self.geocoder.geocode(address)

########NEW FILE########
__FILENAME__ = test_distance
"""
Test distance formulas
"""
import math

from nose.tools import assert_raises, assert_almost_equal

from geopy.point import Point
from geopy.distance import (Distance,
                            GreatCircleDistance,
                            VincentyDistance,
                            EARTH_RADIUS,
                            ELLIPSOIDS)


EARTH_CIRCUMFERENCE = 2 * math.pi * EARTH_RADIUS
NORTH_POLE = Point(90, 0)
SOUTH_POLE = Point(-90, 0)
FIJI = Point(-16.1333333, 180.0) # Vunikondi, Fiji


class CommonDistanceComputationCases:
    def test_zero_measure(self):
        self.cls(
            (40.753152999999998, -73.982275999999999),
            (40.753152999999998, -73.982275999999999)
        )

    def test_should_have_length_when_only_given_length(self):
        distance = 1
        assert self.cls(distance).kilometers == distance

    def test_should_have_zero_distance_for_coincident_points(self):
        assert self.cls((0, 0), (0, 0)).kilometers == 0

    def test_should_have_nonzero_distance_for_distinct_points(self):
        assert self.cls((0, 0), (0, 1)).kilometers > 0

    def test_max_longitude(self):
        distance = self.cls(kilometers=1.0)
        destination = distance.destination(FIJI, 45)
        assert_almost_equal(destination.longitude, -179.99338, 4)

    def test_should_compute_distance_for_trip_between_poles(self):
        distance = self.cls(SOUTH_POLE, NORTH_POLE)
        expected_distance = EARTH_CIRCUMFERENCE / 2
        assert_almost_equal(distance.kilometers, expected_distance, -2)

    def test_should_compute_destination_for_trip_between_poles(self):
        distance = self.cls(EARTH_CIRCUMFERENCE / 2)
        destination = distance.destination(NORTH_POLE, 0)
        assert_almost_equal(destination.latitude, -90, 0)
        assert_almost_equal(destination.longitude, 0)

    def test_should_recognize_equivalence_of_pos_and_neg_180_longitude(self):
        distance = self.cls((0, 180), (0, -180)).kilometers
        assert_almost_equal(distance, 0)


class CommonMathematicalOperatorCases:
    def test_should_be_able_to_add_distances(self):
        added = self.cls(1.0) + self.cls(1.0)
        assert_almost_equal(added.kilometers, 2.0)

    def test_should_not_allow_adding_with_objects_that_arent_distances(self):
        assert_raises(TypeError, lambda: self.cls(1.0) + 5)

    def test_should_be_able_to_negate_distances(self):
        distance = self.cls(1.0)
        assert_almost_equal(-(distance.kilometers),
                            (-distance).kilometers)

    def test_should_be_able_to_subtract_distances(self):
        subtracted = self.cls(2.0) - self.cls(1.0)
        assert_almost_equal(subtracted.kilometers, 1)

    def test_should_be_able_to_multiply_distances_by_floats(self):
        assert_almost_equal((self.cls(2.0) * 2.0).kilometers,
                            4.0)

    def test_should_not_be_able_to_multiply_distances_by_distances(self):
        assert_raises(TypeError, lambda: self.cls(1.0) * self.cls(2.0))

    def test_should_be_able_to_divide_distances_by_distances(self):
        ratio = self.cls(4.0) / self.cls(2.0)
        assert_almost_equal(ratio, 2.0)

    def test_should_be_able_to_divide_distances_by_floats(self):
        divided_distance = self.cls(4.0) / 2.0
        assert_almost_equal(divided_distance.kilometers, 2.0)

    def test_should_be_able_to_take_absolute_value_of_distances(self):
        assert_almost_equal(abs(self.cls(-1.0)).kilometers,
                            1.0)

    def test_should_be_true_in_boolean_context_when_nonzero_length(self):
        assert self.cls(1.0)

    def test_should_be_false_in_boolean_context_when_zero_length(self):
        assert not self.cls(0)

    def test_should_get_consistent_results_for_distance_calculations(self):
        distance1, distance2 = [self.cls((0, 0), (0, 1))
                                for _ in range(2)]
        assert distance1.kilometers == distance2.kilometers


class CommonConversionCases:
    def test_should_convert_to_kilometers(self):
        assert self.cls(1.0).kilometers == 1.0

    def test_should_convert_to_kilometers_with_abbreviation(self):
        assert self.cls(1.0).km == 1.0

    def test_should_convert_to_meters(self):
        assert self.cls(1.0).meters == 1000.0

    def test_should_convert_to_meters_with_abbreviation(self):
        assert self.cls(1.0).m == 1000.0

    def test_should_convert_to_miles(self):
        assert_almost_equal(self.cls(1.0).miles, 0.621371192)

    def test_should_convert_to_miles_with_abbreviation(self):
        assert_almost_equal(self.cls(1.0).mi, 0.621371192)

    def test_should_convert_to_feet(self):
        assert_almost_equal(self.cls(1.0).feet, 3280.8399, 4)

    def test_should_convert_to_feet_with_abbreviation(self):
        assert_almost_equal(self.cls(1.0).ft, 3280.8399, 4)

    def test_should_convert_to_nautical_miles(self):
        assert_almost_equal(self.cls(1.0).nautical, 0.539956803)

    def test_should_convert_to_nautical_miles_with_abbrevation(self):
        assert_almost_equal(self.cls(1.0).nm, 0.539956803)


class CommonDistanceCases(CommonDistanceComputationCases,
                          CommonMathematicalOperatorCases,
                          CommonConversionCases):
    pass


class TestWhenInstantiatingBaseDistanceClass:
    def test_should_not_be_able_to_give_multiple_points(self):
        assert_raises(NotImplementedError, lambda: Distance(1, 2, 3, 4))


class TestWhenComputingGreatCircleDistance(CommonDistanceCases):
    cls = GreatCircleDistance

    def test_should_compute_distance_for_half_trip_around_equator(self):
        distance_around_earth = self.cls((0, 0), (0, 180)).kilometers
        assert distance_around_earth == EARTH_CIRCUMFERENCE / 2

    def test_should_compute_destination_for_half_trip_around_equator(self):
        distance = self.cls(EARTH_CIRCUMFERENCE / 2)
        destination = distance.destination((0, 0), 0)
        assert_almost_equal(destination.latitude, 0)
        assert_almost_equal(destination.longitude, 180)


class TestWhenComputingVincentyDistance(CommonDistanceCases):
    cls = VincentyDistance

    def setup(self):
        self.original_ellipsoid = self.cls.ELLIPSOID

    def teardown(self):
        self.cls.ELLIPSOID = self.original_ellipsoid

    def test_should_not_converge_for_half_trip_around_equator(self):
        assert_raises(ValueError, self.cls, (0, 0), (0, 180))

    def test_should_compute_destination_for_half_trip_around_equator(self):
        distance = self.cls(EARTH_CIRCUMFERENCE / 2)
        destination = distance.destination((0, 0), 0)
        assert_almost_equal(destination.latitude, 0, 0)
        assert_almost_equal(destination.longitude, -180, 0)

    def test_should_get_distinct_results_for_different_ellipsoids(self):
        results = []
        for ellipsoid_name in ELLIPSOIDS.keys():
            results.append(self.cls((0, 0), (0, 1), ellipsoid=ELLIPSOIDS[ellipsoid_name]))

        assert not any(results[x].kilometers == results[y].kilometers
                       for x in range(len(results))
                       for y in range(len(results))
                       if x != y)


########NEW FILE########
__FILENAME__ = test_format

import unittest
import geopy

class TestFormat(unittest.TestCase):

    def test_format(self):
        d = geopy.point.Point.parse_degrees('-13', '19', 0)
        s = geopy.format.format_degrees(d)
        self.assertEqual("-13 19\' 0.0\"", s)

if __name__ == '__main__':
    unittest.main()


########NEW FILE########
__FILENAME__ = test_location
# encoding: utf-8
"""
Test Location.
"""

import unittest
from geopy.location import Location
from geopy.point import Point


GRAND_CENTRAL_STR = "89 E 42nd St New York, NY 10017"

GRAND_CENTRAL_COORDS_STR = "40.752662,-73.9773"
GRAND_CENTRAL_COORDS_TUPLE = (40.752662, -73.9773, 0)
GRAND_CENTRAL_POINT = Point(GRAND_CENTRAL_COORDS_STR)

GRAND_CENTRAL_RAW = {
    'id': '1',
    'class': 'place',
    'lat': '40.752662',
    'lon': '-73.9773',
    'display_name':
        "89, East 42nd Street, New York, "
        "New York, 10017, United States of America",
}


class LocationTestCase(unittest.TestCase): # pylint: disable=R0904
    """
    Test :class:`geopy.location.Location`.
    """

    def _location_iter_test(self,
            loc,
            ref_address=GRAND_CENTRAL_STR,
            ref_longitude=GRAND_CENTRAL_COORDS_TUPLE[0],
            ref_latitude=GRAND_CENTRAL_COORDS_TUPLE[1]
        ):
        """
        Helper for equality tests on Location's __iter__.
        """
        address, (latitude, longitude) = loc
        self.assertEqual(address, ref_address)
        self.assertEqual(latitude, ref_longitude)
        self.assertEqual(longitude, ref_latitude)

    def _location_properties_test(self, loc, raw=None):
        """
        Helper for equality tests of Location's properties
        """
        self.assertEqual(loc.address, GRAND_CENTRAL_STR)
        self.assertEqual(loc.latitude, GRAND_CENTRAL_COORDS_TUPLE[0])
        self.assertEqual(loc.longitude, GRAND_CENTRAL_COORDS_TUPLE[1])
        self.assertEqual(loc.altitude, GRAND_CENTRAL_COORDS_TUPLE[2])
        if raw is not None:
            self.assertEqual(loc.raw, raw)

    def test_location_init(self):
        """
        Location with string point
        """
        loc = Location(GRAND_CENTRAL_STR, GRAND_CENTRAL_COORDS_STR)
        self._location_iter_test(loc)
        self.assertEqual(loc.point, GRAND_CENTRAL_POINT)

    def test_location_point(self):
        """
        Location with Point
        """
        loc = Location(GRAND_CENTRAL_STR, GRAND_CENTRAL_POINT)
        self._location_iter_test(loc)
        self.assertEqual(loc.point, GRAND_CENTRAL_POINT)

    def test_location_none(self):
        """
        Location with None point
        """
        loc = Location(GRAND_CENTRAL_STR, None)
        self._location_iter_test(loc, GRAND_CENTRAL_STR, None, None)
        self.assertEqual(loc.point, None)

    def test_location_iter(self):
        """
        Location with iterable point
        """
        loc = Location(GRAND_CENTRAL_STR, GRAND_CENTRAL_COORDS_TUPLE)
        self._location_iter_test(loc)
        self.assertEqual(loc.point, GRAND_CENTRAL_POINT)

    def test_location_typeerror(self):
        """
        Location invalid point TypeError
        """
        with self.assertRaises(TypeError):
            Location(GRAND_CENTRAL_STR, 1)

    def test_location_array_access(self):
        """
        Location array access
        """
        loc = Location(GRAND_CENTRAL_STR, GRAND_CENTRAL_COORDS_TUPLE)
        self.assertEqual(loc[0], GRAND_CENTRAL_STR)
        self.assertEqual(loc[1][0], GRAND_CENTRAL_COORDS_TUPLE[0])
        self.assertEqual(loc[1][1], GRAND_CENTRAL_COORDS_TUPLE[1])

    def test_location_properties(self):
        """
        Location properties
        """
        loc = Location(GRAND_CENTRAL_STR, GRAND_CENTRAL_POINT)
        self._location_properties_test(loc)

    def test_location_raw(self):
        """
        Location.raw
        """
        loc = Location(
            GRAND_CENTRAL_STR, GRAND_CENTRAL_POINT, raw=GRAND_CENTRAL_RAW
        )
        self._location_properties_test(loc, GRAND_CENTRAL_RAW)

    def test_location_string(self):
        """
        str(Location) == Location.address
        """
        loc = Location(GRAND_CENTRAL_STR, GRAND_CENTRAL_POINT)
        self.assertEqual(str(loc), loc.address)

    def test_location_len(self):
        """
        len(Location)
        """
        loc = Location(GRAND_CENTRAL_STR, GRAND_CENTRAL_POINT)
        self.assertEqual(len(loc), 2)

    def test_location_eq(self):
        """
        Location.__eq__
        """
        loc1 = Location(GRAND_CENTRAL_STR, GRAND_CENTRAL_POINT)
        loc2 = Location(GRAND_CENTRAL_STR, GRAND_CENTRAL_COORDS_TUPLE)
        self.assertEqual(loc1, loc2)

    def test_location_ne(self):
        """
        Location.__ne__
        """
        loc1 = Location(GRAND_CENTRAL_STR, GRAND_CENTRAL_POINT)
        loc2 = Location(GRAND_CENTRAL_STR, None)
        self.assertNotEqual(loc1, loc2)

########NEW FILE########
__FILENAME__ = test_point
# encoding: utf-8
"""
Test Point.
"""

import unittest
from geopy.point import Point

class PointTestCase(unittest.TestCase): # pylint: disable=R0904
    """
    geopy.point.Point
    """

    lat = 40.74113
    lon = -73.989656
    alt = 3
    coords = (lat, lon, alt)

    def test_point_float(self):
        """
        Point() floats
        """
        point = Point(self.lat, self.lon, self.alt)
        self.assertEqual(point.longitude, self.lon)
        self.assertEqual(point.latitude, self.lat)
        self.assertEqual(point.altitude, self.alt)

    def test_point_str_simple(self):
        """
        Point() str
        """
        for each in ("%s,%s", "%s %s", "%s;%s"):
            point = Point(each % (self.lat, self.lon))
            self.assertEqual(point.longitude, self.lon)
            self.assertEqual(point.latitude, self.lat)

    def test_point_str_deg(self):
        """
        Point() str degrees, minutes &c
        """
        point = Point((u"UT: N 3920' 0'' / W 7435' 0''"))
        self.assertEqual(point.latitude, 39.333333333333336)
        self.assertEqual(point.longitude, -74.58333333333333)
        self.assertEqual(point.altitude, 0)

    def test_point_getitem(self):
        """
        Point.__getitem__
        """
        point = Point(self.lat, self.lon, self.alt)
        self.assertEqual(point[0], self.lat)
        self.assertEqual(point[1], self.lon)
        self.assertEqual(point[2], self.alt)

    def test_point_setitem(self):
        """
        Point.__setitem__
        """
        point = Point(self.lat + 10, self.lon + 10, self.alt + 10)
        for each in (0, 1, 2):
            point[each] = point[each] - 10
        self.assertEqual(point[0], self.lat)
        self.assertEqual(point[1], self.lon)
        self.assertEqual(point[2], self.alt)

    def test_point_eq(self):
        """
        Point.__eq__
        """
        self.assertEqual(
            Point(self.lat, self.lon),
            Point("%s %s" % (self.lat, self.lon))
        )

    def test_point_ne(self):
        """
        Point.__ne__
        """
        self.assertTrue(
            Point(self.lat, self.lon, self.alt) !=
            Point(self.lat+10, self.lon-10, self.alt)
        )




########NEW FILE########
__FILENAME__ = test_proxy
"""
Test ability to proxy requests.
"""

import os
import unittest
from test import proxy_server
from geopy.compat import urlopen, URLError
from geopy.geocoders.base import Geocoder

### UNIT TEST(S) to test Proxy in Geocoder base class ###
###
### Solution requires that proxy_server.py is run to start simple proxy
### daemon proxy PID is located in /var/run/proxy_server.pid and can be
### stoped using the command `kill -9 $(cat /var/run/proxy_server.pid)`


class ProxyTestCase(unittest.TestCase): # pylint: disable=R0904,C0111
    def setUp(self):

        # TODO subprocess.Popen proxy locally on os.name=="posix", and skip if not

        # Backup environ settings
        self.orig_http_proxy = os.environ['http_proxy'] if 'http_proxy' in os.environ else None

        # Get HTTP for comparison before proxy test
        base_http = urlopen('http://www.blankwebsite.com/')
        base_html = base_http.read()
        self.noproxy_data = base_html if base_html else None

        # Create the proxy instance
        self.proxyd = proxy_server.ProxyServer()
        # Set the http_proxy environment variable with Proxy_server default value
        os.environ['http_proxy'] = self.proxyd.get_proxy_url()

    def teardown(self):
        if self.orig_http_proxy:
            os.environ['http_proxy'] = self.orig_http_proxy
        else:
            del os.environ['http_proxy']

    def test_proxy(self):
        ''' Test of OTB Geocoder Proxy functionality works'''
        class DummyGeocoder(Geocoder):
            def geocode(self, location):
                geo_request = urlopen(location)
                geo_html = geo_request.read()
                return geo_html if geo_html else None

        '''Testcase to test that proxy standup code works'''
        geocoder_dummy = DummyGeocoder(proxies={"http": "http://localhost:1337"})
        try:
            self.assertTrue(
                self.noproxy_data,
                geocoder_dummy.geocode('http://www.blankwebsite.com/')
            )
        except URLError as err:
            if "connection refused" in str(err).lower():
                raise unittest.SkipTest("Proxy not running")
            raise err

########NEW FILE########
