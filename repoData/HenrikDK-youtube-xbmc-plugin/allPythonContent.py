__FILENAME__ = BaseTestCase
import sys
import os
import time
import unittest2
import MockYouTubeDepends
from mock import Mock
MockYouTubeDepends.MockYouTubeDepends().mockXBMC()

sys.path.append('../plugin/')
sys.path.append('../xbmc-mocks/')

if not os.path.exists("tmp"):
    os.mkdir("tmp")
else:
    for old_file in os.listdir("tmp"):
        os.remove("./tmp/" + old_file)


class BaseTestCase(unittest2.TestCase):  #pragma: no cover
    def setUp(self):
        time.sleep(5)
        MockYouTubeDepends.MockYouTubeDepends().mock()
        MockYouTubeDepends.MockYouTubeDepends().mockXBMC()
        self.intializePlugin()

    def intializePlugin(self):
        import cookielib
        import urllib2
        sys.modules["__main__"].cookiejar = cookielib.LWPCookieJar("resources/cookie.jar")
        sys.modules["__main__"].opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(sys.modules["__main__"].cookiejar))
        urllib2.install_opener(sys.modules["__main__"].opener)

        sys.argv = ["something", -1, "something_else"]
        import CommonFunctions
        reload(CommonFunctions)
        sys.modules["__main__"].common = CommonFunctions
        sys.modules["__main__"].common.log = sys.modules["__main__"].xbmc.log
        sys.modules["__main__"].settingsDL.load_strings("./resources/settings.xml")
        sys.modules["__main__"].xbmcaddon.Addon.return_value = sys.modules["__main__"].settingsDL
        sys.modules["__main__"].xbmcvfs.exists.return_value = True

        import SimpleDownloader
        sys.modules["__main__"].downloader = SimpleDownloader.SimpleDownloader()
        sys.modules["__main__"].xbmcvfs.exists.return_value = False
        import YouTubePluginSettings
        sys.modules["__main__"].pluginsettings = YouTubePluginSettings.YouTubePluginSettings()
        import YouTubeUtils
        sys.modules["__main__"].utils = YouTubeUtils.YouTubeUtils()
        import YouTubeStorage
        sys.modules["__main__"].storage = YouTubeStorage.YouTubeStorage()
        import YouTubeCore
        sys.modules["__main__"].core = YouTubeCore.YouTubeCore()
        sys.modules["__main__"].core.getVideoIdStatusFromCache = Mock()
        sys.modules["__main__"].core.getVideoIdStatusFromCache.return_value = []
        import YouTubeLogin
        sys.modules["__main__"].login = YouTubeLogin.YouTubeLogin()
        import YouTubeFeeds
        sys.modules["__main__"].feeds = YouTubeFeeds.YouTubeFeeds()
        import YouTubeSubtitleControl
        sys.modules["__main__"].subtitles = YouTubeSubtitleControl.YouTubeSubtitleControl()
        import YouTubePlayer
        sys.modules["__main__"].player = YouTubePlayer.YouTubePlayer()
        import YouTubeScraper
        sys.modules["__main__"].scraper = YouTubeScraper.YouTubeScraper()
        import YouTubePlaylistControl
        sys.modules["__main__"].playlist = YouTubePlaylistControl.YouTubePlaylistControl()
        import YouTubeNavigation
        self.navigation = YouTubeNavigation.YouTubeNavigation()

    def reset_xbmc_mocks(self):
        sys.modules["__main__"].xbmcplugin.addDirectoryItem.reset_mock()
        sys.modules["__main__"].xbmcplugin.reset_mock()
        sys.modules["__main__"].xbmc.PlayList().add.reset_mock()
        sys.modules["__main__"].xbmc.PlayList().reset_mock()
        sys.modules["__main__"].xbmc.reset_mock()
        sys.modules["__main__"].xbmcgui.ListItem.reset_mock()
        sys.modules["__main__"].xbmcgui.reset_mock()

    def assert_directory_count_greater_than_or_equals(self, count):
        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list

        if len(args) < count:
            print "Directory list length %s is not greater than or equal to expected list lengt %s" % (repr(len(args)), repr(count))
        
        assert(len(args) >= count)
    
    def assert_directory_count_less_than_or_equals(self, count):
        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list
        
        if len(args) > count:
            print "Directory list length %s is not less than or equal to expected list lengt %s" % (repr(len(args)), repr(count))
        
        assert(len(args) <= count)

    def assert_directory_count_equals(self, count):
        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list
        
        if len(args) != count:
            print "Expected directory list length %s does not match actual list lengt %s" % (repr(count), repr(len(args)))
        
        assert(len(args) == count)
    
    def assert_directory_is_a_video_list(self):
        folder_count = 0
        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list
        
        for call in args:
            if call[1]["isFolder"] == True:
                folder_count += 1
        
        if folder_count > 1:
            print "Directory is not a video list, it contains %s folders (Max 1 allowed)" % folder_count
            print "Directory list: \r\n" + repr(args)

        assert(folder_count <= 1)
        
    def assert_directory_is_a_folder_list(self):
        video_count = 0
        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list
        
        for call in args:
            if call[1]["isFolder"] == False:
                video_count += 1
        
        if video_count > 0:
            print "Directory is not a folder list, it contains %s videos" % video_count
            print "Directory list: \r\n" + repr(args)
            
        assert(video_count == 0)
            
    def assert_directory_contains_almost_only_unique_video_items(self):
        video_ids = []
        non_unique = []
        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list
        
        for call in args:
            url = call[1]["url"]
            if url.find("videoid=") > -1:
                video = url[url.find("videoid=") + len("videoid="):]
                if video.find("&") > -1:
                    video = video[:video.find("&")]
                
                if video:
                    if video in video_ids:
                        non_unique.append(video)
                    video_ids.append(video)
        
        if len(non_unique) > 2:
            print "Directory contains three or more duplicate videoids.\r\n Duplicates: %s \r\n Full List: %s" % (repr(non_unique), repr(video_ids)) 
            print "Directory list: \r\n" + repr(args)
            
        assert(len(non_unique) <= 2)
    
    def assert_directory_items_should_have_external_thumbnails(self):
        args = sys.modules["__main__"].xbmcgui.ListItem.call_args_list
        
        missing_thumb_count = 0
        for call in args:
            if call[1]["thumbnailImage"].find("http://") == -1: 
                missing_thumb_count += 1
        
        if missing_thumb_count > 1:
            print "Directory contains more than one item with an invalid thumbnail: " 
            print "List Items: \r\n" + repr(args)
        
        assert(missing_thumb_count <= 1)
    
    def assert_directory_items_should_have_thumbnails(self):
        args = sys.modules["__main__"].xbmcgui.ListItem.call_args_list
        
        missing_thumb_count = 0
        for call in args:
            if len(call[1]["thumbnailImage"]) <= 7: 
                missing_thumb_count += 1
        
        if missing_thumb_count > 1:
            print "Directory contains more than one item with an invalid thumbnail: " 
            print "List Items: \r\n" + repr(args)
        
        assert(missing_thumb_count <= 1)
        
    def assert_directory_items_should_have_poster_thumbnails(self):
        args = sys.modules["__main__"].xbmcgui.ListItem.call_args_list
        
        missing_poster_count = 0
        for call in args:
            if call[1]["thumbnailImage"].find("poster") == -1: 
                missing_poster_count += 1
        
        if missing_poster_count > 1:
            print "Directory contains more than one item with an invalid thumbnail: " 
            print "List Items: \r\n" + repr(args)
        
        assert(missing_poster_count <= 1)
    
    def assert_directory_should_have_next_folder(self):
        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list
        
        next_folder_count = 0
        
        for call in args:
            if call[1]["url"].find("page=") > 0:
                next_folder_count += 1
        
        if next_folder_count != 1:
            print "Expected Directory Listing to contain a next folder but didn't find any:"
            print "List Items: \r\n" + repr(args)
        assert(next_folder_count == 1)
        
    def assert_directory_item_urls_contain(self, param):
        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list
        
        missing_count = 0
        
        for call in args:
            url = call[1]["url"]
            if url.find(param + "=") < 0:
                missing_count += 1
            else:
                value = url[url.find(param + "=") + len(param + "="):]
                if value.find("&") > -1:
                    value = value[:value.find("&")]

                if len(value) == 0:
                    missing_count += 1
        
        if missing_count > 1:
            print 'Expected directory items url\'s to contain the "%s" but more than one item was missing this property' % param
            print "Directory list: \r\n" + repr(args)
            
        assert(missing_count <= 1)

    def assert_directory_item_urls_contain_at_least_one(self, param):
        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list

        found = False

        for call in args:
            print repr(call)
            url = call[1]["url"]
            if url.find(param) > -1:
                found = True
        
        if not found:
            print 'Couldnt find %s in list of directory item title\'s' % param
            print "Directory list: \r\n" + repr(args)
            
        assert(found == True)

    def assert_directory_item_titles_contain(self, param):
        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list

        found = False
        
        for call in args:
            title = call[1]["Title"]
            if title.find(param) > -1:
                found = True 
        
        if not found:
            print 'Couldnt find %s in list of directory item title\'s' % param
            print "Directory list: \r\n" + repr(args)
            
        assert(found == True)

    def assert_directory_item_titles_does_not_contain(self, param):
        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list
        
        found = False
        
        for call in args:
            title = call[1]["Title"]
            if title.find(param) > -1:
                found = True 
        
        if found:
            print 'Found %s in list of directory item title\'s' % param
            print "Directory list: \r\n" + repr(args)
            
        assert(found == False)
                
    def assert_playlist_count_greater_than_or_equals(self, count):
        args = sys.modules["__main__"].xbmc.PlayList().add.call_args_list
        
        if len(args) < count:
            print "Playlist list length %s is not greater than or equal to expected list lengt %s" % (repr(len(args)), repr(count))
        
        assert(len(args) >= count)
        
    def assert_playlist_count_less_than_or_equals(self, count):
        args = sys.modules["__main__"].xbmc.PlayList().add.call_args_list
        
        if len(args) > count:
            print "Playlist list length %s is not less than or equal to expected list lengt %s" % (repr(len(args)), repr(count))
        
        assert(len(args) <= count)

    def assert_playlist_count_equals(self, count):
        args = sys.modules["__main__"].xbmc.PlayList().add.call_args_list
        
        if len(args) != count:
            print "Playlist list length %s does not equal expected list lengt %s" % (repr(len(args)), repr(count))
        
        assert(len(args) == count)

    def assert_playlist_contains_only_unique_video_items(self):
        video_ids = []
        non_unique = []
        args = sys.modules["__main__"].xbmc.PlayList().add.call_args_list
        
        for call in args:
            url = call[0][0]
            if url.find("videoid=") > -1:
                video = url[url.find("videoid=") + len("videoid="):]
                if video.find("&") > -1:
                    video = video[:video.find("&")]
                
                if video:
                    if video in video_ids:
                        non_unique.append(video)
                    video_ids.append(video)
        
        if len(non_unique) > 0:
            print "Playlist contains one or more duplicate videoids.\r\n Duplicates: %s \r\n Full List: %s" % (repr(non_unique), repr(video_ids)) 
            print "Playlist: \r\n" + repr(args)
            
        assert(len(non_unique) == 0)
    
    def assert_playlist_videos_contain(self, videoid):
        video_ids = []
        args = sys.modules["__main__"].xbmc.PlayList().add.call_args_list
        
        for call in args:
            url = call[0][0]
            if url.find("videoid=") > -1:
                video = url[url.find("videoid=") + len("videoid="):]
                if video.find("&") > -1:
                    video = video[:video.find("&")]
                
                if video not in video_ids:
                    video_ids.append(video)
        
        print repr(video_ids)
        
        if videoid not in video_ids:
            print 'Expected to find %s in playlist items' % videoid
            print "Playlist items: \r\n" + repr(args)
        
        assert(videoid in video_ids)

    def assert_playlist_videos_does_not_contain(self, videoid):
        video_ids = []
        args = sys.modules["__main__"].xbmc.PlayList().add.call_args_list
        
        for call in args:
            url = call[0][0]
            if url.find("videoid=") > -1:
                video = url[url.find("videoid=") + len("videoid="):]
                if video.find("&") > -1:
                    video = video[:video.find("&")]
                
                if video not in video_ids:
                    video_ids.append(video)
        
        if videoid in video_ids:
            print 'Expected not to find %s in playlist items' % videoid
            print "Playlist items: \r\n" + repr(args)
            
        assert(videoid not in video_ids)

########NEW FILE########
__FILENAME__ = CommonFunctions
'''
   Parsedom for XBMC plugins
   Copyright (C) 2010-2011 Tobias Ussing And Henrik Mosgaard Jensen

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import sys
import urllib
import urllib2
import re
import io
import inspect
import time
import HTMLParser
#import chardet
import json

version = u"1.5.1"
plugin = u"CommonFunctions Beta-" + version
print plugin

USERAGENT = u"Mozilla/5.0 (Windows NT 6.2; Win64; x64; rv:16.0.1) Gecko/20121011 Firefox/16.0.1"

if hasattr(sys.modules["__main__"], "xbmc"):
    xbmc = sys.modules["__main__"].xbmc
else:
    import xbmc

if hasattr(sys.modules["__main__"], "xbmcgui"):
    xbmcgui = sys.modules["__main__"].xbmcgui
else:
    import xbmcgui

if hasattr(sys.modules["__main__"], "dbg"):
    dbg = sys.modules["__main__"].dbg
else:
    dbg = False

if hasattr(sys.modules["__main__"], "dbglevel"):
    dbglevel = sys.modules["__main__"].dbglevel
else:
    dbglevel = 3

if hasattr(sys.modules["__main__"], "opener"):
    urllib2.install_opener(sys.modules["__main__"].opener)


# This function raises a keyboard for user input
def getUserInput(title=u"Input", default=u"", hidden=False):
    log("", 5)
    result = None

    # Fix for when this functions is called with default=None
    if not default:
        default = u""

    keyboard = xbmc.Keyboard(default, title)
    keyboard.setHiddenInput(hidden)
    keyboard.doModal()

    if keyboard.isConfirmed():
        result = keyboard.getText()

    log(repr(result), 5)
    return result


# This function raises a keyboard numpad for user input
def getUserInputNumbers(title=u"Input", default=u""):
    log("", 5)
    result = None

    # Fix for when this functions is called with default=None
    if not default:
        default = u""

    keyboard = xbmcgui.Dialog()
    result = keyboard.numeric(0, title, default)

    log(repr(result), 5)
    return str(result)


def getXBMCVersion():
    log("", 3)
    version = xbmc.getInfoLabel( "System.BuildVersion" )
    log(version, 3)
    for key in ["-", " "]:
        if version.find(key) -1:
            version = version[:version.find(key)]
    version = float(version)
    log(repr(version))
    return version

# Converts the request url passed on by xbmc to the plugin into a dict of key-value pairs
def getParameters(parameterString):
    log("", 5)
    commands = {}
    if getXBMCVersion() >= 12.0:
        parameterString = urllib.unquote_plus(parameterString)
    splitCommands = parameterString[parameterString.find('?') + 1:].split('&')

    for command in splitCommands:
        if (len(command) > 0):
            splitCommand = command.split('=')
            key = splitCommand[0]
            try: 
                value = splitCommand[1].encode("utf-8")
            except:
                log("Error utf-8 encoding argument value: " + repr(splitCommand[1]))
                value = splitCommand[1]

            commands[key] = value

    log(repr(commands), 5)
    return commands


def replaceHTMLCodes(txt):
    log(repr(txt), 5)

    # Fix missing ; in &#<number>;
    txt = re.sub("(&#[0-9]+)([^;^0-9]+)", "\\1;\\2", makeUTF8(txt))

    txt = HTMLParser.HTMLParser().unescape(txt)
    txt = txt.replace("&amp;", "&")
    log(repr(txt), 5)
    return txt


def stripTags(html):
    log(repr(html), 5)
    sub_start = html.find("<")
    sub_end = html.find(">")
    while sub_start < sub_end and sub_start > -1:
        html = html.replace(html[sub_start:sub_end + 1], "").strip()
        sub_start = html.find("<")
        sub_end = html.find(">")

    log(repr(html), 5)
    return html


def _getDOMContent(html, name, match, ret):  # Cleanup
    log("match: " + match, 3)

    endstr = u"</" + name  # + ">"

    start = html.find(match)
    end = html.find(endstr, start)
    pos = html.find("<" + name, start + 1 )

    log(str(start) + " < " + str(end) + ", pos = " + str(pos) + ", endpos: " + str(end), 8)

    while pos < end and pos != -1:  # Ignore too early </endstr> return
        tend = html.find(endstr, end + len(endstr))
        if tend != -1:
            end = tend
        pos = html.find("<" + name, pos + 1)
        log("loop: " + str(start) + " < " + str(end) + " pos = " + str(pos), 8)

    log("start: %s, len: %s, end: %s" % (start, len(match), end), 3)
    if start == -1 and end == -1:
        result = u""
    elif start > -1 and end > -1:
        result = html[start + len(match):end]
    elif end > -1:
        result = html[:end]
    elif start > -1:
        result = html[start + len(match):]

    if ret:
        endstr = html[end:html.find(">", html.find(endstr)) + 1]
        result = match + result + endstr

    log("done result length: " + str(len(result)), 3)
    return result

def _getDOMAttributes(match, name, ret):
    log("", 3)

    lst = re.compile('<' + name + '.*?' + ret + '=([\'"].[^>]*?[\'"])>', re.M | re.S).findall(match)
    if len(lst) == 0:
        lst = re.compile('<' + name + '.*?' + ret + '=(.[^>]*?)>', re.M | re.S).findall(match)
    ret = []
    for tmp in lst:
        cont_char = tmp[0]
        if cont_char in "'\"":
            log("Using %s as quotation mark" % cont_char, 3)

            # Limit down to next variable.
            if tmp.find('=' + cont_char, tmp.find(cont_char, 1)) > -1:
                tmp = tmp[:tmp.find('=' + cont_char, tmp.find(cont_char, 1))]

            # Limit to the last quotation mark
            if tmp.rfind(cont_char, 1) > -1:
                tmp = tmp[1:tmp.rfind(cont_char)]
        else:
            log("No quotation mark found", 3)
            if tmp.find(" ") > 0:
                tmp = tmp[:tmp.find(" ")]
            elif tmp.find("/") > 0:
                tmp = tmp[:tmp.find("/")]
            elif tmp.find(">") > 0:
                tmp = tmp[:tmp.find(">")]

        ret.append(tmp.strip())

    log("Done: " + repr(ret), 3)
    return ret

def _getDOMElements(item, name, attrs):
    log("", 3)

    lst = []
    for key in attrs:
        lst2 = re.compile('(<' + name + '[^>]*?(?:' + key + '=[\'"]' + attrs[key] + '[\'"].*?>))', re.M | re.S).findall(item)
        if len(lst2) == 0 and attrs[key].find(" ") == -1:  # Try matching without quotation marks
            lst2 = re.compile('(<' + name + '[^>]*?(?:' + key + '=' + attrs[key] + '.*?>))', re.M | re.S).findall(item)

        if len(lst) == 0:
            log("Setting main list " + repr(lst2), 5)
            lst = lst2
            lst2 = []
        else:
            log("Setting new list " + repr(lst2), 5)
            test = range(len(lst))
            test.reverse()
            for i in test:  # Delete anything missing from the next list.
                if not lst[i] in lst2:
                    log("Purging mismatch " + str(len(lst)) + " - " + repr(lst[i]), 3)
                    del(lst[i])

    if len(lst) == 0 and attrs == {}:
        log("No list found, trying to match on name only", 3)
        lst = re.compile('(<' + name + '>)', re.M | re.S).findall(item)
        if len(lst) == 0:
            lst = re.compile('(<' + name + ' .*?>)', re.M | re.S).findall(item)

    log("Done: " + str(type(lst)), 3)
    return lst

def parseDOM(html, name=u"", attrs={}, ret=False):
    log("Name: " + repr(name) + " - Attrs:" + repr(attrs) + " - Ret: " + repr(ret) + " - HTML: " + str(type(html)), 3)

    if isinstance(name, str): # Should be handled
        try:
            name = name #.decode("utf-8")
        except:
            log("Couldn't decode name binary string: " + repr(name))

    if isinstance(html, str):
        try:
            html = [html.decode("utf-8")] # Replace with chardet thingy
        except:
            log("Couldn't decode html binary string. Data length: " + repr(len(html)))
            html = [html]
    elif isinstance(html, unicode):
        html = [html]
    elif not isinstance(html, list):
        log("Input isn't list or string/unicode.")
        return u""

    if not name.strip():
        log("Missing tag name")
        return u""

    ret_lst = []
    for item in html:
        temp_item = re.compile('(<[^>]*?\n[^>]*?>)').findall(item)
        for match in temp_item:
            item = item.replace(match, match.replace("\n", " "))

        lst = _getDOMElements(item, name, attrs)

        if isinstance(ret, str):
            log("Getting attribute %s content for %s matches " % (ret, len(lst) ), 3)
            lst2 = []
            for match in lst:
                lst2 += _getDOMAttributes(match, name, ret)
            lst = lst2
        else:
            log("Getting element content for %s matches " % len(lst), 3)
            lst2 = []
            for match in lst:
                log("Getting element content for %s" % match, 4)
                temp = _getDOMContent(item, name, match, ret).strip()
                item = item[item.find(temp, item.find(match)) + len(temp):]
                lst2.append(temp)
            lst = lst2
        ret_lst += lst

    log("Done: " + repr(ret_lst), 3)
    return ret_lst


def extractJS(data, function=False, variable=False, match=False, evaluate=False, values=False):
    log("")
    scripts = parseDOM(data, "script")
    if len(scripts) == 0:
        log("Couldn't find any script tags. Assuming javascript file was given.")
        scripts = [data]

    lst = []
    log("Extracting", 4)
    for script in scripts:
        tmp_lst = []
        if function:
            tmp_lst = re.compile(function + '\(.*?\).*?;', re.M | re.S).findall(script)
        elif variable:
            tmp_lst = re.compile(variable.replace("[", "\[").replace("]", "\]") + '[ ]+=.*?;', re.M | re.S).findall(script)            
        else:
            tmp_lst = [script]
        if len(tmp_lst) > 0:
            log("Found: " + repr(tmp_lst), 4)
            lst += tmp_lst
        else:
            log("Found nothing on: " + script, 4)

    test = range(0, len(lst))
    test.reverse()
    for i in test:
        if match and lst[i].find(match) == -1:
            log("Removing item: " + repr(lst[i]), 10)
            del lst[i]
        else:
            log("Cleaning item: " + repr(lst[i]), 4)
            if lst[i][0] == u"\n":
                lst[i] == lst[i][1:]
            if lst[i][len(lst) -1] == u"\n":
                lst[i] == lst[i][:len(lst)- 2]
            lst[i] = lst[i].strip()

    if values or evaluate:
        for i in range(0, len(lst)):
            log("Getting values %s" % lst[i])
            if function:
                if evaluate: # include the ( ) for evaluation
                    data = re.compile("(\(.*?\))", re.M | re.S).findall(lst[i])
                else:
                    data = re.compile("\((.*?)\)", re.M | re.S).findall(lst[i])
            elif variable:
                tlst = re.compile(variable +".*?=.*?;", re.M | re.S).findall(lst[i])
                data = []
                for tmp in tlst: # This breaks for some stuff. "ad_tag": "http://ad-emea.doubleclick.net/N4061/pfadx/com.ytpwatch.entertainment/main_563326'' # ends early, must end with } 
                    cont_char = tmp[0]
                    cont_char = tmp[tmp.find("=") + 1:].strip()
                    cont_char = cont_char[0]
                    if cont_char in "'\"":
                        log("Using %s as quotation mark" % cont_char, 1)
                        tmp = tmp[tmp.find(cont_char) + 1:tmp.rfind(cont_char)]
                    else:
                        log("No quotation mark found", 1)
                        tmp = tmp[tmp.find("=") + 1: tmp.rfind(";")]

                    tmp = tmp.strip()
                    if len(tmp) > 0:
                        data.append(tmp)
            else:
                log("ERROR: Don't know what to extract values from")

            log("Values extracted: %s" % repr(data))
            if len(data) > 0:
                lst[i] = data[0]

    if evaluate:
        for i in range(0, len(lst)):
            log("Evaluating %s" % lst[i])
            data = lst[i].strip()
            try:
                try:
                    lst[i] = json.loads(data)
                except:
                    log("Couldn't json.loads, trying eval")
                    lst[i] = eval(data)
            except:
                log("Couldn't eval: %s from %s" % (repr(data), repr(lst[i])))

    log("Done: " + str(len(lst)))
    return lst

def fetchPage(params={}):
    get = params.get
    link = get("link")
    ret_obj = { "new_url": link}
    if get("post_data"):
        log("called for : " + repr(params['link']))
    else:
        log("called for : " + repr(params))

    if not link or int(get("error", "0")) > 2:
        log("giving up")
        ret_obj["status"] = 500
        return ret_obj

    if get("post_data"):
        if get("hide_post_data"):
            log("Posting data", 2)
        else:
            log("Posting data: " + urllib.urlencode(get("post_data")), 2)

        request = urllib2.Request(link, urllib.urlencode(get("post_data")))
        request.add_header('Content-Type', 'application/x-www-form-urlencoded')
    else:
        log("Got request", 2)
        request = urllib2.Request(link)

    if get("headers"):
        for head in get("headers"):
            request.add_header(head[0], head[1])

    request.add_header('User-Agent', USERAGENT)

    if get("cookie"):
        request.add_header('Cookie', get("cookie"))

    if get("refering"):
        log("Setting refering: " + get("refering"), 3)
        request.add_header('Referer', get("refering"))

    try:
        log("connecting to server...", 1)

        con = urllib2.urlopen(request)
        ret_obj["header"] = con.info().headers
        ret_obj["new_url"] = con.geturl()
        if get("no-content", "false") == u"false" or get("no-content", "false") == "false":
            inputdata = con.read()
            #data_type = chardet.detect(inputdata)
            #inputdata = inputdata.decode(data_type["encoding"])
            ret_obj["content"] = inputdata.decode("utf-8")

        con.close()

        log("Done")
        ret_obj["status"] = 200
        return ret_obj

    except urllib2.HTTPError, e:
        err = str(e)
        log("HTTPError : " + err)
        log("HTTPError - Headers: " + str(e.headers) + " - Content: " + e.fp.read())

        params["error"] = str(int(get("error", "0")) + 1)
        ret = fetchPage(params)

        if not "content" in ret and e.fp:
            ret["content"] = e.fp.read()
            return ret

        ret_obj["status"] = 500
        return ret_obj

    except urllib2.URLError, e:
        err = str(e)
        log("URLError : " + err)

        time.sleep(3)
        params["error"] = str(int(get("error", "0")) + 1)
        ret_obj = fetchPage(params)
        return ret_obj


def getCookieInfoAsHTML():
    log("", 5)
    if hasattr(sys.modules["__main__"], "cookiejar"):
        cookiejar = sys.modules["__main__"].cookiejar

        cookie = repr(cookiejar)
        cookie = cookie.replace("<_LWPCookieJar.LWPCookieJar[", "")
        cookie = cookie.replace("), Cookie(version=0,", "></cookie><cookie ")
        cookie = cookie.replace(")]>", "></cookie>")
        cookie = cookie.replace("Cookie(version=0,", "<cookie ")
        cookie = cookie.replace(", ", " ")
        log(repr(cookie), 5)
        return cookie

    log("Found no cookie", 5)
    return ""


# This function implements a horrible hack related to python 2.4's terrible unicode handling.
def makeAscii(data):
    log(repr(data), 5)
    #if sys.hexversion >= 0x02050000:
    #        return data

    try:
        return data.encode('ascii', "ignore")
    except:
        log("Hit except on : " + repr(data))
        s = u""
        for i in data:
            try:
                i.encode("ascii", "ignore")
            except:
                log("Can't convert character", 4)
                continue
            else:
                s += i

        log(repr(s), 5)
        return s


# This function handles stupid utf handling in python.
def makeUTF8(data):
    log(repr(data), 5)
    return data
    try:
        return data.decode('utf8', 'xmlcharrefreplace') # was 'ignore'
    except:
        log("Hit except on : " + repr(data))
        s = u""
        for i in data:
            try:
                i.decode("utf8", "xmlcharrefreplace") 
            except:
                log("Can't convert character", 4)
                continue
            else:
                s += i
        log(repr(s), 5)
        return s


def openFile(filepath, options=u"r"):
    log(repr(filepath) + " - " + repr(options))
    if options.find("b") == -1:  # Toggle binary mode on failure
        alternate = options + u"b"
    else:
        alternate = options.replace(u"b", u"")

    try:
        log("Trying normal: %s" % options)
        return io.open(filepath, options)
    except:
        log("Fallback to binary: %s" % alternate)
        return io.open(filepath, alternate)


def log(description, level=0):
    if dbg and dbglevel > level:
        try:
            xbmc.log((u"[%s] %s : '%s'" % (plugin, inspect.stack()[1][3], description)).decode("utf-8"), xbmc.LOGNOTICE)
        except:
            xbmc.log(u"FALLBACK [%s] %s : '%s'" % (plugin, inspect.stack()[1][3], repr(description)), xbmc.LOGNOTICE)

########NEW FILE########
__FILENAME__ = DialogDownloadProgress
import os
import sys
import re
from traceback import print_exc

if hasattr(sys.modules["__main__"], "xbmc"):
    xbmc = sys.modules["__main__"].xbmc
else:
    import xbmc

if hasattr(sys.modules["__main__"], "xbmcgui"):
    xbmcgui = sys.modules["__main__"].xbmcgui
else:
    import xbmcgui

if hasattr(sys.modules["__main__"], "xbmcaddon"):
    xbmcaddon = sys.modules["__main__"].xbmcaddon
else:
    import xbmcaddon

try:
    settings = xbmcaddon.Addon(id='script.module.simple.downloader')
except:
    if sys.modules["__main__"].settings:
        settings = sys.modules["__main__"].settings

addonDir = settings.getAddonInfo("path")
XBMC_SKIN  = xbmc.getSkinDir()


class xbmcguiWindowError(Exception):
    def __init__(self, winError=None):
        Exception.__init__(self, winError)

        
class Control:
    def __init__(self, control, ctype, coords=(0, 0), anim=[], **kwargs):
        self.SKINS_PATH = os.path.join(addonDir, "resources", "skins")
        self.ADDON_SKIN = ("default", XBMC_SKIN)[os.path.exists(os.path.join(self.SKINS_PATH, XBMC_SKIN))]
        self.MEDIA_PATH = os.path.join(self.SKINS_PATH, self.ADDON_SKIN, "media")

        self.controlXML = control # from self.getControl(2001)
        self.id = self.controlXML.getId()
        self.label = xbmc.getInfoLabel("Control.GetLabel(%i)" % self.id)
        self.anim = anim

        try: extra = dict([k.split("=") for k in self.label.split(",")])
        except: extra = {}
        option = {}
        x, y, w, h = self.getCoords(coords)
        # HERE!
        print "BLAAAAAAAAAAAAAAAAAAAAAAAAAAA self.controlXML: " + repr(type(self.controlXML))
        print "BLAAAAAAAAAAAAAAAAAAAAAAAAAAA self.controlXML: " + repr(self.controlXML)
        print "BLAAAAAAAAAAAAAAAAAAAAAAAAAAA xbmcgui.ControlImage: " + repr(xbmcgui.ControlImage)
        print "BLAAAAAAAAAAAAAAAAAAAAAAAAAAA xbmcgui.ControlLabel: " + repr(xbmcgui.ControlLabel)
        print "BLAAAAAAAAAAAAAAAAAAAAAAAAAAA xbmcgui.ControlProgress: " + repr(xbmcgui.ControlProgress)
        if type(self.controlXML) == xbmcgui.ControlImage or ctype == 0:
            # http://passion-xbmc.org/gros_fichiers/XBMC%20Python%20Doc/xbmc_svn/xbmcgui.html#ControlImage
            texture = self.label
            valideOption = "colorKey, aspectRatio, colorDiffuse".split(", ")
            for key, value in extra.items():
                key, value = key.strip(), value.strip()
                if key == "texture": texture = value
                if key not in valideOption: continue
                option[key] = value
                if "color" in key.lower():
                    option[key] = '0x' + value
                elif key == "aspectRatio" and value.isdigit():
                    option[key] = int(value)
                texture = self.getTexture(texture)
            # ControlImage(x, y, width, height, filename[, colorKey, aspectRatio, colorDiffuse])
            self.control = xbmcgui.ControlImage(x, y, w, h, texture, **option)

        elif type(self.controlXML) == xbmcgui.ControlLabel or ctype == 1:
            # http://passion-xbmc.org/gros_fichiers/XBMC%20Python%20Doc/xbmc_svn/xbmcgui.html#ControlLabel
            valideOption = "font, textColor, disabledColor, alignment, hasPath, angle".split(", ")
            for key, value in extra.items():
                key, value = key.strip(), value.strip()
                if key not in valideOption: continue
                option[key] = value
                if "color" in key.lower():
                    option[key] = '0x' + value
                elif key == "alignment":
                    option[key] = self.getAlignment(value)
                elif key == "hasPath" and value == "true":
                    option[key] = True
                elif key == "angle" and value.isdigit():
                    option[key] = int(value)
            # ControlLabel(x, y, width, height, label[, font, textColor, disabledColor, alignment, hasPath, angle])
            self.control = xbmcgui.ControlLabel(x, y, w, h, "", **option)

        elif type(self.controlXML) == xbmcgui.ControlProgress or ctype == 2:
            # http://passion-xbmc.org/gros_fichiers/XBMC%20Python%20Doc/xbmc_svn/xbmcgui.html#ControlProgress
            valideOption = "texturebg, textureleft, texturemid, textureright, textureoverlay".split(", ")
            for key, value in kwargs.items():
                key, value = key.strip(), value.strip()
                if key not in valideOption: continue
                option[key] = self.getTexture(value)
            # ControlProgress(x, y, width, height[, texturebg, textureleft, texturemid, textureright, textureoverlay])
            self.control = xbmcgui.ControlProgress(x, y, w, h, **option)
        else:
            print "ERROR TRACEBACK BLAA. no match for self.controlXML: " + repr(self.controlXML)

    def getTexture(self, texture):
        if not xbmc.skinHasImage(texture):
            if os.path.isfile(os.path.join(self.MEDIA_PATH, texture)):
                texture = os.path.join(self.MEDIA_PATH, texture)
            else:
                texture = ""
        return texture

    def getCoords(self, default):
        x, y = self.controlXML.getPosition()
        w, h = self.controlXML.getWidth(), self.controlXML.getHeight()
        return (default[0] + x, default[1] + y, w, h)

    def getAlignment(self, alignment):
        xbfont = {
            "left": 0x00000000,
            "right": 0x00000001,
            "centerx": 0x00000002,
            "centery": 0x00000004,
            "truncated": 0x00000008
            }
        align = xbfont["left"]
        for a in alignment.split("+"):
            align += xbfont.get(a, xbfont["left"])
        return align

    def setAnimations(self):
        if self.anim and settings.getSetting("animation") == "true":
            try: self.control.setAnimations(self.anim)
            except: print_exc()

    def addControl(self, window):
        window.addControl(self.control)
        self.control.setVisibleCondition("[SubString(Window.Property(DialogDownloadProgress.Hide),false) | SubString(Window.Property(DialogDownloadProgress.Hide),)]")
        self.setAnimations()
        return self.control


class DialogDownloadProgressXML(xbmcgui.WindowXMLDialog):
    def __init__(self, *args, **kwargs):
        xbmcgui.WindowXMLDialog.__init__(self, *args, **kwargs)
        self.doModal()

    def onInit(self):
        self.controls = {}
        try:
            self.getControls()
        except:
            print_exc()
        self.close()

    def getControls(self):
        coordinates = self.getControl(2000).getPosition()

        c_anim = []
        try:
            for anim in re.findall("(\[.*?\])", xbmc.getInfoLabel("Control.GetLabel(1999)"), re.S):
                try: c_anim.append(tuple(eval(anim)))
                except: pass
        except:
            print_exc()

        self.controls["background"] = Control(self.getControl(2001), 0, coordinates, c_anim)

        self.controls["heading"] = Control(self.getControl(2002), 1, coordinates, c_anim)

        self.controls["label"] = Control(self.getControl(2003), 1, coordinates, c_anim)

        try:
            v = xbmc.getInfoLabel("Control.GetLabel(2045)").replace(", ", ",")
            progressTextures = dict([k.split("=") for k in v.split(",")])
        except:
            progressTextures = {}

        self.controls["progress"] = Control(self.getControl(2004), 2, coordinates, c_anim, **progressTextures)

    def onFocus(self, controlID):
        pass

    def onClick(self, controlID):
        pass

    def onAction(self, action):
        pass


class Window:
    def __init__(self, parent_win=None, **kwargs):
        if xbmc.getInfoLabel("Window.Property(DialogDownloadProgress.IsAlive)") == "true":
            raise xbmcguiWindowError("DialogDownloadProgress IsAlive: Not possible to overscan!")

        self.SKINS_PATH = os.path.join(addonDir, "resources", "skins")
        self.ADDON_SKIN = ("default", XBMC_SKIN)[os.path.exists(os.path.join(self.SKINS_PATH, XBMC_SKIN))]

        windowXml = DialogDownloadProgressXML("DialogDownloadProgress.xml", addonDir, self.ADDON_SKIN)
        #windowXml = DialogDownloadProgressXML("DialogProgress.xml", addonDir, self.ADDON_SKIN)
        self.controls = windowXml.controls
        del windowXml

        self.window   = parent_win
        self.windowId = parent_win

        self.background = None
        self.heading	= None
        self.label	  = None
        self.progress   = None

    def setupWindow(self):
        error = 0
        # get the id for the current 'active' window as an integer.
        # http://wiki.xbmc.org/index.php?title=Window_IDs
        try: currentWindowId = xbmcgui.getCurrentWindowId()
        except: currentWindowId = self.window

        if hasattr(currentWindowId, "__int__") and currentWindowId != self.windowId:
            self.removeControls()
            self.windowId = currentWindowId
            self.window = xbmcgui.Window(self.windowId)
            self.initialize()

        if not self.window or not hasattr(self.window, "addControl"):
            self.removeControls()
            error = 1
        if error:
            raise xbmcguiWindowError("xbmcgui.Window(%s)" % repr(currentWindowId))

        #self.window.setProperty("DialogDownloadProgress.IsAlive", "true")

    def initialize(self):
        try:
            # BACKGROUND
            self.background = self.controls["background"].addControl(self.window)
        except:
            print_exc()

        try:
            # HEADING
            self.heading = self.controls["heading"].addControl(self.window)
            self.heading.setLabel(self.header)
        except:
            print_exc()

        try:
            # LABEL
            self.label = self.controls["label"].addControl(self.window)
            self.label.setLabel(self.line)
        except:
            print_exc()

        try:
            # CURRENT PROGRESS
            self.progress = self.controls["progress"].addControl(self.window)
        except:
            print_exc()

    def removeControls(self):
        if hasattr(self.window, "removeControl"):
            if self.progress:
                try: self.window.removeControl(self.progress)
                except: pass
            if self.label:
                try: self.window.removeControl(self.label)
                except: pass
            if self.heading:
                try: self.window.removeControl(self.heading)
                except: pass
            if self.background:
                try: self.window.removeControl(self.background)
                except: pass

            if hasattr(self.window, "clearProperty"):
                self.window.clearProperty("DialogDownloadProgress.Hide")
                self.window.clearProperty("DialogDownloadProgress.Cancel")
                self.window.clearProperty("DialogDownloadProgress.IsAlive")


class DownloadProgress(Window):
    def __init__(self, parent_win=None, **kwargs):
        # get class Window object
        Window.__init__(self, parent_win, **kwargs)
        self.canceled = False
        self.header = ""
        self.line = ""

    def close(self):
        self.canceled = True
        xbmc.sleep(100)
        self.removeControls()
        del self.controls
        del self.window

    def create(self, heading="Download Progress", label=""):
        self.header = heading
        self.line   = label
        self.update(0.1, heading, label)

    def iscanceled(self):
        return self.canceled

    def update(self, percent=0, heading="", label=""):
        self.setupWindow()
        if heading and hasattr(self.heading, "setLabel"):
            # set heading
            try: self.heading.setLabel(heading)
            except: print_exc()
        if label and hasattr(self.label, "setLabel"):
            # set label
            self.line = label
            try: self.label.setLabel(label)
            except: print_exc()
        if percent and hasattr(self.progress, "setPercent"):
            # set progress of listing
            try: self.progress.setPercent(percent)
            except: print_exc()

########NEW FILE########
__FILENAME__ = IntegrationTestSuite
import nose

if __name__ == "__main__":
    nose.run()

########NEW FILE########
__FILENAME__ = mock
# mock.py
# Test tools for mocking and patching.
# Copyright (C) 2007-2011 Michael Foord & the mock team
# E-mail: fuzzyman AT voidspace DOT org DOT uk

# mock 0.8.0
# http://www.voidspace.org.uk/python/mock/

# Released subject to the BSD License
# Please see http://www.voidspace.org.uk/python/license.shtml

# Scripts maintained at http://www.voidspace.org.uk/python/index.shtml
# Comments, suggestions and bug reports welcome.


__all__ = (
    'Mock',
    'MagicMock',
    'mocksignature',
    'patch',
    'sentinel',
    'DEFAULT',
    'ANY',
    'call',
    'create_autospec',
    'FILTER_DIR',
    'NonCallableMock',
    'NonCallableMagicMock',
)


__version__ = '0.8.0beta3'


import pprint
import sys

try:
    import inspect
except ImportError:
    # for alternative platforms that
    # may not have inspect
    inspect = None


try:
    from functools import wraps
except ImportError:
    # Python 2.4 compatibility
    def wraps(original):
        def inner(f):
            f.__name__ = original.__name__
            f.__doc__ = original.__doc__
            f.__module__ = original.__module__
            return f
        return inner

try:
    unicode
except NameError:
    # Python 3
    basestring = unicode = str

try:
    long
except NameError:
    # Python 3
    long = int

try:
    BaseException
except NameError:
    # Python 2.4 compatibility
    BaseException = Exception

try:
    next
except NameError:
    def next(obj):
        return obj.next()


BaseExceptions = (BaseException,)
if 'java' in sys.platform:
    # jython
    import java
    BaseExceptions = (BaseException, java.lang.Throwable)

try:
    _isidentifier = str.isidentifier
except AttributeError:
    # Python 2.X
    import keyword
    import re
    regex = re.compile(r'^[a-z_][a-z0-9_]*$', re.I)
    def _isidentifier(string):
        if string in keyword.kwlist:
            return False
        return regex.match(string)


inPy3k = sys.version_info[0] == 3

# Needed to work around Python 3 bug where use of "super" interferes with
# defining __class__ as a descriptor
_super = super

self = 'im_self'
builtin = '__builtin__'
if inPy3k:
    self = '__self__'
    builtin = 'builtins'

FILTER_DIR = True


def _is_instance_mock(obj):
    # can't use isinstance on Mock objects because they override __class__
    # The base class for all mocks is NonCallableMock
    return issubclass(type(obj), NonCallableMock)


def _is_exception(obj):
    return (
        isinstance(obj, BaseExceptions) or
        isinstance(obj, ClassTypes) and issubclass(obj, BaseExceptions)
    )


class _slotted(object):
    __slots__ = ['a']


DescriptorTypes = (
    type(_slotted.a),
    property,
)


# getsignature and mocksignature heavily "inspired" by
# the decorator module: http://pypi.python.org/pypi/decorator/
# by Michele Simionato

def _getsignature(func, skipfirst):
    if inspect is None:
        raise ImportError('inspect module not available')

    if inspect.isclass(func):
        func = func.__init__
        # will have a self arg
        skipfirst = True
    elif not (inspect.ismethod(func) or inspect.isfunction(func)):
        func = func.__call__

    regargs, varargs, varkwargs, defaults = inspect.getargspec(func)

    # instance methods need to lose the self argument
    if getattr(func, self, None) is not None:
        regargs = regargs[1:]

    _msg = "_mock_ is a reserved argument name, can't mock signatures using _mock_"
    assert '_mock_' not in regargs, _msg
    if varargs is not None:
        assert '_mock_' not in varargs, _msg
    if varkwargs is not None:
        assert '_mock_' not in varkwargs, _msg
    if skipfirst:
        regargs = regargs[1:]

    signature = inspect.formatargspec(regargs, varargs, varkwargs, defaults,
                                      formatvalue=lambda value: "")
    return signature[1:-1], func


def _getsignature2(func, skipfirst):
    if inspect is None:
        raise ImportError('inspect module not available')

    if isinstance(func, ClassTypes):
        try:
            func = func.__init__
        except AttributeError:
            return
        skipfirst = True
    elif not isinstance(func, FunctionTypes):
        func = func.__call__

    try:
        regargs, varargs, varkwargs, defaults = inspect.getargspec(func)
    except TypeError:
        # C function / method, possibly inherited object().__init__
        return

    # instance methods and classmethods need to lose the self argument
    if getattr(func, self, None) is not None:
        regargs = regargs[1:]
    if skipfirst:
        # this condition and the above one are never both True - why?
        regargs = regargs[1:]

    signature = inspect.formatargspec(regargs, varargs, varkwargs, defaults,
                                      formatvalue=lambda value: "")
    return signature[1:-1], func


def _check_signature(func, mock, skipfirst):
    if not _callable(func):
        return

    result = _getsignature2(func, skipfirst)
    if result is None:
        return
    signature, func = result

    # can't use self because "self" is common as an argument name
    # unfortunately even not in the first place
    src = "lambda _mock_self, %s: None" % signature
    checksig = eval(src, {})
    _copy_func_details(func, checksig)
    type(mock)._mock_check_sig = checksig


def _copy_func_details(func, funcopy):
    funcopy.__name__ = func.__name__
    funcopy.__doc__ = func.__doc__
    #funcopy.__dict__.update(func.__dict__)
    funcopy.__module__ = func.__module__
    if not inPy3k:
        funcopy.func_defaults = func.func_defaults
        return
    funcopy.__defaults__ = func.__defaults__
    funcopy.__kwdefaults__ = func.__kwdefaults__


def _callable(obj):
    if isinstance(obj, ClassTypes):
        return True
    if getattr(obj, '__call__', None) is not None:
        return True
    return False


def _is_list(obj):
    # checks for list or tuples
    # XXXX badly named!
    return type(obj) in (list, tuple)


def _instance_callable(obj):
    """Given an object, return True if the object is callable.
    For classes, return True if instances would be callable."""
    if not isinstance(obj, ClassTypes):
        # already an instance
        return hasattr(obj, '__call__')

    klass = obj
    # uses __bases__ instead of __mro__ so that we work with old style classes
    if '__call__' in klass.__dict__:
        return True
    for base in klass.__bases__:
        if _instance_callable(base):
            return True
    return False


def _set_signature(mock, original):
    # creates a function with signature (*args, **kwargs) that delegates to a
    # mock. It still does signature checking by calling a lambda with the same
    # signature as the original. This is effectively mocksignature2.
    if not _callable(original):
        return

    skipfirst = isinstance(original, ClassTypes)
    result = _getsignature2(original, skipfirst)
    if result is None:
        # was a C function (e.g. object().__init__ ) that can't be mocked
        return

    signature, func = result

    src = "lambda %s: None" % signature
    context = {'_mock_': mock}
    checksig = eval(src, context)
    _copy_func_details(func, checksig)

    name = original.__name__
    if not _isidentifier(name):
        name = 'funcopy'
    context = {'checksig': checksig, 'mock': mock}
    src = """def %s(*args, **kwargs):
    checksig(*args, **kwargs)
    return mock(*args, **kwargs)""" % name
    exec (src, context)
    funcopy = context[name]
    _setup_func(funcopy, mock)
    return funcopy


def mocksignature(func, mock=None, skipfirst=False):
    """
    mocksignature(func, mock=None, skipfirst=False)

    Create a new function with the same signature as `func` that delegates
    to `mock`. If `skipfirst` is True the first argument is skipped, useful
    for methods where `self` needs to be omitted from the new function.

    If you don't pass in a `mock` then one will be created for you.

    The mock is set as the `mock` attribute of the returned function for easy
    access.

    `mocksignature` can also be used with classes. It copies the signature of
    the `__init__` method.

    When used with callable objects (instances) it copies the signature of the
    `__call__` method.
    """
    if mock is None:
        mock = Mock()
    signature, func = _getsignature(func, skipfirst)
    src = "lambda %(signature)s: _mock_(%(signature)s)" % {
        'signature': signature
    }

    funcopy = eval(src, dict(_mock_=mock))
    _copy_func_details(func, funcopy)
    _setup_func(funcopy, mock)
    return funcopy


def _setup_func(funcopy, mock):
    funcopy.mock = mock

    # can't use isinstance with mocks
    if not _is_instance_mock(mock):
        return

    def assert_called_with(*args, **kwargs):
        return mock.assert_called_with(*args, **kwargs)
    def assert_called_once_with(*args, **kwargs):
        return mock.assert_called_once_with(*args, **kwargs)
    def assert_has_calls(*args, **kwargs):
        return mock.assert_has_calls(*args, **kwargs)
    def assert_any_call(*args, **kwargs):
        return mock.assert_any_call(*args, **kwargs)
    def reset_mock():
        funcopy.method_calls = _CallList()
        funcopy.mock_calls = _CallList()
        mock.reset_mock()
        ret = funcopy.return_value
        if _is_instance_mock(ret) and not ret is mock:
            ret.reset_mock()

    funcopy.called = False
    funcopy.call_count = 0
    funcopy.call_args = None
    funcopy.call_args_list = _CallList()
    funcopy.method_calls = _CallList()
    funcopy.mock_calls = _CallList()

    funcopy.return_value = mock.return_value
    funcopy.side_effect = mock.side_effect
    funcopy._mock_children = mock._mock_children

    funcopy.assert_called_with = assert_called_with
    funcopy.assert_called_once_with = assert_called_once_with
    funcopy.assert_has_calls = assert_has_calls
    funcopy.assert_any_call = assert_any_call
    funcopy.reset_mock = reset_mock

    mock._mock_signature = funcopy


def _is_magic(name):
    return '__%s__' % name[2:-2] == name


class SentinelObject(object):
    "A unique, named, sentinel object."
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return '<SentinelObject "%s">' % self.name


class Sentinel(object):
    """Access attributes to return a named object, usable as a sentinel."""
    def __init__(self):
        self._sentinels = {}

    def __getattr__(self, name):
        if name == '__bases__':
            # Without this help(mock) raises an exception
            raise AttributeError
        return self._sentinels.setdefault(name, SentinelObject(name))


sentinel = Sentinel()

DEFAULT = sentinel.DEFAULT


class OldStyleClass:
    pass
ClassType = type(OldStyleClass)


def _copy(value):
    if type(value) in (dict, list, tuple, set):
        return type(value)(value)
    return value


ClassTypes = (type,)
if not inPy3k:
    ClassTypes = (type, ClassType)

_allowed_names = set(
    [
        'return_value', '_mock_return_value', 'side_effect',
        '_mock_side_effect', '_mock_parent', '_mock_new_parent',
        '_mock_name', '_mock_new_name'
    ]
)


def _mock_signature_property(name):
    _allowed_names.add(name)
    def _get(self):
        sig = self._mock_signature
        if sig is None:
            return getattr(self, '_mock_' + name)
        return getattr(sig, name)
    def _set(self, value):
        sig = self._mock_signature
        if sig is None:
            setattr(self, '_mock_' + name, value)
        else:
            setattr(sig, name, value)

    return property(_get, _set)



class _CallList(list):

    def __contains__(self, value):
        if not isinstance(value, list):
            return list.__contains__(self, value)
        len_value = len(value)
        len_self = len(self)
        if len_value > len_self:
            return False

        for i in range(0, len_self - len_value + 1):
            sub_list = self[i:i+len_value]
            if sub_list == value:
                return True
        return False

    def __repr__(self):
        return pprint.pformat(list(self))


def _check_and_set_parent(parent, value, name, new_name):
    if not _is_instance_mock(value):
        return False
    if (value._mock_name or value._mock_new_name or
        value._mock_parent or value._mock_new_parent):
        return False

    if new_name:
        value._mock_new_parent = parent
        value._mock_new_name = new_name
    if name:
        value._mock_parent = parent
        value._mock_name = name
    return True



class Base(object):
    _mock_return_value = DEFAULT
    _mock_side_effect = None
    def __init__(self, *args, **kwargs):
        pass



class NonCallableMock(Base):
    """A non-callable version of `Mock`"""

    def __new__(cls, *args, **kw):
        # every instance has its own class
        # so we can create magic methods on the
        # class without stomping on other mocks
        new = type(cls.__name__, (cls,), {'__doc__': cls.__doc__})
        return object.__new__(new)


    def __init__(
            self, spec=None, wraps=None, name=None, spec_set=None,
            parent=None, _spec_state=None, _new_name='', _new_parent=None,
            **kwargs
        ):
        if _new_parent is None:
            _new_parent = parent

        self._mock_parent = parent
        self._mock_name = name
        self._mock_new_name = _new_name
        self._mock_new_parent = _new_parent

        if spec_set is not None:
            spec = spec_set
            spec_set = True
        self._mock_add_spec(spec, spec_set)

        self._mock_children = {}
        self._mock_wraps = wraps
        self._mock_signature = None

        self._mock_called = False
        self._mock_call_args = None
        self._mock_call_count = 0
        self._mock_call_args_list = _CallList()
        self._mock_mock_calls = _CallList()

        self.reset_mock()
        self.configure_mock(**kwargs)

        _super(NonCallableMock, self).__init__(
            spec, wraps, name, spec_set, parent,
            _spec_state, **kwargs
        )


    def mock_add_spec(self, spec, spec_set=False):
        """Add a spec to a mock. `spec` can either be an object or a
        list of strings. Only attributes on the `spec` can be fetched as
        attributes from the mock.

        If `spec_set` is True then only attributes on the spec can be set."""
        self._mock_add_spec(spec, spec_set)


    def _mock_add_spec(self, spec, spec_set):
        _spec_class = None

        if spec is not None and not _is_list(spec):
            if isinstance(spec, ClassTypes):
                _spec_class = spec
            else:
                _spec_class = _get_class(spec)

            spec = dir(spec)

        self._spec_class = _spec_class
        self._spec_set = spec_set
        self._mock_methods = spec


    def __get_return_value(self):
        ret = self._mock_return_value
        if self._mock_signature is not None:
            ret = self._mock_signature.return_value

        if ret is DEFAULT:
            ret = self._get_child_mock(
                _new_parent=self, _new_name='()'
            )
            self.return_value = ret
        return ret


    def __set_return_value(self, value):
        if self._mock_signature is not None:
            self._mock_signature.return_value = value
        else:
            self._mock_return_value = value
            _check_and_set_parent(self, value, None, '()')

    __return_value_doc = "The value to be returned when the mock is called."
    return_value = property(__get_return_value, __set_return_value,
                            __return_value_doc)


    @property
    def __class__(self):
        if self._spec_class is None:
            return type(self)
        return self._spec_class

    called = _mock_signature_property('called')
    call_count = _mock_signature_property('call_count')
    call_args = _mock_signature_property('call_args')
    call_args_list = _mock_signature_property('call_args_list')
    mock_calls = _mock_signature_property('mock_calls')


    def __get_side_effect(self):
        sig = self._mock_signature
        if sig is None:
            return self._mock_side_effect
        return sig.side_effect

    def __set_side_effect(self, value):
        value = _try_iter(value)
        sig = self._mock_signature
        if sig is None:
            self._mock_side_effect = value
        else:
            sig.side_effect = value

    side_effect = property(__get_side_effect, __set_side_effect)


    def reset_mock(self):
        "Restore the mock object to its initial state."
        self.called = False
        self.call_args = None
        self.call_count = 0
        self.mock_calls = _CallList()
        self.call_args_list = _CallList()
        self.method_calls = _CallList()

        for child in self._mock_children.values():
            child.reset_mock()

        ret = self._mock_return_value
        if _is_instance_mock(ret) and ret is not self:
            ret.reset_mock()


    def configure_mock(self, **kwargs):
        """XXX needs docstring"""
        for arg, val in sorted(kwargs.items(),
                               # we sort on the number of dots so that
                               # attributes are set before we set attributes on
                               # attributes
                               key=lambda entry: entry[0].count('.')):
            args = arg.split('.')
            final = args.pop()
            obj = self
            for entry in args:
                obj = getattr(obj, entry)
            setattr(obj, final, val)


    def __getattr__(self, name):
        if name == '_mock_methods':
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
            raise AttributeError(name)

        result = self._mock_children.get(name)
        if result is None:
            wraps = None
            if self._mock_wraps is not None:
                # XXXX should we get the attribute without triggering code
                # execution?
                wraps = getattr(self._mock_wraps, name)

            result = self._get_child_mock(
                parent=self, name=name, wraps=wraps, _new_name=name,
                _new_parent=self
            )
            self._mock_children[name]  = result

        elif isinstance(result, _SpecState):
            result = create_autospec(
                result.spec, result.spec_set, result.instance,
                None, result.parent, result.name
            )
            self._mock_children[name]  = result

        return result


    def __repr__(self):
        _name_list = [self._mock_new_name]
        _parent = self._mock_new_parent
        last = self

        dot = '.'
        if _name_list == ['()']:
            dot = ''
        while _parent is not None:
            last = _parent

            _name_list.append(_parent._mock_new_name + dot)
            dot = '.'
            if _parent._mock_new_name == '()':
                dot = ''

            _parent = _parent._mock_new_parent

        _name_list = list(reversed(_name_list))
        _first = last._mock_name or 'mock'
        if len(_name_list) > 1:
            if _name_list[1] not in ('()', '().'):
                _first += '.'
        _name_list[0] = _first
        name = ''.join(_name_list)

        name_string = ''
        if name not in ('mock', 'mock.'):
            name_string = ' name=%r' % name

        spec_string = ''
        if self._spec_class is not None:
            spec_string = ' spec=%r'
            if self._spec_set:
                spec_string = ' spec_set=%r'
            spec_string = spec_string % self._spec_class.__name__
        return "<%s%s%s id='%s'>" % (
            type(self).__name__,
            name_string,
            spec_string,
            id(self)
        )


    def __dir__(self):
        extras = self._mock_methods or []
        from_type = dir(type(self))
        from_dict = list(self.__dict__)

        if FILTER_DIR:
            from_type = [e for e in from_type if not e.startswith('_')]
            from_dict = [e for e in from_dict if not e.startswith('_') or
                         _is_magic(e)]
        return sorted(set(extras + from_type + from_dict +
                          list(self._mock_children)))


    def __setattr__(self, name, value):
        if not 'method_calls' in self.__dict__:
            # allow all attribute setting until initialisation is complete
            return object.__setattr__(self, name, value)

        if (self._spec_set and self._mock_methods is not None and
            name not in self._mock_methods and
            name not in self.__dict__ and
            name not in _allowed_names):
            raise AttributeError("Mock object has no attribute '%s'" % name)
        elif name in _unsupported_magics:
            msg = 'Attempting to set unsupported magic method %r.' % name
            raise AttributeError(msg)
        elif name in _all_magics:
            if self._mock_methods is not None and name not in self._mock_methods:
                raise AttributeError("Mock object has no attribute '%s'" % name)

            if isinstance(value, MagicProxy):
                setattr(type(self), name, value)
                return

            if not _is_instance_mock(value):
                setattr(type(self), name, _get_method(name, value))
                original = value
                real = lambda *args, **kw: original(self, *args, **kw)
                value = mocksignature(value, real, skipfirst=True)
            else:
                setattr(type(self), name, value)
        elif name in _allowed_names:
            pass
        elif _check_and_set_parent(self, value, name, name):
            self._mock_children[name] = value
            return
        return object.__setattr__(self, name, value)


    def __delattr__(self, name):
        if name in _all_magics and name in type(self).__dict__:
            delattr(type(self), name)
            if name not in self.__dict__:
                # for magic methods that are still MagicProxy objects and
                # not set on the instance itself
                return
        return object.__delattr__(self, name)


    def _format_mock_call_signature(self, args, kwargs):
        name = self._mock_name or 'mock'
        return _format_call_signature(name, args, kwargs)


    def _format_mock_failure_message(self, args, kwargs):
        message = 'Expected call: %s\nActual call: %s'
        expected_string = self._format_mock_call_signature(args, kwargs)
        call_args = self.call_args
        if len(call_args) == 3:
            call_args = call_args[1:]
        actual_string = self._format_mock_call_signature(*call_args)
        return message % (expected_string, actual_string)


    def assert_called_with(_mock_self, *args, **kwargs):
        """assert that the mock was called with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        self = _mock_self
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            raise AssertionError('Expected call: %s\nNot called' % (expected,))

        if self.call_args != (args, kwargs):
            msg = self._format_mock_failure_message(args, kwargs)
            raise AssertionError(msg)


    def assert_called_once_with(_mock_self, *args, **kwargs):
        """assert that the mock was called exactly once and with the specified
        arguments."""
        self = _mock_self
        if not self.call_count == 1:
            msg = ("Expected to be called once. Called %s times." %
                   self.call_count)
            raise AssertionError(msg)
        return self.assert_called_with(*args, **kwargs)


    def assert_has_calls(self, calls, any_order=False):
        """assert the mock has been called with the specified calls.
        The `mock_calls` list is checked for the calls.

        If `any_order` is False (the default) then the calls must be
        sequentially. There can be extra calls before or after the
        specified calls.

        If `any_order` is True then the calls can be in any order, but
        they must all appear in `mock_calls`."""
        if not any_order:
            if calls not in self.mock_calls:
                raise AssertionError(
                    'Calls not found.\nExpected: %r\n'
                    'Actual: %r' % (calls, self.mock_calls)
                )
            return

        all_calls = list(self.mock_calls)

        not_found = []
        for kall in calls:
            try:
                all_calls.remove(kall)
            except ValueError:
                not_found.append(kall)
        if not_found:
            raise AssertionError(
                '%r not all found in call list' % (tuple(not_found),)
            )


    def assert_any_call(self, *args, **kwargs):
        """assert the mock has been called with the specified arguments.

        The assert passes if the mock has *ever* been called, unlike
        `assert_called_with` and `assert_called_once_with` that only pass if
        the call is the most recent one."""
        kall = call(*args, **kwargs)
        if not kall in self.call_args_list:
            expected_string = self._format_mock_call_signature(args, kwargs)
            raise AssertionError(
                '%s call not found' % expected_string
            )

    def _get_child_mock(self, **kw):
        """Create the child mocks for attributes and return value.
        By default child mocks will be the same type as the parent.
        Subclasses of Mock may want to override this to customize the way
        child mocks are made."""
        _type = type(self)
        if not issubclass(_type, CallableMixin):
            if issubclass(_type, NonCallableMagicMock):
                klass = MagicMock
            elif issubclass(_type, NonCallableMock) :
                klass = Mock
        else:
            klass = _type.__mro__[1]
        return klass(**kw)



def _try_iter(obj):
    if obj is None:
        return obj
    if _is_exception(obj):
        return obj
    if _callable(obj):
        return obj
    try:
        return iter(obj)
    except TypeError:
        # XXXX backwards compatibility
        # but this will blow up on first call - so maybe we should fail early?
        return obj



class CallableMixin(Base):

    def __init__(self, spec=None, side_effect=None, return_value=DEFAULT,
                 wraps=None, name=None, spec_set=None, parent=None,
                 _spec_state=None, _new_name='', _new_parent=None, **kwargs):
        self._mock_return_value = return_value

        _super(CallableMixin, self).__init__(
            spec, wraps, name, spec_set, parent,
            _spec_state, _new_name, _new_parent, **kwargs
        )

        self.side_effect = side_effect




    def _mock_check_sig(self, *args, **kwargs):
        # stub method that can be replaced with one with a specific signature
        pass


    def __call__(_mock_self, *args, **kwargs):
        # can't use self in-case a function / method we are mocking uses self
        # in the signature
        _mock_self._mock_check_sig(*args, **kwargs)
        return _mock_self._mock_call(*args, **kwargs)


    def _mock_call(_mock_self, *args, **kwargs):
        self = _mock_self
        self.called = True
        self.call_count += 1
        self.call_args = _Call((args, kwargs), two=True)
        self.call_args_list.append(_Call((args, kwargs), two=True))

        _new_name = self._mock_new_name
        _new_parent = self._mock_new_parent
        self.mock_calls.append(_Call(('', args, kwargs)))

        skip_next_dot = _new_name == '()'
        while _new_parent is not None:
            this_call = _Call((_new_name, args, kwargs))
            if _new_parent._mock_new_name:
                dot = '.'
                if skip_next_dot:
                    dot = ''

                skip_next_dot = False
                if _new_parent._mock_new_name == '()':
                    skip_next_dot = True

                _new_name = _new_parent._mock_new_name + dot + _new_name

            _new_parent.mock_calls.append(this_call)
            _new_parent = _new_parent._mock_new_parent

        parent = self._mock_parent
        name = self._mock_name
        while parent is not None:
            parent.method_calls.append(_Call((name, args, kwargs)))
            if parent._mock_parent is None:
                break
            name = parent._mock_name + '.' + name
            parent = parent._mock_parent

        ret_val = DEFAULT
        if self.side_effect is not None:
            if _is_exception(self.side_effect):
                raise self.side_effect

            if not _callable(self.side_effect):
                return next(self.side_effect)

            ret_val = self.side_effect(*args, **kwargs)
            if ret_val is DEFAULT:
                ret_val = self.return_value

        if (self._mock_wraps is not None and
             self._mock_return_value is DEFAULT):
            return self._mock_wraps(*args, **kwargs)
        if ret_val is DEFAULT:
            ret_val = self.return_value
        return ret_val



class Mock(CallableMixin, NonCallableMock):
    """
    Create a new `Mock` object. `Mock` takes several optional arguments
    that specify the behaviour of the Mock object:

    * `spec`: This can be either a list of strings or an existing object (a
      class or instance) that acts as the specification for the mock object. If
      you pass in an object then a list of strings is formed by calling dir on
      the object (excluding unsupported magic attributes and methods). Accessing
      any attribute not in this list will raise an `AttributeError`.

      If `spec` is an object (rather than a list of strings) then
      `mock.__class__` returns the class of the spec object. This allows mocks
      to pass `isinstance` tests.

    * `spec_set`: A stricter variant of `spec`. If used, attempting to *set*
      or get an attribute on the mock that isn't on the object passed as
      `spec_set` will raise an `AttributeError`.

    * `side_effect`: A function to be called whenever the Mock is called. See
      the :attr:`Mock.side_effect` attribute. Useful for raising exceptions or
      dynamically changing return values. The function is called with the same
      arguments as the mock, and unless it returns :data:`DEFAULT`, the return
      value of this function is used as the return value.

      Alternatively `side_effect` can be an exception class or instance. In
      this case the exception will be raised when the mock is called.

    * `return_value`: The value returned when the mock is called. By default
      this is a new Mock (created on first access). See the
      :attr:`Mock.return_value` attribute.

    * `wraps`: Item for the mock object to wrap. If `wraps` is not None
      then calling the Mock will pass the call through to the wrapped object
      (returning the real result and ignoring `return_value`). Attribute
      access on the mock will return a Mock object that wraps the corresponding
      attribute of the wrapped object (so attempting to access an attribute that
      doesn't exist will raise an `AttributeError`).

      If the mock has an explicit `return_value` set then calls are not passed
      to the wrapped object and the `return_value` is returned instead.

    * `name`: If the mock has a name then it will be used in the repr of the
      mock. This can be useful for debugging. The name is propagated to child
      mocks.

    Mocks can also be called with arbitrary keyword arguments. These will be
    used to set attributes on the mock after it is created.
    """



def _dot_lookup(thing, comp, import_path):
    try:
        return getattr(thing, comp)
    except AttributeError:
        __import__(import_path)
        return getattr(thing, comp)


def _importer(target):
    components = target.split('.')
    import_path = components.pop(0)
    thing = __import__(import_path)

    for comp in components:
        import_path += ".%s" % comp
        thing = _dot_lookup(thing, comp, import_path)
    return thing


def _is_started(patcher):
    # XXXX horrible
    return hasattr(patcher, 'is_local')


class _patch(object):

    attribute_name = None

    def __init__(
            self, target, attribute, new, spec, create,
            mocksignature, spec_set, autospec, new_callable, kwargs
        ):
        if new_callable is not None:
            if new is not DEFAULT:
                raise ValueError(
                    "Cannot use 'new' and 'new_callable' together"
                )
            if autospec is not False:
                raise ValueError(
                    "Cannot use 'autospec' and 'new_callable' together"
                )

        self.target = target
        self.attribute = attribute
        self.new = new
        self.new_callable = new_callable
        self.spec = spec
        self.create = create
        self.has_local = False
        self.mocksignature = mocksignature
        self.spec_set = spec_set
        self.autospec = autospec
        self.kwargs = kwargs
        self.additional_patchers = []


    def copy(self):
        patcher = _patch(
            self.target, self.attribute, self.new, self.spec,
            self.create, self.mocksignature, self.spec_set,
            self.autospec, self.new_callable, self.kwargs
        )
        patcher.attribute_name = self.attribute_name
        patcher.additional_patchers = [
            p.copy() for p in self.additional_patchers
        ]
        return patcher


    def __call__(self, func):
        if isinstance(func, ClassTypes):
            return self.decorate_class(func)
        return self.decorate_callable(func)


    def decorate_class(self, klass):
        for attr in dir(klass):
            if not attr.startswith(patch.TEST_PREFIX):
                continue

            attr_value = getattr(klass, attr)
            if not hasattr(attr_value, "__call__"):
                continue

            patcher = self.copy()
            setattr(klass, attr, patcher(attr_value))
        return klass


    def decorate_callable(self, func):
        if hasattr(func, 'patchings'):
            func.patchings.append(self)
            return func

        @wraps(func)
        def patched(*args, **keywargs):
            # don't use a with here (backwards compatability with Python 2.4)
            extra_args = []
            entered_patchers = []

            # can't use try...except...finally because of Python 2.4
            # compatibility
            try:
                try:
                    for patching in patched.patchings:
                        arg = patching.__enter__()
                        entered_patchers.append(patching)
                        if patching.attribute_name is not None:
                            keywargs.update(arg)
                        elif patching.new is DEFAULT:
                            extra_args.append(arg)

                    args += tuple(extra_args)
                    return func(*args, **keywargs)
                except:
                    if (patching not in entered_patchers and
                        _is_started(patching)):
                        # the patcher may have been started, but an exception
                        # raised whilst entering one of its additional_patchers
                        entered_patchers.append(patching)
                    # re-raise the exception
                    raise
            finally:
                for patching in reversed(entered_patchers):
                    patching.__exit__()

        patched.patchings = [self]
        if hasattr(func, 'func_code'):
            # not in Python 3
            patched.compat_co_firstlineno = getattr(
                func, "compat_co_firstlineno",
                func.func_code.co_firstlineno
            )
        return patched


    def get_original(self):
        target = self.target
        name = self.attribute

        original = DEFAULT
        local = False

        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True

        if not self.create and original is DEFAULT:
            raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
        return original, local


    def __enter__(self):
        """Perform the patch."""
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable

        original, local = self.get_original()

        if new is DEFAULT and autospec is False:
            inherit = False
            if spec_set == True:
                spec_set = original
            elif spec == True:
                # set spec to the object we are replacing
                spec = original

            if (spec or spec_set) is not None:
                if isinstance(original, ClassTypes):
                    # If we're patching out a class and there is a spec
                    inherit = True

            Klass = MagicMock
            _kwargs = {}
            if new_callable is not None:
                Klass = new_callable
            elif (spec or spec_set) is not None:
                if not _callable(spec or spec_set):
                    Klass = NonCallableMagicMock

            if spec is not None:
                _kwargs['spec'] = spec
            if spec_set is not None:
                _kwargs['spec_set'] = spec_set

            # add a name to mocks
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and self.attribute):
                _kwargs['name'] = self.attribute

            _kwargs.update(kwargs)
            new = Klass(**_kwargs)

            if inherit and _is_instance_mock(new):
                # we can only tell if the instance should be callable if the
                # spec is not a list
                if (not _is_list(spec or spec_set) and not
                    _instance_callable(spec or spec_set)):
                    Klass = NonCallableMagicMock

                _kwargs.pop('name')
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs)
        elif autospec is not False:
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool? mocksignature should also not be used. Should we
            # check this?
            if new is not DEFAULT:
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                )
            spec_set = bool(spec_set)
            if autospec is True:
                autospec = original
            new = create_autospec(autospec, spec_set=spec_set, configure=kwargs,
                                  _name=self.attribute)
        elif kwargs:
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating")

        new_attr = new
        if self.mocksignature:
            new_attr = mocksignature(original, new)

        self.temp_original = original
        self.is_local = local
        setattr(self.target, self.attribute, new_attr)
        if self.attribute_name is not None:
            extra_args = {}
            if self.new is DEFAULT:
                extra_args[self.attribute_name] =  new
            for patching in self.additional_patchers:
                arg = patching.__enter__()
                if patching.new is DEFAULT:
                    extra_args.update(arg)
            return extra_args

        return new


    def __exit__(self, *_):
        """Undo the patch."""
        if not _is_started(self):
            raise RuntimeError('stop called on unstarted patcher')

        if self.is_local and self.temp_original is not DEFAULT:
            setattr(self.target, self.attribute, self.temp_original)
        else:
            delattr(self.target, self.attribute)
            if not self.create and not hasattr(self.target, self.attribute):
                # needed for proxy objects like django settings
                setattr(self.target, self.attribute, self.temp_original)

        del self.temp_original
        del self.is_local
        for patcher in reversed(self.additional_patchers):
            if _is_started(patcher):
                patcher.__exit__()

    start = __enter__
    stop = __exit__



def _get_target(target):
    try:
        target, attribute = target.rsplit('.', 1)
    except (TypeError, ValueError):
        raise TypeError("Need a valid target to patch. You supplied: %r" %
                        (target,))
    target = _importer(target)
    return target, attribute


def _patch_object(
        target, attribute, new=DEFAULT, spec=None,
        create=False, mocksignature=False, spec_set=None, autospec=False,
        new_callable=None, **kwargs
    ):
    """
    patch.object(target, attribute, new=DEFAULT, spec=None, create=False,
                 mocksignature=False, spec_set=None)

    patch the named member (`attribute`) on an object (`target`) with a mock
    object.

    Arguments new, spec, create, mocksignature and spec_set have the same
    meaning as for patch.
    """
    return _patch(
        target, attribute, new, spec, create, mocksignature,
        spec_set, autospec, new_callable, kwargs
    )


def _patch_multiple(target, spec=None, create=False,
        mocksignature=False, spec_set=None, autospec=False,
        new_callable=None, **kwargs
    ):
    """Perform multiple patches in a single call. It takes the object to be
    patched (either as an object or a string to fetch the object by importing)
    and keyword arguments for the patches::

        with patch.multiple(settings, FIRST_PATCH='one', SECOND_PATCH='two'):
            ...

    Like `patch` it can be used as a decorator, class decorator or a context
    manager. The arguments `spec`, `spec_set`, `create`, `mocksignature`,
    `autospec` and `new_callable` have the same meaning as for `patch`. These
    arguments will be applied to *all* the patches being done by
    `patch.multiple`.
    """
    if type(target) in (unicode, str):
        target = _importer(target)

    if not kwargs:
        raise ValueError(
            'Must supply at least one keyword argument with patch.multiple'
        )
    # need to wrap in a list for python 3, where items is a view
    items = list(kwargs.items())
    attribute, new = items[0]
    patcher = _patch(
        target, attribute, new, spec, create, mocksignature, spec_set,
        autospec, new_callable, {}
    )
    patcher.attribute_name = attribute
    for attribute, new in items[1:]:
        this_patcher = _patch(
            target, attribute, new, spec, create, mocksignature, spec_set,
            autospec, new_callable, {}
        )
        this_patcher.attribute_name = attribute
        patcher.additional_patchers.append(this_patcher)
    return patcher


def patch(
        target, new=DEFAULT, spec=None, create=False,
        mocksignature=False, spec_set=None, autospec=False,
        new_callable=None, **kwargs
    ):
    """
    `patch` acts as a function decorator, class decorator or a context
    manager. Inside the body of the function or with statement, the `target`
    (specified in the form `'package.module.ClassName'`) is patched
    with a `new` object. When the function/with statement exits the patch is
    undone.

    The `target` is imported and the specified attribute patched with the new
    object, so it must be importable from the environment you are calling the
    decorator from.

    If `new` is omitted, then a new `MagicMock` is created and passed in as an
    extra argument to the decorated function.

    The `spec` and `spec_set` keyword arguments are passed to the `MagicMock`
    if patch is creating one for you.

    In addition you can pass `spec=True` or `spec_set=True`, which causes
    patch to pass in the object being mocked as the spec/spec_set object.

    `new_callable` allows you to specify a different class, or callable object,
    that will be called to create the `new` object. By default `MagicMock` is
    used.

    A more powerful form of `spec` is `autospec`. If you set `autospec=True`
    then the mock with be created with a spec from the object being replaced.
    All attributes of the mock will also have the spec of the corresponding
    attribute of the object being replaced. Methods and functions being mocked
    will have their arguments checked and will raise a `TypeError` if they are
    called with the wrong signature (similar to `mocksignature`). For mocks
    replacing a class, their return value (the 'instance') will have the same
    spec as the class.

    Instead of `autospec=True` you can pass `autospec=some_object` to use an
    arbitrary object as the spec instead of the one being replaced.

    If `mocksignature` is True then the patch will be done with a function
    created by mocking the one being replaced. If the object being replaced is
    a class then the signature of `__init__` will be copied. If the object
    being replaced is a callable object then the signature of `__call__` will
    be copied.

    By default `patch` will fail to replace attributes that don't exist. If
    you pass in 'create=True' and the attribute doesn't exist, patch will
    create the attribute for you when the patched function is called, and
    delete it again afterwards. This is useful for writing tests against
    attributes that your production code creates at runtime. It is off by by
    default because it can be dangerous. With it switched on you can write
    passing tests against APIs that don't actually exist!

    Patch can be used as a TestCase class decorator. It works by
    decorating each test method in the class. This reduces the boilerplate
    code when your test methods share a common patchings set. `patch` finds
    tests by looking for method names that start with `patch.TEST_PREFIX`.
    By default this is `test`, which matches the way `unittest` finds tests.
    You can specify an alternative prefix by setting `patch.TEST_PREFIX`.

    Patch can be used with the with statement, if this is available in your
    version of Python. Here the patching applies to the indented block after
    the with statement. If you use "as" then the patched object will be bound
    to the name after the "as"; very useful if `patch` is creating a mock
    object for you.

    `patch` also takes arbitrary keyword arguments. These will be passed to
    the `Mock` (or `new_callable`) on construction.

    `patch.dict(...)`, `patch.multiple(...)` and `patch.object(...)` are
    available for alternate use-cases.
    """
    target, attribute = _get_target(target)
    return _patch(
        target, attribute, new, spec, create, mocksignature,
        spec_set, autospec, new_callable, kwargs
    )


class _patch_dict(object):
    """
    Patch a dictionary and restore the dictionary to its original state after
    the test.

    `in_dict` can be a dictionary or a mapping like container. If it is a
    mapping then it must at least support getting, setting and deleting items
    plus iterating over keys.

    `in_dict` can also be a string specifying the name of the dictionary, which
    will then be fetched by importing it.

    `values` can be a dictionary of values to set in the dictionary. `values`
    can also be an iterable of `(key, value)` pairs.

    If `clear` is True then the dictionary will be cleared before the new
    values are set.

    `patch.dict` can also be called with arbitrary keyword arguments to set
    values in the dictionary::

        with patch.dict('sys.modules', mymodule=Mock(), other_module=Mock()):
            ...
    """

    def __init__(self, in_dict, values=(), clear=False, **kwargs):
        if isinstance(in_dict, basestring):
            in_dict = _importer(in_dict)
        self.in_dict = in_dict
        # support any argument supported by dict(...) constructor
        self.values = dict(values)
        self.values.update(kwargs)
        self.clear = clear
        self._original = None


    def __call__(self, f):
        if isinstance(f, ClassTypes):
            return self.decorate_class(f)
        @wraps(f)
        def _inner(*args, **kw):
            self._patch_dict()
            try:
                return f(*args, **kw)
            finally:
                self._unpatch_dict()

        return _inner


    def decorate_class(self, klass):
        for attr in dir(klass):
            attr_value = getattr(klass, attr)
            if (attr.startswith(patch.TEST_PREFIX) and
                 hasattr(attr_value, "__call__")):
                decorator = _patch_dict(self.in_dict, self.values, self.clear)
                decorated = decorator(attr_value)
                setattr(klass, attr, decorated)
        return klass


    def __enter__(self):
        """Patch the dict."""
        self._patch_dict()


    def _patch_dict(self):
        values = self.values
        in_dict = self.in_dict
        clear = self.clear

        try:
            original = in_dict.copy()
        except AttributeError:
            # dict like object with no copy method
            # must support iteration over keys
            original = {}
            for key in in_dict:
                original[key] = in_dict[key]
        self._original = original

        if clear:
            _clear_dict(in_dict)

        try:
            in_dict.update(values)
        except AttributeError:
            # dict like object with no update method
            for key in values:
                in_dict[key] = values[key]


    def _unpatch_dict(self):
        in_dict = self.in_dict
        original = self._original

        _clear_dict(in_dict)

        try:
            in_dict.update(original)
        except AttributeError:
            for key in original:
                in_dict[key] = original[key]


    def __exit__(self, *args):
        """Unpatch the dict."""
        self._unpatch_dict()
        return False

    start = __enter__
    stop = __exit__


def _clear_dict(in_dict):
    try:
        in_dict.clear()
    except AttributeError:
        keys = list(in_dict)
        for key in keys:
            del in_dict[key]


patch.object = _patch_object
patch.dict = _patch_dict
patch.multiple = _patch_multiple
patch.TEST_PREFIX = 'test'

magic_methods = (
    "lt le gt ge eq ne "
    "getitem setitem delitem "
    "len contains iter "
    "hash str sizeof "
    "enter exit "
    "divmod neg pos abs invert "
    "complex int float index "
    "trunc floor ceil "
)

numerics = "add sub mul div floordiv mod lshift rshift and xor or pow "
inplace = ' '.join('i%s' % n for n in numerics.split())
right = ' '.join('r%s' % n for n in numerics.split())
extra = ''
if inPy3k:
    extra = 'bool next '
else:
    extra = 'unicode long nonzero oct hex truediv rtruediv '

# not including __prepare__, __instancecheck__, __subclasscheck__
# (as they are metaclass methods)
# __del__ is not supported at all as it causes problems if it exists

_non_defaults = set('__%s__' % method for method in [
    'cmp', 'getslice', 'setslice', 'coerce', 'subclasses',
    'format', 'get', 'set', 'delete', 'reversed',
    'missing', 'reduce', 'reduce_ex', 'getinitargs',
    'getnewargs', 'getstate', 'setstate', 'getformat',
    'setformat', 'repr', 'dir'
])


def _get_method(name, func):
    "Turns a callable object (like a mock) into a real function"
    def method(self, *args, **kw):
        return func(self, *args, **kw)
    method.__name__ = name
    return method


_magics = set(
    '__%s__' % method for method in
    ' '.join([magic_methods, numerics, inplace, right, extra]).split()
)

_all_magics = _magics | _non_defaults

_unsupported_magics = set([
    '__getattr__', '__setattr__',
    '__init__', '__new__', '__prepare__'
    '__instancecheck__', '__subclasscheck__',
    '__del__'
])

_calculate_return_value = {
    '__hash__': lambda self: object.__hash__(self),
    '__str__': lambda self: object.__str__(self),
    '__sizeof__': lambda self: object.__sizeof__(self),
    '__unicode__': lambda self: unicode(object.__str__(self)),
}

_side_effect_methods = {
    '__eq__': lambda self: lambda other: self is other,
    '__ne__': lambda self: lambda other: self is not other,
}

_return_values = {
    '__int__': 1,
    '__contains__': False,
    '__len__': 0,
    '__iter__': iter([]),
    '__exit__': False,
    '__complex__': 1j,
    '__float__': 1.0,
    '__bool__': True,
    '__nonzero__': True,
    '__oct__': '1',
    '__hex__': '0x1',
    '__long__': long(1),
    '__index__': 1,
}


def _get_eq(self):
    def __eq__(other):
        ret_val = self.__eq__._mock_return_value
        if ret_val is not DEFAULT:
            return ret_val
        return self is other
    return __eq__

def _get_ne(self):
    def __ne__(other):
        if self.__ne__._mock_return_value is not DEFAULT:
            return DEFAULT
        return self is not other
    return __ne__

_side_effect_methods = {
    '__eq__': _get_eq,
    '__ne__': _get_ne,
}



def _set_return_value(mock, method, name):
    return_value = DEFAULT
    if name in _return_values:
        return_value = _return_values[name]
    elif name in _calculate_return_value:
        try:
            return_value = _calculate_return_value[name](mock)
        except AttributeError:
            # XXXX why do we return AttributeError here?
            #      set it as a side_effect instead?
            return_value = AttributeError(name)
    elif name in _side_effect_methods:
        side_effect = _side_effect_methods[name](mock)
        method.side_effect = side_effect
    if return_value is not DEFAULT:
        method.return_value = return_value



class MagicMixin(object):
    def __init__(self, *args, **kw):
        _super(MagicMixin, self).__init__(*args, **kw)
        self._mock_set_magics()

    def _mock_set_magics(self):
        these_magics = _magics
        if self._mock_methods is not None:
            these_magics = _magics.intersection(self._mock_methods)

        remove_magics = _magics - these_magics

        for entry in remove_magics:
            if entry in type(self).__dict__:
                # remove unneeded magic methods
                delattr(self, entry)

        for entry in these_magics:
            if entry in type(self).__dict__:
                # don't overwrite existing attributes if called a second time
                continue
            setattr(self, entry, _create_proxy(entry, self))



class NonCallableMagicMock(MagicMixin, NonCallableMock):
    """A version of `MagicMock` that isn't callable."""
    def mock_add_spec(self, spec, spec_set=False):
        """Add a spec to a mock. `spec` can either be an object or a
        list of strings. Only attributes on the `spec` can be fetched as
        attributes from the mock.

        If `spec_set` is True then only attributes on the spec can be set."""
        self._mock_add_spec(spec, spec_set)
        self._mock_set_magics()



class MagicMock(MagicMixin, Mock):
    """
    MagicMock is a subclass of Mock with default implementations
    of most of the magic methods. You can use MagicMock without having to
    configure the magic methods yourself.

    If you use the `spec` or `spec_set` arguments then *only* magic
    methods that exist in the spec will be created.

    Attributes and the return value of a `MagicMock` will also be `MagicMocks`.
    """
    def mock_add_spec(self, spec, spec_set=False):
        """Add a spec to a mock. `spec` can either be an object or a
        list of strings. Only attributes on the `spec` can be fetched as
        attributes from the mock.

        If `spec_set` is True then only attributes on the spec can be set."""
        self._mock_add_spec(spec, spec_set)
        self._mock_set_magics()



def _create_proxy(entry, self):
    # could specify parent?
    def create_mock():
        m = MagicMock(name=entry, _new_name=entry, _new_parent=self)
        setattr(self, entry, m)
        _set_return_value(self, m, entry)
        return m
    return MagicProxy(create_mock)



class MagicProxy(object):
    def __init__(self, create_mock):
        self.create_mock = create_mock
    def __call__(self, *args, **kwargs):
        m = self.create_mock()
        return m(*args, **kwargs)
    def __get__(self, obj, _type=None):
        return self.create_mock()



class _ANY(object):
    "A helper object that compares equal to everything."

    def __eq__(self, other):
        return True

    def __repr__(self):
        return '<ANY>'

ANY = _ANY()



def _format_call_signature(name, args, kwargs):
    message = '%s(%%s)' % name
    formatted_args = ''
    args_string = ', '.join([repr(arg) for arg in args])
    kwargs_string = ', '.join([
        '%s=%r' % (key, value) for key, value in kwargs.items()
    ])
    if args_string:
        formatted_args = args_string
    if kwargs_string:
        if formatted_args:
            formatted_args += ', '
        formatted_args += kwargs_string

    return message % formatted_args



class _Call(tuple):
    """
    A tuple for holding the results of a call to a mock, either in the form
    `(args, kwargs)` or `(name, args, kwargs)`.

    If args or kwargs are empty then a call tuple will compare equal to
    a tuple without those values. This makes comparisons less verbose::

        _Call(('name', (), {})) == ('name',)
        _Call(('name', (1,), {})) == ('name', (1,))
        _Call(((), {'a': 'b'})) == ({'a': 'b'},)

    The `_Call` object provides a useful shortcut for comparing with call::

        _Call(((1, 2), {'a': 3})) == call(1, 2, a=3)
        _Call(('foo', (1, 2), {'a': 3})) == call.foo(1, 2, a=3)

    If the _Call has no name then it will match any name.
    """
    def __new__(cls, value=(), name=None, parent=None, two=False,
                from_kall=True):
        name = ''
        args = ()
        kwargs = {}
        if len(value) == 3:
            name, args, kwargs = value
        elif len(value) == 2:
            first, second = value
            if isinstance(first, basestring):
                name = first
                if isinstance(second, tuple):
                    args = second
                else:
                    kwargs = second
            else:
                args, kwargs = first, second
        elif len(value) == 1:
            value, = value
            if isinstance(value, basestring):
                name = value
            elif isinstance(value, tuple):
                args = value
            else:
                kwargs = value

        if two:
            return tuple.__new__(cls, (args, kwargs))

        return tuple.__new__(cls, (name, args, kwargs))


    def __init__(self, value=(), name=None, parent=None, two=False,
                 from_kall=True):
        self.name = name
        self.parent = parent
        self.from_kall = from_kall


    def __eq__(self, other):
        try:
            len(other)
        except TypeError:
            return False

        self_name = ''
        if len(self) == 2:
            self_args, self_kwargs = self
        else:
            self_name, self_args, self_kwargs = self

        other_name = ''
        if len(other) == 0:
            other_args, other_kwargs = (), {}
        elif len(other) == 3:
            other_name, other_args, other_kwargs = other
        elif len(other) == 1:
            value, = other
            if isinstance(value, tuple):
                other_args = value
                other_kwargs = {}
            elif isinstance(value, basestring):
                other_name = value
                other_args, other_kwargs = (), {}
            else:
                other_args = ()
                other_kwargs = value
        else:
            # len 2
            # could be (name, args) or (name, kwargs) or (args, kwargs)
            first, second = other
            if isinstance(first, basestring):
                other_name = first
                if isinstance(second, tuple):
                    other_args, other_kwargs = second, {}
                else:
                    other_args, other_kwargs = (), second
            else:
                other_args, other_kwargs = first, second

        if self_name and other_name != self_name:
            return False
        return (self_args, self_kwargs) == (other_args, other_kwargs)


    def __ne__(self, other):
        return not self.__eq__(other)


    def __call__(self, *args, **kwargs):
        if self.name is None:
            return _Call(('', args, kwargs), name='()')

        name = self.name + '()'
        return _Call((self.name, args, kwargs), name=name, parent=self)


    def __getattr__(self, attr):
        if self.name is None:
            return _Call(name=attr, from_kall=False)
        name = '%s.%s' % (self.name, attr)
        return _Call(name=name, parent=self, from_kall=False)


    def __repr__(self):
        if not self.from_kall:
            name = self.name or 'call'
            if name.startswith('()'):
                name = 'call%s' % name
            return name

        if len(self) == 2:
            name = 'call'
            args, kwargs = self
        else:
            name, args, kwargs = self
            if not name:
                name = 'call'
            elif not name.startswith('()'):
                name = 'call.%s' % name
            else:
                name = 'call%s' % name
        return _format_call_signature(name, args, kwargs)


    def call_list(self):
        """For a call object that represents multiple calls, `call_list`
        returns a list of all the intermediate calls as well as the
        final call."""
        vals = []
        thing = self
        while thing is not None:
            if thing.from_kall:
                vals.append(thing)
            thing = thing.parent
        return _CallList(reversed(vals))


call = _Call(from_kall=False)



def create_autospec(spec, spec_set=False, instance=False,
                    configure=None, _parent=None, _name=None):
    """Create a mock object using another object as a spec. Attributes on the
    mock will use the corresponding attribute on the `spec` object as their
    spec.

    Functions or methods being mocked will have their arguments checked in a
    similar way to `mocksignature` to check that they are called with the
    correct signature.

    If `spec_set` is True then attempting to set attributes that don't exist
    on the spec object will raise an `AttributeError`.

    If a class is used as a spec then the return value of the mock (the
    instance of the class) will have the same spec. You can use a class as the
    spec for an instance object by passing `instance=True`. The returned mock
    will only be callable if instances of the mock are callable.

    `configure` is a dictionary that will be used as keyword arguments for the
    created mock."""
    if configure is None:
        configure = {}

    if _is_list(spec):
        # can't pass a list instance to the mock constructor as it will be
        # interpreted as a list of strings
        spec = type(spec)

    is_type = isinstance(spec, ClassTypes)

    kwargs = {'spec': spec}
    if spec_set:
        kwargs = {'spec_set': spec}
    elif spec is None:
        # None we mock with a normal mock without a spec
        kwargs = {}

    kwargs.update(configure)

    Klass = MagicMock
    if type(spec) in DescriptorTypes:
        # descriptors don't have a spec
        # because we don't know what type they return
        kwargs = {}
    elif not _callable(spec):
        Klass = NonCallableMagicMock
    elif is_type and instance and not _instance_callable(spec):
        Klass = NonCallableMagicMock

    _new_name = _name
    if _parent is None:
        # for a top level object no _new_name should be set
        _new_name = ''

    mock = Klass(parent=_parent, _new_parent=_parent, _new_name=_new_name,
                 name=_name, **kwargs)

    if isinstance(spec, FunctionTypes):
        # should only happen at the top level because we don't
        # recurse for functions
        mock = _set_signature(mock, spec)
    else:
        _check_signature(spec, mock, is_type)

    if _parent is not None and not instance:
        _parent._mock_children[_name] = mock

    if is_type and not instance:
        # XXXX could give a name to the return_value mock?
        mock.return_value = create_autospec(spec, spec_set, instance=True,
                                            _name='()', _parent=mock)

    for entry in dir(spec):
        if _is_magic(entry):
            # MagicMock already does the useful magic methods for us
            continue

        if isinstance(spec, FunctionTypes) and entry in FunctionAttributes:
            # allow a mock to actually be a function from mocksignature
            continue

        # XXXX do we need a better way of getting attributes
        # without triggering code execution (?) Probably not - we need the
        # actual object to mock it so we would rather trigger a property than
        # mock the property descriptor. Likewise we want to mock out
        # dynamically provided attributes.
        # XXXX what about attributes that raise exceptions on being fetched
        # we could be resilient against it, or catch and propagate the exception
        # when the attribute is fetched from the mock
        original = getattr(spec, entry)

        kwargs = {'spec': original}
        if spec_set:
            kwargs = {'spec_set': original}

        if not isinstance(original, FunctionTypes):
            new = _SpecState(original, spec_set, mock, entry, instance)
            mock._mock_children[entry] = new
        else:
            parent = mock
            if isinstance(spec, FunctionTypes):
                parent = mock.mock

            new = MagicMock(parent=parent, name=entry, _new_name=entry,
                            _new_parent=parent, **kwargs)
            mock._mock_children[entry] = new
            skipfirst = _must_skip(spec, entry, is_type)
            _check_signature(original, new, skipfirst=skipfirst)

        # so functions created with mocksignature become instance attributes,
        # *plus* their underlying mock exists in _mock_children of the parent
        # mock. Adding to _mock_children may be unnecessary where we are also
        # setting as an instance attribute?
        if isinstance(new, FunctionTypes):
            setattr(mock, entry, new)

    return mock


def _must_skip(spec, entry, skipfirst):
    if not isinstance(spec, ClassTypes):
        if entry in getattr(spec, '__dict__', {}):
            # instance attribute - shouldn't skip
            return False
        # can't use type because of old style classes
        spec = spec.__class__
    if not hasattr(spec, '__mro__'):
        # old style class: can't have descriptors anyway
        return skipfirst

    for klass in spec.__mro__:
        result = klass.__dict__.get(entry, DEFAULT)
        if result is DEFAULT:
            continue
        if isinstance(result, (staticmethod, classmethod)):
            return False
        return skipfirst

    # shouldn't get here unless attribute dynamically provided
    return skipfirst


def _get_class(obj):
    try:
        return obj.__class__
    except AttributeError:
        # in Python 2, _sre.SRE_Pattern objects have no __class__
        return type(obj)


class _SpecState(object):

    def __init__(self, spec, spec_set=False, parent=None,
                 name=None, ids=None, instance=False):
        self.spec = spec
        self.ids = ids
        self.spec_set = spec_set
        self.parent = parent
        self.instance = instance
        self.name = name


FunctionTypes = (
    # python function
    type(create_autospec),
    # instance method
    type(ANY.__eq__),
    # unbound method
    type(_ANY.__eq__),
)

FunctionAttributes = set([
    'func_closure',
    'func_code',
    'func_defaults',
    'func_dict',
    'func_doc',
    'func_globals',
    'func_name',
])

########NEW FILE########
__FILENAME__ = MockYouTubeDepends
import sys
import time
import inspect

class MockYouTubeDepends:
    def mock(self):
        import platform
        from mock import Mock
        sys.path.append("../plugin/")

        # Setup default test various values
        sys.modules["__main__"].plugin = "YouTube - IntegrationTest"
        sys.modules["__main__"].dbg = True
        try:
            plat = platform.uname()
        except:
            plat = ('', '', '', '', '', '')

        if plat[0] == "FreeBSD" and False:
            sys.modules["__main__"].dbglevel = 5
        else:
            sys.modules["__main__"].dbglevel = 3

        sys.modules["__main__"].login = ""
        sys.modules["__main__"].cache = Mock()
        sys.modules["__main__"].cache.cacheFunction.side_effect = self.execute
        sys.modules["__main__"].cache.getMulti.return_value = []
        sys.modules["__main__"].cache.get.return_value = ""

    def mockXBMC(self):
        from mock import Mock
        sys.path.append("../xbmc-mocks/")
        import xbmc
        import xbmcaddon
        import xbmcgui
        import xbmcplugin
        import xbmcvfs

        #Setup basic xbmc dependencies
        sys.modules["__main__"].xbmc = Mock(spec=xbmc)
        sys.modules["__main__"].xbmc.getSkinDir = Mock()
        sys.modules["__main__"].xbmc.translatePath = Mock()
        sys.modules["__main__"].xbmc.translatePath.return_value = "./tmp/"
        sys.modules["__main__"].xbmc.log = Mock()
        sys.modules["__main__"].xbmc.log.side_effect = self.log
        sys.modules["__main__"].xbmc.getSkinDir = Mock()
        sys.modules["__main__"].xbmc.getSkinDir.return_value = "testSkinPath"
        sys.modules["__main__"].xbmc.getInfoLabel = Mock()
        sys.modules["__main__"].xbmc.getInfoLabel.return_value = "some_info_label"
        sys.modules["__main__"].xbmcaddon = Mock(spec=xbmcaddon)
        sys.modules["__main__"].xbmcgui = Mock(spec=xbmcgui)
        sys.modules["__main__"].xbmcgui.WindowXMLDialog.return_value = "testWindowXML"
        sys.modules["__main__"].xbmcgui.getCurrentWindowId.return_value = 1

        sys.modules["__main__"].xbmcplugin = Mock(spec=xbmcplugin)
        sys.modules["__main__"].xbmcvfs = xbmcvfs
        sys.modules["__main__"].xbmcvfs = Mock(spec=xbmcvfs)
        sys.modules["__main__"].xbmcvfs.exists.return_value = False
        import xbmcSettings
        sys.modules["__main__"].settings = xbmcSettings.xbmcSettings()
        sys.modules["__main__"].settingsDL = xbmcSettings.xbmcSettings()

        import xbmcLanguage
        sys.modules["__main__"].language = xbmcLanguage.xbmcLanguage()

        sys.modules["DialogDownloadProgress"] = __import__("mock")
        sys.modules["DialogDownloadProgress"].DownloadProgress = Mock()
        sys.modules["storageserverdummy"] = Mock()

    def log(self, description, level=0):
        if sys.modules["__main__"].dbg and sys.modules["__main__"].dbglevel > level:
            try:
                print "%s [%s] %s : '%s'" % (time.strftime("%H:%M:%S"), "YouTube IntegrationTest", inspect.stack()[3][3], description.decode("utf-8", "ignore"))
            except:
                print "%s [%s] %s : '%s'" % (time.strftime("%H:%M:%S"), "YouTube IntegrationTest", inspect.stack()[3][3], description)

    def execute(self, function, *args):
        return function(*args)

########NEW FILE########
__FILENAME__ = hotp
from pyotp.otp import OTP
import urllib


class HOTP(OTP):
    def at(self, count):
        """
        Generates the OTP for the given count
        @param [Integer] count counter
        @returns [Integer] OTP
        """
        return self.generate_otp(count)
    
    def verify(self, otp, counter):
        """
        Verifies the OTP passed in against the current time OTP
        @param [String/Integer] otp the OTP to check against
        @param [Integer] counter the counter of the OTP
        """
        return otp == self.at(counter)
    
    def provisioning_uri(self, name, initial_count=0):
        """
        Returns the provisioning URI for the OTP
        This can then be encoded in a QR Code and used
        to provision the Google Authenticator app
        @param [String] name of the account
        @param [Integer] initial_count starting counter value, defaults to 0
        @return [String] provisioning uri
        """
        return 'otpauth://hotp/%(name)s?secret=%(secret)s&counter=%(initial_count)s' % {
            'name': urllib.quote(name, safe='@'),
            'secret': self.secret,
            'initial_count': initial_count,
        }

########NEW FILE########
__FILENAME__ = otp
import base64
import hashlib
import hmac


class OTP(object):
    def __init__(self, s, digits=6, digest=hashlib.sha1):
        """
        @param [String] secret in the form of base32
        @option options digits [Integer] (6)
            Number of integers in the OTP
            Google Authenticate only supports 6 currently
        @option options digest [Callable] (hashlib.sha1)
            Digest used in the HMAC
            Google Authenticate only supports 'sha1' currently
        @returns [OTP] OTP instantiation
        """
        self.digits = digits
        self.digest = digest
        self.secret = s
    
    def generate_otp(self, input):
        """
        @param [Integer] input the number used seed the HMAC
        Usually either the counter, or the computed integer
        based on the Unix timestamp
        """
        hmac_hash = hmac.new(
            self.byte_secret(),
            self.int_to_bytestring(input),
            self.digest,
        ).digest()
        
        offset = ord(hmac_hash[19]) & 0xf
        code = ((ord(hmac_hash[offset]) & 0x7f) << 24 |
            (ord(hmac_hash[offset + 1]) & 0xff) << 16 |
            (ord(hmac_hash[offset + 2]) & 0xff) << 8 |
            (ord(hmac_hash[offset + 3]) & 0xff))
        return code % 10 ** self.digits
    
    def byte_secret(self):
        return base64.b32decode(self.secret, casefold=True)
    
    def int_to_bytestring(self, int, padding=8):
        """
        Turns an integer to the OATH specified
        bytestring, which is fed to the HMAC
        along with the secret
        """
        result = []
        while int != 0:
            result.append(chr(int & 0xFF))
            int = int >> 8
        return ''.join(reversed(result)).rjust(padding, '\0')

########NEW FILE########
__FILENAME__ = totp
from pyotp.otp import OTP
import datetime
import time
import urllib


class TOTP(OTP):
    def __init__(self, *args, **kwargs):
        """
        @option options [Integer] interval (30) the time interval in seconds for OTP
            This defaults to 30 which is standard.
        """
        self.interval = kwargs.pop('interval', 30)
        super(TOTP, self).__init__(*args, **kwargs)
    
    def at(self, for_time):
        """
        Accepts either a Unix timestamp integer or a Time object.
        Time objects will be adjusted to UTC automatically
        @param [Time/Integer] time the time to generate an OTP for
        """
        if not isinstance(for_time, datetime.datetime):
            for_time = datetime.datetime.fromtimestamp(int(for_time))
        return self.generate_otp(self.timecode(for_time))
    
    def now(self):
        """
        Generate the current time OTP
        @return [Integer] the OTP as an integer
        """
        return self.generate_otp(self.timecode(datetime.datetime.now()))
    
    def verify(self, otp, for_time=None):
        """
        Verifies the OTP passed in against the current time OTP
        @param [String/Integer] otp the OTP to check against
        """
        if for_time is None:
            for_time = datetime.datetime.now()
        return otp == self.at(for_time)
    
    def provisioning_uri(self, name):
        """
        Returns the provisioning URI for the OTP
        This can then be encoded in a QR Code and used
        to provision the Google Authenticator app
        @param [String] name of the account
        @return [String] provisioning uri
        """
        return 'otpauth://totp/%(name)s?secret=%(secret)s' % {
            'name': urllib.quote(name, safe='@'),
            'secret': self.secret,
        }
    
    def timecode(self, for_time):
        i = time.mktime(for_time.timetuple())
        return int(i / self.interval)

########NEW FILE########
__FILENAME__ = SimpleDownloader
'''
   Simple Downloader plugin for XBMC
   Copyright (C) 2010-2011 Tobias Ussing And Henrik Mosgaard Jensen

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import sys
import urllib2
import os
import time
import subprocess
import DialogDownloadProgress


#http://wiki.openelec.tv/index.php?title=How_to_make_OpenELEC_addon_-_on_MuMuDVB_sample
class SimpleDownloader():
    dialog = u""

    def __init__(self):
        self.version = u"0.9.3"
        self.plugin = u"SimpleDownloader Beta-" + self.version

        if hasattr(sys.modules["__main__"], "common"):
            self.common = sys.modules["__main__"].common
        else:
            import CommonFunctions
            self.common = CommonFunctions

        self.common.log("")

        try:
            import StorageServer
            self.cache = StorageServer.StorageServer("Downloader")
        except:
            import storageserverdummy as StorageServer
            self.cache = StorageServer.StorageServer("Downloader")

        if hasattr(sys.modules["__main__"], "xbmcaddon"):
            self.xbmcaddon = sys.modules["__main__"].xbmcaddon
        else:
            import xbmcaddon
            self.xbmcaddon = xbmcaddon

        self.settings = self.xbmcaddon.Addon(id='script.module.simple.downloader.beta')

        if hasattr(sys.modules["__main__"], "xbmc"):
            self.xbmc = sys.modules["__main__"].xbmc
        else:
            import xbmc
            self.xbmc = xbmc

        if hasattr(sys.modules["__main__"], "xbmcvfs"):
            self.xbmcvfs = sys.modules["__main__"].xbmcvfs
        else:
            try:
                import xbmcvfs
                self.xbmcvfs = xbmcvfs
            except ImportError:
                import xbmcvfsdummy as xbmcvfs
                self.xbmcvfs = xbmcvfs

        if hasattr(sys.modules["__main__"], "dbglevel"):
            self.dbglevel = sys.modules["__main__"].dbglevel
        else:
            self.dbglevel = 3

        if hasattr(sys.modules["__main__"], "dbg"):
            self.dbg = sys.modules["__main__"].dbg
        else:
            self.dbg = True

        self.language = self.settings.getLocalizedString
        self.hide_during_playback = self.settings.getSetting("hideDuringPlayback") == "true"
        self.notification_length = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10][int(self.settings.getSetting("notification_length"))] * 1000

        if self.settings.getSetting("rtmp_binary"):
            self.rtmp_binary = self.settings.getSetting("rtmp_binary")
        else:
            self.rtmp_binary = "rtmpdump"

        if self.settings.getSetting("vlc_binary"):
            self.vlc_binary = self.settings.getSetting("vlc_binary")
        else:
            self.vlc_binary = "vlc"

        if self.settings.getSetting("mplayer_binary"):
            self.mplayer_binary = self.settings.getSetting("mplayer_binary")
        else:
            self.mplayer_binary = "mplayer"

        self.__workersByName = {}

        self.temporary_path = self.xbmc.translatePath(self.settings.getAddonInfo("profile"))
        if not self.xbmcvfs.exists(self.temporary_path):
            self.common.log("Making path structure: " + repr(self.temporary_path))
            self.xbmcvfs.mkdir(self.temporary_path)
        self.cur_dl = {}
        self.common.log("Done")

    def download(self, filename, params={}, async=True):
        self.common.log("", 5)
        if async:
            self.common.log("Async", 5)
            self._run_async(self._startDownload, filename, params)
        else:
            self.common.log("Normal", 5)
            self._startDownload(filename, params)
        self.common.log("Done", 5)

    def _startDownload(self, filename, params={}):
        self.common.log("", 5)
        if self.cache.lock("SimpleDownloaderLock"):
            self.common.log("Downloader not active, initializing downloader.")
            self._addItemToQueue(filename, params)
            self._processQueue()
            self.cache.unlock("SimpleDownloaderLock")
        else:
            self.common.log("Downloader is active, Queueing item.")
            self._addItemToQueue(filename, params)
        self.common.log("Done", 5)

    def _setPaths(self, filename, params={}):
        self.common.log(filename, 5)
        # Check utf-8 stuff here
        params["path_incomplete"] = os.path.join(self.temporary_path.decode("utf-8"), self.common.makeUTF8(filename))
        params["path_complete"] = os.path.join(params["download_path"].decode("utf-8"), self.common.makeUTF8(filename))
        self.common.log(params["path_incomplete"], 5)
        self.common.log(params["path_complete"], 5)

        if self.xbmcvfs.exists(params["path_complete"]):
            self.common.log("Removing existing %s" % repr(params["path_complete"]))
            self.xbmcvfs.delete(params["path_complete"])

        if self.xbmcvfs.exists(params["path_incomplete"]):
            self.common.log("Removing incomplete %s" % repr(params["path_incomplete"]))
            self.xbmcvfs.delete(params["path_incomplete"])

        self.common.log("Done", 5)

    def _processQueue(self):
        self.common.log("")
        item = self._getNextItemFromQueue()
        if item:
            (filename, item) = item

            if item:
                if not self.dialog:
                    self.dialog = DialogDownloadProgress.DownloadProgress()
                    self.dialog.create(self.language(201), "")

                while item:
                    status = 500
                    self._setPaths(filename, item)

                    if not "url" in item:
                        self.common.log("URL missing : %s" % repr(item))
                    elif item["url"].find("ftp") > -1 or item["url"].find("http") > -1:
                        status = self._downloadURL(filename, item)
                    else:
                        self._detectStream(filename, item)
                        if "cmd_call" in item:
                            status = self._downloadStream(filename, item)
                        else:
                            self._showMessage(self.language(301), filename)

                    if status == 200:
                        if self.xbmcvfs.exists(item["path_incomplete"]):
                            self.common.log("Moving %s to %s" % (repr(item["path_incomplete"]), repr(item["path_complete"])))
                            self.xbmcvfs.rename(item["path_incomplete"], item["path_complete"])
                            self._showMessage(self.language(203), filename)
                        else:
                            self.common.log("Download complete, but file %s not found" % repr(item["path_incomplete"]))
                            self._showMessage(self.language(204), "ERROR")
                    elif status != 300:
                        self.common.log("Failure: " + repr(item) + " - " + repr(status))
                        self._showMessage(self.language(204), self.language(302))

                    if status == 300:
                        item = False
                    else:
                        self._removeItemFromQueue(filename)
                        item = self._getNextItemFromQueue()
                        if item:
                            (filename, item) = item

                self.common.log("Finished download queue.")
                self.cache.set("StopQueue", "")
                if self.dialog:
                    self.dialog.close()
                    self.common.log("Closed dialog")
                self.dialog = u""

    def _runCommand(self, args):
        self.common.log(" ".join(args))
        try:
            proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            self.cur_dl["proc"] =  proc
        except:
            self.common.log("Couldn't run command")
            return False
        else:
            self.common.log("Returning process", 5)
            return proc

    def _readPipe(self, proc):
        self.common.log("", 50)
        try:
            return proc.communicate()[0]
        except:
            return ""

    def _rtmpDetectArgs(self, probe_args, item):
        get = item.get
        self.common.log("")

        if get("url"):
            probe_args += ["--rtmp", get("url")]
        elif get("rtmp"):
            probe_args += ["--rtmp", get("url")]
            
        if get("host"):
            probe_args += ["--host", get("host")]
            
        if get("port"):
            probe_args += ["--port", get("port")]

        if get("protocol"):
            probe_args += ["--protocol", get("protocol")]

        if get("app"):
            probe_args += ["--app", get("app")]

        if get("tcUrl"):
            probe_args += ["--tcUrl", get("tcUrl")]

        if get("pageUrl"):
            probe_args += ["--pageUrl", get("pageUrl")]

        if get("swfUrl"):
            probe_args += ["--swfUrl", get("swfUrl")]

        if get("flashVer"):
            probe_args += ["--flashVer", get("flashVer")]

        if get("auth"):
            probe_args += ["--auth", get("auth")]

        if get("conn"):
            probe_args += ["--conn", get("conn")]

        if get("playpath"):
            probe_args += ["--playpath", get("playpath")]

        if get("playlist"):
            probe_args += ["--playlist"]

        if get("live"):
            probe_args += ["--live"]

        if get("subscribe"):
            probe_args += ["--subscribe", get("subscribe")]

        if get("resume"):
            probe_args += ["--resume"]

        if get("skip"):
            probe_args += ["--skip", get("skip")]

        if get("start"):
            probe_args += ["--start", get("start")]

        if get("stop") and "--stop" not in probe_args:
            probe_args += ["--stop", str(get("stop"))]
        elif get("duration") and "--stop" not in probe_args:
            probe_args += ["--stop", str(get("duration"))]

        if get("buffer"):
            probe_args += ["--buffer", get("buffer")]

        if get("timeout"):
            probe_args += ["--timeout", get("timeout")]

        if get("token"):
            probe_args += ["--token", get("token")]

        if get("swfhash"):
            probe_args += ["--swfhash", get("swfhash")]

        if get("swfsize"):
            probe_args += ["--swfsize", get("swfsize")]

        if get("player_url"):
            probe_args += ["--swfVfy", get("player_url")]
        elif get("swfVfy"):
            probe_args += ["--swfVfy", get("player_url")]

        if get("swfAge"):
            probe_args += ["--swfAge", get("swfAge")]

        self.common.log("Done: " + repr(probe_args))
        return probe_args

    def _detectStream(self, filename, item):
        get = item.get
        self.common.log(get("url"))

        # RTMPDump
        if get("url").find("rtmp") > -1 or get("use_rtmpdump"):
            self.common.log("Trying rtmpdump")
            # Detect filesize
            probe_args = [self.rtmp_binary, "--stop", "1"]

            probe_args = self._rtmpDetectArgs(probe_args, item)

            proc = self._runCommand(probe_args)
            if proc:
                output = ""
                now = time.time()
                while not proc.poll():
                    temp_output = self._readPipe(proc)
                    output += temp_output
                    if now + 15 < time.time() or output.find("Starting") > -1:
                        self.common.log("Breaking, duration: " + repr(time.time() - now))
                        break

                if output.find("Starting") > -1:  # If download actually started
                    if output.find("filesize") > -1:
                        item["total_size"] = int(float(output[output.find("filesize") + len("filesize"):output.find("\n", output.find("filesize"))]))
                    elif get("live"):
                        item["total_size"] = 0

                    cmd_call = self._rtmpDetectArgs([self.rtmp_binary], item)

                    cmd_call += ["--flv", item["path_incomplete"]]
                    item["cmd_call"] = cmd_call

                try:
                    proc.kill()
                except:
                    pass

        # VLC
        # Fix getting filesize
        if ("total_size" not in item and "cmd_call" not in item) or get("use_vlc"):
            self.common.log("Trying vlc")
            # Detect filesize
            probe_args = [self.vlc_binary, "-I", "dummy", "-v", "-v", "--stop-time", "1", "--sout", "file/avi:" + item["path_incomplete"], item["url"], "vlc://quit"]

            proc = self._runCommand(probe_args)
            if proc:
                output = ""
                now = time.time()
                while not proc.poll():
                    temp_output = self._readPipe(proc)
                    output += temp_output
                    if now + 15 < time.time() or output.find(get("url") + "' successfully opened") > -1:
                        self.common.log("Breaking, duration: " + repr(time.time() - now))
                        break

                if output.find(get("url") + "' successfully opened") > -1:
                    if output.find("media_length:") > -1 and False:
                        item["total_size"] = int(float(output[output.find("media_length:") + len("media_length:"):output.find("s", output.find("media_length:"))]))
                    elif get("live"):
                        item["total_size"] = 0

                    # Download args
                    cmd_call = [self.vlc_binary, "-v", "-v", "-I", "dummy", "--sout", "file/avi:" + get("path_incomplete")]

                    if "duration" in item:
                        cmd_call += ["--stop-time", str(get("duration"))]

                    cmd_call += [get("url"), "vlc://quit"]
                    item["cmd_call"] = cmd_call

                try:
                    proc.kill()
                except:
                    pass

        # Mplayer
        # -endpos doesn't work with dumpstream.
        if ("total_size" not in item and "cmd_call" not in item) or get("use_mplayer"):
            self.common.log("Trying mplayer")
            # Detect filesize
            probe_args = [self.mplayer_binary, "-v", "-endpos", "1", "-vo", "null", "-ao", "null", get("url")]

            proc = self._runCommand(probe_args)
            if proc:
                output = ""
                now = time.time()
                while not proc.poll():
                    temp_output = self._readPipe(proc)
                    output += temp_output
                    if now + 15 < time.time() or output.find("Starting playback") > -1:
                        self.common.log("Breaking, duration: " + repr(time.time() - now))
                        break

                if output.find("Starting playback") > -1:
                    if output.find("filesize") > -1:
                        item["total_size"] = int(float(output[output.find("filesize: ") + len("filesize: "):output.find("\n", output.find("filesize: "))]))
                    elif get("live"):
                        item["total_size"] = 0

                    item["cmd_call"] = [self.mplayer_binary, "-v", "-dumpstream", "-dumpfile", item["path_incomplete"], get("url")]

                try:
                    proc.kill()
                except:
                    pass

        if not "total_size" in item:
            item["total_size"] = 0

    def _stopCurrentDownload(self):
        self.common.log("")
        if "proc" in self.cur_dl:
            self.common.log("Killing: " + repr(self.cur_dl))
            proc = self.cur_dl["proc"]
            try:
                proc.kill()
                self.common.log("Killed")
            except:
                self.common.log("Couldn't kill")
        self.common.log("Done")

    def _downloadStream(self, filename, item):
        get = item.get
        self.common.log(filename)
        self.common.log(get("cmd_call"))


        same_bytes_count = 0
        retval = 1

        params = {"bytes_so_far": 0, "mark": 0.0, "queue_mark": 0.0, "obytes_so_far": 0}
        item["percent"] = 0.1
        item["old_percent"] = -1
        delay = 0.3
        stall_timeout = self.settings.getSetting("stall_timeout")
        proc = self._runCommand(get("cmd_call"))
        output = ""
        if proc:
            while proc.returncode == None and "quit" not in params:
                temp_output = proc.stdout.read(23) 
                if len(output) > 10000:
                    output = output[0:500] + "\r\n\r\n\r\n"
                output += temp_output

                if self.xbmcvfs.exists(item["path_incomplete"]):
                    params["bytes_so_far"] = os.path.getsize(item["path_incomplete"])
                    if params["mark"] == 0.0 and params["bytes_so_far"] > 0:
                        params["mark"] = time.time()
                        self.common.log("Mark set")

                if params["bytes_so_far"] == params["obytes_so_far"]:
                    if same_bytes_count == 0:
                        now = time.time()
                    same_bytes_count += 1
                    #if delay < 3:
                    #    delay = delay * 1.2

                    if same_bytes_count >= 300 and (item["total_size"] != 0 or params["bytes_so_far"] != 0) and (now + int(stall_timeout) < time.time()):
                        self.common.log("Download complete. Same bytes for 300 times in a row.")
                        if (item["total_size"] > 0 and item["total_size"] * 0.998 < params["bytes_so_far"]):
                            self.common.log("Size disrepancy: " + str(item["total_size"] - params["bytes_so_far"]))
                        retval = 0
                        break
                    else:
                        self.common.log("Sleeping: " + str(delay) + " - " + str(params["bytes_so_far"]), 5)
                        time.sleep(delay)
                        continue
                else:
                    same_bytes_count = 0
                    #if delay > 0.3:
                    #    delay = delay * 0.8
                    self.common.log("Bytes updated: " + str(delay) + " - " + str(params["bytes_so_far"]), 5)

                self.common.log("bytes_so_far : " + str(params["bytes_so_far"]), 5)

                self._generatePercent(item, params)

                if "duration" in item and repr(get("cmd_call")).find("mplayer") > -1 and item["percent"] > 105:
                    self.common.log("Mplayer over percentage %s. Killing! " % repr(item["percent"]))
                    retval = 0
                    proc.kill()
                    break
     
                if item["percent"] > item["old_percent"] or time.time() - params["queue_mark"] > 3:
                    self._updateProgress(filename, item, params)
                    item["old_percent"] = item["percent"]

                if params["bytes_so_far"] >= item["total_size"] and item["total_size"] != 0:
                    self.common.log("Download complete. Matched size")
                    retval = 0
                    break

                if "duration" in item and params["mark"] > 0.0 and (params["mark"] + int(get("duration")) + 10 < time.time()) and False:
                    self.common.log("Download complete. Over duration.")
                    retval = 0
                    break

                # Some rtmp streams seem abort after ~ 99.8%. Don't complain for those.
                if (item["total_size"] != 0 and get("url").find("rtmp") > -1 and item["total_size"] * 0.998 < params["bytes_so_far"]):
                    self.common.log("Download complete. Size disrepancy: " + str(item["total_size"] - params["bytes_so_far"]) + " - " + str(same_bytes_count))
                    retval = 0
                    break

                params["obytes_so_far"] = params["bytes_so_far"]
            
            try:
                output += proc.stdout.read()
                proc.kill()
            except:
                pass

        if "quit" in params:
            self.common.log("Download aborted.")
            return 300
        if retval == 1:
            self.common.log("Download failed, binary output: %s" % output)
            return 500

        self.common.log("Done")
        return 200

    def _downloadURL(self, filename, item):
        self.common.log(filename)

        url = urllib2.Request(item["url"])
        if "useragent" in item:
            url.add_header("User-Agent", item["useragent"])
        else:
            url.add_header("User-Agent", self.common.USERAGENT)

        file = self.common.openFile(item["path_incomplete"], "wb")
        con = urllib2.urlopen(url)

        item["total_size"] = 0
        chunk_size = 1024 * 8

        if con.info().getheader("Content-Length").strip():
            item["total_size"] = int(con.info().getheader("Content-Length").strip())

        params = {"bytes_so_far": 0, "mark": 0.0, "queue_mark": 0.0, "obytes_so_far": 0}
        item["percent"] = 0.1
        item["old_percent"] = -1
        try:
            while "quit" not in params:
                chunk = con.read(chunk_size)
                file.write(chunk)
                params["bytes_so_far"] += len(chunk)

                if params["mark"] == 0.0 and params["bytes_so_far"] > 0:
                    params["mark"] = time.time()
                    self.common.log("Mark set")

                self._generatePercent(item, params)

                self.common.log("recieved chunk: %s - %s" % ( repr(item["percent"] > item["old_percent"]), repr(time.time() - params["queue_mark"])), 4)
                if item["percent"] > item["old_percent"] or time.time() - params["queue_mark"] > 30:
                    self._run_async(self._updateProgress(filename, item, params))

                    item["old_percent"] = item["percent"]

                params["obytes_so_far"] = params["bytes_so_far"]

                if not chunk:
                    break
            self.common.log("Loop done")

            con.close()
            file.close()
        except:
            self.common.log("Download failed.")
            try:
                con.close()
            except:
                self.common.log("Failed to close download stream")

            try:
                file.close()
            except:
                self.common.log("Failed to close file handle")

            self._showMessage(self.language(204), "ERROR")
            return 500

        if "quit" in params:
            self.common.log("Download aborted.")
            return 300

        self.common.log("Done")
        return 200

    def _convertSecondsToHuman(self, seconds):
        seconds = int(seconds)
        if seconds < 60:
            return "~%ss" % (seconds)
        elif seconds < 3600:
            return "~%sm" % (seconds / 60)

    def _generatePercent(self, item, params):
        self.common.log("", 5)
        get = params.get
        iget = item.get

        new_delta = False
        if "last_delta" in item:
            if time.time() - item["last_delta"] > 0.2:
                new_delta = True
        else:
            item["last_delta"] = 0.0
            new_delta = True

        if item["total_size"] > 0 and new_delta:
            self.common.log("total_size", 5)
            item["percent"] = float(get("bytes_so_far")) / float(item["total_size"]) * 100
        elif iget("duration") and get("mark") != 0.0 and new_delta:
            time_spent = time.time() - get("mark")
            item["percent"] = time_spent / int(iget("duration")) * 100
            self.common.log("Time spent: %s. Duration: %s. Time left: %s (%s)" % (int(time_spent), int(iget("duration")),
                                                                                  int(int(iget("duration")) - time_spent),
                                                                                  self._convertSecondsToHuman(int(iget("duration")) - time_spent)), 5)

        elif new_delta:
            self.common.log("cycle - " + str(time.time() - item["last_delta"]), 5)
            delta = time.time() - item["last_delta"]
            if delta > 10 or delta < 0:
                delta = 5

            item["percent"] = iget("old_percent") + delta
            if item["percent"] >= 100:
                item["percent"] -= 100
                item["old_percent"] = item["percent"]

        if new_delta:
            item["last_delta"] = time.time()

    def _getQueue(self):
        self.common.log("")
        queue = self.cache.get("SimpleDownloaderQueue")

        try:
                items = eval(queue)
        except:
            items = {}

        self.common.log("Done: " + str(len(items)))
        return items

    def _updateProgress(self, filename, item, params):
        self.common.log("", 3)
        get = params.get
        iget = item.get
        queue = False
        new_mark = time.time()

        if new_mark == get("mark"):
            speed = 0
        else:
            speed = int((get("bytes_so_far") / 1024) / (new_mark - get("mark")))

        if new_mark - get("queue_mark") > 1.5:
            queue = self.cache.get("SimpleDownloaderQueue")
            self.queue = queue
        elif hasattr(self, "queue"):
            queue = self.queue

        self.common.log("eval queue", 2)

        try:
            items = eval(queue)
        except:
            items = {}

        if new_mark - get("queue_mark") > 1.5:
            heading = u"[%s] %sKb/s (%.2f%%)" % (len(items), speed, item["percent"])
            self.common.log("Updating %s - %s" % (heading, self.common.makeUTF8(filename)), 2)
            params["queue_mark"] = new_mark

        if self.xbmc.Player().isPlaying() and self.xbmc.getCondVisibility("VideoPlayer.IsFullscreen"):
            if self.dialog:
                self.dialog.close()
                self.dialog = u""
        else:
            if not self.dialog:
                self.dialog = DialogDownloadProgress.DownloadProgress()
                self.dialog.create(self.language(201), "")

            heading = u"[%s] %s - %.2f%%" % (len(items), self.language(202), item["percent"])

            if iget("Title"):
                self.dialog.update(percent=item["percent"], heading=heading, label=iget("Title"))
            else:
                self.dialog.update(percent=item["percent"], heading=heading, label=filename)
        self.common.log("Done", 3)

    #============================= Download Queue =================================
    def _getNextItemFromQueue(self):
        if self.cache.lock("SimpleDownloaderQueueLock"):
            items = []

            queue = self.cache.get("SimpleDownloaderQueue")
            self.common.log("queue loaded : " + repr(queue))

            if queue:
                try:
                    items = eval(queue)
                except:
                    items = False

                item = {}
                if len(items) > 0:
                    item = items[0]
                    self.common.log("returning : " + item[0])

                self.cache.unlock("SimpleDownloaderQueueLock")
                if items:
                    return item
                else:
                    return False
            else:
                self.common.log("Couldn't aquire lock")

    def _addItemToQueue(self, filename, params={}):
        if self.cache.lock("SimpleDownloaderQueueLock"):

            items = []
            if filename:
                queue = self.cache.get("SimpleDownloaderQueue")
                self.common.log("queue loaded : " + repr(queue), 3)

                if queue:
                    try:
                        items = eval(queue)
                    except:
                        items = []

                append = True
                for index, item in enumerate(items):
                    (item_id, item) = item
                    if item_id == filename:
                        append = False
                        del items[index]
                        break

                if append:
                    items.append((filename, params))
                    self.common.log("Added: " + filename + " to queue - " + str(len(items)))
                else:
                    items.insert(1, (filename, params)) # 1 or 0?
                    self.common.log("Moved " + filename + " to front of queue. - " + str(len(items)))

                self.cache.set("SimpleDownloaderQueue", repr(items))

                self.cache.unlock("SimpleDownloaderQueueLock")
                self.common.log("Done")
        else:
            self.common.log("Couldn't lock")

    def _removeItemFromQueue(self, filename):
        if self.cache.lock("SimpleDownloaderQueueLock"):
            items = []

            queue = self.cache.get("SimpleDownloaderQueue")
            self.common.log("queue loaded : " + repr(queue), 3)

            if queue:
                try:
                    items = eval(queue)
                except:
                    items = []

                for index, item in enumerate(items):
                    (item_id, item) = item
                    if item_id == filename:
                        del items[index]
                        self.cache.set("SimpleDownloaderQueue", repr(items))
                        self.common.log("Removed: " + filename + " from queue")

                self.cache.unlock("SimpleDownloaderQueueLock")
                self.common.log("Done")
            else:
                self.common.log("Exception")

    def movieItemToPosition(self, filename, position):
        if position > 0 and  self.cache.lock("SimpleDownloaderQueueLock"):
            items = []
            if filename:
                queue = self.cache.get("SimpleDownloaderQueue")
                self.common.log("queue loaded : " + repr(queue), 3)

                if queue:
                    try:
                        items = eval(queue)
                    except:
                        items = []

                    self.common.log("pre items: %s " % repr(items), 3)
                    for index, item in enumerate(items):
                        (item_id, item) = item
                        if item_id == filename:
                            print "FOUND ID"
                            del items[index]
                            items = items[:position] + [(filename, item)] + items[position:]
                            break
                    self.common.log("post items: %s " % repr(items), 3)

                    self.cache.set("SimpleDownloaderQueue", repr(items))

                    self.cache.unlock("SimpleDownloaderQueueLock")
                    self.common.log("Done")
        else:
            self.common.log("Couldn't lock")

    def isRTMPInstalled(self):
        basic_args = ["rtmpdump", "-V"]

        try:
            p = subprocess.Popen(basic_args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            output = p.communicate()[1]
            return output.find("RTMPDump") > -1
        except:
            return False

    def isVLCInstalled(self):
        basic_args = ["vlc", "--version"]

        try:
            p = subprocess.Popen(basic_args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            output = p.communicate()[0]
            self.common.log(repr(output))
            return output.find("VLC") > -1
        except:
            return False

    def isMPlayerInstalled(self):
        basic_args = ["mplayer"]

        try:
            p = subprocess.Popen(basic_args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            output = p.communicate()[0]
            self.common.log(repr(output))
            return output.find("MPlayer") > -1
        except:
            return False

    def _run_async(self, func, *args, **kwargs):
        from threading import Thread
        worker = Thread(target=func, args=args, kwargs=kwargs)
        self.__workersByName[worker.getName()] = worker
        worker.start()
        return worker

    # Shows a more user-friendly notification
    def _showMessage(self, heading, message):
        self.xbmc.executebuiltin((u'XBMC.Notification("%s", "%s", %s)' % (heading, self.common.makeUTF8(message), self.notification_length)).encode("utf-8"))

########NEW FILE########
__FILENAME__ = storageserverdummy
'''
     StorageServer override.
     Version: 1.0
'''


class StorageServer():
    def __init__(self, table=False):
        return None

    def cacheFunction(self, funct=False, *args):
        return funct(*args)

    def set(self, name, data):
        return ""

    def get(self, name):
        return ""

    def setMulti(self, name, data):
        return ""

    def getMulti(self, name, items):
        return ""

    def lock(self, name):
        return False

    def unlock(self, name):
        return False

########NEW FILE########
__FILENAME__ = TestYouTubeDiscoScraper
import BaseTestCase
import nose

class TestYouTubeDiscoScraper(BaseTestCase.BaseTestCase):
    def test_plugin_should_scrape_disco_search_video_list_correctly(self):
        self.navigation.listMenu({"scraper": "search_disco", "search": "Lady Gaga", "path": "/root/explore/music/disco/new"})

        self.assert_directory_count_greater_than_or_equals(10)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_contains_almost_only_unique_video_items()
        self.assert_directory_items_should_have_external_thumbnails()

if __name__ == "__main__":
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubeDownloader
# -*- coding: utf-8 -*-
import BaseTestCase
import nose
import sys
import os
from mock import Mock


class TestYouTubeDownloader(BaseTestCase.BaseTestCase):

    def test_plugin_should_download_standard_videos(self):
        sys.modules["__main__"].xbmcvfs.rename.side_effect = os.rename
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].downloader._getNextItemFromQueue = Mock()
        (video, status) = sys.modules["__main__"].player.buildVideoObject({"action": "download", "videoid": "54VJWHL2K3I"})
        video["download_path"] = "./tmp/"
        video["url"] = video["video_url"]
        sys.modules["__main__"].downloader._getNextItemFromQueue.side_effect = [("Roll a D6-[54VJWHL2K3I].mp4", video), {}]

        self.navigation.executeAction({"action": "download", "videoid": "54VJWHL2K3I", "async": "false"})
        assert(os.path.exists('./tmp/Roll a D6-[54VJWHL2K3I].mp4'))
        assert(os.path.getsize('./tmp/Roll a D6-[54VJWHL2K3I].mp4') > 100)

    def ttest_plugin_should_download_with_subtitles_when_available(self):
        sys.modules["__main__"].xbmcvfs.rename.side_effect = os.rename
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings.xml")
        sys.modules["__main__"].downloader._getNextItemFromQueue = Mock()
        (video, status) = sys.modules["__main__"].player.buildVideoObject({"action": "download", "videoid": "bUcszN8jRB8"})
        video["download_path"] = "./tmp/"
        video["url"] = video["video_url"]
        sys.modules["__main__"].downloader._getNextItemFromQueue.side_effect = [("Morning Dew  a bad lip reading of Bruno Mars, feat. Lady Gaga and Jay-Z-[bUcszN8jRB8].mp4", video), {}]

        self.navigation.executeAction({"action": "download", "videoid": "bUcszN8jRB8", "async": "false"})

        assert(os.path.exists('./tmp/Morning Dew  a bad lip reading of Bruno Mars, feat. Lady Gaga and Jay-Z-[bUcszN8jRB8].mp4'))
        assert(os.path.exists('./tmp/Morning Dew  a bad lip reading of Bruno Mars, feat. Lady Gaga and Jay-Z-[bUcszN8jRB8].ssa'))
        assert(os.path.getsize('./tmp/Morning Dew  a bad lip reading of Bruno Mars, feat. Lady Gaga and Jay-Z-[bUcszN8jRB8].mp4') > 100)
        assert(os.path.getsize('./tmp/Morning Dew  a bad lip reading of Bruno Mars, feat. Lady Gaga and Jay-Z-[bUcszN8jRB8].ssa') > 100)

if __name__ == "__main__":
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubeFolderStructure
import BaseTestCase
import nose
import sys


class TestYouTubeFolderStructure(BaseTestCase.BaseTestCase):

    def test_plugin_should_list_advanced_folder_structure_when_user_is_logged_in(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings.xml")
        sys.modules["__main__"].settings.setSetting("oauth2_access_token", "some_token")

        self.navigation.listMenu()

        # we probably need some better asserts here
        self.assert_directory_count_greater_than_or_equals(10)
        self.assert_directory_count_less_than_or_equals(50)
        self.assert_directory_is_a_folder_list()

    def test_plugin_should_list_basic_folder_structure_when_user_is_not_logged_in(self):
        self.navigation.listMenu()

        # we probably need some better asserts here
        self.assert_directory_count_greater_than_or_equals(3)
        self.assert_directory_count_less_than_or_equals(10)
        self.assert_directory_is_a_folder_list()

    def test_plugin_should_list_subfolders_when_user_navigates_to_a_folder(self):
        self.navigation.listMenu({"path": "/root/explore"})

        # we probably need some better asserts here
        self.assert_directory_count_greater_than_or_equals(4)
        self.assert_directory_count_less_than_or_equals(10)
        self.assert_directory_is_a_folder_list()

if __name__ == "__main__":
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubeLogin
import BaseTestCase
import nose
import sys
import time


class TestYouTubeLogin(BaseTestCase.BaseTestCase):
    totp = ""

    def test_plugin_should_perform_basic_login_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings.xml")

        assert(sys.modules["__main__"].settings.getSetting("auth") == "")

        print "username: " + sys.modules["__main__"].settings.getSetting("username")
        print "pass: " + sys.modules["__main__"].settings.getSetting("user_password")
        print "oauth2_access_token: " + sys.modules["__main__"].settings.getSetting("oauth2_access_token")

        self.navigation.executeAction({"action": "settings"})

        oauth2_access_token = sys.modules["__main__"].settings.getSetting("oauth2_access_token")
        login_cookies = sys.modules["__main__"].settings.getSetting("login_cookies")
        print "username: " + sys.modules["__main__"].settings.getSetting("username")
        print "pass: " + sys.modules["__main__"].settings.getSetting("user_password")
        print "oauth2_access_token: " + oauth2_access_token + " - " + str(len(oauth2_access_token))
        print "login_cookies: " + login_cookies + " - " + str(len(login_cookies))
        assert(len(oauth2_access_token) > 40)

    def test_plugin_should_perform_unlinked_login_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/unlinked-login-settings.xml")

        assert(sys.modules["__main__"].settings.getSetting("auth") == "")

        print "username: " + sys.modules["__main__"].settings.getSetting("username")
        print "pass: " + sys.modules["__main__"].settings.getSetting("user_password")
        print "oauth2_access_token: " + sys.modules["__main__"].settings.getSetting("oauth2_access_token")

        self.navigation.executeAction({"action": "settings"})

        oauth2_access_token = sys.modules["__main__"].settings.getSetting("oauth2_access_token")
        print "username: " + sys.modules["__main__"].settings.getSetting("username")
        print "pass: " + sys.modules["__main__"].settings.getSetting("user_password")
        print "oauth2_access_token: " + oauth2_access_token + " - " + str(len(oauth2_access_token))
        assert(len(oauth2_access_token) > 40)

    def test_plugin_should_perform_basic_2factor_login_correctly(self):
        import pyotp
        self.totp = pyotp.TOTP("fbfkkk27ffmaihzg")
        self.lastpin = False

        sys.modules["__main__"].settings.load_strings("./resources/2factor-login-settings.xml")
        tmp = sys.modules["__main__"].xbmcgui.Dialog()
        tmp.numeric.side_effect = self.generatePin

        assert(sys.modules["__main__"].settings.getSetting("auth") == "")

        print "username: " + sys.modules["__main__"].settings.getSetting("username")
        print "pass: " + sys.modules["__main__"].settings.getSetting("user_password")
        print "oauth2_access_token: " + sys.modules["__main__"].settings.getSetting("oauth2_access_token")

        self.navigation.executeAction({"action": "settings"})

        oauth2_access_token = sys.modules["__main__"].settings.getSetting("oauth2_access_token") 
        print "username: " + sys.modules["__main__"].settings.getSetting("username")
        print "pass: " + sys.modules["__main__"].settings.getSetting("user_password")
        print "oauth2_access_token: " + oauth2_access_token + " - " + str(len(oauth2_access_token))
        assert(len(oauth2_access_token) > 40)

    def test_plugin_should_perform_googleplus_login_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-plus.xml")

        assert(sys.modules["__main__"].settings.getSetting("auth") == "")

        print "username: " + sys.modules["__main__"].settings.getSetting("username")
        print "pass: " + sys.modules["__main__"].settings.getSetting("user_password")
        print "oauth2_access_token: " + sys.modules["__main__"].settings.getSetting("oauth2_access_token")

        self.navigation.executeAction({"action": "settings"})

        oauth2_access_token = sys.modules["__main__"].settings.getSetting("oauth2_access_token")
        print "username: " + sys.modules["__main__"].settings.getSetting("username")
        print "pass: " + sys.modules["__main__"].settings.getSetting("user_password")
        print "oauth2_access_token: " + oauth2_access_token + " - " + str(len(oauth2_access_token))
        assert(len(oauth2_access_token) > 40)

    def test_plugin_should_perform_googleplus_login_with_page_administrator_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-plus-page.xml")

        assert(sys.modules["__main__"].settings.getSetting("auth") == "")

        print "username: " + sys.modules["__main__"].settings.getSetting("username")
        print "pass: " + sys.modules["__main__"].settings.getSetting("user_password")
        print "oauth2_access_token: " + sys.modules["__main__"].settings.getSetting("oauth2_access_token")

        self.navigation.executeAction({"action": "settings"})

        oauth2_access_token = sys.modules["__main__"].settings.getSetting("oauth2_access_token")
        print "username: " + sys.modules["__main__"].settings.getSetting("username")
        print "pass: " + sys.modules["__main__"].settings.getSetting("user_password")
        print "oauth2_access_token: " + oauth2_access_token + " - " + str(len(oauth2_access_token))
        assert(len(oauth2_access_token) > 40)

    def generatePin(self, *args, **kwargs):
        userpin = str(self.totp.at(time.time()))
        while len(userpin) < 6:
            userpin = "0" + userpin

        if userpin == self.lastpin:
            time.sleep(15)
            return self.generatePin(args, kwargs)
        print "GENERATED PIN : " + str(userpin)
        return userpin

if __name__ == "__main__":
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubePlayer
# -*- coding: utf-8 -*-
import BaseTestCase
import nose
import sys
from mock import Mock


class TestYouTubePlayer(BaseTestCase.BaseTestCase):

    def test_plugin_should_play_standard_videos(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].cache.getMulti.return_value = ["7"]

        self.navigation.executeAction({"action": "play_video", "videoid": "54VJWHL2K3I"})

        args = sys.modules["__main__"].xbmcplugin.setResolvedUrl.call_args_list
        print "url: " + repr(sys.modules["__main__"].xbmcgui.ListItem.call_args_list)
        print "Args: " + repr(args)
        print repr("listitem" in args[0][1])
        print repr(args[0][1]["handle"] == -1)
        print repr(args[0][1]["succeeded"] == True)

        assert("listitem" in args[0][1])
        assert(args[0][1]["handle"] == -1)
        assert(args[0][1]["succeeded"] == True)

    def test_plugin_should_play_standard_videos_flashvars_fallback(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].cache.getMulti.return_value = ["7"]

        self.navigation.executeAction({"action": "play_video", "videoid": "54VJWHL2K3I", "use_flashvars": "true"})

        args = sys.modules["__main__"].xbmcplugin.setResolvedUrl.call_args_list
        print "url: " + repr(sys.modules["__main__"].xbmcgui.ListItem.call_args_list)
        print "Args: " + repr(args)
        print repr("listitem" in args[0][1])
        print repr(args[0][1]["handle"] == -1)
        print repr(args[0][1]["succeeded"] == True)

        assert("listitem" in args[0][1])
        assert(args[0][1]["handle"] == -1)
        assert(args[0][1]["succeeded"] == True)

    def test_plugin_should_play_standard_videos_embed_fallback(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].cache.getMulti.return_value = ["7"]

        self.navigation.executeAction({"action": "play_video", "videoid": "54VJWHL2K3I", "embed": "true"})

        args = sys.modules["__main__"].xbmcplugin.setResolvedUrl.call_args_list
        print "url: " + repr(sys.modules["__main__"].xbmcgui.ListItem.call_args_list)
        print "Args: " + repr(args)
        print repr("listitem" in args[0][1])
        print repr(args[0][1]["handle"] == -1)
        print repr(args[0][1]["succeeded"] == True)

        assert("listitem" in args[0][1])
        assert(args[0][1]["handle"] == -1)
        assert(args[0][1]["succeeded"] == True)

    def test_plugin_should_play_live_vidoes(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].cache.getMulti.return_value = ["7"]

        self.navigation.executeAction({"action": "play_video", "videoid": "xrM34fdmloc"})

        args = sys.modules["__main__"].xbmcplugin.setResolvedUrl.call_args_list
        print "url: " + repr(sys.modules["__main__"].xbmcgui.ListItem.call_args_list)
        print "Args: " + repr(args)
        print repr("listitem" in args[0][1])
        print repr(args[0][1]["handle"] == -1)
        print repr(args[0][1]["succeeded"] == True)

        assert("listitem" in args[0][1])
        assert(args[0][1]["handle"] == -1)
        assert(args[0][1]["succeeded"] == True)

    def test_plugin_should_warn_on_restricted_videos_if_no_credentials(self):
        sys.modules["__main__"].settings.load_strings("./resources/settings.xml")
        sys.modules["__main__"].cache.getMulti.return_value = ["7"]
        sys.modules["__main__"].utils.showMessage = Mock()
        self.navigation.executeAction({"action": "play_video", "videoid": "Vzue74y7A84"})

        args = sys.modules["__main__"].utils.showMessage.call_args_list
        print "url: " + repr(sys.modules["__main__"].xbmcgui.ListItem.call_args_list)
        print "Args: " + repr(args)
        print repr(args[0][0][1] == "Playback requires valid YouTube account")

        assert(args[0][0][1] == "Playback requires valid YouTube account")

    def test_plugin_should_play_age_restricted_videos_if_user_provides_credentials(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].cache.getMulti.return_value = ["7"]

        self.navigation.executeAction({"action": "play_video", "videoid": "Vzue74y7A84"})

        args = sys.modules["__main__"].xbmcplugin.setResolvedUrl.call_args_list
        print "url: " + repr(sys.modules["__main__"].xbmcgui.ListItem.call_args_list)
        print "Args: " + repr(args)
        print repr("listitem" in args[0][1])
        print repr(args[0][1]["handle"] == -1)
        print repr(args[0][1]["succeeded"] == True)

        assert("listitem" in args[0][1])
        assert(args[0][1]["handle"] == -1)
        assert(args[0][1]["succeeded"] == True)

    def test_plugin_should_play_rtmpe_vidoes(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].cache.getMulti.return_value = ["7"]

        self.navigation.executeAction({"action": "play_video", "videoid": "8wxOVn99FTE"})

        args = sys.modules["__main__"].xbmcplugin.setResolvedUrl.call_args_list
        print "url: " + repr(sys.modules["__main__"].xbmcgui.ListItem.call_args_list)
        print "Args: " + repr(args)
        print repr("listitem" in args[0][1])
        print repr(args[0][1]["handle"] == -1)
        print repr(args[0][1]["succeeded"] == True)

        assert("listitem" in args[0][1])
        assert(args[0][1]["handle"] == -1)
        assert(args[0][1]["succeeded"] == True)

    def test_plugin_should_play_videos_with_subtitles_when_available(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].settings.setSetting("lang_code", "1")
        import os
        sys.modules["__main__"].xbmcvfs.exists.side_effect = os.path.exists
        sys.modules["__main__"].cache.getMulti.return_value = ["7"]
        self.navigation.executeAction({"action": "play_video", "videoid": "bUcszN8jRB8"})

        args = sys.modules["__main__"].xbmcplugin.setResolvedUrl.call_args_list
        args2 = sys.modules["__main__"].xbmc.Player().setSubtitles.call_args_list

        print "url: " + repr(sys.modules["__main__"].xbmcgui.ListItem.call_args_list)
        print "Args: " + repr(args)
        print "Args2: " + repr(args2)
        print repr("listitem" in args[0][1])
        print repr(args[0][1]["handle"] == -1)
        print repr(args[0][1]["succeeded"] == True)
        print repr(args2[0][0][0] == u"./tmp/Morning Dew  a bad lip reading of Bruno Mars, feat. Lady Gaga and Jay-Z-[bUcszN8jRB8]-EN.ssa")

        assert("listitem" in args[0][1])
        assert(args[0][1]["handle"] == -1)
        assert(args[0][1]["succeeded"] == True)
        assert(args2[0][0][0] == u"./tmp/Morning Dew  a bad lip reading of Bruno Mars, feat. Lady Gaga and Jay-Z-[bUcszN8jRB8]-EN.ssa")

    def test_plugin_should_play_videos_with_subtitles_and_annotation_when_available(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].settings.setSetting("lang_code", "1")
        import os
        sys.modules["__main__"].xbmcvfs.exists.side_effect = os.path.exists
        sys.modules["__main__"].cache.getMulti.return_value = ["7"]

        self.navigation.executeAction({"action": "play_video", "videoid": "YcQfiYUXrtI"})

        args = sys.modules["__main__"].xbmcplugin.setResolvedUrl.call_args_list
        args2 = sys.modules["__main__"].xbmc.Player().setSubtitles.call_args_list
        print "url: " + repr(sys.modules["__main__"].xbmcgui.ListItem.call_args_list)
        print "Args: " + repr(args)
        print "Args2: " + repr(args2)
        print repr("listitem" in args[0][1])
        print repr(args[0][1]["handle"] == -1)
        print repr(args[0][1]["succeeded"] == True)
        print repr(args2[0][0][0] == './tmp/Kicked Your Monkey  A Bad Lip Reading of Gotye\'s Somebody That I Used To Know-[YcQfiYUXrtI]-EN.ssa')

        assert("listitem" in args[0][1])
        assert(args[0][1]["handle"] == -1)
        assert(args[0][1]["succeeded"] == True)
        assert(args2[0][0][0] == './tmp/Kicked Your Monkey  A Bad Lip Reading of Gotye\'s Somebody That I Used To Know-[YcQfiYUXrtI]-EN.ssa')

    def test_plugin_should_play_video_with_subtitle_other_than_english(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].settings.setSetting("lang_code", "2")
        sys.modules["__main__"].cache.getMulti.return_value = ["7"]
        import os
        sys.modules["__main__"].xbmcvfs.exists.side_effect = os.path.exists

        self.navigation.executeAction({"action": "play_video", "videoid": "4Z9WVZddH9w"})

        args = sys.modules["__main__"].xbmcplugin.setResolvedUrl.call_args_list
        args2 = sys.modules["__main__"].xbmc.Player().setSubtitles.call_args_list
        print "url: " + repr(sys.modules["__main__"].xbmcgui.ListItem.call_args_list)
        print "Args: " + repr(args)
        print "Args2: " + repr(args2)
        print repr("listitem" in args[0][1])
        print repr(args[0][1]["handle"] == -1)
        print repr(args[0][1]["succeeded"] == True)
        print repr(args2[0][0][0] == u"./tmp/ZEITGEIST MOVING FORWARD  OFFICIAL RELEASE  2011-[4Z9WVZddH9w]-ES.ssa")

        assert("listitem" in args[0][1])
        assert(args[0][1]["handle"] == -1)
        assert(args[0][1]["succeeded"] == True)
        assert(args2[0][0][0] == u"./tmp/ZEITGEIST MOVING FORWARD  OFFICIAL RELEASE  2011-[4Z9WVZddH9w]-ES.ssa")

    def ttest_plugin_should_play_geolocked_videos(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].cache.getMulti.return_value = ["7"]
        import os
        sys.modules["__main__"].xbmcvfs.exists.side_effect = os.path.exists

        self.navigation.executeAction({"action": "play_video", "videoid": "ha_NOX_-Aeg"})

        args = sys.modules["__main__"].xbmcplugin.setResolvedUrl.call_args_list
        print "url: " + repr(sys.modules["__main__"].xbmcgui.ListItem.call_args_list)
        print "Args: " + repr(args)
        print repr("listitem" in args[0][1])
        print repr(args[0][1]["handle"] == -1)
        print repr(args[0][1]["succeeded"] == True)

        assert("listitem" in args[0][1])
        assert(args[0][1]["handle"] == -1)
        assert(args[0][1]["succeeded"] == True)

if __name__ == "__main__":
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubePlaylists
import BaseTestCase
import nose
import sys


class TestYouTubePlaylists(BaseTestCase.BaseTestCase):

    def test_plugin_should_queue_playlist_and_start_playback_if_user_selects_play_all_in_playlist(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        self.navigation.executeAction({"action": "play_all", "videoid": "Q7GVSx7yMaA", "playlist": "E3E0C28746217FA6"})

        self.assert_playlist_count_greater_than_or_equals(30)
        self.assert_directory_items_should_have_thumbnails()
        self.assert_playlist_contains_only_unique_video_items()
        self.assert_playlist_videos_does_not_contain("6CaawfTDBM8")
        self.assert_playlist_videos_contain("Q7GVSx7yMaA")

    def test_plugin_should_queue_playlist_and_start_playback_if_user_selects_play_all_outside_playlist(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        self.navigation.executeAction({"action": "play_all", "playlist": "E3E0C28746217FA6"})

        self.assert_playlist_count_greater_than_or_equals(30)
        self.assert_directory_items_should_have_thumbnails()
        self.assert_playlist_contains_only_unique_video_items()

    def test_plugin_should_queue_disco_search_and_start_playback_if_user_selects_play_all_outside_disco_search(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        self.navigation.executeAction({"action": "play_all", "scraper": "search_disco", "search": "Linkin Park"})

        self.assert_playlist_count_greater_than_or_equals(15)
        self.assert_directory_items_should_have_thumbnails()
        self.assert_playlist_contains_only_unique_video_items()

    def test_plugin_should_queue_disco_search_and_start_playback_if_user_selects_play_all_in_disco_search(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        self.navigation.executeAction({"action": "play_all", "scraper": "search_disco", "search": "Linkin Park", "videoid": "ysSxxIqKNN0"})

        self.assert_playlist_count_greater_than_or_equals(15)
        self.assert_directory_items_should_have_thumbnails()
        self.assert_playlist_contains_only_unique_video_items()
        self.assert_playlist_videos_contain("ysSxxIqKNN0")
        self.assert_playlist_videos_does_not_contain("pmUTBDuUGz8")

    def test_plugin_should_queue_user_watch_later_feed_if_user_selects_play_all_outside_list(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        self.navigation.executeAction({"action": "play_all", "user_feed": "watch_later"})

        self.assert_playlist_count_greater_than_or_equals(10)
        self.assert_directory_items_should_have_thumbnails()
        self.assert_playlist_contains_only_unique_video_items()

    def test_plugin_should_queue_user_new_subscriptions_feed_if_user_selects_play_all_on_external_user_outside_list(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        self.navigation.executeAction({"action": "play_all", "contact": "TobiasTheViking", "user_feed": "newsubscriptions"})

        self.assert_playlist_count_greater_than_or_equals(10)
        self.assert_directory_items_should_have_thumbnails()
        self.assert_playlist_contains_only_unique_video_items()

    def test_plugin_should_queue_users_liked_videos_if_user_selects_play_all_outside_list(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].settings.setSetting("cookies_saved", "false")

        self.navigation.executeAction({"action": "play_all", "scraper": "liked_videos", "login": "true"})

        self.assert_playlist_count_greater_than_or_equals(10)
        self.assert_directory_items_should_have_thumbnails()
        self.assert_playlist_contains_only_unique_video_items()

if __name__ == "__main__":
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubePublicFeeds
import BaseTestCase
import nose


class TestYouTubePublicFeedsScraper(BaseTestCase.BaseTestCase):
    def test_plugin_should_list_categories_folder_list_correctly(self):
        self.navigation.listMenu({"feed": "feed_categories", "path": "/root/explore/categories", "folder": "true"})

        self.assert_directory_count_greater_than_or_equals(10)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_folder_list()
        self.assert_directory_item_urls_contain("category")

    def test_plugin_should_list_category_video_list_correctly(self):
        self.navigation.listMenu({"feed": "feed_category", "path": "/root/explore/categories", "category": "Comedy"})

        self.assert_directory_count_greater_than_or_equals(30)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_contains_almost_only_unique_video_items()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_category_video_list_page_2_correctly(self):
        self.navigation.listMenu({"feed": "feed_category", "path": "/root/explore/categories", "category": "Comedy", "page": "1"})

        self.assert_directory_count_greater_than_or_equals(30)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_contains_almost_only_unique_video_items()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_live_video_list_correctly(self):
        self.navigation.listMenu({"feed": "feed_live", "path": "/root/explore/movies"})

        self.assert_directory_count_greater_than_or_equals(30)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_items_should_have_thumbnails()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_most_viewed_video_list_correctly(self):
        self.navigation.listMenu({"feed": "feed_viewed", "path": "/root/explore/movies"})

        self.assert_directory_count_greater_than_or_equals(10)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_most_linked_video_list_correctly(self):
        self.navigation.listMenu({"feed": "feed_linked", "path": "/root/explore/movies"})

        self.assert_directory_count_greater_than_or_equals(20)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_most_recent_videos_list_correctly(self):
        self.navigation.listMenu({"feed": "feed_recent", "path": "/root/explore/movies"})

        self.assert_directory_count_greater_than_or_equals(30)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_most_responded_video_list_correctly(self):
        self.navigation.listMenu({"feed": "feed_responded", "path": "/root/explore/movies"})

        self.assert_directory_count_greater_than_or_equals(30)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_most_share_video_list_correctly(self):
        self.navigation.listMenu({"feed": "feed_shared", "path": "/root/explore/movies"})

        self.assert_directory_count_greater_than_or_equals(30)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_top_featured_video_list_correctly(self):
        self.navigation.listMenu({"feed": "feed_featured", "path": "/root/explore/movies"})

        self.assert_directory_count_greater_than_or_equals(20)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_trending_video_list_correctly(self):
        self.navigation.listMenu({"feed": "feed_trending", "path": "/root/explore/movies"})

        self.assert_directory_count_greater_than_or_equals(30)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_top_favorited_video_list_correctly(self):
        self.navigation.listMenu({"feed": "feed_favorites", "path": "/root/explore/movies"})

        self.assert_directory_count_greater_than_or_equals(30)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_top_rated_video_list_correctly(self):
        self.navigation.listMenu({"feed": "feed_rated", "path": "/root/explore/movies"})

        self.assert_directory_count_greater_than_or_equals(30)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_search_video_list_correctly(self):
        self.navigation.listMenu({"feed": "search", "search": "Star Craft 2", "path": "/root/favorites"})

        self.assert_directory_count_greater_than_or_equals(30)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_contains_almost_only_unique_video_items()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_related_video_list_correctly(self):
        self.navigation.listMenu({"feed": "related", "videoid": "byv-wpqDydI", "path": "/root/favorites"})

        self.assert_directory_count_greater_than_or_equals(20)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_contains_almost_only_unique_video_items()
        self.assert_directory_items_should_have_external_thumbnails()

if __name__ == "__main__":
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubeStorageFolders
import BaseTestCase
import nose
import sys


class TestYouTubeStorageFolders(BaseTestCase.BaseTestCase):

    def test_plugin_should_list_stored_searches_folder_list_correctly(self):
        self.navigation.listMenu({"path": "/root/search/new", "feed": "search", "search": "Tuna"})
        self.navigation.listMenu({"path": "/root/search/new", "feed": "search", "search": "Tulip"})
        self.navigation.listMenu({"path": "/root/search/new", "feed": "search", "search": "Monkey"})
        self.reset_xbmc_mocks()

        self.navigation.listMenu({"path": "/root/search/", "store": "searches", "folder": "true"})

        print repr(sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list)
        self.assert_directory_item_urls_contain_at_least_one("Tuna")
        self.assert_directory_item_urls_contain_at_least_one("Tulip")
        self.assert_directory_item_urls_contain_at_least_one("Monkey")
        self.assert_directory_count_less_than_or_equals(4)
        self.assert_directory_count_greater_than_or_equals(3)
        self.assert_directory_is_a_folder_list()

if __name__ == "__main__":
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubeTrailersScraper
import BaseTestCase
import nose

class TestYouTubeShowsScraper(BaseTestCase.BaseTestCase):

    def test_plugin_should_scrape_trailers_top_100_playlist_and_video_list(self):

        self.navigation.listMenu({'login':"false" , 'feed':'uploads', 'contact':"trailers", "external":"true", "path": "/root/explore/trailers"})

        self.assert_directory_count_greater_than_or_equals(10)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_items_should_have_thumbnails()
        self.assert_directory_should_have_next_folder()

if __name__ == "__main__":
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubeUserActions
import BaseTestCase
import nose
import time
import sys
from mock import Mock


class TestYouTubeUserActions(BaseTestCase.BaseTestCase):
    def test_plugin_should_add_favorite(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        self.navigation.listMenu({"user_feed": "favorites", "login": "true", "path": "/root/favorites"})
        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list
        for arg in args:
            print repr(arg[1]["url"].find("f21TjSzgxjM") > -1)
            if arg[1]["url"].find("f21TjSzgxjM") > -1:
                result = sys.modules["__main__"].core._fetchPage({"link": "http://gdata.youtube.com/feeds/api/users/default/favorites?start-index=1&max-results=50", "auth": "true", "api": "true"})
                items = sys.modules["__main__"].core.getVideoInfo(result["content"])
                for item in items:
                    if item["videoid"] == "f21TjSzgxjM":
                        self.navigation.executeAction({"action": "remove_favorite", "editid": item["editid"]})

        self.navigation.executeAction({"action": "add_favorite", "videoid": "f21TjSzgxjM"})
        self.navigation.listMenu({"user_feed": "favorites", "login": "true", "path": "/root/favorites"})
        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list
        result = False
        for arg in args:
            print repr(arg[1]["url"].find("f21TjSzgxjM") > -1)
            if arg[1]["url"].find("f21TjSzgxjM") > -1:
                result = True
        assert(result)

    def test_plugin_should_remove_favorite(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        self.navigation.listMenu({"user_feed": "favorites", "login": "true", "path": "/root/favorites"})
        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list
        result = False
        for arg in args:
            #print repr(arg[1]["url"].find("7eiD38Av8fQ") > -1)
            if arg[1]["url"].find("7eiD38Av8fQ") > -1:
                result = True
        if not result:
            self.navigation.executeAction({"action": "add_favorite", "videoid": "7eiD38Av8fQ"})

        result = sys.modules["__main__"].core._fetchPage({"link": "http://gdata.youtube.com/feeds/api/users/default/favorites?start-index=1&max-results=50", "auth": "true", "api": "true"})
        items = sys.modules["__main__"].core.getVideoInfo(result["content"])
        editid = False
        for item in items:
            if item["videoid"] == "7eiD38Av8fQ":
                editid = item["editid"]

        if editid:
            self.navigation.executeAction({"action": "remove_favorite", "editid": editid})
            self.navigation.listMenu({"user_feed": "favorites", "login": "true", "path": "/root/favorites"})
            args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list
            print repr(args)
            for arg in args:
                assert(arg[1]["url"].find("7eiD38Av8fQ") == -1)
        else:
            assert(False)

    def ttest_plugin_should_add_subscription(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        #self.navigation.executeAction({"action": "add_subscription", "channel": "chuggaaconroy"})
        self.navigation.listMenu({"user_feed": "subscriptions", 'login': 'true', "path": "/root/subscriptions/something/smokey"})
        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list
        print repr(args)
        assert(False)

    def ttest_plugin_should_remove_subscription(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        self.navigation.executeAction({"action": "remove_subscription", "editid": "8wxOVn99FTE"})
        assert(False)

    def ttest_plugin_should_add_contact(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        self.navigation.executeAction({"action": "add_contact", "contact": "chuggaaconroy"})

        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in-10-perpage.xml")

        self.navigation.listMenu({"user_feed": "contacts", 'login': 'true', "path": "/root/contacts/smokey", "folder": "true"})

        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list
        print repr(args)
        assert(False)

    def ttest_plugin_should_remove_contact(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        self.navigation.executeAction({"action": "remove_contact", "contact": "chuggaaconroy"})
        assert(False)

    def ttest_plugin_should_add_to_playlist(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        result = sys.modules["__main__"].core._fetchPage({"link": "http://gdata.youtube.com/feeds/api/users/default/playlists?v=2.1&start-index=1&max-results=50", "auth": "true"})
        items = sys.modules["__main__"].core.getFolderInfo(result["content"])

        playlistid = False
        for item in items:
            print repr(item)
            if item["Title"] == "1":
                playlistid = item["editid"]

        if playlistid:
            self.navigation.executeAction({"action": "add_to_playlist", "videoid": "8wxOVn99FTE", "playlist": playlistid})
            assert(False)
        else:
            assert(False)

    def ttest_plugin_should_remove_from_playlist(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        result = sys.modules["__main__"].core._fetchPage({"link": "http://gdata.youtube.com/feeds/api/users/default/playlists?v=2.1&start-index=1&max-results=50", "auth": "true"})
        items = sys.modules["__main__"].core.getFolderInfo(result["content"])

        playlistid = False
        for item in items:
            print repr(item)
            if item["Title"] == "1":
                playlistid = item["editid"]

        result = sys.modules["__main__"].core._fetchPage({'link': 'http://gdata.youtube.com/feeds/api/playlists/' + playlistid + '?v=2.1&start-index=1&max-results=50', 'auth': 'true'})

        items = sys.modules["__main__"].core.getVideoInfo(result["content"])

        playlist_entry_id = False
        for item in items:
            print repr(item)
            if item["Title"] == "1":
                playlist_entry_id = item["playlist_entry_id"]

        if playlistid and playlist_entry_id:
            self.navigation.executeAction({"action": "remove_from_playlist", "playlist_entry_id": playlist_entry_id, "playlist": playlistid})
            assert(False)
        else:
            assert(False)

    def test_plugin_should_add_playlist(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        sys.modules["__main__"].xbmc.Keyboard().isConfirmed.return_value = True
        sys.modules["__main__"].common.getUserInput = Mock()
        sys.modules["__main__"].common.getUserInput.return_value = "testlist"

        result = sys.modules["__main__"].core._fetchPage({"link": "http://gdata.youtube.com/feeds/api/users/default/playlists?v=2.1&start-index=1&max-results=50", "auth": "true"})
        items = sys.modules["__main__"].core.getFolderInfo(result["content"])

        for item in items:
            if item["Title"] == "testlist":
                print "Deleting stale playlist with editid: %s" % item["editid"]
                self.navigation.executeAction({"action": "delete_playlist", "playlist": item["editid"]})

        self.navigation.executeAction({"action": "create_playlist", "title": "testlist", "summary": "test"})

        time.sleep(15)
        exists = False
        result = sys.modules["__main__"].core._fetchPage({"link": "http://gdata.youtube.com/feeds/api/users/default/playlists?v=2.1&start-index=1&max-results=50", "auth": "true"})
        items = sys.modules["__main__"].core.getFolderInfo(result["content"])

        for item in items:
            print repr(item) + " - looking for 'testlist'"
            if item["Title"] == "testlist":
                exists = True
        assert(exists)

    def test_plugin_should_remove_playlist(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].xbmc.Keyboard().isConfirmed.return_value = True
        sys.modules["__main__"].common.getUserInput = Mock()
        sys.modules["__main__"].common.getUserInput.return_value = "testlist"

        exists = False
        result = sys.modules["__main__"].core._fetchPage({"link": "http://gdata.youtube.com/feeds/api/users/default/playlists?v=2.1&start-index=1&max-results=50", "auth": "true"})
        items = sys.modules["__main__"].core.getFolderInfo(result["content"])

        for item in items:
            if item["Title"] == "testlist":
                print "Playlist 'testlist' exists."
                exists = True
        if not exists:
            print "Playlist does not exist. Creating."
            #self.navigation.executeAction({"action": "create_playlist", "title": "testlist", "summary": "test"})
            self.navigation.executeAction({"action": "create_playlist", "summary": "test"})

        result = sys.modules["__main__"].core._fetchPage({"link": "http://gdata.youtube.com/feeds/api/users/default/playlists?v=2.1&start-index=1&max-results=50", "auth": "true"})
        items = sys.modules["__main__"].core.getFolderInfo(result["content"])
        print repr(items)
        editid = False
        for item in items:
            print repr(item) + " - looking for 'testlist'"
            if item["Title"] == "testlist":
                editid = item["editid"]
                self.navigation.executeAction({"action": "delete_playlist", "playlist": item["editid"]})

        self.navigation.listMenu({"user_feed": "playlists", "login": "true", "path": "/root/playlists", "folder": "true"})

        args = sys.modules["__main__"].xbmcplugin.addDirectoryItem.call_args_list
        result = False
        if editid:
            for arg in args:
                print repr(arg[1]) + " - " + editid
                assert(arg[1]["url"].find(editid) == -1)
        else:
            assert(False)

if __name__ == "__main__":
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubeUserFeeds
import BaseTestCase
import nose
import sys

class TestYouTubeUserFeeds(BaseTestCase.BaseTestCase):

    def test_plugin_should_list_user_favorites_video_list_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].settings.setSetting("perpage", "5")

        self.navigation.listMenu({"feed": "favorites", "login": "true", "path": "/root/favorites"})

        self.assert_directory_count_greater_than_or_equals(20)
        self.assert_directory_count_less_than_or_equals(50)
        self.assert_directory_is_a_video_list()
        self.assert_directory_contains_almost_only_unique_video_items()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_user_favorites_video_list_page_2_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].settings.setSetting("perpage", "2")

        self.navigation.listMenu({"feed": "favorites", "login": "true", "page": "1", "path": "/root/favorites"})

        self.assert_directory_count_greater_than_or_equals(10)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_contains_almost_only_unique_video_items()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_user_playlists_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        self.navigation.listMenu({"user_feed": "playlists", "login": "true", "path": "/root/playlists", "folder": "true"})

        self.assert_directory_count_greater_than_or_equals(10)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_folder_list()
        self.assert_directory_item_urls_contain("playlist")

    def test_plugin_should_list_user_uploads_videos_list_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        self.navigation.listMenu({"feed": "uploads", 'login': 'true', "path": "/root/uploads"})

        self.assert_directory_count_greater_than_or_equals(10)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_contains_almost_only_unique_video_items()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_user_uploads_videos_list_page_2_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].settings.setSetting("perpage", "0")

        self.navigation.listMenu({"feed": "uploads", 'login': 'true', "page": "1", "path": "/root/uploads"})

        self.assert_directory_count_greater_than_or_equals(5)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_contains_almost_only_unique_video_items()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_user_watch_later_video_list_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        self.navigation.listMenu({"user_feed": "watch_later", 'login': 'true', "path": "/root/watch_later"})

        self.assert_directory_count_greater_than_or_equals(10)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_contains_almost_only_unique_video_items()
        self.assert_directory_items_should_have_external_thumbnails()
        self.assert_directory_item_urls_contain("playlist_entry_id")

    def test_plugin_should_list_user_recommended_video_list_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        self.navigation.listMenu({"user_feed": "recommended", 'login': 'true', "path": "/root/watch_later"})

        self.assert_directory_count_greater_than_or_equals(10)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_contains_almost_only_unique_video_items()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_user_watch_later_video_list_page_2_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        self.navigation.listMenu({"user_feed": "watch_later", 'login': 'true', "page": "1", "path": "/root/watch_later"})

        self.assert_directory_count_greater_than_or_equals(5)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_contains_almost_only_unique_video_items()
        self.assert_directory_items_should_have_external_thumbnails()
        self.assert_directory_item_urls_contain("playlist_entry_id")

    def test_plugin_should_list_user_playlist_video_list_correctly_(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        self.navigation.listMenu({"user_feed": "playlist", 'login': 'true', "path": "/root/playlist/smokey", "playlist": "E3E0C28746217FA6"})

        self.assert_directory_count_greater_than_or_equals(10)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_should_have_next_folder()
        self.assert_directory_is_a_video_list()

    def test_plugin_should_list_user_playlist_video_list_page_2_correctly_(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        self.navigation.listMenu({"user_feed": "playlist", 'login': 'true', "path": "/root/playlist/smokey", "playlist": "E3E0C28746217FA6", "page": "1"})

        self.assert_directory_count_greater_than_or_equals(10)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()

    def test_plugin_should_list_user_contacts_folder_list_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        self.navigation.listMenu({"user_feed": "contacts", 'login': 'true', "path": "/root/contacts/smokey", "folder": "true"})

        self.assert_directory_count_greater_than_or_equals(2)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_folder_list()
        self.assert_directory_item_urls_contain("contact")

    def test_plugin_should_list_user_subscriptions_folder_list_correctly_(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        self.navigation.listMenu({"user_feed": "subscriptions", 'login': 'true', "folder": "true", "path": "/root/subscriptions/something/smokey"})

        self.assert_directory_count_greater_than_or_equals(2)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_folder_list()
        self.assert_directory_item_urls_contain("channel")

    def test_plugin_should_list_newsubscriptions_video_list_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")

        self.navigation.listMenu({"user_feed": "newsubscriptions", "login": "true", "path": "/root/subscriptions/new"})

        self.assert_directory_count_greater_than_or_equals(10)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_contains_almost_only_unique_video_items()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_user_watched_history_video_list_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        self.navigation.listMenu({"user_feed": "watch_history", 'login': 'true', "path": "/root/history"})

        self.assert_directory_count_greater_than_or_equals(8)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_items_should_have_external_thumbnails()

    def test_plugin_should_list_user_watched_history_video_list_page_2_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        self.navigation.listMenu({"user_feed": "watch_history", 'login': 'true', "page": "1", "path": "/root/history"})

        self.assert_directory_count_greater_than_or_equals(8)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_items_should_have_external_thumbnails()

if __name__ == "__main__":
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubeUserScraper
import BaseTestCase
import nose
import sys


class TestYouTubeUserScraper(BaseTestCase.BaseTestCase):
    def test_plugin_should_scrape_liked_videos_list_correctly(self):
        sys.modules["__main__"].settings.load_strings("./resources/basic-login-settings-logged-in.xml")
        sys.modules["__main__"].settings.setSetting("cookies_saved", "false")

        self.navigation.listMenu({"scraper": "liked_videos", 'login': 'true', "path": "/root/liked_videos"})

        self.assert_directory_count_greater_than_or_equals(10)
        self.assert_directory_count_less_than_or_equals(51)
        self.assert_directory_is_a_video_list()
        self.assert_directory_contains_almost_only_unique_video_items()
        self.assert_directory_items_should_have_external_thumbnails()

if __name__ == "__main__":
    nose.runmodule()

########NEW FILE########
__FILENAME__ = xbmcLanguage
import xml.dom.minidom as minidom
import io


class xbmcLanguage:
    """
    Borg singleton config object
    """
    _we_are_one = {}
    _languageString = {}

    def __init__(self):
        self.__dict__ = self._we_are_one

    def _load_strings(self):
        print " *** *** loading language strings  *** ***"
        file = io.open("./resources/strings.xml").read()

        dom = minidom.parseString(file)
        strings = dom.getElementsByTagName("string")

        for string in strings:
            if string.firstChild:
                self._languageString[int(string.getAttribute("id"))] = string.firstChild.data

    def __call__(self, id):
        if not self._languageString:
            self._load_strings()

        if id in self._languageString:
            return self._languageString[id]
        return ""

if __name__ == "__main__":
    x = xbmcLanguage()
    print x(30230)
    print x(30232)
    x2 = xbmcLanguage()
    print x2(30232)
    print x2(30230)

########NEW FILE########
__FILENAME__ = xbmcSettings
import xml.dom.minidom as minidom
import io


class xbmcSettings():
    def __init__(self):
        self.settingsString = {}
        self.path = ""

    def load_strings(self, path="./resources/settings.xml"):
        print " *** *** loading settings strings *** ***"
        self.path = path
        file = io.open(path).read()
        self.dom = minidom.parseString(file)
        self.strings = self.dom.getElementsByTagName("setting")

        for string in self.strings:
            self.settingsString[string.getAttribute("id")] = string.getAttribute("value")

    def __call__(self, key="", value=False):
        if not self.settingsString:
            self.load_strings()

        if value != False:
            self.settingsString[key] = value
            if self.path.find("settings-logged-in") > -1:  # This only updates. No insert!
                for string in self.strings:
                    if string.getAttribute("id") == key:
                        string.setAttribute("value", value)
                f = open(self.path, 'w')
                self.dom.writexml(f)
                f.close()

        elif key in self.settingsString:
            return self.settingsString[key]

        return ""

    def __getattr__(self, name):
        return self

if __name__ == "__main__":
    x1 = xbmcSettings()
    print "x1: " + x1.getSetting("downloads")
    print "setting x1 = funkytown"
    x1.setSetting("downloads", "funkytown" )
    x2 = xbmcSettings()
    print "x2: " + x2.getSetting("downloads")
    print "x1: " + x1.getSetting("downloads")

########NEW FILE########
__FILENAME__ = default
'''
    YouTube plugin for XBMC
    Copyright (C) 2010-2011 Tobias Ussing And Henrik Mosgaard Jensen

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import os
import sys
import xbmc
import xbmcgui
import urllib2
import xbmcaddon
import cookielib
import xbmcplugin
try:
    import xbmcvfs
except ImportError:
    import xbmcvfsdummy as xbmcvfs

# plugin constants
version = "3.4.0"
plugin = "YouTube Beta-" + version
author = "TheCollective"
url = "www.xbmc.com"

# xbmc hooks
settings = xbmcaddon.Addon(id='plugin.video.youtube.beta')
language = settings.getLocalizedString
dbg = settings.getSetting("debug") == "true"
dbglevel = 3

# plugin structure
feeds = ""
scraper = ""
playlist = ""
navigation = ""
downloader = ""
storage = ""
login = ""
player = ""
cache = ""

path = xbmc.translatePath(settings.getAddonInfo("profile"))
path = os.path.join(path, 'yt-cookiejar.txt')
print("Loading cookies from :" + repr(path))
cookiejar = cookielib.LWPCookieJar(path)

if xbmcvfs.exists(path):
    try:
        cookiejar.load()
    except:
        pass

cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
opener = urllib2.build_opener(cookie_handler)

if (__name__ == "__main__" ):
    if dbg:
        print plugin + " ARGV: " + repr(sys.argv)
    else:
        print plugin

    try:
        import StorageServer
        cache = StorageServer.StorageServer("YouTube")
    except:
        import storageserverdummy as StorageServer
        cache = StorageServer.StorageServer("YouTube")

    import CommonFunctions as common
    common.plugin = plugin

    import YouTubeUtils
    utils = YouTubeUtils.YouTubeUtils()
    import YouTubeStorage
    storage = YouTubeStorage.YouTubeStorage()
    import YouTubePluginSettings
    pluginsettings = YouTubePluginSettings.YouTubePluginSettings()
    import YouTubeCore
    core = YouTubeCore.YouTubeCore()
    import YouTubeLogin
    login = YouTubeLogin.YouTubeLogin()
    import YouTubeFeeds
    feeds = YouTubeFeeds.YouTubeFeeds()
    import YouTubeSubtitleControl
    subtitles = YouTubeSubtitleControl.YouTubeSubtitleControl()
    import YouTubePlayer
    player = YouTubePlayer.YouTubePlayer()
    import SimpleDownloader as downloader
    downloader = downloader.SimpleDownloader()
    import YouTubeScraper
    scraper = YouTubeScraper.YouTubeScraper()
    import YouTubePlaylistControl
    playlist = YouTubePlaylistControl.YouTubePlaylistControl()
    import YouTubeNavigation
    navigation = YouTubeNavigation.YouTubeNavigation()

    if (not settings.getSetting("firstrun")):
        login.login()
        settings.setSetting("firstrun", "1")

    if (not sys.argv[2]):
        navigation.listMenu()
    else:
        params = common.getParameters(sys.argv[2])
        get = params.get
        if (get("action")):
            navigation.executeAction(params)
        elif (get("path")):
            navigation.listMenu(params)
        else:
            print plugin + " ARGV Nothing done.. verify params " + repr(params)

########NEW FILE########
__FILENAME__ = storageserverdummy
'''
     StorageServer override.
     Version: 1.0
'''
import xbmc
try:
    import hashlib
except:
    import md5

import xbmcvfs
import os
import time
import sys

if hasattr(sys.modules["__main__"], "settings"):
    settings = sys.modules["__main__"].settings
else:
    settings = False


class StorageServer:
    def __init__(self, table=False):
        self.table = table
        if settings:
            temporary_path = xbmc.translatePath(settings.getAddonInfo("profile"))
            if not xbmcvfs.exists(temporary_path):
                os.makedirs(temporary_path)

        return None

    def cacheFunction(self, funct=False, *args):
        result = ""
        if not settings:
            return funct(*args)
        elif funct and self.table:
            name = repr(funct)
            if name.find(" of ") > -1:
                name = name[name.find("method") + 7:name.find(" of ")]
            elif name.find(" at ") > -1:
                name = name[name.find("function") + 9:name.find(" at ")]

            # Build unique name
            if "hashlib" in globals():
                keyhash = hashlib.md5()
            else:
                keyhash = md5.new()

            for params in args:
                if isinstance(params, dict):
                    for key in sorted(params.iterkeys()):
                        if key not in ["new_results_function"]:
                            keyhash.update("'%s'='%s'" % (key, params[key]))
                elif isinstance(params, list):
                    keyhash.update(",".join(["%s" % el for el in params]))
                else:
                    try:
                        keyhash.update(params)
                    except:
                        keyhash.update(str(params))

            name += "-" + keyhash.hexdigest() + ".cache"

            path = os.path.join(xbmc.translatePath(settings.getAddonInfo("profile")).decode("utf-8"), name)
            if xbmcvfs.exists(path) and os.path.getmtime(path) > time.time() - 3600:
                print "Getting cache : " + repr(path)
                temp = open(path)
                result = eval(temp.read())
                temp.close()
            else:
                print "Setting cache: " + repr(path)
                result = funct(*args)
                if len(result) > 0:
                    temp = open(path, "w")
                    temp.write(repr(result))
                    temp.close()

        return result

    def set(self, name, data):
        return ""

    def get(self, name):
        return ""

    def setMulti(self, name, data):
        return ""

    def getMulti(self, name, items):
        return ""

    def lock(self, name):
        return False

    def unlock(self, name):
        return False

########NEW FILE########
__FILENAME__ = xbmcvfsdummy
'''
     XBMCVFS override for Dharma.
     Version: 1.0
'''

import os


def exists(target):
    return os.path.exists(target)


def rename(origin, target):
    return os.rename(origin, target)


def delete(target):
    if os.path.isfile(target) and not os.path.isdir(target):
        return os.unlink(target)
    return False

########NEW FILE########
__FILENAME__ = YouTubeCore
'''
    YouTube plugin for XBMC
    Copyright (C) 2010-2012 Tobias Ussing And Henrik Mosgaard Jensen

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import re
import sys
import time
import socket
import urllib
import urllib2

try:
    import simplejson as json
except ImportError:
    import json

# ERRORCODES:
# 200 = OK
# 303 = See other (returned an error message)
# 500 = uncaught error


class url2request(urllib2.Request):
    """Workaround for using DELETE with urllib2"""
    def __init__(self, url, method, data=None, headers={}, origin_req_host=None, unverifiable=False):
        self._method = method
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)

    def get_method(self):
        if self._method:
            return self._method
        else:
            return urllib2.Request.get_method(self)


class YouTubeCore():
    APIKEY = "AI39si6hWF7uOkKh4B9OEAX-gK337xbwR9Vax-cdeF9CF9iNAcQftT8NVhEXaORRLHAmHxj6GjM-Prw04odK4FxACFfKkiH9lg"

    #===============================================================================
    # The time parameter restricts the search to videos uploaded within the specified time.
    # Valid values for this parameter are today (1 day), this_week (7 days), this_month (1 month) and all_time.
    # The default value for this parameter is all_time.
    #
    # This parameter is supported for search feeds as well as for the top_rated, top_favorites, most_viewed,
    # most_popular, most_discussed and most_responded standard feeds.
    #===============================================================================

    urls = {}
    urls['batch'] = "http://gdata.youtube.com/feeds/api/videos/batch"
    urls['thumbnail'] = "http://i.ytimg.com/vi/%s/0.jpg"

    def __init__(self):
        self.settings = sys.modules["__main__"].settings
        self.language = sys.modules["__main__"].language
        self.plugin = sys.modules["__main__"].plugin
        self.dbg = sys.modules["__main__"].dbg
        self.storage = sys.modules["__main__"].storage
        self.cache = sys.modules["__main__"].cache
        self.login = sys.modules["__main__"].login
        self.utils = sys.modules["__main__"].utils
        self.common = sys.modules["__main__"].common
        urllib2.install_opener(sys.modules["__main__"].opener)

        timeout = [5, 10, 15, 20, 25][int(self.settings.getSetting("timeout"))]
        if not timeout:
            timeout = "15"
        socket.setdefaulttimeout(float(timeout))
        return None

    def delete_favorite(self, params={}):
        self.common.log("")
        get = params.get

        delete_url = "http://gdata.youtube.com/feeds/api/users/default/favorites"
        delete_url += "/" + get('editid')
        result = self._fetchPage({"link": delete_url, "api": "true", "login": "true", "auth": "true", "method": "DELETE"})
        return (result["content"], result["status"])

    def remove_contact(self, params={}):
        self.common.log("")
        get = params.get
        delete_url = "http://gdata.youtube.com/feeds/api/users/default/contacts"
        delete_url += "/" + get("contact")
        result = self._fetchPage({"link": delete_url, "api": "true", "login": "true", "auth": "true", "method": "DELETE"})
        return (result["content"], result["status"])

    def remove_subscription(self, params={}):
        self.common.log("")
        get = params.get
        delete_url = "http://gdata.youtube.com/feeds/api/users/default/subscriptions"
        delete_url += "/" + get("editid")
        result = self._fetchPage({"link": delete_url, "api": "true", "login": "true", "auth": "true", "method": "DELETE"})
        return (result["content"], result["status"])

    def add_contact(self, params={}):
        self.common.log("")
        get = params.get
        url = "http://gdata.youtube.com/feeds/api/users/default/contacts"
        add_request = '<?xml version="1.0" encoding="UTF-8"?> <entry xmlns="http://www.w3.org/2005/Atom" xmlns:yt="http://gdata.youtube.com/schemas/2007"><yt:username>%s</yt:username></entry>' % get("contact")
        result = self._fetchPage({"link": url, "api": "true", "login": "true", "auth": "true", "request": add_request})
        return (result["content"], result["status"])

    def add_favorite(self, params={}):
        get = params.get
        url = "http://gdata.youtube.com/feeds/api/users/default/favorites"
        add_request = '<?xml version="1.0" encoding="UTF-8"?><entry xmlns="http://www.w3.org/2005/Atom"><id>%s</id></entry>' % get("videoid")
        result = self._fetchPage({"link": url, "api": "true", "login": "true", "auth": "true", "request": add_request})
        return (result["content"], result["status"])

    def add_subscription(self, params={}):
        self.common.log("")
        get = params.get
        url = "http://gdata.youtube.com/feeds/api/users/default/subscriptions"
        add_request = '<?xml version="1.0" encoding="UTF-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:yt="http://gdata.youtube.com/schemas/2007"> <category scheme="http://gdata.youtube.com/schemas/2007/subscriptiontypes.cat" term="user"/><yt:username>%s</yt:username></entry>' % get("channel")
        result = self._fetchPage({"link": url, "api": "true", "login": "true", "auth": "true", "request": add_request})
        return (result["content"], result["status"])

    def add_playlist(self, params={}):
        get = params.get
        url = "http://gdata.youtube.com/feeds/api/users/default/playlists"
        add_request = '<?xml version="1.0" encoding="UTF-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:yt="http://gdata.youtube.com/schemas/2007"><title type="text">%s</title><summary>%s</summary></entry>' % (get("title"), get("summary"))
        result = self._fetchPage({"link": url, "api": "true", "login": "true", "auth": "true", "request": add_request})
        return (result["content"], result["status"])

    def del_playlist(self, params={}):
        self.common.log("")
        get = params.get
        url = "http://gdata.youtube.com/feeds/api/users/default/playlists/%s" % (get("playlist"))
        result = self._fetchPage({"link": url, "api": "true", "login": "true", "auth": "true", "method": "DELETE"})
        return (result["content"], result["status"])

    def add_to_playlist(self, params={}):
        get = params.get
        self.common.log("")
        url = "http://gdata.youtube.com/feeds/api/playlists/%s" % get("playlist")
        add_request = '<?xml version="1.0" encoding="UTF-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:yt="http://gdata.youtube.com/schemas/2007"><id>%s</id></entry>' % get("videoid")
        result = self._fetchPage({"link": url, "api": "true", "login": "true", "auth": "true", "request": add_request})
        return (result["content"], result["status"])

    def remove_from_playlist(self, params={}):
        self.common.log("")
        get = params.get
        url = "http://gdata.youtube.com/feeds/api/playlists/%s/%s" % (get("playlist"), get("playlist_entry_id"))
        result = self._fetchPage({"link": url, "api": "true", "login": "true", "auth": "true", "method": "DELETE"})
        return (result["content"], result["status"])

    def remove_from_watch_later(self, params={}):
        self.common.log("")
        get = params.get
        url = "https://gdata.youtube.com/feeds/api/users/default/watch_later/%s" % get("playlist_entry_id")
        result = self._fetchPage({"link": url, "api": "true", "login": "true", "auth": "true", "method": "DELETE"})
        return (result["content"], result["status"])

    def set_video_watched(self, params={}):
        self.common.log("")
        get = params.get
        url = "https://gdata.youtube.com/feeds/api/users/default/watch_later/%s" % get("videoid")
        result = self._fetchPage({"link": url, "api": "true", "login": "true", "auth": "true", "method": "DELETE"})
        return (result["content"], result["status"])

    def getCategoriesFolderInfo(self, xml, params={}):
        self.common.log("")
        self.common.log(xml)
        entries = self.common.parseDOM(xml, "atom:category", ret=True)

        folders = []
        for node in entries:
            folder = {}
            print repr(node)
            if 'yt:deprecated' in node:
                continue

            title = self.common.parseDOM(node, "atom:category", ret="label")[0]

            if title:
                folder['Title'] = self.common.replaceHTMLCodes(title)

            folder['category'] = self.common.parseDOM(node, "atom:category", ret="term")[0]
            folder["icon"] = "explore"
            folder["thumbnail"] = "explore"
            folder["feed"] = "feed_category"

            folders.append(folder)

        return folders

    def getFolderInfo(self, xml, params={}):
        get = params.get

        self.common.log(xml)
        entries = self.common.parseDOM(xml, "entry")
        show_next = False

        #find out if there are more pages
        for link in self.common.parseDOM(xml, "link", ret="rel"):
            if link == "next":
                show_next = True
                break

        folders = []
        for node in entries:
            folder = {"published": "2008-07-05T19:56:35.000-07:00"}

            if get("feed") != "feed_categories":
                folder["login"] = "true"
            title = self.common.parseDOM(node, "title")[0]
            if title.find(": ") > 0:
                title = title[title.find(": ") + 2:]
                title = self.common.replaceHTMLCodes(title)
                
            folder['Title'] = title
            for tmp in self.common.parseDOM(node, "published"):
                folder['published'] = tmp

            for entryid in self.common.parseDOM(node, "id"):
                folder["editid"] = entryid[entryid.rfind(":") + 1:]

            thumb = ""
            if get("user_feed") == "contacts":
                folder["thumbnail"] = "user"
                folder["contact"] = self.common.parseDOM(node, 'yt:username')[0]
                folder["store"] = "contact_options"
                folder["folder"] = "true"

            if get("user_feed") == "subscriptions":
                folder["channel"] = self.common.parseDOM(node, 'yt:username')[0]

            if get("user_feed") == "playlists":
                folder['playlist'] = self.common.parseDOM(node, 'yt:playlistId')[0]
                folder["user_feed"] = "playlist"

            params["thumb"] = "true"
            thumb = self.storage.retrieve(params, "thumbnail", folder)
            if thumb:
                folder["thumbnail"] = thumb

            folders.append(folder)

        if show_next:
            self.utils.addNextFolder(folders, params)

        return folders

    def getBatchDetailsOverride(self, items, params={}):
        videoids = []

        for video in items:
            for k, v in video.items():
                if k == "videoid":
                    videoids.append(v)

        (ytobjects, status) = self.getBatchDetails(videoids, params)

        for video in items:
            videoid = video["videoid"]
            for item in ytobjects:
                if item['videoid'] == videoid:
                    for k, v in video.items():
                        item[k] = v

        while len(items) > len(ytobjects):
            ytobjects.append({'videoid': 'false'})

        return (ytobjects, 200)

    def getBatchDetailsThumbnails(self, items, params={}):
        ytobjects = []
        videoids = []

        for (videoid, thumb) in items:
            videoids.append(videoid)

        (tempobjects, status) = self.getBatchDetails(videoids, params)

        for i in range(0, len(items)):
            (videoid, thumbnail) = items[i]
            for item in tempobjects:
                if item['videoid'] == videoid:
                    item['thumbnail'] = thumbnail
                    ytobjects.append(item)
                    break

        while len(items) > len(ytobjects):
            ytobjects.append({'videoid': 'false'})

        return (ytobjects, 200)

    def getBatchDetails(self, items, params={}):
        self.common.log("params: " + repr(params))
        self.common.log("items: " + str(len(items)))
        request_start = "<feed xmlns='http://www.w3.org/2005/Atom'\n xmlns:media='http://search.yahoo.com/mrss/'\n xmlns:batch='http://schemas.google.com/gdata/batch'\n xmlns:yt='http://gdata.youtube.com/schemas/2007'>\n <batch:operation type='query'/> \n"
        request_end = "</feed>"

        video_request = ""

        ytobjects = []
        status = 500
        i = 1

        temp_objs = self.cache.getMulti("videoidcache", items)

        for index, videoid in enumerate(items):
            if index < len(temp_objs):
                if temp_objs[index]:
                    ytobjects.append(eval(temp_objs[index]))
                    continue
            if videoid:
                video_request += "<entry> \n <id>http://gdata.youtube.com/feeds/api/videos/" + videoid + "</id>\n</entry> \n"
                if i == 50:
                    final_request = request_start + video_request + request_end
                    rstat = 403
                    while rstat == 403:
                        result = self._fetchPage({"link": "http://gdata.youtube.com/feeds/api/videos/batch", "api": "true", "request": final_request})
                        rstat = self.common.parseDOM(result["content"], "batch:status", ret="code")
                        if len(rstat) > 0:
                            if int(rstat[len(rstat) - 1]) == 403:
                                self.common.log("quota exceeded. Waiting 5 seconds. " + repr(rstat))
                                rstat = 403
                                time.sleep(5)

                    temp = self.getVideoInfo(result["content"], params)
                    ytobjects += temp
                    video_request = ""
                    i = 1
                i += 1

        if i > 1:
            final_request = request_start + video_request + request_end
            result = self._fetchPage({"link": "http://gdata.youtube.com/feeds/api/videos/batch", "api": "true", "request": final_request})

            temp = self.getVideoInfo(result["content"], params)
            ytobjects += temp

            save_data = {}
            for item in ytobjects:
                save_data[item["videoid"]] = repr(item)
            self.cache.setMulti("videoidcache", save_data)

        if len(ytobjects) > 0:
            status = 200

        self.common.log("ytobjects: " + str(len(ytobjects)))

        return (ytobjects, status)

    #===============================================================================
    #
    # Internal functions to YouTubeCore.py
    #
    # Return should be value(True for bool functions), or False if failed.
    #
    # False MUST be handled properly in External functions
    #
    #===============================================================================

    def _fetchPage(self, params={}):  # This does not handle cookie timeout for _httpLogin
        if self.settings.getSetting("force_proxy") == "true" and self.settings.getSetting("proxy"):
            params["proxy"] = self.settings.getSetting("proxy")

        get = params.get
        link = get("link")
        ret_obj = {"status": 500, "content": "", "error": 0}
        cookie = ""

        if (get("url_data") or get("request") or get("hidden")) and False:
            self.common.log("called for : " + repr(params['link']))
        else:
            self.common.log("called for : " + repr(params))

        if get("auth", "false") == "true":
            self.common.log("got auth")
            if self._getAuth():
                if link.find("?") > -1:
                    link += "&oauth_token=" + self.settings.getSetting("oauth2_access_token")
                else:
                    link += "?oauth_token=" + self.settings.getSetting("oauth2_access_token")

                self.common.log("updated link: " + link)
            else:
                self.common.log("couldn't get login token")

        if not link or get("error", 0) > 2:
            self.common.log("giving up")
            return ret_obj

        if get("url_data"):
            url_data = get("url_data")
            url_data_encoded = {}
            for k, v in url_data.iteritems():
                url_data_encoded[k] = unicode(v).encode('utf-8')

            request = urllib2.Request(link, urllib.urlencode(url_data_encoded))
            request.add_header('Content-Type', 'application/x-www-form-urlencoded')
        elif get("request", "false") == "false":
            if get("proxy"):
                proxy = get("proxy")
                link = proxy + urllib.quote(link)
                self.common.log("got proxy: %s" % link)
            else:
                self.common.log("got default: %s" % link)

            request = url2request(link, get("method", "GET"))
        else:
            self.common.log("got request")
            request = urllib2.Request(link, get("request"))
            request.add_header('X-GData-Client', "")
            request.add_header('Content-Type', 'application/atom+xml')
            request.add_header('Content-Length', str(len(get("request"))))

        if get("proxy") or (self.settings.getSetting("proxy") != "" and link.find(self.settings.getSetting("proxy")) > -1):
            proxy = self.settings.getSetting("proxy")
            referer = proxy[:proxy.rfind("/")]
            self.common.log("Added proxy refer: %s" % referer)

            request.add_header('Referer', referer)

        if get("api", "false") == "true":
            self.common.log("got api")
            request.add_header('GData-Version', '2.1')
            request.add_header('X-GData-Key', 'key=' + self.APIKEY)
        else:
            request.add_header('User-Agent', self.common.USERAGENT)

            if get("no-language-cookie", "false") == "true":
                cookie += "PREF=f1=50000000&hl=en; "

        if get("login", "false") == "true":
            self.common.log("got login")
            if (self.settings.getSetting("username") == "" or self.settings.getSetting("user_password") == ""):
                self.common.log("_fetchPage, login required but no credentials provided")
                ret_obj["status"] = 303
                ret_obj["content"] = self.language(30622)
                return ret_obj

            # This should be a call to self.login._httpLogin()
            if self.settings.getSetting("cookies_saved") != "true":
                if isinstance(self.login, str):
                    self.login = sys.modules["__main__"].login
                self.login._httpLogin()

        if get("referer", "false") != "false":
            self.common.log("Added referer: %s" % get("referer"))
            request.add_header('Referer', get("referer"))

        try:
            self.common.log("connecting to server... %s" % link )

            if cookie:
                self.common.log("Setting cookie: " + cookie)
                request.add_header('Cookie', cookie)
            con = urllib2.urlopen(request)

            inputdata = con.read()
            ret_obj["content"] = inputdata.decode("utf-8")
            ret_obj["location"] = link

            ret_obj["new_url"] = con.geturl()
            ret_obj["header"] = str(con.info())
            con.close()

            self.common.log("Result: %s " % repr(ret_obj), 9)

            self.common.log("done")
            ret_obj["status"] = 200
            return ret_obj

        except urllib2.HTTPError, e:
            cont = False
            err = str(e)
            msg = e.read()

            self.common.log("HTTPError : " + err)
            if e.code == 400 or True:
                self.common.log("Unhandled HTTPError : [%s] %s " % (e.code, msg), 1)

            params["error"] = get("error", 0) + 1
            ret_obj = self._fetchPage(params)

            if cont and ret_obj["content"] == "":
                ret_obj["content"] = cont
                ret_obj["status"] = 303

            return ret_obj

        except urllib2.URLError, e:
            err = str(e)
            self.common.log("URLError : " + err)
            if err.find("SSL") > -1:
                ret_obj["status"] = 303
                ret_obj["content"] = self.language(30629)
                ret_obj["error"] = 3  # Tell _findErrors that we have an error
                return ret_obj

            time.sleep(3)
            params["error"] = get("error", 0) + 1
            ret_obj = self._fetchPage(params)
            return ret_obj

        except socket.timeout:
            self.common.log("Socket timeout")
            return ret_obj

    def _findErrors(self, ret, silent=False):
        self.common.log("")

        ## Couldn't find 2 factor or normal login
        error = self.common.parseDOM(ret['content'], "div", attrs={"class": "errormsg"})
        if len(error) == 0:
            # An error in 2-factor
            self.common.log("1")
            error = self.common.parseDOM(ret['content'], "div", attrs={"class": "error smaller"})
        if len(error) == 0:
            self.common.log("2")
            error = self.common.parseDOM(ret['content'], "div", attrs={"id": "unavailable-message"})
        if len(error) == 0 and ret['content'].find("yt:quota") > -1:
            self.common.log("3")
            # Api quota
            html = self.common.parseDOM(ret['content'], "error")
            error = self.common.parseDOM(html, "code")

        if len(error) == 0:  # Bad password for _httpLogin.
            error = self.common.parseDOM(ret['content'], "span", attrs={"class": "errormsg"})

            # Has a link. Lets remove that.
            if len(error) == 1:
                if error[0].find("<") > -1:
                    error[0] = error[0][0:error[0].find("<")]

        if len(error) == 0:
            self.common.log("4")
            error = self.common.parseDOM(ret['content'], "div", attrs={"id": "watch7-player-age-gate-content"})

        if len(error) == 0:
            self.common.log("5")
            if len(self.common.parseDOM(ret['content'], "input", attrs={"id": "send-code-button"})):
                error = [self.language(30630)]

        if len(error) == 0:
            self.common.log("6")
            if len(self.common.parseDOM(ret['content'], "h1", attrs={"id": "login-challenge-heading"})):
                error = [self.language(30630)]

        if len(error) == 0:
            self.common.log("7")
            if len(self.common.parseDOM(ret['content'], "h2", attrs={"class": "smsauth-interstitial-heading"})):
                error = [self.language(30630)]

        if len(error) == 0:
            self.common.log("8")
            error = self.common.parseDOM(ret['content'], "span", attrs={"class": "error-msg"})

        if len(error) > 0:
            self.common.log("Found error: " + repr(error))
            error = self.common.stripTags(error[0])
            self.common.log("Found error: " + repr(error))
            if error.find("[") > -1:
                error = error[0:error.find("[")]
            error = urllib.unquote(error.replace("\n", " ").replace("  ", " ")).replace("&#39;", "'")
            self.common.log("returning error : " + repr(error.strip()))
            return error.strip()

        # If no error was found. But fetchPage has an error level of 3+, return the fetchPage content.
        if len(error) == 0 and ret["error"] >= 3:
            self.common.log("Returning error from _fetchPage : " + repr(ret))
            return ret["content"]

        if not silent:
            self.common.log("couldn't find any errors: " + repr(ret))

        return False

    def _oRefreshToken(self):
        self.common.log("")
        # Refresh token
        if self.settings.getSetting("oauth2_refresh_token"):
            url = "https://accounts.google.com/o/oauth2/token"
            data = {"client_id": "208795275779.apps.googleusercontent.com",
                "client_secret": "sZn1pllhAfyonULAWfoGKCfp",
                "refresh_token": self.settings.getSetting("oauth2_refresh_token"),
                "grant_type": "refresh_token"}
            self.settings.setSetting("oauth2_access_token", "")
            ret = self._fetchPage({"link": url, "no-language-cookie": "true", "url_data": data})
            if ret["status"] == 200:
                oauth = ""
                try:
                    oauth = json.loads(ret["content"])
                except:
                    self.common.log("Except: " + repr(ret))
                    return False

                self.common.log("- returning, got result a: " + repr(oauth))

                self.settings.setSetting("oauth2_access_token", oauth["access_token"])
                self.settings.setSetting("oauth2_expires_at", str(int(oauth["expires_in"]) + time.time()) )
                self.common.log("Success")
                return True
            else:
                self.common.log("Failure, Trying a clean login")
                if isinstance(self.login, str):
                    self.login = sys.modules["__main__"].login
                self.login.login({"new": "true"})
            return False

        self.common.log("didn't even try")

        return False

    def performNewLogin(self):
        self.common.log("")
        if isinstance(self.login, str):
            self.login = sys.modules["__main__"].login

        (result, status) = self.login.login()

        if status == 200:
            self.common.log("returning new auth")
            return self.settings.getSetting("oauth2_access_token")

        self.common.log("failed because login failed")
        return False

    def refreshTokenIfNessecary(self):
        now = time.time()

        if self.settings.getSetting("oauth2_expires_at"):
            expire_at = float(self.settings.getSetting("oauth2_expires_at"))
        else:
            expire_at = now

        if expire_at <= now:
            self.common.log("Oauth expired refreshing")
            self._oRefreshToken()

    def _getAuth(self):
        self.common.log("")

        self.refreshTokenIfNessecary()

        auth = self.settings.getSetting("oauth2_access_token")
        if (auth):
            return auth

        return self.performNewLogin()

    def getVideoId(self, node):
        videoid = "false"
        for id in self.common.parseDOM(node, "yt:videoid"):
            videoid = id

        if videoid == "false":
            for id in self.common.parseDOM(node, "content", ret="src"):
                videoid = id
                videoid = videoid[videoid.rfind("/") + 1:]

        if videoid == "false":
            for id in self.common.parseDOM(node, "link", ret="href"):
                match = re.match('.*?v=(.*)\&.*', id)
                if match:
                    videoid = match.group(1)

        return videoid

    def getPlaylistId(self, node):
        result = ""

        for entryid in self.common.parseDOM(node, "id"):
            entryid = entryid[entryid.rfind(":") + 1:]
            result = entryid

        return result

    def videoIsUnavailable(self, node):
        result = False

        for state in self.common.parseDOM(node, "yt:state", ret=True):
            # Ignore unplayable items.
            if (state == 'deleted' or state == 'rejected'):
                result = True

            # Get reason for why we can't playback the file.
            reason = self.common.parseDOM(node, "yt:state", ret="reasonCode")
            value = self.common.parseDOM(node, "yt:state")

            if not reason:
                return result

            if reason[0] in [ "private", 'requesterRegion']:
                result = True
            elif reason[0] != 'limitedSyndication':
                self.common.log("removing video, reason: %s value: %s" % (reason[0], value[0]))
                result = True

        return result

    def getVideoEditId(self, node):
        result = ""
        for edit_link in self.common.parseDOM(node, "link", ret=True):
            for obj in self.common.parseDOM(edit_link, "link", attrs={"rel": "edit"}, ret="href"):
                result = obj[obj.rfind('/') + 1:]
        return result

    def addNextPageLinkIfNecessary(self, params, xml, ytobjects):
        show_next = False
        # find out if there are more pages
        for link in self.common.parseDOM(xml, "link", ret="rel"):
            if link == "next":
                show_next = True
                break
        if show_next:
            self.utils.addNextFolder(ytobjects, params)

    def updateVideoIdStatusInCache(self, pre_id, ytobjects):
        self.common.log(pre_id)
        save_data = {}
        for item in ytobjects:
            if "videoid" in item:
                save_data[item["videoid"]] = repr(item)

        self.cache.setMulti(pre_id, save_data)

    def getVideoIdStatusFromCache(self, pre_id, ytobjects):
        self.common.log(pre_id)
        load_data = []
        for item in ytobjects:
            if "videoid" in item:
                load_data.append(item["videoid"])

        res = self.cache.getMulti(pre_id, load_data)
        if len(res) != len(load_data):
            self.common.log("Length mismatch:" + repr(res) + " - " + repr(load_data))
        i = 0
        for item in ytobjects:
            if "videoid" in item:
                if i < len(res):
                    item["Overlay"] = res[i]
                i += 1 # This can NOT be enumerated because there might be missing videoids
        return ytobjects

    def getVideoEntries(self, xml):
        entries = self.common.parseDOM(xml, "entry")
        if not entries:
            entries = self.common.parseDOM(xml, "atom:entry")

        return entries

    def getVideoCreator(self, node):
        result = ""

        # media:credit is not set for favorites, playlists
        for tmp in self.common.parseDOM(node, "media:credit"):
            result = tmp
        if result == "":
            for tmp in self.common.parseDOM(node, "name"):
                result = tmp

        return result

    def getVideoTitle(self, node):
        result = ""
        for tmp in self.common.parseDOM(node, "media:title"):
            result = self.common.replaceHTMLCodes(tmp)
        return result

    def getVideoDuration(self, node):
        result = 1

        for tmp in self.common.parseDOM(node, "yt:duration", ret="seconds"):
            if tmp:
                result = tmp

        return result

    def getVideoUploadDate(self, node):
        result = time.localtime()

        for tmp in self.common.parseDOM(node, "published"):
            result = time.strptime(tmp[:tmp.find(".")], "%Y-%m-%dT%H:%M:%S")

        return result

    def getViewCount(self, node):
        result = 0

        for tmp in self.common.parseDOM(node, "yt:statistics", ret="viewCount"):
            result = int(tmp)

        return result

    def getVideoDescription(self, node, uploadDate, viewCount):
        result = ""

        for tmp in self.common.parseDOM(node, "media:description"):
            result = self.common.replaceHTMLCodes(tmp)

        infoString = "Date Uploaded: " + time.strftime("%Y-%m-%d %H:%M:%S", uploadDate) + ", "
        infoString += "View count: " + str(viewCount)

        result = infoString + "\n" + result

        return result

    def getVideoRating(self, node):
        result = 0.0

        for tmp in self.common.parseDOM(node, "gd:rating", ret="average"):
            result = float(tmp)

        return result

    def getVideoGenre(self, node):
        result = ""

        for tmp in self.common.parseDOM(node, "media:category", ret="label"):
            result = self.common.replaceHTMLCodes(tmp)

        return result

    def getVideoInfo(self, xml, params={}):
        self.common.log("", 3)

        entries = self.getVideoEntries(xml)

        ytobjects = []
        for node in entries:
            video ={}

            video["videoid"] = self.getVideoId(node)
            video["playlist_entry_id"] = self.getPlaylistId(node)
            video['editid'] = self.getVideoEditId(node)

            if self.videoIsUnavailable(node):
                self.common.log("Video is unavailable, removing from result.", 3)
                video["videoid"] = "false"

            video["Studio"] = self.getVideoCreator(node)
            video["Title"] = self.getVideoTitle(node)
            video["Duration"] = self.getVideoDuration(node)
            video["Rating"] = self.getVideoRating(node)
            video["Genre"] = self.getVideoGenre(node)

            viewCount = self.getViewCount(node)
            video["Count"] = viewCount
            uploadDate = self.getVideoUploadDate(node)
            video['Date'] = time.strftime("%d-%m-%Y", uploadDate)

            video["Plot"] = self.getVideoDescription(node, uploadDate, viewCount)

            video['thumbnail'] = self.urls["thumbnail"] % video['videoid']

            ytobjects.append(video)

        self.addNextPageLinkIfNecessary(params, xml, ytobjects)

        self.updateVideoIdStatusInCache("videoidcache", ytobjects)
        self.getVideoIdStatusFromCache("vidstatus-", ytobjects)

        self.common.log("Done: " + str(len(ytobjects)),3)
        return ytobjects

########NEW FILE########
__FILENAME__ = YouTubeFeeds
'''
    YouTube plugin for XBMC
    Copyright (C) 2010-2012 Tobias Ussing And Henrik Mosgaard Jensen

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import sys
import  urllib


class YouTubeFeeds():
    # YouTube General Feeds
    urls = {}
    urls['playlist'] = "http://gdata.youtube.com/feeds/api/playlists/%s"
    urls['related'] = "http://gdata.youtube.com/feeds/api/videos/%s/related"
    urls['search'] = "http://gdata.youtube.com/feeds/api/videos?q=%s&safeSearch=%s"

    # YouTube User specific Feeds
    urls['uploads'] = "http://gdata.youtube.com/feeds/api/users/%s/uploads"
    urls['favorites'] = "http://gdata.youtube.com/feeds/api/users/%s/favorites"
    urls['playlists'] = "http://gdata.youtube.com/feeds/api/users/%s/playlists"
    urls['contacts'] = "http://gdata.youtube.com/feeds/api/users/default/contacts"
    urls['subscriptions'] = "http://gdata.youtube.com/feeds/api/users/%s/subscriptions"
    urls['newsubscriptions'] = "http://gdata.youtube.com/feeds/api/users/%s/newsubscriptionvideos"
    urls["recommended"] = "http://gdata.youtube.com/feeds/api/users/default/recommendations"
    urls['watch_later'] = "http://gdata.youtube.com/feeds/api/users/default/watch_later?v=2.1"
    urls['watch_history'] = "http://gdata.youtube.com/feeds/api/users/default/watch_history?v=2"

    # YouTube Standard feeds
    urls['feed_categories'] = "http://gdata.youtube.com/schemas/2007/categories.cat"
    urls['feed_category'] = "http://gdata.youtube.com/feeds/api/standardfeeds/most_viewed_%s?v=2&time=%s"
    urls['feed_rated'] = "http://gdata.youtube.com/feeds/api/standardfeeds/top_rated?time=%s"
    urls['feed_favorites'] = "http://gdata.youtube.com/feeds/api/standardfeeds/top_favorites?time=%s"
    urls['feed_viewed'] = "http://gdata.youtube.com/feeds/api/standardfeeds/most_viewed?time=%s"
    urls['feed_linked'] = "http://gdata.youtube.com/feeds/api/standardfeeds/most_popular?time=%s"
    urls['feed_discussed'] = "http://gdata.youtube.com/feeds/api/standardfeeds/most_discussed?time=%s"
    urls['feed_responded'] = "http://gdata.youtube.com/feeds/api/standardfeeds/most_responded?time=%s"
    urls['feed_live'] = "http://gdata.youtube.com/feeds/api/charts/live/events/live_now"

    # Wont work with time parameter
    urls['feed_recent'] = "http://gdata.youtube.com/feeds/api/standardfeeds/most_recent"
    urls['feed_featured'] = "http://gdata.youtube.com/feeds/api/standardfeeds/recently_featured"
    urls['feed_trending'] = "http://gdata.youtube.com/feeds/api/standardfeeds/on_the_web"
    urls['feed_shared'] = "http://gdata.youtube.com/feeds/api/standardfeeds/most_shared"

    def __init__(self):
        self.settings = sys.modules["__main__"].settings
        self.language = sys.modules["__main__"].language
        self.plugin = sys.modules["__main__"].plugin
        self.dbg = sys.modules["__main__"].dbg
        self.utils = sys.modules["__main__"].utils
        self.storage = sys.modules["__main__"].storage
        self.core = sys.modules["__main__"].core
        self.pluginsettings = sys.modules["__main__"].pluginsettings
        self.common = sys.modules["__main__"].common

    def createUrl(self, params={}):
        self.common.log("", 4)
        get = params.get
        time = "this_week"
        per_page = self.pluginsettings.itemsPerPage()
        region = self.pluginsettings.currentRegion()

        page = get("page", "0")
        start_index = per_page * int(page) + 1
        url = ""

        if (get("feed")):
            url = self.urls[get("feed")]

        if (get("user_feed")):
            url = self.urls[get("user_feed")]

        if get("search"):
            url = self.urls["search"]
            query = urllib.unquote_plus(get("search"))
            safe_search = self.pluginsettings.safeSearchLevel()
            url = url % (query, safe_search)
            authors = self.settings.getSetting("stored_searches_author")
            if len(authors) > 0:
                try:
                    authors = eval(authors)
                    if query in authors:
                        url += "&" + urllib.urlencode({'author': authors[query]})
                except:
                    self.common.log("Search - eval failed")

        if (url.find("%s") > 0):
            if (get("contact") and not (get("external") and get("channel"))):
                url = url % get("contact")
            elif (get("channel")):
                url = url % get("channel")
            elif (get("playlist")):
                url = url % get("playlist")
            elif (get("videoid") and not get("action") == "add_to_playlist"):
                url = url % get("videoid")
            elif (get("category")):
                url = url % (get("category"), "today")
            elif (url.find("time=") > 0):
                url = url % time
            else:
                url = url % "default"

        if (url.find("?") == -1):
            url += "?"
        else:
            url += "&"

        if not get("playlist") and not get("folder") and not get("action") == "play_all" and not get("action") == "add_to_playlist":
            url += "start-index=" + repr(start_index) + "&max-results=" + repr(per_page)

        if (url.find("standardfeeds") > 0 and region):
            url = url.replace("/standardfeeds/", "/standardfeeds/" + region + "/")

        url = url.replace(" ", "+")
        self.common.log(url, 4)
        return url

    def list(self, params={}):
        self.common.log("", 4)
        get = params.get
        result = {"content": "", "status": 303}

        if get("folder"):
            return self.listFolder(params)

        if get("playlist"):
            return self.listPlaylist(params)

        if get("login") == "true":
            if (not self.core._getAuth()):
                self.common.log("Login required but auth wasn't set!")
                return (self.language(30609), 303)

        url = self.createUrl(params)

        if url:
            self.common.log(repr(url), 4)
            result = self.core._fetchPage({"link": url, "auth": get("login"), "api": "true"})

        if result["status"] != 200:
            return (result["content"], result["status"])

        videos = self.core.getVideoInfo(result["content"], params)

        if len(videos) == 0:
            return (videos, 303)

        thumbnail = videos[0].get('thumbnail', "")

        if thumbnail:
            self.storage.store(params, thumbnail, "thumbnail")

        self.common.log("Done", 4)
        return (videos, 200)

    def listPlaylist(self, params={}):
        self.common.log("", 4)
        get = params.get
        page = int(get("page", "0"))
        per_page = self.pluginsettings.itemsPerPage()
        next = 'false'

        videos = self.storage.retrieve(params)

        if page != 0 and videos:
            if (per_page * (page + 1) < len(videos)):
                next = 'true'

            videos = videos[(per_page * page):(per_page * (page + 1))]

            (result, status) = self.core.getBatchDetailsOverride(videos, params)
        else:
            result = self.listAll(params)

            if len(result) == 0:
                return (result, 303)

            videos = []
            for video in result:
                vget = video.get
                item = {}
                item["playlist_entry_id"] = vget("playlist_entry_id")
                item["videoid"] = vget("videoid")
                videos.append(item)

            self.storage.store(params, videos)

            thumbnail = result[0].get('thumbnail', "")
            if (thumbnail):
                self.storage.store(params, thumbnail, "thumbnail")

            if (len(result) > 0 and get("fetch_all") != "true"):
                if (per_page * (page + 1) < len(result)):
                    next = 'true'

                result = result[(per_page * page):(per_page * (page + 1))]

        if next == "true":
            self.utils.addNextFolder(result, params)

        self.common.log(repr(result), 4)
        return (result, 200)

    def listFolder(self, params={}):
        self.common.log("", 4)
        get = params.get
        result = []

        if get("store"):
            if get("store") == "contact_options":
                return self.storage.getUserOptionFolder(params)
            else:
                return self.storage.getStoredSearches(params)

        page = int(get("page", "0"))
        per_page = self.pluginsettings.itemsPerPage()

        if (page != 0):
            result = self.storage.retrieve(params)

        elif not get("page"):
            if get("feed") == "feed_categories":
                result = self.listCategories(params)
            else:
                result = self.listAll(params)

            if len(result) == 0:
                return (result, 303)

            self.storage.store(params, result)

        next = 'false'

        if (len(result) > 0):
            if (per_page * (page + 1) < len(result)):
                next = 'true'
        result = result[(per_page * page):(per_page * (page + 1))]

        if get("user_feed") == "subscriptions":
            for item in result:
                viewmode = self.storage.retrieve(params, "viewmode", item)

                if (get("external")):
                    item["external"] = "true"
                    item["contact"] = get("contact")

                if (viewmode == "favorites"):
                    item["user_feed"] = "favorites"
                    item["view_mode"] = "subscriptions_uploads"
                elif(viewmode == "playlists"):
                    item["user_feed"] = "playlists"
                    item["folder"] = "true"
                    item["view_mode"] = "subscriptions_playlists"
                else:
                    item["user_feed"] = "uploads"
                    item["view_mode"] = "subscriptions_favorites"

        if next == "true":
            self.utils.addNextFolder(result, params)

        self.common.log(repr(result), 4)
        return (result, 200)

    def listCategories(self, params={}):
        self.common.log("", 4)

        url = self.createUrl(params)
        ytobjects = []

        result = self.core._fetchPage({"link": url})

        if result["status"] == 200:
            ytobjects = self.core.getCategoriesFolderInfo(result["content"], params)

        if len(ytobjects) == 0:
            return ytobjects

        self.common.log(repr(ytobjects), 4)
        return ytobjects

    def listAll(self, params={}):
        self.common.log("", 4)
        get = params.get
        result = {"content": "", "status": 303}

        auth = "false"
        if get("login") == "true":
            auth = "true"
            if (not self.core._getAuth()):
                self.common.log("login required but auth wasn't set!")
                return (self.language(30609), 303)

        feed = self.createUrl(params)
        index = 1
        url = feed + "v=2.1&start-index=" + str(index) + "&max-results=" + repr(50)
        url = url.replace(" ", "+")

        ytobjects = []

        result = self.core._fetchPage({"link": url, "auth": auth})

        if result["status"] == 200:
            if get("folder") == "true":
                ytobjects = self.core.getFolderInfo(result["content"], params)
            else:
                ytobjects = self.core.getVideoInfo(result["content"], params)

        if len(ytobjects) == 0:
            return ytobjects

        next = ytobjects[len(ytobjects) - 1].get("next", "false")
        if next == "true":
            ytobjects = ytobjects[:len(ytobjects) - 1]

        while next == "true":
            index += 50
            url = feed + "start-index=" + str(index) + "&max-results=" + repr(50)
            url = url.replace(" ", "+")
            result = self.core._fetchPage({"link": url, "auth": "true"})

            if result["status"] != 200:
                break
            temp_objects = []
            if get("folder") == "true":
                temp_objects = self.core.getFolderInfo(result["content"], params)
            else:
                temp_objects = self.core.getVideoInfo(result["content"], params)

            if len(temp_objects) > 0:
                next = temp_objects[len(temp_objects) - 1].get("next", "false")
                if next == "true":
                    temp_objects = temp_objects[:len(temp_objects) - 1]
                ytobjects += temp_objects
            else:
                self.common.log("Didn't get any temp_objects. This should NOT happen")

        if get("user_feed"):
            if get("user_feed") != "playlist" and get("action") != "play_all":
                ytobjects.sort(key=lambda item: item["Title"].lower(), reverse=False)
            elif (self.storage.getReversePlaylistOrder(params)):
                ytobjects.reverse()

        self.common.log(repr(ytobjects), 4)
        return ytobjects

########NEW FILE########
__FILENAME__ = YouTubeLogin
'''
    YouTube plugin for XBMC
    Copyright (C) 2010-2012 Tobias Ussing And Henrik Mosgaard Jensen

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import re
import sys
import time
try: import simplejson as json
except ImportError: import json

# ERRORCODES:
# 0 = Ignore
# 200 = OK
# 303 = See other (returned an error message)
# 500 = uncaught error


class YouTubeLogin():
    APIKEY = "AI39si6hWF7uOkKh4B9OEAX-gK337xbwR9Vax-cdeF9CF9iNAcQftT8NVhEXaORRLHAmHxj6GjM-Prw04odK4FxACFfKkiH9lg"

    urls = {}
    urls[u"oauth_api_login"] = u"https://accounts.google.com/o/oauth2/auth?client_id=208795275779.apps.googleusercontent.com&redirect_uri=urn:ietf:wg:oauth:2.0:oob&scope=http%3A%2F%2Fgdata.youtube.com&response_type=code"

    def __init__(self):
        self.xbmc = sys.modules["__main__"].xbmc

        self.pluginsettings = sys.modules["__main__"].pluginsettings
        self.settings = sys.modules["__main__"].settings
        self.language = sys.modules["__main__"].language
        self.plugin = sys.modules["__main__"].plugin
        self.dbg = sys.modules["__main__"].dbg

        self.utils = sys.modules["__main__"].utils
        self.core = sys.modules["__main__"].core
        self.common = sys.modules["__main__"].common

    def login(self, params={}):
        get = params.get
        self.common.log("")

        old_user_name = self.pluginsettings.userName()
        old_user_password = self.pluginsettings.userPassword()
        self.settings.openSettings()

        user_name = self.pluginsettings.userName()
        user_password = self.pluginsettings.userPassword()

        self.dbg = self.pluginsettings.debugModeIsEnabled()
        result = ""
        status = 500

        if not user_name:
            return (result, 200)

        refreshed = False
        if get("new", "false") == "false" and self.pluginsettings.authenticationRefreshRoken and old_user_name == user_name and old_user_password == user_password:
            self.common.log("refreshing token: " + str(refreshed))
            refreshed = self.core._oRefreshToken()

        if not refreshed:
            result, status = self.authorize()

        self.xbmc.executebuiltin("Container.Refresh")
        return (result, status)

    def authorize(self):
        self.common.log("token not refresh, or new uname or password")
        self.settings.setSetting("oauth2_access_token", "")
        self.settings.setSetting("oauth2_refresh_token", "")
        self.settings.setSetting("oauth2_expires_at", "")
        (result, status) = self._httpLogin({"new": "true"})
        if status == 200:
            (result, status) = self._apiLogin()
        if status == 200:
            self.utils.showErrorMessage(self.language(30031), result, 303)
        else:
            self.utils.showErrorMessage(self.language(30609), result, status)
        return result, status

    def _apiLogin(self):
        self.common.log("")

        url = self.urls[u"oauth_api_login"]

        logged_in = False
        fetch_options = {"link": url}
        step = 0
        self.common.log("Go to the api login page")
        while not logged_in and fetch_options and step < 6:
            self.common.log("Step : " + str(step))
            step += 1

            ret = self.core._fetchPage(fetch_options)
            fetch_options = False

            for accounts in self.common.parseDOM(ret["content"], "ol", attrs={"id": "account-list"}):
                self.common.log("Detected google plus with page administrator.")
                acurl = self.common.parseDOM(accounts, "a", ret="href")
                acname = self.common.parseDOM(accounts, "span", attrs={"class": "account-name"})
                if len(acurl):
                    fetch_options = {"link": acurl[0].replace("&amp;", "&")}
                    continue

            newurl = self.common.parseDOM(ret["content"], "form", attrs={"method": "POST"}, ret="action")
            state_wrapper = self.common.parseDOM(ret["content"], "input", attrs={"id": "state_wrapper"}, ret="value")

            if len(newurl) > 0 and len(state_wrapper) > 0:
                url_data = {"state_wrapper": state_wrapper[0],
                            "submit_access": "true"}

                fetch_options = {"link": newurl[0].replace("&amp;", "&"), "url_data": url_data}
                self.common.log("Press 'Accept' button")
                continue

            code = self.common.parseDOM(ret["content"], "input", attrs={"id": "code"}, ret="value")
            if len(code) > 0:
                url = "https://accounts.google.com/o/oauth2/token"
                url_data = {"client_id": "208795275779.apps.googleusercontent.com",
                            "client_secret": "sZn1pllhAfyonULAWfoGKCfp",
                            "code": code[0],
                            "redirect_uri": "urn:ietf:wg:oauth:2.0:oob",
                            "grant_type": "authorization_code"}
                fetch_options = {"link": url, "url_data": url_data}
                self.common.log("Extract and use access code")
                continue

            # use token
            if ret["content"].find("access_token") > -1:
                self.common.log("Saving access_token")
                oauth = json.loads(ret["content"])

                if len(oauth) > 0:
                    self.settings.setSetting("oauth2_expires_at", str(int(oauth["expires_in"]) + time.time()))
                    self.settings.setSetting("oauth2_access_token", oauth["access_token"])
                    self.settings.setSetting("oauth2_refresh_token", oauth["refresh_token"])

                    logged_in = True
                    self.common.log("Done: " + self.settings.getSetting("username"))

        if logged_in:
            return (self.language(30030), 200)
        else:
            self.common.log("Failed")
            return (self.language(30609), 303)

    def _httpLogin(self, params={}):
        get = params.get
        self.common.log("")

        if get("new", "false") == "true" or get("page", "false") != "false":
            self.settings.setSetting("cookies_saved", "false")
        elif self.settings.getSetting("cookies_saved") == "true":
            self.common.log("Use saved cookies")
            return (self.settings.getSetting("cookies_saved"), 200)

        fetch_options = {"link": get("link", "http://www.youtube.com/"), "no-language-cookie": "true"}

        step = 0
        galx = ""
        ret = {}

        while fetch_options and step < 18:  # 6 steps for 2-factor login
            self.common.log("Step : " + str(step))
            step += 1

            if step == 17:
                return (self.core._findErrors(ret), 303)

            ret = self.core._fetchPage(fetch_options)

            if ret["content"].find(" captcha") > -1:
                self.common.log("Captcha needs to be filled")
                break
            fetch_options = False

            # Check if we are logged in.
#            nick = self.common.parseDOM(ret["content"], "p", attrs={"class": "masthead-expanded-acct-sw-id2"})
            nick = self.common.parseDOM(ret["content"], "span", attrs={"id": "yt-masthead-user-displayname"})


            # Check if there are any errors to report
            errors = self.core._findErrors(ret, silent=True)
            if errors:
                if errors.find("cookie-clear-message-1") == -1 and (errors.find("The code you entered didn") == -1 or (errors.find("The code you entered didn") > -1 and step > 12)):
                    self.common.log("Returning error: " + repr(errors))
                    return (errors, 303)

            if len(nick) > 0 and nick[0] != "Sign In":
                self.common.log("Logged in. Parsing data: " + repr(nick))
                sys.modules["__main__"].cookiejar.save()
                self.settings.setSetting("cookies_saved", "true")
                return(ret, 200)

            # Click login link on youtube.com
            newurl = self.common.parseDOM(ret["content"], "button", attrs={"href": ".*?ServiceLogin.*?"}, ret="href")
            if len(newurl) > 0:
                # Start login procedure
                if newurl[0] != "#":
                    fetch_options = {"link": newurl[0].replace("&amp;", "&"), "referer": ret["location"]}
                    self.common.log("Part A : " + repr(fetch_options))

            # Fill out login information and send.
            newurl = self.common.parseDOM(ret["content"].replace("\n", " "), "form", attrs={"id": "gaia_loginform"}, ret="action")
            if len(newurl) > 0:
                (galx, url_data) = self._fillLoginInfo(ret)
                if len(galx) > 0 and len(url_data) > 0:
                    fetch_options = {"link": newurl[0], "url_data": url_data, "hidden": "true", "referer": ret["location"]}
                    self.common.log("Part B")
                    self.common.log("fetch options: " + repr(fetch_options), 10)  # WARNING, SHOWS LOGIN INFO/PASSWORD
                    continue

            newurl = self.common.parseDOM(ret["content"], "meta", attrs={"http-equiv": "refresh"}, ret="content")
            if len(newurl) > 0:
                newurl = newurl[0].replace("&amp;", "&")
                newurl = newurl[newurl.find("&#39;") + 5:newurl.rfind("&#39;")]
                fetch_options = {"link": newurl, "referer": ret["location"]}
                self.common.log("Part C: "  + repr(fetch_options))
                continue

            ## 2-factor login start
            if ret["content"].find("smsUserPin") > -1:
                url_data = self._fillUserPin(ret["content"])
                if len(url_data) == 0:
                    return (False, 500)

                new_part = self.common.parseDOM(ret["content"], "form", attrs={"id": "gaia_secondfactorform"}, ret="action")
                t_url = ret["new_url"]
                t_url = t_url[:t_url.find("/", 10) + 1] + new_part[0].replace("&amp;", "&")
                fetch_options = {"link": t_url, "url_data": url_data, "referer": ret["new_url"]}

                self.common.log("Part D: " + repr(fetch_options))
                continue

            smsToken = self.common.parseDOM(ret["content"].replace("\n", ""), "input", attrs={"name": "smsToken"}, ret="value")

            if len(smsToken) > 0 and galx != "":
                url_data = {"smsToken": smsToken[0],
                            "PersistentCookie": "yes",
                            "service": "youtube",
                            "GALX": galx}

                target_url = self.common.parseDOM(ret["content"], "form", attrs={"name": "hiddenpost"}, ret="action")
                fetch_options = {"link": target_url[0], "url_data": url_data, "referer": ret["location"]}
                self.common.log("Part E: " + repr(fetch_options))
                continue

            ## 2-factor login finish
            if not fetch_options:
                # Check for errors.
                return (self.core._findErrors(ret), 303)

        return (ret, 500)

    def _fillLoginInfo(self, ret):
        self.common.log("")
        content = ret["content"]

        url_data = {}

        for name in self.common.parseDOM(content, "input", ret="name"):
            for val in self.common.parseDOM(content, "input", attrs={"name": name}, ret="value"):
                url_data[name] = self.common.makeAscii(val)

        self.common.log("Extracted url_data: " + repr(url_data), 0)
        url_data["Email"] = self.pluginsettings.userName()
        url_data["Passwd"] = self.pluginsettings.userPassword()
        if url_data["Passwd"] == "":
            url_data["Passwd"] = self.common.getUserInput(self.language(30628), hidden=True)

        self.common.log("Done")
        return (url_data["GALX"], url_data)

    def _fillUserPin(self, content):
        self.common.log("")
        #form = self.common.parseDOM(content, "form", attrs={"id": "gaia_secondfactorform"}, ret=True)
        form = self.common.parseDOM(content, "form", attrs={"id": "gaia_secondfactorform"}, ret=True)

        url_data = {}
        for name in self.common.parseDOM(form, "input", ret="name"):
            if name not in ["smsSend", "retry"]:
                #for val in self.common.parseDOM(form, "input", attrs={"name": name}, ret="value"):
                #    url_data[name] = self.common.makeAscii(val)
             if name not in ["smsSend", "retry"]:
                 for val in self.common.parseDOM(form, "input", attrs={"name": name}, ret="value"):
                     url_data[name] = self.common.makeAscii(val)
                

        self.common.log("url_data: " + repr(form), 0)

        if "smsToken" in url_data:
            self.smsToken = url_data["smsToken"]
        if "continue" in url_data:
            url_data["continue"] = url_data["continue"].replace("&amp;", "&")
        userpin = self.common.getUserInputNumbers(self.language(30627))

        if len(userpin) > 0:
            url_data["smsUserPin"] = userpin
            self.common.log("Done: " + repr(url_data))
            url_data["smsVerifyPin"] = "Verify" # Overwrite this variable since it might contain unicode.
            return url_data
        else:
            self.common.log("Error")
            return {}

########NEW FILE########
__FILENAME__ = YouTubeNavigation
'''
   YouTube plugin for XBMC
   Copyright (C) 2010-2012 Tobias Ussing And Henrik Mosgaard Jensen

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import sys
import urllib


class YouTubeNavigation():
    def __init__(self):
        self.xbmc = sys.modules["__main__"].xbmc
        self.xbmcgui = sys.modules["__main__"].xbmcgui
        self.xbmcplugin = sys.modules["__main__"].xbmcplugin

        self.settings = sys.modules["__main__"].settings
        self.language = sys.modules["__main__"].language
        self.plugin = sys.modules["__main__"].plugin
        self.dbg = sys.modules["__main__"].dbg

        self.utils = sys.modules["__main__"].utils
        self.core = sys.modules["__main__"].core
        self.common = sys.modules["__main__"].common
        self.cache = sys.modules["__main__"].cache

        self.pluginsettings = sys.modules["__main__"].pluginsettings
        self.playlist = sys.modules["__main__"].playlist
        self.login = sys.modules["__main__"].login
        self.feeds = sys.modules["__main__"].feeds
        self.player = sys.modules["__main__"].player
        self.downloader = sys.modules["__main__"].downloader
        self.storage = sys.modules["__main__"].storage
        self.scraper = sys.modules["__main__"].scraper
        self.subtitles = sys.modules["__main__"].subtitles

        # This list contains the main menu structure the user first encounters when running the plugin
        #     label                        , path                                          , thumbnail                    ,  login                  ,  feed / action
        self.categories = (
            {'Title':self.language(30044)  ,'path':"/root/explore"                         , 'thumbnail':"explore"           , 'login':"false" },
            {'Title':self.language(30041)  ,'path':"/root/explore/categories"              , 'thumbnail':"explore"           , 'login':"false" , 'feed':'feed_categories', 'folder':'true'},
            {'Title':self.language(30001)  ,'path':"/root/explore/feeds"                   , 'thumbnail':"feeds"             , 'login':"false" },
            {'Title':self.language(30009)  ,'path':"/root/explore/feeds/discussed"         , 'thumbnail':"most"              , 'login':"false" , 'feed':"feed_discussed" },
            {'Title':self.language(30010)  ,'path':"/root/explore/feeds/linked"            , 'thumbnail':"most"              , 'login':"false" , 'feed':"feed_linked" },
            {'Title':self.language(30011)  ,'path':"/root/explore/feeds/viewed"            , 'thumbnail':"most"              , 'login':"false" , 'feed':"feed_viewed" },
            {'Title':self.language(30012)  ,'path':"/root/explore/feeds/recent"            , 'thumbnail':"most"              , 'login':"false" , 'feed':"feed_recent" },
            {'Title':self.language(30013)  ,'path':"/root/explore/feeds/responded"         , 'thumbnail':"most"              , 'login':"false" , 'feed':"feed_responded" },
            {'Title':self.language(30050)  ,'path':"/root/explore/feeds/shared"            , 'thumbnail':"most"              , 'login':"false" , 'feed':"feed_shared" },
            {'Title':self.language(30014)  ,'path':"/root/explore/feeds/featured"          , 'thumbnail':"featured"          , 'login':"false" , 'feed':"feed_featured" },
            {'Title':self.language(30049)  ,'path':"/root/explore/feeds/trending"          , 'thumbnail':"featured"          , 'login':"false" , 'feed':"feed_trending" },
            {'Title':self.language(30015)  ,'path':"/root/explore/feeds/favorites"         , 'thumbnail':"top"               , 'login':"false" , 'feed':"feed_favorites" },
            {'Title':self.language(30016)  ,'path':"/root/explore/feeds/rated"             , 'thumbnail':"top"               , 'login':"false" , 'feed':"feed_rated" },
            {'Title':self.language(30052)  ,'path':"/root/explore/music"                   , 'thumbnail':"music"             , 'login':"false" , 'store':"disco_searches", "folder":"true" },
            {'Title':self.language(30040)  ,'path':"/root/explore/music/new"               , 'thumbnail':"search"            , 'login':"false" , 'scraper':"search_disco"},
            {'Title':self.language(30032)  ,'path':"/root/explore/trailers"                , 'thumbnail':"trailers"          , 'login':"false" , 'feed':'uploads', 'contact':"trailers", "external":"true"},
            {'Title':self.language(30051)  ,'path':"/root/explore/live"                    , 'thumbnail':"live"              , 'login':"false" , 'feed':"feed_live" },
            {'Title':self.language(30019)  ,'path':"/root/recommended"                     , 'thumbnail':"recommended"       , 'login':"true"  , 'user_feed':"recommended" },
            {'Title':self.language(30008)  ,'path':"/root/watch_later"                     , 'thumbnail':"watch_later"       , 'login':"true"  , 'user_feed':"watch_later" },
            {'Title':self.language(30056)  ,'path':"/root/liked"                           , 'thumbnail':"liked"             , 'login':"true"  , 'scraper':"liked_videos" },
            {'Title':self.language(30059)  ,'path':"/root/history"                         , 'thumbnail':"history"           , 'login':"true"  , 'user_feed':"watch_history" },
            {'Title':self.language(30018)  ,'path':"/root/contacts"                        , 'thumbnail':"contacts"          , 'login':"true"  , 'user_feed':"contacts", 'folder':'true' },
            {'Title':self.language(30024)  ,'path':"/root/contacts/new"                    , 'thumbnail':"contacts"          , 'login':"true"  , 'action':"add_contact"},
            {'Title':self.language(30002)  ,'path':"/root/favorites"                       , 'thumbnail':"favorites"         , 'login':"true"  , 'user_feed':"favorites" },
            {'Title':self.language(30017)  ,'path':"/root/playlists"                       , 'thumbnail':"playlists"         , 'login':"true"  , 'user_feed':"playlists", 'folder':'true' },
            {'Title':self.language(30003)  ,'path':"/root/subscriptions"                   , 'thumbnail':"subscriptions"     , 'login':"true"  , 'user_feed':"subscriptions", 'folder':'true' },
            {'Title':self.language(30004)  ,'path':"/root/subscriptions/new"               , 'thumbnail':"newsubscriptions"  , 'login':"true"  , 'user_feed':"newsubscriptions" },
            {'Title':self.language(30005)  ,'path':"/root/uploads"                         , 'thumbnail':"uploads"           , 'login':"true"  , 'user_feed':"uploads" },
            {'Title':self.language(30045)  ,'path':"/root/downloads"                       , 'thumbnail':"downloads"         , 'login':"false" , 'feed':"downloads" },
            {'Title':self.language(30006)  ,'path':"/root/search"                          , 'thumbnail':"search"            , 'login':"false" , 'store':"searches", 'folder':'true' },
            {'Title':self.language(30007)  ,'path':"/root/search/new"                      , 'thumbnail':"search"            , 'login':"false" , 'feed':"search" },
            {'Title':self.language(30027)  ,'path':"/root/login"                           , 'thumbnail':"login"             , 'login':"false" , 'action':"settings" },
            {'Title':self.language(30028)  ,'path':"/root/settings"                        , 'thumbnail':"settings"          , 'login':"true"  , 'action':"settings" }
                                         )

    #==================================== Main Entry Points===========================================
    def listMenu(self, params={}):
        self.common.log(repr(params), 5)
        get = params.get
        cache = True

        path = get("path", "/root")
        if get("feed") not in ["search", "related"] and not get("channel") and not get("contact") and not get("playlist") and get("page", "0") == "0" and get("scraper") not in ["search_disco", "music_artist"]:
            for category in self.categories:
                cat_get = category.get
                if (cat_get("path").find(path + "/") > - 1):
                    if (cat_get("path").rfind("/") <= len(path + "/")):
                        setting = self.settings.getSetting(cat_get("path").replace("/root/explore/", "").replace("/root/", ""))
                        if not setting or setting == "true":
                            if cat_get("feed") == "downloads":
                                if (self.settings.getSetting("download_path")):
                                    self.addListItem(params, category)
                            else:
                                self.addListItem(params, category)

        if (get("feed") or get("user_feed") or get("options") or get("store") or get("scraper")):
            return self.list(params)

        video_view = self.settings.getSetting("list_view") == "1"

        if (video_view):
            self.xbmc.executebuiltin("Container.SetViewMode(500)")

        self.xbmcplugin.endOfDirectory(handle=int(sys.argv[1]), succeeded=True, cacheToDisc=cache)
        self.common.log("Done", 5)

    def executeAction(self, params={}):
        self.common.log(params, 3)
        get = params.get
        if (get("action") == "settings"):
            self.login.login(params)
        if (get("action") in ["delete_search", "delete_disco"]):
            self.storage.deleteStoredSearch(params)
        if (get("action") in ["edit_search", "edit_disco"]):
            self.storage.editStoredSearch(params)
            self.listMenu(params)
        if (get("action") == "remove_favorite"):
            self.removeFromFavorites(params)
        if (get("action") == "add_favorite"):
            self.addToFavorites(params)
        if (get("action") == "remove_contact"):
            self.removeContact(params)
        if (get("action") == "add_contact"):
            self.addContact(params)
        if (get("action") == "remove_subscription"):
            self.removeSubscription(params)
        if (get("action") == "add_subscription"):
            self.addSubscription(params)
        if (get("action") == "download"):
            self.downloadVideo(params)
        if (get("action") == "play_video"):
            self.player.playVideo(params)
        if (get("action") == "queue_video"):
            self.playlist.queueVideo(params)
        if (get("action") == "change_subscription_view"):
            self.storage.changeSubscriptionView(params)
            self.list(params)
        if (get("action") == "play_all"):
            self.playlist.playAll(params)
        if (get("action") == "add_to_playlist"):
            self.playlist.addToPlaylist(params)
        if (get("action") == "remove_from_playlist"):
            self.playlist.removeFromPlaylist(params)
        if (get("action") == "delete_playlist"):
            self.playlist.deletePlaylist(params)
        if (get("action") == "reverse_order"):
            self.storage.reversePlaylistOrder(params)
        if (get("action") == "create_playlist"):
            self.playlist.createPlaylist(params)
        self.common.log("Done", 5)

    #==================================== Item Building and Listing ===========================================
    def list(self, params={}):
        self.common.log("", 5)
        get = params.get
        results = []
        if (get("feed") == "search" or get("scraper") == "search_disco"):
            if not get("search"):
                query = self.common.getUserInput(self.language(30006), '').strip()
                if not query:
                    return False
                params["search"] = query
            if get("scraper") == "search_disco":
                params["store"] = "disco_searches"
            self.storage.saveStoredSearch(params)
            if get("scraper") == "search_disco":
                del params["store"]

        if get("scraper"):
            (results, status) = self.scraper.scrape(params)
        elif get("store"):
            (results, status) = self.storage.list(params)
            self.common.log("store returned " + repr(results))
        else:
            (results, status) = self.feeds.list(params)

        if status == 200:
            if get("folder", "false") != "false":
                self.parseFolderList(params, results)
            else:
                self.parseVideoList(params, results)
                self.common.log("Done", 5)
                return True
        else:
            self.showListingError(params)
            self.common.log("Error")
            return False

    def showListingError(self, params={}):
        self.common.log(repr(params), 5)
        get = params.get
        label = ""
        if get("external"):
            categories = self.storage.user_options
        else:
            categories = self.categories

        for category in categories:
            cat_get = category.get
            if (
                (get("feed") and cat_get("feed") == get("feed")) or
                (get("user_feed") and cat_get("user_feed") == get("user_feed")) or
                (get("scraper") and cat_get("scraper") == get("scraper"))
                ):
                label = cat_get("Title")

        if get("channel"):
            label = get("channel")
        if get("playlist"):
            label = self.language(30615)
        if label:
            self.utils.showMessage(label, self.language(30601))
        self.common.log("Done", 5)

    #================================== Plugin Actions =========================================
    def downloadVideo(self, params):
        get = params.get
        self.common.log(repr(params))
        if not self.settings.getSetting("download_path"):
            self.common.log("Download path missing. Opening settings")
            self.utils.showMessage(self.language(30600), self.language(30611))
            self.settings.openSettings()

        download_path = self.settings.getSetting("download_path")
        if not download_path:
            return

        self.common.log("path: " + repr(download_path))
        (video, status) = self.player.buildVideoObject(params)

        if "video_url" in video and download_path:
            params["Title"] = video['Title']
            params["url"] = video['video_url']
            params["download_path"] = download_path
            filename = "%s-[%s].mp4" % (''.join(c for c in video['Title'] if c not in self.utils.INVALID_CHARS), video["videoid"])

            self.subtitles.downloadSubtitle(video)
            if get("async"):
                self.downloader.download(filename, params, async=False)
            else:
                self.downloader.download(filename, params)
        else:
            if "apierror" in video:
                self.utils.showMessage(self.language(30625), video["apierror"])
            else:
                self.utils.showMessage(self.language(30625), "ERROR")

    def addToFavorites(self, params={}):
        self.common.log("", 5)
        get = params.get
        if (get("videoid")):
            (message, status) = self.core.add_favorite(params)
            if status != 200:
                self.utils.showErrorMessage(self.language(30020), message, status)
                self.common.log("Error", 5)
                return False
        self.common.log("Done", 5)
        return True

    def removeFromFavorites(self, params={}):
        self.common.log("", 5)
        get = params.get

        if (get("editid")):
            (message, status) = self.core.delete_favorite(params)
            if status != 200:
                self.utils.showErrorMessage(self.language(30020), message, status)
                return False
            self.xbmc.executebuiltin("Container.Refresh")

        self.common.log("Done", 5)
        return True

    def addContact(self, params={}):
        self.common.log("", 5)
        get = params.get

        if not get("contact"):
            contact = self.common.getUserInput(self.language(30519), '')
            params["contact"] = contact

        if (get("contact")):
            (result, status) = self.core.add_contact(params)
            if status != 200:
                self.utils.showErrorMessage(self.language(30029), result, status)
                return False
            self.utils.showMessage(self.language(30613), get("contact"))
            self.xbmc.executebuiltin("Container.Refresh")

        self.common.log("Done", 5)
        return True

    def removeContact(self, params={}):
        self.common.log("", 5)
        get = params.get

        if (get("contact")):
            (result, status) = self.core.remove_contact(params)
            if status != 200:
                self.utils.showErrorMessage(self.language(30029), result, status)
                return False

            self.utils.showMessage(self.language(30614), get("contact"))
            self.xbmc.executebuiltin("Container.Refresh")
        return True

    def addSubscription(self, params={}):
        self.common.log("", 5)
        get = params.get
        if (get("channel")):
            (message, status) = self.core.add_subscription(params)
            if status != 200:
                self.utils.showErrorMessage(self.language(30021), message, status)
                return False
        self.common.log("Done", 5)
        return True

    def removeSubscription(self, params={}):
        self.common.log("", 5)
        get = params.get
        if (get("editid")):
            (message, status) = self.core.remove_subscription(params)
            if status != 200:
                self.utils.showErrorMessage(self.language(30021), message, status)
                return False

            self.xbmc.executebuiltin("Container.Refresh")
        self.common.log("Done", 5)
        return True

    #================================== List Item manipulation =========================================
    # is only used by List Menu
    def addListItem(self, params={}, item_params={}):
        self.common.log("", 5)
        item = item_params.get

        if (not item("action")):
            if (item("login") == "false"):
                self.addFolderListItem(params, item_params)
            else:
                if (len(self.settings.getSetting("oauth2_access_token")) > 0):
                    self.addFolderListItem(params, item_params)
        else:
            if (item("action") == "settings"):
                if (len(self.settings.getSetting("oauth2_access_token")) > 0):
                    if (item("login") == "true"):
                        self.addActionListItem(params, item_params)
                else:
                    if (item("login") == "false"):
                        self.addActionListItem(params, item_params)
            elif (item("action") == "play_video"):
                self.addVideoListItem(params, item_params, 0)
            else:
                self.addActionListItem(params, item_params)
        self.common.log("Done", 5)

    # common function for adding folder items
    def addFolderListItem(self, params={}, item_params={}, size=0):
        self.common.log("", 5)
        item = item_params.get

        icon = "DefaultFolder.png"
        if item("icon"):
            icon = self.utils.getThumbnail(item("icon"))

        thumbnail = item("thumbnail")

        cm = self.addFolderContextMenuItems(params, item_params)

        if (item("thumbnail", "DefaultFolder.png").find("http://") == - 1):
            thumbnail = self.utils.getThumbnail(item("thumbnail"))

        listitem = self.xbmcgui.ListItem(item("Title"), iconImage=icon, thumbnailImage=thumbnail)
        url = '%s?path=%s&' % (sys.argv[0], item("path"))
        url = self.utils.buildItemUrl(item_params, url)

        if len(cm) > 0:
            listitem.addContextMenuItems(cm, replaceItems=False)

        listitem.setProperty("Folder", "true")
        if (item("feed") == "downloads"):
            url = self.settings.getSetting("download_path")
        self.xbmcplugin.addDirectoryItem(handle=int(sys.argv[1]), url=url, listitem=listitem, isFolder=True, totalItems=size)
        self.common.log("Done", 5)

    # common function for adding action items
    def addActionListItem(self, params={}, item_params={}, size=0):
        self.common.log("", 5)
        item = item_params.get
        folder = True
        icon = "DefaultFolder.png"
        thumbnail = self.utils.getThumbnail(item("thumbnail"))
        listitem = self.xbmcgui.ListItem(item("Title"), iconImage=icon, thumbnailImage=thumbnail)

        if (item("action") == "playbyid"):
            folder = False
            listitem.setProperty('IsPlayable', 'true')

        url = '%s?path=%s&' % (sys.argv[0], item("path"))
        url += 'action=' + item("action") + '&'

        self.xbmcplugin.addDirectoryItem(handle=int(sys.argv[1]), url=url, listitem=listitem, isFolder=folder, totalItems=size)
        self.common.log("Done", 5)

    # common function for adding video items
    def addVideoListItem(self, params={}, item_params={}, listSize=0):
        self.common.log("", 5)
        get = params.get
        item = item_params.get

        icon = item("icon", "default")
        if(get("scraper", "").find("music") > -1):
            icon = "music"
        elif(get("scraper", "").find("disco") > -1):
            icon = "discoball"
        elif(get("feed", "").find("live") > -1):
            icon = "live"

        icon = self.utils.getThumbnail(icon)

        listitem = self.xbmcgui.ListItem(item("Title"), iconImage=icon, thumbnailImage=item("thumbnail"))

        url = '%s?path=%s&action=play_video&videoid=%s' % (sys.argv[0], "/root/video", item("videoid"))

        if get("user_feed") == "watch_later":
            url += "&watch_later=true&playlist_entry_id=%s&" % item("playlist_entry_id")

        cm = self.addVideoContextMenuItems(params, item_params)

        listitem.addContextMenuItems(cm, replaceItems=True)

        listitem.setProperty("Video", "true")
        listitem.setProperty("IsPlayable", "true")
        listitem.addStreamInfo('video', {'duration': item('Duration')})
        listitem.setInfo(type='Video', infoLabels=item_params)
        self.xbmcplugin.addDirectoryItem(handle=int(sys.argv[1]), url=url, listitem=listitem, isFolder=False, totalItems=listSize + 1)
        self.common.log("Done", 5)

    #==================================== Core Output Parsing Functions ===========================================

    # Parses a folder list consisting of a tuple of dictionaries
    def parseFolderList(self, params, results):
        self.common.log("", 5)
        listSize = len(results)
        get = params.get

        cache = True
        if get("store") or get("user_feed"):
            cache = False

        for result_params in results:
            result_params["path"] = get("path")
            self.addFolderListItem(params, result_params, listSize + 1)

        self.xbmcplugin.endOfDirectory(handle=int(sys.argv[1]), succeeded=True, cacheToDisc=cache)
        self.common.log("Done", 5)

    # parses a video list consisting of a tuple of dictionaries
    def parseVideoList(self, params, results):
        self.common.log("", 5)
        listSize = len(results)
        get = params.get

        for result_params in results:
            result_params["path"] = get("path")
            result = result_params.get

            if result("videoid") == "false":
                continue

            if get("scraper") == "watch_later":
                result_params["index"] = str(results.index(result_params) + 1)

            if result("next") == "true":
                self.addFolderListItem(params, result_params, listSize)
            else:
                self.addVideoListItem(params, result_params, listSize)

        video_view = int(self.settings.getSetting("list_view")) <= 1
        if (video_view):
            self.xbmc.executebuiltin("Container.SetViewMode(500)")

        self.xbmcplugin.addSortMethod(handle=int(sys.argv[1]), sortMethod=self.xbmcplugin.SORT_METHOD_UNSORTED)
        self.xbmcplugin.addSortMethod(handle=int(sys.argv[1]), sortMethod=self.xbmcplugin.SORT_METHOD_LABEL)
        self.xbmcplugin.addSortMethod(handle=int(sys.argv[1]), sortMethod=self.xbmcplugin.SORT_METHOD_VIDEO_RATING)
        self.xbmcplugin.addSortMethod(handle=int(sys.argv[1]), sortMethod=self.xbmcplugin.SORT_METHOD_DATE)
        self.xbmcplugin.addSortMethod(handle=int(sys.argv[1]), sortMethod=self.xbmcplugin.SORT_METHOD_PROGRAM_COUNT)
        self.xbmcplugin.addSortMethod(handle=int(sys.argv[1]), sortMethod=self.xbmcplugin.SORT_METHOD_VIDEO_RUNTIME)
        self.xbmcplugin.addSortMethod(handle=int(sys.argv[1]), sortMethod=self.xbmcplugin.SORT_METHOD_GENRE)

        self.xbmcplugin.endOfDirectory(handle=int(sys.argv[1]), succeeded=True, cacheToDisc=True)
        self.common.log("Done", 5)

    def addVideoContextMenuItems(self, params={}, item_params={}):
        self.common.log("", 5)
        cm = []
        get = params.get
        item = item_params.get

        title = self.common.makeAscii(item("Title"))
        url_title = urllib.quote_plus(title)
        studio = self.common.makeAscii(item("Studio", "Unknown Author"))
        url_studio = urllib.quote_plus(studio)

        cm.append((self.language(30504), "XBMC.Action(Queue)",))

        if (get("playlist")):
            cm.append((self.language(30521), "XBMC.RunPlugin(%s?path=%s&action=play_all&playlist=%s&videoid=%s&)" % (sys.argv[0], item("path"), get("playlist"), item("videoid"))))

        if (get("user_feed") == "newsubscriptions" or get("user_feed") == "favorites"):
            contact = "default"
            if get("contact"):
                contact = get("contact")
            cm.append((self.language(30521), "XBMC.RunPlugin(%s?path=%s&action=play_all&user_feed=%s&contact=%s&videoid=%s&)" % (sys.argv[0], item("path"), get("user_feed"), contact, item("videoid"))))

        cm.append((self.language(30501), "XBMC.RunPlugin(%s?path=%s&action=download&videoid=%s)" % (sys.argv[0], item("path"), item("videoid"))))

        if (self.settings.getSetting("username") != "" and self.settings.getSetting("oauth2_access_token")):
            if (get("user_feed") == "favorites" and not get("contact")):
                cm.append((self.language(30506), 'XBMC.RunPlugin(%s?path=%s&action=remove_favorite&editid=%s&)' % (sys.argv[0], item("path"), item("editid"))))
            else:
                cm.append((self.language(30503), 'XBMC.RunPlugin(%s?path=%s&action=add_favorite&videoid=%s&)' % (sys.argv[0], item("path"), item("videoid"))))

            if (get("external") == "true" or (get("feed") not in ["subscriptions_favorites", "subscriptions_uploads", "subscriptions_playlists"] and (get("user_feed") != "uploads" and not get("external")))):
                cm.append((self.language(30512) % studio, 'XBMC.RunPlugin(%s?path=%s&channel=%s&action=add_subscription)' % (sys.argv[0], item("path"), url_studio)))

            if (get("playlist") and item("playlist_entry_id")):
                cm.append((self.language(30530), "XBMC.RunPlugin(%s?path=%s&action=remove_from_playlist&playlist=%s&playlist_entry_id=%s&)" % (sys.argv[0], item("path"), get("playlist"), item("playlist_entry_id"))))
            cm.append((self.language(30528), "XBMC.RunPlugin(%s?path=%s&action=add_to_playlist&videoid=%s&)" % (sys.argv[0], item("path"), item("videoid"))))

        if (get("feed") != "uploads" and get("user_feed") != "uploads"):
            cm.append((self.language(30516) % studio, "XBMC.Container.Update(%s?path=%s&feed=uploads&channel=%s)" % (sys.argv[0], get("path"), url_studio)))

        cm.append((self.language(30514), "XBMC.Container.Update(%s?path=%s&feed=search&search=%s)" % (sys.argv[0], get("path"), url_title)))
        cm.append((self.language(30527), "XBMC.Container.Update(%s?path=%s&feed=related&videoid=%s)" % (sys.argv[0], get("path"), item("videoid"))))
        cm.append((self.language(30523), "XBMC.ActivateWindow(VideoPlaylist)"))
        cm.append((self.language(30502), "XBMC.Action(Info)",))

        self.common.log("Done", 5)
        return cm

    def addFolderContextMenuItems(self, params={}, item_params={}):
        self.common.log("", 5)
        cm = []
        get = params.get
        item = item_params.get

        if (item("next", "false") == "true"):
            return cm

        if (item("user_feed") in ["favorites", "newsubscriptions", "watch_later", "recommended"]):
            cm.append((self.language(30520), "XBMC.RunPlugin(%s?path=%s&action=play_all&user_feed=%s&contact=%s&login=true&)" % (sys.argv[0], item("path"), item("user_feed"), "default")))
            cm.append((self.language(30522), "XBMC.RunPlugin(%s?path=%s&action=play_all&shuffle=true&user_feed=%s&contact=%s&login=true&)" % (sys.argv[0], item("path"), item("user_feed"), "default")))

        if item("scraper") in ["liked_videos"]:
            cm.append((self.language(30520), "XBMC.RunPlugin(%s?path=%s&action=play_all&scraper=%s&login=true&)" % (sys.argv[0], item("path"), item("scraper"))))
            cm.append((self.language(30522), "XBMC.RunPlugin(%s?path=%s&action=play_all&shuffle=true&scraper=%s&login=true&)" % (sys.argv[0], item("path"), item("scraper"))))

        if (item("playlist")):
            cm.append((self.language(30531), "XBMC.RunPlugin(%s?path=%s&action=reverse_order&playlist=%s&)" % (sys.argv[0], item("path"), item("playlist"))))
            cm.append((self.language(30520), "XBMC.RunPlugin(%s?path=%s&action=play_all&user_feed=playlist&playlist=%s&)" % (sys.argv[0], item("path"), item("playlist"))))
            cm.append((self.language(30522), "XBMC.RunPlugin(%s?path=%s&action=play_all&user_feed=playlist&shuffle=true&playlist=%s&)" % (sys.argv[0], item("path"), item("playlist"))))
            if not get("external"):
                cm.append((self.language(30539), "XBMC.RunPlugin(%s?path=%s&action=delete_playlist&playlist=%s&)" % (sys.argv[0], item("path"), item("playlist"))))

        if (item("scraper") == "search_disco"):
            cm.append((self.language(30520), "XBMC.RunPlugin(%s?path=%s&action=play_all&scraper=search_disco&search=%s&)" % (sys.argv[0], item("path"), item("search"))))
            cm.append((self.language(30522), "XBMC.RunPlugin(%s?path=%s&action=play_all&shuffle=true&scraper=search_disco&search=%s&)" % (sys.argv[0], item("path"), item("search"))))
            if not get("scraper") == "disco_top_artist":
                cm.append((self.language(30524), 'XBMC.Container.Update(%s?path=%s&action=edit_disco&store=disco_searches&search=%s&)' % (sys.argv[0], item("path"), item("search"))))
                cm.append((self.language(30525), 'XBMC.RunPlugin(%s?path=%s&action=delete_disco&store=disco_searches&delete=%s&)' % (sys.argv[0], item("path"), item("search"))))

        if (item("feed") == "search"):
            cm.append((self.language(30515), 'XBMC.Container.Update(%s?path=%s&action=edit_search&store=searches&search=%s&)' % (sys.argv[0], item("path"), item("search"))))
            cm.append((self.language(30508), 'XBMC.RunPlugin(%s?path=%s&action=delete_search&store=searches&delete=%s&)' % (sys.argv[0], item("path"), item("search"))))

        if (item("view_mode")):
            cm_url = 'XBMC.Container.Update(%s?path=%s&channel=%s&action=change_subscription_view&view_mode=%s&' % (sys.argv[0], item("path"), item("channel"), "%s")
            if (item("external")):
                cm_url += "external=true&contact=" + get("contact") + "&"
            cm_url += ")"

            if (item("user_feed") == "favorites"):
                cm.append((self.language(30511), cm_url % ("uploads")))
                cm.append((self.language(30526), cm_url % ("playlists&folder=true")))
            elif(item("user_feed") == "playlists"):
                cm.append((self.language(30511), cm_url % ("uploads")))
                cm.append((self.language(30510), cm_url % ("favorites")))
            elif (item("user_feed") == "uploads"):
                cm.append((self.language(30510), cm_url % ("favorites")))
                cm.append((self.language(30526), cm_url % ("playlists&folder=true")))

        if (item("channel") or item("contact")):
            if (self.settings.getSetting("username") != "" and self.settings.getSetting("oauth2_access_token")):
                title = self.common.makeAscii(item("channel", ""))
                if (get("external")):
                    channel = get("channel", "")
                    if not channel:
                        channel = get("contact")
                    cm.append((self.language(30512) % title, 'XBMC.RunPlugin(%s?path=%s&channel=%s&action=add_subscription)' % (sys.argv[0], item("path"), channel)))
                elif item("editid"):
                    cm.append((self.language(30513) % title, 'XBMC.RunPlugin(%s?path=%s&editid=%s&action=remove_subscription)' % (sys.argv[0], item("path"), item("editid"))))

        if (item("contact") and not get("store")):
            if (self.pluginsettings.userHasProvidedValidCredentials()):
                if (item("external")):
                    cm.append((self.language(30026), 'XBMC.RunPlugin(%s?path=%s&action=add_contact&contact=%s&)' % (sys.argv[0], item("path"), item("Title"))))
                else:
                    cm.append((self.language(30025), 'XBMC.RunPlugin(%s?path=%s&action=remove_contact&contact=%s&)' % (sys.argv[0], item("path"), item("Title"))))

        cm.append((self.language(30523), "XBMC.ActivateWindow(VideoPlaylist)"))
        self.common.log("Done", 5)
        return cm

########NEW FILE########
__FILENAME__ = YouTubePlayer
'''
   YouTube plugin for XBMC
    Copyright (C) 2010-2012 Tobias Ussing And Henrik Mosgaard Jensen

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import re
import sys
import cgi
import urllib
try: import simplejson as json
except ImportError: import json

class YouTubePlayer():
    fmt_value = {
        5: "240p h263 flv container",
        18: "360p h264 mp4 container | 270 for rtmpe?",
        22: "720p h264 mp4 container",
        26: "???",
        33: "???",
        34: "360p h264 flv container",
        35: "480p h264 flv container",
        37: "1080p h264 mp4 container",
        38: "720p vp8 webm container",
        43: "360p h264 flv container",
        44: "480p vp8 webm container",
        45: "720p vp8 webm container",
        46: "520p vp8 webm stereo",
        59: "480 for rtmpe",
        78: "seems to be around 400 for rtmpe",
        82: "360p h264 stereo",
        83: "240p h264 stereo",
        84: "720p h264 stereo",
        85: "520p h264 stereo",
        100: "360p vp8 webm stereo",
        101: "480p vp8 webm stereo",
        102: "720p vp8 webm stereo",
        120: "hd720",
        121: "hd1080"
        }

    # YouTube Playback Feeds
    urls = {}
    urls['video_stream'] = "http://www.youtube.com/watch?v=%s&safeSearch=none"
    urls['embed_stream'] = "http://www.youtube.com/get_video_info?video_id=%s"
    urls['video_info'] = "http://gdata.youtube.com/feeds/api/videos/%s"


    def __init__(self):
        self.xbmcgui = sys.modules["__main__"].xbmcgui
        self.xbmcplugin = sys.modules["__main__"].xbmcplugin

        self.pluginsettings = sys.modules["__main__"].pluginsettings
        self.storage = sys.modules["__main__"].storage
        self.settings = sys.modules["__main__"].settings
        self.language = sys.modules["__main__"].language
        self.dbg = sys.modules["__main__"].dbg

        self.common = sys.modules["__main__"].common
        self.utils = sys.modules["__main__"].utils
        self.cache = sys.modules["__main__"].cache
        self.core = sys.modules["__main__"].core
        self.login = sys.modules["__main__"].login
        self.subtitles = sys.modules["__main__"].subtitles

        self.algoCache = {}

    def playVideo(self, params={}):
        self.common.log(repr(params), 3)
        get = params.get

        (video, status) = self.buildVideoObject(params)

        if status != 200:
            self.common.log(u"construct video url failed contents of video item " + repr(video))
            self.utils.showErrorMessage(self.language(30603), video["apierror"], status)
            return False

        listitem = self.xbmcgui.ListItem(label=video['Title'], iconImage=video['thumbnail'], thumbnailImage=video['thumbnail'], path=video['video_url'])

        listitem.setInfo(type='Video', infoLabels=video)

        self.common.log(u"Playing video: " + repr(video['Title']) + " - " + repr(get('videoid')) + " - " + repr(video['video_url']))

        self.xbmcplugin.setResolvedUrl(handle=int(sys.argv[1]), succeeded=True, listitem=listitem)

        if self.settings.getSetting("lang_code") != "0" or self.settings.getSetting("annotations") == "true":
            self.subtitles.addSubtitles(video)

        if (get("watch_later") == "true" and get("playlist_entry_id")):
            self.common.log(u"removing video from watch later playlist")
            self.core.remove_from_watch_later(params)

        self.storage.storeValue("vidstatus-" + video['videoid'], "7")

    def getInfo(self, params):
        get = params.get
        video = self.cache.get("videoidcache" + get("videoid"))
        if len(video) > 0:
            self.common.log(u"returning cache ")
            return (eval(video), 200)

        result = self.core._fetchPage({"link": self.urls["video_info"] % get("videoid"), "api": "true"})

        if result["status"] == 200:
            video = self.core.getVideoInfo(result["content"], params)

            if len(video) == 0:
                self.common.log(u"- Couldn't parse API output, YouTube doesn't seem to know this video id?")
                video = {}
                video["apierror"] = self.language(30608)
                return (video, 303)
        else:
            self.common.log(u"- Got API Error from YouTube!")
            video = {}
            video["apierror"] = result["content"]

            return (video, 303)

        video = video[0]
        self.cache.set("videoidcache" + get("videoid"), repr(video))
        return (video, result["status"])

    def selectVideoQuality(self, params, links):
        get = params.get

        print "links: " + repr(type(links).__name__)
        link = links.get
        video_url = ""

        self.common.log(u"")

        if get("action") == "download":
            hd_quality = int(self.settings.getSetting("hd_videos_download"))
            if (hd_quality == 0):
                hd_quality = int(self.settings.getSetting("hd_videos"))

        else:
            if (not get("quality")):
                hd_quality = int(self.settings.getSetting("hd_videos"))
            else:
                if (get("quality") == "1080p"):
                    hd_quality = 3
                elif (get("quality") == "720p"):
                    hd_quality = 2
                else:
                    hd_quality = 1

        # SD videos are default, but we go for the highest res
        if (link(35)):
            video_url = link(35)
        elif (link(59)):
            video_url = link(59)
        elif link(44):
            video_url = link(44)
        elif (link(78)):
            video_url = link(78)
        elif (link(34)):
            video_url = link(34)
        elif (link(43)):
            video_url = link(43)
        elif (link(26)):
            video_url = link(26)
        elif (link(18)):
            video_url = link(18)
        elif (link(33)):
            video_url = link(33)
        elif (link(5)):
            video_url = link(5)

        if hd_quality > 1:  # <-- 720p
            if (link(22)):
                video_url = link(22)
            elif (link(45)):
                video_url = link(45)
            elif link(120):
                video_url = link(120)
        if hd_quality > 2:
            if (link(37)):
                video_url = link(37)
            elif link(121):
                video_url = link(121)

        if link(38) and False:
            video_url = link(38)

        for fmt_key in links.iterkeys():
            if link(int(fmt_key)):
                if self.dbg:
                    text = repr(fmt_key) + " - "
                    if fmt_key in self.fmt_value:
                        text += self.fmt_value[fmt_key]
                    else:
                        text += "Unknown"

                    if (link(int(fmt_key)) == video_url):
                        text += "*"
                    self.common.log(text)
            else:
                self.common.log(u"- Missing fmt_value: " + repr(fmt_key))

        if hd_quality == 0 and not get("quality"):
            return self.userSelectsVideoQuality(params, links)

        if not len(video_url) > 0:
            self.common.log(u"- construct_video_url failed, video_url not set")
            return video_url

        if get("action") != "download" and video_url.find("rtmp") == -1:
            video_url += '|' + urllib.urlencode({'User-Agent':self.common.USERAGENT})

        self.common.log(u"Done")
        return video_url

    def userSelectsVideoQuality(self, params, links):
        levels =    [([37,121], u"1080p"),
                     ([22,45,120], u"720p"),
                     ([35,44], u"480p"),
                     ([18], u"380p"),
                     ([34,43],u"360p"),
                     ([5],u"240p"),
                     ([17],u"144p")]

        link = links.get
        quality_list = []
        choices = []

        for qualities, name in levels:
            for quality in qualities:
                if link(quality):
                    quality_list.append((quality, name))
                    break

        for (quality, name) in quality_list:
            choices.append(name)

        dialog = self.xbmcgui.Dialog()
        selected = dialog.select(self.language(30518), choices)

        if selected > -1:
            (quality, name) = quality_list[selected]
            return link(quality)

        return u""

    def checkForErrors(self, video):
        status = 200

        if "video_url" not in video or video[u"video_url"] == u"":
            status = 303
            if u"apierror" not in video:
                vget = video.get
                if vget(u"live_play"):
                    video[u'apierror'] = self.language(30612)
                elif vget(u"stream_map"):
                    video[u'apierror'] = self.language(30620)
                else:
                    video[u'apierror'] = self.language(30618)

        return (video, status)

    def buildVideoObject(self, params):
        self.common.log(repr(params))

        (video, status) = self.getInfo(params)

        if status != 200:
            video[u'apierror'] = self.language(30618)
            return (video, 303)

        video_url = self.subtitles.getLocalFileSource(params, video)
        if video_url:
            video[u'video_url'] = video_url
            return (video, 200)

        (links, video) = self.extractVideoLinksFromYoutube(video, params)

        if len(links) != 0:
            video[u"video_url"] = self.selectVideoQuality(params, links)
        elif "hlsvp" in video:
            #hls selects the quality based on available bitrate (adaptive quality), no need to select it here
            video[u"video_url"] = video[u"hlsvp"]
            self.common.log("Using hlsvp url %s" % video[u"video_url"])

        (video, status) = self.checkForErrors(video)

        self.common.log(u"Done")

        return (video, status)

    def removeAdditionalEndingDelimiter(self, data):
        pos = data.find("};")
        if pos != -1:
            self.common.log(u"found extra delimiter, removing")
            data = data[:pos + 1]
        return data

    def normalizeUrl(self, url):
        if url[0:2] == "//":
            url = "http:" + url
        return url

    def extractFlashVars(self, data, assets=0):
        flashvars = {}
        found = False

        for line in data.split("\n"):
            if line.strip().find(";ytplayer.config = ") > 0:
                found = True
                p1 = line.find(";ytplayer.config = ") + len(";ytplayer.config = ") - 1
                p2 = line.rfind(";")
                if p1 <= 0 or p2 <= 0:
                    continue
                data = line[p1 + 1:p2]
                break
        data = self.removeAdditionalEndingDelimiter(data)

        if found:
            data = json.loads(data)
            if assets:
                flashvars = data["assets"]
            else:
                flashvars = data["args"]

        for k in ["html", "css", "js"]:
            if k in flashvars:
                flashvars[k] = self.normalizeUrl(flashvars[k])

        self.common.log("Step2: " + repr(data), 4)

        self.common.log(u"flashvars: " + repr(flashvars), 2)
        return flashvars

    def scrapeWebPageForVideoLinks(self, result, video):
        self.common.log(u"")
        links = {}

        flashvars = self.extractFlashVars(result[u"content"])
        if not flashvars.has_key(u"url_encoded_fmt_stream_map"):
            return links

        if flashvars.has_key(u"ttsurl"):
            video[u"ttsurl"] = flashvars[u"ttsurl"]

        if flashvars.has_key(u"hlsvp"):                               
            video[u"hlsvp"] = flashvars[u"hlsvp"]    

        for url_desc in flashvars[u"url_encoded_fmt_stream_map"].split(u","):
            url_desc_map = cgi.parse_qs(url_desc)
            self.common.log(u"url_map: " + repr(url_desc_map), 2)
            if not (url_desc_map.has_key(u"url") or url_desc_map.has_key(u"stream")):
                continue

            key = int(url_desc_map[u"itag"][0])
            url = u""
            if url_desc_map.has_key(u"url"):
                url = urllib.unquote(url_desc_map[u"url"][0])
            elif url_desc_map.has_key(u"conn") and url_desc_map.has_key(u"stream"):
                url = urllib.unquote(url_desc_map[u"conn"][0])
                if url.rfind("/") < len(url) -1:
                    url = url + "/"
                url = url + urllib.unquote(url_desc_map[u"stream"][0])
            elif url_desc_map.has_key(u"stream") and not url_desc_map.has_key(u"conn"):
                url = urllib.unquote(url_desc_map[u"stream"][0])

            if url_desc_map.has_key(u"sig"):
                url = url + u"&signature=" + url_desc_map[u"sig"][0]
            elif url_desc_map.has_key(u"s"):
                sig = url_desc_map[u"s"][0]
                flashvars = self.extractFlashVars(result[u"content"], 1)
                url = url + u"&signature=" + self.decrypt_signature(sig, flashvars[u"js"])

            links[key] = url

        return links

    def _jsToPy(self, jsFunBody):
        pythonFunBody = re.sub(r'function (\w*)\$(\w*)', r'function \1_S_\2', jsFunBody)
        pythonFunBody = pythonFunBody.replace('function', 'def').replace('{', ':\n\t').replace('}', '').replace(';', '\n\t').replace('var ', '')
        pythonFunBody = pythonFunBody.replace('.reverse()', '[::-1]')

        lines = pythonFunBody.split('\n')
        for i in range(len(lines)):
            # a.split("") -> list(a)
            match = re.search('(\w+?)\.split\(""\)', lines[i])
            if match:
                lines[i] = lines[i].replace( match.group(0), 'list(' + match.group(1)  + ')')
            # a.length -> len(a)
            match = re.search('(\w+?)\.length', lines[i])
            if match:
                lines[i] = lines[i].replace( match.group(0), 'len(' + match.group(1)  + ')')
            # a.slice(3) -> a[3:]
            match = re.search('(\w+?)\.slice\(([0-9]+?)\)', lines[i])
            if match:
                lines[i] = lines[i].replace( match.group(0), match.group(1) + ('[%s:]' % match.group(2)) )
            # a.join("") -> "".join(a)
            match = re.search('(\w+?)\.join\(("[^"]*?")\)', lines[i])
            if match:
                lines[i] = lines[i].replace( match.group(0), match.group(2) + '.join(' + match.group(1) + ')' )
        return "\n".join(lines)

    def _getLocalFunBody(self, funName, playerData):
        # get function body
        funName=funName.replace('$', '\\$')
        match = re.search('(function %s\([^)]+?\){[^}]+?})' % funName, playerData)
        if match:
            # return jsFunBody
            return match.group(1)
        return ''

    def _getAllLocalSubFunNames(self, mainFunBody):
        match = re.compile('[ =(,]([\w\$_]+)\([^)]*\)').findall( mainFunBody )
        if len(match):
            # first item is name of main function, so omit it
            funNameTab = set( match[1:] )
            return funNameTab
        return set()

    def decrypt_signature(self, s, playerUrl):
        self.common.log("decrypt_signature sign_len[%d] playerUrl[%s]" % (len(s), playerUrl) )

        # use algoCache
        if playerUrl not in self.algoCache:
            # get player HTML 5 sript
            res = self.core._fetchPage({u"link": playerUrl})
            playerData = res["content"]
            try:
                playerData = playerData.decode('utf-8', 'ignore')
            except Exception as ex:
                self.common.log("Error: " + str(sys.exc_info()[0]) + " - " + str(ex))
                self.common.log('Unable to download playerUrl webpage')
                return ''

            # get main function name
            match = re.search("signature=(\w+?)\([^)]\)", playerData)
            if match:
                mainFunName = match.group(1)
                self.common.log('Main signature function name = "%s"' % mainFunName)
            else:
                self.common.log('Can not get main signature function name')
                return ''

            fullAlgoCode = self._getfullAlgoCode( mainFunName, playerData )

            # wrap all local algo function into one function extractedSignatureAlgo()
            algoLines = fullAlgoCode.split('\n')
            for i in range(len(algoLines)):
                algoLines[i] = '\t' + algoLines[i]
            fullAlgoCode  = 'def extractedSignatureAlgo(param):'
            fullAlgoCode += '\n'.join(algoLines)
            fullAlgoCode += '\n\treturn %s(param)' % mainFunName
            fullAlgoCode += '\noutSignature = extractedSignatureAlgo( inSignature )\n'

            # after this function we should have all needed code in fullAlgoCode

            self.common.log( "---------------------------------------" )
            self.common.log( "|    ALGO FOR SIGNATURE DECRYPTION    |" )
            self.common.log( "---------------------------------------" )
            self.common.log( fullAlgoCode                         )
            self.common.log( "---------------------------------------" )

            try:
                algoCodeObj = compile(fullAlgoCode, '', 'exec')
            except:
                self.common.log('decryptSignature compile algo code EXCEPTION')
                return ''
        else:
            # get algoCodeObj from algoCache
            self.common.log('Algo taken from cache')
            algoCodeObj = self.algoCache[playerUrl]

        # for security alow only flew python global function in algo code
        vGlobals = {"__builtins__": None, 'len': len, 'list': list}

        # local variable to pass encrypted sign and get decrypted sign
        vLocals = { 'inSignature': s, 'outSignature': '' }

        # execute prepared code
        try:
            exec( algoCodeObj, vGlobals, vLocals )
        except:
            self.common.log('decryptSignature exec code EXCEPTION')
            return ''

        self.common.log('Decrypted signature = [%s]' % vLocals['outSignature'])
        # if algo seems ok and not in cache, add it to cache
        if playerUrl not in self.algoCache and '' != vLocals['outSignature']:
            self.common.log('Algo from player [%s] added to cache' % playerUrl)
            self.algoCache[playerUrl] = algoCodeObj

        return vLocals['outSignature']

    # Note, this method is using a recursion
    def _getfullAlgoCode( self, mainFunName, playerData, recDepth = 0, allLocalFunNamesTab=[] ):
        # Max recursion of 5
        if 5 <= recDepth:
            self.common.log('_getfullAlgoCode: Maximum recursion depth exceeded')
            return

        funBody = self._getLocalFunBody( mainFunName, playerData)
        if '' != funBody:
            funNames = self._getAllLocalSubFunNames(funBody)
            if len(funNames):
                for funName in funNames:
                    funName_=funName.replace('$','_S_')
                    if funName not in allLocalFunNamesTab:
                        funBody=funBody.replace(funName,funName_)
                        allLocalFunNamesTab.append(funName)
                        self.common.log("Add local function %s to known functions" % mainFunName)
                        funBody = self._getfullAlgoCode( funName, playerData, recDepth + 1, allLocalFunNamesTab ) + "\n" + funBody

            # conver code from javascript to python
            funBody = self._jsToPy(funBody)
            return '\n' + funBody + '\n'
        return funBody

    def getVideoPageFromYoutube(self, get, has_verified = False):
        login = "false"
        verify = ""

        if self.pluginsettings.userHasProvidedValidCredentials():
            login = "true"
            if has_verified:
                verify = u"&has_verified=1"

        page = self.core._fetchPage({u"link": (self.urls[u"video_stream"] % get(u"videoid")) + verify, "login": login})
        self.common.log("Step1: " + repr(page["content"].find("ytplayer")))

        if not page:
            page = {u"status":303}

        return page

    def isVideoAgeRestricted(self, result):
        error = self.common.parseDOM(result['content'], "div", attrs={"id": "watch7-player-age-gate-content"})
        self.common.log(repr(error))
        return len(error) > 0

    def extractVideoLinksFromYoutube(self, video, params):
        self.common.log(u"trying website: " + repr(params))
        get = params.get

        result = self.getVideoPageFromYoutube(get)
        if self.isVideoAgeRestricted(result):
            self.common.log(u"Age restricted video")
            if self.pluginsettings.userHasProvidedValidCredentials():
                result = self.getVideoPageFromYoutube(get, True)
            else:
                video[u"apierror"] = self.language(30622)

        if result[u"status"] != 200:
            self.common.log(u"Couldn't get video page from YouTube")
            return ({}, video)

        links = self.scrapeWebPageForVideoLinks(result, video)

        if len(links) == 0 and not( "hlsvp" in video ):
            self.common.log(u"Couldn't find video url- or stream-map.")

            if not u"apierror" in video:
                video[u'apierror'] = self.core._findErrors(result)

        self.common.log(u"Done")
        return (links, video)

########NEW FILE########
__FILENAME__ = YouTubePlaylistControl
'''
   YouTube plugin for XBMC
   Copyright (C) 2010-2012 Tobias Ussing And Henrik Mosgaard Jensen

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import sys


class YouTubePlaylistControl():

    def __init__(self):
        self.xbmc = sys.modules["__main__"].xbmc
        self.xbmcgui = sys.modules["__main__"].xbmcgui

        self.settings = sys.modules["__main__"].settings
        self.language = sys.modules["__main__"].language
        self.plugin = sys.modules["__main__"].plugin
        self.dbg = sys.modules["__main__"].dbg

        self.common = sys.modules["__main__"].common
        self.utils = sys.modules["__main__"].utils
        self.core = sys.modules["__main__"].core

        self.feeds = sys.modules["__main__"].feeds
        self.scraper = sys.modules["__main__"].scraper
        self.player = sys.modules["__main__"].player

    def playAll(self, params={}):
        get = params.get
        self.common.log("")
        params["fetch_all"] = "true"
        result = []

        # fetch the video entries
        if get("scraper") == "search_disco":
            (result, status) = self.scraper.searchDisco(params)
            print repr(result)
        elif get("scraper") == "liked_videos":
            (result, status) = self.getLikedVideos(params)
        elif get("playlist"):
            params["user_feed"] = "playlist"
            params["login"] = "true"
            result = self.getUserFeed(params)
        elif get("user_feed") in ["recommended", "watch_later", "newsubscriptions", "favorites"]:
            params["login"] = "true"
            result = self.getUserFeed(params)
        elif get("video_list"):
            (ytobjects, status) = self.core.getBatchDetails(get("video_list").split(","))
            result = ytobjects

        if len(result) == 0:
            self.common.log("no results")
            return

        self.common.log(repr(len(result)) + " video results ")

        if get("videoid"):
            video_index = -1
            for index, video in enumerate(result):
                vget = video.get
                if vget("videoid") == get("videoid"):
                    video_index = index
            if video_index > -1:
                result = result[video_index:]

        player = self.xbmc.Player()
        if (player.isPlaying()):
            player.stop()

        playlist = self.xbmc.PlayList(self.xbmc.PLAYLIST_VIDEO)
        playlist.clear()

        video_url = "%s?path=/root/video&action=play_video&videoid=%s"
        # queue all entries
        for entry in result:
            video = entry.get
            if video("videoid") == "false":
                continue
            listitem = self.xbmcgui.ListItem(label=video("Title"), iconImage=video("thumbnail"), thumbnailImage=video("thumbnail"))
            listitem.setProperty('IsPlayable', 'true')
            listitem.setProperty("Video", "true" )
            listitem.setInfo(type='Video', infoLabels=entry)

            playlist.add(video_url % (sys.argv[0], video("videoid") ), listitem)

        if (get("shuffle")):
            playlist.shuffle()

        self.xbmc.executebuiltin('playlist.playoffset(video , 0)')

    def queueVideo(self, params={}):
        get = params.get
        self.common.log("Queuing videos: " + get("videoid"))

        items = []
        videoids = get("videoid")

        if videoids.find(','):
            items = videoids.split(',')
        else:
            items.append(videoids)

        (videos, status) = self.core.getBatchDetails(items, params)

        if status != 200:
            self.common.log("construct video url failed contents of video item " + repr(videos))

            self.utils.showErrorMessage(self.language(30603), "apierror", status)
            return False

        playlist = self.xbmc.PlayList(self.xbmc.PLAYLIST_VIDEO)

        video_url = "%s?path=/root&action=play_video&videoid=%s"
        # queue all entries
        for entry in videos:
            video = entry.get
            if video("videoid") == "false":
                continue
            listitem = self.xbmcgui.ListItem(label=video("Title"), iconImage=video("thumbnail"), thumbnailImage=video("thumbnail"))
            listitem.setProperty('IsPlayable', 'true')
            listitem.setProperty("Video", "true" )
            listitem.setInfo(type='Video', infoLabels=entry)

            playlist.add(video_url % (sys.argv[0], video("videoid") ), listitem)

    def getUserFeed(self, params={}):
        get = params.get

        if get("user_feed") == "playlist":
            if not get("playlist"):
                return False
        elif get("user_feed") in ["newsubscriptions", "favorites"]:
            if not get("contact"):
                return False

        return self.feeds.listAll(params)

    def getLikedVideos(self, params={}):
        get = params.get
        if not get("scraper") or not get("login"):
            return False

        return self.scraper.scrapeUserLikedVideos(params)

    def addToPlaylist(self, params={}):
        get = params.get

        result = []
        if (not get("playlist")):
            params["user_feed"] = "playlists"
            params["login"] = "true"
            params["folder"] = "true"
            result = self.feeds.listAll(params)

        selected = -1
        if result:
            list = []
            list.append(self.language(30529))
            for item in result:
                list.append(item["Title"])
            dialog = self.xbmcgui.Dialog()
            selected = dialog.select(self.language(30528), list)

        if selected == 0:
            self.createPlaylist(params)
            if get("title"):
                result = self.feeds.listAll(params)
                for item in result:
                    if get("title") == item["Title"]:
                        params["playlist"] = item["playlist"]
                        break
        elif selected > 0:
            params["playlist"] = result[selected - 1].get("playlist")

        if get("playlist"):
            self.core.add_to_playlist(params)
            return True

        return False

    def createPlaylist(self, params={}):
        input = self.common.getUserInput(self.language(30529))
        if input:
            params["title"] = input
            self.core.add_playlist(params)
            return True
        return False

    def removeFromPlaylist(self, params={}):
        get = params.get

        if get("playlist") and get("playlist_entry_id"):
            (message, status) = self.core.remove_from_playlist(params)

            if (status != 200):
                self.utils.showErrorMessage(self.language(30600), message, status)
                return False

            self.xbmc.executebuiltin("Container.Refresh")
        return True

    def deletePlaylist(self, params):
        get = params.get
        if get("playlist"):
            (message, status) = self.core.del_playlist(params)
            print "called " + repr(status)
            if status != 200:
                self.utils.showErrorMessage(self.language(30600), message, status)
                return False
            self.xbmc.executebuiltin("Container.Refresh")
        return True

########NEW FILE########
__FILENAME__ = YouTubePluginSettings
'''
   YouTube plugin for XBMC
    Copyright (C) 2010-2012 Tobias Ussing And Henrik Mosgaard Jensen

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''
import sys

class YouTubePluginSettings():

    def __init__(self):
        self.settings = sys.modules["__main__"].settings
        self.dbg = sys.modules["__main__"].dbg

    def itemsPerPage(self):
        return (10, 15, 20, 25, 30, 40, 50)[int(self.settings.getSetting("perpage"))]

    def currentRegion(self):
        return ('', 'AU', 'BR', 'CA', 'CZ', 'FR', 'DE', 'GB', 'NL', 'HK', 'IN', 'IE', 'IL', 'IT', 'JP', 'MX', 'NZ', 'PL', 'RU', 'KR', 'ES', 'SE', 'TW', 'US', 'ZA')[int(self.settings.getSetting("region_id"))]

    def safeSearchLevel(self):
        return ("none", "moderate", "strict")[int(self.settings.getSetting("safe_search"))]

    def requestTimeout(self):
        return [5, 10, 15, 20, 25][int(self.settings.getSetting("timeout"))]

    def userHasProvidedValidCredentials(self):
        return (self.settings.getSetting("username") != "" and self.settings.getSetting("oauth2_access_token") != "")

    def userName(self):
        return self.settings.getSetting("username")

    def userPassword(self):
        return self.settings.getSetting("user_password")

    def debugModeIsEnabled(self):
        return self.settings.getSetting("debug") == "true"

    def authenticationRefreshRoken(self):
        return self.settings.getSetting("oauth2_refresh_token")

########NEW FILE########
__FILENAME__ = YouTubeScraper
'''
   YouTube plugin for XBMC
   Copyright (C) 2010-2012 Tobias Ussing And Henrik Mosgaard Jensen

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import sys
import urllib


class YouTubeScraper():
    urls = {}
    urls['disco_main'] = "http://www.youtube.com/disco"
    urls['disco_search'] = "http://www.youtube.com/disco?action_search=1&query=%s"
    urls['main'] = "http://www.youtube.com"
    urls['trailers'] = "http://www.youtube.com/trailers"
    urls['liked_videos'] = "http://www.youtube.com/my_liked_videos"
    urls['music'] = "http://www.youtube.com/music"
    urls['playlist'] = "http://www.youtube.com/view_play_list?p=%s"

    def __init__(self):
        self.settings = sys.modules["__main__"].settings
        self.language = sys.modules["__main__"].language
        self.plugin = sys.modules["__main__"].plugin
        self.dbg = sys.modules["__main__"].dbg

        self.utils = sys.modules["__main__"].utils
        self.core = sys.modules["__main__"].core
        self.common = sys.modules["__main__"].common
        self.cache = sys.modules["__main__"].cache

        self.feeds = sys.modules["__main__"].feeds
        self.storage = sys.modules["__main__"].storage

#=================================== User Scraper ============================================

    def scrapeUserLikedVideos(self, params):
        self.common.log("")

        url = self.createUrl(params)

        result = self.core._fetchPage({"link": url, "login": "true"})

        liked_playlist = self.common.parseDOM(result["content"], "button", {"id": "vm-playlist-play-all"}, ret="href")[0]

        if (liked_playlist.rfind("list=") > 0):
            liked_playlist = liked_playlist[liked_playlist.rfind("list=") + len("list="):]
            if liked_playlist.rfind("&") > 0:
                liked_playlist = liked_playlist[:liked_playlist.rfind("&")]

            return self.feeds.listPlaylist({"user_feed": "playlist", "playlist" : liked_playlist, "fetch_all":"true", "login":"true"})

        return ([], 303)

#=================================== Music ============================================

    def searchDisco(self, params={}):
        self.common.log("")

        url = self.createUrl(params)
        result = self.core._fetchPage({"link": url})

        if (result["content"].find("list=") != -1):
            result["content"] = result["content"].replace("\u0026", "&")
            mix_list_id = result["content"][result["content"].find("list=") + 5:]
            if (mix_list_id.find("&") != -1):
                mix_list_id = mix_list_id[:mix_list_id.find("&")]
            elif (mix_list_id.find('"') != -1):
                mix_list_id = mix_list_id[:mix_list_id.find('"')]

            return self.feeds.listPlaylist({"playlist": mix_list_id, "user_feed": "playlist", "fetch_all":"true"})

        return ([], 303)

        #================================== Common ============================================
    def getNewResultsFunction(self, params={}):
        get = params.get

        function = ""
        if (get("scraper") == "search_disco"):
            function = self.searchDisco

        if (get("scraper") in ["liked_videos", "watched_history"]):
            function = self.scrapeUserLikedVideos

        if function:
            params["new_results_function"] = function

        return True

    def createUrl(self, params={}):
        get = params.get
        page = str(int(get("page", "0")) + 1)
        url = ""

        if (get("scraper") in self.urls):
            url = self.urls[get("scraper")]
            if url.find('%s') > 0:
                url = url % page
            elif url.find('?') > -1:
                url += "&p=" + page
            else:
                url += "?p=" + page

        if (get("scraper") in "search_disco"):
            url = self.urls["disco_search"] % urllib.quote_plus(get("search"))

        return url

    def paginator(self, params={}):
        self.common.log(repr(params))
        get = params.get

        status = 303
        result = []
        next = 'false'
        page = int(get("page", "0"))
        per_page = (10, 15, 20, 25, 30, 40, 50,)[int(self.settings.getSetting("perpage"))]

        if get("page"):
            del params["page"]

        if (get("scraper") == "shows" and get("show")):
            (result, status) = params["new_results_function"](params)
        else:
            (result, status) = self.cache.cacheFunction(params["new_results_function"], params)

        self.common.log("paginator new result count " + str(repr(len(result[0:50]))))

        if len(result) == 0:
            if get("scraper") not in ["music_top100"]:
                return (result, 303)
            result = self.storage.retrieve(params)
            if len(result) > 0:
                status = 200
        elif get("scraper") in ["music_top100"]:
            self.storage.store(params, result)

        if not get("folder"):
            if (per_page * (page + 1) < len(result)):
                next = 'true'

            if (get("fetch_all") != "true"):
                result = result[(per_page * page):(per_page * (page + 1))]

            if len(result) == 0:
                return (result, status)

        if get("batch") == "thumbnails":
            (result, status) = self.core.getBatchDetailsThumbnails(result, params)
        elif get("batch"):
            (result, status) = self.core.getBatchDetails(result, params)

        if get("batch"):
            del params["batch"]
        if page > 0:
            params["page"] = str(page)

        if not get("page") and (get("scraper") == "search_disco"):
            thumbnail = result[0].get("thumbnail")
            self.storage.store(params, thumbnail, "thumbnail")

        if next == "true":
            self.utils.addNextFolder(result, params)

        return (result, status)

    def scrape(self, params={}):
        self.getNewResultsFunction(params)

        result = self.paginator(params)
        self.common.log(repr(result), 5)
        return result

########NEW FILE########
__FILENAME__ = YouTubeStorage
'''
   YouTube plugin for XBMC
   Copyright (C) 2010-2012 Tobias Ussing And Henrik Mosgaard Jensen

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import sys
import urllib
import io


class YouTubeStorage():
    def __init__(self):
        self.xbmc = sys.modules["__main__"].xbmc
        self.settings = sys.modules["__main__"].settings
        self.language = sys.modules["__main__"].language
        self.plugin = sys.modules["__main__"].plugin
        self.dbg = sys.modules["__main__"].dbg

        self.utils = sys.modules["__main__"].utils
        self.common = sys.modules["__main__"].common
        self.cache = sys.modules["__main__"].cache

        # This list contains the list options a user sees when indexing a contact
        #                label                      , external         , login         ,    thumbnail                    , feed
        self.user_options = (
                    {'Title':self.language(30020), 'external':"true", 'login':"true", 'thumbnail':"favorites",     'user_feed':"favorites"},
                    {'Title':self.language(30023), 'external':"true", 'login':"true", 'thumbnail':"playlists",     'user_feed':"playlists", 'folder':"true"},
                    {'Title':self.language(30021), 'external':"true", 'login':"true", 'thumbnail':"subscriptions", 'user_feed':"subscriptions", 'folder':"true"},
                    {'Title':self.language(30022), 'external':"true", 'login':"true", 'thumbnail':"uploads",         'user_feed':"uploads"},
                       )

    def list(self, params={}):
        self.common.log(repr(params), 5)
        get = params.get
        if get("store") == "contact_options":
            return self.getUserOptionFolder(params)
        elif get("store") == "artists":
            return self.getStoredArtists(params)
        elif get("store"):
            return self.getStoredSearches(params)
        self.common.log("Done", 5)

    def openFile(self, filepath, options="w"):
        self.common.log(repr(filepath), 5)
        if options.find("b") == -1:  # Toggle binary mode on failure
            alternate = options + "b"
        else:
            alternate = options.replace("b", "")

        try:
            return io.open(filepath, options)
        except:
            return io.open(filepath, alternate)

    def getStoredSearches(self, params={}):
        self.common.log(repr(params), 5)
        get = params.get

        searches = self.retrieveSettings(params)

        result = []
        for search in searches:
            item = {}
            item["path"] = get("path")
            item["Title"] = search
            item["search"] = urllib.quote_plus(search)

            if (get("store") == "searches"):
                item["feed"] = "search"
                item["icon"] = "search"
            elif get("store") == "disco_searches":
                item["scraper"] = "search_disco"
                item["icon"] = "discoball"

            thumbnail = self.retrieveSettings(params, "thumbnail", item)
            if thumbnail:
                item["thumbnail"] = thumbnail
            else:
                item["thumbnail"] = item["icon"]
            result.append(item)

        self.common.log("Done: " + repr(result), 5)
        return (result, 200)

    def deleteStoredSearch(self, params={}):
        self.common.log(repr(params), 5)
        get = params.get

        query = urllib.unquote_plus(get("delete"))
        searches = self.retrieveSettings(params)

        for count, search in enumerate(searches):
            if (search.lower() == query.lower()):
                del(searches[count])
                break

        self.storeSettings(params, searches)

        self.xbmc.executebuiltin("Container.Refresh")

    def saveStoredSearch(self, params={}):
        self.common.log(repr(params), 5)
        get = params.get

        if get("search"):
            searches = self.retrieveSettings(params)
            self.common.log("1: " + repr(searches), 5)

            new_query = urllib.unquote_plus(get("search"))
            old_query = new_query

            if get("old_search"):
                old_query = urllib.unquote_plus(get("old_search"))

            for count, search in enumerate(searches):
                if (search.lower() == old_query.lower()):
                    del(searches[count])
                    break

            searchCount = (10, 20, 30, 40,)[int(self.settings.getSetting("saved_searches"))] - 1
            searches = [new_query] + searches[:searchCount]
            self.common.log("2: " + repr(searches), 5)
            self.storeSettings(params, searches)
        self.common.log("Done", 5)

    def editStoredSearch(self, params={}):
        self.common.log(repr(params), 5)
        get = params.get

        if (get("search")):
            old_query = urllib.unquote_plus(get("search"))
            new_query = self.common.getUserInput(self.language(30515), old_query)
            params["search"] = new_query
            params["old_search"] = old_query

            if get("action") == "edit_disco":
                params["scraper"] = "search_disco"
                params["store"] = "disco_searches"
            else:
                params["store"] = "searches"
                params["feed"] = "search"

            self.saveStoredSearch(params)

            params["search"] = urllib.quote_plus(new_query)
            del params["old_search"]

        if get("action"):
            del params["action"]
        if get("store"):
            del params["store"]

    def getUserOptionFolder(self, params={}):
        self.common.log(repr(params), 5)
        get = params.get

        result = []
        for item in self.user_options:
            item["path"] = get("path")
            item["contact"] = get("contact")
            result.append(item)

        return (result, 200)

    def changeSubscriptionView(self, params={}):
        self.common.log(repr(params), 5)
        get = params.get

        if (get("view_mode")):
            key = self.getStorageKey(params, "viewmode")

            self.storeValue(key, get("view_mode"))

            params['user_feed'] = get("view_mode")
            if get("viewmode") == "playlists":
                params["folder"] = "true"  # No result

    def reversePlaylistOrder(self, params={}):
        self.common.log(repr(params), 5)
        get = params.get

        if (get("playlist")):
            value = "true"
            existing = self.retrieve(params, "value")
            if existing == "true":
                value = "false"  # No result

            self.store(params, value, "value")

            self.xbmc.executebuiltin("Container.Refresh")

    def getReversePlaylistOrder(self, params={}):
        self.common.log(repr(params), 5)
        get = params.get

        result = False
        if (get("playlist")):
            existing = self.retrieve(params, "value")
            if existing == "true":
                result = True

        return result

    #=================================== Storage Key ========================================
    def getStorageKey(self, params={}, type="", item={}):
        self.common.log(repr(params), 5)
        if type == "value":
            return self._getValueStorageKey(params, item)
        elif type == "viewmode":
            return self._getViewModeStorageKey(params, item)
        elif type == "thumbnail":
            return self._getThumbnailStorageKey(params, item)
        return self._getResultSetStorageKey(params)

    def _getThumbnailStorageKey(self, params={}, item={}):
        self.common.log(repr(params), 5)
        get = params.get
        iget = item.get
        key = ""

        if get("search") or iget("search"):
            key = "disco_search_"
            if get("feed") or iget("feed"):
                key = "search_"

            if get("store") == "searches":
                key = "search_"

            if get("search"):
                key += urllib.unquote_plus(get("search", ""))

            if iget("search"):
                key += urllib.unquote_plus(iget("search", ""))

        if get("user_feed"):
            key = get("user_feed")

            if get("channel"):
                key = "subscriptions_" + get("channel")

            if iget("channel"):
                key = "subscriptions_" + iget("channel")

            if get("playlist"):
                key = "playlist_" + get("playlist")

            if iget("playlist"):
                key = "playlist_" + iget("playlist")

        if key:
            key += "_thumb"

        return key

    def _getValueStorageKey(self, params={}, item={}):
        self.common.log(repr(params), 5)
        get = params.get
        iget = item.get
        key = ""

        if ((get("action") == "reverse_order" or get("user_feed") == "playlist") and (iget("playlist") or get("playlist"))):

            key = "reverse_playlist_"
            if iget("playlist"):
                key += iget("playlist")

            if get("playlist"):
                key += get("playlist")

            if (get("external")):
                key += "_external_" + get("contact")
        return key 

    def _getViewModeStorageKey(self, params={}, item={}):
        self.common.log(repr(params), 5)
        get = params.get
        iget = item.get
        key = ""

        if (get("external")):
            key = "external_" + get("contact") + "_"
        elif (iget("external")):
            key = "external_" + iget("contact") + "_"

        if get("channel"):
            key += "view_mode_" + get("channel")
        elif (iget("channel")):
            key += "view_mode_" + iget("channel")

        return key

    def _getResultSetStorageKey(self, params={}):
        self.common.log(repr(params), 5)
        get = params.get

        key = ""

        if get("scraper"):
            key = "s_" + get("scraper")

            if get("scraper") == "disco_search":
                key = "store_disco_searches"

            if get("category"):
                key += "_category_" + get("category")

        if get("user_feed"):
            key = "result_" + get("user_feed")

            if get("playlist"):
                key += "_" + get("playlist")

            if get("channel"):
                key += "_" + get("channel")

            if get("external") and not get("thumb"):
                key += "_external_" + get("contact")

        if get("feed") == "search":
            key = "store_searches"

        if get("store"):
            key = "store_" + get("store")

        return key

    #============================= Storage Functions =================================
    def store(self, params={}, results=[], type="", item={}):
        self.common.log(repr(params), 5)
        key = self.getStorageKey(params, type, item)

        self.common.log("Got key " + repr(key))

        self.common.log(repr(type), 5)
        if type == "thumbnail" or type == "viewmode" or type == "value":
            self.storeValue(key, results)
        else:
            self.storeResultSet(key, results)
        self.common.log("done", 5)

    def storeValue(self, key, value):
        self.common.log(repr(key) + " - " + repr(value), 5)
        if value:
            self.cache.set(key, value)
        self.common.log("done", 5)

    def storeResultSet(self, key, results=[], params={}):
        self.common.log(repr(params), 5)
        get = params.get

        if results:
            if get("prepend"):
                searchCount = (10, 20, 30, 40,)[int(self.settings.getSetting("saved_searches"))]
                existing = self.retrieveResultSet(key)
                existing = [results] + existing[:searchCount]
                self.cache.set(key, repr(existing))
            elif get("append"):
                existing = self.retrieveResultSet(key)
                existing.append(results)
                self.cache.set(key, repr(existing))
            else:
                value = repr(results)
                self.cache.set(key, value)
        self.common.log("done", 5)

    def storeSettings(self, params={}, results=[], type="", item={}):
        self.common.log(repr(params), 5)

        key = self.getStorageKey(params, type, item)

        self.storeResultSetSettings(key, results)

        self.common.log("done", 5)

    def storeResultSetSettings(self, key, results=[], params={}):
        self.common.log(repr(params), 5)

        if results:
            value = repr(results)
            self.settings.setSetting(key, value)

        self.common.log("done", 5)

    #============================= Retrieval Functions =================================
    def retrieve(self, params={}, type="", item={}):
        self.common.log(repr(params), 5)
        key = self.getStorageKey(params, type, item)

        if type == "thumbnail" or type == "viewmode" or type == "value":
            return self.retrieveValue(key)
        else:
            return self.retrieveResultSet(key)

    def retrieveValue(self, key):
        self.common.log(repr(key), 5)
        value = ""
        if key:
            value = self.cache.get(key)

        return value

    def retrieveResultSet(self, key):
        self.common.log(repr(key), 5)
        results = []

        value = self.cache.get(key)
        self.common.log(repr(value), 5)
        if value:
            try:
                results = eval(value)
            except:
                results = []

        return results

    def retrieveSettings(self, params={}, type="", item={}):
        self.common.log(repr(params), 5)
        key = self.getStorageKey(params, type, item)

        self.common.log("Got key " + repr(key))

        return self.retrieveResultSetSettings(key)

    def retrieveResultSetSettings(self, key):
        self.common.log(repr(key), 5)
        results = []

        value = self.settings.getSetting(key)
        self.common.log(repr(value), 5)
        if value:
            try:
                results = eval(value)
            except:
                results = []

        return results

    def updateVideoIdStatusInCache(self, pre_id, ytobjects):
        self.common.log(pre_id)
        save_data = {}
        for item in ytobjects:
            if "videoid" in item:
                save_data[item["videoid"]] = repr(item)

        self.cache.setMulti(pre_id, save_data)

    def getVideoIdStatusFromCache(self, pre_id, ytobjects):
        self.common.log(pre_id)
        load_data = []
        for item in ytobjects:
            if "videoid" in item:
                load_data.append(item["videoid"])

        res = self.cache.getMulti(pre_id, load_data)
        if len(res) != len(load_data):
            self.common.log("Length mismatch:" + repr(res) + " - " + repr(load_data))

        i = 0
        for item in ytobjects:
            if "videoid" in item:
                if i < len(res):
                    item["Overlay"] = res[i]
                i += 1 # This can NOT be enumerated because there might be missing videoids
        return ytobjects

########NEW FILE########
__FILENAME__ = YouTubeSubtitleControl
'''
   YouTube plugin for XBMC
    Copyright (C) 2010-2012 Tobias Ussing And Henrik Mosgaard Jensen

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import sys
import urllib
import re
import os.path
import time
try: import simplejson as json
except ImportError: import json


class YouTubeSubtitleControl():

    urls = {}
    urls['timed_text_index'] = "http://www.youtube.com/api/timedtext?type=list&v=%s"
    urls['close_caption_url'] = "http://www.youtube.com/api/timedtext?type=track&v=%s&lang=%s"
    urls['annotation_url'] = "http://www.youtube.com/annotations/read2?video_id=%s&feat=TC"

    def __init__(self):
        self.xbmc = sys.modules["__main__"].xbmc
        self.xbmcgui = sys.modules["__main__"].xbmcgui
        self.xbmcvfs = sys.modules["__main__"].xbmcvfs

        self.common = sys.modules["__main__"].common
        self.utils = sys.modules["__main__"].utils
        self.core = sys.modules["__main__"].core

        self.dbg = sys.modules["__main__"].dbg
        self.settings = sys.modules["__main__"].settings
        self.storage = sys.modules["__main__"].storage

    # ================================ Subtitle Downloader ====================================
    def downloadSubtitle(self, video={}):
        self.common.log(u"")
        get = video.get

        style = u""
        result = u""

        if self.settings.getSetting("annotations") == "true" and not "download_path" in video:
            xml = self.core._fetchPage({"link": self.urls["annotation_url"] % get('videoid')})
            if xml["status"] == 200 and xml["content"]:
                (result, style) = self.transformAnnotationToSSA(xml["content"])

        if self.settings.getSetting("lang_code") != "0":
            subtitle_url = self.getSubtitleUrl(video)

            if not subtitle_url and self.settings.getSetting("transcode") == "true":
                subtitle_url = self.getTranscriptionUrl(video)

            if subtitle_url:
                xml = self.core._fetchPage({"link": subtitle_url})
                if xml["status"] == 200 and xml["content"]:
                    result += self.transformSubtitleXMLtoSRT(xml["content"])

        if len(result) > 0:
            result = "[Script Info]\r\n; This is a Sub Station Alpha v4 script.\r\n; For Sub Station Alpha info and downloads,\r\n; go to http://www.eswat.demon.co.uk/\r\n; or email kotus@eswat.demon.co.uk\r\nTitle: Auto Generated\r\nScriptType: v4.00\r\nCollisions: Normal\r\nPlayResY: 1280\r\nPlayResX: 800\r\n\r\n[V4 Styles]\r\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, TertiaryColour, BackColour, Bold, Italic, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, AlphaLevel, Encoding\r\nStyle: Default,Arial,80,&H00FFFFFF&,65535,65535,&00000000&,-1,0,1,3,2,2,0,0,0,0,0\r\nStyle: speech,Arial,60,0,65535,65535,&H4BFFFFFF&,0,0,3,1,0,1,0,0,0,0,0\r\nStyle: popup,Arial,60,0,65535,65535,&H4BFFFFFF&,0,0,3,3,0,1,0,0,0,0,0\r\nStyle: highlightText,Wolf_Rain,60,15724527,15724527,15724527,&H4BFFFFFF&,0,0,1,1,2,2,5,5,0,0,0\r\n" + style + "\r\n[Events]\r\nFormat: Marked, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\r\n" + result

            result += "Dialogue: Marked=0,0:00:0.00,0:00:0.00,Default,Name,0000,0000,0000,,\r\n"  # This solves a bug.
            self.saveSubtitle(result, video)
            self.common.log(u"Done")
            return True

        self.common.log(u"Failure")
        return False

    def getSubtitleUrl(self, video={}):
        self.common.log(u"")
        get = video.get
        url = ""

        xml = self.core._fetchPage({"link": self.urls["timed_text_index"] % get('videoid')})

        self.common.log(u"subtitle index: " + repr(xml["content"]))
        self.common.log(u"CONTENT TYPE1: " + repr(type(xml["content"])))

        if xml["status"] == 200:
            subtitle = ""
            code = ""
            codelist = self.common.parseDOM(xml["content"], "track", ret="lang_code")
            sublist = self.common.parseDOM(xml["content"], "track", ret="name")
            lang_original = self.common.parseDOM(xml["content"], "track", ret="lang_original")
            if len(sublist) != len(codelist) and len(sublist) != len(lang_original):
                self.common.log(u"Code list and sublist length mismatch: " + repr(codelist) + " - " + repr(sublist))
                return ""

            lang_code = ["off", "en", "es", "de", "fr", "it", "ja"][int(self.settings.getSetting("lang_code"))]
            self.common.log(u"selected language: " + repr(lang_code))

            for i in range(0, len(codelist)):
                if codelist[i].find(lang_code) > -1:
                    subtitle = sublist[i].replace(u" ", u"%20")
                    code = codelist[i]
                    self.common.log(u"found subtitle specified: " + subtitle + " - " + code)
                    break

                if codelist[i].find("en") > -1:
                    subtitle = sublist[i].replace(u" ", u"%20")
                    code = "en"
                    self.common.log(u"found subtitle default: " + subtitle + " - " + code)

            if code:
                url = self.urls["close_caption_url"] % (get("videoid"), code)
                if len(subtitle) > 0:
                    url += "&name=" + subtitle

        self.common.log(u"found subtitle url: " + repr(url))
        return url

    def getSubtitleFileName(self, video):
        get = video.get
        lang_code = ["off", "en", "es", "de", "fr", "it", "ja"][int(self.settings.getSetting("lang_code"))]
        filename = ''.join(c for c in self.common.makeUTF8(video['Title']) if c not in self.utils.INVALID_CHARS) + "-[" + get('videoid') + "]-" + lang_code.upper() + ".ssa"
        filename = filename.encode("ascii", "ignore")
        return filename

    def saveSubtitle(self, result, video={}):
        self.common.log(repr(type(result)))
        filename = self.getSubtitleFileName(video)

        path = os.path.join(self.xbmc.translatePath(self.settings.getAddonInfo("profile")).decode("utf-8"), filename)

        w = self.storage.openFile(path, "w")
        try:
            w.write(result.encode("utf-8")) # WTF, didn't have to do this before, did i?
        except Exception as e:
            self.common.log("Exception: " + repr(e))
            try:
                w.write(result)
                self.common.log(u"NOT utf-8 WRITE!!!: " + path + " - " + repr(result))
            except Exception as de:
                self.common.log("Exception2: " + repr(de))
            time.sleep(5)

        w.close()

        if "download_path" in video:
            self.xbmcvfs.rename(path, os.path.join(video["download_path"], filename))


    def getTranscriptionUrl(self, video={}):
        self.common.log(u"")
        get = video.get
        trans_url = ""
        if "ttsurl" in video:
            if len(video["ttsurl"]) > 0:
                trans_url = urllib.unquote(video["ttsurl"]).replace("\\", "") + "&type=trackformat=1&lang=en&kind=asr&name=&v=" + get("videoid")
                if self.settings.getSetting("lang_code") > 1:  # 1 == en
                    lang_code = ["off", "en", "es", "de", "fr", "it", "ja"][int(self.settings.getSetting("lang_code"))]
                    trans_url += "&tlang=" + lang_code
        return trans_url

    def simpleReplaceHTMLCodes(self, str):
        str = str.strip()
        str = str.replace("&amp;", "&")
        str = str.replace("&quot;", '"')
        str = str.replace("&hellip;", "...")
        str = str.replace("&gt;", ">")
        str = str.replace("&lt;", "<")
        str = str.replace("&#39;", "'")
        return str

    def convertSecondsToTimestamp(self, seconds):
        self.common.log(u"", 3)
        hours = str(int(seconds / 3600))
        seconds = seconds % 3600

        minutes = str(int(seconds/60))
        if len(minutes) == 1:
            minutes = "0" + minutes

        seconds = str(seconds % 60)
        if len(seconds) == 1:
            seconds = "0" + seconds

        self.common.log(u"Done", 3)
        return "%s:%s:%s" % (hours, minutes, seconds)

    def transformSubtitleXMLtoSRT(self, xml):
        self.common.log(u"")

        result = u""
        for node in self.common.parseDOM(xml, "text", ret=True):
            text = self.common.parseDOM(node, "text")[0]
            text = self.simpleReplaceHTMLCodes(text).replace("\n", "\\n")
            start = float(self.common.parseDOM(node, "text", ret="start")[0])
            duration = self.common.parseDOM(node, "text", ret="dur")
            end = start + 0.1
            if len(duration) > 0:
                end = start + float(duration[0])

            start = self.convertSecondsToTimestamp(start)
            end = self.convertSecondsToTimestamp(end)

            if start and end:
                result += "Dialogue: Marked=%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\r\n" % ("0", start, end, "Default", "Name", "0000", "0000", "0000", "", text)

        return result

    def transformColor(self, color):
        self.common.log(u"Color: %s - len: %s" % (color, len(color)), 3)
        if color:
            color = hex(int(color))
            color = str(color)
            color = color[2:]
            self.common.log(u"Color: %s - len: %s" % (color, len(color)), 5)
            if color == "0":
                color = "000000"
            if len(color) == 4:
                color = "00" + color
            if len(color) == 6:
                color = color[4:6] + color[2:4] + color[0:2]

        self.common.log(u"Returning color: %s - len: %s" % (color, len(color)), 5)
        return color

    def transformAlpha(self, alpha):
        self.common.log(u"Alpha: %s - len: %s" % (alpha, len(alpha)), 5)
        if not alpha or alpha == "0" or alpha == "0.0":
            alpha = "-1"  # No background.
        else:
            # YouTube and SSA have inverted alphas.
            alpha = int(float(alpha) * 256)
            alpha = hex(256 - alpha)
            alpha = alpha[2:]

        self.common.log(u"Alpha: %s - len: %s" % (alpha, len(alpha)), 5)
        return alpha

    def transformAnnotationToSSA(self, xml):
        self.common.log(u"")
        result = u""
        ssa_fixes = []
        style_template = u"Style: annot%s,Arial,%s,&H%s&,&H%s&,&H%s&,&H%s&,0,0,3,3,0,1,0,0,0,0,0\r\n"
        styles_count = 0
        append_style = u""
        entries = self.common.parseDOM(xml, "annotation", ret=True)
        for node in entries:
            if node:
                stype = u"".join(self.common.parseDOM(node, "annotation", ret="type"))
                style = u"".join(self.common.parseDOM(node, "annotation", ret="style"))
                self.common.log(u"stype : " + stype, 5)
                self.common.log(u"style : " + style, 5)

                if stype == "highlight":
                    linkt = "".join(self.common.parseDOM(node, "url", ret="type"))
                    linkv = "".join(self.common.parseDOM(node, "url", ret="value"))
                    if linkt == "video":
                        self.common.log(u"Reference to video : " + linkv)
                elif node.find("TEXT") > -1:
                    text = self.common.parseDOM(node, "TEXT")
                    if len(text):
                        text = self.common.replaceHTMLCodes(text[0])
                        start = ""

                        ns_fsize = 60
                        start = False
                        end = False

                        if style == "popup":
                            cnode = self.common.parseDOM(node, "rectRegion", ret="t")
                            start = cnode[0]
                            end = cnode[1]
                            tmp_y = self.common.parseDOM(node, "rectRegion", ret="y")
                            tmp_h = self.common.parseDOM(node, "rectRegion", ret="h")
                            tmp_x = self.common.parseDOM(node, "rectRegion", ret="x")
                            tmp_w = self.common.parseDOM(node, "rectRegion", ret="w")
                        elif style == "speech":
                            cnode = self.common.parseDOM(node, "anchoredRegion", ret="t")
                            start = cnode[0]
                            end = cnode[1]
                            tmp_y = self.common.parseDOM(node, "anchoredRegion", ret="y")
                            tmp_h = self.common.parseDOM(node, "anchoredRegion", ret="h")
                            tmp_x = self.common.parseDOM(node, "anchoredRegion", ret="x")
                            tmp_w = self.common.parseDOM(node, "anchoredRegion", ret="w")
                        elif style == "higlightText":
                            cnode = False
                        else:
                            cnode = False

                        for snode in self.common.parseDOM(node, "appearance", attrs={"fgColor": ".*?"}, ret=True):
                            ns_fsize = self.common.parseDOM(snode, "appearance", ret="textSize")
                            if len(ns_fsize):
                                ns_fsize = int(1.2 * (1280 * float(ns_fsize[0]) / 100))
                            else:
                                ns_fsize = 60
                            ns_fcolor = self.common.parseDOM(snode, "appearance", ret="fgColor")
                            ns_fcolor = self.transformColor(ns_fcolor[0])

                            ns_bcolor = self.common.parseDOM(snode, "appearance", ret="bgColor")
                            ns_bcolor = self.transformColor(ns_bcolor[0])

                            ns_alpha = self.common.parseDOM(snode, "appearance", ret="bgAlpha")
                            ns_alpha = self.transformAlpha(ns_alpha[0])

                            append_style += style_template % (styles_count, ns_fsize, ns_fcolor, ns_fcolor, ns_fcolor, ns_alpha + ns_bcolor)
                            style = "annot" + str(styles_count)
                            styles_count += 1

                        self.common.log(u"start: %s - end: %s - style: %s" % (start, end, style), 5)
                        if start and end and style != "highlightText":
                            marginV = 1280 * float(tmp_y[0]) / 100
                            marginV += 1280 * float(tmp_h[0]) / 100
                            marginV = 1280 - int(marginV)
                            marginV += 5
                            marginL = int((800 * float(tmp_x[0]) / 100))
                            marginL += 5
                            marginR = 800 - marginL - int((800 * float(tmp_w[0]) / 100)) - 15
                            if marginR < 0:
                                marginR = 0
                            result += "Dialogue: Marked=%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\r\n" % ("0", start, end, style, "Name", marginL, marginR, marginV, "", text)
                            ssa_fixes.append([start, end])

        # Fix errors in the SSA specs.
        if len(ssa_fixes) > 0:
            for a_start, a_end in ssa_fixes:
                for b_start, b_end in ssa_fixes:
                    if time.strptime(a_end[0:a_end.rfind(".")], "%H:%M:%S") < time.strptime(b_start[0:b_start.rfind(".")], "%H:%M:%S"):
                        result += "Dialogue: Marked=0,%s,%s,Default,Name,0000,0000,0000,,\r\n" % (a_end, b_start)

        self.common.log(u"Done : " + repr((result, append_style)),5)
        return (result, append_style)

    def addSubtitles(self, video={}):
        get = video.get
        self.common.log(u"fetching subtitle if available")

        filename = self.getSubtitleFileName(video)

        download_path = os.path.join(self.settings.getSetting("download_path").decode("utf-8"), filename)
        path = os.path.join(self.xbmc.translatePath(self.settings.getAddonInfo("profile")).decode("utf-8"), filename)

        set_subtitle = False
        if self.xbmcvfs.exists(download_path):
            path = download_path
            set_subtitle = True
        elif self.xbmcvfs.exists(path):
            set_subtitle = True
        elif self.downloadSubtitle(video):
            set_subtitle = True

        self.common.log(u"Done trying to locate: " + path, 4)
        if self.xbmcvfs.exists(path) and not "download_path" in video and set_subtitle:
            player = self.xbmc.Player()

            i = 0
            while not player.isPlaying():
                i += 1
                self.common.log(u"Waiting for playback to start ")
                time.sleep(1)
                if i > 10:
                    break

            self.xbmc.Player().setSubtitles(path)
            self.common.log(u"added subtitle %s to playback" % path)

    def getLocalFileSource(self, params, video):
        get = params.get
        result = u""
        if (get("action", "") != "download"):
            path = self.settings.getSetting("download_path")
            filename = u"".join(c for c in self.common.makeUTF8(video['Title']) if c not in self.utils.INVALID_CHARS) + u"-[" + get('videoid') + u"]" + u".mp4"
            path = os.path.join(path.decode("utf-8"), filename)
            try:
                if self.xbmcvfs.exists(path):
                    result = path
            except:
                self.common.log(u"failed to locate local subtitle file, trying youtube instead")
        return result

########NEW FILE########
__FILENAME__ = YouTubeUtils
'''
   YouTube plugin for XBMC
   Copyright (C) 2010-2012 Tobias Ussing And Henrik Mosgaard Jensen

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import sys
import os


class YouTubeUtils:
    def __init__(self):
        self.xbmc = sys.modules["__main__"].xbmc
        self.settings = sys.modules["__main__"].settings
        self.language = sys.modules["__main__"].language
        self.common = sys.modules["__main__"].common
        self.plugin = sys.modules["__main__"].plugin
        self.dbg = sys.modules["__main__"].dbg
        self.PR_VIDEO_QUALITY = self.settings.getSetting("pr_video_quality") == "true"
        self.INVALID_CHARS = "\\/:*?\"<>|"
        self.THUMBNAIL_PATH = os.path.join(self.settings.getAddonInfo('path'), "thumbnails")

    def showMessage(self, heading, message):
        self.common.log(repr(type(heading)) + " - " + repr(type(message)))
        duration = ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10][int(self.settings.getSetting('notification_length'))]) * 1000
        self.xbmc.executebuiltin((u'XBMC.Notification("%s", "%s", %s)' % (heading, message, duration)).encode("utf-8"))

    def getThumbnail(self, title):
        if (not title):
            title = "DefaultFolder"

        thumbnail = os.path.join(sys.modules["__main__"].plugin, title + ".png")

        if (not self.xbmc.skinHasImage(thumbnail)):
            thumbnail = os.path.join(self.THUMBNAIL_PATH, title + ".png")
            if (not os.path.isfile(thumbnail)):
                thumbnail = "DefaultFolder.png"

        return thumbnail

    def showErrorMessage(self, title="", result="", status=500):
        if title == "":
            title = self.language(30600)
        if result == "":
            result = self.language(30617)

        if (status == 303):
            self.showMessage(title, result)
        else:
            self.showMessage(title, self.language(30617))

    def buildItemUrl(self, item_params={}, url=""):
        blacklist = ("path", "thumbnail", "Overlay", "icon", "next", "content", "editid", "summary", "published", "count", "Rating", "Plot", "Title", "new_results_function")
        for key, value in item_params.items():
            if key not in blacklist:
                url += key + "=" + value + "&"
        return url

    def addNextFolder(self, items=[], params={}):
        get = params.get
        item = {"Title": self.language(30509), "thumbnail": "next", "next": "true", "page": str(int(get("page", "0")) + 1)}
        for k, v in params.items():
            if (k != "thumbnail" and k != "Title" and k != "page" and k != "new_results_function"):
                item[k] = v
        items.append(item)

    def extractVID(self, items):
        if isinstance(items, str):
            items = [items]

        self.common.log(repr(items), 4)

        ret_list = []
        for item in items:
            item = item[item.find("v=") + 2:]
            if item.find("&") > -1:
                item = item[:item.find("&")]
            ret_list.append(item)

        self.common.log(repr(ret_list), 4)
        return ret_list

    def convertStringToBinary(self, value):
        if isinstance(value, unicode):
            return ''.join(format(ord(i),'0>8b') for i in value)
        else :
            return value


########NEW FILE########
__FILENAME__ = BaseTestCase
import sys
import unittest2, io
from mock import Mock
import MockYouTubeDepends

MockYouTubeDepends.MockYouTubeDepends().mockXBMC()

sys.path.append('../plugin/')
sys.path.append('../xbmc-mocks/')

class BaseTestCase(unittest2.TestCase):#pragma: no cover
	
	def setUp(self):
		MockYouTubeDepends.MockYouTubeDepends().mockXBMC()
		MockYouTubeDepends.MockYouTubeDepends().mock()
	
	def readTestInput(self, filename, should_eval = True):
		try:
			testinput = open("resources/" + filename)
			inputdata = testinput.read()
		except:
			testinput = io.open("resources/" + filename)
			inputdata = testinput.read()

		if should_eval:
			inputdata = eval(inputdata)
		return inputdata
	
	def raiseError(self, exception):
		raise exception

########NEW FILE########
__FILENAME__ = CommonFunctions
'''
   Parsedom for XBMC plugins
   Copyright (C) 2010-2011 Tobias Ussing And Henrik Mosgaard Jensen

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import sys
import urllib
import urllib2
import re
import io
import inspect
import time
import HTMLParser
#import chardet
import json

version = u"1.5.1"
plugin = u"CommonFunctions Beta-" + version
print plugin

USERAGENT = u"Mozilla/5.0 (Windows NT 6.2; Win64; x64; rv:16.0.1) Gecko/20121011 Firefox/16.0.1"

if hasattr(sys.modules["__main__"], "xbmc"):
    xbmc = sys.modules["__main__"].xbmc
else:
    import xbmc

if hasattr(sys.modules["__main__"], "xbmcgui"):
    xbmcgui = sys.modules["__main__"].xbmcgui
else:
    import xbmcgui

if hasattr(sys.modules["__main__"], "dbg"):
    dbg = sys.modules["__main__"].dbg
else:
    dbg = False

if hasattr(sys.modules["__main__"], "dbglevel"):
    dbglevel = sys.modules["__main__"].dbglevel
else:
    dbglevel = 3

if hasattr(sys.modules["__main__"], "opener"):
    urllib2.install_opener(sys.modules["__main__"].opener)


# This function raises a keyboard for user input
def getUserInput(title=u"Input", default=u"", hidden=False):
    log("", 5)
    result = None

    # Fix for when this functions is called with default=None
    if not default:
        default = u""

    keyboard = xbmc.Keyboard(default, title)
    keyboard.setHiddenInput(hidden)
    keyboard.doModal()

    if keyboard.isConfirmed():
        result = keyboard.getText()

    log(repr(result), 5)
    return result


# This function raises a keyboard numpad for user input
def getUserInputNumbers(title=u"Input", default=u""):
    log("", 5)
    result = None

    # Fix for when this functions is called with default=None
    if not default:
        default = u""

    keyboard = xbmcgui.Dialog()
    result = keyboard.numeric(0, title, default)

    log(repr(result), 5)
    return str(result)


def getXBMCVersion():
    log("", 3)
    version = xbmc.getInfoLabel( "System.BuildVersion" )
    log(version, 3)
    for key in ["-", " "]:
        if version.find(key) -1:
            version = version[:version.find(key)]
    version = float(version)
    log(repr(version))
    return version

# Converts the request url passed on by xbmc to the plugin into a dict of key-value pairs
def getParameters(parameterString):
    log("", 5)
    commands = {}
    if getXBMCVersion() >= 12.0:
        parameterString = urllib.unquote_plus(parameterString)
    splitCommands = parameterString[parameterString.find('?') + 1:].split('&')

    for command in splitCommands:
        if (len(command) > 0):
            splitCommand = command.split('=')
            key = splitCommand[0]
            try: 
                value = splitCommand[1].encode("utf-8")
            except:
                log("Error utf-8 encoding argument value: " + repr(splitCommand[1]))
                value = splitCommand[1]

            commands[key] = value

    log(repr(commands), 5)
    return commands


def replaceHTMLCodes(txt):
    log(repr(txt), 5)

    # Fix missing ; in &#<number>;
    txt = re.sub("(&#[0-9]+)([^;^0-9]+)", "\\1;\\2", makeUTF8(txt))

    txt = HTMLParser.HTMLParser().unescape(txt)
    txt = txt.replace("&amp;", "&")
    log(repr(txt), 5)
    return txt


def stripTags(html):
    log(repr(html), 5)
    sub_start = html.find("<")
    sub_end = html.find(">")
    while sub_start < sub_end and sub_start > -1:
        html = html.replace(html[sub_start:sub_end + 1], "").strip()
        sub_start = html.find("<")
        sub_end = html.find(">")

    log(repr(html), 5)
    return html


def _getDOMContent(html, name, match, ret):  # Cleanup
    log("match: " + match, 3)

    endstr = u"</" + name  # + ">"

    start = html.find(match)
    end = html.find(endstr, start)
    pos = html.find("<" + name, start + 1 )

    log(str(start) + " < " + str(end) + ", pos = " + str(pos) + ", endpos: " + str(end), 8)

    while pos < end and pos != -1:  # Ignore too early </endstr> return
        tend = html.find(endstr, end + len(endstr))
        if tend != -1:
            end = tend
        pos = html.find("<" + name, pos + 1)
        log("loop: " + str(start) + " < " + str(end) + " pos = " + str(pos), 8)

    log("start: %s, len: %s, end: %s" % (start, len(match), end), 3)
    if start == -1 and end == -1:
        result = u""
    elif start > -1 and end > -1:
        result = html[start + len(match):end]
    elif end > -1:
        result = html[:end]
    elif start > -1:
        result = html[start + len(match):]

    if ret:
        endstr = html[end:html.find(">", html.find(endstr)) + 1]
        result = match + result + endstr

    log("done result length: " + str(len(result)), 3)
    return result

def _getDOMAttributes(match, name, ret):
    log("", 3)

    lst = re.compile('<' + name + '.*?' + ret + '=([\'"].[^>]*?[\'"])>', re.M | re.S).findall(match)
    if len(lst) == 0:
        lst = re.compile('<' + name + '.*?' + ret + '=(.[^>]*?)>', re.M | re.S).findall(match)
    ret = []
    for tmp in lst:
        cont_char = tmp[0]
        if cont_char in "'\"":
            log("Using %s as quotation mark" % cont_char, 3)

            # Limit down to next variable.
            if tmp.find('=' + cont_char, tmp.find(cont_char, 1)) > -1:
                tmp = tmp[:tmp.find('=' + cont_char, tmp.find(cont_char, 1))]

            # Limit to the last quotation mark
            if tmp.rfind(cont_char, 1) > -1:
                tmp = tmp[1:tmp.rfind(cont_char)]
        else:
            log("No quotation mark found", 3)
            if tmp.find(" ") > 0:
                tmp = tmp[:tmp.find(" ")]
            elif tmp.find("/") > 0:
                tmp = tmp[:tmp.find("/")]
            elif tmp.find(">") > 0:
                tmp = tmp[:tmp.find(">")]

        ret.append(tmp.strip())

    log("Done: " + repr(ret), 3)
    return ret

def _getDOMElements(item, name, attrs):
    log("", 3)

    lst = []
    for key in attrs:
        lst2 = re.compile('(<' + name + '[^>]*?(?:' + key + '=[\'"]' + attrs[key] + '[\'"].*?>))', re.M | re.S).findall(item)
        if len(lst2) == 0 and attrs[key].find(" ") == -1:  # Try matching without quotation marks
            lst2 = re.compile('(<' + name + '[^>]*?(?:' + key + '=' + attrs[key] + '.*?>))', re.M | re.S).findall(item)

        if len(lst) == 0:
            log("Setting main list " + repr(lst2), 5)
            lst = lst2
            lst2 = []
        else:
            log("Setting new list " + repr(lst2), 5)
            test = range(len(lst))
            test.reverse()
            for i in test:  # Delete anything missing from the next list.
                if not lst[i] in lst2:
                    log("Purging mismatch " + str(len(lst)) + " - " + repr(lst[i]), 3)
                    del(lst[i])

    if len(lst) == 0 and attrs == {}:
        log("No list found, trying to match on name only", 3)
        lst = re.compile('(<' + name + '>)', re.M | re.S).findall(item)
        if len(lst) == 0:
            lst = re.compile('(<' + name + ' .*?>)', re.M | re.S).findall(item)

    log("Done: " + str(type(lst)), 3)
    return lst

def parseDOM(html, name=u"", attrs={}, ret=False):
    log("Name: " + repr(name) + " - Attrs:" + repr(attrs) + " - Ret: " + repr(ret) + " - HTML: " + str(type(html)), 3)

    if isinstance(name, str): # Should be handled
        try:
            name = name #.decode("utf-8")
        except:
            log("Couldn't decode name binary string: " + repr(name))

    if isinstance(html, str):
        try:
            html = [html.decode("utf-8")] # Replace with chardet thingy
        except:
            log("Couldn't decode html binary string. Data length: " + repr(len(html)))
            html = [html]
    elif isinstance(html, unicode):
        html = [html]
    elif not isinstance(html, list):
        log("Input isn't list or string/unicode.")
        return u""

    if not name.strip():
        log("Missing tag name")
        return u""

    ret_lst = []
    for item in html:
        temp_item = re.compile('(<[^>]*?\n[^>]*?>)').findall(item)
        for match in temp_item:
            item = item.replace(match, match.replace("\n", " "))

        lst = _getDOMElements(item, name, attrs)

        if isinstance(ret, str):
            log("Getting attribute %s content for %s matches " % (ret, len(lst) ), 3)
            lst2 = []
            for match in lst:
                lst2 += _getDOMAttributes(match, name, ret)
            lst = lst2
        else:
            log("Getting element content for %s matches " % len(lst), 3)
            lst2 = []
            for match in lst:
                log("Getting element content for %s" % match, 4)
                temp = _getDOMContent(item, name, match, ret).strip()
                item = item[item.find(temp, item.find(match)) + len(temp):]
                lst2.append(temp)
            lst = lst2
        ret_lst += lst

    log("Done: " + repr(ret_lst), 3)
    return ret_lst


def extractJS(data, function=False, variable=False, match=False, evaluate=False, values=False):
    log("")
    scripts = parseDOM(data, "script")
    if len(scripts) == 0:
        log("Couldn't find any script tags. Assuming javascript file was given.")
        scripts = [data]

    lst = []
    log("Extracting", 4)
    for script in scripts:
        tmp_lst = []
        if function:
            tmp_lst = re.compile(function + '\(.*?\).*?;', re.M | re.S).findall(script)
        elif variable:
            tmp_lst = re.compile(variable.replace("[", "\[").replace("]", "\]") + '[ ]+=.*?;', re.M | re.S).findall(script)            
        else:
            tmp_lst = [script]
        if len(tmp_lst) > 0:
            log("Found: " + repr(tmp_lst), 4)
            lst += tmp_lst
        else:
            log("Found nothing on: " + script, 4)

    test = range(0, len(lst))
    test.reverse()
    for i in test:
        if match and lst[i].find(match) == -1:
            log("Removing item: " + repr(lst[i]), 10)
            del lst[i]
        else:
            log("Cleaning item: " + repr(lst[i]), 4)
            if lst[i][0] == u"\n":
                lst[i] == lst[i][1:]
            if lst[i][len(lst) -1] == u"\n":
                lst[i] == lst[i][:len(lst)- 2]
            lst[i] = lst[i].strip()

    if values or evaluate:
        for i in range(0, len(lst)):
            log("Getting values %s" % lst[i])
            if function:
                if evaluate: # include the ( ) for evaluation
                    data = re.compile("(\(.*?\))", re.M | re.S).findall(lst[i])
                else:
                    data = re.compile("\((.*?)\)", re.M | re.S).findall(lst[i])
            elif variable:
                tlst = re.compile(variable +".*?=.*?;", re.M | re.S).findall(lst[i])
                data = []
                for tmp in tlst: # This breaks for some stuff. "ad_tag": "http://ad-emea.doubleclick.net/N4061/pfadx/com.ytpwatch.entertainment/main_563326'' # ends early, must end with } 
                    cont_char = tmp[0]
                    cont_char = tmp[tmp.find("=") + 1:].strip()
                    cont_char = cont_char[0]
                    if cont_char in "'\"":
                        log("Using %s as quotation mark" % cont_char, 1)
                        tmp = tmp[tmp.find(cont_char) + 1:tmp.rfind(cont_char)]
                    else:
                        log("No quotation mark found", 1)
                        tmp = tmp[tmp.find("=") + 1: tmp.rfind(";")]

                    tmp = tmp.strip()
                    if len(tmp) > 0:
                        data.append(tmp)
            else:
                log("ERROR: Don't know what to extract values from")

            log("Values extracted: %s" % repr(data))
            if len(data) > 0:
                lst[i] = data[0]

    if evaluate:
        for i in range(0, len(lst)):
            log("Evaluating %s" % lst[i])
            data = lst[i].strip()
            try:
                try:
                    lst[i] = json.loads(data)
                except:
                    log("Couldn't json.loads, trying eval")
                    lst[i] = eval(data)
            except:
                log("Couldn't eval: %s from %s" % (repr(data), repr(lst[i])))

    log("Done: " + str(len(lst)))
    return lst

def fetchPage(params={}):
    get = params.get
    link = get("link")
    ret_obj = { "new_url": link}
    if get("post_data"):
        log("called for : " + repr(params['link']))
    else:
        log("called for : " + repr(params))

    if not link or int(get("error", "0")) > 2:
        log("giving up")
        ret_obj["status"] = 500
        return ret_obj

    if get("post_data"):
        if get("hide_post_data"):
            log("Posting data", 2)
        else:
            log("Posting data: " + urllib.urlencode(get("post_data")), 2)

        request = urllib2.Request(link, urllib.urlencode(get("post_data")))
        request.add_header('Content-Type', 'application/x-www-form-urlencoded')
    else:
        log("Got request", 2)
        request = urllib2.Request(link)

    if get("headers"):
        for head in get("headers"):
            request.add_header(head[0], head[1])

    request.add_header('User-Agent', USERAGENT)

    if get("cookie"):
        request.add_header('Cookie', get("cookie"))

    if get("refering"):
        log("Setting refering: " + get("refering"), 3)
        request.add_header('Referer', get("refering"))

    try:
        log("connecting to server...", 1)

        con = urllib2.urlopen(request)
        ret_obj["header"] = con.info().headers
        ret_obj["new_url"] = con.geturl()
        if get("no-content", "false") == u"false" or get("no-content", "false") == "false":
            inputdata = con.read()
            #data_type = chardet.detect(inputdata)
            #inputdata = inputdata.decode(data_type["encoding"])
            ret_obj["content"] = inputdata.decode("utf-8")

        con.close()

        log("Done")
        ret_obj["status"] = 200
        return ret_obj

    except urllib2.HTTPError, e:
        err = str(e)
        log("HTTPError : " + err)
        log("HTTPError - Headers: " + str(e.headers) + " - Content: " + e.fp.read())

        params["error"] = str(int(get("error", "0")) + 1)
        ret = fetchPage(params)

        if not "content" in ret and e.fp:
            ret["content"] = e.fp.read()
            return ret

        ret_obj["status"] = 500
        return ret_obj

    except urllib2.URLError, e:
        err = str(e)
        log("URLError : " + err)

        time.sleep(3)
        params["error"] = str(int(get("error", "0")) + 1)
        ret_obj = fetchPage(params)
        return ret_obj


def getCookieInfoAsHTML():
    log("", 5)
    if hasattr(sys.modules["__main__"], "cookiejar"):
        cookiejar = sys.modules["__main__"].cookiejar

        cookie = repr(cookiejar)
        cookie = cookie.replace("<_LWPCookieJar.LWPCookieJar[", "")
        cookie = cookie.replace("), Cookie(version=0,", "></cookie><cookie ")
        cookie = cookie.replace(")]>", "></cookie>")
        cookie = cookie.replace("Cookie(version=0,", "<cookie ")
        cookie = cookie.replace(", ", " ")
        log(repr(cookie), 5)
        return cookie

    log("Found no cookie", 5)
    return ""


# This function implements a horrible hack related to python 2.4's terrible unicode handling.
def makeAscii(data):
    log(repr(data), 5)
    #if sys.hexversion >= 0x02050000:
    #        return data

    try:
        return data.encode('ascii', "ignore")
    except:
        log("Hit except on : " + repr(data))
        s = u""
        for i in data:
            try:
                i.encode("ascii", "ignore")
            except:
                log("Can't convert character", 4)
                continue
            else:
                s += i

        log(repr(s), 5)
        return s


# This function handles stupid utf handling in python.
def makeUTF8(data):
    log(repr(data), 5)
    return data
    try:
        return data.decode('utf8', 'xmlcharrefreplace') # was 'ignore'
    except:
        log("Hit except on : " + repr(data))
        s = u""
        for i in data:
            try:
                i.decode("utf8", "xmlcharrefreplace") 
            except:
                log("Can't convert character", 4)
                continue
            else:
                s += i
        log(repr(s), 5)
        return s


def openFile(filepath, options=u"r"):
    log(repr(filepath) + " - " + repr(options))
    if options.find("b") == -1:  # Toggle binary mode on failure
        alternate = options + u"b"
    else:
        alternate = options.replace(u"b", u"")

    try:
        log("Trying normal: %s" % options)
        return io.open(filepath, options)
    except:
        log("Fallback to binary: %s" % alternate)
        return io.open(filepath, alternate)


def log(description, level=0):
    if dbg and dbglevel > level:
        try:
            xbmc.log((u"[%s] %s : '%s'" % (plugin, inspect.stack()[1][3], description)).decode("utf-8"), xbmc.LOGNOTICE)
        except:
            xbmc.log(u"FALLBACK [%s] %s : '%s'" % (plugin, inspect.stack()[1][3], repr(description)), xbmc.LOGNOTICE)

########NEW FILE########
__FILENAME__ = mock
# mock.py
# Test tools for mocking and patching.
# Copyright (C) 2007-2011 Michael Foord & the mock team
# E-mail: fuzzyman AT voidspace DOT org DOT uk

# mock 0.8.0
# http://www.voidspace.org.uk/python/mock/

# Released subject to the BSD License
# Please see http://www.voidspace.org.uk/python/license.shtml

# Scripts maintained at http://www.voidspace.org.uk/python/index.shtml
# Comments, suggestions and bug reports welcome.


__all__ = (
    'Mock',
    'MagicMock',
    'mocksignature',
    'patch',
    'sentinel',
    'DEFAULT',
    'ANY',
    'call',
    'create_autospec',
    'FILTER_DIR',
    'NonCallableMock',
    'NonCallableMagicMock',
)


__version__ = '0.8.0beta3'


import pprint
import sys

try:
    import inspect
except ImportError:
    # for alternative platforms that
    # may not have inspect
    inspect = None


try:
    from functools import wraps
except ImportError:
    # Python 2.4 compatibility
    def wraps(original):
        def inner(f):
            f.__name__ = original.__name__
            f.__doc__ = original.__doc__
            f.__module__ = original.__module__
            return f
        return inner

try:
    unicode
except NameError:
    # Python 3
    basestring = unicode = str

try:
    long
except NameError:
    # Python 3
    long = int

try:
    BaseException
except NameError:
    # Python 2.4 compatibility
    BaseException = Exception

try:
    next
except NameError:
    def next(obj):
        return obj.next()


BaseExceptions = (BaseException,)
if 'java' in sys.platform:
    # jython
    import java
    BaseExceptions = (BaseException, java.lang.Throwable)

try:
    _isidentifier = str.isidentifier
except AttributeError:
    # Python 2.X
    import keyword
    import re
    regex = re.compile(r'^[a-z_][a-z0-9_]*$', re.I)
    def _isidentifier(string):
        if string in keyword.kwlist:
            return False
        return regex.match(string)


inPy3k = sys.version_info[0] == 3

# Needed to work around Python 3 bug where use of "super" interferes with
# defining __class__ as a descriptor
_super = super

self = 'im_self'
builtin = '__builtin__'
if inPy3k:
    self = '__self__'
    builtin = 'builtins'

FILTER_DIR = True


def _is_instance_mock(obj):
    # can't use isinstance on Mock objects because they override __class__
    # The base class for all mocks is NonCallableMock
    return issubclass(type(obj), NonCallableMock)


def _is_exception(obj):
    return (
        isinstance(obj, BaseExceptions) or
        isinstance(obj, ClassTypes) and issubclass(obj, BaseExceptions)
    )


class _slotted(object):
    __slots__ = ['a']


DescriptorTypes = (
    type(_slotted.a),
    property,
)


# getsignature and mocksignature heavily "inspired" by
# the decorator module: http://pypi.python.org/pypi/decorator/
# by Michele Simionato

def _getsignature(func, skipfirst):
    if inspect is None:
        raise ImportError('inspect module not available')

    if inspect.isclass(func):
        func = func.__init__
        # will have a self arg
        skipfirst = True
    elif not (inspect.ismethod(func) or inspect.isfunction(func)):
        func = func.__call__

    regargs, varargs, varkwargs, defaults = inspect.getargspec(func)

    # instance methods need to lose the self argument
    if getattr(func, self, None) is not None:
        regargs = regargs[1:]

    _msg = "_mock_ is a reserved argument name, can't mock signatures using _mock_"
    assert '_mock_' not in regargs, _msg
    if varargs is not None:
        assert '_mock_' not in varargs, _msg
    if varkwargs is not None:
        assert '_mock_' not in varkwargs, _msg
    if skipfirst:
        regargs = regargs[1:]

    signature = inspect.formatargspec(regargs, varargs, varkwargs, defaults,
                                      formatvalue=lambda value: "")
    return signature[1:-1], func


def _getsignature2(func, skipfirst):
    if inspect is None:
        raise ImportError('inspect module not available')

    if isinstance(func, ClassTypes):
        try:
            func = func.__init__
        except AttributeError:
            return
        skipfirst = True
    elif not isinstance(func, FunctionTypes):
        func = func.__call__

    try:
        regargs, varargs, varkwargs, defaults = inspect.getargspec(func)
    except TypeError:
        # C function / method, possibly inherited object().__init__
        return

    # instance methods and classmethods need to lose the self argument
    if getattr(func, self, None) is not None:
        regargs = regargs[1:]
    if skipfirst:
        # this condition and the above one are never both True - why?
        regargs = regargs[1:]

    signature = inspect.formatargspec(regargs, varargs, varkwargs, defaults,
                                      formatvalue=lambda value: "")
    return signature[1:-1], func


def _check_signature(func, mock, skipfirst):
    if not _callable(func):
        return

    result = _getsignature2(func, skipfirst)
    if result is None:
        return
    signature, func = result

    # can't use self because "self" is common as an argument name
    # unfortunately even not in the first place
    src = "lambda _mock_self, %s: None" % signature
    checksig = eval(src, {})
    _copy_func_details(func, checksig)
    type(mock)._mock_check_sig = checksig


def _copy_func_details(func, funcopy):
    funcopy.__name__ = func.__name__
    funcopy.__doc__ = func.__doc__
    #funcopy.__dict__.update(func.__dict__)
    funcopy.__module__ = func.__module__
    if not inPy3k:
        funcopy.func_defaults = func.func_defaults
        return
    funcopy.__defaults__ = func.__defaults__
    funcopy.__kwdefaults__ = func.__kwdefaults__


def _callable(obj):
    if isinstance(obj, ClassTypes):
        return True
    if getattr(obj, '__call__', None) is not None:
        return True
    return False


def _is_list(obj):
    # checks for list or tuples
    # XXXX badly named!
    return type(obj) in (list, tuple)


def _instance_callable(obj):
    """Given an object, return True if the object is callable.
    For classes, return True if instances would be callable."""
    if not isinstance(obj, ClassTypes):
        # already an instance
        return hasattr(obj, '__call__')

    klass = obj
    # uses __bases__ instead of __mro__ so that we work with old style classes
    if '__call__' in klass.__dict__:
        return True
    for base in klass.__bases__:
        if _instance_callable(base):
            return True
    return False


def _set_signature(mock, original):
    # creates a function with signature (*args, **kwargs) that delegates to a
    # mock. It still does signature checking by calling a lambda with the same
    # signature as the original. This is effectively mocksignature2.
    if not _callable(original):
        return

    skipfirst = isinstance(original, ClassTypes)
    result = _getsignature2(original, skipfirst)
    if result is None:
        # was a C function (e.g. object().__init__ ) that can't be mocked
        return

    signature, func = result

    src = "lambda %s: None" % signature
    context = {'_mock_': mock}
    checksig = eval(src, context)
    _copy_func_details(func, checksig)

    name = original.__name__
    if not _isidentifier(name):
        name = 'funcopy'
    context = {'checksig': checksig, 'mock': mock}
    src = """def %s(*args, **kwargs):
    checksig(*args, **kwargs)
    return mock(*args, **kwargs)""" % name
    exec (src, context)
    funcopy = context[name]
    _setup_func(funcopy, mock)
    return funcopy


def mocksignature(func, mock=None, skipfirst=False):
    """
    mocksignature(func, mock=None, skipfirst=False)

    Create a new function with the same signature as `func` that delegates
    to `mock`. If `skipfirst` is True the first argument is skipped, useful
    for methods where `self` needs to be omitted from the new function.

    If you don't pass in a `mock` then one will be created for you.

    The mock is set as the `mock` attribute of the returned function for easy
    access.

    `mocksignature` can also be used with classes. It copies the signature of
    the `__init__` method.

    When used with callable objects (instances) it copies the signature of the
    `__call__` method.
    """
    if mock is None:
        mock = Mock()
    signature, func = _getsignature(func, skipfirst)
    src = "lambda %(signature)s: _mock_(%(signature)s)" % {
        'signature': signature
    }

    funcopy = eval(src, dict(_mock_=mock))
    _copy_func_details(func, funcopy)
    _setup_func(funcopy, mock)
    return funcopy


def _setup_func(funcopy, mock):
    funcopy.mock = mock

    # can't use isinstance with mocks
    if not _is_instance_mock(mock):
        return

    def assert_called_with(*args, **kwargs):
        return mock.assert_called_with(*args, **kwargs)
    def assert_called_once_with(*args, **kwargs):
        return mock.assert_called_once_with(*args, **kwargs)
    def assert_has_calls(*args, **kwargs):
        return mock.assert_has_calls(*args, **kwargs)
    def assert_any_call(*args, **kwargs):
        return mock.assert_any_call(*args, **kwargs)
    def reset_mock():
        funcopy.method_calls = _CallList()
        funcopy.mock_calls = _CallList()
        mock.reset_mock()
        ret = funcopy.return_value
        if _is_instance_mock(ret) and not ret is mock:
            ret.reset_mock()

    funcopy.called = False
    funcopy.call_count = 0
    funcopy.call_args = None
    funcopy.call_args_list = _CallList()
    funcopy.method_calls = _CallList()
    funcopy.mock_calls = _CallList()

    funcopy.return_value = mock.return_value
    funcopy.side_effect = mock.side_effect
    funcopy._mock_children = mock._mock_children

    funcopy.assert_called_with = assert_called_with
    funcopy.assert_called_once_with = assert_called_once_with
    funcopy.assert_has_calls = assert_has_calls
    funcopy.assert_any_call = assert_any_call
    funcopy.reset_mock = reset_mock

    mock._mock_signature = funcopy


def _is_magic(name):
    return '__%s__' % name[2:-2] == name


class SentinelObject(object):
    "A unique, named, sentinel object."
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return '<SentinelObject "%s">' % self.name


class Sentinel(object):
    """Access attributes to return a named object, usable as a sentinel."""
    def __init__(self):
        self._sentinels = {}

    def __getattr__(self, name):
        if name == '__bases__':
            # Without this help(mock) raises an exception
            raise AttributeError
        return self._sentinels.setdefault(name, SentinelObject(name))


sentinel = Sentinel()

DEFAULT = sentinel.DEFAULT


class OldStyleClass:
    pass
ClassType = type(OldStyleClass)


def _copy(value):
    if type(value) in (dict, list, tuple, set):
        return type(value)(value)
    return value


ClassTypes = (type,)
if not inPy3k:
    ClassTypes = (type, ClassType)

_allowed_names = set(
    [
        'return_value', '_mock_return_value', 'side_effect',
        '_mock_side_effect', '_mock_parent', '_mock_new_parent',
        '_mock_name', '_mock_new_name'
    ]
)


def _mock_signature_property(name):
    _allowed_names.add(name)
    def _get(self):
        sig = self._mock_signature
        if sig is None:
            return getattr(self, '_mock_' + name)
        return getattr(sig, name)
    def _set(self, value):
        sig = self._mock_signature
        if sig is None:
            setattr(self, '_mock_' + name, value)
        else:
            setattr(sig, name, value)

    return property(_get, _set)



class _CallList(list):

    def __contains__(self, value):
        if not isinstance(value, list):
            return list.__contains__(self, value)
        len_value = len(value)
        len_self = len(self)
        if len_value > len_self:
            return False

        for i in range(0, len_self - len_value + 1):
            sub_list = self[i:i+len_value]
            if sub_list == value:
                return True
        return False

    def __repr__(self):
        return pprint.pformat(list(self))


def _check_and_set_parent(parent, value, name, new_name):
    if not _is_instance_mock(value):
        return False
    if (value._mock_name or value._mock_new_name or
        value._mock_parent or value._mock_new_parent):
        return False

    if new_name:
        value._mock_new_parent = parent
        value._mock_new_name = new_name
    if name:
        value._mock_parent = parent
        value._mock_name = name
    return True



class Base(object):
    _mock_return_value = DEFAULT
    _mock_side_effect = None
    def __init__(self, *args, **kwargs):
        pass



class NonCallableMock(Base):
    """A non-callable version of `Mock`"""

    def __new__(cls, *args, **kw):
        # every instance has its own class
        # so we can create magic methods on the
        # class without stomping on other mocks
        new = type(cls.__name__, (cls,), {'__doc__': cls.__doc__})
        return object.__new__(new)


    def __init__(
            self, spec=None, wraps=None, name=None, spec_set=None,
            parent=None, _spec_state=None, _new_name='', _new_parent=None,
            **kwargs
        ):
        if _new_parent is None:
            _new_parent = parent

        self._mock_parent = parent
        self._mock_name = name
        self._mock_new_name = _new_name
        self._mock_new_parent = _new_parent

        if spec_set is not None:
            spec = spec_set
            spec_set = True
        self._mock_add_spec(spec, spec_set)

        self._mock_children = {}
        self._mock_wraps = wraps
        self._mock_signature = None

        self._mock_called = False
        self._mock_call_args = None
        self._mock_call_count = 0
        self._mock_call_args_list = _CallList()
        self._mock_mock_calls = _CallList()

        self.reset_mock()
        self.configure_mock(**kwargs)

        _super(NonCallableMock, self).__init__(
            spec, wraps, name, spec_set, parent,
            _spec_state, **kwargs
        )


    def mock_add_spec(self, spec, spec_set=False):
        """Add a spec to a mock. `spec` can either be an object or a
        list of strings. Only attributes on the `spec` can be fetched as
        attributes from the mock.

        If `spec_set` is True then only attributes on the spec can be set."""
        self._mock_add_spec(spec, spec_set)


    def _mock_add_spec(self, spec, spec_set):
        _spec_class = None

        if spec is not None and not _is_list(spec):
            if isinstance(spec, ClassTypes):
                _spec_class = spec
            else:
                _spec_class = _get_class(spec)

            spec = dir(spec)

        self._spec_class = _spec_class
        self._spec_set = spec_set
        self._mock_methods = spec


    def __get_return_value(self):
        ret = self._mock_return_value
        if self._mock_signature is not None:
            ret = self._mock_signature.return_value

        if ret is DEFAULT:
            ret = self._get_child_mock(
                _new_parent=self, _new_name='()'
            )
            self.return_value = ret
        return ret


    def __set_return_value(self, value):
        if self._mock_signature is not None:
            self._mock_signature.return_value = value
        else:
            self._mock_return_value = value
            _check_and_set_parent(self, value, None, '()')

    __return_value_doc = "The value to be returned when the mock is called."
    return_value = property(__get_return_value, __set_return_value,
                            __return_value_doc)


    @property
    def __class__(self):
        if self._spec_class is None:
            return type(self)
        return self._spec_class

    called = _mock_signature_property('called')
    call_count = _mock_signature_property('call_count')
    call_args = _mock_signature_property('call_args')
    call_args_list = _mock_signature_property('call_args_list')
    mock_calls = _mock_signature_property('mock_calls')


    def __get_side_effect(self):
        sig = self._mock_signature
        if sig is None:
            return self._mock_side_effect
        return sig.side_effect

    def __set_side_effect(self, value):
        value = _try_iter(value)
        sig = self._mock_signature
        if sig is None:
            self._mock_side_effect = value
        else:
            sig.side_effect = value

    side_effect = property(__get_side_effect, __set_side_effect)


    def reset_mock(self):
        "Restore the mock object to its initial state."
        self.called = False
        self.call_args = None
        self.call_count = 0
        self.mock_calls = _CallList()
        self.call_args_list = _CallList()
        self.method_calls = _CallList()

        for child in self._mock_children.values():
            child.reset_mock()

        ret = self._mock_return_value
        if _is_instance_mock(ret) and ret is not self:
            ret.reset_mock()


    def configure_mock(self, **kwargs):
        """XXX needs docstring"""
        for arg, val in sorted(kwargs.items(),
                               # we sort on the number of dots so that
                               # attributes are set before we set attributes on
                               # attributes
                               key=lambda entry: entry[0].count('.')):
            args = arg.split('.')
            final = args.pop()
            obj = self
            for entry in args:
                obj = getattr(obj, entry)
            setattr(obj, final, val)


    def __getattr__(self, name):
        if name == '_mock_methods':
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
            raise AttributeError(name)

        result = self._mock_children.get(name)
        if result is None:
            wraps = None
            if self._mock_wraps is not None:
                # XXXX should we get the attribute without triggering code
                # execution?
                wraps = getattr(self._mock_wraps, name)

            result = self._get_child_mock(
                parent=self, name=name, wraps=wraps, _new_name=name,
                _new_parent=self
            )
            self._mock_children[name]  = result

        elif isinstance(result, _SpecState):
            result = create_autospec(
                result.spec, result.spec_set, result.instance,
                None, result.parent, result.name
            )
            self._mock_children[name]  = result

        return result


    def __repr__(self):
        _name_list = [self._mock_new_name]
        _parent = self._mock_new_parent
        last = self

        dot = '.'
        if _name_list == ['()']:
            dot = ''
        while _parent is not None:
            last = _parent

            _name_list.append(_parent._mock_new_name + dot)
            dot = '.'
            if _parent._mock_new_name == '()':
                dot = ''

            _parent = _parent._mock_new_parent

        _name_list = list(reversed(_name_list))
        _first = last._mock_name or 'mock'
        if len(_name_list) > 1:
            if _name_list[1] not in ('()', '().'):
                _first += '.'
        _name_list[0] = _first
        name = ''.join(_name_list)

        name_string = ''
        if name not in ('mock', 'mock.'):
            name_string = ' name=%r' % name

        spec_string = ''
        if self._spec_class is not None:
            spec_string = ' spec=%r'
            if self._spec_set:
                spec_string = ' spec_set=%r'
            spec_string = spec_string % self._spec_class.__name__
        return "<%s%s%s id='%s'>" % (
            type(self).__name__,
            name_string,
            spec_string,
            id(self)
        )


    def __dir__(self):
        extras = self._mock_methods or []
        from_type = dir(type(self))
        from_dict = list(self.__dict__)

        if FILTER_DIR:
            from_type = [e for e in from_type if not e.startswith('_')]
            from_dict = [e for e in from_dict if not e.startswith('_') or
                         _is_magic(e)]
        return sorted(set(extras + from_type + from_dict +
                          list(self._mock_children)))


    def __setattr__(self, name, value):
        if not 'method_calls' in self.__dict__:
            # allow all attribute setting until initialisation is complete
            return object.__setattr__(self, name, value)

        if (self._spec_set and self._mock_methods is not None and
            name not in self._mock_methods and
            name not in self.__dict__ and
            name not in _allowed_names):
            raise AttributeError("Mock object has no attribute '%s'" % name)
        elif name in _unsupported_magics:
            msg = 'Attempting to set unsupported magic method %r.' % name
            raise AttributeError(msg)
        elif name in _all_magics:
            if self._mock_methods is not None and name not in self._mock_methods:
                raise AttributeError("Mock object has no attribute '%s'" % name)

            if isinstance(value, MagicProxy):
                setattr(type(self), name, value)
                return

            if not _is_instance_mock(value):
                setattr(type(self), name, _get_method(name, value))
                original = value
                real = lambda *args, **kw: original(self, *args, **kw)
                value = mocksignature(value, real, skipfirst=True)
            else:
                setattr(type(self), name, value)
        elif name in _allowed_names:
            pass
        elif _check_and_set_parent(self, value, name, name):
            self._mock_children[name] = value
            return
        return object.__setattr__(self, name, value)


    def __delattr__(self, name):
        if name in _all_magics and name in type(self).__dict__:
            delattr(type(self), name)
            if name not in self.__dict__:
                # for magic methods that are still MagicProxy objects and
                # not set on the instance itself
                return
        return object.__delattr__(self, name)


    def _format_mock_call_signature(self, args, kwargs):
        name = self._mock_name or 'mock'
        return _format_call_signature(name, args, kwargs)


    def _format_mock_failure_message(self, args, kwargs):
        message = 'Expected call: %s\nActual call: %s'
        expected_string = self._format_mock_call_signature(args, kwargs)
        call_args = self.call_args
        if len(call_args) == 3:
            call_args = call_args[1:]
        actual_string = self._format_mock_call_signature(*call_args)
        return message % (expected_string, actual_string)


    def assert_called_with(_mock_self, *args, **kwargs):
        """assert that the mock was called with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        self = _mock_self
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            raise AssertionError('Expected call: %s\nNot called' % (expected,))

        if self.call_args != (args, kwargs):
            msg = self._format_mock_failure_message(args, kwargs)
            raise AssertionError(msg)


    def assert_called_once_with(_mock_self, *args, **kwargs):
        """assert that the mock was called exactly once and with the specified
        arguments."""
        self = _mock_self
        if not self.call_count == 1:
            msg = ("Expected to be called once. Called %s times." %
                   self.call_count)
            raise AssertionError(msg)
        return self.assert_called_with(*args, **kwargs)


    def assert_has_calls(self, calls, any_order=False):
        """assert the mock has been called with the specified calls.
        The `mock_calls` list is checked for the calls.

        If `any_order` is False (the default) then the calls must be
        sequentially. There can be extra calls before or after the
        specified calls.

        If `any_order` is True then the calls can be in any order, but
        they must all appear in `mock_calls`."""
        if not any_order:
            if calls not in self.mock_calls:
                raise AssertionError(
                    'Calls not found.\nExpected: %r\n'
                    'Actual: %r' % (calls, self.mock_calls)
                )
            return

        all_calls = list(self.mock_calls)

        not_found = []
        for kall in calls:
            try:
                all_calls.remove(kall)
            except ValueError:
                not_found.append(kall)
        if not_found:
            raise AssertionError(
                '%r not all found in call list' % (tuple(not_found),)
            )


    def assert_any_call(self, *args, **kwargs):
        """assert the mock has been called with the specified arguments.

        The assert passes if the mock has *ever* been called, unlike
        `assert_called_with` and `assert_called_once_with` that only pass if
        the call is the most recent one."""
        kall = call(*args, **kwargs)
        if not kall in self.call_args_list:
            expected_string = self._format_mock_call_signature(args, kwargs)
            raise AssertionError(
                '%s call not found, possible calls are: \r\n\r\n %s' % (expected_string, repr(self.call_args_list)) 
            )
    
    def _get_child_mock(self, **kw):
        """Create the child mocks for attributes and return value.
        By default child mocks will be the same type as the parent.
        Subclasses of Mock may want to override this to customize the way
        child mocks are made."""
        _type = type(self)
        if not issubclass(_type, CallableMixin):
            if issubclass(_type, NonCallableMagicMock):
                klass = MagicMock
            elif issubclass(_type, NonCallableMock) :
                klass = Mock
        else:
            klass = _type.__mro__[1]
        return klass(**kw)



def _try_iter(obj):
    if obj is None:
        return obj
    if _is_exception(obj):
        return obj
    if _callable(obj):
        return obj
    try:
        return iter(obj)
    except TypeError:
        # XXXX backwards compatibility
        # but this will blow up on first call - so maybe we should fail early?
        return obj



class CallableMixin(Base):

    def __init__(self, spec=None, side_effect=None, return_value=DEFAULT,
                 wraps=None, name=None, spec_set=None, parent=None,
                 _spec_state=None, _new_name='', _new_parent=None, **kwargs):
        self._mock_return_value = return_value

        _super(CallableMixin, self).__init__(
            spec, wraps, name, spec_set, parent,
            _spec_state, _new_name, _new_parent, **kwargs
        )

        self.side_effect = side_effect




    def _mock_check_sig(self, *args, **kwargs):
        # stub method that can be replaced with one with a specific signature
        pass


    def __call__(_mock_self, *args, **kwargs):
        # can't use self in-case a function / method we are mocking uses self
        # in the signature
        _mock_self._mock_check_sig(*args, **kwargs)
        return _mock_self._mock_call(*args, **kwargs)


    def _mock_call(_mock_self, *args, **kwargs):
        self = _mock_self
        self.called = True
        self.call_count += 1
        self.call_args = _Call((args, kwargs), two=True)
        self.call_args_list.append(_Call((args, kwargs), two=True))

        _new_name = self._mock_new_name
        _new_parent = self._mock_new_parent
        self.mock_calls.append(_Call(('', args, kwargs)))

        skip_next_dot = _new_name == '()'
        while _new_parent is not None:
            this_call = _Call((_new_name, args, kwargs))
            if _new_parent._mock_new_name:
                dot = '.'
                if skip_next_dot:
                    dot = ''

                skip_next_dot = False
                if _new_parent._mock_new_name == '()':
                    skip_next_dot = True

                _new_name = _new_parent._mock_new_name + dot + _new_name

            _new_parent.mock_calls.append(this_call)
            _new_parent = _new_parent._mock_new_parent

        parent = self._mock_parent
        name = self._mock_name
        while parent is not None:
            parent.method_calls.append(_Call((name, args, kwargs)))
            if parent._mock_parent is None:
                break
            name = parent._mock_name + '.' + name
            parent = parent._mock_parent

        ret_val = DEFAULT
        if self.side_effect is not None:
            if _is_exception(self.side_effect):
                raise self.side_effect

            if not _callable(self.side_effect):
                return next(self.side_effect)

            ret_val = self.side_effect(*args, **kwargs)
            if ret_val is DEFAULT:
                ret_val = self.return_value

        if (self._mock_wraps is not None and
             self._mock_return_value is DEFAULT):
            return self._mock_wraps(*args, **kwargs)
        if ret_val is DEFAULT:
            ret_val = self.return_value
        return ret_val



class Mock(CallableMixin, NonCallableMock):
    """
    Create a new `Mock` object. `Mock` takes several optional arguments
    that specify the behaviour of the Mock object:

    * `spec`: This can be either a list of strings or an existing object (a
      class or instance) that acts as the specification for the mock object. If
      you pass in an object then a list of strings is formed by calling dir on
      the object (excluding unsupported magic attributes and methods). Accessing
      any attribute not in this list will raise an `AttributeError`.

      If `spec` is an object (rather than a list of strings) then
      `mock.__class__` returns the class of the spec object. This allows mocks
      to pass `isinstance` tests.

    * `spec_set`: A stricter variant of `spec`. If used, attempting to *set*
      or get an attribute on the mock that isn't on the object passed as
      `spec_set` will raise an `AttributeError`.

    * `side_effect`: A function to be called whenever the Mock is called. See
      the :attr:`Mock.side_effect` attribute. Useful for raising exceptions or
      dynamically changing return values. The function is called with the same
      arguments as the mock, and unless it returns :data:`DEFAULT`, the return
      value of this function is used as the return value.

      Alternatively `side_effect` can be an exception class or instance. In
      this case the exception will be raised when the mock is called.

    * `return_value`: The value returned when the mock is called. By default
      this is a new Mock (created on first access). See the
      :attr:`Mock.return_value` attribute.

    * `wraps`: Item for the mock object to wrap. If `wraps` is not None
      then calling the Mock will pass the call through to the wrapped object
      (returning the real result and ignoring `return_value`). Attribute
      access on the mock will return a Mock object that wraps the corresponding
      attribute of the wrapped object (so attempting to access an attribute that
      doesn't exist will raise an `AttributeError`).

      If the mock has an explicit `return_value` set then calls are not passed
      to the wrapped object and the `return_value` is returned instead.

    * `name`: If the mock has a name then it will be used in the repr of the
      mock. This can be useful for debugging. The name is propagated to child
      mocks.

    Mocks can also be called with arbitrary keyword arguments. These will be
    used to set attributes on the mock after it is created.
    """



def _dot_lookup(thing, comp, import_path):
    try:
        return getattr(thing, comp)
    except AttributeError:
        __import__(import_path)
        return getattr(thing, comp)


def _importer(target):
    components = target.split('.')
    import_path = components.pop(0)
    thing = __import__(import_path)

    for comp in components:
        import_path += ".%s" % comp
        thing = _dot_lookup(thing, comp, import_path)
    return thing


def _is_started(patcher):
    # XXXX horrible
    return hasattr(patcher, 'is_local')


class _patch(object):

    attribute_name = None

    def __init__(
            self, target, attribute, new, spec, create,
            mocksignature, spec_set, autospec, new_callable, kwargs
        ):
        if new_callable is not None:
            if new is not DEFAULT:
                raise ValueError(
                    "Cannot use 'new' and 'new_callable' together"
                )
            if autospec is not False:
                raise ValueError(
                    "Cannot use 'autospec' and 'new_callable' together"
                )

        self.target = target
        self.attribute = attribute
        self.new = new
        self.new_callable = new_callable
        self.spec = spec
        self.create = create
        self.has_local = False
        self.mocksignature = mocksignature
        self.spec_set = spec_set
        self.autospec = autospec
        self.kwargs = kwargs
        self.additional_patchers = []


    def copy(self):
        patcher = _patch(
            self.target, self.attribute, self.new, self.spec,
            self.create, self.mocksignature, self.spec_set,
            self.autospec, self.new_callable, self.kwargs
        )
        patcher.attribute_name = self.attribute_name
        patcher.additional_patchers = [
            p.copy() for p in self.additional_patchers
        ]
        return patcher


    def __call__(self, func):
        if isinstance(func, ClassTypes):
            return self.decorate_class(func)
        return self.decorate_callable(func)


    def decorate_class(self, klass):
        for attr in dir(klass):
            if not attr.startswith(patch.TEST_PREFIX):
                continue

            attr_value = getattr(klass, attr)
            if not hasattr(attr_value, "__call__"):
                continue

            patcher = self.copy()
            setattr(klass, attr, patcher(attr_value))
        return klass


    def decorate_callable(self, func):
        if hasattr(func, 'patchings'):
            func.patchings.append(self)
            return func

        @wraps(func)
        def patched(*args, **keywargs):
            # don't use a with here (backwards compatability with Python 2.4)
            extra_args = []
            entered_patchers = []

            # can't use try...except...finally because of Python 2.4
            # compatibility
            try:
                try:
                    for patching in patched.patchings:
                        arg = patching.__enter__()
                        entered_patchers.append(patching)
                        if patching.attribute_name is not None:
                            keywargs.update(arg)
                        elif patching.new is DEFAULT:
                            extra_args.append(arg)

                    args += tuple(extra_args)
                    return func(*args, **keywargs)
                except:
                    if (patching not in entered_patchers and
                        _is_started(patching)):
                        # the patcher may have been started, but an exception
                        # raised whilst entering one of its additional_patchers
                        entered_patchers.append(patching)
                    # re-raise the exception
                    raise
            finally:
                for patching in reversed(entered_patchers):
                    patching.__exit__()

        patched.patchings = [self]
        if hasattr(func, 'func_code'):
            # not in Python 3
            patched.compat_co_firstlineno = getattr(
                func, "compat_co_firstlineno",
                func.func_code.co_firstlineno
            )
        return patched


    def get_original(self):
        target = self.target
        name = self.attribute

        original = DEFAULT
        local = False

        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True

        if not self.create and original is DEFAULT:
            raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
        return original, local


    def __enter__(self):
        """Perform the patch."""
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable

        original, local = self.get_original()

        if new is DEFAULT and autospec is False:
            inherit = False
            if spec_set == True:
                spec_set = original
            elif spec == True:
                # set spec to the object we are replacing
                spec = original

            if (spec or spec_set) is not None:
                if isinstance(original, ClassTypes):
                    # If we're patching out a class and there is a spec
                    inherit = True

            Klass = MagicMock
            _kwargs = {}
            if new_callable is not None:
                Klass = new_callable
            elif (spec or spec_set) is not None:
                if not _callable(spec or spec_set):
                    Klass = NonCallableMagicMock

            if spec is not None:
                _kwargs['spec'] = spec
            if spec_set is not None:
                _kwargs['spec_set'] = spec_set

            # add a name to mocks
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and self.attribute):
                _kwargs['name'] = self.attribute

            _kwargs.update(kwargs)
            new = Klass(**_kwargs)

            if inherit and _is_instance_mock(new):
                # we can only tell if the instance should be callable if the
                # spec is not a list
                if (not _is_list(spec or spec_set) and not
                    _instance_callable(spec or spec_set)):
                    Klass = NonCallableMagicMock

                _kwargs.pop('name')
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs)
        elif autospec is not False:
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool? mocksignature should also not be used. Should we
            # check this?
            if new is not DEFAULT:
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                )
            spec_set = bool(spec_set)
            if autospec is True:
                autospec = original
            new = create_autospec(autospec, spec_set=spec_set, configure=kwargs,
                                  _name=self.attribute)
        elif kwargs:
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating")

        new_attr = new
        if self.mocksignature:
            new_attr = mocksignature(original, new)

        self.temp_original = original
        self.is_local = local
        setattr(self.target, self.attribute, new_attr)
        if self.attribute_name is not None:
            extra_args = {}
            if self.new is DEFAULT:
                extra_args[self.attribute_name] =  new
            for patching in self.additional_patchers:
                arg = patching.__enter__()
                if patching.new is DEFAULT:
                    extra_args.update(arg)
            return extra_args

        return new


    def __exit__(self, *_):
        """Undo the patch."""
        if not _is_started(self):
            raise RuntimeError('stop called on unstarted patcher')

        if self.is_local and self.temp_original is not DEFAULT:
            setattr(self.target, self.attribute, self.temp_original)
        else:
            delattr(self.target, self.attribute)
            if not self.create and not hasattr(self.target, self.attribute):
                # needed for proxy objects like django settings
                setattr(self.target, self.attribute, self.temp_original)

        del self.temp_original
        del self.is_local
        for patcher in reversed(self.additional_patchers):
            if _is_started(patcher):
                patcher.__exit__()

    start = __enter__
    stop = __exit__



def _get_target(target):
    try:
        target, attribute = target.rsplit('.', 1)
    except (TypeError, ValueError):
        raise TypeError("Need a valid target to patch. You supplied: %r" %
                        (target,))
    target = _importer(target)
    return target, attribute


def _patch_object(
        target, attribute, new=DEFAULT, spec=None,
        create=False, mocksignature=False, spec_set=None, autospec=False,
        new_callable=None, **kwargs
    ):
    """
    patch.object(target, attribute, new=DEFAULT, spec=None, create=False,
                 mocksignature=False, spec_set=None)

    patch the named member (`attribute`) on an object (`target`) with a mock
    object.

    Arguments new, spec, create, mocksignature and spec_set have the same
    meaning as for patch.
    """
    return _patch(
        target, attribute, new, spec, create, mocksignature,
        spec_set, autospec, new_callable, kwargs
    )


def _patch_multiple(target, spec=None, create=False,
        mocksignature=False, spec_set=None, autospec=False,
        new_callable=None, **kwargs
    ):
    """Perform multiple patches in a single call. It takes the object to be
    patched (either as an object or a string to fetch the object by importing)
    and keyword arguments for the patches::

        with patch.multiple(settings, FIRST_PATCH='one', SECOND_PATCH='two'):
            ...

    Like `patch` it can be used as a decorator, class decorator or a context
    manager. The arguments `spec`, `spec_set`, `create`, `mocksignature`,
    `autospec` and `new_callable` have the same meaning as for `patch`. These
    arguments will be applied to *all* the patches being done by
    `patch.multiple`.
    """
    if type(target) in (unicode, str):
        target = _importer(target)

    if not kwargs:
        raise ValueError(
            'Must supply at least one keyword argument with patch.multiple'
        )
    # need to wrap in a list for python 3, where items is a view
    items = list(kwargs.items())
    attribute, new = items[0]
    patcher = _patch(
        target, attribute, new, spec, create, mocksignature, spec_set,
        autospec, new_callable, {}
    )
    patcher.attribute_name = attribute
    for attribute, new in items[1:]:
        this_patcher = _patch(
            target, attribute, new, spec, create, mocksignature, spec_set,
            autospec, new_callable, {}
        )
        this_patcher.attribute_name = attribute
        patcher.additional_patchers.append(this_patcher)
    return patcher


def patch(
        target, new=DEFAULT, spec=None, create=False,
        mocksignature=False, spec_set=None, autospec=False,
        new_callable=None, **kwargs
    ):
    """
    `patch` acts as a function decorator, class decorator or a context
    manager. Inside the body of the function or with statement, the `target`
    (specified in the form `'package.module.ClassName'`) is patched
    with a `new` object. When the function/with statement exits the patch is
    undone.

    The `target` is imported and the specified attribute patched with the new
    object, so it must be importable from the environment you are calling the
    decorator from.

    If `new` is omitted, then a new `MagicMock` is created and passed in as an
    extra argument to the decorated function.

    The `spec` and `spec_set` keyword arguments are passed to the `MagicMock`
    if patch is creating one for you.

    In addition you can pass `spec=True` or `spec_set=True`, which causes
    patch to pass in the object being mocked as the spec/spec_set object.

    `new_callable` allows you to specify a different class, or callable object,
    that will be called to create the `new` object. By default `MagicMock` is
    used.

    A more powerful form of `spec` is `autospec`. If you set `autospec=True`
    then the mock with be created with a spec from the object being replaced.
    All attributes of the mock will also have the spec of the corresponding
    attribute of the object being replaced. Methods and functions being mocked
    will have their arguments checked and will raise a `TypeError` if they are
    called with the wrong signature (similar to `mocksignature`). For mocks
    replacing a class, their return value (the 'instance') will have the same
    spec as the class.

    Instead of `autospec=True` you can pass `autospec=some_object` to use an
    arbitrary object as the spec instead of the one being replaced.

    If `mocksignature` is True then the patch will be done with a function
    created by mocking the one being replaced. If the object being replaced is
    a class then the signature of `__init__` will be copied. If the object
    being replaced is a callable object then the signature of `__call__` will
    be copied.

    By default `patch` will fail to replace attributes that don't exist. If
    you pass in 'create=True' and the attribute doesn't exist, patch will
    create the attribute for you when the patched function is called, and
    delete it again afterwards. This is useful for writing tests against
    attributes that your production code creates at runtime. It is off by by
    default because it can be dangerous. With it switched on you can write
    passing tests against APIs that don't actually exist!

    Patch can be used as a TestCase class decorator. It works by
    decorating each test method in the class. This reduces the boilerplate
    code when your test methods share a common patchings set. `patch` finds
    tests by looking for method names that start with `patch.TEST_PREFIX`.
    By default this is `test`, which matches the way `unittest` finds tests.
    You can specify an alternative prefix by setting `patch.TEST_PREFIX`.

    Patch can be used with the with statement, if this is available in your
    version of Python. Here the patching applies to the indented block after
    the with statement. If you use "as" then the patched object will be bound
    to the name after the "as"; very useful if `patch` is creating a mock
    object for you.

    `patch` also takes arbitrary keyword arguments. These will be passed to
    the `Mock` (or `new_callable`) on construction.

    `patch.dict(...)`, `patch.multiple(...)` and `patch.object(...)` are
    available for alternate use-cases.
    """
    target, attribute = _get_target(target)
    return _patch(
        target, attribute, new, spec, create, mocksignature,
        spec_set, autospec, new_callable, kwargs
    )


class _patch_dict(object):
    """
    Patch a dictionary and restore the dictionary to its original state after
    the test.

    `in_dict` can be a dictionary or a mapping like container. If it is a
    mapping then it must at least support getting, setting and deleting items
    plus iterating over keys.

    `in_dict` can also be a string specifying the name of the dictionary, which
    will then be fetched by importing it.

    `values` can be a dictionary of values to set in the dictionary. `values`
    can also be an iterable of `(key, value)` pairs.

    If `clear` is True then the dictionary will be cleared before the new
    values are set.

    `patch.dict` can also be called with arbitrary keyword arguments to set
    values in the dictionary::

        with patch.dict('sys.modules', mymodule=Mock(), other_module=Mock()):
            ...
    """

    def __init__(self, in_dict, values=(), clear=False, **kwargs):
        if isinstance(in_dict, basestring):
            in_dict = _importer(in_dict)
        self.in_dict = in_dict
        # support any argument supported by dict(...) constructor
        self.values = dict(values)
        self.values.update(kwargs)
        self.clear = clear
        self._original = None


    def __call__(self, f):
        if isinstance(f, ClassTypes):
            return self.decorate_class(f)
        @wraps(f)
        def _inner(*args, **kw):
            self._patch_dict()
            try:
                return f(*args, **kw)
            finally:
                self._unpatch_dict()

        return _inner


    def decorate_class(self, klass):
        for attr in dir(klass):
            attr_value = getattr(klass, attr)
            if (attr.startswith(patch.TEST_PREFIX) and
                 hasattr(attr_value, "__call__")):
                decorator = _patch_dict(self.in_dict, self.values, self.clear)
                decorated = decorator(attr_value)
                setattr(klass, attr, decorated)
        return klass


    def __enter__(self):
        """Patch the dict."""
        self._patch_dict()


    def _patch_dict(self):
        values = self.values
        in_dict = self.in_dict
        clear = self.clear

        try:
            original = in_dict.copy()
        except AttributeError:
            # dict like object with no copy method
            # must support iteration over keys
            original = {}
            for key in in_dict:
                original[key] = in_dict[key]
        self._original = original

        if clear:
            _clear_dict(in_dict)

        try:
            in_dict.update(values)
        except AttributeError:
            # dict like object with no update method
            for key in values:
                in_dict[key] = values[key]


    def _unpatch_dict(self):
        in_dict = self.in_dict
        original = self._original

        _clear_dict(in_dict)

        try:
            in_dict.update(original)
        except AttributeError:
            for key in original:
                in_dict[key] = original[key]


    def __exit__(self, *args):
        """Unpatch the dict."""
        self._unpatch_dict()
        return False

    start = __enter__
    stop = __exit__


def _clear_dict(in_dict):
    try:
        in_dict.clear()
    except AttributeError:
        keys = list(in_dict)
        for key in keys:
            del in_dict[key]


patch.object = _patch_object
patch.dict = _patch_dict
patch.multiple = _patch_multiple
patch.TEST_PREFIX = 'test'

magic_methods = (
    "lt le gt ge eq ne "
    "getitem setitem delitem "
    "len contains iter "
    "hash str sizeof "
    "enter exit "
    "divmod neg pos abs invert "
    "complex int float index "
    "trunc floor ceil "
)

numerics = "add sub mul div floordiv mod lshift rshift and xor or pow "
inplace = ' '.join('i%s' % n for n in numerics.split())
right = ' '.join('r%s' % n for n in numerics.split())
extra = ''
if inPy3k:
    extra = 'bool next '
else:
    extra = 'unicode long nonzero oct hex truediv rtruediv '

# not including __prepare__, __instancecheck__, __subclasscheck__
# (as they are metaclass methods)
# __del__ is not supported at all as it causes problems if it exists

_non_defaults = set('__%s__' % method for method in [
    'cmp', 'getslice', 'setslice', 'coerce', 'subclasses',
    'format', 'get', 'set', 'delete', 'reversed',
    'missing', 'reduce', 'reduce_ex', 'getinitargs',
    'getnewargs', 'getstate', 'setstate', 'getformat',
    'setformat', 'repr', 'dir'
])


def _get_method(name, func):
    "Turns a callable object (like a mock) into a real function"
    def method(self, *args, **kw):
        return func(self, *args, **kw)
    method.__name__ = name
    return method


_magics = set(
    '__%s__' % method for method in
    ' '.join([magic_methods, numerics, inplace, right, extra]).split()
)

_all_magics = _magics | _non_defaults

_unsupported_magics = set([
    '__getattr__', '__setattr__',
    '__init__', '__new__', '__prepare__'
    '__instancecheck__', '__subclasscheck__',
    '__del__'
])

_calculate_return_value = {
    '__hash__': lambda self: object.__hash__(self),
    '__str__': lambda self: object.__str__(self),
    '__sizeof__': lambda self: object.__sizeof__(self),
    '__unicode__': lambda self: unicode(object.__str__(self)),
}

_side_effect_methods = {
    '__eq__': lambda self: lambda other: self is other,
    '__ne__': lambda self: lambda other: self is not other,
}

_return_values = {
    '__int__': 1,
    '__contains__': False,
    '__len__': 0,
    '__iter__': iter([]),
    '__exit__': False,
    '__complex__': 1j,
    '__float__': 1.0,
    '__bool__': True,
    '__nonzero__': True,
    '__oct__': '1',
    '__hex__': '0x1',
    '__long__': long(1),
    '__index__': 1,
}


def _get_eq(self):
    def __eq__(other):
        ret_val = self.__eq__._mock_return_value
        if ret_val is not DEFAULT:
            return ret_val
        return self is other
    return __eq__

def _get_ne(self):
    def __ne__(other):
        if self.__ne__._mock_return_value is not DEFAULT:
            return DEFAULT
        return self is not other
    return __ne__

_side_effect_methods = {
    '__eq__': _get_eq,
    '__ne__': _get_ne,
}



def _set_return_value(mock, method, name):
    return_value = DEFAULT
    if name in _return_values:
        return_value = _return_values[name]
    elif name in _calculate_return_value:
        try:
            return_value = _calculate_return_value[name](mock)
        except AttributeError:
            # XXXX why do we return AttributeError here?
            #      set it as a side_effect instead?
            return_value = AttributeError(name)
    elif name in _side_effect_methods:
        side_effect = _side_effect_methods[name](mock)
        method.side_effect = side_effect
    if return_value is not DEFAULT:
        method.return_value = return_value



class MagicMixin(object):
    def __init__(self, *args, **kw):
        _super(MagicMixin, self).__init__(*args, **kw)
        self._mock_set_magics()

    def _mock_set_magics(self):
        these_magics = _magics
        if self._mock_methods is not None:
            these_magics = _magics.intersection(self._mock_methods)

        remove_magics = _magics - these_magics

        for entry in remove_magics:
            if entry in type(self).__dict__:
                # remove unneeded magic methods
                delattr(self, entry)

        for entry in these_magics:
            if entry in type(self).__dict__:
                # don't overwrite existing attributes if called a second time
                continue
            setattr(self, entry, _create_proxy(entry, self))



class NonCallableMagicMock(MagicMixin, NonCallableMock):
    """A version of `MagicMock` that isn't callable."""
    def mock_add_spec(self, spec, spec_set=False):
        """Add a spec to a mock. `spec` can either be an object or a
        list of strings. Only attributes on the `spec` can be fetched as
        attributes from the mock.

        If `spec_set` is True then only attributes on the spec can be set."""
        self._mock_add_spec(spec, spec_set)
        self._mock_set_magics()



class MagicMock(MagicMixin, Mock):
    """
    MagicMock is a subclass of Mock with default implementations
    of most of the magic methods. You can use MagicMock without having to
    configure the magic methods yourself.

    If you use the `spec` or `spec_set` arguments then *only* magic
    methods that exist in the spec will be created.

    Attributes and the return value of a `MagicMock` will also be `MagicMocks`.
    """
    def mock_add_spec(self, spec, spec_set=False):
        """Add a spec to a mock. `spec` can either be an object or a
        list of strings. Only attributes on the `spec` can be fetched as
        attributes from the mock.

        If `spec_set` is True then only attributes on the spec can be set."""
        self._mock_add_spec(spec, spec_set)
        self._mock_set_magics()



def _create_proxy(entry, self):
    # could specify parent?
    def create_mock():
        m = MagicMock(name=entry, _new_name=entry, _new_parent=self)
        setattr(self, entry, m)
        _set_return_value(self, m, entry)
        return m
    return MagicProxy(create_mock)



class MagicProxy(object):
    def __init__(self, create_mock):
        self.create_mock = create_mock
    def __call__(self, *args, **kwargs):
        m = self.create_mock()
        return m(*args, **kwargs)
    def __get__(self, obj, _type=None):
        return self.create_mock()



class _ANY(object):
    "A helper object that compares equal to everything."

    def __eq__(self, other):
        return True

    def __repr__(self):
        return '<ANY>'

ANY = _ANY()



def _format_call_signature(name, args, kwargs):
    message = '%s(%%s)' % name
    formatted_args = ''
    args_string = ', '.join([repr(arg) for arg in args])
    kwargs_string = ', '.join([
        '%s=%r' % (key, value) for key, value in kwargs.items()
    ])
    if args_string:
        formatted_args = args_string
    if kwargs_string:
        if formatted_args:
            formatted_args += ', '
        formatted_args += kwargs_string

    return message % formatted_args



class _Call(tuple):
    """
    A tuple for holding the results of a call to a mock, either in the form
    `(args, kwargs)` or `(name, args, kwargs)`.

    If args or kwargs are empty then a call tuple will compare equal to
    a tuple without those values. This makes comparisons less verbose::

        _Call(('name', (), {})) == ('name',)
        _Call(('name', (1,), {})) == ('name', (1,))
        _Call(((), {'a': 'b'})) == ({'a': 'b'},)

    The `_Call` object provides a useful shortcut for comparing with call::

        _Call(((1, 2), {'a': 3})) == call(1, 2, a=3)
        _Call(('foo', (1, 2), {'a': 3})) == call.foo(1, 2, a=3)

    If the _Call has no name then it will match any name.
    """
    def __new__(cls, value=(), name=None, parent=None, two=False,
                from_kall=True):
        name = ''
        args = ()
        kwargs = {}
        if len(value) == 3:
            name, args, kwargs = value
        elif len(value) == 2:
            first, second = value
            if isinstance(first, basestring):
                name = first
                if isinstance(second, tuple):
                    args = second
                else:
                    kwargs = second
            else:
                args, kwargs = first, second
        elif len(value) == 1:
            value, = value
            if isinstance(value, basestring):
                name = value
            elif isinstance(value, tuple):
                args = value
            else:
                kwargs = value

        if two:
            return tuple.__new__(cls, (args, kwargs))

        return tuple.__new__(cls, (name, args, kwargs))


    def __init__(self, value=(), name=None, parent=None, two=False,
                 from_kall=True):
        self.name = name
        self.parent = parent
        self.from_kall = from_kall


    def __eq__(self, other):
        try:
            len(other)
        except TypeError:
            return False

        self_name = ''
        if len(self) == 2:
            self_args, self_kwargs = self
        else:
            self_name, self_args, self_kwargs = self

        other_name = ''
        if len(other) == 0:
            other_args, other_kwargs = (), {}
        elif len(other) == 3:
            other_name, other_args, other_kwargs = other
        elif len(other) == 1:
            value, = other
            if isinstance(value, tuple):
                other_args = value
                other_kwargs = {}
            elif isinstance(value, basestring):
                other_name = value
                other_args, other_kwargs = (), {}
            else:
                other_args = ()
                other_kwargs = value
        else:
            # len 2
            # could be (name, args) or (name, kwargs) or (args, kwargs)
            first, second = other
            if isinstance(first, basestring):
                other_name = first
                if isinstance(second, tuple):
                    other_args, other_kwargs = second, {}
                else:
                    other_args, other_kwargs = (), second
            else:
                other_args, other_kwargs = first, second

        if self_name and other_name != self_name:
            return False
        return (self_args, self_kwargs) == (other_args, other_kwargs)


    def __ne__(self, other):
        return not self.__eq__(other)


    def __call__(self, *args, **kwargs):
        if self.name is None:
            return _Call(('', args, kwargs), name='()')

        name = self.name + '()'
        return _Call((self.name, args, kwargs), name=name, parent=self)


    def __getattr__(self, attr):
        if self.name is None:
            return _Call(name=attr, from_kall=False)
        name = '%s.%s' % (self.name, attr)
        return _Call(name=name, parent=self, from_kall=False)


    def __repr__(self):
        if not self.from_kall:
            name = self.name or 'call'
            if name.startswith('()'):
                name = 'call%s' % name
            return name

        if len(self) == 2:
            name = 'call'
            args, kwargs = self
        else:
            name, args, kwargs = self
            if not name:
                name = 'call'
            elif not name.startswith('()'):
                name = 'call.%s' % name
            else:
                name = 'call%s' % name
        return _format_call_signature(name, args, kwargs)


    def call_list(self):
        """For a call object that represents multiple calls, `call_list`
        returns a list of all the intermediate calls as well as the
        final call."""
        vals = []
        thing = self
        while thing is not None:
            if thing.from_kall:
                vals.append(thing)
            thing = thing.parent
        return _CallList(reversed(vals))


call = _Call(from_kall=False)



def create_autospec(spec, spec_set=False, instance=False,
                    configure=None, _parent=None, _name=None):
    """Create a mock object using another object as a spec. Attributes on the
    mock will use the corresponding attribute on the `spec` object as their
    spec.

    Functions or methods being mocked will have their arguments checked in a
    similar way to `mocksignature` to check that they are called with the
    correct signature.

    If `spec_set` is True then attempting to set attributes that don't exist
    on the spec object will raise an `AttributeError`.

    If a class is used as a spec then the return value of the mock (the
    instance of the class) will have the same spec. You can use a class as the
    spec for an instance object by passing `instance=True`. The returned mock
    will only be callable if instances of the mock are callable.

    `configure` is a dictionary that will be used as keyword arguments for the
    created mock."""
    if configure is None:
        configure = {}

    if _is_list(spec):
        # can't pass a list instance to the mock constructor as it will be
        # interpreted as a list of strings
        spec = type(spec)

    is_type = isinstance(spec, ClassTypes)

    kwargs = {'spec': spec}
    if spec_set:
        kwargs = {'spec_set': spec}
    elif spec is None:
        # None we mock with a normal mock without a spec
        kwargs = {}

    kwargs.update(configure)

    Klass = MagicMock
    if type(spec) in DescriptorTypes:
        # descriptors don't have a spec
        # because we don't know what type they return
        kwargs = {}
    elif not _callable(spec):
        Klass = NonCallableMagicMock
    elif is_type and instance and not _instance_callable(spec):
        Klass = NonCallableMagicMock

    _new_name = _name
    if _parent is None:
        # for a top level object no _new_name should be set
        _new_name = ''

    mock = Klass(parent=_parent, _new_parent=_parent, _new_name=_new_name,
                 name=_name, **kwargs)

    if isinstance(spec, FunctionTypes):
        # should only happen at the top level because we don't
        # recurse for functions
        mock = _set_signature(mock, spec)
    else:
        _check_signature(spec, mock, is_type)

    if _parent is not None and not instance:
        _parent._mock_children[_name] = mock

    if is_type and not instance:
        # XXXX could give a name to the return_value mock?
        mock.return_value = create_autospec(spec, spec_set, instance=True,
                                            _name='()', _parent=mock)

    for entry in dir(spec):
        if _is_magic(entry):
            # MagicMock already does the useful magic methods for us
            continue

        if isinstance(spec, FunctionTypes) and entry in FunctionAttributes:
            # allow a mock to actually be a function from mocksignature
            continue

        # XXXX do we need a better way of getting attributes
        # without triggering code execution (?) Probably not - we need the
        # actual object to mock it so we would rather trigger a property than
        # mock the property descriptor. Likewise we want to mock out
        # dynamically provided attributes.
        # XXXX what about attributes that raise exceptions on being fetched
        # we could be resilient against it, or catch and propagate the exception
        # when the attribute is fetched from the mock
        original = getattr(spec, entry)

        kwargs = {'spec': original}
        if spec_set:
            kwargs = {'spec_set': original}

        if not isinstance(original, FunctionTypes):
            new = _SpecState(original, spec_set, mock, entry, instance)
            mock._mock_children[entry] = new
        else:
            parent = mock
            if isinstance(spec, FunctionTypes):
                parent = mock.mock

            new = MagicMock(parent=parent, name=entry, _new_name=entry,
                            _new_parent=parent, **kwargs)
            mock._mock_children[entry] = new
            skipfirst = _must_skip(spec, entry, is_type)
            _check_signature(original, new, skipfirst=skipfirst)

        # so functions created with mocksignature become instance attributes,
        # *plus* their underlying mock exists in _mock_children of the parent
        # mock. Adding to _mock_children may be unnecessary where we are also
        # setting as an instance attribute?
        if isinstance(new, FunctionTypes):
            setattr(mock, entry, new)

    return mock


def _must_skip(spec, entry, skipfirst):
    if not isinstance(spec, ClassTypes):
        if entry in getattr(spec, '__dict__', {}):
            # instance attribute - shouldn't skip
            return False
        # can't use type because of old style classes
        spec = spec.__class__
    if not hasattr(spec, '__mro__'):
        # old style class: can't have descriptors anyway
        return skipfirst

    for klass in spec.__mro__:
        result = klass.__dict__.get(entry, DEFAULT)
        if result is DEFAULT:
            continue
        if isinstance(result, (staticmethod, classmethod)):
            return False
        return skipfirst

    # shouldn't get here unless attribute dynamically provided
    return skipfirst


def _get_class(obj):
    try:
        return obj.__class__
    except AttributeError:
        # in Python 2, _sre.SRE_Pattern objects have no __class__
        return type(obj)


class _SpecState(object):

    def __init__(self, spec, spec_set=False, parent=None,
                 name=None, ids=None, instance=False):
        self.spec = spec
        self.ids = ids
        self.spec_set = spec_set
        self.parent = parent
        self.instance = instance
        self.name = name


FunctionTypes = (
    # python function
    type(create_autospec),
    # instance method
    type(ANY.__eq__),
    # unbound method
    type(_ANY.__eq__),
)

FunctionAttributes = set([
    'func_closure',
    'func_code',
    'func_defaults',
    'func_dict',
    'func_doc',
    'func_globals',
    'func_name',
])

########NEW FILE########
__FILENAME__ = MockYouTubeDepends
import sys
import time
import inspect


class MockYouTubeDepends:
    common = ""

    def mock(self):
        from mock import Mock
        sys.path.append(u"../plugin/")

        #Setup default test various values
        sys.modules[u"__main__"].plugin = u"YouTube - Unittest"
        sys.modules[u"__main__"].dbg = True
        try:
            plat = platform.uname()
        except:
            plat = ('', '', '', '', '', '')

        if plat[0] == u"FreeBSD" and False:
            sys.modules[u"__main__"].dbglevel = 5
        else:
            sys.modules[u"__main__"].dbglevel = 3

        sys.modules[u"__main__"].login = ""
        sys.modules[u"__main__"].language = Mock()
        sys.modules[u"__main__"].opener = Mock()
        sys.modules[u"__main__"].cookiejar = Mock()

        import YouTubeUtils
        sys.modules[u"__main__"].utils = Mock(spec=YouTubeUtils.YouTubeUtils)
        sys.modules[u"__main__"].utils.INVALID_CHARS = u"\\/:*?\"<>|"

        sys.modules[u"__main__"].common = Mock()
        sys.modules[u"__main__"].common.log.side_effect = self.log
        sys.modules[u"__main__"].common.USERAGENT = u"Mozilla/5.0 (MOCK)"

        sys.modules[u"__main__"].cache = Mock()

        import YouTubeStorage
        sys.modules[u"__main__"].storage = Mock(spec=YouTubeStorage.YouTubeStorage)
        import YouTubePluginSettings
        sys.modules[u"__main__"].pluginsettings = Mock(spec=YouTubePluginSettings.YouTubePluginSettings)
        import YouTubeCore
        sys.modules[u"__main__"].core = Mock(spec=YouTubeCore.YouTubeCore)
        import YouTubeLogin
        sys.modules[u"__main__"].login = Mock(spec=YouTubeLogin.YouTubeLogin)
        import YouTubeFeeds
        sys.modules[u"__main__"].feeds = Mock(spec=YouTubeFeeds.YouTubeFeeds)
        import YouTubeSubtitleControl
        sys.modules[u"__main__"].subtitles = Mock(spec=YouTubeSubtitleControl.YouTubeSubtitleControl)
        import YouTubePlayer
        sys.modules[u"__main__"].player = Mock(spec=YouTubePlayer.YouTubePlayer)
        sys.modules[u"__main__"].downloader = Mock()
        import YouTubeScraper
        sys.modules[u"__main__"].scraper = Mock(spec=YouTubeScraper.YouTubeScraper)
        import YouTubePlaylistControl
        sys.modules[u"__main__"].playlist = Mock(spec=YouTubePlaylistControl.YouTubePlaylistControl)
        import YouTubeNavigation
        sys.modules[u"__main__"].navigation = Mock(spec=YouTubeNavigation.YouTubeNavigation)

    def mockXBMC(self):
        from mock import Mock
        sys.path.append(u"../xbmc-mocks/")
        import xbmc
        import xbmcaddon
        import xbmcgui
        import xbmcplugin
        import xbmcvfs

        #Setup basic xbmc dependencies
        sys.modules[u"__main__"].xbmc = Mock(spec=xbmc)
        sys.modules[u"__main__"].xbmc.translatePath = Mock()
        sys.modules[u"__main__"].xbmc.translatePath.return_value = u"testing"
        sys.modules[u"__main__"].xbmc.getSkinDir = Mock()
        sys.modules[u"__main__"].xbmc.getSkinDir.return_value = u"testSkinPath"
        sys.modules[u"__main__"].xbmc.getInfoLabel.return_value = u"some_info_label"
        sys.modules[u"__main__"].xbmcaddon = Mock(spec=xbmcaddon)
        sys.modules[u"__main__"].xbmcgui = Mock(spec=xbmcgui)
        sys.modules[u"__main__"].xbmcgui.WindowXMLDialog.return_value = u"testWindowXML"

        sys.modules[u"__main__"].xbmcplugin = Mock(spec=xbmcplugin)
        sys.modules[u"__main__"].xbmcvfs = Mock(spec=xbmcvfs)
        sys.modules[u"__main__"].settings = Mock(spec=xbmcaddon.Addon())
        sys.modules[u"__main__"].settings.getAddonInfo.return_value = u"somepath"

        sys.modules[u"DialogDownloadProgress"] = __import__(u"mock")
        sys.modules[u"DialogDownloadProgress"].DownloadProgress = Mock()

    def log(self, description, level=0):
        if sys.modules[u"__main__"].dbg and sys.modules[u"__main__"].dbglevel > level:
            try:
                print u"%s [%s] %s : '%s'" % (time.strftime(u"%H:%M:%S"), u"YouTube IntegrationTest", inspect.stack()[3][3], description.decode(u"utf-8", u"ignore"))
            except:
                print u"%s [%s] %s : '%s'" % (time.strftime(u"%H:%M:%S"), u"YouTube IntegrationTest", inspect.stack()[3][3], description)

########NEW FILE########
__FILENAME__ = Testxbmcvfsdummy
# -*- coding: utf-8 -*-
import nose
import BaseTestCase
from mock import patch


class Testxbmcvfsdummy(BaseTestCase.BaseTestCase):
    def test_exists_should_call_os_path_exists(self):
        import xbmcvfsdummy as xbmcvfs
        patcher = patch("os.path")
        patcher.start()

        import os
        os.path.exists.return_value = "my_result"

        result = xbmcvfs.exists("someFile")
        args = os.path.exists.call_args_list

        patcher.stop()

        print repr(args)
        assert(args[0][0][0] == "someFile")
        assert(result == "my_result")

    def test_rename_should_call_os_path_rename(self):
        import xbmcvfsdummy as xbmcvfs
        patcher = patch("os.rename")
        patcher.start()

        import os
        os.rename.return_value = "my_result"

        result = xbmcvfs.rename("someFile", "someOtherFile")

        args = os.rename.call_args_list
        patcher.stop()
        print repr(args)	
        assert(args[0][0][0] == "someFile")
        assert(args[0][0][1] == "someOtherFile")
        assert(result == "my_result")

    def test_delete_file_should_return_false_if_path_is_directory(self):
        import xbmcvfsdummy as xbmcvfs
        patcher = patch("os.path")
        patcher.start()
        import os
        os.path.isfile.return_value = False
        
        result = xbmcvfs.delete("someFile")
        
        args = os.path.isfile.call_args_list
        patcher.stop()
        print repr(args)
        assert(args[0][0][0] == "someFile")
        assert(result == False)

    def test_delete_file_should_call_os_unlink(self):
        import xbmcvfsdummy as xbmcvfs

        patcher = patch("os.path")
        patcher.start()
        patcher2 = patch("os.unlink")
        patcher2.start()
        import os
        os.path.isfile.return_value = True
        os.path.isdir.return_value = False
        os.unlink.return_value = "my_result"

        result = xbmcvfs.delete("someFile")
        
        args = os.path.isfile.call_args_list
        args2 = os.unlink.call_args_list
        patcher.stop()
        patcher2.stop()
        print repr(xbmcvfs)
        print repr(result)
        assert(result == "my_result")
	
if __name__ == '__main__':
	nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubeCore
import nose
import BaseTestCase
from mock import Mock, patch
import sys
import time
from YouTubeCore import YouTubeCore

class TestYouTubeCore(BaseTestCase.BaseTestCase):

    def setUp(self):
        super(self.__class__,self).setUp()
        sys.modules[ "__main__" ].settings.getSetting.side_effect = ["3","4", "my_auth"]
        sys.modules[ "__main__" ].storage.retrieve.return_value = "some_thumbnail"
        sys.modules[ "__main__" ].language.return_value = "error_message"
        sys.modules[ "__main__" ].common.parseDOM.return_value = []
        sys.modules[ "__main__" ].common.replaceHTMLCodes.return_value = "SomeHTMLFreeString"
        sys.modules[ "__main__" ].common.makeUTF8.return_value = "SomeUTF8EncodedString"

    def test_delete_favorite_should_call_fetchPage_with_correct_fetch_options(self):
        core = YouTubeCore()
        core._fetchPage = Mock()
        core._fetchPage.return_value = {"content":"success", "status":200}
        delete_url = "http://gdata.youtube.com/feeds/api/users/default/favorites/test"

        core.delete_favorite({ "editid": "test" })

        assert(core._fetchPage.called)
        assert(core._fetchPage.call_count == 1)
        core._fetchPage.assert_called_with({"link": delete_url, "api": "true", "login": "true", "auth": "true", "method": "DELETE"})

    def test_remove_contact_should_call_fetchPage_with_correct_fetch_options(self):
        core = YouTubeCore()
        core._fetchPage = Mock()
        core._fetchPage.return_value = {"content":"success", "status":200}
        delete_url = "http://gdata.youtube.com/feeds/api/users/default/contacts/come_contact"

        core.remove_contact({ "contact": "come_contact" })

        assert(core._fetchPage.called)
        assert(core._fetchPage.call_count == 1)
        core._fetchPage.assert_called_with({"link": delete_url, "api": "true", "login": "true", "auth": "true", "method": "DELETE"})

    def test_remove_subscription_should_call_fetchPage_with_correct_fetch_options(self):
        core = YouTubeCore()
        core._fetchPage = Mock()
        core._fetchPage.return_value = {"content":"success", "status":200}
        delete_url = "http://gdata.youtube.com/feeds/api/users/default/subscriptions/edit_id"

        core.remove_subscription({ "editid": "edit_id" })

        assert(core._fetchPage.called)
        assert(core._fetchPage.call_count == 1)
        core._fetchPage.assert_called_with({"link": delete_url, "api": "true", "login": "true", "auth": "true", "method": "DELETE"})

    def test_add_contact_should_call_fetchPage_with_correct_fetch_options(self):
        core = YouTubeCore()
        core._fetchPage = Mock()
        core._fetchPage.return_value = {"content":"success", "status":200}
        delete_url = "http://gdata.youtube.com/feeds/api/users/default/contacts"
        request = '<?xml version="1.0" encoding="UTF-8"?> <entry xmlns="http://www.w3.org/2005/Atom" xmlns:yt="http://gdata.youtube.com/schemas/2007"><yt:username>some_contact</yt:username></entry>'

        core.add_contact({ "editid": "edit_id", "contact":"some_contact" })

        assert(core._fetchPage.called)
        assert(core._fetchPage.call_count == 1)
        core._fetchPage.assert_called_with({"request":request,"link": delete_url, "api": "true", "login": "true", "auth": "true"})

    def test_add_favorite_should_call_fetchPage_with_correct_fetch_options(self):
        core = YouTubeCore()
        core._fetchPage = Mock()
        core._fetchPage.return_value = {"content":"success", "status":200}
        url = "http://gdata.youtube.com/feeds/api/users/default/favorites"
        request = '<?xml version="1.0" encoding="UTF-8"?><entry xmlns="http://www.w3.org/2005/Atom"><id>some_id</id></entry>'

        core.add_favorite({ "editid": "edit_id", "videoid":"some_id" })

        assert(core._fetchPage.called)
        assert(core._fetchPage.call_count == 1)
        core._fetchPage.assert_called_with({"request":request,"link": url, "api": "true", "login": "true", "auth": "true"})

    def test_add_subscription_should_call_fetchPage_with_correct_fetch_options(self):
        core = YouTubeCore()
        core._fetchPage = Mock()
        core._fetchPage.return_value = {"content":"success", "status":200}
        url = "http://gdata.youtube.com/feeds/api/users/default/subscriptions"
        request = '<?xml version="1.0" encoding="UTF-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:yt="http://gdata.youtube.com/schemas/2007"> <category scheme="http://gdata.youtube.com/schemas/2007/subscriptiontypes.cat" term="user"/><yt:username>channel</yt:username></entry>'

        core.add_subscription({ "channel": "channel"})

        assert(core._fetchPage.called)
        assert(core._fetchPage.call_count == 1)
        core._fetchPage.assert_called_with({"request":request,"link": url, "api": "true", "login": "true", "auth": "true"})

    def test_add_playlist_should_call_fetchPage_with_correct_fetch_options(self):
        core = YouTubeCore()
        core._fetchPage = Mock()
        core._fetchPage.return_value = {"content":"success", "status":200}
        url = "http://gdata.youtube.com/feeds/api/users/default/playlists"
        request = '<?xml version="1.0" encoding="UTF-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:yt="http://gdata.youtube.com/schemas/2007"><title type="text">some_title</title><summary>some_summary</summary></entry>'

        core.add_playlist({ "title": "some_title", "summary":"some_summary"})

        assert(core._fetchPage.called)
        assert(core._fetchPage.call_count == 1)
        core._fetchPage.assert_called_with({"request":request,"link": url, "api": "true", "login": "true", "auth": "true"})

    def test_del_playlist_should_call_fetchPage_with_correct_fetch_options(self):
        core = YouTubeCore()
        core._fetchPage = Mock()
        core._fetchPage.return_value = {"content":"success", "status":200}
        url = "http://gdata.youtube.com/feeds/api/users/default/playlists/some_playlist"

        core.del_playlist({ "playlist": "some_playlist"})

        assert(core._fetchPage.called)
        assert(core._fetchPage.call_count == 1)
        core._fetchPage.assert_called_with({"link": url, "api": "true", "login": "true", "auth": "true","method":"DELETE"})

    def test_add_to_playlist_should_call_fetchPage_with_correct_fetch_options(self):
        core = YouTubeCore()
        core._fetchPage = Mock()
        core._fetchPage.return_value = {"content":"success", "status":200}
        url = "http://gdata.youtube.com/feeds/api/playlists/some_playlist"
        request = '<?xml version="1.0" encoding="UTF-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:yt="http://gdata.youtube.com/schemas/2007"><id>some_id</id></entry>'

        core.add_to_playlist({ "playlist": "some_playlist","videoid":"some_id"})

        assert(core._fetchPage.called)
        assert(core._fetchPage.call_count == 1)
        core._fetchPage.assert_called_with({"request":request,"link": url, "api": "true", "login": "true", "auth": "true"})

    def test_remove_from_playlist_should_call_fetchPage_with_correct_fetch_options(self):
        core = YouTubeCore()
        core._fetchPage = Mock()
        core._fetchPage.return_value = {"content":"success", "status":200}
        url = "http://gdata.youtube.com/feeds/api/playlists/some_playlist/some_entry_id"

        core.remove_from_playlist({ "playlist": "some_playlist","playlist_entry_id":"some_entry_id"})

        assert(core._fetchPage.called)
        assert(core._fetchPage.call_count == 1)
        core._fetchPage.assert_called_with({"link": url, "api": "true", "login": "true", "auth": "true","method":"DELETE"})

    def test_remove_from_watch_later_should_call_fetchPage_with_correct_fetch_options(self):
        core = YouTubeCore()
        core._fetchPage = Mock()
        core._fetchPage.return_value = {"content":"success", "status":200}
        url = "https://gdata.youtube.com/feeds/api/users/default/watch_later/some_entry_id"

        core.remove_from_watch_later({ "playlist": "some_playlist","playlist_entry_id":"some_entry_id"})

        assert(core._fetchPage.called)
        assert(core._fetchPage.call_count == 1)
        core._fetchPage.assert_called_with({"link": url, "api": "true", "login": "true", "auth": "true","method":"DELETE"})


    def test_getCategoriesFolderInfo_should_set_item_params_correctly_for_contacts_feed(self):
        input = self.readTestInput("categories-test.xml", False)
        core = YouTubeCore()
        sys.modules["__main__"].common.parseDOM.side_effect = [["entries"], ["Film & Animation"], ["Film"]]
        sys.modules["__main__"].common.replaceHTMLCodes.side_effect = ["Film & Animation", "Film"]

        result = core.getCategoriesFolderInfo(input, {"feed":"feed_categories"})

        print repr(result[0])
        assert(len(result) > 0)
        assert(result[0]["thumbnail"] == "explore")
        assert(result[0]["Title"] == "Film & Animation")
        assert(result[0]["category"] == "Film")

    def test_getCategoriesFolderInfo_should_use_parseDOM_to_look_for_categories(self):
        core = YouTubeCore()
        sys.modules["__main__"].common.parseDOM.side_effect = [["entries"], ["label"], ["term"]]

        core.getCategoriesFolderInfo("xml", {})

        sys.modules["__main__"].common.parseDOM.assert_any_call('entries', 'atom:category', ret="label")

    def test_getCategoriesFolderInfo_should_skip_deprecated_categories(self):
        sys.modules["__main__"].common.parseDOM.side_effect = [["yt:deprecated"], ["label"], ["term"]]
        core = YouTubeCore()

        result = core.getCategoriesFolderInfo("xml", {})

        assert(len(result) == 0)

    def test_getFolderInfo_should_use_getElementsByTagName_to_look_for_link_and_entries(self):
        sys.modules["__main__"].common.parseDOM.side_effect = [["entry"], [""], ["title"], ["published"], ["id"]]
        core = YouTubeCore()

        core.getFolderInfo("xml", {})

        calls = sys.modules["__main__"].common.parseDOM.call_args_list
        print repr(calls)

        assert(calls[0][0][1] == "entry")
        assert(calls[1][0][1] == "link")

    def test_getFolderInfo_should_search_links_relation_attribute_for_multiple_pages(self):
        sys.modules["__main__"].common.parseDOM.side_effect = [["entry"], ["next"], ["title"], ["published"], ["id"]]
        sys.modules["__main__"].common.parseDOM.side_effect = [[], ["next"]]
        core = YouTubeCore()

        core.getFolderInfo("xml", {})

        sys.modules["__main__"].utils.addNextFolder.assert_called_with([], {})

    def test_getFolderInfo_should_find_edit_id_in_xml_structure_if_id_tag_is_present(self):
        input = self.readTestInput("getFolderInfoPlaylistTest.xml", False)
        sys.modules["__main__"].common.parseDOM.side_effect = [["entry"], [], ["title"], ["published"], ["some_playlist_id"]]
        core = YouTubeCore()

        result = core.getFolderInfo(input, {})

        assert(result[0]["editid"] == "some_playlist_id")


    def test_getFolderInfo_should_set_item_params_correctly_for_contacts_feed(self):
        input = self.readTestInput("getFolderInfoContactTest.xml", False)
        sys.modules["__main__"].common.parseDOM.side_effect = [["entry"], [], ["some_other_user"], ["published"], ["some_other_user"],["some_other_user"]]
        core = YouTubeCore()

        result = core.getFolderInfo(input, {"user_feed":"contacts"})

        assert(result[0]["editid"] == "some_other_user")
        assert(result[0]["thumbnail"] == "some_thumbnail")
        assert(result[0]["login"] == "true")
        assert(result[0]["contact"] == "some_other_user")
        assert(result[0]["store"] == "contact_options")
        assert(result[0]["Title"] == "some_other_user")
        assert(result[0]["folder"] == "true")

    def test_getFolderInfo_should_set_item_params_correctly_for_subscriptions_feed(self):
        input = self.readTestInput("getFolderInfoSubscriptionsTest.xml", False)
        sys.modules["__main__"].common.parseDOM.side_effect = [["entry"], [], ["GoogleTechTalks"], ["published"], ["some_edit_id"], ["GoogleTechTalks"]]
        core = YouTubeCore()

        result = core.getFolderInfo(input, {"user_feed":"subscriptions"})
        print repr(result)
        assert(result[0]["editid"] == "some_edit_id")
        assert(result[0]["thumbnail"] == "some_thumbnail")
        assert(result[0]["login"] == "true")
        assert(result[0]["channel"] == "GoogleTechTalks")
        assert(result[0]["Title"] == "GoogleTechTalks")

    def test_getFolderInfo_should_set_item_params_correctly_for_playlist_feed(self):
        input = self.readTestInput("getFolderInfoPlaylistTest.xml", False)
        sys.modules["__main__"].common.parseDOM.side_effect = [["entry"], [], ["Stand back I'm going to try Science!"], ["published"], ["some_playlist_id"], ["some_playlist_id"]]
        core = YouTubeCore()

        result = core.getFolderInfo(input, {"user_feed":"playlists"})

        assert(result[0]["editid"] == "some_playlist_id")
        assert(result[0]["thumbnail"] == "some_thumbnail")
        assert(result[0]["login"] == "true")
        assert(result[0]["playlist"] == "some_playlist_id")
        assert(result[0]["user_feed"] == "playlist")
        assert(result[0]["Title"] == "Stand back I'm going to try Science!")

    def test_getFolderInfo_should_call_storage_retrieve_to_find_thumbnail(self):
        input = self.readTestInput("getFolderInfoPlaylistTest.xml", False)
        sys.modules["__main__"].common.parseDOM.side_effect = [["entry"], [], ["Stand back I'm going to try Science!"], ["published"], ["some_playlist_id"], ["some_playlist_id"]]
        core = YouTubeCore()

        result = core.getFolderInfo(input, {})

        assert(sys.modules["__main__"].storage.retrieve.call_count == 1)

    def test_getFolderInfo_should_call_utils_addNextFolder_to_set_default_next_folder_on_feed(self):
        sys.modules["__main__"].common.parseDOM.side_effect = [[], ["next"]]
        core = YouTubeCore()

        core.getFolderInfo("xml", {})

        sys.modules["__main__"].utils.addNextFolder.assert_called_with([], {})

    def test_getBatchDetailsOverride_should_call_getBatchDetails_with_list_of_video_ids(self):
        core = YouTubeCore()
        core.getBatchDetails = Mock()
        core.getBatchDetails.return_value = ([{"videoid":"some_id3"},{"videoid":"some_id2"},{"videoid":"some_id1"}], 200)
        items = [{"videoid":"some_id1","some_key1":"value1"},{"videoid":"some_id2","some_key2":"value2"}, {"videoid":"some_id3","some_key3":"value3"}]

        (result, status) = core.getBatchDetailsOverride(items, params={})

        core.getBatchDetails.assert_called_with(['some_id1', 'some_id2', 'some_id3'], {})

    def test_getBatchDetailsOverride_should_override_specified_properties_in_output_from_getBatchDetails(self):
        core = YouTubeCore()
        core.getBatchDetails = Mock()
        core.getBatchDetails.return_value = ([{"videoid":"some_id3","some_key3":"blabla"},{"videoid":"some_id2","some_key2":"blabla"},{"videoid":"some_id1","some_key1":"blabla"}], 200)
        items = [{"videoid":"some_id1","some_key1":"value1"},{"videoid":"some_id2","some_key2":"value2"}, {"videoid":"some_id3","some_key3":"value3"}]

        (result, status) = core.getBatchDetailsOverride(items, params={})

        assert(result[0]["some_key3"] == "value3")
        assert(result[1]["some_key2"] == "value2")
        assert(result[2]["some_key1"] == "value1")

    def test_getBatchDetailsThumbnails_should_call_getBatchDetails_with_list_of_video_ids(self):
        core = YouTubeCore()
        core.getBatchDetails = Mock()
        core.getBatchDetails.return_value = ([{"videoid":"some_id3","some_key3":"blabla"},{"videoid":"some_id2","some_key2":"blabla"},{"videoid":"some_id1","some_key1":"blabla"}], 200)
        items = [("some_id3","some_thumb3"),("some_id2","some_thumb2"),("some_id1","some_thumb1")]

        (result, status) = core.getBatchDetailsThumbnails(items, params={})

        core.getBatchDetails.assert_called_with(['some_id3', 'some_id2', 'some_id1'], {})

    def test_getBatchDetailsThumbnails_should_override_thumbnails_in_output_from_getBatchDetails(self):
        core = YouTubeCore()
        core.getBatchDetails = Mock()
        core.getBatchDetails.return_value = ([{"videoid":"some_id3","some_key3":"blabla"},{"videoid":"some_id2","some_key2":"blabla"},{"videoid":"some_id1","some_key1":"blabla"}], 200)
        items = [("some_id3","some_thumb3"),("some_id2","some_thumb2"),("some_id1","some_thumb1")]

        (result, status) = core.getBatchDetailsThumbnails(items, params={})

        assert(result[0]["thumbnail"] == "some_thumb3")
        assert(result[1]["thumbnail"] == "some_thumb2")
        assert(result[2]["thumbnail"] == "some_thumb1")

    def test_getBatchDetailsThumbnails_should_fill_out_missing_videos_in_collection_from_getBatchDetails_to_maintain_collection_size(self):
        core = YouTubeCore()
        core.getBatchDetails = Mock()
        core.getBatchDetails.return_value = ([{"videoid":"some_id3","some_key3":"blabla"},{"videoid":"some_id2","some_key2":"blabla"}], 200)
        items = [("some_id3","some_thumb3"),("some_id2","some_thumb2"),("some_id1","some_thumb1")]

        (result, status) = core.getBatchDetailsThumbnails(items, params={})

        assert(result[0]["thumbnail"] == "some_thumb3")
        assert(result[1]["thumbnail"] == "some_thumb2")
        assert(result[2]["videoid"] == "false")

    def test_getBatchDetailsOverride_should_fill_out_missing_videos_in_collection_from_getBatchDetails_to_maintain_collection_size(self):
        core = YouTubeCore()
        core.getBatchDetails = Mock()
        core.getBatchDetails.return_value = ([{"videoid":"some_id3","some_key3":"blabla"},{"videoid":"some_id2","some_key2":"blabla"}], 200)
        items = [{"videoid":"some_id1","some_key1":"value1"},{"videoid":"some_id2","some_key2":"value2"}, {"videoid":"some_id3","some_key3":"value3"}]

        (result, status) = core.getBatchDetailsOverride(items, params={})

        assert(result[0]["some_key3"] == "value3")
        assert(result[1]["some_key2"] == "value2")
        assert(result[2]["videoid"] == "false")

    def test_getBatchDetails_should_call_cache_getMulti_before_hitting_youtube(self):
        core = YouTubeCore()
        core._fetchPage = Mock()

        core.getBatchDetails([],{})

        sys.modules["__main__"].cache.getMulti.assert_called_with('videoidcache', [])

    def test_getBatchDetails_should_not_request_video_information_for_cached_videos(self):
        core = YouTubeCore()
        core._fetchPage = Mock()
        core.getVideoInfo = Mock()
        core.getVideoInfo.return_value = []
        core._fetchPage.return_value = {"content":"","status":303}
        sys.modules["__main__"].cache.getMulti.return_value = ['{"videoid":"some_id_1"}',"","","",'{"videoid":"some_id_5"}']

        core.getBatchDetails(["some_id_1","some_id_2","some_id_3","some_id_4","some_id_5"],{})

        request = core._fetchPage.call_args_list[0][0][0]["request"]
        assert(request.find("some_id_1") < 0)
        assert(request.find("some_id_5") < 0)

    def test_getBatchDetails_should_at_most_request_50_videos_in_one_call(self):
        core = YouTubeCore()
        core._fetchPage = Mock()
        core.getVideoInfo = Mock()
        core.getVideoInfo.return_value = []
        core._fetchPage.return_value = {"content":"","status":303}
        sys.modules["__main__"].cache.getMulti.return_value = []
        sys.modules["__main__"].common.parseDOM.return_value = ""
        ids = []
        i= 1
        while i < 52:
            ids.append("some_id_"  + str(i))
            i += 1

        core.getBatchDetails(ids,{})

        request = core._fetchPage.call_args_list[0][0][0]["request"]
        assert(request.find("some_id_52") < 0)
        assert(request.find("some_id_1") > 0)
        assert(request.find("some_id_50") > 0)

    def test_getBatchDetails_should_search_result_for_response_status_code(self):
        core = YouTubeCore()
        core._fetchPage = Mock()
        core._fetchPage.return_value = {"content":"","status":303}
        core.getVideoInfo = Mock()
        core.getVideoInfo.return_value = []
        sys.modules["__main__"].cache.getMulti.return_value = []
        sys.modules["__main__"].common.parseDOM.return_value = ""
        ids = []
        i= 1
        while i < 52:
            ids.append("some_id_"  + str(i))
            i += 1

        core.getBatchDetails(ids,{})

        sys.modules["__main__"].common.parseDOM.assert_called_with("","batch:status",ret="code")

    def test_getBatchDetails_should_sleep_for_5_seconds_if_youtube_returns_error(self):
        patcher = patch("time.sleep")
        patcher.start()
        import time
        time.sleep = Mock()
        core = YouTubeCore()
        core._fetchPage = Mock()
        core.getVideoInfo = Mock()
        core.getVideoInfo.return_value = []
        core._fetchPage.return_value = {"content":"","status":303}
        sys.modules["__main__"].cache.getMulti.return_value = []
        status = [[],["","403"]]
        sys.modules["__main__"].common.parseDOM.side_effect = lambda x = "", y ="",attrs = {},ret = {}: status.pop()
        ids = []
        i= 1
        while i < 52:
            ids.append("some_id_"  + str(i))
            i += 1

        core.getBatchDetails(ids,{})

        time.sleep.assert_called_with(5)
        patcher.stop()


    def test_getBatchDetails_should_call_get_video_info_on_result(self):
        core = YouTubeCore()
        core._fetchPage = Mock()
        core.getVideoInfo = Mock()
        core.getVideoInfo.return_value = []
        core._fetchPage.return_value = {"content":"some_content","status":303}
        sys.modules["__main__"].cache.getMulti.return_value = ['{"videoid":"some_id_1"}',"","","",'{"videoid":"some_id_5"}']

        core.getBatchDetails(["some_id_1","some_id_2","some_id_3","some_id_4","some_id_5"],{"param":"some_params"})

        core.getVideoInfo.assert_called_with("some_content",{"param":"some_params"})

    def test_getBatchDetails_should_handle_collection_sizes_above_50(self):
        core = YouTubeCore()
        core._fetchPage = Mock()
        core.getVideoInfo = Mock()
        core.getVideoInfo.return_value = []
        core._fetchPage.return_value = {"content":"","status":303}
        sys.modules["__main__"].cache.getMulti.return_value = []
        sys.modules["__main__"].common.parseDOM.return_value = ""
        ids = []
        i= 1
        while i < 75:
            ids.append("some_id_"  + str(i))
            i += 1

        core.getBatchDetails(ids,{})

        assert(core._fetchPage.call_count == 2)

    def test_fetchPage_should_return_error_status_and_empty_content_if_no_params_are_provided(self):
        patcher = patch("urllib2.urlopen")
        patcher.start()
        import urllib2
        dummy_connection = Mock()
        dummy_connection.read.return_value = "Nothing here\n"
        dummy_connection.geturl.return_value = ""
        dummy_connection.info.return_value = "Mock header"
        patcher(urllib2.urlopen).return_value = dummy_connection
        core = YouTubeCore()

        ret = core._fetchPage({})
        patcher.stop()

        assert(ret['status'] == 500 and ret['content'] == "")

    def test_fetchPage_should_call_getAuth_to_fetch_oauth_token_if_auth_is_in_params_collection(self):
        sys.modules[ "__main__" ].settings.getSetting.side_effect = [ "3", "", "", "4", "my_token", "false", "my_token" ]
        patcher = patch("urllib2.urlopen")
        patcher.start()
        import urllib2
        dummy_connection = Mock()
        dummy_connection.read.return_value = "Nothing here\n"
        dummy_connection.geturl.return_value = ""
        dummy_connection.info.return_value = "Mock header"
        patcher(urllib2.urlopen).return_value = dummy_connection
        core = YouTubeCore()
        core._getAuth = Mock()

        ret = core._fetchPage({"auth":"true", "link":"www.somelink.dk"})

        patcher.stop()
        core._getAuth.assert_called_with()

    def test_fetchPage_should_call_getSettings_if_to_fetch_oauth_token_if_auth_is_in_params_collection(self):
        sys.modules[ "__main__" ].settings.getSetting.side_effect = [ "3", "", "", "4", "my_token", "false", "my_token" ]
        patcher = patch("urllib2.urlopen")
        patcher.start()
        import urllib2
        dummy_connection = Mock()
        dummy_connection.read.return_value = "Nothing here\n"
        dummy_connection.geturl.return_value = ""
        dummy_connection.info.return_value = "Mock header"
        patcher(urllib2.urlopen).return_value = dummy_connection
        core = YouTubeCore()
        core._getAuth = Mock()

        ret = core._fetchPage({"auth":"true", "link":"www.somelink.dk"})

        patcher.stop()
        sys.modules[ "__main__" ].settings.getSetting.assert_any_call("oauth2_access_token")

    def test_fetchPage_should_give_up_after_3_tries(self):
        core = YouTubeCore()
        core._getAuth = Mock()

        ret = core._fetchPage({"auth":"true", "link":"www.somelink.dk", "error":"3"})

        sys.modules[ "__main__" ].common.log.assert_called_with("giving up")

    def test_fetchPage_should_call_urllib_add_header_id_url_data_is_in_params_collection(self):
        sys.modules[ "__main__" ].settings.getSetting.side_effect = ["3","4","4", "false", "my_auth"]
        patcher1 = patch("urllib2.urlopen")
        patcher2 = patch("urllib2.Request")
        patcher1.start()
        patcher2.start()
        import urllib2
        dummy_connection = Mock()
        dummy_connection.read.return_value = "Nothing here\n"
        dummy_connection.geturl.return_value = ""
        dummy_connection.info.return_value = "Mock header"
        patcher1(urllib2.urlopen).return_value = dummy_connection
        dummy_request = Mock()
        urllib2.Request = Mock()
        patcher2(urllib2.Request).return_value = dummy_request
        core = YouTubeCore()
        core._getAuth = Mock()
        ret = core._fetchPage({"auth":"true", "link":"www.somelink.dk", "url_data":{"data":"some_data"}})

        args = urllib2.Request.call_args
        patcher1.stop()
        patcher2.stop()
        print repr(args)
        assert(args[0][0] == 'www.somelink.dk?oauth_token=4')
        assert(args[0][1]== 'data=some_data')

    def test_fetchPage_should_set_request_method_to_get_if_request_is_not_in_params_collection(self):
        sys.modules[ "__main__" ].settings.getSetting = Mock()
        sys.modules[ "__main__" ].settings.getSetting.side_effect = ["3","4","false","false", "false", "false"]

        patcher1 = patch("urllib2.urlopen")
        patcher2 = patch("YouTubeCore.url2request")
        patcher1.start()
        patcher2.start()
        import YouTubeCore
        import urllib2
        YouTubeCore.url2request = Mock()
        dummy_connection = Mock()
        dummy_connection.read.return_value = "Nothing here\n"
        dummy_connection.geturl.return_value = ""
        dummy_connection.info.return_value = "Mock header"
        patcher1(urllib2.urlopen).return_value = dummy_connection
        core = YouTubeCore.YouTubeCore()
        core._getAuth = Mock()

        ret = core._fetchPage({"auth":"true", "link":"www.somelink.dk"})

        patcher1.stop()
        args = YouTubeCore.url2request.call_args
        patcher2.stop()
        assert(args[0][1] == "GET")

    def test_fetchPage_should_append_GdataApi_headers_if_request_is_set(self):
        sys.modules[ "__main__" ].settings.getSetting.side_effect = [ "3", "4", "my_token", "false", "my_auth" ]
        patcher1 = patch("urllib2.urlopen")
        patcher2 = patch("urllib2.Request")
        patcher1.start()
        patcher2.start()
        import urllib2
        dummy_connection = Mock()
        dummy_connection.read.return_value = "Nothing here\n"
        dummy_connection.geturl.return_value = ""
        dummy_connection.info.return_value = "Mock header"
        patcher1(urllib2.urlopen).return_value = dummy_connection
        dummy_request = Mock()
        urllib2.Request = Mock()
        patcher2(urllib2.Request).return_value = dummy_request
        core = YouTubeCore()
        core._getAuth = Mock()

        ret = core._fetchPage({"auth":"true", "link":"www.somelink.dk", "request":"some_request"})

        patcher1.stop()
        patcher2.stop()

        assert(dummy_request.add_header.call_args_list[0][0][0] == 'X-GData-Client')
        assert(dummy_request.add_header.call_args_list[1][0][0] == 'Content-Type')
        assert(dummy_request.add_header.call_args_list[1][0][1] == 'application/atom+xml')
        assert(dummy_request.add_header.call_args_list[2][0][0] == 'Content-Length')
        assert(dummy_request.add_header.call_args_list[2][0][1] == '12')
        #assert(dummy_request.add_header.call_args[0][1] == 'GoogleLogin auth=my_auth')
        #assert(dummy_request.add_header.call_args[0][0] == 'Authorization')

    def test_fetchPage_should_append_api_key_to_headers_if_api_is_in_params(self):
        sys.modules[ "__main__" ].settings.getSetting.side_effect = ["3", "4", "", "", "false", ""]
        patcher1 = patch("urllib2.urlopen")
        patcher2 = patch("YouTubeCore.url2request")
        patcher1.start()
        patcher2.start()
        import YouTubeCore
        import urllib2
        YouTubeCore.url2request = Mock()
        dummy_connection = Mock()
        dummy_connection.read.return_value = "Nothing here\n"
        dummy_connection.geturl.return_value = ""
        dummy_connection.info.return_value = "Mock header"
        patcher1(urllib2.urlopen).return_value = dummy_connection
        core = YouTubeCore.YouTubeCore()
        core._getAuth = Mock()
        core.APIKEY = "MYKEY"

        ret = core._fetchPage({"api":"true", "link":"www.somelink.dk"})

        patcher1.stop()
        args = YouTubeCore.url2request().add_header.call_args_list
        patcher2.stop()

        assert(args[0][0][0] == 'GData-Version')
        assert(args[0][0][1] == '2.1')
        assert(args[1][0][0] == "X-GData-Key")
        assert(args[1][0][1] == "key=MYKEY")

    def test_fetchPage_should_return_error_message_if_login_is_in_params_collection_and_plugin_is_missing_login_info(self):
        sys.modules[ "__main__" ].settings.getSetting.side_effect = ["3", "4", "", "", "false", ""]
        patcher1 = patch("urllib2.urlopen")
        patcher2 = patch("YouTubeCore.url2request")
        patcher1.start()
        patcher2.start()
        import YouTubeCore
        import urllib2
        YouTubeCore.url2request = Mock()
        dummy_connection = Mock()
        dummy_connection.read.return_value = "Nothing here\n"
        dummy_connection.geturl.return_value = ""
        dummy_connection.info.return_value = "Mock header"
        patcher1(urllib2.urlopen).return_value = dummy_connection
        core = YouTubeCore.YouTubeCore()
        core._getAuth = Mock()

        ret = core._fetchPage({"login":"true","link":"www.somelink.dk"})
        patcher1.stop()
        patcher2.stop()

        assert(ret["status"] == 303)
        assert(ret["content"] == "error_message")
        sys.modules[ "__main__" ].language.assert_called_with(30622)

    def test_fetchPage_should_fetch_token_from_settings_if_login_is_in_params(self):
        settings = ["my_token", "my_token", "my_token", "{'my_token': 'my_token'}", "my_token", "user", "pass", "4", "", "", "3"]
        sys.modules[ "__main__" ].settings.getSetting.side_effect = lambda x: settings.pop()
        patcher1 = patch("urllib2.urlopen")
        patcher2 = patch("YouTubeCore.url2request")
        patcher1.start()
        patcher2.start()
        import YouTubeCore
        import urllib2
        YouTubeCore.url2request = Mock()
        dummy_connection = Mock()
        dummy_connection.read.return_value = "Nothing here\n"
        dummy_connection.geturl.return_value = ""
        dummy_connection.info.return_value = "Mock header"
        patcher1(urllib2.urlopen).return_value = dummy_connection
        core = YouTubeCore.YouTubeCore()
        core._getAuth = Mock()

        ret = core._fetchPage({"login":"true","link":"www.somelink.dk"})

        patcher1.stop()
        patcher2.stop()

        sys.modules[ "__main__" ].settings.getSetting.assert_any_call("cookies_saved")

    def test_fetchPage_should_retry_on_URLError(self):
        settings = ["my_token", "my_token", "my_token", "my_token", "my_token", "user", "pass", "4", "", "", "3"]
        sys.modules[ "__main__" ].settings.getSetting.side_effect = lambda x: settings.pop()
        patcher1 = patch("urllib2.urlopen")
        patcher2 = patch("YouTubeCore.url2request")
        patcher3 = patch("time.sleep")
        patcher1.start()
        patcher2.start()
        patcher3.start()
        import YouTubeCore
        import urllib2
        import time
        time.sleep = Mock()
        YouTubeCore.url2request = Mock()
        dummy_connection = Mock()
        read_values = ["Nothing here\n","something verify-age-actions"]
        dummy_connection.read.side_effect = urllib2.URLError("Boom")
        patcher1(urllib2.urlopen).return_value = dummy_connection
        core = YouTubeCore.YouTubeCore()
        core._getAuth = Mock()

        params = {"login":"","link":"www.somelink.dk"}
        ret = core._fetchPage(params)

        patcher1.stop()
        args = YouTubeCore.url2request().add_header.call_args_list
        patcher2.stop()
        patcher3.stop()
        assert(params["error"] == 3)

    def test_fetchPage_should_log_content_on_HTTPError_if_no_known_reason_is_found(self):
        settings = ["my_token", "my_token", "my_token", "my_token", "my_token", "user", "pass", "4", "", "", "3"]
        sys.modules[ "__main__" ].settings.getSetting.side_effect = lambda x: settings.pop()
        patcher1 = patch("urllib2.urlopen")
        patcher2 = patch("YouTubeCore.url2request")
        patcher1.start()
        patcher2.start()
        import YouTubeCore
        import urllib2
        YouTubeCore.url2request = Mock()
        fp = Mock()
        fp.read.return_value = "something"
        dummy_connection = Mock()
        read_values = ["Nothing here\n","something verify-age-actions"]
        dummy_connection.read.side_effect = urllib2.HTTPError("",400,"BOOM","",fp)
        patcher1(urllib2.urlopen).return_value = dummy_connection
        core = YouTubeCore.YouTubeCore()
        core._oRefreshToken = Mock()
        core._getAuth = Mock()

        params = {"login":"","link":"www.somelink.dk"}
        ret = core._fetchPage(params)

        patcher1.stop()
        args = YouTubeCore.url2request().add_header.call_args_list
        patcher2.stop()

        fp.read.assert_any_call()

    def test_fetchPage_should_return_content_of_link_and_proper_status_code(self):
        sys.modules[ "__main__" ].settings.getSetting.side_effect = [ "3", "4", "false", "", ""]
        patcher = patch("urllib2.urlopen")
        patcher.start()
        import urllib2
        dummy_connection = Mock()
        dummy_connection.read.return_value = "Nothing here\n"
        dummy_connection.geturl.return_value = ""
        dummy_connection.info.return_value = "Mock header"
        patcher(urllib2.urlopen).return_value = dummy_connection
        core = YouTubeCore()

        ret = core._fetchPage({ "link": "http://tobiasussing.dk"})
        patcher.stop()

        assert(ret['status'] == 200 and ret['content'] == "Nothing here\n")

    def test_fetchPage_should_add_proxy_when_forced_true(self):
        sys.modules[ "__main__" ].settings.getSetting.side_effect = [ "3", "true", "proxy/?browse=", "proxy/?browse=", "proxy/?browse=" ]
        patcher = patch("urllib2.urlopen")
        patcher.start()
        import urllib2
        dummy_connection = Mock()
        dummy_connection.read.return_value = "Nothing here\n"
        dummy_connection.geturl.return_value = ""
        dummy_connection.info.return_value = "Mock header"
        patcher(urllib2.urlopen).return_value = dummy_connection
        core = YouTubeCore()

        ret = core._fetchPage({ "link": "http://tobiasussing.dk"})
        patcher.stop()
        print repr(ret)
        assert(ret['status'] == 200 and ret['content'] == "Nothing here\n")
        sys.modules[ "__main__" ].common.log.assert_any_call("got proxy: proxy/?browse=http%3A//tobiasussing.dk")

    def test_findErrors_should_use_parseDOM_to_look_for_errormsg_tag(self):
        input = { "content": "some_content"}
        parsedom = [ ["Mock error [" ] ] # This should probably be updated to something real.
        sys.modules[ "__main__" ].common.parseDOM.side_effect = lambda x,y,attrs: parsedom.pop()
        sys.modules[ "__main__" ].common.stripTags.return_value = "Mock error"
        core = YouTubeCore()

        result = core._findErrors( input )

        sys.modules[ "__main__" ].common.parseDOM.assert_called_with(input["content"], 'div', attrs={ "class": "errormsg" })
        assert(result == "Mock error")

    def test_findErrors_should_use_parseDOM_to_look_for_error_smaller(self):
        input = { "content": "some_content"}
        parsedom = [ ["Mock error ["],[] ] # This should probably be updated to something real.
        sys.modules[ "__main__" ].common.parseDOM.side_effect = lambda x,y,attrs: parsedom.pop()
        sys.modules[ "__main__" ].common.stripTags.return_value = "Mock error"
        core = YouTubeCore()

        result = core._findErrors({"content":"some_content"})

        sys.modules[ "__main__" ].common.parseDOM.assert_called_with(input["content"], 'div', attrs={ "class": "error smaller" })
        assert(result == "Mock error")

    def test_findErrors_should_use_parseDOM_to_look_for_unavailable_message(self):
        input = { "content": "some_content"}
        parsedom = [ ["Mock error ["],[],[] ] # This should probably be updated to something real.
        sys.modules[ "__main__" ].common.parseDOM.side_effect = lambda x,y,attrs: parsedom.pop()
        sys.modules[ "__main__" ].common.stripTags.return_value = "Mock error"
        core = YouTubeCore()

        result = core._findErrors({"content":"some_content"})

        sys.modules[ "__main__" ].common.parseDOM.assert_called_with(input["content"], 'div', attrs={ "id": "unavailable-message" })
        assert(result == "Mock error")

    def test_findErrors_should_use_parseDOM_to_look_for_error_if_content_contains_yt_quota(self):
        input = { "content": "some_content yt:quota"}
        parsedom = [ ["Mock error ["],[],[],[],[] ] # This should probably be updated to something real.
        sys.modules[ "__main__" ].common.parseDOM.side_effect = lambda x = "",y ="",attrs = {}: parsedom.pop()
        sys.modules[ "__main__" ].common.stripTags.return_value = "Mock error"
        core = YouTubeCore()

        result = core._findErrors(input)

        assert(sys.modules[ "__main__" ].common.parseDOM.call_args_list[3][0][0] == input["content"])
        assert(sys.modules[ "__main__" ].common.parseDOM.call_args_list[3][0][1] == 'error')
        sys.modules[ "__main__" ].common.parseDOM.assert_called_with([], 'code')
        assert(result == "Mock error")

    def test_findErrors_should_return_if_error_found(self):
        input = { "content": "some_content"}
        parsedom = [ ["Mock error [" ] ] # This should probably be updated to something real.
        sys.modules[ "__main__" ].common.parseDOM.side_effect = lambda x,y,attrs: parsedom.pop()
        sys.modules[ "__main__" ].common.stripTags.return_value = "Mock error"
        core = YouTubeCore()

        result = core._findErrors( input )

        assert(result == "Mock error")

    def test_oRefreshToken_should_reset_access_token_before_calling_fetch_page(self):
        settings = [ "","some_token","3"]
        sys.modules[ "__main__" ].settings.getSetting.side_effect = lambda x: settings.pop()
        core = YouTubeCore()
        core._fetchPage = Mock()
        core._fetchPage.return_value = {"status":303,"content":"fail"}

        result = core._oRefreshToken()

        sys.modules[ "__main__" ].settings.setSetting.assert_called_with("oauth2_access_token","")

    def test_oRefreshToken_should_fetch_refresh_token_from_settings(self):
        settings = [ "","3"]
        sys.modules[ "__main__" ].settings.getSetting.side_effect = lambda x: settings.pop()
        core = YouTubeCore()
        core._fetchPage = Mock()

        result = core._oRefreshToken()

        sys.modules[ "__main__" ].settings.getSetting.assert_called_with("oauth2_refresh_token")

    def test_oRefreshToken_should_fetchPage_with_correct_params(self):
        settings = [ "","some_token","3"]
        sys.modules[ "__main__" ].settings.getSetting.side_effect = lambda x: settings.pop()
        core = YouTubeCore()
        core._fetchPage = Mock()
        core._fetchPage.return_value = {"status":303,"content":"fail"}

        result = core._oRefreshToken()

        assert(core._fetchPage.call_args[0][0]["link"] == "https://accounts.google.com/o/oauth2/token")
        assert(core._fetchPage.call_args[0][0].has_key("url_data"))

    def test_oRefreshToken_should_pars_token_json_structure_correctly(self):
        patcher = patch("time.time")
        patcher.start()
        import time
        time.time = Mock()
        time.time.return_value = 3600

        settings = [ "","some_token","3"]
        sys.modules[ "__main__" ].settings.getSetting.side_effect = lambda x: settings.pop()
        core = YouTubeCore()
        core._fetchPage = Mock()
        core._fetchPage.return_value = {"status":200,"content":'{"access_token":"", "expires_in": "3600"}'}

        result = core._oRefreshToken()
        patcher.stop()

        sys.modules[ "__main__" ].settings.setSetting.assert_any_call("oauth2_access_token", "")
        sys.modules[ "__main__" ].settings.setSetting.assert_any_call("oauth2_expires_at", "7200")

    def test_oRefreshToken_should_log_error_if_invalid_json_structure_is_returned(self):
        settings = [ "","some_token","3"]
        sys.modules[ "__main__" ].settings.getSetting.side_effect = lambda x: settings.pop()
        core = YouTubeCore()
        core._fetchPage = Mock()
        output = {"status":200,"content":'{"access_token"][sdlkfjfksldf"super_secrect_token"[}]'}
        core._fetchPage.return_value = output

        result = core._oRefreshToken()

        sys.modules[ "__main__" ].common.log.assert_called_with("Except: " + repr(output))

    def test_oRefreshToken_should_set_access_token_if_found(self):
        patcher = patch("time.time")
        patcher.start()
        import time
        time.time = Mock()
        time.time.return_value = 3600

        settings = [ "","some_token","3"]
        sys.modules[ "__main__" ].settings.getSetting.side_effect = lambda x: settings.pop()
        core = YouTubeCore()
        core._fetchPage = Mock()
        core._fetchPage.return_value = {"status":200,"content":'{"access_token":"super_secrect_token", "expires_in": "3600"}'}

        result = core._oRefreshToken()
        patcher.stop()

        sys.modules[ "__main__" ].settings.setSetting.assert_any_call("oauth2_access_token", "")
        sys.modules[ "__main__" ].settings.setSetting.assert_any_call("oauth2_access_token", "super_secrect_token")
        sys.modules[ "__main__" ].settings.setSetting.assert_any_call("oauth2_expires_at", "7200")

    def test_getAuth_should_check_token_expiration_before_calling_refresh_token(self):
        settings = [ "","some_token","3249320480292","3249320480292","3"]
        sys.modules[ "__main__" ].settings.getSetting.side_effect = lambda x: settings.pop()
        core = YouTubeCore()
        core._oRefreshToken = Mock()

        result = core._getAuth()

        sys.modules[ "__main__" ].settings.getSetting.assert_any_call("oauth2_expires_at")

    def test_getAuth_should_call_oRefreshToken_to_refresh_token(self):
        settings = [ "","some_token","2", "2","3"]
        sys.modules[ "__main__" ].settings.getSetting.side_effect = lambda x: settings.pop()
        core = YouTubeCore()
        core._oRefreshToken = Mock()

        result = core._getAuth()

        core._oRefreshToken.assert_called_with()

    def test_getAuth_should_fetch_token_from_settings(self):
        settings = [ "", "","32342498270492","32342498270492","3"]
        sys.modules[ "__main__" ].settings.getSetting.side_effect = lambda x: settings.pop()
        core = YouTubeCore()
        core._oRefreshToken = Mock()
        sys.modules[ "__main__" ].login.login.return_value = ("",200)

        result = core._getAuth()

        sys.modules["__main__" ].settings.getSetting.assert_called_with("oauth2_access_token")

    def test_getAuth_should_call_login_if_token_isnt_found(self):
        settings = [ "","","","3"]
        sys.modules[ "__main__" ].settings.getSetting.side_effect = lambda x: settings.pop()
        sys.modules[ "__main__" ].login.login.return_value = ("",200)
        core = YouTubeCore()
        core._oRefreshToken = Mock()

        result = core._getAuth()

        sys.modules[ "__main__" ].login.login.assert_called_with()
        sys.modules[ "__main__" ].settings.getSetting.assert_called_with("oauth2_access_token")

    def test_getVideoInfo_should_call_getVideoEntries_to_get_video_items(self):
        core = YouTubeCore()
        core.getVideoEntries = Mock(return_value=[])
        core.updateVideoIdStatusInCache = Mock()
        core.addNextPageLinkIfNecessary = Mock()
        core.getVideoIdStatusFromCache = Mock()

        core.getVideoInfo("xml",{})

        core.getVideoEntries.assert_any_call("xml")

    def test_getVideoInfo_should_call_setYTCache_to_save_video_info_to_cache(self):
        core = YouTubeCore()
        core.getVideoEntries = Mock(return_value=[])
        core.updateVideoIdStatusInCache = Mock()
        core.addNextPageLinkIfNecessary = Mock()
        core.getVideoIdStatusFromCache = Mock()

        core.getVideoInfo("xml",{})

        core.updateVideoIdStatusInCache.assert_any_call("videoidcache", [])

    def test_getVideoInfo_should_call_addNextPageLinkIfNecessary_to_set_next_page_indicator(self):
        core = YouTubeCore()
        core.getVideoEntries = Mock(return_value=[])
        core.updateVideoIdStatusInCache = Mock()
        core.addNextPageLinkIfNecessary = Mock()
        core.getVideoIdStatusFromCache = Mock()

        core.getVideoInfo("xml",{})

        core.addNextPageLinkIfNecessary.assert_any_call({},"xml",[])

    def setUp_getVideoInfo_full_run(self):
        self.core.getVideoEntries = Mock(return_value=["entry"])
        self.core.videoIsUnavailable = Mock(return_value=False)
        self.core.updateVideoIdStatusInCache = Mock()
        self.core.addNextPageLinkIfNecessary = Mock()
        self.core.getVideoId = Mock(return_value="123")
        self.core.getVideoTitle = Mock(return_value="Title")
        self.core.getVideoDescription = Mock(return_value="Description")
        self.core.getViewCount = Mock(return_value=0)
        self.core.getVideoUploadDate = Mock(return_value=time.localtime())
        self.core.getVideoCreator = Mock(return_value="VideoCreator")
        self.core.getVideoRating = Mock(return_value="1")
        self.core.getVideoGenre = Mock(return_value="VideoGenre")
        self.core.getVideoDuration = Mock(return_value="2")
        self.core.getVideoEditId = Mock(return_value="editId")
        sys.modules["__main__"].storage.retrieveValue.return_value = "0"

    def test_getVideoInfo_should_call_getVideoId_to_get_video_id(self):
        self.core = YouTubeCore()
        self.setUp_getVideoInfo_full_run()
        self.core.getVideoIdStatusFromCache = Mock()

        self.core.getVideoInfo("xml",{})

        self.core.getVideoId.assert_any_call("entry")

    def test_getVideoInfo_should_call_getNodeValue_to_get_Title(self):
        self.core = YouTubeCore()
        self.setUp_getVideoInfo_full_run()
        self.core.getVideoIdStatusFromCache = Mock()

        self.core.getVideoInfo("xml",{})

        self.core.getVideoTitle.assert_any_call("entry")

    def test_getVideoInfo_should_call_getVideoDescription_to_get_video_Plot(self):
        self.core = YouTubeCore()
        self.setUp_getVideoInfo_full_run()
        self.core.getVideoIdStatusFromCache = Mock()

        self.core.getVideoInfo("xml",{})

        self.core.getVideoDescription.assert_any_call("entry", time.localtime(), 0)

    def test_getVideoInfo_should_call_getVideoUploadDate_to_get_Date(self):
        self.core = YouTubeCore()
        self.setUp_getVideoInfo_full_run()
        self.core.getVideoIdStatusFromCache = Mock()

        self.core.getVideoInfo("xml",{})

        self.core.getVideoUploadDate.assert_any_call("entry")

    def test_getVideoInfo_should_call_getVideoCreator_to_get_Studio(self):
        self.core = YouTubeCore()
        self.setUp_getVideoInfo_full_run()
        self.core.getVideoIdStatusFromCache = Mock()

        self.core.getVideoInfo("xml",{})

        self.core.getVideoCreator.assert_any_call("entry")

    def test_getVideoInfo_should_call_getVideoDuration_to_get_Duration(self):
        self.core = YouTubeCore()
        self.setUp_getVideoInfo_full_run()
        self.core.getVideoIdStatusFromCache = Mock()

        self.core.getVideoInfo("xml",{})

        self.core.getVideoDuration.assert_any_call("entry")

    def test_getVideoInfo_should_call_getVideoRating_to_get_Rating(self):
        self.core = YouTubeCore()
        self.setUp_getVideoInfo_full_run()
        self.core.getVideoIdStatusFromCache = Mock()

        self.core.getVideoInfo("xml",{})

        self.core.getVideoRating.assert_any_call("entry")

    def test_getVideoInfo_should_set_videoid_false_if_video_is_unavailable(self):
        self.core = YouTubeCore()
        self.setUp_getVideoInfo_full_run()
        self.core.videoIsUnavailable.return_value = True
        self.core.getVideoIdStatusFromCache = Mock()

        result = self.core.getVideoInfo("xml",{})

        assert(result[0]["videoid"] == "false")

    def test_getVideoInfo_should_call_getViewCount_to_get_view_Count(self):
        self.core = YouTubeCore()
        self.setUp_getVideoInfo_full_run()
        self.core.getVideoIdStatusFromCache = Mock()

        self.core.getVideoInfo("xml",{})

        self.core.getViewCount.assert_any_call("entry")

    def test_getVideoInfo_should_call_getVideoGenre_to_get_Genre(self):
        self.core = YouTubeCore()
        self.setUp_getVideoInfo_full_run()
        self.core.getVideoIdStatusFromCache = Mock()

        self.core.getVideoInfo("xml",{})

        self.core.getVideoGenre.assert_any_call("entry")

    def test_getVideoInfo_should_call_getVideoEditId_to_search_for_edit_id(self):
        self.core = YouTubeCore()
        self.setUp_getVideoInfo_full_run()
        self.core.getVideoIdStatusFromCache = Mock()

        self.core.getVideoInfo("xml",{})

        self.core.getVideoEditId.assert_any_call("entry")

    def test_getVideoInfo_should_parse_youtube_xml(self):
        sys.modules[ "__main__" ].storage.retrieveValue.return_value = "7"
        import CommonFunctions
        sys.modules["__main__"].common = CommonFunctions
        core = YouTubeCore()
        core.getVideoIdStatusFromCache = Mock()

        result = core.getVideoInfo(self.readTestInput("youtubeFavoritesFeed.xml", False))

        print repr(result)
        assert(result[0]["editid"] == 'some_edit_id')
        assert(result[0]["Title"] == "Aurora seen from the ISS in Orbit")
        assert(result[0]["playlist_entry_id"] == 'some_edit_id')
        assert(result[0]["Rating"] > 4.9)
        assert(result[0]["videoid"] == 'ogtKe7N05F0')
        assert(result[0]["Duration"] == "35")
        assert(result[0]["Genre"] == "Science & Technology")
        assert(result[0]["Studio"] == "isoeph")
        assert(result[0]["Date"] == "29-09-2011")
        assert(result[0]["thumbnail"] == "http://i.ytimg.com/vi/ogtKe7N05F0/0.jpg")

    def test_addNextPageLinkIfNecessary_should_call_parseDOM_to_find_links(self):
        core = YouTubeCore()

        core.addNextPageLinkIfNecessary({}, "xml", [])

        sys.modules["__main__"].common.parseDOM.assert_any_call("xml", "link", ret="rel")

    def test_addNextPageLinkIfNecessary_should_call_addNextFolder_if_next_link_is_found(self):
        sys.modules["__main__"].common.parseDOM.return_value = ["next"]
        core = YouTubeCore()

        core.addNextPageLinkIfNecessary({}, "xml", [])

        sys.modules["__main__"].utils.addNextFolder([],{})

    def test_addNextPageLinkIfNecessary_should_not_call_addNextFolder_if_next_link_is_not_found(self):
        sys.modules["__main__"].common.parseDOM.return_value = ["notnext"]
        core = YouTubeCore()

        core.addNextPageLinkIfNecessary({}, "xml", [])

        sys.modules["__main__"].utils.addNextFolder([],{})

    def test_getVideoEntries_should_call_parseDOM_to_find_video_entries(self):
        sys.modules["__main__"].common.parseDOM.return_value = ["some_entry"]
        core = YouTubeCore()

        core.getVideoEntries("xml")

        sys.modules["__main__"].common.parseDOM.assert_any_call("xml", "entry")

    def test_getVideoEntries_should_make_2nd_attempt_call_to_parseDOM_to_find_video_entries(self):
        sys.modules["__main__"].common.parseDOM.side_effect = ["","some_entry"]
        core = YouTubeCore()

        core.getVideoEntries("xml")

        sys.modules["__main__"].common.parseDOM.assert_any_call("xml", "atom:entry")

    def test_setYTCache_should_construct_proper_videoid_structure_for_cache(self):
        core = YouTubeCore()
        item = {"videoid":"someid"}
        core.updateVideoIdStatusInCache("pre-id", [item])

        sys.modules["__main__"].cache.setMulti.assert_any_call("pre-id", {"someid":repr(item)})

    def test_setYTCache_should_call_cache_setMulti_to_save_video_items(self):
        core = YouTubeCore()

        core.updateVideoIdStatusInCache("pre-id", [])

        sys.modules["__main__"].cache.setMulti.assert_any_call("pre-id", {})

    def test_getVideoDescription_should_call_parseDOM_to_find_plot(self):
        core = YouTubeCore()
        uploadDate = time.localtime()

        core.getVideoDescription("xml", uploadDate, 1)

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml","media:description")

    def test_getVideoDescription_should_call_replaceHTMLCodes_to_ensure_output_is_human_readable(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["some_value"]
        core = YouTubeCore()
        uploadDate = time.localtime()

        core.getVideoDescription("xml", uploadDate, 1)

        sys.modules[ "__main__" ].common.replaceHTMLCodes.assert_any_call("some_value")

    def test_getVideoDescription_should_add_date_to_plot(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["some_value"]
        core = YouTubeCore()
        uploadDate = time.localtime()

        result = core.getVideoDescription("xml", uploadDate, 1)

        sys.modules[ "__main__" ].common.replaceHTMLCodes.assert_any_call("some_value")

        assert(result.find("Date Uploaded: ") > -1)

    def test_getVideoDescription_should_add_view_count_to_plot(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["some_value"]

        core = YouTubeCore()
        uploadDate = time.localtime()

        result = core.getVideoDescription("xml", uploadDate, 1)

        sys.modules[ "__main__" ].common.replaceHTMLCodes.assert_any_call("some_value")

        assert(result.find("View count: 1") > -1)

    def test_getVideoId_should_return_false_if_no_id_is_found(self):
        core = YouTubeCore()

        result = core.getVideoId("xml")

        assert(result == "false")

    def test_getVideoId_should_call_parseDOM_to_find_video_id(self):
        core = YouTubeCore()
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["some_id"]

        result = core.getVideoId("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml","yt:videoid")
        assert(result == "some_id")

    def test_getVideoId_should_make_2nd_attempt_to_find_videoid(self):
        core = YouTubeCore()
        sys.modules[ "__main__" ].common.parseDOM.side_effect = [[],["something/some_id"]]

        result = core.getVideoId("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml","content",ret="src")
        assert(result == "some_id")

    def test_getVideoId_should_make_3rd_attempt_to_find_videoid(self):
        core = YouTubeCore()
        sys.modules[ "__main__" ].common.parseDOM.side_effect = [[],[],["something?blabla=morebla&v=some_id&bla=morebla"]]

        result = core.getVideoId("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml","link",ret="href")
        assert(result == "some_id")

    def test_getPlaylistId_should_call_parseDOM_to_find_playlistId(self):
        core = YouTubeCore()

        result = core.getPlaylistId("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml","id")

    def test_getPlaylistId_should_return_empty_string_if_no_playlistId_is_found(self):
        core = YouTubeCore()

        result = core.getPlaylistId("xml")

        assert(result == "")

    def test_getPlaylistId_should_return_proper_playlistId(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["some_thing:some_id"]
        core = YouTubeCore()

        result = core.getPlaylistId("xml")

        assert(result == "some_id")

    def test_getVideoEditId_should_call_parseDOM_to_find_edit_id(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = []
        core = YouTubeCore()

        result = core.getVideoEditId("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml","link",ret=True)

    def test_getVideoEditId_should_call_parseDOM_twice_to_find_edit_id(self):
        sys.modules[ "__main__" ].common.parseDOM.side_effect = [["edit_link"], []]
        core = YouTubeCore()

        result = core.getVideoEditId("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("edit_link", "link", attrs={"rel": "edit"}, ret="href")

    def test_getVideoEditId_should_find_proper_edit_id(self):
        sys.modules[ "__main__" ].common.parseDOM.side_effect = [["edit_link"], ["something/someid"]]
        core = YouTubeCore()

        result = core.getVideoEditId("xml")

        assert(result == "someid")

    def test_getVideoEditId_should_return_empty_string_if_no_edit_id_is_found(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = []
        core = YouTubeCore()

        result = core.getVideoEditId("xml")

        assert(result == "")

    def test_videoIsUnavailable_should_return_false_if_video_is_available(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = []
        core = YouTubeCore()

        result = core.videoIsUnavailable("xml")

        assert(result == False)

    def test_videoIsUnavailable_should_call_parseDOM_to_check_if_video_is_available(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = []
        core = YouTubeCore()

        result = core.videoIsUnavailable("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml","yt:state",ret=True)

    def test_videoIsUnavailable_should_return_true_if_video_state_is_rejected(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["rejected"]
        core = YouTubeCore()

        result = core.videoIsUnavailable("xml")

        assert(result == True)

    def test_videoIsUnavailable_should_return_true_if_video_state_is_deleted(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["deleted"]
        core = YouTubeCore()

        result = core.videoIsUnavailable("xml")

        assert(result == True)

    def test_videoIsUnavailable_should_call_parseDOM_to_find_reason(self):
        sys.modules[ "__main__" ].common.parseDOM.side_effect = [["something"],[""],[""]]
        core = YouTubeCore()

        result = core.videoIsUnavailable("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml","yt:state", ret="reasonCode")

    def test_videoIsUnavailable_should_call_parseDOM_to_find_reason_value(self):
        sys.modules[ "__main__" ].common.parseDOM.side_effect = [["something"],[""],[""]]
        core = YouTubeCore()

        result = core.videoIsUnavailable("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml","yt:state")

    def test_videoIsUnavailable_should_return_true_if_reason_is_private(self):
        sys.modules[ "__main__" ].common.parseDOM.side_effect = [["something"],["private"],[""]]
        core = YouTubeCore()

        result = core.videoIsUnavailable("xml")

        assert(result == True)

    def test_videoIsUnavailable_should_return_true_if_reason_is_requesterRegion(self):
        sys.modules[ "__main__" ].common.parseDOM.side_effect = [["something"],["requesterRegion"],[""]]
        core = YouTubeCore()

        result = core.videoIsUnavailable("xml")

        assert(result == True)

    def test_videoIsUnavailable_should_return_true_if_reason_is_not_limitedSyndication(self):
        sys.modules[ "__main__" ].common.parseDOM.side_effect = [["something"],["some_other_reason_than limitedSyndication"],[""]]
        core = YouTubeCore()

        result = core.videoIsUnavailable("xml")

        assert(result == True)

    def test_getVideoCreator_call_parseDOM_to_find_video_creator(self):
        core = YouTubeCore()

        result = core.getVideoCreator("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml","media:credit")

    def test_getVideoCreator_call_parseDOM_twice_to_find_video_creator(self):
        core = YouTubeCore()

        result = core.getVideoCreator("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml","name")

    def test_getVideoCreator_should_return_empty_string_if_video_creator_is_not_found(self):

        core = YouTubeCore()

        result = core.getVideoCreator("xml")

        assert(result == "")

    def test_getVideoCreator_should_return_proper_string_if_video_creator_is_found(self):
        sys.modules[ "__main__" ].common.parseDOM.side_effect = [["some_string"],["some_other_string"]]
        core = YouTubeCore()

        result = core.getVideoCreator("xml")

        print repr(result)
        assert(result == "some_string")

    def test_getVideoCreator_should_return_proper_string_if_video_creator_is_found_on_2nd_attempt(self):
        sys.modules[ "__main__" ].common.parseDOM.side_effect = [["some_string"],["some_other_string"]]
        core = YouTubeCore()

        result = core.getVideoCreator("xml")

        print repr(result)
        assert(result == "some_string")

    def test_getVideoTitle_should_call_replaceHTMLCodes_to_ensure_string_is_human_readable(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["some_string"]
        sys.modules[ "__main__" ].common.replaceHTMLCodes.side_effect = ["some_title"]
        core = YouTubeCore()

        result = core.getVideoTitle("xml")

        sys.modules[ "__main__" ].common.replaceHTMLCodes.assert_any_call("some_string")

    def test_getVideoTitle_should_call_parseDOM_to_find_title(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["some_string"]
        sys.modules[ "__main__" ].common.makeUTF8.side_effect = ["some_utf8_string"]
        sys.modules[ "__main__" ].common.replaceHTMLCodes.side_effect = ["some_title"]
        core = YouTubeCore()

        result = core.getVideoTitle("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml","media:title")

    def test_getVideoTitle_should_return_empty_string_if_no_title_is_found(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = []
        sys.modules[ "__main__" ].common.makeUTF8.side_effect = ["some_utf8_string"]
        sys.modules[ "__main__" ].common.replaceHTMLCodes.side_effect = ["some_title"]
        core = YouTubeCore()

        result = core.getVideoTitle("xml")

        print repr(result)
        assert(result == "")

    def test_getVideoTitle_should_return_proper_title_string_if_title_is_found(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["some_string"]
        sys.modules[ "__main__" ].common.makeUTF8.side_effect = ["some_utf8_string"]
        sys.modules[ "__main__" ].common.replaceHTMLCodes.side_effect = ["some_title"]
        core = YouTubeCore()

        result = core.getVideoTitle("xml")

        print repr(result)
        assert(result == "some_title")

    def test_getVideoDuration_should_call_parseDOM_to_find_duration(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = []
        core = YouTubeCore()

        core.getVideoDuration("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml","yt:duration",ret="seconds")

    def test_getVideoDuration_should_return_one_if_no_duration_is_found(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = []
        core = YouTubeCore()

        result = core.getVideoDuration("xml")

        print repr(result)
        assert(result == 1)

    def test_getVideoDuration_should_return_proper_duration_string_if_duration_is_found(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["120"]
        core = YouTubeCore()

        result = core.getVideoDuration("xml")

        print repr(result)
        assert(result == "120")

    def test_getVideoRating_should_call_parseDOM_to_find_rating(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = []
        core = YouTubeCore()

        result = core.getVideoRating("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml", "gd:rating", ret="average")

    def test_getVideoRating_should_return_zero_rating_if_no_rating_is_found(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = []
        core = YouTubeCore()

        result = core.getVideoRating("xml")

        print repr(result)
        assert(result == 0.0)

    def test_getVideoRating_should_return_proper_rating_if_rating_is_found(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["0.123"]
        core = YouTubeCore()

        result = core.getVideoRating("xml")

        print repr(result)
        assert(result == 0.123)

    def test_getVideoGenre_should_call_replaceHTMLCodes_to_ensure_string_is_human_readable(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["some_string"]
        sys.modules[ "__main__" ].common.replaceHTMLCodes.side_effect = ["some_title"]
        core = YouTubeCore()

        result = core.getVideoGenre("xml")

        sys.modules[ "__main__" ].common.replaceHTMLCodes.assert_any_call("some_string")

    def test_getVideoGenre_should_call_parseDOM_to_find_genre(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["some_string"]
        sys.modules[ "__main__" ].common.makeUTF8.side_effect = ["some_utf8_string"]
        sys.modules[ "__main__" ].common.replaceHTMLCodes.side_effect = ["some_title"]
        core = YouTubeCore()

        result = core.getVideoGenre("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml", 'media:category', ret='label')

    def test_getVideoGenre_should_return_empty_string_if_no_genre_is_found(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = []
        sys.modules[ "__main__" ].common.makeUTF8.side_effect = ["some_utf8_string"]
        sys.modules[ "__main__" ].common.replaceHTMLCodes.side_effect = ["some_title"]
        core = YouTubeCore()

        result = core.getVideoGenre("xml")

        print repr(result)
        assert(result == "")

    def test_getVideoGenre_should_return_proper_genre_string_if_genre_is_found(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["some_string"]
        sys.modules[ "__main__" ].common.makeUTF8.side_effect = ["some_utf8_string"]
        sys.modules[ "__main__" ].common.replaceHTMLCodes.side_effect = ["some_genre"]
        core = YouTubeCore()

        result = core.getVideoGenre("xml")

        print repr(result)
        assert(result == "some_genre")

    def test_getViewCount_should_call_parseDOM_to_find_view_count(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = []
        core = YouTubeCore()

        result = core.getVideoRating("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml", "gd:rating", ret="average")

    def test_getViewCount_should_return_zero_count_if_no_view_count_is_found(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = []
        core = YouTubeCore()

        result = core.getVideoRating("xml")

        print repr(result)
        assert(result == 0)

    def test_getViewCount_should_return_proper_view_count_if_view_count_is_found(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["123"]
        core = YouTubeCore()

        result = core.getVideoRating("xml")

        print repr(result)
        assert(result == 123)

    def test_getVideoUploadDate_should_call_parseDOM_to_find_upload_date(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = []
        core = YouTubeCore()

        result = core.getVideoUploadDate("xml")

        sys.modules[ "__main__" ].common.parseDOM.assert_any_call("xml", "published")

    def test_getVideoUploadDate_should_return_current_date_if_upload_date_isnt_found(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = []
        core = YouTubeCore()

        result = core.getVideoUploadDate("xml")

        print repr(result)
        assert(result == time.localtime())

    def test_getVideoUploadDate_should_return_proper_date_if_upload_date_is_found(self):
        sys.modules[ "__main__" ].common.parseDOM.return_value = ["2011-04-22T12:12:12.CET"]
        core = YouTubeCore()

        result = core.getVideoUploadDate("xml")

        print repr(result)
        assert(result == time.struct_time((2011,04,22,12,12,12,4,112,-1)))

if __name__ == "__main__":
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubeFeeds
import nose
import BaseTestCase
from mock import Mock
import sys
from YouTubeFeeds import YouTubeFeeds


class TestYouTubeFeeds(BaseTestCase.BaseTestCase):
    def test_createUrl_should_call_getSetting_to_get_videos_pr_page(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].pluginsettings.currentRegion.return_value = ""
        feeds = YouTubeFeeds()
        
        feeds.createUrl()
        
        sys.modules["__main__"].pluginsettings.itemsPerPage.assert_any_call()

    def test_createUrl_should_call_getSetting_to_get_region_id(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].pluginsettings.currentRegion.return_value = ""
        feeds = YouTubeFeeds()
        
        feeds.createUrl()

        sys.modules["__main__"].pluginsettings.currentRegion.assert_any_call()

    def test_createUrl_should_get_correct_feed_url_if_feed_is_in_params(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].pluginsettings.currentRegion.return_value = ""
        feeds = YouTubeFeeds()
        
        result = feeds.createUrl({"feed": "favorites"})
        result = result[:result.find("?")]
        url = feeds.urls["favorites"] % ("default")
        sys.modules["__main__"].pluginsettings.currentRegion.assert_any_call()
        assert(result == url)

    def test_createUrl_should_get_correct_user_feed_url_if_user_feed_is_in_params(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].pluginsettings.currentRegion.return_value = ""
        feeds = YouTubeFeeds()
        
        result = feeds.createUrl({"user_feed": "favorites"})
        result = result[:result.find("?")]
        url = feeds.urls["favorites"] % ("default")
        assert(result == url)
        
    def test_createUrl_should_get_correct_search_url_if_search_is_in_params(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].pluginsettings.currentRegion.return_value = ""
        sys.modules["__main__"].pluginsettings.safeSearchLevel.return_value = "moderate"
        feeds = YouTubeFeeds()
        
        result = feeds.createUrl({"search": "some_search"})
        result = result[:result.find("moderate") + 8]
        url = feeds.urls["search"] % ("some_search", "moderate")
        assert(result == url)
        
    def test_createUrl_should_add_contact_name_to_url_if_contact_is_in_params(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].pluginsettings.currentRegion.return_value = ""
        feeds = YouTubeFeeds()
        
        result = feeds.createUrl({"feed": "favorites", "contact": "some_contact"})
        
        result = result[:result.find("?")]
        url = feeds.urls["favorites"] % ("some_contact")
        assert(result == url)

    def test_createUrl_should_add_channel_to_url_if_channel_is_in_params(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].pluginsettings.currentRegion.return_value = ""
        feeds = YouTubeFeeds()
        
        result = feeds.createUrl({"feed": "favorites", "channel": "some_channel"})
        
        result = result[:result.find("?")]
        url = feeds.urls["favorites"] % ("some_channel")
        assert(result == url)
	
    def test_createUrl_should_add_category_and_time_to_url_if_category_is_in_params(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].pluginsettings.currentRegion.return_value = ""
        feeds = YouTubeFeeds()
        
        result = feeds.createUrl({"feed": "feed_category", "category": "some_category"})
        
        result = result[:result.rfind("&")]
        result = result[:result.rfind("&")]
        url = feeds.urls["feed_category"] % (("some_category"), "today")
        assert(result == url)

    def test_createUrl_should_add_playlist_to_url_if_playlist_is_in_params(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].pluginsettings.currentRegion.return_value = ""
        feeds = YouTubeFeeds()
        
        result = feeds.createUrl({"feed": "playlist", "channel": "some_playlist"})
        
        result = result[:result.find("?")]
        url = feeds.urls["playlist"] % ("some_playlist")
        assert(result == url)

    def test_createUrl_should_add_videoid_to_url_if_videoid_is_in_params(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].pluginsettings.currentRegion.return_value = ""

        feeds = YouTubeFeeds()
        
        result = feeds.createUrl({"feed": "related", "videoid": "some_videoid"})
        
        result = result[:result.find("?")]
        url = feeds.urls["related"] % ("some_videoid")
        assert(result == url)

    def test_createUrl_should_add_region_if_standard_feed(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].pluginsettings.currentRegion.return_value = "AU"
        feeds = YouTubeFeeds()
        
        result = feeds.createUrl({"feed": "feed_linked"})
        
        result = result[:result.find("?")]
        assert(result.find("standardfeeds/AU/") > 0)

    def test_createUrl_should_start_index_and_max_results_for_non_folder_non_play_all_feeds(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].pluginsettings.currentRegion.return_value = ""

        feeds = YouTubeFeeds()
        
        result = feeds.createUrl({"feed": "feed_linked"})
        
        result = result[result.find("?"):]
        assert(result == "?time=this_week&start-index=1&max-results=15")
	
    def test_createUrl_should_add_time_if_url_contains_time_param(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].pluginsettings.currentRegion.return_value = ""
        feeds = YouTubeFeeds()
        
        result = feeds.createUrl({"feed": "feed_linked"})
        
        assert(result.find("?time=this_week") > 0)
	
    def test_list_should_call_listFolder_if_folder_is_in_params(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        feeds = YouTubeFeeds()
        feeds.listFolder = Mock()
        
        result = feeds.list({"folder": "true"})

        print repr(result)

        feeds.listFolder.assert_called_with({"folder": "true"})
        
    def test_list_should_call_listPlaylist_if_playlist_is_in_params(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        feeds = YouTubeFeeds()
        feeds.listPlaylist = Mock()
        
        result = feeds.list({"playlist": "some_playlist"})

        print repr(result)

        feeds.listPlaylist.assert_called_with({"playlist": "some_playlist"})
        
    def test_list_should_call_core_getAuth_to_test_if_login_is_set_if_login_is_in_params(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        feeds = YouTubeFeeds()
        feeds.listPlaylist = Mock()
        feeds.listFolder = Mock()
        feeds.createUrl = Mock()
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_content", "status": 200}
        sys.modules["__main__"].core.getVideoInfo.return_value = []
        result = feeds.list({"login": "true"})

        print repr(result)

        sys.modules["__main__"].core._getAuth.assert_called_with()
	
    def test_list_should_return_error_message_if_login_is_not_set_and_login_is_in_params(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_content", "status": 200}
        sys.modules["__main__"].core.getVideoInfo.return_value = []
        sys.modules["__main__"].core._getAuth.return_value = False
        sys.modules["__main__"].language.return_value = "some_string"
        feeds = YouTubeFeeds()
        feeds.listPlaylist = Mock()
        feeds.listFolder = Mock()
        feeds.createUrl = Mock()
        result = feeds.list({"login": "true"})
        
        assert(result == ("some_string", 303))
        sys.modules["__main__"].language.assert_called_with(30609)
        
    def test_list_should_call_createUrl_to_fetch_url(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_content", "status": 200}
        sys.modules["__main__"].core.getVideoInfo.return_value = []
        sys.modules["__main__"].language.return_value = "some_string"
        feeds = YouTubeFeeds()
        feeds.listPlaylist = Mock()
        feeds.listFolder = Mock()
        feeds.createUrl = Mock()
        result = feeds.list()

        print repr(result)

        feeds.createUrl.assert_called_with({})

    def test_list_should_call_core_fetchPage_to_get_feed_content(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_content", "status": 200}
        sys.modules["__main__"].core.getVideoInfo.return_value = []
        sys.modules["__main__"].language.return_value = "some_string"
        feeds = YouTubeFeeds()
        feeds.listPlaylist = Mock()
        feeds.listFolder = Mock()
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        result = feeds.list()

        print repr(result)

        sys.modules["__main__"].core._fetchPage.assert_called_with({"api": "true", "link": "some_url", "auth": None})
    
    def test_list_should_call_return_content_and_status_if_fetchPage_failed(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 303}
        sys.modules["__main__"].core.getVideoInfo.return_value = []
        sys.modules["__main__"].language.return_value = "some_string"
        feeds = YouTubeFeeds()
        feeds.listPlaylist = Mock()
        feeds.listFolder = Mock()
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
	
        result = feeds.list()
        
        assert(result == ("some_fail", 303))
	
    def test_list_should_call_core_getVideoInfo_if_fetchPage_succeded_and_folder_is_not_in_params(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].core.getVideoInfo.return_value = []
        sys.modules["__main__"].language.return_value = "some_string"
        feeds = YouTubeFeeds()
        feeds.listPlaylist = Mock()
        feeds.listFolder = Mock()
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
	
        result = feeds.list()

        print repr(result)

        sys.modules["__main__"].core.getVideoInfo.assert_called_with("some_fail", {})

    def test_list_should_return_error_status_if_video_list_is_empty(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].core.getVideoInfo.return_value = []
        sys.modules["__main__"].language.return_value = "some_string"
        feeds = YouTubeFeeds()
        feeds.listPlaylist = Mock()
        feeds.listFolder = Mock()
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
	
        result = feeds.list()
        
        assert(result == ([], 303))
                
    def test_list_should_call_storage_store_to_save_first_thumbnail_in_list(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].core.getVideoInfo.return_value = [{"videoid": "some_id", "thumbnail": "some_thumb"}]
        sys.modules["__main__"].language.return_value = "some_string"
        feeds = YouTubeFeeds()
        feeds.listPlaylist = Mock()
        feeds.listFolder = Mock()
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
	
        result = feeds.list()

        print repr(result)

        sys.modules["__main__"].storage.store.assert_called_with({}, "some_thumb", "thumbnail")

    def test_listPlaylist_should_call_pluginSettings_to_get_perpage(self):

        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].core.getVideoInfo.return_value = [{"videoid": "some_id", "thumbnail": "some_thumb"}]
        sys.modules["__main__"].language.return_value = "some_string"
        feeds = YouTubeFeeds()
        feeds.listFolder = Mock()
        feeds.listAll = Mock()
        feeds.listAll.return_value = []
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
	
        result = feeds.listPlaylist()
        print repr(result)

        sys.modules["__main__"].pluginsettings.itemsPerPage.assert_any_call()
                        
    def test_listPlaylist_should_call_storage_retrieve_to_fetch_cached_video_listing(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].core.getVideoInfo.return_value = [{"videoid": "some_id", "thumbnail": "some_thumb"}]
        sys.modules["__main__"].language.return_value = "some_string"
        feeds = YouTubeFeeds()
        feeds.listFolder = Mock()
        feeds.listAll = Mock()
        feeds.listAll.return_value = []
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
	
        result = feeds.listPlaylist()

        print repr(result)

        sys.modules["__main__"].storage.retrieve.assert_called_with({})
        
    def test_listPlaylist_should_call_getBatchDetailsOverride_to_fetch_video_info_for_stored_video_list(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].core.getVideoInfo.return_value = [{"videoid": "some_id", "thumbnail": "some_thumb"}]
        sys.modules["__main__"].language.return_value = "some_string"
        sys.modules["__main__"].storage.retrieve.return_value = [{}, {}]
        sys.modules["__main__"].core.getBatchDetailsOverride.return_value = ([], 200)
        feeds = YouTubeFeeds()
        feeds.listFolder = Mock()
        feeds.listAll = Mock()
        feeds.listAll.return_value = []
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
	
        result = feeds.listPlaylist({"page": "1"})

        print repr(result)

        sys.modules["__main__"].core.getBatchDetailsOverride.assert_called_with([], {"page": "1"})

    def test_listPlaylist_should_call_listAll_if_stored_list_isnt_found(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].core.getVideoInfo.return_value = [{"videoid": "some_id", "thumbnail": "some_thumb"}]
        sys.modules["__main__"].language.return_value = "some_string"
        feeds = YouTubeFeeds()
        feeds.listFolder = Mock()
        feeds.listAll = Mock()
        feeds.listAll.return_value = []
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
	
        result = feeds.listPlaylist()

        print repr(result)

        feeds.listAll.assert_called_with({})
        
    def test_listPlaylist_should_return_error_status_if_listAll_returns_empty_list(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].core.getVideoInfo.return_value = [{"videoid": "some_id", "thumbnail": "some_thumb"}]
        sys.modules["__main__"].language.return_value = "some_string"
        feeds = YouTubeFeeds()
        feeds.listFolder = Mock()
        feeds.listAll = Mock()
        feeds.listAll.return_value = []
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
	
        result = feeds.listPlaylist()

        assert(result == ([], 303))

    def test_listPlaylist_should_call_storage_store_with_list_of_video_ids_and_entryids(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].language.return_value = "some_string"
        list = [{"videoid": "some_id", "thumbnail": "some_thumb", "playlist_entry_id": "some_id"}]
        feeds = YouTubeFeeds()
        feeds.listFolder = Mock()
        feeds.listAll = Mock()
        feeds.listAll.return_value = list
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
	
        result = feeds.listPlaylist()

        print repr(result)

        sys.modules["__main__"].storage.store.assert_any_call({}, [{"videoid": "some_id", "playlist_entry_id": "some_id"}], )
                
    def test_listPlaylist_should_call_storage_store_with_first_thumbnail_of_list(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].language.return_value = "some_string"
        list = [{"videoid": "some_id", "thumbnail": "some_thumb", "playlist_entry_id": "some_id"}]
        feeds = YouTubeFeeds()
        feeds.listFolder = Mock()
        feeds.listAll = Mock()
        feeds.listAll.return_value = list
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
	
        result = feeds.listPlaylist()

        print repr(result)

        sys.modules["__main__"].storage.store.assert_called_with({}, "some_thumb", "thumbnail")
        
    def test_listPlaylist_should_call_addNextFolder_for_lists_longer_than_perpage(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].language.return_value = "some_string"
        ids = []
        i= 1
        while i < 52:
            ids.append({"videoid": "some_id_" + str(i), "thumbnail": "some_thumb_" + str(i), "playlist_entry_id": "some_id_" + str(i)})
            i += 1
        feeds = YouTubeFeeds()
        feeds.listFolder = Mock()
        feeds.listAll = Mock()
        feeds.listAll.return_value = ids
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
	
        result = feeds.listPlaylist()

        print repr(result)

        sys.modules["__main__"].utils.addNextFolder.assert_called_with(ids[:15], {})

    def test_listPlaylist_should_limit_list_lengt_to_perpage_count(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].language.return_value = "some_string"
        ids = []
        i= 1
        while i < 52:
            ids.append({"videoid": "some_id_" + str(i), "thumbnail": "some_thumb_" + str(i), "playlist_entry_id": "some_id_" + str(i)})
            i += 1
        feeds = YouTubeFeeds()
        feeds.listFolder = Mock()
        feeds.listAll = Mock()
        feeds.listAll.return_value = ids
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
	
        videos, status = feeds.listPlaylist()
        assert(len(videos) == 15)
        
    def test_listPlaylist_should_starts_list_position_from_page_count_and_perpage_count(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].language.return_value = "some_string"
        ids = []
        i= 1
        while i < 52:
            ids.append({"videoid": "some_id_" + str(i), "thumbnail": "some_thumb_" + str(i), "playlist_entry_id": "some_id_" + str(i)})
            i += 1
        sys.modules["__main__"].core.getBatchDetailsOverride.side_effect = lambda x, y: (x, 200)
        sys.modules["__main__"].storage.retrieve.return_value = ids
        feeds = YouTubeFeeds()
        feeds.listFolder = Mock()
        feeds.listAll = Mock()
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"

        videos, status = feeds.listPlaylist({"page": "1"})
        print repr(videos)
        print repr(status)

        assert(len(videos) == 15)
        assert(videos[0]["videoid"] == "some_id_16")
        assert(videos[14]["videoid"] == "some_id_30")
        
    def test_listFolder_should_call_storage_getUserOptionFolder_if_storage_is_contact_options(self):
        feeds = YouTubeFeeds()

        feeds.listFolder({"store": "contact_options"})
        	
        sys.modules["__main__"].storage.getUserOptionFolder.assert_called_with({"store": "contact_options"})
	
    def test_listFolder_should_call_storage_getStoredSearches_if_storage_is_set_but_not_contact_options(self):
        feeds = YouTubeFeeds()

        feeds.listFolder({"store": "some_store"})
        	
        sys.modules["__main__"].storage.getStoredSearches.assert_called_with({"store": "some_store"})

    def test_listFolder_should_call_getSetting_to_get_perpage(self):
        feeds = YouTubeFeeds()
        feeds.listAll = Mock()
        feeds.listAll.return_value = []
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        feeds.listFolder()
        	
        sys.modules["__main__"].pluginsettings.itemsPerPage.assert_any_call()
        
    def test_listFolder_should_call_storage_retrieve_to_fetch_cached_video_listing_if_page_is_in_params(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].storage.retrieve.return_value = []
        feeds = YouTubeFeeds()
        feeds.listAll = Mock()
        feeds.listAll.return_value = []
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        feeds.listFolder({"page": "1"})
        	
        sys.modules["__main__"].storage.retrieve.assert_called_with({"page": "1"})

    def test_listFolder_should_call_listAll_page_is_not_in_params(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].storage.retrieve.return_value = []
        feeds = YouTubeFeeds()
        feeds.listAll = Mock()
        feeds.listAll.return_value = []
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        feeds.listFolder()
        	
        feeds.listAll.assert_called_with({})

    def test_listFolder_should_call_storage_store_to_save_new_list(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].storage.retrieve.return_value = []
        feeds = YouTubeFeeds()
        feeds.listAll = Mock()
        feeds.listAll.return_value = ["some"]
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        feeds.listFolder()
        	
        sys.modules["__main__"].storage.store.assert_called_with({}, ["some"])

    def test_listFolder_should_call_addNextFolder_for_lists_longer_than_perpage(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].storage.retrieve.return_value = []
        ids = []
        i= 1
        while i < 52:
            ids.append({"Title": "title_" + str(i), "thumbnail": "some_thumb_" + str(i), "id": "some_id_" + str(i)})
            i += 1
        feeds = YouTubeFeeds()
        feeds.listAll = Mock()
        feeds.listAll.return_value = ids
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        feeds.listFolder()
        	
        sys.modules["__main__"].utils.addNextFolder.assert_called_with(ids[:15], {})
        
    def test_listFolder_should_limit_list_lengt_to_perpage_count(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].storage.retrieve.return_value = []
        ids = []
        i= 1
        while i < 52:
            ids.append({"Title": "title_" + str(i), "thumbnail": "some_thumb_" + str(i), "id": "some_id_" + str(i)})
            i += 1
        feeds = YouTubeFeeds()
        feeds.listAll = Mock()
        feeds.listAll.return_value = ids
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        videos, status = feeds.listFolder()
        	
        assert(len(videos) == 15)
        
    def test_listFolder_should_starts_list_position_from_page_count_and_perpage_count(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        ids = []
        i= 1
        while i < 52:
            ids.append({"Title": "title_" + str(i), "thumbnail": "some_thumb_" + str(i), "id": "some_id_" + str(i)})
            i += 1
        feeds = YouTubeFeeds()
        feeds.listAll = Mock()
        sys.modules["__main__"].storage.retrieve.return_value = ids
        feeds.listAll.return_value = ids
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        (videos, status) = feeds.listFolder({"page": "1"})
        
        assert(videos[0]["id"] == "some_id_16")
        assert(videos[14]["id"] == "some_id_30")
        
    def test_listFolder_should_call_retrieve_to_get_view_mode_if_feed_is_subscriptions(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].storage.retrieve.return_value = [{"id": "some_item"}]
        feeds = YouTubeFeeds()
        feeds.listAll = Mock()
        feeds.listAll.return_value = [{"id": "some_item"}]
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        (videos, status) = feeds.listFolder({"user_feed": "subscriptions"})
        
        sys.modules["__main__"].storage.retrieve.assert_called_with({"user_feed": "subscriptions"}, "viewmode", {'user_feed': 'uploads', 'view_mode': 'subscriptions_favorites', 'id': 'some_item'})
	
    def test_listFolder_should_set_correct_view_mode_if_feed_is_subscriptions(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].storage.retrieve.return_value = "favorites"
        feeds = YouTubeFeeds()
        feeds.listAll = Mock()
        feeds.listAll.return_value = [{"id": "some_item"}]
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        (videos, status) = feeds.listFolder({"user_feed": "subscriptions"})
        
        assert(videos[0]["user_feed"] == "favorites")
	
    def test_listAll_should_call_getAuth_if_login_is_in_params(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].storage.retrieve.return_value = "favorites"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].core.getVideoInfo.return_value = []
        feeds = YouTubeFeeds()
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        feeds.listAll({"login": "true"})
        
        sys.modules["__main__"].core._getAuth.assert_called_with()
        
    def test_listAll_should_call_createUrl_to_get_url(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].storage.retrieve.return_value = "favorites"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].core.getVideoInfo.return_value = []
        feeds = YouTubeFeeds()
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        feeds.listAll({"login": "true"})
        
        feeds.createUrl.assert_called_with({"login": "true"})
	
    def test_listAll_should_call_fetchPage_correctly(self):
        sys.modules["__main__"].pluginsettings.itemsPerPage.return_value = 15
        sys.modules["__main__"].storage.retrieve.return_value = "favorites"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].core.getVideoInfo.return_value = []
        feeds = YouTubeFeeds()
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        feeds.listAll({"login": "true"})
        
        sys.modules["__main__"].core._fetchPage.assert_called_with({"link": "some_urlv=2.1&start-index=1&max-results=50", "auth": "true"})
        
    def test_listAll_should_call_core_getFolderInfo_if_folder_is_in_params(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].storage.retrieve.return_value = "favorites"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].core.getFolderInfo.return_value = []
        feeds = YouTubeFeeds()
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        feeds.listAll({"login": "true", "folder": "true"})
        
        sys.modules["__main__"].core.getFolderInfo.assert_called_with("some_fail", {"login": "true", "folder": "true"})
        
    def test_listAll_should_call_core_getVideoInfo_if_folder_is_not_in_params(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].storage.retrieve.return_value = "favorites"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        sys.modules["__main__"].core.getVideoInfo.return_value = []
        feeds = YouTubeFeeds()
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        feeds.listAll({"login": "true"})
        
        sys.modules["__main__"].core.getVideoInfo.assert_called_with("some_fail", {"login": "true"})
        
    def test_listAll_should_call_fetchPage_multiple_times_if_feed_requires_it(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].storage.retrieve.return_value = "favorites"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        list = [[{"next": "false"}], [{"next": "true"}]]
        sys.modules["__main__"].core.getVideoInfo.side_effect = lambda x, y: list.pop()
        feeds = YouTubeFeeds()
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        feeds.listAll({"login": "true"})
        
        assert(sys.modules["__main__"].core._fetchPage.call_count == 2)
        
    def test_listAll_should_call_core_getFolderInfo_multiple_times_if_feed_requires_it(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].storage.retrieve.return_value = "favorites"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        list = [[{"next": "false"}], [{"next": "true"}]]
        sys.modules["__main__"].core.getFolderInfo.side_effect = lambda x, y: list.pop()
        feeds = YouTubeFeeds()
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        feeds.listAll({"folder": "true"})
        
        assert(sys.modules["__main__"].core.getFolderInfo.call_count == 2)
        
    def test_listAll_should_call_core_getVideoInfo_multiple_times_if_feed_requires_it(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].storage.retrieve.return_value = "favorites"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        list = [[{"next": "false"}, {"next": "false"}], [{"next": "false"}, {"next": "true"}]]
        sys.modules["__main__"].core.getVideoInfo.side_effect = lambda x, y: list.pop()
        feeds = YouTubeFeeds()
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"
        
        video = feeds.listAll()

        print repr(video)

        assert(sys.modules["__main__"].core.getVideoInfo.call_count == 2)
        
    def test_listAll_should_append_additional_items_to_list(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].storage.retrieve.return_value = "favorites"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        list = [[{"next": "false"}, {"next": "false"}], [{"next": "false"}, {"next": "true"}], [{"next": "false"}, {"next": "true"}], [{"next": "false"}, {"next": "true"}]]
        sys.modules["__main__"].core.getVideoInfo.side_effect = lambda x, y: list.pop()
        feeds = YouTubeFeeds()
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"

        video = feeds.listAll()

        print repr(video)

        assert(video == [{'next': 'false'}, {'next': 'false'}, {'next': 'false'}, {'next': 'false'}, {'next': 'false'}])

    def test_listAll_should_call_storage_getReversePlaylistOrder_to_reverse_list_if_not_play_all(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].storage.retrieve.return_value = "favorites"
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "some_fail", "status": 200}
        list = [[{"next": "false"}], [{"next": "true"}]]
        sys.modules["__main__"].core.getVideoInfo.side_effect = lambda x, y: list.pop()
        feeds = YouTubeFeeds()
        feeds.createUrl = Mock()
        feeds.createUrl.return_value = "some_url"

        feeds.listAll({"user_feed": "playlist"})

        sys.modules["__main__"].storage.getReversePlaylistOrder.assert_called_with({"user_feed": "playlist"})

if __name__ == "__main__":
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubeLogin
# -*- coding: utf-8 -*-
import nose
import BaseTestCase
from mock import Mock, patch
import sys
from  YouTubeLogin import YouTubeLogin 


class TestYouTubeLogin(BaseTestCase.BaseTestCase):

    def test_login_should_get_both_old_and_new_user_name_to_check_for_user_changes(self):
        sys.modules["__main__"].settings.getSetting.return_value = ""
        login = YouTubeLogin()
        login.authorize = Mock(return_value=([],200))

        login.login()

        sys.modules["__main__"].pluginsettings.userName.call_count = 2
        sys.modules["__main__"].pluginsettings.userPassword.call_count = 2

    def test_login_should_call_xbmc_open_settings_to_allow_user_to_revise_credentials(self):
        login = YouTubeLogin()
        login.authorize = Mock(return_value=([],200))

        login.login()

        sys.modules["__main__"].settings.openSettings.assert_called_with()

    def test_login_should_check_debug_flag_to_ensure_we_get_proper_debug_incase_of_errors(self):
        login = YouTubeLogin()
        login.authorize = Mock(return_value=([],200))

        login.login()

        sys.modules["__main__"].pluginsettings.debugModeIsEnabled.assert_called_with()

    def test_login_should_exit_cleanly_if_user_hasnt_entered_a_username(self):
        sys.modules["__main__"].pluginsettings.userName.return_value = ""
        login = YouTubeLogin()
        login.authorize = Mock(return_value=([],200))

        (result, status) = login.login()

        assert (result == "")
        assert (status == 200)

    def test_login_should_tell_xbmc_to_refresh_the_current_folder_listing_if_login_was_success_full(self):
        login = YouTubeLogin()
        login.authorize = Mock(return_value=([],200))

        login.login()
        
        sys.modules["__main__"].xbmc.executebuiltin.assert_called_with("Container.Refresh")

    def test_login_should_ask_core_to_refresh_security_token_if_we_have_an_existing_token_and_credentials_are_unchanged(self):
        sys.modules["__main__"].pluginsettings.userName.return_value = "some_user"
        sys.modules["__main__"].pluginsettings.userPassword.return_value = "some_pass"
        sys.modules["__main__"].pluginsettings.authenticationRefreshRoken.return_value = "some_token"
        login = YouTubeLogin()
        login.authorize = Mock(return_value=([],200))

        login.login({"new":"false"})

        sys.modules["__main__"].core._oRefreshToken.assert_any_call()

    def test_login_should_not_ask_core_to_refresh_security_token_if_user_name_has_changed(self):
        sys.modules["__main__"].pluginsettings.userName.side_effect = ["some_user","some_other_user"]
        sys.modules["__main__"].pluginsettings.userPassword.return_value = "some_pass"
        sys.modules["__main__"].pluginsettings.authenticationRefreshRoken.return_value = "some_token"
        login = YouTubeLogin()
        login.authorize = Mock(return_value=([],200))

        login.login({"new":"false"})

        assert(sys.modules["__main__"].core._oRefreshToken.call_count == 0)

    def test_login_should_not_ask_core_to_refresh_security_token_if_user_password_has_changed(self):
        sys.modules["__main__"].pluginsettings.userName.return_value = "some_user"
        sys.modules["__main__"].pluginsettings.userPassword.side_effect = ["some_pass","some_other_pass"]
        sys.modules["__main__"].pluginsettings.authenticationRefreshRoken.return_value = "some_token"
        login = YouTubeLogin()
        login.authorize = Mock(return_value=([],200))

        login.login({"new":"false"})

        assert(sys.modules["__main__"].core._oRefreshToken.call_count == 0)

    def test_login_should_call_authorize_if_refresh_token_didnt_work(self):
        sys.modules["__main__"].core._oRefreshToken.return_value = False
        login = YouTubeLogin()
        login.authorize = Mock(return_value=("",303))

        login.login()
        
        sys.modules["__main__"].core._oRefreshToken.assert_called_with()
        login.authorize.assert_called_with()

    def test_authorize_should_reset_oauth2_data_when_refreshing(self):
        sys.modules["__main__"].settings.getSetting.return_value = ""
        login = YouTubeLogin()
        login._httpLogin = Mock(return_value=("",303))

        login.authorize()

        sys.modules["__main__"].settings.setSetting.assert_any_call("oauth2_access_token","")
        sys.modules["__main__"].settings.setSetting.assert_any_call("oauth2_refresh_token","")
        sys.modules["__main__"].settings.setSetting.assert_any_call("oauth2_expires_at","")

    def test_authorize_should_call_apiLogin_if_httplogin_succeded(self):
        login = YouTubeLogin()
        login._apiLogin = Mock(return_value=("",200))
        login._httpLogin = Mock(return_value=("",200))

        login.authorize()

        login._httpLogin.assert_any_call({ "new": "true"})
        login._apiLogin.assert_any_call()

    def test_authorize_should_show_error_message_on_http_login_failure(self):
        sys.modules["__main__"].language.side_effect = ["string1", "string2"]

        login = YouTubeLogin()
        login._apiLogin = Mock(return_value=("",200))
        login._httpLogin = Mock(return_value=("",500))

        login.authorize()
        
        sys.modules["__main__"].utils.showErrorMessage.assert_called_with("string1","",500)
        sys.modules["__main__"].language.assert_called_with(30609)

    def test_authorize_should_show_error_message_on_api_login_failure(self):
        sys.modules["__main__"].language.side_effect = ["string1", "string2"]

        login = YouTubeLogin()
        login._apiLogin = Mock(return_value=("",500))
        login._httpLogin = Mock(return_value=("",200))

        login.authorize()

        sys.modules["__main__"].utils.showErrorMessage.assert_called_with("string1","",500)
        sys.modules["__main__"].language.assert_called_with(30609)

    def test_authorize_should_show_refreshing_folder_message_on_success(self):
        sys.modules["__main__"].language.side_effect = ["string1", "string2"]

        login = YouTubeLogin()
        login._apiLogin = Mock(return_value=("",200))
        login._httpLogin = Mock(return_value=("",200))

        login.authorize()

        sys.modules["__main__"].utils.showErrorMessage.assert_called_with("string1","",303)
        sys.modules["__main__"].language.assert_called_with(30031)

    def test_apiLogin_should_call_oauth2_login_url_only_one_time_if_url_fails(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"content":""}
        sys.modules["__main__"].common.parseDOM.return_value = ""
        login = YouTubeLogin()
        
        login._apiLogin()

        assert(sys.modules["__main__"].core._fetchPage.call_count == 1)
	
    def test_apiLogin_should_call_fetchPage_with_correct_params(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"content":""}
        sys.modules["__main__"].common.parseDOM.return_value = ""
        login = YouTubeLogin()
        
        login._apiLogin()
        
        args = sys.modules["__main__"].core._fetchPage.call_args
        assert(args[0][0].has_key("link"))
        
    def test_apiLogin_should_search_for_state_wrapper_and_new_url(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"content":""}
        sys.modules["__main__"].common.parseDOM.side_effect = ["", "","","","some_state_wrapper","some_new_url"]
        login = YouTubeLogin()
        
        login._apiLogin()
        
        args = sys.modules["__main__"].common.parseDOM.call_args
        assert(args[0] == ("","input"))
        assert(args[1].has_key("attrs"))
        assert(args[1]["attrs"].has_key("id"))
        assert(args[1]["attrs"]["id"] == "code")
        
    def test_apiLogin_should_follow_redirect_if_statewrapper_present(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"content":""}
        sys.modules["__main__"].common.parseDOM.side_effect = ["", "","", ["some_code"], "", "", "", ""]
        login = YouTubeLogin()
        
        login._apiLogin()
        
        assert(sys.modules["__main__"].core._fetchPage.call_count == 2)
        	
    def test_apiLogin_should_call_fetchPage_with_correct_params_on_redirect(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"content":""}
        sys.modules["__main__"].common.parseDOM.side_effect = ["", ["some_new_url"], ["some_state_wrapper"], "", "", "", ""]
        login = YouTubeLogin()
        
        login._apiLogin()
        
        args = sys.modules["__main__"].core._fetchPage.call_args
        print(repr(args))
        assert(args[0][0]["link"] == "some_new_url")
        assert(args[0][0]["url_data"]["submit_access"] == "true" )
        assert(args[0][0]["url_data"]["state_wrapper"] == "some_state_wrapper" )
        
        
    def test_apiLogin_should_request_token_if_code_present(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"content":""}
        sys.modules["__main__"].common.parseDOM.side_effect = ["", "","", ["some_code"], "", "", "", ""]
        login = YouTubeLogin()
        
        login._apiLogin()
        
        print(repr(sys.modules["__main__"].core._fetchPage.call_count))
        assert(sys.modules["__main__"].core._fetchPage.call_count == 2)
	
    def test_apiLogin_should_call_fetchPage_with_correct_params_when_fetching_request_token(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"content":""}
        sys.modules["__main__"].common.parseDOM.side_effect = ["", "","", ["some_code"], "", "", "", ""]
        login = YouTubeLogin()
        
        login._apiLogin()

        args = sys.modules["__main__"].core._fetchPage.call_args[0][0]

        print(repr(args))
        assert(args["link"] == "https://accounts.google.com/o/oauth2/token")
        assert(args.has_key("url_data"))
        assert(args["url_data"]["code"] == "some_code" )
        assert(args["url_data"]["grant_type"] == "authorization_code" )
        
    def test_apiLogin_should_set_oauth_specific_values_on_success(self):
        patcher = patch("time.time")
        patcher.start()
        import time
        time.time = Mock(return_value=1)

        sys.modules["__main__"].core._fetchPage.side_effect = [{"content":'{"expires_in":"12", "access_token":"my_favorite_access_token", "refresh_token":"my_favorite_refresh_token" }'},{"content":""}]
        sys.modules["__main__"].settings.getSetting.return_value = ""
        sys.modules["__main__"].common.parseDOM.return_value = ""
        login = YouTubeLogin()
        
        login._apiLogin()
        patcher.stop()

        sys.modules["__main__"].settings.setSetting.assert_any_call("oauth2_expires_at", '13')
        sys.modules["__main__"].settings.setSetting.assert_any_call("oauth2_access_token", "my_favorite_access_token")
        sys.modules["__main__"].settings.setSetting.assert_any_call("oauth2_refresh_token", "my_favorite_refresh_token")

    def test_apiLogin_should_provide_correct_message_and_success_status_code_on_success(self):
        fetch_values = [{"content":""},{"content":'{"expires_in":"12", "access_token":"my_favorite_access_token", "refresh_token":"my_favorite_refresh_token" }'}]
        sys.modules["__main__"].core._fetchPage.side_effect = lambda x: fetch_values.pop()
        sys.modules["__main__"].settings.getSetting.return_value = "" 
        sys.modules["__main__"].common.parseDOM.return_value = ""
        login = YouTubeLogin()
        
        result = login._apiLogin()
        
        sys.modules["__main__"].language.assert_called_with(30030)
        assert(result[1] == 200)
        
    def test_apiLogin_should_provide_correct_message_and_failure_status_code_on_failure(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"content":""}
        sys.modules["__main__"].common.parseDOM.return_value = ""
        login = YouTubeLogin()
        
        result = login._apiLogin()
        
        sys.modules["__main__"].language.assert_called_with(30609)
        assert(result[1] == 303)	
	
    def test_httpLogin_should_check_if_new_is_in_params_collection_before_resetting_login_info(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"","status":200}
        sys.modules["__main__"].settings.getSetting.return_value = "true" 
        sys.modules["__main__"].common.parseDOM.return_value = ""
        login = YouTubeLogin()
        
        result = login._httpLogin({"new":"false"})
        
        assert(sys.modules["__main__"].settings.setSetting.call_count == 0)
        assert(sys.modules["__main__"].core._fetchPage.call_count == 0)
        
    def test_httpLogin_should_return_existing_http_login_info_if_new_is_not_in_params(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"","status":200}
        sys.modules["__main__"].settings.getSetting.return_value = "true"
        sys.modules["__main__"].common.parseDOM.return_value = ""
        login = YouTubeLogin()
        
        result = login._httpLogin()
        
        sys.modules["__main__"].settings.getSetting.assert_called_with("cookies_saved")
        assert(sys.modules["__main__"].core._fetchPage.call_count == 0)
        assert(result[1] == 200)
        assert(result[0] == "true")

    def test_httpLogin_should_call_fetchPage_with_proper_fetch_options_on_first_run(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"","status":200}
        sys.modules["__main__"].settings.getSetting.return_value = "smokey" 
        sys.modules["__main__"].common.parseDOM.return_value = ""
        login = YouTubeLogin()
        
        result = login._httpLogin({"new":"true"})
        
        args = sys.modules["__main__"].core._fetchPage.call_args
        assert(sys.modules["__main__"].core._fetchPage.call_count == 1)
        print repr(args)
        assert(args[0][0] == {"link":"http://www.youtube.com/"})

    def test_httpLogin_should_use_parseDOM_to_check_for_login_button_link(self):
        sys.modules["__main__"].core._findErrors.return_value = False
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"","status":200}
        sys.modules["__main__"].settings.getSetting.return_value = "smokey" 
        sys.modules["__main__"].common.parseDOM.return_value = ""
        login = YouTubeLogin()
        
        result = login._httpLogin({"new":"true"})

        args = sys.modules["__main__"].common.parseDOM.call_args_list

        print repr(args)
        assert(sys.modules["__main__"].core._fetchPage.call_count == 1)
        print repr(args[1][1])
        assert(args[1][0] == ("","button"))
        assert(args[1][1] == {'attrs': {'href': '.*?ServiceLogin.*?'}, 'ret': 'href'})

    def test_httpLogin_should_call_fetchPage_with_proper_redirect_url_if_login_link_is_found(self):
        sys.modules["__main__"].core._findErrors.return_value = False
        dom_values = ["", "", "", "", "","","","","","","","","",["someURL"], ""]
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"","status":200, "location": "here"}
        sys.modules["__main__"].settings.getSetting.return_value = "smokey" 
        sys.modules["__main__"].common.parseDOM.side_effect = lambda x = "",y = "",attrs = {},ret = "": dom_values.pop()
        login = YouTubeLogin()
        
        result = login._httpLogin({"new":"true"})

        print repr(result)
        sys.modules["__main__"].core._fetchPage.assert_called_with({'referer': 'here', 'link': 'someURL'})
        assert(sys.modules["__main__"].core._fetchPage.call_count == 2)
	
    def test_httpLogin_should_use_parseDOM_to_check_for_login_form(self):
        sys.modules["__main__"].core._findErrors.return_value = False
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"","status":200}
        sys.modules["__main__"].settings.getSetting.return_value = "smokey" 
        sys.modules["__main__"].common.parseDOM.return_value = ""
        login = YouTubeLogin()
        
        result = login._httpLogin({"new":"true"})

        args = sys.modules["__main__"].common.parseDOM.call_args_list

        print repr(args)
        assert(sys.modules["__main__"].core._fetchPage.call_count == 1)
        assert(args[2][0] == ("","form"))
        assert(args[2][1] == {'attrs': {'id': 'gaia_loginform'}, 'ret': 'action'})

    def test_httpLogin_should_call_fillLoginInfo_if_login_form_present(self):
        sys.modules["__main__"].core._findErrors.return_value = False
        dom_values = ["","","","","","","","",["someURL"],"", ""]
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"somePage","status":200}
        sys.modules["__main__"].settings.getSetting.return_value = "smokey" 
        sys.modules["__main__"].common.parseDOM.side_effect = lambda x = "",y = "",attrs = {},ret = "": dom_values.pop()
        login = YouTubeLogin()
        login._fillLoginInfo = Mock()
        login._fillLoginInfo.return_value = ("",{})
        
        result = login._httpLogin({"new":"true"})
        
        login._fillLoginInfo.assert_called_with({'content': 'somePage', 'status': 200})

    def test_httpLogin_should_call_fetchPage_with_proper_fetch_options_if_fillLoginInfo_succeded(self):
        sys.modules["__main__"].core._findErrors.return_value = False
        dom_values = ["","","","","","","","",["someURL"],"", ""]
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"somePage","status":200, "location": "here"}
        sys.modules["__main__"].settings.getSetting.return_value = "smokey" 
        sys.modules["__main__"].common.parseDOM.side_effect = lambda x = "",y = "",attrs = {},ret = "": dom_values.pop()
        login = YouTubeLogin()
        login._fillLoginInfo = Mock()
        login._fillLoginInfo.return_value = ("some_galx_value",{"some_key":"some_value"})
        
        result = login._httpLogin({"new":"true"})
        
        login._fillLoginInfo.assert_called_with({'content': 'somePage', 'status': 200, 'location': 'here'})
        assert(sys.modules["__main__"].core._fetchPage.call_count == 2)
        sys.modules["__main__"].core._fetchPage.assert_called_with({'url_data': {'some_key': 'some_value'}, 'referer': 'here', 'link': 'someURL', 'hidden': 'true'})
	
    def test_httpLogin_should_use_parseDOM_to_check_for_new_url_redirects(self):
        sys.modules["__main__"].core._findErrors.return_value = False
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"","status":200}
        sys.modules["__main__"].settings.getSetting.return_value = "smokey" 
        sys.modules["__main__"].common.parseDOM.return_value = ""
        login = YouTubeLogin()
        
        result = login._httpLogin({"new":"true"})

        args = sys.modules["__main__"].common.parseDOM.call_args_list
        print repr(args[2])
        assert(sys.modules["__main__"].core._fetchPage.call_count == 1)
        assert(args[3][0] == ('', 'meta'))
        assert(args[3][1] == {'attrs': {'http-equiv': 'refresh'}, 'ret': 'content'})

    def test_httpLogin_should_call_fetchPage_with_proper_redirect_url(self):
        sys.modules["__main__"].core._findErrors.return_value = False
        dom_values = ["","","","","","","",["&#39;someURL&#39;"],"","", ""]
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"somePage","status":200, "location": "here"}
        sys.modules["__main__"].settings.getSetting.return_value = "smokey" 
        sys.modules["__main__"].common.parseDOM.side_effect = lambda x = "",y = "",attrs = {},ret = "": dom_values.pop()
        login = YouTubeLogin()
        login._fillLoginInfo = Mock()
        login._fillLoginInfo.return_value = ("some_galx_value",{"some_key":"some_value"})
        
        result = login._httpLogin({"new":"true"})
        
        assert(sys.modules["__main__"].core._fetchPage.call_count == 2)
        sys.modules["__main__"].core._fetchPage.assert_called_with({'referer': 'here', 'link': 'someURL'})
        
    def test_httpLogin_should_search_fetchPage_result_to_check_for_2factor_login(self):
        sys.modules["__main__"].core._findErrors.return_value = False
        dummy_content = Mock()
        dummy_content.find.return_value = -1
        page_values = [ {"content":"","status":200}, {"content":dummy_content,"status":200}]
        sys.modules["__main__"].core._fetchPage.side_effect = lambda x: page_values.pop() 
        sys.modules["__main__"].core._fetchPage.return_value = {"content":dummy_content,"status":200}
        sys.modules["__main__"].settings.getSetting.return_value = "smokey" 
        sys.modules["__main__"].common.parseDOM.return_value = ""
        login = YouTubeLogin()
        
        result = login._httpLogin({"new":"true"})
        
        args = dummy_content.find.call_args_list

        assert(sys.modules["__main__"].core._fetchPage.call_count == 1)
        print repr(args)
        assert(args[1][0] == ("smsUserPin",))

    def test_httpLogin_should_call_fillUserPin_if_2factor_login_needs_smsUserPin(self):
        sys.modules["__main__"].core._findErrors.return_value = False
        page_values = [ {"content":" captcha","status":200, "location": "here"}, { "new_url": "http://www.mock.com/", "content":"something,smsUserPin,somethingElse","status":200, "location": "here"}]
        sys.modules["__main__"].core._fetchPage.side_effect = lambda x: page_values.pop() 
        sys.modules["__main__"].settings.getSetting.return_value = "smokey" 
        dom_values = [["Login"], [], [], [], []]
        sys.modules["__main__"].common.parseDOM.side_effect = lambda x = "",y = "",attrs = {},ret = "": dom_values.pop()

        login = YouTubeLogin()
        login._fillUserPin = Mock()
        login._fillUserPin.return_value = "123456"
        
        result = login._httpLogin({"new":"true"})
        
        assert(sys.modules["__main__"].core._fetchPage.call_count == 2)
        login._fillUserPin.assert_called_with("something,smsUserPin,somethingElse")
        
    def test_httpLogin_should_call_fetchPage_with_correct_fetch_options_if_fillUserPin_succeded(self):
        sys.modules["__main__"].core._findErrors.return_value = False
        page_values = [ {"content":" captcha","status":200, "location": "here"}, { "new_url": "http://www.mock.com", "content":"something,smsUserPin,somethingElse","status":200, "location": "here"}]
        sys.modules["__main__"].core._fetchPage.side_effect = lambda x: page_values.pop() 
        sys.modules["__main__"].settings.getSetting.return_value = "smokey" 
        dom_values = [["Login"], [], [], [], []]
        sys.modules["__main__"].common.parseDOM.side_effect = lambda x = "",y = "",attrs = {},ret = "": dom_values.pop()
        login = YouTubeLogin()
        login._fillUserPin = Mock()
        login._fillUserPin.return_value = "some_url_data"
        
        result = login._httpLogin({"new":"true"})
        
        assert(sys.modules["__main__"].core._fetchPage.call_count == 2)
        sys.modules["__main__"].core._fetchPage.assert_called_with({'referer': 'http://www.mock.com', 'link': 'Login', 'url_data': 'some_url_data'})
        
    def test_httpLogin_should_use_parseDOM_to_find_smsToken(self):
        sys.modules["__main__"].core._findErrors.return_value = False
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"","status":200}
        sys.modules["__main__"].settings.getSetting.return_value = "smokey" 
        sys.modules["__main__"].common.parseDOM.return_value = ""
        login = YouTubeLogin()
        
        result = login._httpLogin({"new":"true"})

        args = sys.modules["__main__"].common.parseDOM.call_args_list

        print repr(args)
        assert(sys.modules["__main__"].core._fetchPage.call_count == 1)
        assert(args[4][0] == ('', 'input'))
        assert(args[4][1] == {'attrs': {'name': 'smsToken'}, 'ret': 'value'})

    def test_httpLogin_should_call_fetchPage_with_correct_fetch_options_if_smsToken_is_found(self):
        sys.modules["__main__"].core._findErrors.return_value = False
        dom_values = ["USERNAME", ["some cont"], ["some smsToken"], "", "", "", "", ["galx"], "", ""]
        login_values = [("",""), ("some_galx", "some_url_data")]
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"","status":200, "location": "here"}
        sys.modules["__main__"].settings.getSetting.return_value = "smokey" 
        sys.modules["__main__"].common.parseDOM.side_effect = lambda x = "",y = "",attrs = {},ret = "": dom_values.pop()

        login = YouTubeLogin()
        login._fillLoginInfo = Mock()
        login._fillLoginInfo.side_effect = lambda x: login_values.pop()

        result = login._httpLogin({"new":"true"})

        print sys.modules["__main__"].core._fetchPage.call_count
        assert(sys.modules["__main__"].core._fetchPage.call_count == 3)
        print repr(sys.modules["__main__"].core._fetchPage.call_args_list)
        sys.modules["__main__"].core._fetchPage.assert_called_with({'referer': 'here', 'link': 'some cont', 'url_data': {'service': 'youtube', 'GALX': 'some_galx', 'PersistentCookie': 'yes', 'smsToken': 'some smsToken'}})

    def test_httpLogin_should_look_save_cookiejar_on_login_success(self):
        sys.modules["__main__"].core._findErrors.return_value = False
        sys.modules["__main__"].core._fetchPage.return_value = {"content": "logged_in","status":200}
        sys.modules["__main__"].settings.getSetting.return_value = "smokey" 
        sys.modules["__main__"].common.parseDOM.side_effect = [ ["USERNAME"], ["USERNAME"]]
        login = YouTubeLogin()

        result = login._httpLogin({"new":"true"})

        assert(sys.modules["__main__"].core._fetchPage.call_count == 1)
        assert(sys.modules["__main__"].cookiejar.save.call_count == 1)

    def test_httpLogin_should_call_findErrors_on_login_failure(self):
        sys.modules["__main__"].core._findErrors.return_value = False
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"","status":200}
        sys.modules["__main__"].settings.getSetting.return_value = "smokey" 
        sys.modules["__main__"].common.parseDOM.return_value = ""
        login = YouTubeLogin()
        
        result = login._httpLogin({"new":"true"})

        sys.modules["__main__"].core._findErrors.assert_called_with({'content': '', 'status': 200})

    def test_httpLogin_should_fail_with_captcha(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"content":" captcha","status":200}
        sys.modules["__main__"].settings.getSetting.return_value = "smokey" 
        sys.modules["__main__"].common.parseDOM.return_value = ""
        login = YouTubeLogin()
        result = login._httpLogin({"new":"true"})
        print repr(result)
        assert(result == ({'content': ' captcha', 'status': 200},500))

    def test_fillLoginInfo_should_use_parseDOM(self):
        sys.modules["__main__"].pluginsettings.userName.return_value = "value1"
        sys.modules["__main__"].pluginsettings.userPassword.return_value = "value1"
        sys.modules["__main__"].common.parseDOM.side_effect = [["smsToken", "GALX"], ["value2"], ["value2"]]
        login = YouTubeLogin()
        
        result = login._fillLoginInfo({"content": "new", "new_url": "url"})

        assert(sys.modules["__main__"].common.parseDOM.call_count > 0)

    def test_fillLoginInfo_should_get_username_and_passwords_from_pluginsettings(self):
        sys.modules["__main__"].pluginsettings.userName.return_value = "value1"
        sys.modules["__main__"].pluginsettings.userPassword.return_value = "value1"

        sys.modules["__main__"].settings.getSetting.return_value = "smokey"
        sys.modules["__main__"].common.parseDOM.side_effect = [["GALX"], [""]]
        login = YouTubeLogin()
        
        result = login._fillLoginInfo({"content": "new", "new_url": "url"})

        sys.modules["__main__"].pluginsettings.userName.assert_any_call()
        sys.modules["__main__"].pluginsettings.userPassword.assert_any_call()

    def test_fillLoginInfo_should_ask_user_for_password_if_not_set(self):
        sys.modules["__main__"].pluginsettings.userName.return_value = ""
        sys.modules["__main__"].pluginsettings.userPassword.return_value = ""
        sys.modules["__main__"].common.parseDOM.side_effect = [["GALX"], [""]]
        sys.modules["__main__"].language.return_value = "someTitle"
        sys.modules["__main__"].common.getUserInput.return_value = "somePword"
        login = YouTubeLogin()
        
        result = login._fillLoginInfo({"content": "new", "new_url": "url"})

        sys.modules["__main__"].common.getUserInput.assert_any_call('someTitle', hidden=True)

    def test_fillLoginInfo_should_return_login_info_if_all_values_are_found(self):
        sys.modules["__main__"].pluginsettings.userName.return_value = "value1"
        sys.modules["__main__"].pluginsettings.userPassword.return_value = "value1"
        sys.modules["__main__"].common.parseDOM.side_effect = [["uilel", "dsh", "rmShown", "GALX"], ["value2"], ["value2"], ["value2"], ["value2"]]
        sys.modules["__main__"].language.return_value = "someTitle"
        sys.modules["__main__"].common.getUserInput.return_value = "somePword"
        sys.modules["__main__"].common.makeAscii.return_value = "value2"
        login = YouTubeLogin()
        
        (galx, url_data) = login._fillLoginInfo({"content": "new", "new_url": "url"})
        
        assert(galx == "value2")
        assert(url_data["uilel"] == "value2")
        assert(url_data["dsh"] == "value2")
        assert(url_data["rmShown"] == "value2")
        assert(url_data["GALX"] == "value2")
        assert(url_data["Passwd"] == "value1")
        assert(url_data["Email"] == "value1")

    def test_fillLoginInfo_should_not_return_login_info_if_values_are_missing(self):
        sys.modules["__main__"].pluginsettings.userName.return_value = ""
        sys.modules["__main__"].pluginsettings.userPassword.return_value = ""
        sys.modules["__main__"].common.parseDOM.side_effect = [["GALX"], [""]]
        sys.modules["__main__"].language.return_value = "someTitle"
        sys.modules["__main__"].common.getUserInput.return_value = "somePword"
        sys.modules["__main__"].common.makeAscii.return_value = ""
        login = YouTubeLogin()
        
        (galx, url_data) = login._fillLoginInfo({"content": "new", "new_url": "url"})

        print(repr(url_data))

        assert(galx == "")        
        assert(url_data == {'Passwd': 'somePword', 'GALX': '', 'Email': ''})
        
    def test_fillUserPin_should_call_parseDOM_for_smsToken(self):
        sys.modules["__main__"].settings.getSetting.return_value = "" 
        sys.modules["__main__"].common.parseDOM.side_effect = [["form"], ["smsToken"], ["value2"]]
        sys.modules["__main__"].language.return_value = ""
        sys.modules["__main__"].common.getUserInput.return_value = ""
        sys.modules["__main__"].common.getUserInputNumbers.return_value = "123456"
        login = YouTubeLogin()
        
        result = login._fillUserPin("new")

        args = sys.modules["__main__"].common.parseDOM.call_args_list

        print(repr(args))
        assert(args[0][0] == ("new","form"))
        assert(args[2][1] == {'attrs': {'name': 'smsToken'}, 'ret': 'value'})
        
    def test_fillUserPin_should_ask_user_for_user_pin(self):
        sys.modules["__main__"].settings.getSetting.return_value = "" 
        sys.modules["__main__"].common.parseDOM.return_value = "something"
        sys.modules["__main__"].language.return_value = "someTitle"
        sys.modules["__main__"].common.getUserInputNumbers.return_value = "123456"
        login = YouTubeLogin()
        
        result = login._fillUserPin("new")
        
        sys.modules["__main__"].common.getUserInputNumbers.assert_called_with('someTitle')
        
    def test_fillUserPin_should_return_url_data_structure_if_all_values_are_found(self):
        sys.modules["__main__"].settings.getSetting.return_value = "value1" 
        sys.modules["__main__"].common.parseDOM.side_effect = [["form"], ["smsToken"], ["value2"]]
        sys.modules["__main__"].language.return_value = "someTitle"
        sys.modules["__main__"].common.getUserInputNumbers.return_value = "value3"
        sys.modules["__main__"].common.makeAscii.return_value = "value2"

        login = YouTubeLogin()
        
        result = login._fillUserPin("new")
        
        print(repr(result))
        assert(result["smsUserPin"] == "value3")
        assert(result["smsToken"] == "value2")
        
    def test_fillUserPin_should_not_return_url_data_structure_if_values_are_missing(self):
        sys.modules["__main__"].settings.getSetting.return_value = ""
        sys.modules["__main__"].common.parseDOM.return_value = ""
        sys.modules["__main__"].language.return_value = ""
        sys.modules["__main__"].common.getUserInput.return_value = ""
        sys.modules["__main__"].common.getUserInputNumbers.return_value = ""
        login = YouTubeLogin()
        
        result = login._fillUserPin("new")

        assert(result == {})                

if __name__ == '__main__':
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubeNavigation
# -*- coding: utf-8 -*-
import nose
import BaseTestCase
from mock import Mock
import sys
from YouTubeNavigation import YouTubeNavigation

class TestYouTubeNavigation(BaseTestCase.BaseTestCase):

    def test_listMenu_should_traverse_menustructure_correctly(self):
        sys.argv = ["something", -1, "something_else"]
        sys.modules["__main__"].settings.getSetting.return_value = "true"
        navigation = YouTubeNavigation()
        navigation.list = Mock()
        navigation.addListItem = Mock()
        navigation.listMenu()

        args = navigation.addListItem.call_args_list
        print repr(args)
        for arg in args:
                assert(arg[0][1]["path"].replace('/root/', '').find('/') < 0)
        assert(navigation.addListItem.call_count > 1)

    def test_listMenu_should_only_list_subfolders_to_a_path(self):
        sys.argv = ["something", -1, "something_else"]
        list = ["", "", "", ""]
        sys.modules["__main__"].settings.getSetting.side_effect = lambda x: list.pop()
        navigation = YouTubeNavigation()
        navigation.categories = ({"path": "/root/my_first_level"}, {"path": "/root/my_first_level/my_second_level"}, {"path": "/root/my_other_first_level"}, {"path": "/root/my_other_first_level/my_other_second_level"})
        navigation.list = Mock()
        navigation.addListItem = Mock()
        navigation.listMenu({"path": "/root/my_first_level"})

        navigation.addListItem.assert_called_with({"path": "/root/my_first_level"}, {"path": "/root/my_first_level/my_second_level"})

    def test_listMenu_should_use_visibility_from_settings_to_decide_if_items_are_displayed(self):
        sys.argv = ["something", -1, "something_else"]
        list = ["false", "true", "false", "true"]
        sys.modules["__main__"].settings.getSetting.side_effect = lambda x: list.pop()
        navigation = YouTubeNavigation()
        navigation.categories = ({"path": "/root/my_first_level"}, {"path": "/root/my_first_level/my_second_level1"}, {"path": "/root/my_first_level/my_second_level2"}, {"path": "/root/my_first_level/my_second_level3"})
        navigation.list = Mock()
        navigation.addListItem = Mock()
        navigation.listMenu({"path": "/root/my_first_level"})

        navigation.addListItem.assert_any_call({"path": "/root/my_first_level"}, {"path": "/root/my_first_level/my_second_level1"})
        navigation.addListItem.assert_any_call({"path": "/root/my_first_level"}, {"path": "/root/my_first_level/my_second_level3"})

    def test_listMenu_should_check_if_download_path_is_set_to_decide_if_download_folder_is_visible(self):
        sys.argv = ["something", -1, "something_else"]
        list = ["true", "true", "true", "", "true"]
        sys.modules["__main__"].settings.getSetting.side_effect = lambda x: list.pop()
        navigation = YouTubeNavigation()
        navigation.categories = ({"path": "/root/my_first_level/my_second_level1", "feed": "downloads"}, {"path": "/root/my_first_level/my_second_level2", "feed": "downloads"})
        navigation.list = Mock()
        navigation.addListItem = Mock()
        navigation.listMenu({"path": "/root/my_first_level"})
        
        navigation.addListItem.assert_called_with({"path": "/root/my_first_level"}, {"path": "/root/my_first_level/my_second_level2", "feed": "downloads"})
        
    def test_listMenu_should_call_list_if_feed_in_params(self):
        sys.argv = ["something", -1, "something_else"]
        navigation = YouTubeNavigation()
        navigation.list = Mock()
        navigation.addListItem = Mock()
        navigation.listMenu({"path": "/root/some_other_path", "feed": "some_feed"})
        
        navigation.list.assert_called_with({"path": "/root/some_other_path", "feed": "some_feed"})
        
    def test_listMenu_should_call_list_if_user_feed_in_params(self):
        sys.argv = ["something", -1, "something_else"]
        navigation = YouTubeNavigation()
        navigation.list = Mock()
        navigation.addListItem = Mock()
        navigation.listMenu({"path": "/root/some_other_path", "user_feed": "some_feed"})
        
        navigation.list.assert_called_with({"path": "/root/some_other_path", "user_feed": "some_feed"})
        
    def test_listMenu_should_call_list_if_options_in_params(self):
        sys.argv = ["something", -1, "something_else"]
        navigation = YouTubeNavigation()
        navigation.list = Mock()
        navigation.addListItem = Mock()
        navigation.listMenu({"path": "/root/some_other_path", "options": "some_options"})
        
        navigation.list.assert_called_with({"path": "/root/some_other_path", "options": "some_options"})
        
    def test_listMenu_should_call_list_if_store_in_params(self):
        sys.argv = ["something", -1, "something_else"]
        navigation = YouTubeNavigation()
        navigation.list = Mock()
        navigation.addListItem = Mock()
        navigation.listMenu({"path": "/root/some_other_path", "store": "some_store"})
        
        navigation.list.assert_called_with({"path": "/root/some_other_path", "store": "some_store"})
        
    def test_listMenu_should_call_list_if_scraper_in_params(self):
        sys.argv = ["something", -1, "something_else"]
        navigation = YouTubeNavigation()
        navigation.list = Mock()
        navigation.addListItem = Mock()
        navigation.listMenu({"path": "/root/some_other_path", "scraper": "some_scraper"})
        
        navigation.list.assert_called_with({"path": "/root/some_other_path", "scraper": "some_scraper"})
        
    def test_listMenu_should_call_settings_getSetting_to_get_listview(self):
        sys.argv = ["something", -1, "something_else"]
        navigation = YouTubeNavigation()
        navigation.list = Mock()
        navigation.addListItem = Mock()
        navigation.listMenu({"path": "/root/some_other_path"})
        
        sys.modules["__main__"].settings.getSetting.assert_called_with("list_view")

    def test_listMenu_should_call_xbmc_executeBuiltin_correctly_if_list_view_is_set(self):
        sys.argv = ["something", -1, "something_else"]
        settings = ["1", "true", "1"]
        sys.modules["__main__"].settings.getSetting.side_effect = lambda x: settings.pop()
        navigation = YouTubeNavigation()
        navigation.list = Mock()
        navigation.addListItem = Mock()
        
        navigation.listMenu({"path": "/root/some_other_path"})
        
        sys.modules["__main__"].xbmc.executebuiltin.assert_called_with('Container.SetViewMode(500)')
        
    def test_listMenu_should_call_xbmc_plugin_end_of_directory_correctly(self):
        sys.argv = ["something", -1, "something_else"]
        settings = ["1", "true", "1"]
        sys.modules["__main__"].settings.getSetting.side_effect = lambda x: settings.pop()
        navigation = YouTubeNavigation()
        navigation.list = Mock()
        navigation.addListItem = Mock()
        
        navigation.listMenu({"path": "/root/some_other_path"})
        
        sys.modules["__main__"].xbmcplugin.endOfDirectory.assert_called_with(cacheToDisc=True, handle=-1, succeeded=True)

    def test_executeAction_should_call_login_login_if_action_is_settings(self):
        navigation = YouTubeNavigation()
        
        navigation.executeAction({"action": "settings"})
        
        sys.modules["__main__"].login.login.assert_called_with({"action": "settings"})

    def test_executeAction_should_call_storage_deleteStoredSearch_if_action_is_delete_search(self):
        navigation = YouTubeNavigation()
        
        navigation.executeAction({"action": "delete_search"})
        
        sys.modules["__main__"].storage.deleteStoredSearch.assert_called_with({"action": "delete_search"})

    def test_executeAction_should_call_storage_deleteStoredSearch_if_action_is_delete_disco(self):
        navigation = YouTubeNavigation()
        
        navigation.executeAction({"action": "delete_disco"})
        
        sys.modules["__main__"].storage.deleteStoredSearch.assert_called_with({"action": "delete_disco"})

    def test_executeAction_should_call_storage_editStoredSearch_if_action_is_edit_search(self):
        navigation = YouTubeNavigation()
        navigation.listMenu = Mock()
        
        navigation.executeAction({"action": "edit_search"})
        
        sys.modules["__main__"].storage.editStoredSearch.assert_called_with({"action": "edit_search"})

    def test_executeAction_should_call_storage_editStoredSearch_if_action_is_edit_disco(self):
        navigation = YouTubeNavigation()
        navigation.listMenu = Mock()
        
        navigation.executeAction({"action": "edit_disco"})
        
        sys.modules["__main__"].storage.editStoredSearch.assert_called_with({"action": "edit_disco"})

    def test_executeAction_should_call_listMenu_if_action_is_edit_search(self):
        navigation = YouTubeNavigation()
        navigation.listMenu = Mock()
        
        navigation.executeAction({"action": "edit_search"})
        
        navigation.listMenu.assert_called_with({"action": "edit_search"})

    def test_executeAction_should_call_listMenu_if_action_is_edit_disco(self):
        navigation = YouTubeNavigation()
        navigation.listMenu = Mock()
        
        navigation.executeAction({"action": "edit_disco"})
        
        navigation.listMenu.assert_called_with({"action": "edit_disco"})

    def test_executeAction_should_call_removeFromFavorites_if_action_is_remove_favorite(self):
        navigation = YouTubeNavigation()
        navigation.removeFromFavorites = Mock()
        
        navigation.executeAction({"action": "remove_favorite"})
        
        navigation.removeFromFavorites.assert_called_with({"action": "remove_favorite"})        

    def test_executeAction_should_call_addToFavorites_if_action_is_add_favorite(self):
        navigation = YouTubeNavigation()
        navigation.addToFavorites = Mock()
        
        navigation.executeAction({"action": "add_favorite"})
        
        navigation.addToFavorites.assert_called_with({"action": "add_favorite"})        

    def test_executeAction_should_call_removeContact_if_action_is_remove_contact(self):
        navigation = YouTubeNavigation()
        navigation.removeContact = Mock()
        
        navigation.executeAction({"action": "remove_contact"})
        
        navigation.removeContact.assert_called_with({"action": "remove_contact"})

    def test_executeAction_should_call_addContact_if_action_is_add_contact(self):
        navigation = YouTubeNavigation()
        navigation.addContact = Mock()
        
        navigation.executeAction({"action": "add_contact"})
        
        navigation.addContact.assert_called_with({"action": "add_contact"})

    def test_executeAction_should_call_removeSubscription_if_action_is_remove_subscription(self):
        navigation = YouTubeNavigation()
        navigation.removeSubscription = Mock()
        
        navigation.executeAction({"action": "remove_subscription"})
        
        navigation.removeSubscription.assert_called_with({"action": "remove_subscription"})

    def test_executeAction_should_call_addSubscription_if_action_is_add_subscription(self):
        navigation = YouTubeNavigation()
        navigation.addSubscription = Mock()
        
        navigation.executeAction({"action": "add_subscription"})
        
        navigation.addSubscription.assert_called_with({"action": "add_subscription"})

    def test_executeAction_should_call_downloader_downloadVideo_if_action_is_download(self):
        navigation = YouTubeNavigation()
        navigation.downloadVideo = Mock()

        navigation.executeAction({"action": "download"})

        navigation.downloadVideo.assert_called_with({'action': 'download'})

    def test_downloadVideo_should_exit_cleanly_if_download_path_is_not_set(self):
        sys.modules["__main__"].settings.getSetting.return_value = ""
        navigation = YouTubeNavigation()

        navigation.downloadVideo({"action": "download"})

        assert (sys.modules["__main__"].player.buildVideoObject.call_count == 0)
        assert (sys.modules["__main__"].downloader.download.call_count == 0)

    def test_downloadVideo_should_notify_user_if_download_path_is_not_set(self):
        sys.modules["__main__"].settings.getSetting.return_value = ""
        navigation = YouTubeNavigation()

        navigation.downloadVideo({"action": "download"})

        assert (sys.modules["__main__"].utils.showMessage.call_count == 1)

    def test_downloadVideo_should_open_settings_module_so_user_can_enter_new_download_path_if_download_path_is_not_set(self):
        sys.modules["__main__"].settings.getSetting.return_value = ""
        navigation = YouTubeNavigation()

        navigation.downloadVideo({"action": "download"})

        assert (sys.modules["__main__"].settings.openSettings.call_count == 1)

    def test_downloadVideo_should_call_downloader_downloadVideo_if_action_is_download(self):
        sys.modules["__main__"].player.buildVideoObject = Mock()
        sys.modules["__main__"].player.buildVideoObject.return_value = ({"videoid": "ytvideo1", "video_url": "Mock url", "Title": "Mock Title" }, "mock" )
        sys.modules["__main__"].settings.getSetting.return_value = "some_path"
        navigation = YouTubeNavigation()

        navigation.downloadVideo({"action": "download"})

        sys.modules["__main__"].downloader.download.assert_called_with("Mock Title-[ytvideo1].mp4", {'action': 'download', 'url': 'Mock url', "download_path": "some_path", "Title": "Mock Title"})

    def test_executeAction_should_call_player_playVideo_if_action_is_play_video(self):
        navigation = YouTubeNavigation()
        
        navigation.executeAction({"action": "play_video"})
        
        sys.modules["__main__"].player.playVideo.assert_called_with({"action": "play_video"})

    def test_executeAction_should_call_playlist_queueVideo_if_action_is_queue_video(self):
        navigation = YouTubeNavigation()
        
        navigation.executeAction({"action": "queue_video"})
        
        sys.modules["__main__"].playlist.queueVideo.assert_called_with({"action": "queue_video"})

    def test_executeAction_should_call_storage_changeSubscriptionView_if_action_is_change_subscription_view(self):
        navigation = YouTubeNavigation()
        navigation.list = Mock()
        navigation.executeAction({"action": "change_subscription_view"})
        
        sys.modules["__main__"].storage.changeSubscriptionView.assert_called_with({"action": "change_subscription_view"})

    def test_executeAction_should_call_list_if_action_is_change_subscription_view(self):
        navigation = YouTubeNavigation()
        navigation.list = Mock()
        navigation.executeAction({"action": "change_subscription_view"})
        
        navigation.list.assert_called_with({"action": "change_subscription_view"})

    def test_executeAction_should_call_playlist_playAll_if_action_is_play_all(self):
        navigation = YouTubeNavigation()
        
        navigation.executeAction({"action": "play_all"})
        
        sys.modules["__main__"].playlist.playAll.assert_called_with({"action": "play_all"})

    def test_executeAction_should_call_playlist_addToPlaylist_if_action_is_add_to_playlist(self):
        navigation = YouTubeNavigation()
        
        navigation.executeAction({"action": "add_to_playlist"})
        
        sys.modules["__main__"].playlist.addToPlaylist.assert_called_with({"action": "add_to_playlist"})

    def test_executeAction_should_call_playlist_removeFromPlaylist_if_action_is_remove_from_playlist(self):
        navigation = YouTubeNavigation()
        
        navigation.executeAction({"action": "remove_from_playlist"})
        
        sys.modules["__main__"].playlist.removeFromPlaylist.assert_called_with({"action": "remove_from_playlist"})

    def test_executeAction_should_call_playlist_deletePlaylist_if_action_is_delete_playlist(self):
        navigation = YouTubeNavigation()
        
        navigation.executeAction({"action": "delete_playlist"})
        
        sys.modules["__main__"].playlist.deletePlaylist.assert_called_with({"action": "delete_playlist"})

    def test_executeAction_should_call_playlist_createPlaylist_if_action_is_create_playlist(self):
        navigation = YouTubeNavigation()
        
        navigation.executeAction({"action": "create_playlist"})
        
        sys.modules["__main__"].playlist.createPlaylist.assert_called_with({"action": "create_playlist"})

    def test_executeAction_should_call_storage_reversePlaylistOrder_if_action_is_reverse_order(self):
        navigation = YouTubeNavigation()
        
        navigation.executeAction({"action": "reverse_order"})
        
        sys.modules["__main__"].storage.reversePlaylistOrder.assert_called_with({"action": "reverse_order"})

    def test_list_should_ask_user_for_input_if_feed_is_search_and_search_is_missing_from_params(self):
        sys.modules["__main__"].feeds.list.return_value = ([],200)
        sys.modules["__main__"].language.return_value = "some_string"
        navigation = YouTubeNavigation()
        navigation.parseVideoList = Mock()
        navigation.parseFolderList = Mock()
        navigation.showListingError = Mock()
        
        navigation.list({"feed": "search"})
        
        sys.modules["__main__"].common.getUserInput.assert_called_with("some_string", "")

    def test_list_should_ask_user_for_input_if_scraper_is_search_disco_and_search_is_missing_from_params(self):
        sys.modules["__main__"].scraper.scrape.return_value = ([],200)
        sys.modules["__main__"].language.return_value = "some_string"
        navigation = YouTubeNavigation()
        navigation.parseVideoList = Mock()
        navigation.parseFolderList = Mock()
        navigation.showListingError = Mock()
        
        navigation.list({"scraper": "search_disco"})
        
        sys.modules["__main__"].common.getUserInput.assert_called_with("some_string", "")

    def test_list_should_call_storage_saveStoredSearch_if_feed_is_search(self):
        sys.modules["__main__"].feeds.list.return_value = ([],200)
        sys.modules["__main__"].language.return_value = "some_string"
        sys.modules["__main__"].common.getUserInput.return_value = "some_user_string"
        navigation = YouTubeNavigation()
        navigation.parseVideoList = Mock()
        navigation.parseFolderList = Mock()
        navigation.showListingError = Mock()
        
        navigation.list({"feed": "search"})
        
        sys.modules["__main__"].storage.saveStoredSearch.assert_called_with({"feed": "search", "search": "some_user_string"})

    def test_list_should_call_storage_saveStoredSearch_if_scraper_is_search_disco(self):
        sys.modules["__main__"].scraper.scrape.return_value = ([],200)
        sys.modules["__main__"].language.return_value = "some_string"
        sys.modules["__main__"].common.getUserInput.return_value = "some_user_string"
        navigation = YouTubeNavigation()
        navigation.parseVideoList = Mock()
        navigation.parseFolderList = Mock()
        navigation.showListingError = Mock()
        
        navigation.list({"scraper": "search_disco"})
        
        sys.modules["__main__"].storage.saveStoredSearch.assert_called_with({"scraper": "search_disco", "search": "some_user_string"})

    def test_list_should_call_scraper_scrape_if_scraper_is_in_params(self):
        sys.modules["__main__"].scraper.scrape.return_value = ([],200)
        navigation = YouTubeNavigation()
        navigation.parseVideoList = Mock()
        navigation.parseFolderList = Mock()
        navigation.showListingError = Mock()
        
        navigation.list({"scraper": "some_scraper"})
        
        sys.modules["__main__"].scraper.scrape.assert_called_with({"scraper": "some_scraper"})

    def test_list_should_call_storage_list_if_store_is_in_params(self):
        sys.modules["__main__"].storage.list.return_value = ([],200)
        navigation = YouTubeNavigation()
        navigation.parseVideoList = Mock()
        navigation.parseFolderList = Mock()
        navigation.showListingError = Mock()
        
        navigation.list({"store": "some_store"})
        
        sys.modules["__main__"].storage.list.assert_called_with({"store": "some_store"})
        
    def test_list_should_call_feeds_list_if_neither_store_or_scraper_is_in_params(self):
        sys.modules["__main__"].feeds.list.return_value = ([],200)
        navigation = YouTubeNavigation()
        navigation.parseVideoList = Mock()
        navigation.parseFolderList = Mock()
        navigation.showListingError = Mock()
        
        navigation.list({})
        
        sys.modules["__main__"].feeds.list.assert_called_with({})
        
    def test_list_should_call_parseFolderList_if_list_was_successfull_and_folder_is_in_params(self):
        sys.modules["__main__"].feeds.list.return_value = ([],200)
        navigation = YouTubeNavigation()
        navigation.parseVideoList = Mock()
        navigation.parseFolderList = Mock()
        navigation.showListingError = Mock()
        
        navigation.list({"folder": "true"})
        
        navigation.parseFolderList.assert_called_with({"folder": "true"},[])
        
    def test_list_should_call_parseVideoList_if_list_was_successfull_and_folder_is_not_in_params(self):
        sys.modules["__main__"].feeds.list.return_value = ([],200)
        navigation = YouTubeNavigation()
        navigation.parseVideoList = Mock()
        navigation.parseFolderList = Mock()
        navigation.showListingError = Mock()
        
        navigation.list({})
        
        navigation.parseVideoList.assert_called_with({},[])        
        
    def test_list_should_call_showListingError_if_list_was_unsuccessfull(self):
        sys.modules["__main__"].feeds.list.return_value = ([],303)
        navigation = YouTubeNavigation()
        navigation.parseVideoList = Mock()
        navigation.parseFolderList = Mock()
        navigation.showListingError = Mock()
        
        navigation.list({})
        
        navigation.showListingError.assert_called_with({})        
        
    def test_showListingError_should_search_categories_for_folder_name_if_external_is_not_in_params(self):
        sys.modules["__main__"].language.return_value = "some_string"
        navigation = YouTubeNavigation()
        navigation.categories = ({"feed": "my_feed", "Title": "my_category_title"}, {"feed": "not_my_feed", "Title": "not_my_category_title"})
        
        navigation.showListingError({"feed": "my_feed"})
        
        sys.modules["__main__"].utils.showMessage.assert_called_with("my_category_title", "some_string")
                
    def test_showListingError_should_search_storage_user_options_if_external_is_in_params(self):
        sys.modules["__main__"].language.return_value = "some_string"
        sys.modules["__main__"].storage.user_options = ({"feed": "my_feed", "Title": "my_options_title"}, {"feed": "not_my_feed", "Title": "not_my_options_title"})
        navigation = YouTubeNavigation()
        
        navigation.showListingError({"feed": "my_feed", "external": "true"})
        
        sys.modules["__main__"].utils.showMessage.assert_called_with("my_options_title", "some_string")
                
    def test_showListingError_should_use_channel_title_if_channel_is_in_params(self):
        sys.modules["__main__"].language.return_value = "some_string"
        navigation = YouTubeNavigation()
        navigation.categories = ({"feed": "my_feed", "Title": "my_category_title"}, {"feed": "not_my_feed", "Title": "not_my_category_title"})
        
        navigation.showListingError({"feed": "my_feed", "channel": "some_channel_title"})
        
        sys.modules["__main__"].utils.showMessage.assert_called_with("some_channel_title", "some_string")
        
    def test_showListingError_should_use_language_string_if_playlist_is_in_params(self):
        sys.modules["__main__"].language.return_value = "some_string"
        navigation = YouTubeNavigation()
        navigation.categories = ({"feed": "my_feed", "Title": "my_category_title"}, {"feed": "not_my_feed", "Title": "not_my_category_title"})
        
        navigation.showListingError({"feed": "my_feed", "playlist": "some_playlist"})
        
        sys.modules["__main__"].utils.showMessage.assert_called_with("some_string", "some_string")
        sys.modules["__main__"].language.assert_any_call(30615)
        sys.modules["__main__"].language.assert_any_call(30601)
        
    def test_showListingError_should_call_utils_showMessage_correctly(self):
        sys.modules["__main__"].language.return_value = "some_string"
        navigation = YouTubeNavigation()
        navigation.categories = ({"feed": "my_feed", "Title": "my_category_title"}, {"feed": "not_my_feed", "Title": "not_my_category_title"})
        
        navigation.showListingError({"feed": "my_feed"})
        
        sys.modules["__main__"].utils.showMessage.assert_called_with("my_category_title", "some_string")
                
    def test_addToFavorites_should_exit_cleanly_if_video_id_is_missing(self):
        navigation = YouTubeNavigation()
        
        navigation.addToFavorites()
        
        assert(sys.modules["__main__"].core.add_favorite.call_count == 0)
        assert(sys.modules["__main__"].utils.showErrorMessage.call_count == 0)
        
    def test_addToFavorites_should_call_core_add_favorite(self):
        sys.modules["__main__"].core.add_favorite.return_value = ("",303)
        sys.modules["__main__"].language.return_value = "some_title"
        navigation = YouTubeNavigation()
        
        navigation.addToFavorites({"videoid": "some_id"})
        
        sys.modules["__main__"].core.add_favorite.assert_called_with({"videoid": "some_id"})
        
    def test_addToFavorites_should_show_error_message_on_failure(self):
        sys.modules["__main__"].core.add_favorite.return_value = ("",303)
        sys.modules["__main__"].language.return_value = "some_title"
        navigation = YouTubeNavigation()
        
        navigation.addToFavorites({"videoid": "some_id"})
        
        sys.modules["__main__"].utils.showErrorMessage.assert_called_with("some_title", "",303)
        sys.modules["__main__"].language.assert_called_with(30020)
        
    def test_removeFromFavorites_should_exit_cleanly_if_editid_is_missing(self):
        navigation = YouTubeNavigation()
        
        navigation.removeFromFavorites()
        
        assert(sys.modules["__main__"].core.delete_favorite.call_count == 0)
        assert(sys.modules["__main__"].utils.showErrorMessage.call_count == 0)        
        
    def test_removeFromFavorites_should_call_core_delete_favorite(self):
        sys.modules["__main__"].core.delete_favorite.return_value = ("",200)
        navigation = YouTubeNavigation()
        
        navigation.removeFromFavorites({"editid": "some_id"})
        
        sys.modules["__main__"].core.delete_favorite.assert_called_with({"editid": "some_id"})
        
    def test_removeFromFavorites_should_show_error_message_on_failure(self):
        sys.modules["__main__"].core.delete_favorite.return_value = ("",303)
        sys.modules["__main__"].language.return_value = "some_title"
        navigation = YouTubeNavigation()
        
        navigation.removeFromFavorites({"editid": "some_id"})
        
        sys.modules["__main__"].utils.showErrorMessage.assert_called_with("some_title", "",303)
        sys.modules["__main__"].language.assert_called_with(30020)
                
    def test_addContact_should_ask_user_for_contact_name_if_missing(self):
        navigation = YouTubeNavigation()
        sys.modules["__main__"].language.return_value = "some_title"
        sys.modules["__main__"].common.getUserInput.return_value = ""
        
        navigation.addContact()
        
        sys.modules["__main__"].common.getUserInput.assert_called_with("some_title", "")
        
    def test_addContact_should_call_core_add_contact(self):
        navigation = YouTubeNavigation()
        sys.modules["__main__"].core.add_contact.return_value = ("", 200)
        sys.modules["__main__"].language.return_value = "some_title"
        
        navigation.addContact({"contact": "some_contact"})
        
        sys.modules["__main__"].core.add_contact.assert_called_with({"contact": "some_contact"})
        
    def test_addContact_should_exit_cleanly_if_contact_is_missing_and_no_contact_is_given(self):
        navigation = YouTubeNavigation()
        sys.modules["__main__"].language.return_value = "some_title"
        sys.modules["__main__"].common.getUserInput.return_value = ""
        
        navigation.addContact()
        
        assert(sys.modules["__main__"].core.add_contact.call_count == 0)
        assert(sys.modules["__main__"].utils.showErrorMessage.call_count == 0)        
        sys.modules["__main__"].common.getUserInput.assert_called_with("some_title", "")
        
    def test_addContact_should_show_error_message_on_failure(self):
        sys.modules["__main__"].core.add_contact.return_value = ("", 303)
        sys.modules["__main__"].language.return_value = "some_title"
        navigation = YouTubeNavigation()
        
        navigation.addContact({"contact": "some_contact"})
        
        sys.modules["__main__"].utils.showErrorMessage.assert_called_with("some_title", "",303)
        sys.modules["__main__"].language.assert_any_call(30029)
        
    def test_addContact_should_show_success_message_on_success(self):
        sys.modules["__main__"].core.add_contact.return_value = ("", 200)
        sys.modules["__main__"].language.return_value = "some_title"
        navigation = YouTubeNavigation()
        
        navigation.addContact({"contact": "some_contact"})
        
        sys.modules["__main__"].utils.showMessage.assert_called_with("some_title", "some_contact")
        sys.modules["__main__"].language.assert_any_call(30013)
        
    def test_addContact_should_call_xbmc_executebuiltin_on_success(self):
        sys.modules["__main__"].core.add_contact.return_value = ("", 200)
        sys.modules["__main__"].language.return_value = "some_title"
        navigation = YouTubeNavigation()
        
        navigation.addContact({"contact": "some_contact"})
        
        sys.modules["__main__"].xbmc.executebuiltin.assert_called_with('Container.Refresh')
                
    def test_removeContact_should_exit_cleanly_if_contact_is_missing(self):
        navigation = YouTubeNavigation()
        
        navigation.removeContact()
        
        assert(sys.modules["__main__"].core.remove_contact.call_count == 0)
        assert(sys.modules["__main__"].utils.showErrorMessage.call_count == 0)        
        
    def test_removeContact_should_call_core_remove_contact(self):
        sys.modules["__main__"].core.remove_contact.return_value = ("", 200)
        navigation = YouTubeNavigation()
        
        navigation.removeContact({"contact": "some_contact"})
        
        sys.modules["__main__"].core.remove_contact.assert_called_with({"contact": "some_contact"})
        
    def test_removeContact_should_show_error_message_on_failure(self):
        sys.modules["__main__"].core.remove_contact.return_value = ("", 303)
        sys.modules["__main__"].language.return_value = "some_title"
        navigation = YouTubeNavigation()
        
        navigation.removeContact({"contact": "some_contact"})
        
        sys.modules["__main__"].utils.showErrorMessage.assert_called_with("some_title", "",303)
        sys.modules["__main__"].language.assert_any_call(30029)
        
    def test_removeContact_should_show_success_message_on_success(self):
        sys.modules["__main__"].core.remove_contact.return_value = ("", 200)
        sys.modules["__main__"].language.return_value = "some_title"
        navigation = YouTubeNavigation()
        
        navigation.removeContact({"contact": "some_contact"})
        
        sys.modules["__main__"].utils.showMessage.assert_called_with("some_title", "some_contact")
        sys.modules["__main__"].language.assert_any_call(30013)
        
    def test_removeContact_should_call_xbmc_execute_builtin_on_success(self):
        sys.modules["__main__"].core.remove_contact.return_value = ("", 200)
        sys.modules["__main__"].language.return_value = "some_title"
        navigation = YouTubeNavigation()
        
        navigation.removeContact({"contact": "some_contact"})

        sys.modules["__main__"].xbmc.executebuiltin.assert_called_with('Container.Refresh')        
        
    def test_removeSubscription_should_exit_cleanly_if_editid_is_missing(self):
        navigation = YouTubeNavigation()
        
        navigation.removeSubscription()
        
        assert(sys.modules["__main__"].core.remove_subscription.call_count == 0)
        assert(sys.modules["__main__"].utils.showErrorMessage.call_count == 0)        
        
    def test_removeSubscription_should_call_core_remove_subscription(self):
        navigation = YouTubeNavigation()
        sys.modules["__main__"].core.remove_subscription.return_value = ("",200)
        
        navigation.removeSubscription({"editid": "some_editid"})
        
        sys.modules["__main__"].core.remove_subscription.assert_called_with({"editid": "some_editid"})
        
    def test_removeSubscription_should_show_error_message_on_failure(self):
        navigation = YouTubeNavigation()
        sys.modules["__main__"].language.return_value = "some_message"
        sys.modules["__main__"].core.remove_subscription.return_value = ("",303)
        
        navigation.removeSubscription({"editid": "some_editid"})
        
        sys.modules["__main__"].utils.showErrorMessage.assert_called_with("some_message", "",303)
        sys.modules["__main__"].language.assert_called_with(30021)
        
    def test_removeSubscription_should_call_xbmc_execute_builtin_on_success(self):
        navigation = YouTubeNavigation()
        sys.modules["__main__"].core.remove_subscription.return_value = ("",200)
        
        navigation.removeSubscription({"editid": "some_editid"})
        
        sys.modules["__main__"].xbmc.executebuiltin.assert_called_with('Container.Refresh')
        
    def test_addSubscription_should_exit_cleanly_if_channel_is_missing(self):
        navigation = YouTubeNavigation()
        
        navigation.addSubscription()
        
        assert(sys.modules["__main__"].core.add_subscription.call_count == 0)
        assert(sys.modules["__main__"].utils.showErrorMessage.call_count == 0)
        
    def test_addSubscription_should_call_core_add_subscription(self):
        navigation = YouTubeNavigation()
        sys.modules["__main__"].core.add_subscription.return_value = ("",200)
        
        navigation.addSubscription({"channel": "some_channel"})
        
        sys.modules["__main__"].core.add_subscription.assert_called_with({"channel": "some_channel"})
        
    def test_addSubscription_should_show_error_message_on_failure(self):
        navigation = YouTubeNavigation()
        sys.modules["__main__"].language.return_value = "some_message"
        sys.modules["__main__"].core.add_subscription.return_value = ("",303)
        
        navigation.addSubscription({"channel": "some_channel"})
        
        sys.modules["__main__"].utils.showErrorMessage.assert_called_with("some_message", "",303)
        sys.modules["__main__"].language.assert_called_with(30021)
        
    def test_addListItem_should_call_addFolderListItem_if_item_is_not_an_action_and_doesnt_require_login(self):
        sys.modules["__main__"].settings.getSetting.return_value = ""
        navigation = YouTubeNavigation()
        navigation.addFolderListItem = Mock()
        
        navigation.addListItem({}, {"feed": "some_feed", "login": "false"})
        
        navigation.addFolderListItem.assert_called_with({}, {"feed": "some_feed", "login": "false"})
        
    def test_addListItem_should_call_addFolderListItem_if_item_is_not_an_action__requires_login_and_user_is_logged_in(self):
        sys.modules["__main__"].settings.getSetting.return_value = "some_token"
        navigation = YouTubeNavigation()
        navigation.addFolderListItem = Mock()
        
        navigation.addListItem({}, {"feed": "some_feed", "login": "true"})
        
        navigation.addFolderListItem.assert_called_with({}, {"feed": "some_feed", "login": "true"})
        
    def test_addListItem_should_call_addActionListItem_if_item_action_is_settings_user_is_logged_in_and_item_requires_login(self):
        sys.modules["__main__"].settings.getSetting.return_value = "some_token"
        navigation = YouTubeNavigation()
        navigation.addActionListItem = Mock()
        
        navigation.addListItem({}, {"action": "settings", "login": "true"})
        
        navigation.addActionListItem.assert_called_with({}, {"action": "settings", "login": "true"})
        
    def test_addListItem_should_call_addActionListItem_if_item_action_is_settings_user_is_not_logged_in_and_item_doesnt_require_login(self):
        sys.modules["__main__"].settings.getSetting.return_value = ""
        navigation = YouTubeNavigation()
        navigation.addActionListItem = Mock()
        
        navigation.addListItem({}, {"action": "settings", "login": "false"})
        
        navigation.addActionListItem.assert_called_with({}, {"action": "settings", "login": "false"})
        
    def test_addListItem_should_call_addVideoListItem_if_item_action_is_play_video(self):
        navigation = YouTubeNavigation()
        navigation.addVideoListItem = Mock()
        
        navigation.addListItem({}, {"action": "play_video"})
        
        navigation.addVideoListItem.assert_called_with({}, {"action": "play_video"}, 0)
        
    def test_addListItem_should_call_addActionListItem_if_item_has_action(self):
        navigation = YouTubeNavigation()
        navigation.addActionListItem = Mock()
        
        navigation.addListItem({}, {"action": "some_action"})
        
        navigation.addActionListItem.assert_called_with({}, {"action": "some_action"})
        
    def test_addFolderListItem_should_call_utils_get_thumbnail_to_get_icon_path(self):
        sys.argv = ["some_path", -1, "some_params"]
        navigation = YouTubeNavigation()
        navigation.addFolderContextMenuItems = Mock()
        navigation.addFolderContextMenuItems.return_value = []
        
        navigation.addFolderListItem({}, {"action": "some_action", "icon": "some_icon"})
        
        sys.modules["__main__"].utils.getThumbnail("some_icon")
        
    def test_addFolderListItem_should_call_addFolderContextMenuItems_to_get_context_menu_items(self):
        sys.argv = ["some_path", -1, "some_params"]
        navigation = YouTubeNavigation()
        navigation.addFolderContextMenuItems = Mock()
        navigation.addFolderContextMenuItems.return_value = []
        
        navigation.addFolderListItem({}, {"action": "some_action", "icon": "some_icon"})
        
        navigation.addFolderContextMenuItems.assert_called_with({}, {"action": "some_action", "icon": "some_icon"})
        
    def test_addFolderListItem_should_call_utils_get_thumbnail_to_get_thumbnail_path(self):
        sys.argv = ["some_path", -1, "some_params"]
        navigation = YouTubeNavigation()
        navigation.addFolderContextMenuItems = Mock()
        navigation.addFolderContextMenuItems.return_value = []
        
        navigation.addFolderListItem({}, {"action": "some_action", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].utils.getThumbnail.assert_called_with("some_thumbnail")
        
    def test_addFolderListItem_should_call_xbmcgui_ListItem_to_fetch_xbmc_listitem_object(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        navigation.addFolderContextMenuItems = Mock()
        navigation.addFolderContextMenuItems.return_value = []
        
        navigation.addFolderListItem({}, {"action": "some_action", "Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].xbmcgui.ListItem.assert_called_with("some_title",iconImage='some_image_path', thumbnailImage='some_image_path')
        
    def test_addFolderListItem_should_call_utils_buildItemUrl_to_get_proper_item_url(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        navigation.addFolderContextMenuItems = Mock()
        navigation.addFolderContextMenuItems.return_value = []
        
        navigation.addFolderListItem({}, {"action": "some_action", "Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].utils.buildItemUrl({"action": "some_action", "Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
    def test_addFolderListItem_should_call_listitem_addContextMenuItems_to_add_context_menu(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        navigation.addFolderContextMenuItems = Mock()
        navigation.addFolderContextMenuItems.return_value = [1,2]
        
        navigation.addFolderListItem({}, {"action": "some_action", "Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].xbmcgui.ListItem().addContextMenuItems.assert_called_with([1,2],replaceItems=False)
        
    def test_addFolderListItem_should_call_listitem_setProperty_to_inidicate_item_is_a_folder(self):
        sys.argv = ["some_path", -1, "some_params"]
        navigation = YouTubeNavigation()
        navigation.addFolderContextMenuItems = Mock()
        navigation.addFolderContextMenuItems.return_value = []
        
        navigation.addFolderListItem({}, {"action": "some_action", "Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].xbmcgui.ListItem().setProperty.assert_called_with('Folder', 'true')
        
    def test_addFolderListItem_should_call_settings_getSetting_to_fetch_download_path_if_item_feed_is_downloads(self):
        sys.argv = ["some_path", -1, "some_params"]
        navigation = YouTubeNavigation()
        navigation.addFolderContextMenuItems = Mock()
        navigation.addFolderContextMenuItems.return_value = []
        
        navigation.addFolderListItem({}, {"feed": "downloads", "Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].settings.getSetting.assert_called_with("download_path")
        
    def test_addFolderListItem_should_call_xbmcplugin_addDirectoryItem_correctly(self):
        sys.argv = ["some_path", -1, "some_params"]
        navigation = YouTubeNavigation()
        navigation.addFolderContextMenuItems = Mock()
        navigation.addFolderContextMenuItems.return_value = []
        
        navigation.addFolderListItem({}, {"feed": "downloads", "Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].settings.getSetting.assert_called_with("download_path")
        
    def test_addActionListItem_should_call_utils_get_thumbnail_to_get_thumbnail_path(self):
        sys.argv = ["some_path", -1, "some_params"]
        navigation = YouTubeNavigation()
        
        navigation.addActionListItem({}, {"action": "some_action", "Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].utils.getThumbnail.assert_called_with("some_thumbnail")

    def test_addActionListItem_should_call_xbmcgui_ListItem_to_fetch_xbmc_listitem_object(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        
        navigation.addActionListItem({}, {"action": "some_action", "Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].xbmcgui.ListItem.assert_called_with("some_title",iconImage='DefaultFolder.png', thumbnailImage='some_image_path')

    def test_addActionListItem_should_call_listitem_setProperty_to_inidicate_item_is_playable_if_item_action_is_playbyid(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        
        navigation.addActionListItem({}, {"action": "playbyid", "Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].xbmcgui.ListItem().setProperty.assert_called_with("IsPlayable", "true")


    def test_addActionListItem_should_call_xbmcplugin_addDirectoryItem_correctly(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].xbmcgui.ListItem.return_value = []
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        
        navigation.addActionListItem({}, {"action": "some_action", "Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].xbmcplugin.addDirectoryItem.assert_called_with(totalItems = 0, url="some_path?path=None&action=some_action&", isFolder=True, listitem = [], handle=-1)

    def test_addVideoListItem_should_set_default_icon_for_disco(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        
        navigation.addVideoListItem({"scraper": "search_disco"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].utils.getThumbnail.assert_called_with("discoball")

    def test_addVideoListItem_should_set_default_icon_for_live(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        
        navigation.addVideoListItem({"feed": "some_live"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].utils.getThumbnail.assert_called_with("live")

    def test_addVideoListItem_should_set_default_icon_for_music(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()

        navigation.addVideoListItem({"scraper": "scraper_music"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})

        sys.modules["__main__"].utils.getThumbnail.assert_called_with("music")

    def test_addVideoListItem_should_call_xbmcgui_ListItem_to_fetch_xbmc_listitem_object(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        
        navigation.addVideoListItem({}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].xbmcgui.ListItem.assert_called_with("some_title",iconImage="some_image_path",thumbnailImage="some_thumbnail")

    def test_addVideoListItem_should_call_addVideoContextMenuItems_to_get_context_menu_items(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        
        navigation.addVideoListItem({}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        navigation.addVideoContextMenuItems.assert_called_with({}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})

    def test_addVideoListItem_should_call_listitem_addContextMenuItems_to_add_context_menu(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        navigation.addVideoContextMenuItems.return_value = []
        
        navigation.addVideoListItem({}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].xbmcgui.ListItem().addContextMenuItems.assert_called_with([],replaceItems=True)

    def test_addVideoListItem_should_call_listitem_setProperty_to_indicate_listitem_is_video(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        navigation.addVideoContextMenuItems.return_value = []
        
        navigation.addVideoListItem({}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].xbmcgui.ListItem().setProperty.assert_any_call("Video", "true")
        sys.modules["__main__"].xbmcgui.ListItem().setProperty.assert_any_call("IsPlayable", "true")

    def test_addVideoListItem_should_call_listitem_setInfo_to_allow_xbmc_to_sort_and_display_video_info(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        navigation.addVideoContextMenuItems.return_value = []
        
        navigation.addVideoListItem({}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].xbmcgui.ListItem().setInfo.assert_called_with(infoLabels= {'icon': 'some_icon', 'thumbnail': 'some_thumbnail', 'Title': 'some_title'}, type = 'Video')

    def test_addVideoListItem_should_call_xbmcplugin_addDirectoryItem_correctly(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        list_item = Mock()
        sys.modules["__main__"].xbmcgui.ListItem.return_value = list_item 
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        navigation.addVideoContextMenuItems.return_value = []
        
        navigation.addVideoListItem({}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].xbmcplugin.addDirectoryItem.assert_called_with(handle=-1, url = "some_path?path=/root/video&action=play_video&videoid=None", listitem=list_item, isFolder=False, totalItems=1)

    def test_addActionListItem_should_set_default_path_for_videos_correctly(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        list_item = Mock()
        sys.modules["__main__"].xbmcgui.ListItem.return_value = list_item 
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        navigation.addVideoContextMenuItems.return_value = []
        
        navigation.addVideoListItem({}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"})
        
        sys.modules["__main__"].xbmcplugin.addDirectoryItem.assert_called_with(handle=-1, url = "some_path?path=/root/video&action=play_video&videoid=None", listitem=list_item, isFolder=False, totalItems=1)

    def test_parseFolderList_should_set_cache_false_if_item_is_store_og_user_feed(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        navigation.addFolderListItem = Mock()
        
        navigation.parseFolderList({"user_feed": "some_feed", "path": "some_path"},[{"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}])
        
        sys.modules["__main__"].xbmcplugin.endOfDirectory.assert_called_with(handle=-1,succeeded=True,cacheToDisc=False)

    def test_parseFolderList_should_call_addFolderListItem_for_each_item(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        navigation.addFolderListItem = Mock()
        
        navigation.parseFolderList({"user_feed": "some_feed", "path": "some_path"},[{"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}])
        
        assert(navigation.addFolderListItem.call_count == 3)

    def test_parseFolderList_should_call_xbmcplugin_endOfDirectory_correctly(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        navigation.addFolderListItem = Mock()
        
        navigation.parseFolderList({"user_feed": "some_feed", "path": "some_path"},[{"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}])
        
        sys.modules["__main__"].xbmcplugin.endOfDirectory.assert_called_with(handle=-1,succeeded=True,cacheToDisc=False)

    def test_parseVideoList_should_skip_items_where_videoid_is_false(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        sys.modules["__main__"].settings.getSetting.return_value = 0
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        navigation.addVideoListItem = Mock()
        
        navigation.parseVideoList({"user_feed": "some_feed", "path": "some_path"},[{"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "false"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}])
        
        assert(navigation.addVideoListItem.call_count == 2)

    def test_parseVideoList_should_add_index_to_items_from_watch_later_feed(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        sys.modules["__main__"].settings.getSetting.return_value = 0
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        navigation.addVideoListItem = Mock()
        
        navigation.parseVideoList({"scraper": "watch_later", "path": "some_path"},[{"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "false"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}])
        
        navigation.addVideoListItem.assert_called_with({'path': 'some_path', 'scraper': 'watch_later'}, {'path': 'some_path', 'icon': 'some_icon', 'index': '3', 'thumbnail': 'some_thumbnail', 'Title': 'some_title'},3)

    def test_parseVideoList_should_call_addFolderListItem_to_next_item(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        sys.modules["__main__"].settings.getSetting.return_value = 0
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        navigation.addVideoListItem = Mock()
        navigation.addFolderListItem = Mock()
        
        navigation.parseVideoList({"scraper": "watch_later", "path": "some_path"},[{"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "false"}, {"next": "true", "Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}])
        
        navigation.addFolderListItem.assert_called_with({"scraper": "watch_later", "path": "some_path"}, {"next": "true", 'path': 'some_path', 'icon': 'some_icon', 'index': '3', 'thumbnail': 'some_thumbnail', 'Title': 'some_title'},3)

    def test_parseVideoList_should_call_addVideoListItem_if_item_is_not_next_item(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        sys.modules["__main__"].settings.getSetting.return_value = 0
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        navigation.addVideoListItem = Mock()
        navigation.addFolderListItem = Mock()
        
        navigation.parseVideoList({"scraper": "watch_later", "path": "some_path"},[{"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "false"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail", "next": "true"}])
        
        navigation.addVideoListItem.assert_called_once_with({'path': 'some_path', 'scraper': 'watch_later'}, {'path': 'some_path', 'icon': 'some_icon', 'index': '1', 'thumbnail': 'some_thumbnail', 'Title': 'some_title'},3)

    def test_parseVideoList_should_call_settings_getSetting_to_get_list_view(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        sys.modules["__main__"].settings.getSetting.return_value = 0
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        navigation.addVideoListItem = Mock()
        navigation.addFolderListItem = Mock()
        
        navigation.parseVideoList({"scraper": "watch_later", "path": "some_path"},[{"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "false"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail", "next": "true"}])
        
        sys.modules["__main__"].settings.getSetting.assert_called_with("list_view")

    def test_parseVideoList_should_call_xbmc_executebuiltin_if_list_view_is_set(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        sys.modules["__main__"].settings.getSetting.return_value = 1
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        navigation.addVideoListItem = Mock()
        navigation.addFolderListItem = Mock()
        
        navigation.parseVideoList({"scraper": "watch_later", "path": "some_path"},[{"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "false"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail", "next": "true"}])
        
        sys.modules["__main__"].xbmc.executebuiltin.assert_called_with('Container.SetViewMode(500)')
        
    def test_parseVideoList_should_call_xbmcplugin_addSortMethod_for_valid_sort_methods(self):
        sys.argv = ["some_path", -1, "some_params"]
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        sys.modules["__main__"].settings.getSetting.return_value = 1
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        navigation.addVideoListItem = Mock()
        navigation.addFolderListItem = Mock()
        
        navigation.parseVideoList({"scraper": "watch_later", "path": "some_path"},[{"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "false"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail", "next": "true"}])
        
        sys.modules["__main__"].xbmcplugin.addSortMethod.assert_any_call(handle=-1,sortMethod=sys.modules["__main__"].xbmcplugin.SORT_METHOD_UNSORTED)
        sys.modules["__main__"].xbmcplugin.addSortMethod.assert_any_call(handle=-1,sortMethod=sys.modules["__main__"].xbmcplugin.SORT_METHOD_LABEL)
        sys.modules["__main__"].xbmcplugin.addSortMethod.assert_any_call(handle=-1,sortMethod=sys.modules["__main__"].xbmcplugin.SORT_METHOD_VIDEO_RATING)
        sys.modules["__main__"].xbmcplugin.addSortMethod.assert_any_call(handle=-1,sortMethod=sys.modules["__main__"].xbmcplugin.SORT_METHOD_DATE)
        sys.modules["__main__"].xbmcplugin.addSortMethod.assert_any_call(handle=-1,sortMethod=sys.modules["__main__"].xbmcplugin.SORT_METHOD_PROGRAM_COUNT)
        sys.modules["__main__"].xbmcplugin.addSortMethod.assert_any_call(handle=-1,sortMethod=sys.modules["__main__"].xbmcplugin.SORT_METHOD_VIDEO_RUNTIME)
        sys.modules["__main__"].xbmcplugin.addSortMethod.assert_any_call(handle=-1,sortMethod=sys.modules["__main__"].xbmcplugin.SORT_METHOD_GENRE)
        
    def test_parseVideoList_should_call_xbmcplugin_endOfDirectory_correctly(self):        
        sys.modules["__main__"].utils.getThumbnail.return_value = "some_image_path"
        sys.modules["__main__"].settings.getSetting.return_value = 1
        navigation = YouTubeNavigation()
        navigation.addVideoContextMenuItems = Mock()
        navigation.addVideoListItem = Mock()
        navigation.addFolderListItem = Mock()
        
        navigation.parseVideoList({"scraper": "watch_later", "path": "some_path"},[{"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "false"}, {"Title": "some_title", "icon": "some_icon", "thumbnail": "some_thumbnail", "next": "true"}])
        
        sys.modules["__main__"].xbmcplugin.endOfDirectory.assert_called_with(cacheToDisc=True,handle=-1,succeeded=True)
        
    def test_addVideoContextMenuItems_should_call_utils_makeAscii_on_Title(self):
        sys.argv = ["some_plugin", -1, "some_path"]
        sys.modules["__main__"].language.return_value = "some_button_string %s"
        sys.modules["__main__"].common.makeAscii.side_effect = lambda x: x
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].common.makeAscii.assert_any_call("some_title")
        
    def test_addVideoContextMenuItems_should_call_utils_makeAscii_on_Studio(self):
        sys.argv = ["some_plugin", -1, "some_path"]
        sys.modules["__main__"].language.return_value = "some_button_string %s"
        sys.modules["__main__"].common.makeAscii.side_effect = lambda x: x
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].common.makeAscii.assert_called_with("Unknown Author")
        
    def prepareContestMenu(self):
        sys.argv = ["some_plugin", -1, "some_path"]
        sys.modules["__main__"].language.return_value = "some_button_string %s"
        sys.modules["__main__"].common.makeAscii.side_effect = lambda x: x
        
    def assert_context_menu_contains(self, cm, title, path):
        found = False
        for (ititle, ipath) in cm:
                if ititle == title and ipath == path :
                        found = True

        if found == False:
                print "Failed to find item in context menu: " + title + " - " + path + "\r\n"
                
                for (title, path) in cm:
                    print "item " + str(cm.index((title, path))) +": " + title + " - " + path
                        
        assert(found)

    def assert_context_menu_doesnt_contain(self, cm, title, path):
        found = False
        for (ititle, ipath) in cm:
                if ititle == title and ipath == path :
                        found = True

        if found == True:
                print "Failed to find item in context menu: " + title + " - " + path + "\r\n"
                
                for (title, path) in cm:
                    print "item " + str(cm.index((title, path))) +": " + title + " - " + path
                        
        assert(found == False)
        
    def test_addVideoContextMenuItems_should_add_play_all_from_video_id_to_items_in_playlists(self):
        self.prepareContestMenu()
        navigation = YouTubeNavigation()
        path_params = {"playlist": "some_playlist"}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "some_id"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30512)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=play_all&playlist=some_playlist&videoid=some_id&)')
                

    def test_addVideoContextMenuItems_should_add_play_all_from_video_id_to_items_in_new_subscriptions_feed(self):
        self.prepareContestMenu()
        navigation = YouTubeNavigation()
        path_params = {"user_feed": "newsubscriptions"}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "some_id"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30521)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=play_all&user_feed=newsubscriptions&contact=default&videoid=some_id&)')

    def test_addVideoContextMenuItems_should_add_download_video_to_all_video_items(self):
        self.prepareContestMenu()
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "some_id"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30501)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=download&videoid=some_id)')

    def test_addVideoContextMenuItems_should_add_add_favorite_option_if_user_is_logged_in_and_item_is_not_in_favorites_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "some_id"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30503)
        sys.modules["__main__"].settings.getSetting.assert_any_call("username")
        sys.modules["__main__"].settings.getSetting.assert_any_call("oauth2_access_token")
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=add_favorite&videoid=some_id&)')

    def test_addVideoContextMenuItems_should_add_add_favorite_option_if_user_is_logged_in_and_item_is_in_external_users_favorites_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {"user_feed": "favorites", "contact": "some_contact"}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "some_id"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30501)
        sys.modules["__main__"].settings.getSetting.assert_any_call("username")
        sys.modules["__main__"].settings.getSetting.assert_any_call("oauth2_access_token")
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=add_favorite&videoid=some_id&)')
        
    def test_addVideoContextMenuItems_should_add_remove_favorite_option_if_user_is_logged_in_and_item_is_in_favorites_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {"user_feed": "favorites"}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "editid": "some_id"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30506)
        sys.modules["__main__"].settings.getSetting.assert_any_call("username")
        sys.modules["__main__"].settings.getSetting.assert_any_call("oauth2_access_token")
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=remove_favorite&editid=some_id&)')

    def test_addVideoContextMenuItems_should_add_add_subscription_option_to_channels_not_in_subscriptions_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {"user_feed": "favorites"}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "editid": "some_id"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30512)
        self.assert_context_menu_contains(cm, "some_button_string Unknown Author", 'XBMC.RunPlugin(some_plugin?path=some_path&channel=Unknown+Author&action=add_subscription)')        

    def test_addVideoContextMenuItems_should_add_add_subscriptions_option_to_external_users_subscriptions_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {"feed": "subscriptions_favorites", "external": "true"}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "editid": "some_id"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30512)
        self.assert_context_menu_contains(cm, "some_button_string Unknown Author", 'XBMC.RunPlugin(some_plugin?path=some_path&channel=Unknown+Author&action=add_subscription)')        

    def test_addVideoContextMenuItems_should_not_add_add_subscrition_option_to_users_uploads_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {"user_feed": "uploads"}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "editid": "some_id"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        self.assert_context_menu_doesnt_contain(cm, "some_button_string Unknown Author", 'XBMC.RunPlugin(some_plugin?path=some_path&channel=Unknown+Author&action=add_subscription)')        

    def test_addVideoContextMenuItems_should_not_add_add_subscription_option_to_subscription_favorites_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {"feed": "subscriptions_favorites"}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "editid": "some_id"}

        cm = navigation.addVideoContextMenuItems(path_params, item_params)

        self.assert_context_menu_doesnt_contain(cm, "some_button_string Unknown Author", 'XBMC.RunPlugin(some_plugin?path=some_path&channel=Unknown+Author&action=add_subscription)')

    def test_addVideoContextMenuItems_should_not_add_add_subscription_option_to_subscription_playlists_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {"feed": "subscriptions_playlists"}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "editid": "some_id"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        self.assert_context_menu_doesnt_contain(cm, "some_button_string Unknown Author", 'XBMC.RunPlugin(some_plugin?path=some_path&channel=Unknown+Author&action=add_subscription)')        

    def test_addVideoContextMenuItems_should_not_add_add_subscription_option_to_subscription_uploads_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {"feed": "subscriptions_uploads"}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "editid": "some_id"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        self.assert_context_menu_doesnt_contain(cm, "some_button_string Unknown Author", 'XBMC.RunPlugin(some_plugin?path=some_path&channel=Unknown+Author&action=add_subscription)')

    def test_addVideoContextMenuItems_should_add_remove_from_playlist_option_to_items_in_playlists(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {"playlist": "some_playlist"}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "playlist_entry_id": "some_id"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30530)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=remove_from_playlist&playlist=some_playlist&playlist_entry_id=some_id&)')        

    def test_addVideoContextMenuItems_should_add_add_to_playlist_option_to_video_items_if_user_is_logged_in(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30528)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.Container.Update(some_plugin?path=None&feed=related&videoid=someid)')        

    def test_addVideoContextMenuItems_should_add_more_videos_by_user_if_item_is_not_in_uploads_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30516)
        self.assert_context_menu_contains(cm, "some_button_string Unknown Author", 'XBMC.Container.Update(some_plugin?path=None&feed=uploads&channel=Unknown+Author)')        

    def test_addVideoContextMenuItems_should_not_add_more_videos_by_user_if_item_is_in_uploads_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {"user_feed": "uploads"}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        self.assert_context_menu_doesnt_contain(cm, "some_button_string Unknown Author", 'XBMC.Container.Update(some_plugin?path=None&feed=uploads&channel=Unknown+Author)')
        
    def test_addVideoContextMenuItems_should_add_related_videos_option_to_video_items(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30527)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.Container.Update(some_plugin?path=None&feed=related&videoid=someid)')        

    def test_addVideoContextMenuItems_should_add_find_similar_option_to_video_items(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30514)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.Container.Update(some_plugin?path=None&feed=search&search=some_title)')        

    def test_addVideoContextMenuItems_should_add_now_playing_option_to_video_items(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30523)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.ActivateWindow(VideoPlaylist)')

    def test_addVideoContextMenuItems_should_add_video_info_option_to_video_items(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid"}
        
        cm = navigation.addVideoContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30523)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.Action(Info)')

    def test_addFolderContextMenuItems_should_not_add_any_options_to_next_folders(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "next": "true"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        assert(cm == [])

    def test_addFolderContextMenuItems_should_add_play_all_option_to_newsubsctiptions_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "user_feed": "newsubscriptions"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30520)
        sys.modules["__main__"].language.assert_any_call(30522)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=play_all&user_feed=newsubscriptions&contact=default&login=true&)')        
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=play_all&shuffle=true&user_feed=newsubscriptions&contact=default&login=true&)')
        
    def test_addFolderContextMenuItems_should_add_play_all_option_to_favorites_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "user_feed": "favorites"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30520)
        sys.modules["__main__"].language.assert_any_call(30522)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=play_all&user_feed=favorites&contact=default&login=true&)')        
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=play_all&shuffle=true&user_feed=favorites&contact=default&login=true&)')

    def test_addFolderContextMenuItems_should_add_playlist_options_to_playlist_items(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "playlist": "some_playlist"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30531)
        sys.modules["__main__"].language.assert_any_call(30539)
        sys.modules["__main__"].language.assert_any_call(30520)
        sys.modules["__main__"].language.assert_any_call(30522)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=reverse_order&playlist=some_playlist&)')        
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=play_all&user_feed=playlist&playlist=some_playlist&)')
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=play_all&user_feed=playlist&shuffle=true&playlist=some_playlist&)')        
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=delete_playlist&playlist=some_playlist&)')
                
    def test_addFolderContextMenuItems_should_add_play_all_option_to_watch_later_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "user_feed": "watch_later"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30520)
        sys.modules["__main__"].language.assert_any_call(30522)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=play_all&user_feed=watch_later&contact=default&login=true&)')        
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=play_all&shuffle=true&user_feed=watch_later&contact=default&login=true&)')
                
    def test_addFolderContextMenuItems_should_add_play_all_option_to_recommended_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "user_feed": "recommended"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30520)
        sys.modules["__main__"].language.assert_any_call(30522)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=play_all&user_feed=recommended&contact=default&login=true&)')        
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=play_all&shuffle=true&user_feed=recommended&contact=default&login=true&)')

    def test_addFolderContextMenuItems_should_add_play_all_option_to_liked_videos_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "scraper": "liked_videos"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30520)
        sys.modules["__main__"].language.assert_any_call(30522)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=play_all&scraper=liked_videos&login=true&)')        
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=play_all&shuffle=true&scraper=liked_videos&login=true&)')
        
    def test_addFolderContextMenuItems_should_add_play_all_option_to_disco_search(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "scraper": "search_disco", "search": "some_search"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30520)
        sys.modules["__main__"].language.assert_any_call(30522)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=play_all&scraper=search_disco&search=some_search&)')        
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=play_all&shuffle=true&scraper=search_disco&search=some_search&)')
        
    def test_addFolderContextMenuItems_should_add_edit_and_delete_options_to_disco_searches(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "scraper": "search_disco", "search": "some_search"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30524)
        sys.modules["__main__"].language.assert_any_call(30525)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.Container.Update(some_plugin?path=some_path&action=edit_disco&store=disco_searches&search=some_search&)')        
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=delete_disco&store=disco_searches&delete=some_search&)')
        
    def test_addFolderContextMenuItems_should_not_add_edit_and_delete_options_to_dissco_searches_in_the_top_artist_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {"scraper": "disco_top_artist"}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "scraper": "search_disco", "search": "some_search"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        self.assert_context_menu_doesnt_contain(cm, "some_button_string %s", 'XBMC.Container.Update(some_plugin?path=some_path&action=edit_disco&store=disco_searches&search=some_search&)')        
        self.assert_context_menu_doesnt_contain(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=delete_disco&store=disco_searches&delete=some_search&)')
        
    def test_addFolderContextMenuItems_should_add_edit_and_delete_options_to_searches(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "feed": "search", "search": "some_search"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30515)
        sys.modules["__main__"].language.assert_any_call(30508)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.Container.Update(some_plugin?path=some_path&action=edit_search&store=searches&search=some_search&)')        
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=delete_search&store=searches&delete=some_search&)')

    def test_addFolderContextMenuItems_should_add_correct_view_mode_options_to_subscriptions_favorites_feeds(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "view_mode": "some_view_mode", "user_feed": "favorites"}

        cm = navigation.addFolderContextMenuItems(path_params, item_params)

        sys.modules["__main__"].language.assert_any_call(30511)
        sys.modules["__main__"].language.assert_any_call(30526)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.Container.Update(some_plugin?path=some_path&channel=None&action=change_subscription_view&view_mode=uploads&)')
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.Container.Update(some_plugin?path=some_path&channel=None&action=change_subscription_view&view_mode=playlists&folder=true&)')

    def test_addFolderContextMenuItems_should_add_correct_view_mode_options_to_subscriptions_uploads_feeds(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "view_mode": "some_view_mode", "user_feed": "uploads"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30510)
        sys.modules["__main__"].language.assert_any_call(30526)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.Container.Update(some_plugin?path=some_path&channel=None&action=change_subscription_view&view_mode=favorites&)')        
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.Container.Update(some_plugin?path=some_path&channel=None&action=change_subscription_view&view_mode=playlists&folder=true&)')
        
    def test_addFolderContextMenuItems_should_add_correct_view_mode_options_to_subscriptions_playlists_feeds(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "view_mode": "some_view_mode", "user_feed": "playlists"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30511)
        sys.modules["__main__"].language.assert_any_call(30510)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.Container.Update(some_plugin?path=some_path&channel=None&action=change_subscription_view&view_mode=favorites&)')        
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.Container.Update(some_plugin?path=some_path&channel=None&action=change_subscription_view&view_mode=uploads&)')        
        
    def test_addFolderContextMenuItems_should_add_add_subscription_option_to_subscriptions_not_in_users_subscription_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {"external": "true"}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "channel": "some_channel"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30512)        
        self.assert_context_menu_contains(cm, "some_button_string some_channel", 'XBMC.RunPlugin(some_plugin?path=some_path&channel=None&action=add_subscription)')
        
    def test_addFolderContextMenuItems_should_add_remove_subscription_option_to_subscriptions_in_users_subscriptions_feed(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        sys.modules["__main__"].common.makeAscii.side_effect = lambda x: x
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "channel": "some_channel", "editid": "some_editid"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30513)
        self.assert_context_menu_contains(cm, "some_button_string some_channel", 'XBMC.RunPlugin(some_plugin?path=some_path&editid=some_editid&action=remove_subscription)')        
        
    def test_addFolderContextMenuItems_should_add_add_contact_option_to_external_contacts_if_user_is_logged_in(self):
        self.prepareContestMenu()
        sys.modules["__main__"].pluginsettings.userHasProvidedValidCredentials.return_value = True
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "contact": "some_contact", "external": "true"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30026)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=add_contact&contact=some_title&)')        
        
    def test_addFolderContextMenuItems_should_add_remove_contact_options_to_items_in_contact_feed_if_user_is_logged_in(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail", "videoid": "someid", "contact": "some_contact"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30025)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.RunPlugin(some_plugin?path=some_path&action=remove_contact&contact=some_title&)')                
        
    def test_addFolderContextMenuItems_should_add_now_playing_option_to_folder_items(self):
        self.prepareContestMenu()
        sys.modules["__main__"].settings.getSetting.return_value = "something"
        navigation = YouTubeNavigation()
        path_params = {}
        item_params = {"Title": "some_title", "path": "some_path", "icon": "some_icon", "thumbnail": "some_thumbnail"}
        
        cm = navigation.addFolderContextMenuItems(path_params, item_params)
        
        sys.modules["__main__"].language.assert_any_call(30523)
        self.assert_context_menu_contains(cm, "some_button_string %s", 'XBMC.ActivateWindow(VideoPlaylist)')
        
if __name__ == '__main__':
        nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubePlayer
# -*- coding: utf-8 -*-
import nose
import urllib
import BaseTestCase
from mock import Mock, patch
import sys
from YouTubePlayer import YouTubePlayer


class TestYouTubePlayer(BaseTestCase.BaseTestCase):

    def test__getVideoLinks_should_return_empty_dictionary_on_missing_map(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"status":303, "content": ""}
        sys.modules["__main__"].common.parseDOM.return_value = []

        player = YouTubePlayer()
        (result, status) = player.extractVideoLinksFromYoutube({},{"videoid":"123"})

        assert (result == {})

    def test_playVideo_should_call_getVideoObject(self):
        player = YouTubePlayer()
        player.buildVideoObject = Mock(return_value=[{"apierror": "some error"}, 303])

        player.playVideo()

        player.buildVideoObject.assert_called_with({})

    def test_playVideo_should_log_and_fail_gracefully_on_apierror(self):
        player = YouTubePlayer()
        player.buildVideoObject = Mock()
        player.buildVideoObject.return_value = [{"apierror": "some error"}, 303]

        result = player.playVideo()

        assert(result == False)
        sys.modules["__main__" ].common.log.assert_called_with("construct video url failed contents of video item {'apierror': 'some error'}")

    def test_playVideo_should_call_xbmc_setResolvedUrl(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        player = YouTubePlayer()
        player.addSubtitles = Mock()
        player.buildVideoObject = Mock()
        player.buildVideoObject.return_value = ({"Title": "someTitle", "videoid": "some_id", "thumbnail": "someThumbnail", "video_url": "someUrl"}, 200)
        sys.argv = ["test1", "1", "test2"]

        player.playVideo({"videoid": "some_id"})

        assert(sys.modules["__main__"].xbmcplugin.setResolvedUrl.call_count > 0)

    def test_playVideo_should_call_addSubtitles(self):
        video = {"Title": "someTitle", "videoid": "some_id", "thumbnail": "someThumbnail", "video_url": "someUrl"}
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.argv = ["test1", "1", "test2"]
        player = YouTubePlayer()
        player.buildVideoObject = Mock()
        player.buildVideoObject.return_value = (video, 200)

        player.playVideo({"videoid": "some_id"})

        sys.modules["__main__"].subtitles.addSubtitles.assert_called_with(video)

    def test_playVideo_should_call_remove_from_watch_later_if_viewing_video_from_watch_later_queue(self):
        player = YouTubePlayer()
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        sys.argv = ["test1", "1", "test2"]
        player.buildVideoObject = Mock()
        player.buildVideoObject.return_value = ({"Title": "someTitle", "videoid": "some_id", "thumbnail": "someThumbnail", "video_url": "someUrl"}, 200)
        player.addSubtitles = Mock()
        call_params = {"videoid": "some_id", "watch_later": "true", "playlist": "playlist_id", "playlist_entry_id": "entry_id"}

        player.playVideo(call_params)

        sys.modules["__main__"].core.remove_from_watch_later.assert_called_with(call_params)

    def test_playVideo_should_update_locally_stored_watched_status(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        sys.argv = ["test1", "1", "test2"]
        player = YouTubePlayer()
        player.buildVideoObject = Mock()
        player.buildVideoObject.return_value = ({"Title": "someTitle", "videoid": "some_id", "thumbnail": "someThumbnail", "video_url": "someUrl"}, 200)
        player.addSubtitles = Mock()

        player.playVideo({"videoid": "some_id"})
        sys.modules["__main__"].storage.storeValue.assert_called_with("vidstatus-some_id", "7" )

    def test_getInfo_should_use_cache_when_possible(self):
        sys.modules["__main__"].cache.get.return_value = '["something"]'
        player = YouTubePlayer()

        player.getInfo({"videoid": "some_id"})

        sys.modules["__main__"].cache.get.assert_called_with("videoidcachesome_id")

    def test_getInfo_should_call_fetchPage_with_correct_url(self):
        sys.modules["__main__"].cache.get.return_value = {}
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 303, "content": "something"}
        player = YouTubePlayer()

        player.getInfo({"videoid": "some_id"})

        sys.modules["__main__"].core._fetchPage.assert_called_with({"api": "true", "link": player.urls["video_info"] % ("some_id")})

    def test_getInfo_should_call_core_getVideoInfo_to_parse_youtube_xml(self):
        sys.modules["__main__"].cache.get.return_value = {}
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 200, "content": "something"}
        sys.modules["__main__"].core.getVideoInfo.return_value = [{"videoid": "some_id"}]
        player = YouTubePlayer()

        player.getInfo({"videoid": "some_id"})

        sys.modules["__main__"].core.getVideoInfo.assert_called_with("something", {"videoid": "some_id"})

    def test_getInfo_should_fail_correctly_if_api_is_unavailable(self):
        sys.modules["__main__"].cache.get.return_value = {}
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 200, "content": "something"}
        sys.modules["__main__"].core.getVideoInfo.return_value = []
        sys.modules["__main__"].language.return_value = "some_string"
        player = YouTubePlayer()

        (video, status) = player.getInfo({"videoid": "some_id"})

        sys.modules["__main__"].common.log.assert_called_with("- Couldn't parse API output, YouTube doesn't seem to know this video id?")
        sys.modules["__main__"].language.assert_called_with(30608)
        assert(video["apierror"] == "some_string")

    def test_getInfo_should_save_video_info_in_cache(self):
        sys.modules["__main__"].cache.get.return_value = {}
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 200, "content": "something"}
        sys.modules["__main__"].core.getVideoInfo.return_value = [{"videoid": "some_id"}]
        player = YouTubePlayer()

        player.getInfo({"videoid": "some_id"})

        sys.modules["__main__"].cache.set.assert_called_with('videoidcachesome_id', "{'videoid': 'some_id'}")

    def test_selectVideoQuality_should_prefer_h264_over_vp8_for_720p_as_appletv2_cant_handle_vp8_properly(self):
        sys.modules["__main__"].settings.getSetting.return_value = "2"
        player = YouTubePlayer()

        url = player.selectVideoQuality({},{22: "h264", 45: "vp8"})

        print "url: " + repr(url)
        assert(url[:url.find("|")].strip() == "h264")

    def test_selectVideoQuality_should_prefer_1080p_if_asked_to(self):
        sys.modules["__main__"].settings.getSetting.return_value = "2"
        player = YouTubePlayer()

        url = player.selectVideoQuality({"quality": "1080p"},{37: "1080p", 22: "720p", 35: "SD"})

        assert(url[:url.find("|")].strip() == "1080p")

    def test_selectVideoQuality_should_prefer_720p_if_asked_to(self):
        sys.modules["__main__"].settings.getSetting.return_value = "2"
        player = YouTubePlayer()

        url = player.selectVideoQuality({"quality": "720p"},{37: "1080p", 22: "720p", 35: "SD"})

        assert(url[:url.find("|")].strip() == "720p")

    def test_selectVideoQuality_should_prefer_SD_if_asked_to(self):
        sys.modules["__main__"].settings.getSetting.return_value = "2"
        player = YouTubePlayer()

        url = player.selectVideoQuality({"quality": "SD"},{37: "1080p", 22: "720p", 35: "SD"})

        assert(url[:url.find("|")].strip() == "SD")

    def test_selectVideoQuality_should_choose_highest_sd_quality_if_only_multiple_sd_qualities_are_available(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        player = YouTubePlayer()

        url = player.selectVideoQuality({},{5: "1", 33: "2", 18: "3", 26: "4", 43: "5", 34: "6", 78: "7", 44: "8", 59: "9", 35: "10"})

        assert(url[:url.find("|")].strip() == "10")

    def test_selectVideoQuality_should_prefer_1080p_if_user_has_selected_that_option(self):
        sys.modules["__main__"].settings.getSetting.return_value = "3"
        player = YouTubePlayer()

        url = player.selectVideoQuality({},{35: "SD", 22: "720p", 37: "1080p"})

        assert(url[:url.find("|")].strip() == "1080p")

    def test_selectVideoQuality_should_limit_to_720p_if_user_has_selected_that_option(self):
        sys.modules["__main__"].settings.getSetting.return_value = "2"
        player = YouTubePlayer()

        url = player.selectVideoQuality({},{35: "SD", 22: "720p", 37: "1080p"})

        assert(url[:url.find("|")].strip() == "720p")

    def test_selectVideoQuality_should_limit_to_sd_if_user_has_selected_that_option(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        player = YouTubePlayer()

        url = player.selectVideoQuality({},{35: "SD", 22: "720p", 37: "1080p"})

        assert(url[:url.find("|")].strip() == "SD")

    def test_selectVideoQuality_should_call_userSelectsVideoQuality_if_user_selected_that_option(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        player = YouTubePlayer()
        player.userSelectsVideoQuality = Mock()

        player.selectVideoQuality({},{35: "SD", 22: "720p", 37: "1080p"})

        player.userSelectsVideoQuality.assert_called_with({}, {35: 'SD', 37: '1080p', 22: '720p'})

    def test_selectVideoQuality_should_add_valid_user_agent_when_not_called_by_download_function(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        player = YouTubePlayer()

        url = player.selectVideoQuality({},{35: "SD", 22: "720p", 37: "1080p"})

        assert(url.find("|" + urllib.urlencode({'User-Agent':"Mozilla/5.0 (MOCK)"})) > 0)

    def test_selectVideoQuality_should_not_add_user_agent_when_called_by_download_function(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        player = YouTubePlayer()

        url = player.selectVideoQuality({"action": "download"},{35: "SD", 22: "720p", 37: "1080p"})

        assert(url.find("|" + urllib.urlencode({'User-Agent':"Mozilla/5.0 (MOCK)"})) < 0)

    def test_userSelectsVideoQuality_should_append_list_of_known_qualities(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].xbmcgui.Dialog().select.return_value = -1
        sys.modules["__main__"].language.return_value = ""
        player = YouTubePlayer()

        url = player.userSelectsVideoQuality({}, {35: u"SD", 22: u"720p", 37: u"1080p", 35: u"480p", 18: u"380p", 34: u"360p", 5: u"240p", 17: u"144p"})
        print repr(url)

        sys.modules["__main__"].xbmcgui.Dialog().select.assert_any_call("", [u"1080p", u"720p", u"480p", u"380p", u"360p", u"240p", u"144p"])

    def test_userSelectsVideoQuality_should_prefer_h264_over_vp8_as_appletv2_cant_handle_vp8_properly(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].xbmcgui.Dialog().select.return_value = 0
        sys.modules["__main__"].language.return_value = ""
        player = YouTubePlayer()

        url = player.userSelectsVideoQuality({}, {22: "h264", 45: "vp8"})

        assert(url == "h264")

    def test_userSelectsVideoQuality_should_select_proper_quality_based_on_user_input(self):
        player = YouTubePlayer()
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].xbmcgui.Dialog().select.return_value = 0
        sys.modules["__main__"].language.return_value = ""
        sys.modules["__main__"].common.makeUTF8.return_value = "bla"

        url = player.userSelectsVideoQuality({}, {35: u"SD", 22: u"720p", 37: u"1080p"})

        sys.modules["__main__"].xbmcgui.Dialog().select.assert_called_with("", [u"1080p", u"720p", u"480p"])
        assert(url == "1080p")

    def test_userSelectsVideoQuality_should_call_xbmc_dialog_select_to_ask_for_user_input(self):
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].xbmcgui.Dialog().select.return_value = -1
        sys.modules["__main__"].language.return_value = ""
        player = YouTubePlayer()

        url = player.userSelectsVideoQuality({}, {35: "SD", 22: "720p", 37: "1080p"})

        print repr(url)

        assert(sys.modules["__main__"].xbmcgui.Dialog().select.call_count > 0)

    def test_buildVideoObject_should_get_video_information_from_getInfo(self):
        sys.modules["__main__"].settings.getSetting.return_value = ""
        player = YouTubePlayer()
        player.getInfo = Mock()
        player.getInfo.return_value = ({}, 303)
        player.extractVideoLinksFromYoutube = Mock()
        player.extractVideoLinksFromYoutube.return_value = ({}, {})

        player.buildVideoObject({})

        player.getInfo.assert_called_with({})

    def test_buildVideoObject_should_use_local_file_for_playback_if_found(self):
        sys.modules["__main__"].subtitles.getLocalFileSource.return_value = "somePath/someTitle.mp4"
        params = {"videoid": "some_id"}
        player = YouTubePlayer()
        player.getInfo = Mock()
        video = {"videoid": "some_id", "Title": "someTitle"}
        player.getInfo.return_value = (video, 200)

        (video, status) = player.buildVideoObject(params)

        assert(video["video_url"] == "somePath/someTitle.mp4")

    def test_buildVideoObject_should_not_scrape_webpage_if_local_file_is_found(self):
        sys.modules["__main__"].subtitles.getLocalFileSource.return_value = "somePath/someTitle.mp4"
        params = {"videoid": "some_id"}
        player = YouTubePlayer()
        player.getInfo = Mock()
        player.extractVideoLinksFromYoutube = Mock()
        video = {"videoid": "some_id", "Title": "someTitle"}
        player.getInfo.return_value = (video, 200)

        player.buildVideoObject(params)

        assert(player.extractVideoLinksFromYoutube.call_count == 0)

    def test_buildVideoObject_should_check_for_local_file_before_scraping(self):
        sys.modules["__main__"].subtitles.getLocalFileSource.return_value = "somePath/someTitle.mp4"
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        params = {"videoid": "some_id"}
        player = YouTubePlayer()
        player.getInfo = Mock()
        video = {"videoid": "some_id", "Title": "someTitle"}
        player.getInfo.return_value = (video, 200)

        (video, status) = player.buildVideoObject(params)

        sys.modules["__main__"].subtitles.getLocalFileSource.assert_called_with(params, video)

    def test_buildVideoObject_should_call_getVideoLinks_if_local_file_not_found(self):
        sys.modules["__main__"].subtitles.getLocalFileSource.return_value = ""
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        params = {"videoid": "some_id"}
        player = YouTubePlayer()
        player.getInfo = Mock()
        player.extractVideoLinksFromYoutube = Mock()
        player.extractVideoLinksFromYoutube.return_value = ({}, {})
        video = {"videoid": "some_id", "Title": "someTitle"}
        player.getInfo.return_value = (video, 200)

        player.buildVideoObject(params)

        player.extractVideoLinksFromYoutube.assert_any_call(video, params)

    def test_buildVideoObject_should_call_selectVideoQuality_if_local_file_not_found_and_remote_links_found(self):
        sys.modules["__main__"].subtitles.getLocalFileSource.return_value = ""
        params = {"videoid": "some_id"}
        video = {"videoid": "some_id", "Title": "someTitle"}

        player = YouTubePlayer()
        player.getInfo = Mock()
        player.getInfo.return_value = (video, 200)

        player.extractVideoLinksFromYoutube = Mock()
        player.extractVideoLinksFromYoutube.return_value = ({22: "720p"}, {})
        player.selectVideoQuality = Mock()

        player.buildVideoObject(params)

        player.selectVideoQuality.assert_called_with(params,{22: "720p"})

    def test_buildVideoObject_should_use_pre_defined_error_messages_on_missing_url(self):
        sys.modules["__main__"].settings.getSetting.return_value = ""
        player = YouTubePlayer()
        player.getInfo = Mock()
        player.getInfo.return_value = ({}, 303)
        player.getLocalFileSource = Mock(return_value="")
        player.extractVideoLinksFromYoutube = Mock(return_value = ({}, {}))

        player.buildVideoObject({})

        player.getInfo.assert_called_with({})
        sys.modules["__main__"].language.assert_called_with(30618)

    def test_buildVideoLinks_should_try_scraping_first(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"status":303, "content": ""}
        sys.modules["__main__"].common.parseDOM.return_value = []

        player = YouTubePlayer()
        player.extractVideoLinksFromYoutube({},{"videoid":"123"})

        sys.modules["__main__"].core._fetchPage.assert_any_call({"link":player.urls["video_stream"] % "123", "login":"true"})

    def ttest_getVideoLinks_should_fall_back_to_embed(self):

        assert(False)

    def ttest_getVideoLinks_should_get_error_message_from_embed(self):
        assert(False)

    def test_getVideoLinks_should_parse_main_video_structure_on_webpage_correctly(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 200, "content": self.readTestInput("normal-video-page-bQbbtnTz1KE.html", False)}
        sys.modules["__main__"].common.parseDOM.return_value = []
        player = YouTubePlayer()
        sys.modules["__main__"].core._findErrors.return_value = "mock error"

        result = player.extractVideoLinksFromYoutube({}, {"videoid": "some_id"})

        print repr(result)

        assert(result[0].has_key(35))

    def test_getVideoLinks_should_parse_rtmpe_video_structure_on_webpage_correctly(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 200, "content": self.readTestInput("rtmpe-video-page-8wxOVn99FTE.html", False)}
        player = YouTubePlayer()
        sys.modules["__main__"].core._findErrors.return_value = "mock error"
        sys.modules["__main__"].common.parseDOM.return_value = []

        result = player.extractVideoLinksFromYoutube({}, {"videoid": "some_id"})

        print repr(result)

        assert(result[0].has_key(36))

    def test_getVideoLinks_should_parse_live_video_structure_on_webpage_correctly(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 200, "content": self.readTestInput("live-video-page-e93MaEwrsfc.html", False)}
        sys.modules["__main__"].common.parseDOM.return_value = []
        player = YouTubePlayer()
        sys.modules["__main__"].core._findErrors.return_value = "mock error"

        result = player.extractVideoLinksFromYoutube({}, {"videoid": "some_id"})

        print repr(result)

        assert(result[0].has_key(35))

    def test_buildVideoObject_with_hls(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 200, "content": self.readTestInput("live-video-hls-page-S_pMsJw-_oA.html", False)}
        sys.modules["__main__"].subtitles.getLocalFileSource.return_value = ""
        sys.modules["__main__"].common.parseDOM.return_value = []
        params = {"videoid": "some_id"}
        player = YouTubePlayer()
        player.getInfo = Mock()
        video = {"videoid": "some_id", "Title": "someTitle"}
        player.getInfo.return_value = (video, 200)

        (video, status) = player.buildVideoObject(params)
        
        assert(video["video_url"] == "http://www.youtube.com/api/manifest/hls_variant/id/S_pMsJw-_oA.2/sparams/cp%2Cid%2Cip%2Cipbits%2Cmaudio%2Cplaylist_type%2Cpmbypass%2Csource%2Cexpire/expire/1364700604/playlist_type/DVR/ipbits/8/upn/Ftpj_wWBeuQ/signature/4B46E966BDE27C0772BA90DE72F0B083F7C44E5A.6F1348A5EE63E4167F1E03C1DE268DABA3EB836E/fexp/932000%2C906383%2C902000%2C919512%2C929903%2C931202%2C900821%2C900823%2C931203%2C931401%2C908529%2C919373%2C930803%2C906836%2C920201%2C929602%2C930101%2C930603%2C900824%2C910223/ip/205.178.10.177/key/yt1/maudio/1/sver/3/cp/U0hVSVdLTl9FTkNONV9PRVJHOmtkY0VJTkJQay02/pmbypass/yes/source/yt_live_broadcast/file/index.m3u8")


if __name__ == '__main__':
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubePlaylistControl
# -*- coding: utf-8 -*-
import nose
import BaseTestCase
from mock import Mock
import sys
from  YouTubePlaylistControl import YouTubePlaylistControl


class TestYouTubePlaylistControl(BaseTestCase.BaseTestCase):
    def test_playAll_should_call_getUserFeed_if_user_feed_is_playlist_in_params(self):
        control = YouTubePlaylistControl()
        control.getUserFeed = Mock()
        control.getUserFeed.return_value = ""
        
        control.playAll({"user_feed":"playlist", "playlist":"someid"})
        
        control.getUserFeed.assert_called_with({"playlist":"someid", "user_feed":"playlist",'fetch_all': 'true', "login":"true"})
        
    def test_playAll_should_call_getDiscoSearch_if_scraper_is_disco_search_in_params(self):
        control = YouTubePlaylistControl()
        sys.modules["__main__"].scraper.searchDisco.return_value = ("", 200)
        
        control.playAll({"scraper":"search_disco", "search":"some_search"})

        sys.modules["__main__"].scraper.searchDisco.assert_called_with({"scraper":"search_disco", "search":"some_search", "fetch_all" : "true"})
                
    def test_playAll_should_call_getUserFeed_if_user_feed_is_favorites_in_params(self):
        control = YouTubePlaylistControl()
        control.getUserFeed = Mock()
        control.getUserFeed.return_value = ""
        
        control.playAll({"user_feed":"favorites"})
        
        control.getUserFeed.assert_called_with({"user_feed":"favorites", 'login':"true", 'fetch_all': 'true'})
                
    def test_playAll_should_call_getLikedVideos_if_scraper_is_liked_videos_in_params(self):
        control = YouTubePlaylistControl()
        control.getLikedVideos = Mock()
        control.getLikedVideos.return_value = ("",200)
        
        control.playAll({"scraper":"liked_videos"})
        
        control.getLikedVideos.assert_called_with({"scraper":"liked_videos", 'fetch_all': 'true'})

    def test_playAll_should_call_getUserFeed_if_user_feed_is_subscriptions_in_params(self):
        control = YouTubePlaylistControl()
        control.getUserFeed = Mock()
        control.getUserFeed.return_value = ""
        
        control.playAll({"user_feed":"newsubscriptions"})
        
        control.getUserFeed.assert_called_with({"user_feed":"newsubscriptions", 'login':"true", 'fetch_all': 'true'})
        
    def test_playAll_should_not_call_xbmc_player_if_params_is_empty(self):
        control = YouTubePlaylistControl()
        
        control.playAll({})
        
        assert(sys.modules["__main__"].xbmc.Player.call_count == 0)
        assert(sys.modules["__main__"].xbmc.Player().call_count == 0)
        
    def test_playAll_should_call_xbmc_player_stop_if_player_is_playing(self):
        control = YouTubePlaylistControl()
        control.getUserFeed = Mock()
        control.getUserFeed.return_value = [{"Title":"someTitle", "videoid":"some_id","thumbnail":"some_thumbnail"}]
        
        control.playAll({"user_feed":"playlist", "playlist":"someid"})
        
        sys.modules["__main__"].xbmc.Player.assert_called_with()
        sys.modules["__main__"].xbmc.Player().isPlaying.assert_called_with()
        sys.modules["__main__"].xbmc.Player().stop.assert_called_with()
        
    def test_playAll_should_call_xbmc_PlayList_clear_if_results_is_not_empty(self):
        playlist_value = Mock()
        sys.modules["__main__"].xbmc.PlayList.return_value = playlist_value
        control = YouTubePlaylistControl()
        control.getUserFeed = Mock()
        control.getUserFeed.return_value = [{"Title":"someTitle", "videoid":"some_id","thumbnail":"some_thumbnail"}]
        
        control.playAll({"user_feed":"playlist", "playlist":"someid"})
        
        playlist_value.clear.assert_called_with()
        
    def test_playAll_should_call_xbmc_player_shuffle_if_shuffle_is_in_params(self):
        playlist_value = Mock()
        sys.modules["__main__"].xbmc.PlayList.return_value = playlist_value
        control = YouTubePlaylistControl()
        control.getUserFeed = Mock()
        control.getUserFeed.return_value = [{"Title":"someTitle", "videoid":"some_id","thumbnail":"some_thumbnail"}]
        
        control.playAll({"user_feed":"playlist", "playlist":"someid","shuffle":"true"})
        
        sys.modules["__main__"].xbmc.Player.assert_called_with()
        sys.modules["__main__"].xbmc.Player().isPlaying.assert_called_with()
        sys.modules["__main__"].xbmc.Player().stop.assert_called_with()
        playlist_value.shuffle.assert_called_with()
        
    def test_playAll_should_queue_all_items_in_result_list(self):
        playlist_value = Mock()
        sys.modules["__main__"].xbmc.PlayList.return_value = playlist_value
        control = YouTubePlaylistControl()
        control.getUserFeed = Mock()
        control.getUserFeed.return_value = [{"Title":"someTitle1", "videoid":"some_id1","thumbnail":"some_thumbnail1"},{"Title":"someTitle2", "videoid":"some_id2","thumbnail":"some_thumbnail2"}]
        
        control.playAll({"user_feed":"playlist","playlist":"someid","shuffle":"true"})
        
        assert(playlist_value.add.call_count == 2)
        
    def test_playAll_should_queue_all_items_in_result_list_after_provided_videoid(self):
        playlist_value = Mock()
        sys.modules["__main__"].xbmc.PlayList.return_value = playlist_value
        control = YouTubePlaylistControl()
        control.getUserFeed = Mock()
        control.getUserFeed.return_value = [{"Title":"someTitle1", "videoid":"some_id1","thumbnail":"some_thumbnail1"},{"Title":"someTitle2", "videoid":"some_id2","thumbnail":"some_thumbnail2"},{"Title":"someTitle3", "videoid":"some_id3","thumbnail":"some_thumbnail3"},{"Title":"someTitle4", "videoid":"some_id4","thumbnail":"some_thumbnail4"}]
        
        control.playAll({"user_feed":"playlist","playlist":"someid","shuffle":"true","videoid":"some_id3"})
        
        assert(playlist_value.add.call_count == 2)
	
    def test_playAll_should_start_playback_of_playlist_if_result_list_is_not_empty(self):
        playlist_value = Mock()
        sys.modules["__main__"].xbmc.PlayList.return_value = playlist_value
        control = YouTubePlaylistControl()
        control.getUserFeed = Mock()
        control.getUserFeed.return_value = [{"Title":"someTitle1", "videoid":"some_id1","thumbnail":"some_thumbnail1"},{"Title":"someTitle2", "videoid":"some_id2","thumbnail":"some_thumbnail2"}]
        
        control.playAll({"user_feed":"playlist", "playlist":"someid"})
        
        sys.modules["__main__"].xbmc.executebuiltin.assert_called_with('playlist.playoffset(video , 0)')
        
    def test_queueVideo_should_handle_a_list_of_video_ids_seperated_by_a_comma(self):
        playlist_value = Mock()
        sys.modules["__main__"].xbmc.PlayList.return_value = playlist_value
        sys.modules["__main__"].core.getBatchDetails.return_value = ({"apierror":""},303)
        control = YouTubePlaylistControl()
        control.getPlayList = Mock()
        control.getPlayList.return_value = [{"Title":"someTitle1", "videoid":"some_id1","thumbnail":"some_thumbnail1"},{"Title":"someTitle2", "videoid":"some_id2","thumbnail":"some_thumbnail2"}]
        
        control.queueVideo({"videoid":"someid1,someid2,someid3"})
        
        sys.modules["__main__"].core.getBatchDetails.assert_called_with(['someid1', 'someid2', 'someid3'], {'videoid': 'someid1,someid2,someid3'})        

    def test_queueVideo_should_call_get_batch_details_for_the_video_list(self):
        playlist_value = Mock()
        sys.modules["__main__"].xbmc.PlayList.return_value = playlist_value
        sys.modules["__main__"].core.getBatchDetails.return_value = ({"apierror":""},303)
        control = YouTubePlaylistControl()
        control.getPlayList = Mock()
        control.getPlayList.return_value = [{"Title":"someTitle1", "videoid":"some_id1","thumbnail":"some_thumbnail1"},{"Title":"someTitle2", "videoid":"some_id2","thumbnail":"some_thumbnail2"}]
        
        control.queueVideo({"videoid":"someid1,someid2,someid3"})
        
        sys.modules["__main__"].core.getBatchDetails.assert_called_with(['someid1', 'someid2', 'someid3'], {'videoid': 'someid1,someid2,someid3'})        

    def test_queueVideo_should_show_error_message_if_get_batch_details_fails(self):
        playlist_value = Mock()
        sys.modules["__main__"].xbmc.PlayList.return_value = playlist_value
        sys.modules["__main__"].language.return_value = ""
        sys.modules["__main__"].core.getBatchDetails.return_value = ([],303)
        control = YouTubePlaylistControl()
        control.getPlayList = Mock()
        control.getPlayList.return_value = [{"Title":"someTitle1", "videoid":"some_id1","thumbnail":"some_thumbnail1"},{"Title":"someTitle2", "videoid":"some_id2","thumbnail":"some_thumbnail2"}]
        
        control.queueVideo({"videoid":"someid1,someid2,someid3"})
        
        sys.modules["__main__"].utils.showErrorMessage.assert_called_with("","apierror",303)

    def test_queueVideo_should_correctly_queue_all_items_in_result_list(self):
        playlist_value = Mock()
        sys.modules["__main__"].xbmc.PlayList.return_value = playlist_value
        sys.modules["__main__"].language.return_value = ""
        sys.modules["__main__"].core.getBatchDetails.return_value = ([{"Title":"someTitle1","videoid":"some_id1", "thumbnail":"thumbnail1","video_url":"some_url1"}, {"Title":"someTitle1","videoid":"some_id1", "thumbnail":"thumbnail1","video_url":"some_url1"}, {"Title":"someTitle1","videoid":"some_id1", "thumbnail":"thumbnail1","video_url":"some_url1"}], 200)
        sys.modules["__main__"].common.makeAscii.return_value = ""
        control = YouTubePlaylistControl()
        control.getPlayList = Mock()
        control.getPlayList.return_value = [{"Title":"someTitle1", "videoid":"some_id1","thumbnail":"some_thumbnail1"},{"Title":"someTitle2", "videoid":"some_id2","thumbnail":"some_thumbnail2"}]
        
        control.queueVideo({"videoid":"someid1,someid2,someid3"})
        
        assert(playlist_value.add.call_count == 3)

    def test_getUserFeed_should_call_feeds_list_all(self):
        control = YouTubePlaylistControl()
        
        control.getUserFeed({"user_feed":"playlist","playlist":"some_playlist"})
        
        assert(sys.modules["__main__"].feeds.listAll.call_count > 0)
        
    def test_getUserFeed_should_exit_cleanly_if_contact_is_missing(self):
        sys.modules["__main__"].feeds.listAll.return_value = ("",200)
        control = YouTubePlaylistControl()
        
        control.getUserFeed({"user_feed":"favorites"})
        
        assert(sys.modules["__main__"].feeds.listAll.call_count == 0)

    def test_getUserFeed_should_call_core_list_all_with_correct_params(self):
        sys.modules["__main__"].feeds.listAll.return_value = ("",200)
        control = YouTubePlaylistControl()
        
        control.getUserFeed({"contact":"some_contact", "user_feed":"favorites"})
        
        assert(sys.modules["__main__"].feeds.listAll.call_count == 1)
        sys.modules["__main__"].feeds.listAll.assert_called_with({"user_feed":"favorites","contact":"some_contact"})

    def test_getUserFeed_should_exit_cleanly_if_user_feed_is_playlist_and_playlist_id_is_missing_from_params(self):
        control = YouTubePlaylistControl()
        
        control.getUserFeed({"user_feed":"playlist"})
        
        assert(sys.modules["__main__"].feeds.listAll.call_count == 0)
	
    def test_getLikedVideos_should_exit_cleanly_if_scraper_or_login_is_not_in_params(self):
        control = YouTubePlaylistControl()
        
        control.getLikedVideos({})
        
        assert(sys.modules["__main__"].scraper.scrapeUserLikedVideos.call_count == 0)
	
    def test_getLikedVideos_should_call_scraper_scrapeLikedVideos(self):
        sys.modules["__main__"].scraper.scrapeUserLikedVideos.return_value = ("",200)
        sys.modules["__main__"].core.getBatchDetails.return_value = ("",200)
        control = YouTubePlaylistControl()
        
        control.getLikedVideos({"login":"true","scraper":"liked_videos"})
        
        sys.modules["__main__"].scraper.scrapeUserLikedVideos.assert_called_with({"login":"true","scraper":"liked_videos"})
        
    def test_getLikedVideos_should_call_core_getBatchDetails_if_scraper_succeded(self):
        sys.modules["__main__"].scraper.scrapeUserLikedVideos.return_value = ("",200)
        sys.modules["__main__"].core.getBatchDetails.return_value = ("",200)
        control = YouTubePlaylistControl()
        
        control.getLikedVideos({"login":"true","scraper":"liked_videos"})
        
        sys.modules["__main__"].scraper.scrapeUserLikedVideos.assert_called_with({"login":"true","scraper":"liked_videos"})

    def test_addToPlaylist_should_call_list_all_if_playlist_is_not_in_params(self):
        sys.modules["__main__"].feeds.listAll.return_value = ([])
        control = YouTubePlaylistControl()
        
        control.addToPlaylist({})
        
        sys.modules["__main__"].feeds.listAll.assert_called_with({'user_feed': 'playlists', 'login': 'true', 'folder': 'true'})
        assert(sys.modules["__main__"].feeds.listAll.call_count == 1)

    def test_addToPlaylist_should_ask_user_for_playlist_if_playlist_is_not_in_params(self):
        sys.modules["__main__"].feeds.listAll.return_value = ([{"Title":"PlayList1"},{"Title":"PlayList2"}])
        sys.modules["__main__"].xbmcgui.Dialog().select.return_value = 0
        control = YouTubePlaylistControl()
        control.createPlayList = Mock()

        control.addToPlaylist({})
        
        assert(sys.modules["__main__"].xbmcgui.Dialog.call_count == 2)
        assert(sys.modules["__main__"].xbmcgui.Dialog().select.call_count == 1)

    def test_addToPlaylist_should_call_createPlaylist_if_user_selects_create_option(self):
        sys.modules["__main__"].xbmcgui.Dialog().select.return_value = 0
        sys.modules["__main__"].feeds.listAll.return_value = ([{"Title":"PlayList1"},{"Title":"PlayList2"}])
        control = YouTubePlaylistControl()
        control.createPlaylist = Mock()
        
        control.addToPlaylist({})
        
        control.createPlaylist.assert_called_with({'user_feed': 'playlists', 'login': 'true', 'folder': 'true'})

    def test_addToPlaylist_should_call_core_add_to_playlist_if_playlist_is_in_params(self):
        control = YouTubePlaylistControl()
        control.createPlayList = Mock()
        
        control.addToPlaylist({"playlist":"playlist1"})
        
        sys.modules["__main__"].core.add_to_playlist.assert_called_with({'playlist': 'playlist1'})

    def test_addToPlaylist_should_call_core_add_to_playlist_if_user_has_selected_playlist(self):
        sys.modules["__main__"].xbmcgui.Dialog().select.return_value = 1
        sys.modules["__main__"].feeds.listAll.return_value = ([{"Title":"PlayList1","playlist":"playlist1"},{"Title":"PlayList2","playlist":"playlist2"}])
        control = YouTubePlaylistControl()
        control.createPlayList = Mock()
        
        control.addToPlaylist({})
        
        sys.modules["__main__"].core.add_to_playlist.assert_called_with({'user_feed': 'playlists', 'login': 'true', 'playlist': 'playlist1', 'folder': 'true'})

    def test_createPlayList_should_ask_user_for_input(self):
        sys.modules["__main__"].common.getUserInput.return_value = ""
        sys.modules["__main__"].xbmcgui.Dialog().select.return_value = 1
        sys.modules["__main__"].language.return_value = "my_string"
        control = YouTubePlaylistControl()
        
        control.createPlaylist({})
        
        sys.modules["__main__"].common.getUserInput.assert_called_with("my_string")
        sys.modules["__main__"].language.assert_called_with(30529)

    def test_createPlayList_should_call_addPlaylist_if_user_provided_playlist_name(self):
        sys.modules["__main__"].common.getUserInput.return_value = "my_playlist_name"
        sys.modules["__main__"].xbmcgui.Dialog().select.return_value = 1
        sys.modules["__main__"].language.return_value = "my_string"
        control = YouTubePlaylistControl()
        
        control.createPlaylist({})
        
        sys.modules["__main__"].core.add_playlist.assert_called_with({"title":"my_playlist_name"})
        
    def test_createPlayList_should_not_call_addPlaylist_if_user_cancels(self):
        sys.modules["__main__"].common.getUserInput.return_value = ""
        sys.modules["__main__"].xbmcgui.Dialog().select.return_value = 1
        sys.modules["__main__"].language.return_value = "my_string"
        control = YouTubePlaylistControl()
        
        control.createPlaylist({})
        
        assert(sys.modules["__main__"].core.add_playlist.call_count == 0)

        
    def test_removeFromPlaylist_should_exit_cleanly_if_playlist_or_playlist_entry_id_is_missing(self):
        control = YouTubePlaylistControl()
        
        control.removeFromPlaylist({})
        
        assert(sys.modules["__main__"].core.remove_from_playlist.call_count == 0)

    def test_removeFromPlaylist_should_call_core_remove_from_playlist(self):
        sys.modules["__main__"].core.remove_from_playlist.return_value = ("",200)
        control = YouTubePlaylistControl()

        control.removeFromPlaylist({"playlist_entry_id":"some_playlist_entry_id", "playlist":"some_playlist"})
        
        sys.modules["__main__"].core.remove_from_playlist.assert_called_with({"playlist_entry_id":"some_playlist_entry_id", "playlist":"some_playlist"})

    def test_removeFromPlaylist_should_show_error_message_if_remove_call_failed(self):
        sys.modules["__main__"].core.remove_from_playlist.return_value = ("fail",303)
        sys.modules["__main__"].language.return_value = "my_string"
        control = YouTubePlaylistControl()
        
        control.removeFromPlaylist({"playlist_entry_id":"some_playlist_entry_id", "playlist":"some_playlist"})
        
        sys.modules["__main__"].utils.showErrorMessage.assert_called_with("my_string","fail",303)
	
    def test_removeFromPlaylist_should_call_xbmc_execute_builtin_on_success(self):
        control = YouTubePlaylistControl()
        sys.modules["__main__"].core.remove_from_playlist.return_value = ("",200)
        
        control.removeFromPlaylist({"playlist_entry_id":"some_playlist_entry_id", "playlist":"some_playlist"})
        
        sys.modules["__main__"].xbmc.executebuiltin.assert_called_with("Container.Refresh")
	
    def test_deletePlaylist_should_exit_cleanly_if_playlist_is_missing(self):
        sys.modules["__main__"].core.remove_from_playlist.return_value = ("",200)
        control = YouTubePlaylistControl()
        
        control.deletePlaylist({})
        
        assert(sys.modules["__main__"].core.del_playlist.call_count == 0)
	
    def test_deletePlaylist_should_call_core_delete_playlist(self):
        sys.modules["__main__"].core.del_playlist.return_value = ("",200)
        control = YouTubePlaylistControl()
        
        control.deletePlaylist({"playlist":"some_playlist"})
        
        sys.modules["__main__"].core.del_playlist.assert_called_with({"playlist":"some_playlist"})
	
    def test_deletePlaylist_should_show_error_message_if_delete_call_failed(self):
        sys.modules["__main__"].core.del_playlist.return_value = ("fail",303)
        sys.modules["__main__"].language.return_value = "my_string"
        control = YouTubePlaylistControl()
        
        control.deletePlaylist({"playlist":"some_playlist"})
        
        sys.modules["__main__"].utils.showErrorMessage.assert_called_with("my_string","fail",303)
	
    def test_deletePlaylist_should_call_xbmc_execute_builtin_on_success(self):
        sys.modules["__main__"].core.del_playlist.return_value = ("",200)
        control = YouTubePlaylistControl()
        
        control.deletePlaylist({"playlist":"some_playlist_id"})
        
        sys.modules["__main__"].xbmc.executebuiltin.assert_called_with("Container.Refresh")	

if __name__ == '__main__':
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubePluginSettings
import nose
import BaseTestCase
import sys
from YouTubePluginSettings import YouTubePluginSettings

class TestYouTubePluginSettings(BaseTestCase.BaseTestCase):

    def test_itemsPerPage_should_call_settings_correctly(self):
        settings = YouTubePluginSettings()
        sys.modules["__main__"].settings.getSetting.return_value = "0"

        settings.itemsPerPage()

        sys.modules[ "__main__" ].settings.getSetting.assert_any_call("perpage")

    def test_currentRegion_should_call_settings_correctly(self):
        settings = YouTubePluginSettings()
        sys.modules["__main__"].settings.getSetting.return_value = "0"

        settings.currentRegion()

        sys.modules[ "__main__" ].settings.getSetting.assert_any_call("region_id")

    def test_safeSearchLevel_should_call_settings_correctly(self):
        settings = YouTubePluginSettings()
        sys.modules["__main__"].settings.getSetting.return_value = "0"

        settings.safeSearchLevel()

        sys.modules[ "__main__" ].settings.getSetting.assert_any_call("safe_search")

    def test_requestTimeout_should_call_settings_correctly(self):
        settings = YouTubePluginSettings()
        sys.modules["__main__"].settings.getSetting.return_value = "0"

        settings.requestTimeout()

        sys.modules[ "__main__" ].settings.getSetting.assert_any_call("timeout")

    def test_userHasProvidedValidCredentials_should_call_settings_correctly(self):
        settings = YouTubePluginSettings()
        sys.modules["__main__"].settings.getSetting.return_value = "0"

        settings.userHasProvidedValidCredentials()

        sys.modules[ "__main__" ].settings.getSetting.assert_any_call("username")
        sys.modules[ "__main__" ].settings.getSetting.assert_any_call("oauth2_access_token")


    def test_userName_should_call_settings_correctly(self):
        settings = YouTubePluginSettings()

        settings.userName()

        sys.modules[ "__main__" ].settings.getSetting.assert_any_call("username")

    def test_userPassword_should_call_settings_correctly(self):
        settings = YouTubePluginSettings()

        settings.userPassword()

        sys.modules[ "__main__" ].settings.getSetting.assert_any_call("user_password")

    def test_debugModeIsEnabled_should_call_settings_correctly(self):
        settings = YouTubePluginSettings()

        settings.debugModeIsEnabled()

        sys.modules[ "__main__" ].settings.getSetting.assert_any_call("debug")

    def test_authenticationRefreshRoken_should_call_settings_correctly(self):
        settings = YouTubePluginSettings()

        settings.authenticationRefreshRoken()

        sys.modules[ "__main__" ].settings.getSetting.assert_any_call("oauth2_refresh_token")

if __name__ == "__main__":
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubeScraper
# -*- coding: utf-8 -*-
import nose
import BaseTestCase
from mock import Mock, patch
import sys
from  YouTubeScraper import YouTubeScraper 

class TestYouTubeScraper(BaseTestCase.BaseTestCase):
    scraper = ""
    
    def setUp(self):
        super(self.__class__,self).setUp()
        sys.modules["__main__"].common.parseDOM.return_value = ["some_string","some_string","some_string"]
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"some_content","status":200}
        sys.modules["__main__"].common.makeAscii.return_value = "some_ascii_string"
        sys.modules["__main__"].common.replaceHTMLCodes.return_value = "some_html_free_string"
        sys.modules["__main__"].utils.extractVID.return_value = ["some_id_1","some_id_2","some_id_3"]
        sys.modules["__main__"].language.return_value = "some_language_string %s"
        sys.modules["__main__"].common.stripTags.return_value = "some_tag_less_string"
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        sys.modules["__main__"].cache.cacheFunction.return_value = (["some_cached_string"], 200)
        
        self.scraper = YouTubeScraper()
        self.scraper.createUrl = Mock()
        self.scraper.createUrl.return_value = "some_url"

    def test_searchDisco_should_call_createUrl_to_get_seach_url(self):
        
        self.scraper.searchDisco({"search":"some_search"})
        
        self.scraper.createUrl.assert_any_call({"search":"some_search"})

    def test_searchDisco_should_call_fetchPage_to_get_search_result(self):
        
        self.scraper.searchDisco({"search":"some_search"})
                
        sys.modules["__main__"].core._fetchPage.assert_any_call({"link":"some_url"})

    def test_searchDisco_should_call_listPlaylist_to_list_content(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"some_content&v=some_video_id&list=some_mix_list&blablabla","status":200}
        sys.modules["__main__"].feeds.return_value = []

        self.scraper.searchDisco({"search":"some_search"})

        assert(sys.modules["__main__"].core._fetchPage.call_count == 1)
        sys.modules["__main__"].core._fetchPage.assert_any_call({"link":"some_url"})

    def test_searchDisco_should_return_list_of_dictionaries_with_video_information(self):
        sys.modules["__main__"].common.parseDOM.return_value = ["some_id_1,some_id_2,some_id_3"]
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"some_content&v=some_video_id&list=some_mix_list&blablabla","status":200}
        sys.modules["__main__"].feeds.listPlaylist.return_value = [{"videoid":"some_id_1"},{"videoid":"some_id_2"},{"videoid":"some_id_3"}]
        
        result = self.scraper.searchDisco({"search":"some_search"})
        
        assert(result[0]["videoid"] == "some_id_1")
        assert(result[1]["videoid"] == "some_id_2")
        assert(result[2]["videoid"] == "some_id_3")

    def test_scrapeUserLikedVideos_should_call_createUrl_to_get_proper_url(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"some_content_&p=some_playlist&_blabal", "status":200}
        sys.modules["__main__"].common.parseDOM.return_value = ["a=1&list=list1&b=2"]

        self.scraper.scrapeUserLikedVideos({})
        
        self.scraper.createUrl.assert_any_call({})

    def test_scrapeUserLikedVideos_should_call_core_fetchPage_to_get_page_content(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"some_content_&p=some_playlist&_blabal", "status":200}
        sys.modules["__main__"].common.parseDOM.return_value = ["a=1&list=list1&b=2"]
        
        self.scraper.scrapeUserLikedVideos({})
        
        sys.modules["__main__"].core._fetchPage.assert_any_call({"link":"some_url","login":"true"})

    def test_scrapeUserLikedVideos_should_call_parseDOM_to_find_playlist(self):
        sys.modules["__main__"].core._fetchPage.return_value = {"content":"some_content_&p=some_playlist&_blabal", "status":200}
        sys.modules["__main__"].common.parseDOM.return_value = ["a=1&list=list1&b=2"]
        
        self.scraper.scrapeUserLikedVideos({})
        
        assert(sys.modules["__main__"].common.parseDOM.call_count > 0)

    def test_getNewResultsFunction_should_set_proper_params_for_searchDisco_if_scraper_is_search_diso(self):
        params = {"scraper":"search_disco"}
        
        self.scraper.getNewResultsFunction(params)
        
        assert(params["new_results_function"] == self.scraper.searchDisco)

    def test_getNewResultsFunction_should_set_proper_params_for_scrapeUserVideoFeed_if_scraper_is_liked_videos(self):
        params = {"scraper":"liked_videos"}
        
        self.scraper.getNewResultsFunction(params)
        
        assert(params["new_results_function"] == self.scraper.scrapeUserLikedVideos)

    def test_createUrl_should_return_proper_url_for_search_disco(self):
        self.scraper = YouTubeScraper()
        
        url = self.scraper.createUrl({"scraper":"search_disco", "search":"some_search"})
        
        assert(url == self.scraper.urls["disco_search"] % "some_search")

    def test_paginator_should_call_cache_function_with_pointer_to_new_results_function_if_scraper_is_not_show(self):
        
        result, status = self.scraper.paginator({"scraper":"some_scraper","new_results_function":"some_function_pointer"})
        
        sys.modules["__main__"].cache.cacheFunction.assert_called_with("some_function_pointer",{"scraper":"some_scraper","new_results_function":"some_function_pointer"})

    def test_paginator_should_call_new_results_function_pointer_if_scraper_is_show_and_show_is_in_params(self):
        self.scraper.scrapeShow = Mock()
        self.scraper.scrapeShow.return_value = (["some_string"],200)
        params = {"scraper":"show","new_results_function":self.scraper.scrapeShow, "show":"some_show"}

        result, status = self.scraper.paginator(params)
        
        sys.modules["__main__"].cache.cacheFunction.assert_called_with(self.scraper.scrapeShow,params)

    def test_paginator_should_return_error_if_no_results_are_found(self):
        sys.modules["__main__"].cache.cacheFunction.return_value = ([],303)
        
        result, status = self.scraper.paginator({"scraper":"some_scraper","new_results_function":"some_function_pointer"})
        
        assert(status == 303)
        assert(result == [])

    def test_paginator_should_call_getBatchDetailsThumbnails_if_batch_is_thumbnails(self):
        sys.modules["__main__"].core.getBatchDetailsThumbnails.return_value = ([],200)
        
        result, status = self.scraper.paginator({"scraper":"some_scraper","new_results_function":"some_function_pointer", "batch":"thumbnails"})
        
        assert(sys.modules["__main__"].core.getBatchDetailsThumbnails.call_count > 0)
        
    def test_paginator_should_call_getBatchDetails_if_batch_is_set_but_not_thumbnails(self):
        sys.modules["__main__"].core.getBatchDetails.return_value = ([],200)
        
        result, status = self.scraper.paginator({"scraper":"some_scraper","new_results_function":"some_function_pointer", "batch":"true"})
        
        assert(sys.modules["__main__"].core.getBatchDetails.call_count > 0)
        
    def test_paginator_should_call_utils_addNextFolder_if_item_list_is_longer_than_per_page_count(self):
        sys.modules["__main__"].core.getBatchDetails.return_value = ([],200)
        videos = []
        i = 0
        while i < 50:
            videos.append("some_cached_string_" + str(i))
            i += 1
            
        sys.modules["__main__"].cache.cacheFunction.return_value = (videos, 200)
        
        result, status = self.scraper.paginator({"scraper":"some_scraper","new_results_function":"some_function_pointer", "batch":"true"})
        
        assert(sys.modules["__main__"].utils.addNextFolder.call_count > 0)
        
    def test_paginator_should_store_thumbnail_if_scraper_is_search_disco(self):
        sys.modules["__main__"].cache.cacheFunction.return_value = ([{"thumbnail":"some_cached_string"}], 200)
        
        result, status = self.scraper.paginator({"scraper":"search_disco","new_results_function":"some_function_pointer"})
        
        sys.modules["__main__"].storage.store.assert_called_with({'new_results_function': 'some_function_pointer', 'scraper': 'search_disco'}, 'some_cached_string', 'thumbnail')

    def test_paginator_should_limit_list_length_if_its_longer_than_perpage(self):
        videos = []
        i = 0
        while i < 50:
            videos.append("some_cached_string_" + str(i))
            i += 1
            
        sys.modules["__main__"].cache.cacheFunction.return_value = (videos, 200)
        
        result, status = self.scraper.paginator({"scraper":"some_scraper","new_results_function":"some_function_pointer"})
        
        assert(len(result) == 15)
        
    def test_paginator_should_not_limit_list_length_if_fetch_all_is_set(self):
        videos = []
        i = 0
        while i < 50:
            videos.append("some_cached_string_" + str(i))
            i += 1
            
        sys.modules["__main__"].cache.cacheFunction.return_value = (videos, 200)
        
        result, status = self.scraper.paginator({"scraper":"some_scraper","new_results_function":"some_function_pointer","fetch_all":"true"})
        
        assert(len(result) == 50)
    
    def test_paginator_should_begin_list_at_correct_count_if_page_is_set(self):
        videos = []
        i = 0
        while i < 50:
            videos.append("some_cached_string_" + str(i))
            i += 1
            
        sys.modules["__main__"].cache.cacheFunction.return_value = (videos, 200)
        
        result, status = self.scraper.paginator({"scraper":"some_scraper","new_results_function":"some_function_pointer","page":"1"})
        
        assert(result[0] == "some_cached_string_15")
        assert(result[14] == "some_cached_string_29")
            
    def test_scrape_should_call_getNewResultsFunction(self):
        self.scraper.getNewResultsFunction = Mock()
        self.scraper.paginator = Mock()
        
        self.scraper.scrape()
        
        self.scraper.getNewResultsFunction.assert_called_with({})

    def test_scrape_should_call_paginator(self):
        self.scraper.getNewResultsFunction = Mock()
        self.scraper.paginator = Mock()
        
        self.scraper.scrape()
        
        self.scraper.paginator.assert_called_with({})
        
if __name__ == '__main__':
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubeStorage
# -*- coding: utf-8 -*-
import nose
import BaseTestCase
from mock import Mock, patch
import sys
from YouTubeStorage import YouTubeStorage


class TestYouTubeStorage(BaseTestCase.BaseTestCase):
    def test_list_should_call_getUserOptionFolder_if_store_contact_option_is_in_params(self):
        storage = YouTubeStorage()
        storage.getUserOptionFolder = Mock()
        storage.getUserOptionFolder.return_value = ("", 200)

        storage.list({"store": "contact_options"})

        storage.getUserOptionFolder.assert_called_with({"store": "contact_options"})

    def test_list_should_call_getStoredArtists_if_store_artist_is_in_params(self):
        storage = YouTubeStorage()
        storage.getStoredArtists = Mock()
        storage.getStoredArtists.return_value = ("", 200)

        storage.list({"store": "artists"})

        storage.getStoredArtists.assert_called_with({"store": "artists"})

    def test_list_should_call_getStoredSearches_if_store_is_defined_in_params_but_not_artist_or_contact_option(self):
        storage = YouTubeStorage()
        storage.getStoredSearches = Mock()
        storage.getStoredSearches.return_value = ("", 200)

        storage.list({"store": "somestore"})

        storage.getStoredSearches.assert_called_with({"store": "somestore"})

    def test_openFile_should_call_io_open(self):
        patcher = patch("io.open")
        patcher.start()
        import io
        io.open.return_value = "my_result"
        storage = YouTubeStorage()

        result = storage.openFile("someFile")
        patcher.stop()

        assert(result == "my_result")

    def test_getStoredSearches_should_call_retrieve_to_get_searches(self):
        storage = YouTubeStorage()
        storage.retrieveSettings = Mock()
        storage.retrieveSettings.return_value =  ["some_search"]
        storage.storeSettings = Mock()
        
        storage.getStoredSearches({"path": "some_path"})
        
        assert(storage.retrieveSettings.call_count > 0)        

    def test_getStoredSearches_should_call_retrieve_to_get_thumbnail_collection(self):
        storage = YouTubeStorage()
        storage.retrieveSettings = Mock()
        storage.retrieveSettings.return_value =  ["some_search"]
        storage.storeSettings = Mock()
        
        storage.getStoredSearches({"path": "some_path"})
        
        assert(storage.retrieveSettings.call_args[0][0] == {"path": "some_path"})
        assert(storage.retrieveSettings.call_args[0][1] == "thumbnail")
        assert(storage.retrieveSettings.call_args[0][2] == {'path': 'some_path', 'search': 'some_search', 'thumbnail': ['some_search'], 'Title': 'some_search'})
        assert(storage.retrieveSettings.call_count == 2)

    def test_getStoredSearches_should_return_proper_list_structure(self):
        storage = YouTubeStorage()
        storage.retrieveSettings = Mock()
        storage.retrieveSettings.return_value =  ["some_search"]
        storage.storeSettings = Mock()
        
        (result, status) = storage.getStoredSearches({"path": "some_path"})
        
        print repr(result)
        assert(result == [{'path': 'some_path', 'search': 'some_search', 'thumbnail': ['some_search'], 'Title': 'some_search'}])
        
    def test_getStoredSearches_should_call_quote_plus_on_search_items(self):
        patcher = patch("urllib.quote_plus")
        patcher.start()
        import urllib
        urllib.quote_plus.return_value = "some_quoted_search"
        storage = YouTubeStorage()
        storage.retrieveSettings = Mock()
        storage.retrieveSettings.return_value =  ["some_search"]
        storage.storeSettings = Mock()
        
        (result, status) = storage.getStoredSearches({"path": "some_path"})
        args = urllib.quote_plus.call_args
        patcher.stop()
        
        assert(args[0][0] == "some_search")
        assert(result == [{'path': 'some_path', 'search': 'some_quoted_search', 'thumbnail': ['some_search'], 'Title': 'some_search'}])
                

    def test_deleteStoredSearch_should_call_unquote_on_delete_param(self):
        patcher = patch("urllib.unquote_plus")
        patcher.start()
        import urllib
        urllib.unquote_plus.return_value = "some_unquoted_search"
        storage = YouTubeStorage()
        storage.retrieve = Mock()
        storage.retrieve.return_value =  ["some_search1"]
        storage.storeSettings = Mock()
        
        storage.deleteStoredSearch({"delete": "some_search2"})
        args = urllib.unquote_plus.call_args
        patcher.stop()
        
        assert(args[0][0] == "some_search2")

    def test_deleteStoredSearch_should_call_retrieve_to_get_searches(self):
        storage = YouTubeStorage()
        storage.retrieveSettings = Mock()
        storage.retrieveSettings.return_value =  ["some_search1"]
        storage.storeSettings = Mock()
        
        storage.deleteStoredSearch({"delete": "some_search2"})
        
        storage.retrieveSettings.assert_called_with({'delete': 'some_search2'})
        assert(storage.retrieveSettings.call_count == 1)

    def test_deleteStoredSearch_should_remove_search_from_list_before_calling_store(self):
        storage = YouTubeStorage()
        storage.retrieve = Mock()
        storage.retrieve.return_value =  ["some_search2"]
        storage.storeSettings = Mock()
        
        storage.deleteStoredSearch({"delete": "some_search2"})
        
        storage.storeSettings.assert_called_with({"delete": "some_search2"},[])

    def test_deleteStoredSearch_should_call_executebuiltin(self):
        storage = YouTubeStorage()
        storage.retrieve = Mock()
        storage.retrieve.return_value =  ["some_search2"]
        storage.storeSettings = Mock()
        
        storage.deleteStoredSearch({"delete": "some_search2"})
        
        sys.modules["__main__"].xbmc.executebuiltin.assert_called_with('Container.Refresh')

    def test_saveStoredSearch_should_exit_cleanly_if_search_is_not_in_params(self):
        storage = YouTubeStorage()
        storage.retrieve = Mock()
        storage.retrieve.return_value =  ["some_search2"]
        storage.storeSettings = Mock()
        
        storage.saveStoredSearch({})
        
        assert(storage.retrieve.call_count == 0)
        assert(storage.storeSettings.call_count == 0)
        
    def test_saveStoredSearch_should_call_unquote_on_search_param(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"        
        patcher = patch("urllib.unquote_plus")
        patcher.start()
        import urllib
        urllib.unquote_plus.return_value = "some_unquoted_search"
        storage = YouTubeStorage()
        storage.retrieveSettings = Mock()
        storage.retrieveSettings.return_value =  ["some_search1"]
        storage.storeSettings = Mock()
        
        storage.saveStoredSearch({"search": "some_search"})

        args = urllib.unquote_plus.call_args
        patcher.stop()
        
        assert(args[0][0] == "some_search")

    def test_saveStoredSearch_should_call_unquote_on_old_search_param_if_it_exists(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"        
        patcher = patch("urllib.unquote_plus")
        patcher.start()
        import urllib
        urllib.unquote_plus.return_value = "some_unquoted_search"
        storage = YouTubeStorage()
        storage.retrieveSettings = Mock()
        storage.retrieveSettings.return_value =  ["some_search1"]
        storage.storeSettings = Mock()
        
        storage.saveStoredSearch({"search": "some_search1", "old_search": "some_search2"})
        
        args = urllib.unquote_plus.call_args_list
        patcher.stop()
        
        assert(args[0][0][0] == "some_search1")
        assert(args[1][0][0] == "some_search2")

    def test_saveStoredSearch_should_call_retrieve_to_get_list_of_searches(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        storage = YouTubeStorage()
        storage.retrieveSettings = Mock()
        storage.retrieveSettings.return_value =  ["some_search2"]
        storage.storeSettings = Mock()
        
        storage.saveStoredSearch({"search": "some_search1", "old_search": "some_search2"})
        
        storage.retrieveSettings.assert_called_with({"search": "some_search1", "old_search": "some_search2"})

    def test_saveStoredSearch_should_remove_old_search_from_collection_and_prepend_new_search(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        storage = YouTubeStorage()
        storage.retrieveSettings = Mock()
        storage.retrieveSettings.return_value =  ["some_search4", "some_search2", "some_search3"]
        storage.storeSettings = Mock()
        
        storage.saveStoredSearch({"search": "some_search1", "old_search": "some_search2"})
        
        storage.storeSettings.assert_called_with({"search": "some_search1", "old_search": "some_search2"},['some_search1', 'some_search4', 'some_search3'])
        
    def test_saveStoredSearch_should_limit_search_collection_before_calling_store(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        storage = YouTubeStorage()
        storage.retrieveSettings = Mock()
        storage.retrieveSettings.return_value =  ["some_search4", "some_search2", "some_search3", "", "", "", "", "", "", "", ""]
        storage.storeSettings = Mock()
        
        storage.saveStoredSearch({"search": "some_search1", "old_search": "some_search2"})
        
        assert(len(storage.storeSettings.call_args[0][1]) == 10)
        storage.storeSettings.assert_called_with({"search": "some_search1", "old_search": "some_search2"},['some_search1', 'some_search4', 'some_search3',"", "", "", "", "", "", ""])

    def test_saveStoredSearch_should_call_getSettings_to_get_max_searches_count(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        storage = YouTubeStorage()
        storage.retrieveSettings = Mock()
        storage.retrieveSettings.return_value =  ["some_search2"]
        storage.storeSettings = Mock()
        
        storage.saveStoredSearch({"search": "some_search1", "old_search": "some_search2"})
        
        sys.modules["__main__"].settings.getSetting.assert_called_with("saved_searches")

    def test_saveStoredSearch_should_call_store_to_save_searches_collection(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        storage = YouTubeStorage()
        storage.retrieveSettings = Mock()
        storage.retrieveSettings.return_value =  ["some_search2"]
        storage.storeSettings = Mock()
        
        storage.saveStoredSearch({"search": "some_search1", "old_search": "some_search2"})
        
        assert(storage.storeSettings.call_count > 0)

    def test_editStoredSearch_should_exit_cleanly_if_search_param_is_missing(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        sys.modules["__main__"].common.getUserInput.return_value = "some_search3"
        storage = YouTubeStorage()
        storage.retrieve = Mock()
        storage.retrieve.return_value =  ["some_search2"]
        storage.storeSettings = Mock()
        
        storage.editStoredSearch({})
        
        assert(storage.storeSettings.call_count == 0)
        assert(storage.retrieve.call_count == 0)

    def test_editStoredSearch_should_ask_user_for_new_search_phrase(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        sys.modules["__main__"].language.return_value = "some_title"
        sys.modules["__main__"].common.getUserInput.return_value = "some_search3"
        storage = YouTubeStorage()
        storage.retrieveSettings = Mock()
        storage.retrieveSettings.return_value =  ["some_search2"]
        storage.storeSettings = Mock()
        
        storage.editStoredSearch({"search": "some_search1"})
        
        sys.modules["__main__"].common.getUserInput.assert_called_with('some_title', 'some_search1')

    def test_editStoredSearch_should_set_store_to_searches_if_editing_searches(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        sys.modules["__main__"].language.return_value = "some_title"
        sys.modules["__main__"].common.getUserInput.return_value = "some_search3"
        storage = YouTubeStorage()
        storage.retrieveSettings = Mock()
        storage.retrieveSettings.return_value =  ["some_search2"]
        storage.storeSettings = Mock()
        
        storage.editStoredSearch({"search": "some_search1"})
        
        assert(storage.storeSettings.call_args[0][0].has_key("feed"))
        
    def test_editStoredSearch_should_set_store_to_disco_if_editing_disco_searches(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        sys.modules["__main__"].language.return_value = "some_title"
        sys.modules["__main__"].common.getUserInput.return_value = "some_search3"
        storage = YouTubeStorage()
        storage.retrieveSettings = Mock()
        storage.retrieveSettings.return_value =  ["some_search2"]
        storage.storeSettings = Mock()
        
        storage.editStoredSearch({"search": "some_search1", "action": "edit_disco"})
        
        assert(storage.storeSettings.call_args[0][0].has_key("scraper"))

    def test_editStoredSearch_should_call_saveStoredSearch(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        sys.modules["__main__"].language.return_value = "some_title"
        sys.modules["__main__"].common.getUserInput.return_value = "some_search3"
        storage = YouTubeStorage()
        storage.retrieve = Mock()
        storage.retrieve.return_value =  ["some_search2"]
        storage.storeSettings = Mock()
        storage.saveStoredSearch = Mock()
        
        storage.editStoredSearch({"search": "some_search1", "action": "edit_disco"})
        
        storage.saveStoredSearch.assert_called_with({'search': 'some_search3', 'scraper': 'search_disco'})

    def test_editStoredSearch_should_remove_old_search_param_before_exiting(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        sys.modules["__main__"].language.return_value = "some_title"
        sys.modules["__main__"].common.getUserInput.return_value = "some_search3"
        storage = YouTubeStorage()
        storage.retrieve = Mock()
        storage.retrieve.return_value =  ["some_search2"]
        storage.storeSettings = Mock()
        storage.saveStoredSearch = Mock()
        params = {"search": "some_search1", "action": "edit_disco", "old_search": "some_search4"}
        
        storage.editStoredSearch(params)
        
        assert(params.has_key("old_search") == False)
        
    def test_editStoredSearch_should_set_search_params_before_exiting(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        sys.modules["__main__"].language.return_value = "some_title"
        sys.modules["__main__"].common.getUserInput.return_value = "some_search3"
        storage = YouTubeStorage()
        storage.retrieve = Mock()
        storage.retrieve.return_value =  ["some_search2"]
        storage.storeSettings = Mock()
        storage.saveStoredSearch = Mock()
        params = {"search": "some_search1", "action": "edit_disco", "old_search": "some_search4"}
        
        storage.editStoredSearch(params)
        
        assert(params.has_key("search"))
        assert(params["search"] == "some_search3")
        
    def test_getUserOptionFolder_should_return_modified_version_of_items_in_user_options(self):
        sys.modules["__main__"].language.return_value = "some_title"
        storage = YouTubeStorage()
        
        (result, status) = storage.getUserOptionFolder({})
        
        assert(len(result) == 4)
        assert(result[0]["user_feed"] == "favorites")
        assert(result[1]["user_feed"] == "playlists")
        assert(result[2]["user_feed"] == "subscriptions")
        assert(result[3]["user_feed"] == "uploads")
        
    def test_changeSubscriptionView_should_exit_cleanly_if_view_mode_is_not_in_params(self):
        storage = YouTubeStorage()
        storage.getStorageKey = Mock()
        storage.storeValue = Mock()
        
        storage.changeSubscriptionView({})
        
        assert(storage.getStorageKey.call_count == 0)
        assert(storage.storeValue.call_count == 0)

    def test_changeSubscriptionView_should_call_getStorageKey(self):
        storage = YouTubeStorage()
        storage.getStorageKey = Mock()
        storage.storeValue = Mock()
        
        storage.changeSubscriptionView({"view_mode": "my_view_mode"})
        
        storage.getStorageKey.assert_called_with({"user_feed": "my_view_mode", "view_mode": "my_view_mode"}, "viewmode")

    def test_changeSubscriptionView_should_call_storeValue(self):
        storage = YouTubeStorage()
        storage.getStorageKey = Mock()
        storage.getStorageKey.return_value = "my_key"
        storage.storeValue = Mock()
        
        storage.changeSubscriptionView({"view_mode": "my_view_mode"})
        
        storage.storeValue.assert_called_with("my_key", "my_view_mode")

    def test_changeSubscriptionView_should_fill_params_collection_before_exiting(self):
        storage = YouTubeStorage()
        storage.getStorageKey = Mock()
        storage.getStorageKey.return_value = "my_key"
        storage.storeValue = Mock()
        
        params = {"view_mode": "my_view_mode"}
        storage.changeSubscriptionView(params)
        
        assert(params.has_key("user_feed"))

    def test_reversePlaylistOrder_should_exit_cleanly_if_playlist_params_is_missing(self):
        storage = YouTubeStorage()
        storage.retrieve = Mock()
        storage.retrieve.return_value =  "false"
        storage.store = Mock()
        
        storage.reversePlaylistOrder({})
        
        assert(storage.retrieve.call_count == 0)
        assert(storage.store.call_count == 0)
                
    def test_reversePlaylistOrder_should_call_retrieve_to_fetch_reverse_value(self):
        storage = YouTubeStorage()
        storage.retrieve = Mock()
        storage.retrieve.return_value =  "false"
        storage.store = Mock()
        
        storage.reversePlaylistOrder({"playlist": "some_playlists"})
        
        storage.retrieve.assert_called_with({'playlist': 'some_playlists'}, 'value')
        
    def test_reversePlaylistOrder_should_call_store_to_save_reverse_value(self):
        storage = YouTubeStorage()
        storage.retrieve = Mock()
        storage.retrieve.return_value =  "false"
        storage.store = Mock()
        
        storage.reversePlaylistOrder({"playlist": "some_playlists"})
        
        storage.store.assert_called_with({'playlist': 'some_playlists'}, 'true', 'value')
        
    def test_reversePlaylistOrder_should_executebuiltin_on_succes(self):
        storage = YouTubeStorage()
        storage.retrieve = Mock()
        storage.retrieve.return_value =  "false"
        storage.store = Mock()
        
        storage.reversePlaylistOrder({"playlist": "some_playlists"})
        
        sys.modules["__main__"].xbmc.executebuiltin.assert_called_with('Container.Refresh')
        
    def test_getReversePlaylistOrder_should_return_false_if_playlist_is_not_in_params(self):
        storage = YouTubeStorage()
        storage.retrieve = Mock()
        storage.retrieve.return_value =  "true"
        storage.store = Mock()
        
        result = storage.getReversePlaylistOrder()
        
        assert(result == False)
        
    def test_getReversePlaylistOrder_should_call_retrieve_to_fetch_reverse_value(self):
        storage = YouTubeStorage()
        storage.retrieve = Mock()
        storage.retrieve.return_value =  "true"
        
        result = storage.getReversePlaylistOrder({"playlist": "some_playlists"})
        
        assert(result == True)
        
    def test_getStorageKey_should_call_getValueStorageKey_if_type_is_value(self):
        storage = YouTubeStorage()
        storage._getValueStorageKey = Mock()
        
        result = storage.getStorageKey({"some_param": "param_value"},"value")
        
        storage._getValueStorageKey.assert_called_with({"some_param": "param_value"},{})
        
    def test_getStorageKey_should_call_getViewModeStorageKey_if_type_is_viewmode(self):
        storage = YouTubeStorage()
        storage._getViewModeStorageKey = Mock()
        
        result = storage.getStorageKey({"some_param": "param_value"}, "viewmode")
        
        storage._getViewModeStorageKey.assert_called_with({"some_param": "param_value"},{})
        
    def test_getStorageKey_should_call_getThumbnailStorageKey_if_type_is_thumbnail(self):
        storage = YouTubeStorage()
        storage._getThumbnailStorageKey = Mock()
        
        result = storage.getStorageKey({"some_param": "param_value"}, "thumbnail")
        
        storage._getThumbnailStorageKey.assert_called_with({"some_param": "param_value"},{})        
        
    def test_getStorageKey_should_call_getResultSetStorageKey_if_type_is_not_set(self):
        storage = YouTubeStorage()
        storage._getResultSetStorageKey = Mock()
        
        result = storage.getStorageKey({"some_param": "param_value"})
        
        storage._getResultSetStorageKey.assert_called_with({"some_param": "param_value"})
        
    def test_getThumbnailStorageKey_should_return_correct_key_for_search_path(self):
        storage = YouTubeStorage()
        
        result = storage._getThumbnailStorageKey({"search": "some_search", "feed": "search"})
        
        assert(result == "search_some_search_thumb")

    def test_getThumbnailStorageKey_should_return_correct_key_for_disco_search_path(self):
        storage = YouTubeStorage()
        
        result = storage._getThumbnailStorageKey({"search": "some_search"})
        
        assert(result == "disco_search_some_search_thumb")
        
    def test_getThumbnailStorageKey_should_return_correct_key_for_search_item(self):
        storage = YouTubeStorage()
        
        result = storage._getThumbnailStorageKey({"some_param": "something"}, {"search": "some_search", "feed": "search"})
        
        assert(result == "search_some_search_thumb")
        
    def test_getThumbnailStorageKey_should_return_correct_key_for_disco_search_item(self):
        storage = YouTubeStorage()
        
        result = storage._getThumbnailStorageKey({"some_param": "something"}, {"search": "some_search"})
        
        assert(result == "disco_search_some_search_thumb")

    def test_getThumbnailStorageKey_should_return_correct_key_for_user_feed_path(self):
        storage = YouTubeStorage()
        
        result = storage._getThumbnailStorageKey({"user_feed": "something"})
        
        assert(result == "something_thumb")
        
    def test_getThumbnailStorageKey_should_return_correct_key_for_channel_path(self):
        storage = YouTubeStorage()
        
        result = storage._getThumbnailStorageKey({"user_feed": "some_feed", "channel": "some_channel"})
        
        assert(result == "subscriptions_some_channel_thumb")
        
    def test_getThumbnailStorageKey_should_return_correct_key_for_channel_item(self):
        storage = YouTubeStorage()
        
        result = storage._getThumbnailStorageKey({"user_feed": "something"},{"channel": "some_channel"})
        
        assert(result == "subscriptions_some_channel_thumb")
        
    def test_getThumbnailStorageKey_should_return_correct_key_for_playlist_path(self):
        storage = YouTubeStorage()
        
        result = storage._getThumbnailStorageKey({"user_feed": "some_feed", "playlist": "some_playlist"})
        
        assert(result == "playlist_some_playlist_thumb")

    def test_getThumbnailStorageKey_should_return_correct_key_for_playlist_item(self):
        storage = YouTubeStorage()
        
        result = storage._getThumbnailStorageKey({"user_feed": "something"},{"playlist": "some_playlist"})
        
        assert(result == "playlist_some_playlist_thumb")
        
    def test_getThumbnailStorageKey_should_appen_thumb_to_key(self):
        storage = YouTubeStorage()
        
        result = storage._getThumbnailStorageKey({"some_param": "something"}, {"search": "some_search"})
        
        assert(result[result.rfind("_"):] == "_thumb")
        
    def test_getValueStorageKey_should_return_correct_key_for_reverse_playlist_action(self):
        storage = YouTubeStorage()
        
        result = storage._getValueStorageKey({"action": "reverse_order", "playlist": "some_playlist"})
        
        assert(result == "reverse_playlist_some_playlist")

    def test_getValueStorageKey_should_return_correct_key_for_reverse_playlist_path(self):
        storage = YouTubeStorage()
        
        result = storage._getValueStorageKey({"user_feed": "playlist", "playlist": "some_playlist"})
        
        assert(result == "reverse_playlist_some_playlist")

    def test_getValueStorageKey_should_return_correct_key_for_reverse_playlist_item(self):
        storage = YouTubeStorage()
        
        result = storage._getValueStorageKey({"user_feed": "playlist"}, {"playlist": "some_playlist"})
        
        assert(result == "reverse_playlist_some_playlist")

    def test_getValueStorageKey_should_handle_external_marker(self):
        storage = YouTubeStorage()
        
        result = storage._getValueStorageKey({"user_feed": "playlist", "external": "true", "contact": "some_contact"}, {"playlist": "some_playlist"})
        
        assert(result == "reverse_playlist_some_playlist_external_some_contact")

    def test_getViewModeStorageKey_should_handle_external_marker(self):
        storage = YouTubeStorage()
        
        result = storage._getViewModeStorageKey({"channel": "some_channel", "external": "true", "contact": "some_contact"})
        
        assert(result[:result.find("_")] == "external" )

    def test_getViewModeStorageKey_should_return_correct_key_for_channel_item(self):
        storage = YouTubeStorage()
        
        result = storage._getViewModeStorageKey({},{"channel": "some_channel"})
        
        assert(result == "view_mode_some_channel")

    def test_getViewModeStorageKey_should_return_correct_key_for_channel_path(self):
        storage = YouTubeStorage()
        
        result = storage._getViewModeStorageKey({"channel": "some_channel"})
        
        assert(result == "view_mode_some_channel")

    def test_getResultSetStorageKey_should_return_correct_key_for_music_category_path(self):
        storage = YouTubeStorage()
        
        result = storage._getResultSetStorageKey({"scraper": "music", "category": "some_category"})
        
        assert(result == "s_music_category_some_category")

    def test_getResultSetStorageKey_should_return_correct_key_for_disco_search_path(self):
        storage = YouTubeStorage()
        
        result = storage._getResultSetStorageKey({"scraper": "disco_search", "search": "some_search"})
        
        assert(result == "store_disco_searches")

    def test_getResultSetStorageKey_should_return_correct_key_for_category_path(self):
        storage = YouTubeStorage()
        
        result = storage._getResultSetStorageKey({"scraper": "categories", "category": "some_category"})
        
        assert(result == "s_categories_category_some_category")

    def test_getResultSetStorageKey_should_return_correct_key_for_playlist_path(self):
        storage = YouTubeStorage()
        
        result = storage._getResultSetStorageKey({"user_feed": "playlist", "playlist": "some_playlist"})
        
        assert(result == "result_playlist_some_playlist")

    def test_getResultSetStorageKey_should_return_correct_key_for_subscription_path(self):
        storage = YouTubeStorage()
        
        result = storage._getResultSetStorageKey({"user_feed": "subscriptions", "channel": "some_channel"})
        
        assert(result == "result_subscriptions_some_channel")

    def test_getResultSetStorageKey_should_handle_external_correctly(self):
        storage = YouTubeStorage()
        
        result = storage._getResultSetStorageKey({"user_feed": "playlist", "playlist": "some_playlist", "external": "true", "contact": "some_contact"})
        
        assert(result.find("external") > 0)

    def test_getResultSetStorageKey_should_return_correct_key_for_stored_searches(self):
        storage = YouTubeStorage()
        
        result = storage._getResultSetStorageKey({"feed": "search"})
        
        assert(result == "store_searches")

    def test_getResultSetStorageKey_should_return_correct_key_for_generic_stores(self):
        storage = YouTubeStorage()
        
        result = storage._getResultSetStorageKey({"store": "pokeystore"})
        
        assert(result == "store_pokeystore")

    def test_store_should_call_getStorageKey_to_fetch_correct_storage_key(self):
        storage = YouTubeStorage()
        storage.getStorageKey = Mock()
        
        result = storage.store({"store": "pokeystore"})
        
        storage.getStorageKey.assert_called_with({'store': 'pokeystore'}, '', {})

    def test_store_should_call_storeValue_if_type_is_set(self):
        storage = YouTubeStorage()
        storage.storeValue = Mock()
        storage.getStorageKey = Mock()
        storage.getStorageKey.return_value = "key"
        
        result = storage.store({}, {"store": "pokeystore"}, "value")

        print repr(result)

        storage.storeValue.assert_called_with("key", {"store": "pokeystore"})
        
    def test_store_should_call_storeResultSet_if_type_is_not_set(self):
        storage = YouTubeStorage()
        storage.storeResultSet = Mock()
        storage.getStorageKey = Mock()
        storage.getStorageKey.return_value = "key"

        storage.store({}, {"store": "pokeystore"})

        storage.storeResultSet.assert_called_with("key", {"store": "pokeystore"})

    def test_storeValue_should_call_cache_set_with_correct_params(self):
        storage = YouTubeStorage()
        storage.storeResultSet = Mock()
        storage.getStorageKey = Mock()
        storage.getStorageKey.return_value = "key"
        
        storage.storeValue("some_key", "some_value")
        
        sys.modules["__main__"].cache.set.assert_called_with("some_key", "some_value")

    def test_storeResultSet_should_call_cache_set_with_correct_params_by_default(self):
        storage = YouTubeStorage()
        
        storage.storeResultSet("some_key", ["some_value"])
        
        sys.modules["__main__"].cache.set.assert_called_with("some_key", repr(["some_value"]))
        
    def test_storeResultSet_should_call_retrieveResultSet_if_prepend_is_in_params(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        storage = YouTubeStorage()
        storage.retrieveResultSet = Mock()
        storage.retrieveResultSet.return_value = []
        
        storage.storeResultSet("some_key", ["some_value"], {"prepend": "true"})
        
        storage.retrieveResultSet.assert_called_with("some_key")

    def test_storeResultSet_should_call_settings_getSetting_to_get_stored_searches_limit_if_prepend_is_params(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        storage = YouTubeStorage()
        storage.retrieveResultSet = Mock()
        storage.retrieveResultSet.return_value = []
        
        storage.storeResultSet("some_key", ["some_value"], {"prepend": "true"})
        
        sys.modules["__main__"].settings.getSetting.assert_called_with("saved_searches")
        
    def test_storeResultSet_should_call_retrieveResultSet_if_append_is_in_params(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        storage = YouTubeStorage()
        storage.retrieveResultSet = Mock()
        storage.retrieveResultSet.return_value = []
        
        storage.storeResultSet("some_key", ["some_value"], {"append": "true"})
        
        storage.retrieveResultSet.assert_called_with("some_key")
                
    def test_storeResultSet_should_call_cache_set_if_prepend_is_in_params(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        storage = YouTubeStorage()
        storage.retrieveResultSet = Mock()
        storage.retrieveResultSet.return_value = []
        
        storage.storeResultSet("some_key", "some_value", {"prepend": "true"})
        
        sys.modules["__main__"].cache.set.assert_called_with("some_key", repr(["some_value"]))
        
    def test_storeResultSet_should_call_cache_set_correctly_if_append_is_in_params(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        storage = YouTubeStorage()
        storage.retrieveResultSet = Mock()
        storage.retrieveResultSet.return_value = ["smokey"]
        
        storage.storeResultSet("some_key", "some_value", {"append": "true"})
        
        sys.modules["__main__"].cache.set.assert_called_with("some_key", repr(["smokey", "some_value"]))
        
    def test_storeResultSet_should_append_item_to_collection_if_append_is_in_params(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        storage = YouTubeStorage()
        storage.retrieveResultSet = Mock()
        
        storage.storeResultSet("some_key", "some_value", {"append": "true"})
        
        storage.retrieveResultSet().append.assert_called_with("some_value")
        
    def test_storeResultSet_should_prepend_item_to_collection_if_prepend_is_in_params(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        storage = YouTubeStorage()
        storage.retrieveResultSet = Mock()
        storage.retrieveResultSet.return_value = ["some_default"]
        
        storage.storeResultSet("some_key", "some_value", {"prepend": "true"})
        
        sys.modules["__main__"].cache.set.assert_called_with("some_key", repr(["some_value", "some_default"]))
        
    def test_retrieve_should_call_getStorageKey_to_fetch_correct_storage_key(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        storage = YouTubeStorage()
        storage.getStorageKey = Mock()
        storage.getStorageKey.return_value = "some_key"
        
        storage.retrieve("some_key", "some_value", {"prepend": "true"})
        
        storage.getStorageKey.assert_called_with("some_key", "some_value", {"prepend": "true"})

    def test_retrieve_should_call_retrieveValue_if_type_is_set(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        storage = YouTubeStorage()
        storage.getStorageKey = Mock()
        storage.getStorageKey.return_value = "some_key"
        storage.retrieveValue = Mock()
        
        storage.retrieve("some_key", "thumbnail")
        
        storage.retrieveValue.assert_called_with("some_key")
        
    def test_retrieve_should_call_retrieveResultSet_if_type_is_not_set(self):
        sys.modules["__main__"].settings.getSetting.return_value = "0"
        storage = YouTubeStorage()
        storage.getStorageKey = Mock()
        storage.getStorageKey.return_value = "some_key"
        storage.retrieveResultSet = Mock()
        
        storage.retrieve("some_key")
        
        storage.retrieveResultSet.assert_called_with("some_key")
        
    def test_retrieveValue_should_call_cache_get_with_correct_params(self):
        storage = YouTubeStorage()
        
        storage.retrieveValue("some_key")
        
        sys.modules["__main__"].cache.get.assert_called_with("some_key")
        
    def test_retrieveResultSet_should_call_get_with_correct_params(self):
        storage = YouTubeStorage()
        
        storage.retrieveResultSet("some_key")
        
        sys.modules["__main__"].cache.get.assert_called_with("some_key")

    def test_retrieveResultSet_should_evaluate_content_from_sql_get(self):
        storage = YouTubeStorage()
        sys.modules["__main__"].cache.get.return_value = "['some_value']"
        
        result = storage.retrieveResultSet("some_key")
        
        assert(result == ['some_value'])

    def test_updateVideoIdStatusInCache_should_add_video_items_to_collection_saved_in_cache(self):
        storage = YouTubeStorage()

        storage.updateVideoIdStatusInCache("some_id",[{"videoid":"test1"}])

        sys.modules["__main__"].cache.setMulti.assert_called_with("some_id", {"test1":repr({"videoid":"test1"})})

    def test_updateVideoIdStatusInCache_should_not_add_items_without_a_video_id_to_collection_saved_in_cache(self):
        storage = YouTubeStorage()

        storage.updateVideoIdStatusInCache("some_id",[{"other_stuff":"stuff"}])

        sys.modules["__main__"].cache.setMulti.assert_called_with("some_id", {})

    def test_updateVideoIdStatusInCache_should_call_cache_setMulti_to_save_collection_in_cache(self):
        storage = YouTubeStorage()

        storage.updateVideoIdStatusInCache("some_id",[{"videoid":"test1"}])

        assert (sys.modules["__main__"].cache.setMulti.call_count == 1)

    def test_getVideoIdStatusFromCache_should_set_overlay_information_on_requested(self):
        storage = YouTubeStorage()
        sys.modules["__main__"].cache.getMulti.return_value = ["2"]

        result = storage.getVideoIdStatusFromCache("some_id", [{"videoid":"vid1", "Overlay":"1"}])

        assert (result[0]["Overlay"] == "2")

    def test_getVideoIdStatusFromCache_should_result_sets_with_missing_items(self):
        storage = YouTubeStorage()
        sys.modules["__main__"].cache.getMulti.return_value = ["2"]

        result = storage.getVideoIdStatusFromCache("some_id", [{"videoid":"vid1", "Overlay":"1"},{"videoid":"vid2", "Overlay":"1"}])

        assert (result[0]["Overlay"] == "2")
        assert (result[1]["Overlay"] == "1")

    def test_getVideoIdStatusFromCache_should_request_information_for_video_items(self):
        storage = YouTubeStorage()
        sys.modules["__main__"].cache.getMulti.return_value = ["2"]

        storage.getVideoIdStatusFromCache("some_id", [{"videoid":"vid1"},{"videoid":"vid2"}])

        sys.modules["__main__"].cache.getMulti.assert_any_call("some_id",["vid1","vid2"])

    def test_getVideoIdStatusFromCache_should_not_request_information_for_items_without_a_videoid(self):
        storage = YouTubeStorage()
        sys.modules["__main__"].cache.getMulti.return_value = ["2"]

        storage.getVideoIdStatusFromCache("some_id", [{"videoid":"vid1"},{"other_id":"stuff"}])

        sys.modules["__main__"].cache.getMulti.assert_any_call("some_id",["vid1"])

    def test_getVideoIdStatusFromCache_should_call_cache_GetMulti_to_request_information(self):
        storage = YouTubeStorage()
        sys.modules["__main__"].cache.getMulti.return_value = ["2"]

        storage.getVideoIdStatusFromCache("some_id", [{"videoid":"vid1"},{"other_id":"stuff"}])

        assert (sys.modules["__main__"].cache.getMulti.call_count == 1)

if __name__ == '__main__':
        nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubeSubtitleControl
# -*- coding: utf-8 -*-
import nose
import BaseTestCase
from YouTubeSubtitleControl import YouTubeSubtitleControl
from mock import Mock, patch
import sys

class TestYouTubePlayer(BaseTestCase.BaseTestCase):

    def test_saveSubtitle_should_call_xbmcvfs_translatePath(self):
        sys.modules["__main__"].xbmc.translatePath.return_value = "tempFilePath"
        sys.modules["__main__"].common.makeUTF8.return_value = "testTitle"

        subtitles = YouTubeSubtitleControl()
        subtitles.getSubtitleFileName = Mock()

        subtitles.saveSubtitle("my_subtitle_stream", {"Title": "testTitle", "videoid": "someVideoId", "download_path": "downloadFilePath"})

        sys.modules["__main__"].xbmc.translatePath.assert_called_with("somepath")

    def test_saveSubtitle_should_call_xbmcvfs_rename(self):
        sys.modules["__main__"].xbmc.translatePath.return_value = "tempFilePath"
        sys.modules["__main__"].common.makeUTF8.return_value = "testTitle"
        subtitles = YouTubeSubtitleControl()
        subtitles.getSubtitleFileName = Mock(return_value="testTitle-[someVideoId].ssa")

        subtitles.saveSubtitle("my_subtitle_stream", {"Title": "testTitle", "videoid": "someVideoId", "download_path": "downloadFilePath"})

        sys.modules["__main__"].xbmcvfs.rename.assert_called_with("tempFilePath/testTitle-[someVideoId].ssa", "downloadFilePath/testTitle-[someVideoId].ssa")

    def test_saveSubtitle_should_call_openFile_with_correct_params(self):
        sys.modules["__main__"].xbmc.translatePath.return_value = "tempFilePath"
        sys.modules["__main__"].common.makeUTF8.return_value = "testTitle"
        subtitles = YouTubeSubtitleControl()
        subtitles.getSubtitleFileName = Mock(return_value="testTitle-[someVideoId].ssa")

        subtitles.saveSubtitle("my_subtitle_stream", {"Title": "testTitle", "videoid": "someVideoId", "download_path": "downloadFilePath"})

        sys.modules["__main__"].storage.openFile.assert_called_with("tempFilePath/testTitle-[someVideoId].ssa", "w") # was "wb"

    def test_downloadSubtitle_should_call_transformSubtitleToSSA(self):
        player = YouTubeSubtitleControl()
        sys.modules["__main__"].core._fetchPage = Mock()
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 200, "content": "nothingness"}
        subtitlesettings = ["false", "0", "true"]
        sys.modules["__main__"].settings.getSetting = Mock()
        sys.modules["__main__"].settings.getSetting.side_effect = lambda x: subtitlesettings.pop()
        player.transformAnnotationToSSA = Mock()
        player.transformAnnotationToSSA.return_value = ("", "style")

        player.downloadSubtitle()

        player.transformAnnotationToSSA.assert_called_with("nothingness")

    def test_downloadSubtitle_should_call_saveSubtitle(self):
        player = YouTubeSubtitleControl()
        sys.modules["__main__"].core._fetchPage = Mock()
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 200, "content": "nothingness"}
        subtitlesettings = ["false", "0", "true"]
        sys.modules["__main__"].settings.getSetting = Mock()
        sys.modules["__main__"].settings.getSetting.side_effect = lambda x: subtitlesettings.pop()
        player.transformAnnotationToSSA = Mock()
        player.transformAnnotationToSSA.return_value = ("something", "style")
        player.saveSubtitle = Mock()

        result = player.downloadSubtitle()

        assert(result == True)
        assert(player.saveSubtitle.called)

    def test_downloadSubtitle_should_call_getSubtitleUrl(self):
        player = YouTubeSubtitleControl()
        sys.modules["__main__"].core._fetchPage = Mock()
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 200, "content": "nothingness"}

        subtitlesettings = ["false", "2", "true"]

        sys.modules["__main__"].settings.getSetting = Mock()
        sys.modules["__main__"].settings.getSetting.side_effect = lambda x: subtitlesettings.pop()
        player.transformAnnotationToSSA = Mock()
        player.transformAnnotationToSSA.return_value = ("", "style")
        player.getSubtitleUrl = Mock()
        player.getSubtitleUrl.return_value = ""

        player.downloadSubtitle()

        player.getSubtitleUrl.assert_called_with({})

    def test_downloadSubtitle_should_call_getTranscriptionUrl(self):
        player = YouTubeSubtitleControl()
        sys.modules["__main__"].core._fetchPage = Mock()
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 200, "content": "nothingness"}
        subtitlesettings = ["true", "2", "true"]

        sys.modules["__main__"].settings.getSetting = Mock()
        sys.modules["__main__"].settings.getSetting.side_effect = lambda x: subtitlesettings.pop()
        player.transformAnnotationToSSA = Mock()
        player.transformAnnotationToSSA.return_value = ("", "style")
        player.getSubtitleUrl = Mock()
        player.getSubtitleUrl.return_value = ""
        player.getTranscriptionUrl = Mock()
        player.getTranscriptionUrl.return_value = ""

        player.downloadSubtitle()

        player.getTranscriptionUrl.assert_called_with({})

    def test_convertSecondsToTimestamp_should_convert(self):
        player = YouTubeSubtitleControl()

        res = player.convertSecondsToTimestamp(250.43800000000002)
        print repr(res)

        assert(res == "0:04:10.438")

    def test_downloadSubtitle_should_call_transformSubtitleXMLtoSRT(self):
        player = YouTubeSubtitleControl()
        sys.modules["__main__"].core._fetchPage = Mock()
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 200, "content": "nothingness"}

        subtitlesettings = ["true", "2", "true"]

        sys.modules["__main__"].settings.getSetting = Mock()
        sys.modules["__main__"].settings.getSetting.side_effect = lambda x: subtitlesettings.pop()
        player.transformAnnotationToSSA = Mock()
        player.transformAnnotationToSSA.return_value = ("", "style")
        player.getSubtitleUrl = Mock()
        player.getSubtitleUrl.return_value = ""
        player.getTranscriptionUrl = Mock()
        player.getTranscriptionUrl.return_value = "something"
        player.transformSubtitleXMLtoSRT = Mock()
        player.transformSubtitleXMLtoSRT.return_value = ""

        player.downloadSubtitle()

        player.transformSubtitleXMLtoSRT.assert_called_with("nothingness")

    def test_downloadSubtitle_should_exit_gracefully_if_subtitles_and_annotations_are_disabled(self):
        player = YouTubeSubtitleControl()

        subtitlessettings = ["false", "0", "false"]

        def popSetting(self, *args, **kwargs):
            val = subtitlessettings.pop()
            return val

        sys.modules["__main__"].settings.getSetting = Mock()
        sys.modules["__main__"].settings.getSetting.side_effect = popSetting

        result = player.downloadSubtitle()

        assert(result == False)

    def test_getSubtitleUrl_should_call_fetchPage_with_correct_url(self):
        player = YouTubeSubtitleControl()
        sys.modules["__main__"].core._fetchPage = Mock()
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 303, "content": ""}

        player.getSubtitleUrl({"videoid": "some_id"})

        sys.modules["__main__"].core._fetchPage.assert_called_with({"link": player.urls["timed_text_index"] % ('some_id')})

    def test_getTranscriptionUrl_should_call_return_correct_url(self):
        player = YouTubeSubtitleControl()
        sys.modules["__main__"].core._fetchPage = Mock()
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 303, "content": ""}
        sys.modules["__main__"].settings.getSetting = Mock()
        sys.modules["__main__"].settings.getSetting.return_value = "1"
        ret = player.getTranscriptionUrl({"videoid": "some_id", "ttsurl": "http://some.url/transcript"})
        print ret
        assert(ret == "http://some.url/transcript&type=trackformat=1&lang=en&kind=asr&name=&v=some_id&tlang=en")

    def test_getSubtitleUrl_should_find_url_with_proper_language_code(self):
        player = YouTubeSubtitleControl()
        sys.modules["__main__"].core._fetchPage = Mock()
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 200, "content": self.readTestInput("timedtextDirectoryTest.xml", False)}
        sys.modules["__main__"].settings.getSetting = Mock()
        sys.modules["__main__"].settings.getSetting.return_value = "3"
        sys.modules["__main__"].common.parseDOM.side_effect = [["de"], ["german"], ["deutch"]]
        sys.modules["__main__"].core.getVideoIdStatusFromCache = Mock()

        url = player.getSubtitleUrl({"videoid": "some_id"})
        print repr(url)

        assert(url.find("lang=de") > 0)

    def test_getSubtitleUrl_should_fall_back_to_english_if_proper_language_code_is_not_found(self):
        player = YouTubeSubtitleControl()
        sys.modules["__main__"].core._fetchPage = Mock()
        sys.modules["__main__"].core._fetchPage.return_value = {"status": 200, "content": self.readTestInput("timedtextDirectoryTest.xml", False)}
        sys.modules["__main__"].core.getVideoIdStatusFromCache = Mock()
        sys.modules["__main__"].settings.getSetting = Mock()
        sys.modules["__main__"].settings.getSetting.return_value = "2"
        sys.modules["__main__"].common.parseDOM.side_effect = [["en"], ["english"], ["english"]]

        url = player.getSubtitleUrl({"videoid": "some_id"})

        assert(url.find("lang=en") > 0)

    def test_transformSubtitleXMLtoSRT_should_parse_youtube_subtitle_xml(self):
        player = YouTubeSubtitleControl()
        sys.modules["__main__"].common.replaceHTMLCodes = Mock()
        sys.modules["__main__"].common.replaceHTMLCodes.side_effect = lambda x: x.encode("ascii", 'ignore')
        sys.modules["__main__"].common.parseDOM.side_effect = [["content"] * 3, ["content"], ["00"], ["10"], ["content1"], ["20"], ["30"], ["content3"], ["40"], ["50"]]

        result = player.transformSubtitleXMLtoSRT(self.readTestInput("subtitleTest.xml", False))

        assert(len(result.split("\r\n")) == 4)

    def test_transformSubtitleXMLtoSRT_should_call_replaceHTMLCodes_for_user_visible_text(self):
        sys.modules["__main__"].common.parseDOM.side_effect = [["content TEXT"] * 2, ["text"], ["14.017"], ["2.07"], ["text"], ["16.087"], ["2.996"]]
        player = YouTubeSubtitleControl()
        player.simpleReplaceHTMLCodes = Mock()
        player.simpleReplaceHTMLCodes.side_effect = lambda x: x.encode("ascii", 'ignore')

        result = player.transformSubtitleXMLtoSRT(self.readTestInput("subtitleTest.xml", False))

        print repr(result)

        assert(player.simpleReplaceHTMLCodes.call_count > 0)

    def test_transformSubtitleXMLtoSRT_should_correctly_find_start_time_for_text_elements(self):
        input = '<?xml version="1.0" encoding="utf-8" ?><transcript>\n\
                <text start="14.017" dur="2.07">first</text>\n\
                <text start="16.087" dur="2.996">second</text>\n\
                </transcript>'
        player = YouTubeSubtitleControl()
        sys.modules["__main__"].common.replaceHTMLCodes = Mock()
        sys.modules["__main__"].common.replaceHTMLCodes.side_effect = lambda x: x.encode("ascii", 'ignore')
        sys.modules["__main__"].common.parseDOM.side_effect = [["content TEXT"] * 2, ["text"], ["14.017"], ["2.07"], ["text"], ["16.087"], ["2.996"]]

        result = player.transformSubtitleXMLtoSRT(input).split("\r\n")

        assert(result[0].find("Marked=0,0:00:14.017") > 0)
        assert(result[1].find("Marked=0,0:00:16.087") > 0)

    def test_transformSubtitleXMLtoSRT_should_correctly_recalculate_duration_time_for_text_elements(self):
        input = '<?xml version="1.0" encoding="utf-8" ?><transcript>\n\
                <text start="14.017" dur="2.07">first</text>\n\
                <text start="16.087" dur="2.996">second</text>\n\
                </transcript>'
        player = YouTubeSubtitleControl()
        sys.modules["__main__"].common.replaceHTMLCodes = Mock()
        sys.modules["__main__"].common.replaceHTMLCodes.side_effect = lambda x: x.encode("ascii", 'ignore')
        sys.modules["__main__"].common.parseDOM.side_effect = [["content TEXT"] * 2, ["text"], ["14.017"], ["2.07"], ["text"], ["16.087"], ["2.996"]]

        result = player.transformSubtitleXMLtoSRT(input).split("\r\n")

        assert(result[0].find("0:00:16.087,Default") > 0)
        assert(result[1].find("0:00:19.083,Default") > 0)

    def test_transformAlpha_should_tranform_transparent(self):
        player = YouTubeSubtitleControl()

        color = player.transformAlpha("0.0")
        print color
        assert(color == "-1")

    def test_transformAlpha_should_tranform_80(self):
        player = YouTubeSubtitleControl()

        color = player.transformAlpha("0.800000011921")
        print color
        assert(color == "34")

    def test_transformColor_should_convert_white(self):
        player = YouTubeSubtitleControl()

        color = player.transformColor("16777215")
        print color
        assert(color == "ffffff")

    def test_transformColor_should_convert_red(self):
        player = YouTubeSubtitleControl()

        color = player.transformColor("13369344")
        print color
        assert(color == "0000cc")

    def test_transformColor_should_convert_blue(self):
        player = YouTubeSubtitleControl()

        color = player.transformColor("9828")
        print color
        assert(color == "642600")

    def test_transformColor_should_convert_0(self):
        player = YouTubeSubtitleControl()

        color = player.transformColor("0")
        print color
        assert(color == "000000")

    def test_transformAnnotationToSSA_should_parse_youtube_annotations_xml(self):
        player = YouTubeSubtitleControl()
        sys.modules["__main__"].common.replaceHTMLCodes = Mock()
        sys.modules["__main__"].common.replaceHTMLCodes.side_effect = lambda x: x.encode("ascii", 'ignore')
        sys.modules["__main__"].common.parseDOM.side_effect = [["content TEXT"], ["TEXT"], ["popup"], ["popup"], ["0:00:06.5", "0:01:06.5"], [0], [0], [0], [0], [["snode"]], ["16777215"], ["26777215"], ["36777215"], ["46777215"]]

        (result, style) = player.transformAnnotationToSSA(self.readTestInput("annotationsTest.xml", False).encode("utf-8"))
        print repr(result)
        assert(len(result.split("\r\n")) == 2)

    def test_transformAnnotationToSSA_should_call_replaceHTMLCodes_for_user_visible_text(self):
        player = YouTubeSubtitleControl()
        sys.modules["__main__"].common.replaceHTMLCodes = Mock()
        sys.modules["__main__"].common.replaceHTMLCodes.side_effect = lambda x: x.encode("ascii", 'ignore')
        sys.modules["__main__"].common.parseDOM.side_effect = [["content TEXT"], ["TEXT"], ["bla"], ["bla2"], []]

        result = player.transformAnnotationToSSA(self.readTestInput("annotationsTest.xml", False).encode("utf-8"))
        print repr(result)

        assert(sys.modules["__main__"].common.replaceHTMLCodes.call_count > 0)

    def test_addSubtitles_should_call_downloadSubtitle(self):
        player = YouTubeSubtitleControl()

        sys.modules["__main__"].common.makeUTF8.return_value = "testTitle"
        sys.modules["__main__"].settings.getSetting = Mock()
        sys.modules["__main__"].settings.getSetting.return_value = "testDownloadPath"
        sys.modules["__main__"].xbmcvfs.exists.return_value = False
        player.downloadSubtitle = Mock()
        player.getSubtitleFileName = Mock(return_value="testTitle-[testid].ssa")
        player.downloadSubtitle.return_value = False

        player.addSubtitles({"videoid": "testid", "Title": "testTitle"})

        player.downloadSubtitle.assert_called_with({"videoid": "testid", "Title": "testTitle"})

    def test_addSubtitles_should_check_if_subtitle_exists_locally_before_calling_downloadSubtitle(self):
        player = YouTubeSubtitleControl()

        settings = [False, True]
        sys.modules["__main__"].settings.getSetting.return_value = "testDownloadPath"
        sys.modules["__main__"].xbmcvfs.exists.side_effect = lambda x: settings.pop()
        sys.modules["__main__"].common.makeUTF8.return_value = "testTitle"
        player.downloadSubtitle = Mock()
        player.getSubtitleFileName = Mock(return_value="testTitle-[testid].ssa")
        player.downloadSubtitle.return_value = False

        player.addSubtitles({"videoid": "testid", "Title": "testTitle"})

        sys.modules["__main__"].xbmcvfs.exists.assert_called_with('testDownloadPath/testTitle-[testid].ssa')
        assert(player.downloadSubtitle.call_count == 0)

    def test_addSubtitles_should_call_xbmcs_setSubtitles(self):
        sys.modules["__main__"].settings.getSetting.return_value = "testDownloadPath"
        sys.modules["__main__"].xbmcvfs.exists.return_value = True
        sys.modules["__main__"].common.makeUTF8.return_value = "testTitle"
        player = YouTubeSubtitleControl()
        player.getSubtitleFileName = Mock(return_value="testTitle-[testid].ssa")
        player.downloadSubtitle = Mock()
        player.downloadSubtitle.return_value = True

        player.addSubtitles({"videoid": "testid", "Title": "testTitle"})

        sys.modules["__main__"].xbmcvfs.exists.assert_called_with('testDownloadPath/testTitle-[testid].ssa')
        sys.modules["__main__"].xbmc.Player().setSubtitles.assert_called_with('testDownloadPath/testTitle-[testid].ssa')

    def test_addSubtitles_should_sleep_for_1_second_if_player_isnt_ready(self):
        sys.modules["__main__"].settings.getSetting.return_value = "testDownloadPath"
        sys.modules["__main__"].xbmcvfs.exists.return_value = True
        sys.modules["__main__"].xbmc.Player().isPlaying.side_effect = [False, True] 
        sys.modules["__main__"].common.makeUTF8.return_value = "testTitle"
        patcher = patch("time.sleep")
        patcher.start()
        sleep = Mock()
        import time
        time.sleep = sleep
        player = YouTubeSubtitleControl()
        player.getSubtitleFileName = Mock(return_value="testTitle-[testid].ssa")
        player.downloadSubtitle = Mock()
        player.downloadSubtitle.return_value = True

        player.addSubtitles({"videoid": "testid", "Title": "testTitle"})

        patcher.stop()
        sleep.assert_any_call(1)

    def test_addSubtitles_should_check_if_subtitle_exists_locally_before_calling_xbmcs_setSubtitles(self):
        player = YouTubeSubtitleControl()
        player.getSubtitleFileName = Mock(return_value="testTitle-[testid].ssa")
        sys.modules["__main__"].settings.getSetting.return_value = "testDownloadPath"
        sys.modules["__main__"].xbmcvfs.exists.return_value = True
        sys.modules["__main__"].common.makeUTF8.return_value = "testTitle"
        player.downloadSubtitle = Mock()
        player.downloadSubtitle.return_value = False

        player.addSubtitles({"videoid": "testid", "Title": "testTitle"})

        sys.modules["__main__"].xbmcvfs.exists.assert_called_with('testDownloadPath/testTitle-[testid].ssa')
        assert(player.downloadSubtitle.call_count == 0)
        sys.modules["__main__"].xbmc.Player().setSubtitles.assert_called_with('testDownloadPath/testTitle-[testid].ssa')

    def test_addSubtitles_should_wait_for_playback_to_start_before_adding_subtitle(self):
        player = YouTubeSubtitleControl()
        player.getSubtitleFileName = Mock(return_value="testTitle-[testid].ssa")
        sys.modules["__main__"].settings.getSetting.return_value = "testDownloadPath"
        sys.modules["__main__"].xbmcvfs.exists.return_value = True
        sys.modules["__main__"].common.makeUTF8.return_value = "testTitle"
        player.addSubtitles({"videoid": "testid", "Title": "testTitle"})

        sys.modules["__main__"].xbmc.Player().isPlaying.assert_called_with()
        sys.modules["__main__"].xbmc.Player().setSubtitles.assert_called_with('testDownloadPath/testTitle-[testid].ssa')

if __name__ == '__main__':
    nose.runmodule()

########NEW FILE########
__FILENAME__ = TestYouTubeUtils
# -*- coding: utf-8 -*-
import nose
import BaseTestCase
from mock import Mock, patch
import sys
from  YouTubeUtils import YouTubeUtils 


class TestYouTubeUtils(BaseTestCase.BaseTestCase):

    def test_showMessage_should_call_xbmc_execute_builtin_correctly(self):
        sys.modules["__main__"].settings.getSetting.return_value = "3"
        utils = YouTubeUtils()
        
        utils.showMessage("someHeading","someMessage")

        sys.modules["__main__"].xbmc.executebuiltin.assert_called_with('XBMC.Notification("someHeading", "someMessage", 4000)')
        
    def test_getThumbnail_should_call_xbmc_skinHasImage(self):
        sys.modules["__main__"].xbmc.skinHasImage = Mock()
        utils = YouTubeUtils()
        
        result = utils.getThumbnail("someTeading")

        sys.modules["__main__"].xbmc.skinHasImage.assert_called_with('YouTube - Unittest/someTeading.png')
        
    def test_getThumbnail_should_user_default_folder_image_if_no_title_is_given(self):
        sys.modules["__main__"].xbmc.skinHasImage.return_value = False
        utils = YouTubeUtils()
        
        result = utils.getThumbnail("")
        
        sys.modules["__main__"].xbmc.skinHasImage.assert_called_with('YouTube - Unittest/DefaultFolder.png')
        assert(result == "DefaultFolder.png")
	
    def test_getThumbnail_should_user_thumbnail_path_to_resolve_file_paths(self):
        sys.modules["__main__"].settings.getAddonInfo.return_value = "testingPath/"
        sys.modules["__main__"].xbmc.skinHasImage.return_value = False        
        patcher = patch("os.path")
        patcher.start()
        import os
        utils = YouTubeUtils()
        
        result = utils.getThumbnail("")
        call = os.path.join.call_args_list[0]
        patcher.stop()
        
        assert(call == (('testingPath/', 'thumbnails'), {}))
        
    def test_showErrorMessage_should_call_showMessage_with_default(self):
        sys.modules["__main__"].language.return_value = "ERROR"
        utils = YouTubeUtils()
        utils.showMessage = Mock()	
        
        result = utils.showErrorMessage("someTitle","someResult")
        
        utils.showMessage.assert_called_with("someTitle","ERROR")

    def test_showErrorMessage_should_call_showMessage_with_empty_title(self):
        sys.modules["__main__"].language.return_value = "ERROR"
        utils = YouTubeUtils()
        utils.showMessage = Mock()	
        
        result = utils.showErrorMessage("","someResult", 303)
        
        utils.showMessage.assert_called_with("ERROR","someResult")
        sys.modules["__main__"].language.assert_called_with(30600)

    def test_showErrorMessage_should_call_showMessage_with_empty_result(self):
        sys.modules["__main__"].language.return_value = "ERROR"
        utils = YouTubeUtils()
        utils.showMessage = Mock()	
        
        result = utils.showErrorMessage("someTitle","")
        
        utils.showMessage.assert_called_with("someTitle","ERROR")
        sys.modules["__main__"].language.assert_called_with(30617)
	
    def test_showErrorMessage_should_call_showMessage_with_result(self):
        utils = YouTubeUtils()
        utils.showMessage = Mock()	
        
        result = utils.showErrorMessage("someTitle","someResult", 303)
        
        utils.showMessage.assert_called_with("someTitle","someResult")
	
    def test_buildItemUrl_should_ignore_items_in_blacklist(self):
        input = {"path":"FAIL","thumbnail":"FAIL", "Overlay":"FAIL", "icon":"FAIL", "next":"FAIL", "content":"FAIL" , "editid":"FAIL", "summary":"FAIL", "published":"FAIL","count":"FAIL","Rating":"FAIL","Plot":"FAIL","Title":"FAIL","new_results_function":"FAIL","some_other_param":"some_value"}
        utils = YouTubeUtils()
        
        result = utils.buildItemUrl(input)
        
        assert(result.find("FAIL") < 0)
        
    def test_buildItemUrl_should_build_url_from_params_collection(self):
        input = {"some_other_param":"some_value", "some_param":"some_other_value"}
        utils = YouTubeUtils()
        
        result = utils.buildItemUrl(input)
        
        assert(result == "some_param=some_other_value&some_other_param=some_value&")

    def test_buildItemUrl_should_append_to_existing_url(self):
        input = {"some_other_param":"some_value", "some_param":"some_other_value"}
        utils = YouTubeUtils()
        
        result = utils.buildItemUrl(input, "myfirst_url?")
        
        assert(result == "myfirst_url?some_param=some_other_value&some_other_param=some_value&")
        
    def test_addNextFolder_should_ignore_item_Title_thumbnail_page_and_new_results_funtion(self):
        sys.modules["__main__"].language.return_value = "Next"
        input = {"some_other_param":"some_value", "some_param":"some_other_value","page":"1","Title":"My annoying Title", "thumbnail":"someThumbnail","new_results_function":"functionPointer"}
        utils = YouTubeUtils()
        result = []
        
        utils.addNextFolder(result, input)
        
        assert(result[0]["Title"] == "Next")
        assert(result[0]["some_other_param"] == "some_value")
        assert(result[0]["some_param"] == "some_other_value")
        assert(result[0]["page"] == "2")
        assert(result[0]["thumbnail"] == "next")
        assert(result[0]["next"] == "true")
        
    def test_addNextFolder_should_increment_current_page(self):
        sys.modules["__main__"].language.return_value = "Next"
        input = {"some_other_param":"some_value", "some_param":"some_other_value","page":"45"}
        utils = YouTubeUtils()
        result = []
        
        utils.addNextFolder(result, input)
        
        assert(result[0]["page"] == "46")

    def test_extractVID_should_return_id_from_string(self):
        utils = YouTubeUtils()
        result = utils.extractVID("/watch?v=bla-id&amp;feature=artist")
        
        assert(len(result) == 1)
        assert(result[0] == "bla-id")

    def test_extractVID_should_return_ids_from_list(self):
        utils = YouTubeUtils()
        result = utils.extractVID(["&v=bla2", "&v=bla3&w="])
        
        assert(len(result) == 2)
        assert(result[0] == "bla2")
        assert(result[1] == "bla3")
        
    def test_extractVID_should_call_log_twice_with_correct_input(self):
        test = [ "?v=bla2", "&v=bla3&", "&v=bla4&amp;", "&amp;v=bla5&"]
        utils = YouTubeUtils()
        result = utils.extractVID(test)

        print repr(result)
        print repr(sys.modules["__main__"].common.log.call_args_list)

        sys.modules["__main__"].common.log.assert_any_call(repr(test), 4)
        sys.modules["__main__"].common.log.assert_any_call(repr([ "bla2", "bla3", "bla4", "bla5"]), 4)

        assert(len(result) == 4)
        assert(result[0] == "bla2")
        assert(result[1] == "bla3")
        assert(result[2] == "bla4")
        assert(result[3] == "bla5")

if __name__ == '__main__':
	nose.runmodule()

########NEW FILE########
__FILENAME__ = UnitTestSuite
import nose

if __name__ == "__main__":
	nose.run()

########NEW FILE########
__FILENAME__ = xbmc
DRIVE_NOT_READY = int
class InfoTagMusic:
    """InfoTagMusic class.
    
    """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def getAlbum(*args):
        """getAlbum() -- returns a string.
        """

    def getAlbumArtist(*args):
        """getAlbumArtist() -- returns a string.
        """

    def getArtist(*args):
        """getArtist() -- returns a string.
        """

    def getComment(*args):
        """getComment() -- returns a string.
        """

    def getDisc(*args):
        """getDisc() -- returns an integer.
        """

    def getDuration(*args):
        """getDuration() -- returns an integer.
        """

    def getGenre(*args):
        """getAlbum() -- returns a string.
        """

    def getLastPlayed(*args):
        """getLastPlayed() -- returns a string.
        """

    def getListeners(*args):
        """getListeners() -- returns an integer.
        """

    def getLyrics(*args):
        """getLyrics() -- returns a string.
        """

    def getPlayCount(*args):
        """getPlayCount() -- returns an integer.
        """

    def getReleaseDate(*args):
        """getReleaseDate() -- returns a string.
        """

    def getTitle(*args):
        """getTitle() -- returns a string.
        """

    def getTrack(*args):
        """getTrack() -- returns an integer.
        """

    def getTrackAndDisc(*args):
        """getTrackAndDisc() -- returns an integer.
        """

    def getURL(*args):
        """getURL() -- returns a string.
        """



class InfoTagVideo:
    """InfoTagVideo class.
    
    """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def getCast(*args):
        """getCast() -- returns a string.
        """

    def getDirector(*args):
        """getDirector() -- returns a string.
        """

    def getFile(*args):
        """getFile() -- returns a string.
        """

    def getFirstAired(*args):
        """getFirstAired() -- returns a string.
        """

    def getGenre(*args):
        """getGenre() -- returns a string.
        """

    def getIMDBNumber(*args):
        """getIMDBNumber() -- returns a string.
        """

    def getLastPlayed(*args):
        """getLastPlayed() -- returns a string.
        """

    def getOriginalTitle(*args):
        """getOriginalTitle() -- returns a string.
        """

    def getPath(*args):
        """getPath() -- returns a string.
        """

    def getPictureURL(*args):
        """getPictureURL() -- returns a string.
        """

    def getPlayCount(*args):
        """getPlayCount() -- returns a integer.
        """

    def getPlot(*args):
        """getPlot() -- returns a string.
        """

    def getPlotOutline(*args):
        """getPlotOutline() -- returns a string.
        """

    def getPremiered(*args):
        """getPremiered() -- returns a string.
        """

    def getRating(*args):
        """getRating() -- returns a float.
        """

    def getTagLine(*args):
        """getTagLine() -- returns a string.
        """

    def getTitle(*args):
        """getTitle() -- returns a string.
        """

    def getVotes(*args):
        """getVotes() -- returns a string.
        """

    def getWritingCredits(*args):
        """getWritingCredits() -- returns a string.
        """

    def getYear(*args):
        """getYear() -- returns a integer.
        """



class Keyboard:
    """Keyboard class.
    
    Keyboard([default, heading, hidden]) -- Creates a new Keyboard object with default text
                                    heading and hidden input flag if supplied.
    
    default        : [opt] string - default text entry.
    heading        : [opt] string - keyboard heading.
    hidden         : [opt] boolean - True for hidden text entry.
    
    example:
      - kb = xbmc.Keyboard('default', 'heading', True)
      - kb.setDefault('password') # optional
      - kb.setHeading('Enter password') # optional
      - kb.setHiddenInput(True) # optional
      - kb.doModal()
      - if (kb.isConfirmed()):
      -   text = kb.getText()
    """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def doModal(*args):
        """doModal([autoclose]) -- Show keyboard and wait for user action.
        
        autoclose      : [opt] integer - milliseconds to autoclose dialog. (default=do not autoclose)
        
        example:
          - kb.doModal(30000)
        """

    def getText(*args):
        """getText() -- Returns the user input as a string.
        
        *Note, This will always return the text entry even if you cancel the keyboard.
               Use the isConfirmed() method to check if user cancelled the keyboard.
        
        example:
          - text = kb.getText()
        """

    def isConfirmed(*args):
        """isConfirmed() -- Returns False if the user cancelled the input.
        
        example:
          - if (kb.isConfirmed()):
        """

    def setDefault(*args):
        """setDefault(default) -- Set the default text entry.
        
        default        : string - default text entry.
        
        example:
          - kb.setDefault('password')
        """

    def setHeading(*args):
        """setHeading(heading) -- Set the keyboard heading.
        
        heading        : string - keyboard heading.
        
        example:
          - kb.setHeading('Enter password')
        """

    def setHiddenInput(*args):
        """setHiddenInput(hidden) -- Allows hidden text entry.
        
        hidden        : boolean - True for hidden text entry.
        example:
          - kb.setHiddenInput(True)
        """



LOGDEBUG = int
LOGERROR = int
LOGFATAL = int
LOGINFO = int
LOGNONE = int
LOGNOTICE = int
LOGSEVERE = int
LOGWARNING = int
PLAYER_CORE_AUTO = int
PLAYER_CORE_DVDPLAYER = int
PLAYER_CORE_MPLAYER = int
PLAYER_CORE_PAPLAYER = int
PLAYLIST_MUSIC = int
PLAYLIST_VIDEO = int
class PlayList:
    """PlayList class.
    
    PlayList(int playlist) -- retrieve a reference from a valid xbmc playlist
    
    int playlist can be one of the next values:
    
      0 : xbmc.PLAYLIST_MUSIC
      1 : xbmc.PLAYLIST_VIDEO
    
    Use PlayList[int position] or __getitem__(int position) to get a PlayListItem.
    """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __getitem__(*args):
        """x.__getitem__(y) <==> x[y]
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __len__(*args):
        """x.__len__() <==> len(x)
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def add(*args):
        """add(url[, listitem, index]) -- Adds a new file to the playlist.
        
        url            : string or unicode - filename or url to add.
        listitem       : [opt] listitem - used with setInfo() to set different infolabels.
        index          : [opt] integer - position to add playlist item. (default=end)
        
        *Note, You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - playlist = xbmc.PlayList(xbmc.PLAYLIST_VIDEO)
          - video = 'F:\\movies\\Ironman.mov'
          - listitem = xbmcgui.ListItem('Ironman', thumbnailImage='F:\\movies\\Ironman.tbn')
          - listitem.setInfo('video', {'Title': 'Ironman', 'Genre': 'Science Fiction'})
          - playlist.add(url=video, listitem=listitem, index=7)
        """

    def clear(*args):
        """clear() -- clear all items in the playlist.
        """

    def getposition(*args):
        """getposition() -- returns the position of the current song in this playlist.
        """

    def load(*args):
        """load(filename) -- Load a playlist.
        
        clear current playlist and copy items from the file to this Playlist
        filename can be like .pls or .m3u ...
        returns False if unable to load playlist, True otherwise.
        """

    def remove(*args):
        """remove(filename) -- remove an item with this filename from the playlist.
        """

    def shuffle(*args):
        """shuffle() -- shuffle the playlist.
        """

    def size(*args):
        """size() -- returns the total number of PlayListItems in this playlist.
        """

    def unshuffle(*args):
        """unshuffle() -- unshuffle the playlist.
        """



class PlayListItem:
    """PlayListItem class.
    
    PlayListItem() -- Creates a new PlaylistItem which can be added to a PlayList.
    """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def getdescription(*args):
        """getdescription() -- Returns the description of this PlayListItem.
        """

    def getduration(*args):
        """getduration() -- Returns the duration of this PlayListItem.
        """

    def getfilename(*args):
        """getfilename() -- Returns the filename of this PlayListItem.
        """



class Player:
    """Player class.
    
    Player([core]) -- Creates a new Player with as default the xbmc music playlist.
    
    core     : (optional) Use a specified playcore instead of letting xbmc decide the playercore to use.
             : - xbmc.PLAYER_CORE_AUTO
             : - xbmc.PLAYER_CORE_DVDPLAYER
             : - xbmc.PLAYER_CORE_MPLAYER
             : - xbmc.PLAYER_CORE_PAPLAYER
    """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def disableSubtitles(*args):
        """DisableSubtitles() -- disable subtitles
        """

    def getAvailableAudioStreams(*args):
        """getAvailableAudioStreams() -- get Audio stream names
        """

    def getMusicInfoTag(*args):
        """getMusicInfoTag() -- returns the MusicInfoTag of the current playing 'Song'.
        
        Throws: Exception, if player is not playing a file or current file is not a music file.
        """

    def getPlayingFile(*args):
        """getPlayingFile() -- returns the current playing file as a string.
        
        Throws: Exception, if player is not playing a file.
        """

    def getSubtitles(*args):
        """getSubtitles() -- get subtitle stream name
        """

    def getTime(*args):
        """getTime() -- Returns the current time of the current playing media as fractional seconds.
        
        Throws: Exception, if player is not playing a file.
        """

    def getTotalTime(*args):
        """getTotalTime() -- Returns the total time of the current playing media in
                          seconds.  This is only accurate to the full second.
        
        Throws: Exception, if player is not playing a file.
        """

    def getVideoInfoTag(*args):
        """getVideoInfoTag() -- returns the VideoInfoTag of the current playing Movie.
        
        Throws: Exception, if player is not playing a file or current file is not a movie file.
        
        Note, this doesn't work yet, it's not tested
        """

    def isPlaying(*args):
        """isPlaying() -- returns True is xbmc is playing a file.
        """

    def isPlayingAudio(*args):
        """isPlayingAudio() -- returns True is xbmc is playing an audio file.
        """

    def isPlayingVideo(*args):
        """isPlayingVideo() -- returns True if xbmc is playing a video.
        """

    def onPlayBackEnded(*args):
        """onPlayBackEnded() -- onPlayBackEnded method.
        
        Will be called when xbmc stops playing a file
        """

    def onPlayBackPaused(*args):
        """onPlayBackPaused() -- onPlayBackPaused method.
        
        Will be called when user pauses a playing file
        """

    def onPlayBackResumed(*args):
        """onPlayBackResumed() -- onPlayBackResumed method.
        
        Will be called when user resumes a paused file
        """

    def onPlayBackStarted(*args):
        """onPlayBackStarted() -- onPlayBackStarted method.
        
        Will be called when xbmc starts playing a file
        """

    def onPlayBackStopped(*args):
        """onPlayBackStopped() -- onPlayBackStopped method.
        
        Will be called when user stops xbmc playing a file
        """

    def pause(*args):
        """pause() -- Pause playing.
        """

    def play(*args):
        """play([item, listitem, windowed]) -- Play this item.
        
        item           : [opt] string - filename, url or playlist.
        listitem       : [opt] listitem - used with setInfo() to set different infolabels.
        windowed       : [opt] bool - true=play video windowed, false=play users preference.(default)
        
        *Note, If item is not given then the Player will try to play the current item
               in the current playlist.
        
               You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - listitem = xbmcgui.ListItem('Ironman')
          - listitem.setInfo('video', {'Title': 'Ironman', 'Genre': 'Science Fiction'})
          - xbmc.Player( xbmc.PLAYER_CORE_MPLAYER ).play(url, listitem, windowed)
        """

    def playnext(*args):
        """playnext() -- Play next item in playlist.
        """

    def playprevious(*args):
        """playprevious() -- Play previous item in playlist.
        """

    def playselected(*args):
        """playselected() -- Play a certain item from the current playlist.
        """

    def seekTime(*args):
        """seekTime() -- Seeks the specified amount of time as fractional seconds.
                      The time specified is relative to the beginning of the
                      currently playing media file.
        
        Throws: Exception, if player is not playing a file.
        """

    def setAudioStream(*args):
        """setAudioStream(stream) -- set Audio Stream 
        
        stream           : int
        
        example:
          - setAudioStream(1)
        """

    def setSubtitles(*args):
        """setSubtitles(path) -- set subtitle file and enable subtitles
        
        path           : string or unicode - Path to subtitle
        
        example:
          - setSubtitles('/path/to/subtitle/test.srt')
        """

    def stop(*args):
        """stop() -- Stop playing.
        """



TRAY_CLOSED_MEDIA_PRESENT = int
TRAY_CLOSED_NO_MEDIA = int
TRAY_OPEN = int
__author__ = str
__credits__ = str
__date__ = str
__platform__ = str
__version__ = str
abortRequested = bool
def dashboard(*args):
    """dashboard() -- Boot to dashboard as set in My Pograms/General.
    
    example:
      - xbmc.dashboard()
    """

def enableNavSounds(*args):
    """enableNavSounds(yesNo) -- Enables/Disables nav sounds
    
    yesNo          : integer - enable (True) or disable (False) nav sounds
    
    example:
      - xbmc.enableNavSounds(True)
    """

def executeJSONRPC(*args):
    """executeJSONRPC(jsonrpccommand) -- Execute an JSONRPC command.
    
    jsonrpccommand    : string - jsonrpc command to execute.
    
    List of commands - 
    
    example:
      - response = xbmc.executeJSONRPC('{ "jsonrpc": "2.0", "method": "JSONRPC.Introspect", "id": 1 }')
    """

def executebuiltin(*args):
    """executebuiltin(function) -- Execute a built in XBMC function.
    
    function       : string - builtin function to execute.
    
    List of functions - http://wiki.xbmc.org/?title=List_of_Built_In_Functions 
    
    NOTE: This function is executed asynchronously, so do not rely on it being done immediately
    
    example:
      - xbmc.executebuiltin('XBMC.RunXBE(c:\\avalaunch.xbe)')
    """

def executehttpapi(*args):
    """executehttpapi(httpcommand) -- Execute an HTTP API command.
    
    httpcommand    : string - http command to execute.
    
    List of commands - http://wiki.xbmc.org/?title=WebServerHTTP-API#The_Commands 
    
    example:
      - response = xbmc.executehttpapi('TakeScreenShot(special://temp/test.jpg,0,false,200,-1,90)')
    """

def executescript(*args):
    """executescript(script) -- Execute a python script.
    
    script         : string - script filename to execute.
    
    example:
      - xbmc.executescript('special://home/scripts/update.py')
    """

def getCacheThumbName(*args):
    """getCacheThumbName(path) -- Returns a thumb cache filename.
    
    path           : string or unicode - path to file
    
    example:
      - thumb = xbmc.getCacheThumbName('f:\\videos\\movie.avi')
    """

def getCleanMovieTitle(*args):
    """getCleanMovieTitle(path[, usefoldername]) -- Returns a clean movie title and year string if available.
    
    path           : string or unicode - String to clean
    bool           : [opt] bool - use folder names (defaults to false)
    
    example:
      - title, year = xbmc.getCleanMovieTitle('/path/to/moviefolder/test.avi', True)
    """

def getCondVisibility(*args):
    """getCondVisibility(condition) -- Returns True (1) or False (0) as a bool.
    
    condition      : string - condition to check.
    
    List of Conditions - http://wiki.xbmc.org/?title=List_of_Boolean_Conditions 
    
    *Note, You can combine two (or more) of the above settings by using "+" as an AND operator,
    "|" as an OR operator, "!" as a NOT operator, and "[" and "]" to bracket expressions.
    
    example:
      - visible = xbmc.getCondVisibility('[Control.IsVisible(41) + !Control.IsVisible(12)]')
    """

def getDVDState(*args):
    """getDVDState() -- Returns the dvd state as an integer.
    
    return values are:
       1 : xbmc.DRIVE_NOT_READY
      16 : xbmc.TRAY_OPEN
      64 : xbmc.TRAY_CLOSED_NO_MEDIA
      96 : xbmc.TRAY_CLOSED_MEDIA_PRESENT
    
    example:
      - dvdstate = xbmc.getDVDState()
    """

def getFreeMem(*args):
    """getFreeMem() -- Returns the amount of free memory in MB as an integer.
    
    example:
      - freemem = xbmc.getFreeMem()
    """

def getGlobalIdleTime(*args):
    """getGlobalIdleTime() -- Returns the elapsed idle time in seconds as an integer.
    
    example:
      - t = xbmc.getGlobalIdleTime()
    """

def getIPAddress(*args):
    """getIPAddress() -- Returns the current ip address as a string.
    
    example:
      - ip = xbmc.getIPAddress()
    """

def getInfoImage(*args):
    """getInfoImage(infotag) -- Returns a filename including path to the InfoImage's
                             thumbnail as a string.
    
    infotag        : string - infotag for value you want returned.
    
    List of InfoTags - http://wiki.xbmc.org/?title=InfoLabels 
    
    example:
      - filename = xbmc.getInfoImage('Weather.Conditions')
    """

def getInfoLabel(*args):
    """getInfoLabel(infotag) -- Returns an InfoLabel as a string.
    
    infotag        : string - infoTag for value you want returned.
    
    List of InfoTags - http://wiki.xbmc.org/?title=InfoLabels 
    
    example:
      - label = xbmc.getInfoLabel('Weather.Conditions')
    """

def getLanguage(*args):
    """getLanguage() -- Returns the active language as a string.
    
    example:
      - language = xbmc.getLanguage()
    """

def getLocalizedString(*args):
    """getLocalizedString(id) -- Returns a localized 'unicode string'.
    
    id             : integer - id# for string you want to localize.
    
    *Note, See strings.xml in \language\{yourlanguage}\ for which id
           you need for a string.
    
    example:
      - locstr = xbmc.getLocalizedString(6)
    """

def getRegion(*args):
    """getRegion(id) -- Returns your regions setting as a string for the specified id.
    
    id             : string - id of setting to return
    
    *Note, choices are (dateshort, datelong, time, meridiem, tempunit, speedunit)
    
           You can use the above as keywords for arguments.
    
    example:
      - date_long_format = xbmc.getRegion('datelong')
    """

def getSkinDir(*args):
    """getSkinDir() -- Returns the active skin directory as a string.
    
    *Note, This is not the full path like 'special://home/addons/MediaCenter', but only 'MediaCenter'.
    
    example:
      - skindir = xbmc.getSkinDir()
    """

def getSupportedMedia(*args):
    """getSupportedMedia(media) -- Returns the supported file types for the specific media as a string.
    
    media          : string - media type
    
    *Note, media type can be (video, music, picture).
    
           The return value is a pipe separated string of filetypes (eg. '.mov|.avi').
    
           You can use the above as keywords for arguments.
    
    example:
      - mTypes = xbmc.getSupportedMedia('video')
    """

def log(*args):
    """log(msg[, level]) -- Write a string to XBMC's log file.
    
    msg            : string - text to output.
    level          : [opt] integer - log level to ouput at. (default=LOGNOTICE)
    
    
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
    
           Text is written to the log for the following conditions.
             XBMC loglevel == -1 (NONE, nothing at all is logged)         XBMC loglevel == 0 (NORMAL, shows LOGNOTICE, LOGERROR, LOGSEVERE and LOGFATAL)         XBMC loglevel == 1 (DEBUG, shows all)       See pydocs for valid values for level.
    
    example:
      - xbmc.log(msg='This is a test string.', level=xbmc.LOGDEBUG)
    """

def makeLegalFilename(*args):
    """makeLegalFilename(filename[, fatX]) -- Returns a legal filename or path as a string.
    
    filename       : string or unicode - filename/path to make legal
    fatX           : [opt] bool - True=Xbox file system(Default)
    
    *Note, If fatX is true you should pass a full path. If fatX is false only pass
           the basename of the path.
    
           You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
    
    example:
      - filename = xbmc.makeLegalFilename('F:\Trailers\Ice Age: The Meltdown.avi')
    """

def output(*args):
    """output(msg[, level]) -- Write a string to XBMC's log file and the debug window.
    
    msg            : string - text to output.
    level          : [opt] integer - log level to ouput at. (default=LOGNOTICE)
    
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
    
           Text is written to the log for the following conditions.
             XBMC loglevel == -1 (NONE, nothing at all is logged)         XBMC loglevel == 0 (NORMAL, shows LOGNOTICE, LOGERROR, LOGSEVERE and LOGFATAL)         XBMC loglevel == 1 (DEBUG, shows all)       See pydocs for valid values for level.
    
    example:
      - xbmc.output(msg='This is a test string.', level=xbmc.LOGDEBUG)
    """

def playSFX(*args):
    """playSFX(filename) -- Plays a wav file by filename
    
    filename       : string - filename of the wav file to play.
    
    example:
      - xbmc.playSFX('special://xbmc/scripts/dingdong.wav')
    """

def restart(*args):
    """restart() -- Restart the xbox.
    
    example:
      - xbmc.restart()
    """

def shutdown(*args):
    """shutdown() -- Shutdown the xbox.
    
    example:
      - xbmc.shutdown()
    """

def skinHasImage(*args):
    """skinHasImage(image) -- Returns True if the image file exists in the skin.
    
    image          : string - image filename
    
    *Note, If the media resides in a subfolder include it. (eg. home-myfiles\\home-myfiles2.png)
    
           You can use the above as keywords for arguments.
    
    example:
      - exists = xbmc.skinHasImage('ButtonFocusedTexture.png')
    """

def sleep(*args):
    """sleep(time) -- Sleeps for 'time' msec.
    
    time           : integer - number of msec to sleep.
    
    *Note, This is useful if you have for example a Player class that is waiting
           for onPlayBackEnded() calls.
    
    Throws: PyExc_TypeError, if time is not an integer.
    
    example:
      - xbmc.sleep(2000) # sleeps for 2 seconds
    """

def subHashAndFileSize(*args):
    """subHashAndFileSize(file)
    
    file        : file to calculate subtitle hash and size for
    example:
     size,hash = xbmcvfs.subHashAndFileSize(file)
    """

def translatePath(*args):
    """translatePath(path) -- Returns the translated path.
    
    path           : string or unicode - Path to format
    
    *Note, Only useful if you are coding for both Linux and Windows/Xbox.
           e.g. Converts 'special://masterprofile/script_data' -> '/home/user/XBMC/UserData/script_data'
           on Linux. Would return 'special://masterprofile/script_data' on the Xbox.
    
    example:
      - fpath = xbmc.translatePath('special://masterprofile/script_data')
    """

def validatePath(*args):
    """validatePath(path) -- Returns the validated path.
    
    path           : string or unicode - Path to format
    
    *Note, Only useful if you are coding for both Linux and Windows/Xbox for fixing slash problems.
           e.g. Corrects 'Z://something' -> 'Z:\something'
    
    example:
      - fpath = xbmc.validatePath(somepath)
    """


########NEW FILE########
__FILENAME__ = xbmcaddon
class Addon:
    """Addon class.
    
    Addon(id) -- Creates a new Addon class.
    
    id          : string - id of the addon.
    
    *Note, You can use the above as a keyword.
    
    example:
     - self.Addon = xbmcaddon.Addon(id='script.recentlyadded')
    """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def getAddonInfo(*args):
        """getAddonInfo(id) -- Returns the value of an addon property as a string.
        
        id        : string - id of the property that the module needs to access.
        
        *Note, choices are (author, changelog, description, disclaimer, fanart. icon, id, name, path
                            profile, stars, summary, type, version)
        
               You can use the above as keywords for arguments.
        
        example:
          - version = self.Addon.getAddonInfo('version')
        """

    def getLocalizedString(*args):
        """getLocalizedString(id) -- Returns an addon's localized 'unicode string'.
        
        id             : integer - id# for string you want to localize.
        
        *Note, You can use the above as keywords for arguments.
        
        example:
          - locstr = self.Addon.getLocalizedString(id=6)
        """

    def getSetting(*args):
        """getSetting(id) -- Returns the value of a setting as a unicode string.
        
        id        : string - id of the setting that the module needs to access.
        
        *Note, You can use the above as a keyword.
        
        example:
          - apikey = self.Addon.getSetting('apikey')
        """

    def openSettings(*args):
        """openSettings() -- Opens this scripts settings dialog.
        
        example:
          - self.Settings.openSettings()
        """

    def setSetting(*args):
        """setSetting(id, value) -- Sets a script setting.
        
        id        : string - id of the setting that the module needs to access.
        value     : string or unicode - value of the setting.
        
        *Note, You can use the above as keywords for arguments.
        
        example:
          - self.Settings.setSetting(id='username', value='teamxbmc')
        """



__author__ = str
__credits__ = str
__date__ = str
__platform__ = str
__version__ = str

########NEW FILE########
__FILENAME__ = xbmcgui
class Action:
    """Action class.
    
    For backwards compatibility reasons the == operator is extended so that itcan compare an action with other actions and action.GetID() with numbers  example: (action == ACTION_MOVE_LEFT)
    """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __eq__(*args):
        """x.__eq__(y) <==> x==y
        """

    def __format__(*args):
        """default object formatter
        """

    def __ge__(*args):
        """x.__ge__(y) <==> x>=y
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __gt__(*args):
        """x.__gt__(y) <==> x>y
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __le__(*args):
        """x.__le__(y) <==> x<=y
        """

    def __lt__(*args):
        """x.__lt__(y) <==> x<y
        """

    def __ne__(*args):
        """x.__ne__(y) <==> x!=y
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def getAmount1(*args):
        """getAmount1() -- Returns the first amount of force applied to the thumbstick n.
        
        """

    def getAmount2(*args):
        """getAmount2() -- Returns the second amount of force applied to the thumbstick n.
        
        """

    def getButtonCode(*args):
        """getButtonCode() -- Returns the button code for this action.
        
        """

    def getId(*args):
        """getId() -- Returns the action's current id as a long or 0 if no action is mapped in the xml's.
        
        """



class ControlButton:
    """ControlButton class.
    
    ControlButton(x, y, width, height, label[, focusTexture, noFocusTexture, textOffsetX, textOffsetY,
                  alignment, font, textColor, disabledColor, angle, shadowColor, focusedColor])
    
    x              : integer - x coordinate of control.
    y              : integer - y coordinate of control.
    width          : integer - width of control.
    height         : integer - height of control.
    label          : string or unicode - text string.
    focusTexture   : [opt] string - filename for focus texture.
    noFocusTexture : [opt] string - filename for no focus texture.
    textOffsetX    : [opt] integer - x offset of label.
    textOffsetY    : [opt] integer - y offset of label.
    alignment      : [opt] integer - alignment of label - *Note, see xbfont.h
    font           : [opt] string - font used for label text. (e.g. 'font13')
    textColor      : [opt] hexstring - color of enabled button's label. (e.g. '0xFFFFFFFF')
    disabledColor  : [opt] hexstring - color of disabled button's label. (e.g. '0xFFFF3300')
    angle          : [opt] integer - angle of control. (+ rotates CCW, - rotates CW)
    shadowColor    : [opt] hexstring - color of button's label's shadow. (e.g. '0xFF000000')
    focusedColor   : [opt] hexstring - color of focused button's label. (e.g. '0xFF00FFFF')
    
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
           After you create the control, you need to add it to the window with addControl().
    
    example:
      - self.button = xbmcgui.ControlButton(100, 250, 200, 50, 'Status', font='font14')
    """

    def __cmp__(*args):
        """x.__cmp__(y) <==> cmp(x,y)
        """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def controlDown(*args):
        """controlDown(control) -- Set's the controls down navigation.
        
        control        : control object - control to navigate to on down.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlDown(self.button1)
        """

    def controlLeft(*args):
        """controlLeft(control) -- Set's the controls left navigation.
        
        control        : control object - control to navigate to on left.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlLeft(self.button1)
        """

    def controlRight(*args):
        """controlRight(control) -- Set's the controls right navigation.
        
        control        : control object - control to navigate to on right.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlRight(self.button1)
        """

    def controlUp(*args):
        """controlUp(control) -- Set's the controls up navigation.
        
        control        : control object - control to navigate to on up.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlUp(self.button1)
        """

    def getHeight(*args):
        """getHeight() -- Returns the control's current height as an integer.
        
        example:
          - height = self.button.getHeight()
        """

    def getId(*args):
        """getId() -- Returns the control's current id as an integer.
        
        example:
          - id = self.button.getId()
        """

    def getLabel(*args):
        """getLabel() -- Returns the buttons label as a unicode string.
        
        example:
          - label = self.button.getLabel()
        """

    def getLabel2(*args):
        """getLabel2() -- Returns the buttons label2 as a unicode string.
        
        example:
          - label = self.button.getLabel2()
        """

    def getPosition(*args):
        """getPosition() -- Returns the control's current position as a x,y integer tuple.
        
        example:
          - pos = self.button.getPosition()
        """

    def getWidth(*args):
        """getWidth() -- Returns the control's current width as an integer.
        
        example:
          - width = self.button.getWidth()
        """

    def setAnimations(*args):
        """setAnimations([(event, attr,)*]) -- Set's the control's animations.
        
        [(event,attr,)*] : list - A list of tuples consisting of event and attributes pairs.
          - event        : string - The event to animate.
          - attr         : string - The whole attribute string separated by spaces.
        
        Animating your skin - http://wiki.xbmc.org/?title=Animating_Your_Skin 
        
        example:
          - self.button.setAnimations([('focus', 'effect=zoom end=90,247,220,56 time=0',)])
        """

    def setDisabledColor(*args):
        """setDisabledColor(disabledColor) -- Set's this buttons disabled color.
        
        disabledColor  : hexstring - color of disabled button's label. (e.g. '0xFFFF3300')
        
        example:
          - self.button.setDisabledColor('0xFFFF3300')
        """

    def setEnableCondition(*args):
        """setEnableCondition(enable) -- Set's the control's enabled condition.
            Allows XBMC to control the enabled status of the control.
        
        enable           : string - Enable condition.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setEnableCondition('System.InternetState')
        """

    def setEnabled(*args):
        """setEnabled(enabled) -- Set's the control's enabled/disabled state.
        
        enabled        : bool - True=enabled / False=disabled.
        
        example:
          - self.button.setEnabled(False)
        """

    def setHeight(*args):
        """setHeight(height) -- Set's the controls height.
        
        height         : integer - height of control.
        
        example:
          - self.image.setHeight(100)
        """

    def setLabel(*args):
        """setLabel([label, font, textColor, disabledColor, shadowColor, focusedColor]) -- Set's this buttons text attributes.
        
        label          : [opt] string or unicode - text string.
        font           : [opt] string - font used for label text. (e.g. 'font13')
        textColor      : [opt] hexstring - color of enabled button's label. (e.g. '0xFFFFFFFF')
        disabledColor  : [opt] hexstring - color of disabled button's label. (e.g. '0xFFFF3300')
        shadowColor    : [opt] hexstring - color of button's label's shadow. (e.g. '0xFF000000')
        focusedColor   : [opt] hexstring - color of focused button's label. (e.g. '0xFFFFFF00')
        label2         : [opt] string or unicode - text string.
        
        *Note, You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - self.button.setLabel('Status', 'font14', '0xFFFFFFFF', '0xFFFF3300', '0xFF000000')
        """

    def setNavigation(*args):
        """setNavigation(up, down, left, right) -- Set's the controls navigation.
        
        up             : control object - control to navigate to on up.
        down           : control object - control to navigate to on down.
        left           : control object - control to navigate to on left.
        right          : control object - control to navigate to on right.
        
        *Note, Same as controlUp(), controlDown(), controlLeft(), controlRight().
               Set to self to disable navigation for that direction.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.setNavigation(self.button1, self.button2, self.button3, self.button4)
        """

    def setPosition(*args):
        """setPosition(x, y) -- Set's the controls position.
        
        x              : integer - x coordinate of control.
        y              : integer - y coordinate of control.
        
        *Note, You may use negative integers. (e.g sliding a control into view)
        
        example:
          - self.button.setPosition(100, 250)
        """

    def setVisible(*args):
        """setVisible(visible) -- Set's the control's visible/hidden state.
        
        visible        : bool - True=visible / False=hidden.
        
        example:
          - self.button.setVisible(False)
        """

    def setVisibleCondition(*args):
        """setVisibleCondition(visible[,allowHiddenFocus]) -- Set's the control's visible condition.
            Allows XBMC to control the visible status of the control.
        
        visible          : string - Visible condition.
        allowHiddenFocus : bool - True=gains focus even if hidden.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setVisibleCondition('[Control.IsVisible(41) + !Control.IsVisible(12)]', True)
        """

    def setWidth(*args):
        """setWidth(width) -- Set's the controls width.
        
        width          : integer - width of control.
        
        example:
          - self.image.setWidth(100)
        """



class ControlCheckMark:
    """ControlCheckMark class.
    
    ControlCheckMark(x, y, width, height, label[, focusTexture, noFocusTexture,
                     checkWidth, checkHeight, alignment, font, textColor, disabledColor])
    
    x              : integer - x coordinate of control.
    y              : integer - y coordinate of control.
    width          : integer - width of control.
    height         : integer - height of control.
    label          : string or unicode - text string.
    focusTexture   : [opt] string - filename for focus texture.
    noFocusTexture : [opt] string - filename for no focus texture.
    checkWidth     : [opt] integer - width of checkmark.
    checkHeight    : [opt] integer - height of checkmark.
    alignment      : [opt] integer - alignment of label - *Note, see xbfont.h
    font           : [opt] string - font used for label text. (e.g. 'font13')
    textColor      : [opt] hexstring - color of enabled checkmark's label. (e.g. '0xFFFFFFFF')
    disabledColor  : [opt] hexstring - color of disabled checkmark's label. (e.g. '0xFFFF3300')
    
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
           After you create the control, you need to add it to the window with addControl().
    
    example:
      - self.checkmark = xbmcgui.ControlCheckMark(100, 250, 200, 50, 'Status', font='font14')
    """

    def __cmp__(*args):
        """x.__cmp__(y) <==> cmp(x,y)
        """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def controlDown(*args):
        """controlDown(control) -- Set's the controls down navigation.
        
        control        : control object - control to navigate to on down.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlDown(self.button1)
        """

    def controlLeft(*args):
        """controlLeft(control) -- Set's the controls left navigation.
        
        control        : control object - control to navigate to on left.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlLeft(self.button1)
        """

    def controlRight(*args):
        """controlRight(control) -- Set's the controls right navigation.
        
        control        : control object - control to navigate to on right.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlRight(self.button1)
        """

    def controlUp(*args):
        """controlUp(control) -- Set's the controls up navigation.
        
        control        : control object - control to navigate to on up.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlUp(self.button1)
        """

    def getHeight(*args):
        """getHeight() -- Returns the control's current height as an integer.
        
        example:
          - height = self.button.getHeight()
        """

    def getId(*args):
        """getId() -- Returns the control's current id as an integer.
        
        example:
          - id = self.button.getId()
        """

    def getPosition(*args):
        """getPosition() -- Returns the control's current position as a x,y integer tuple.
        
        example:
          - pos = self.button.getPosition()
        """

    def getSelected(*args):
        """getSelected() -- Returns the selected status for this checkmark as a bool.
        
        example:
          - selected = self.checkmark.getSelected()
        """

    def getWidth(*args):
        """getWidth() -- Returns the control's current width as an integer.
        
        example:
          - width = self.button.getWidth()
        """

    def setAnimations(*args):
        """setAnimations([(event, attr,)*]) -- Set's the control's animations.
        
        [(event,attr,)*] : list - A list of tuples consisting of event and attributes pairs.
          - event        : string - The event to animate.
          - attr         : string - The whole attribute string separated by spaces.
        
        Animating your skin - http://wiki.xbmc.org/?title=Animating_Your_Skin 
        
        example:
          - self.button.setAnimations([('focus', 'effect=zoom end=90,247,220,56 time=0',)])
        """

    def setDisabledColor(*args):
        """setDisabledColor(disabledColor) -- Set's this controls disabled color.
        
        disabledColor  : hexstring - color of disabled checkmark's label. (e.g. '0xFFFF3300')
        
        example:
          - self.checkmark.setDisabledColor('0xFFFF3300')
        """

    def setEnableCondition(*args):
        """setEnableCondition(enable) -- Set's the control's enabled condition.
            Allows XBMC to control the enabled status of the control.
        
        enable           : string - Enable condition.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setEnableCondition('System.InternetState')
        """

    def setEnabled(*args):
        """setEnabled(enabled) -- Set's the control's enabled/disabled state.
        
        enabled        : bool - True=enabled / False=disabled.
        
        example:
          - self.button.setEnabled(False)
        """

    def setHeight(*args):
        """setHeight(height) -- Set's the controls height.
        
        height         : integer - height of control.
        
        example:
          - self.image.setHeight(100)
        """

    def setLabel(*args):
        """setLabel(label[, font, textColor, disabledColor]) -- Set's this controls text attributes.
        
        label          : string or unicode - text string.
        font           : [opt] string - font used for label text. (e.g. 'font13')
        textColor      : [opt] hexstring - color of enabled checkmark's label. (e.g. '0xFFFFFFFF')
        disabledColor  : [opt] hexstring - color of disabled checkmark's label. (e.g. '0xFFFF3300')
        
        example:
          - self.checkmark.setLabel('Status', 'font14', '0xFFFFFFFF', '0xFFFF3300')
        """

    def setNavigation(*args):
        """setNavigation(up, down, left, right) -- Set's the controls navigation.
        
        up             : control object - control to navigate to on up.
        down           : control object - control to navigate to on down.
        left           : control object - control to navigate to on left.
        right          : control object - control to navigate to on right.
        
        *Note, Same as controlUp(), controlDown(), controlLeft(), controlRight().
               Set to self to disable navigation for that direction.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.setNavigation(self.button1, self.button2, self.button3, self.button4)
        """

    def setPosition(*args):
        """setPosition(x, y) -- Set's the controls position.
        
        x              : integer - x coordinate of control.
        y              : integer - y coordinate of control.
        
        *Note, You may use negative integers. (e.g sliding a control into view)
        
        example:
          - self.button.setPosition(100, 250)
        """

    def setSelected(*args):
        """setSelected(isOn) -- Sets this checkmark status to on or off.
        
        isOn           : bool - True=selected (on) / False=not selected (off)
        
        example:
          - self.checkmark.setSelected(True)
        """

    def setVisible(*args):
        """setVisible(visible) -- Set's the control's visible/hidden state.
        
        visible        : bool - True=visible / False=hidden.
        
        example:
          - self.button.setVisible(False)
        """

    def setVisibleCondition(*args):
        """setVisibleCondition(visible[,allowHiddenFocus]) -- Set's the control's visible condition.
            Allows XBMC to control the visible status of the control.
        
        visible          : string - Visible condition.
        allowHiddenFocus : bool - True=gains focus even if hidden.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setVisibleCondition('[Control.IsVisible(41) + !Control.IsVisible(12)]', True)
        """

    def setWidth(*args):
        """setWidth(width) -- Set's the controls width.
        
        width          : integer - width of control.
        
        example:
          - self.image.setWidth(100)
        """



class ControlFadeLabel:
    """ControlFadeLabel class.
    Control that scroll's lables
    ControlFadeLabel(x, y, width, height[, font, textColor, alignment])
    
    x              : integer - x coordinate of control.
    y              : integer - y coordinate of control.
    width          : integer - width of control.
    height         : integer - height of control.
    font           : [opt] string - font used for label text. (e.g. 'font13')
    textColor      : [opt] hexstring - color of fadelabel's labels. (e.g. '0xFFFFFFFF')
    alignment      : [opt] integer - alignment of label - *Note, see xbfont.h
    
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
           After you create the control, you need to add it to the window with addControl().
    
    example:
      - self.fadelabel = xbmcgui.ControlFadeLabel(100, 250, 200, 50, textColor='0xFFFFFFFF')
    """

    def __cmp__(*args):
        """x.__cmp__(y) <==> cmp(x,y)
        """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def addLabel(*args):
        """addLabel(label) -- Add a label to this control for scrolling.
        
        label          : string or unicode - text string.
        
        example:
          - self.fadelabel.addLabel('This is a line of text that can scroll.')
        """

    def controlDown(*args):
        """controlDown(control) -- Set's the controls down navigation.
        
        control        : control object - control to navigate to on down.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlDown(self.button1)
        """

    def controlLeft(*args):
        """controlLeft(control) -- Set's the controls left navigation.
        
        control        : control object - control to navigate to on left.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlLeft(self.button1)
        """

    def controlRight(*args):
        """controlRight(control) -- Set's the controls right navigation.
        
        control        : control object - control to navigate to on right.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlRight(self.button1)
        """

    def controlUp(*args):
        """controlUp(control) -- Set's the controls up navigation.
        
        control        : control object - control to navigate to on up.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlUp(self.button1)
        """

    def getHeight(*args):
        """getHeight() -- Returns the control's current height as an integer.
        
        example:
          - height = self.button.getHeight()
        """

    def getId(*args):
        """getId() -- Returns the control's current id as an integer.
        
        example:
          - id = self.button.getId()
        """

    def getPosition(*args):
        """getPosition() -- Returns the control's current position as a x,y integer tuple.
        
        example:
          - pos = self.button.getPosition()
        """

    def getWidth(*args):
        """getWidth() -- Returns the control's current width as an integer.
        
        example:
          - width = self.button.getWidth()
        """

    def reset(*args):
        """reset() -- Clears this fadelabel.
        
        example:
          - self.fadelabel.reset()
        """

    def setAnimations(*args):
        """setAnimations([(event, attr,)*]) -- Set's the control's animations.
        
        [(event,attr,)*] : list - A list of tuples consisting of event and attributes pairs.
          - event        : string - The event to animate.
          - attr         : string - The whole attribute string separated by spaces.
        
        Animating your skin - http://wiki.xbmc.org/?title=Animating_Your_Skin 
        
        example:
          - self.button.setAnimations([('focus', 'effect=zoom end=90,247,220,56 time=0',)])
        """

    def setEnableCondition(*args):
        """setEnableCondition(enable) -- Set's the control's enabled condition.
            Allows XBMC to control the enabled status of the control.
        
        enable           : string - Enable condition.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setEnableCondition('System.InternetState')
        """

    def setEnabled(*args):
        """setEnabled(enabled) -- Set's the control's enabled/disabled state.
        
        enabled        : bool - True=enabled / False=disabled.
        
        example:
          - self.button.setEnabled(False)
        """

    def setHeight(*args):
        """setHeight(height) -- Set's the controls height.
        
        height         : integer - height of control.
        
        example:
          - self.image.setHeight(100)
        """

    def setNavigation(*args):
        """setNavigation(up, down, left, right) -- Set's the controls navigation.
        
        up             : control object - control to navigate to on up.
        down           : control object - control to navigate to on down.
        left           : control object - control to navigate to on left.
        right          : control object - control to navigate to on right.
        
        *Note, Same as controlUp(), controlDown(), controlLeft(), controlRight().
               Set to self to disable navigation for that direction.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.setNavigation(self.button1, self.button2, self.button3, self.button4)
        """

    def setPosition(*args):
        """setPosition(x, y) -- Set's the controls position.
        
        x              : integer - x coordinate of control.
        y              : integer - y coordinate of control.
        
        *Note, You may use negative integers. (e.g sliding a control into view)
        
        example:
          - self.button.setPosition(100, 250)
        """

    def setVisible(*args):
        """setVisible(visible) -- Set's the control's visible/hidden state.
        
        visible        : bool - True=visible / False=hidden.
        
        example:
          - self.button.setVisible(False)
        """

    def setVisibleCondition(*args):
        """setVisibleCondition(visible[,allowHiddenFocus]) -- Set's the control's visible condition.
            Allows XBMC to control the visible status of the control.
        
        visible          : string - Visible condition.
        allowHiddenFocus : bool - True=gains focus even if hidden.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setVisibleCondition('[Control.IsVisible(41) + !Control.IsVisible(12)]', True)
        """

    def setWidth(*args):
        """setWidth(width) -- Set's the controls width.
        
        width          : integer - width of control.
        
        example:
          - self.image.setWidth(100)
        """



class ControlGroup:
    """ControlGroup class.
    
    ControlGroup(x, y, width, height
    
    x              : integer - x coordinate of control.
    y              : integer - y coordinate of control.
    width          : integer - width of control.
    height         : integer - height of control.
    example:
      - self.group = xbmcgui.ControlGroup(100, 250, 125, 75)
    """

    def __cmp__(*args):
        """x.__cmp__(y) <==> cmp(x,y)
        """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def controlDown(*args):
        """controlDown(control) -- Set's the controls down navigation.
        
        control        : control object - control to navigate to on down.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlDown(self.button1)
        """

    def controlLeft(*args):
        """controlLeft(control) -- Set's the controls left navigation.
        
        control        : control object - control to navigate to on left.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlLeft(self.button1)
        """

    def controlRight(*args):
        """controlRight(control) -- Set's the controls right navigation.
        
        control        : control object - control to navigate to on right.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlRight(self.button1)
        """

    def controlUp(*args):
        """controlUp(control) -- Set's the controls up navigation.
        
        control        : control object - control to navigate to on up.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlUp(self.button1)
        """

    def getHeight(*args):
        """getHeight() -- Returns the control's current height as an integer.
        
        example:
          - height = self.button.getHeight()
        """

    def getId(*args):
        """getId() -- Returns the control's current id as an integer.
        
        example:
          - id = self.button.getId()
        """

    def getPosition(*args):
        """getPosition() -- Returns the control's current position as a x,y integer tuple.
        
        example:
          - pos = self.button.getPosition()
        """

    def getWidth(*args):
        """getWidth() -- Returns the control's current width as an integer.
        
        example:
          - width = self.button.getWidth()
        """

    def setAnimations(*args):
        """setAnimations([(event, attr,)*]) -- Set's the control's animations.
        
        [(event,attr,)*] : list - A list of tuples consisting of event and attributes pairs.
          - event        : string - The event to animate.
          - attr         : string - The whole attribute string separated by spaces.
        
        Animating your skin - http://wiki.xbmc.org/?title=Animating_Your_Skin 
        
        example:
          - self.button.setAnimations([('focus', 'effect=zoom end=90,247,220,56 time=0',)])
        """

    def setEnableCondition(*args):
        """setEnableCondition(enable) -- Set's the control's enabled condition.
            Allows XBMC to control the enabled status of the control.
        
        enable           : string - Enable condition.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setEnableCondition('System.InternetState')
        """

    def setEnabled(*args):
        """setEnabled(enabled) -- Set's the control's enabled/disabled state.
        
        enabled        : bool - True=enabled / False=disabled.
        
        example:
          - self.button.setEnabled(False)
        """

    def setHeight(*args):
        """setHeight(height) -- Set's the controls height.
        
        height         : integer - height of control.
        
        example:
          - self.image.setHeight(100)
        """

    def setNavigation(*args):
        """setNavigation(up, down, left, right) -- Set's the controls navigation.
        
        up             : control object - control to navigate to on up.
        down           : control object - control to navigate to on down.
        left           : control object - control to navigate to on left.
        right          : control object - control to navigate to on right.
        
        *Note, Same as controlUp(), controlDown(), controlLeft(), controlRight().
               Set to self to disable navigation for that direction.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.setNavigation(self.button1, self.button2, self.button3, self.button4)
        """

    def setPosition(*args):
        """setPosition(x, y) -- Set's the controls position.
        
        x              : integer - x coordinate of control.
        y              : integer - y coordinate of control.
        
        *Note, You may use negative integers. (e.g sliding a control into view)
        
        example:
          - self.button.setPosition(100, 250)
        """

    def setVisible(*args):
        """setVisible(visible) -- Set's the control's visible/hidden state.
        
        visible        : bool - True=visible / False=hidden.
        
        example:
          - self.button.setVisible(False)
        """

    def setVisibleCondition(*args):
        """setVisibleCondition(visible[,allowHiddenFocus]) -- Set's the control's visible condition.
            Allows XBMC to control the visible status of the control.
        
        visible          : string - Visible condition.
        allowHiddenFocus : bool - True=gains focus even if hidden.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setVisibleCondition('[Control.IsVisible(41) + !Control.IsVisible(12)]', True)
        """

    def setWidth(*args):
        """setWidth(width) -- Set's the controls width.
        
        width          : integer - width of control.
        
        example:
          - self.image.setWidth(100)
        """



class ControlImage:
    """ControlImage class.
    
    ControlImage(x, y, width, height, filename[, colorKey, aspectRatio, colorDiffuse])
    
    x              : integer - x coordinate of control.
    y              : integer - y coordinate of control.
    width          : integer - width of control.
    height         : integer - height of control.
    filename       : string - image filename.
    colorKey       : [opt] hexString - (example, '0xFFFF3300')
    aspectRatio    : [opt] integer - (values 0 = stretch (default), 1 = scale up (crops), 2 = scale down (black bars)colorDiffuse   : hexString - (example, '0xC0FF0000' (red tint))
    
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
           After you create the control, you need to add it to the window with addControl().
    
    example:
      - self.image = xbmcgui.ControlImage(100, 250, 125, 75, aspectRatio=2)
    """

    def __cmp__(*args):
        """x.__cmp__(y) <==> cmp(x,y)
        """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def controlDown(*args):
        """controlDown(control) -- Set's the controls down navigation.
        
        control        : control object - control to navigate to on down.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlDown(self.button1)
        """

    def controlLeft(*args):
        """controlLeft(control) -- Set's the controls left navigation.
        
        control        : control object - control to navigate to on left.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlLeft(self.button1)
        """

    def controlRight(*args):
        """controlRight(control) -- Set's the controls right navigation.
        
        control        : control object - control to navigate to on right.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlRight(self.button1)
        """

    def controlUp(*args):
        """controlUp(control) -- Set's the controls up navigation.
        
        control        : control object - control to navigate to on up.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlUp(self.button1)
        """

    def getHeight(*args):
        """getHeight() -- Returns the control's current height as an integer.
        
        example:
          - height = self.button.getHeight()
        """

    def getId(*args):
        """getId() -- Returns the control's current id as an integer.
        
        example:
          - id = self.button.getId()
        """

    def getPosition(*args):
        """getPosition() -- Returns the control's current position as a x,y integer tuple.
        
        example:
          - pos = self.button.getPosition()
        """

    def getWidth(*args):
        """getWidth() -- Returns the control's current width as an integer.
        
        example:
          - width = self.button.getWidth()
        """

    def setAnimations(*args):
        """setAnimations([(event, attr,)*]) -- Set's the control's animations.
        
        [(event,attr,)*] : list - A list of tuples consisting of event and attributes pairs.
          - event        : string - The event to animate.
          - attr         : string - The whole attribute string separated by spaces.
        
        Animating your skin - http://wiki.xbmc.org/?title=Animating_Your_Skin 
        
        example:
          - self.button.setAnimations([('focus', 'effect=zoom end=90,247,220,56 time=0',)])
        """

    def setColorDiffuse(*args):
        """setColorDiffuse(colorDiffuse) -- Changes the images color.
        
        colorDiffuse   : hexString - (example, '0xC0FF0000' (red tint))
        
        example:
          - self.image.setColorDiffuse('0xC0FF0000')
        """

    def setEnableCondition(*args):
        """setEnableCondition(enable) -- Set's the control's enabled condition.
            Allows XBMC to control the enabled status of the control.
        
        enable           : string - Enable condition.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setEnableCondition('System.InternetState')
        """

    def setEnabled(*args):
        """setEnabled(enabled) -- Set's the control's enabled/disabled state.
        
        enabled        : bool - True=enabled / False=disabled.
        
        example:
          - self.button.setEnabled(False)
        """

    def setHeight(*args):
        """setHeight(height) -- Set's the controls height.
        
        height         : integer - height of control.
        
        example:
          - self.image.setHeight(100)
        """

    def setImage(*args):
        """setImage(filename, colorKey) -- Changes the image.
        
        filename       : string - image filename.
        
        example:
          - self.image.setImage('special://home/scripts/test.png')
        """

    def setNavigation(*args):
        """setNavigation(up, down, left, right) -- Set's the controls navigation.
        
        up             : control object - control to navigate to on up.
        down           : control object - control to navigate to on down.
        left           : control object - control to navigate to on left.
        right          : control object - control to navigate to on right.
        
        *Note, Same as controlUp(), controlDown(), controlLeft(), controlRight().
               Set to self to disable navigation for that direction.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.setNavigation(self.button1, self.button2, self.button3, self.button4)
        """

    def setPosition(*args):
        """setPosition(x, y) -- Set's the controls position.
        
        x              : integer - x coordinate of control.
        y              : integer - y coordinate of control.
        
        *Note, You may use negative integers. (e.g sliding a control into view)
        
        example:
          - self.button.setPosition(100, 250)
        """

    def setVisible(*args):
        """setVisible(visible) -- Set's the control's visible/hidden state.
        
        visible        : bool - True=visible / False=hidden.
        
        example:
          - self.button.setVisible(False)
        """

    def setVisibleCondition(*args):
        """setVisibleCondition(visible[,allowHiddenFocus]) -- Set's the control's visible condition.
            Allows XBMC to control the visible status of the control.
        
        visible          : string - Visible condition.
        allowHiddenFocus : bool - True=gains focus even if hidden.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setVisibleCondition('[Control.IsVisible(41) + !Control.IsVisible(12)]', True)
        """

    def setWidth(*args):
        """setWidth(width) -- Set's the controls width.
        
        width          : integer - width of control.
        
        example:
          - self.image.setWidth(100)
        """



class ControlLabel:
    """ControlLabel class.
    
    ControlLabel(x, y, width, height, label[, font, textColor, 
                 disabledColor, alignment, hasPath, angle])
    
    x              : integer - x coordinate of control.
    y              : integer - y coordinate of control.
    width          : integer - width of control.
    height         : integer - height of control.
    label          : string or unicode - text string.
    font           : [opt] string - font used for label text. (e.g. 'font13')
    textColor      : [opt] hexstring - color of enabled label's label. (e.g. '0xFFFFFFFF')
    disabledColor  : [opt] hexstring - color of disabled label's label. (e.g. '0xFFFF3300')
    alignment      : [opt] integer - alignment of label - *Note, see xbfont.h
    hasPath        : [opt] bool - True=stores a path / False=no path.
    angle          : [opt] integer - angle of control. (+ rotates CCW, - rotates CW)
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
           After you create the control, you need to add it to the window with addControl().
    
    example:
      - self.label = xbmcgui.ControlLabel(100, 250, 125, 75, 'Status', angle=45)
    """

    def __cmp__(*args):
        """x.__cmp__(y) <==> cmp(x,y)
        """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def controlDown(*args):
        """controlDown(control) -- Set's the controls down navigation.
        
        control        : control object - control to navigate to on down.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlDown(self.button1)
        """

    def controlLeft(*args):
        """controlLeft(control) -- Set's the controls left navigation.
        
        control        : control object - control to navigate to on left.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlLeft(self.button1)
        """

    def controlRight(*args):
        """controlRight(control) -- Set's the controls right navigation.
        
        control        : control object - control to navigate to on right.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlRight(self.button1)
        """

    def controlUp(*args):
        """controlUp(control) -- Set's the controls up navigation.
        
        control        : control object - control to navigate to on up.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlUp(self.button1)
        """

    def getHeight(*args):
        """getHeight() -- Returns the control's current height as an integer.
        
        example:
          - height = self.button.getHeight()
        """

    def getId(*args):
        """getId() -- Returns the control's current id as an integer.
        
        example:
          - id = self.button.getId()
        """

    def getLabel(*args):
        """getLabel() -- Returns the text value for this label.
        
        example:
          - label = self.label.getLabel()
        """

    def getPosition(*args):
        """getPosition() -- Returns the control's current position as a x,y integer tuple.
        
        example:
          - pos = self.button.getPosition()
        """

    def getWidth(*args):
        """getWidth() -- Returns the control's current width as an integer.
        
        example:
          - width = self.button.getWidth()
        """

    def setAnimations(*args):
        """setAnimations([(event, attr,)*]) -- Set's the control's animations.
        
        [(event,attr,)*] : list - A list of tuples consisting of event and attributes pairs.
          - event        : string - The event to animate.
          - attr         : string - The whole attribute string separated by spaces.
        
        Animating your skin - http://wiki.xbmc.org/?title=Animating_Your_Skin 
        
        example:
          - self.button.setAnimations([('focus', 'effect=zoom end=90,247,220,56 time=0',)])
        """

    def setEnableCondition(*args):
        """setEnableCondition(enable) -- Set's the control's enabled condition.
            Allows XBMC to control the enabled status of the control.
        
        enable           : string - Enable condition.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setEnableCondition('System.InternetState')
        """

    def setEnabled(*args):
        """setEnabled(enabled) -- Set's the control's enabled/disabled state.
        
        enabled        : bool - True=enabled / False=disabled.
        
        example:
          - self.button.setEnabled(False)
        """

    def setHeight(*args):
        """setHeight(height) -- Set's the controls height.
        
        height         : integer - height of control.
        
        example:
          - self.image.setHeight(100)
        """

    def setLabel(*args):
        """setLabel(label) -- Set's text for this label.
        
        label          : string or unicode - text string.
        
        example:
          - self.label.setLabel('Status')
        """

    def setNavigation(*args):
        """setNavigation(up, down, left, right) -- Set's the controls navigation.
        
        up             : control object - control to navigate to on up.
        down           : control object - control to navigate to on down.
        left           : control object - control to navigate to on left.
        right          : control object - control to navigate to on right.
        
        *Note, Same as controlUp(), controlDown(), controlLeft(), controlRight().
               Set to self to disable navigation for that direction.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.setNavigation(self.button1, self.button2, self.button3, self.button4)
        """

    def setPosition(*args):
        """setPosition(x, y) -- Set's the controls position.
        
        x              : integer - x coordinate of control.
        y              : integer - y coordinate of control.
        
        *Note, You may use negative integers. (e.g sliding a control into view)
        
        example:
          - self.button.setPosition(100, 250)
        """

    def setVisible(*args):
        """setVisible(visible) -- Set's the control's visible/hidden state.
        
        visible        : bool - True=visible / False=hidden.
        
        example:
          - self.button.setVisible(False)
        """

    def setVisibleCondition(*args):
        """setVisibleCondition(visible[,allowHiddenFocus]) -- Set's the control's visible condition.
            Allows XBMC to control the visible status of the control.
        
        visible          : string - Visible condition.
        allowHiddenFocus : bool - True=gains focus even if hidden.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setVisibleCondition('[Control.IsVisible(41) + !Control.IsVisible(12)]', True)
        """

    def setWidth(*args):
        """setWidth(width) -- Set's the controls width.
        
        width          : integer - width of control.
        
        example:
          - self.image.setWidth(100)
        """



class ControlList:
    """ControlList class.
    
    ControlList(x, y, width, height[, font, textColor, buttonTexture, buttonFocusTexture,
                selectedColor, imageWidth, imageHeight, itemTextXOffset, itemTextYOffset,
                itemHeight, space, alignmentY])
    
    x                  : integer - x coordinate of control.
    y                  : integer - y coordinate of control.
    width              : integer - width of control.
    height             : integer - height of control.
    font               : [opt] string - font used for items label. (e.g. 'font13')
    textColor          : [opt] hexstring - color of items label. (e.g. '0xFFFFFFFF')
    buttonTexture      : [opt] string - filename for focus texture.
    buttonFocusTexture : [opt] string - filename for no focus texture.
    selectedColor      : [opt] integer - x offset of label.
    imageWidth         : [opt] integer - width of items icon or thumbnail.
    imageHeight        : [opt] integer - height of items icon or thumbnail.
    itemTextXOffset    : [opt] integer - x offset of items label.
    itemTextYOffset    : [opt] integer - y offset of items label.
    itemHeight         : [opt] integer - height of items.
    space              : [opt] integer - space between items.
    alignmentY         : [opt] integer - Y-axis alignment of items label - *Note, see xbfont.h
    
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
           After you create the control, you need to add it to the window with addControl().
    
    example:
      - self.cList = xbmcgui.ControlList(100, 250, 200, 250, 'font14', space=5)
    """

    def __cmp__(*args):
        """x.__cmp__(y) <==> cmp(x,y)
        """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def addItem(*args):
        """addItem(item) -- Add a new item to this list control.
        
        item               : string, unicode or ListItem - item to add.
        
        example:
          - cList.addItem('Reboot XBMC')
        """

    def addItems(*args):
        """addItems(items) -- Adds a list of listitems or strings to this list control.
        
        items                : List - list of strings, unicode objects or ListItems to add.
        
        *Note, You can use the above as keywords for arguments.
        
               Large lists benefit considerably, than using the standard addItem()
        example:
          - cList.addItems(items=listitems)
        """

    def controlDown(*args):
        """controlDown(control) -- Set's the controls down navigation.
        
        control        : control object - control to navigate to on down.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlDown(self.button1)
        """

    def controlLeft(*args):
        """controlLeft(control) -- Set's the controls left navigation.
        
        control        : control object - control to navigate to on left.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlLeft(self.button1)
        """

    def controlRight(*args):
        """controlRight(control) -- Set's the controls right navigation.
        
        control        : control object - control to navigate to on right.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlRight(self.button1)
        """

    def controlUp(*args):
        """controlUp(control) -- Set's the controls up navigation.
        
        control        : control object - control to navigate to on up.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlUp(self.button1)
        """

    def getHeight(*args):
        """getHeight() -- Returns the control's current height as an integer.
        
        example:
          - height = self.button.getHeight()
        """

    def getId(*args):
        """getId() -- Returns the control's current id as an integer.
        
        example:
          - id = self.button.getId()
        """

    def getItemHeight(*args):
        """getItemHeight() -- Returns the control's current item height as an integer.
        
        example:
          - item_height = self.cList.getItemHeight()
        """

    def getListItem(*args):
        """getListItem(index) -- Returns a given ListItem in this List.
        
        index           : integer - index number of item to return.
        
        *Note, throws a ValueError if index is out of range.
        
        example:
          - listitem = cList.getListItem(6)
        """

    def getPosition(*args):
        """getPosition() -- Returns the control's current position as a x,y integer tuple.
        
        example:
          - pos = self.button.getPosition()
        """

    def getSelectedItem(*args):
        """getSelectedItem() -- Returns the selected item as a ListItem object.
        
        *Note, Same as getSelectedPosition(), but instead of an integer a ListItem object
               is returned. Returns None for empty lists.
               See windowexample.py on how to use this.
        
        example:
          - item = cList.getSelectedItem()
        """

    def getSelectedPosition(*args):
        """getSelectedPosition() -- Returns the position of the selected item as an integer.
        
        *Note, Returns -1 for empty lists.
        
        example:
          - pos = cList.getSelectedPosition()
        """

    def getSpace(*args):
        """getSpace() -- Returns the control's space between items as an integer.
        
        example:
          - gap = self.cList.getSpace()
        """

    def getSpinControl(*args):
        """getSpinControl() -- returns the associated ControlSpin object.
        
        *Note, Not working completely yet -
               After adding this control list to a window it is not possible to change
               the settings of this spin control.
        
        example:
          - ctl = cList.getSpinControl()
        """

    def getWidth(*args):
        """getWidth() -- Returns the control's current width as an integer.
        
        example:
          - width = self.button.getWidth()
        """

    def reset(*args):
        """reset() -- Clear all ListItems in this control list.
        
        example:
          - cList.reset()
        """

    def selectItem(*args):
        """selectItem(item) -- Select an item by index number.
        
        item               : integer - index number of the item to select.
        
        example:
          - cList.selectItem(12)
        """

    def setAnimations(*args):
        """setAnimations([(event, attr,)*]) -- Set's the control's animations.
        
        [(event,attr,)*] : list - A list of tuples consisting of event and attributes pairs.
          - event        : string - The event to animate.
          - attr         : string - The whole attribute string separated by spaces.
        
        Animating your skin - http://wiki.xbmc.org/?title=Animating_Your_Skin 
        
        example:
          - self.button.setAnimations([('focus', 'effect=zoom end=90,247,220,56 time=0',)])
        """

    def setEnableCondition(*args):
        """setEnableCondition(enable) -- Set's the control's enabled condition.
            Allows XBMC to control the enabled status of the control.
        
        enable           : string - Enable condition.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setEnableCondition('System.InternetState')
        """

    def setEnabled(*args):
        """setEnabled(enabled) -- Set's the control's enabled/disabled state.
        
        enabled        : bool - True=enabled / False=disabled.
        
        example:
          - self.button.setEnabled(False)
        """

    def setHeight(*args):
        """setHeight(height) -- Set's the controls height.
        
        height         : integer - height of control.
        
        example:
          - self.image.setHeight(100)
        """

    def setImageDimensions(*args):
        """setImageDimensions(imageWidth, imageHeight) -- Sets the width/height of items icon or thumbnail.
        
        imageWidth         : [opt] integer - width of items icon or thumbnail.
        imageHeight        : [opt] integer - height of items icon or thumbnail.
        
        example:
          - cList.setImageDimensions(18, 18)
        """

    def setItemHeight(*args):
        """setItemHeight(itemHeight) -- Sets the height of items.
        
        itemHeight         : integer - height of items.
        
        example:
          - cList.setItemHeight(25)
        """

    def setNavigation(*args):
        """setNavigation(up, down, left, right) -- Set's the controls navigation.
        
        up             : control object - control to navigate to on up.
        down           : control object - control to navigate to on down.
        left           : control object - control to navigate to on left.
        right          : control object - control to navigate to on right.
        
        *Note, Same as controlUp(), controlDown(), controlLeft(), controlRight().
               Set to self to disable navigation for that direction.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.setNavigation(self.button1, self.button2, self.button3, self.button4)
        """

    def setPageControlVisible(*args):
        """setPageControlVisible(visible) -- Sets the spin control's visible/hidden state.
        
        visible            : boolean - True=visible / False=hidden.
        
        example:
          - cList.setPageControlVisible(True)
        """

    def setPosition(*args):
        """setPosition(x, y) -- Set's the controls position.
        
        x              : integer - x coordinate of control.
        y              : integer - y coordinate of control.
        
        *Note, You may use negative integers. (e.g sliding a control into view)
        
        example:
          - self.button.setPosition(100, 250)
        """

    def setSpace(*args):
        """setSpace(space) -- Set's the space between items.
        
        space              : [opt] integer - space between items.
        
        example:
          - cList.setSpace(5)
        """

    def setStaticContent(*args):
        """setStaticContent(items) -- Fills a static list with a list of listitems.
        
        items                : List - list of listitems to add.
        
        *Note, You can use the above as keywords for arguments.
        
        example:
          - cList.setStaticContent(items=listitems)
        """

    def setVisible(*args):
        """setVisible(visible) -- Set's the control's visible/hidden state.
        
        visible        : bool - True=visible / False=hidden.
        
        example:
          - self.button.setVisible(False)
        """

    def setVisibleCondition(*args):
        """setVisibleCondition(visible[,allowHiddenFocus]) -- Set's the control's visible condition.
            Allows XBMC to control the visible status of the control.
        
        visible          : string - Visible condition.
        allowHiddenFocus : bool - True=gains focus even if hidden.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setVisibleCondition('[Control.IsVisible(41) + !Control.IsVisible(12)]', True)
        """

    def setWidth(*args):
        """setWidth(width) -- Set's the controls width.
        
        width          : integer - width of control.
        
        example:
          - self.image.setWidth(100)
        """

    def size(*args):
        """size() -- Returns the total number of items in this list control as an integer.
        
        example:
          - cnt = cList.size()
        """



class ControlProgress:
    """ControlProgress class.
    
    ControlProgress(x, y, width, height[, texturebg, textureleft, texturemid, textureright, textureoverlay])
    
    x              : integer - x coordinate of control.
    y              : integer - y coordinate of control.
    width          : integer - width of control.
    height         : integer - height of control.
    texturebg      : [opt] string - image filename.
    textureleft    : [opt] string - image filename.
    texturemid     : [opt] string - image filename.
    textureright   : [opt] string - image filename.
    textureoverlay : [opt] string - image filename.
    
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
           After you create the control, you need to add it to the window with addControl().
    
    example:
      - self.progress = xbmcgui.ControlProgress(100, 250, 125, 75)
    """

    def __cmp__(*args):
        """x.__cmp__(y) <==> cmp(x,y)
        """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def controlDown(*args):
        """controlDown(control) -- Set's the controls down navigation.
        
        control        : control object - control to navigate to on down.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlDown(self.button1)
        """

    def controlLeft(*args):
        """controlLeft(control) -- Set's the controls left navigation.
        
        control        : control object - control to navigate to on left.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlLeft(self.button1)
        """

    def controlRight(*args):
        """controlRight(control) -- Set's the controls right navigation.
        
        control        : control object - control to navigate to on right.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlRight(self.button1)
        """

    def controlUp(*args):
        """controlUp(control) -- Set's the controls up navigation.
        
        control        : control object - control to navigate to on up.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlUp(self.button1)
        """

    def getHeight(*args):
        """getHeight() -- Returns the control's current height as an integer.
        
        example:
          - height = self.button.getHeight()
        """

    def getId(*args):
        """getId() -- Returns the control's current id as an integer.
        
        example:
          - id = self.button.getId()
        """

    def getPercent(*args):
        """getPercent() -- Returns a float of the percent of the progress.
        
        example:
          - print self.progress.getValue()
        """

    def getPosition(*args):
        """getPosition() -- Returns the control's current position as a x,y integer tuple.
        
        example:
          - pos = self.button.getPosition()
        """

    def getWidth(*args):
        """getWidth() -- Returns the control's current width as an integer.
        
        example:
          - width = self.button.getWidth()
        """

    def setAnimations(*args):
        """setAnimations([(event, attr,)*]) -- Set's the control's animations.
        
        [(event,attr,)*] : list - A list of tuples consisting of event and attributes pairs.
          - event        : string - The event to animate.
          - attr         : string - The whole attribute string separated by spaces.
        
        Animating your skin - http://wiki.xbmc.org/?title=Animating_Your_Skin 
        
        example:
          - self.button.setAnimations([('focus', 'effect=zoom end=90,247,220,56 time=0',)])
        """

    def setEnableCondition(*args):
        """setEnableCondition(enable) -- Set's the control's enabled condition.
            Allows XBMC to control the enabled status of the control.
        
        enable           : string - Enable condition.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setEnableCondition('System.InternetState')
        """

    def setEnabled(*args):
        """setEnabled(enabled) -- Set's the control's enabled/disabled state.
        
        enabled        : bool - True=enabled / False=disabled.
        
        example:
          - self.button.setEnabled(False)
        """

    def setHeight(*args):
        """setHeight(height) -- Set's the controls height.
        
        height         : integer - height of control.
        
        example:
          - self.image.setHeight(100)
        """

    def setNavigation(*args):
        """setNavigation(up, down, left, right) -- Set's the controls navigation.
        
        up             : control object - control to navigate to on up.
        down           : control object - control to navigate to on down.
        left           : control object - control to navigate to on left.
        right          : control object - control to navigate to on right.
        
        *Note, Same as controlUp(), controlDown(), controlLeft(), controlRight().
               Set to self to disable navigation for that direction.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.setNavigation(self.button1, self.button2, self.button3, self.button4)
        """

    def setPercent(*args):
        """setPercent(percent) -- Sets the percentage of the progressbar to show.
        
        percent       : float - percentage of the bar to show.
        
        *Note, valid range for percent is 0-100
        
        example:
          - self.progress.setPercent(60)
        """

    def setPosition(*args):
        """setPosition(x, y) -- Set's the controls position.
        
        x              : integer - x coordinate of control.
        y              : integer - y coordinate of control.
        
        *Note, You may use negative integers. (e.g sliding a control into view)
        
        example:
          - self.button.setPosition(100, 250)
        """

    def setVisible(*args):
        """setVisible(visible) -- Set's the control's visible/hidden state.
        
        visible        : bool - True=visible / False=hidden.
        
        example:
          - self.button.setVisible(False)
        """

    def setVisibleCondition(*args):
        """setVisibleCondition(visible[,allowHiddenFocus]) -- Set's the control's visible condition.
            Allows XBMC to control the visible status of the control.
        
        visible          : string - Visible condition.
        allowHiddenFocus : bool - True=gains focus even if hidden.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setVisibleCondition('[Control.IsVisible(41) + !Control.IsVisible(12)]', True)
        """

    def setWidth(*args):
        """setWidth(width) -- Set's the controls width.
        
        width          : integer - width of control.
        
        example:
          - self.image.setWidth(100)
        """



class ControlRadioButton:
    """ControlRadioButton class.
    
    ControlRadioButton(x, y, width, height, label[, focusTexture, noFocusTexture, textOffsetX, textOffsetY,
                  alignment, font, textColor, disabledColor, angle, shadowColor, focusedColor,
                  radioFocusTexture, noRadioFocusTexture])
    
    x                   : integer - x coordinate of control.
    y                   : integer - y coordinate of control.
    width               : integer - width of control.
    height              : integer - height of control.
    label               : string or unicode - text string.
    focusTexture        : [opt] string - filename for focus texture.
    noFocusTexture      : [opt] string - filename for no focus texture.
    textOffsetX         : [opt] integer - x offset of label.
    textOffsetY         : [opt] integer - y offset of label.
    alignment           : [opt] integer - alignment of label - *Note, see xbfont.h
    font                : [opt] string - font used for label text. (e.g. 'font13')
    textColor           : [opt] hexstring - color of enabled radio button's label. (e.g. '0xFFFFFFFF')
    disabledColor       : [opt] hexstring - color of disabled radio button's label. (e.g. '0xFFFF3300')
    angle               : [opt] integer - angle of control. (+ rotates CCW, - rotates CW)
    shadowColor         : [opt] hexstring - color of radio button's label's shadow. (e.g. '0xFF000000')
    focusedColor        : [opt] hexstring - color of focused radio button's label. (e.g. '0xFF00FFFF')
    radioFocusTexture   : [opt] string - filename for radio focus texture.
    noRadioFocusTexture : [opt] string - filename for radio no focus texture.
    
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
           After you create the control, you need to add it to the window with addControl().
    
    example:
      - self.radiobutton = xbmcgui.ControlRadioButton(100, 250, 200, 50, 'Status', font='font14')
    """

    def __cmp__(*args):
        """x.__cmp__(y) <==> cmp(x,y)
        """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def controlDown(*args):
        """controlDown(control) -- Set's the controls down navigation.
        
        control        : control object - control to navigate to on down.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlDown(self.button1)
        """

    def controlLeft(*args):
        """controlLeft(control) -- Set's the controls left navigation.
        
        control        : control object - control to navigate to on left.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlLeft(self.button1)
        """

    def controlRight(*args):
        """controlRight(control) -- Set's the controls right navigation.
        
        control        : control object - control to navigate to on right.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlRight(self.button1)
        """

    def controlUp(*args):
        """controlUp(control) -- Set's the controls up navigation.
        
        control        : control object - control to navigate to on up.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlUp(self.button1)
        """

    def getHeight(*args):
        """getHeight() -- Returns the control's current height as an integer.
        
        example:
          - height = self.button.getHeight()
        """

    def getId(*args):
        """getId() -- Returns the control's current id as an integer.
        
        example:
          - id = self.button.getId()
        """

    def getPosition(*args):
        """getPosition() -- Returns the control's current position as a x,y integer tuple.
        
        example:
          - pos = self.button.getPosition()
        """

    def getWidth(*args):
        """getWidth() -- Returns the control's current width as an integer.
        
        example:
          - width = self.button.getWidth()
        """

    def isSelected(*args):
        """isSelected() -- Returns the radio buttons's selected status.
        
        example:
          - is = self.radiobutton.isSelected()
        """

    def setAnimations(*args):
        """setAnimations([(event, attr,)*]) -- Set's the control's animations.
        
        [(event,attr,)*] : list - A list of tuples consisting of event and attributes pairs.
          - event        : string - The event to animate.
          - attr         : string - The whole attribute string separated by spaces.
        
        Animating your skin - http://wiki.xbmc.org/?title=Animating_Your_Skin 
        
        example:
          - self.button.setAnimations([('focus', 'effect=zoom end=90,247,220,56 time=0',)])
        """

    def setEnableCondition(*args):
        """setEnableCondition(enable) -- Set's the control's enabled condition.
            Allows XBMC to control the enabled status of the control.
        
        enable           : string - Enable condition.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setEnableCondition('System.InternetState')
        """

    def setEnabled(*args):
        """setEnabled(enabled) -- Set's the control's enabled/disabled state.
        
        enabled        : bool - True=enabled / False=disabled.
        
        example:
          - self.button.setEnabled(False)
        """

    def setHeight(*args):
        """setHeight(height) -- Set's the controls height.
        
        height         : integer - height of control.
        
        example:
          - self.image.setHeight(100)
        """

    def setLabel(*args):
        """setLabel(label[, font, textColor, disabledColor, shadowColor, focusedColor]) -- Set's the radio buttons text attributes.
        
        label          : string or unicode - text string.
        font           : [opt] string - font used for label text. (e.g. 'font13')
        textColor      : [opt] hexstring - color of enabled radio button's label. (e.g. '0xFFFFFFFF')
        disabledColor  : [opt] hexstring - color of disabled radio button's label. (e.g. '0xFFFF3300')
        shadowColor    : [opt] hexstring - color of radio button's label's shadow. (e.g. '0xFF000000')
        focusedColor   : [opt] hexstring - color of focused radio button's label. (e.g. '0xFFFFFF00')
        
        *Note, You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - self.radiobutton.setLabel('Status', 'font14', '0xFFFFFFFF', '0xFFFF3300', '0xFF000000')
        """

    def setNavigation(*args):
        """setNavigation(up, down, left, right) -- Set's the controls navigation.
        
        up             : control object - control to navigate to on up.
        down           : control object - control to navigate to on down.
        left           : control object - control to navigate to on left.
        right          : control object - control to navigate to on right.
        
        *Note, Same as controlUp(), controlDown(), controlLeft(), controlRight().
               Set to self to disable navigation for that direction.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.setNavigation(self.button1, self.button2, self.button3, self.button4)
        """

    def setPosition(*args):
        """setPosition(x, y) -- Set's the controls position.
        
        x              : integer - x coordinate of control.
        y              : integer - y coordinate of control.
        
        *Note, You may use negative integers. (e.g sliding a control into view)
        
        example:
          - self.button.setPosition(100, 250)
        """

    def setRadioDimension(*args):
        """setRadioDimension(x, y, width, height) -- Sets the radio buttons's radio texture's position and size.
        
        x                   : integer - x coordinate of radio texture.
        y                   : integer - y coordinate of radio texture.
        width               : integer - width of radio texture.
        height              : integer - height of radio texture.
        
        *Note, You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - self.radiobutton.setRadioDimension(x=100, y=5, width=20, height=20)
        """

    def setSelected(*args):
        """setSelected(selected) -- Sets the radio buttons's selected status.
        
        selected            : bool - True=selected (on) / False=not selected (off)
        
        *Note, You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - self.radiobutton.setSelected(True)
        """

    def setVisible(*args):
        """setVisible(visible) -- Set's the control's visible/hidden state.
        
        visible        : bool - True=visible / False=hidden.
        
        example:
          - self.button.setVisible(False)
        """

    def setVisibleCondition(*args):
        """setVisibleCondition(visible[,allowHiddenFocus]) -- Set's the control's visible condition.
            Allows XBMC to control the visible status of the control.
        
        visible          : string - Visible condition.
        allowHiddenFocus : bool - True=gains focus even if hidden.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setVisibleCondition('[Control.IsVisible(41) + !Control.IsVisible(12)]', True)
        """

    def setWidth(*args):
        """setWidth(width) -- Set's the controls width.
        
        width          : integer - width of control.
        
        example:
          - self.image.setWidth(100)
        """



class ControlSlider:
    """ControlSlider class.
    
    ControlSlider(x, y, width, height[, textureback, texture, texturefocus])
    
    x              : integer - x coordinate of control.
    y              : integer - y coordinate of control.
    width          : integer - width of control.
    height         : integer - height of control.
    textureback    : [opt] string - image filename.
    texture        : [opt] string - image filename.
    texturefocus   : [opt] string - image filename.
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
           After you create the control, you need to add it to the window with addControl().
    
    example:
      - self.slider = xbmcgui.ControlSlider(100, 250, 350, 40)
    """

    def __cmp__(*args):
        """x.__cmp__(y) <==> cmp(x,y)
        """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def controlDown(*args):
        """controlDown(control) -- Set's the controls down navigation.
        
        control        : control object - control to navigate to on down.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlDown(self.button1)
        """

    def controlLeft(*args):
        """controlLeft(control) -- Set's the controls left navigation.
        
        control        : control object - control to navigate to on left.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlLeft(self.button1)
        """

    def controlRight(*args):
        """controlRight(control) -- Set's the controls right navigation.
        
        control        : control object - control to navigate to on right.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlRight(self.button1)
        """

    def controlUp(*args):
        """controlUp(control) -- Set's the controls up navigation.
        
        control        : control object - control to navigate to on up.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlUp(self.button1)
        """

    def getHeight(*args):
        """getHeight() -- Returns the control's current height as an integer.
        
        example:
          - height = self.button.getHeight()
        """

    def getId(*args):
        """getId() -- Returns the control's current id as an integer.
        
        example:
          - id = self.button.getId()
        """

    def getPercent(*args):
        """getPercent() -- Returns a float of the percent of the slider.
        
        example:
          - print self.slider.getPercent()
        """

    def getPosition(*args):
        """getPosition() -- Returns the control's current position as a x,y integer tuple.
        
        example:
          - pos = self.button.getPosition()
        """

    def getWidth(*args):
        """getWidth() -- Returns the control's current width as an integer.
        
        example:
          - width = self.button.getWidth()
        """

    def setAnimations(*args):
        """setAnimations([(event, attr,)*]) -- Set's the control's animations.
        
        [(event,attr,)*] : list - A list of tuples consisting of event and attributes pairs.
          - event        : string - The event to animate.
          - attr         : string - The whole attribute string separated by spaces.
        
        Animating your skin - http://wiki.xbmc.org/?title=Animating_Your_Skin 
        
        example:
          - self.button.setAnimations([('focus', 'effect=zoom end=90,247,220,56 time=0',)])
        """

    def setEnableCondition(*args):
        """setEnableCondition(enable) -- Set's the control's enabled condition.
            Allows XBMC to control the enabled status of the control.
        
        enable           : string - Enable condition.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setEnableCondition('System.InternetState')
        """

    def setEnabled(*args):
        """setEnabled(enabled) -- Set's the control's enabled/disabled state.
        
        enabled        : bool - True=enabled / False=disabled.
        
        example:
          - self.button.setEnabled(False)
        """

    def setHeight(*args):
        """setHeight(height) -- Set's the controls height.
        
        height         : integer - height of control.
        
        example:
          - self.image.setHeight(100)
        """

    def setNavigation(*args):
        """setNavigation(up, down, left, right) -- Set's the controls navigation.
        
        up             : control object - control to navigate to on up.
        down           : control object - control to navigate to on down.
        left           : control object - control to navigate to on left.
        right          : control object - control to navigate to on right.
        
        *Note, Same as controlUp(), controlDown(), controlLeft(), controlRight().
               Set to self to disable navigation for that direction.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.setNavigation(self.button1, self.button2, self.button3, self.button4)
        """

    def setPercent(*args):
        """setPercent(50) -- Sets the percent of the slider.
        
        example:
        self.slider.setPercent(50)
        """

    def setPosition(*args):
        """setPosition(x, y) -- Set's the controls position.
        
        x              : integer - x coordinate of control.
        y              : integer - y coordinate of control.
        
        *Note, You may use negative integers. (e.g sliding a control into view)
        
        example:
          - self.button.setPosition(100, 250)
        """

    def setVisible(*args):
        """setVisible(visible) -- Set's the control's visible/hidden state.
        
        visible        : bool - True=visible / False=hidden.
        
        example:
          - self.button.setVisible(False)
        """

    def setVisibleCondition(*args):
        """setVisibleCondition(visible[,allowHiddenFocus]) -- Set's the control's visible condition.
            Allows XBMC to control the visible status of the control.
        
        visible          : string - Visible condition.
        allowHiddenFocus : bool - True=gains focus even if hidden.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setVisibleCondition('[Control.IsVisible(41) + !Control.IsVisible(12)]', True)
        """

    def setWidth(*args):
        """setWidth(width) -- Set's the controls width.
        
        width          : integer - width of control.
        
        example:
          - self.image.setWidth(100)
        """



class ControlTextBox:
    """ControlTextBox class.
    
    ControlTextBox(x, y, width, height[, font, textColor])
    
    x              : integer - x coordinate of control.
    y              : integer - y coordinate of control.
    width          : integer - width of control.
    height         : integer - height of control.
    font           : [opt] string - font used for text. (e.g. 'font13')
    textColor      : [opt] hexstring - color of textbox's text. (e.g. '0xFFFFFFFF')
    
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
           After you create the control, you need to add it to the window with addControl().
    
    example:
      - self.textbox = xbmcgui.ControlTextBox(100, 250, 300, 300, textColor='0xFFFFFFFF')
    """

    def __cmp__(*args):
        """x.__cmp__(y) <==> cmp(x,y)
        """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def controlDown(*args):
        """controlDown(control) -- Set's the controls down navigation.
        
        control        : control object - control to navigate to on down.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlDown(self.button1)
        """

    def controlLeft(*args):
        """controlLeft(control) -- Set's the controls left navigation.
        
        control        : control object - control to navigate to on left.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlLeft(self.button1)
        """

    def controlRight(*args):
        """controlRight(control) -- Set's the controls right navigation.
        
        control        : control object - control to navigate to on right.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlRight(self.button1)
        """

    def controlUp(*args):
        """controlUp(control) -- Set's the controls up navigation.
        
        control        : control object - control to navigate to on up.
        
        *Note, You can also use setNavigation(). Set to self to disable navigation.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.controlUp(self.button1)
        """

    def getHeight(*args):
        """getHeight() -- Returns the control's current height as an integer.
        
        example:
          - height = self.button.getHeight()
        """

    def getId(*args):
        """getId() -- Returns the control's current id as an integer.
        
        example:
          - id = self.button.getId()
        """

    def getPosition(*args):
        """getPosition() -- Returns the control's current position as a x,y integer tuple.
        
        example:
          - pos = self.button.getPosition()
        """

    def getWidth(*args):
        """getWidth() -- Returns the control's current width as an integer.
        
        example:
          - width = self.button.getWidth()
        """

    def reset(*args):
        """reset() -- Clear's this textbox.
        
        example:
          - self.textbox.reset()
        """

    def scroll(*args):
        """scroll(position) -- Scrolls to the given position.
        
        id           : integer - position to scroll to.
        
        example:
          - self.textbox.scroll(10)
        """

    def setAnimations(*args):
        """setAnimations([(event, attr,)*]) -- Set's the control's animations.
        
        [(event,attr,)*] : list - A list of tuples consisting of event and attributes pairs.
          - event        : string - The event to animate.
          - attr         : string - The whole attribute string separated by spaces.
        
        Animating your skin - http://wiki.xbmc.org/?title=Animating_Your_Skin 
        
        example:
          - self.button.setAnimations([('focus', 'effect=zoom end=90,247,220,56 time=0',)])
        """

    def setEnableCondition(*args):
        """setEnableCondition(enable) -- Set's the control's enabled condition.
            Allows XBMC to control the enabled status of the control.
        
        enable           : string - Enable condition.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setEnableCondition('System.InternetState')
        """

    def setEnabled(*args):
        """setEnabled(enabled) -- Set's the control's enabled/disabled state.
        
        enabled        : bool - True=enabled / False=disabled.
        
        example:
          - self.button.setEnabled(False)
        """

    def setHeight(*args):
        """setHeight(height) -- Set's the controls height.
        
        height         : integer - height of control.
        
        example:
          - self.image.setHeight(100)
        """

    def setNavigation(*args):
        """setNavigation(up, down, left, right) -- Set's the controls navigation.
        
        up             : control object - control to navigate to on up.
        down           : control object - control to navigate to on down.
        left           : control object - control to navigate to on left.
        right          : control object - control to navigate to on right.
        
        *Note, Same as controlUp(), controlDown(), controlLeft(), controlRight().
               Set to self to disable navigation for that direction.
        
        Throws: TypeError, if one of the supplied arguments is not a control type.
                ReferenceError, if one of the controls is not added to a window.
        
        example:
          - self.button.setNavigation(self.button1, self.button2, self.button3, self.button4)
        """

    def setPosition(*args):
        """setPosition(x, y) -- Set's the controls position.
        
        x              : integer - x coordinate of control.
        y              : integer - y coordinate of control.
        
        *Note, You may use negative integers. (e.g sliding a control into view)
        
        example:
          - self.button.setPosition(100, 250)
        """

    def setText(*args):
        """setText(text) -- Set's the text for this textbox.
        
        text           : string or unicode - text string.
        
        example:
          - self.textbox.setText('This is a line of text that can wrap.')
        """

    def setVisible(*args):
        """setVisible(visible) -- Set's the control's visible/hidden state.
        
        visible        : bool - True=visible / False=hidden.
        
        example:
          - self.button.setVisible(False)
        """

    def setVisibleCondition(*args):
        """setVisibleCondition(visible[,allowHiddenFocus]) -- Set's the control's visible condition.
            Allows XBMC to control the visible status of the control.
        
        visible          : string - Visible condition.
        allowHiddenFocus : bool - True=gains focus even if hidden.
        
        List of Conditions - http://wiki.xbmc.org/index.php?title=List_of_Boolean_Conditions 
        
        example:
          - self.button.setVisibleCondition('[Control.IsVisible(41) + !Control.IsVisible(12)]', True)
        """

    def setWidth(*args):
        """setWidth(width) -- Set's the controls width.
        
        width          : integer - width of control.
        
        example:
          - self.image.setWidth(100)
        """



class Dialog:
    """Dialog class.
    """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def browse(*args):
        """browse(type, heading, shares[, mask, useThumbs, treatAsFolder, default, enableMultiple]) -- Show a 'Browse' dialog.
        
        type           : integer - the type of browse dialog.
        heading        : string or unicode - dialog heading.
        shares         : string or unicode - from sources.xml. (i.e. 'myprograms')
        mask           : [opt] string or unicode - '|' separated file mask. (i.e. '.jpg|.png')
        useThumbs      : [opt] boolean - if True autoswitch to Thumb view if files exist.
        treatAsFolder  : [opt] boolean - if True playlists and archives act as folders.
        default        : [opt] string - default path or file.
        
        enableMultiple : [opt] boolean - if True multiple file selection is enabled.
        Types:
          0 : ShowAndGetDirectory
          1 : ShowAndGetFile
          2 : ShowAndGetImage
          3 : ShowAndGetWriteableDirectory
        
        *Note, If enableMultiple is False (default): returns filename and/or path as a string
               to the location of the highlighted item, if user pressed 'Ok' or a masked item
               was selected. Returns the default value if dialog was canceled.
               If enableMultiple is True: returns tuple of marked filenames as a string,       if user pressed 'Ok' or a masked item was selected. Returns empty tuple if dialog was canceled.
        
               If type is 0 or 3 the enableMultiple parameter is ignored.
        example:
          - dialog = xbmcgui.Dialog()
          - fn = dialog.browse(3, 'XBMC', 'files', '', False, False, False, 'special://masterprofile/script_data/XBMC Lyrics')
        """

    def numeric(*args):
        """numeric(type, heading[, default]) -- Show a 'Numeric' dialog.
        
        type           : integer - the type of numeric dialog.
        heading        : string or unicode - dialog heading.
        default        : [opt] string - default value.
        
        Types:
          0 : ShowAndGetNumber    (default format: #)
          1 : ShowAndGetDate      (default format: DD/MM/YYYY)
          2 : ShowAndGetTime      (default format: HH:MM)
          3 : ShowAndGetIPAddress (default format: #.#.#.#)
        
        *Note, Returns the entered data as a string.
               Returns the default value if dialog was canceled.
        
        example:
          - dialog = xbmcgui.Dialog()
          - d = dialog.numeric(1, 'Enter date of birth')
        """

    def ok(*args):
        """ok(heading, line1[, line2, line3]) -- Show a dialog 'OK'.
        
        heading        : string or unicode - dialog heading.
        line1          : string or unicode - line #1 text.
        line2          : [opt] string or unicode - line #2 text.
        line3          : [opt] string or unicode - line #3 text.
        
        *Note, Returns True if 'Ok' was pressed, else False.
        
        example:
          - dialog = xbmcgui.Dialog()
          - ok = dialog.ok('XBMC', 'There was an error.')
        """

    def select(*args):
        """select(heading, list) -- Show a select dialog.
        
        heading        : string or unicode - dialog heading.
        list           : string list - list of items.
        autoclose      : [opt] integer - milliseconds to autoclose dialog. (default=do not autoclose)
        
        *Note, Returns the position of the highlighted item as an integer.
        
        example:
          - dialog = xbmcgui.Dialog()
          - ret = dialog.select('Choose a playlist', ['Playlist #1', 'Playlist #2, 'Playlist #3'])
        """

    def yesno(*args):
        """yesno(heading, line1[, line2, line3]) -- Show a dialog 'YES/NO'.
        
        heading        : string or unicode - dialog heading.
        line1          : string or unicode - line #1 text.
        line2          : [opt] string or unicode - line #2 text.
        line3          : [opt] string or unicode - line #3 text.
        nolabel        : [opt] label to put on the no button.
        yeslabel       : [opt] label to put on the yes button.
        
        *Note, Returns True if 'Yes' was pressed, else False.
        
        example:
          - dialog = xbmcgui.Dialog()
          - ret = dialog.yesno('XBMC', 'Do you want to exit this script?')
        """



class DialogProgress:
    """DialogProgress class.
    """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def close(*args):
        """close() -- Close the progress dialog.
        
        example:
          - pDialog.close()
        """

    def create(*args):
        """create(heading[, line1, line2, line3]) -- Create and show a progress dialog.
        
        heading        : string or unicode - dialog heading.
        line1          : string or unicode - line #1 text.
        line2          : [opt] string or unicode - line #2 text.
        line3          : [opt] string or unicode - line #3 text.
        
        *Note, Use update() to update lines and progressbar.
        
        example:
          - pDialog = xbmcgui.DialogProgress()
          - ret = pDialog.create('XBMC', 'Initializing script...')
        """

    def iscanceled(*args):
        """iscanceled() -- Returns True if the user pressed cancel.
        
        example:
          - if (pDialog.iscanceled()): return
        """

    def update(*args):
        """update(percent[, line1, line2, line3]) -- Update's the progress dialog.
        
        percent        : integer - percent complete. (0:100)
        line1          : [opt] string or unicode - line #1 text.
        line2          : [opt] string or unicode - line #2 text.
        line3          : [opt] string or unicode - line #3 text.
        
        *Note, If percent == 0, the progressbar will be hidden.
        
        example:
          - pDialog.update(25, 'Importing modules...')
        """



ICON_OVERLAY_HAS_TRAINER = int
ICON_OVERLAY_HD = int
ICON_OVERLAY_LOCKED = int
ICON_OVERLAY_NONE = int
ICON_OVERLAY_RAR = int
ICON_OVERLAY_TRAINED = int
ICON_OVERLAY_UNWATCHED = int
ICON_OVERLAY_WATCHED = int
ICON_OVERLAY_ZIP = int
class ListItem:
    """ListItem class.
    
    ListItem([label, label2, iconImage, thumbnailImage, path]) -- Creates a new ListItem.
    
    label          : [opt] string or unicode - label1 text.
    label2         : [opt] string or unicode - label2 text.
    iconImage      : [opt] string - icon filename.
    thumbnailImage : [opt] string - thumbnail filename.
    path           : [opt] string or unicode - listitem's path.
    
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
    
    example:
      - listitem = xbmcgui.ListItem('Casino Royale', '[PG-13]', 'blank-poster.tbn', 'poster.tbn', path='f:\\movies\\casino_royale.mov')
    """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def addContextMenuItems(*args):
        """addContextMenuItems([(label, action,)*], replaceItems) -- Adds item(s) to the context menu for media lists.
        
        items               : list - [(label, action,)*] A list of tuples consisting of label and action pairs.
          - label           : string or unicode - item's label.
          - action          : string or unicode - any built-in function to perform.
        replaceItems        : [opt] bool - True=only your items will show/False=your items will be added to context menu(Default).
        
        List of functions - http://wiki.xbmc.org/?title=List_of_Built_In_Functions 
        
        *Note, You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - listitem.addContextMenuItems([('Theater Showtimes', 'XBMC.RunScript(special://home/scripts/showtimes/default.py,Iron Man)',)])
        """

    def getLabel(*args):
        """getLabel() -- Returns the listitem label.
        
        example:
          - label = self.list.getSelectedItem().getLabel()
        """

    def getLabel2(*args):
        """getLabel2() -- Returns the listitem's second label.
        
        example:
          - label2 = self.list.getSelectedItem().getLabel2()
        """

    def getProperty(*args):
        """getProperty(key) -- Returns a listitem property as a string, similar to an infolabel.
        
        key            : string - property name.
        
        *Note, Key is NOT case sensitive.
               You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - AspectRatio = self.list.getSelectedItem().getProperty('AspectRatio')
        """

    def isSelected(*args):
        """isSelected() -- Returns the listitem's selected status.
        
        example:
          - is = self.list.getSelectedItem().isSelected()
        """

    def select(*args):
        """select(selected) -- Sets the listitem's selected status.
        
        selected        : bool - True=selected/False=not selected
        
        example:
          - self.list.getSelectedItem().select(True)
        """

    def setIconImage(*args):
        """setIconImage(icon) -- Sets the listitem's icon image.
        
        icon            : string or unicode - image filename.
        
        example:
          - self.list.getSelectedItem().setIconImage('emailread.png')
        """

    def setInfo(*args):
        """setInfo(type, infoLabels) -- Sets the listitem's infoLabels.
        
        type              : string - type of media(video/music/pictures).
        infoLabels        : dictionary - pairs of { label: value }.
        
        *Note, To set pictures exif info, prepend 'exif:' to the label. Exif values must be passed
               as strings, separate value pairs with a comma. (eg. {'exif:resolution': '720,480'}
               See CPictureInfoTag::TranslateString in PictureInfoTag.cpp for valid strings.
        
               You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        General Values that apply to all types:
            count         : integer (12) - can be used to store an id for later, or for sorting purposes
            size          : long (1024) - size in bytes
            date          : string (%d.%m.%Y / 01.01.2009) - file date
        
        Video Values:
            genre         : string (Comedy)
            year          : integer (2009)
            episode       : integer (4)
            season        : integer (1)
            top250        : integer (192)
            tracknumber   : integer (3)
            rating        : float (6.4) - range is 0..10
            watched       : depreciated - use playcount instead
            playcount     : integer (2) - number of times this item has been played
            overlay       : integer (2) - range is 0..8.  See GUIListItem.h for values
            cast          : list (Michal C. Hall)
            castandrole   : list (Michael C. Hall|Dexter)
            director      : string (Dagur Kari)
            mpaa          : string (PG-13)
            plot          : string (Long Description)
            plotoutline   : string (Short Description)
            title         : string (Big Fan)
            originaltitle : string (Big Fan)
            duration      : string (3:18)
            studio        : string (Warner Bros.)
            tagline       : string (An awesome movie) - short description of movie
            writer        : string (Robert D. Siegel)
            tvshowtitle   : string (Heroes)
            premiered     : string (2005-03-04)
            status        : string (Continuing) - status of a TVshow
            code          : string (tt0110293) - IMDb code
            aired         : string (2008-12-07)
            credits       : string (Andy Kaufman) - writing credits
            lastplayed    : string (%Y-%m-%d %h:%m:%s = 2009-04-05 23:16:04)
            album         : string (The Joshua Tree)
            votes         : string (12345 votes)
            trailer       : string (/home/user/trailer.avi)
        
        Music Values:
            tracknumber   : integer (8)
            duration      : integer (245) - duration in seconds
            year          : integer (1998)
            genre         : string (Rock)
            album         : string (Pulse)
            artist        : string (Muse)
            title         : string (American Pie)
            rating        : string (3) - single character between 0 and 5
            lyrics        : string (On a dark desert highway...)
            playcount     : integer (2) - number of times this item has been played
            lastplayed    : string (%Y-%m-%d %h:%m:%s = 2009-04-05 23:16:04)
        
        Picture Values:
            title         : string (In the last summer-1)
            picturepath   : string (/home/username/pictures/img001.jpg)
            exif*         : string (See CPictureInfoTag::TranslateString in PictureInfoTag.cpp for valid strings)
        
        example:
          - self.list.getSelectedItem().setInfo('video', { 'Genre': 'Comedy' })
        """

    def setLabel(*args):
        """setLabel(label) -- Sets the listitem's label.
        
        label          : string or unicode - text string.
        
        example:
          - self.list.getSelectedItem().setLabel('Casino Royale')
        """

    def setLabel2(*args):
        """setLabel2(label2) -- Sets the listitem's second label.
        
        label2         : string or unicode - text string.
        
        example:
          - self.list.getSelectedItem().setLabel2('[pg-13]')
        """

    def setPath(*args):
        """setPath(path) -- Sets the listitem's path.
        
        path           : string or unicode - path, activated when item is clicked.
        
        *Note, You can use the above as keywords for arguments.
        
        example:
          - self.list.getSelectedItem().setPath(path='ActivateWindow(Weather)')
        """

    def setProperty(*args):
        """setProperty(key, value) -- Sets a listitem property, similar to an infolabel.
        
        key            : string - property name.
        value          : string or unicode - value of property.
        
        *Note, Key is NOT case sensitive.
               You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
         Some of these are treated internally by XBMC, such as the 'StartOffset' property, which is
         the offset in seconds at which to start playback of an item.  Others may be used in the skin
         to add extra information, such as 'WatchedCount' for tvshow items
        
        example:
          - self.list.getSelectedItem().setProperty('AspectRatio', '1.85 : 1')
          - self.list.getSelectedItem().setProperty('StartOffset', '256.4')
        """

    def setThumbnailImage(*args):
        """setThumbnailImage(thumb) -- Sets the listitem's thumbnail image.
        
        thumb           : string or unicode - image filename.
        
        example:
          - self.list.getSelectedItem().setThumbnailImage('emailread.png')
        """



class Window:
    """Window class.
    
    Window(self[, int windowId) -- Create a new Window to draw on.
                                   Specify an id to use an existing window.
    
    Throws: ValueError, if supplied window Id does not exist.
            Exception, if more then 200 windows are created.
    
    Deleting this window will activate the old window that was active
    and resets (not delete) all controls that are associated with this window.
    """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def addControl(*args):
        """addControl(self, Control) -- Add a Control to this window.
        
        Throws: TypeError, if supplied argument is not a Control type
                ReferenceError, if control is already used in another window
                RuntimeError, should not happen :-)
        
        The next controls can be added to a window atm
        
          -ControlLabel
          -ControlFadeLabel
          -ControlTextBox
          -ControlButton
          -ControlCheckMark
          -ControlList
          -ControlGroup
          -ControlImage
          -ControlRadioButton
          -ControlProgress
        """

    def clearProperties(*args):
        """clearProperties() -- Clears all window properties.
        
        example:
          - win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
          - win.clearProperties()
        """

    def clearProperty(*args):
        """clearProperty(key) -- Clears the specific window property.
        
        key            : string - property name.
        
        *Note, key is NOT case sensitive. Equivalent to setProperty(key,'')
               You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
          - win.clearProperty('Category')
        """

    def close(*args):
        """close(self) -- Closes this window.
        
        Closes this window by activating the old window.
        The window is not deleted with this method.
        """

    def doModal(*args):
        """doModal(self) -- Display this window until close() is called.
        """

    def getControl(*args):
        """getControl(self, int controlId) -- Get's the control from this window.
        
        Throws: Exception, if Control doesn't exist
        
        controlId doesn't have to be a python control, it can be a control id
        from a xbmc window too (you can find id's in the xml files
        
        Note, not python controls are not completely usable yet
        You can only use the Control functions
        """

    def getFocus(*args):
        """getFocus(self, Control) -- returns the control which is focused.
        Throws: SystemError, on Internal error
                RuntimeError, if no control has focus
        
        """

    def getFocusId(*args):
        """getFocusId(self, int) -- returns the id of the control which is focused.
        Throws: SystemError, on Internal error
                RuntimeError, if no control has focus
        
        """

    def getHeight(*args):
        """getHeight(self) -- Returns the height of this screen.
        """

    def getProperty(*args):
        """getProperty(key) -- Returns a window property as a string, similar to an infolabel.
        
        key            : string - property name.
        
        *Note, key is NOT case sensitive.
               You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
          - category = win.getProperty('Category')
        """

    def getResolution(*args):
        """getResolution(self) -- Returns the resolution of the screen. The returned value is one of the following:
           0 - 1080i      (1920x1080)
           1 - 720p       (1280x720)
           2 - 480p 4:3   (720x480)
           3 - 480p 16:9  (720x480)
           4 - NTSC 4:3   (720x480)
           5 - NTSC 16:9  (720x480)
           6 - PAL 4:3    (720x576)
           7 - PAL 16:9   (720x576)
           8 - PAL60 4:3  (720x480)
           9 - PAL60 16:9 (720x480)
        """

    def getWidth(*args):
        """getWidth(self) -- Returns the width of this screen.
        """

    def onAction(*args):
        """onAction(self, Action action) -- onAction method.
        
        This method will recieve all actions that the main program will send
        to this window.
        By default, only the PREVIOUS_MENU action is handled.
        Overwrite this method to let your script handle all actions.
        Don't forget to capture ACTION_PREVIOUS_MENU, else the user can't close this window.
        """

    def onClick(*args):
        """onClick(self, Control control) -- onClick method.
        
        This method will recieve all click events that the main program will send
        to this window.
        """

    def onFocus(*args):
        """onFocus(self, Control control) -- onFocus method.
        
        This method will recieve all focus events that the main program will send
        to this window.
        """

    def onInit(*args):
        """onInit(self) -- onInit method.
        
        This method will be called to initialize the window
        """

    def removeControl(*args):
        """removeControl(self, Control) -- Removes the control from this window.
        
        Throws: TypeError, if supplied argument is not a Control type
                RuntimeError, if control is not added to this window
        
        This will not delete the control. It is only removed from the window.
        """

    def setCoordinateResolution(*args):
        """setCoordinateResolution(self, int resolution) -- Sets the resolution
        that the coordinates of all controls are defined in.  Allows XBMC
        to scale control positions and width/heights to whatever resolution
        XBMC is currently using.
         resolution is one of the following:
           0 - 1080i      (1920x1080)
           1 - 720p       (1280x720)
           2 - 480p 4:3   (720x480)
           3 - 480p 16:9  (720x480)
           4 - NTSC 4:3   (720x480)
           5 - NTSC 16:9  (720x480)
           6 - PAL 4:3    (720x576)
           7 - PAL 16:9   (720x576)
           8 - PAL60 4:3  (720x480)
           9 - PAL60 16:9 (720x480)
        """

    def setFocus(*args):
        """setFocus(self, Control) -- Give the supplied control focus.
        Throws: TypeError, if supplied argument is not a Control type
                SystemError, on Internal error
                RuntimeError, if control is not added to a window
        
        """

    def setFocusId(*args):
        """setFocusId(self, int) -- Gives the control with the supplied focus.
        Throws: 
                SystemError, on Internal error
                RuntimeError, if control is not added to a window
        
        """

    def setProperty(*args):
        """setProperty(key, value) -- Sets a window property, similar to an infolabel.
        
        key            : string - property name.
        value          : string or unicode - value of property.
        
        *Note, key is NOT case sensitive. Setting value to an empty string is equivalent to clearProperty(key)
               You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
          - win.setProperty('Category', 'Newest')
        """

    def show(*args):
        """show(self) -- Show this window.
        
        Shows this window by activating it, calling close() after it wil activate the
        current window again.
        Note, if your script ends this window will be closed to. To show it forever, 
        make a loop at the end of your script ar use doModal() instead
        """



class WindowDialog:
    """WindowDialog class.
    """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def addControl(*args):
        """addControl(self, Control) -- Add a Control to this window.
        
        Throws: TypeError, if supplied argument is not a Control type
                ReferenceError, if control is already used in another window
                RuntimeError, should not happen :-)
        
        The next controls can be added to a window atm
        
          -ControlLabel
          -ControlFadeLabel
          -ControlTextBox
          -ControlButton
          -ControlCheckMark
          -ControlList
          -ControlGroup
          -ControlImage
          -ControlRadioButton
          -ControlProgress
        """

    def clearProperties(*args):
        """clearProperties() -- Clears all window properties.
        
        example:
          - win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
          - win.clearProperties()
        """

    def clearProperty(*args):
        """clearProperty(key) -- Clears the specific window property.
        
        key            : string - property name.
        
        *Note, key is NOT case sensitive. Equivalent to setProperty(key,'')
               You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
          - win.clearProperty('Category')
        """

    def close(*args):
        """close(self) -- Closes this window.
        
        Closes this window by activating the old window.
        The window is not deleted with this method.
        """

    def doModal(*args):
        """doModal(self) -- Display this window until close() is called.
        """

    def getControl(*args):
        """getControl(self, int controlId) -- Get's the control from this window.
        
        Throws: Exception, if Control doesn't exist
        
        controlId doesn't have to be a python control, it can be a control id
        from a xbmc window too (you can find id's in the xml files
        
        Note, not python controls are not completely usable yet
        You can only use the Control functions
        """

    def getFocus(*args):
        """getFocus(self, Control) -- returns the control which is focused.
        Throws: SystemError, on Internal error
                RuntimeError, if no control has focus
        
        """

    def getFocusId(*args):
        """getFocusId(self, int) -- returns the id of the control which is focused.
        Throws: SystemError, on Internal error
                RuntimeError, if no control has focus
        
        """

    def getHeight(*args):
        """getHeight(self) -- Returns the height of this screen.
        """

    def getProperty(*args):
        """getProperty(key) -- Returns a window property as a string, similar to an infolabel.
        
        key            : string - property name.
        
        *Note, key is NOT case sensitive.
               You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
          - category = win.getProperty('Category')
        """

    def getResolution(*args):
        """getResolution(self) -- Returns the resolution of the screen. The returned value is one of the following:
           0 - 1080i      (1920x1080)
           1 - 720p       (1280x720)
           2 - 480p 4:3   (720x480)
           3 - 480p 16:9  (720x480)
           4 - NTSC 4:3   (720x480)
           5 - NTSC 16:9  (720x480)
           6 - PAL 4:3    (720x576)
           7 - PAL 16:9   (720x576)
           8 - PAL60 4:3  (720x480)
           9 - PAL60 16:9 (720x480)
        """

    def getWidth(*args):
        """getWidth(self) -- Returns the width of this screen.
        """

    def onAction(*args):
        """onAction(self, Action action) -- onAction method.
        
        This method will recieve all actions that the main program will send
        to this window.
        By default, only the PREVIOUS_MENU action is handled.
        Overwrite this method to let your script handle all actions.
        Don't forget to capture ACTION_PREVIOUS_MENU, else the user can't close this window.
        """

    def onClick(*args):
        """onClick(self, Control control) -- onClick method.
        
        This method will recieve all click events that the main program will send
        to this window.
        """

    def onFocus(*args):
        """onFocus(self, Control control) -- onFocus method.
        
        This method will recieve all focus events that the main program will send
        to this window.
        """

    def onInit(*args):
        """onInit(self) -- onInit method.
        
        This method will be called to initialize the window
        """

    def removeControl(*args):
        """removeControl(self, Control) -- Removes the control from this window.
        
        Throws: TypeError, if supplied argument is not a Control type
                RuntimeError, if control is not added to this window
        
        This will not delete the control. It is only removed from the window.
        """

    def setCoordinateResolution(*args):
        """setCoordinateResolution(self, int resolution) -- Sets the resolution
        that the coordinates of all controls are defined in.  Allows XBMC
        to scale control positions and width/heights to whatever resolution
        XBMC is currently using.
         resolution is one of the following:
           0 - 1080i      (1920x1080)
           1 - 720p       (1280x720)
           2 - 480p 4:3   (720x480)
           3 - 480p 16:9  (720x480)
           4 - NTSC 4:3   (720x480)
           5 - NTSC 16:9  (720x480)
           6 - PAL 4:3    (720x576)
           7 - PAL 16:9   (720x576)
           8 - PAL60 4:3  (720x480)
           9 - PAL60 16:9 (720x480)
        """

    def setFocus(*args):
        """setFocus(self, Control) -- Give the supplied control focus.
        Throws: TypeError, if supplied argument is not a Control type
                SystemError, on Internal error
                RuntimeError, if control is not added to a window
        
        """

    def setFocusId(*args):
        """setFocusId(self, int) -- Gives the control with the supplied focus.
        Throws: 
                SystemError, on Internal error
                RuntimeError, if control is not added to a window
        
        """

    def setProperty(*args):
        """setProperty(key, value) -- Sets a window property, similar to an infolabel.
        
        key            : string - property name.
        value          : string or unicode - value of property.
        
        *Note, key is NOT case sensitive. Setting value to an empty string is equivalent to clearProperty(key)
               You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
          - win.setProperty('Category', 'Newest')
        """

    def show(*args):
        """show(self) -- Show this window.
        
        Shows this window by activating it, calling close() after it wil activate the
        current window again.
        Note, if your script ends this window will be closed to. To show it forever, 
        make a loop at the end of your script ar use doModal() instead
        """



class WindowXML:
    """WindowXML class.
    
    WindowXML(self, xmlFilename, scriptPath[, defaultSkin, defaultRes]) -- Create a new WindowXML script.
    
    xmlFilename     : string - the name of the xml file to look for.
    scriptPath      : string - path to script. used to fallback to if the xml doesn't exist in the current skin. (eg os.getcwd())
    defaultSkin     : [opt] string - name of the folder in the skins path to look in for the xml. (default='Default')
    defaultRes      : [opt] string - default skins resolution. (default='720p')
    
    *Note, skin folder structure is eg(resources/skins/Default/720p)
    
    example:
     - ui = GUI('script-Lyrics-main.xml', os.getcwd(), 'LCARS', 'PAL')
       ui.doModal()
       del ui
    """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def addControl(*args):
        """addControl(self, Control) -- Add a Control to this window.
        
        Throws: TypeError, if supplied argument is not a Control type
                ReferenceError, if control is already used in another window
                RuntimeError, should not happen :-)
        
        The next controls can be added to a window atm
        
          -ControlLabel
          -ControlFadeLabel
          -ControlTextBox
          -ControlButton
          -ControlCheckMark
          -ControlList
          -ControlGroup
          -ControlImage
          -ControlRadioButton
          -ControlProgress
        """

    def addItem(*args):
        """addItem(item[, position]) -- Add a new item to this Window List.
        
        item            : string, unicode or ListItem - item to add.
        position        : [opt] integer - position of item to add. (NO Int = Adds to bottom,0 adds to top, 1 adds to one below from top,-1 adds to one above from bottom etc etc )
                                        - If integer positions are greater than list size, negative positions will add to top of list, positive positions will add to bottom of list
        example:
          - self.addItem('Reboot XBMC', 0)
        """

    def clearList(*args):
        """clearList() -- Clear the Window List.
        
        example:
          - self.clearList()
        """

    def clearProperties(*args):
        """clearProperties() -- Clears all window properties.
        
        example:
          - win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
          - win.clearProperties()
        """

    def clearProperty(*args):
        """clearProperty(key) -- Clears the specific window property.
        
        key            : string - property name.
        
        *Note, key is NOT case sensitive. Equivalent to setProperty(key,'')
               You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
          - win.clearProperty('Category')
        """

    def close(*args):
        """close(self) -- Closes this window.
        
        Closes this window by activating the old window.
        The window is not deleted with this method.
        """

    def doModal(*args):
        """doModal(self) -- Display this window until close() is called.
        """

    def getControl(*args):
        """getControl(self, int controlId) -- Get's the control from this window.
        
        Throws: Exception, if Control doesn't exist
        
        controlId doesn't have to be a python control, it can be a control id
        from a xbmc window too (you can find id's in the xml files
        
        Note, not python controls are not completely usable yet
        You can only use the Control functions
        """

    def getCurrentListPosition(*args):
        """getCurrentListPosition() -- Gets the current position in the Window List.
        
        example:
          - pos = self.getCurrentListPosition()
        """

    def getFocus(*args):
        """getFocus(self, Control) -- returns the control which is focused.
        Throws: SystemError, on Internal error
                RuntimeError, if no control has focus
        
        """

    def getFocusId(*args):
        """getFocusId(self, int) -- returns the id of the control which is focused.
        Throws: SystemError, on Internal error
                RuntimeError, if no control has focus
        
        """

    def getHeight(*args):
        """getHeight(self) -- Returns the height of this screen.
        """

    def getListItem(*args):
        """getListItem(position) -- Returns a given ListItem in this Window List.
        
        position        : integer - position of item to return.
        
        example:
          - listitem = self.getListItem(6)
        """

    def getListSize(*args):
        """getListSize() -- Returns the number of items in this Window List.
        
        example:
          - listSize = self.getListSize()
        """

    def getProperty(*args):
        """getProperty(key) -- Returns a window property as a string, similar to an infolabel.
        
        key            : string - property name.
        
        *Note, key is NOT case sensitive.
               You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
          - category = win.getProperty('Category')
        """

    def getResolution(*args):
        """getResolution(self) -- Returns the resolution of the screen. The returned value is one of the following:
           0 - 1080i      (1920x1080)
           1 - 720p       (1280x720)
           2 - 480p 4:3   (720x480)
           3 - 480p 16:9  (720x480)
           4 - NTSC 4:3   (720x480)
           5 - NTSC 16:9  (720x480)
           6 - PAL 4:3    (720x576)
           7 - PAL 16:9   (720x576)
           8 - PAL60 4:3  (720x480)
           9 - PAL60 16:9 (720x480)
        """

    def getWidth(*args):
        """getWidth(self) -- Returns the width of this screen.
        """

    def onAction(*args):
        """onAction(self, Action action) -- onAction method.
        
        This method will recieve all actions that the main program will send
        to this window.
        By default, only the PREVIOUS_MENU action is handled.
        Overwrite this method to let your script handle all actions.
        Don't forget to capture ACTION_PREVIOUS_MENU, else the user can't close this window.
        """

    def onClick(*args):
        """onClick(self, Control control) -- onClick method.
        
        This method will recieve all click events that the main program will send
        to this window.
        """

    def onFocus(*args):
        """onFocus(self, Control control) -- onFocus method.
        
        This method will recieve all focus events that the main program will send
        to this window.
        """

    def onInit(*args):
        """onInit(self) -- onInit method.
        
        This method will be called to initialize the window
        """

    def removeControl(*args):
        """removeControl(self, Control) -- Removes the control from this window.
        
        Throws: TypeError, if supplied argument is not a Control type
                RuntimeError, if control is not added to this window
        
        This will not delete the control. It is only removed from the window.
        """

    def removeItem(*args):
        """removeItem(position) -- Removes a specified item based on position, from the Window List.
        
        position        : integer - position of item to remove.
        
        example:
          - self.removeItem(5)
        """

    def setCoordinateResolution(*args):
        """setCoordinateResolution(self, int resolution) -- Sets the resolution
        that the coordinates of all controls are defined in.  Allows XBMC
        to scale control positions and width/heights to whatever resolution
        XBMC is currently using.
         resolution is one of the following:
           0 - 1080i      (1920x1080)
           1 - 720p       (1280x720)
           2 - 480p 4:3   (720x480)
           3 - 480p 16:9  (720x480)
           4 - NTSC 4:3   (720x480)
           5 - NTSC 16:9  (720x480)
           6 - PAL 4:3    (720x576)
           7 - PAL 16:9   (720x576)
           8 - PAL60 4:3  (720x480)
           9 - PAL60 16:9 (720x480)
        """

    def setCurrentListPosition(*args):
        """setCurrentListPosition(position) -- Set the current position in the Window List.
        
        position        : integer - position of item to set.
        
        example:
          - self.setCurrentListPosition(5)
        """

    def setFocus(*args):
        """setFocus(self, Control) -- Give the supplied control focus.
        Throws: TypeError, if supplied argument is not a Control type
                SystemError, on Internal error
                RuntimeError, if control is not added to a window
        
        """

    def setFocusId(*args):
        """setFocusId(self, int) -- Gives the control with the supplied focus.
        Throws: 
                SystemError, on Internal error
                RuntimeError, if control is not added to a window
        
        """

    def setProperty(*args):
        """setProperty(key, value) -- Sets a container property, similar to an infolabel.
        
        key            : string - property name.
        value          : string or unicode - value of property.
        
        *Note, Key is NOT case sensitive.
               You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - self.setProperty('Category', 'Newest')
        """

    def show(*args):
        """show(self) -- Show this window.
        
        Shows this window by activating it, calling close() after it wil activate the
        current window again.
        Note, if your script ends this window will be closed to. To show it forever, 
        make a loop at the end of your script ar use doModal() instead
        """



class WindowXMLDialog:
    """WindowXMLDialog class.
    
    WindowXMLDialog(self, xmlFilename, scriptPath[, defaultSkin, defaultRes]) -- Create a new WindowXMLDialog script.
    
    xmlFilename     : string - the name of the xml file to look for.
    scriptPath      : string - path to script. used to fallback to if the xml doesn't exist in the current skin. (eg os.getcwd())
    defaultSkin     : [opt] string - name of the folder in the skins path to look in for the xml. (default='Default')
    defaultRes      : [opt] string - default skins resolution. (default='720p')
    
    *Note, skin folder structure is eg(resources/skins/Default/720p)
    
    example:
     - ui = GUI('script-Lyrics-main.xml', os.getcwd(), 'LCARS', 'PAL')
       ui.doModal()
       del ui
    """

    def __delattr__(*args):
        """x.__delattr__('name') <==> del x.name
        """

    def __format__(*args):
        """default object formatter
        """

    def __getattribute__(*args):
        """x.__getattribute__('name') <==> x.name
        """

    def __hash__(*args):
        """x.__hash__() <==> hash(x)
        """

    def __init__(*args):
        """x.__init__(...) initializes x; see x.__class__.__doc__ for signature
        """

    def __new__(*args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T
        """

    def __reduce__(*args):
        """helper for pickle
        """

    def __reduce_ex__(*args):
        """helper for pickle
        """

    def __repr__(*args):
        """x.__repr__() <==> repr(x)
        """

    def __setattr__(*args):
        """x.__setattr__('name', value) <==> x.name = value
        """

    def __sizeof__(*args):
        """__sizeof__() -> size of object in memory, in bytes
        """

    def __str__(*args):
        """x.__str__() <==> str(x)
        """

    def __subclasshook__(*args):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """

    def addControl(*args):
        """addControl(self, Control) -- Add a Control to this window.
        
        Throws: TypeError, if supplied argument is not a Control type
                ReferenceError, if control is already used in another window
                RuntimeError, should not happen :-)
        
        The next controls can be added to a window atm
        
          -ControlLabel
          -ControlFadeLabel
          -ControlTextBox
          -ControlButton
          -ControlCheckMark
          -ControlList
          -ControlGroup
          -ControlImage
          -ControlRadioButton
          -ControlProgress
        """

    def addItem(*args):
        """addItem(item[, position]) -- Add a new item to this Window List.
        
        item            : string, unicode or ListItem - item to add.
        position        : [opt] integer - position of item to add. (NO Int = Adds to bottom,0 adds to top, 1 adds to one below from top,-1 adds to one above from bottom etc etc )
                                        - If integer positions are greater than list size, negative positions will add to top of list, positive positions will add to bottom of list
        example:
          - self.addItem('Reboot XBMC', 0)
        """

    def clearList(*args):
        """clearList() -- Clear the Window List.
        
        example:
          - self.clearList()
        """

    def clearProperties(*args):
        """clearProperties() -- Clears all window properties.
        
        example:
          - win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
          - win.clearProperties()
        """

    def clearProperty(*args):
        """clearProperty(key) -- Clears the specific window property.
        
        key            : string - property name.
        
        *Note, key is NOT case sensitive. Equivalent to setProperty(key,'')
               You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
          - win.clearProperty('Category')
        """

    def close(*args):
        """close(self) -- Closes this window.
        
        Closes this window by activating the old window.
        The window is not deleted with this method.
        """

    def doModal(*args):
        """doModal(self) -- Display this window until close() is called.
        """

    def getControl(*args):
        """getControl(self, int controlId) -- Get's the control from this window.
        
        Throws: Exception, if Control doesn't exist
        
        controlId doesn't have to be a python control, it can be a control id
        from a xbmc window too (you can find id's in the xml files
        
        Note, not python controls are not completely usable yet
        You can only use the Control functions
        """

    def getCurrentListPosition(*args):
        """getCurrentListPosition() -- Gets the current position in the Window List.
        
        example:
          - pos = self.getCurrentListPosition()
        """

    def getFocus(*args):
        """getFocus(self, Control) -- returns the control which is focused.
        Throws: SystemError, on Internal error
                RuntimeError, if no control has focus
        
        """

    def getFocusId(*args):
        """getFocusId(self, int) -- returns the id of the control which is focused.
        Throws: SystemError, on Internal error
                RuntimeError, if no control has focus
        
        """

    def getHeight(*args):
        """getHeight(self) -- Returns the height of this screen.
        """

    def getListItem(*args):
        """getListItem(position) -- Returns a given ListItem in this Window List.
        
        position        : integer - position of item to return.
        
        example:
          - listitem = self.getListItem(6)
        """

    def getListSize(*args):
        """getListSize() -- Returns the number of items in this Window List.
        
        example:
          - listSize = self.getListSize()
        """

    def getProperty(*args):
        """getProperty(key) -- Returns a window property as a string, similar to an infolabel.
        
        key            : string - property name.
        
        *Note, key is NOT case sensitive.
               You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
          - category = win.getProperty('Category')
        """

    def getResolution(*args):
        """getResolution(self) -- Returns the resolution of the screen. The returned value is one of the following:
           0 - 1080i      (1920x1080)
           1 - 720p       (1280x720)
           2 - 480p 4:3   (720x480)
           3 - 480p 16:9  (720x480)
           4 - NTSC 4:3   (720x480)
           5 - NTSC 16:9  (720x480)
           6 - PAL 4:3    (720x576)
           7 - PAL 16:9   (720x576)
           8 - PAL60 4:3  (720x480)
           9 - PAL60 16:9 (720x480)
        """

    def getWidth(*args):
        """getWidth(self) -- Returns the width of this screen.
        """

    def onAction(*args):
        """onAction(self, Action action) -- onAction method.
        
        This method will recieve all actions that the main program will send
        to this window.
        By default, only the PREVIOUS_MENU action is handled.
        Overwrite this method to let your script handle all actions.
        Don't forget to capture ACTION_PREVIOUS_MENU, else the user can't close this window.
        """

    def onClick(*args):
        """onClick(self, Control control) -- onClick method.
        
        This method will recieve all click events that the main program will send
        to this window.
        """

    def onFocus(*args):
        """onFocus(self, Control control) -- onFocus method.
        
        This method will recieve all focus events that the main program will send
        to this window.
        """

    def onInit(*args):
        """onInit(self) -- onInit method.
        
        This method will be called to initialize the window
        """

    def removeControl(*args):
        """removeControl(self, Control) -- Removes the control from this window.
        
        Throws: TypeError, if supplied argument is not a Control type
                RuntimeError, if control is not added to this window
        
        This will not delete the control. It is only removed from the window.
        """

    def removeItem(*args):
        """removeItem(position) -- Removes a specified item based on position, from the Window List.
        
        position        : integer - position of item to remove.
        
        example:
          - self.removeItem(5)
        """

    def setCoordinateResolution(*args):
        """setCoordinateResolution(self, int resolution) -- Sets the resolution
        that the coordinates of all controls are defined in.  Allows XBMC
        to scale control positions and width/heights to whatever resolution
        XBMC is currently using.
         resolution is one of the following:
           0 - 1080i      (1920x1080)
           1 - 720p       (1280x720)
           2 - 480p 4:3   (720x480)
           3 - 480p 16:9  (720x480)
           4 - NTSC 4:3   (720x480)
           5 - NTSC 16:9  (720x480)
           6 - PAL 4:3    (720x576)
           7 - PAL 16:9   (720x576)
           8 - PAL60 4:3  (720x480)
           9 - PAL60 16:9 (720x480)
        """

    def setCurrentListPosition(*args):
        """setCurrentListPosition(position) -- Set the current position in the Window List.
        
        position        : integer - position of item to set.
        
        example:
          - self.setCurrentListPosition(5)
        """

    def setFocus(*args):
        """setFocus(self, Control) -- Give the supplied control focus.
        Throws: TypeError, if supplied argument is not a Control type
                SystemError, on Internal error
                RuntimeError, if control is not added to a window
        
        """

    def setFocusId(*args):
        """setFocusId(self, int) -- Gives the control with the supplied focus.
        Throws: 
                SystemError, on Internal error
                RuntimeError, if control is not added to a window
        
        """

    def setProperty(*args):
        """setProperty(key, value) -- Sets a container property, similar to an infolabel.
        
        key            : string - property name.
        value          : string or unicode - value of property.
        
        *Note, Key is NOT case sensitive.
               You can use the above as keywords for arguments and skip certain optional arguments.
               Once you use a keyword, all following arguments require the keyword.
        
        example:
          - self.setProperty('Category', 'Newest')
        """

    def show(*args):
        """show(self) -- Show this window.
        
        Shows this window by activating it, calling close() after it wil activate the
        current window again.
        Note, if your script ends this window will be closed to. To show it forever, 
        make a loop at the end of your script ar use doModal() instead
        """



__author__ = str
__credits__ = str
__date__ = str
__platform__ = str
__version__ = str
def getCurrentWindowDialogId(*args):
    """getCurrentWindowDialogId() -- Returns the id for the current 'active' dialog as an integer.
    
    example:
      - wid = xbmcgui.getCurrentWindowDialogId()
    """

def getCurrentWindowId(*args):
    """getCurrentWindowId() -- Returns the id for the current 'active' window as an integer.
    
    example:
      - wid = xbmcgui.getCurrentWindowId()
    """

def lock(*args):
    """lock() -- Lock the gui until xbmcgui.unlock() is called.
    
    *Note, This will improve performance when doing a lot of gui manipulation at once.
           The main program (xbmc itself) will freeze until xbmcgui.unlock() is called.
    
    example:
      - xbmcgui.lock()
    """

def unlock(*args):
    """unlock() -- Unlock the gui from a lock() call.
    
    example:
      - xbmcgui.unlock()
    """


########NEW FILE########
__FILENAME__ = xbmcplugin
SORT_METHOD_ALBUM = int
SORT_METHOD_ALBUM_IGNORE_THE = int
SORT_METHOD_ARTIST = int
SORT_METHOD_ARTIST_IGNORE_THE = int
SORT_METHOD_BITRATE = int
SORT_METHOD_DATE = int
SORT_METHOD_DRIVE_TYPE = int
SORT_METHOD_DURATION = int
SORT_METHOD_EPISODE = int
SORT_METHOD_FILE = int
SORT_METHOD_GENRE = int
SORT_METHOD_LABEL = int
SORT_METHOD_LABEL_IGNORE_THE = int
SORT_METHOD_LISTENERS = int
SORT_METHOD_MPAA_RATING = int
SORT_METHOD_NONE = int
SORT_METHOD_PLAYLIST_ORDER = int
SORT_METHOD_PRODUCTIONCODE = int
SORT_METHOD_PROGRAM_COUNT = int
SORT_METHOD_SIZE = int
SORT_METHOD_SONG_RATING = int
SORT_METHOD_STUDIO = int
SORT_METHOD_STUDIO_IGNORE_THE = int
SORT_METHOD_TITLE = int
SORT_METHOD_TITLE_IGNORE_THE = int
SORT_METHOD_TRACKNUM = int
SORT_METHOD_UNSORTED = int
SORT_METHOD_VIDEO_RATING = int
SORT_METHOD_VIDEO_RUNTIME = int
SORT_METHOD_VIDEO_TITLE = int
SORT_METHOD_VIDEO_YEAR = int
__author__ = str
__credits__ = str
__date__ = str
__platform__ = str
__version__ = str
def addDirectoryItem(*args):
    """addDirectoryItem(handle, url, listitem [,isFolder, totalItems]) -- Callback function to pass directory contents back to XBMC.
     - Returns a bool for successful completion.
    
    handle      : integer - handle the plugin was started with.
    url         : string - url of the entry. would be plugin:// for another virtual directory
    listitem    : ListItem - item to add.
    isFolder    : [opt] bool - True=folder / False=not a folder(default).
    totalItems  : [opt] integer - total number of items that will be passed.(used for progressbar)
    
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
    
    example:
      - if not xbmcplugin.addDirectoryItem(int(sys.argv[1]), 'F:\\Trailers\\300.mov', listitem, totalItems=50): break
    """

def addDirectoryItems(*args):
    """addDirectoryItems(handle, items [,totalItems]) -- Callback function to pass directory contents back to XBMC as a list.
     - Returns a bool for successful completion.
    
    handle      : integer - handle the plugin was started with.
    items       : List - list of (url, listitem[, isFolder]) as a tuple to add.
    totalItems  : [opt] integer - total number of items that will be passed.(used for progressbar)
    
    *Note, You can use the above as keywords for arguments.
    
           Large lists benefit over using the standard addDirectoryItem()
           You may call this more than once to add items in chunks
    
    example:
      - if not xbmcplugin.addDirectoryItems(int(sys.argv[1]), [(url, listitem, False,)]: raise
    """

def addSortMethod(*args):
    """addSortMethod(handle, sortMethod, label2) -- Adds a sorting method for the media list.
    
    handle      : integer - handle the plugin was started with.
    sortMethod  : integer - number for sortmethod see FileItem.h.
    label2Mask  : [opt] string - the label mask to use for the second label.  Defaults to '%D'
                  applies to: SORT_METHOD_NONE, SORT_METHOD_UNSORTED, SORT_METHOD_VIDEO_TITLE,
                              SORT_METHOD_TRACKNUM, SORT_METHOD_FILE, SORT_METHOD_TITLE
                              SORT_METHOD_TITLE_IGNORE_THE, SORT_METHOD_LABEL
                              SORT_METHOD_LABEL_IGNORE_THE
    
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
    
    example:
      - xbmcplugin.addSortMethod(int(sys.argv[1]), xbmcplugin.SORT_METHOD_TITLE)
    """

def endOfDirectory(*args):
    """endOfDirectory(handle[, succeeded, updateListing, cacheToDisc]) -- Callback function to tell XBMC that the end of the directory listing in a virtualPythonFolder module is reached.
    
    handle           : integer - handle the plugin was started with.
    succeeded        : [opt] bool - True=script completed successfully(Default)/False=Script did not.
    updateListing    : [opt] bool - True=this folder should update the current listing/False=Folder is a subfolder(Default).
    cacheToDisc      : [opt] bool - True=Folder will cache if extended time(default)/False=this folder will never cache to disc.
    
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
    
    example:
      - xbmcplugin.endOfDirectory(int(sys.argv[1]), cacheToDisc=False)
    """

def getSetting(*args):
    """getSetting(handle, id) -- Returns the value of a setting as a string.
    
    handle    : integer - handle the plugin was started with.
    id        : string - id of the setting that the module needs to access.
    
    *Note, You can use the above as a keyword.
    
    example:
      - apikey = xbmcplugin.getSetting(int(sys.argv[1]), 'apikey')
    """

def setContent(*args):
    """setContent(handle, content) -- Sets the plugins content.
    
    handle      : integer - handle the plugin was started with.
    content     : string - content type (eg. movies)
    
    *Note, You can use the above as keywords for arguments.
           content: files, songs, artists, albums, movies, tvshows, episodes, musicvideos
    
    example:
      - xbmcplugin.setContent(int(sys.argv[1]), 'movies')
    """

def setPluginCategory(*args):
    """setPluginCategory(handle, category) -- Sets the plugins name for skins to display.
    
    handle      : integer - handle the plugin was started with.
    category    : string or unicode - plugins sub category.
    
    *Note, You can use the above as keywords for arguments.
    
    example:
      - xbmcplugin.setPluginCategory(int(sys.argv[1]), 'Comedy')
    """

def setPluginFanart(*args):
    """setPluginFanart(handle, image, color1, color2, color3) -- Sets the plugins fanart and color for skins to display.
    
    handle      : integer - handle the plugin was started with.
    image       : [opt] string - path to fanart image.
    color1      : [opt] hexstring - color1. (e.g. '0xFFFFFFFF')
    color2      : [opt] hexstring - color2. (e.g. '0xFFFF3300')
    color3      : [opt] hexstring - color3. (e.g. '0xFF000000')
    
    *Note, You can use the above as keywords for arguments.
    
    example:
      - xbmcplugin.setPluginFanart(int(sys.argv[1]), 'special://home/addons/plugins/video/Apple movie trailers II/fanart.png', color2='0xFFFF3300')
    """

def setProperty(*args):
    """setProperty(handle, key, value) -- Sets a container property for this plugin.
    
    handle      : integer - handle the plugin was started with.
    key         : string - property name.
    value       : string or unicode - value of property.
    
    *Note, Key is NOT case sensitive.
           You can use the above as keywords for arguments.
    
    example:
      - xbmcplugin.setProperty(int(sys.argv[1]), 'Emulator', 'M.A.M.E.')
    """

def setResolvedUrl(*args):
    """setResolvedUrl(handle, succeeded, listitem) -- Callback function to tell XBMC that the file plugin has been resolved to a url
    
    handle           : integer - handle the plugin was started with.
    succeeded        : bool - True=script completed successfully/False=Script did not.
    listitem         : ListItem - item the file plugin resolved to for playback.
    
    *Note, You can use the above as keywords for arguments and skip certain optional arguments.
           Once you use a keyword, all following arguments require the keyword.
    
    example:
      - xbmcplugin.setResolvedUrl(int(sys.argv[1]), True, listitem)
    """

def setSetting(*args):
    """setSetting(handle, id, value) -- Sets a plugin setting for the current running plugin.
    
    handle    : integer - handle the plugin was started with.
    id        : string - id of the setting that the module needs to access.
    value     : string or unicode - value of the setting.
    
    *Note, You can use the above as keywords for arguments.
    
    example:
      - xbmcplugin.setSetting(int(sys.argv[1]), id='username', value='teamxbmc')
    """


########NEW FILE########
__FILENAME__ = xbmcvfs
def copy(*args):
    """copy(source, destination) -- copy file to destination, returns true/false.
    
    source          : file to copy.
    destination     : destination file
    example:
      success = xbmcvfs.copy(source, destination)
    """

def delete(*args):
    """delete(file)
    
    file        : file to delete
    example:
      xbmcvfs.delete(file)
    """

def exists(*args):
    """exists(path)
    
    path        : file or folder
    example:
      success = xbmcvfs.exists(path)
    """

def rename(*args):
    """rename(file, newFileName)
    
    file        : file to reanamenewFileName : new filename, including the full path
    example:
      success = xbmcvfs.rename(file,newFileName)
    """


########NEW FILE########
