__FILENAME__ = APC20
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC20/APC20.py
import Live
from APC40.APC import APC
from _Framework.InputControlElement import *
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import EncoderElement
from _Framework.ButtonMatrixElement import ButtonMatrixElement
from _Framework.TransportComponent import TransportComponent
from APC40.APCSessionComponent import APCSessionComponent
from APC40.SpecialMixerComponent import SpecialMixerComponent
from ShiftableZoomingComponent import ShiftableZoomingComponent
from ShiftableSelectorComponent import ShiftableSelectorComponent
from SliderModesComponent import SliderModesComponent
from consts import *

class APC20(APC):
    """ Script for Akai's APC20 Controller """

    def __init__(self, c_instance):
        self._shift_modes = None
        APC.__init__(self, c_instance)

    def disconnect(self):
        self._shift_modes = None
        APC.disconnect(self)

    def _activate_combination_mode(self, track_offset, support_devices):
        APC._activate_combination_mode(self, track_offset, support_devices)
        if support_devices:
            self._shift_modes.invert_assignment()

    def _setup_session_control(self):
        is_momentary = True
        self._shift_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 81)
        self._session = APCSessionComponent(8, 5)
        self._session.name = 'Session_Control'
        self._matrix = ButtonMatrixElement()
        self._matrix.name = 'Button_Matrix'
        scene_launch_buttons = [ ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, index + 82) for index in range(5) ]
        track_stop_buttons = [ ButtonElement(is_momentary, MIDI_NOTE_TYPE, index, 52) for index in range(8) ]
        for index in range(len(scene_launch_buttons)):
            scene_launch_buttons[index].name = 'Scene_' + str(index) + '_Launch_Button'

        for index in range(len(track_stop_buttons)):
            track_stop_buttons[index].name = 'Track_' + str(index) + '_Stop_Button'

        self._session.set_stop_track_clip_buttons(tuple(track_stop_buttons))
        self._session.set_stop_track_clip_value(2)
        for scene_index in range(5):
            scene = self._session.scene(scene_index)
            scene.name = 'Scene_' + str(scene_index)
            button_row = []
            scene.set_launch_button(scene_launch_buttons[scene_index])
            scene.set_triggered_value(2)
            for track_index in range(8):
                button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, track_index, scene_index + 53)
                button.name = str(track_index) + '_Clip_' + str(scene_index) + '_Button'
                button_row.append(button)
                clip_slot = scene.clip_slot(track_index)
                clip_slot.name = str(track_index) + '_Clip_Slot_' + str(scene_index)
                clip_slot.set_triggered_to_play_value(2)
                clip_slot.set_triggered_to_record_value(4)
                clip_slot.set_stopped_value(5)
                clip_slot.set_started_value(1)
                clip_slot.set_recording_value(3)
                clip_slot.set_launch_button(button)

            self._matrix.add_row(tuple(button_row))

        self._session.selected_scene().name = 'Selected_Scene'
        self._session.selected_scene().set_launch_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 0, 64))
        self._session_zoom = ShiftableZoomingComponent(self._session, tuple(track_stop_buttons))
        self._session_zoom.name = 'Session_Overview'
        self._session_zoom.set_button_matrix(self._matrix)
        self._session_zoom.set_zoom_button(self._shift_button)
        self._session_zoom.set_scene_bank_buttons(tuple(scene_launch_buttons))
        self._session_zoom.set_stopped_value(3)
        self._session_zoom.set_selected_value(5)

    def _setup_mixer_control(self):
        is_momentary = True
        self._mixer = SpecialMixerComponent(8)
        self._mixer.name = 'Mixer'
        self._mixer.master_strip().name = 'Master_Channel_Strip'
        self._mixer.selected_strip().name = 'Selected_Channel_Strip'
        for track in range(8):
            strip = self._mixer.channel_strip(track)
            strip.name = 'Channel_Strip_' + str(track)
            solo_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, track, 49)
            mute_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, track, 50)
            solo_button.name = str(track) + '_Solo_Button'
            mute_button.name = str(track) + '_Mute_Button'
            strip.set_solo_button(solo_button)
            strip.set_mute_button(mute_button)
            strip.set_shift_button(self._shift_button)
            strip.set_invert_mute_feedback(True)

        master_volume_control = SliderElement(MIDI_CC_TYPE, 0, 14)
        prehear_control = EncoderElement(MIDI_CC_TYPE, 0, 47, Live.MidiMap.MapMode.relative_two_compliment)
        master_volume_control.name = 'Master_Volume_Control'
        prehear_control.name = 'Prehear_Volume_Control'
        self._mixer.set_prehear_volume_control(prehear_control)
        self._mixer.master_strip().set_volume_control(master_volume_control)

    def _setup_custom_components(self):
        is_momentary = True
        master_select_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 80)
        master_select_button.name = 'Master_Select_Button'
        select_buttons = []
        arm_buttons = []
        sliders = []
        for track in range(8):
            select_buttons.append(ButtonElement(is_momentary, MIDI_NOTE_TYPE, track, 51))
            arm_buttons.append(ButtonElement(is_momentary, MIDI_NOTE_TYPE, track, 48))
            sliders.append(SliderElement(MIDI_CC_TYPE, track, 7))
            select_buttons[-1].name = str(track) + '_Select_Button'
            arm_buttons[-1].name = str(track) + '_Arm_Button'
            sliders[-1].name = str(track) + '_Volume_Control'

        transport = TransportComponent()
        transport.name = 'Transport'
        slider_modes = SliderModesComponent(self._mixer, tuple(sliders))
        slider_modes.name = 'Slider_Modes'
        self._shift_modes = ShiftableSelectorComponent(tuple(select_buttons), master_select_button, tuple(arm_buttons), self._matrix, self._session, self._session_zoom, self._mixer, transport, slider_modes, self._send_introduction_message)
        self._shift_modes.name = 'Shift_Modes'
        self._shift_modes.set_mode_toggle(self._shift_button)

    def _product_model_id_byte(self):
        return 123
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC20/consts.py
MANUFACTURER_ID = 71
ABLETON_MODE = 65
NOTE_MODE = 67
########NEW FILE########
__FILENAME__ = ShiftableSelectorComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC20/ShiftableSelectorComponent.py
import Live
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from _Framework.ButtonElement import ButtonElement
from consts import *

class ShiftableSelectorComponent(ModeSelectorComponent):
    """ SelectorComponent that assigns buttons to functions based on the shift button """

    def __init__(self, select_buttons, master_button, arm_buttons, matrix, session, zooming, mixer, transport, slider_modes, mode_callback):
        raise len(select_buttons) == 8 or AssertionError
        raise len(arm_buttons) == 8 or AssertionError
        ModeSelectorComponent.__init__(self)
        self._toggle_pressed = False
        self._note_mode_active = False
        self._invert_assignment = False
        self._select_buttons = select_buttons
        self._master_button = master_button
        self._slider_modes = slider_modes
        self._arm_buttons = arm_buttons
        self._transport = transport
        self._session = session
        self._zooming = zooming
        self._matrix = matrix
        self._mixer = mixer
        self._mode_callback = mode_callback
        self._master_button.add_value_listener(self._master_value)

    def disconnect(self):
        ModeSelectorComponent.disconnect(self)
        self._master_button.remove_value_listener(self._master_value)
        self._select_buttons = None
        self._master_button = None
        self._slider_modes = None
        self._arm_buttons = None
        self._transport = None
        self._session = None
        self._zooming = None
        self._matrix = None
        self._mixer = None
        self._mode_callback = None

    def set_mode_toggle(self, button):
        ModeSelectorComponent.set_mode_toggle(self, button)
        self.set_mode(0)

    def invert_assignment(self):
        self._invert_assignment = True
        self._recalculate_mode()

    def number_of_modes(self):
        return 2

    def update(self):
        if self.is_enabled():
            if self._mode_index == 0:
                for index in range(len(self._select_buttons)):
                    strip = self._mixer.channel_strip(index)
                    strip.set_select_button(None)

                self._mixer.master_strip().set_select_button(None)
                self._transport.set_play_button(self._select_buttons[0])
                self._transport.set_stop_button(self._select_buttons[1])
                self._transport.set_record_button(self._select_buttons[2])
                self._transport.set_overdub_button(self._select_buttons[3])
                self._session.set_track_bank_buttons(self._select_buttons[5], self._select_buttons[4])
                self._session.set_scene_bank_buttons(self._select_buttons[7], self._select_buttons[6])
                self._zooming.set_nav_buttons(self._select_buttons[6], self._select_buttons[7], self._select_buttons[4], self._select_buttons[5])
                self._on_note_mode_changed()
            elif self._mode_index == 1:
                self._transport.set_play_button(None)
                self._transport.set_stop_button(None)
                self._transport.set_record_button(None)
                self._transport.set_overdub_button(None)
                self._session.set_track_bank_buttons(None, None)
                self._session.set_scene_bank_buttons(None, None)
                self._zooming.set_nav_buttons(None, None, None, None)
                for index in range(len(self._select_buttons)):
                    strip = self._mixer.channel_strip(index)
                    strip.set_select_button(self._select_buttons[index])

                self._mixer.master_strip().set_select_button(self._master_button)
            else:
                raise False or AssertionError
            if self._mode_index == int(self._invert_assignment):
                self._slider_modes.set_mode_buttons(None)
                for index in range(len(self._select_buttons)):
                    self._mixer.channel_strip(index).set_arm_button(self._arm_buttons[index])

            else:
                for index in range(len(self._select_buttons)):
                    self._mixer.channel_strip(index).set_arm_button(None)

                self._slider_modes.set_mode_buttons(self._arm_buttons)

    def _toggle_value(self, value):
        raise self._mode_toggle != None or AssertionError
        raise value in range(128) or AssertionError
        self._toggle_pressed = value > 0
        self._recalculate_mode()

    def _recalculate_mode(self):
        self.set_mode((int(self._toggle_pressed) + int(self._invert_assignment)) % self.number_of_modes())

    def _master_value(self, value):
        if not self._master_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self.is_enabled() and self._invert_assignment == self._toggle_pressed and (not self._master_button.is_momentary() or value > 0):
                    for button in self._select_buttons:
                        button.turn_off()

                    self._matrix.reset()
                    mode_byte = NOTE_MODE
                    mode_byte = self._note_mode_active and ABLETON_MODE
                self._mode_callback(mode_byte)
                self._note_mode_active = not self._note_mode_active
                self._zooming.set_ignore_buttons(self._note_mode_active)
                self._transport.update()
                self._on_note_mode_changed()

    def _on_note_mode_changed(self):
        if not self._master_button != None:
            raise AssertionError
            if self.is_enabled() and self._invert_assignment == self._toggle_pressed:
                self._note_mode_active and self._master_button.turn_on()
            else:
                self._master_button.turn_off()
########NEW FILE########
__FILENAME__ = ShiftableZoomingComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC20/ShiftableZoomingComponent.py
import Live
from _Framework.SessionZoomingComponent import SessionZoomingComponent
from _Framework.ButtonElement import ButtonElement

class ShiftableZoomingComponent(SessionZoomingComponent):
    """ Special ZoomingComponent that uses clip stop buttons for stop all when zoomed """

    def __init__(self, session, stop_buttons):
        SessionZoomingComponent.__init__(self, session)
        self._stop_buttons = stop_buttons
        self._ignore_buttons = False
        for button in self._stop_buttons:
            raise isinstance(button, ButtonElement) or AssertionError
            button.add_value_listener(self._stop_value, identify_sender=True)

    def disconnect(self):
        SessionZoomingComponent.disconnect(self)
        for button in self._stop_buttons:
            button.remove_value_listener(self._stop_value)

    def set_ignore_buttons(self, ignore):
        if not isinstance(ignore, type(False)):
            raise AssertionError
            if self._ignore_buttons != ignore:
                self._ignore_buttons = ignore
                self._is_zoomed_out or self._session.set_enabled(not ignore)
            self.update()

    def update(self):
        if not self._ignore_buttons:
            SessionZoomingComponent.update(self)
        elif self.is_enabled():
            if self._scene_bank_buttons != None:
                for button in self._scene_bank_buttons:
                    button.turn_off()

    def _stop_value(self, value, sender):
        if not value in range(128):
            raise AssertionError
            if not sender != None:
                raise AssertionError
                self.is_enabled() and not self._ignore_buttons and self._is_zoomed_out and (value != 0 or not sender.is_momentary()) and self.song().stop_all_clips()

    def _zoom_value(self, value):
        if not self._zoom_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self.is_enabled():
                    if self._zoom_button.is_momentary():
                        self._is_zoomed_out = value > 0
                    else:
                        self._is_zoomed_out = not self._is_zoomed_out
                    if not self._ignore_buttons:
                        self._scene_bank_index = self._is_zoomed_out and int(self._session.scene_offset() / self._session.height() / self._buttons.height())
                    else:
                        self._scene_bank_index = 0
                    self._session.set_enabled(not self._is_zoomed_out)
                    self._is_zoomed_out and self.update()

    def _matrix_value(self, value, x, y, is_momentary):
        if not self._ignore_buttons:
            SessionZoomingComponent._matrix_value(self, value, x, y, is_momentary)

    def _nav_up_value(self, value):
        if not self._ignore_buttons:
            SessionZoomingComponent._nav_up_value(self, value)

    def _nav_down_value(self, value):
        if not self._ignore_buttons:
            SessionZoomingComponent._nav_down_value(self, value)

    def _nav_left_value(self, value):
        if not self._ignore_buttons:
            SessionZoomingComponent._nav_left_value(self, value)

    def _nav_right_value(self, value):
        if not self._ignore_buttons:
            SessionZoomingComponent._nav_right_value(self, value)

    def _scene_bank_value(self, value, sender):
        if not self._ignore_buttons:
            SessionZoomingComponent._scene_bank_value(self, value, sender)
########NEW FILE########
__FILENAME__ = SliderModesComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC20/SliderModesComponent.py
import Live
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from _Framework.ButtonElement import ButtonElement

class SliderModesComponent(ModeSelectorComponent):
    """ SelectorComponent that assigns sliders to different functions """

    def __init__(self, mixer, sliders):
        raise len(sliders) == 8 or AssertionError
        ModeSelectorComponent.__init__(self)
        self._mixer = mixer
        self._sliders = sliders
        self._mode_index = 0

    def disconnect(self):
        ModeSelectorComponent.disconnect(self)
        self._mixer = None
        self._sliders = None

    def set_mode_buttons(self, buttons):
        raise isinstance(buttons, (tuple, type(None))) or AssertionError
        for button in self._modes_buttons:
            button.remove_value_listener(self._mode_value)

        self._modes_buttons = []
        if buttons != None:
            for button in buttons:
                raise isinstance(button, ButtonElement) or AssertionError
                identify_sender = True
                button.add_value_listener(self._mode_value, identify_sender)
                self._modes_buttons.append(button)

        self.update()

    def number_of_modes(self):
        return 8

    def update(self):
        if not (self.is_enabled() and self._mode_index in range(self.number_of_modes())):
            raise AssertionError
            for index in range(len(self._modes_buttons)):
                if index == self._mode_index:
                    self._modes_buttons[index].turn_on()
                else:
                    self._modes_buttons[index].turn_off()

            for index in range(len(self._sliders)):
                strip = self._mixer.channel_strip(index)
                slider = self._sliders[index]
                slider.use_default_message()
                slider.set_identifier(slider.message_identifier() - self._mode_index)
                strip.set_volume_control(None)
                strip.set_pan_control(None)
                strip.set_send_controls((None, None, None))
                slider.release_parameter()
                if self._mode_index == 0:
                    strip.set_volume_control(slider)
                elif self._mode_index == 1:
                    strip.set_pan_control(slider)
                elif self._mode_index < 5:
                    send_controls = [None, None, None]
                    send_controls[self._mode_index - 2] = slider
                    strip.set_send_controls(tuple(send_controls))
########NEW FILE########
__FILENAME__ = APC
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC40/APC.py
from __future__ import with_statement
import Live
from _Framework.ControlSurface import ControlSurface
MANUFACTURER_ID = 71
ABLETON_MODE = 65
DO_COMBINE = Live.Application.combine_apcs()

class APC(ControlSurface):
    """ Script for Akai's line of APC Controllers """
    _active_instances = []

    def _combine_active_instances():
        support_devices = False
        for instance in APC._active_instances:
            support_devices |= instance._device_component != None

        track_offset = 0
        for instance in APC._active_instances:
            instance._activate_combination_mode(track_offset, support_devices)
            track_offset += instance._session.width()

    _combine_active_instances = staticmethod(_combine_active_instances)

    def __init__(self, c_instance):
        ControlSurface.__init__(self, c_instance)
        with self.component_guard():
            self._suppress_session_highlight = True
            self._suppress_send_midi = True
            self._suggested_input_port = 'Akai ' + self.__class__.__name__
            self._suggested_output_port = 'Akai ' + self.__class__.__name__
            self._shift_button = None
            self._matrix = None
            self._session = None
            self._session_zoom = None
            self._mixer = None
            self._setup_session_control()
            self._setup_mixer_control()
            self._session.set_mixer(self._mixer)
            self._shift_button.name = 'Shift_Button'
            self._setup_custom_components()
            self.set_highlighting_session_component(self._session)
            for component in self.components:
                component.set_enabled(False)

        self._device_id = 0
        self._common_channel = 0
        self._dongle_challenge = (Live.Application.get_random_int(0, 2000000), Live.Application.get_random_int(2000001, 4000000))

    def disconnect(self):
        self._do_uncombine()
        self._shift_button = None
        self._matrix = None
        self._session = None
        self._session_zoom = None
        self._mixer = None
        ControlSurface.disconnect(self)

    def refresh_state(self):
        ControlSurface.refresh_state(self)
        self.schedule_message(5, self._update_hardware)

    def handle_sysex(self, midi_bytes):
        self._suppress_send_midi = False
        if midi_bytes[3] == 6 and midi_bytes[4] == 2:
            self._on_identity_response(midi_bytes)
        elif midi_bytes[4] == 81:
            self._on_dongle_response(midi_bytes)

    def _on_identity_response(self, midi_bytes):
        if midi_bytes[5] == MANUFACTURER_ID and midi_bytes[6] == self._product_model_id_byte():
            version_bytes = midi_bytes[9:13]
            self._device_id = midi_bytes[13]
            self._send_introduction_message()
            challenge1 = [0,
             0,
             0,
             0,
             0,
             0,
             0,
             0]
            challenge2 = [0,
             0,
             0,
             0,
             0,
             0,
             0,
             0]
            for index in range(8):
                challenge1[index] = self._dongle_challenge[0] >> 4 * (7 - index) & 15
                challenge2[index] = self._dongle_challenge[1] >> 4 * (7 - index) & 15

            dongle_message = (240,
             MANUFACTURER_ID,
             self._device_id,
             self._product_model_id_byte(),
             80,
             0,
             16) + tuple(challenge1) + tuple(challenge2) + (247,)
            self._send_midi(dongle_message)
            message = self.__class__.__name__ + ': Got response from controller, version ' + str((version_bytes[0] << 4) + version_bytes[1]) + '.' + str((version_bytes[2] << 4) + version_bytes[3])
            self.log_message(message)

    def _on_dongle_response(self, midi_bytes):
        if midi_bytes[1] == MANUFACTURER_ID and midi_bytes[3] == self._product_model_id_byte() and midi_bytes[2] == self._device_id and midi_bytes[5] == 0:
            if midi_bytes[6] == 16:
                response = [long(0), long(0)]
                for index in range(8):
                    response[0] += long(midi_bytes[7 + index] & 15) << 4 * (7 - index)
                    response[1] += long(midi_bytes[15 + index] & 15) << 4 * (7 - index)

                expected_response = Live.Application.encrypt_challenge(self._dongle_challenge[0], self._dongle_challenge[1])
                [long(expected_response[0]), long(expected_response[1])] == response and self._on_handshake_successful()

    def _on_handshake_successful(self):
        self._suppress_session_highlight = False
        for component in self.components:
            component.set_enabled(True)

        self._on_selected_track_changed()
        self._do_combine()

    def _update_hardware(self):
        self._suppress_send_midi = True
        self._suppress_session_highlight = True
        with self.component_guard():
            for component in self.components:
                component.set_enabled(False)

        self._suppress_send_midi = False
        self._do_uncombine()
        self._send_midi((240, 126, 0, 6, 1, 247))

    def _set_session_highlight(self, track_offset, scene_offset, width, height, include_return_tracks):
        if not self._suppress_session_highlight or (track_offset,
         scene_offset,
         width,
         height) == (-1, -1, -1, -1):
            ControlSurface._set_session_highlight(self, track_offset, scene_offset, width, height, include_return_tracks)

    def _send_midi(self, midi_bytes, optimized = None):
        sent_successfully = False
        if not self._suppress_send_midi:
            sent_successfully = ControlSurface._send_midi(self, midi_bytes, optimized=optimized)
        return sent_successfully

    def _send_introduction_message(self, mode_byte = ABLETON_MODE):
        self._send_midi((240,
         MANUFACTURER_ID,
         self._device_id,
         self._product_model_id_byte(),
         96,
         0,
         4,
         mode_byte,
         self.application().get_major_version(),
         self.application().get_minor_version(),
         self.application().get_bugfix_version(),
         247))

    def _activate_combination_mode(self, track_offset, support_devices):
        self._session.link_with_track_offset(track_offset)

    def _do_combine(self):
        if DO_COMBINE and self not in APC._active_instances:
            APC._active_instances.append(self)
            APC._combine_active_instances()

    def _do_uncombine(self):
        if self in APC._active_instances:
            APC._active_instances.remove(self)
            self._session.unlink()
            APC._combine_active_instances()

    def _setup_session_control(self):
        raise AssertionError, 'Function _setup_session_control must be overridden by subclass'

    def _setup_mixer_control(self):
        raise AssertionError, 'Function _setup_mixer_control must be overridden by subclass'

    def _setup_custom_components(self):
        raise AssertionError, 'Function _setup_custom_components must be overridden by subclass'

    def _product_model_id_byte(self):
        raise AssertionError, 'Function _product_model_id_byte must be overridden by subclass'
########NEW FILE########
__FILENAME__ = APC40
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC40/APC40.py
import Live
from APC import APC
from _Framework.ControlSurface import ControlSurface
from _Framework.InputControlElement import *
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import EncoderElement
from _Framework.ButtonMatrixElement import ButtonMatrixElement
from _Framework.MixerComponent import MixerComponent
from _Framework.ClipSlotComponent import ClipSlotComponent
from _Framework.ChannelStripComponent import ChannelStripComponent
from _Framework.SceneComponent import SceneComponent
from _Framework.SessionZoomingComponent import SessionZoomingComponent
from _Framework.ChannelTranslationSelector import ChannelTranslationSelector
from EncModeSelectorComponent import EncModeSelectorComponent
from RingedEncoderElement import RingedEncoderElement
from DetailViewCntrlComponent import DetailViewCntrlComponent
from ShiftableDeviceComponent import ShiftableDeviceComponent
from ShiftableTransportComponent import ShiftableTransportComponent
from ShiftTranslatorComponent import ShiftTranslatorComponent
from PedaledSessionComponent import PedaledSessionComponent
from SpecialMixerComponent import SpecialMixerComponent

class APC40(APC):
    """ Script for Akai's APC40 Controller """

    def __init__(self, c_instance):
        APC.__init__(self, c_instance)
        self._device_selection_follows_track_selection = True

    def _setup_session_control(self):
        is_momentary = True
        self._shift_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 98)
        right_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 96)
        left_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 97)
        up_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 94)
        down_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 95)
        right_button.name = 'Bank_Select_Right_Button'
        left_button.name = 'Bank_Select_Left_Button'
        up_button.name = 'Bank_Select_Up_Button'
        down_button.name = 'Bank_Select_Down_Button'
        self._session = PedaledSessionComponent(8, 5)
        self._session.name = 'Session_Control'
        self._session.set_track_bank_buttons(right_button, left_button)
        self._session.set_scene_bank_buttons(down_button, up_button)
        matrix = ButtonMatrixElement()
        matrix.name = 'Button_Matrix'
        scene_launch_buttons = [ ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, index + 82) for index in range(5) ]
        track_stop_buttons = [ ButtonElement(is_momentary, MIDI_NOTE_TYPE, index, 52) for index in range(8) ]
        for index in range(len(scene_launch_buttons)):
            scene_launch_buttons[index].name = 'Scene_' + str(index) + '_Launch_Button'

        for index in range(len(track_stop_buttons)):
            track_stop_buttons[index].name = 'Track_' + str(index) + '_Stop_Button'

        stop_all_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 81)
        stop_all_button.name = 'Stop_All_Clips_Button'
        self._session.set_stop_all_clips_button(stop_all_button)
        self._session.set_stop_track_clip_buttons(tuple(track_stop_buttons))
        self._session.set_stop_track_clip_value(2)
        for scene_index in range(5):
            scene = self._session.scene(scene_index)
            scene.name = 'Scene_' + str(scene_index)
            button_row = []
            scene.set_launch_button(scene_launch_buttons[scene_index])
            scene.set_triggered_value(2)
            for track_index in range(8):
                button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, track_index, scene_index + 53)
                button.name = str(track_index) + '_Clip_' + str(scene_index) + '_Button'
                button_row.append(button)
                clip_slot = scene.clip_slot(track_index)
                clip_slot.name = str(track_index) + '_Clip_Slot_' + str(scene_index)
                clip_slot.set_triggered_to_play_value(2)
                clip_slot.set_triggered_to_record_value(4)
                clip_slot.set_stopped_value(5)
                clip_slot.set_started_value(1)
                clip_slot.set_recording_value(3)
                clip_slot.set_launch_button(button)

            matrix.add_row(tuple(button_row))

        self._session.set_slot_launch_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 0, 67))
        self._session.selected_scene().name = 'Selected_Scene'
        self._session.selected_scene().set_launch_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 0, 64))
        self._session_zoom = SessionZoomingComponent(self._session)
        self._session_zoom.name = 'Session_Overview'
        self._session_zoom.set_button_matrix(matrix)
        self._session_zoom.set_zoom_button(self._shift_button)
        self._session_zoom.set_nav_buttons(up_button, down_button, left_button, right_button)
        self._session_zoom.set_scene_bank_buttons(tuple(scene_launch_buttons))
        self._session_zoom.set_stopped_value(3)
        self._session_zoom.set_selected_value(5)

    def _setup_mixer_control(self):
        is_momentary = True
        self._mixer = SpecialMixerComponent(8)
        self._mixer.name = 'Mixer'
        self._mixer.master_strip().name = 'Master_Channel_Strip'
        self._mixer.selected_strip().name = 'Selected_Channel_Strip'
        for track in range(8):
            strip = self._mixer.channel_strip(track)
            strip.name = 'Channel_Strip_' + str(track)
            volume_control = SliderElement(MIDI_CC_TYPE, track, 7)
            arm_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, track, 48)
            solo_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, track, 49)
            mute_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, track, 50)
            select_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, track, 51)
            volume_control.name = str(track) + '_Volume_Control'
            arm_button.name = str(track) + '_Arm_Button'
            solo_button.name = str(track) + '_Solo_Button'
            mute_button.name = str(track) + '_Mute_Button'
            select_button.name = str(track) + '_Select_Button'
            strip.set_volume_control(volume_control)
            strip.set_arm_button(arm_button)
            strip.set_solo_button(solo_button)
            strip.set_mute_button(mute_button)
            strip.set_select_button(select_button)
            strip.set_shift_button(self._shift_button)
            strip.set_invert_mute_feedback(True)

        crossfader = SliderElement(MIDI_CC_TYPE, 0, 15)
        master_volume_control = SliderElement(MIDI_CC_TYPE, 0, 14)
        master_select_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 80)
        prehear_control = EncoderElement(MIDI_CC_TYPE, 0, 47, Live.MidiMap.MapMode.relative_two_compliment)
        crossfader.name = 'Crossfader'
        master_volume_control.name = 'Master_Volume_Control'
        master_select_button.name = 'Master_Select_Button'
        prehear_control.name = 'Prehear_Volume_Control'
        self._mixer.set_crossfader_control(crossfader)
        self._mixer.set_prehear_volume_control(prehear_control)
        self._mixer.master_strip().set_volume_control(master_volume_control)
        self._mixer.master_strip().set_select_button(master_select_button)

    def _setup_custom_components(self):
        self._setup_device_and_transport_control()
        self._setup_global_control()

    def _setup_device_and_transport_control(self):
        is_momentary = True
        device_bank_buttons = []
        device_param_controls = []
        bank_button_labels = ('Clip_Track_Button', 'Device_On_Off_Button', 'Previous_Device_Button', 'Next_Device_Button', 'Detail_View_Button', 'Rec_Quantization_Button', 'Midi_Overdub_Button', 'Metronome_Button')
        for index in range(8):
            device_bank_buttons.append(ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 58 + index))
            device_bank_buttons[-1].name = bank_button_labels[index]
            ring_mode_button = ButtonElement(not is_momentary, MIDI_CC_TYPE, 0, 24 + index)
            ringed_encoder = RingedEncoderElement(MIDI_CC_TYPE, 0, 16 + index, Live.MidiMap.MapMode.absolute)
            ringed_encoder.set_ring_mode_button(ring_mode_button)
            ringed_encoder.name = 'Device_Control_' + str(index)
            ring_mode_button.name = ringed_encoder.name + '_Ring_Mode_Button'
            device_param_controls.append(ringed_encoder)

        device = ShiftableDeviceComponent()
        device.name = 'Device_Component'
        device.set_bank_buttons(tuple(device_bank_buttons))
        device.set_shift_button(self._shift_button)
        device.set_parameter_controls(tuple(device_param_controls))
        device.set_on_off_button(device_bank_buttons[1])
        self.set_device_component(device)
        detail_view_toggler = DetailViewCntrlComponent()
        detail_view_toggler.name = 'Detail_View_Control'
        detail_view_toggler.set_shift_button(self._shift_button)
        detail_view_toggler.set_device_clip_toggle_button(device_bank_buttons[0])
        detail_view_toggler.set_detail_toggle_button(device_bank_buttons[4])
        detail_view_toggler.set_device_nav_buttons(device_bank_buttons[2], device_bank_buttons[3])
        transport = ShiftableTransportComponent()
        transport.name = 'Transport'
        play_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 91)
        stop_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 92)
        record_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 93)
        nudge_up_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 100)
        nudge_down_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 101)
        tap_tempo_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 99)
        play_button.name = 'Play_Button'
        stop_button.name = 'Stop_Button'
        record_button.name = 'Record_Button'
        nudge_up_button.name = 'Nudge_Up_Button'
        nudge_down_button.name = 'Nudge_Down_Button'
        tap_tempo_button.name = 'Tap_Tempo_Button'
        transport.set_shift_button(self._shift_button)
        transport.set_play_button(play_button)
        transport.set_stop_button(stop_button)
        transport.set_record_button(record_button)
        transport.set_nudge_buttons(nudge_up_button, nudge_down_button)
        transport.set_tap_tempo_button(tap_tempo_button)
        transport.set_quant_toggle_button(device_bank_buttons[5])
        transport.set_overdub_button(device_bank_buttons[6])
        transport.set_metronome_button(device_bank_buttons[7])
        bank_button_translator = ShiftTranslatorComponent()
        bank_button_translator.set_controls_to_translate(tuple(device_bank_buttons))
        bank_button_translator.set_shift_button(self._shift_button)

    def _setup_global_control(self):
        is_momentary = True
        global_bank_buttons = []
        global_param_controls = []
        for index in range(8):
            ring_button = ButtonElement(not is_momentary, MIDI_CC_TYPE, 0, 56 + index)
            ringed_encoder = RingedEncoderElement(MIDI_CC_TYPE, 0, 48 + index, Live.MidiMap.MapMode.absolute)
            ringed_encoder.name = 'Track_Control_' + str(index)
            ring_button.name = ringed_encoder.name + '_Ring_Mode_Button'
            ringed_encoder.set_ring_mode_button(ring_button)
            global_param_controls.append(ringed_encoder)

        global_bank_buttons = []
        global_bank_labels = ('Pan_Button', 'Send_A_Button', 'Send_B_Button', 'Send_C_Button')
        for index in range(4):
            global_bank_buttons.append(ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 87 + index))
            global_bank_buttons[-1].name = global_bank_labels[index]

        encoder_modes = EncModeSelectorComponent(self._mixer)
        encoder_modes.name = 'Track_Control_Modes'
        encoder_modes.set_modes_buttons(global_bank_buttons)
        encoder_modes.set_controls(tuple(global_param_controls))
        global_translation_selector = ChannelTranslationSelector()
        global_translation_selector.name = 'Global_Translations'
        global_translation_selector.set_controls_to_translate(tuple(global_param_controls))
        global_translation_selector.set_mode_buttons(tuple(global_bank_buttons))

    def _product_model_id_byte(self):
        return 115
########NEW FILE########
__FILENAME__ = APCSessionComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC40/APCSessionComponent.py
import Live
from _Framework.SessionComponent import SessionComponent

class APCSessionComponent(SessionComponent):
    """ Special SessionComponent for the APC controllers' combination mode """

    def __init__(self, num_tracks, num_scenes):
        SessionComponent.__init__(self, num_tracks, num_scenes)

    def link_with_track_offset(self, track_offset):
        if not track_offset >= 0:
            raise AssertionError
            self._is_linked() and self._unlink()
        self.set_offsets(track_offset, 0)
        self._link()

    def unlink(self):
        if self._is_linked():
            self._unlink()
########NEW FILE########
__FILENAME__ = DetailViewCntrlComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC40/DetailViewCntrlComponent.py
import Live
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.ButtonElement import ButtonElement
SHOW_PLAYING_CLIP_DELAY = 5

class DetailViewCntrlComponent(ControlSurfaceComponent):
    """ Component that can toggle the device chain- and clip view of the selected track """

    def __init__(self):
        ControlSurfaceComponent.__init__(self)
        self._device_clip_toggle_button = None
        self._detail_toggle_button = None
        self._left_button = None
        self._right_button = None
        self._shift_button = None
        self._shift_pressed = False
        self._show_playing_clip_ticks_delay = -1
        self.application().view.add_is_view_visible_listener('Detail', self._detail_view_visibility_changed)
        self._register_timer_callback(self._on_timer)

    def disconnect(self):
        self._unregister_timer_callback(self._on_timer)
        self.application().view.remove_is_view_visible_listener('Detail', self._detail_view_visibility_changed)
        if self._device_clip_toggle_button != None:
            self._device_clip_toggle_button.remove_value_listener(self._device_clip_toggle_value)
            self._device_clip_toggle_button = None
        if self._detail_toggle_button != None:
            self._detail_toggle_button.remove_value_listener(self._detail_toggle_value)
            self._detail_toggle_button = None
        if self._left_button != None:
            self._left_button.remove_value_listener(self._nav_value)
            self._left_button = None
        if self._right_button != None:
            self._right_button.remove_value_listener(self._nav_value)
            self._right_button = None
        if self._shift_button != None:
            self._shift_button.remove_value_listener(self._shift_value)
            self._shift_button = None

    def set_device_clip_toggle_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._device_clip_toggle_button != button:
                if self._device_clip_toggle_button != None:
                    self._device_clip_toggle_button.remove_value_listener(self._device_clip_toggle_value)
                self._device_clip_toggle_button = button
                self._device_clip_toggle_button != None and self._device_clip_toggle_button.add_value_listener(self._device_clip_toggle_value)
            self.update()

    def set_detail_toggle_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._detail_toggle_button != button:
                if self._detail_toggle_button != None:
                    self._detail_toggle_button.remove_value_listener(self._detail_toggle_value)
                self._detail_toggle_button = button
                self._detail_toggle_button != None and self._detail_toggle_button.add_value_listener(self._detail_toggle_value)
            self.update()

    def set_device_nav_buttons(self, left_button, right_button):
        if not (left_button == None or isinstance(left_button, ButtonElement)):
            raise AssertionError
            if not (right_button == None or isinstance(right_button, ButtonElement)):
                raise AssertionError
                identify_sender = True
                if self._left_button != None:
                    self._left_button.remove_value_listener(self._nav_value)
                self._left_button = left_button
                if self._left_button != None:
                    self._left_button.add_value_listener(self._nav_value, identify_sender)
                self._right_button != None and self._right_button.remove_value_listener(self._nav_value)
            self._right_button = right_button
            self._right_button != None and self._right_button.add_value_listener(self._nav_value, identify_sender)
        self.update()

    def set_shift_button(self, button):
        if not (button == None or isinstance(button, ButtonElement) and button.is_momentary()):
            raise AssertionError
            if self._shift_button != button:
                if self._shift_button != None:
                    self._shift_button.remove_value_listener(self._shift_value)
                self._shift_button = button
                self._shift_button != None and self._shift_button.add_value_listener(self._shift_value)
            self.update()

    def on_enabled_changed(self):
        self.update()

    def update(self):
        if self.is_enabled():
            if not self._shift_pressed:
                if self._left_button != None:
                    self._left_button.turn_off()
                if self._right_button != None:
                    self._right_button.turn_off()
                if self._device_clip_toggle_button != None:
                    self._device_clip_toggle_button.turn_off()
                self._detail_view_visibility_changed()

    def _detail_view_visibility_changed(self):
        if self.is_enabled() and not self._shift_pressed and self._detail_toggle_button != None:
            if self.application().view.is_view_visible('Detail'):
                self._detail_toggle_button.turn_on()
            else:
                self._detail_toggle_button.turn_off()

    def _device_clip_toggle_value(self, value):
        if not self._device_clip_toggle_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self.is_enabled() and not self._shift_pressed:
                    button_is_momentary = self._device_clip_toggle_button.is_momentary()
                    if not button_is_momentary or value != 0:
                        if not self.application().view.is_view_visible('Detail'):
                            self.application().view.show_view('Detail')
                        self.application().view.is_view_visible('Detail/DeviceChain') or self.application().view.show_view('Detail/DeviceChain')
                    else:
                        self.application().view.show_view('Detail/Clip')
                self._show_playing_clip_ticks_delay = button_is_momentary and value != 0 and SHOW_PLAYING_CLIP_DELAY
            else:
                self._show_playing_clip_ticks_delay = -1

    def _detail_toggle_value(self, value):
        if not self._detail_toggle_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self.is_enabled() and not self._shift_pressed:
                    (not self._detail_toggle_button.is_momentary() or value != 0) and (self.application().view.is_view_visible('Detail') or self.application().view.show_view('Detail'))
                else:
                    self.application().view.hide_view('Detail')

    def _shift_value(self, value):
        raise self._shift_button != None or AssertionError
        raise value in range(128) or AssertionError
        self._shift_pressed = value != 0
        self.update()

    def _nav_value(self, value, sender):
        raise sender != None and sender in (self._left_button, self._right_button) or AssertionError
        if self.is_enabled() and not self._shift_pressed:
            if not sender.is_momentary() or value != 0:
                modifier_pressed = True
                if not self.application().view.is_view_visible('Detail') or not self.application().view.is_view_visible('Detail/DeviceChain'):
                    self.application().view.show_view('Detail')
                    self.application().view.show_view('Detail/DeviceChain')
                else:
                    direction = Live.Application.Application.View.NavDirection.left
                    if sender == self._right_button:
                        direction = Live.Application.Application.View.NavDirection.right
                    self.application().view.scroll_view(direction, 'Detail/DeviceChain', not modifier_pressed)

    def _on_timer(self):
        if self.is_enabled() and not self._shift_pressed:
            if self._show_playing_clip_ticks_delay > -1:
                if self._show_playing_clip_ticks_delay == 0:
                    song = self.song()
                    playing_slot_index = song.view.selected_track.playing_slot_index
                    if playing_slot_index > -1:
                        song.view.selected_scene = song.scenes[playing_slot_index]
                        if song.view.highlighted_clip_slot.has_clip:
                            self.application().view.show_view('Detail/Clip')
                self._show_playing_clip_ticks_delay -= 1
########NEW FILE########
__FILENAME__ = EncModeSelectorComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC40/EncModeSelectorComponent.py
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from _Framework.ButtonElement import ButtonElement
from _Framework.MixerComponent import MixerComponent

class EncModeSelectorComponent(ModeSelectorComponent):
    """ Class that reassigns encoders on the AxiomPro to different mixer functions """

    def __init__(self, mixer):
        raise isinstance(mixer, MixerComponent) or AssertionError
        ModeSelectorComponent.__init__(self)
        self._controls = None
        self._mixer = mixer

    def disconnect(self):
        for button in self._modes_buttons:
            button.remove_value_listener(self._mode_value)

        self._controls = None
        self._mixer = None
        ModeSelectorComponent.disconnect(self)

    def set_modes_buttons(self, buttons):
        raise buttons == None or isinstance(buttons, tuple) or len(buttons) == self.number_of_modes() or AssertionError
        identify_sender = True
        for button in self._modes_buttons:
            button.remove_value_listener(self._mode_value)

        self._modes_buttons = []
        if buttons != None:
            for button in buttons:
                raise isinstance(button, ButtonElement) or AssertionError
                self._modes_buttons.append(button)
                button.add_value_listener(self._mode_value, identify_sender)

        self.set_mode(0)
        self.update()

    def set_controls(self, controls):
        raise controls == None or isinstance(controls, tuple) and len(controls) == 8 or AssertionError
        self._controls = controls
        self.set_mode(0)
        self.update()

    def number_of_modes(self):
        return 4

    def on_enabled_changed(self):
        self.update()

    def update(self):
        if not self._modes_buttons != None:
            raise AssertionError
            if self.is_enabled() and self._modes_buttons != None:
                for button in self._modes_buttons:
                    if self._modes_buttons.index(button) == self._mode_index:
                        button.turn_on()
                    else:
                        button.turn_off()

            if self._controls != None:
                for index in range(len(self._controls)):
                    if self._mode_index == 0:
                        self._mixer.channel_strip(index).set_pan_control(self._controls[index])
                        self._mixer.channel_strip(index).set_send_controls((None, None, None))
                    elif self._mode_index == 1:
                        self._mixer.channel_strip(index).set_pan_control(None)
                        self._mixer.channel_strip(index).set_send_controls((self._controls[index], None, None))
                    elif self._mode_index == 2:
                        self._mixer.channel_strip(index).set_pan_control(None)
                        self._mixer.channel_strip(index).set_send_controls((None, self._controls[index], None))
                    elif self._mode_index == 3:
                        self._mixer.channel_strip(index).set_pan_control(None)
                        self._mixer.channel_strip(index).set_send_controls((None, None, self._controls[index]))
                    else:
                        print 'Invalid mode index'
                        raise False or AssertionError
########NEW FILE########
__FILENAME__ = PedaledSessionComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC40/PedaledSessionComponent.py
import Live
from APCSessionComponent import APCSessionComponent
from _Framework.ButtonElement import ButtonElement

class PedaledSessionComponent(APCSessionComponent):
    """ Special SessionComponent with a button (pedal) to fire the selected clip slot """

    def __init__(self, num_tracks, num_scenes):
        APCSessionComponent.__init__(self, num_tracks, num_scenes)
        self._slot_launch_button = None

    def disconnect(self):
        APCSessionComponent.disconnect(self)
        if self._slot_launch_button != None:
            self._slot_launch_button.remove_value_listener(self._slot_launch_value)
            self._slot_launch_button = None

    def set_slot_launch_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._slot_launch_button != button:
                if self._slot_launch_button != None:
                    self._slot_launch_button.remove_value_listener(self._slot_launch_value)
                self._slot_launch_button = button
                self._slot_launch_button != None and self._slot_launch_button.add_value_listener(self._slot_launch_value)
            self.update()

    def _slot_launch_value(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._slot_launch_button != None:
                raise AssertionError
                if self.is_enabled():
                    (value != 0 or not self._slot_launch_button.is_momentary()) and self.song().view.highlighted_clip_slot != None and self.song().view.highlighted_clip_slot.fire()
########NEW FILE########
__FILENAME__ = RingedEncoderElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC40/RingedEncoderElement.py
from _Framework.EncoderElement import EncoderElement
from _Framework.ButtonElement import ButtonElement
RING_OFF_VALUE = 0
RING_SIN_VALUE = 1
RING_VOL_VALUE = 2
RING_PAN_VALUE = 3

class RingedEncoderElement(EncoderElement):
    """ Class representing a continuous control on the controller enclosed with an LED ring """

    def __init__(self, msg_type, channel, identifier, map_mode):
        EncoderElement.__init__(self, msg_type, channel, identifier, map_mode)
        self._ring_mode_button = None
        self.set_needs_takeover(False)

    def set_ring_mode_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            self._ring_mode_button != None and self._ring_mode_button.send_value(RING_OFF_VALUE, force=True)
        self._ring_mode_button = button
        self._update_ring_mode()

    def connect_to(self, parameter):
        if parameter != self._parameter_to_map_to and not self.is_mapped_manually():
            self._ring_mode_button.send_value(RING_OFF_VALUE, force=True)
        EncoderElement.connect_to(self, parameter)

    def release_parameter(self):
        EncoderElement.release_parameter(self)
        self._update_ring_mode()

    def install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback):
        EncoderElement.install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback)
        if not self._is_mapped and self.value_listener_count() == 0:
            self._is_being_forwarded = install_forwarding_callback(self)
        self._update_ring_mode()

    def is_mapped_manually(self):
        return not self._is_mapped and not self._is_being_forwarded

    def _update_ring_mode(self):
        if self._ring_mode_button != None:
            if self.is_mapped_manually():
                self._ring_mode_button.send_value(RING_SIN_VALUE, force=True)
            elif self._parameter_to_map_to != None:
                param = self._parameter_to_map_to
                p_range = param.max - param.min
                value = (param.value - param.min) / p_range * 127
                self.send_value(int(value), force=True)
                if self._parameter_to_map_to.min == -1 * self._parameter_to_map_to.max:
                    self._ring_mode_button.send_value(RING_PAN_VALUE, force=True)
                elif self._parameter_to_map_to.is_quantized:
                    self._ring_mode_button.send_value(RING_SIN_VALUE, force=True)
                else:
                    self._ring_mode_button.send_value(RING_VOL_VALUE, force=True)
            else:
                self._ring_mode_button.send_value(RING_OFF_VALUE, force=True)
########NEW FILE########
__FILENAME__ = ShiftableDeviceComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC40/ShiftableDeviceComponent.py
import Live
from _Generic.Devices import *
from _Framework.DeviceComponent import DeviceComponent
from _Framework.ChannelTranslationSelector import ChannelTranslationSelector
from _Framework.ButtonElement import ButtonElement

class ShiftableDeviceComponent(DeviceComponent):
    """ DeviceComponent that only uses bank buttons if a shift button is pressed """

    def __init__(self):
        DeviceComponent.__init__(self)
        self._shift_button = None
        self._shift_pressed = False
        self._control_translation_selector = ChannelTranslationSelector(8)

    def disconnect(self):
        DeviceComponent.disconnect(self)
        self._control_translation_selector.disconnect()
        if self._shift_button != None:
            self._shift_button.remove_value_listener(self._shift_value)
            self._shift_button = None

    def set_parameter_controls(self, controls):
        DeviceComponent.set_parameter_controls(self, controls)
        self._control_translation_selector.set_controls_to_translate(controls)
        self._control_translation_selector.set_mode(self._bank_index)

    def set_device(self, device):
        DeviceComponent.set_device(self, device)
        self._control_translation_selector.set_mode(self._bank_index)

    def set_shift_button(self, button):
        if not (button == None or isinstance(button, ButtonElement) and button.is_momentary()):
            raise AssertionError
            if self._shift_button != button:
                if self._shift_button != None:
                    self._shift_button.remove_value_listener(self._shift_value)
                self._shift_button = button
                self._shift_button != None and self._shift_button.add_value_listener(self._shift_value)
            self.update()

    def update(self):
        if self._parameter_controls != None:
            for control in self._parameter_controls:
                control.release_parameter()

        if self.is_enabled() and self._device != None:
            self._device_bank_registry.set_device_bank(self._device, self._bank_index)
            if self._parameter_controls != None:
                if self._bank_index < number_of_parameter_banks(self._device):
                    old_bank_name = self._bank_name
                    self._assign_parameters()
                    if self._bank_name != old_bank_name:
                        self._show_msg_callback(self._device.name + ' Bank: ' + self._bank_name)
            self._shift_pressed or self._on_on_off_changed()
        elif self._bank_buttons != None:
            for index in range(len(self._bank_buttons)):
                if index == self._bank_index:
                    self._bank_buttons[index].turn_on()
                else:
                    self._bank_buttons[index].turn_off()

    def _shift_value(self, value):
        raise self._shift_button != None or AssertionError
        raise value in range(128) or AssertionError
        self._shift_pressed = value != 0
        self.update()

    def _bank_value(self, value, sender):
        if not (sender != None and sender in self._bank_buttons):
            raise AssertionError
            if self._shift_pressed and self.is_enabled():
                self._bank_name = (value != 0 or not sender.is_momentary()) and ''
                self._bank_index = list(self._bank_buttons).index(sender)
                self._control_translation_selector.set_mode(self._bank_index)
                self.update()

    def _on_off_value(self, value):
        if not self._shift_pressed:
            DeviceComponent._on_off_value(self, value)

    def _on_on_off_changed(self):
        if not self._shift_pressed:
            DeviceComponent._on_on_off_changed(self)
########NEW FILE########
__FILENAME__ = ShiftableTransportComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC40/ShiftableTransportComponent.py
import Live
from _Framework.TransportComponent import TransportComponent
from _Framework.ButtonElement import ButtonElement

class ShiftableTransportComponent(TransportComponent):
    """ TransportComponent that only uses certain buttons if a shift button is pressed """

    def __init__(self):
        TransportComponent.__init__(self)
        self._shift_button = None
        self._quant_toggle_button = None
        self._shift_pressed = False
        self._last_quant_value = Live.Song.RecordingQuantization.rec_q_eight
        self.song().add_midi_recording_quantization_listener(self._on_quantisation_changed)
        self._on_quantisation_changed()

    def disconnect(self):
        TransportComponent.disconnect(self)
        if self._shift_button != None:
            self._shift_button.remove_value_listener(self._shift_value)
            self._shift_button = None
        if self._quant_toggle_button != None:
            self._quant_toggle_button.remove_value_listener(self._quant_toggle_value)
            self._quant_toggle_button = None
        self.song().remove_midi_recording_quantization_listener(self._on_quantisation_changed)

    def set_shift_button(self, button):
        if not (button == None or isinstance(button, ButtonElement) and button.is_momentary()):
            raise AssertionError
            if self._shift_button != button:
                if self._shift_button != None:
                    self._shift_button.remove_value_listener(self._shift_value)
                self._shift_button = button
                self._shift_button != None and self._shift_button.add_value_listener(self._shift_value)
            self.update()

    def set_quant_toggle_button(self, button):
        if not (button == None or isinstance(button, ButtonElement) and button.is_momentary()):
            raise AssertionError
            if self._quant_toggle_button != button:
                if self._quant_toggle_button != None:
                    self._quant_toggle_button.remove_value_listener(self._quant_toggle_value)
                self._quant_toggle_button = button
                self._quant_toggle_button != None and self._quant_toggle_button.add_value_listener(self._quant_toggle_value)
            self.update()

    def update(self):
        pass

    def _shift_value(self, value):
        self._shift_pressed = value != 0
        if self.is_enabled():
            self._overdub_toggle.set_enabled(not self._shift_pressed)
            self._metronome_toggle.set_enabled(not self._shift_pressed)
            self.update()

    def _quant_toggle_value(self, value):
        if not self._last_quant_value != Live.Song.RecordingQuantization.rec_q_no_q:
            raise AssertionError
            if self.is_enabled() and not self._shift_pressed:
                if value != 0 or not self._quant_toggle_button.is_momentary():
                    quant_value = self.song().midi_recording_quantization
                    self._last_quant_value = quant_value != Live.Song.RecordingQuantization.rec_q_no_q and quant_value
                    self.song().midi_recording_quantization = Live.Song.RecordingQuantization.rec_q_no_q
                else:
                    self.song().midi_recording_quantization = self._last_quant_value

    def _on_quantisation_changed(self):
        if self.is_enabled():
            quant_value = self.song().midi_recording_quantization
            quant_on = quant_value != Live.Song.RecordingQuantization.rec_q_no_q
            if quant_on:
                self._last_quant_value = quant_value
            if not self._shift_pressed and self._quant_toggle_button != None:
                if quant_on:
                    self._quant_toggle_button.turn_on()
                else:
                    self._quant_toggle_button.turn_off()
########NEW FILE########
__FILENAME__ = ShiftTranslatorComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC40/ShiftTranslatorComponent.py
from _Framework.ChannelTranslationSelector import ChannelTranslationSelector
from _Framework.ButtonElement import ButtonElement
from _Framework.MixerComponent import MixerComponent

class ShiftTranslatorComponent(ChannelTranslationSelector):
    """ Class that translates the channel of some buttons as long as a shift button is held """

    def __init__(self):
        ChannelTranslationSelector.__init__(self)
        self._shift_button = None
        self._shift_pressed = False

    def disconnect(self):
        if self._shift_button != None:
            self._shift_button.remove_value_listener(self._shift_value)
            self._shift_button = None
        ChannelTranslationSelector.disconnect(self)

    def set_shift_button(self, button):
        if not (button == None or isinstance(button, ButtonElement) and button.is_momentary()):
            raise AssertionError
            if self._shift_button != None:
                self._shift_button.remove_value_listener(self._shift_value)
            self._shift_button = button
            self._shift_button != None and self._shift_button.add_value_listener(self._shift_value)
        self.set_mode(0)

    def on_enabled_changed(self):
        if self.is_enabled():
            self.set_mode(int(self._shift_pressed))

    def number_of_modes(self):
        return 2

    def _shift_value(self, value):
        if not self._shift_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            self._shift_pressed = value != 0
            self.is_enabled() and self.set_mode(int(self._shift_pressed))
########NEW FILE########
__FILENAME__ = SpecialChanStripComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC40/SpecialChanStripComponent.py
from _Framework.ChannelStripComponent import ChannelStripComponent
TRACK_FOLD_DELAY = 5

class SpecialChanStripComponent(ChannelStripComponent):
    """ Subclass of channel strip component using select button for (un)folding tracks """

    def __init__(self):
        ChannelStripComponent.__init__(self)
        self._toggle_fold_ticks_delay = -1
        self._register_timer_callback(self._on_timer)

    def disconnect(self):
        self._unregister_timer_callback(self._on_timer)
        ChannelStripComponent.disconnect(self)

    def _select_value(self, value):
        ChannelStripComponent._select_value(self, value)
        if self.is_enabled() and self._track != None:
            if self._track.is_foldable and self._select_button.is_momentary() and value != 0:
                self._toggle_fold_ticks_delay = TRACK_FOLD_DELAY
            else:
                self._toggle_fold_ticks_delay = -1

    def _on_timer(self):
        if self.is_enabled() and self._track != None and self._toggle_fold_ticks_delay > -1:
            if not self._track.is_foldable:
                raise AssertionError
                if self._toggle_fold_ticks_delay == 0:
                    self._track.fold_state = not self._track.fold_state
                self._toggle_fold_ticks_delay -= 1
########NEW FILE########
__FILENAME__ = SpecialMixerComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/APC40/SpecialMixerComponent.py
from _Framework.MixerComponent import MixerComponent
from SpecialChanStripComponent import SpecialChanStripComponent

class SpecialMixerComponent(MixerComponent):
    """ Special mixer class that uses return tracks alongside midi and audio tracks """

    def __init__(self, num_tracks):
        MixerComponent.__init__(self, num_tracks)

    def tracks_to_use(self):
        return tuple(self.song().visible_tracks) + tuple(self.song().return_tracks)

    def _create_strip(self):
        return SpecialChanStripComponent()
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom/config.py
from consts import *
from _Axiom.consts import PAD_TRANSLATION
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = (GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8,
 GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4)
VOLUME_CONTROLS = GENERIC_SLIDERS
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': -1,
 'PREVBANK': -1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'USB Axiom',
 'OUTPUTPORT': 'USB Axiom',
 'CHANNEL': 0,
 'PAD_TRANSLATION': PAD_TRANSLATION}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': GENERIC_SLI9}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = 23
GENERIC_PLAY = 24
GENERIC_REC = 25
GENERIC_LOOP = 20
GENERIC_RWD = 21
GENERIC_FFWD = 22
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 102
GENERIC_ENC2 = 103
GENERIC_ENC3 = 104
GENERIC_ENC4 = 105
GENERIC_ENC5 = 106
GENERIC_ENC6 = 107
GENERIC_ENC7 = 108
GENERIC_ENC8 = 109
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 110
GENERIC_SLI2 = 111
GENERIC_SLI3 = 112
GENERIC_SLI4 = 113
GENERIC_SLI5 = 114
GENERIC_SLI6 = 115
GENERIC_SLI7 = 116
GENERIC_SLI8 = 117
GENERIC_SLI9 = 118
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = 52
GENERIC_BUT2 = 53
GENERIC_BUT3 = 54
GENERIC_BUT4 = 55
GENERIC_BUT5 = 56
GENERIC_BUT6 = 57
GENERIC_BUT7 = 58
GENERIC_BUT8 = 59
GENERIC_BUT9 = 60
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = 80
GENERIC_PAD2 = 81
GENERIC_PAD3 = 82
GENERIC_PAD4 = 83
GENERIC_PAD5 = 85
GENERIC_PAD6 = 86
GENERIC_PAD7 = 87
GENERIC_PAD8 = 88
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = AxiomPro
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/AxiomPro/AxiomPro.py
from __future__ import with_statement
import Live
from _Framework.ControlSurface import ControlSurface
from _Framework.ControlElement import ControlElement
from _Framework.InputControlElement import *
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import EncoderElement
from _Framework.PhysicalDisplayElement import PhysicalDisplayElement
from _Framework.LogicalDisplaySegment import LogicalDisplaySegment
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.ChannelStripComponent import ChannelStripComponent
from _Framework.MixerComponent import MixerComponent
from _Framework.TransportComponent import TransportComponent
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from _Framework.ClipSlotComponent import ClipSlotComponent
from _Framework.SceneComponent import SceneComponent
from _Framework.SessionComponent import SessionComponent
from TransportViewModeSelector import TransportViewModeSelector
from SelectButtonModeSelector import SelectButtonModeSelector
from PageableDeviceComponent import PageableDeviceComponent
from EncoderMixerModeSelector import EncoderMixerModeSelector
from MixerOrDeviceModeSelector import MixerOrDeviceModeSelector
from NotifyingMixerComponent import NotifyingMixerComponent
from DisplayingMixerComponent import DisplayingMixerComponent
from PeekableEncoderElement import PeekableEncoderElement
SYSEX_START = (240, 0, 1, 5, 32, 127)
PAD_TRANSLATIONS = ((0, 2, 85, 15),
 (1, 2, 86, 15),
 (2, 2, 87, 15),
 (3, 2, 88, 15),
 (0, 3, 81, 15),
 (1, 3, 82, 15),
 (2, 3, 83, 15),
 (3, 3, 84, 15))

class AxiomPro(ControlSurface):
    """ Script for the M-Audio Axiom Pro """

    def __init__(self, c_instance):
        ControlSurface.__init__(self, c_instance)
        with self.component_guard():
            is_momentary = True
            self._device_selection_follows_track_selection = True
            self.set_pad_translations(PAD_TRANSLATIONS)
            self._suggested_input_port = 'HyperControl'
            self._suggested_output_port = 'HyperControl'
            self._display_on_button = ButtonElement(not is_momentary, MIDI_CC_TYPE, 15, 79)
            self._waiting_for_first_response = True
            mixer1 = DisplayingMixerComponent(0)
            mixer1.set_select_buttons(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 111), ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 110))
            mixer1.set_mute_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 12))
            mixer1.set_solo_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 13))
            mixer2 = NotifyingMixerComponent(8)
            mixer2.set_bank_buttons(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 15), ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 14))
            mixer2.master_strip().set_volume_control(SliderElement(MIDI_CC_TYPE, 15, 41))
            for index in range(8):
                mixer2.channel_strip(index).set_volume_control(SliderElement(MIDI_CC_TYPE, 15, 33 + index))

            device = PageableDeviceComponent()
            self.set_device_component(device)
            ffwd_button = ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 115)
            rwd_button = ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 114)
            loop_button = ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 113)
            transport = TransportComponent()
            transport.set_stop_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 116))
            transport.set_play_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 117))
            transport.set_record_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 118))
            session = SessionComponent(0, 0)
            transport_view_modes = TransportViewModeSelector(transport, session, ffwd_button, rwd_button, loop_button)
            select_button_modes = SelectButtonModeSelector(mixer2, tuple([ ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 49 + offset) for offset in range(8) ]))
            select_button_modes.set_mode_toggle(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 57))
            self._mixer_encoder_modes = EncoderMixerModeSelector(mixer2)
            encoders = []
            for offset in range(8):
                encoders.append(PeekableEncoderElement(MIDI_CC_TYPE, 15, 17 + offset, Live.MidiMap.MapMode.relative_smooth_two_compliment))
                encoders[-1].set_feedback_delay(-1)

            mixer_or_device = MixerOrDeviceModeSelector(self._mixer_encoder_modes, device, tuple(encoders), tuple([ ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 74 + offset) for offset in range(4) ]))
            mixer_or_device.set_mode_toggle(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 109))
            mixer_or_device.set_peek_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 78))
            self._track_display = PhysicalDisplayElement(8, 1)
            self._track_display.set_clear_all_message(SYSEX_START + (16, 247))
            self._track_display.set_message_parts(SYSEX_START + (17, 1, 0, 0), (247,))
            self._track_display.segment(0).set_data_source(mixer1.selected_strip().track_name_data_source())
            device_display = PhysicalDisplayElement(8, 1)
            device_display.set_message_parts(SYSEX_START + (17, 1, 0, 10), (247,))
            parameter_display = PhysicalDisplayElement(16, 1)
            parameter_display.set_message_parts(SYSEX_START + (17, 2, 0, 0), (247,))
            select_button_modes.set_mode_display(parameter_display)
            mixer1.set_display(parameter_display)
            mixer2.set_bank_display(parameter_display)
            page_displays = []
            for index in range(4):
                page_displays.append(PhysicalDisplayElement(5, 1))
                page_displays[-1].set_message_parts(SYSEX_START + (17,
                 4,
                 index,
                 0), (247,))

            encoder_display = PhysicalDisplayElement(80, 8)
            encoder_display.set_message_parts(SYSEX_START + (17, 3), (247,))
            for index in range(8):
                pos_id = tuple()
                if index != 0:
                    pos_id += (0,)
                if index > 3:
                    pos_id += (index % 4, 13)
                else:
                    pos_id += (index % 4, 0)
                encoder_display.segment(index).set_position_identifier(pos_id)

            mixer_or_device.set_displays(encoder_display, parameter_display, device_display, tuple(page_displays))
            for component in self.components:
                component.set_enabled(False)

    def refresh_state(self):
        ControlSurface.refresh_state(self)
        self._waiting_for_first_response = True
        self.schedule_message(10, self._send_midi, SYSEX_START + (32, 46, 247))

    def handle_sysex(self, midi_bytes):
        if midi_bytes[0:-2] == SYSEX_START + (32,):
            msg_id_byte = midi_bytes[-2]
            is_setup_response = msg_id_byte in (46, 38)
            has_sliders = msg_id_byte == 46
            if is_setup_response:
                if self._waiting_for_first_response:
                    self._waiting_for_first_response = False
                    self._display_on_button.send_value(0)
                    for component in self.components:
                        component.set_enabled(True)

                    self._display_on_button.send_value(127)
                    self._send_midi(SYSEX_START + (16, 247))
                    self._send_midi(SYSEX_START + (17, 3, 0, 1, 65, 98, 108, 101, 116, 111, 110, 32, 76, 105, 118, 101, 32, 67, 111, 110, 116, 114, 111, 108, 32, 0, 1, 4, 83, 117, 114, 102, 97, 99, 101, 32, 118, 49, 46, 48, 46, 48, 46, 247))
                self._mixer_encoder_modes.set_show_volume_page(not has_sliders)
                for display in self._displays:
                    display.set_block_messages(False)

                self.schedule_message(25, self._refresh_displays)
            elif msg_id_byte == 43:
                self._send_midi(SYSEX_START + (16, 247))
                for display in self._displays:
                    if display is self._track_display:
                        display.update()
                    else:
                        display.set_block_messages(True)

    def disconnect(self):
        ControlSurface.disconnect(self)
        self._send_midi(SYSEX_START + (32, 0, 247))
        self._send_midi(SYSEX_START + (16, 247))
        self._send_midi(SYSEX_START + (17, 3, 0, 4, 65, 98, 108, 101, 116, 111, 110, 32, 76, 105, 118, 101, 32, 67, 111, 110, 116, 114, 111, 108, 32, 0, 1, 4, 83, 117, 114, 102, 97, 99, 101, 32, 67, 108, 111, 115, 101, 100, 46, 247))
########NEW FILE########
__FILENAME__ = DisplayingMixerComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/AxiomPro/DisplayingMixerComponent.py
from _Framework.ButtonElement import ButtonElement
from _Framework.MixerComponent import MixerComponent
from _Framework.PhysicalDisplayElement import PhysicalDisplayElement

class DisplayingMixerComponent(MixerComponent):
    """ Special mixer class that displays the Mute/Solo state of the selected track """

    def __init__(self, num_tracks):
        MixerComponent.__init__(self, num_tracks)
        self._selected_tracks = []
        self._display = None
        self._mute_button = None
        self._solo_button = None
        self._register_timer_callback(self._on_timer)

    def disconnect(self):
        self._unregister_timer_callback(self._on_timer)
        self._selected_tracks = None
        MixerComponent.disconnect(self)
        self._display = None

    def set_display(self, display):
        raise isinstance(display, PhysicalDisplayElement) or AssertionError
        self._display = display

    def set_solo_button(self, button):
        if not (button == None or isinstance(button, ButtonElement) and button.is_momentary()):
            raise AssertionError
            self.selected_strip().set_solo_button(button)
            if self._solo_button != button:
                if self._solo_button != None:
                    self._solo_button.remove_value_listener(self._solo_value)
                self._solo_button = button
                self._solo_button != None and self._solo_button.add_value_listener(self._solo_value)
            self.update()

    def set_mute_button(self, button):
        if not (button == None or isinstance(button, ButtonElement) and button.is_momentary()):
            raise AssertionError
            self.selected_strip().set_mute_button(button)
            if self._mute_button != button:
                if self._mute_button != None:
                    self._mute_button.remove_value_listener(self._mute_value)
                self._mute_button = button
                self._mute_button != None and self._mute_button.add_value_listener(self._mute_value)
            self.update()

    def _on_timer(self):
        sel_track = None
        while len(self._selected_tracks) > 0:
            track = self._selected_tracks[-1]
            if track != None and track.has_midi_input and track.can_be_armed and not track.arm:
                sel_track = track
                break
            del self._selected_tracks[-1]

        if sel_track != None:
            found_recording_clip = False
            song = self.song()
            tracks = song.tracks
            if song.is_playing:
                check_arrangement = song.record_mode
                for track in tracks:
                    if track.can_be_armed and track.arm:
                        if check_arrangement:
                            found_recording_clip = True
                            break
                        else:
                            playing_slot_index = track.playing_slot_index
                            if playing_slot_index in range(len(track.clip_slots)):
                                slot = track.clip_slots[playing_slot_index]
                                if slot.has_clip and slot.clip.is_recording:
                                    found_recording_clip = True
                                    break

                if found_recording_clip or song.exclusive_arm:
                    for track in tracks:
                        if track.can_be_armed and track.arm and track != sel_track:
                            track.arm = False

                sel_track.arm = True
                sel_track.view.select_instrument()
        self._selected_tracks = []

    def _solo_value(self, value):
        if not self._solo_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self._display != None and self.song().view.selected_track not in (self.song().master_track, None):
                    track = value != 0 and self.song().view.selected_track
                    display_string = str(track.name) + ': Solo '
                    track.solo and display_string += 'On'
                else:
                    display_string += 'Off'
                self._display.display_message(display_string)
            else:
                self._display.update()

    def _mute_value(self, value):
        if not self._mute_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self._display != None and self.song().view.selected_track not in (self.song().master_track, None):
                    track = value != 0 and self.song().view.selected_track
                    display_string = str(track.name) + ': Mute '
                    track.mute and display_string += 'On'
                else:
                    display_string += 'Off'
                self._display.display_message(display_string)
            else:
                self._display.update()

    def _next_track_value(self, value):
        MixerComponent._next_track_value(self, value)
        self._selected_tracks.append(self.song().view.selected_track)

    def _prev_track_value(self, value):
        MixerComponent._prev_track_value(self, value)
        self._selected_tracks.append(self.song().view.selected_track)
########NEW FILE########
__FILENAME__ = EncoderMixerModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/AxiomPro/EncoderMixerModeSelector.py
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from _Framework.ButtonElement import ButtonElement
from _Framework.DisplayDataSource import DisplayDataSource
from NotifyingMixerComponent import NotifyingMixerComponent

class EncoderMixerModeSelector(ModeSelectorComponent):
    """ Class that reassigns encoders on the AxiomPro to different mixer functions """

    def __init__(self, mixer):
        raise isinstance(mixer, NotifyingMixerComponent) or AssertionError
        ModeSelectorComponent.__init__(self)
        self._mixer = mixer
        self._controls = None
        self._page_names = ('Vol', 'Pan', 'SendA', 'SendB', 'SendC')
        self._page_name_sources = None
        self._current_page_data_source = DisplayDataSource()
        self._parameter_sources = [ DisplayDataSource() for index in range(8) ]
        self._show_volume_page = False
        self._mixer.set_update_callback(self._mixer_assignments_changed)

    def disconnect(self):
        for button in self._modes_buttons:
            button.remove_value_listener(self._mode_value)

        self._mixer = None
        self._controls = None
        self._page_names = None
        self._page_name_sources = None
        self._current_page_data_source = None
        self._parameter_sources = None
        ModeSelectorComponent.disconnect(self)

    def set_modes_buttons(self, buttons):
        raise buttons == None or isinstance(buttons, tuple) or len(buttons) == self.number_of_modes() or AssertionError
        identify_sender = True
        for button in self._modes_buttons:
            button.remove_value_listener(self._mode_value)

        self._modes_buttons = []
        if buttons != None:
            for button in buttons:
                raise isinstance(button, ButtonElement) or AssertionError
                self._modes_buttons.append(button)
                button.add_value_listener(self._mode_value, identify_sender)

        self.set_mode(0)
        self.update()

    def set_controls(self, controls):
        raise controls == None or isinstance(controls, tuple) and len(controls) == 8 or AssertionError
        self._controls = controls
        self.set_mode(0)
        self.update()

    def set_show_volume_page(self, show):
        if not isinstance(show, type(False)):
            raise AssertionError
            if show != self._show_volume_page:
                self._show_volume_page = show
                if self._page_name_sources != None:
                    offset = 0
                    offset = self._show_volume_page or 1
                for idx in range(4):
                    self._page_name_sources[idx].set_display_string(self._page_names[idx + offset])

            self.update()

    def page_name_data_source(self, index):
        if not index in range(4):
            raise AssertionError
            if self._page_name_sources == None:
                self._page_name_sources = []
                offset = 0
                offset = self._show_volume_page or 1
            for idx in range(4):
                self._page_name_sources.append(DisplayDataSource())
                self._page_name_sources[idx].set_display_string(self._page_names[idx + offset])

        return self._page_name_sources[index]

    def parameter_data_source(self, index):
        raise self._controls != None or AssertionError
        raise index in range(len(self._controls)) or AssertionError
        return self._mixer.channel_strip(index).track_name_data_source()

    def current_page_data_source(self):
        return self._current_page_data_source

    def number_of_modes(self):
        return 4

    def update(self):
        if not self._modes_buttons != None:
            raise AssertionError
            if self.is_enabled() and self._controls != None:
                mode = self._mode_index
                self._show_volume_page or mode += 1
            self._current_page_data_source.set_display_string(self._page_names[mode])
            for index in range(len(self._controls)):
                self._controls[index].release_parameter()
                self._mixer.channel_strip(index).track_name_data_source().update()
                self._mixer.channel_strip(index).set_pan_control(None)
                self._mixer.channel_strip(index).set_send_controls((None, None, None))
                if self._show_volume_page:
                    self._mixer.channel_strip(index).set_volume_control(None)
                if not (mode == 0 and self._show_volume_page):
                    raise AssertionError
                    self._mixer.channel_strip(index).set_volume_control(self._controls[index])
                elif mode == 1:
                    self._mixer.channel_strip(index).set_pan_control(self._controls[index])
                elif mode == 2:
                    self._mixer.channel_strip(index).set_send_controls((self._controls[index], None, None))
                elif mode == 3:
                    self._mixer.channel_strip(index).set_send_controls((None, self._controls[index], None))
                elif not (mode == 4 and not self._show_volume_page):
                    raise AssertionError
                    self._mixer.channel_strip(index).set_send_controls((None, None, self._controls[index]))
                else:
                    print 'Invalid mode index'
                    raise False or AssertionError

    def _mixer_assignments_changed(self):
        self.update()
########NEW FILE########
__FILENAME__ = MixerOrDeviceModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/AxiomPro/MixerOrDeviceModeSelector.py
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from _Framework.ButtonElement import ButtonElement
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.PhysicalDisplayElement import PhysicalDisplayElement
from _Framework.LogicalDisplaySegment import LogicalDisplaySegment
from EncoderMixerModeSelector import EncoderMixerModeSelector
from PageableDeviceComponent import PageableDeviceComponent
from PeekableEncoderElement import PeekableEncoderElement

class MixerOrDeviceModeSelector(ModeSelectorComponent):
    """ Class that toggles between mixer and device modes """

    def __init__(self, mixer_modes, device, encoders, page_buttons):
        raise isinstance(mixer_modes, EncoderMixerModeSelector) or AssertionError
        raise isinstance(device, PageableDeviceComponent) or AssertionError
        raise isinstance(encoders, tuple) or AssertionError
        raise isinstance(page_buttons, tuple) or AssertionError
        ModeSelectorComponent.__init__(self)
        self._mixer_modes = mixer_modes
        self._device = device
        self._encoders = encoders
        self._page_buttons = page_buttons
        self._peek_button = None
        self._encoders_display = None
        self._value_display = None
        self._device_display = None
        self._page_displays = None
        self._device_dummy_source = DisplayDataSource()
        self._parameter_source = DisplayDataSource()
        self._device_dummy_source.set_display_string('Mixer')
        self._clean_value_display_in = -1
        self._must_update_encoder_display = False
        self._register_timer_callback(self._on_timer)
        identify_sender = True
        for encoder in self._encoders:
            encoder.add_value_listener(self._parameter_value, identify_sender)

        self.set_mode(0)

    def disconnect(self):
        self._unregister_timer_callback(self._on_timer)
        self._mixer_modes = None
        self._device = None
        self._encoders = None
        self._page_buttons = None
        self._encoders_display = None
        self._value_display = None
        self._device_display = None
        self._page_displays = None
        self._device_dummy_source = None
        self._parameter_source = None
        ModeSelectorComponent.disconnect(self)

    def set_displays(self, encoders_display, value_display, device_display, page_displays):
        if not isinstance(encoders_display, PhysicalDisplayElement):
            raise AssertionError
            raise isinstance(value_display, PhysicalDisplayElement) or AssertionError
            raise isinstance(device_display, PhysicalDisplayElement) or AssertionError
            raise isinstance(page_displays, tuple) or AssertionError
            self._encoders_display = encoders_display
            self._value_display = value_display
            self._device_display = device_display
            self._page_displays = page_displays
            self._value_display != None and self._value_display.segment(0).set_data_source(self._parameter_source)
        self.update()

    def set_peek_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._peek_button != button:
                if self._peek_button != None:
                    self._peek_button.remove_value_listener(self._peek_value)
                self._peek_button = button
                self._peek_button != None and self._peek_button.add_value_listener(self._peek_value)
            self.update()

    def number_of_modes(self):
        return 2

    def update(self):
        if self.is_enabled():
            if self._mode_index == 0:
                self._device.set_parameter_controls(None)
                self._device.set_bank_buttons(None)
                self._mixer_modes.set_controls(self._encoders)
                self._mixer_modes.set_modes_buttons(self._page_buttons)
                if self._device_display != None:
                    self._device_display.segment(0).set_data_source(self._mixer_modes.current_page_data_source())
                    self._device_display.update()
                if self._encoders_display != None:
                    for index in range(len(self._encoders)):
                        self._encoders_display.segment(index).set_data_source(self._mixer_modes.parameter_data_source(index))

                    self._encoders_display.update()
                if self._page_displays != None:
                    for index in range(len(self._page_displays)):
                        self._page_displays[index].segment(0).set_data_source(self._mixer_modes.page_name_data_source(index))
                        self._page_displays[index].update()

            elif self._mode_index == 1:
                self._mixer_modes.set_controls(None)
                self._mixer_modes.set_modes_buttons(None)
                self._device.set_parameter_controls(self._encoders)
                self._device.set_bank_buttons(self._page_buttons)
                if self._device_display != None:
                    self._device_display.segment(0).set_data_source(self._device.device_name_data_source())
                    self._device_display.update()
                if self._encoders_display != None:
                    for index in range(len(self._encoders)):
                        self._encoders_display.segment(index).set_data_source(self._device.parameter_name_data_source(index))

                    self._encoders_display.update()
                if self._page_displays != None:
                    for index in range(len(self._page_displays)):
                        self._page_displays[index].segment(0).set_data_source(self._device.page_name_data_source(index))
                        self._page_displays[index].update()

            else:
                print 'Invalid mode index'
                raise False or AssertionError

    def _parameter_value(self, value, control):
        if not control in self._encoders:
            raise AssertionError
            if self.is_enabled():
                parameter = control.mapped_parameter()
                parameter != None and self._parameter_source.set_display_string(parameter.name + ': ' + parameter.__str__())
            else:
                self._parameter_source.set_display_string('<unmapped>')
            self._clean_value_display_in = 20

    def _on_timer(self):
        if self._clean_value_display_in > 0:
            self._clean_value_display_in -= 1
            if self._clean_value_display_in == 0:
                self._parameter_source.set_display_string('')
                self._clean_value_display_in = -1
        if self._must_update_encoder_display:
            self._encoders_display.update()
            self._must_update_encoder_display = False

    def _peek_value(self, value):
        if not self._peek_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            new_peek_mode = value != 0
            peek_changed = False
            for encoder in self._encoders:
                if new_peek_mode != encoder.get_peek_mode():
                    encoder.set_peek_mode(new_peek_mode)
                    peek_changed = True

            self._must_update_encoder_display = peek_changed and self._encoders_display != None and True
########NEW FILE########
__FILENAME__ = NotifyingMixerComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/AxiomPro/NotifyingMixerComponent.py
from _Framework.MixerComponent import MixerComponent
from _Framework.PhysicalDisplayElement import PhysicalDisplayElement

class NotifyingMixerComponent(MixerComponent):
    """ Special mixer class that notifies an observer when reassigning parameters """

    def __init__(self, num_tracks):
        self._update_callback = None
        MixerComponent.__init__(self, num_tracks)
        self._bank_display = None

    def disconnect(self):
        MixerComponent.disconnect(self)
        self._update_callback = None

    def set_update_callback(self, callback):
        raise callback == None or dir(callback).count('im_func') is 1 or AssertionError
        self._update_callback = callback

    def set_bank_display(self, display):
        raise isinstance(display, PhysicalDisplayElement) or AssertionError
        self._bank_display = display

    def on_selected_track_changed(self):
        MixerComponent.on_selected_track_changed(self)
        selected_track = self.song().view.selected_track
        num_strips = len(self._channel_strips)
        track_index = selected_track in self._tracks_to_use() and list(self._tracks_to_use()).index(selected_track)
        new_offset = track_index - track_index % num_strips
        if not new_offset / num_strips == int(new_offset / num_strips):
            raise AssertionError
            self.set_track_offset(new_offset)

    def update(self):
        MixerComponent.update(self)
        if self._update_callback != None:
            self._update_callback()

    def _tracks_to_use(self):
        return tuple(self.song().visible_tracks) + tuple(self.song().return_tracks)

    def _reassign_tracks(self):
        MixerComponent._reassign_tracks(self)
        if self._update_callback != None:
            self._update_callback()

    def _bank_up_value(self, value):
        old_offset = int(self._track_offset)
        MixerComponent._bank_up_value(self, value)
        if self._bank_display != None:
            if value != 0 and old_offset != self._track_offset:
                min_track = self._track_offset + 1
                max_track = min(len(self._tracks_to_use()), min_track + len(self._channel_strips))
                self._bank_display.display_message('Tracks ' + str(min_track) + ' - ' + str(max_track))
            else:
                self._bank_display.update()

    def _bank_down_value(self, value):
        old_offset = int(self._track_offset)
        MixerComponent._bank_down_value(self, value)
        if self._bank_display != None:
            if value != 0 and old_offset != self._track_offset:
                min_track = self._track_offset + 1
                max_track = min(len(self._tracks_to_use()), min_track + len(self._channel_strips))
                self._bank_display.display_message('Tracks ' + str(min_track) + ' - ' + str(max_track))
            else:
                self._bank_display.update()
########NEW FILE########
__FILENAME__ = PageableDeviceComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/AxiomPro/PageableDeviceComponent.py
import Live
from _Generic.Devices import *
from _Framework.DeviceComponent import DeviceComponent
from _Framework.EncoderElement import EncoderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.DisplayDataSource import DisplayDataSource
SPECIAL_NAME_DICT = {'InstrumentImpulse': (('Pad1', 'Pad2'),
                       ('Pad3', 'Pad4'),
                       ('Pad5', 'Pad6'),
                       ('Pad7', 'Pad8')),
 'Operator': (('OscA', 'OscB', 'OscC', 'OscD'),
              ('LFO', 'Fltr'),
              ('Pitch',),
              ('Glob.',)),
 'MultiSampler': (('Vol.', 'Pitch'),
                  ('Fltr', 'FEnv'),
                  ('LFO1', 'LFO2', 'LFO3'),
                  ('Osc',)),
 'UltraAnalog': (('Osc',),
                 ('Fltr', 'FEnv', 'FMod'),
                 ('VEnv', 'Mix'),
                 ('Out',)),
 'LoungeLizard': (('Ma&Ti',),
                  ('To&Da',),
                  ('Pick', 'Mod'),
                  ('Glob.',)),
 'StringStudio': (('Ex&St', 'Damp'),
                  ('Te&Pi', 'Body'),
                  ('Fltr', 'LFO'),
                  ('Glob.', 'Vibr')),
 'Eq8': (('Bands', 'EQ1-3'),
         ('Freq', 'Gain'),
         ('Reso', 'Fltr'),
         ('Glob.',))}
SPECIAL_DEVICE_DICT = {'InstrumentImpulse': [(IMP_BANK1, IMP_BANK2),
                       (IMP_BANK3, IMP_BANK4),
                       (IMP_BANK5, IMP_BANK6),
                       (IMP_BANK7, IMP_BANK8)],
 'Operator': [(OPR_BANK1,
               OPR_BANK2,
               OPR_BANK3,
               OPR_BANK4),
              (OPR_BANK5, OPR_BANK6),
              (OPR_BANK7,),
              (OPR_BANK8,)],
 'MultiSampler': [(SAM_BANK1, SAM_BANK8),
                  (SAM_BANK2, SAM_BANK3),
                  (SAM_BANK4, SAM_BANK5, SAM_BANK6),
                  (SAM_BANK7,)],
 'UltraAnalog': [(ALG_BANK1,),
                 (ALG_BANK2, ALG_BANK3, ALG_BANK4),
                 (ALG_BANK5, ALG_BANK6),
                 (ALG_BANK7,)],
 'LoungeLizard': [(ELC_BANK1,),
                  (ELC_BANK2,),
                  (ELC_BANK3, ELC_BANK4),
                  (ELC_BANK5,)],
 'StringStudio': [(TNS_BANK1, TNS_BANK2),
                  (TNS_BANK3, TNS_BANK4),
                  (TNS_BANK6, TNS_BANK7),
                  (TNS_BANK8, TNS_BANK5)],
 'Eq8': [(EQ8_BANK1, EQ8_BANK7),
         (EQ8_BANK2, EQ8_BANK3),
         (EQ8_BANK4, EQ8_BANK5),
         (EQ8_BANK6,)]}

class PageableDeviceComponent(DeviceComponent):
    """ Class representing a device on the AxiomPro """

    def __init__(self):
        DeviceComponent.__init__(self)
        self._parameter_value_data_source = DisplayDataSource()
        self._parameter_name_data_sources = []
        self._page_name_data_sources = []
        self._page_index = [0,
         0,
         0,
         0]
        for new_index in range(8):
            self._parameter_name_data_sources.append(DisplayDataSource())
            self._page_name_data_sources.append(DisplayDataSource())
            self._parameter_name_data_sources[-1].set_display_string(' - ')
            self._page_name_data_sources[-1].set_display_string(' - ')

    def disconnect(self):
        self._parameter_value_data_source = None
        self._parameter_name_data_sources = None
        self._page_name_data_sources = None
        DeviceComponent.disconnect(self)

    def set_device(self, device):
        DeviceComponent.set_device(self, device)
        if self._device == None:
            for source in self._parameter_name_data_sources:
                source.set_display_string(' - ')

            for source in self._page_name_data_sources:
                source.set_display_string(' - ')

    def set_bank_buttons(self, buttons):
        raise buttons == None or isinstance(buttons, tuple) and len(buttons) == 4 or AssertionError
        DeviceComponent.set_bank_buttons(self, buttons)

    def set_parameter_controls(self, controls):
        raise controls == None or isinstance(controls, tuple) and len(controls) == 8 or AssertionError
        if self._parameter_controls != None:
            for control in self._parameter_controls:
                if self._device != None:
                    control.release_parameter()

        self._parameter_controls = controls
        if self._parameter_controls != None:
            for control in self._parameter_controls:
                raise control != None or AssertionError
                raise isinstance(control, EncoderElement) or AssertionError

        self.update()

    def parameter_value_data_source(self):
        return self._parameter_value_data_source

    def parameter_name_data_source(self, index):
        raise index in range(8) or AssertionError
        return self._parameter_name_data_sources[index]

    def page_name_data_source(self, index):
        raise index in range(8) or AssertionError
        return self._page_name_data_sources[index]

    def _bank_value(self, value, button):
        if not self._bank_buttons != None:
            raise AssertionError
            raise value != None or AssertionError
            raise button != None or AssertionError
            raise isinstance(value, int) or AssertionError
            raise isinstance(button, ButtonElement) or AssertionError
            if not list(self._bank_buttons).count(button) == 1:
                raise AssertionError
                if self.is_enabled():
                    if not button.is_momentary() or value is not 0:
                        bank = list(self._bank_buttons).index(button)
                        self._bank_index = self._device != None and bank != self._bank_index and bank
                    else:
                        self._page_index[bank] += 1
                    self.update()

    def _assign_parameters(self):
        if not self.is_enabled():
            raise AssertionError
            raise self._device != None or AssertionError
            raise self._parameter_controls != None or AssertionError
            self._device.class_name in SPECIAL_DEVICE_DICT.keys() and self.__assign_parameters_special()
        elif self._device.class_name in DEVICE_DICT.keys():
            self.__assign_parameters_normal()
        else:
            self.__assign_parameters_plugin()
        self._parameter_value_data_source.set_display_string('')
        for index in range(len(self._parameter_controls)):
            if self._parameter_controls[index].mapped_parameter() != None:
                self._parameter_name_data_sources[index].set_display_string(self._parameter_controls[index].mapped_parameter().name)
            else:
                self._parameter_name_data_sources[index].set_display_string(' - ')

    def __assign_parameters_special(self):
        """ Assign the controls to the parameters of a device with more than 4 pages """
        banks = SPECIAL_DEVICE_DICT[self._device.class_name]
        bank_names = SPECIAL_NAME_DICT[self._device.class_name]
        pages = banks[self._bank_index]
        self._page_index[self._bank_index] %= len(pages)
        self._bank_name = bank_names[self._bank_index][self._page_index[self._bank_index]]
        page = pages[self._page_index[self._bank_index]]
        raise len(page) >= len(self._parameter_controls) or AssertionError
        for index in range(len(self._parameter_controls)):
            parameter = get_parameter_by_name(self._device, page[index])
            if parameter != None:
                self._parameter_controls[index].connect_to(parameter)
            else:
                self._parameter_controls[index].release_parameter()

        for index in range(len(self._page_name_data_sources)):
            if index < len(bank_names):
                page_names = bank_names[index]
                if index == self._bank_index:
                    self._page_name_data_sources[index].set_display_string(page_names[(self._page_index[index] + 1) % len(page_names)])
                else:
                    self._page_name_data_sources[index].set_display_string(page_names[self._page_index[index] % len(page_names)])
            else:
                self._page_name_data_sources[index].set_display_string(' - ')

    def __assign_parameters_normal(self):
        """ Assign the controls to the parameters of a device with 4 pages or less """
        if not self._device.class_name in DEVICE_BOB_DICT.keys():
            raise AssertionError
            self._page_index[self._bank_index] = 0
            banks = DEVICE_DICT[self._device.class_name]
            bank_names = []
            if len(banks) > self._bank_index:
                if self._device.class_name in BANK_NAME_DICT.keys() and len(BANK_NAME_DICT[self._device.class_name]) > 1:
                    bank_names = BANK_NAME_DICT[self._device.class_name]
                bank = banks[self._bank_index]
                self._bank_name = self._bank_index in range(len(bank_names)) and bank_names[self._bank_index]
            else:
                self._bank_name = 'Bank ' + str(self._bank_index + 1)
            raise len(bank) >= len(self._parameter_controls) or AssertionError
            for index in range(len(self._parameter_controls)):
                parameter = get_parameter_by_name(self._device, bank[index])
                if parameter != None:
                    self._parameter_controls[index].connect_to(parameter)
                else:
                    self._parameter_controls[index].release_parameter()

        for index in range(len(self._page_name_data_sources)):
            if index < len(bank_names):
                self._page_name_data_sources[index].set_display_string(bank_names[index])
            else:
                self._page_name_data_sources[index].set_display_string(' - ')

    def __assign_parameters_plugin(self):
        """ Assign the controls to the parameters of a plugin """
        num_controls = len(self._parameter_controls)
        num_banks = min(8, number_of_parameter_banks(self._device))
        num_double_pages = 0
        num_double_pages_before = 0
        parameters_to_use = self._device.parameters[1:]
        self._bank_name = 'Bank ' + str(self._bank_index + 1)
        if num_banks > 4:
            num_double_pages = num_banks - 4
        if self._bank_index < num_double_pages:
            self._page_index[self._bank_index] %= 2
            num_double_pages_before = self._bank_index
        else:
            self._page_index[self._bank_index] = 0
            num_double_pages_before = num_double_pages
        if self._bank_index + num_double_pages_before < num_banks:
            bank_offset = (self._bank_index + num_double_pages_before) * num_controls
            page_offset = bank_offset + self._page_index[self._bank_index] * num_controls
            for control in self._parameter_controls:
                if page_offset < len(parameters_to_use):
                    control.connect_to(parameters_to_use[page_offset])
                else:
                    control.release_parameter()
                page_offset += 1

            bank_names = []
            parameter_offset = 0
            for index in range(4):
                display_string = ' - '
                if index < num_banks:
                    if index < num_double_pages:
                        if not (index == self._bank_index and self._page_index[index] == 0):
                            if index != self._bank_index:
                                add_offset_before = self._page_index[index] != 0
                                add_offset_before and parameter_offset += num_controls
                            display_string = str(parameter_offset + 1).rjust(2) + '-' + str(parameter_offset + num_controls).rjust(2)
                            add_offset_before or parameter_offset += num_controls
                    else:
                        display_string = str(parameter_offset + 1).rjust(2) + '-' + str(parameter_offset + num_controls).rjust(2)
                self._page_name_data_sources[index].set_display_string(display_string)
                parameter_offset += num_controls
########NEW FILE########
__FILENAME__ = PeekableEncoderElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/AxiomPro/PeekableEncoderElement.py
import Live
from _Framework.EncoderElement import EncoderElement
from _Framework.InputControlElement import *

class PeekableEncoderElement(EncoderElement):
    """ Encoder that can be connected and disconnected to a specific parameter """

    def __init__(self, msg_type, channel, identifier, map_mode):
        EncoderElement.__init__(self, msg_type, channel, identifier, map_mode)
        self._peek_mode = False

    def set_peek_mode(self, peek_mode):
        if not isinstance(peek_mode, type(False)):
            raise AssertionError
            self._peek_mode = self._peek_mode != peek_mode and peek_mode
            self._request_rebuild()

    def get_peek_mode(self):
        return self._peek_mode

    def install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback):
        current_parameter = self._parameter_to_map_to
        if self._peek_mode:
            self._parameter_to_map_to = None
        InputControlElement.install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback)
        self._parameter_to_map_to = current_parameter
########NEW FILE########
__FILENAME__ = SelectButtonModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/AxiomPro/SelectButtonModeSelector.py
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from _Framework.ButtonElement import ButtonElement
from _Framework.PhysicalDisplayElement import PhysicalDisplayElement
from _Framework.MixerComponent import MixerComponent

class SelectButtonModeSelector(ModeSelectorComponent):
    """ Class that reassigns buttons on the AxiomPro to different mixer functions """

    def __init__(self, mixer, buttons):
        raise isinstance(mixer, MixerComponent) or AssertionError
        raise isinstance(buttons, tuple) or AssertionError
        raise len(buttons) == 8 or AssertionError
        ModeSelectorComponent.__init__(self)
        self._mixer = mixer
        self._buttons = buttons
        self._mode_display = None
        self._mode_index = 0
        self.update()

    def disconnect(self):
        self._mixer = None
        self._buttons = None
        self._mode_display = None

    def set_mode_display(self, display):
        raise isinstance(display, PhysicalDisplayElement) or AssertionError
        self._mode_display = display

    def number_of_modes(self):
        return 4

    def update(self):
        if self.is_enabled():
            for index in range(len(self._buttons)):
                if self._mode_index == 0:
                    self._mixer.channel_strip(index).set_select_button(self._buttons[index])
                    self._mixer.channel_strip(index).set_arm_button(None)
                    self._mixer.channel_strip(index).set_mute_button(None)
                    self._mixer.channel_strip(index).set_solo_button(None)
                elif self._mode_index == 1:
                    self._mixer.channel_strip(index).set_select_button(None)
                    self._mixer.channel_strip(index).set_arm_button(self._buttons[index])
                    self._mixer.channel_strip(index).set_mute_button(None)
                    self._mixer.channel_strip(index).set_solo_button(None)
                elif self._mode_index == 2:
                    self._mixer.channel_strip(index).set_select_button(None)
                    self._mixer.channel_strip(index).set_arm_button(None)
                    self._mixer.channel_strip(index).set_mute_button(self._buttons[index])
                    self._mixer.channel_strip(index).set_solo_button(None)
                elif self._mode_index == 3:
                    self._mixer.channel_strip(index).set_select_button(None)
                    self._mixer.channel_strip(index).set_arm_button(None)
                    self._mixer.channel_strip(index).set_mute_button(None)
                    self._mixer.channel_strip(index).set_solo_button(self._buttons[index])
                else:
                    print 'Invalid mode index'
                    raise False or AssertionError

    def _toggle_value(self, value):
        if not self._mode_toggle.is_momentary():
            raise AssertionError
            ModeSelectorComponent._toggle_value(self, value)
            if value != 0 and self._mode_display is not None:
                mode_name = ''
                mode_name = self._mode_index == 0 and 'Select'
            elif self._mode_index == 1:
                mode_name = 'Arm'
            elif self._mode_index == 2:
                mode_name = 'Mute'
            elif self._mode_index == 3:
                mode_name = 'Solo'
            self._mode_display.display_message(mode_name)
        else:
            self._mode_display.update()
########NEW FILE########
__FILENAME__ = TransportViewModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/AxiomPro/TransportViewModeSelector.py
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from _Framework.ButtonElement import ButtonElement
from _Framework.TransportComponent import TransportComponent
from _Framework.SessionComponent import SessionComponent

class TransportViewModeSelector(ModeSelectorComponent):
    """ Class that reassigns specific buttons based on the views visible in Live """

    def __init__(self, transport, session, ffwd_button, rwd_button, loop_button):
        raise isinstance(transport, TransportComponent) or AssertionError
        raise isinstance(session, SessionComponent) or AssertionError
        raise isinstance(ffwd_button, ButtonElement) or AssertionError
        raise isinstance(rwd_button, ButtonElement) or AssertionError
        raise isinstance(loop_button, ButtonElement) or AssertionError
        ModeSelectorComponent.__init__(self)
        self._transport = transport
        self._session = session
        self._ffwd_button = ffwd_button
        self._rwd_button = rwd_button
        self._loop_button = loop_button
        self.application().view.add_is_view_visible_listener('Session', self._on_view_changed)
        self.update()

    def disconnect(self):
        ModeSelectorComponent.disconnect(self)
        self._transport = None
        self._session = None
        self._ffwd_button = None
        self._rwd_button = None
        self._loop_button = None
        self.application().view.remove_is_view_visible_listener('Session', self._on_view_changed)

    def update(self):
        if self.is_enabled():
            if self._mode_index == 0:
                self._transport.set_seek_buttons(self._ffwd_button, self._rwd_button)
                self._transport.set_loop_button(self._loop_button)
                self._session.set_select_buttons(None, None)
                self._session.selected_scene().set_launch_button(None)
            else:
                self._transport.set_seek_buttons(None, None)
                self._transport.set_loop_button(None)
                self._session.set_select_buttons(self._ffwd_button, self._rwd_button)
                self._session.selected_scene().set_launch_button(self._loop_button)

    def _on_view_changed(self):
        if self.application().view.is_view_visible('Session'):
            self._mode_index = 1
        else:
            self._mode_index = 0
        self.update()
########NEW FILE########
__FILENAME__ = Axiom
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_25_Classic/Axiom.py
from _Axiom.consts import *
from _Axiom.Transport import Transport
from _Axiom.Pads import Pads
from _Axiom.Encoders import Encoders
import Live
import MidiRemoteScript

class Axiom:
    """ A controller script for the M-Audio Axiom Keyboard/Controller series """

    def __init__(self, c_instance):
        self.__c_instance = c_instance
        self.__current_track = self.song().view.selected_track
        self.__current_device = self.__current_track.view.selected_device
        self.song().add_visible_tracks_listener(self.__tracks_changed)
        self.__transport_unit = Transport(self)
        self.__encoder_unit = Encoders(self, False)
        self.__pad_unit = Pads(self)

    def application(self):
        """returns a reference to the application that we are running in
        """
        return Live.Application.get_application()

    def song(self):
        """returns a reference to the Live song instance that we do control
        """
        return self.__c_instance.song()

    def disconnect(self):
        """Live -> Script
        Called right before we get disconnected from Live.
        """
        self.song().remove_visible_tracks_listener(self.__tracks_changed)
        self.__encoder_unit.disconnect()

    def can_lock_to_devices(self):
        return True

    def suggest_input_port(self):
        """Live -> Script
        Live can ask the script for an input port name to find a suitable one.
        """
        return str('USB Axiom 25')

    def suggest_output_port(self):
        """Live -> Script
        Live can ask the script for an output port name to find a suitable one.
        """
        return str('USB Axiom 25')

    def suggest_map_mode(self, cc_no, channel):
        """Live -> Script
        Live can ask the script for a suitable mapping mode for a given CC.
        """
        suggested_map_mode = Live.MidiMap.MapMode.absolute
        if cc_no in AXIOM_ENCODERS:
            suggested_map_mode = Live.MidiMap.MapMode.relative_smooth_binary_offset
        return suggested_map_mode

    def show_message(self, message):
        self.__c_instance.show_message(message)

    def supports_pad_translation(self):
        return True

    def connect_script_instances(self, instanciated_scripts):
        """Called by the Application as soon as all scripts are initialized.
        You can connect yourself to other running scripts here, as we do it
        connect the extension modules (MackieControlXTs).
        """
        pass

    def request_rebuild_midi_map(self):
        """Script -> Live
        When the internal MIDI controller has changed in a way that you need to rebuild
        the MIDI mappings, request a rebuild by calling this function
        This is processed as a request, to be sure that its not too often called, because
        its time-critical.
        """
        self.__c_instance.request_rebuild_midi_map()

    def send_midi(self, midi_event_bytes):
        """Script -> Live
        Use this function to send MIDI events through Live to the _real_ MIDI devices
        that this script is assigned to.
        """
        self.__c_instance.send_midi(midi_event_bytes)

    def refresh_state(self):
        """Live -> Script
        Send out MIDI to completely update the attached MIDI controller.
        Will be called when requested by the user, after for example having reconnected
        the MIDI cables...
        """
        pass

    def build_midi_map(self, midi_map_handle):
        """Live -> Script
        Build DeviceParameter Mappings, that are processed in Audio time, or
        forward MIDI messages explicitly to our receive_midi_functions.
        Which means that when you are not forwarding MIDI, nor mapping parameters, you will
        never get any MIDI messages at all.
        """
        script_handle = self.__c_instance.handle()
        for channel in range(4):
            Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, channel, EXP_PEDAL_CC)

        self.__transport_unit.build_midi_map(script_handle, midi_map_handle)
        self.__encoder_unit.build_midi_map(script_handle, midi_map_handle)
        self.__pad_unit.build_midi_map(script_handle, midi_map_handle)
        self.__c_instance.set_pad_translation(PAD_TRANSLATION)

    def update_display(self):
        """Live -> Script
        Aka on_timer. Called every 100 ms and should be used to update display relevant
        parts of the controller
        """
        if self.__transport_unit:
            self.__transport_unit.refresh_state()

    def receive_midi(self, midi_bytes):
        """Live -> Script
        MIDI messages are only received through this function, when explicitly
        forwarded in 'build_midi_map'.
        """
        if midi_bytes[0] & 240 == CC_STATUS:
            channel = midi_bytes[0] & 15
            cc_no = midi_bytes[1]
            cc_value = midi_bytes[2]
            if list(AXIOM_TRANSPORT).count(cc_no) > 0:
                self.__transport_unit.receive_midi_cc(cc_no, cc_value)
            elif list(AXIOM_ENCODERS).count(cc_no) > 0:
                self.__encoder_unit.receive_midi_cc(cc_no, cc_value, channel)
            elif list(AXIOM_PADS).count(cc_no) > 0:
                self.__pad_unit.receive_midi_cc(cc_no, cc_value, channel)
            elif cc_no == EXP_PEDAL_CC:
                self.__encoder_unit.set_modifier(cc_value == 0)
                self.request_rebuild_midi_map()
        elif midi_bytes[0] == 240:
            pass

    def lock_to_device(self, device):
        self.__encoder_unit.lock_to_device(device)

    def unlock_from_device(self, device):
        self.__encoder_unit.unlock_from_device(device)

    def set_appointed_device(self, device):
        self.__encoder_unit.set_appointed_device(device)

    def __tracks_changed(self):
        self.request_rebuild_midi_map()

    def bank_changed(self, new_bank):
        if self.__encoder_unit.set_bank(new_bank):
            self.request_rebuild_midi_map()

    def restore_bank(self, bank):
        self.__encoder_unit.restore_bank(bank)
        self.request_rebuild_midi_map()

    def instance_identifier(self):
        return self.__c_instance.instance_identifier()
########NEW FILE########
__FILENAME__ = Axiom
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_49_61_Classic/Axiom.py
from _Axiom.consts import *
from _Axiom.Transport import Transport
from _Axiom.Pads import Pads
from _Axiom.Encoders import Encoders
from SliderSection import SliderSection
import Live
import MidiRemoteScript

class Axiom:
    """ A controller script for the M-Audio Axiom Keyboard/Controller series """

    def __init__(self, c_instance):
        self.__c_instance = c_instance
        self.__current_track = self.song().view.selected_track
        self.__current_device = self.__current_track.view.selected_device
        self.song().add_visible_tracks_listener(self.__tracks_changed)
        self.__transport_unit = Transport(self)
        self.__encoder_unit = Encoders(self, True)
        self.__slider_unit = SliderSection(self)
        self.__pad_unit = Pads(self)

    def application(self):
        """returns a reference to the application that we are running in
        """
        return Live.Application.get_application()

    def song(self):
        """returns a reference to the Live song instance that we do control
        """
        return self.__c_instance.song()

    def disconnect(self):
        """Live -> Script
        Called right before we get disconnected from Live.
        """
        self.song().remove_visible_tracks_listener(self.__tracks_changed)
        self.__encoder_unit.disconnect()

    def can_lock_to_devices(self):
        return True

    def suggest_input_port(self):
        """Live -> Script
        Live can ask the script for an input port name to find a suitable one.
        """
        return str('USB Axiom')

    def suggest_output_port(self):
        """Live -> Script
        Live can ask the script for an output port name to find a suitable one.
        """
        return str('USB Axiom')

    def suggest_map_mode(self, cc_no, channel):
        """Live -> Script
        Live can ask the script for a suitable mapping mode for a given CC.
        """
        suggested_map_mode = Live.MidiMap.MapMode.absolute
        if cc_no in AXIOM_ENCODERS:
            suggested_map_mode = Live.MidiMap.MapMode.relative_smooth_binary_offset
        return suggested_map_mode

    def show_message(self, message):
        self.__c_instance.show_message(message)

    def supports_pad_translation(self):
        return True

    def connect_script_instances(self, instanciated_scripts):
        """Called by the Application as soon as all scripts are initialized.
        You can connect yourself to other running scripts here, as we do it
        connect the extension modules (MackieControlXTs).
        """
        pass

    def request_rebuild_midi_map(self):
        """Script -> Live
        When the internal MIDI controller has changed in a way that you need to rebuild
        the MIDI mappings, request a rebuild by calling this function
        This is processed as a request, to be sure that its not too often called, because
        its time-critical.
        """
        self.__c_instance.request_rebuild_midi_map()

    def send_midi(self, midi_event_bytes):
        """Script -> Live
        Use this function to send MIDI events through Live to the _real_ MIDI devices
        that this script is assigned to.
        """
        self.__c_instance.send_midi(midi_event_bytes)

    def refresh_state(self):
        """Live -> Script
        Send out MIDI to completely update the attached MIDI controller.
        Will be called when requested by the user, after for example having reconnected
        the MIDI cables...
        """
        pass

    def build_midi_map(self, midi_map_handle):
        """Live -> Script
        Build DeviceParameter Mappings, that are processed in Audio time, or
        forward MIDI messages explicitly to our receive_midi_functions.
        Which means that when you are not forwarding MIDI, nor mapping parameters, you will
        never get any MIDI messages at all.
        """
        script_handle = self.__c_instance.handle()
        self.__transport_unit.build_midi_map(script_handle, midi_map_handle)
        self.__encoder_unit.build_midi_map(script_handle, midi_map_handle)
        self.__slider_unit.build_midi_map(script_handle, midi_map_handle)
        self.__pad_unit.build_midi_map(script_handle, midi_map_handle)
        self.__c_instance.set_pad_translation(PAD_TRANSLATION)

    def update_display(self):
        """Live -> Script
        Aka on_timer. Called every 100 ms and should be used to update display relevant
        parts of the controller
        """
        if self.__transport_unit:
            self.__transport_unit.refresh_state()

    def receive_midi(self, midi_bytes):
        """Live -> Script
        MIDI messages are only received through this function, when explicitly
        forwarded in 'build_midi_map'.
        """
        if midi_bytes[0] & 240 == CC_STATUS:
            channel = midi_bytes[0] & 15
            cc_no = midi_bytes[1]
            cc_value = midi_bytes[2]
            if list(AXIOM_TRANSPORT).count(cc_no) > 0:
                self.__transport_unit.receive_midi_cc(cc_no, cc_value)
            elif list(AXIOM_BUTTONS).count(cc_no) > 0:
                self.__slider_unit.receive_midi_cc(cc_no, cc_value, channel)
            elif list(AXIOM_ENCODERS).count(cc_no) > 0:
                self.__encoder_unit.receive_midi_cc(cc_no, cc_value, channel)
            elif list(AXIOM_PADS).count(cc_no) > 0:
                self.__pad_unit.receive_midi_cc(cc_no, cc_value, channel)
        elif midi_bytes[0] == 240:
            pass

    def lock_to_device(self, device):
        self.__encoder_unit.lock_to_device(device)

    def unlock_from_device(self, device):
        self.__encoder_unit.unlock_from_device(device)

    def set_appointed_device(self, device):
        self.__encoder_unit.set_appointed_device(device)

    def __tracks_changed(self):
        self.request_rebuild_midi_map()

    def bank_changed(self, new_bank):
        if self.__encoder_unit.set_bank(new_bank):
            self.request_rebuild_midi_map()

    def restore_bank(self, bank):
        self.__encoder_unit.restore_bank(bank)
        self.request_rebuild_midi_map()

    def instance_identifier(self):
        return self.__c_instance.instance_identifier()
########NEW FILE########
__FILENAME__ = SliderSection
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_49_61_Classic/SliderSection.py
import Live
from _Axiom.consts import *

class SliderSection:
    """ Class representing the sliders and Zone/Group-buttons on the
        Axiom 49 & 61 Controllers
    """

    def __init__(self, parent):
        self.__parent = parent
        self.__mod_pressed = False

    def build_midi_map(self, script_handle, midi_map_handle):
        feedback_rule = Live.MidiMap.CCFeedbackRule()
        needs_takeover = True
        feedback_rule.channel = 0
        feedback_rule.cc_no = AXIOM_SLI9
        feedback_rule.cc_value_map = tuple()
        feedback_rule.delay_in_ms = -1.0
        for channel in range(16):
            Live.MidiMap.map_midi_cc_with_feedback_map(midi_map_handle, self.__parent.song().master_track.mixer_device.volume, channel, AXIOM_SLI9, Live.MidiMap.MapMode.absolute_14_bit, feedback_rule, not needs_takeover)

        for channel in range(4):
            Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, channel, AXIOM_BUT9)
            for slider in range(8):
                tracks = self.__parent.song().visible_tracks
                track_index = slider + channel * 8
                if len(tracks) > track_index:
                    feedback_rule.channel = 0
                    feedback_rule.cc_no = AXIOM_SLIDERS[slider]
                    feedback_rule.cc_value_map = tuple()
                    feedback_rule.delay_in_ms = -1.0
                    Live.MidiMap.map_midi_cc_with_feedback_map(midi_map_handle, tracks[track_index].mixer_device.volume, channel, AXIOM_SLIDERS[slider], Live.MidiMap.MapMode.absolute_14_bit, feedback_rule, not needs_takeover)
                    Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, channel, AXIOM_BUTTONS[slider])
                else:
                    break

    def receive_midi_cc(self, cc_no, cc_value, channel):
        if list(AXIOM_BUTTONS).count(cc_no) > 0:
            button_index = list(AXIOM_BUTTONS).index(cc_no)
            if cc_no == AXIOM_BUT9:
                self.__mod_pressed = cc_value == 127
            elif button_index in range(8):
                tracks = self.__parent.song().visible_tracks
                track_index = button_index + 8 * channel
                if len(tracks) > track_index:
                    track = tracks[track_index]
                    if track and track.can_be_armed:
                        if not self.__mod_pressed:
                            track.mute = not track.mute
                        else:
                            track.arm = not track.arm
                            if self.__parent.song().exclusive_arm:
                                for t in tracks:
                                    if t.can_be_armed and t.arm and not t == track:
                                        t.arm = False

                            if track.arm:
                                if track.view.select_instrument():
                                    self.__parent.song().view.selected_track = track
########NEW FILE########
__FILENAME__ = Axiom_AIR_25_49_61
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/Axiom_AIR_25_49_61.py
from __future__ import with_statement
import Live
from Live import MidiMap
from _Framework.ControlSurface import ControlSurface
from _Framework.InputControlElement import InputControlElement, MIDI_CC_TYPE, MIDI_NOTE_TYPE
from _Framework.ButtonElement import ButtonElement
from _Framework.PhysicalDisplayElement import PhysicalDisplayElement
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.TransportComponent import TransportComponent
from ConfigurableButtonElement import ConfigurableButtonElement
from IdentifyingEncoderElement import IdentifyingEncoderElement
from NumericalDisplayElement import NumericalDisplayElement
from FaderModeSelector import FaderModeSelector
from FaderButtonModeSelector import FaderButtonModeSelector
from SingleFaderButtonModeSelector import SingleFaderButtonModeSelector
from EncoderModeSelector import EncoderModeSelector
from MainModeSelector import MainModeSelector
from DeviceNavComponent import DeviceNavComponent
from SpecialSessionComponent import SpecialSessionComponent
from SpecialMixerComponent import SpecialMixerComponent
from BestBankDeviceComponent import BestBankDeviceComponent
from TransportViewModeSelector import TransportViewModeSelector
from consts import *

def create_configurable_button(identifier, name, send_channel_offset = 0, identifier_send_offset = 0, send_msg_type = None):
    button = ConfigurableButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, GLOBAL_CHANNEL, identifier, GLOBAL_SEND_CHANNEL + send_channel_offset, identifier_send_offset, send_msg_type)
    button.name = name
    return button


def create_button(identifier, name):
    button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, GLOBAL_CHANNEL, identifier)
    button.name = name
    return button


def create_encoder(identifier, name):
    encoder = IdentifyingEncoderElement(MIDI_CC_TYPE, GLOBAL_CHANNEL, identifier, MidiMap.MapMode.relative_smooth_two_compliment, 12)
    encoder.name = name
    encoder.set_feedback_delay(-1)
    return encoder


def create_slider(identifier, name):
    slider = IdentifyingEncoderElement(MIDI_CC_TYPE, GLOBAL_CHANNEL, identifier, MidiMap.MapMode.absolute)
    slider.name = name
    slider.set_feedback_delay(-1)
    return slider


class Axiom_AIR_25_49_61(ControlSurface):
    """ Script for the M-Audio Axiom A.I.R. 25, 49 and 61 """

    def __init__(self, c_instance):
        ControlSurface.__init__(self, c_instance)
        self._alt_device_component = None
        with self.component_guard():
            self.set_pad_translations(PAD_TRANSLATIONS)
            self._device_selection_follows_track_selection = True
            self._suggested_input_port = 'HyperControl'
            self._suggested_output_port = 'HyperControl'
            self._single_fader_button_modes = None
            self._has_faders = True
            self._display_reset_delay = -1
            self._hc_byte = HC_BYTE
            self._waiting_for_first_response = True
            self._setup_controls()
            self._setup_displays()
            self._setup_mixer()
            self._setup_session()
            self._setup_transport()
            self._setup_device()
            self._setup_modes()
            self._drum_group_midi_button = None
            self._drum_group_hyper_button = None
            for component in self.components:
                component.set_enabled(False)

    def disconnect(self):
        self._scheduled_messages = []
        for encoder in self._encoders:
            encoder.remove_value_listener(self._encoder_value)

        for fader in self._faders:
            fader.remove_value_listener(self._fader_value)

        for fader_button in self._fader_buttons:
            fader_button.remove_value_listener(self._fader_button_value)

        self._master_fader.remove_value_listener(self._fader_value)
        self._master_fader_button.remove_value_listener(self._fader_button_value)
        self._select_button.remove_value_listener(self._select_button_value)
        self._identify_button.remove_value_listener(self._identify_value)
        self._fader_group_midi_button.remove_value_listener(self._midi_button_value)
        self._fader_group_mix_button.remove_value_listener(self._hyper_button_value)
        self._fader_group_fx_button.remove_value_listener(self._hyper_button_value)
        self._encoder_group_midi_button.remove_value_listener(self._midi_button_value)
        self._encoder_group_mix_button.remove_value_listener(self._hyper_button_value)
        self._encoder_group_fx_button.remove_value_listener(self._hyper_button_value)
        if self._drum_group_midi_button != None:
            self._drum_group_midi_button.remove_value_listener(self._midi_button_value)
        if self._drum_group_hyper_button != None:
            self._drum_group_hyper_button.remove_value_listener(self._hyper_button_value)
        self._alt_device_component = None
        self._name_display = None
        self._value_display = None
        self._bank_display = None
        self._pad_display = None
        self._name_display_data_source = None
        self._value_display_data_source = None
        self._bank_display_data_source = None
        self._pad_display_data_source = None
        self._select_button = None
        self._left_button = None
        self._right_button = None
        self._up_button = None
        self._down_button = None
        self._loop_button = None
        self._ffwd_button = None
        self._rwd_button = None
        self._play_button = None
        self._stop_button = None
        self._rec_button = None
        self._master_fader_button = None
        self._fader_buttons = None
        self._faders = None
        self._encoders = None
        self._drum_pads = None
        self._identify_button = None
        self._main_group_hyper_button = None
        self._main_group_track_button = None
        self._main_group_fx_button = None
        self._encoder_group_midi_button = None
        self._encoder_group_mix_button = None
        self._encoder_group_fx_button = None
        self._fader_group_mode_button = None
        self._fader_group_midi_button = None
        self._fader_group_mix_button = None
        self._fader_group_fx_button = None
        self._drum_group_midi_button = None
        self._drum_group_roll_button = None
        self._drum_group_hyper_button = None
        self._mixer_for_encoders = None
        self._mixer_for_faders = None
        self._device_for_encoders = None
        self._device_for_faders = None
        self._transport = None
        self._session = None
        ControlSurface.disconnect(self)
        self._send_midi(SYSEX_START + DISABLE_HYPERCONTROL)

    def refresh_state(self):
        ControlSurface.refresh_state(self)
        self.schedule_message(5, self._send_midi, IDENTITY_REQUEST)

    def handle_sysex(self, midi_bytes):
        if midi_bytes[0:10] == AXIOM_AIR_RESPONSE:
            if midi_bytes[12:15] < AXIOM_REV4_RESPONSE:
                self.schedule_message(1, self._send_midi, SYSEX_START + ENGAGE_HYPERCONTROL)
                self.schedule_message(2, self._send_midi, SYSEX_START + CLEAR_ALL)
                self.schedule_message(3, self._name_display.display_message, 'Firmware')
                self.schedule_message(13, self._name_display.display_message, 'Update')
                self.schedule_message(23, self._name_display.display_message, 'Required')
                self.schedule_message(33, self._send_midi, SYSEX_START + DISABLE_HYPERCONTROL)
            elif midi_bytes[12:15] >= AXIOM_REV4_RESPONSE:
                if self._waiting_for_first_response == True:
                    self._waiting_for_first_response = False
                    self._has_faders = midi_bytes[10] != 50
                    self.schedule_message(1, self._send_midi, SYSEX_START + ENGAGE_HYPERCONTROL)
                    self.schedule_message(2, self._send_midi, SYSEX_START + SPECIAL_HYPERCONTROL)
                    self.schedule_message(3, self._complete_setup)
                else:
                    self._display_reset_delay = 0
        elif midi_bytes[0:8] == REQUEST_HYPERCONTROL:
            self.schedule_message(5, self._send_midi, IDENTITY_REQUEST)

    def update_display(self):
        ControlSurface.update_display(self)
        if self._display_reset_delay >= 0:
            self._display_reset_delay -= 1
            if self._display_reset_delay == -1:
                self._set_displays_to_default()

    def _on_selected_track_changed(self):
        ControlSurface._on_selected_track_changed(self)
        self._display_reset_delay = 0

    def restore_bank(self, bank_index):
        ControlSurface.restore_bank(self, bank_index)
        if self._alt_device_component != None:
            self._alt_device_component.restore_bank(bank_index)

    def set_appointed_device(self, device):
        ControlSurface.set_appointed_device(self, device)
        with self.component_guard():
            if self._alt_device_component != None:
                self._alt_device_component.set_device(device)

    def set_alt_device_component(self, device_component):
        self._alt_device_component = device_component

    def _update_device_selection(self):
        track = self.song().view.selected_track
        device_to_select = track.view.selected_device
        if device_to_select == None and len(track.devices) > 0:
            device_to_select = track.devices[0]
        if device_to_select != None:
            self.song().view.select_device(device_to_select)
        self._device_component.set_device(device_to_select)
        if self._alt_device_component != None:
            self._alt_device_component.set_device(device_to_select)

    def _setup_controls(self):
        self._left_button = create_button(99, 'Left_Button')
        self._right_button = create_button(100, 'Right_Button')
        self._up_button = create_button(101, 'Up_Button')
        self._down_button = create_button(102, 'Down_Button')
        self._loop_button = create_button(113, 'Loop_Button')
        self._rwd_button = create_button(114, 'Rwd_Button')
        self._ffwd_button = create_button(115, 'FFwd_Button')
        self._stop_button = create_button(116, 'Stop_Button')
        self._play_button = create_button(117, 'Play_Button')
        self._rec_button = create_button(118, 'Record_Button')
        self._select_button = ConfigurableButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, GLOBAL_CHANNEL, 98)
        self._select_button.name = 'Select_Button'
        self._select_button.add_value_listener(self._select_button_value)
        self._main_group_hyper_button = create_configurable_button(104, 'Fader_Group_HyperControl_Button', 2, 14)
        self._main_group_track_button = create_configurable_button(105, 'Main_Group_Track_Button', 2, 11)
        self._main_group_fx_button = create_configurable_button(106, 'Main_Group_Inst_FX_Button', 2, 11)
        self._identify_button = create_configurable_button(97, 'Identify_Button', 2, 16)
        self._identify_button.add_value_listener(self._identify_value)
        self._fader_buttons = []
        for index in range(8):
            self._fader_buttons.append(create_configurable_button(49 + index, 'Fader_Button_%d' % index))
            self._fader_buttons[-1].add_value_listener(self._fader_button_value, identify_sender=True)

        self._faders = []
        for index in range(8):
            self._faders.append(create_slider(33 + index, 'Fader_%d' % index))
            self._faders[-1].add_value_listener(self._fader_value, identify_sender=True)

        self._master_fader_button = create_configurable_button(57, 'Master_Fader_Button')
        self._master_fader_button.add_value_listener(self._fader_button_value, identify_sender=True)
        self._master_fader = create_slider(41, 'Master_Fader')
        self._master_fader.add_value_listener(self._fader_value, identify_sender=True)
        self._fader_group_mode_button = create_configurable_button(61, 'Fader_Group_Mode_Button')
        self._fader_group_midi_button = create_configurable_button(60, 'Fader_Group_MIDI_Button')
        self._fader_group_midi_button.add_value_listener(self._midi_button_value, identify_sender=True)
        self._fader_group_mix_button = create_configurable_button(58, 'Fader_Group_Mix_Button', 0, 1)
        self._fader_group_mix_button.add_value_listener(self._hyper_button_value, identify_sender=True)
        self._fader_group_fx_button = create_configurable_button(59, 'Fader_Group_Inst_FX_Button', 0, -1)
        self._fader_group_fx_button.add_value_listener(self._hyper_button_value, identify_sender=True)
        self._encoders = []
        for index in range(8):
            self._encoders.append(create_encoder(17 + index, 'Encoder_%d' % index))
            self._encoders[-1].add_value_listener(self._encoder_value, identify_sender=True)

        self._encoder_group_midi_button = create_configurable_button(27, 'Encoder_Group_MIDI_Button', 0, 72)
        self._encoder_group_midi_button.add_value_listener(self._midi_button_value, identify_sender=True)
        self._encoder_group_mix_button = create_configurable_button(25, 'Encoder_Group_Mix_Button', 0, 72)
        self._encoder_group_mix_button.add_value_listener(self._hyper_button_value, identify_sender=True)
        self._encoder_group_fx_button = create_configurable_button(26, 'Encoder_Group_Inst_FX_Button', 0, 72)
        self._encoder_group_fx_button.add_value_listener(self._hyper_button_value, identify_sender=True)

    def _setup_drum_pads(self):
        self._drum_pads = []
        num_pads = 12 if self._has_faders else 16
        for index in range(8):
            self._drum_pads.append(create_configurable_button(81 + index, 'Pad_%d' % index, 0, 0, MIDI_CC_TYPE))

        for index in range(num_pads - 8):
            self._drum_pads.append(ConfigurableButtonElement(IS_MOMENTARY, MIDI_NOTE_TYPE, GLOBAL_CHANNEL - 1, 81 + index, GLOBAL_SEND_CHANNEL, 8, MIDI_CC_TYPE))
            self._drum_pads[-1].name = 'Pad_' + str(index + 8)

        self._drum_group_midi_button = create_configurable_button(91, 'Drum_Group_MIDI_Button', 2, -2)
        self._drum_group_midi_button.add_value_listener(self._midi_button_value, identify_sender=True)
        self._drum_group_roll_button = create_configurable_button(90, 'Drum_Group_Roll_Button', -1)
        self._drum_group_hyper_button = create_configurable_button(89, 'Drum_Group_HyperControl_Button', 2, 2)
        self._drum_group_hyper_button.add_value_listener(self._hyper_button_value, identify_sender=True)

    def _setup_displays(self):
        self._name_display = PhysicalDisplayElement(12, 1)
        self._name_display.name = 'Name_Display'
        self._name_display.set_message_parts(SYSEX_START + (21,), (0, 247))
        self._name_display.set_clear_all_message(CLEAR_NAME)
        self._name_display_data_source = DisplayDataSource()
        self._name_display.segment(0).set_data_source(self._name_display_data_source)
        self._value_display = NumericalDisplayElement(3, 1)
        self._value_display.name = 'Value_Display'
        self._value_display.set_message_parts(SYSEX_START + (20, 48), (0, 247))
        self._value_display.set_clear_all_message(CLEAR_VALUE)
        self._value_display_data_source = DisplayDataSource()
        self._value_display.segment(0).set_data_source(self._value_display_data_source)
        self._bank_display = NumericalDisplayElement(3, 1)
        self._bank_display.name = 'Bank_Display'
        self._bank_display.set_message_parts(SYSEX_START + (19,), (0, 247))
        self._bank_display.set_clear_all_message(CLEAR_BANK)
        self._bank_display_data_source = DisplayDataSource()
        self._bank_display.segment(0).set_data_source(self._bank_display_data_source)
        self._pad_display = NumericalDisplayElement(2, 1)
        self._pad_display.name = 'Pad_Display'
        self._pad_display.set_message_parts(SYSEX_START + (18,), (0, 247))
        self._pad_display.set_clear_all_message(CLEAR_PAD)
        self._pad_display_data_source = DisplayDataSource()
        self._pad_display.segment(0).set_data_source(self._pad_display_data_source)

    def _setup_mixer(self):
        self._mixer_for_encoders = SpecialMixerComponent(self._name_display, self._value_display, 8)
        self._mixer_for_encoders.name = 'Mixer_for_encoders'
        self._mixer_for_faders = SpecialMixerComponent(self._name_display, self._value_display, 8)
        self._mixer_for_faders.name = 'Mixer_for_faders'

    def _setup_session(self):
        self._session = SpecialSessionComponent(0, 0)
        self._session.name = 'Session_Control'
        self._session.selected_scene().name = 'Selected_Scene'
        self._session.set_mixer(self._mixer_for_encoders)
        self._session.set_alt_mixer(self._mixer_for_faders)
        self._session.set_track_banking_increment(8)
        self._session.add_offset_listener(self._update_bank_value)

    def _setup_transport(self):
        self._transport = TransportComponent()
        self._transport.name = 'Transport'
        self._transport.set_stop_button(self._stop_button)
        self._transport.set_play_button(self._play_button)
        self._transport.set_record_button(self._rec_button)
        transport_view_modes = TransportViewModeSelector(self._transport, self._session, self._ffwd_button, self._rwd_button, self._loop_button)
        transport_view_modes.name = 'Transport_View_Modes'

    def _setup_device(self):
        self._device_for_encoders = BestBankDeviceComponent()
        self._device_for_encoders.name = 'Device_Component_for_encoders'
        self._device_for_faders = BestBankDeviceComponent()
        self._device_for_faders.name = 'Device_Component_for_faders'
        self.set_device_component(self._device_for_encoders)
        self.set_alt_device_component(self._device_for_faders)
        self._device_nav = DeviceNavComponent()
        self._device_nav.name = 'Device_Nav_Component'

    def _setup_modes(self):
        self._fader_button_modes = FaderButtonModeSelector(self._mixer_for_faders, tuple(self._fader_buttons))
        self._fader_button_modes.name = 'Fader_Button_Modes'
        self._fader_button_modes.set_mode_toggle(self._fader_group_mode_button)
        self._fader_modes = FaderModeSelector(self._mixer_for_faders, self._device_for_faders, tuple(self._faders), self._fader_button_modes, self._master_fader_button)
        self._fader_modes.name = 'Fader_Modes'
        self._fader_modes.set_mode_buttons((self._fader_group_mix_button, self._fader_group_fx_button))
        self._encoder_modes = EncoderModeSelector(self._mixer_for_encoders, self._device_for_encoders, tuple(self._encoders))
        self._encoder_modes.name = 'Encoder_Modes'
        self._encoder_modes.set_mode_buttons((self._encoder_group_mix_button, self._encoder_group_fx_button))
        main_modes = MainModeSelector(self._device_for_encoders, self._device_for_faders, self._session, self._mixer_for_faders, self._device_nav, self._up_button, self._down_button, self._left_button, self._right_button, self._select_button)
        main_modes.name = 'Main_Modes'
        main_modes.set_mode_buttons((self._main_group_track_button, self._main_group_fx_button))

    def _setup_master_fader(self):
        if self._has_faders:
            self._mixer_for_encoders.master_strip().set_volume_control(self._master_fader)
        else:
            self._mixer_for_encoders.selected_strip().set_volume_control(self._master_fader)

    def _setup_single_fader_button_modes(self):
        self._single_fader_button_modes = SingleFaderButtonModeSelector(self._mixer_for_encoders, self._fader_group_midi_button)
        self._single_fader_button_modes.name = 'Single_Fader_Button_Modes'
        self._single_fader_button_modes.set_mode_toggle(self._fader_group_mode_button)

    def _complete_setup(self):
        self._setup_drum_pads()
        self._set_drum_pads_to_hc()
        self._setup_master_fader()
        if not self._has_faders:
            self._setup_single_fader_button_modes()
        for control in self.controls:
            if isinstance(control, InputControlElement):
                control.clear_send_cache()

        for component in self.components:
            component.set_enabled(True)

        self._fader_group_midi_button.send_value(LED_OFF, True)
        self._encoder_group_midi_button.send_value(LED_OFF, True)
        self._main_group_hyper_button.send_value(AMB_FULL, True)
        self.request_rebuild_midi_map()
        self._on_selected_track_changed()
        self.schedule_message(1, self._show_startup_message)

    def _show_startup_message(self):
        self._send_midi(SYSEX_START + CLEAR_ALL)
        self._name_display.display_message('Ableton Live')
        self._display_reset_delay = INITIAL_DISPLAY_DELAY

    def _select_button_value(self, value):
        self._display_reset_delay = STANDARD_DISPLAY_DELAY

    def _identify_value(self, value):
        for encoder in self._encoders:
            encoder.set_identify_mode(value > 0)

        for fader in self._faders:
            fader.set_identify_mode(value > 0)

        self._master_fader.set_identify_mode(value > 0)
        self._display_reset_delay = 0
        self._identify_button.turn_on() if value > 0 else self._identify_button.turn_off()

    def _midi_button_value(self, value, sender):
        if value > 0:
            if sender is self._drum_group_midi_button:
                hc_byte = self._hc_byte ^ PADS
                if hc_byte != self._hc_byte:
                    self._hc_byte = hc_byte
                    self._drum_group_hyper_button.send_value(LED_OFF, True)
                    self.schedule_message(1, self._send_midi, SYSEX_START + (32, self._hc_byte, 247))
            elif sender is self._encoder_group_midi_button:
                hc_byte = self._hc_byte ^ ENCODERS
                if hc_byte != self._hc_byte:
                    self._hc_byte = hc_byte
                    self._encoder_group_mix_button.send_value(LED_OFF, True)
                    self._encoder_group_fx_button.send_value(LED_OFF, True)
                    if self._encoder_modes.mode_index < 3:
                        self._encoder_modes.set_enabled(False)
                    self.schedule_message(1, self._send_midi, SYSEX_START + (32, self._hc_byte, 247))
            elif sender is self._fader_group_midi_button:
                if self._has_faders:
                    hc_byte = self._hc_byte ^ FADERS
                    if hc_byte != self._hc_byte:
                        self._hc_byte = hc_byte
                        self._fader_group_mix_button.send_value(LED_OFF, True)
                        self._fader_group_fx_button.send_value(LED_OFF, True)
                        self._fader_group_mode_button.send_value(LED_OFF, True)
                        if self._fader_modes.mode_index < 2:
                            self._fader_modes.set_enabled(False)
                            self._fader_button_modes.set_enabled(False)
                        self.schedule_message(1, self._send_midi, SYSEX_START + (32, self._hc_byte, 247))
                else:
                    self._display_reset_delay = STANDARD_DISPLAY_DELAY

    def _hyper_button_value(self, value, sender):
        if value > 0:
            if sender is self._drum_group_hyper_button:
                if self._hc_byte | PADS != self._hc_byte:
                    self._hc_byte = self._hc_byte | PADS
                    self._send_midi(SYSEX_START + (32, self._hc_byte, 247))
                    self.schedule_message(1, self._set_drum_pads_to_hc)
            elif sender is self._encoder_group_fx_button or sender is self._encoder_group_mix_button:
                if self._hc_byte | ENCODERS != self._hc_byte:
                    self._hc_byte = self._hc_byte | ENCODERS
                    self._send_midi(SYSEX_START + (32, self._hc_byte, 247))
                    self._encoder_group_midi_button.turn_off()
                    if sender is self._encoder_group_fx_button:
                        self._encoder_modes.set_enabled(True)
                        self._display_reset_delay = 0
                        return
                    else:
                        self.schedule_message(1, self._encoder_modes.set_enabled, True)
                        self.schedule_message(1, self._encoder_modes.update)
                        self._display_reset_delay = 2
                        return
            elif sender is self._fader_group_fx_button or sender is self._fader_group_mix_button:
                if self._hc_byte | FADERS != self._hc_byte:
                    self._hc_byte = self._hc_byte | FADERS
                    self._send_midi(SYSEX_START + (32, self._hc_byte, 247))
                    self._fader_group_midi_button.turn_off()
                    self._fader_button_modes.set_enabled(True)
                    if sender is self._fader_group_fx_button:
                        self._fader_modes.set_enabled(True)
                        self._fader_button_modes.set_enabled(True)
                        self._display_reset_delay = 0
                        return
                    else:
                        self.schedule_message(1, self._fader_modes.set_enabled, True)
                        self.schedule_message(1, self._fader_modes.update)
                        self.schedule_message(1, self._fader_button_modes.set_enabled, True)
                        self.schedule_message(1, self._fader_button_modes.update)
                        self._display_reset_delay = 2
                        return
            self._display_reset_delay = 0

    def _set_drum_pads_to_hc(self):
        self._drum_group_midi_button.send_value(LED_OFF, True)
        self._drum_group_hyper_button.send_value(RED_FULL, True)
        for index in range(len(self._drum_pads)):
            self._drum_pads[index].send_value(RED_LOW, True)

    def _fader_button_value(self, value, sender):
        self._display_reset_delay = STANDARD_DISPLAY_DELAY

    def _fader_value(self, value, sender):
        param = sender.mapped_parameter()
        if param != None:
            param_range = param.max - param.min
            if param.name == 'Track Volume':
                if sender == self._master_fader:
                    if self._has_faders:
                        name_string = 'Master  Vol'
                    else:
                        name_string = self._mixer_for_faders.selected_strip().track_name_data_source().display_string() + '   Vol'
                else:
                    name_string = self._mixer_for_faders.channel_strip(self._faders.index(sender)).track_name_data_source().display_string() + '   Vol'
            else:
                name_string = param.name
                value = int((param.value - param.min) / param_range * 127)
            value_string = str(value)
        else:
            name_string = '<unmapped>'
            value_string = None
            self.schedule_message(1, self._set_value_string)
        self._set_name_string(name_string)
        self._set_value_string(value_string)

    def _encoder_value(self, value, sender):
        param = sender.mapped_parameter()
        if param != None:
            param_range = param.max - param.min
            if param.name == 'Track Volume':
                name_string = self._mixer_for_encoders.channel_strip(self._encoders.index(sender)).track_name_data_source().display_string() + '   Vol'
                value = int((param.value - param.min) / param_range * 127)
            elif param.name == 'Track Panning':
                name_string = self._mixer_for_encoders.channel_strip(self._encoders.index(sender)).track_name_data_source().display_string() + '   Pan'
                value = int(param.value / param_range * 127)
                if value < 0:
                    name_string += '  L'
                elif value > 0:
                    name_string += '  R'
                else:
                    name_string += '  C'
            else:
                name_string = param.name
                value = int((param.value - param.min) / param_range * 127)
            value_string = str(value)
        else:
            name_string = '<unmapped>'
            value_string = None
            self.schedule_message(1, self._set_value_string)
        self._set_name_string(name_string)
        self._set_value_string(value_string)

    def _set_displays_to_default(self):
        self._name_display.segment(0).set_data_source(self._mixer_for_encoders.selected_strip().track_name_data_source())
        self._name_display.update()
        self._update_bank_value()
        self._set_value_string(None)
        self._send_midi(SYSEX_START + LCD_HC_DEFAULT)

    def _set_name_string(self, name_string):
        self._name_display.segment(0).set_data_source(self._name_display_data_source)
        self._name_display_data_source.set_display_string(name_string)
        self._display_reset_delay = STANDARD_DISPLAY_DELAY

    def _set_value_string(self, value_string = None):
        if value_string != None:
            self._value_display_data_source.set_display_string(value_string)
        else:
            self._value_display.reset()

    def _set_bank_string(self, bank_string = None):
        if bank_string != None:
            self._bank_display_data_source.set_display_string(bank_string)
        else:
            self._bank_display.reset()

    def _update_bank_value(self):
        bank = (self._session.track_offset() + 1) / self._session.track_banking_increment() + 1
        self._set_bank_string(str(bank))

    def _install_mapping(self, midi_map_handle, control, parameter, feedback_delay, feedback_map):
        if not self._in_build_midi_map:
            raise AssertionError
            raise midi_map_handle != None or AssertionError
            raise control != None and parameter != None or AssertionError
            raise isinstance(parameter, Live.DeviceParameter.DeviceParameter) or AssertionError
            raise isinstance(control, InputControlElement) or AssertionError
            raise isinstance(feedback_delay, int) or AssertionError
            if not isinstance(feedback_map, tuple):
                raise AssertionError
                success = False
                feedback_rule = None
                feedback_rule = control.message_type() is MIDI_NOTE_TYPE and Live.MidiMap.NoteFeedbackRule()
                feedback_rule.note_no = 0
                feedback_rule.vel_map = (0,)
            elif control.message_type() is MIDI_CC_TYPE:
                feedback_rule = Live.MidiMap.CCFeedbackRule()
                feedback_rule.cc_no = 0
                feedback_rule.cc_value_map = (0,)
            elif control.message_type() is MIDI_PB_TYPE:
                feedback_rule = Live.MidiMap.PitchBendFeedbackRule()
                feedback_rule.value_pair_map = feedback_map
            raise feedback_rule != None or AssertionError
            feedback_rule.channel = control.message_channel()
            feedback_rule.delay_in_ms = feedback_delay
            success = control.message_type() is MIDI_NOTE_TYPE and Live.MidiMap.map_midi_note_with_feedback_map(midi_map_handle, parameter, control.message_channel(), control.message_identifier(), feedback_rule)
        elif control.message_type() is MIDI_CC_TYPE:
            success = Live.MidiMap.map_midi_cc_with_feedback_map(midi_map_handle, parameter, control.message_channel(), control.message_identifier(), control.message_map_mode(), feedback_rule, not control.needs_takeover())
        elif control.message_type() is MIDI_PB_TYPE:
            success = Live.MidiMap.map_midi_pitchbend_with_feedback_map(midi_map_handle, parameter, control.message_channel(), feedback_rule, not control.needs_takeover())
        return success
########NEW FILE########
__FILENAME__ = BestBankDeviceComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/BestBankDeviceComponent.py
from _Framework.DeviceComponent import DeviceComponent
from _Generic.Devices import parameter_bank_names, parameter_banks, DEVICE_DICT, BANK_NAME_DICT, DEVICE_BOB_DICT
BOP_BANK_NAME = 'Best of Parameters'

class BestBankDeviceComponent(DeviceComponent):
    """ Special Device component that uses the best of bank of a device as default """

    def __init__(self):
        DeviceComponent.__init__(self)
        new_banks = {}
        new_bank_names = {}
        self._device_banks = DEVICE_DICT
        self._device_bank_names = BANK_NAME_DICT
        self._device_best_banks = DEVICE_BOB_DICT
        for device_name in self._device_banks.keys():
            current_banks = self._device_banks[device_name]
            if len(current_banks) > 1:
                current_banks = self._device_best_banks[device_name] + current_banks
                new_bank_names[device_name] = (BOP_BANK_NAME,) + self._device_bank_names[device_name]
            new_banks[device_name] = current_banks

        self._device_banks = new_banks
        self._device_bank_names = new_bank_names

    def set_parameter_controls(self, controls):
        if self._parameter_controls != None:
            for control in self._parameter_controls:
                if self._device != None:
                    control.release_parameter()

        self._parameter_controls = controls
        self.update()

    def _number_of_parameter_banks(self):
        result = 0
        if self._device != None:
            if self._device.class_name in self._device_banks.keys():
                result = len(self._device_banks[self._device.class_name])
            else:
                result = DeviceComponent._number_of_parameter_banks(self)
        return result

    def _parameter_banks(self):
        return parameter_banks(self._device, self._device_banks)

    def _parameter_bank_names(self):
        return parameter_bank_names(self._device, self._device_bank_names)

    def _is_banking_enabled(self):
        return True
########NEW FILE########
__FILENAME__ = ConfigurableButtonElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/ConfigurableButtonElement.py
from _Framework.ButtonElement import ButtonElement
from _Framework.InputControlElement import MIDI_NOTE_TYPE, MIDI_CC_TYPE, MIDI_CC_STATUS
from consts import *

class ConfigurableButtonElement(ButtonElement):
    """ Special button class that can be configured with custom on- and off-values
    and can send and receive on different channels with different message types """

    def __init__(self, is_momentary, msg_type, channel, identifier, send_channel = None, identifier_send_offset = 0, send_msg_type = None):
        ButtonElement.__init__(self, is_momentary, msg_type, channel, identifier)
        self._send_channel = send_channel
        self._send_msg_type = send_msg_type
        self._identifier_send_offset = identifier_send_offset
        self._on_value = AMB_FULL
        self._off_value = LED_OFF
        self._is_enabled = True
        self._is_notifying = False
        self._force_next_value = False
        self._pending_listeners = []

    def set_on_off_values(self, on_value, off_value):
        self.clear_send_cache()
        self._on_value = on_value
        self._off_value = off_value

    def set_force_next_value(self):
        self._force_next_value = True

    def set_enabled(self, enabled):
        self._is_enabled = enabled

    def turn_on(self):
        self.send_value(self._on_value)

    def turn_off(self):
        self.send_value(self._off_value)

    def reset(self):
        self.send_value(self._off_value)

    def add_value_listener(self, callback, identify_sender = False):
        if not self._is_notifying:
            ButtonElement.add_value_listener(self, callback, identify_sender)
        else:
            self._pending_listeners.append((callback, identify_sender))

    def receive_value(self, value):
        self._is_notifying = True
        ButtonElement.receive_value(self, value)
        self._is_notifying = False
        for listener in self._pending_listeners:
            self.add_value_listener(listener[0], listener[1])

        self._pending_listeners = []

    def send_value(self, value, force = False):
        if force or self._force_next_value or value != self._last_sent_value:
            data_byte1 = self._original_identifier + self._identifier_send_offset
            data_byte2 = value
            status_byte = self._send_channel if self._send_channel else self._original_channel
            if self._send_msg_type:
                if self._send_msg_type == MIDI_NOTE_TYPE:
                    status_byte += MIDI_NOTE_ON_STATUS
                elif self._send_msg_type == MIDI_CC_TYPE:
                    status_byte += MIDI_CC_STATUS
            elif self._msg_type == MIDI_NOTE_TYPE:
                status_byte += MIDI_NOTE_ON_STATUS
            elif self._msg_type == MIDI_CC_TYPE:
                status_byte += MIDI_CC_STATUS
            if self.send_midi((status_byte, data_byte1, data_byte2)):
                self._last_sent_message = (value, None)
                if self._report_output:
                    is_input = True
                    self._report_value(value, not is_input)
        self._force_next_value = False
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/consts.py
SYSEX_START = (240, 0, 1, 5, 32, 127)
IDENTITY_REQUEST = (240, 126, 127, 6, 1, 247)
AXIOM_AIR_RESPONSE = (240, 126, 127, 6, 2, 0, 1, 5, 99, 14)
AXIOM_REV4_RESPONSE = (49, 48, 49)
AXIOM_R4_FULL_RESPONSE = (240, 126, 127, 6, 2, 0, 1, 5, 99, 14, 51, 64, 49, 48, 49, 48, 247)
ENGAGE_HYPERCONTROL = (32, 62, 247)
ENGAGE_HYPERCL_NO_PADS = (32, 58, 247)
SPECIAL_HYPERCONTROL = (33, 9, 247)
DISABLE_HYPERCONTROL = (32, 0, 247)
REQUEST_HYPERCONTROL = (240, 0, 1, 5, 34, 127, 7, 2)
LCD_ALL_ON = (22, 31, 127, 127, 127, 247)
LCD_ALL_OFF = (22, 0, 0, 0, 0, 0)
LCD_HC_DEFAULT = (22, 18, 4, 64, 1, 247)
CLEAR_ALL = (16, 247)
CLEAR_VALUE = (187, 21, 0)
CLEAR_BANK = (187, 22, 0)
CLEAR_PAD = (187, 23, 0)
CLEAR_KNOB = (187, 24, 0)
CLEAR_NAME = (187, 25, 0)
DISPLAY_WORD_ON = (240, 0, 1, 5, 32, 127, 20, 49, 48, 50, 53, 0, 247)
DISPLAY_WORD_OFF = (240, 0, 1, 5, 32, 127, 20, 49, 48, 50, 52, 0, 247)
HC_BYTE = 62
ENCODERS = 2
PADS = 4
FADERS = 8
NAVIGATION = 16
TRANSPORT = 32
KEYBOARD = 64
IS_MOMENTARY = True
NUM_TRACKS = 8
GLOBAL_CHANNEL = 15
GLOBAL_SEND_CHANNEL = 12
INITIAL_DISPLAY_DELAY = 15
STANDARD_DISPLAY_DELAY = 15
PAD_TRANSLATIONS = ((0, 0, 85, 14),
 (1, 0, 86, 14),
 (2, 0, 87, 14),
 (3, 0, 88, 14),
 (0, 1, 81, 14),
 (1, 1, 82, 14),
 (2, 1, 83, 14),
 (3, 1, 84, 14),
 (0, 2, 85, 15),
 (1, 2, 86, 15),
 (2, 2, 87, 15),
 (3, 2, 88, 15),
 (0, 3, 81, 15),
 (1, 3, 82, 15),
 (2, 3, 83, 15),
 (3, 3, 84, 15))
ETCHINGS = ['track',
 'inst_fx',
 'memory',
 'parameter',
 'value',
 'pan',
 'l',
 'r',
 'program',
 'volume',
 'edit',
 'channel',
 'strip',
 'hyper',
 'page',
 'send',
 'bank',
 'pad',
 'knob',
 'fader',
 'button']
LED_OFF = 0
GRN_LOW = 1
RED_LOW = 2
AMB_LOW = 3
GRN_HALF = 17
RED_HALF = 18
AMB_HALF = 19
GRN_HIGH = 33
RED_HIGH = 34
AMB_HIGH = 35
GRN_FULL = 49
RED_FULL = 50
AMB_FULL = 51
########NEW FILE########
__FILENAME__ = DeviceNavComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/DeviceNavComponent.py
import Live
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent

class DeviceNavComponent(ControlSurfaceComponent):
    """ Component that can navigate the selection of devices """

    def __init__(self):
        ControlSurfaceComponent.__init__(self)
        self._left_button = None
        self._right_button = None

    def disconnect(self):
        if self._left_button != None:
            self._left_button.remove_value_listener(self._nav_value)
            self._left_button = None
        if self._right_button != None:
            self._right_button.remove_value_listener(self._nav_value)
            self._right_button = None

    def set_device_nav_buttons(self, left_button, right_button):
        identify_sender = True
        if self._left_button != None:
            self._left_button.remove_value_listener(self._nav_value)
        self._left_button = left_button
        if self._left_button != None:
            self._left_button.add_value_listener(self._nav_value, identify_sender)
        if self._right_button != None:
            self._right_button.remove_value_listener(self._nav_value)
        self._right_button = right_button
        if self._right_button != None:
            self._right_button.add_value_listener(self._nav_value, identify_sender)
        self.update()

    def on_enabled_changed(self):
        self.update()

    def update(self):
        if self.is_enabled():
            pass

    def _nav_value(self, value, sender):
        if self.is_enabled():
            if not sender.is_momentary() or value != 0:
                modifier_pressed = True
                if not self.application().view.is_view_visible('Detail') or not self.application().view.is_view_visible('Detail/DeviceChain'):
                    self.application().view.show_view('Detail')
                    self.application().view.show_view('Detail/DeviceChain')
                else:
                    direction = Live.Application.Application.View.NavDirection.left
                    if sender == self._right_button:
                        direction = Live.Application.Application.View.NavDirection.right
                    self.application().view.scroll_view(direction, 'Detail/DeviceChain', not modifier_pressed)
########NEW FILE########
__FILENAME__ = DisplayingChanStripComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/DisplayingChanStripComponent.py
from _Framework.ButtonElement import ButtonElement
from _Framework.ChannelStripComponent import ChannelStripComponent
from consts import *

class DisplayingChanStripComponent(ChannelStripComponent):
    """ Special channel strip class that displays Mute/Solo/Arm state"""

    def __init__(self):
        ChannelStripComponent.__init__(self)
        self._name_display = None
        self._value_display = None

    def disconnect(self):
        ChannelStripComponent.disconnect(self)
        self._name_display = None
        self._value_display = None

    def set_name_display(self, name_display):
        self._name_display = name_display

    def set_value_display(self, value_display):
        self._value_display = value_display

    def set_arm_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if button != self._arm_button:
                if self._arm_button != None:
                    self._arm_button.remove_value_listener(self._arm_value)
                    self._arm_button.reset()
                self._arm_pressed = False
                self._arm_button = button
                self._arm_button != None and self._arm_button.add_value_listener(self._arm_value)
            self.update()

    def _on_mute_changed(self):
        if self._mute_button != None:
            if self._track != None and self._track != self.song().master_track:
                self._mute_button.set_on_off_values(AMB_FULL, AMB_LOW)
            else:
                self._mute_button.set_on_off_values(AMB_LOW, LED_OFF)
        ChannelStripComponent._on_mute_changed(self)

    def _on_solo_changed(self):
        if self._solo_button != None:
            if self._track != None and self._track != self.song().master_track:
                self._solo_button.set_on_off_values(AMB_FULL, AMB_LOW)
            else:
                self._solo_button.set_on_off_values(AMB_LOW, LED_OFF)
        ChannelStripComponent._on_solo_changed(self)

    def _on_arm_changed(self):
        if self._arm_button != None:
            if self._track != None and self._track in self.song().tracks:
                self._arm_button.set_on_off_values(RED_FULL, RED_LOW)
            else:
                self._arm_button.set_on_off_values(RED_LOW, LED_OFF)
        ChannelStripComponent._on_arm_changed(self)

    def _mute_value(self, value):
        ChannelStripComponent._mute_value(self, value)
        if self._track != None and self._track != self.song().master_track:
            if self._name_display != None and self._value_display != None:
                value != 0 and self._name_display.display_message('Mute :')
                self._value_display.send_midi(DISPLAY_WORD_ON) if self._track.mute else self._value_display.send_midi(DISPLAY_WORD_OFF)

    def _solo_value(self, value):
        ChannelStripComponent._solo_value(self, value)
        if self._track != None and self._track != self.song().master_track:
            if self._name_display != None and self._value_display != None:
                value != 0 and self._name_display.display_message('Solo :')
                self._value_display.send_midi(DISPLAY_WORD_ON) if self._track.solo else self._value_display.send_midi(DISPLAY_WORD_OFF)

    def _arm_value(self, value):
        ChannelStripComponent._arm_value(self, value)
        if self._track != None and self._track != self.song().master_track and self._name_display != None and self._value_display != None:
            if self._track not in self.song().return_tracks:
                value != 0 and self._name_display.display_message('Arm :')
                self._value_display.send_midi(DISPLAY_WORD_ON) if self._track.arm else self._value_display.send_midi(DISPLAY_WORD_OFF)
########NEW FILE########
__FILENAME__ = EncoderModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/EncoderModeSelector.py
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from consts import *

class EncoderModeSelector(ModeSelectorComponent):
    """ SelectorComponent that assigns encoders to different functions """

    def __init__(self, mixer, device, encoders):
        ModeSelectorComponent.__init__(self)
        self._mixer = mixer
        self._device = device
        self._encoders = encoders
        self._mode_index = 1
        self._submode_index = 1
        self._number_of_modes = 4

    def disconnect(self):
        ModeSelectorComponent.disconnect(self)
        self._mixer = None
        self._device = None
        self._encoders = None

    def set_mode_buttons(self, buttons):
        for button in buttons:
            identify_sender = True
            button.add_value_listener(self._mode_value, identify_sender)
            self._modes_buttons.append(button)

    def number_of_modes(self):
        return self._number_of_modes

    def update(self):
        if self.is_enabled():
            self._device.set_allow_update(False)
            self._mixer.set_allow_update(False)
            self._device.set_parameter_controls(())
            self._mixer.selected_strip().set_send_controls(())
            for index in range(len(self._encoders)):
                strip = self._mixer.channel_strip(index)
                encoder = self._encoders[index]
                strip.set_volume_control(None)
                strip.set_pan_control(None)
                encoder.release_parameter()
                if self._mode_index == 0:
                    strip.set_volume_control(encoder)
                    encoder.set_on_off_values(AMB_FULL, LED_OFF)
                elif self._mode_index == 1:
                    strip.set_pan_control(encoder)
                    encoder.set_on_off_values(RED_FULL, LED_OFF)
                elif self._mode_index == 2:
                    encoder.set_on_off_values(GRN_FULL, LED_OFF)
                elif self._mode_index == 3:
                    encoder.set_on_off_values(RED_FULL, LED_OFF)

            if self._mode_index == 0:
                self._modes_buttons[0].send_value(AMB_FULL, True)
                self._modes_buttons[1].send_value(LED_OFF, True)
            elif self._mode_index == 1:
                self._modes_buttons[0].send_value(RED_FULL, True)
                self._modes_buttons[1].send_value(LED_OFF, True)
            elif self._mode_index == 2:
                self._modes_buttons[0].send_value(GRN_FULL, True)
                self._modes_buttons[1].send_value(LED_OFF, True)
                self._mixer.selected_strip().set_send_controls(self._encoders)
            elif self._mode_index == 3:
                self._modes_buttons[0].send_value(LED_OFF, True)
                self._modes_buttons[1].send_value(RED_FULL, True)
                self._device.set_parameter_controls(self._encoders)
            self._device.set_allow_update(True)
            self._mixer.set_allow_update(True)

    def _mode_value(self, value, sender):
        if self.is_enabled() and value is not 0 or not sender.is_momentary():
            if self._modes_buttons.index(sender) == 0:
                if self._mode_index != self.number_of_modes() - 1:
                    self._submode_index = (self._submode_index + 1) % (self.number_of_modes() - 1)
                self.set_mode(self._submode_index)
            else:
                self.set_mode(self.number_of_modes() - 1)
########NEW FILE########
__FILENAME__ = FaderButtonModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/FaderButtonModeSelector.py
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from consts import *

class FaderButtonModeSelector(ModeSelectorComponent):
    """ SelectorComponent that assigns fader buttons to different functions """

    def __init__(self, mixer, fader_buttons):
        ModeSelectorComponent.__init__(self)
        self._mixer = mixer
        self._fader_buttons = fader_buttons
        self._mode_index = 0
        self._number_of_modes = 3
        self._is_mix_mode = True
        self._flashing_button = None
        self._flashing_button_on = True
        self._flashing_reset_delay = 0
        self._register_timer_callback(self._on_timer)

    def disconnect(self):
        self._unregister_timer_callback(self._on_timer)
        ModeSelectorComponent.disconnect(self)
        self._mixer = None
        self._fader_buttons = None
        self._flashing_button = None

    def number_of_modes(self):
        return self._number_of_modes

    def set_mix_mode(self):
        self._is_mix_mode = True
        self.update()

    def set_track_select_mode(self):
        self._is_mix_mode = False
        self.update()

    def update(self):
        if self.is_enabled():
            for index in range(len(self._fader_buttons)):
                strip = self._mixer.channel_strip(index)
                fader_button = self._fader_buttons[index]
                strip.set_solo_button(None)
                strip.set_arm_button(None)
                strip.set_mute_button(None)
                strip.set_select_button(None)
                if self._is_mix_mode:
                    if self._mode_index == 0:
                        strip.set_mute_button(fader_button)
                    elif self._mode_index == 1:
                        strip.set_solo_button(fader_button)
                    else:
                        strip.set_arm_button(fader_button)
                else:
                    fader_button.set_on_off_values(GRN_FULL, LED_OFF)
                    strip.set_select_button(fader_button)

            self._flashing_button = None
            if self._is_mix_mode:
                if self._mode_index == 0:
                    self._mode_toggle.send_value(AMB_FULL, True)
                elif self._mode_index == 1:
                    self._mode_toggle.send_value(AMB_FULL, True)
                    self._flashing_button = self._mode_toggle
                else:
                    self._mode_toggle.send_value(RED_FULL, True)
            else:
                self._mode_toggle.send_value(GRN_FULL, True)

    def _on_timer(self):
        if self.is_enabled():
            if self._flashing_button != None:
                if self._flashing_reset_delay > 0:
                    self._flashing_reset_delay -= 1
                else:
                    self._flash()
                    self._flashing_reset_delay = 5

    def _toggle_value(self, value):
        if self.is_enabled():
            ModeSelectorComponent._toggle_value(self, value)

    def _flash(self):
        self._flashing_button.turn_off() if self._flashing_button_on else self._flashing_button.turn_on()
        self._flashing_button_on = not self._flashing_button_on
########NEW FILE########
__FILENAME__ = FaderModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/FaderModeSelector.py
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from consts import *

class FaderModeSelector(ModeSelectorComponent):
    """ SelectorComponent that assigns faders to different functions """

    def __init__(self, mixer, device, faders, fader_button_modes, master_fader_button):
        ModeSelectorComponent.__init__(self)
        self._mixer = mixer
        self._device = device
        self._faders = faders
        self._fader_button_modes = fader_button_modes
        self._master_fader_button = master_fader_button
        self._master_fader_button.set_on_off_values(GRN_FULL, LED_OFF)
        self._mode_index = 0
        self._submode_index = 0
        self._number_of_modes = 3

    def disconnect(self):
        ModeSelectorComponent.disconnect(self)
        self._mixer = None
        self._device = None
        self._faders = None
        self._fader_button_modes = None
        self._master_fader_button = None

    def set_mode_buttons(self, buttons):
        for button in buttons:
            identify_sender = True
            button.add_value_listener(self._mode_value, identify_sender)
            self._modes_buttons.append(button)

    def number_of_modes(self):
        return self._number_of_modes

    def update(self):
        if self.is_enabled():
            self._device.set_allow_update(False)
            self._mixer.set_allow_update(False)
            self._device.set_parameter_controls(())
            for index in range(len(self._faders)):
                strip = self._mixer.channel_strip(index)
                fader = self._faders[index]
                strip.set_volume_control(None)
                fader.release_parameter()
                if self._mode_index <= 1:
                    strip.set_volume_control(fader)

            if self._mode_index == 0:
                self._modes_buttons[0].send_value(AMB_FULL, True)
                self._modes_buttons[1].send_value(LED_OFF, True)
                self._fader_button_modes.set_mix_mode()
                self._mixer.master_strip().set_select_button(None)
                self._master_fader_button.turn_off()
            elif self._mode_index == 1:
                self._modes_buttons[0].send_value(GRN_FULL, True)
                self._modes_buttons[1].send_value(LED_OFF, True)
                self._fader_button_modes.set_track_select_mode()
                self._mixer.master_strip().set_select_button(self._master_fader_button)
            else:
                self._modes_buttons[0].send_value(LED_OFF, True)
                self._modes_buttons[1].send_value(RED_FULL, True)
                self._device.set_parameter_controls(self._faders)
                self._fader_button_modes.set_track_select_mode()
                self._mixer.master_strip().set_select_button(self._master_fader_button)
            self._device.set_allow_update(True)
            self._mixer.set_allow_update(True)

    def _mode_value(self, value, sender):
        if self.is_enabled():
            if value is not 0 or not sender.is_momentary():
                if self._modes_buttons.index(sender) == 0:
                    if self._mode_index != self.number_of_modes() - 1:
                        self._submode_index = (self._submode_index + 1) % (self.number_of_modes() - 1)
                    self.set_mode(self._submode_index)
                else:
                    self.set_mode(self.number_of_modes() - 1)
########NEW FILE########
__FILENAME__ = IdentifyingEncoderElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/IdentifyingEncoderElement.py
from _Framework.EncoderElement import EncoderElement
from _Framework.InputControlElement import *

class IdentifyingEncoderElement(EncoderElement):
    """ Encoder with LED that can be connected and disconnected to a specific parameter
    and can send and receive on different channels """

    def __init__(self, msg_type, channel, identifier, map_mode, send_channel = None, identifier_send_offset = 0):
        EncoderElement.__init__(self, msg_type, channel, identifier, map_mode)
        self._identify_mode = False
        self._send_channel = send_channel
        self._identifier_send_offset = identifier_send_offset
        self._on_value = 127
        self._off_value = 0
        self._force_next_value = False

    def set_identify_mode(self, identify_mode):
        if self._identify_mode != identify_mode:
            self._identify_mode = identify_mode
            self._request_rebuild()

    def get_identify_mode(self):
        return self._identify_mode

    def install_connections(self, translate_message, install_mapping, install_forwarding):
        current_parameter = self._parameter_to_map_to
        if self._identify_mode:
            self._parameter_to_map_to = None
        InputControlElement.install_connections(self, translate_message, install_mapping, install_forwarding)
        self._parameter_to_map_to = current_parameter
        self._update_led()

    def set_on_off_values(self, on_value, off_value):
        self.clear_send_cache()
        self._on_value = on_value
        self._off_value = off_value

    def set_force_next_value(self):
        self._force_next_value = True

    def turn_on(self):
        self.send_value(self._on_value)

    def turn_off(self):
        self.send_value(self._off_value)

    def reset(self):
        self.send_value(self._off_value)

    def send_value(self, value, force = False):
        if force or self._force_next_value or value != self._last_sent_value and self._is_being_forwarded:
            data_byte1 = self._original_identifier + self._identifier_send_offset
            data_byte2 = value
            status_byte = self._send_channel if self._send_channel else self._original_channel
            if self._msg_type == MIDI_NOTE_TYPE:
                status_byte += MIDI_NOTE_ON_STATUS
            elif self._msg_type == MIDI_CC_TYPE:
                status_byte += MIDI_CC_STATUS
            if self.send_midi((status_byte, data_byte1, data_byte2)):
                self._last_sent_message = (value, None)
                if self._report_output:
                    is_input = True
                    self._report_value(value, not is_input)
        self._force_next_value = False

    def connect_to(self, parameter):
        if parameter != self._parameter_to_map_to and not self.is_mapped_manually():
            self.send_value(self._off_value, force=True)
        EncoderElement.connect_to(self, parameter)

    def release_parameter(self):
        EncoderElement.release_parameter(self)
        self._update_led()

    def is_mapped_manually(self):
        return not self._is_mapped and not self._is_being_forwarded

    def _update_led(self):
        if self.is_mapped_manually():
            self.send_value(self._on_value, force=True)
        elif self._parameter_to_map_to != None:
            self.send_value(self._on_value, force=True)
        else:
            self.send_value(self._off_value, force=True)
########NEW FILE########
__FILENAME__ = MainModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/MainModeSelector.py
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from consts import *

class MainModeSelector(ModeSelectorComponent):
    """ SelectorComponent that assigns navigation buttons to different functions """

    def __init__(self, device_0, device_1, session, mixer, device_nav, up_button, down_button, left_button, right_button, select_button):
        ModeSelectorComponent.__init__(self)
        self._device_0 = device_0
        self._device_1 = device_1
        self._session = session
        self._mixer = mixer
        self._device_nav = device_nav
        self._select_button = select_button
        self._left_button = left_button
        self._right_button = right_button
        self._up_button = up_button
        self._down_button = down_button
        self._mode_index = 0

    def disconnect(self):
        ModeSelectorComponent.disconnect(self)
        self._device_0 = None
        self._device_1 = None
        self._session = None
        self._mixer = None
        self._device_nav = None
        self._select_button = None
        self._left_button = None
        self._right_button = None
        self._up_button = None
        self._down_button = None

    def number_of_modes(self):
        return 2

    def update(self):
        if self.is_enabled():
            if self._mode_index == 0:
                self._modes_buttons[0].send_value(GRN_FULL, True)
                self._modes_buttons[1].send_value(LED_OFF, True)
                self._device_0.set_on_off_button(None)
                self._device_0.set_bank_nav_buttons(None, None)
                self._device_1.set_bank_nav_buttons(None, None)
                self._device_nav.set_device_nav_buttons(None, None)
                self._session.set_track_bank_buttons(self._right_button, self._left_button)
                self._session.set_track_select_buttons(self._down_button, self._up_button)
                self._mixer.selected_strip().set_arm_button(self._select_button)
            elif self._mode_index == 1:
                self._modes_buttons[0].send_value(LED_OFF, True)
                self._modes_buttons[1].send_value(GRN_FULL, True)
                self._session.set_track_bank_buttons(None, None)
                self._session.set_track_select_buttons(None, None)
                self._mixer.selected_strip().set_arm_button(None)
                self._device_0.set_on_off_button(self._select_button)
                self._device_0.set_bank_nav_buttons(self._left_button, self._right_button)
                self._device_1.set_bank_nav_buttons(self._left_button, self._right_button)
                self._device_nav.set_device_nav_buttons(self._up_button, self._down_button)
########NEW FILE########
__FILENAME__ = NumericalDisplayElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/NumericalDisplayElement.py
from _Framework.PhysicalDisplayElement import PhysicalDisplayElement
from NumericalDisplaySegment import NumericalDisplaySegment

class NumericalDisplayElement(PhysicalDisplayElement):
    """ Special display element that only displays numerical values """
    _ascii_translations = {'0': 48,
     '1': 49,
     '2': 50,
     '3': 51,
     '4': 52,
     '5': 53,
     '6': 54,
     '7': 55,
     '8': 56,
     '9': 57}

    def __init__(self, width_in_chars, num_segments):
        PhysicalDisplayElement.__init__(self, width_in_chars, num_segments)
        self._logical_segments = []
        self._translation_table = NumericalDisplayElement._ascii_translations
        width_without_delimiters = self._width - num_segments + 1
        width_per_segment = int(width_without_delimiters / num_segments)
        for index in range(num_segments):
            new_segment = NumericalDisplaySegment(width_per_segment, self.update)
            self._logical_segments.append(new_segment)

    def display_message(self, message):
        if not self._message_header != None:
            raise AssertionError
            raise message != None or AssertionError
            raise isinstance(message, str) or AssertionError
            message = self._block_messages or NumericalDisplaySegment.adjust_string(message, self._width)
            self.send_midi(self._message_header + tuple([ self._translate_char(c) for c in message ]) + self._message_tail)

    def _translate_char(self, char_to_translate):
        if not char_to_translate != None:
            raise AssertionError
            raise isinstance(char_to_translate, str) or isinstance(char_to_translate, unicode) or AssertionError
            raise len(char_to_translate) == 1 or AssertionError
            result = char_to_translate in self._translation_table.keys() and self._translation_table[char_to_translate]
        else:
            result = self._translation_table['0']
        return result
########NEW FILE########
__FILENAME__ = NumericalDisplaySegment
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/NumericalDisplaySegment.py
from _Framework.LogicalDisplaySegment import LogicalDisplaySegment

class NumericalDisplaySegment(LogicalDisplaySegment):
    """ Special display segment that only displays numerical values """

    @staticmethod
    def adjust_string(original, length):
        characters_to_retain = {'0': 48,
         '1': 49,
         '2': 50,
         '3': 51,
         '4': 52,
         '5': 53,
         '6': 54,
         '7': 55,
         '8': 56,
         '9': 57}
        resulting_string = ''
        for char in original:
            if char in characters_to_retain:
                resulting_string = resulting_string + char

        if len(resulting_string) > length:
            resulting_string = resulting_string[:length]
        if len(resulting_string) < length:
            resulting_string = resulting_string.rjust(length)
        return resulting_string

    def __init__(self, width, update_callback):
        LogicalDisplaySegment.__init__(self, width, update_callback)

    def display_string(self):
        resulting_string = ' ' * self._width
        if self._data_source != None:
            resulting_string = NumericalDisplaySegment.adjust_string(self._data_source.display_string(), self._width)
        return resulting_string
########NEW FILE########
__FILENAME__ = SingleFaderButtonModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/SingleFaderButtonModeSelector.py
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from consts import *

class SingleFaderButtonModeSelector(ModeSelectorComponent):
    """ SelectorComponent that assigns single fader button to different functions """

    def __init__(self, mixer, fader_button):
        ModeSelectorComponent.__init__(self)
        self._mixer = mixer
        self._fader_button = fader_button
        self._mode_index = 0
        self._number_of_modes = 3
        self._flashing_button = None
        self._flashing_button_on = True
        self._flashing_reset_delay = 0
        self._register_timer_callback(self._on_timer)

    def disconnect(self):
        self._unregister_timer_callback(self._on_timer)
        ModeSelectorComponent.disconnect(self)
        self._mixer = None
        self._fader_button = None
        self._flashing_button = None

    def number_of_modes(self):
        return self._number_of_modes

    def update(self):
        if self.is_enabled():
            strip = self._mixer.selected_strip()
            fader_button = self._fader_button
            self._flashing_button = None
            if self.song().view.selected_track != self.song().master_track:
                strip.set_solo_button(None)
                strip.set_arm_button(None)
                strip.set_mute_button(None)
                if self._mode_index == 0:
                    strip.set_mute_button(fader_button)
                    self._mode_toggle.send_value(AMB_FULL, True)
                elif self._mode_index == 1:
                    strip.set_solo_button(fader_button)
                    self._mode_toggle.send_value(AMB_FULL, True)
                    self._flashing_button = self._mode_toggle
                else:
                    strip.set_arm_button(fader_button)
                    self._mode_toggle.send_value(RED_FULL, True)

    def _on_timer(self):
        if self._flashing_button != None:
            if self._flashing_reset_delay > 0:
                self._flashing_reset_delay -= 1
            else:
                self._flash()
                self._flashing_reset_delay = 5

    def _flash(self):
        self._flashing_button.turn_off() if self._flashing_button_on else self._flashing_button.turn_on()
        self._flashing_button_on = not self._flashing_button_on
########NEW FILE########
__FILENAME__ = SpecialMixerComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/SpecialMixerComponent.py
from _Framework.MixerComponent import MixerComponent
from DisplayingChanStripComponent import DisplayingChanStripComponent

class SpecialMixerComponent(MixerComponent):
    """ Special mixer class that uses displaying channel strips """

    def __init__(self, name_display, value_display, num_tracks, num_returns = 0, with_eqs = False, with_filters = False):
        MixerComponent.__init__(self, num_tracks, num_returns=0, with_eqs=False, with_filters=False)
        self._name_display = name_display
        self._value_display = value_display
        for index in range(num_tracks):
            self._channel_strips[index].set_name_display(self._name_display)
            self._channel_strips[index].set_value_display(self._value_display)

        for index in range(num_returns):
            self._return_strips[index].set_name_display(self._name_display)
            self._return_strips[index].set_value_display(self._value_display)

        self._selected_strip.set_name_display(self._name_display)
        self._selected_strip.set_value_display(self._value_display)

    def disconnect(self):
        MixerComponent.disconnect(self)
        self._name_display = None
        self._value_display = None

    def tracks_to_use(self):
        return self.song().visible_tracks + self.song().return_tracks

    def _create_strip(self):
        return DisplayingChanStripComponent()
########NEW FILE########
__FILENAME__ = SpecialSessionComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/SpecialSessionComponent.py
from _Framework.SessionComponent import SessionComponent

class SpecialSessionComponent(SessionComponent):
    """ Session component which allows parallel mixer components
    and has track select buttons """

    def __init__(self, num_tracks, num_scenes):
        self._alt_mixer = None
        self._next_track_button = None
        self._prev_track_button = None
        SessionComponent.__init__(self, num_tracks, num_scenes)

    def disconnect(self):
        SessionComponent.disconnect(self)
        self._alt_mixer = None
        if self._next_track_button != None:
            self._next_track_button.remove_value_listener(self._next_track_value)
            self._next_track_button = None
        if self._prev_track_button != None:
            self._prev_track_button.remove_value_listener(self._prev_track_value)
            self._prev_track_button = None

    def set_alt_mixer(self, alt_mixer):
        self._alt_mixer = alt_mixer
        if self._alt_mixer != None:
            self._alt_mixer.set_track_offset(self.track_offset())

    def set_track_select_buttons(self, next_button, prev_button):
        do_update = False
        if next_button is not self._next_track_button:
            do_update = True
            if self._next_track_button != None:
                self._next_track_button.remove_value_listener(self._next_track_value)
            self._next_track_button = next_button
            if self._next_track_button != None:
                self._next_track_button.add_value_listener(self._next_track_value)
        if prev_button is not self._prev_track_button:
            do_update = True
            if self._prev_track_button != None:
                self._prev_track_button.remove_value_listener(self._prev_track_value)
            self._prev_track_button = prev_button
            if self._prev_track_button != None:
                self._prev_track_button.add_value_listener(self._prev_track_value)
        if do_update:
            self.on_selected_track_changed()

    def tracks_to_use(self):
        list_of_tracks = None
        if self._mixer != None:
            list_of_tracks = self._mixer.tracks_to_use()
        elif self._alt_mixer != None:
            list_of_tracks = self._alt_mixer.tracks_to_use()
        else:
            list_of_tracks = self.song().visible_tracks
        return list_of_tracks

    def track_banking_increment(self):
        return self._track_banking_increment

    def _change_offsets(self, track_increment, scene_increment):
        if not track_increment != 0:
            offsets_changed = scene_increment != 0
            if offsets_changed:
                self._track_offset += track_increment
                self._scene_offset += scene_increment
                if self._mixer != None:
                    self._mixer.set_track_offset(self.track_offset())
                if self._alt_mixer != None:
                    self._alt_mixer.set_track_offset(self.track_offset())
            self._reassign_tracks()
            if offsets_changed:
                self._reassign_scenes()
                self.notify_offset()
                self.width() > 0 and self.height() > 0 and self._do_show_highlight()

    def _next_track_value(self, value):
        if self.is_enabled():
            if value is not 0 or not self._next_track_button.is_momentary():
                selected_track = self.song().view.selected_track
                all_tracks = self.song().visible_tracks + self.song().return_tracks + (self.song().master_track,)
                if selected_track != all_tracks[-1]:
                    index = list(all_tracks).index(selected_track)
                    self.song().view.selected_track = all_tracks[index + 1]

    def _prev_track_value(self, value):
        if self.is_enabled():
            if value is not 0 or not self._prev_track_button.is_momentary():
                selected_track = self.song().view.selected_track
                all_tracks = self.song().visible_tracks + self.song().return_tracks + (self.song().master_track,)
                if selected_track != all_tracks[0]:
                    index = list(all_tracks).index(selected_track)
                    self.song().view.selected_track = all_tracks[index - 1]
########NEW FILE########
__FILENAME__ = TransportViewModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_25_49_61/TransportViewModeSelector.py
from _Framework.ModeSelectorComponent import ModeSelectorComponent

class TransportViewModeSelector(ModeSelectorComponent):
    """ Class that reassigns specific buttons based on the views visible in Live """

    def __init__(self, transport, session, ffwd_button, rwd_button, loop_button):
        ModeSelectorComponent.__init__(self)
        self._transport = transport
        self._session = session
        self._ffwd_button = ffwd_button
        self._rwd_button = rwd_button
        self._loop_button = loop_button
        self.application().view.add_is_view_visible_listener('Session', self._on_view_changed)
        self._on_view_changed()

    def disconnect(self):
        ModeSelectorComponent.disconnect(self)
        self._transport = None
        self._session = None
        self._ffwd_button = None
        self._rwd_button = None
        self._loop_button = None
        self.application().view.remove_is_view_visible_listener('Session', self._on_view_changed)

    def update(self):
        if self.is_enabled():
            if self._mode_index == 0:
                self._transport.set_seek_buttons(self._ffwd_button, self._rwd_button)
                self._transport.set_loop_button(self._loop_button)
                self._session.set_select_buttons(None, None)
                self._session.selected_scene().set_launch_button(None)
            else:
                self._transport.set_seek_buttons(None, None)
                self._transport.set_loop_button(None)
                self._session.set_select_buttons(self._ffwd_button, self._rwd_button)
                self._session.selected_scene().set_launch_button(self._loop_button)

    def _on_view_changed(self):
        if self.application().view.is_view_visible('Session'):
            self._mode_index = 1
        else:
            self._mode_index = 0
        self.update()
########NEW FILE########
__FILENAME__ = AxiomAirMini32
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_Mini32/AxiomAirMini32.py
from __future__ import with_statement
import Live
from _Framework.ControlSurface import ControlSurface
from _Framework.InputControlElement import MIDI_CC_TYPE
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import EncoderElement
from _Framework.TransportComponent import TransportComponent
from _Framework.SessionComponent import SessionComponent
from _Framework.MixerComponent import MixerComponent
from _Framework.ChannelStripComponent import ChannelStripComponent
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from Axiom_DirectLink.BestBankDeviceComponent import BestBankDeviceComponent
from EncoderMixerModeSelector import EncoderMixerModeSelector
from MixerOrDeviceModeSelector import MixerOrDeviceModeSelector
from DeviceNavComponent import DeviceNavComponent
SYSEX_START = (240, 0, 1, 5, 32, 127)
ENGAGE_HYPERCONTROL = (32, 60, 247)
DISABLE_HYPERCONTROL = (32, 0, 247)
NUM_TRACKS = 8
GLOBAL_CHANNEL = 15
PAD_TRANSLATIONS = ((0, 0, 85, 14),
 (1, 0, 86, 14),
 (2, 0, 87, 14),
 (3, 0, 88, 14),
 (0, 1, 81, 14),
 (1, 1, 82, 14),
 (2, 1, 83, 14),
 (3, 1, 84, 14),
 (0, 2, 85, 15),
 (1, 2, 86, 15),
 (2, 2, 87, 15),
 (3, 2, 88, 15),
 (0, 3, 81, 15),
 (1, 3, 82, 15),
 (2, 3, 83, 15),
 (3, 3, 84, 15))

def make_button(cc_no):
    is_momentary = True
    return ButtonElement(is_momentary, MIDI_CC_TYPE, GLOBAL_CHANNEL, cc_no)


def make_encoder(cc_no):
    return EncoderElement(MIDI_CC_TYPE, GLOBAL_CHANNEL, cc_no, Live.MidiMap.MapMode.absolute)


class AxiomAirMini32(ControlSurface):
    """ Script for the M-Audio Axiom A.I.R. Mini 32 """

    def __init__(self, c_instance):
        ControlSurface.__init__(self, c_instance)
        with self.component_guard():
            self._suggested_input_port = 'HyperControl'
            self._suggested_output_port = 'HyperControl'
            self._device_selection_follows_track_selection = True
            self.set_pad_translations(PAD_TRANSLATIONS)
            stop_button = make_button(116)
            play_button = make_button(117)
            record_button = make_button(118)
            select_button = make_button(98)
            nav_left_button = make_button(99)
            nav_right_button = make_button(100)
            nav_up_button = make_button(101)
            nav_down_button = make_button(102)
            mixer_modes_toggle = make_button(58)
            mixer_or_device_toggle = make_button(59)
            hypercontrol_mode_toggle = make_button(60)
            encoders = tuple([ make_encoder(33 + index) for index in range(8) ])
            transport = TransportComponent()
            transport.set_stop_button(stop_button)
            transport.set_play_button(play_button)
            transport.set_record_button(record_button)
            session = SessionComponent(0, 0)
            session.set_track_banking_increment(8)
            device = BestBankDeviceComponent()
            self.set_device_component(device)
            device_nav = DeviceNavComponent()
            mixer = SpecialMixerComponent(NUM_TRACKS)
            session.set_mixer(mixer)
            mixer_encoder_modes = EncoderMixerModeSelector(mixer)
            mixer_encoder_modes.set_mode_toggle(mixer_modes_toggle)
            mixer_or_device = MixerOrDeviceModeSelector(encoders, select_button, nav_up_button, nav_down_button, nav_left_button, nav_right_button, mixer, session, device, mixer_encoder_modes, device_nav)
            mixer_or_device.set_mode_buttons((mixer_modes_toggle, mixer_or_device_toggle, hypercontrol_mode_toggle))

    def refresh_state(self):
        ControlSurface.refresh_state(self)
        self.schedule_message(5, self._send_midi, SYSEX_START + ENGAGE_HYPERCONTROL)
        for component in self.components:
            if isinstance(component, ModeSelectorComponent):
                component.set_mode(0)

    def handle_sysex(self, midi_bytes):
        pass

    def disconnect(self):
        ControlSurface.disconnect(self)
        self._send_midi(SYSEX_START + DISABLE_HYPERCONTROL)


class SpecialMixerComponent(MixerComponent):
    """ Special mixer class that uses return tracks alongside midi and audio tracks """

    def tracks_to_use(self):
        return tuple(self.song().visible_tracks) + tuple(self.song().return_tracks)

    def _create_strip(self):
        return SpecialChanStripComponent()


class SpecialChanStripComponent(ChannelStripComponent):
    """ Special channel strip class that allows arm button for master track,
    for use with mixer.selected_strip() """

    def set_arm_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if button != self._arm_button:
                if self._arm_button != None:
                    self._arm_button.remove_value_listener(self._arm_value)
                    self._arm_button.reset()
                self._arm_pressed = False
                self._arm_button = button
                self._arm_button != None and self._arm_button.add_value_listener(self._arm_value)
            self.update()
########NEW FILE########
__FILENAME__ = DeviceNavComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_Mini32/DeviceNavComponent.py
import Live
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent

class DeviceNavComponent(ControlSurfaceComponent):
    """ Component that can navigate the selection of devices """

    def __init__(self):
        ControlSurfaceComponent.__init__(self)
        self._left_button = None
        self._right_button = None

    def disconnect(self):
        if self._left_button != None:
            self._left_button.remove_value_listener(self._nav_value)
            self._left_button = None
        if self._right_button != None:
            self._right_button.remove_value_listener(self._nav_value)
            self._right_button = None

    def set_device_nav_buttons(self, left_button, right_button):
        identify_sender = True
        if self._left_button != None:
            self._left_button.remove_value_listener(self._nav_value)
        self._left_button = left_button
        if self._left_button != None:
            self._left_button.add_value_listener(self._nav_value, identify_sender)
        if self._right_button != None:
            self._right_button.remove_value_listener(self._nav_value)
        self._right_button = right_button
        if self._right_button != None:
            self._right_button.add_value_listener(self._nav_value, identify_sender)
        self.update()

    def on_enabled_changed(self):
        self.update()

    def update(self):
        if self.is_enabled():
            pass

    def _nav_value(self, value, sender):
        if self.is_enabled():
            if not sender.is_momentary() or value != 0:
                app_view = self.application().view
                if not app_view.is_view_visible('Detail') or not app_view.is_view_visible('Detail/DeviceChain'):
                    app_view.show_view('Detail')
                    app_view.show_view('Detail/DeviceChain')
                else:
                    directions = Live.Application.Application.View.NavDirection
                    direction = directions.right if sender == self._right_button else directions.left
                    modifier_pressed = True
                    app_view.scroll_view(direction, 'Detail/DeviceChain', not modifier_pressed)
########NEW FILE########
__FILENAME__ = EncoderMixerModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_Mini32/EncoderMixerModeSelector.py
from _Framework.ModeSelectorComponent import ModeSelectorComponent

class EncoderMixerModeSelector(ModeSelectorComponent):
    """ Class that reassigns encoders on the AxiomAirMini32 to different mixer functions """

    def __init__(self, mixer):
        ModeSelectorComponent.__init__(self)
        self._mixer = mixer
        self._controls = None

    def disconnect(self):
        self._mixer = None
        self._controls = None
        ModeSelectorComponent.disconnect(self)

    def set_mode_toggle(self, button):
        ModeSelectorComponent.set_mode_toggle(self, button)
        self.set_mode(0)

    def set_controls(self, controls):
        self._controls = controls
        self.update()

    def number_of_modes(self):
        return 2

    def update(self):
        if self.is_enabled() and self._controls != None:
            mode = self._mode_index
            for index in range(len(self._controls)):
                strip = self._mixer.channel_strip(index)
                if mode == 0:
                    strip.set_pan_control(None)
                    strip.set_volume_control(self._controls[index])
                elif mode == 1:
                    strip.set_volume_control(None)
                    strip.set_pan_control(self._controls[index])
########NEW FILE########
__FILENAME__ = MixerOrDeviceModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_AIR_Mini32/MixerOrDeviceModeSelector.py
from _Framework.ModeSelectorComponent import ModeSelectorComponent

class MixerOrDeviceModeSelector(ModeSelectorComponent):
    """ Class that toggles between mixer and device modes """

    def __init__(self, encoders, select_button, up_button, down_button, left_button, right_button, mixer, session, device, mixer_modes, device_nav):
        ModeSelectorComponent.__init__(self)
        self._encoders = encoders
        self._select_button = select_button
        self._up_button = up_button
        self._down_button = down_button
        self._left_button = left_button
        self._right_button = right_button
        self._mixer = mixer
        self._session = session
        self._device = device
        self._mixer_modes = mixer_modes
        self._device_nav = device_nav

    def disconnect(self):
        self._encoders = None
        self._select_button = None
        self._up_button = None
        self._down_button = None
        self._left_button = None
        self._right_button = None
        self._mixer = None
        self._session = None
        self._device = None
        self._mixer_modes = None
        self._device_nav = None
        ModeSelectorComponent.disconnect(self)

    def number_of_modes(self):
        return 3

    def update(self):
        if self.is_enabled():
            if self._mode_index == 0:
                self._device.set_parameter_controls(None)
                self._mixer_modes.set_controls(self._encoders)
                self._device.set_bank_nav_buttons(None, None)
                self._device_nav.set_device_nav_buttons(None, None)
                self._mixer.set_select_buttons(self._down_button, self._up_button)
                self._session.set_track_bank_buttons(self._right_button, self._left_button)
                self._device.set_on_off_button(None)
                self._mixer.selected_strip().set_arm_button(self._select_button)
            elif self._mode_index == 1:
                self._mixer_modes.set_controls(None)
                self._device.set_parameter_controls(self._encoders)
                self._mixer.set_select_buttons(None, None)
                self._session.set_track_bank_buttons(None, None)
                self._device.set_bank_nav_buttons(self._left_button, self._right_button)
                self._device_nav.set_device_nav_buttons(self._up_button, self._down_button)
                self._mixer.selected_strip().set_arm_button(None)
                self._device.set_on_off_button(self._select_button)
            elif self._mode_index == 2:
                self._mixer_modes.set_controls(None)
                self._device.set_parameter_controls(None)
                self._device.set_bank_nav_buttons(None, None)
                self._device_nav.set_device_nav_buttons(None, None)
                self._mixer.set_select_buttons(None, None)
                self._session.set_track_bank_buttons(None, None)
                self._device.set_on_off_button(None)
                self._mixer.selected_strip().set_arm_button(None)
########NEW FILE########
__FILENAME__ = Axiom_DirectLink
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_DirectLink/Axiom_DirectLink.py
from __future__ import with_statement
import Live
from _Framework.ControlSurface import ControlSurface
from _Framework.ControlElement import ControlElement
from _Framework.InputControlElement import *
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import EncoderElement
from _Framework.PhysicalDisplayElement import PhysicalDisplayElement
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.ChannelStripComponent import ChannelStripComponent
from _Framework.MixerComponent import MixerComponent
from _Framework.TransportComponent import TransportComponent
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from _Framework.ClipSlotComponent import ClipSlotComponent
from _Framework.SceneComponent import SceneComponent
from _Framework.SessionComponent import SessionComponent
from TransportViewModeSelector import TransportViewModeSelector
from ShiftableMixerComponent import ShiftableMixerComponent
from ShiftableSessionComponent import ShiftableSessionComponent
from ShiftableTransportComponent import ShiftableTransportComponent
from PeekableEncoderElement import PeekableEncoderElement
from BestBankDeviceComponent import BestBankDeviceComponent
from DetailViewCntrlComponent import DetailViewCntrlComponent
INITIAL_DISPLAY_DELAY = 20
STANDARD_DISPLAY_DELAY = 10
IS_MOMENTARY = True
SYSEX_START = (240, 0, 1, 5, 32, 127)
PAD_TRANSLATIONS = ((0, 3, 60, 15),
 (1, 3, 62, 15),
 (2, 3, 64, 15),
 (3, 3, 65, 15),
 (0, 2, 67, 15),
 (1, 2, 69, 15),
 (2, 2, 71, 15),
 (3, 2, 72, 15))

class Axiom_DirectLink(ControlSurface):
    """ Script for the M-Audio Axiom DirectLink """

    def __init__(self, c_instance):
        ControlSurface.__init__(self, c_instance)
        with self.component_guard():
            self.set_pad_translations(PAD_TRANSLATIONS)
            self._device_selection_follows_track_selection = True
            self._suggested_input_port = 'DirectLink'
            self._suggested_output_port = 'DirectLink'
            self._waiting_for_first_response = True
            self._has_sliders = True
            self._current_midi_map = None
            self._display_reset_delay = -1
            self._shift_pressed = False
            self._shift_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 15, 13)
            self._master_slider = SliderElement(MIDI_CC_TYPE, 15, 41)
            self._next_nav_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 15, 111)
            self._prev_nav_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 15, 110)
            self._device_bank_buttons = None
            self._device_navigation = None
            self._shift_button.name = 'Shift_Button'
            self._master_slider.name = 'Master_Volume_Control'
            self._next_nav_button.name = 'Next_Track_Button'
            self._prev_nav_button.name = 'Prev_Track_Button'
            self._master_slider.add_value_listener(self._slider_value, identify_sender=True)
            self._shift_button.add_value_listener(self._shift_value)
            self._setup_mixer()
            self._setup_transport_and_session()
            self._setup_device()
            self._setup_display()
            for component in self.components:
                component.set_enabled(False)

    def refresh_state(self):
        ControlSurface.refresh_state(self)
        self._waiting_for_first_response = True
        self.schedule_message(3, self._send_midi, SYSEX_START + (32, 46, 247))

    def handle_sysex(self, midi_bytes):
        if midi_bytes[0:-2] == SYSEX_START + (32,) and midi_bytes[-2] != 0:
            self._has_sliders = midi_bytes[-2] & 8 != 0
            if self._waiting_for_first_response:
                self._waiting_for_first_response = False
                self.schedule_message(1, self._show_startup_message)
                for component in self.components:
                    component.set_enabled(True)

            if self._has_sliders:
                self._mixer.master_strip().set_volume_control(self._master_slider)
                self._mixer.update()
            else:
                self._mixer.master_strip().set_volume_control(None)
                self._mixer.selected_strip().set_volume_control(self._master_slider)
            self.request_rebuild_midi_map()

    def disconnect(self):
        self._display_data_source.set_display_string('  ')
        self._shift_button.remove_value_listener(self._shift_value)
        self._inst_button.remove_value_listener(self._inst_value)
        for encoder in self._encoders:
            encoder.remove_value_listener(self._encoder_value)

        for slider in tuple(self._sliders) + (self._master_slider,):
            slider.remove_value_listener(self._slider_value)

        for button in tuple(self._strip_buttons) + (self._selected_mute_solo_button,):
            button.remove_value_listener(self._mixer_button_value)

        for button in self._device_bank_buttons:
            button.remove_value_listener(self._device_bank_value)

        self._encoders = None
        self._sliders = None
        self._strip_buttons = None
        self._master_slider = None
        self._current_midi_map = None
        self._selected_mute_solo_button = None
        self._inst_button = None
        self._shift_button = None
        self._device_navigation = None
        self._display = None
        ControlSurface.disconnect(self)
        self._send_midi(SYSEX_START + (32, 0, 247))

    def build_midi_map(self, midi_map_handle):
        self._current_midi_map = midi_map_handle
        ControlSurface.build_midi_map(self, midi_map_handle)

    def update_display(self):
        ControlSurface.update_display(self)
        if self._display_reset_delay >= 0:
            self._display_reset_delay -= 1
            if self._display_reset_delay == -1:
                self._show_current_track_name()

    def _setup_mixer(self):
        self._selected_mute_solo_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 15, 12)
        mute_solo_flip_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 15, 57)
        self._strip_buttons = []
        self._selected_mute_solo_button.name = 'Selected_Mute_Button'
        mute_solo_flip_button.name = 'Mute_Solo_Flip_Button'
        self._selected_mute_solo_button.add_value_listener(self._mixer_button_value, identify_sender=True)
        self._mixer = ShiftableMixerComponent(8)
        self._mixer.name = 'Mixer'
        self._mixer.set_shift_button(self._shift_button)
        self._mixer.set_selected_mute_solo_button(self._selected_mute_solo_button)
        self._mixer.set_select_buttons(self._next_nav_button, self._prev_nav_button)
        self._mixer.selected_strip().name = 'Selected_Channel_Strip'
        self._mixer.master_strip().name = 'Master_Channel_Strip'
        self._mixer.master_strip().set_volume_control(self._master_slider)
        self._sliders = []
        for index in range(8):
            strip = self._mixer.channel_strip(index)
            strip.name = 'Channel_Strip_' + str(index)
            strip.set_invert_mute_feedback(True)
            self._sliders.append(SliderElement(MIDI_CC_TYPE, 15, 33 + index))
            self._sliders[-1].name = str(index) + '_Volume_Control'
            self._sliders[-1].set_feedback_delay(-1)
            self._sliders[-1].add_value_listener(self._slider_value, identify_sender=True)
            strip.set_volume_control(self._sliders[-1])
            self._strip_buttons.append(ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 15, 49 + index))
            self._strip_buttons[-1].name = str(index) + '_Mute_Button'
            self._strip_buttons[-1].add_value_listener(self._mixer_button_value, identify_sender=True)

        self._mixer.set_strip_mute_solo_buttons(tuple(self._strip_buttons), mute_solo_flip_button)

    def _setup_transport_and_session(self):
        ffwd_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 15, 115)
        rwd_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 15, 114)
        loop_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 15, 113)
        play_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 15, 117)
        stop_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 15, 116)
        rec_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 15, 118)
        ffwd_button.name = 'FFwd_Button'
        rwd_button.name = 'Rwd_Button'
        loop_button.name = 'Loop_Button'
        play_button.name = 'Play_Button'
        stop_button.name = 'Stop_Button'
        rec_button.name = 'Record_Button'
        transport = ShiftableTransportComponent()
        transport.name = 'Transport'
        transport.set_shift_button(self._shift_button)
        transport.set_stop_button(stop_button)
        transport.set_play_button(play_button)
        transport.set_record_button(rec_button)
        pads = []
        for index in range(len(PAD_TRANSLATIONS)):
            pads.append(ButtonElement(IS_MOMENTARY, MIDI_NOTE_TYPE, 15, PAD_TRANSLATIONS[index][2]))
            pads[-1].name = 'Pad_' + str(index)

        self._session = ShiftableSessionComponent(8, 0)
        self._session.name = 'Session_Control'
        self._session.selected_scene().name = 'Selected_Scene'
        self._session.set_mixer(self._mixer)
        self._session.set_shift_button(self._shift_button)
        self._session.set_clip_slot_buttons(tuple(pads))
        transport_view_modes = TransportViewModeSelector(transport, self._session, ffwd_button, rwd_button, loop_button)
        transport_view_modes.name = 'Transport_View_Modes'

    def _setup_device(self):
        self._encoders = []
        for offset in range(8):
            self._encoders.append(PeekableEncoderElement(MIDI_CC_TYPE, 15, 17 + offset, Live.MidiMap.MapMode.relative_smooth_two_compliment))
            self._encoders[-1].set_feedback_delay(-1)
            self._encoders[-1].add_value_listener(self._encoder_value, identify_sender=True)
            self._encoders[-1].name = 'Device_Control_' + str(offset)

        prev_bank_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 15, 14)
        next_bank_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 15, 15)
        prev_bank_button.name = 'Device_Bank_Down_Button'
        next_bank_button.name = 'Device_Bank_Up_Button'
        device = BestBankDeviceComponent()
        device.name = 'Device_Component'
        self.set_device_component(device)
        device.set_parameter_controls(tuple(self._encoders))
        device.set_bank_nav_buttons(prev_bank_button, next_bank_button)
        self._device_bank_buttons = (prev_bank_button, next_bank_button)
        prev_bank_button.add_value_listener(self._device_bank_value)
        next_bank_button.add_value_listener(self._device_bank_value)
        self._inst_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 15, 109)
        self._inst_button.name = 'Inst_Button'
        self._inst_button.add_value_listener(self._inst_value)
        self._device_navigation = DetailViewCntrlComponent()
        self._device_navigation.name = 'Device_Navigation_Component'

    def _setup_display(self):
        self._display = PhysicalDisplayElement(5, 1)
        self._display.name = 'Display'
        self._display.set_message_parts(SYSEX_START + (17, 1, 0, 0), (247,))
        self._display_data_source = DisplayDataSource()
        self._display.segment(0).set_data_source(self._display_data_source)

    def _on_selected_track_changed(self):
        ControlSurface._on_selected_track_changed(self)
        self._show_current_track_name()

    def _shift_value(self, value):
        if not value in range(128):
            raise AssertionError
            self._shift_pressed = value > 0
            for encoder in self._encoders:
                encoder.set_peek_mode(self._shift_pressed)

            self._shift_pressed and self._mixer.set_select_buttons(None, None)
            self._session.set_track_bank_buttons(self._next_nav_button, self._prev_nav_button)
            self._device_component.set_bank_nav_buttons(None, None)
            self._device_navigation.set_device_nav_buttons(self._device_bank_buttons[0], self._device_bank_buttons[1])
        else:
            self._session.set_track_bank_buttons(None, None)
            self._mixer.set_select_buttons(self._next_nav_button, self._prev_nav_button)
            self._device_navigation.set_device_nav_buttons(None, None)
            self._device_component.set_bank_nav_buttons(self._device_bank_buttons[0], self._device_bank_buttons[1])
        self.request_rebuild_midi_map()

    def _encoder_value(self, value, sender):
        if not sender in self._encoders:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                display_string = self._device_component.is_enabled() and ' - '
                display_string = sender.mapped_parameter() != None and sender.mapped_parameter().name
            self._display_data_source.set_display_string(display_string)
            self._set_display_data_source(self._display_data_source)
            self._display_reset_delay = STANDARD_DISPLAY_DELAY

    def _slider_value(self, value, sender):
        if not sender in tuple(self._sliders) + (self._master_slider,):
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self._mixer.is_enabled():
                    display_string = ' - '
                    if sender.mapped_parameter() != None:
                        master = self.song().master_track
                        tracks = self.song().tracks
                        returns = self.song().return_tracks
                        track = None
                        if sender == self._master_slider:
                            track = self._has_sliders and master
                        else:
                            track = self.song().view.selected_track
                    else:
                        track = self._mixer.channel_strip(self._sliders.index(sender))._track
                    display_string = track == master and 'Ma'
                elif track in tracks:
                    display_string = str(list(tracks).index(track) + 1)
                elif track in returns:
                    display_string = str(chr(ord('A') + list(returns).index(track)))
                else:
                    raise False or AssertionError
                display_string += ' Vol'
            self._display_data_source.set_display_string(display_string)
            self._set_display_data_source(self._display_data_source)
            self._display_reset_delay = STANDARD_DISPLAY_DELAY

    def _mixer_button_value(self, value, sender):
        if not sender in tuple(self._strip_buttons) + (self._selected_mute_solo_button,):
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self._mixer.is_enabled() and value > 0:
                    strip = None
                    strip = sender == self._selected_mute_solo_button and self._mixer.selected_strip()
                else:
                    strip = self._mixer.channel_strip(self._strip_buttons.index(sender))
                strip != None and self._set_display_data_source(strip.track_name_data_source())
            else:
                self._display_data_source.set_display_string(' - ')
                self._set_display_data_source(self._display_data_source)
            self._display_reset_delay = STANDARD_DISPLAY_DELAY

    def _device_bank_value(self, value):
        if not value in range(128):
            raise AssertionError
            if self._device_component.is_enabled() and value > 0:
                data_source = self._device_component.bank_name_data_source()
                data_source = self._shift_pressed and self._device_component.device_name_data_source()
            self._set_display_data_source(data_source)
            self._display_reset_delay = STANDARD_DISPLAY_DELAY

    def _inst_value(self, value):
        if not value in range(128):
            raise AssertionError
            value > 0 and self._device_component.is_enabled() and self.song().view.selected_track.view.select_instrument() and self._set_display_data_source(self._device_component.device_name_data_source())
            self._display_reset_delay = STANDARD_DISPLAY_DELAY

    def _show_current_track_name(self):
        if self._display != None and self._mixer != None:
            self._set_display_data_source(self._mixer.selected_strip().track_name_data_source())

    def _show_startup_message(self):
        self._display.display_message('LIVE')
        self._display_reset_delay = INITIAL_DISPLAY_DELAY

    def _set_display_data_source(self, data_source):
        raise isinstance(data_source, DisplayDataSource) or AssertionError
        self._display.segment(0).set_data_source(data_source)
        data_source.update()
########NEW FILE########
__FILENAME__ = BestBankDeviceComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_DirectLink/BestBankDeviceComponent.py
import Live
from _Framework.DeviceComponent import DeviceComponent
from _Framework.DisplayDataSource import DisplayDataSource
from _Generic.Devices import parameter_bank_names, parameter_banks, DEVICE_DICT, BANK_NAME_DICT, DEVICE_BOB_DICT
BOP_BANK_NAME = 'Best of Parameters'

class BestBankDeviceComponent(DeviceComponent):
    """ Special Device component that uses the best of bank of a device as default """

    def __init__(self):
        DeviceComponent.__init__(self)
        new_banks = {}
        new_bank_names = {}
        self._device_banks = DEVICE_DICT
        self._device_bank_names = BANK_NAME_DICT
        self._device_best_banks = DEVICE_BOB_DICT
        for device_name, current_banks in self._device_banks.iteritems():
            raise len(current_banks) > 1 and (device_name in self._device_best_banks.keys() or AssertionError), "Could not find best-of-banks for '%s'" % device_name
            if not device_name in self._device_bank_names.keys():
                raise AssertionError, "Could not find bank names for '%s'" % device_name
                current_banks = self._device_best_banks[device_name] + current_banks
                new_bank_names[device_name] = (BOP_BANK_NAME,) + self._device_bank_names[device_name]
            new_banks[device_name] = current_banks

        self._device_banks = new_banks
        self._device_bank_names = new_bank_names
        self._bank_name_data_source = DisplayDataSource()

    def disconnect(self):
        self._bank_name_data_source = None
        DeviceComponent.disconnect(self)

    def bank_name_data_source(self):
        return self._bank_name_data_source

    def _bank_up_value(self, value):
        DeviceComponent._bank_up_value(self, value)
        self._update_bank_display()

    def _bank_down_value(self, value):
        DeviceComponent._bank_down_value(self, value)
        self._update_bank_display()

    def _update_bank_display(self):
        if self.is_enabled():
            bank_name = ''
            if self._device != None and self._bank_name != '<No Bank>':
                bank_name = self._bank_name
                if bank_name in (BOP_BANK_NAME, 'Bank 1'):
                    bank_name = 'Home'
            self._bank_name_data_source.set_display_string(bank_name)

    def _is_banking_enabled(self):
        return True

    def _number_of_parameter_banks(self):
        result = 0
        if self._device != None:
            if self._device.class_name in self._device_banks.keys():
                result = len(self._device_banks[self._device.class_name])
            else:
                result = DeviceComponent._number_of_parameter_banks(self)
        return result

    def _parameter_banks(self):
        return parameter_banks(self._device, self._device_banks)

    def _parameter_bank_names(self):
        return parameter_bank_names(self._device, self._device_bank_names)
########NEW FILE########
__FILENAME__ = DetailViewCntrlComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_DirectLink/DetailViewCntrlComponent.py
import Live
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.ButtonElement import ButtonElement

class DetailViewCntrlComponent(ControlSurfaceComponent):
    """ Component that can navigate the selection of devices """

    def __init__(self):
        ControlSurfaceComponent.__init__(self)
        self._left_button = None
        self._right_button = None

    def disconnect(self):
        if self._left_button != None:
            self._left_button.remove_value_listener(self._nav_value)
            self._left_button = None
        if self._right_button != None:
            self._right_button.remove_value_listener(self._nav_value)
            self._right_button = None

    def set_device_nav_buttons(self, left_button, right_button):
        if not (left_button == None or isinstance(left_button, ButtonElement)):
            raise AssertionError
            if not (right_button == None or isinstance(right_button, ButtonElement)):
                raise AssertionError
                identify_sender = True
                if self._left_button != None:
                    self._left_button.remove_value_listener(self._nav_value)
                self._left_button = left_button
                if self._left_button != None:
                    self._left_button.add_value_listener(self._nav_value, identify_sender)
                self._right_button != None and self._right_button.remove_value_listener(self._nav_value)
            self._right_button = right_button
            self._right_button != None and self._right_button.add_value_listener(self._nav_value, identify_sender)
        self.update()

    def on_enabled_changed(self):
        self.update()

    def update(self):
        if self.is_enabled():
            if self._left_button != None:
                self._left_button.turn_off()
            if self._right_button != None:
                self._right_button.turn_off()

    def _nav_value(self, value, sender):
        raise sender != None and sender in (self._left_button, self._right_button) or AssertionError
        if self.is_enabled():
            if not sender.is_momentary() or value != 0:
                modifier_pressed = True
                if not self.application().view.is_view_visible('Detail') or not self.application().view.is_view_visible('Detail/DeviceChain'):
                    self.application().view.show_view('Detail')
                    self.application().view.show_view('Detail/DeviceChain')
                else:
                    direction = Live.Application.Application.View.NavDirection.left
                    if sender == self._right_button:
                        direction = Live.Application.Application.View.NavDirection.right
                    self.application().view.scroll_view(direction, 'Detail/DeviceChain', not modifier_pressed)
########NEW FILE########
__FILENAME__ = PeekableEncoderElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_DirectLink/PeekableEncoderElement.py
import Live
from _Framework.EncoderElement import EncoderElement
from _Framework.InputControlElement import *

class PeekableEncoderElement(EncoderElement):
    """ Encoder that can be connected and disconnected to a specific parameter """

    def __init__(self, msg_type, channel, identifier, map_mode):
        EncoderElement.__init__(self, msg_type, channel, identifier, map_mode)
        self._peek_mode = False

    def set_peek_mode(self, peek_mode):
        if not isinstance(peek_mode, type(False)):
            raise AssertionError
            self._peek_mode = self._peek_mode != peek_mode and peek_mode
            self._request_rebuild()

    def get_peek_mode(self):
        return self._peek_mode

    def install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback):
        current_parameter = self._parameter_to_map_to
        if self._peek_mode:
            self._parameter_to_map_to = None
        InputControlElement.install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback)
        self._parameter_to_map_to = current_parameter
########NEW FILE########
__FILENAME__ = ShiftableMixerComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_DirectLink/ShiftableMixerComponent.py
from _Framework.MixerComponent import MixerComponent
from _Framework.ButtonElement import ButtonElement

class ShiftableMixerComponent(MixerComponent):
    """ Special mixer class that reassigns controls based on a shift button """

    def __init__(self, num_tracks):
        self._shift_button = None
        self._selected_mute_solo_button = None
        self._strip_mute_solo_buttons = None
        self._mute_solo_flip_button = None
        MixerComponent.__init__(self, num_tracks)
        self._selected_tracks = []
        self._register_timer_callback(self._on_timer)

    def disconnect(self):
        self._unregister_timer_callback(self._on_timer)
        self._selected_tracks = None
        MixerComponent.disconnect(self)
        if self._shift_button != None:
            self._shift_button.remove_value_listener(self._shift_value)
            self._shift_button = None
        if self._mute_solo_flip_button != None:
            self._mute_solo_flip_button.remove_value_listener(self._mute_solo_flip_value)
            self._mute_solo_flip_button = None
        self._selected_mute_solo_button = None
        self._strip_mute_solo_buttons = None

    def set_shift_button(self, shift_button):
        if not (shift_button == None or shift_button.is_momentary()):
            raise AssertionError
            if self._shift_button != None:
                self._shift_button.remove_value_listener(self._shift_value)
            self._shift_button = shift_button
            self._shift_button != None and self._shift_button.add_value_listener(self._shift_value)

    def set_selected_mute_solo_button(self, button):
        raise isinstance(button, (type(None), ButtonElement)) or AssertionError
        self._selected_mute_solo_button = button
        self.selected_strip().set_mute_button(self._selected_mute_solo_button)
        self.selected_strip().set_solo_button(None)

    def set_strip_mute_solo_buttons(self, buttons, flip_button):
        if not (buttons is None or isinstance(buttons, tuple) and len(buttons) == len(self._channel_strips)):
            raise AssertionError
            if not isinstance(flip_button, (type(None), ButtonElement)):
                raise AssertionError
                self._mute_solo_flip_button != None and self._mute_solo_flip_button.remove_value_listener(self._mute_solo_flip_value)
            self._mute_solo_flip_button = flip_button
            self._mute_solo_flip_button != None and self._mute_solo_flip_button.add_value_listener(self._mute_solo_flip_value)
        self._strip_mute_solo_buttons = buttons
        for index in range(len(self._channel_strips)):
            strip = self.channel_strip(index)
            button = None
            if self._strip_mute_solo_buttons != None:
                button = self._strip_mute_solo_buttons[index]
            strip.set_mute_button(button)
            strip.set_solo_button(None)

    def tracks_to_use(self):
        return tuple(self.song().visible_tracks) + tuple(self.song().return_tracks)

    def _shift_value(self, value):
        if not self._shift_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value > 0 and self.selected_strip().set_mute_button(None)
            self.selected_strip().set_solo_button(self._selected_mute_solo_button)
        else:
            self.selected_strip().set_solo_button(None)
            self.selected_strip().set_mute_button(self._selected_mute_solo_button)

    def _mute_solo_flip_value(self, value):
        raise self._mute_solo_flip_button != None or AssertionError
        raise value in range(128) or AssertionError
        if self._strip_mute_solo_buttons != None:
            for index in range(len(self._strip_mute_solo_buttons)):
                strip = self.channel_strip(index)
                if value > 0:
                    strip.set_mute_button(None)
                    strip.set_solo_button(self._strip_mute_solo_buttons[index])
                else:
                    strip.set_solo_button(None)
                    strip.set_mute_button(self._strip_mute_solo_buttons[index])

    def _on_timer(self):
        sel_track = None
        while len(self._selected_tracks) > 0:
            track = self._selected_tracks[-1]
            if track != None and track.has_midi_input and track.can_be_armed and not track.arm:
                sel_track = track
                break
            del self._selected_tracks[-1]

        if sel_track != None:
            found_recording_clip = False
            song = self.song()
            tracks = song.tracks
            if song.is_playing:
                check_arrangement = song.record_mode
                for track in tracks:
                    if track.can_be_armed and track.arm:
                        if check_arrangement:
                            found_recording_clip = True
                            break
                        else:
                            playing_slot_index = track.playing_slot_index
                            if playing_slot_index in range(len(track.clip_slots)):
                                slot = track.clip_slots[playing_slot_index]
                                if slot.has_clip and slot.clip.is_recording:
                                    found_recording_clip = True
                                    break

                if found_recording_clip or song.exclusive_arm:
                    for track in tracks:
                        if track.can_be_armed and track.arm and track != sel_track:
                            track.arm = False

                sel_track.arm = True
                sel_track.view.select_instrument()
        self._selected_tracks = []

    def _next_track_value(self, value):
        MixerComponent._next_track_value(self, value)
        self._selected_tracks.append(self.song().view.selected_track)

    def _prev_track_value(self, value):
        MixerComponent._prev_track_value(self, value)
        self._selected_tracks.append(self.song().view.selected_track)
########NEW FILE########
__FILENAME__ = ShiftableSessionComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_DirectLink/ShiftableSessionComponent.py
from _Framework.SessionComponent import SessionComponent
from _Framework.ButtonElement import ButtonElement

class ShiftableSessionComponent(SessionComponent):
    """ Special session class that reassigns controls based on a shift button """

    def __init__(self, num_tracks, num_scenes):
        self._shift_button = None
        self._clip_slot_buttons = None
        SessionComponent.__init__(self, num_tracks, num_scenes)

    def disconnect(self):
        SessionComponent.disconnect(self)
        if self._shift_button != None:
            self._shift_button.remove_value_listener(self._shift_value)
            self._shift_button = None
        self._clip_slot_buttons = None

    def set_shift_button(self, shift_button):
        if not (shift_button == None or shift_button.is_momentary()):
            raise AssertionError
            if self._shift_button != None:
                self._shift_button.remove_value_listener(self._shift_value)
            self._shift_button = shift_button
            self._shift_button != None and self._shift_button.add_value_listener(self._shift_value)

    def set_clip_slot_buttons(self, buttons):
        raise buttons == None or isinstance(buttons, tuple) and len(buttons) == self._num_tracks or AssertionError
        self._clip_slot_buttons = buttons
        self._shift_value(0)

    def on_selected_track_changed(self):
        SessionComponent.on_selected_track_changed(self)
        selected_track = self.song().view.selected_track
        tracks = self.tracks_to_use()
        track_index = selected_track in tracks and list(tracks).index(selected_track)
        new_offset = track_index - track_index % self._num_tracks
        if not new_offset / self._num_tracks == int(new_offset / self._num_tracks):
            raise AssertionError
            self.set_offsets(new_offset, self.scene_offset())

    def _shift_value(self, value):
        raise self._shift_button != None or AssertionError
        raise value in range(128) or AssertionError
        for index in range(self._num_tracks):
            slot = self.selected_scene().clip_slot(index)
            if value == 0 or self._clip_slot_buttons == None:
                slot.set_launch_button(None)
            else:
                slot.set_launch_button(self._clip_slot_buttons[index])

    def _bank_right_value(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._bank_right_button != None:
                raise AssertionError
                self.is_enabled() and (value is not 0 or not self._bank_right_button.is_momentary()) and self.set_offsets(self._track_offset + self._num_tracks, self.scene_offset())

    def _bank_left_value(self, value):
        if not isinstance(value, int):
            raise AssertionError
            if not self._bank_left_button != None:
                raise AssertionError
                self.is_enabled() and (value is not 0 or not self._bank_left_button.is_momentary()) and self.set_offsets(max(0, self._track_offset - self._num_tracks), self.scene_offset())
########NEW FILE########
__FILENAME__ = ShiftableTransportComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_DirectLink/ShiftableTransportComponent.py
import Live
from _Framework.ButtonElement import ButtonElement
from _Framework.TransportComponent import TransportComponent

class ShiftableTransportComponent(TransportComponent):
    """ Special transport class handling the seek buttons differently based on a shift button"""

    def __init__(self):
        self._shift_button = None
        self._shift_pressed = False
        TransportComponent.__init__(self)

    def disconnect(self):
        if self._shift_button != None:
            self._shift_button.remove_value_listener(self._shift_value)
            self._shift_button = None
        TransportComponent.disconnect(self)

    def set_shift_button(self, button):
        if not (button == None or isinstance(button, ButtonElement) and button.is_momentary()):
            raise AssertionError
            if self._shift_button != button:
                if self._shift_button != None:
                    self._shift_button.remove_value_listener(self._shift_value)
                    self._shift_pressed = False
                self._shift_button = button
                self._shift_button != None and self._shift_button.add_value_listener(self._shift_value)

    def _shift_value(self, value):
        if not self._shift_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            self._shift_pressed = self.is_enabled() and value > 0

    def _ffwd_value(self, value):
        if not self._ffwd_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            self.song().current_song_time = self._shift_pressed and self.song().last_event_time
        else:
            TransportComponent._ffwd_value(self, value)

    def _rwd_value(self, value):
        if not self._rwd_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            self.song().current_song_time = self._shift_pressed and 0.0
        else:
            TransportComponent._rwd_value(self, value)
########NEW FILE########
__FILENAME__ = TransportViewModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Axiom_DirectLink/TransportViewModeSelector.py
import Live
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from _Framework.ButtonElement import ButtonElement
from _Framework.TransportComponent import TransportComponent
from _Framework.SessionComponent import SessionComponent

class TransportViewModeSelector(ModeSelectorComponent):
    """ Class that reassigns specific buttons based on the views visible in Live """

    def __init__(self, transport, session, ffwd_button, rwd_button, loop_button):
        raise isinstance(transport, TransportComponent) or AssertionError
        raise isinstance(session, SessionComponent) or AssertionError
        raise isinstance(ffwd_button, ButtonElement) or AssertionError
        raise isinstance(rwd_button, ButtonElement) or AssertionError
        raise isinstance(loop_button, ButtonElement) or AssertionError
        ModeSelectorComponent.__init__(self)
        self._transport = transport
        self._session = session
        self._ffwd_button = ffwd_button
        self._rwd_button = rwd_button
        self._loop_button = loop_button
        self.application().view.add_is_view_visible_listener('Session', self._on_view_changed)
        self.update()

    def disconnect(self):
        ModeSelectorComponent.disconnect(self)
        self._transport = None
        self._session = None
        self._ffwd_button = None
        self._rwd_button = None
        self._loop_button = None
        self.application().view.remove_is_view_visible_listener('Session', self._on_view_changed)

    def update(self):
        if self.is_enabled():
            if self._mode_index == 0:
                self._transport.set_seek_buttons(self._ffwd_button, self._rwd_button)
                self._transport.set_loop_button(self._loop_button)
                self._session.set_select_buttons(None, None)
                self._session.selected_scene().set_launch_button(None)
            else:
                self._transport.set_seek_buttons(None, None)
                self._transport.set_loop_button(None)
                self._session.set_select_buttons(self._ffwd_button, self._rwd_button)
                self._session.selected_scene().set_launch_button(self._loop_button)

    def _on_view_changed(self):
        if self.application().view.is_view_visible('Session'):
            self._mode_index = 1
        else:
            self._mode_index = 0
        self.update()
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/BCF2000/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = ((GENERIC_ENC1, 0),
 (GENERIC_ENC2, 0),
 (GENERIC_ENC3, 0),
 (GENERIC_ENC4, 0),
 (GENERIC_ENC5, 0),
 (GENERIC_ENC6, 0),
 (GENERIC_ENC7, 0),
 (GENERIC_ENC8, 0))
VOLUME_CONTROLS = ((GENERIC_SLI1, -1),
 (GENERIC_SLI2, -1),
 (GENERIC_SLI3, -1),
 (GENERIC_SLI4, -1),
 (GENERIC_SLI5, -1),
 (GENERIC_SLI6, -1),
 (GENERIC_SLI7, -1),
 (GENERIC_SLI8, -1))
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': GENERIC_PAD5,
 'PREVBANK': GENERIC_PAD1,
 'BANK1': 65,
 'BANK2': 66,
 'BANK3': 67,
 'BANK4': 68,
 'BANK5': 69,
 'BANK6': 70,
 'BANK7': 71,
 'BANK8': 72}
CONTROLLER_DESCRIPTIONS = {'INPUTPORT': 'BCF2000',
 'OUTPUTPORT': 'BCF2000',
 'CHANNEL': 0}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': -1}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/BCF2000/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = 89
GENERIC_PLAY = 90
GENERIC_REC = 91
GENERIC_LOOP = 92
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 1
GENERIC_ENC2 = 2
GENERIC_ENC3 = 3
GENERIC_ENC4 = 4
GENERIC_ENC5 = 5
GENERIC_ENC6 = 6
GENERIC_ENC7 = 7
GENERIC_ENC8 = 8
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 81
GENERIC_SLI2 = 82
GENERIC_SLI3 = 83
GENERIC_SLI4 = 84
GENERIC_SLI5 = 85
GENERIC_SLI6 = 86
GENERIC_SLI7 = 87
GENERIC_SLI8 = 88
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = 73
GENERIC_BUT2 = 74
GENERIC_BUT3 = 75
GENERIC_BUT4 = 76
GENERIC_BUT5 = 77
GENERIC_BUT6 = 78
GENERIC_BUT7 = 79
GENERIC_BUT8 = 80
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/BCR2000/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
VOLUME_CONTROLS = (97, 98, 99, 100, 101, 102, 103, 104)
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': -1,
 'PREVBANK': -1,
 'BANK1': GENERIC_PAD1,
 'BANK2': GENERIC_PAD2,
 'BANK3': GENERIC_PAD3,
 'BANK4': GENERIC_PAD4,
 'BANK5': GENERIC_PAD5,
 'BANK6': GENERIC_PAD6,
 'BANK7': GENERIC_PAD7,
 'BANK8': GENERIC_PAD8}
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'BCR2000',
 'OUTPUTPORT': 'BCR2000',
 'CHANNEL': 0}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': GENERIC_SLIDERS,
 'SEND2': (89, 90, 91, 92, 93, 94, 95, 96),
 'MASTERVOLUME': -1}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/BCR2000/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = 105
GENERIC_PLAY = 106
GENERIC_REC = 107
GENERIC_LOOP = 108
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 1
GENERIC_ENC2 = 2
GENERIC_ENC3 = 3
GENERIC_ENC4 = 4
GENERIC_ENC5 = 5
GENERIC_ENC6 = 6
GENERIC_ENC7 = 7
GENERIC_ENC8 = 8
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 81
GENERIC_SLI2 = 82
GENERIC_SLI3 = 83
GENERIC_SLI4 = 84
GENERIC_SLI5 = 85
GENERIC_SLI6 = 86
GENERIC_SLI7 = 87
GENERIC_SLI8 = 88
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = 73
GENERIC_BUT2 = 74
GENERIC_BUT3 = 75
GENERIC_BUT4 = 76
GENERIC_BUT5 = 77
GENERIC_BUT6 = 78
GENERIC_BUT7 = 79
GENERIC_BUT8 = 80
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = 65
GENERIC_PAD2 = 66
GENERIC_PAD3 = 67
GENERIC_PAD4 = 68
GENERIC_PAD5 = 69
GENERIC_PAD6 = 70
GENERIC_PAD7 = 71
GENERIC_PAD8 = 72
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = LiveOSC
"""
# Copyright (C) 2007 Nathan Ramella (nar@remix.net)
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# For questions regarding this module contact
# Nathan Ramella <nar@remix.net> or visit http://www.remix.net

This script is based off the Ableton Live supplied MIDI Remote Scripts, customised
for OSC request delivery and response. This script can be run without any extra
Python libraries out of the box. 

This is the second file that is loaded, by way of being instantiated through
__init__.py

"""

import Live
import LiveOSCCallbacks
import RemixNet
import OSC
import LiveUtils
import sys
from Logger import log
from _Framework.InputControlElement import *
from _Framework.TransportComponent import TransportComponent
from _Framework.ButtonElement import ButtonElement 
from _Framework.ControlSurface import ControlSurface 

class LiveOSC:
    __module__ = __name__
    __doc__ = "Main class that establishes the LiveOSC Component"
    #struct per emmagatzemar les referencies als callbacks per poder gestionarlos
    prlisten = {}
    plisten = {}
    dlisten = {}
    clisten = {}
    slisten = {}
    pplisten = {}
    cnlisten = {}
    cclisten = {}
    wlisten = {}
    llisten = {}
    #struct per emmagatzemar els listeners de noms
    dnlisten = {}
    sclisten = {}
    snlisten = {}
    
    _send_pos = {}
    
    mlisten = { "solo": {}, "mute": {}, "arm": {}, "panning": {}, "volume": {}, "sends": {}, "name": {}, "oml": {}, "omr": {}, "devices": {}, "color": {} }
    rlisten = { "solo": {}, "mute": {}, "panning": {}, "volume": {}, "sends": {}, "name": {}, "color": {} }
    masterlisten = { "panning": {}, "volume": {}, "crossfader": {} }
    scenelisten = {}
    
    scene = 0
    track = 0

    def __init__(self, c_instance):
        self._LiveOSC__c_instance = c_instance
      
        self.basicAPI = 0       
        self.oscEndpoint = RemixNet.OSCEndpoint()
        self.oscEndpoint.send('/remix/oscserver/startup', 1)
        """transport = TransportComponent()
        transport.set_play_button(ButtonElement(True, 0, 1, 28))"""
        log("LiveOSC initialized")
        # log("log "+str(LiveUtils.getSong().tracks[0].devices[0].name));
        # Visible tracks listener
        if self.song().tracks_has_listener(self.refresh_state) != 1:
            self.song().add_tracks_listener(self.refresh_state)
        
######################################################################
# Standard Ableton Methods

    def connect_script_instances(self, instanciated_scripts):
        """
        Called by the Application as soon as all scripts are initialized.
        You can connect yourself to other running scripts here, as we do it
        connect the extension modules
        """
        return

    def is_extension(self):
        return False

    def request_rebuild_midi_map(self):
        """
        To be called from any components, as soon as their internal state changed in a 
        way, that we do need to remap the mappings that are processed directly by the 
        Live engine.
        Dont assume that the request will immediately result in a call to
        your build_midi_map function. For performance reasons this is only
        called once per GUI frame.
        """
        return
    
    def update_display(self):
        """
        This function is run every 100ms, so we use it to initiate our Song.current_song_time
        listener to allow us to process incoming OSC commands as quickly as possible under
        the current listener scheme.
        """
        ######################################################
        # START OSC LISTENER SETUP
              
        if self.basicAPI == 0:
            # By default we have set basicAPI to 0 so that we can assign it after
            # initialization. We try to get the current song and if we can we'll
            # connect our basicAPI callbacks to the listener allowing us to 
            # respond to incoming OSC every 60ms.
            #
            # Since this method is called every 100ms regardless of the song time
            # changing, we use both methods for processing incoming UDP requests
            # so that from a resting state you can initiate play/clip triggering.

            try:
                doc = self.song()
            except:
                log('could not get song handle')
                return
            try:
                self.basicAPI = LiveOSCCallbacks.LiveOSCCallbacks(self._LiveOSC__c_instance, self.oscEndpoint)
                # Commented for stability
               
            except:
                self.oscEndpoint.send('/remix/echo', 'setting up basicAPI failed')
                log('setting up basicAPI failed');
                return
            
            # If our OSC server is listening, try processing incoming requests.
            # Any 'play' initiation will trigger the current_song_time listener
            # and bump updates from 100ms to 60ms.
            
        if self.oscEndpoint:
            try:
                self.oscEndpoint.processIncomingUDP()
            except:
                log('error processing incoming UDP packets:', sys.exc_info());
            
        if self.oscEndpoint:
            self.positions()
            #self.songtime_change()
            
        # END OSC LISTENER SETUP
        ######################################################

    """def current_song_time_changed(self):
        time = self.song().current_song_time
        if int(time) != self.time:
            self.time = int(time)
            self.oscEndpoint.send("/live/beat", self.time)"""

    def send_midi(self, midi_event_bytes):
        """
        Use this function to send MIDI events through Live to the _real_ MIDI devices 
        that this script is assigned to.
        """
        pass

    def receive_midi(self, midi_bytes):
        log("recived midi")
        return

    def can_lock_to_devices(self):
        return False

    def suggest_input_port(self):
        return ''

    def suggest_output_port(self):
        return ''
    
    def suggest_map_mode(self, cc_no, channel):
        return Live.MidiMap.MapMode.absolute

    def __handle_display_switch_ids(self, switch_id, value):
	pass
    
    
######################################################################
# Useful Methods

    def application(self):
        """returns a reference to the application that we are running in"""
        return Live.Application.get_application()

    def song(self):
        """returns a reference to the Live Song that we do interact with"""
        return self._LiveOSC__c_instance.song()

    def handle(self):
        """returns a handle to the c_interface that is needed when forwarding MIDI events via the MIDI map"""
        return self._LiveOSC__c_instance.handle()
            
    def getslots(self):
        tracks = self.song().tracks

        clipSlots = []
        for track in tracks:
            clipSlots.append(track.clip_slots)
        return clipSlots
    
    def positions(self):
        tracks = self.song().tracks
        pos = 0
        ps = 0
        if self.song().is_playing != 4: 
            for i in range(len(tracks)):
                track = tracks[i]
                if track.is_foldable != 1:
                    if track.playing_slot_index != -2:
                        if track.playing_slot_index != -1:
                            ps = track.playing_slot_index
                            clip = track.clip_slots[ps].clip
                            if clip.looping == 1:
                                if clip.playing_position < clip.loop_start:
                                    clip.looping = 0
                                    start = clip.loop_start
                                    end = clip.loop_end
                                    clip.looping = 1
                                    pos = round((clip.playing_position - start) / (end - start), 3)
                                    #pos = round((clip.loop_start - clip.playing_position) / (clip.loop_start - start), 3)
                                else:
                                    pos = round((clip.playing_position - clip.loop_start) / (clip.loop_end - clip.loop_start), 3)

                            else:
                                pos = round((clip.playing_position-clip.loop_start) / (clip.length), 3)
                            
                            self.oscEndpoint.send('/clip/playing_position',(i, ps, pos))
                        else:
                            pass
                    else:
                        pass

                else:
                    pass
        else:
            pass

    def trBlock(self, trackOffset, blocksize):
        block = []
        tracks = self.song().tracks
        
        for track in range(0, blocksize):
            block.extend([str(tracks[trackOffset+track].name)])                            
        self.oscEndpoint.send("/live/name/trackblock", block)
        self.oscEndpoint.send("/live/trackblock/refresh", block)

    def sendDeviceIds(self):
        block=[]
        block=LiveUtils.getTrackDevicesWithId()
        log("abans d'enviar osc deviceChange")
        self.oscEndpoint.send('/track/deviceChange', block)
        
    def sendTrackIds(self):
        log("entro a sendTrackIds")
        block=[]
        block=LiveUtils.getTrackWithId()
        log("abans d'enviar osc trackChange")
        self.oscEndpoint.send('/track/trackChange', block)
        

######################################################################
# Used Ableton Methods

    def disconnect(self):
        self.rem_clip_listeners()
        self.rem_mixer_listeners()
        self.rem_scene_listeners()
        self.rem_tempo_listener()
        self.rem_overdub_listener()
        self.rem_tracks_listener()
        self.rem_device_listeners()
        self.rem_transport_listener()
        self.rem_scenes_listeners()
        
        self.song().remove_tracks_listener(self.refresh_state)
        
        self.oscEndpoint.send('/remix/oscserver/shutdown', 1)
        self.oscEndpoint.shutdown()
            
    def build_midi_map(self, midi_map_handle):
        #self.refresh_state()
        """parameter=InputControlElement(MIDI_CC_TYPE,1,8)"""
        """self.parameter=self.song().tracks[0].devices[0].parameters[5].value
        channel=0
        cc=8
        Live.MidiMap.map_midi_cc(midi_map_handle, parameter, channel, cc, Live.MidiMap.MapMode.absolute, True)
        Live.MidiMap.forward_midi_cc(self._LiveOSC__c_instance.handle(), midi_map_handle, channel, cc)"""
        log("entro a build midi map")
        self.add_device_listeners()
            
    def refresh_state(self):
        log("entro a refresh state")
        self.add_clip_listeners()
        self.add_mixer_listeners()
        self.add_scene_listeners()
        self.add_scenes_listeners()
        self.add_tempo_listener()
        self.add_loop_listener()
        self.add_metronome_listener()
        self.add_overdub_listener()
        self.add_tracks_listener()
        self.add_device_listeners()
        self.add_transport_listener()
        self.add_device_id()
        self.request_rebuild_midi_map()

######################################################################
# Add / Remove Listeners   
    def add_scene_listeners(self):
        self.rem_scene_listeners()

        if self.song().scenes_has_listener(self.scenes_change) != 1:
            self.song().add_scenes_listener(self.scenes_change)

        if self.song().view.selected_scene_has_listener(self.scene_change) != 1:
            self.song().view.add_selected_scene_listener(self.scene_change)

        if self.song().view.selected_track_has_listener(self.track_change) != 1:
            self.song().view.add_selected_track_listener(self.track_change)


    def rem_scene_listeners(self):
        if self.song().view.selected_scene_has_listener(self.scene_change) == 1:
            self.song().view.remove_selected_scene_listener(self.scene_change)
            
        if self.song().view.selected_track_has_listener(self.track_change) == 1:
            self.song().view.remove_selected_track_listener(self.track_change)

    def scenes_change(self):
        log("envio event de track ids")
        self.sendTrackIds()
        self.oscEndpoint.send("/client/refresh", (1))

    def track_change(self):
        selected_track = self.song().view.selected_track
        tracks = self.song().tracks
        index = 0
        selected_index = 0
        for track in tracks:
            index = index + 1        
            if track == selected_track:
                selected_index = index
                
        if selected_index != self.track:
            self.track = selected_index
            self.oscEndpoint.send("/live/track", (selected_index))

    def scene_change(self):
        selected_scene = self.song().view.selected_scene
        scenes = self.song().scenes
        index = 0
        selected_index = 0
        for scene in scenes:
            index = index + 1        
            if scene == selected_scene:
                selected_index = index
                
        if selected_index != self.scene:
            self.scene = selected_index
            self.oscEndpoint.send("/live/scene", (selected_index))

    def add_loop_listener(self):
        self.rem_loop_listener()

        print "add loop listener"
        if self.song().loop_has_listener(self.loop_change) != 1:
            self.song().add_loop_listener(self.loop_change)

    def rem_loop_listener(self):
        if self.song().loop_has_listener(self.loop_change) == 1:
            self.song().remove_loop_listener(self.loop_change)

    def loop_change(self):
        loop = LiveUtils.getSong().loop
        self.oscEndpoint.send("/live/loop", int(loop))

    def add_metronome_listener(self):
        self.rem_metronome_listener()

        print "add metronome listener"
        if self.song().metronome_has_listener(self.metronome_change) != 1:
            self.song().add_metronome_listener(self.metronome_change)

    def rem_metronome_listener(self):
        if self.song().metronome_has_listener(self.metronome_change) == 1:
            self.song().remove_metronome_listener(self.metronome_change)

    def metronome_change(self):
        metronome = LiveUtils.getSong().metronome
        self.oscEndpoint.send("/live/metronome", int(metronome))

    def signature_change(self):
        numerator = LiveUtils.getSong().signature_numerator
        denominator = LiveUtils.getSong().signature_denominator
        self.oscEndpoint.send("/live/signature", (int(numerator), int(denominator)))


    def add_tempo_listener(self):
        self.rem_tempo_listener()

        print "add tempo/signature listener"
        if self.song().tempo_has_listener(self.tempo_change) != 1:
            self.song().add_tempo_listener(self.tempo_change)
        if self.song().signature_numerator_has_listener(self.signature_change) != 1:
            self.song().add_signature_numerator_listener(self.signature_change)
        if self.song().signature_denominator_has_listener(self.signature_change) != 1:
            self.song().add_signature_denominator_listener(self.signature_change)

    def rem_tempo_listener(self):
        if self.song().tempo_has_listener(self.tempo_change) == 1:
            self.song().remove_tempo_listener(self.tempo_change)
        if self.song().signature_numerator_has_listener(self.signature_change) == 1:
            self.song().remove_signature_numerator_listener(self.signature_change)
        if self.song().signature_denominator_has_listener(self.signature_change) == 1:
            self.song().remove_signature_denominator_listener(self.signature_change)

    def tempo_change(self):
        tempo = LiveUtils.getTempo()
        self.oscEndpoint.send("/live/tempo", (tempo))
	
    def add_transport_listener(self):
        if self.song().is_playing_has_listener(self.transport_change) != 1:
            self.song().add_is_playing_listener(self.transport_change)
            
    def rem_transport_listener(self):
        if self.song().is_playing_has_listener(self.transport_change) == 1:
            self.song().remove_is_playing_listener(self.transport_change)    
    
    def transport_change(self):
        self.oscEndpoint.send("/live/play", int(self.song().is_playing))
        
    def songtime_change(self):
        self.oscEndpoint.send("/set/playing_position", (self.song().current_song_time))
    
    def add_overdub_listener(self):
        self.rem_overdub_listener()
    
        if self.song().overdub_has_listener(self.overdub_change) != 1:
            self.song().add_overdub_listener(self.overdub_change)
	    
    def rem_overdub_listener(self):
        if self.song().overdub_has_listener(self.overdub_change) == 1:
            self.song().remove_overdub_listener(self.overdub_change)
	    
    def overdub_change(self):
        overdub = LiveUtils.getSong().overdub
        self.oscEndpoint.send("/live/overdub", int(overdub))
	
    def add_tracks_listener(self):
        self.rem_tracks_listener()
    
        if self.song().tracks_has_listener(self.tracks_change) != 1:
            self.song().add_tracks_listener(self.tracks_change)
    
    def rem_tracks_listener(self):
        if self.song().tracks_has_listener(self.tempo_change) == 1:
            self.song().remove_tracks_listener(self.tracks_change)
    
    def tracks_change(self):
        log("entro a tracks change")
        self.sendTrackIds()
        self.sendDeviceIds()
        self.oscEndpoint.send("/client/refresh", (1))

    def rem_clip_listeners(self):
        for slot in self.slisten:
            if slot != None:
                if slot.has_clip_has_listener(self.slisten[slot]) == 1:
                    slot.remove_has_clip_listener(self.slisten[slot])
    
        self.slisten = {}
        
        for clip in self.clisten:
            if clip != None:
                if clip.playing_status_has_listener(self.clisten[clip]) == 1:
                    clip.remove_playing_status_listener(self.clisten[clip])
                
        self.clisten = {}

        for clip in self.pplisten:
            if clip != None:
                if clip.playing_position_has_listener(self.pplisten[clip]) == 1:
                    clip.remove_playing_position_listener(self.pplisten[clip])
                
        self.pplisten = {}

        for clip in self.cnlisten:
            if clip != None:
                if clip.name_has_listener(self.cnlisten[clip]) == 1:
                    clip.remove_name_listener(self.cnlisten[clip])
                
        self.cnlisten = {}

        for clip in self.cclisten:
            if clip != None:
                if clip.color_has_listener(self.cclisten[clip]) == 1:
                    clip.remove_color_listener(self.cclisten[clip])
                
        self.cclisten = {}


        for clip in self.wlisten:
            if clip != None:
                if clip.is_audio_clip:
                    if clip.warping_has_listener(self.wlisten[clip]) == 1:
                        clip.remove_warping_listener(self.wlisten[clip])
                
        self.wlisten = {}
        
        for clip in self.llisten:
            if clip != None:
                if clip.looping_has_listener(self.llisten[clip]) == 1:
                    clip.remove_looping_listener(self.llisten[clip])
                
        self.llisten = {}        


        
    def add_clip_listeners(self):
        self.rem_clip_listeners()
    
        tracks = self.getslots()
        for track in range(len(tracks)):
            for clip in range(len(tracks[track])):
                c = tracks[track][clip]
                if c.clip != None:
                    self.add_cliplistener(c.clip, track, clip)
                    log("ClipLauncher: added clip listener tr: " + str(track) + " clip: " + str(clip));
                
                self.add_slotlistener(c, track, clip)
        
    def add_cliplistener(self, clip, tid, cid):
        cb = lambda :self.clip_changestate(clip, tid, cid)
        
        if self.clisten.has_key(clip) != 1:
            clip.add_playing_status_listener(cb)
            self.clisten[clip] = cb
            
        cb2 = lambda :self.clip_position(clip, tid, cid)
        if self.pplisten.has_key(clip) != 1:
            clip.add_playing_position_listener(cb2)
            self.pplisten[clip] = cb2
            
        cb3 = lambda :self.clip_name(clip, tid, cid)
        if self.cnlisten.has_key(clip) != 1:
            clip.add_name_listener(cb3)
            self.cnlisten[clip] = cb3

        if self.cclisten.has_key(clip) != 1:
            clip.add_color_listener(cb3)
            self.cclisten[clip] = cb3
        
        if clip.is_audio_clip:
            cb4 = lambda: self.clip_warping(clip, tid, cid)
            if self.wlisten.has_key(clip) != 1:
                clip.add_warping_listener(cb4)
                self.wlisten[clip] = cb4
            
        cb5 = lambda: self.clip_looping(clip, tid, cid)
        if self.llisten.has_key(clip) != 1:
            clip.add_looping_listener(cb5)
            self.llisten[clip] = cb5   
        
    def add_slotlistener(self, slot, tid, cid):
        cb = lambda :self.slot_changestate(slot, tid, cid)
        
        if self.slisten.has_key(slot) != 1:
            slot.add_has_clip_listener(cb)
            self.slisten[slot] = cb   
            
#remove mixer listeners
    def rem_mixer_listeners(self):
        # Master Track
        for type in ("volume", "panning", "crossfader"):
            for tr in self.masterlisten[type]:
                if tr != None:
                    cb = self.masterlisten[type][tr]
                
                    test = eval("tr.mixer_device." + type+ ".value_has_listener(cb)")
                
                    if test == 1:
                        eval("tr.mixer_device." + type + ".remove_value_listener(cb)")

        # Normal Tracks
        for type in ("arm", "solo", "mute"):
            for tr in self.mlisten[type]:
                if tr != None:
                    cb = self.mlisten[type][tr]
                    
                    if type == "arm":
                        if tr.can_be_armed == 1:
                            if tr.arm_has_listener(cb) == 1:
                                tr.remove_arm_listener(cb)
                                
                    else:
                        test = eval("tr." + type+ "_has_listener(cb)")
                
                        if test == 1:
                            eval("tr.remove_" + type + "_listener(cb)")
                
        for type in ("volume", "panning"):
            for tr in self.mlisten[type]:
                if tr != None:
                    cb = self.mlisten[type][tr]
                
                    test = eval("tr.mixer_device." + type+ ".value_has_listener(cb)")
                
                    if test == 1:
                        eval("tr.mixer_device." + type + ".remove_value_listener(cb)")
         
        for tr in self.mlisten["sends"]:
            if tr != None:
                for send in self.mlisten["sends"][tr]:
                    if send != None:
                        cb = self.mlisten["sends"][tr][send]

                        if send.value_has_listener(cb) == 1:
                            send.remove_value_listener(cb)
                        
                        
        for tr in self.mlisten["name"]:
            if tr != None:
                cb = self.mlisten["name"][tr]

                if tr.name_has_listener(cb) == 1:
                    tr.remove_name_listener(cb)
                    
        for tr in self.mlisten["color"]:
            if tr != None:
                cb = self.mlisten["color"][tr]

                try:
                    if tr.color_has_listener(cb) == 1:
                        tr.remove_color_listener(cb)
                except:
                    pass
    
        for tr in self.mlisten["devices"]:
            if tr != None:
                cb = self.mlisten["devices"][tr]
                log("Remove device listener in track: " + str(tr));
                
                if tr.devices_has_listener(cb) == 1:
                    tr.remove_devices_listener(cb)

        for tr in self.mlisten["oml"]:
            if tr != None:
                cb = self.mlisten["oml"][tr]

                if tr.output_meter_left_has_listener(cb) == 1:
                    tr.remove_output_meter_left_listener(cb)

        for tr in self.mlisten["omr"]:
            if tr != None:
                cb = self.mlisten["omr"][tr]

                if tr.output_meter_right_has_listener(cb) == 1:
                    tr.remove_output_meter_right_listener(cb)
                    
        # Return Tracks                
        for type in ("solo", "mute"):
            for tr in self.rlisten[type]:
                if tr != None:
                    cb = self.rlisten[type][tr]
                
                    test = eval("tr." + type+ "_has_listener(cb)")
                
                    if test == 1:
                        eval("tr.remove_" + type + "_listener(cb)")
                
        for type in ("volume", "panning"):
            for tr in self.rlisten[type]:
                if tr != None:
                    cb = self.rlisten[type][tr]
                
                    test = eval("tr.mixer_device." + type+ ".value_has_listener(cb)")
                
                    if test == 1:
                        eval("tr.mixer_device." + type + ".remove_value_listener(cb)")
         
        for tr in self.rlisten["sends"]:
            if tr != None:
                for send in self.rlisten["sends"][tr]:
                    if send != None:
                        cb = self.rlisten["sends"][tr][send]
                
                        if send.value_has_listener(cb) == 1:
                            send.remove_value_listener(cb)

        for tr in self.rlisten["name"]:
            if tr != None:
                cb = self.rlisten["name"][tr]

                if tr.name_has_listener(cb) == 1:
                    tr.remove_name_listener(cb)
                    
        for tr in self.rlisten["color"]:
            if tr != None:
                cb = self.rlisten["color"][tr]
                try:
                    if tr.color_has_listener(cb) == 1:
                        tr.remove_color_listener(cb)
                except:
                    pass
                    
        self.mlisten = { "solo": {}, "mute": {}, "arm": {}, "panning": {}, "volume": {}, "sends": {}, "name": {}, "oml": {}, "omr": {}, "devices": {}, "color": {} }
        self.rlisten = { "solo": {}, "mute": {}, "panning": {}, "volume": {}, "sends": {}, "name": {}, "color": {} }
        self.masterlisten = { "panning": {}, "volume": {}, "crossfader": {} }
    
    # afegim listeners als elements de mixer
    def add_mixer_listeners(self):
        self.rem_mixer_listeners()
        
        # Master Track
        tr = self.song().master_track
        for type in ("volume", "panning", "crossfader"):
            self.add_master_listener(0, type, tr)
        
        self.add_meter_listener(0, tr, 2)
        
        # Normal Tracks
        tracks = self.song().tracks
        for track in range(len(tracks)):
            tr = tracks[track]

            self.add_trname_listener(track, tr, 0)
            self.add_track_device_listeners(track,tr)
            
            if tr.has_audio_output:
                self.add_meter_listener(track, tr)
            
            for type in ("arm", "solo", "mute"):
                if type == "arm":
                    if tr.can_be_armed == 1:
                        self.add_mixert_listener(track, type, tr)
                else:
                    self.add_mixert_listener(track, type, tr)
                
            for type in ("volume", "panning"):
                self.add_mixerv_listener(track, type, tr)
                
            for sid in range(len(tr.mixer_device.sends)):
                self.add_send_listener(track, tr, sid, tr.mixer_device.sends[sid])
        
        # Return Tracks
        tracks = self.song().return_tracks
        for track in range(len(tracks)):
            tr = tracks[track]

            self.add_trname_listener(track, tr, 1)
            self.add_meter_listener(track, tr, 1)
            
            for type in ("solo", "mute"):
                self.add_retmixert_listener(track, type, tr)
                
            for type in ("volume", "panning"):
                self.add_retmixerv_listener(track, type, tr)
            
            for sid in range(len(tr.mixer_device.sends)):
                self.add_retsend_listener(track, tr, sid, tr.mixer_device.sends[sid])
        
    
    # Add track listeners
    def add_send_listener(self, tid, track, sid, send):
        if self.mlisten["sends"].has_key(track) != 1:
            self.mlisten["sends"][track] = {}
                    
        if self.mlisten["sends"][track].has_key(send) != 1:
            cb = lambda :self.send_changestate(tid, track, sid, send)
            
            self.mlisten["sends"][track][send] = cb
            send.add_value_listener(cb)
    
    def add_mixert_listener(self, tid, type, track):
        if self.mlisten[type].has_key(track) != 1:
            cb = lambda :self.mixert_changestate(type, tid, track)
            
            self.mlisten[type][track] = cb
            eval("track.add_" + type + "_listener(cb)")
            
    def add_mixerv_listener(self, tid, type, track):
        if self.mlisten[type].has_key(track) != 1:
            cb = lambda :self.mixerv_changestate(type, tid, track)
            
            self.mlisten[type][track] = cb
            eval("track.mixer_device." + type + ".add_value_listener(cb)")

    # Add master listeners
    def add_master_listener(self, tid, type, track):
        if self.masterlisten[type].has_key(track) != 1:
            cb = lambda :self.mixerv_changestate(type, tid, track, 2)
            
            self.masterlisten[type][track] = cb
            eval("track.mixer_device." + type + ".add_value_listener(cb)")
            
            
    # Add return listeners
    def add_retsend_listener(self, tid, track, sid, send):
        if self.rlisten["sends"].has_key(track) != 1:
            self.rlisten["sends"][track] = {}
                    
        if self.rlisten["sends"][track].has_key(send) != 1:
            cb = lambda :self.send_changestate(tid, track, sid, send, 1)
            
            self.rlisten["sends"][track][send] = cb
            send.add_value_listener(cb)
    
    def add_retmixert_listener(self, tid, type, track):
        if self.rlisten[type].has_key(track) != 1:
            cb = lambda :self.mixert_changestate(type, tid, track, 1)
            
            self.rlisten[type][track] = cb
            eval("track.add_" + type + "_listener(cb)")
            
    def add_retmixerv_listener(self, tid, type, track):
        if self.rlisten[type].has_key(track) != 1:
            cb = lambda :self.mixerv_changestate(type, tid, track, 1)
            
            self.rlisten[type][track] = cb
            eval("track.mixer_device." + type + ".add_value_listener(cb)")      

    # Track device Listener
    def add_track_device_listeners(self,tid,track):
        cbt = lambda :self.track_device_listener(tid,track)
        
        if self.mlisten["devices"].has_key(track) != 1:
            self.mlisten["devices"][track] = cbt
        
        track.add_devices_listener(cbt)
        log("Added device listener in track " + str(tid));

    # Track name listener
    def add_trname_listener(self, tid, track, ret = 0):
        cb = lambda :self.trname_changestate(tid, track, ret)

        if ret == 1:
            if self.rlisten["name"].has_key(track) != 1:
                self.rlisten["name"][track] = cb
            if self.rlisten["color"].has_key(track) != 1:
                self.rlisten["color"][track] = cb
        
        else:
            if self.mlisten["name"].has_key(track) != 1:
                self.mlisten["name"][track] = cb
            if self.mlisten["color"].has_key(track) != 1:
                self.mlisten["color"][track] = cb

        
        track.add_name_listener(cb)
        try:
            track.add_color_listener(cb)
        except:
            log("Failed adding color listener for %d" % tid)
            pass
        log("Added listeners for track %d" % tid)
    # Output Meter Listeners
    def add_meter_listener(self, tid, track, r = 0):
        cb = lambda :self.meter_changestate(tid, track, 0, r)

        if self.mlisten["oml"].has_key(track) != 1:
            self.mlisten["oml"][track] = cb

        track.add_output_meter_left_listener(cb)

        cb = lambda :self.meter_changestate(tid, track, 1, r)

        if self.mlisten["omr"].has_key(track) != 1:
            self.mlisten["omr"][track] = cb

        track.add_output_meter_right_listener(cb)

######################################################################
# Listener Callbacks
        
    # Clip Callbacks
    def clip_warping(self, clip, tid, cid):
        self.oscEndpoint.send('/live/clip/warping', (tid, cid, int(clip.warping)))
        
    def clip_looping(self, clip, tid, cid):
        self.oscEndpoint.send('/live/clip/loopstate', (tid, cid, int(clip.looping)))
    
    def clip_name(self, clip, tid, cid):
        self.oscEndpoint.send('/live/name/clip', (tid, cid, str(clip.name), clip.color))
    
    def clip_position(self, clip, tid, cid):
        send = self._send_pos.has_key(tid) and self._send_pos[tid] or 0
    
        if self.check_md(1) or (self.check_md(5) and send):
            if clip.is_playing:
                if send > 0:
                    self._send_pos[tid] -= 1
                    
                self.oscEndpoint.send('/live/clip/position', (tid, cid, clip.playing_position, clip.length, clip.loop_start, clip.loop_end))
    
    def slot_changestate(self, slot, tid, cid):
        tmptrack = LiveUtils.getTrack(tid)
        armed = tmptrack.arm and 1 or 0
        
        # Added new clip
        if slot.clip != None:
            self.add_cliplistener(slot.clip, tid, cid)
            
            playing = 1
            if slot.clip.is_playing == 1:
                playing = 2
            
            if slot.clip.is_triggered == 1:
                playing = 3
            
            length =  slot.clip.loop_end - slot.clip.loop_start
            
            self.oscEndpoint.send('/live/track/info', (tid, armed, cid, playing, length))
            self.oscEndpoint.send('/live/name/clip', (tid, cid, str(slot.clip.name), slot.clip.color))
        else:
            if self.clisten.has_key(slot.clip) == 1:
                slot.clip.remove_playing_status_listener(self.clisten[slot.clip])
                
            if self.pplisten.has_key(slot.clip) == 1:
                slot.clip.remove_playing_position_listener(self.pplisten[slot.clip])

            if self.cnlisten.has_key(slot.clip) == 1:
                slot.clip.remove_name_listener(self.cnlisten[slot.clip])

            if self.cclisten.has_key(slot.clip) == 1:
                slot.clip.remove_color_listener(self.cclisten[slot.clip])
            
            self.oscEndpoint.send('/live/track/info', (tid, armed, cid, 0, 0.0))
            self.oscEndpoint.send('/live/clip/info', (tid, cid, 0))
                
        #log("Slot changed" + str(self.clips[tid][cid]))
    
    def clip_changestate(self, clip, x, y):
        log("Listener: x: " + str(x) + " y: " + str(y));

        playing = 1
        
        if clip.is_playing == 1:
            playing = 2
            
        if clip.is_triggered == 1:
            playing = 3
            
        self.oscEndpoint.send('/live/clip/info', (x, y, playing))
        self._send_pos[x] = 3
        
        #log("Clip changed x:" + str(x) + " y:" + str(y) + " status:" + str(playing)) 
        
        
    # Mixer Callbacks
    def mixerv_changestate(self, type, tid, track, r = 0):
        val = eval("track.mixer_device." + type + ".value")
        types = { "panning": "pan", "volume": "volume", "crossfader": "crossfader" }
        
        if r == 2:
            self.oscEndpoint.send('/live/master/' + types[type], (float(val)))
        elif r == 1:
            self.oscEndpoint.send('/live/return/' + types[type], (tid, float(val)))
        else:
            self.oscEndpoint.send('/live/' + types[type], (tid, float(val)))        
        
    def mixert_changestate(self, type, tid, track, r = 0):
        val = eval("track." + type)
        
        if r == 1:
            self.oscEndpoint.send('/live/return/' + type, (tid, int(val)))
        else:
            self.oscEndpoint.send('/live/' + type, (tid, int(val)))        
    
    def send_changestate(self, tid, track, sid, send, r = 0):
        val = send.value
        
        if r == 1:
            self.oscEndpoint.send('/live/return/send', (tid, sid, float(val)))   
        else:
            self.oscEndpoint.send('/live/send', (tid, sid, float(val)))   


    # Track name changestate
    def trname_changestate(self, tid, track, r = 0):
        if r == 1:
            col = 0
            try:
                col = track.color
            except:
                pass
            self.oscEndpoint.send('/live/name/return', (tid, str(track.name), col))
        else:
            col = 0
            try:
                col = track.color
            except:
                pass
            ndevices=len(track.devices)
            self.oscEndpoint.send('/live/name/track', (tid, str(track.name), col))
            self.trBlock(0, len(LiveUtils.getTracks()))
            
    # Meter Changestate
    def meter_changestate(self, tid, track, lr, r = 0):
        if r == 2:
            if self.check_md(2):
                if lr == 0:
                    self.oscEndpoint.send('/live/master/meter', (0, float(track.output_meter_left)))
                else:
                    self.oscEndpoint.send('/live/master/meter', (1, float(track.output_meter_right)))
        elif r == 1:
            if self.check_md(3):
                if lr == 0:
                    self.oscEndpoint.send('/live/return/meter', (tid, 0, float(track.output_meter_left)))
                else:
                    self.oscEndpoint.send('/live/return/meter', (tid, 1, float(track.output_meter_right)))        
        else:
            if self.check_md(4):
                if lr == 0:
                    self.oscEndpoint.send('/live/track/meter', (tid, 0, float(track.output_meter_left)))
                else:
                    self.oscEndpoint.send('/live/track/meter', (tid, 1, float(track.output_meter_right)))
    
    def check_md(self, param):
        devices = self.song().master_track.devices
        return 1
    
        if len(devices) > 0:
            if devices[0].parameters[param].value > 0:
                return 1
            else:
                return 0
        else:
            return 0
    
    # Device Listeners
    def add_device_id(self):
        for i in range(len(self.song().tracks)):
            for j in range(len(self.song().tracks[i].devices)):
                #log("device name" + str(Live.Application.encrypt_challenge));
                """print dir(self.song())"""

    def add_device_listeners(self):
        self.rem_device_listeners()

        self.do_add_device_listeners(self.song().tracks,0)
        self.do_add_device_listeners(self.song().return_tracks,1)
        self.do_add_device_listeners([self.song().master_track],2)
            
            
    def do_add_device_listeners(self, tracks, type):
        for i in range(len(tracks)):
            self.add_devicelistener(tracks[i], i, type)
        
            if len(tracks[i].devices) >= 1:
                for j in range(len(tracks[i].devices)):
                    self.add_name_device_listener(tracks[i].devices[j])
                    #self.add_devpmlistener(tracks[i].devices[j])
                    if len(tracks[i].devices[j].parameters) >= 1:
                        for k in range (len(tracks[i].devices[j].parameters)):
                            par = tracks[i].devices[j].parameters[k]
                            self.add_paramlistener(par, i, j, k, type)
                            
                            
    def add_name_device_listener(self,device):
        log("entro a add_name_device_listener")
        cb = lambda :self.dev_name_change(device)
        if device.name_has_listener(cb) != 1:
            device.add_name_listener(cb)
            self.dnlisten[device]=cb
                          
    def rem_device_listeners(self):
        for pr in self.prlisten:
            ocb = self.prlisten[pr]
            if pr != None:
                if pr.value_has_listener(ocb) == 1:
                    pr.remove_value_listener(ocb)
        
        self.prlisten = {}
        
        for tr in self.dlisten:
            ocb = self.dlisten[tr]
            if tr != None:
                if tr.view.selected_device_has_listener(ocb) == 1:
                    tr.view.remove_selected_device_listener(ocb)
                    
        self.dlisten = {}
        
        for de in self.plisten:
            ocb = self.plisten[de]
            if de != None:
                if de.parameters_has_listener(ocb) == 1:
                    de.remove_parameters_listener(ocb)
                    
        self.plisten = {}
        #here we delete de device name listeners
        for de in self.dnlisten:
            ocb = self.dnlisten[de]
            if de != None:
                if de.name_has_listener(ocb) == 1:
                    de.remove_name_listener(ocb)
                    
        self.dnlisten = {}


    def add_devpmlistener(self, device):
        cb = lambda :self.devpm_change()

        if self.plisten.has_key(device) != 1:
            device.add_parameters_listener(cb)
            self.plisten[device] = cb
    
    def devpm_change(self):
        #self.refresh_state()
            self.add_device_listeners()
            self.oscEndpoint.send('/updateDevices', (1))
            
    def dev_name_change(self,device):
        log("entro a envio de device name change dins de la funct dev_name_change")
        name= device.name
        self.oscEndpoint.send('/devicenamechanged', (str(name)))
    
    
        
    def add_paramlistener(self, param, tid, did, pid, type):
        cb = lambda :self.param_changestate(param, tid, did, pid, type)
        
        if self.prlisten.has_key(param) != 1:
            param.add_value_listener(cb)
            self.prlisten[param] = cb
            
    def param_changestate(self, param, tid, did, pid, type):
        if type == 2:
            self.oscEndpoint.send('/live/master/device/param', (did, pid, param.value, str(param.name)))
        elif type == 1:
            self.oscEndpoint.send('/live/return/device/param', (tid, did, pid, param.value, str(param.name)))
        else:
            self.oscEndpoint.send('/live/device/param', (tid, did, pid, param.value, str(param.name)))
        
    def add_devicelistener(self, track, tid, type):
        cb = lambda :self.device_changestate(track, tid, type)
        
        if self.dlisten.has_key(track) != 1:
            track.view.add_selected_device_listener(cb)
            self.dlisten[track] = cb
               

    def track_device_listener(self, tid, track):
        log("entro a track_device_listener")
        self.sendDeviceIds()
        
                
    def device_changestate(self, track, tid, type):
        
        did = self.tuple_idx(track.devices, track.view.selected_device)

        if type == 2:
            devices = LiveUtils.getSong().master_track.devices
            nm = str(devices[int(did)].name)
            params = LiveUtils.getSong().master_track.devices[did].parameters
            onoff = params[0].value
            num = len(devices)
            self.oscEndpoint.send('/master/selected_device', (1, did, nm, onoff, num))
        elif type == 1:
            devices = LiveUtils.getSong().return_tracks[tid].devices
            nm = str(devices[int(did)].name)
            params = LiveUtils.getSong().return_tracks[tid].devices[did].parameters
            onoff = params[0].value
            num = len(devices)
            self.oscEndpoint.send('/return/selected_device', (2, tid, did, nm, onoff, num))
        else:
            devices = LiveUtils.getSong().tracks[tid].devices
            nm = str(devices[int(did)].name)
            params = LiveUtils.getSong().tracks[tid].devices[did].parameters
            onoff = params[0].value
            num = len(devices)
            self.oscEndpoint.send('/track/selected_device', (0, tid, did, nm, onoff, num))       
        
    def tuple_idx(self, tuple, obj):
        for i in xrange(0,len(tuple)):
            if (tuple[i] == obj):
                return i

    def add_scenes_listeners(self):
        self.rem_scenes_listeners()
        scenes = self.song().scenes
        for sc in range (len(scenes)):
            scene = scenes[sc]
            self.add_scenelistener(scene, sc)

    def rem_scenes_listeners(self):
        for scene in self.sclisten:
            if scene != None:
                if scene.color_has_listener(self.sclisten[scene]) == 1:
                    scene.remove_color_listener(self.sclisten[scene])
            else:
                pass
        self.sclisten = {}

        for scene in self.snlisten:
            if scene != None:
                if scene.name_has_listener(self.snlisten[scene]) == 1:
                    scene.remove_name_listener(self.snlisten[scene])
            else:
                pass
        self.snlisten = {}

    def add_scenelistener(self, scene, sc):
        cb = lambda :self.scene_namecolor_changestate(scene, sc)
        if self.sclisten.has_key(scene) != 1:
            scene.add_color_listener(cb)
            self.sclisten[scene] = cb
        else:
            pass

        cb2 = lambda :self.scene_namecolor_changestate(scene, sc)
        if self.snlisten.has_key(scene) != 1:
            scene.add_name_listener(cb2)
            self.snlisten[scene] = cb2
        else:
            pass


    def scene_namecolor_changestate(self, scene, sc):
        nm = scene.name
        self.oscEndpoint.send("/live/name/scene", (sc, repr(nm), scene.color))



########NEW FILE########
__FILENAME__ = LiveOSCCallbacks
"""
# Copyright (C) 2007 Rob King (rob@re-mu.org)
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# For questions regarding this module contact
# Rob King <rob@e-mu.org> or visit http://www.e-mu.org

This file contains all the current Live OSC callbacks. 

"""
import Live
import RemixNet
import OSC
import LiveUtils
import sys

from Logger import log

class LiveOSCCallbacks:
    def __init__(self, c_instance, oscEndpoint):
        self.oscEndpoint = oscEndpoint
        self.callbackManager = oscEndpoint.callbackManager

        self.c_instance = c_instance

        self.callbackManager.add("/live/tempo", self.tempoCB)
        self.callbackManager.add("/live/signature", self.signatureCB)
        self.callbackManager.add("/live/time", self.timeCB)
        self.callbackManager.add("/live/nudge", self.nudgeCB)
        self.callbackManager.add("/live/next/cue", self.nextCueCB)
        self.callbackManager.add("/live/prev/cue", self.prevCueCB)
        self.callbackManager.add("/live/play", self.playCB)
        self.callbackManager.add("/live/play/continue", self.playContinueCB)
        self.callbackManager.add("/live/play/selection", self.playSelectionCB)
        self.callbackManager.add("/live/play/clip", self.playClipCB)
        self.callbackManager.add("/live/play/scene", self.playSceneCB)  
        self.callbackManager.add("/live/stop", self.stopCB)
        self.callbackManager.add("/live/stop/clip", self.stopClipCB)
        self.callbackManager.add("/live/stop/track", self.stopTrackCB)
        self.callbackManager.add("/live/rec", self.recCB)
        self.callbackManager.add("/live/song", self.songCB)
        self.callbackManager.add("/live/scenes", self.scenesCB)
        self.callbackManager.add("/live/tracks", self.tracksCB)
        self.callbackManager.add("/live/returntracks", self.returnTracksCB)
        self.callbackManager.add("/live/name/scene", self.nameSceneCB)
        self.callbackManager.add("/live/scene", self.sceneCB)
        self.callbackManager.add("/live/name/sceneblock", self.nameSceneBlockCB)
        self.callbackManager.add("/live/name/track", self.nameTrackCB)
        self.callbackManager.add("/live/name/trackblock", self.nameTrackBlockCB)
        self.callbackManager.add("/live/name/clip", self.nameClipCB)
        self.callbackManager.add("/live/name/clipblock", self.nameClipBlockCB)    
        self.callbackManager.add("/live/arm", self.armTrackCB)
        self.callbackManager.add("/live/mute", self.muteTrackCB)
        self.callbackManager.add("/live/solo", self.soloTrackCB)
        self.callbackManager.add("/live/volume", self.volumeCB)
        self.callbackManager.add("/live/pan", self.panCB)
        self.callbackManager.add("/live/send", self.sendCB)
        self.callbackManager.add("/live/pitch", self.pitchCB)
        self.callbackManager.add("/live/track/jump", self.trackJump)
        self.callbackManager.add("/live/track/info", self.trackInfoCB)
        self.callbackManager.add("/live/undo", self.undoCB)
        self.callbackManager.add("/live/redo", self.redoCB)
        self.callbackManager.add("/live/play/clipslot", self.playClipSlotCB)
        
        self.callbackManager.add("/live/scene/view", self.viewSceneCB)
        
        self.callbackManager.add("/live/track/view", self.viewTrackCB)
        self.callbackManager.add("/live/return/view", self.viewTrackCB)
        self.callbackManager.add("/live/master/view", self.mviewTrackCB)
        
        self.callbackManager.add("/live/track/device/view", self.viewDeviceCB)
        self.callbackManager.add("/live/return/device/view", self.viewDeviceCB)
        self.callbackManager.add("/live/master/device/view", self.mviewDeviceCB)        
        
        self.callbackManager.add("/live/clip/view", self.viewClipCB)
        
        self.callbackManager.add("/live/detail/view", self.detailViewCB)
        
        self.callbackManager.add("/live/overdub", self.overdubCB)
        self.callbackManager.add("/live/state", self.stateCB)
        self.callbackManager.add("/live/tap", self.tapCB)
        self.callbackManager.add("/live/loop", self.loopCB)
        self.callbackManager.add("/live/metronome", self.metronomeCB)
        self.callbackManager.add("/live/transportstate", self.transportStateCB)
        self.callbackManager.add("/live/clip/info", self.clipInfoCB)
        
        self.callbackManager.add("/live/return/mute", self.muteTrackCB)
        self.callbackManager.add("/live/return/solo", self.soloTrackCB)
        self.callbackManager.add("/live/return/volume", self.volumeCB)
        self.callbackManager.add("/live/return/pan", self.panCB)
        self.callbackManager.add("/live/return/send", self.sendCB)

        self.callbackManager.add("/live/master/volume", self.volumeCB)
        self.callbackManager.add("/live/cue/volume", self.volumeCB)
        self.callbackManager.add("/live/master/pan", self.panCB)
        
        self.callbackManager.add("/live/devicelist", self.devicelistCB)
        self.callbackManager.add("/live/return/devicelist", self.devicelistCB)
        self.callbackManager.add("/live/master/devicelist", self.mdevicelistCB)

        self.callbackManager.add("/live/device/range", self.devicerangeCB)
        self.callbackManager.add("/live/return/device/range", self.devicerangeCB)
        self.callbackManager.add("/live/master/device/range", self.mdevicerangeCB)
        
        self.callbackManager.add("/live/device", self.deviceCB)
        self.callbackManager.add("/live/return/device", self.deviceCB)
        self.callbackManager.add("/live/master/device", self.mdeviceCB)
        
        self.callbackManager.add("/live/clip/loopstate", self.loopStateCB)
        self.callbackManager.add("/live/clip/loopstart", self.loopStartCB)
        self.callbackManager.add("/live/clip/loopend", self.loopEndCB)
        
        self.callbackManager.add("/live/clip/loopstate_id", self.loopStateCB)
        self.callbackManager.add("/live/clip/loopstart_id", self.loopStartCB)
        self.callbackManager.add("/live/clip/loopend_id", self.loopEndCB)
        
        self.callbackManager.add("/live/clip/warping", self.warpingCB)
        
        self.callbackManager.add("/live/clip/signature", self.sigCB)

        self.callbackManager.add("/live/clip/add_note", self.addNoteCB)
        self.callbackManager.add("/live/clip/notes", self.getNotesCB)

        self.callbackManager.add("/live/master/crossfader", self.crossfaderCB)
        self.callbackManager.add("/live/track/crossfader", self.trackxfaderCB)
        self.callbackManager.add("/live/return/crossfader", self.trackxfaderCB)

        self.callbackManager.add("/live/quantization", self.quantizationCB)
        self.callbackManager.add("/live/selection", self.selectionCB)
        self.callbackManager.add("/live/info/clipblock", self.clipBlockInfoCB)
        self.callbackManager.add("/live/fold", self.foldTrackCB)
        self.callbackManager.add("/live/setup/selectstate", self.selectstateCB)
        self.callbackManager.add("/live/setdeviceid", self.setdeviceidCB)
        self.callbackManager.add("/live/settrackid", self.settrackidCB)
        self.callbackManager.add("/live/trackblock/refresh", self.trackblockRefreshCB)
   
    def trackblockRefreshCB(self, msg, source):
       block = []
       tracks = LiveUtils.getTracks()
        
       for track in xrange(0, len(LiveUtils.getTracks())):
           block.extend([str(tracks[track].name)])                            
       self.oscEndpoint.send("/live/trackblock/refresh", block)
       
        
    def returnTracksCB(self, msg, source):
        block = []
        for returnindex in xrange(0,len(LiveUtils.getSong().return_tracks)):
             block.extend([str(LiveUtils.getSong().return_tracks[returnindex].name)])                            
        self.oscEndpoint.send("/live/name/sendblock", block)
        
    
    def settrackidCB(self, msg, source):
        id=msg[2]
        track=msg[3]
        LiveUtils.getSong().tracks[track].name+=id
        log("apend id completed")
            
    def setdeviceidCB(self, msg, source):
        id=msg[2]
        track=msg[3]
        device=msg[4]
        LiveUtils.getSong().tracks[track].devices[device].name+=id
        log("apend id completed")
    
    def selectstateCB(self, msg, source):
        log("Entro a selectstate");
        print "entro a selectstate"
        tracks= LiveUtils.getSong().tracks
        for i in xrange(0,len(tracks)):
            print tracks[i].is_part_of_selection
            if tracks[i].is_part_of_selection == 1:
                index=i
          
        self.oscEndpoint.send("/live/setup/selectedtrack", (index))
            

    def sigCB(self, msg, source):
        """ Called when a /live/clip/signature message is recieved
        """
        track = msg[2]
        clip = msg[3]
        c = LiveUtils.getSong().tracks[track].clip_slots[clip].clip
        
        if len(msg) == 4:
            self.oscEndpoint.send("/live/clip/signature", (track, clip, c.signature_numerator, c.signature_denominator))
            
        if len(msg) == 6:
            self.oscEndpoint.send("/live/clip/signature", 1)
            c.signature_denominator = msg[5]
            c.signature_numerator = msg[4]

    def warpingCB(self, msg, source):
        """ Called when a /live/clip/warping message is recieved
        """
        track = msg[2]
        clip = msg[3]
        
        
        if len(msg) == 4:
            state = LiveUtils.getSong().tracks[track].clip_slots[clip].clip.warping
            self.oscEndpoint.send("/live/clip/warping", (track, clip, int(state)))
        
        elif len(msg) == 5:
            LiveUtils.getSong().tracks[track].clip_slots[clip].clip.warping = msg[4]

    def selectionCB(self, msg, source):
        """ Called when a /live/selection message is received
        """
        if len(msg) == 6:
            self.c_instance.set_session_highlight(msg[2], msg[3], msg[4], msg[5], 0)

    def trackxfaderCB(self, msg, source):
        """ Called when a /live/track/crossfader or /live/return/crossfader message is received
        """
        ty = msg[0] == '/live/return/crossfader' and 1 or 0
    
        if len(msg) == 3:
            track = msg[2]
        
            if ty == 1:
                assign = LiveUtils.getSong().return_tracks[track].mixer_device.crossfade_assign
                name   = LiveUtils.getSong().return_tracks[track].mixer_device.crossfade_assignments.values[assign]
            
                self.oscEndpoint.send("/live/return/crossfader", (track, str(assign), str(name)))
            else:
                assign = LiveUtils.getSong().tracks[track].mixer_device.crossfade_assign
                name   = LiveUtils.getSong().tracks[track].mixer_device.crossfade_assignments.values[assign]
            
                self.oscEndpoint.send("/live/track/crossfader", (track, str(assign), str(name)))

            
        elif len(msg) == 4:
            track = msg[2]
            assign = msg[3]
            
            if ty == 1:
                LiveUtils.getSong().return_tracks[track].mixer_device.crossfade_assign = assign
            else:
                LiveUtils.getSong().tracks[track].mixer_device.crossfade_assign = assign

    def tempoCB(self, msg, source):
        """Called when a /live/tempo message is received.

        Messages:
        /live/tempo                 Request current tempo, replies with /live/tempo (float tempo)
        /live/tempo (float tempo)   Set the tempo, replies with /live/tempo (float tempo)
        """
        if len(msg) == 2 or (len(msg) == 3 and msg[2] == "query"):
            self.oscEndpoint.send("/live/tempo", LiveUtils.getTempo())
        
        elif len(msg) == 3:
            tempo = msg[2]
            LiveUtils.setTempo(tempo)

    def nudgeCB(self, msg, source):
        """Called when a /live/nudge message is received

        Messages:
        /live/nudge Request status
        /live/nudge float direction (<0 down, 0 stop or >0 up)
        """
        song = LiveUtils.getSong()
        if len(msg) == 2 or (len(msg) == 3 and msg[2] == "query"):
            status = 0.0
            if song.nudge_up == 1:
                status = 1.0
            elif song.nudge_down == 1:
                status = -1.0
            else:
                status = 0.0

            self.oscEndpoint.send("/live/nudge", status)

        elif len(msg) == 3:
            nudge = msg[2]
            if nudge < 0.0:
                song.nudge_up = 0
                song.nudge_down = 1
            elif nudge > 0.0:
                song.nudge_up = 1
                song.nudge_down = 0
            else:
                song.nudge_up = 0
                song.nudge_down = 0




    def signatureCB(self, msg, source):
        """Called when a /live/signature message is received

        Messages:
        /live/signature         Request current song signature, replies with /live/signature (int numerator, int denominator)
        /live/signature (int numerator, int denominator)
                                Set the song signature
        """
        song = LiveUtils.getSong()
        if len(msg) == 2 or (len(msg) == 3 and msg[2] == "query"):
            numerator = song.signature_numerator
            denominator = song.signature_denominator
            self.oscEndpoint.send("/live/signature", (int(numerator), int(denominator)))
        elif len(msg) == 4:
            numerator = msg[2]
            denominator = msg[3]
            try:
                song.signature_numerator = numerator
                song.signature_denominator = denominator
            except RuntimeError:
                numerator = song.signature_numerator
                denominator = song.signature_denominator
            self.oscEndpoint.send("/live/signature", (int(numerator), int(denominator)))

        
    def timeCB(self, msg, source):
        """Called when a /live/time message is received.

        Messages:
        /live/time                 Request current song time, replies with /live/time (float time)
        /live/time (float time)    Set the time , replies with /live/time (float time)
        """
        if len(msg) == 2 or (len(msg) == 3 and msg[2] == "query"):
            self.oscEndpoint.send("/live/time", float(LiveUtils.currentTime()))

        elif len(msg) == 3:
            time = msg[2]
            LiveUtils.currentTime(time)

    def nextCueCB(self, msg, source):
        """Called when a /live/next/cue message is received.

        Messages:
        /live/next/cue              Jumps to the next cue point
        """
        LiveUtils.jumpToNextCue()
        
    def prevCueCB(self, msg, source):
        """Called when a /live/prev/cue message is received.

        Messages:
        /live/prev/cue              Jumps to the previous cue point
        """
        LiveUtils.jumpToPrevCue()
        
    def playCB(self, msg, source):
        """Called when a /live/play message is received.

        Messages:
        /live/play              Starts the song playing
        """
        LiveUtils.play()
        
    def playContinueCB(self, msg, source):
        """Called when a /live/play/continue message is received.

        Messages:
        /live/play/continue     Continues playing the song from the current point
        """
        LiveUtils.continuePlaying()
        
    def playSelectionCB(self, msg, source):
        """Called when a /live/play/selection message is received.

        Messages:
        /live/play/selection    Plays the current selection
        """
        LiveUtils.playSelection()
        
    def playClipCB(self, msg, source):
        """Called when a /live/play/clip message is received.

        Messages:
        /live/play/clip     (int track, int clip)   Launches clip number clip in track number track
        """
        if len(msg) == 4:
            track = msg[2]
            clip = msg[3]
            LiveUtils.launchClip(track, clip)
            
    def playSceneCB(self, msg, source):
        """Called when a /live/play/scene message is received.

        Messages:
        /live/play/scene    (int scene)     Launches scene number scene
        """
        if len(msg) == 3:
            scene = msg[2]
            LiveUtils.launchScene(scene)
    
    def stopCB(self, msg, source):
        """Called when a /live/stop message is received.

        Messages:
        /live/stop              Stops playing the song
        """
        LiveUtils.stop()
        
    def stopClipCB(self, msg, source):
        """Called when a /live/stop/clip message is received.

        Messages:
        /live/stop/clip     Stop all clips
        /live/stop/clip     (int track, int clip)   Stops clip number clip in track number track
        """
        if len(msg) == 2:
            LiveUtils.stopClips()

        if len(msg) == 4:
            track = msg[2]
            clip = msg[3]
            LiveUtils.stopClip(track, clip)

    def stopTrackCB(self, msg, source):
        """Called when a /live/stop/track message is received.

        Messages:
        /live/stop/track     (int track, int clip)   Stops track number track
        """
        if len(msg) == 3:
            track = msg[2]
            LiveUtils.stopTrack(track)

    def recCB(self, msg, source):
        """Called when a /live/rec message is received
        Messages:
        /live/rec   Switches the rec button on/off.

        """
        rec = LiveUtils.getSong().record_mode
        if rec == 1:
            rec = 0
        else:
            rec = 1
        LiveUtils.getSong().record_mode = rec
        self.oscEndpoint.send("/live/rec", int(rec))

    def scenesCB(self, msg, source):
        """Called when a /live/scenes message is received.

        Messages:
        /live/scenes        no argument or 'query'  Returns the total number of scenes

        """
        if len(msg) == 2 or (len(msg) == 3 and msg[2] == "query"):
            sceneTotal = len(LiveUtils.getScenes())
            self.oscEndpoint.send("/live/scenes", (sceneTotal))
            return

    def sceneCB(self, msg, source):
        """Called when a /live/scene message is received.
        
        Messages:
        /live/scene         no argument or 'query'  Returns the currently playing scene number
        """
        if len(msg) == 2 or (len(msg) == 3 and msg[2] == "query"):
            selected_scene = LiveUtils.getSong().view.selected_scene
            scenes = LiveUtils.getScenes()
            index = 0
            selected_index = 0
            for scene in scenes:
                index = index + 1        
                if scene == selected_scene:
                    selected_index = index
                    
            self.oscEndpoint.send("/live/scene", (selected_index))
            
        elif len(msg) == 3:
            scene = msg[2]
            LiveUtils.getSong().view.selected_scene = LiveUtils.getSong().scenes[scene]

    def tracksCB(self, msg, source):
        """Called when a /live/tracks message is received.

        Messages:
        /live/tracks       no argument or 'query'  Returns the total number of scenes

        """
        if len(msg) == 2 or (len(msg) == 3 and msg[2] == "query"):
            trackTotal = len(LiveUtils.getTracks())
            self.oscEndpoint.send("/live/tracks", (trackTotal))
            return


    def nameSceneCB(self, msg, source):
        """Called when a /live/name/scene message is received.

        Messages:
        /live/name/scene                            Returns a a series of all the scene names in the form /live/name/scene (int scene, string name)
        /live/name/scene    (int scene)             Returns a single scene's name in the form /live/name/scene (int scene, string name)
        /live/name/scene    (int scene, string name)Sets scene number scene's name to name

        """        
        #Requesting all scene names
        if len(msg) == 2 or (len(msg) == 3 and msg[2] == "query"):
            bundle = OSC.OSCBundle()
            sceneNumber = 0
            for scene in LiveUtils.getScenes():
                bundle.append("/live/name/scene", (sceneNumber, str(scene.name)))
                sceneNumber = sceneNumber + 1
            self.oscEndpoint.sendMessage(bundle)
            return
        #Requesting a single scene name
        if len(msg) == 3:
            sceneNumber = msg[2]
            self.oscEndpoint.send("/live/name/scene", (sceneNumber, str(LiveUtils.getScene(sceneNumber).name)))
            return
        #renaming a scene
        if len(msg) == 4:
            sceneNumber = msg[2]
            name = msg[3]
            LiveUtils.getScene(sceneNumber).name = name

    def nameSceneBlockCB(self, msg, source):
        """Called when a /live/name/sceneblock message is received.

        /live/name/clipblock    (int offset, int blocksize) Returns a list of blocksize scene names starting at offset
        """
        if len(msg) == 4:
            block = []
            sceneOffset = msg[2]
            blocksize = msg[3]
            for scene in range(0, blocksize):
                sceneObj = LiveUtils.getScene(sceneOffset + scene)
                block.extend([str(sceneObj.name), sceneObj.color])
            self.oscEndpoint.send("/live/name/sceneblock", block)
            
            
    def nameTrackCB(self, msg, source):
        """Called when a /live/name/track message is received.

        Messages:
        /live/name/track                            Returns a a series of all the track names in the form /live/name/track (int track, string name)
        /live/name/track    (int track)             Returns a single track's name in the form /live/name/track (int track, string name)
        /live/name/track    (int track, string name)Sets track number track's name to name

        """
        #Requesting all track names
        if len(msg) == 2 or (len(msg) == 3 and msg[2] == "query"):
            trackNumber = 0
            bundle = OSC.OSCBundle()
            for track in LiveUtils.getTracks():
                ndevices=len(track.devices)
                col = 0
                try:
                    col = track.color
                except:
                        pass
                bundle.append("/live/name/track", (trackNumber, str(track.name),int(track.has_midi_input), ndevices, col))
                trackNumber = trackNumber + 1
            self.oscEndpoint.sendMessage(bundle)
            return
        #Requesting a single track name
        if len(msg) == 3:
            trackNumber = msg[2]
            self.oscEndpoint.send("/live/name/track", (trackNumber, str(LiveUtils.getTrack(trackNumber).name),int(LiveUtils.getTrack(trackNumber).has_midi_input)))
            return
        #renaming a track
        if len(msg) == 4:
            trackNumber = msg[2]
            name = msg[3]
            LiveUtils.getTrack(trackNumber).name = name

    def nameTrackBlockCB(self, msg, source):
        """Called when a /live/name/trackblock message is received.

        /live/name/trackblock    (int offset, int blocksize) Returns a list of blocksize track names starting at offset
        :param msg:
        :param source:
        """
        if len(msg) == 4:
            block = []
            trackOffset = msg[2]
            blocksize = msg[3]
            foldstates = {}
            groups = {}
            ## Open all tracks
            for track in range(0, blocksize):
                trackobj = LiveUtils.getSong().tracks[trackOffset + track]
                if trackobj.is_foldable == 1:
                    foldstates[trackOffset+track] = trackobj.fold_state
                    trackobj.fold_state = 0
            ## Close each group and get all invisible'd tracks
            for track in range(0, blocksize):
                trackObj = LiveUtils.getSong().tracks[trackOffset + track]
                if trackObj.is_foldable == 1:
                    trackObj.fold_state = 1
                    for vistrack in range(track,blocksize):
                        vtrack = LiveUtils.getSong().tracks[trackOffset + vistrack]
                        if vtrack.is_visible == 0:
                            groups[trackOffset + vistrack] = trackOffset + track
            ## Set track folds back to its original state
            for track in range(0, blocksize):
                trackObj = LiveUtils.getSong().tracks[trackOffset + track]
                if trackObj.is_foldable == 1:
                    trackObj.fold_state = foldstates[trackOffset+track]

            for track in range(0, blocksize):
                trackObj = LiveUtils.getSong().tracks[trackOffset + track]
                is_foldable = 0
                fold_state = -1
                is_visible = 1
                if trackObj.is_foldable == 1:
                    is_foldable = 1
                    if trackObj.fold_state == 1:
                        fold_state = 1
                    else:
                        fold_state = 0
                else:
                    if (trackOffset + track) in groups:
                        fold_state = groups[trackOffset + track]
                if trackObj.is_visible == 0:
                    is_visible = 0
                volume = LiveUtils.trackVolume(track)
                mute = 0
                if trackObj.mute == 1:
                    mute = 1
                else:
                    mute = 0
                block.extend([str(trackObj.name), trackObj.color, is_foldable, fold_state, is_visible, float(volume), mute])
            self.oscEndpoint.send("/live/name/trackblock", block)

    def nameClipBlockCB(self, msg, source):
        """Called when a /live/name/clipblock message is received.

        /live/name/clipblock    (int track, int clip, blocksize x/tracks, blocksize y/clipslots) Returns a list of clip names for a block of clips (int blockX, int blockY, clipname)

        """
        #Requesting a block of clip names X1 Y1 X2 Y2 where X1,Y1 is the first clip (track, clip) of the block, X2 the number of tracks to cover and Y2 the number of scenes
        
        if len(msg) == 6:
            block = []
            trackOffset = msg[2]
            clipOffset = msg[3]
            blocksizeX = msg[4]
            blocksizeY = msg[5]
            for clip in range(0, blocksizeY):
                for track in range(0, blocksizeX):
                        trackNumber = trackOffset+track
                        clipNumber = clipOffset+clip
                        clipObj = LiveUtils.getSong().tracks[trackNumber].clip_slots[clipNumber].clip
                        if clipObj != None:
                            block.extend([str(clipObj.name)])
                        else:
                            block.extend([""])
                            
            self.oscEndpoint.send("/live/name/clipblock", block)



    def nameClipCB(self, msg, source):
        """Called when a /live/name/clip message is received.

        Messages:
        /live/name/clip                                      Returns a a series of all the clip names in the form /live/name/clip (int track, int clip, string name)
        /live/name/clip    (int track, int clip)             Returns a single clip's name in the form /live/name/clip (int clip, string name)
        /live/name/clip    (int track, int clip, string name)Sets clip number clip in track number track's name to name

        """
        #Requesting all clip names
        if len(msg) == 2 or (len(msg) == 3 and msg[2] == "query"):
            trackNumber = 0
            clipNumber = 0
            for track in LiveUtils.getTracks():
                bundle = OSC.OSCBundle()
                for clipSlot in track.clip_slots:
                    if clipSlot.clip != None:
                        bundle.append("/live/name/clip", (trackNumber, clipNumber, str(clipSlot.clip.name), clipSlot.clip.color))
                    clipNumber = clipNumber + 1
                self.oscEndpoint.sendMessage(bundle)
                clipNumber = 0
                trackNumber = trackNumber + 1
            return
        #Requesting a single clip name
        if len(msg) == 4:
            trackNumber = msg[2]
            clipNumber = msg[3]
            self.oscEndpoint.send("/live/name/clip", (trackNumber, clipNumber, str(LiveUtils.getClip(trackNumber, clipNumber).name), LiveUtils.getClip(trackNumber, clipNumber).color))
            return
        #renaming a clip
        if len(msg) >= 5:
            trackNumber = msg[2]
            clipNumber = msg[3]
            name = msg[4]
            LiveUtils.getClip(trackNumber, clipNumber).name = name

        if len(msg) >= 6:
            trackNumber = msg[2]
            clipNumber = msg[3]
            color = msg[5]
            LiveUtils.getClip(trackNumber, clipNumber).color = color

    def addNoteCB(self, msg, source):
        """Called when a /live/clip/add_note message is received

        Messages:
        /live/clip/add_note (int pitch) (double time) (double duration) (int velocity) (bool muted)    Add the given note to the clip
        """
        trackNumber = msg[2]
        clipNumber = msg[3]
        pitch = msg[4]
        time = msg[5]
        duration = msg[6]
        velocity = msg[7]
        muted = msg[8]
        LiveUtils.getClip(trackNumber, clipNumber).deselect_all_notes()

        notes = ((pitch, time, duration, velocity, muted),)
        LiveUtils.getClip(trackNumber, clipNumber).replace_selected_notes(notes)
        self.oscEndpoint.send('/live/clip/note', (trackNumber, clipNumber, pitch, time, duration, velocity, muted))

    def getNotesCB(self, msg, source):
        """Called when a /live/clip/notes message is received

        Messages:
        /live/clip/notes    Return all notes in the clip in /live/clip/note messages.  Each note is sent in the format
                            (int trackNumber) (int clipNumber) (int pitch) (double time) (double duration) (int velocity) (int muted)
        """
        trackNumber = msg[2]
        clipNumber = msg[3]
        LiveUtils.getClip(trackNumber, clipNumber).select_all_notes()
        bundle = OSC.OSCBundle()
        for note in LiveUtils.getClip(trackNumber, clipNumber).get_selected_notes():
            pitch = note[0]
            time = note[1]
            duration = note[2]
            velocity = note[3]
            muted = 0
            if note[4]:
                muted = 1
            bundle.append('/live/clip/note', (trackNumber, clipNumber, pitch, time, duration, velocity, muted))
        self.oscEndpoint.sendMessage(bundle)
    
    def armTrackCB(self, msg, source):
        """Called when a /live/arm message is received.

        Messages:
        /live/arm     (int track)   (int armed/disarmed)     Arms track number track
        """
        track = msg[2]
        
        if len(msg) == 4:
            if msg[3] == 1:
                LiveUtils.armTrack(track)
            else:
                LiveUtils.disarmTrack(track)
        # Return arm status        
        elif len(msg) == 3:
            status = LiveUtils.getTrack(track).arm
            self.oscEndpoint.send("/live/arm", (track, int(status)))     
            
    def muteTrackCB(self, msg, source):
        """Called when a /live/mute message is received.

        Messages:
        /live/mute     (int track)   Mutes track number track
        """
        ty = msg[0] == '/live/return/mute' and 1 or 0
        track = msg[2]
            
        if len(msg) == 4:
            if msg[3] == 1:
                LiveUtils.muteTrack(track, ty)
            else:
                LiveUtils.unmuteTrack(track, ty)
                
        elif len(msg) == 3:
            if ty == 1:
                status = LiveUtils.getSong().return_tracks[track].mute
                self.oscEndpoint.send("/live/return/mute", (track, int(status)))
                
            else:
                status = LiveUtils.getTrack(track).mute
                self.oscEndpoint.send("/live/mute", (track, int(status)))
            
    def soloTrackCB(self, msg, source):
        """Called when a /live/solo message is received.

        Messages:
        /live/solo     (int track)   Solos track number track
        """
        ty = msg[0] == '/live/return/solo' and 1 or 0
        track = msg[2]
        
        if len(msg) == 4:
            if msg[3] == 1:
                LiveUtils.soloTrack(track, ty)
            else:
                LiveUtils.unsoloTrack(track, ty)
            
        elif len(msg) == 3:
            if ty == 1:
                status = LiveUtils.getSong().return_tracks[track].solo
                self.oscEndpoint.send("/live/return/solo", (track, int(status)))
                
            else:
                status = LiveUtils.getTrack(track).solo
                self.oscEndpoint.send("/live/solo", (track, int(status)))
            
    def volumeCB(self, msg, source):
        """Called when a /live/volume message is received.

        Messages:
        /live/volume     (int track)                            Returns the current volume of track number track as: /live/volume (int track, float volume(0.0 to 1.0))
        /live/volume     (int track, float volume(0.0 to 1.0))  Sets track number track's volume to volume
        """
        if msg[0] == '/live/return/volume':
            ty = 1
        elif msg[0] == '/live/master/volume':
            ty = 2
        elif msg[0] == '/live/cue/volume':
            ty = 3
        else:
            ty = 0
        
        if len(msg) == 2 and ty == 2:
            self.oscEndpoint.send("/live/master/volume", LiveUtils.getSong().master_track.mixer_device.volume.value)

        elif len(msg) == 2 and ty == 3:
            self.oscEndpoint.send("/live/cue/volume", LiveUtils.getSong().master_track.mixer_device.cue_volume.value)

        elif len(msg) == 3 and ty == 2:
            volume = msg[2]
            LiveUtils.getSong().master_track.mixer_device.volume.value = volume

        elif len(msg) == 3 and ty == 3:
            volume = msg[2]
            LiveUtils.getSong().master_track.mixer_device.cue_volume.value = volume

        elif len(msg) == 4:
            track = msg[2]
            volume = msg[3]
            
            if ty == 0:
                LiveUtils.trackVolume(track, volume)
            elif ty == 1:
                LiveUtils.getSong().return_tracks[track].mixer_device.volume.value = volume

        elif len(msg) == 3:
            track = msg[2]

            if ty == 1:
                self.oscEndpoint.send("/live/return/volume", (track, LiveUtils.getSong().return_tracks[track].mixer_device.volume.value))
            
            else:
                self.oscEndpoint.send("/live/volume", (track, LiveUtils.trackVolume(track)))
            
    def panCB(self, msg, source):
        """Called when a /live/pan message is received.

        Messages:
        /live/pan     (int track)                            Returns the pan of track number track as: /live/pan (int track, float pan(-1.0 to 1.0))
        /live/pan     (int track, float pan(-1.0 to 1.0))    Sets track number track's pan to pan

        """
        if msg[0] == '/live/return/pan':
            ty = 1
        elif msg[0] == '/live/master/pan':
            ty = 2
        else:
            ty = 0
        
        if len(msg) == 2 and ty == 2:
            self.oscEndpoint.send("/live/master/pan", LiveUtils.getSong().master_track.mixer_device.panning.value)
        
        elif len(msg) == 3 and ty == 2:
            pan = msg[2]
            LiveUtils.getSong().master_track.mixer_device.panning.value = pan
            
        elif len(msg) == 4:
            track = msg[2]
            pan = msg[3]
            
            if ty == 0:
                LiveUtils.trackPan(track, pan)
            elif ty == 1:
                LiveUtils.getSong().return_tracks[track].mixer_device.panning.value = pan
            
        elif len(msg) == 3:
            track = msg[2]
            
            if ty == 1:
                self.oscEndpoint.send("/live/pan", (track, LiveUtils.getSong().return_tracks[track].mixer_device.panning.value))
            
            else:
                self.oscEndpoint.send("/live/pan", (track, LiveUtils.trackPan(track)))

            
    def sendCB(self, msg, source):
        """Called when a /live/send message is received.

        Messages:
        /live/send     (int track, int send)                              Returns the send level of send (send) on track number track as: /live/send (int track, int send, float level(0.0 to 1.0))
        /live/send     (int track, int send, float level(0.0 to 1.0))     Sets the send (send) of track number (track)'s level to (level)

        """
        ty = msg[0] == '/live/return/send' and 1 or 0
        track = msg[2]
        
        if len(msg) == 5:
            send = msg[3]
            level = msg[4]
            if ty == 1:
                LiveUtils.getSong().return_tracks[track].mixer_device.sends[send].value = level
            
            else:
                LiveUtils.trackSend(track, send, level)
        
        elif len(msg) == 4:
            send = msg[3]
            if ty == 1:
                self.oscEndpoint.send("/live/return/send", (track, send, float(LiveUtils.getSong().return_tracks[track].mixer_device.sends[send].value)))

            else:
                self.oscEndpoint.send("/live/send", (track, send, float(LiveUtils.trackSend(track, send))))
            
        elif len(msg) == 3:
            if ty == 1:
                sends = LiveUtils.getSong().return_tracks[track].mixer_device.sends
            else:
                sends = LiveUtils.getSong().tracks[track].mixer_device.sends
                
            so = [track]
            for i in range(len(sends)):
                so.append(i)
                so.append(float(sends[i].value))
                
            if ty == 1:
                self.oscEndpoint.send("/live/return/send", tuple(so))
            else:
                self.oscEndpoint.send("/live/send", tuple(so))
                
        
            
    def pitchCB(self, msg, source):
        """Called when a /live/pitch message is received.

        Messages:
        /live/pitch     (int track, int clip)                                               Returns the pan of track number track as: /live/pan (int track, int clip, int coarse(-48 to 48), int fine (-50 to 50))
        /live/pitch     (int track, int clip, int coarse(-48 to 48), int fine (-50 to 50))  Sets clip number clip in track number track's pitch to coarse / fine

        """
        if len(msg) == 6:
            track = msg[2]
            clip = msg[3]
            coarse = msg[4]
            fine = msg[5]
            LiveUtils.clipPitch(track, clip, coarse, fine)
        if len(msg) ==4:
            track = msg[2]
            clip = msg[3]
            self.oscEndpoint.send("/live/pitch", LiveUtils.clipPitch(track, clip))

    def trackJump(self, msg, source):
        """Called when a /live/track/jump message is received.

        Messages:
        /live/track/jump     (int track, float beats)   Jumps in track's currently running session clip by beats
        """
        if len(msg) == 4:
            track = msg[2]
            beats = msg[3]
            track = LiveUtils.getTrack(track)
            track.jump_in_running_session_clip(beats)

    def trackInfoCB(self, msg, source):
        """Called when a /live/track/info message is received.

        Messages:
        /live/track/info     (int track)   Returns clip slot status' for all clips in a track in the form /live/track/info (tracknumber, armed  (clipnumber, state, length))
                                           [state: 1 = Has Clip, 2 = Playing, 3 = Triggered]
        """
        
        clipslots = LiveUtils.getClipSlots()
        
        new = []
        if len(msg) == 3:
            new.append(clipslots[msg[2]])
            tracknum = msg[2] - 1
        else:
            new = clipslots
            tracknum = -1
        
        for track in new:
            tracknum = tracknum + 1
            clipnum = -1
            tmptrack = LiveUtils.getTrack(tracknum)
            armed = tmptrack.arm and 1 or 0
            li = [tracknum, armed]
            for clipSlot in track:
                clipnum = clipnum + 1
                li.append(clipnum);
                if clipSlot.clip != None:
                    clip = clipSlot.clip
                    if clip.is_playing == 1:
                        li.append(2)
                        li.append(clip.length)
                        
                    elif clip.is_triggered == 1:
                        li.append(3)
                        li.append(clip.length)
                        
                    else:
                        li.append(1)
                        li.append(clip.length)
                else:
                    li.append(0)
                    li.append(0.0)
                    
            tu = tuple(li)
            
            self.oscEndpoint.send("/live/track/info", tu)


    def undoCB(self, msg, source):
        """Called when a /live/undo message is received.
        
        Messages:
        /live/undo      Requests the song to undo the last action
        """
        LiveUtils.getSong().undo()
        
    def redoCB(self, msg, source):
        """Called when a /live/redo message is received.
        
        Messages:
        /live/redo      Requests the song to redo the last action
        """
        LiveUtils.getSong().redo()
        
    def playClipSlotCB(self, msg, source):
        """Called when a /live/play/clipslot message is received.
        
        Messages:
        /live/play/clipslot     (int track, int clip)   Launches clip number clip in track number track
        """
        if len(msg) == 4:
            track_num = msg[2]
            clip_num = msg[3]
            track = LiveUtils.getTrack(track_num)
            clipslot = track.clip_slots[clip_num]
            clipslot.fire()

    def viewSceneCB(self, msg, source):
        """Called when a /live/scene/view message is received.
        
        Messages:
        /live/scene/view     (int track)      Selects a track to view
        """
        
        if len(msg) == 3:
            scene = msg[2]
            LiveUtils.getSong().view.selected_scene = LiveUtils.getSong().scenes[scene]
            
    def viewTrackCB(self, msg, source):
        """Called when a /live/track/view message is received.
        
        Messages:
        /live/track/view     (int track)      Selects a track to view
        """
        ty = msg[0] == '/live/return/view' and 1 or 0
        track_num = msg[2]
        
        if len(msg) == 3:
            if ty == 1:
                track = LiveUtils.getSong().return_tracks[track_num]
            else:
                track = LiveUtils.getSong().tracks[track_num]
                
            LiveUtils.getSong().view.selected_track = track
            Live.Application.get_application().view.show_view("Detail/DeviceChain")
                
            #track.view.select_instrument()
            
    def mviewTrackCB(self, msg, source):
        """Called when a /live/master/view message is received.
        
        Messages:
        /live/track/view     (int track)      Selects a track to view
        """
        track = LiveUtils.getSong().master_track

        LiveUtils.getSong().view.selected_track = track
        Live.Application.get_application().view.show_view("Detail/DeviceChain")        
        
        #track.view.select_instrument()
        
    def viewClipCB(self, msg, source):
        """Called when a /live/clip/view message is received.
        
        Messages:
        /live/clip/view     (int track, int clip)      Selects a track to view
        """
        track = LiveUtils.getSong().tracks[msg[2]]
        
        if len(msg) == 4:
            clip  = msg[3]
        else:
            clip  = 0
        
        LiveUtils.getSong().view.selected_track = track
        LiveUtils.getSong().view.detail_clip = track.clip_slots[clip].clip
        Live.Application.get_application().view.show_view("Detail/Clip")  

    def detailViewCB(self, msg, source):
        """Called when a /live/detail/view message is received. Used to switch between clip/track detail

        Messages:
        /live/detail/view (int) Selects view where 0=clip detail, 1=track detail
        """
        if len(msg) == 3:
            if msg[2] == 0:
                Live.Application.get_application().view.show_view("Detail/Clip")
            elif msg[2] == 1:
                Live.Application.get_application().view.show_view("Detail/DeviceChain")

    def viewDeviceCB(self, msg, source):
        """Called when a /live/track/device/view message is received.
        
        Messages:
        /live/track/device/view     (int track)      Selects a track to view
        """
        ty = msg[0] == '/live/return/device/view' and 1 or 0
        track_num = msg[2]
        
        if len(msg) == 4:
            if ty == 1:
                track = LiveUtils.getSong().return_tracks[track_num]
            else:
                track = LiveUtils.getSong().tracks[track_num]

            LiveUtils.getSong().view.selected_track = track
            LiveUtils.getSong().view.select_device(track.devices[msg[3]])
            Live.Application.get_application().view.show_view("Detail/DeviceChain")
            
    def mviewDeviceCB(self, msg, source):
        track = LiveUtils.getSong().master_track
        
        if len(msg) == 3:
            LiveUtils.getSong().view.selected_track = track
            LiveUtils.getSong().view.select_device(track.devices[msg[2]])
            Live.Application.get_application().view.show_view("Detail/DeviceChain")
        
    def overdubCB(self, msg, source):
        """Called when a /live/overdub message is received.
        
        Messages:
        /live/overdub                       Gets the overdub status with a /live/overdub (0|1)
        /live/overdub     (int on=1/off=0/switch=2)      Enables/disables overdub
        """
        overdub = LiveUtils.getSong().overdub
        if len(msg) == 3:
            change = msg[2]
            if change == 2:
                if overdub == 1:
                    overdub = 0
                else:
                    overdub = 1
            else:
                overdub = change
            LiveUtils.getSong().overdub = overdub

    def tapCB(self, msg, source):
        """Called when a /live/tap message arrives

        """
        LiveUtils.getSong().tap_tempo()


    def loopCB(self, msg, source):
        """Called when a /live/loop message is received

         Messages:
         /live/loop (1/0/2)  set/unset/switch netronome
        """
        loop = LiveUtils.getSong().loop
        if len(msg) == 3:
            change = msg[2]
            if change == 2:
                if loop == 1:
                    loop = 0
                else:
                    loop = 1
            else:
                loop = change
            LiveUtils.getSong().loop = loop

    def metronomeCB(self, msg, source):
        """Called when a /live/metronome message is received

         Messages:
         /live/metronome (1/0/2)  set/unset/switch netronome
        """
        metronome = LiveUtils.getSong().metronome
        if len(msg) == 3:
            change = msg[2]
            if change == 2:
                if metronome == 1:
                    metronome = 0
                else:
                    metronome = 1
            else:
                metronome = change
            LiveUtils.getSong().metronome = metronome

    def transportStateCB(self, msg, source):
        """Called when a /live/transportstate message is received

        Messages:
        /live/transportstate    Gets the transport state: playing(1/0), overdub(1/0), tempo, metronome(1/0),
                                    signature_numerator, signature_denominator, loop(1/0)
        """
        song = LiveUtils.getSong()
        overdub = song.overdub
        tempo = LiveUtils.getTempo()
        playing = song.is_playing
        metronome = song.metronome
        numerator = song.signature_numerator
        denominator = song.signature_denominator
        loop = song.loop
        self.oscEndpoint.send("/live/transportstate", (int(playing), int(overdub), float(tempo), int(metronome), int(numerator), int(denominator), int(loop)))

    def stateCB(self, msg, source):
        """Called when a /live/state is received.
        
        Messages:
        /live/state                    Returns the current tempo and overdub status
        """
        if len(msg) == 2 or (len(msg) == 3 and msg[2] == "query"):
            tempo = LiveUtils.getTempo()
            overdub = LiveUtils.getSong().overdub
            self.oscEndpoint.send("/live/state", (tempo, int(overdub)))
        
    def clipInfoCB(self,msg, source):
        """Called when a /live/clip/info message is received.
        
        Messages:
        /live/clip/info     (int track, int clip)      Gets the status of a single clip in the form  /live/clip/info (tracknumber, clipnumber, state)
                                                       [state: 1 = Has Clip, 2 = Playing, 3 = Triggered]
        """
        
        if len(msg) == 4:
            trackNumber = msg[2]
            clipNumber = msg[3]    
            
            clip = LiveUtils.getClip(trackNumber, clipNumber)
            
            playing = 0
            
            if clip != None:
                playing = 1
                
                if clip.is_playing == 1:
                    playing = 2
                elif clip.is_triggered == 1:
                    playing = 3

            self.oscEndpoint.send("/live/clip/info", (trackNumber, clipNumber, playing))
        
        return
        
    def deviceCB(self, msg, source):
        ty = msg[0] == '/live/return/device' and 1 or 0
        track = msg[2]
    
        if len(msg) == 4:
            device = msg[3]
            po = [track, device]
            
            if ty == 1:
                params = LiveUtils.getSong().return_tracks[track].devices[device].parameters
            else:
                params = LiveUtils.getSong().tracks[track].devices[device].parameters
    
            for i in range(len(params)):
                po.append(i)
                po.append(float(params[i].value))
                po.append(str(params[i].name))
            
            self.oscEndpoint.send(ty == 1 and "/live/return/device/allparam" or "/live/device/allparam", tuple(po))
    
        elif len(msg) == 5:
            device = msg[3]
            param  = msg[4]
            mode   =1
            
            if ty == 1:
                p = LiveUtils.getSong().return_tracks[track].devices[device].parameters[param]
            else: 
                p = LiveUtils.getSong().tracks[track].devices[device].parameters[param]
        
            self.oscEndpoint.send(ty == 1 and "/live/return/device/param" or "/live/device/param", (track, device, param, p.value, str(p.name),mode))
    
    
        elif len(msg) == 6:
            device = msg[3]
            param  = msg[4]
            value  = msg[5]
        
            if ty == 1:
                LiveUtils.getSong().return_tracks[track].devices[device].parameters[param].value = value
            else:
                LiveUtils.getSong().tracks[track].devices[device].parameters[param].value = value

    def devicerangeCB(self, msg, source):
        ty = msg[0] == '/live/return/device/range' and 1 or 0
        track = msg[2]
    
        if len(msg) == 4:
            device = msg[3]
            po = [track, device]
            
            if ty == 1:
                params = LiveUtils.getSong().return_tracks[track].devices[device].parameters
            else:
                params = LiveUtils.getSong().tracks[track].devices[device].parameters
    
            for i in range(len(params)):
                po.append(i)
                po.append(params[i].min)
                po.append(params[i].max)
            
            self.oscEndpoint.send(ty == 1 and "/live/return/device/range" or "/live/device/range", tuple(po))
    
        elif len(msg) == 5:
            device = msg[3]
            param  = msg[4]
            
            if ty == 1:
                p = LiveUtils.getSong().return_tracks[track].devices[device].parameters[param]
            else: 
                p = LiveUtils.getSong().tracks[track].devices[device].parameters[param]
        
            self.oscEndpoint.send(ty == 1 and "/live/return/device/range" or "/live/device/range", (track, device, param, p.min, p.max, p.is_quantized+1))
                
    def devicelistCB(self, msg, source):
        ty = msg[0] == '/live/return/devicelist' and 1 or 0

        track = msg[2]
    
        if len(msg) == 3:
            do = [track]
            
            if ty == 1:
                devices = LiveUtils.getSong().return_tracks[track].devices
            else:
                devices = LiveUtils.getSong().tracks[track].devices
        
            for i in range(len(devices)):
                do.append(i)
                do.append(str(devices[i].name))
            
            self.oscEndpoint.send(ty == 1 and "/live/return/devicelist" or "/live/devicelist", tuple(do))

    def mdeviceCB(self, msg, source):
        if len(msg) == 3:
            device = msg[2]
            po = [device]
            
            params = LiveUtils.getSong().master_track.devices[device].parameters
    
            for i in range(len(params)):
                po.append(i)
                po.append(float(params[i].value))
                po.append(str(params[i].name))
            
            self.oscEndpoint.send("/live/master/device", tuple(po))
    
        elif len(msg) == 4:
            device = msg[2]
            param  = msg[3]
            
            p = LiveUtils.getSong().master_track.devices[device].parameters[param]
        
            self.oscEndpoint.send("/live/master/device", (device, param, p.value, str(p.name)))
    
        elif len(msg) == 5:
            device = msg[2]
            param  = msg[3]
            value  = msg[4]
        
            LiveUtils.getSong().master_track.devices[device].parameters[param].value = value

    def mdevicerangeCB(self, msg, source):
        if len(msg) == 3:
            device = msg[2]
            po = [device]
            
            params = LiveUtils.getSong().master_track.devices[device].parameters
    
            for i in range(len(params)):
                po.append(i)
                po.append(params[i].max)
                po.append(params[i].min)
                po.append(params[i].p.is_quantized+1)
              
            
            self.oscEndpoint.send("/live/master/device/range", tuple(po))
    
        elif len(msg) == 4:
            device = msg[2]
            param  = msg[3]
            
            p = LiveUtils.getSong().master_track.devices[device].parameters[param]
        
            self.oscEndpoint.send("/live/master/device/range", (device, param, p.min, p.max, p.is_quantized + 1))
            
    def mdevicelistCB(self, msg, source):
        if len(msg) == 2 or (len(msg) == 3 and msg[2] == "query"):
            do = []
            devices = LiveUtils.getSong().master_track.devices
        
            for i in range(len(devices)):
                do.append(i)
                do.append(str(devices[i].name))
            
            self.oscEndpoint.send("/live/master/devicelist", tuple(do))            
            
            
    def crossfaderCB(self, msg, source):
        if len(msg) == 2 or (len(msg) == 3 and msg[2] == "query"):
            self.oscEndpoint.send("/live/master/crossfader", float(LiveUtils.getSong().master_track.mixer_device.crossfader.value))
        
        elif len(msg) == 3:
            val = msg[2]
            LiveUtils.getSong().master_track.mixer_device.crossfader.value = val


    def loopStateCB(self, msg, source):
        type = msg[0] == '/live/clip/loopstate_id' and 1 or 0
    
        trackNumber = msg[2]
        clipNumber = msg[3]
    
        if len(msg) == 4:
            if type == 1:
                self.oscEndpoint.send("/live/clip/loopstate", (trackNumber, clipNumber, int(LiveUtils.getClip(trackNumber, clipNumber).looping)))
            else:
                self.oscEndpoint.send("/live/clip/loopstate", (int(LiveUtils.getClip(trackNumber, clipNumber).looping)))    
        
        elif len(msg) == 5:
            loopState = msg[4]
            LiveUtils.getClip(trackNumber, clipNumber).looping =  loopState

    def loopStartCB(self, msg, source):
        type = msg[0] == '/live/clip/loopstart_id' and 1 or 0
        
        trackNumber = msg[2]
        clipNumber = msg[3]
    
        if len(msg) == 4:
            if type == 1:
                self.oscEndpoint.send("/live/clip/loopstart", (trackNumber, clipNumber, float(LiveUtils.getClip(trackNumber, clipNumber).loop_start)))    
            else:
                self.oscEndpoint.send("/live/clip/loopstart", (float(LiveUtils.getClip(trackNumber, clipNumber).loop_start)))    
    
        elif len(msg) == 5:
            loopStart = msg[4]
            LiveUtils.getClip(trackNumber, clipNumber).loop_start = loopStart
            
    def loopEndCB(self, msg, source):
        type = msg[0] == '/live/clip/loopend_id' and 1 or 0
    
        trackNumber = msg[2]
        clipNumber = msg[3]    
        if len(msg) == 4:
            if type == 1:
                self.oscEndpoint.send("/live/clip/loopend", (trackNumber, clipNumber, float(LiveUtils.getClip(trackNumber, clipNumber).loop_end)))
            else:
                self.oscEndpoint.send("/live/clip/loopend", (float(LiveUtils.getClip(trackNumber, clipNumber).loop_end)))    
        
        elif len(msg) == 5:
            loopEnd = msg[4]
            LiveUtils.getClip(trackNumber, clipNumber).loop_end =  loopEnd

    def quantizationCB(self, msg, source):
        quant = msg[2]
        LiveUtils.getSong().clip_trigger_quantization = quant


    def foldTrackCB(self, msg, source):
        trackNumber = msg[2]
        track = LiveUtils.getSong().tracks[trackNumber]
        if track is None:
            return
        if track.is_foldable:
            if track.fold_state == 0:
                track.fold_state = 1
                trackState = 1
            else:
                track.fold_state = 0
                trackState = 0
            self.oscEndpoint.send("/live/fold", (trackNumber, trackState))

    def songCB(self, msg, source):
        """Called when a /live/song message is received.
        Messages:
        /live/song                 Request current song, replies with /live/time
        (int tracks, int scenes)
        """
        sceneTotal = len(LiveUtils.getScenes())
        trackTotal = len(LiveUtils.getSong().tracks)
        self.oscEndpoint.send("/live/song", (trackTotal, sceneTotal))

    def clipBlockInfoCB(self, msg, source):
        """Called when a /live/info/clipblock message is received
        Messages:
        /live/info/clipblock    Request a block [x,y,width,height], replies with [int x, int y, string name, int color]*
        """
        if len(msg) == 6:
            block = []
            trackOffset = msg[2]
            clipOffset = msg[3]
            blocksizeX = msg[4]
            blocksizeY = msg[5]
            for clip in range(0, blocksizeY):
                for track in range(0, blocksizeX):
                    trackNumber = trackOffset+track
                    clipNumber = clipOffset+clip
                    clipObj =LiveUtils.getSong().tracks[trackNumber].clip_slots[clipNumber].clip
                    if clipObj!= None:
                        color = clipObj.color
                        block.extend([trackNumber,clipNumber,str(clipObj.name),color])
            self.oscEndpoint.send("/live/info/clipblock", block)



########NEW FILE########
__FILENAME__ = LiveUtils
"""
# LiveUtils, a collection of simple utility functions for controlling Ableton Live
# Copyright (C) 2007 Rob King (rob@e-mu.org)
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# For questions regarding this module contact
# Rob King <rob@e-mu.org> or visit http://www.e-mu.org
"""
import Live
import sys

from Logger import log

def getTrackWithId():
    trackIds =[]
    i=0
    tracks= getTracks()
    for track in tracks:
        trackName=track.name
        if(trackName.find('ConductrIdT') != -1):
            trackIds.append(str(track.name))
            trackIds.append(i)
                
        i=i+1
    
    return trackIds

def getTrackDevicesWithId():
    deviceIds =[]
    i=0
    j=0
    tracks= getTracks()
    for track in tracks:
        for device in track.devices:
            deviceName=device.name
            log(device.name)
            if(deviceName.find('ConductrId') != -1):
                deviceIds.append(str(device.name))
                deviceIds.append(i)
                deviceIds.append(j)
                
                
            j=j+1
        
        j=0
        i=i+1
    
    return deviceIds        
    
def getSong():
    """Gets a the current Song instance"""
    return Live.Application.get_application().get_document()

def continuePlaying():
    """Continues Playing"""
    getSong().continue_playing()

def playSelection():
    """Plays the current selection"""
    getSong().play_selection()

def jumpBy(time):
    """Jumps the playhead relative to it's current position by time.  Stops playback."""
    getSong().jump_by(time)
    
def scrubBy(time):
    """Jumps the playhead relative to it's current position by time.  Does not stop playback"""
    getSong().scrub_by(time)

def play():
    """Starts Ableton Playing"""
    print "playing"
    getSong().start_playing()

def stopClips():
    """Stops all currently playing clips"""
    getSong().stop_all_clips()

def stop():
    """Stops Ableton"""
    getSong().stop_playing()

def currentTime(time = None):
    """Sets/Returns the current song time"""
    song = getSong()
    if time is not None:
        song.current_song_time = time
    return getSong().current_song_time

def getScenes():
    """Returns a list of scenes"""
    return getSong().scenes

def getScene(num):
    """Returns scene number (num) (starting at 0)"""
    return getSong().scenes[num]

def launchScene(scene):
    """Launches scene number (scene)"""
    getScene(scene).fire()

def getTracks():
    """Returns a list of tracks"""
    return getSong().tracks

def getTrack(num):
    """Returns track number (num) (starting at 0)"""
    return getSong().tracks[num]

def stopTrack(trackNumber):
    """Stops all clips in track number (trackNumber)"""
    track = getTrack(trackNumber)
    for clipSlot in track.clip_slots:
        clipSlot.stop()
    
def getTempo():
    """Returns the current song tempo"""
    return getSong().tempo

def setTempo(tempo):
    getSong().tempo = tempo

def jumpToNextCue():
    getSong().jump_to_next_cue()    

def jumpToPrevCue():
    getSong().jump_to_prev_cue()
    
def armTrack(num):
    """Arms track number (num)"""
    getTrack(num).arm = 1

def disarmTrack(num):
    """Disarms track number (num)"""
    getTrack(num).arm = 0

def toggleArmTrack(num):
    """Toggles the armed state of track number (num)"""
    armed = getTrack(num).arm
    if armed:
        getTrack(num).arm = 0
    else:
        getTrack(num).arm = 1

def muteTrack(track, ty = 0):
    """Mutes track number (num)"""
    if ty == 1:
        getSong().return_tracks[track].mute = 1
    else:
        getTrack(track).mute = 1

def unmuteTrack(track, ty = 0):
    """Unmutes track number (num)"""
    if ty == 1:
        getSong().return_tracks[track].mute = 0
    else:    
        getTrack(track).mute = 0
    
def toggleMuteTrack(num):
    """Toggles the muted state of track number (num)"""
    muted = getTrack(num).mute
    if muted:
        getTrack(num).mute = 0
    else:
        getTrack(num).mute = 1

def soloTrack(track, ty = 0):
    """Solo's track number (num)"""
    if ty == 1:
        getSong().return_tracks[track].solo = 1
    else:
        getTrack(track).solo = 1    
    
def unsoloTrack(track, ty = 0):
    """Un-solos track number (num)"""
    if ty == 1:
        getSong().return_tracks[track].solo = 0
    else:
        getTrack(track).solo = 0
    
def toggleSoloTrack(num):
    """Toggles the soloed state of track number (num)"""
    soloed = getTrack(num).solo
    if soloed:
        getTrack(num).solo = 0
    else:
        getTrack(num).solo = 1

def trackVolume(track, volume = None):
    """Gets/Changes the volume of track (track)

    If (volume) is specified, changes the volume of track number
    (track) to (volume), a value between 0.0 and 1.0.
    """
    if volume != None:
        getTrack(track).mixer_device.volume.value = volume
    return getTrack(track).mixer_device.volume.value

def trackPan(track, pan = None):
    """Gets/Changes the panning of track number (track)

    If (pan) is specified, changes the panning to (pan).
    (pan) should be a value between -1.0 to 1.0
    """
    if pan != None:
        getTrack(track).mixer_device.panning.value = pan
    return getTrack(track).mixer_device.panning.value

def trackSend(track, send = None, level=None):
    """Gets/Changes the level of send number (send) on track (track).

    If (level) is specified, the level of the send is set to (level),
    a value between 0.0 and 1.0
    """
    if send == None:
        return getTrack(track).mixer_device.sends
    if level != None:
        getTrack(track).mixer_device.sends[send].value = level
    return getTrack(track).mixer_device.sends[send].value
    
def trackName(track, name = None):
    """Gets/Changes the name of track (track).

    If (name) is specified, the track name is changed
    """
    if name != None:
        getTrack(track).name = name
    return str(getTrack(track).name)

def getClipSlots():
    """Gets a 2D list of all the clip slots in the song"""
    tracks = getTracks()
    clipSlots = []
    for track in tracks:
        clipSlots.append(track.clip_slots)
    return clipSlots

def getClips():
    """Gets a 2D list of all the clip in the song.

    If there is no clip in a clip slot, None is returned

    """
    tracks = getTracks()
    clips = []
    for track in getClipSlots():
        trackClips = []
        for clipSlot in track:
            trackClips.append(clipSlot.clip)
        clips.append(trackClips)
    return clips

def launchClip(track, clip):
    """Launches clip number (clip) in track number (track)"""
    getClip(track, clip).fire()

def stopClip(track, clip):
    """Stops clip number (clip) in track (track)""" 
    getClip(track, clip).stop()

def getClip(track, clip):
    """Returns clip number (clip) in track (track)"""
    # painful code!
    #clips = getClips()
    #return clips[track][clip]
    return getSong().tracks[track].clip_slots[clip].clip

def clipName(track, clip, name = None):
    """Gets/changes the name of clip number (clip) in track (track)

    In (name) is specified, the name of the clip is changed

    """
    if name != None:
        getClip(track, clip).name = name
    return str(getClip(track, clip).name)

def clipPitch(track, clip, coarse = None, fine = None):
    """Gets/changes the coarse and fine pitch shift of clip (clip) in track (track).

    If (coarse) or (fine) are specified, changes the clip's pitch.
    """
    clip = getClip(track, clip)
    if coarse != None:
        clip.pitch_coarse = coarse
    if fine != None:
        clip.pitch_fine = fine
    return (clip.pitch_coarse, clip.pitch_fine)




########NEW FILE########
__FILENAME__ = Logger
import sys
import time

try:
    import socket
except:
    print "No Sockets"
    
class Logger:
    """
    Simple logger.
    Tries to use a socket which connects to localhost port 4444 by default.
    If that fails then it logs to a file
    """
    def __init__(self):
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        except:
            print "Couldn't create socket"
            self.socket = None
            
        self.connected = 0
        
        if self.socket:
            try:
                self.socket.connect(("localhost", 4444))
                self.connected = 1
                self.stderr = sys.stderr
                sys.stderr = self
            except:
                print "Couldn't connect socket"

        self.buf = ""

    def log(self,msg):
        if self.connected:
            self.send(msg + '\n')
        else:
            print(msg)
        
    def send(self,msg):
        if self.connected:
            self.socket.send(msg)
    
    def close(self):
        if self.connected:
            self.socket.send("Closing..")
            self.socket.close()
            
    def write(self, msg):
        self.stderr.write(msg)
        self.buf = self.buf + msg
        lines = self.buf.split("\n", 2)
        if len(lines) == 2:
            self.send("STDERR: " + lines[0] + "\n")
            self.buf = lines[1]

logger = Logger()

def log(*args):
    text = ''
    for arg in args:
        if text != '':
            text = text + ' '
        text = text + str(arg)
    if logger != None:
        logger.log(text)


########NEW FILE########
__FILENAME__ = LogServer
#!/usr/bin/env python

import SocketServer
import time
import sys

class LoggerRequestHandler(SocketServer.BaseRequestHandler):
    def setup(self):
        print self.client_address, 'connected!'

    def handle(self):
        while 1:
            time.sleep(0.01)
            data = self.request.recv(1024)
            if len(data) > 0:
                sys.stdout.write(data)

    def finish(self):
        print self.client_address, 'disconnected!'

if __name__=='__main__':
    SocketServer.ThreadingTCPServer.allow_reuse_address = True
    server = SocketServer.ThreadingTCPServer(('', 4444), LoggerRequestHandler)
    server.serve_forever()


########NEW FILE########
__FILENAME__ = OSC
#!/usr/bin/python
#
# Open SoundControl for Python
# Copyright (C) 2002 Daniel Holth, Clinton McChesney
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# For questions regarding this module contact 
# Daniel Holth <dholth@stetson.edu> or visit
# http://www.stetson.edu/~ProctoLogic/
#
# Changelog:
# 15 Nov. 2001:
#   Removed dependency on Python 2.0 features.
#   - dwh
# 13 Feb. 2002:
#   Added a generic callback handler.
#   - dwh
#
# Updated June 2007 by Hans Huebner (hans.huebner@gmail.com)
#   Improved bundle support, API cleanup

import sys
import struct
import math
import string
import time

from Logger import log

def hexDump(bytes):
    """Useful utility; prints the string in hexadecimal"""
    for i in range(len(bytes)):
        sys.stdout.write("%2x " % (ord(bytes[i])))
        if (i+1) % 8 == 0:
            print repr(bytes[i-7:i+1])

    if(len(bytes) % 8 != 0):
        print string.rjust("", 11), repr(bytes[i-7:i+1])

class OSCMessage:
    """Builds typetagged OSC messages."""
    def __init__(self, address='', msg=()):
        self.address  = address
        self.typetags = ","
        self.message  = ""

        if type(msg) in (str, int, float):
           self.append(msg)
        elif type(msg) in (list,tuple):
             for m in msg:
                if type(m) not in (str,int,float):
                    log("don't know how to encode message element " + str(m) + " " + str(type(m)))
                    return
                self.append(m)
        else:
            log("don't know how to encode message " + str(m) + " " + str(type(m)))
            return

    def append(self, argument, typehint = None):
        """Appends data to the message,
        updating the typetags based on
        the argument's type.
        If the argument is a blob (counted string)
        pass in 'b' as typehint."""

        if typehint == 'b':
            binary = OSCBlob(argument)
        else:
            binary = OSCArgument(argument)

        self.typetags = self.typetags + binary[0]
        self.message = self.message + binary[1]

    def getBinary(self):
        """Returns the binary message (so far) with typetags."""
        address  = OSCArgument(self.address)[1]
        typetags = OSCArgument(self.typetags)[1]
        return address + typetags + self.message

    def __repr__(self):
        return self.getBinary()

JAN_1970 = 2208988800L
SECS_TO_PICOS = 4294967296L
def abs_to_timestamp(abs):
    """ since 1970 => since 1900 64b OSC """
    sec_1970 = long(abs)
    sec_1900 = sec_1970 + JAN_1970

    sec_frac = float(abs - sec_1970)
    picos = long(sec_frac * SECS_TO_PICOS)

    total_picos = (abs + JAN_1970) * SECS_TO_PICOS
    return struct.pack('!LL', sec_1900, picos)

class OSCBundle:
    """Builds OSC bundles"""
    def __init__(self, when=None):
        self.items = []
        if when == None:
            when = time.time()
        self.when = when

    def append(self, address, msg = None):
        if isinstance(address, str):
            self.items.append(OSCMessage(address, msg))
        elif isinstance(address, OSCMessage):
            # address really is an OSCMessage
            self.items.append(address)
        else:
            raise Exception('invalid type of first argument to OSCBundle.append(), need address string or OSCMessage, not ', str(type(address)))

    def getBinary(self):
        retval = OSCArgument('#bundle')[1] + abs_to_timestamp(self.when)
        for item in self.items:
            binary = item.getBinary()
            retval = retval + OSCArgument(len(binary))[1] + binary
        return retval

def readString(data):
    length   = string.find(data,"\0")
    nextData = int(math.ceil((length+1) / 4.0) * 4)
    return (data[0:length], data[nextData:])

def readBlob(data):
    length   = struct.unpack(">i", data[0:4])[0]    
    nextData = int(math.ceil((length) / 4.0) * 4) + 4   
    return (data[4:length+4], data[nextData:])

def readInt(data):
    if(len(data)<4):
        print "Error: too few bytes for int", data, len(data)
        rest = data
        integer = 0
    else:
        integer = struct.unpack(">i", data[0:4])[0]
        rest    = data[4:]
        
    return (integer, rest)

def readLong(data):
    """Tries to interpret the next 8 bytes of the data
    as a 64-bit signed integer."""
    high, low = struct.unpack(">ll", data[0:8])
    big = (long(high) << 32) + low
    rest = data[8:]
    return (big, rest)

def readFloat(data):
    if(len(data)<4):
        print "Error: too few bytes for float", data, len(data)
        rest = data
        float = 0
    else:
        float = struct.unpack(">f", data[0:4])[0]
        rest  = data[4:]

    return (float, rest)

def OSCBlob(next):
    """Convert a string into an OSC Blob,
    returning a (typetag, data) tuple."""

    if type(next) == type(""):
        length = len(next)
        padded = math.ceil((len(next)) / 4.0) * 4
        binary = struct.pack(">i%ds" % (padded), length, next)
        tag    = 'b'
    else:
        tag    = ''
        binary = ''
    
    return (tag, binary)

def OSCArgument(next):
    """Convert some Python types to their
    OSC binary representations, returning a
    (typetag, data) tuple."""
    
    if type(next) == type(""):        
        OSCstringLength = math.ceil((len(next)+1) / 4.0) * 4
        binary  = struct.pack(">%ds" % (OSCstringLength), next)
        tag = "s"
    elif type(next) == type(42.5):
        binary  = struct.pack(">f", next)
        tag = "f"
    elif type(next) == type(13):
        binary  = struct.pack(">i", next)
        tag = "i"
    else:
        raise Exception("don't know how to encode " + str(next) + " as OSC argument, type=" + str(type(next)))

    return (tag, binary)

def parseArgs(args):
    """Given a list of strings, produces a list
    where those strings have been parsed (where
    possible) as floats or integers."""
    parsed = []
    for arg in args:
        print arg
        arg = arg.strip()
        interpretation = None
        try:
            interpretation = float(arg)
            if string.find(arg, ".") == -1:
                interpretation = int(interpretation)
        except:
            # Oh - it was a string.
            interpretation = arg
        parsed.append(interpretation)
    return parsed

def decodeOSC(data):
    """Converts a typetagged OSC message to a Python list."""
    table = {"i":readInt, "f":readFloat, "s":readString, "b":readBlob}
    decoded = []
    address,  rest = readString(data)
    typetags = ""

    if address == "#bundle":
        time, rest = readLong(rest)
        decoded.append(address)
        decoded.append(time)
        while len(rest)>0:
            length, rest = readInt(rest)
            decoded.append(decodeOSC(rest[:length]))
            rest = rest[length:]

    elif len(rest)>0:
        typetags, rest = readString(rest)
        decoded.append(address)
        decoded.append(typetags)
        if(typetags[0] == ","):
            for tag in typetags[1:]:
                value, rest = table[tag](rest)                
                decoded.append(value)
        else:
            print "Oops, typetag lacks the magic ,"
    else:
        decoded.append(address)
        decoded.append(',')

    # return only the data
    return decoded

class CallbackManager:
    """This utility class maps OSC addresses to callables.

    The CallbackManager calls its callbacks with a list
    of decoded OSC arguments, including the address and
    the typetags as the first two arguments."""

    def __init__(self):
        self.callbacks = {}
        self.add("#bundle", self.unbundler)

    def handle(self, data, source):
        """Given OSC data, tries to call the callback with the right address."""
        decoded = decodeOSC(data)
        self.dispatch(decoded, source)

    def dispatch(self, message, source):
        """Sends decoded OSC data to an appropriate calback"""
        address = message[0]
        self.callbacks[address](message, source)

    def add(self, address, callback):
        """Adds a callback to our set of callbacks,
        or removes the callback with name if callback
        is None."""
        if callback == None:
            del self.callbacks[address]
        else:
            self.callbacks[address] = callback

    def unbundler(self, messages, source):
        """Dispatch the messages in a decoded bundle."""
        # first two elements are #bundle and the time tag, rest are messages.
        for message in messages[2:]:
            self.dispatch(message, source)

if __name__ == "__main__":
    hexDump("Welcome to the OSC testing program.")
    print
    message = OSCMessage("/foo/play")
    message.append(44)
    message.append(11)
    message.append(4.5)
    message.append("the white cliffs of dover")
    hexDump(message.getBinary())

    print "Making and unmaking a message.."

    strings = OSCMessage()
    strings.append("Mary had a little lamb")
    strings.append("its fleece was white as snow")
    strings.append("and everywhere that Mary went,")
    strings.append("the lamb was sure to go.")
    strings.append(14.5)
    strings.append(14.5)
    strings.append(-400)

    raw  = strings.getBinary()

    hexDump(raw)
    
    print "Retrieving arguments..."
    data = raw
    for i in range(6):
        text, data = readString(data)
        print text

    number, data = readFloat(data)
    print number

    number, data = readFloat(data)
    print number

    number, data = readInt(data)
    print number

    hexDump(raw)
    print decodeOSC(raw)
    print decodeOSC(message.getBinary())

    print "Testing Blob types."
   
    blob = OSCMessage()
    blob.append("","b")
    blob.append("b","b")
    blob.append("bl","b")
    blob.append("blo","b")
    blob.append("blob","b")
    blob.append("blobs","b")
    blob.append(42)

    hexDump(blob.getBinary())

    print decodeOSC(blob.getBinary())

    def printingCallback(stuff, source):
        sys.stdout.write("Got: ")
        for i in stuff:
            sys.stdout.write(str(i) + " ")
        sys.stdout.write("\n")

    print "Testing bundles"

    print1 = OSCMessage("/print")
    print1.append("Hey man, that's cool.")
    print1.append(42)
    print1.append(3.1415926)

    bundle = OSCBundle()
    bundle.append(print1)
    bundle.append('/foo', (123, 456))
    bundlebinary = bundle.getBinary()
    hexDump(bundlebinary)
    print decodeOSC(bundlebinary)

    print "Testing the callback manager."
    
    c = CallbackManager()
    c.add("/print", printingCallback)
    
    c.handle(message.getBinary(), None)
    
    c.handle(print1.getBinary(), None)

    print "sending a bundle to the callback manager"
    c.handle(bundlebinary, None)

########NEW FILE########
__FILENAME__ = RemixNet
"""
# Copyright (C) 2007 Nathan Ramella (nar@remix.net)
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# For questions regarding this module contact
# Nathan Ramella <nar@remix.net> or visit http://www.liveapi.org

RemixNet Module

This module contains an OSC interface class to facilitate remote
control of Ableton Live through the OSC protocol.

Based on the original RemixNet.py written by Nathan Ramella (nar@remix.net)

-Updated 29/04/09 by ST8 (st8@q3f.org)
    Works on Mac OSX with Live7/8
    
    The socket module is missing on osx and including it from the
    default python install doesnt work.  Turns out its the os module
    that causes all the problems, removing dependance on this module
    and packaging the script with a modified version of the socket
    module allows it to run on osx.

-Updated May/June 2011 by Hans Huebner (hans.huebner@gmail.com)

    Refactored and removed methods that are not used.
    
    The original version of RemixNet.py had several classes to
    implement sending and receiving OSC packets.  This was relatively
    hard to change or update, and as I wanted to be able to change the
    destination of OSC packets sent out by live at run time, I decided
    to simplify RemixNet so that it only supports those functions that
    are actually used by LiveOSC.  In particular, OSCServer,
    OSCClient, UDPServer and UDPClient have all been collapsed into
    one class, OSCEndpoint.  OSCEndpoint uses one UDP socket to send
    and receive data.  By default, the socket is bound to port 9000 as
    before, but it listens to all network interfaces so that packets
    coming in from the network are accepted.  Also by default,
    outgoing packets are sent to localhost port 9001.  This can be
    changed by sending a /remix/set_peer message with two arguments,
    the host and the port number of the peer.  The host may optionally
    be sent as empty string.  In that case, the peer host will be
    automatically be set to the host that sent the /remix/set_peer
    message, making it easier to configure the OSC association.

    Also, the logging mechanism has been simplified.  It can now be
    used simply by importing the log function from the Logger module
    and then calling log() with a string argument.
"""
import sys
import errno
import Live
from Logger import log

# Import correct paths for os / version
version = Live.Application.get_application().get_major_version()
if sys.platform == "win32":
    import socket   

else:
    if version > 7:
       # 10.5
        try:
            file = open("/usr/lib/python2.5/string.pyc")
        except IOError:
            sys.path.append("/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5")
            import socket_live8 as socket  
        else:
            sys.path.append("/usr/lib/python2.5")
            import socket

import OSC 
            
class OSCEndpoint:
        
    def __init__(self, remoteHost='127.0.0.1', remotePort=9031, localHost='127.0.0.1', localPort=9030, ):
        """
      
        This is the main class we the use as a nexus point in this module.

        - remoteHost and remotePort define the address of the peer
          that we send data to by default.  It can be changed, at run
          time, using the /remix/set_peer OSC message.

        - localHost and localPort define the address that we are
          listening to for incoming OSC packets.  By default, we are
          listening on all interfaces with port 9000.
        
        By default we define and set callbacks for some utility
        addresses:
        
        /remix/echo - Echos back the string argument to the peer.
        /remix/time - Returns time.time() (time in float seconds)
        /remix/set_peer - Reconfigures the peer address which we send OSC messages to
        """

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.setblocking(0)
        self.localAddr = (localHost, localPort)
        self.socket.bind(self.localAddr)

        self.remoteAddr = (remoteHost, remotePort)

        log('OSCEndpoint starting, local address ' + str(self.localAddr) + ' remote address ' + str(self.remoteAddr))
        
        # Create our callback manager and register some utility
        # callbacks
        
        self.callbackManager = OSC.CallbackManager()
        self.callbackManager.add('/remix/echo', self.callbackEcho)
        self.callbackManager.add('/remix/time', self.callbackEcho)
        self.callbackManager.add('/remix/set_peer', self.setPeer)
 
    def send(self, address, msg):
       
        """
        Given an OSC address and OSC msg payload we construct our
        OSC packet and send it to its destination. You can pass in lists
        or tuples in msg and we will iterate over them and append each 
        to the end of a single OSC packet.
        
        This can be useful for transparently dealing with methods that
        yield a variety of values in a list/tuple without the necessity of
        combing through it yourself.
        """
        
        oscMessage = OSC.OSCMessage(address, msg)
        self.sendMessage(oscMessage)

    def sendMessage(self, message):
        self.socket.sendto(message.getBinary(), self.remoteAddr)

    def processIncomingUDP(self):
        """
        This is the function that deals with incoming UDP messages.
        It processes messages as long as any are buffered in the
        socket, then returns.
        
        There are several limitations to the Ableton Live Python environment. 
        
        * The Ableton Live Python environment is minimal. The included module
          list is very short. For instance, we don't have 'select()'.
          
        * The Ableton Live Python version is a bit older than what most Python
          programmers are used to. Its version string says 2.2.1, and the Python
          webpage shows that the offical 2.2.3 came out May 30, 2003. So we've
          got 4 years between us and it. Fortunately since I didn't know any Python
          when I got started on this project the version differences didn't bother 
          me. But I know the lack of modern features has been a pain for a few
          of our developers.
          
        * The Ableton Live Python environment, although it includes the thread
          module, doesn't function how you'd expect it to. The threads appear to
          be on a 100ms timer that cannot be altered consistently through Python.
          
          I did find an interesting behavior in that when you modify the
          sys.setcheckinterval value to very large numbers for about 1-5/100ths of
          a second thread focus goes away entirely and if your running thread is
          a 'while 1:' loop with no sleep, it gets 4-5 iterations in before 
          the thread management stuff kicks in and puts you down back to 100ms 
          loop.
          
          As a goof I tried making a thread that was a 'while 1:' loop with a
          sys.setcheckinterval(50000) inside it -- first iteration it triggered
          the behavior, then it stopped.
          
          It should also be noted that you can make a blocking TCP socket using
          the threads interface. But your refresh is going to be about 40ms slower
          than using a non-blocking UDP socket reader. But hey, you're the boss!
          
          So far the best performance for processing incoming packets can be found
          by attaching a method as a listener to the Song.current_song_time 
          attribute. This attribute updates every 60ms on the dot allowing for 
          16 passes on the incoming UDP traffic every second.
          
          My machine is pretty beefy but I was able to sustain an average of
          over 1300 /remix/echo callback hits a second and only lost .006% 
          of my UDP traffic over 10 million packets on a machine running Live.
          
          One final note -- I make no promises as to the latency of triggers received.
          I haven't tested that at all yet. Since the window is 60ms, don't get 
          your hopes up about MIDI over OSC.
        """
        try:
            # Our socket is in non-blocking mode.  recvfrom will
            # either return the next packet waiting or raise an EAGAIN
            # exception that we catch to exit the reception loop.
            while 1:
                self.data, self.addr = self.socket.recvfrom(65536)
#                log('received packet from ' + str(self.addr))
                try:
                    self.callbackManager.handle(self.data, self.addr)
                except:
                    self.send('/remix/error', (str(sys.exc_info())))

        except Exception, e:
            err, message=e
            if err != errno.EAGAIN:                                 # no data on socket
                log('error handling message, errno ' + str(errno) + ': ' + message)

    def shutdown(self):
        """
        Close our socket.
        """
        self.socket.close()

    # standard callback handlers (in the /remix/ address name space)

    def setPeer(self, msg, source):
        """
        Reconfigure the client side to the address and port indicated
        as the argument.  The first argument is a string with the host
        address or an empty string if the IP address of the sender of
        the reconfiguration message should be used as peer.  The
        second argument is the integer port number of the peer.
        """
        host = msg[2]
        if host == '':
            host = source[0]
        port = msg[3]
        log('reconfigure to send to ' + host + ':' + str(port))
        self.remoteAddr = (host, port)
  
    def callbackEcho(self, msg, source):
        """
        When re receive a '/remix/echo' OSC query from another host
        we respond in kind by passing back the message they sent to us.
        Useful for verifying functionality.
        """
        
        self.send('/remix/echo', msg[2])
        
    def callbackTime(self, msg, source):
        """
        When we receive a '/remix/time' OSC query from another host
        we respond with the current value of time.time()
        
        This callback can be useful for testing timing/queue processing
        between hosts
        """

        self.send('/remix/time', time.time())
        

########NEW FILE########
__FILENAME__ = socket_live8
# Wrapper module for _socket, providing some additional facilities
# implemented in Python.

"""\
This module provides socket operations and some related functions.
On Unix, it supports IP (Internet Protocol) and Unix domain sockets.
On other systems, it only supports IP. Functions specific for a
socket are available as methods of the socket object.

Functions:

socket() -- create a new socket object
socketpair() -- create a pair of new socket objects [*]
fromfd() -- create a socket object from an open file descriptor [*]
gethostname() -- return the current hostname
gethostbyname() -- map a hostname to its IP number
gethostbyaddr() -- map an IP number or hostname to DNS info
getservbyname() -- map a service name and a protocol name to a port number
getprotobyname() -- mape a protocol name (e.g. 'tcp') to a number
ntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order
htons(), htonl() -- convert 16, 32 bit int from host to network byte order
inet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format
inet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)
ssl() -- secure socket layer support (only available if configured)
socket.getdefaulttimeout() -- get the default timeout value
socket.setdefaulttimeout() -- set the default timeout value

 [*] not available on all platforms!

Special objects:

SocketType -- type object for socket objects
error -- exception raised for I/O errors
has_ipv6 -- boolean value indicating if IPv6 is supported

Integer constants:

AF_INET, AF_UNIX -- socket domains (first argument to socket() call)
SOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)

Many other constants may be defined; these may be used in calls to
the setsockopt() and getsockopt() methods.
"""

import _socket
from _socket import *

_have_ssl = False
try:
    import _ssl
    from _ssl import *
    _have_ssl = True
except ImportError:
    pass

import sys

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

try:
    from errno import EBADF
except ImportError:
    EBADF = 9

__all__ = ["getfqdn"]
#__all__.extend(os._get_exports_list(_socket))
#if _have_ssl:
#    __all__.extend(os._get_exports_list(_ssl))

_realsocket = socket
if _have_ssl:
    _realssl = ssl
    def ssl(sock, keyfile=None, certfile=None):
        if hasattr(sock, "_sock"):
            sock = sock._sock
        return _realssl(sock, keyfile, certfile)

# WSA error codes
if sys.platform.lower().startswith("win"):
    errorTab = {}
    errorTab[10004] = "The operation was interrupted."
    errorTab[10009] = "A bad file handle was passed."
    errorTab[10013] = "Permission denied."
    errorTab[10014] = "A fault occurred on the network??" # WSAEFAULT
    errorTab[10022] = "An invalid operation was attempted."
    errorTab[10035] = "The socket operation would block"
    errorTab[10036] = "A blocking operation is already in progress."
    errorTab[10048] = "The network address is in use."
    errorTab[10054] = "The connection has been reset."
    errorTab[10058] = "The network has been shut down."
    errorTab[10060] = "The operation timed out."
    errorTab[10061] = "Connection refused."
    errorTab[10063] = "The name is too long."
    errorTab[10064] = "The host is down."
    errorTab[10065] = "The host is unreachable."
    __all__.append("errorTab")



def getfqdn(name=''):
    """Get fully qualified domain name from name.

    An empty argument is interpreted as meaning the local host.

    First the hostname returned by gethostbyaddr() is checked, then
    possibly existing aliases. In case no FQDN is available, hostname
    from gethostname() is returned.
    """
    name = name.strip()
    if not name or name == '0.0.0.0':
        name = gethostname()
    try:
        hostname, aliases, ipaddrs = gethostbyaddr(name)
    except error:
        pass
    else:
        aliases.insert(0, hostname)
        for name in aliases:
            if '.' in name:
                break
        else:
            name = hostname
    return name


_socketmethods = (
    'bind', 'connect', 'connect_ex', 'fileno', 'listen',
    'getpeername', 'getsockname', 'getsockopt', 'setsockopt',
    'sendall', 'setblocking',
    'settimeout', 'gettimeout', 'shutdown')

if sys.platform == "riscos":
    _socketmethods = _socketmethods + ('sleeptaskw',)

# All the method names that must be delegated to either the real socket
# object or the _closedsocket object.
_delegate_methods = ("recv", "recvfrom", "recv_into", "recvfrom_into",
                     "send", "sendto")

class _closedsocket(object):
    __slots__ = []
    def _dummy(*args):
        raise error(EBADF, 'Bad file descriptor')
    # All _delegate_methods must also be initialized here.
    send = recv = recv_into = sendto = recvfrom = recvfrom_into = _dummy
    __getattr__ = _dummy

class _socketobject(object):

    __doc__ = _realsocket.__doc__

    __slots__ = ["_sock", "__weakref__"] + list(_delegate_methods)

    def __init__(self, family=AF_INET, type=SOCK_STREAM, proto=0, _sock=None):
        if _sock is None:
            _sock = _realsocket(family, type, proto)
        self._sock = _sock
        for method in _delegate_methods:
            setattr(self, method, getattr(_sock, method))

    def close(self):
        self._sock = _closedsocket()
        dummy = self._sock._dummy
        for method in _delegate_methods:
            setattr(self, method, dummy)
    close.__doc__ = _realsocket.close.__doc__

    def accept(self):
        sock, addr = self._sock.accept()
        return _socketobject(_sock=sock), addr
    accept.__doc__ = _realsocket.accept.__doc__

    def dup(self):
        """dup() -> socket object

        Return a new socket object connected to the same system resource."""
        return _socketobject(_sock=self._sock)

    def makefile(self, mode='r', bufsize=-1):
        """makefile([mode[, bufsize]]) -> file object

        Return a regular file object corresponding to the socket.  The mode
        and bufsize arguments are as for the built-in open() function."""
        return _fileobject(self._sock, mode, bufsize)

    family = property(lambda self: self._sock.family, doc="the socket family")
    type = property(lambda self: self._sock.type, doc="the socket type")
    proto = property(lambda self: self._sock.proto, doc="the socket protocol")

    _s = ("def %s(self, *args): return self._sock.%s(*args)\n\n"
          "%s.__doc__ = _realsocket.%s.__doc__\n")
    for _m in _socketmethods:
        exec _s % (_m, _m, _m, _m)
    del _m, _s

socket = SocketType = _socketobject

class _fileobject(object):
    """Faux file object attached to a socket object."""

    default_bufsize = 8192
    name = "<socket>"

    __slots__ = ["mode", "bufsize", "softspace",
                 # "closed" is a property, see below
                 "_sock", "_rbufsize", "_wbufsize", "_rbuf", "_wbuf",
                 "_close"]

    def __init__(self, sock, mode='rb', bufsize=-1, close=False):
        self._sock = sock
        self.mode = mode # Not actually used in this version
        if bufsize < 0:
            bufsize = self.default_bufsize
        self.bufsize = bufsize
        self.softspace = False
        # _rbufsize is the suggested recv buffer size.  It is *strictly*
        # obeyed within readline() for recv calls.  If it is larger than
        # default_bufsize it will be used for recv calls within read().
        if bufsize == 0:
            self._rbufsize = 1
        elif bufsize == 1:
            self._rbufsize = self.default_bufsize
        else:
            self._rbufsize = bufsize
        self._wbufsize = bufsize
        # We use StringIO for the read buffer to avoid holding a list
        # of variously sized string objects which have been known to
        # fragment the heap due to how they are malloc()ed and often
        # realloc()ed down much smaller than their original allocation.
        self._rbuf = StringIO()
        self._wbuf = [] # A list of strings
        self._close = close

    def _getclosed(self):
        return self._sock is None
    closed = property(_getclosed, doc="True if the file is closed")

    def close(self):
        try:
            if self._sock:
                self.flush()
        finally:
            if self._close:
                self._sock.close()
            self._sock = None

    def __del__(self):
        try:
            self.close()
        except:
            # close() may fail if __init__ didn't complete
            pass

    def flush(self):
        if self._wbuf:
            buffer = "".join(self._wbuf)
            self._wbuf = []
            self._sock.sendall(buffer)

    def fileno(self):
        return self._sock.fileno()

    def write(self, data):
        data = str(data) # XXX Should really reject non-string non-buffers
        if not data:
            return
        self._wbuf.append(data)
        if (self._wbufsize == 0 or
            self._wbufsize == 1 and '\n' in data or
            self._get_wbuf_len() >= self._wbufsize):
            self.flush()

    def writelines(self, list):
        # XXX We could do better here for very long lists
        # XXX Should really reject non-string non-buffers
        self._wbuf.extend(filter(None, map(str, list)))
        if (self._wbufsize <= 1 or
            self._get_wbuf_len() >= self._wbufsize):
            self.flush()

    def _get_wbuf_len(self):
        buf_len = 0
        for x in self._wbuf:
            buf_len += len(x)
        return buf_len

    def read(self, size=-1):
        # Use max, disallow tiny reads in a loop as they are very inefficient.
        # We never leave read() with any leftover data from a new recv() call
        # in our internal buffer.
        rbufsize = max(self._rbufsize, self.default_bufsize)
        # Our use of StringIO rather than lists of string objects returned by
        # recv() minimizes memory usage and fragmentation that occurs when
        # rbufsize is large compared to the typical return value of recv().
        buf = self._rbuf
        buf.seek(0, 2)  # seek end
        if size < 0:
            # Read until EOF
            self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
            while True:
                data = self._sock.recv(rbufsize)
                if not data:
                    break
                buf.write(data)
            return buf.getvalue()
        else:
            # Read until size bytes or EOF seen, whichever comes first
            buf_len = buf.tell()
            if buf_len >= size:
                # Already have size bytes in our buffer?  Extract and return.
                buf.seek(0)
                rv = buf.read(size)
                self._rbuf = StringIO()
                self._rbuf.write(buf.read())
                return rv

            self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
            while True:
                left = size - buf_len
                # recv() will malloc the amount of memory given as its
                # parameter even though it often returns much less data
                # than that.  The returned data string is short lived
                # as we copy it into a StringIO and free it.  This avoids
                # fragmentation issues on many platforms.
                data = self._sock.recv(left)
                if not data:
                    break
                n = len(data)
                if n == size and not buf_len:
                    # Shortcut.  Avoid buffer data copies when:
                    # - We have no data in our buffer.
                    # AND
                    # - Our call to recv returned exactly the
                    #   number of bytes we were asked to read.
                    return data
                if n == left:
                    buf.write(data)
                    del data  # explicit free
                    break
                assert n <= left, "recv(%d) returned %d bytes" % (left, n)
                buf.write(data)
                buf_len += n
                del data  # explicit free
                #assert buf_len == buf.tell()
            return buf.getvalue()

    def readline(self, size=-1):
        buf = self._rbuf
        buf.seek(0, 2)  # seek end
        if buf.tell() > 0:
            # check if we already have it in our buffer
            buf.seek(0)
            bline = buf.readline(size)
            if bline.endswith('\n') or len(bline) == size:
                self._rbuf = StringIO()
                self._rbuf.write(buf.read())
                return bline
            del bline
        if size < 0:
            # Read until \n or EOF, whichever comes first
            if self._rbufsize <= 1:
                # Speed up unbuffered case
                buf.seek(0)
                buffers = [buf.read()]
                self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
                data = None
                recv = self._sock.recv
                while data != "\n":
                    data = recv(1)
                    if not data:
                        break
                    buffers.append(data)
                return "".join(buffers)

            buf.seek(0, 2)  # seek end
            self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
            while True:
                data = self._sock.recv(self._rbufsize)
                if not data:
                    break
                nl = data.find('\n')
                if nl >= 0:
                    nl += 1
                    buf.write(buffer(data, 0, nl))
                    self._rbuf.write(buffer(data, nl))
                    del data
                    break
                buf.write(data)
            return buf.getvalue()
        else:
            # Read until size bytes or \n or EOF seen, whichever comes first
            buf.seek(0, 2)  # seek end
            buf_len = buf.tell()
            if buf_len >= size:
                buf.seek(0)
                rv = buf.read(size)
                self._rbuf = StringIO()
                self._rbuf.write(buf.read())
                return rv
            self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
            while True:
                data = self._sock.recv(self._rbufsize)
                if not data:
                    break
                left = size - buf_len
                # did we just receive a newline?
                nl = data.find('\n', 0, left)
                if nl >= 0:
                    nl += 1
                    # save the excess data to _rbuf
                    self._rbuf.write(buffer(data, nl))
                    if buf_len:
                        buf.write(buffer(data, 0, nl))
                        break
                    else:
                        # Shortcut.  Avoid data copy through buf when returning
                        # a substring of our first recv().
                        return data[:nl]
                n = len(data)
                if n == size and not buf_len:
                    # Shortcut.  Avoid data copy through buf when
                    # returning exactly all of our first recv().
                    return data
                if n >= left:
                    buf.write(buffer(data, 0, left))
                    self._rbuf.write(buffer(data, left))
                    break
                buf.write(data)
                buf_len += n
                #assert buf_len == buf.tell()
            return buf.getvalue()

    def readlines(self, sizehint=0):
        total = 0
        list = []
        while True:
            line = self.readline()
            if not line:
                break
            list.append(line)
            total += len(line)
            if sizehint and total >= sizehint:
                break
        return list

    # Iterator protocols

    def __iter__(self):
        return self

    def next(self):
        line = self.readline()
        if not line:
            raise StopIteration
        return line

########NEW FILE########
__FILENAME__ = struct
"""
Functions to convert between Python values and C structs.
Python strings are used to hold the data representing the C struct
and also as format strings to describe the layout of data in the C struct.

The optional first format char indicates byte order, size and alignment:
 @: native order, size & alignment (default)
 =: native order, std. size & alignment
 <: little-endian, std. size & alignment
 >: big-endian, std. size & alignment
 !: same as >

The remaining chars indicate types of args and must match exactly;
these can be preceded by a decimal repeat count:
 x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;
 h:short; H:unsigned short; i:int; I:unsigned int;
 l:long; L:unsigned long; f:float; d:double.
Special cases (preceding decimal count indicates length):
 s:string (array of char); p: pascal string (with count byte).
Special case (only available in native format):
 P:an integer type that is wide enough to hold a pointer.
Special case (not in native mode unless 'long long' in platform C):
 q:long long; Q:unsigned long long
Whitespace between formats is ignored.

The variable struct.error is an exception raised on errors.
"""
__version__ = '0.1'

from _struct import Struct, error

_MAXCACHE = 100
_cache = {}

def _compile(fmt):
    # Internal: compile struct pattern
    if len(_cache) >= _MAXCACHE:
        _cache.clear()
    s = Struct(fmt)
    _cache[fmt] = s
    return s

def calcsize(fmt):
    """
    Return size of C struct described by format string fmt.
    See struct.__doc__ for more on format strings.
    """
    try:
        o = _cache[fmt]
    except KeyError:
        o = _compile(fmt)
    return o.size

def pack(fmt, *args):
    """
    Return string containing values v1, v2, ... packed according to fmt.
    See struct.__doc__ for more on format strings.
    """
    try:
        o = _cache[fmt]
    except KeyError:
        o = _compile(fmt)
    return o.pack(*args)

def pack_into(fmt, buf, offset, *args):
    """
    Pack the values v1, v2, ... according to fmt, write
    the packed bytes into the writable buffer buf starting at offset.
    See struct.__doc__ for more on format strings.
    """
    try:
        o = _cache[fmt]
    except KeyError:
        o = _compile(fmt)
    return o.pack_into(buf, offset, *args)

def unpack(fmt, s):
    """
    Unpack the string, containing packed C structure data, according
    to fmt.  Requires len(string)==calcsize(fmt).
    See struct.__doc__ for more on format strings.
    """
    try:
        o = _cache[fmt]
    except KeyError:
        o = _compile(fmt)
    return o.unpack(s)

def unpack_from(fmt, buf, offset=0):
    """
    Unpack the buffer, containing packed C structure data, according to
    fmt starting at offset. Requires len(buffer[offset:]) >= calcsize(fmt).
    See struct.__doc__ for more on format strings.
    """
    try:
        o = _cache[fmt]
    except KeyError:
        o = _compile(fmt)
    return o.unpack_from(buf, offset)

########NEW FILE########
__FILENAME__ = FireOne
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/FireOne/FireOne.py
import Live
import MidiRemoteScript
NOTE_OFF_STATUS = 128
NOTE_ON_STATUS = 144
CC_STATUS = 176
NUM_NOTES = 128
NUM_CC_NO = 128
NUM_CHANNELS = 16
JOG_DIAL_CC = 60
RWD_NOTE = 91
FFWD_NOTE = 92
STOP_NOTE = 93
PLAY_NOTE = 94
REC_NOTE = 95
SHIFT_NOTE = 70
FIRE_ONE_TRANSPORT = [RWD_NOTE,
 FFWD_NOTE,
 STOP_NOTE,
 PLAY_NOTE,
 REC_NOTE]
FIRE_ONE_F_KEYS = range(54, 64)
FIRE_ONE_CHANNEL = 0

class FireOne:
    """ Small script for the Tascam FireOne mapping transport, jog dial, and shift """

    def __init__(self, c_instance):
        self.__c_instance = c_instance
        self.__shift_pressed = False
        self.__rwd_pressed = False
        self.__ffwd_pressed = False
        self.__jog_dial_map_mode = Live.MidiMap.MapMode.absolute
        self.__spooling_counter = 0
        self.song().add_is_playing_listener(self.__playing_status_changed)
        self.song().add_record_mode_listener(self.__recording_status_changed)
        self.song().add_visible_tracks_listener(self.__tracks_changed)
        self.__playing_status_changed()
        self.__recording_status_changed()

    def application(self):
        """returns a reference to the application that we are running in
        """
        return Live.Application.get_application()

    def song(self):
        """returns a reference to the Live song instance that we do control
        """
        return self.__c_instance.song()

    def disconnect(self):
        """Live -> Script
        Called right before we get disconnected from Live.
        """
        self.send_midi((NOTE_OFF_STATUS + FIRE_ONE_CHANNEL, PLAY_NOTE, 0))
        self.send_midi((NOTE_OFF_STATUS + FIRE_ONE_CHANNEL, REC_NOTE, 0))
        self.song().remove_is_playing_listener(self.__playing_status_changed)
        self.song().remove_record_mode_listener(self.__recording_status_changed)
        self.song().remove_visible_tracks_listener(self.__tracks_changed)

    def connect_script_instances(self, instanciated_scripts):
        """Called by the Application as soon as all scripts are initialized.
        You can connect yourself to other running scripts here, as we do it
        connect the extension modules (MackieControlXTs).
        """
        pass

    def suggest_input_port(self):
        """Live -> Script
        Live can ask the script for an input port name to find a suitable one.
        """
        return str('FireOne Control')

    def suggest_output_port(self):
        """Live -> Script
        Live can ask the script for an output port name to find a suitable one.
        """
        return str('FireOne Control')

    def suggest_map_mode(self, cc_no, channel):
        """Live -> Script
        Live can ask the script for a suitable mapping mode for a given CC.
        """
        suggested_map_mode = Live.MidiMap.MapMode.absolute
        if cc_no == JOG_DIAL_CC:
            suggested_map_mode = self.__jog_dial_map_mode
        return suggested_map_mode

    def can_lock_to_devices(self):
        return False

    def request_rebuild_midi_map(self):
        """Script -> Live
        When the internal MIDI controller has changed in a way that you need to rebuild
        the MIDI mappings, request a rebuild by calling this function
        This is processed as a request, to be sure that its not too often called, because
        its time-critical.
        """
        self.__c_instance.request_rebuild_midi_map()

    def send_midi(self, midi_event_bytes):
        """Script -> Live
        Use this function to send MIDI events through Live to the _real_ MIDI devices
        that this script is assigned to.
        """
        self.__c_instance.send_midi(midi_event_bytes)

    def refresh_state(self):
        """Live -> Script
        Send out MIDI to completely update the attached MIDI controller.
        Will be called when requested by the user, after for example having reconnected
        the MIDI cables...
        """
        pass

    def build_midi_map(self, midi_map_handle):
        """Live -> Script
        Build DeviceParameter Mappings, that are processed in Audio time, or
        forward MIDI messages explicitly to our receive_midi_functions.
        Which means that when you are not forwarding MIDI, nor mapping parameters, you will
        never get any MIDI messages at all.
        """
        script_handle = self.__c_instance.handle()
        Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, FIRE_ONE_CHANNEL, JOG_DIAL_CC)
        for note in FIRE_ONE_TRANSPORT:
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, FIRE_ONE_CHANNEL, note)

        Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, FIRE_ONE_CHANNEL, SHIFT_NOTE)
        for index in range(len(self.song().visible_tracks)):
            if len(FIRE_ONE_F_KEYS) > index:
                Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, FIRE_ONE_CHANNEL, FIRE_ONE_F_KEYS[index])
            else:
                break

    def update_display(self):
        """Live -> Script
        Aka on_timer. Called every 100 ms and should be used to update display relevant
        parts of the controller
        """
        if self.__ffwd_pressed:
            self.__spooling_counter += 1
            if self.__spooling_counter % 2 == 0:
                self.song().jump_by(self.song().signature_denominator)
        elif self.__rwd_pressed:
            self.__spooling_counter += 1
            if self.__spooling_counter % 2 == 0:
                self.song().jump_by(-1 * self.song().signature_denominator)

    def receive_midi(self, midi_bytes):
        """Live -> Script
        MIDI messages are only received through this function, when explicitly
        forwarded in 'build_midi_map'.
        """
        cc_or_note = midi_bytes[1]
        if midi_bytes[0] & 240 == CC_STATUS:
            if cc_or_note is JOG_DIAL_CC:
                self.__jog_dial_message(cc_or_note, midi_bytes[2])
        elif midi_bytes[0] & 240 in (NOTE_ON_STATUS, NOTE_OFF_STATUS):
            value = midi_bytes[2]
            if midi_bytes[0] & 240 == NOTE_OFF_STATUS:
                value = 0
            if cc_or_note is SHIFT_NOTE:
                self.__shift_pressed = value != 0
            elif cc_or_note in FIRE_ONE_TRANSPORT:
                self.__transport_message(cc_or_note, value)
            elif cc_or_note in FIRE_ONE_F_KEYS:
                self.__f_key_message(cc_or_note, value)

    def __playing_status_changed(self):
        """ Update the LED accordingly """
        status = NOTE_OFF_STATUS
        note = PLAY_NOTE
        value = 0
        if self.song().is_playing:
            status = NOTE_ON_STATUS
            value = 127
        status += FIRE_ONE_CHANNEL
        self.send_midi((status, note, value))

    def __recording_status_changed(self):
        """ Update the LED accordingly """
        status = NOTE_OFF_STATUS
        note = REC_NOTE
        value = 0
        if self.song().record_mode:
            status = NOTE_ON_STATUS
            value = 127
        status += FIRE_ONE_CHANNEL
        self.send_midi((status, note, value))

    def __tracks_changed(self):
        self.request_rebuild_midi_map()

    def __transport_message(self, note, value):
        """ One of the transport buttons was pressed or release """
        if not note in FIRE_ONE_TRANSPORT:
            raise AssertionError
            if note is PLAY_NOTE and value != 0:
                self.__shift_pressed and self.song().continue_playing()
            else:
                self.song().is_playing = True
        elif note is STOP_NOTE and value != 0:
            self.song().is_playing = False
        elif note is REC_NOTE and value != 0:
            self.song().record_mode = not self.song().record_mode
        elif note is FFWD_NOTE:
            if value != 0 and not self.__rwd_pressed:
                if self.__shift_pressed:
                    self.song().jump_by(1)
                else:
                    self.song().jump_by(self.song().signature_denominator)
                    self.__ffwd_pressed = True
                    self.__spooling_counter = 0
            elif value == 0:
                self.__ffwd_pressed = False
        elif note is RWD_NOTE:
            if value != 0 and not self.__ffwd_pressed:
                if self.__shift_pressed:
                    self.song().jump_by(-1)
                else:
                    self.song().jump_by(-1 * self.song().signature_denominator)
                    self.__rwd_pressed = True
                    self.__spooling_counter = 0
            elif value == 0:
                self.__rwd_pressed = False

    def __jog_dial_message(self, cc_no, cc_value):
        """ Jog Dial: the function is based on the shift status and the active view """
        raise cc_value in range(128) or AssertionError
        moved_forward = cc_value in range(1, 64)
        if not self.__shift_pressed:
            if self.application().view.is_view_visible('Session'):
                index = list(self.song().scenes).index(self.song().view.selected_scene)
                if moved_forward:
                    if index < len(self.song().scenes) - 1:
                        index = index + 1
                elif index > 0:
                    index = index - 1
                self.song().view.selected_scene = self.song().scenes[index]
            else:
                value = cc_value
                if not moved_forward:
                    value -= 64
                    value *= -1
                self.song().jump_by(value)
        elif self.application().view.is_view_visible('Session'):
            tracks = self.song().visible_tracks
            index = list(tracks).index(self.song().view.selected_track)
            if moved_forward:
                if index < len(tracks) - 1:
                    index = index + 1
            elif index > 0:
                index = index - 1
            self.song().view.selected_track = tracks[index]
        else:
            value = cc_value
            if not moved_forward:
                value -= 64
                value *= -0.1
            self.song().tempo = self.song().tempo + 0.1 * value

    def __f_key_message(self, f_key, value):
        index = list(FIRE_ONE_F_KEYS).index(f_key)
        tracks = self.song().visible_tracks
        raise index >= 0 or AssertionError
        raise len(tracks) > index or AssertionError
        track = tracks[index]
        if not track != None:
            raise AssertionError
            if value > 0:
                if self.__shift_pressed:
                    track.arm = track.can_be_armed and not track.arm
            else:
                track.mute = not track.mute
########NEW FILE########
__FILENAME__ = KeyFadr
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/KeyFadr/KeyFadr.py
from KeyPad import KeyPad

class KeyFadr(KeyPad):
    """
    Reloop KeyFadr controller script.
    """
    _encoder_range = range(80, 72, -1)
    _product_model_id = 102

    def __init__(self, *a, **k):
        super(KeyFadr, self).__init__(*a, **k)
########NEW FILE########
__FILENAME__ = CombinedButtonsElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/KeyPad/CombinedButtonsElement.py
from __future__ import with_statement
from _Framework.ButtonMatrixElement import ButtonMatrixElement
from _Framework.ButtonElement import OFF_VALUE
from _Framework.Util import const, BooleanContext

class CombinedButtonsElement(ButtonMatrixElement):

    def __init__(self, buttons = None, *a, **k):
        super(CombinedButtonsElement, self).__init__(rows=[buttons], *a, **k)
        self._is_pressed = BooleanContext(False)

    def is_momentary(self):
        return True

    def is_pressed(self):
        return any(map(lambda b: b[0].is_pressed(), self.iterbuttons())) or bool(self._is_pressed)

    def on_nested_control_element_value(self, value, sender):
        with self._is_pressed():
            self.notify_value(value)
        if value != OFF_VALUE and not getattr(sender, 'is_momentary', const(False))():
            self.notify_value(OFF_VALUE)

    def send_value(self, value):
        for button, _ in self.iterbuttons():
            button.send_value(value)

    def set_light(self, value):
        for button, _ in self.iterbuttons():
            button.set_light(value)
########NEW FILE########
__FILENAME__ = CuePointControlComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/KeyPad/CuePointControlComponent.py
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.SubjectSlot import subject_slot

class CuePointControlComponent(ControlSurfaceComponent):
    _toggle_cue_button = None
    _prev_cue_button = None
    _next_cue_button = None

    def __init__(self, *a, **k):
        super(CuePointControlComponent, self).__init__(*a, **k)
        self._on_can_jump_to_prev_cue_changed.subject = self.song()
        self._on_can_jump_to_next_cue_changed.subject = self.song()

    def update(self):
        pass

    def set_toggle_cue_button(self, button):
        self._toggle_cue_button = button
        self._on_toggle_cue.subject = button

    @subject_slot('value')
    def _on_toggle_cue(self, value):
        if value or not self._toggle_cue_button.is_momentary():
            self.song().set_or_delete_cue()

    def set_prev_cue_button(self, button):
        self._prev_cue_button = button
        self._on_jump_to_prev_cue.subject = button
        self._on_can_jump_to_prev_cue_changed()

    @subject_slot('can_jump_to_prev_cue')
    def _on_can_jump_to_prev_cue_changed(self):
        if self._prev_cue_button != None:
            self._prev_cue_button.set_light(self.song().can_jump_to_prev_cue)

    @subject_slot('value')
    def _on_jump_to_prev_cue(self, value):
        if value or not self._prev_cue_button.is_momentary():
            if self.song().can_jump_to_prev_cue:
                self.song().jump_to_prev_cue()

    def set_next_cue_button(self, button):
        self._next_cue_button = button
        self._on_jump_to_next_cue.subject = button
        self._on_can_jump_to_next_cue_changed()

    @subject_slot('can_jump_to_next_cue')
    def _on_can_jump_to_next_cue_changed(self):
        if self._next_cue_button != None:
            self._next_cue_button.set_light(self.song().can_jump_to_next_cue)

    @subject_slot('value')
    def _on_jump_to_next_cue(self, value):
        if value or not self._next_cue_button.is_momentary():
            if self.song().can_jump_to_next_cue:
                self.song().jump_to_next_cue()
########NEW FILE########
__FILENAME__ = KeyPad
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/KeyPad/KeyPad.py
from __future__ import with_statement
import Live
from _Framework.ControlSurface import ControlSurface
from _Framework.Layer import Layer
from _Framework.InputControlElement import MIDI_CC_TYPE
from _Framework.SliderElement import SliderElement
from _Framework.EncoderElement import EncoderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.ButtonMatrixElement import ButtonMatrixElement
from _Framework.MixerComponent import MixerComponent
from _Framework.TransportComponent import TransportComponent
from _Framework.SessionComponent import SessionComponent
from CuePointControlComponent import CuePointControlComponent
from CombinedButtonsElement import CombinedButtonsElement
from functools import partial
NUM_CHANNEL_STRIPS = 16
pads = [1,
 2,
 3,
 4,
 9,
 10,
 11,
 12,
 5,
 6,
 7,
 8,
 13,
 14,
 15,
 16]
PAD_TRANSLATIONS = tuple([ (n % 4,
 3 - n / 4,
 pads[n] + 35,
 4) for n in xrange(16) ])

def make_slider(channel, cc, name):
    element = SliderElement(MIDI_CC_TYPE, channel, cc)
    element.name = name
    return element


def make_encoder(channel, cc, name):
    map_mode = Live.MidiMap.MapMode.absolute
    return EncoderElement(MIDI_CC_TYPE, channel, cc, map_mode=map_mode, name=name)


def make_button(channel, cc, name, is_momentary = True):
    return ButtonElement(is_momentary, MIDI_CC_TYPE, channel, cc, name=name)


class KeyPad(ControlSurface):
    """
    Reloop KeyPad controller script.
    """
    _encoder_range = range(73, 81)
    _product_model_id = 101

    def __init__(self, c_instance):
        super(KeyPad, self).__init__(c_instance)
        with self.component_guard():
            self._create_controls()
            self._setup_mixer()
            self._setup_transport()
            self._setup_session()
            self._setup_cue_control()
            self.set_pad_translations(PAD_TRANSLATIONS)

    def _preset_message(self, send_byte):
        """ Sysex message for setting the preset to #2. """
        return (240,
         38,
         self._product_model_id,
         send_byte,
         17,
         2,
         247)

    def refresh_state(self):
        super(KeyPad, self).refresh_state()
        self.schedule_message(2, self._send_midi, self._preset_message(1))

    def handle_sysex(self, midi_bytes):
        if midi_bytes != self._preset_message(2):
            super(KeyPad, self).handle_sysex(midi_bytes)
        else:
            map(lambda x: x.set_enabled(True), (self._mixer,
             self._session,
             self._transport,
             self._cue_control))

    def _create_controls(self):

        def make_controls_range(maker, label, cc_range):
            ccs = [ (index + 1, cc) for index, cc in enumerate(cc_range) ]
            return [ maker(1, cc, label % index) for index, cc in ccs ] + [ maker(2, cc, label % (index + len(ccs))) for index, cc in ccs ]

        def make_controls(maker, label, cc_offset):
            return make_controls_range(maker, label, xrange(cc_offset, cc_offset + 8))

        make_non_momentary_button = partial(make_button, is_momentary=False)
        self._encoders = make_controls(make_encoder, 'Encoder_%d', 57)
        self._rotaries_a = make_controls(make_slider, 'Rotary_A%d', 89)
        self._rotaries_b = make_controls(make_slider, 'Rotary_B%d', 97)
        self._faders = make_controls(make_slider, 'Fader_%d', 0)
        self._mute_buttons = make_controls(make_non_momentary_button, 'Mute_%d_Button', 8)
        self._solo_buttons = make_controls(make_button, 'Solo_%d_Button', 24)
        self._arm_buttons = make_controls(make_button, 'Arm_%d_Button', 40)
        self._play_button = make_button(1, 105, 'Play_Button')
        self._stop_button = make_button(1, 106, 'Stop_Button')
        self._record_button = make_button(1, 107, 'Record_Button')
        self._encoder_pushes = make_controls_range(partial(make_button, is_momentary=False), 'Encoder_%d_Button', self._encoder_range)
        self._shifted_mute_buttons = make_controls(make_non_momentary_button, 'Shifted_Mute_%d_Button', 16)
        self._shifted_solo_buttons = make_controls(make_button, 'Shifted_Solo_%d_Button', 32)
        self._all_shifted_arm_buttons = make_controls(make_button, 'Shifted_Arm_%d_Button', 49)
        self._shifted_arm_buttons = [ CombinedButtonsElement(buttons=(self._all_shifted_arm_buttons[index], self._all_shifted_arm_buttons[index + 8])) for index in xrange(8) ]
        self._shifted_play_button = make_button(1, 108, 'Shifted_Play_Button')
        self._shifted_stop_button = make_button(1, 109, 'Shifted_Stop_Button')
        self._shifted_record_button = make_button(1, 110, 'Shifted_Record_Button')
        self._shifted_octave_down_button = make_button(1, 111, 'Shifted_Octave_Down_Button')
        self._shifted_octave_up_button = make_button(1, 112, 'Shifted_Octave_Up_Button')

    def _setup_mixer(self):
        self._mixer = MixerComponent(NUM_CHANNEL_STRIPS)
        self._mixer.name = 'Mixer'
        self._mixer.set_enabled(False)
        for index in xrange(NUM_CHANNEL_STRIPS):
            strip = self._mixer.channel_strip(index)
            strip.set_invert_mute_feedback(True)
            sends = ButtonMatrixElement(name='%d_Send_Controls' % (index + 1), rows=[(self._rotaries_a[index], self._rotaries_b[index])])
            strip.layer = Layer(volume_control=self._faders[index], pan_control=self._encoders[index], send_controls=sends, mute_button=self._mute_buttons[index], solo_button=self._solo_buttons[index], arm_button=self._arm_buttons[index], select_button=self._encoder_pushes[index])

    def _setup_transport(self):
        self._transport = TransportComponent(name='Transport')
        self._transport.set_enabled(False)
        self._transport.layer = Layer(play_button=self._play_button, stop_button=self._stop_button, record_button=self._record_button, overdub_button=self._shifted_record_button, loop_button=self._shifted_arm_buttons[3], tap_tempo_button=self._shifted_arm_buttons[4], metronome_button=self._shifted_arm_buttons[5], nudge_down_button=self._shifted_arm_buttons[6], nudge_up_button=self._shifted_arm_buttons[7])

    def _setup_session(self):
        self._session = SessionComponent(NUM_CHANNEL_STRIPS, name='Session_Control')
        self._session.set_enabled(False)
        stop_buttons = ButtonMatrixElement(name='Track_Stop_Buttons', rows=[self._shifted_solo_buttons])
        self._session.layer = Layer(stop_all_clips_button=self._shifted_stop_button, stop_track_clip_buttons=stop_buttons, select_prev_button=self._shifted_octave_down_button, select_next_button=self._shifted_octave_up_button)
        self._session.selected_scene().name = 'Selected_Scene_Control'
        self._session.selected_scene().layer = Layer(launch_button=self._shifted_play_button)
        for index in xrange(NUM_CHANNEL_STRIPS):
            slot = self._session.selected_scene().clip_slot(index)
            slot.layer = Layer(launch_button=self._shifted_mute_buttons[index])

    def _setup_cue_control(self):
        self._cue_control = CuePointControlComponent(name='Cue_Point_Control')
        self._cue_control.set_enabled(False)
        self._cue_control.layer = Layer(toggle_cue_button=self._shifted_arm_buttons[0], prev_cue_button=self._shifted_arm_buttons[1], next_cue_button=self._shifted_arm_buttons[2])
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Keystation_Pro_88/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
VOLUME_CONTROLS = ((GENERIC_SLI1, 0),
 (GENERIC_SLI2, 0),
 (GENERIC_SLI3, 0),
 (GENERIC_SLI4, 0),
 (GENERIC_SLI5, 0),
 (GENERIC_SLI6, 0),
 (GENERIC_SLI7, 0),
 (GENERIC_SLI8, 0))
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': GENERIC_PAD5,
 'PREVBANK': GENERIC_PAD1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
CONTROLLER_DESCRIPTIONS = {'INPUTPORT': 'Keystation Pro 88',
 'OUTPUTPORT': 'Keystation Pro 88',
 'CHANNEL': 0}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': 7}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Keystation_Pro_88/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = -1
GENERIC_PLAY = -1
GENERIC_REC = -1
GENERIC_LOOP = -1
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 10
GENERIC_ENC2 = 2
GENERIC_ENC3 = 12
GENERIC_ENC4 = 13
GENERIC_ENC5 = 75
GENERIC_ENC6 = 76
GENERIC_ENC7 = 92
GENERIC_ENC8 = 95
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 73
GENERIC_SLI2 = 72
GENERIC_SLI3 = 91
GENERIC_SLI4 = 93
GENERIC_SLI5 = 74
GENERIC_SLI6 = 71
GENERIC_SLI7 = 5
GENERIC_SLI8 = 84
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/KONTROL49/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = ((GENERIC_ENC1, 0),
 (GENERIC_ENC2, 1),
 (GENERIC_ENC3, 2),
 (GENERIC_ENC4, 3),
 (GENERIC_ENC5, 4),
 (GENERIC_ENC6, 5),
 (GENERIC_ENC7, 6),
 (GENERIC_ENC8, 7))
VOLUME_CONTROLS = ((GENERIC_SLI1, 0),
 (GENERIC_SLI2, 1),
 (GENERIC_SLI3, 2),
 (GENERIC_SLI4, 3),
 (GENERIC_SLI5, 4),
 (GENERIC_SLI6, 5),
 (GENERIC_SLI7, 6),
 (GENERIC_SLI8, 7))
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': GENERIC_PAD5,
 'PREVBANK': GENERIC_PAD1,
 'BANK1': 47,
 'BANK2': 46,
 'BANK3': 45,
 'BANK4': 44,
 'BANK5': 85,
 'BANK6': 86,
 'BANK7': 87,
 'BANK8': 88}
PAD_TRANSLATION = ((0, 0, 61, 9),
 (1, 0, 69, 9),
 (2, 0, 65, 9),
 (3, 0, 63, 9),
 (0, 1, 60, 9),
 (1, 1, 59, 9),
 (2, 1, 57, 9),
 (3, 1, 55, 9),
 (0, 2, 49, 9),
 (1, 2, 51, 9),
 (2, 2, 68, 9),
 (3, 2, 56, 9),
 (0, 3, 48, 9),
 (1, 3, 52, 9),
 (2, 3, 54, 9),
 (3, 3, 58, 9))
CONTROLLER_DESCRIPTIONS = {'INPUTPORT': 'KONTROL49 (PORT B)',
 'OUTPUTPORT': 'KONTROL49 (CTRL)',
 'CHANNEL': 7,
 'PAD_TRANSLATION': PAD_TRANSLATION}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': -1}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/KONTROL49/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = -1
GENERIC_PLAY = -1
GENERIC_REC = -1
GENERIC_LOOP = -1
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 10
GENERIC_ENC2 = 10
GENERIC_ENC3 = 10
GENERIC_ENC4 = 10
GENERIC_ENC5 = 10
GENERIC_ENC6 = 10
GENERIC_ENC7 = 10
GENERIC_ENC8 = 10
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 7
GENERIC_SLI2 = 7
GENERIC_SLI3 = 7
GENERIC_SLI4 = 7
GENERIC_SLI5 = 7
GENERIC_SLI6 = 7
GENERIC_SLI7 = 7
GENERIC_SLI8 = 7
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = ControlHandler
#Embedded file name: C:\ProgramData\Ableton\Live 8\Resources\MIDI Remote Scripts\Maschine_Mk1\ControlHandler.py
import Live
import time
from _Generic.Devices import *
from _Framework.ButtonElement import *
from _Framework.CompoundComponent import *
from MIDI_Map import *
from SceneElement import SceneElement
N_PARM_RANGE = 127

class ControlHandler:
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, surface, matrix):
        self.surface = surface
        self.matrix = matrix
        self.mode = CONTROL_LEVEL
        self.sel_track_parm_index = 0
        self.track = None
        self.selected_sends_index = 0
        self.selected_device = None
        self.selected_bank = 0
        self.selected_device_parm_index = 0
        self.parm = None
        self.parm_is_quant = False
        self.parm_raster_value = 0
        self.parm_range = 0

    def get_mode_color(self, value, mode):
        if value == 0:
            bright = 8
        else:
            bright = 127
        if mode == CONTROL_LEVEL:
            return [27, 127, bright]
        elif mode == CONTROL_PAN:
            return [4, 127, bright]
        elif mode == CONTROL_SEND:
            return [10, 127, bright]
        elif mode == CONTROL_DEVICE:
            return [85, 127, bright]

    def nr_of_parms_in_bank(self):
        if self.selected_device == None:
            return 0
        nr_of_parms = len(self.selected_device.parameters)
        bip = nr_of_parms - 8 * self.selected_bank
        if bip < 8:
            return bip
        return 8

    def inc_bank_nr(self):
        if self.selected_device == None or self.selected_bank + 1 >= self.nr_of_banks():
            return False
        self.selected_bank += 1
        self.surface.show_message('Bank ' + str(self.selected_bank + 1) + ' : ' + str(self.selected_device.name))
        self.reassign_device_parm()
        parminfo = ''
        if self.parm != None:
            parminfo = str(self.parm.name)
        self.surface.show_message(str(self.selected_device.name) + 'Bank ' + str(self.selected_bank + 1) + ' : ' + parminfo)
        return True

    def dec_bank_nr(self):
        if self.selected_device == None or self.selected_bank == 0:
            return False
        self.selected_bank -= 1
        self.reassign_device_parm()
        parminfo = ''
        if self.parm != None:
            parminfo = str(self.parm.name)
        self.surface.show_message(str(self.selected_device.name) + 'Bank ' + str(self.selected_bank + 1) + ' : ' + parminfo)
        return True

    def nr_of_banks(self):
        if self.selected_device == None:
            return 0
        parms = len(self.selected_device.parameters)
        if parms == 0:
            return 0
        return parms / 8 + 1

    def index_parm_id(self, index):
        if index > 11:
            return index - 12
        else:
            return index - 4
        return 0

    def index_mode_id(self, index):
        if index > 4 and index < 8:
            return index - 4
        return 0

    def set_device(self, device):
        self.selected_device = device
        self.selected_bank = 0
        self.reassign_device_parm()

    def set_track(self, index):
        self.track = self.surface._mixer._channel_strips[index]._track

    def reassign_mix_parm(self):
        self.assign_mix_parm(self.track, self.sel_track_parm_index)

    def message_current_parm(self):
        if self.track == None:
            return
        message = 'Control Track : ' + str(self.track.name) + ': '
        if self.mode == CONTROL_LEVEL:
            self.surface.show_message(message + 'Volume')
        elif self.mode == CONTROL_PAN:
            self.surface.show_message(message + 'Pan')
        elif self.mode == CONTROL_SEND:
            self.surface.show_message(message + 'Send ' + SENDS[self.selected_sends_index])
        elif self.mode == CONTROL_DEVICE:
            return 'Device'

    def assign_mix_parm(self, track, index):
        prev = self.parm
        if track == None:
            self.parm = None
            return prev != self.parm
        self.track = track
        self.parm_is_quant = False
        if self.mode == CONTROL_LEVEL:
            self.parm = track.mixer_device.volume
        elif self.mode == CONTROL_PAN:
            self.parm = track.mixer_device.panning
        elif self.mode == CONTROL_SEND:
            nr_of_ret_tracks = len(track.mixer_device.sends)
            if self.selected_sends_index < nr_of_ret_tracks and self.selected_sends_index != -1:
                self.parm = track.mixer_device.sends[self.selected_sends_index]
        self.set_knob_int_value(self.parm)
        self.sel_track_parm_index = index
        return prev != self.parm

    def reassign_device_parm(self):
        self.assign_device_parm(self.selected_device_parm_index, False)

    def assign_device_parm(self, index, showmessage = True):
        prev = self.parm
        if self.mode != CONTROL_DEVICE or self.selected_device == None:
            self.parm = None
            return prev != self.parm
        parms = self.selected_device.parameters
        self.selected_device_parm_index = min(index, self.nr_of_parms_in_bank() - 1)
        parm = parms[self.selected_bank * 8 + self.selected_device_parm_index]
        if parm.is_quantized:
            self.parm_is_quant = True
        else:
            self.parm_is_quant = False
            self.set_knob_int_value(parm)
        if showmessage:
            self.surface.show_message('Device : ' + str(self.selected_device.name) + ' : ' + str(parm.name))
        self.parm = parm
        self.parm_range = parm.max - parm.min
        return prev != self.parm

    def set_knob_int_value(self, parm):
        parm_range = parm.max - parm.min
        self.parm_raster_value = int((parm.value - parm.min) / parm_range * N_PARM_RANGE + 0.1)

    def is_quantized(self, parm):
        self.set_knob_int_value(parm)
        return False

    def mod_value(self, delta, shift):
        if self.parm == None:
            return
        if self.mode == CONTROL_DEVICE:
            if self.parm_is_quant:
                self.parm.value = self.change_parm(self.parm, delta)
                if shift and self.parm_range > 30:
                    self.repeat(self.parm, delta)
            else:
                new_value = self.change_parm(self.parm, delta)
                self.parm.value = new_value
                if not self.is_equal(self.parm.value, new_value):
                    self.parm_is_quant = True
                if not self.parm_is_quant and shift:
                    self.repeat(self.parm, delta)
            self.surface.show_message(' ' + str(self.selected_device.name) + ' : ' + str(self.parm.name) + ' : ' + str(self.parm))
        else:
            self.parm.value = self.change_parm(self.parm, delta)
            if shift:
                self.repeat(self.parm, delta)

    def is_equal(self, val1, val2):
        if val1 == val2:
            return True
        if abs(val1 - val2) < 0.005:
            return True
        return False

    def repeat(self, parm, delta):
        count = 0
        while count < SHIFT_INC - 1:
            parm.value = self.change_parm(parm, delta)
            count += 1

    def change_parm(self, parm, delta):
        if self.parm_is_quant:
            parm_range = parm.max - parm.min + 1
            new_val = min(parm.max, max(parm.min, parm.value + delta))
            return float(new_val)
        else:
            parm_range = parm.max - parm.min
            self.parm_raster_value = min(N_PARM_RANGE, max(0, self.parm_raster_value + delta))
            return float(self.parm_raster_value) / float(N_PARM_RANGE) * parm_range + parm.min

    def disconnect(self):
        self.surface = None
        self.matrix = None
        self.track = None
        self.selected_device = None
        self.parm = None
########NEW FILE########
__FILENAME__ = MainKnobControl
#Embedded file name: C:\ProgramData\Ableton\Live 8\Resources\MIDI Remote Scripts\Maschine_Mk1\MainKnobControl.py
import Live
import time
from MIDI_Map import *
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import *
from VarButtonElement import ColorButton
KN2_MODE_VOLUME = 1
KN2_MODE_CUE = 2
KN2_MODE_QUANT = 3
KN2_MODE_TEMPO_COARSE = 4
KN2_MODE_TEMPO_FINE = 5
KN2_MODE_CLIP_QUANT = 6
KN2_MODE_CLIPN_HOR = 7
KN2_MODE_CLIPN_VER = 8
KN2_MODE_XFADE = 9
KN2_MODE_GENERAL = 10
KN2_P_SCALES = 11
LEFT_DOWN = 1
RIGHT_DOWN = 2
PARM_RANGE = 127
QUANT_DESCR = (' No Rec Quantize', ' 1/4 Rec Quantize', ' 1/8 Rec Quantize', ' 1/8 Rec Triplet Quantize', '1/8 & 1/8 Triplet Quantize', ' 1/16 Rec Quantize', ' 1/16 Triplet Rec Quantize', ' 1/16 & 1/16 Triplet Rec Quantize', '1/32 Rec Quantize')
QUANT_CONST = (Live.Song.RecordingQuantization.rec_q_no_q,
 Live.Song.RecordingQuantization.rec_q_quarter,
 Live.Song.RecordingQuantization.rec_q_eight,
 Live.Song.RecordingQuantization.rec_q_eight_triplet,
 Live.Song.RecordingQuantization.rec_q_eight_eight_triplet,
 Live.Song.RecordingQuantization.rec_q_sixtenth,
 Live.Song.RecordingQuantization.rec_q_sixtenth_triplet,
 Live.Song.RecordingQuantization.rec_q_sixtenth_sixtenth_triplet,
 8)
CLIQ_DESCR = ('None', '8 Bars', '4 Bars', '2 Bars', '1 Bar', '1/2', '1/2T', '1/4', '1/4T', '1/8', '1/8T', '1/16', '1/16T', '1/32')
LR_CONTROL_CLIP = 0
LR_CONTROL_SEL = 1
LR_CONTROL_DEV = 2
LR_CONTROL_LOOP = 3
LR_MODE_HUES = (6, 14, 39, 90)
L_MODE_FUNCTION = ('Clip Horizontal', 'Track Selection', 'Track Selection', 'Loop Start')
R_MODE_FUNCTION = ('Clip Vertical', 'Scene Selection', 'Device Selection', 'Loop Length')
LOOP_KNOB_DIVISION = (4.0, 1.0, 0.5)
PAD_KNOB_OCTAVE = 1
PAD_KNOB_SCALE = 2
PAD_KNOB_BASEN = 4

class MainKnobControl:
    __module__ = __name__
    __doc__ = 'Mk2 Module for Controlling Parameters with Master Knob'

    def __init__(self, parent):
        self._parent = parent
        self.master_track = parent.song().master_track
        self.the_slider = SliderElement(MIDI_CC_TYPE, 1, 86)
        self.the_slider.add_value_listener(self._do_main_slider, True)
        self.volume_button = None
        self._set_volume_button(ButtonElement(True, MIDI_CC_TYPE, 1, 80))
        self.xfade_button = None
        self._set_xfade_button(ButtonElement(True, MIDI_CC_TYPE, 1, 99))
        self.swing_button = None
        self._set_swing_button(ButtonElement(True, MIDI_CC_TYPE, 1, 81))
        self.mode = KN2_MODE_VOLUME
        self.previous_mode = -1
        self.tempo_button = None
        self._set_tempo_button(ButtonElement(True, MIDI_CC_TYPE, 1, 82))
        self.push_button = None
        self._set_push_button(ButtonElement(True, MIDI_CC_TYPE, 1, 87))
        self.clipn_v_button = None
        self.clipn_h_button = None
        self._set_clipn_h_button(ButtonElement(True, MIDI_CC_TYPE, 1, 90))
        self._set_clipn_v_button(ButtonElement(True, MIDI_CC_TYPE, 1, 91))
        self.toggle_buttons = [self.volume_button,
         self.xfade_button,
         self.swing_button,
         self.tempo_button,
         self.clipn_h_button,
         self.clipn_v_button]
        self.shift_button = None
        self._set_shift_button(ButtonElement(True, MIDI_CC_TYPE, 1, 85))
        self.shift_on = False
        self.scroll_mod_left_button = None
        self.scroll_mod_right_button = None
        self._set_scroll_mod_left_button(ButtonElement(True, MIDI_CC_TYPE, 0, 105))
        self._set_scroll_mod_right_button(ButtonElement(True, MIDI_CC_TYPE, 0, 106))
        self._prev_mode = KN2_MODE_VOLUME
        self.lrmode = LR_CONTROL_CLIP
        self.loop_div_index = 0
        self.loop_incdex = 4.0
        self.arrow_mode_button = ColorButton(True, MIDI_CC_TYPE, 30)
        self.arrow_mode_button.add_value_listener(self.toggle_arrow_mode)
        self.arrow_mode_button.send_color(LR_MODE_HUES[self.lrmode])
        self.arrow_mode_button.send_value(1)
        self.navflags = 0
        self.octave_mod_button = ButtonElement(True, MIDI_CC_TYPE, 1, 70)
        self.octave_mod_button.add_value_listener(self._action_octave)
        self.scale_mod_button = ButtonElement(True, MIDI_CC_TYPE, 1, 71)
        self.scale_mod_button.add_value_listener(self._action_scale)
        self.basenote_mod_button = ButtonElement(True, MIDI_CC_TYPE, 1, 72)
        self.basenote_mod_button.add_value_listener(self._action_base_note)
        self.pad_to_mainknob_mode = 0
        self.octave_dwn_button = ButtonElement(True, MIDI_CC_TYPE, 3, 120)
        self.octave_upp_button = ButtonElement(True, MIDI_CC_TYPE, 3, 121)
        self.scale_dwn_button = ButtonElement(True, MIDI_CC_TYPE, 3, 118)
        self.scale_upp_button = ButtonElement(True, MIDI_CC_TYPE, 3, 119)
        self.basent_dwn_button = ButtonElement(True, MIDI_CC_TYPE, 3, 124)
        self.basent_upp_button = ButtonElement(True, MIDI_CC_TYPE, 3, 125)
        self.octave_dwn_button.add_value_listener(self._action_oct_down)
        self.octave_upp_button.add_value_listener(self._action_oct_up)
        self.scale_dwn_button.add_value_listener(self._action_scale_down)
        self.scale_upp_button.add_value_listener(self._action_scale_up)
        self.basent_dwn_button.add_value_listener(self._action_base_down)
        self.basent_upp_button.add_value_listener(self._action_base_up)
        self._measure_left_click = 0
        self._measure_right_click = 0
        self.mode_assign_map = {KN2_MODE_VOLUME: (self.chg_volume,
                           0,
                           'Master Knob controls MASTER Volume',
                           KN2_MODE_CUE),
         KN2_MODE_CUE: (self.chg_cue,
                        0,
                        'Master Knob controls Cue Level',
                        KN2_MODE_VOLUME),
         KN2_MODE_TEMPO_COARSE: (self.chg_tempo,
                                 3,
                                 'Master Knob controls TEMPO Coarse',
                                 KN2_MODE_TEMPO_FINE),
         KN2_MODE_TEMPO_FINE: (self.chg_tempo_fine,
                               3,
                               'Master Knob controls TEMPO Fine',
                               KN2_MODE_TEMPO_COARSE),
         KN2_MODE_XFADE: (self.chg_xfade,
                          1,
                          'Master Knob controls Crossfader',
                          -1),
         KN2_MODE_QUANT: (self.chg_quant,
                          2,
                          'Master Knob controls Recording Quantize',
                          KN2_MODE_CLIP_QUANT),
         KN2_MODE_CLIP_QUANT: (self.chg_clip_q,
                               2,
                               'Master Knob controls Clip Start Quantize',
                               KN2_MODE_QUANT),
         KN2_MODE_CLIPN_HOR: (self.nav_c_hor,
                              4,
                              'Master Knob Clip View horizontally',
                              -1),
         KN2_MODE_CLIPN_VER: (self.nav_c_ver,
                              5,
                              'Master Knob Clip View vertically',
                              -1),
         KN2_MODE_GENERAL: (self.chg_general,
                            -1,
                            None,
                            -1),
         KN2_P_SCALES: (self.modify_pad_scaling,
                        -1,
                        None,
                        -1)}

    def start_up(self):
        self._set_mode(KN2_MODE_VOLUME)
        self.arrow_mode_button.send_value(1)

    def toggle_arrow_mode(self, value):
        if value > 0:
            self.lrmode = (self.lrmode + 1) % 4
            self.arrow_mode_button.send_hue(LR_MODE_HUES[self.lrmode])
            self._parent.show_message('Left/Right Buttons Control:    ' + L_MODE_FUNCTION[self.lrmode] + ' / ' + R_MODE_FUNCTION[self.lrmode])

    def switch_to_matrix_mode(self):
        if self.mode != KN2_MODE_GENERAL:
            self.previous_mode = self.mode
            self._set_mode(KN2_MODE_GENERAL)

    def exit_matrix_mode(self):
        if self.mode == KN2_MODE_GENERAL:
            self._set_mode(self.previous_mode)
            self.previous_mode = -1

    def update_shift(self):
        if self.shift_on:
            self.shift_button.send_value(1)
        else:
            self.shift_button.send_value(0)

    def _set_mode(self, mode):
        if not mode in range(11):
            raise AssertionError
            self.update_shift()
            if mode == self.mode:
                return
            self._prev_mode = mode
            self.mode = mode
            self.switch_radio_buttons(self.mode_assign_map[self.mode][1])
            message = self.mode_assign_map[self.mode][2]
            message != None and self._parent.show_message(message)

    def switch_radio_buttons(self, which):
        for index in range(len(self.toggle_buttons)):
            if index == which:
                self.toggle_buttons[index].send_value(1)
            else:
                self.toggle_buttons[index].send_value(0)

    def update(self):
        self.switch_radio_buttons(self.mode_assign_map[self.mode][1])
        self.arrow_mode_button.send_color(LR_MODE_HUES[self.lrmode])
        self.arrow_mode_button.send_value(1)

    def _do_main_slider(self, value, encoder):
        if not value in range(128):
            raise AssertionError
            if not isinstance(encoder, EncoderElement):
                raise AssertionError
                if value == 1:
                    delta = 1
                else:
                    delta = -1
                if self.pad_to_mainknob_mode != 0:
                    self.mode_assign_map[KN2_P_SCALES][0](delta)
                elif self.navflags == 0:
                    self.mode_assign_map[self.mode][0](delta)
                if self.lrmode == LR_CONTROL_CLIP:
                    self.navflags & LEFT_DOWN != 0 and self.nav_c_hor(delta)
                self.navflags & RIGHT_DOWN != 0 and self.nav_c_ver(delta)
        elif self.lrmode == LR_CONTROL_SEL:
            if self.navflags & LEFT_DOWN != 0:
                self.nav_track(delta)
            if self.navflags & RIGHT_DOWN != 0:
                self._parent.scroll_scene(delta)
        elif self.lrmode == LR_CONTROL_DEV:
            if self.navflags & LEFT_DOWN != 0:
                self.nav_track(delta)
            if self.navflags & RIGHT_DOWN != 0:
                self._parent.scroll_device(delta)
        elif self.lrmode == LR_CONTROL_LOOP:
            if self.navflags & LEFT_DOWN != 0:
                self.adjust_loop_start(delta)
            if self.navflags & RIGHT_DOWN != 0:
                self.adjust_loop_length(delta)

    def modify_pad_scaling(self, delta):
        if self.pad_to_mainknob_mode & PAD_KNOB_OCTAVE != 0:
            self._parent.inc_octave(delta)
        if self.pad_to_mainknob_mode & PAD_KNOB_SCALE != 0:
            self._parent.inc_scale(delta)
        if self.pad_to_mainknob_mode & PAD_KNOB_BASEN != 0:
            self._parent.inc_base_note(delta)

    def adjust_loop_start(self, delta):
        loopval = self._parent.song().loop_start
        loopval += self.loop_incdex * delta
        if loopval < 0:
            loopval = 0
        elif loopval > 999:
            loopval = 999
        self._parent.song().loop_start = loopval

    def adjust_loop_length(self, delta):
        loopval = self._parent.song().loop_length
        loopval += self.loop_incdex * delta
        if loopval < self.loop_incdex:
            loopval = self.loop_incdex
        elif loopval > 999:
            loopval = 999
        self._parent.song().loop_length = loopval

    def chg_general(self, delta):
        self._parent._scenematrix.control_handler.mod_value(delta, self.shift_on)

    def nav_track(self, direction):
        if direction == 1:
            self._parent._a_trk_right(1)
        else:
            self._parent._a_trk_left(1)

    def nav_c_hor(self, direction):
        self._parent.move_view_horizontal(direction)

    def nav_c_ver(self, direction):
        if direction == 1:
            self._parent._session.bank_up()
        else:
            self._parent._session.bank_down()

    def chg_volume(self, diff):
        if self.shift_on:
            self.repeat(self.master_track.mixer_device.volume, diff)
        else:
            self.master_track.mixer_device.volume.value = self.calc_new_parm(self.master_track.mixer_device.volume, diff)

    def chg_xfade(self, diff):
        if self.shift_on:
            self.repeat(self.master_track.mixer_device.crossfader, diff)
        else:
            self.master_track.mixer_device.crossfader.value = self.calc_new_parm(self.master_track.mixer_device.crossfader, diff)

    def chg_cue(self, diff):
        if self.shift_on:
            self.repeat(self.master_track.mixer_device.cue_volume, diff)
        else:
            self.master_track.mixer_device.cue_volume.value = self.calc_new_parm(self.master_track.mixer_device.cue_volume, diff)

    def repeat(self, parm, delta):
        count = 0
        while count < SHIFT_INC:
            parm.value = self.calc_new_parm(parm, delta)
            count += 1

    def calc_new_parm(self, parm, delta):
        parm_range = parm.max - parm.min
        int_val = int((parm.value - parm.min) / parm_range * PARM_RANGE + 0.1)
        inc_val = min(PARM_RANGE, max(0, int_val + delta))
        return float(inc_val) / float(PARM_RANGE) * parm_range + parm.min

    def chg_quant(self, diff):
        rec_quant = self._parent.song().midi_recording_quantization
        index = self.get_quant_index(rec_quant)
        new_index = index + diff
        if new_index >= 0 and new_index < len(QUANT_CONST):
            self._parent.song().midi_recording_quantization = QUANT_CONST[new_index]
            self._parent.show_message(QUANT_DESCR[new_index])

    def chg_clip_q(self, diff):
        quant = self._parent.song().clip_trigger_quantization
        self._parent.song().clip_trigger_quantization = max(0, min(13, quant + diff))
        self._parent.show_message('Clip Quantize ' + CLIQ_DESCR[self._parent.song().clip_trigger_quantization])

    def chg_tempo_fine(self, diff):
        if diff < 0:
            amount = -0.01
        else:
            amount = 0.01
        self.chg_tempo(amount)

    def chg_tempo(self, diff):
        self._parent.song().tempo = max(20, min(999, self._parent.song().tempo + diff))

    def get_quant_index(self, const):
        for index in range(len(QUANT_CONST)):
            if const == QUANT_CONST[index]:
                return index

        return -1

    def _action_octave(self, value):
        if value != 0:
            self.pad_to_mainknob_mode |= PAD_KNOB_OCTAVE
        else:
            self.pad_to_mainknob_mode &= ~PAD_KNOB_OCTAVE

    def _action_scale(self, value):
        if value != 0:
            self.pad_to_mainknob_mode |= PAD_KNOB_SCALE
        else:
            self.pad_to_mainknob_mode &= ~PAD_KNOB_SCALE

    def _action_base_note(self, value):
        if value != 0:
            self.pad_to_mainknob_mode |= PAD_KNOB_BASEN
        else:
            self.pad_to_mainknob_mode &= ~PAD_KNOB_BASEN

    def _set_volume_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.volume_button != None:
                self.volume_button.remove_value_listener(self._action_volume)
            self.volume_button = button
            self.volume_button != None and self.volume_button.add_value_listener(self._action_volume)

    def _action_volume(self, value):
        if not self.volume_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_VOLUME and self._set_mode(KN2_MODE_VOLUME)

    def _set_xfade_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.xfade_button != None:
                self.xfade_button.remove_value_listener(self._action_xfade)
            self.xfade_button = button
            self.xfade_button != None and self.xfade_button.add_value_listener(self._action_xfade)

    def _action_xfade(self, value):
        if not self.xfade_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_XFADE and self._set_mode(KN2_MODE_XFADE)

    def _set_swing_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.swing_button != None:
                self.swing_button.remove_value_listener(self._action_swing)
            self.swing_button = button
            self.swing_button != None and self.swing_button.add_value_listener(self._action_swing)

    def _action_swing(self, value):
        if not self.swing_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_QUANT and self._set_mode(KN2_MODE_QUANT)

    def _set_tempo_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.tempo_button != None:
                self.tempo_button.remove_value_listener(self._action_tempo)
            self.tempo_button = button
            self.tempo_button != None and self.tempo_button.add_value_listener(self._action_tempo)

    def _action_tempo(self, value):
        if not self.tempo_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_TEMPO_COARSE and self._set_mode(KN2_MODE_TEMPO_COARSE)

    def _set_clipn_h_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.clipn_h_button != None:
                self.clipn_h_button.remove_value_listener(self._action_clipnh)
            self.clipn_h_button = button
            self.clipn_h_button != None and self.clipn_h_button.add_value_listener(self._action_clipnh)

    def _action_clipnh(self, value):
        if not self.clipn_h_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_CLIPN_HOR and self._set_mode(KN2_MODE_CLIPN_HOR)

    def _set_clipn_v_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.clipn_v_button != None:
                self.clipn_v_button.remove_value_listener(self._action_clipnv)
            self.clipn_v_button = button
            self.clipn_v_button != None and self.clipn_v_button.add_value_listener(self._action_clipnv)

    def _action_clipnv(self, value):
        if not self.clipn_v_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_CLIPN_VER and self._set_mode(KN2_MODE_CLIPN_VER)

    def _set_shift_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.shift_button != None:
                self.shift_button.remove_value_listener(self._action_shift)
            self.shift_button = button
            self.shift_button != None and self.shift_button.add_value_listener(self._action_shift)

    def _action_shift(self, value):
        if not self.shift_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            self.shift_on = value != 0 and not self.shift_on
            self.update_shift()

    def _set_scroll_mod_left_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.scroll_mod_left_button != None:
                self.scroll_mod_left_button.remove_value_listener(self._action_scroll_left)
            self.scroll_mod_left_button = button
            self.scroll_mod_left_button != None and self.scroll_mod_left_button.add_value_listener(self._action_scroll_left)

    def _set_scroll_mod_right_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.scroll_mod_right_button != None:
                self.scroll_mod_right_button.remove_value_listener(self._action_scroll_right)
            self.scroll_mod_right_button = button
            self.scroll_mod_right_button != None and self.scroll_mod_right_button.add_value_listener(self._action_scroll_right)

    def _action_scroll_left(self, value):
        if not self.scroll_mod_left_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.scroll_mod_left_button.send_value(1)
            self.navflags |= LEFT_DOWN
            self._measure_left_click = int(round(time.time() * 1000))
        else:
            self.scroll_mod_left_button.send_value(0)
            self.navflags &= ~LEFT_DOWN
            clicktime = int(round(time.time() * 1000)) - self._measure_left_click
            if clicktime < CLICK_TIME:
                if self._parent._modifier_down:
                    self._parent.modify_track_offset(-1)
                elif self._parent._mode == PAD_MODE:
                    self._do_lr_as_scale_mode(-1)
                elif self._parent._mode == SCENE_MODE:
                    self._parent.modify_scene_offset(-1)
                elif self._parent._mode == CLIP_MODE:
                    self._parent.move_view_horizontal(-1)
                elif self._parent._mode == CONTROL_MODE:
                    self._parent.move_view_horizontal(-1)

    def _action_scroll_right(self, value):
        if not self.scroll_mod_right_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.scroll_mod_right_button.send_value(1)
            self.navflags |= RIGHT_DOWN
            self._measure_right_click = int(round(time.time() * 1000))
        else:
            self.scroll_mod_right_button.send_value(0)
            self.navflags &= ~RIGHT_DOWN
            clicktime = int(round(time.time() * 1000)) - self._measure_right_click
            if clicktime < CLICK_TIME:
                if self._parent._modifier_down:
                    self._parent.modify_track_offset(1)
                elif self._parent._mode == PAD_MODE:
                    self._do_lr_as_scale_mode(1)
                elif self._parent._mode == SCENE_MODE:
                    self._parent.modify_scene_offset(1)
                elif self._parent._mode == CLIP_MODE:
                    self._parent.move_view_horizontal(1)
                elif self._parent._mode == CONTROL_MODE:
                    self._parent.move_view_horizontal(1)

    def _do_lr_as_scale_mode(self, delta):
        if self.pad_to_mainknob_mode == PAD_KNOB_SCALE:
            self._parent.inc_scale(delta)
        elif self.pad_to_mainknob_mode == PAD_KNOB_BASEN:
            self._parent.inc_base_note(delta)
        else:
            self._parent.inc_octave(delta)

    def _action_oct_down(self, value):
        if value != 0:
            self._parent.inc_octave(-1)

    def _action_oct_up(self, value):
        if value != 0:
            self._parent.inc_octave(1)

    def _action_scale_down(self, value):
        if value != 0:
            self._parent.inc_scale(-1)

    def _action_scale_up(self, value):
        if value != 0:
            self._parent.inc_scale(1)

    def _action_base_down(self, value):
        if value != 0:
            self._parent.inc_base_note(-1)

    def _action_base_up(self, value):
        if value != 0:
            self._parent.inc_base_note(1)

    def _set_push_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.push_button != None:
                self.push_button.remove_value_listener(self._action_push)
            self.push_button = button
            self.push_button != None and self.push_button.add_value_listener(self._action_push)

    def _action_push(self, value):
        if not self.push_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                next_mode = self.mode_assign_map[self.mode][3]
                next_mode != -1 and self._set_mode(next_mode)
            self.loop_div_index = self.lrmode == LR_CONTROL_LOOP and self.navflags != 0 and (self.loop_div_index + 1) % len(LOOP_KNOB_DIVISION)
            self._parent.show_message('Loop Selection Granularity : ' + str(LOOP_KNOB_DIVISION[self.loop_div_index]) + ' beats ')
            self.loop_incdex = LOOP_KNOB_DIVISION[self.loop_div_index]

    def remove_listener(self, control, callback):
        if control != None and control.value_has_listener(callback):
            control.remove_value_listener(callback)
        control.disconnect()

    def disconnect(self):
        self.remove_listener(self.the_slider, self._do_main_slider)
        self.remove_listener(self.arrow_mode_button, self.toggle_arrow_mode)
        self.remove_listener(self.volume_button, self._action_volume)
        self.remove_listener(self.xfade_button, self._action_xfade)
        self.remove_listener(self.swing_button, self._action_swing)
        self.remove_listener(self.clipn_h_button, self._action_clipnh)
        self.remove_listener(self.clipn_v_button, self._action_clipnv)
        self.remove_listener(self.shift_button, self._action_shift)
        self.remove_listener(self.scroll_mod_left_button, self._action_scroll_left)
        self.remove_listener(self.scroll_mod_right_button, self._action_scroll_right)
        self.remove_listener(self.push_button, self._action_push)
        self.remove_listener(self.octave_mod_button, self._action_octave)
        self.remove_listener(self.scale_mod_button, self._action_scale)
        self.remove_listener(self.basenote_mod_button, self._action_base_note)
        self.remove_listener(self.octave_dwn_button, self._action_oct_down)
        self.remove_listener(self.octave_upp_button, self._action_oct_up)
        self.remove_listener(self.scale_dwn_button, self._action_scale_down)
        self.remove_listener(self.scale_upp_button, self._action_scale_up)
        self.remove_listener(self.basent_dwn_button, self._action_base_down)
        self.remove_listener(self.basent_upp_button, self._action_base_up)
        self._parent = None
        self.master_track = None
        self.the_slider = None
        self.mode_assign_map = None
########NEW FILE########
__FILENAME__ = MaschineControlSurface
#Embedded file name: C:\ProgramData\Ableton\Live 8\Resources\MIDI Remote Scripts\Maschine_Mk1\MaschineControlSurface.py
import Live
import MidiRemoteScript
import time
from VarButtonElement import VarButtonElement
from VarButtonElement import TwinButton
from MaschineSessionComponent import MaschineSessionComponent
from MaschineDeviceComponent import MaschineDeviceComponent
from PadScale import *
from SceneMatrix import SceneMatrix
from MainKnobControl import MainKnobControl
from MIDI_Map import *
from _Framework.ControlSurface import ControlSurface
from _Framework.InputControlElement import *
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import EncoderElement
from _Framework.ButtonMatrixElement import ButtonMatrixElement
from _Framework.ChannelTranslationSelector import ChannelTranslationSelector
from _Framework.TransportComponent import TransportComponent
from _Framework.MixerComponent import MixerComponent

class MaschineControlSurface(ControlSurface):
    __module__ = __name__
    __doc__ = 'Control Script for Maschine and Maschine Mikro'

    def __init__(self, c_instance):
        ControlSurface.__init__(self, c_instance)
        self.set_suppress_rebuild_requests(True)
        self._active = True
        self.value_encoder_tempo = None
        self.enc_tempo_mode = None
        self.nav_index = 0
        self._scenematrix = SceneMatrix(self)
        self._master_knob = MainKnobControl(self)
        self.md_select_pressed = False
        self.md_solo_pressed = False
        self._rec_quant = Live.Song.RecordingQuantization.rec_q_no_q
        self.adjust_time = None
        self.modelegacy = False
        self._mode = CLIP_MODE
        self._modifier_down = False
        self.time_callback = None
        self._device_nav_button_left = None
        self._device_nav_button_right = None
        self._return_mode = 0
        self._returntopad = False
        self._pad_mode = PM_OFF
        self._device = self._set_up_device_control()
        self.global_translation_selector = ChannelTranslationSelector()
        self.init_slot = 0
        self.init_done = False
        self._base_note = 0
        self._octave = 0.55
        self._scale_select_mode = MODE_PRESS_NONE
        self.show_message(str(''))
        self.request_rebuild_midi_map()
        self.send_sliders = []
        for track in range(8):
            self.send_sliders.append(SliderElement(MIDI_CC_TYPE, BASIC_CHANNEL, SEND_CC_OFF + track))

        self.send_slider_index = 0
        self.send_slider_toggle_button = ButtonElement(False, MIDI_CC_TYPE, 0, 90)
        self.send_slider_toggle_button.add_value_listener(self._do_toggle_send)
        self._set_up_controls()
        self._setup_transport()
        self._set_up_session()
        self._set_up_mixer()
        self._set_up_timer()
        self._set_up_machine_knobs()
        self.current_scale_index = 0
        self.assign_transpose(SCALES[self.current_scale_index])
        self.update_display()
        self._set_mode()
        self.set_suppress_rebuild_requests(False)
        self.timer_repeat = 0
        self.time_callback = None
        self.invoke_timer(self._start_display, 3)
        self.song().view.add_detail_clip_listener(self.clip_handle)
        self.song().add_visible_tracks_listener(self.clip_handle)
        self.song().add_scenes_listener(self.clip_handle)
        self.application().view.add_view_focus_changed_listener(self.focus_changed)
        self.log_message('##### Maschine & Machine Mikro Controller - Version: 1.10')

    def _start_display(self):
        self._set_mode()
        self._master_knob.update()
        self.clip_mode_button.send_value(100)
        if self._scenematrix.soloexclusive:
            self._armsolomode_button.send_value(1)
        else:
            self._armsolomode_button.send_value(0)
        self._master_knob.start_up()
        self.current_scale_to_display()

    def invoke_timer(self, callback, repeat):
        self.timer_repeat = repeat
        self.time_callback = callback

    def _set_up_controls(self):
        self.scene_mode_button = None
        self._set_scene_mode_button(ButtonElement(True, MIDI_CC_TYPE, 0, 112))
        self.clip_mode_button = None
        self._set_clip_mode_button(ButtonElement(True, MIDI_CC_TYPE, 0, 113))
        self.pad_mode_button = None
        self._set_pad_mode_button(ButtonElement(True, MIDI_CC_TYPE, 0, 114))
        self.control_mode_button = None
        self._set_control_mode_button(ButtonElement(True, MIDI_CC_TYPE, 0, 115))
        self.xfade_assign_button = None
        self._set_xfade_assign_button(ButtonElement(True, MIDI_CC_TYPE, 0, 116))
        self._undo_button = None
        self._set_undo_button(ButtonElement(True, MIDI_CC_TYPE, 0, 85))
        self._redo_button = None
        self._set_redo_button(ButtonElement(True, MIDI_CC_TYPE, 0, 87))
        self._armsolomode_button = None
        self._set_armsolomode_button(ButtonElement(True, MIDI_CC_TYPE, 0, 89))
        self._pad_scale_up = None
        self._pad_scale_down = None
        self._set_scale_up_button(ButtonElement(True, MIDI_CC_TYPE, 0, 83))
        self._set_scale_down_button(ButtonElement(True, MIDI_CC_TYPE, 0, 94))
        self._mode_octave_button = None
        self._mode_base_button = None
        self._fire_button = None
        self._set_mode_select_button(ButtonElement(False, MIDI_CC_TYPE, 0, 117))
        self._set_mode_solo_button(ButtonElement(False, MIDI_CC_TYPE, 0, 118))
        self._set_fire_button(ButtonElement(False, MIDI_CC_TYPE, 0, 119))
        self._pad_solo_button = None
        self._mute_button = None
        self._pad_select_button = None
        self._group_d_button = None
        self._group_h_button = None
        self._fire_dedictated_button = None
        self._set_mikro_select_button(ButtonElement(False, MIDI_CC_TYPE, 1, 117))
        self._set_mikro_solo_button(ButtonElement(False, MIDI_CC_TYPE, 1, 118))
        self._set_mute_button(ButtonElement(False, MIDI_CC_TYPE, 1, 119))
        self._set_group_d_button(ButtonElement(True, MIDI_CC_TYPE, 1, 120))
        self._set_group_h_button(ButtonElement(True, MIDI_CC_TYPE, 1, 121))
        self._set_dedictated_fire_button(ButtonElement(True, MIDI_CC_TYPE, 0, 9))
        self.track_left_button = None
        self._set_track_left_button(ButtonElement(False, MIDI_CC_TYPE, 0, 120))
        self.track_right_button = None
        self._set_track_right_button(ButtonElement(False, MIDI_CC_TYPE, 0, 121))
        self._navigate_button = None
        self._set_navigate_button(ButtonElement(False, MIDI_CC_TYPE, 0, 127))
        self.display_update_button = None
        self._set_display_update_button(ButtonElement(False, MIDI_CC_TYPE, 0, 86))

    def _set_up_device_control(self):
        is_momentary = True
        device = MaschineDeviceComponent(self)
        device.set_device_changed_listener(self._handle_device_changed)
        device.set_device_parm_listener(self._hande_device_parm_changed)
        param_controls = []
        for index in range(8):
            param_controls.append(SliderElement(MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_CC_OFF + index))

        device.set_parameter_controls(tuple(param_controls))
        device.set_on_off_button(ButtonElement(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_BUTTON_CC_OFF))
        device.set_bank_nav_buttons(ButtonElement(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_BUTTON_CC_OFF + 4), ButtonElement(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_BUTTON_CC_OFF + 5))
        global_translation_selector = ChannelTranslationSelector()
        global_translation_selector.set_controls_to_translate(tuple(param_controls))
        self.set_device_nav_button_left(ButtonElement(True, MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_BUTTON_CC_OFF + 6))
        self.set_device_nav_button_right(ButtonElement(True, MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_BUTTON_CC_OFF + 7))
        self.set_device_component(device)
        return device

    def _set_up_mixer(self):
        self._mixer = MixerComponent(8)
        for track in range(8):
            strip = self._mixer.channel_strip(track)
            strip.set_arm_button(ButtonElement(True, MIDI_CC_TYPE, BASIC_CHANNEL, ARM_CC_OFF + track))
            strip.set_solo_button(ButtonElement(True, MIDI_CC_TYPE, BASIC_CHANNEL, SOLO_CC_OFF + track))
            strip.set_mute_button(ButtonElement(True, MIDI_CC_TYPE, BASIC_CHANNEL, MUTE_CC_OFF + track))
            strip.set_volume_control(SliderElement(MIDI_CC_TYPE, BASIC_CHANNEL, LEVEL_CC_OFF + track))
            strip.set_pan_control(SliderElement(MIDI_CC_TYPE, BASIC_CHANNEL, PAN_CC_OFF + track))
            strip.set_select_button(ButtonElement(True, MIDI_CC_TYPE, BASIC_CHANNEL, SELECT_CC_OFF + track))
            st = tuple([self.send_sliders[track]])
            strip.set_send_controls(st)

        self._session.set_mixer(self._mixer)

    def _set_up_timer(self):
        self.blink_state = 1
        self._register_timer_callback(self._on_timer)

    def _on_timer(self):
        if self.time_callback != None and self.timer_repeat > 0:
            self.time_callback()
            self.timer_repeat -= 1
            if self.timer_repeat == 0:
                self.time_callback = None
        if self._mode == CLIP_MODE and not self._modifier_down:
            self._session.notify_b(self.blink_state)
            if self.init_slot == INIT_SLOT and not self.init_done:
                self._set_up_clip_matrix()
                self.init_done = True
        elif self._mode == PAD_MODE:
            pass
        else:
            self._scenematrix.notify_scene_mode(self.blink_state)
        self.blink_state = (self.blink_state + 1) % 8
        self.init_slot += 1

    def _set_mode(self):
        if self._mode == SCENE_MODE:
            self.scene_mode_button.send_value(127)
            self.clip_mode_button.send_value(0)
            self.pad_mode_button.send_value(0)
            self.control_mode_button.send_value(0)
        elif self._mode == CLIP_MODE:
            self.scene_mode_button.send_value(0)
            self.clip_mode_button.send_value(100)
            self.pad_mode_button.send_value(0)
            self.control_mode_button.send_value(0)
        elif self._mode == PAD_MODE:
            self.scene_mode_button.send_value(0)
            self.clip_mode_button.send_value(0)
            self.pad_mode_button.send_value(127)
            self.control_mode_button.send_value(0)
        elif self._mode == CONTROL_MODE:
            self.scene_mode_button.send_value(0)
            self.clip_mode_button.send_value(0)
            self.pad_mode_button.send_value(0)
            self.control_mode_button.send_value(127)

    def song(self):
        return ControlSurface.song(self)

    def _set_up_session(self):
        self._session = MaschineSessionComponent(self)
        self._session.set_scene_bank_buttons(ButtonElement(True, MIDI_CC_TYPE, 0, 92), ButtonElement(True, MIDI_CC_TYPE, 0, 81))
        self._session.set_track_bank_buttons(ButtonElement(True, MIDI_CC_TYPE, 0, 93), ButtonElement(True, MIDI_CC_TYPE, 0, 91))
        self._session.set_stop_all_clips_button(ButtonElement(True, MIDI_CC_TYPE, 0, 111))
        track_stop_buttons = [ ButtonElement(True, MIDI_CC_TYPE, BASIC_CHANNEL, index + STOP_CC_OFF) for index in range(4) ]
        self._session.set_stop_track_clip_buttons(tuple(track_stop_buttons))
        self._init_matrix()
        self._set_up_buttons()
        self._session._link()
        self._session.set_advance(STEP4)

    def _init_matrix(self):
        self._button_sequence = []
        self._matrix = []
        for scene_index in range(4):
            button_row = []
            for track_index in range(4):
                button = VarButtonElement(True, 0, scene_index, track_index, self)
                partner = TwinButton(True, 1, button)
                partner.add_value_listener(self.ox, True)
                button_row.append(button)

            self._matrix.append(tuple(button_row))

        for scene_index in [3,
         2,
         1,
         0]:
            for track_index in range(4):
                self._button_sequence.append(self._matrix[scene_index][track_index])

        self._session.set_matrix(self._matrix)

    def ox(self, value, button):
        if not isinstance(button, TwinButton):
            raise AssertionError
            self._mode == PAD_MODE and button.fire(value)

    def _set_up_buttons(self):
        self._bmatrix = None
        self._bmatrix = ButtonMatrixElement()
        for scene_index in range(4):
            button_row = []
            scene = self._session.scene(scene_index)
            for track_index in range(4):
                button = self._matrix[scene_index][track_index]
                clip_slot = scene.clip_slot(track_index)
                clip_slot.set_launch_button(button)
                clip_slot.set_triggered_to_play_value(1)
                clip_slot.set_triggered_to_record_value(1)
                clip_slot.set_started_value(1)
                clip_slot.set_recording_value(1)
                clip_slot.set_stopped_value(1)

            self._bmatrix.add_row(tuple(button_row))

    def _reset_matrix(self):
        for scene_index in range(4):
            scene = self._session.scene(scene_index)
            for track_index in range(4):
                button = self._matrix[scene_index][track_index]
                clip_slot = scene.clip_slot(track_index)
                clip_slot.set_launch_button(button)

    def update_button_matrix(self):
        self._session.update()
        for scene_index in range(4):
            scene = self._session.scene(scene_index)
            for track_index in range(4):
                button = self._matrix[scene_index][track_index]
                clip_slot = scene.clip_slot(track_index)
                if clip_slot._clip_slot != None and clip_slot._clip_slot.clip != None:
                    button.send_value(1)
                else:
                    button.send_value(0)

    def _deassign_matrix(self):
        for scene_index in range(4):
            scene = self._session.scene(scene_index)
            for track_index in range(4):
                clip_slot = scene.clip_slot(track_index)
                clip_slot.set_launch_button(None)

    def receive_midi(self, midi_bytes):
        raise midi_bytes != None or AssertionError
        raise isinstance(midi_bytes, tuple) or AssertionError
        if len(midi_bytes) is 3:
            midi_msg_type = midi_bytes[0]
            ident = midi_bytes[1]
            forwarding_key = [midi_msg_type]
            forwarding_key.append(ident)
            if midi_msg_type == MIDI_NOTE_ON_STATUS or midi_msg_type == MIDI_NOTE_OFF_STATUS:
                recipient = self._forwarding_registry[tuple(forwarding_key)]
                if midi_msg_type == MIDI_NOTE_ON_STATUS:
                    if recipient != None:
                        recipient.receive_value(127)
                elif midi_msg_type == MIDI_NOTE_OFF_STATUS:
                    pass
            else:
                recipient = self._forwarding_registry[tuple(forwarding_key)]
                if recipient != None:
                    recipient.receive_value(midi_bytes[2])

    def _setup_transport(self):
        transport = TransportComponent()
        transport.set_play_button(ButtonElement(True, MIDI_CC_TYPE, 0, 108))
        transport.set_stop_button(ButtonElement(False, MIDI_CC_TYPE, 0, 110))
        transport.set_record_button(ButtonElement(True, MIDI_CC_TYPE, 0, 109))
        transport.set_overdub_button(ButtonElement(True, MIDI_CC_TYPE, 0, 107))
        transport.set_metronome_button(ButtonElement(True, MIDI_CC_TYPE, 0, 104))
        transport.set_nudge_buttons(ButtonElement(True, MIDI_CC_TYPE, 1, 51), ButtonElement(True, MIDI_CC_TYPE, 1, 50))
        transport.set_punch_buttons(ButtonElement(True, MIDI_CC_TYPE, 1, 52), ButtonElement(True, MIDI_CC_TYPE, 1, 53))
        transport.set_loop_button(ButtonElement(True, MIDI_CC_TYPE, 1, 54))
        transport.set_seek_buttons(ButtonElement(True, MIDI_CC_TYPE, 1, 59), ButtonElement(True, MIDI_CC_TYPE, 1, 58))
        self.xfadeKnob = SliderElement(MIDI_CC_TYPE, 1, 100)
        self.xfadeKnob.connect_to(self.song().master_track.mixer_device.crossfader)
        self.tap_button = ButtonElement(True, MIDI_CC_TYPE, 0, 88)
        self.tap_button.add_value_listener(self._do_tap_tempo)
        self.cue_add_delete_button = ButtonElement(True, MIDI_CC_TYPE, 1, 55)
        self.cue_prev_button = ButtonElement(True, MIDI_CC_TYPE, 1, 56)
        self.cue_next_button = ButtonElement(True, MIDI_CC_TYPE, 1, 57)
        self.cue_add_delete_button.add_value_listener(self._do_toggle_cue)
        self.cue_prev_button.add_value_listener(self._do_toggle_prev_cue)
        self.cue_next_button.add_value_listener(self._do_toggle_next_cue)

    def _invoke_track_edit(self, mode):
        self._deassign_matrix()
        self._scenematrix.assign()
        self._scenematrix.set_mode(mode)
        self._scenematrix.set_active(True)
        self._pad_mode = PM_ON
        self.set_suppress_rebuild_requests(True)
        self.request_rebuild_midi_map()
        self.set_suppress_rebuild_requests(False)
        self.invoke_timer(self._scenematrix.update, 2)

    def _enter_control_mode(self):
        if self._mode == CLIP_MODE:
            self._deassign_matrix()
        elif self._mode == PAD_MODE:
            self._register_buttons()
        self._scenematrix.assign()
        self._scenematrix.set_mode(SCENE_MODE_CONTROL)
        self._scenematrix.set_active(True)
        self._return_mode = SCENE_MODE_CONTROL
        self.set_suppress_rebuild_requests(True)
        self.request_rebuild_midi_map()
        self.set_suppress_rebuild_requests(False)
        self.invoke_timer(self._scenematrix.update, 2)
        self._master_knob.switch_to_matrix_mode()
        self._mode = CONTROL_MODE

    def _enter_scene_mode(self):
        if self._mode == CLIP_MODE:
            self._deassign_matrix()
        elif self._mode == PAD_MODE:
            self._register_buttons()
        elif self._mode == CONTROL_MODE:
            self._master_knob.exit_matrix_mode()
        self._scenematrix.assign()
        self._scenematrix.set_mode(SCENE_MODE_NORMAL)
        self._scenematrix.set_active(True)
        self._return_mode = SCENE_MODE_NORMAL
        self.set_suppress_rebuild_requests(True)
        self.request_rebuild_midi_map()
        self.set_suppress_rebuild_requests(False)
        self.invoke_timer(self._scenematrix.update, 2)
        self._mode = SCENE_MODE

    def _from_pad_mode(self, matrix_mode):
        self._register_buttons()
        self._scenematrix.assign()
        self._scenematrix.set_mode(matrix_mode)
        self._scenematrix.set_active(True)
        self.set_suppress_rebuild_requests(True)
        self.request_rebuild_midi_map()
        self.set_suppress_rebuild_requests(False)
        self.invoke_timer(self._scenematrix.update, 2)
        self._mode = SCENE_MODE

    def _enter_pad_mode(self):
        if self._mode == CLIP_MODE:
            self._deassign_matrix()
        elif self._mode == SCENE_MODE:
            self._scenematrix.deassign()
        elif self._mode == CONTROL_MODE:
            self._scenematrix.deassign()
            self._master_knob.exit_matrix_mode()
        self._scenematrix.set_active(False)
        self._mode = PAD_MODE
        for row in range(4):
            for column in range(4):
                button = self._matrix[row][column]
                button.send_value(0)
                time.sleep(0.001)
                button.set_to_notemode(True)
                fwkey = [MIDI_NOTE_ON_STATUS]
                fwkey.append(button.get_identifier())
                self._forwarding_registry[tuple(fwkey)] = button
                self._forwarding_registry[MIDI_NOTE_OFF_STATUS, button.get_identifier()] = button

        self.time_callback = None
        self._mode = PAD_MODE

    def _register_buttons(self):
        for row in range(4):
            for column in range(4):
                button = self._matrix[row][column]
                button.set_to_notemode(False)
                button.send_value(100)
                fwkey = [MIDI_NOTE_ON_STATUS]
                fwkey.append(button.get_identifier())
                self._forwarding_registry[tuple(fwkey)] = button
                self._forwarding_registry[MIDI_NOTE_OFF_STATUS, button.get_identifier()] = button

    def _back_to_clip_mode(self):
        self._pad_mode = PM_OFF
        self._scenematrix.set_mode(SCENE_MODE_NORMAL)
        self._scenematrix.deassign()
        self._scenematrix.set_active(False)
        self._set_up_clip_matrix()

    def _enter_clip_mode(self):
        if self._mode == SCENE_MODE:
            self._scenematrix.deassign()
            self._scenematrix.set_active(False)
        elif self._mode == CONTROL_MODE:
            self._master_knob.exit_matrix_mode()
            self._scenematrix.set_active(False)
        self._set_up_clip_matrix()
        self._mode = CLIP_MODE

    def _set_up_clip_matrix(self):
        for row in range(4):
            for column in range(4):
                button = self._matrix[row][column]
                button.set_to_notemode(False)

        self.set_suppress_rebuild_requests(True)
        self.request_rebuild_midi_map()
        self._reset_matrix()
        self.invoke_timer(self.update_button_matrix, 3)
        self.set_suppress_rebuild_requests(False)

    def modify_track_offset(self, delta):
        self._scenematrix.mod_track_offset(delta)

    def modify_scene_offset(self, delta):
        self._scenematrix.mod_scene_offset(delta)

    def move_view_horizontal(self, delta):
        if delta == 1:
            self._session.bank_right()
        else:
            self._session.bank_left()
        if self._mode == CONTROL_MODE:
            self._scenematrix.update()

    def _set_up_machine_knobs(self):
        master_track = self.song().master_track
        self.recordQuantSlider = SliderElement(MIDI_CC_TYPE, 0, 42)
        self.recordQuantSlider.add_value_listener(self._on_rec_quant, True)
        self.master_volume = SliderElement(MIDI_CC_TYPE, 0, 40)
        self.prehear = SliderElement(MIDI_CC_TYPE, 0, 41)
        self.master_volume.connect_to(master_track.mixer_device.volume)
        self.prehear.connect_to(master_track.mixer_device.cue_volume)

    def _on_rec_quant(self, value, encoder):
        if not value in range(128):
            raise AssertionError
            raise isinstance(encoder, EncoderElement) or AssertionError
            self._scale_select_mode == MODE_PRESS_NONE and self.set_quant(value)
            self.value_encoder_tempo = value
            self.enc_tempo = self.song().tempo
        elif self._scale_select_mode == MODE_PRESS_SELECT or self._scale_select_mode == MODE_PRESS_SOLO:
            if self.value_encoder_tempo == None:
                self.value_encoder_tempo = value
                self.enc_tempo = self.song().tempo
                self.enc_tempo_mode = self._scale_select_mode
            else:
                if self.enc_tempo_mode != self._scale_select_mode:
                    self.value_encoder_tempo = value
                diff = value - self.value_encoder_tempo
                if self._scale_select_mode == MODE_PRESS_SOLO:
                    diff *= 0.01
                self.song().tempo = max(20, min(999, self.enc_tempo + diff))
                self.enc_tempo_mode = self._scale_select_mode
            if value == 127 or value == 0:
                encoder.send_value(63)
                self.value_encoder_tempo = 63
                self.enc_tempo = self.song().tempo

    def set_quant(self, value):
        req_q = None
        msg = None
        if value < 15:
            msg = ' No Rec Quant '
            self._rec_quant = self.song().midi_recording_quantization
            req_q = Live.Song.RecordingQuantization.rec_q_no_q
        elif value < 30:
            msg = ' 1/4 Rec Quant'
            req_q = Live.Song.RecordingQuantization.rec_q_quarter
        elif value < 45:
            msg = ' 1/8 Rec Quant'
            req_q = Live.Song.RecordingQuantization.rec_q_eight
        elif value < 60:
            msg = ' 1/8 Triplet Quant'
            req_q = Live.Song.RecordingQuantization.rec_q_eight_triplet
        elif value < 75:
            msg = ' 1/8 & 1/8 Triplet Quant'
            req_q = Live.Song.RecordingQuantization.rec_q_eight_eight_triplet
        elif value < 90:
            msg = ' 1/16 Quant'
            req_q = Live.Song.RecordingQuantization.rec_q_sixtenth
        elif value < 105:
            msg = ' 1/16 Triplet Quant'
            req_q = Live.Song.RecordingQuantization.rec_q_sixtenth_triplet
        else:
            msg = ' 1/16 & 1/16 Triplet Quant'
            req_q = Live.Song.RecordingQuantization.rec_q_sixtenth_sixtenth_triplet
        if req_q != self._rec_quant:
            self.song().midi_recording_quantization = req_q
            self._rec_quant = req_q
            self.show_message(str(msg))

    def _set_undo_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._undo_button != None:
                self._undo_button.remove_value_listener(self._do_undo)
            self._undo_button = button
            self._undo_button != None and self._undo_button.add_value_listener(self._do_undo)

    def _do_undo(self, value):
        if not self._undo_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                (value != 0 or not self._undo_button.is_momentary()) and self.song().can_undo == 1 and self.song().undo()
                self.show_message(str('UNDO'))

    def _set_redo_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._redo_button != None:
                self._redo_button.remove_value_listener(self._do_redo)
            self._redo_button = button
            self._redo_button != None and self._redo_button.add_value_listener(self._do_redo)

    def _do_redo(self, value):
        if not self._redo_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                (value != 0 or not self._redo_button.is_momentary()) and self.song().can_redo == 1 and self.song().redo()
                self.show_message(str('Redo'))

    def _set_armsolomode_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._armsolomode_button != None:
                self._armsolomode_button.remove_value_listener(self._do_armsolo_mode)
            self._armsolomode_button = button
            self._armsolomode_button != None and self._armsolomode_button.add_value_listener(self._do_armsolo_mode)

    def _do_armsolo_mode(self, value):
        if not self._armsolomode_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self._scenematrix.set_armsolo_exclusive(self._armsolomode_button)

    def _set_navigate_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._navigate_button != None:
                self._navigate_button.remove_value_listener(self._do_navigate)
            self._navigate_button = button
            self._navigate_button != None and self._navigate_button.add_value_listener(self._do_navigate)

    def _do_navigate(self, value):
        if not self._navigate_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            self.nav_index = value != 0 and (self.nav_index + 1) % len(VIEWS_ALL)
            self.application().view.focus_view(VIEWS_ALL[self.nav_index])
            self.show_message('Focus on : ' + str(VIEWS_ALL[self.nav_index]))

    def _set_fire_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._fire_button != None:
                self._fire_button.remove_value_listener(self._do_mute_fire_button)
            self._fire_button = button
            self._fire_button != None and self._fire_button.add_value_listener(self._do_mute_fire_button)

    def _do_mute_fire_button(self, value):
        raise self._fire_button != None or AssertionError
        raise value in range(128) or AssertionError
        self._handle_mute(value, True)

    def _set_mute_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._mute_button != None:
                self._mute_button.remove_value_listener(self._do_mute_button)
            self._mute_button = button
            self._mute_button != None and self._mute_button.add_value_listener(self._do_mute_button)

    def _do_mute_button(self, value):
        raise self._mute_button != None or AssertionError
        raise value in range(128) or AssertionError
        self._handle_mute(value, self.modelegacy)

    def _handle_mute(self, value, legacymode = False):
        self._modifier_down = value != 0
        if legacymode and self._mode == PAD_MODE:
            if value != 0 or not self._mute_button.is_momentary():
                clip_slot = self.song().view.highlighted_clip_slot
                if clip_slot:
                    clip_slot.fire()
        if not legacymode and (self._mode == PAD_MODE or self._returntopad):
            if value != 0:
                self._from_pad_mode(SCENE_MODE_MUTE)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == SCENE_MODE or self._mode == CONTROL_MODE:
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
                self._pad_mode = PM_OFF
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_MUTE)
                self._pad_mode = PM_ON
        elif self._mode == CLIP_MODE:
            if value > 0:
                self._invoke_track_edit(SCENE_MODE_MUTE)
            else:
                self._back_to_clip_mode()
                self._pad_mode = PM_OFF

    def _set_dedictated_fire_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._fire_dedictated_button != None:
                self._fire_dedictated_button.remove_value_listener(self._do_dedictated_fire_button)
            self._fire_dedictated_button = button
            self._fire_dedictated_button != None and self._fire_dedictated_button.add_value_listener(self._do_dedictated_fire_button)

    def _do_dedictated_fire_button(self, value):
        if not self._fire_dedictated_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                clip_slot = (value != 0 or not self._mute_button.is_momentary()) and self.song().view.highlighted_clip_slot
                clip_slot and clip_slot.fire()

    def _set_mode_solo_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._mode_base_button != None:
                self._mode_base_button.remove_value_listener(self._do_pad_mode_base)
            self._mode_base_button = button
            self._mode_base_button != None and self._mode_base_button.add_value_listener(self._do_pad_mode_base)

    def _do_pad_mode_base(self, value):
        raise self._mode_base_button != None or AssertionError
        raise value in range(128) or AssertionError
        self._handle_solo(value, True)

    def _set_mikro_solo_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._pad_solo_button != None:
                self._pad_solo_button.remove_value_listener(self._do_pad_solo_multi)
            self._pad_solo_button = button
            self._pad_solo_button != None and self._pad_solo_button.add_value_listener(self._do_pad_solo_multi)

    def _do_pad_solo_multi(self, value):
        raise value in range(128) or AssertionError
        self._handle_solo(value, self.modelegacy)

    def _handle_solo(self, value, asmodifier = False):
        self._modifier_down = value != 0
        if asmodifier and self._mode == PAD_MODE:
            if value == 0:
                self._scale_select_mode = MODE_PRESS_NONE
            else:
                self._scale_select_mode = MODE_PRESS_SOLO
        elif not asmodifier and (self._mode == PAD_MODE or self._returntopad):
            if value != 0:
                self._from_pad_mode(SCENE_MODE_SOLO)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == CLIP_MODE:
            if value != 0:
                self._invoke_track_edit(SCENE_MODE_SOLO)
            else:
                self._back_to_clip_mode()
        elif self._mode != PAD_MODE:
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_SOLO)

    def _set_mode_select_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._mode_octave_button != None:
                self._mode_octave_button.remove_value_listener(self._do_pad_mode_octave)
            self._mode_octave_button = button
            self._mode_octave_button != None and self._mode_octave_button.add_value_listener(self._do_pad_mode_octave)

    def _do_pad_mode_octave(self, value):
        raise self._mode_octave_button != None or AssertionError
        raise value in range(128) or AssertionError
        self._handle_select(value, True)

    def _set_mikro_select_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._pad_select_button != None:
                self._pad_select_button.remove_value_listener(self._do_pad_select_multi)
            self._pad_select_button = button
            self._pad_select_button != None and self._pad_select_button.add_value_listener(self._do_pad_select_multi)

    def _do_pad_select_multi(self, value):
        raise value in range(128) or AssertionError
        self._handle_select(value, self.modelegacy)

    def _handle_select(self, value, asmodifer = False):
        self._modifier_down = value != 0
        if asmodifer and self._mode == PAD_MODE:
            if value == 0:
                self._scale_select_mode = MODE_PRESS_NONE
            else:
                self._scale_select_mode = MODE_PRESS_SELECT
        elif not asmodifer and (self._mode == PAD_MODE or self._returntopad):
            if value != 0:
                self._from_pad_mode(SCENE_MODE_SELECT)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == CLIP_MODE:
            if value != 0:
                self._invoke_track_edit(SCENE_MODE_SELECT)
            else:
                self._back_to_clip_mode()
        elif self._mode != PAD_MODE:
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_SELECT)

    def _set_scale_up_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._pad_scale_up != None:
                self._pad_scale_up.remove_value_listener(self._do_pad_note_up)
            self._pad_scale_up = button
            self._pad_scale_up != None and self._pad_scale_up.add_value_listener(self._do_pad_note_up)

    def _do_pad_note_up(self, value):
        raise self._pad_scale_up != None or AssertionError
        raise value in range(128) or AssertionError
        self._handle_groupd_up(value, True)

    def _set_group_d_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._group_d_button != None:
                self._group_d_button.remove_value_listener(self._do_arm)
            self._group_d_button = button
            self._group_d_button != None and self._group_d_button.add_value_listener(self._do_arm)

    def _do_arm(self, value):
        raise self._pad_scale_up != None or AssertionError
        raise value in range(128) or AssertionError
        self._handle_groupd_up(value, self.modelegacy)

    def _handle_groupd_up(self, value, legacymode = False):
        self._modifier_down = value != 0
        if legacymode and self._mode == PAD_MODE:
            if value != 0:
                if self._scale_select_mode == MODE_PRESS_SELECT:
                    self.inc_scale(1)
                elif self._scale_select_mode == MODE_PRESS_SOLO:
                    self.inc_base_note(1)
                else:
                    self.inc_octave(1)
        elif not legacymode and (self._mode == PAD_MODE or self._returntopad):
            if value != 0:
                self._from_pad_mode(SCENE_MODE_ARM)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == CLIP_MODE:
            self.show_message('Arm tracks with pads')
            if value != 0:
                self._invoke_track_edit(SCENE_MODE_ARM)
            else:
                self._back_to_clip_mode()
        elif self._mode == SCENE_MODE or self._mode == CONTROL_MODE:
            self.show_message('Arm tracks with pads')
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_ARM)

    def _set_scale_down_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._pad_scale_down != None:
                self._pad_scale_down.remove_value_listener(self._do_pad_note_down)
            self._pad_scale_down = button
            self._pad_scale_down != None and self._pad_scale_down.add_value_listener(self._do_pad_note_down)

    def _do_pad_note_down(self, value):
        raise self._pad_scale_down != None or AssertionError
        raise value in range(128) or AssertionError
        self._handle_grouph_down(value, True)

    def _set_group_h_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._group_h_button != None:
                self._group_h_button.remove_value_listener(self._do_stop)
            self._group_h_button = button
            self._group_h_button != None and self._group_h_button.add_value_listener(self._do_stop)

    def _do_stop(self, value):
        raise self._group_h_button != None or AssertionError
        raise value in range(128) or AssertionError
        self._handle_grouph_down(value)

    def _handle_grouph_down(self, value, legacymode = False):
        self._modifier_down = value != 0
        if legacymode and self._mode == PAD_MODE:
            if value != 0:
                if self._scale_select_mode == MODE_PRESS_SELECT:
                    self.inc_scale(-1)
                elif self._scale_select_mode == MODE_PRESS_SOLO:
                    self.inc_base_note(-1)
                else:
                    self.inc_octave(-1)
        elif not legacymode and (self._mode == PAD_MODE or self._returntopad):
            if value != 0:
                self._from_pad_mode(SCENE_MODE_STOP)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == CLIP_MODE:
            self.show_message('Stop tracks with pads')
            if value != 0:
                self._invoke_track_edit(SCENE_MODE_STOP)
            else:
                self._back_to_clip_mode()
        elif self._mode == SCENE_MODE or self._mode == CONTROL_MODE:
            self.show_message('Stop tracks with pads')
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_STOP)

    def inc_octave(self, inc):
        scale = SCALES[self.current_scale_index]
        octave = scale.to_octave(self._octave)
        newoctave = octave + inc
        if newoctave < 0:
            newoctave = 0
        elif newoctave > scale.octave_range:
            newoctave = scale.octave_range
        self._octave = scale.to_relative(newoctave, self._octave)
        scale = SCALES[self.current_scale_index]
        self.assign_transpose(scale)
        self.show_message(' OCTAVE ' + BASE_NOTE[self._base_note] + str(newoctave - 2) + ' to ' + scale.name)
        self.current_scale_to_display()

    def inc_base_note(self, inc):
        newbase = self._base_note + inc
        if newbase < 0:
            self._base_note = 11
        elif newbase > 11:
            self._base_note = 0
        else:
            self._base_note = newbase
        scale = SCALES[self.current_scale_index]
        self.assign_transpose(scale)
        self.show_message(' Base Note ' + BASE_NOTE[self._base_note] + ' to ' + scale.name)
        self.current_scale_to_display()

    def inc_scale(self, inc):
        nr_of_scales = len(SCALES)
        newindex = self.current_scale_index + inc
        if newindex >= 0 and newindex < nr_of_scales:
            self.current_scale_index += inc
        elif newindex < 0:
            self.current_scale_index = nr_of_scales - 1
        else:
            self.current_scale_index = 0
        newscale = SCALES[self.current_scale_index]
        self.assign_transpose(newscale)
        self.show_message(' PAD Scale ' + newscale.name + ' ' + BASE_NOTE[self._base_note] + str(newscale.to_octave(self._octave) - 2))
        self.current_scale_to_display()

    def assign_transpose(self, scale):
        raise isinstance(scale, PadScale) or AssertionError
        scale_len = len(scale.notevalues)
        octave = scale.to_octave(self._octave)
        for note_index in range(16):
            button = self._button_sequence[note_index]
            scale_index = note_index % scale_len
            octave_offset = note_index / scale_len
            note_value = scale.notevalues[scale_index] + self._base_note + octave * 12 + octave_offset * 12
            button.set_send_note(note_value)
            button.send_value(0)

    def set_device_nav_button_left(self, button):
        if self._device_nav_button_left != None:
            self._device_nav_button_left.remove_value_listener(self._nav_value_left)
        self._device_nav_button_left = button
        if self._device_nav_button_left != None:
            self._device_nav_button_left.add_value_listener(self._nav_value_left)

    def set_device_nav_button_right(self, button):
        if self._device_nav_button_right != None:
            self._device_nav_button_right.remove_value_listener(self._nav_value_right)
        self._device_nav_button_right = button
        if self._device_nav_button_right != None:
            self._device_nav_button_right.add_value_listener(self._nav_value_right)

    def _nav_value_left(self, value):
        if not self._device_nav_button_left != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                modifier_pressed = True
                value > 0 and (not self.application().view.is_view_visible('Detail') or not self.application().view.is_view_visible('Detail/DeviceChain')) and self.application().view.show_view('Detail')
                self.application().view.show_view('Detail/DeviceChain')
            else:
                direction = Live.Application.Application.View.NavDirection.left
                self.application().view.scroll_view(direction, 'Detail/DeviceChain', not modifier_pressed)

    def _nav_value_right(self, value):
        if not self._device_nav_button_right != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                modifier_pressed = value > 0 and True
                (not self.application().view.is_view_visible('Detail') or not self.application().view.is_view_visible('Detail/DeviceChain')) and self.application().view.show_view('Detail')
                self.application().view.show_view('Detail/DeviceChain')
            else:
                direction = Live.Application.Application.View.NavDirection.right
                self.application().view.scroll_view(direction, 'Detail/DeviceChain', not modifier_pressed)

    def _set_xfade_assign_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.xfade_assign_button != None:
                self.xfade_assign_button.remove_value_listener(self._do_xfade_assign)
            self.xfade_assign_button = button
            self.xfade_assign_button != None and self.xfade_assign_button.add_value_listener(self._do_xfade_assign)

    def _do_xfade_assign(self, value):
        if not self.xfade_assign_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                self._modifier_down = value != 0
                (self._mode == PAD_MODE or self._returntopad) and value != 0 and self._from_pad_mode(SCENE_MODE_XFADE)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == CLIP_MODE:
            if value != 0:
                self._invoke_track_edit(SCENE_MODE_XFADE)
            else:
                self._back_to_clip_mode()
        elif self._mode == SCENE_MODE or self._mode == CONTROL_MODE:
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_XFADE)

    def _set_track_left_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.track_left_button != None:
                self.track_left_button.remove_value_listener(self._a_trk_left)
            self.track_left_button = button
            self.track_left_button != None and self.track_left_button.add_value_listener(self._a_trk_left)

    def _set_track_right_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.track_right_button != None:
                self.track_right_button.remove_value_listener(self._a_trk_right)
            self.track_right_button = button
            self.track_right_button != None and self.track_right_button.add_value_listener(self._a_trk_right)

    def _set_display_update_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.display_update_button != None:
                self.display_update_button.remove_value_listener(self._a_display_update)
            self.display_update_button = button
            self.display_update_button != None and self.display_update_button.add_value_listener(self._a_display_update)

    def _set_scene_mode_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.scene_mode_button != None:
                self.scene_mode_button.remove_value_listener(self._a_mode_scene)
            self.scene_mode_button = button
            self.scene_mode_button != None and self.scene_mode_button.add_value_listener(self._a_mode_scene)

    def _set_clip_mode_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.clip_mode_button != None:
                self.clip_mode_button.remove_value_listener(self._a_mode_clip)
            self.clip_mode_button = button
            self.clip_mode_button != None and self.clip_mode_button.add_value_listener(self._a_mode_clip)

    def _set_pad_mode_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.pad_mode_button != None:
                self.pad_mode_button.remove_value_listener(self._a_mode_pad)
            self.pad_mode_button = button
            self.pad_mode_button != None and self.pad_mode_button.add_value_listener(self._a_mode_pad)

    def _set_control_mode_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.control_mode_button != None:
                self.control_mode_button.remove_value_listener(self._a_mode_control)
            self.control_mode_button = button
            self.control_mode_button != None and self.control_mode_button.add_value_listener(self._a_mode_control)

    def _a_mode_control(self, value):
        if not self.control_mode_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            (value != 0 or not self.control_mode_button.is_momentary()) and self._mode != CONTROL_MODE and self.show_message('CONTROL MODE')
            self.scene_mode_button.turn_off()
            self.clip_mode_button.turn_off()
            self.pad_mode_button.turn_off()
            self.control_mode_button.turn_on()
            self._enter_control_mode()

    def _a_mode_scene(self, value):
        if not self.scene_mode_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            (value != 0 or not self.scene_mode_button.is_momentary()) and self._mode != SCENE_MODE and self.show_message('SCENE MODE')
            self.scene_mode_button.turn_on()
            self.clip_mode_button.turn_off()
            self.pad_mode_button.turn_off()
            self.control_mode_button.turn_off()
            self._enter_scene_mode()

    def _a_mode_clip(self, value):
        if not self.clip_mode_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            (value != 0 or not self.clip_mode_button.is_momentary()) and self._mode != CLIP_MODE and self.show_message('CLIP MODE')
            self.scene_mode_button.turn_off()
            self.clip_mode_button.turn_on()
            self.pad_mode_button.turn_off()
            self.control_mode_button.turn_off()
            self._enter_clip_mode()

    def _a_mode_pad(self, value):
        if not self.pad_mode_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            (value != 0 or not self.pad_mode_button.is_momentary()) and self._mode != PAD_MODE and self.show_message('PAD MODE')
            self.scene_mode_button.turn_off()
            self.clip_mode_button.turn_off()
            self.pad_mode_button.turn_on()
            self.control_mode_button.turn_off()
            self._enter_pad_mode()

    def clip_handle(self):
        if self._mode == SCENE_MODE or self._mode == CONTROL_MODE or self._modifier_down:
            self._scenematrix.update()

    def focus_changed(self):
        pass

    def scroll_focus(self, delta):
        if delta == 1:
            self.nav_index = (self.nav_index + 1) % len(VIEWS_ALL)
        elif self.nav_index == 0:
            self.nav_index = len(VIEWS_ALL) - 1
        else:
            self.nav_index -= 1
        self.show_message('Focus on : ' + str(VIEWS_ALL[self.nav_index]))
        self.application().view.focus_view(VIEWS_ALL[self.nav_index])

    def scroll_device(self, delta):
        if not (delta == 1 or delta == -1):
            raise AssertionError
            direction = delta == 1 and Live.Application.Application.View.NavDirection.right
        else:
            direction = Live.Application.Application.View.NavDirection.left
        self.application().view.scroll_view(direction, 'Detail/DeviceChain', True)

    def scroll_scene(self, delta):
        if not self.track_left_button != None:
            raise AssertionError
            raise delta == 1 or delta == -1 or AssertionError
            direction = delta == 1 and Live.Application.Application.View.NavDirection.down
        else:
            direction = Live.Application.Application.View.NavDirection.up
        self.application().view.scroll_view(direction, 'Session', True)

    def _a_trk_left(self, value):
        if not self.track_left_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                direction = value != 0 and not self.track_left_button.is_momentary() and self.application().view.is_view_visible('Session') and Live.Application.Application.View.NavDirection.left
                self.application().view.scroll_view(direction, 'Session', True)

    def _a_trk_right(self, value):
        if not self.track_left_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                direction = value != 0 and not self.track_right_button.is_momentary() and self.application().view.is_view_visible('Session') and Live.Application.Application.View.NavDirection.right
                self.application().view.scroll_view(direction, 'Session', True)

    def _a_display_update(self, value):
        if not self.display_update_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if value != 0 or not self.display_update_button.is_momentary():
                    self.show_message(' Maschine Display Updated ')
                    self._master_knob.update()
                    self._set_mode()
                    self._mode == PAD_MODE and self.assign_transpose(SCALES[self.current_scale_index])
                elif self._mode == SCENE_MODE:
                    self._enter_scene_mode()
                elif self._mode == CONTROL_MODE:
                    self._enter_control_mode()
                self._master_knob.start_up()
                self.current_scale_to_display()
                self._scenematrix.soloexclusive and self._armsolomode_button.send_value(1)
            else:
                self._armsolomode_button.send_value(0)
            self._session.update()
            self.refresh_state()
            self.update_display()

    def _do_tap_tempo(self, value):
        if not value in range(128):
            raise AssertionError
            value > 0 and self.song().tap_tempo()

    def _do_toggle_cue(self, value):
        if not value in range(128):
            raise AssertionError
            value > 0 and self.song().set_or_delete_cue()

    def _do_toggle_prev_cue(self, value):
        if not value in range(128):
            raise AssertionError
            value > 0 and self.song().jump_to_prev_cue()

    def _do_toggle_next_cue(self, value):
        if not value in range(128):
            raise AssertionError
            value > 0 and self.song().jump_to_next_cue()

    def notify_track_scroll(self):
        if self._mode == CONTROL_MODE:
            self._scenematrix.eval_matrix()
            self._scenematrix.fire_values()

    def _do_toggle_send(self, value):
        nr_of_tracks = len(self.song().return_tracks)
        if value == 0 or nr_of_tracks < 1:
            return
        prev = self.send_slider_index
        self.send_slider_index += 1
        if self.send_slider_index >= nr_of_tracks:
            self.send_slider_index = 0
        self.show_message(' Set Send ' + str(SENDS[self.send_slider_index]))
        if prev != self.send_slider_index:
            for track in range(8):
                strip = self._mixer.channel_strip(track)
                slider_list = []
                for index in range(self.send_slider_index + 1):
                    if index < self.send_slider_index - 1:
                        slider_list.append(None)
                    else:
                        slider_list.append(self.send_sliders[track])
                    strip.set_send_controls(tuple(slider_list))

    def handle_sysex(self, midi_bytes):
        pass

    def _handle_device_changed(self, device):
        self._scenematrix.update_on_device(device)

    def _hande_device_parm_changed(self):
        self._scenematrix.update_on_device_parm_changed()

    def remove_listener(self, control, callback):
        if control != None and control.value_has_listener(callback):
            control.remove_value_listener(callback)
        control.disconnect()

    def current_scale_to_display(self):
        scale = SCALES[self.current_scale_index]
        text = scale.name + ' ' + BASE_NOTE[self._base_note] + str(scale.to_octave(self._octave))
        self.send_to_display(text)

    def send_to_display(self, text, grid = 0):
        if USE_DISPLAY == False:
            return
        if len(text) > 28:
            text = text[:27]
        msgsysex = [240,
         0,
         0,
         102,
         23,
         18,
         min(grid, 3) * 28]
        filled = text.ljust(28)
        for c in filled:
            msgsysex.append(ord(c))

        msgsysex.append(247)
        self._send_midi(tuple(msgsysex))

    def disconnect(self):
        self._active = False
        self.send_to_display('', 0)
        self.send_to_display('', 1)
        self.send_to_display('', 2)
        self.send_to_display('', 3)
        self.set_suppress_rebuild_requests(True)
        self._scenematrix.disconnect()
        self._master_knob.disconnect()
        self.xfadeKnob.disconnect()
        self.remove_listener(self.tap_button, self._do_tap_tempo)
        self.remove_listener(self.cue_add_delete_button, self._do_toggle_cue)
        self.remove_listener(self.cue_prev_button, self._do_toggle_prev_cue)
        self.remove_listener(self.cue_next_button, self._do_toggle_next_cue)
        self.remove_listener(self.send_slider_toggle_button, self._do_toggle_send)
        self.remove_listener(self.recordQuantSlider, self._on_rec_quant)
        self.remove_listener(self._undo_button, self._do_undo)
        self.remove_listener(self._redo_button, self._do_redo)
        self.remove_listener(self._armsolomode_button, self._do_armsolo_mode)
        self.remove_listener(self._navigate_button, self._do_navigate)
        self.remove_listener(self._fire_button, self._do_mute_fire_button)
        self.remove_listener(self._mode_base_button, self._do_pad_mode_base)
        self.remove_listener(self._mode_octave_button, self._do_pad_mode_octave)
        self.remove_listener(self._pad_scale_up, self._do_pad_note_up)
        self.remove_listener(self._pad_scale_down, self._do_pad_note_down)
        self.remove_listener(self._device_nav_button_left, self._nav_value_left)
        self.remove_listener(self._device_nav_button_right, self._nav_value_right)
        self.remove_listener(self.xfade_assign_button, self._do_xfade_assign)
        self.remove_listener(self.track_left_button, self._a_trk_left)
        self.remove_listener(self.track_right_button, self._a_trk_right)
        self.remove_listener(self.display_update_button, self._a_display_update)
        self.remove_listener(self.scene_mode_button, self._a_mode_scene)
        self.remove_listener(self.clip_mode_button, self._a_mode_clip)
        self.remove_listener(self.pad_mode_button, self._a_mode_pad)
        self.remove_listener(self.control_mode_button, self._a_mode_control)
        self.remove_listener(self._pad_solo_button, self._do_pad_solo_multi)
        self.remove_listener(self._mute_button, self._do_mute_button)
        self.remove_listener(self._pad_select_button, self._do_pad_select_multi)
        self.remove_listener(self._group_d_button, self._do_arm)
        self.remove_listener(self._group_h_button, self._do_stop)
        self.remove_listener(self._fire_dedictated_button, self._do_dedictated_fire_button)
        self.xfadeKnob.disconnect()
        self.master_volume.disconnect()
        self.prehear.disconnect()
        self._unregister_timer_callback(self._on_timer)
        self._device.disconnect()
        self._mixer.disconnect()
        self.global_translation_selector.disconnect()
        ControlSurface.disconnect(self)
        self.song().view.remove_detail_clip_listener(self.clip_handle)
        self.song().remove_visible_tracks_listener(self.clip_handle)
        self.song().remove_scenes_listener(self.clip_handle)
        self.application().view.remove_view_focus_changed_listener(self.focus_changed)
        self._button_sequence = None
        self._matrix = None
        self._device = None
        self._bmatrix = None
        self.time_callback = None
        self._device_nav_button_left = None
        self._device_nav_button_right = None
        self.global_translation_selector = None
        self.send_sliders = None
        self.send_slider_toggle_button = None
        self.timer_repeat = None
        self._scenematrix = None
        self._device = None
########NEW FILE########
__FILENAME__ = MaschineDeviceComponent
#Embedded file name: C:\ProgramData\Ableton\Live 8\Resources\MIDI Remote Scripts\Maschine_Mk1\MaschineDeviceComponent.py
import Live
from _Generic.Devices import *
from _Framework.DeviceComponent import DeviceComponent
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.EncoderElement import EncoderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.DisplayDataSource import DisplayDataSource

class MaschineDeviceComponent(DeviceComponent):
    """ Class representing a device in Live """

    def __init__(self, surface):
        DeviceComponent.__init__(self)
        self.surface = surface
        self.device_listener = None
        self.device_parm_listener = None

    def set_device(self, device):
        DeviceComponent.set_device(self, device)
        if self.device_listener != None:
            self.device_listener(device)

    def _on_parameters_changed(self):
        DeviceComponent._on_parameters_changed(self)
        if self.device_parm_listener != None:
            self.device_parm_listener()

    def set_device_changed_listener(self, listener):
        self.device_listener = listener

    def set_device_parm_listener(self, listener):
        self.device_parm_listener = listener

    def disconnect(self):
        DeviceComponent.disconnect(self)
        self.surface = None
        self.device_listener = None
        self.device_parm_listener = None
########NEW FILE########
__FILENAME__ = MaschineSessionComponent
#Embedded file name: C:\ProgramData\Ableton\Live 8\Resources\MIDI Remote Scripts\Maschine_Mk1\MaschineSessionComponent.py
import Live
from MIDI_Map import *
from _Framework.InputControlElement import *
from _Framework.ButtonElement import *
from _Framework.SessionComponent import *

class MaschineSessionComponent(SessionComponent):
    __module__ = __name__
    __doc__ = 'Controller Map for Soft Step Foot Controller'

    def __init__(self, parent):
        SessionComponent.__init__(self, 4, 4)
        self._parent = parent
        self._matrix = None
        self._advance = STEP4
        self._mode_button = None
        self._set_mode_button(ButtonElement(False, MIDI_CC_TYPE, 0, 80))
        self._linkoff = 0

    def _link(self):
        pass

    def get_track_offset(self):
        return self._track_offset + self._linkoff

    def get_scene_offset(self):
        return self._scene_offset

    def set_matrix(self, matrix):
        self._matrix = matrix

    def _set_mode_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._mode_button != None:
                self._mode_button.remove_value_listener(self._do_matrix_adv_mode)
            self._mode_button = button
            if self._mode_button != None:
                self._mode_button.add_value_listener(self._do_matrix_adv_mode)
            self._advance == STEP4 and self._mode_button.send_value(127)
        else:
            self._mode_button.send_value(0)

    def _do_matrix_adv_mode(self, value):
        if not self._mode_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                self._advance = value != 0 and self._advance == STEP1 and STEP4
                self._mode_button.send_value(127)
            else:
                self._advance = STEP1
                self._mode_button.send_value(0)

    def set_advance(self, val):
        self._advance = val
        if self._advance == STEP4:
            self._mode_button.send_value(127)
        else:
            self._mode_button.send_value(0)

    def update(self):
        SessionComponent.update(self)
        try:
            self._advance
        except AttributeError:
            pass
        else:
            if self._advance == STEP4:
                self._mode_button.send_value(127)
            else:
                self._mode_button.send_value(0)

    def notify_b(self, blink):
        if blink > 5:
            blinkslow = 0
        else:
            blinkslow = 1
        blinkfast = blink % 2
        for scene_index in range(4):
            scene = self.scene(scene_index)
            for track_index in range(4):
                clip_slot = scene.clip_slot(track_index)._clip_slot
                if clip_slot != None and clip_slot.has_clip:
                    button = self._matrix[scene_index][track_index]
                    if button != None:
                        if clip_slot.clip.is_triggered:
                            button.send_value(blinkfast * 1)
                        elif clip_slot.clip.is_playing:
                            button.send_value(blinkslow * 1)
                elif clip_slot != None:
                    button = self._matrix[scene_index][track_index]
                    if button != None:
                        if clip_slot.is_triggered:
                            button.send_value(blinkfast * 1)
                        elif clip_slot.is_playing:
                            button.send_value(blinkslow * 1)

    def _bank_up_value(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._bank_up_button != None:
                raise AssertionError
                if self.is_enabled():
                    button_is_momentary = self._bank_up_button.is_momentary()
                    if button_is_momentary:
                        self._scroll_up_ticks_delay = value != 0 and INITIAL_SCROLLING_DELAY
                    else:
                        self._scroll_up_ticks_delay = -1
                not self._is_scrolling() and (value is not 0 or not button_is_momentary) and self.set_offsets(self._track_offset, self._scene_offset + self._advance)

    def bank_down(self):
        if self.is_enabled():
            newoff = max(0, self._scene_offset - 1)
            self.set_offsets(self._track_offset, newoff)

    def bank_up(self):
        if self.is_enabled():
            self.set_offsets(self._track_offset, self._scene_offset + 1)

    def bank_left(self):
        if self.is_enabled():
            self.set_offsets(max(0, self._track_offset - 1), self._scene_offset)

    def bank_right(self):
        if self.is_enabled():
            self.set_offsets(self._track_offset + 1, self._scene_offset)

    def _bank_down_value(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._bank_down_button != None:
                raise AssertionError
                if self.is_enabled():
                    button_is_momentary = self._bank_down_button.is_momentary()
                    if button_is_momentary:
                        if value != 0:
                            self._scroll_down_ticks_delay = INITIAL_SCROLLING_DELAY
                        else:
                            self._scroll_down_ticks_delay = -1
                    newoff = not self._is_scrolling() and (value is not 0 or not button_is_momentary) and self._scene_offset - self._advance
                    newoff = newoff < 0 and 0
                self.set_offsets(self._track_offset, newoff)

    def _bank_right_value(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._bank_right_button != None:
                raise AssertionError
                if self.is_enabled():
                    button_is_momentary = self._bank_right_button.is_momentary()
                    if button_is_momentary:
                        self._scroll_right_ticks_delay = value != 0 and INITIAL_SCROLLING_DELAY
                    else:
                        self._scroll_right_ticks_delay = -1
                not self._is_scrolling() and (value is not 0 or not button_is_momentary) and self.set_offsets(self._track_offset + self._advance, self._scene_offset)
                self._parent.notify_track_scroll()

    def _bank_left_value(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._bank_left_button != None:
                raise AssertionError
                if self.is_enabled():
                    button_is_momentary = self._bank_left_button.is_momentary()
                    if button_is_momentary:
                        self._scroll_left_ticks_delay = value != 0 and INITIAL_SCROLLING_DELAY
                    else:
                        self._scroll_left_ticks_delay = -1
                not self._is_scrolling() and (value is not 0 or not button_is_momentary) and self.set_offsets(max(0, self._track_offset - self._advance), self._scene_offset)
                self._parent.notify_track_scroll()

    def disconnect(self):
        self._parent.remove_listener(self._mode_button, self._do_matrix_adv_mode)
        self._parent = None
        self._matrix = None
        self._mode_button = None
        SessionComponent.disconnect(self)
########NEW FILE########
__FILENAME__ = MIDI_Map
#Embedded file name: C:\ProgramData\Ableton\Live 8\Resources\MIDI Remote Scripts\Maschine_Mk1\MIDI_Map.py
from PadScale import PadScale
USE_DISPLAY = False
PM_OFF = 0
PM_ON = 1
SCENE_MODE = 1
CLIP_MODE = 2
PAD_MODE = 3
CONTROL_MODE = 4
STEP1 = 1
STEP4 = 4
MODE_PRESS_NONE = 0
MODE_PRESS_SELECT = 1
MODE_PRESS_SOLO = 2
SCENE_MODE_NORMAL = 0
SCENE_MODE_MUTE = 1
SCENE_MODE_SELECT = 2
SCENE_MODE_SOLO = 3
SCENE_MODE_ARM = 4
SCENE_MODE_STOP = 5
SCENE_MODE_CONTROL = 6
SCENE_MODE_XFADE = 7
BASIC_CHANNEL = 3
DEVICE_CC_OFF = 40
DEVICE_BUTTON_CC_OFF = 100
LEVEL_CC_OFF = 10
PAN_CC_OFF = 20
SEND_CC_OFF = 30
STOP_CC_OFF = 50
MUTE_CC_OFF = 80
SOLO_CC_OFF = 90
ARM_CC_OFF = 60
SELECT_CC_OFF = 70
COLOR_OFF = 0
COLOR_ON = 1
COLOR_BLINK = 2
COLOR_FBLINK = 3
CONTROL_LEVEL = 0
CONTROL_PAN = 1
CONTROL_SEND = 2
CONTROL_DEVICE = 3
CLICK_TIME = 500
SHIFT_INC = 4
INIT_SLOT = 10
SENDS = ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P')
BASE_NOTE = ('C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B')
VIEWS_ALL = ('Session', 'Detail/Clip', 'Detail/DeviceChain', 'Browser', 'Arranger')
VIEWS = ('Browser', 'Detail/Clip', 'Detail/DeviceChain', 'Session')
CLIPNOTEMAP = ((24, 25, 26, 27),
 (20, 21, 22, 23),
 (16, 17, 18, 19),
 (12, 13, 14, 15))
SCALES = (PadScale('Chromatic', (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)),
 PadScale('Ionian/Major', (0, 2, 4, 5, 7, 9, 11)),
 PadScale('Aeolian/Minor', (0, 2, 3, 5, 7, 8, 10)),
 PadScale('Pentatonic', (0, 2, 4, 7, 9)),
 PadScale('Pentatonic Minor', (0, 3, 5, 7, 10)),
 PadScale('Dorian (B/g)', (0, 2, 3, 5, 7, 9, 10)),
 PadScale('Phrygian (A-flat/f)', (0, 1, 3, 5, 7, 8, 10)),
 PadScale('Lydian (D/e)', (0, 2, 4, 6, 7, 9, 11)),
 PadScale('Mixolydian (F/d)', (0, 2, 4, 5, 7, 9, 10)),
 PadScale('Locrian (D-flat/b-flat)', (0, 1, 3, 5, 6, 8, 10)),
 PadScale('Diminish', (0, 2, 3, 5, 6, 8, 9, 10, 11)),
 PadScale('Major Blues', (0, 3, 4, 7, 9, 10)),
 PadScale('Minor Blues', (0, 3, 4, 6, 7, 10)),
 PadScale('Whole', (0, 2, 4, 6, 8, 10)),
 PadScale('Arabian', (0, 2, 4, 5, 6, 8, 10)),
 PadScale('Egyptian', (0, 2, 5, 7, 10)),
 PadScale('Gypsi', (0, 2, 3, 6, 7, 8, 11)),
 PadScale('Spanish Scale', (0, 1, 3, 4, 5, 7, 8, 10)),
 PadScale('Raga Bhairav', (0, 1, 4, 5, 7, 8, 11)),
 PadScale('Raga Gamanasrama', (0, 1, 4, 6, 7, 9, 11)),
 PadScale('Rag Todi', (0, 1, 3, 6, 7, 8, 11)),
 PadScale('3rd (C,E,G#)', (0, 4, 8)),
 PadScale('4th (C,F,A#)', (0, 5, 10)),
 PadScale('5th', (0, 7)),
 PadScale('Octave', tuple([0])))
PADCHANNEL = 0
DRUM_PADS = (-1, 12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3)
########NEW FILE########
__FILENAME__ = PadScale
#Embedded file name: C:\ProgramData\Ableton\Live 8\Resources\MIDI Remote Scripts\Maschine_Mk1\PadScale.py


class PadScale:
    __module__ = __name__
    __doc__ = ' scale '

    def __init__(self, name, notevalues):
        isinstance(notevalues, tuple)
        self.name = name
        self.notevalues = notevalues
        scale_len = len(self.notevalues)
        rel_range = 16.0 / scale_len
        self.octave_range = int(10 - rel_range + 0.5)
        if self.octave_range < 0:
            self.octave_range = 0

    def to_octave(self, value):
        if self.octave_range == 0:
            return 0
        return int(value * self.octave_range)

    def to_relative(self, value, prev):
        if self.octave_range == 0:
            return prev
        relvalue = value / float(self.octave_range)
        if relvalue > 1.0:
            return 1.0
        elif relvalue < 0.0:
            return 0.0
        return relvalue
########NEW FILE########
__FILENAME__ = SceneElement
#Embedded file name: C:\ProgramData\Ableton\Live 8\Resources\MIDI Remote Scripts\Maschine_Mk1\SceneElement.py
import Live
import time
from _Framework.ButtonElement import *
from _Framework.CompoundComponent import *
from MIDI_Map import *

class SceneElement:
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, index, matrix):
        self._matrix = matrix
        self._launch_button = None
        self.index = index
        self._scene = None
        self._track = None
        self._pressAction = self._launch_scene
        self.eval = self._eval_scene_states
        self.color = COLOR_OFF

    def set_launch_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if button != self._launch_button:
                if self._launch_button != None:
                    self._launch_button.remove_value_listener(self._launch_value)
                self._launch_button = button
                self._launch_button != None and self._launch_button.add_value_listener(self._launch_value)

    def notify(self, blink):
        if blink > 5:
            blinkslow = 0
        else:
            blinkslow = 1
        blinkfast = blink % 2
        if self.color == COLOR_BLINK:
            self._launch_button.send_value(1 * blinkslow)
        elif self.color == COLOR_FBLINK:
            self._launch_button.send_value(1 * blinkfast)

    def set_value(self):
        if self._launch_button != None:
            if self.color == COLOR_OFF:
                self._launch_button.send_value(0)
            else:
                self._launch_button.send_value(1)

    def force_value(self, value):
        if self._launch_button != None:
            self._launch_button.send_value(value)

    def set_scene(self, scene):
        self._scene = scene

    def set_track(self, track):
        if self._track != None:
            if self._track.can_be_armed:
                self._track.remove_arm_listener(self._got_arm)
            self._track.remove_mute_listener(self._got_mute)
            self._track.remove_solo_listener(self._got_solo)
            self._track.remove_playing_slot_index_listener(self._got_playing)
            self._track.remove_fired_slot_index_listener(self._got_slot_fired)
            if self._track.mixer_device.crossfade_assign_has_listener(self._got_xfade):
                self._track.mixer_device.remove_crossfade_assign_listener(self._got_xfade)
        self._track = track
        if track != None:
            if self._track.can_be_armed:
                self._track.add_arm_listener(self._got_arm)
            self._track.add_mute_listener(self._got_mute)
            self._track.add_solo_listener(self._got_solo)
            self._track.add_playing_slot_index_listener(self._got_playing)
            self._track.mixer_device.add_crossfade_assign_listener(self._got_xfade)
            self._track.add_fired_slot_index_listener(self._got_slot_fired)

    def _got_xfade(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_XFADE:
            self.eval()
            self.set_value()

    def _got_arm(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_ARM:
            self.eval()

    def _got_mute(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_MUTE:
            self.eval()

    def _got_solo(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_SOLO:
            self.eval()

    def _got_playing(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_STOP:
            self._matrix.update()

    def _got_slot_fired(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_STOP:
            self._matrix.update()

    def assign_mode(self, mode):
        if mode == SCENE_MODE_NORMAL:
            self.eval = self._eval_scene_states
        elif mode == SCENE_MODE_CONTROL:
            self.eval = self._eval_control_mode
        elif mode == SCENE_MODE_MUTE:
            self.eval = self._eval_mute
        elif mode == SCENE_MODE_SOLO:
            self.eval = self._eval_solo
        elif mode == SCENE_MODE_SELECT:
            self.eval = self._eval_select
        elif mode == SCENE_MODE_ARM:
            self.eval = self._eval_arm
        elif mode == SCENE_MODE_STOP:
            self.eval = self._eval_stop
        elif mode == SCENE_MODE_XFADE:
            self.eval = self._eval_xfade_assign

    def _eval_xfade_assign(self):
        if self._track != None and self._track.mixer_device != None:
            xfade = self._track.mixer_device.crossfade_assign
            if xfade == 0:
                self.color = COLOR_ON
            elif xfade == 1:
                self.color = COLOR_OFF
            elif xfade == 2:
                self.color = COLOR_BLINK
            self._pressAction = self._switch_xfade_assign
        else:
            self.color = COLOR_OFF
            self._pressAction = self._inaktion

    def _switch_xfade_assign(self, value):
        if self._track != None:
            xfade = (self._track.mixer_device.crossfade_assign + 1) % 3
            if xfade == 0:
                self.color = COLOR_ON
            elif xfade == 1:
                self.color = COLOR_OFF
            elif xfade == 2:
                self.color = COLOR_BLINK
            self._track.mixer_device.crossfade_assign = xfade
            self.set_value()

    def _eval_stop(self):
        self._pressAction = self._stop_track
        if self._track != None:
            clipslots = self._track.clip_slots
            stop_fired = self._track.fired_slot_index == -2
            play_fired = self._track.fired_slot_index >= 0
            clip_playing = False
            has_clip = False
            if clipslots != None:
                for cs_index in range(len(clipslots)):
                    clip_slot = clipslots[cs_index]
                    if clip_slot.has_clip:
                        has_clip = True
                        if clip_slot.clip.is_playing:
                            clip_playing = True
                    elif clip_slot.controls_other_clips:
                        has_clip = True
                        if clip_slot.is_playing:
                            clip_playing = True
                        if clip_slot.is_triggered:
                            play_fired = True
                    elif clip_slot.is_triggered:
                        stop_fired = True

            is_group = self._track.is_foldable
            if stop_fired or play_fired:
                self.color = COLOR_FBLINK
            elif is_group:
                if clip_playing:
                    self.color = COLOR_BLINK
                elif has_clip:
                    self.color = COLOR_ON
                else:
                    self.color = COLOR_OFF
            elif clip_playing:
                self.color = COLOR_BLINK
            elif has_clip:
                self.color = COLOR_ON
            else:
                self.color = COLOR_OFF
        else:
            self.color = COLOR_OFF

    def _eval_arm(self):
        prevcolor = self.color
        self._pressAction = self._arm_track
        if self._track == None:
            self.color = COLOR_OFF
        elif self._track.can_be_armed:
            if self._track.arm:
                self.color = COLOR_ON
            else:
                self.color = COLOR_OFF
        else:
            self.color = COLOR_OFF
        if prevcolor != self.color:
            self.set_value()

    def _eval_mute(self):
        prevcolor = self.color
        self._pressAction = self._mute_track
        if self._track == None:
            self.color = COLOR_OFF
        elif self._track.mute:
            self.color = COLOR_OFF
        else:
            self.color = COLOR_ON
        if prevcolor != self.color:
            self.set_value()

    def _eval_solo(self):
        prevcolor = self.color
        self._pressAction = self._solo_track
        if self._track == None:
            self.color = COLOR_OFF
        elif self._track.solo:
            self.color = COLOR_ON
        else:
            self.color = COLOR_OFF
        if prevcolor != self.color:
            self.set_value()

    def _eval_select(self):
        prevcolor = self.color
        self._pressAction = self._select_track
        if self._track == None:
            self.color = COLOR_OFF
        elif self._track == self._matrix.getSelectedTrack():
            self.color = COLOR_ON
        else:
            self.color = COLOR_OFF
        if prevcolor != self.color:
            self.set_value()

    def _eval_control_mode(self):
        prevcolor = self.color
        if self.index > 7:
            if self._matrix.control_handler.mode == CONTROL_DEVICE:
                parm_index = self._matrix.control_handler.index_parm_id(self.index)
                self._eval_device_buttons(parm_index)
            else:
                track_index = self._matrix.control_handler.index_parm_id(self.index)
                self._eval_mixer_button(track_index)
        elif self.index > 3:
            mode = self.index - 4
            self.color = COLOR_ON
            if mode == self._matrix.control_handler.mode:
                self.color = COLOR_ON
            else:
                self.color = COLOR_OFF
            self._pressAction = self._select_dev_mode
        elif self._matrix.control_handler.mode == CONTROL_SEND:
            self._set_up_control_send()
        elif self._matrix.control_handler.mode == CONTROL_DEVICE:
            self._set_up_device_nav()
        else:
            self.color = COLOR_OFF
            self._pressAction = self._inaktion
        if prevcolor != self.color:
            self.set_value()

    def _eval_device_buttons(self, index):
        valid = True
        if self._matrix.control_handler.selected_device == None:
            valid = False
        elif index >= self._matrix.control_handler.nr_of_parms_in_bank():
            valid = False
        if valid:
            if index == 0 and self._matrix.control_handler.selected_bank == 0:
                self.color = COLOR_OFF
            else:
                self.color = COLOR_ON
            if index == self._matrix.control_handler.selected_device_parm_index:
                self.color = COLOR_BLINK
            else:
                self.color = COLOR_ON
            self._pressAction = self._select_knob_assign_device
        else:
            self.color = COLOR_OFF
            self._pressAction = self._inaktion

    def _eval_mixer_button(self, index):
        track = self._matrix._control._mixer._channel_strips[index]._track
        if track == None:
            self.color = COLOR_OFF
            self._pressAction = self._inaktion
        else:
            if index == self._matrix.control_handler.sel_track_parm_index:
                self.color = COLOR_ON
            else:
                self.color = COLOR_OFF
            self._pressAction = self._select_knob_assign

    def _set_up_device_nav(self):
        if self.index == 0:
            self.color = COLOR_ON
            self._pressAction = self._nav_device_left
        elif self.index == 1:
            self.color = COLOR_ON
            self._pressAction = self._nav_device_right
        elif self.index == 2:
            self._pressAction = self._nav_bank_left
            if self._matrix.control_handler.selected_bank == 0:
                self.color = COLOR_OFF
            else:
                self.color = COLOR_ON
        elif self.index == 3:
            self._pressAction = self._nav_bank_right
            if self._matrix.control_handler.selected_bank < self._matrix.control_handler.nr_of_banks() - 1:
                self.color = COLOR_ON
            else:
                self.color = COLOR_OFF

    def _nav_device_left(self, value):
        if value > 0:
            self._matrix._control._nav_value_left(1)

    def _nav_device_right(self, value):
        if value > 0:
            self._matrix._control._nav_value_right(1)

    def _nav_bank_left(self, value):
        if value > 0 and self._matrix.control_handler.dec_bank_nr():
            self._matrix.update_on_device_parm_changed()

    def _nav_bank_right(self, value):
        if value > 0 and self._matrix.control_handler.inc_bank_nr():
            self._matrix.update_on_device_parm_changed()

    def disable_color(self):
        self.color = COLOR_OFF

    def _set_up_control_send(self):
        nr_of_tracks = len(self._matrix._control.song().return_tracks)
        if self.index < nr_of_tracks:
            if nr_of_tracks > 3 and self.index == 3:
                self.color = COLOR_ON
            if self.index == self._matrix.control_handler.selected_sends_index:
                self.color = COLOR_BLINK
            elif self.index == 3 and self._matrix.control_handler.selected_sends_index >= 3:
                self.color = COLOR_BLINK
            else:
                self.color = COLOR_OFF
            self._pressAction = self._select_sub_sends
        else:
            self.color = COLOR_OFF
            self._pressAction = self._inaktion

    def _select_sub_sends(self, value):
        self._matrix._control._master_knob.switch_to_matrix_mode()
        nr_of_tracks = len(self._matrix._control.song().return_tracks)
        new_index = self.index
        fire = False
        if self.index == 3:
            fire = True
            if self._matrix.control_handler.selected_sends_index < 3:
                new_index = 3
            elif self._matrix.control_handler.selected_sends_index < nr_of_tracks - 1:
                new_index = self._matrix.control_handler.selected_sends_index + 1
            else:
                new_index = 3
        self._matrix.control_handler.selected_sends_index = new_index
        self._matrix.control_handler.message_current_parm()
        self._matrix.control_handler.reassign_mix_parm()
        self._matrix.eval_matrix()
        if fire:
            self.set_value()

    def _select_knob_assign(self, value):
        self._matrix._control._master_knob.switch_to_matrix_mode()
        ip = self._matrix.control_handler.index_parm_id(self.index)
        track = self._matrix._control._mixer._channel_strips[ip]._track
        if self._matrix.control_handler.assign_mix_parm(track, ip):
            self._matrix.eval_matrix()
            self._matrix.control_handler.message_current_parm()

    def _select_knob_assign_device(self, value):
        self._matrix._control._master_knob.switch_to_matrix_mode()
        ip = self._matrix.control_handler.index_parm_id(self.index)
        if self._matrix.control_handler.assign_device_parm(ip):
            self._matrix.eval_matrix()

    def _select_dev_mode(self, value):
        self._matrix._control._master_knob.switch_to_matrix_mode()
        mode_index = self._matrix.control_handler.index_mode_id(self.index)
        if mode_index == CONTROL_DEVICE:
            device = self._matrix._control._device._device
            if device != None:
                self._matrix.control_handler.mode = mode_index
                self._matrix.control_handler.selected_device = device
                self._matrix._control.show_message('Control Device: ' + str(device.name))
                self._matrix.control_handler.reassign_device_parm()
                self._update_matrix()
        elif mode_index != self._matrix.control_handler.mode:
            self._matrix.control_handler.mode = mode_index
            self._matrix.control_handler.reassign_mix_parm()
            self._update_matrix()
            self._matrix.control_handler.message_current_parm()

    def _update_matrix(self):
        self._matrix.eval_matrix()
        self._matrix.fire_values()

    def _inaktion(self, value):
        pass

    def _eval_scene_states(self):
        prevcolor = self.color
        self._pressAction = self._launch_scene
        if self._scene == None:
            self.color = COLOR_OFF
        else:
            clip_slots = self._scene.clip_slots
            count = 0
            playcount = 0
            if self._scene.is_triggered:
                self.color = COLOR_FBLINK
            else:
                for cs_index in range(len(clip_slots)):
                    clip_slot = clip_slots[cs_index]
                    if clip_slot.has_clip:
                        count = count + 1
                        if clip_slot.clip.is_playing:
                            playcount = playcount + 1

                if playcount > 0:
                    self.color = COLOR_BLINK
                elif count > 0:
                    self.color = COLOR_ON
                else:
                    self.color = COLOR_OFF
        if prevcolor != self.color:
            self.set_value()

    def unbind(self):
        if self._launch_button != None and self._track != None:
            if self._track.can_be_armed:
                self._track.remove_arm_listener(self._got_arm)
            self._track.remove_mute_listener(self._got_mute)
            self._track.remove_solo_listener(self._got_solo)
            self._track.remove_playing_slot_index_listener(self._got_playing)
            self._track.mixer_device.remove_crossfade_assign_listener(self._got_xfade)
            self._track.remove_fired_slot_index_listener(self._got_slot_fired)
        self._launch_button = None
        self._scene = None

    def disconnect(self):
        if self._launch_button != None and self._launch_button.value_has_listener(self._launch_value):
            self._launch_button.remove_value_listener(self._launch_value)

    def _launch_value(self, value):
        raise self._launch_button != None or AssertionError
        raise self._pressAction != None or AssertionError
        raise value in range(128) or AssertionError
        self._pressAction(value)

    def _launch_scene(self, value):
        if not value in range(128):
            raise AssertionError
            if self._scene != None:
                pass
            self._launch_button.is_momentary() and self._scene.set_fire_button_state(value != 0)
        elif value != 0:
            self._scene.fire()

    def _mute_track(self, value):
        if self._track != None:
            if self._track.mute:
                self._track.mute = False
                self.color = COLOR_ON
                self._launch_button.send_value(1)
            else:
                self._track.mute = True
                self.color = COLOR_OFF
                self._launch_button.send_value(0)

    def _arm_track(self, value):
        if self._track != None and self._track.can_be_armed:
            if self._track.arm:
                self._track.arm = False
                self.color = COLOR_OFF
                self._launch_button.send_value(0)
            else:
                self._track.arm = True
                self.color = COLOR_ON
                self._launch_button.send_value(1)
            self._matrix.do_arm(self.index)

    def _stop_track(self, value):
        if self._track != None:
            self._track.stop_all_clips()

    def _solo_track(self, value):
        if self._track != None:
            if self._track.solo:
                self._track.solo = False
                self.color = COLOR_OFF
                self._launch_button.send_value(0)
            else:
                self._track.solo = True
                self.color = COLOR_ON
                self._launch_button.send_value(1)
            self._matrix.do_solo(self.index)

    def _select_track(self, value):
        if self._track != None:
            self._matrix.setSelectedTrack(self._track)

    def debug(self, message):
        self._matrix._control.log_message(message)
########NEW FILE########
__FILENAME__ = SceneMatrix
#Embedded file name: C:\ProgramData\Ableton\Live 8\Resources\MIDI Remote Scripts\Maschine_Mk1\SceneMatrix.py
import Live
from _Framework.ButtonElement import *
from _Framework.CompoundComponent import *
from MIDI_Map import *
from SceneElement import SceneElement
from ControlHandler import ControlHandler
from MainKnobControl import *

class SceneMatrix:
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, ctrl):
        self.track_offset = 0
        self.scene_offset = 0
        self._scenes = []
        self._control = ctrl
        self.mode = SCENE_MODE_NORMAL
        self.receives_notify = True
        self.control_handler = ControlHandler(ctrl, self)
        self.soloexclusive = True
        self.mutedsolo = False
        for index in range(16):
            self._scenes.append(SceneElement(index, self))

        self._control.song().view.add_selected_track_listener(self._sel_track_changed)
        self.active = False

    def notify_scene_mode(self, blinkstate):
        if self.receives_notify and self.active:
            num_scenes = len(self._scenes)
            for index in range(num_scenes):
                self._scenes[index].eval()
                self._scenes[index].notify(blinkstate)

    def mod_track_offset(self, delta):
        nr_of_tracks = len(self._control.song().tracks)
        newoffset = self.track_offset + delta * 16
        if newoffset > -1 and newoffset < nr_of_tracks:
            self.track_offset = newoffset
            self.show_track_control_message(nr_of_tracks)
            self.update()

    def mod_scene_offset(self, delta):
        scenes = self._control.song().scenes
        nr_of_scenes = len(scenes)
        newoffset = self.scene_offset + delta
        if newoffset > -1 and newoffset + 15 < nr_of_scenes:
            self.scene_offset = newoffset
            self.show_scene_control_message(nr_of_scenes)
            self.update()

    def show_scene_control_message(self, nr_of_scenes):
        self._control.show_message('Pads control Scenes ' + str(self.scene_offset + 1) + ' to ' + str(min(nr_of_scenes, self.scene_offset + 16)) + ' in Scene Mode')

    def show_track_control_message(self, nr_of_tracks):
        self._control.show_message('Pads control Tracks ' + str(self.track_offset + 1) + ' to ' + str(min(nr_of_tracks, self.track_offset + 16)))

    def _sel_track_changed(self):
        if self.mode == SCENE_MODE_SELECT:
            self.update()

    def in_main_mode(self):
        if self.mode == SCENE_MODE_NORMAL or self.mode == SCENE_MODE_CONTROL:
            return True
        return False

    def get_element(self, col, row):
        index = (3 - col) * 4 + row
        return self._scenes[index]

    def set_knob_mode(self, mode):
        self._control._master_knob._set_mode(KN2_MODE_GENERAL)

    def set_armsolo_exclusive(self, button):
        if self.soloexclusive:
            self.soloexclusive = False
            self._control.show_message(str('Exclusive Mode Arm/Solo Off'))
            button.send_value(0)
        else:
            self.soloexclusive = True
            self._control.show_message(str('Exclusive Mode Arm/Solo On'))
            button.send_value(100)

    def unbind(self):
        self._control.song().view.remove_selected_track_listener(self._sel_track_changed)
        num_scenes = len(self._scenes)
        for index in range(num_scenes):
            self._scenes[index].disable_color()
            self._scenes[index].force_value(0)
            self._scenes[index].unbind()

    def deassign(self):
        num_scenes = len(self._scenes)
        for index in range(num_scenes):
            self._scenes[index].set_launch_button(None)
            self._scenes[index].set_scene(None)
            self._scenes[index].set_track(None)
            self._scenes[index].eval()

    def assign(self):
        scenes = self._control.song().scenes
        tracks = self._control.song().tracks
        for index in range(16):
            tr_index = index + self.track_offset
            sc_index = index + self.scene_offset
            self._scenes[index].set_launch_button(self._control._button_sequence[index])
            if sc_index < len(scenes):
                self._scenes[index].set_scene(scenes[sc_index])
            else:
                self._scenes[index].set_scene(None)
            if tr_index < len(tracks):
                self._scenes[index].set_track(tracks[tr_index])
            else:
                self._scenes[index].set_track(None)
            self._scenes[index].eval()

    def set_mode(self, mode):
        self.mode = mode
        if self.mode == SCENE_MODE_NORMAL or self.mode == SCENE_MODE_STOP or self.mode == SCENE_MODE_CONTROL or self.mode == SCENE_MODE_XFADE:
            self.receives_notify = True
        else:
            self.receives_notify = False
        num_scenes = len(self._scenes)
        for index in range(num_scenes):
            self._scenes[index].assign_mode(mode)

        if mode == SCENE_MODE_CONTROL and self.control_handler.parm == None:
            trindex = self.control_handler.sel_track_parm_index
            track = self._control._mixer._channel_strips[trindex]._track
            if track != None:
                self.control_handler.track = track
                self.control_handler.reassign_mix_parm()
        self.update()

    def set_active(self, active):
        self.active = active

    def do_solo(self, track_index):
        if self.soloexclusive:
            tracks = self._control.song().tracks
            for index in range(len(tracks)):
                if index != track_index and tracks[index].solo:
                    tracks[index].solo = False

    def do_arm(self, track_index):
        if self.soloexclusive:
            tracks = self._control.song().tracks
            for index in range(len(tracks)):
                if index != track_index and tracks[index].can_be_armed and tracks[index].arm:
                    tracks[index].arm = False

    def eval_matrix(self):
        for index in range(16):
            self._scenes[index].eval()

    def fire_values(self):
        for index in range(16):
            self._scenes[index].set_value()

    def eval_control(self):
        nr_of_tracks = len(self._control.song().return_tracks)
        if self.control_handler.selected_sends_index >= nr_of_tracks:
            self.control_handler.selected_sends_index = nr_of_tracks - 1

    def setSelectedTrack(self, track):
        self._control.song().view.selected_track = track

    def getSelectedTrack(self):
        return self._control.song().view.selected_track

    def update_on_device(self, device):
        if self.mode == SCENE_MODE_CONTROL and self.control_handler.mode == CONTROL_DEVICE:
            self.control_handler.set_device(device)
            self.update()

    def update_on_device_parm_changed(self):
        if self.mode == SCENE_MODE_CONTROL and self.control_handler.mode == CONTROL_DEVICE:
            self.update()

    def disconnect(self):
        num_scenes = len(self._scenes)
        for index in range(num_scenes):
            self._scenes[index].disconnect()

        self.unbind()
        self._scenes = None
        self._control = None
        self.mode = None
        self.receives_notify = None
        self.control_handler.disconnect()
        self.soloexclusive = None
        self.mutedsolo = None

    def fix_track_offset(self, nr_of_tracks):
        while self.track_offset >= nr_of_tracks:
            self.track_offset -= 16

        self.show_track_control_message(nr_of_tracks)

    def fix_scene_offset(self, nr_of_scenes):
        while self.scene_offset + 15 >= nr_of_scenes and self.scene_offset > 0:
            self.scene_offset -= 1

        self.show_scene_control_message(nr_of_scenes)

    def update(self):
        if not self.active:
            return
        scenes = self._control.song().scenes
        tracks = self._control.song().tracks
        nr_of_tracks = len(tracks)
        nr_of_scenes = len(scenes)
        if self.track_offset < 0:
            self.track_offset = 0
        elif self.track_offset >= nr_of_tracks:
            self.fix_track_offset(nr_of_tracks)
        if self.scene_offset < 0:
            self.scene_offset = 0
        elif self.scene_offset + 15 >= nr_of_scenes:
            self.fix_scene_offset(nr_of_scenes)
        self.eval_control()
        for index in range(16):
            tr_index = index + self.track_offset
            sc_index = index + self.scene_offset
            if sc_index < nr_of_scenes:
                self._scenes[index].set_scene(scenes[sc_index])
            else:
                self._scenes[index].set_scene(None)
            if tr_index < nr_of_tracks:
                self._scenes[index].set_track(tracks[tr_index])
            else:
                self._scenes[index].set_track(None)
            self._scenes[index].eval()
            self._scenes[index].set_value()
########NEW FILE########
__FILENAME__ = VarButtonElement
#Embedded file name: C:\ProgramData\Ableton\Live 8\Resources\MIDI Remote Scripts\Maschine_Mk1\VarButtonElement.py
import Live
import time
from _Framework.ButtonElement import *
from MIDI_Map import *

class VarButtonElement(ButtonElement):
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, is_momentary, channel, scene_index, track_index, parent):
        ButtonElement.__init__(self, is_momentary, MIDI_NOTE_TYPE, channel, CLIPNOTEMAP[scene_index][track_index])
        self._is_enabled = True
        self._is_notifying = False
        self.surface = parent
        self._report_input = False
        self._scene_index = scene_index
        self._track_index = track_index

    def get_identifier(self):
        return self._msg_identifier

    def turn_off(self):
        self.send_value(0)

    def turn_on(self):
        self.send_value(1)

    def message_map_mode(self):
        raise self.message_type() is MIDI_CC_TYPE or AssertionError
        return Live.MidiMap.MapMode.absolute

    def set_enabled(self, enabled):
        self._is_enabled = enabled

    def set_send_note(self, note):
        if note in range(128):
            self._msg_identifier = note
            if not self._is_enabled:
                self._install_translation(self._msg_type, self._original_identifier, self._original_channel, self._msg_identifier, self._msg_channel)

    def receive_value(self, value):
        if self._is_enabled:
            ButtonElement.receive_value(self, value)

    def set_to_notemode(self, notemode):
        self._is_enabled = not notemode
        if notemode:
            self._install_translation(self._msg_type, self._original_identifier, self._original_channel, self._msg_identifier, self._msg_channel)

    def disconnect(self):
        ButtonElement.disconnect(self)
        self._is_enabled = None
        self._is_notifying = None
        self.surface = None
        self._report_input = None
        self._scene_index = None
        self._track_index = None


class TwinButton(ButtonElement):
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, is_momentary, channel, partner):
        raise isinstance(partner, VarButtonElement) or AssertionError
        ButtonElement.__init__(self, is_momentary, MIDI_NOTE_TYPE, channel, partner._original_identifier)
        self._partner = partner

    def fire(self, value):
        self._partner.send_value(value, True)


class ColorButton(ButtonElement):
    __module__ = __name__
    __doc__ = ' Special button class that dealwith Colors '

    def __init__(self, is_momentary, midi_type, identifier):
        ButtonElement.__init__(self, is_momentary, midi_type, 0, identifier)
        self.hue = 2
        self.sat = 127
        self.bright = 127
        self._msg_identifier = identifier

    def send_value(self, value, force_send = False):
        if not value != None:
            raise AssertionError
            raise isinstance(value, int) or AssertionError
            if not value in range(128):
                raise AssertionError
                (force_send or self._is_being_forwarded) and self.send_color(value)
                self._last_sent_value = value
                is_input = self._report_output and True
                self._report_value(value, not is_input)

    def send_hue(self, hue):
        data_byte1 = self._original_identifier
        self.hue = hue
        self.send_midi((MIDI_CC_STATUS + 0, data_byte1, hue))

    def send_bright(self, brightness):
        data_byte1 = self._original_identifier
        self.bright = brightness
        self.send_midi((MIDI_CC_STATUS + 0, data_byte1, brightness))

    def send_color(self, value):
        data_byte1 = self._original_identifier
        self.send_midi((MIDI_CC_STATUS + 2, data_byte1, self.bright))
        self.send_midi((MIDI_CC_STATUS + 1, data_byte1, self.sat))
        self.send_midi((MIDI_CC_STATUS + 0, data_byte1, self.hue))

    def disconnect(self):
        ButtonElement.disconnect(self)
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launchkey/consts.py
SIZE_QUERY = (240, 126, 127, 6, 1, 247)
SIZE_RESPONSE = (240, 126, 127, 6, 2, 0, 32, 41, 0, 25, 0)
LIVE_MODE_ON = (144, 12, 127)
LIVE_MODE_OFF = (144, 12, 0)
PAD_TRANSLATIONS = ((0, 0, 48, 9),
 (1, 0, 49, 9),
 (2, 0, 50, 9),
 (3, 0, 51, 9),
 (0, 1, 44, 9),
 (1, 1, 45, 9),
 (2, 1, 46, 9),
 (3, 1, 47, 9),
 (0, 2, 40, 9),
 (1, 2, 41, 9),
 (2, 2, 42, 9),
 (3, 2, 43, 9),
 (0, 3, 36, 9),
 (1, 3, 37, 9),
 (2, 3, 38, 9),
 (3, 3, 39, 9))
LED_FLASHING_ON = (176, 0, 40)
LED_FLASHING_OFF = (176, 0, 32)
LED_OFF = 4
RED_FULL = 15
RED_BLINK = 11
GREEN_FULL = 60
GREEN_BLINK = 56
AMBER_FULL = 63
AMBER_HALF = 29
AMBER_BLINK = 59
########NEW FILE########
__FILENAME__ = Launchkey
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launchkey/Launchkey.py
from __future__ import with_statement
import Live
from _Framework.ControlSurface import ControlSurface
from _Framework.InputControlElement import InputControlElement, MIDI_CC_TYPE, MIDI_NOTE_TYPE
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import EncoderElement
from _Framework.DeviceComponent import DeviceComponent
from _Framework.TransportComponent import TransportComponent
from Launchpad.ConfigurableButtonElement import ConfigurableButtonElement
from SessionNavigationComponent import SessionNavigationComponent
from TransportViewModeSelector import TransportViewModeSelector
from SpecialMixerComponent import SpecialMixerComponent
from SpecialSessionComponent import SpecialSessionComponent
from consts import *
IS_MOMENTARY = True

def make_button(cc_no, name):
    button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, cc_no)
    button.name = name
    return button


def make_configurable_button(cc_no, name, type = MIDI_NOTE_TYPE, channel = 0):
    button = ConfigurableButtonElement(IS_MOMENTARY, type, channel, cc_no)
    button.name = name
    return button


def make_encoder(cc_no, name):
    encoder = EncoderElement(MIDI_CC_TYPE, 0, cc_no, Live.MidiMap.MapMode.absolute)
    encoder.set_feedback_delay(-1)
    encoder.name = name
    return encoder


def make_slider(cc_no, name):
    slider = SliderElement(MIDI_CC_TYPE, 0, cc_no)
    slider.set_feedback_delay(-1)
    slider.name = name
    return slider


class LaunchkeyControlFactory(object):

    def create_next_track_button(self):
        return make_button(103, 'Next_Track_Button')

    def create_prev_track_button(self):
        return make_button(102, 'Prev_Track_Button')

    def create_scene_launch_button(self):
        return make_configurable_button(104, 'Scene_Launch_Button')

    def create_scene_stop_button(self):
        return make_configurable_button(120, 'Scene_Stop_Button')

    def create_clip_launch_button(self, index):
        return make_configurable_button(96 + index, 'Clip_Launch_%d' % index)

    def create_clip_stop_button(self, index):
        return make_configurable_button(112 + index, 'Clip_Stop_%d' % index)


class Launchkey(ControlSurface):
    """ Script for Novation's Launchkey 25/49/61 keyboards """

    def __init__(self, c_instance, control_factory = LaunchkeyControlFactory(), identity_response = SIZE_RESPONSE):
        ControlSurface.__init__(self, c_instance)
        self._control_factory = control_factory
        self._identity_response = identity_response
        with self.component_guard():
            self.set_pad_translations(PAD_TRANSLATIONS)
            self._device_selection_follows_track_selection = True
            self._suggested_input_port = 'Launchkey InControl'
            self._suggested_output_port = 'Launchkey InControl'
            self._has_sliders = True
            self._current_midi_map = None
            self._master_slider = make_slider(7, 'Master_Volume_Control')
            self._modes_buttons = []
            for index in range(3):
                button = ButtonElement(IS_MOMENTARY, MIDI_NOTE_TYPE, 0, 13 + index)
                self._modes_buttons.append(button)
                self._modes_buttons[-1].add_value_listener(self._dummy_listener)

            self._setup_mixer()
            self._setup_session()
            self._setup_transport()
            self._setup_device()
            self._setup_navigation()
            for component in self.components:
                component.set_enabled(False)

    def refresh_state(self):
        ControlSurface.refresh_state(self)
        self.schedule_message(2, self._send_midi, LIVE_MODE_ON)
        self.schedule_message(3, self._send_midi, SIZE_QUERY)

    def handle_sysex(self, midi_bytes):
        if midi_bytes[0:11] == self._identity_response:
            self._has_sliders = midi_bytes[11] != 48
            self._send_midi(LED_FLASHING_ON)
            self._update_mixer_offset()
            for control in self.controls:
                if isinstance(control, InputControlElement):
                    control.clear_send_cache()

            for component in self.components:
                component.set_enabled(True)

            if self._has_sliders:
                self._mixer.master_strip().set_volume_control(self._master_slider)
                self._mixer.update()
            else:
                self._mixer.master_strip().set_volume_control(None)
                for index in range(len(self._sliders)):
                    self._mixer.channel_strip(index).set_volume_control(None)
                    self._mixer.channel_strip(index).set_mute_button(None)
                    slider = self._sliders[index]
                    slider.release_parameter()

                self._mixer.selected_strip().set_volume_control(self._master_slider)
            self.request_rebuild_midi_map()

    def disconnect(self):
        ControlSurface.disconnect(self)
        for button in self._modes_buttons:
            if button.value_has_listener(self._dummy_listener):
                button.remove_value_listener(self._dummy_listener)

        self._modes_buttons = None
        self._encoders = None
        self._sliders = None
        self._strip_buttons = None
        self._master_slider = None
        self._current_midi_map = None
        self._transport_view_modes = None
        self._send_midi(LED_FLASHING_OFF)
        self._send_midi(LIVE_MODE_OFF)

    def build_midi_map(self, midi_map_handle):
        self._current_midi_map = midi_map_handle
        ControlSurface.build_midi_map(self, midi_map_handle)

    def _setup_mixer(self):
        mute_solo_flip_button = make_button(59, 'Master_Button')
        self._mixer = SpecialMixerComponent(8)
        self._mixer.name = 'Mixer'
        self._mixer.selected_strip().name = 'Selected_Channel_Strip'
        self._mixer.master_strip().name = 'Master_Channel_Strip'
        self._mixer.master_strip().set_volume_control(self._master_slider)
        self._sliders = []
        self._strip_buttons = []
        for index in range(8):
            strip = self._mixer.channel_strip(index)
            strip.name = 'Channel_Strip_' + str(index)
            strip.set_invert_mute_feedback(True)
            self._sliders.append(make_slider(41 + index, 'Volume_Control_%d' % index))
            strip.set_volume_control(self._sliders[-1])
            self._strip_buttons.append(make_button(51 + index, 'Mute_Button_%d' % index))

        self._mixer.set_strip_mute_solo_buttons(tuple(self._strip_buttons), mute_solo_flip_button)

    def _setup_session(self):
        scene_launch_button = self._control_factory.create_scene_launch_button()
        scene_stop_button = self._control_factory.create_scene_stop_button()
        self._session = SpecialSessionComponent(8, 0)
        self._session.name = 'Session_Control'
        self._session.selected_scene().name = 'Selected_Scene'
        self._session.selected_scene().set_launch_button(scene_launch_button)
        self._session.selected_scene().set_triggered_value(GREEN_BLINK)
        self._session.set_stop_all_clips_button(scene_stop_button)
        scene_stop_button.set_on_off_values(AMBER_FULL, LED_OFF)
        self._session.set_mixer(self._mixer)
        self._session.set_track_banking_increment(8)
        self._session.set_stop_track_clip_value(GREEN_BLINK)
        clip_launch_buttons = []
        clip_stop_buttons = []
        for index in range(8):
            clip_launch_buttons.append(self._control_factory.create_clip_launch_button(index))
            clip_stop_buttons.append(self._control_factory.create_clip_stop_button(index))
            clip_slot = self._session.selected_scene().clip_slot(index)
            clip_slot.set_triggered_to_play_value(GREEN_BLINK)
            clip_slot.set_triggered_to_record_value(RED_BLINK)
            clip_slot.set_stopped_value(AMBER_FULL)
            clip_slot.set_started_value(GREEN_FULL)
            clip_slot.set_recording_value(RED_FULL)
            clip_slot.set_launch_button(clip_launch_buttons[-1])
            clip_slot.name = 'Selected_Clip_Slot_' + str(index)

        self._session.set_stop_track_clip_buttons(tuple(clip_stop_buttons))

    def _setup_transport(self):
        rwd_button = make_button(112, 'Rwd_Button')
        ffwd_button = make_button(113, 'FFwd_Button')
        stop_button = make_button(114, 'Stop_Button')
        play_button = make_button(115, 'Play_Button')
        loop_button = make_button(116, 'Loop_Button')
        rec_button = make_button(117, 'Record_Button')
        transport = TransportComponent()
        transport.name = 'Transport'
        transport.set_stop_button(stop_button)
        transport.set_play_button(play_button)
        transport.set_record_button(rec_button)
        transport.set_loop_button(loop_button)
        self._transport_view_modes = TransportViewModeSelector(transport, self._session, ffwd_button, rwd_button)
        self._transport_view_modes.name = 'Transport_View_Modes'

    def _setup_device(self):
        encoders = [ make_encoder(21 + index, 'Device_Control_%d' % index) for index in xrange(8) ]
        self._encoders = tuple(encoders)
        device = DeviceComponent()
        device.name = 'Device_Component'
        self.set_device_component(device)
        device.set_parameter_controls(self._encoders)

    def _setup_navigation(self):
        self._next_track_button = self._control_factory.create_next_track_button()
        self._prev_track_button = self._control_factory.create_prev_track_button()
        self._session_navigation = SessionNavigationComponent(name='Session_Navigation')
        self._session_navigation.set_next_track_button(self._next_track_button)
        self._session_navigation.set_prev_track_button(self._prev_track_button)

    def _dummy_listener(self, value):
        pass

    def _on_selected_track_changed(self):
        ControlSurface._on_selected_track_changed(self)
        self._update_mixer_offset()

    def _update_mixer_offset(self):
        all_tracks = self._session.tracks_to_use()
        selected_track = self.song().view.selected_track
        num_strips = self._session.width()
        if selected_track in all_tracks:
            track_index = list(all_tracks).index(selected_track)
            new_offset = track_index - track_index % num_strips
            self._session.set_offsets(new_offset, self._session.scene_offset())
########NEW FILE########
__FILENAME__ = SessionNavigationComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launchkey/SessionNavigationComponent.py
from _Framework.CompoundComponent import CompoundComponent
from _Framework.ScrollComponent import ScrollComponent
from _Framework import Task
from Push.ViewControlComponent import TrackScroller, BasicSceneScroller

def is_recording_clip(tracks, check_arrangement):
    found_recording_clip = False
    for track in tracks:
        if track.can_be_armed and track.arm:
            if check_arrangement:
                found_recording_clip = True
                break
            else:
                playing_slot_index = track.playing_slot_index
                if playing_slot_index in range(len(track.clip_slots)):
                    slot = track.clip_slots[playing_slot_index]
                    if slot.has_clip and slot.clip.is_recording:
                        found_recording_clip = True
                        break

    return found_recording_clip


class ArmingTrackScrollComponent(ScrollComponent):
    """
    ScrollComponent that arms the last visited MIDI track
    """

    def __init__(self, *a, **k):
        super(ArmingTrackScrollComponent, self).__init__(*a, **k)
        self._arming_task = self._tasks.add(Task.sequence(Task.delay(1), self._arm_task))
        self._arming_task.kill()

    def scroll_up(self):
        super(ArmingTrackScrollComponent, self).scroll_up()
        self._start_arming_task()

    def scroll_down(self):
        super(ArmingTrackScrollComponent, self).scroll_down()
        self._start_arming_task()

    def _start_arming_task(self):
        if self._arming_task.is_killed:
            self._arming_task.restart()

    @property
    def is_scrolling(self):
        return not self._scroll_task_up.is_killed or not self._scroll_task_down.is_killed

    def _track_to_arm(self):
        track = self.song().view.selected_track
        can_arm_track = track != None and track.has_midi_input and track.can_be_armed and not track.arm
        return track if can_arm_track else None

    def _try_arm(self):
        track_to_arm = self._track_to_arm()
        if track_to_arm != None:
            song = self.song()
            tracks = song.tracks
            if song.is_playing:
                check_arrangement = song.record_mode
                if is_recording_clip(tracks, check_arrangement) or song.exclusive_arm:
                    for track in tracks:
                        if track.can_be_armed and track != track_to_arm:
                            track.arm = False

                track_to_arm.arm = True
                track_to_arm.view.select_instrument()

    def _arm_task(self, delta):
        result_state = Task.KILLED
        if self.is_enabled():
            if self.is_scrolling:
                result_state = Task.RUNNING
            else:
                self._try_arm()
        return result_state


class SessionNavigationComponent(CompoundComponent):
    """
    Component that controls the session selection 'crosshair'
    """

    def __init__(self, *a, **k):
        super(SessionNavigationComponent, self).__init__(*a, **k)
        self._scroll_tracks, self._scroll_scenes = self.register_components(ArmingTrackScrollComponent(TrackScroller()), ScrollComponent(BasicSceneScroller()))
        song = self.song()
        view = song.view
        self.register_slot(song, self._scroll_tracks.update, 'visible_tracks')
        self.register_slot(song, self._scroll_tracks.update, 'return_tracks')
        self.register_slot(song, self._scroll_scenes.update, 'scenes')
        self.register_slot(view, self._scroll_tracks.update, 'selected_track')
        self.register_slot(view, self._scroll_scenes.update, 'selected_scene')

    def set_next_track_button(self, button):
        self._scroll_tracks.set_scroll_down_button(button)

    def set_prev_track_button(self, button):
        self._scroll_tracks.set_scroll_up_button(button)

    def set_next_scene_button(self, button):
        self._scroll_scenes.set_scroll_down_button(button)

    def set_prev_scene_button(self, button):
        self._scroll_scenes.set_scroll_up_button(button)

    def update(self):
        pass
########NEW FILE########
__FILENAME__ = SpecialMixerComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launchkey/SpecialMixerComponent.py
from _Framework.MixerComponent import MixerComponent

class SpecialMixerComponent(MixerComponent):
    """ Special mixer class that toggles given buttons between mute and solo """

    def __init__(self, num_tracks):
        MixerComponent.__init__(self, num_tracks)
        self._strip_mute_solo_buttons = None
        self._mute_solo_flip_button = None
        self._mute_solo_is_flipped = False

    def disconnect(self):
        MixerComponent.disconnect(self)
        if self._mute_solo_flip_button != None:
            self._mute_solo_flip_button.remove_value_listener(self._mute_solo_flip_value)
            self._mute_solo_flip_button = None
        self._strip_mute_solo_buttons = None

    def tracks_to_use(self):
        return tuple(self.song().visible_tracks) + tuple(self.song().return_tracks)

    def set_strip_mute_solo_buttons(self, buttons, flip_button):
        if self._mute_solo_flip_button != None:
            self._mute_solo_flip_button.remove_value_listener(self._mute_solo_flip_value)
        self._mute_solo_flip_button = flip_button
        if self._mute_solo_flip_button != None:
            self._mute_solo_flip_button.add_value_listener(self._mute_solo_flip_value)
        self._strip_mute_solo_buttons = buttons
        for index in range(len(self._channel_strips)):
            strip = self.channel_strip(index)
            button = None
            if self._strip_mute_solo_buttons != None:
                button = self._strip_mute_solo_buttons[index]
            strip.set_mute_button(button)
            strip.set_solo_button(None)

    def _mute_solo_flip_value(self, value):
        if self._strip_mute_solo_buttons != None:
            if value == 0:
                self._mute_solo_is_flipped = not self._mute_solo_is_flipped
                self._mute_solo_flip_button.turn_on() if self._mute_solo_is_flipped else self._mute_solo_flip_button.turn_off()
                for index in range(len(self._strip_mute_solo_buttons)):
                    strip = self.channel_strip(index)
                    if self._mute_solo_is_flipped:
                        strip.set_mute_button(None)
                        strip.set_solo_button(self._strip_mute_solo_buttons[index])
                    else:
                        strip.set_solo_button(None)
                        strip.set_mute_button(self._strip_mute_solo_buttons[index])
########NEW FILE########
__FILENAME__ = SpecialSessionComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launchkey/SpecialSessionComponent.py
from _Framework.SessionComponent import SessionComponent
from _Framework.Util import in_range, nop
from consts import *

class SpecialSessionComponent(SessionComponent):
    """ Special session subclass that handles ConfigurableButtons """

    def __init__(self, num_tracks, num_scenes):
        self._update_playing_slots = nop
        SessionComponent.__init__(self, num_tracks, num_scenes)
        self._playing_slots_slots = self.register_slot_manager()
        self._update_playing_slots = self._update_playing_slots_impl
        self._update_playing_slots()

    def on_enabled_changed(self):
        SessionComponent.on_enabled_changed(self)
        for index in xrange(len(self._stop_track_clip_buttons or [])):
            self._update_stop_clips_led(index)

    def _reassign_tracks(self):
        super(SpecialSessionComponent, self)._reassign_tracks()
        self._update_playing_slots()

    def _update_playing_slots_impl(self):
        self._playing_slots_slots.disconnect()
        tracks_to_use = self.tracks_to_use()
        for index in range(self._num_tracks):
            playing_listener = lambda index = index: self._on_playing_slot_index_changed(index)
            if self._track_offset + index < len(tracks_to_use):
                track = tracks_to_use[self._track_offset + index]
                if track != None and track in self.song().tracks:
                    self._playing_slots_slots.register_slot(track, playing_listener, 'playing_slot_index')
            playing_listener()
            self._update_stop_clips_led(index)

    def _on_fired_slot_index_changed(self, index):
        self._update_stop_clips_led(index)

    def _on_playing_slot_index_changed(self, index):
        self._update_stop_clips_led(index)

    def _update_stop_clips_led(self, index):
        if self.is_enabled() and self._stop_track_clip_buttons != None:
            button = self._stop_track_clip_buttons[index]
            tracks = self.tracks_to_use()
            track_index = index + self.track_offset()
            if in_range(track_index, 0, len(tracks)):
                track = tracks[track_index]
                is_player_track = track in self.song().tracks
                if is_player_track and track.fired_slot_index == -2:
                    button.send_value(self._stop_track_clip_value)
                elif is_player_track and track.playing_slot_index >= 0:
                    button.send_value(AMBER_HALF)
                else:
                    button.turn_off()
            else:
                button.send_value(LED_OFF)
########NEW FILE########
__FILENAME__ = TransportViewModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launchkey/TransportViewModeSelector.py
from _Framework.ModeSelectorComponent import ModeSelectorComponent

class TransportViewModeSelector(ModeSelectorComponent):
    """ Class that reassigns specific buttons based on the views visible in Live """

    def __init__(self, transport, session, ffwd_button, rwd_button):
        ModeSelectorComponent.__init__(self)
        self._transport = transport
        self._session = session
        self._ffwd_button = ffwd_button
        self._rwd_button = rwd_button
        self._app_view().add_is_view_visible_listener('Session', self._on_view_changed)
        self.update()

    def disconnect(self):
        ModeSelectorComponent.disconnect(self)
        self._transport = None
        self._session = None
        self._ffwd_button = None
        self._rwd_button = None
        self._app_view().remove_is_view_visible_listener('Session', self._on_view_changed)

    def update(self):
        if self.is_enabled():
            if self._mode_index == 0:
                self._transport.set_seek_buttons(self._ffwd_button, self._rwd_button)
                self._session.set_select_buttons(None, None)
            else:
                self._transport.set_seek_buttons(None, None)
                self._session.set_select_buttons(self._ffwd_button, self._rwd_button)

    def _app_view(self):
        return self.application().view

    def _on_view_changed(self):
        if self._app_view().is_view_visible('Session'):
            self._mode_index = 1
        else:
            self._mode_index = 0
        self.update()
########NEW FILE########
__FILENAME__ = LaunchkeyMini
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launchkey_Mini/LaunchkeyMini.py
from Launchkey.Launchkey import Launchkey, LaunchkeyControlFactory, make_button

class LaunchkeyMiniControlFactory(LaunchkeyControlFactory):

    def create_next_track_button(self):
        return make_button(107, 'Next_Track_Button')

    def create_prev_track_button(self):
        return make_button(106, 'Prev_Track_Button')


class LaunchkeyMini(Launchkey):
    """ Script for Novation's Launchkey Mini keyboard """

    def __init__(self, c_instance):
        super(LaunchkeyMini, self).__init__(c_instance, control_factory=LaunchkeyMiniControlFactory(), identity_response=(240, 126, 127, 6, 2, 0, 32, 41, 53, 0, 0))
        self._suggested_input_port = 'LK Mini InControl'
        self._suggested_output_port = 'LK Mini InControl'

    def _setup_navigation(self):
        super(LaunchkeyMini, self)._setup_navigation()
        self._next_scene_button = make_button(105, 'Next_Scene_Button')
        self._prev_scene_button = make_button(104, 'Prev_Scene_Button')
        self._session_navigation.set_next_scene_button(self._next_scene_button)
        self._session_navigation.set_prev_scene_button(self._prev_scene_button)

    def _setup_transport(self):
        pass
########NEW FILE########
__FILENAME__ = ConfigurableButtonElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launchpad/ConfigurableButtonElement.py
import Live
from _Framework.ButtonElement import *

class ConfigurableButtonElement(ButtonElement):
    """ Special button class that can be configured with custom on- and off-values """

    def __init__(self, is_momentary, msg_type, channel, identifier):
        ButtonElement.__init__(self, is_momentary, msg_type, channel, identifier)
        self._on_value = 127
        self._off_value = 4
        self._is_enabled = True
        self._is_notifying = False
        self._force_next_value = False
        self._pending_listeners = []

    def set_on_off_values(self, on_value, off_value):
        raise on_value in range(128) or AssertionError
        raise off_value in range(128) or AssertionError
        self.clear_send_cache()
        self._on_value = on_value
        self._off_value = off_value

    def set_force_next_value(self):
        self._force_next_value = True

    def set_enabled(self, enabled):
        self._is_enabled = enabled

    def turn_on(self):
        self.send_value(self._on_value)

    def turn_off(self):
        self.send_value(self._off_value)

    def reset(self):
        self.send_value(4)

    def add_value_listener(self, callback, identify_sender = False):
        if not self._is_notifying:
            ButtonElement.add_value_listener(self, callback, identify_sender)
        else:
            self._pending_listeners.append((callback, identify_sender))

    def receive_value(self, value):
        self._is_notifying = True
        ButtonElement.receive_value(self, value)
        self._is_notifying = False
        for listener in self._pending_listeners:
            self.add_value_listener(listener[0], listener[1])

        self._pending_listeners = []

    def send_value(self, value, force = False):
        ButtonElement.send_value(self, value, force or self._force_next_value)
        self._force_next_value = False

    def install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback):
        if self._is_enabled:
            ButtonElement.install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback)
        elif self._msg_channel != self._original_channel or self._msg_identifier != self._original_identifier:
            install_translation_callback(self._msg_type, self._original_identifier, self._original_channel, self._msg_identifier, self._msg_channel)
########NEW FILE########
__FILENAME__ = DefChannelStripComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launchpad/DefChannelStripComponent.py
import Live
from _Framework.ChannelStripComponent import ChannelStripComponent
from ConfigurableButtonElement import ConfigurableButtonElement
from itertools import chain

class DefChannelStripComponent(ChannelStripComponent):
    """ Subclass of channel strip component offering defaultbuttons for the timeables """

    def __init__(self):
        ChannelStripComponent.__init__(self)
        self._default_volume_button = None
        self._default_panning_button = None
        self._default_send1_button = None
        self._default_send2_button = None
        self._invert_mute_feedback = True

    def disconnect(self):
        """ releasing references and removing listeners"""
        if self._track != None:
            volume = self._track.mixer_device.volume
            panning = self._track.mixer_device.panning
            sends = self._track.mixer_device.sends
            if volume.value_has_listener(self._on_volume_changed):
                volume.remove_value_listener(self._on_volume_changed)
            if panning.value_has_listener(self._on_panning_changed):
                panning.remove_value_listener(self._on_panning_changed)
            if len(sends) > 0 and sends[0].value_has_listener(self._on_send1_changed):
                sends[0].remove_value_listener(self._on_send1_changed)
            if len(sends) > 1 and sends[1].value_has_listener(self._on_send2_changed):
                sends[1].remove_value_listener(self._on_send2_changed)
        if self._default_volume_button != None:
            self._default_volume_button.remove_value_listener(self._default_volume_value)
            self._default_volume_button = None
        if self._default_panning_button != None:
            self._default_panning_button.remove_value_listener(self._default_panning_value)
            self._default_panning_button = None
        if self._default_send1_button != None:
            self._default_send1_button.remove_value_listener(self._default_send1_value)
            self._default_send1_button = None
        if self._default_send2_button != None:
            self._default_send2_button.remove_value_listener(self._default_send2_value)
            self._default_send2_button = None
        ChannelStripComponent.disconnect(self)

    def set_track(self, track):
        if not (track == None or isinstance(track, Live.Track.Track)):
            raise AssertionError
            if track != self._track:
                if self._track != None:
                    volume = self._track.mixer_device.volume
                    panning = self._track.mixer_device.panning
                    sends = self._track.mixer_device.sends
                    if volume.value_has_listener(self._on_volume_changed):
                        volume.remove_value_listener(self._on_volume_changed)
                    if panning.value_has_listener(self._on_panning_changed):
                        panning.remove_value_listener(self._on_panning_changed)
                    if len(sends) > 0 and sends[0].value_has_listener(self._on_send1_changed):
                        sends[0].remove_value_listener(self._on_send1_changed)
                    len(sends) > 1 and sends[1].value_has_listener(self._on_send2_changed) and sends[1].remove_value_listener(self._on_send2_changed)
            ChannelStripComponent.set_track(self, track)
        else:
            self.update()

    def set_default_buttons(self, volume, panning, send1, send2):
        if not (volume == None or isinstance(volume, ConfigurableButtonElement)):
            raise AssertionError
            if not (panning == None or isinstance(panning, ConfigurableButtonElement)):
                raise AssertionError
                if not (send1 == None or isinstance(send1, ConfigurableButtonElement)):
                    raise AssertionError
                    if not (send2 == None or isinstance(send2, ConfigurableButtonElement)):
                        raise AssertionError
                        if volume != self._default_volume_button:
                            if self._default_volume_button != None:
                                self._default_volume_button.remove_value_listener(self._default_volume_value)
                            self._default_volume_button = volume
                            if self._default_volume_button != None:
                                self._default_volume_button.add_value_listener(self._default_volume_value)
                        if panning != self._default_panning_button:
                            if self._default_panning_button != None:
                                self._default_panning_button.remove_value_listener(self._default_panning_value)
                            self._default_panning_button = panning
                            if self._default_panning_button != None:
                                self._default_panning_button.add_value_listener(self._default_panning_value)
                        if send1 != self._default_send1_button:
                            if self._default_send1_button != None:
                                self._default_send1_button.remove_value_listener(self._default_send1_value)
                            self._default_send1_button = send1
                            self._default_send1_button != None and self._default_send1_button.add_value_listener(self._default_send1_value)
                    send2 != self._default_send2_button and self._default_send2_button != None and self._default_send2_button.remove_value_listener(self._default_send2_value)
                self._default_send2_button = send2
                self._default_send2_button != None and self._default_send2_button.add_value_listener(self._default_send2_value)
        self.update()

    def set_send_controls(self, controls):
        if not (controls == None or isinstance(controls, tuple)):
            raise AssertionError
            self._send_controls = controls != self._send_controls and controls
            if self._send_controls != None:
                for control in self._send_controls:
                    if control != None:
                        control.reset()

            self.update()

    def update(self):
        ChannelStripComponent.update(self)
        if self._allow_updates:
            if self.is_enabled():
                if self._track != None:
                    volume = self._track.mixer_device.volume
                    panning = self._track.mixer_device.panning
                    sends = self._track.mixer_device.sends
                    if not volume.value_has_listener(self._on_volume_changed):
                        volume.add_value_listener(self._on_volume_changed)
                    if not panning.value_has_listener(self._on_panning_changed):
                        panning.add_value_listener(self._on_panning_changed)
                    if len(sends) > 0:
                        if not sends[0].value_has_listener(self._on_send1_changed):
                            sends[0].add_value_listener(self._on_send1_changed)
                        self._on_send1_changed()
                    elif self._default_send1_button != None:
                        self._default_send1_button.turn_off()
                    if len(sends) > 1:
                        if not sends[1].value_has_listener(self._on_send2_changed):
                            sends[1].add_value_listener(self._on_send2_changed)
                        self._on_send2_changed()
                    elif self._default_send2_button != None:
                        self._default_send2_button.turn_off()
                    self._on_volume_changed()
                    self._on_panning_changed()
                else:
                    if self._default_volume_button != None:
                        self._default_volume_button.reset()
                    if self._default_panning_button != None:
                        self._default_panning_button.reset()
                    if self._default_send1_button != None:
                        self._default_send1_button.reset()
                    if self._default_send2_button != None:
                        self._default_send2_button.reset()
                    if self._mute_button != None:
                        self._mute_button.reset()
                    if self._arm_button != None:
                        self._arm_button.reset()
                    if self._solo_button != None:
                        self._solo_button.reset()
                    if self._volume_control != None:
                        self._volume_control.reset()
                    if self._pan_control != None:
                        self._pan_control.reset()
                    if self._send_controls != None:
                        for send_control in self._send_controls:
                            if send_control != None:
                                send_control.reset()

    def _default_volume_value(self, value):
        if not self._default_volume_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self.is_enabled() and self._track != None:
                    volume = (value != 0 or not self._default_volume_button.is_momentary()) and self._track.mixer_device.volume
                    volume.value = volume.is_enabled and volume.default_value

    def _default_panning_value(self, value):
        if not self._default_panning_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self.is_enabled() and self._track != None:
                    panning = (value != 0 or not self._default_panning_button.is_momentary()) and self._track.mixer_device.panning
                    panning.value = panning.is_enabled and panning.default_value

    def _default_send1_value(self, value):
        if not self._default_send1_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self.is_enabled() and self._track != None:
                    send1 = len(self._track.mixer_device.sends) > 0 and (value != 0 or not self._default_send1_button.is_momentary()) and self._track.mixer_device.sends[0]
                    send1.value = send1.is_enabled and send1.default_value

    def _default_send2_value(self, value):
        if not self._default_send2_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self.is_enabled() and self._track != None:
                    send2 = len(self._track.mixer_device.sends) > 1 and (value != 0 or not self._default_send2_button.is_momentary()) and self._track.mixer_device.sends[1]
                    send2.value = send2.is_enabled and send2.default_value

    def _on_mute_changed(self):
        if self.is_enabled() and self._mute_button != None:
            if self._track != None:
                if self._track in chain(self.song().tracks, self.song().return_tracks) and self._track.mute != self._invert_mute_feedback:
                    self._mute_button.turn_on()
                else:
                    self._mute_button.turn_off()
            else:
                self._mute_button.send_value(0)

    def _on_solo_changed(self):
        if self.is_enabled() and self._solo_button != None:
            if self._track != None:
                if self._track in chain(self.song().tracks, self.song().return_tracks) and self._track.solo:
                    self._solo_button.turn_on()
                else:
                    self._solo_button.turn_off()
            else:
                self._solo_button.send_value(0)

    def _on_arm_changed(self):
        if self.is_enabled() and self._arm_button != None:
            if self._track != None:
                if self._track in self.song().tracks and self._track.can_be_armed and self._track.arm:
                    self._arm_button.turn_on()
                else:
                    self._arm_button.turn_off()
            else:
                self._arm_button.send_value(0)

    def _on_volume_changed(self):
        if not self._track != None:
            raise AssertionError
            if self.is_enabled() and self._default_volume_button != None:
                volume = self._track.mixer_device.volume
                volume.value == volume.default_value and self._default_volume_button.turn_on()
            else:
                self._default_volume_button.turn_off()

    def _on_panning_changed(self):
        if not self._track != None:
            raise AssertionError
            if self.is_enabled() and self._default_panning_button != None:
                panning = self._track.mixer_device.panning
                panning.value == panning.default_value and self._default_panning_button.turn_on()
            else:
                self._default_panning_button.turn_off()

    def _on_send1_changed(self):
        if not self._track != None:
            raise AssertionError
            sends = self._track.mixer_device.sends
            if not len(sends) > 0:
                raise AssertionError
                send1 = self.is_enabled() and self._default_send1_button != None and sends[0]
                send1.value == send1.default_value and self._default_send1_button.turn_on()
            else:
                self._default_send1_button.turn_off()

    def _on_send2_changed(self):
        if not self._track != None:
            raise AssertionError
            sends = self._track.mixer_device.sends
            if not len(sends) > 1:
                raise AssertionError
                send2 = self.is_enabled() and self._default_send2_button != None and sends[1]
                send2.value == send2.default_value and self._default_send2_button.turn_on()
            else:
                self._default_send2_button.turn_off()
########NEW FILE########
__FILENAME__ = Launchpad
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launchpad/Launchpad.py
from __future__ import with_statement
import Live
from _Framework.ControlSurface import ControlSurface
from _Framework.InputControlElement import *
from _Framework.ButtonElement import ButtonElement
from _Framework.ButtonMatrixElement import ButtonMatrixElement
from ConfigurableButtonElement import ConfigurableButtonElement
from MainSelectorComponent import MainSelectorComponent
SIDE_NOTES = (8, 24, 40, 56, 72, 88, 104, 120)
DRUM_NOTES = (41, 42, 43, 44, 45, 46, 47, 57, 58, 59, 60, 61, 62, 63, 73, 74, 75, 76, 77, 78, 79, 89, 90, 91, 92, 93, 94, 95, 105, 106, 107)

class Launchpad(ControlSurface):
    """ Script for Novation's Launchpad Controller """

    def __init__(self, c_instance):
        ControlSurface.__init__(self, c_instance)
        with self.component_guard():
            self._suppress_send_midi = True
            self._suppress_session_highlight = True
            is_momentary = True
            self._suggested_input_port = 'Launchpad'
            self._suggested_output_port = 'Launchpad'
            self._control_is_with_automap = False
            self._user_byte_write_button = ButtonElement(is_momentary, MIDI_CC_TYPE, 0, 16)
            self._user_byte_write_button.name = 'User_Byte_Button'
            self._user_byte_write_button.send_value(1)
            self._user_byte_write_button.add_value_listener(self._user_byte_value)
            self._wrote_user_byte = False
            self._challenge = Live.Application.get_random_int(0, 400000000) & 2139062143
            matrix = ButtonMatrixElement()
            matrix.name = 'Button_Matrix'
            for row in range(8):
                button_row = []
                for column in range(8):
                    button = ConfigurableButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, row * 16 + column)
                    button.name = str(column) + '_Clip_' + str(row) + '_Button'
                    button_row.append(button)

                matrix.add_row(tuple(button_row))

            self._config_button = ButtonElement(is_momentary, MIDI_CC_TYPE, 0, 0, optimized_send_midi=False)
            self._config_button.add_value_listener(self._config_value)
            top_buttons = [ ConfigurableButtonElement(is_momentary, MIDI_CC_TYPE, 0, 104 + index) for index in range(8) ]
            side_buttons = [ ConfigurableButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, SIDE_NOTES[index]) for index in range(8) ]
            top_buttons[0].name = 'Bank_Select_Up_Button'
            top_buttons[1].name = 'Bank_Select_Down_Button'
            top_buttons[2].name = 'Bank_Select_Left_Button'
            top_buttons[3].name = 'Bank_Select_Right_Button'
            top_buttons[4].name = 'Session_Button'
            top_buttons[5].name = 'User1_Button'
            top_buttons[6].name = 'User2_Button'
            top_buttons[7].name = 'Mixer_Button'
            side_buttons[0].name = 'Vol_Button'
            side_buttons[1].name = 'Pan_Button'
            side_buttons[2].name = 'SndA_Button'
            side_buttons[3].name = 'SndB_Button'
            side_buttons[4].name = 'Stop_Button'
            side_buttons[5].name = 'Trk_On_Button'
            side_buttons[6].name = 'Solo_Button'
            side_buttons[7].name = 'Arm_Button'
            self._selector = MainSelectorComponent(matrix, tuple(top_buttons), tuple(side_buttons), self._config_button)
            self._selector.name = 'Main_Modes'
            for control in self.controls:
                if isinstance(control, ConfigurableButtonElement):
                    control.add_value_listener(self._button_value)

            self.set_highlighting_session_component(self._selector.session_component())
            self._suppress_session_highlight = False

    def disconnect(self):
        self._suppress_send_midi = True
        for control in self.controls:
            if isinstance(control, ConfigurableButtonElement):
                control.remove_value_listener(self._button_value)

        self._selector = None
        self._user_byte_write_button.remove_value_listener(self._user_byte_value)
        self._config_button.remove_value_listener(self._config_value)
        ControlSurface.disconnect(self)
        self._suppress_send_midi = False
        self._config_button.send_value(32)
        self._config_button.send_value(0)
        self._config_button = None
        self._user_byte_write_button.send_value(0)
        self._user_byte_write_button = None

    def refresh_state(self):
        ControlSurface.refresh_state(self)
        self.schedule_message(5, self._update_hardware)

    def handle_sysex(self, midi_bytes):
        if len(midi_bytes) == 8:
            if midi_bytes[1:5] == (0, 32, 41, 6):
                response = long(midi_bytes[5])
                response += long(midi_bytes[6]) << 8
                if response == Live.Application.encrypt_challenge2(self._challenge):
                    self._suppress_send_midi = False
                    self.set_enabled(True)

    def build_midi_map(self, midi_map_handle):
        ControlSurface.build_midi_map(self, midi_map_handle)
        if self._selector.mode_index == 1:
            new_channel = self._selector.channel_for_current_mode()
            for note in DRUM_NOTES:
                self._translate_message(MIDI_NOTE_TYPE, note, 0, note, new_channel)

    def _send_midi(self, midi_bytes, optimized = None):
        sent_successfully = False
        if not self._suppress_send_midi:
            sent_successfully = ControlSurface._send_midi(self, midi_bytes, optimized=optimized)
        return sent_successfully

    def _update_hardware(self):
        self._suppress_send_midi = False
        self._wrote_user_byte = True
        self._user_byte_write_button.send_value(1)
        self._suppress_send_midi = True
        self.set_enabled(False)
        self._suppress_send_midi = False
        self._send_challenge()

    def _send_challenge(self):
        for index in range(4):
            challenge_byte = self._challenge >> 8 * index & 127
            self._send_midi((176, 17 + index, challenge_byte))

    def _user_byte_value(self, value):
        if not value in range(128):
            raise AssertionError
            enabled = self._wrote_user_byte or value == 1
            self._control_is_with_automap = not enabled
            self._suppress_send_midi = self._control_is_with_automap
            if not self._control_is_with_automap:
                for control in self.controls:
                    if isinstance(control, ConfigurableButtonElement):
                        control.set_force_next_value()

            self._selector.set_mode(0)
            self.set_enabled(enabled)
            self._suppress_send_midi = False
        else:
            self._wrote_user_byte = False

    def _button_value(self, value):
        raise value in range(128) or AssertionError

    def _config_value(self, value):
        raise value in range(128) or AssertionError

    def _set_session_highlight(self, track_offset, scene_offset, width, height, include_return_tracks):
        if not self._suppress_session_highlight:
            ControlSurface._set_session_highlight(self, track_offset, scene_offset, width, height, include_return_tracks)
########NEW FILE########
__FILENAME__ = MainSelectorComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launchpad/MainSelectorComponent.py
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from _Framework.ButtonElement import ButtonElement
from _Framework.ButtonMatrixElement import ButtonMatrixElement
from _Framework.ButtonSliderElement import ButtonSliderElement
from _Framework.ClipSlotComponent import ClipSlotComponent
from _Framework.ChannelStripComponent import ChannelStripComponent
from _Framework.SceneComponent import SceneComponent
from _Framework.SessionZoomingComponent import SessionZoomingComponent
from ConfigurableButtonElement import ConfigurableButtonElement
from SpecialSessionComponent import SpecialSessionComponent
from SubSelectorComponent import *

class MainSelectorComponent(ModeSelectorComponent):
    """ Class that reassigns the button on the launchpad to different functions """

    def __init__(self, matrix, top_buttons, side_buttons, config_button):
        raise isinstance(matrix, ButtonMatrixElement) or AssertionError
        raise matrix.width() == 8 and matrix.height() == 8 or AssertionError
        raise isinstance(top_buttons, tuple) or AssertionError
        raise len(top_buttons) == 8 or AssertionError
        raise isinstance(side_buttons, tuple) or AssertionError
        raise len(side_buttons) == 8 or AssertionError
        raise isinstance(config_button, ButtonElement) or AssertionError
        ModeSelectorComponent.__init__(self)
        self._session = SpecialSessionComponent(matrix.width(), matrix.height())
        self._zooming = SessionZoomingComponent(self._session)
        self._session.name = 'Session_Control'
        self._zooming.name = 'Session_Overview'
        self._matrix = matrix
        self._side_buttons = side_buttons
        self._nav_buttons = top_buttons[:4]
        self._config_button = config_button
        self._zooming.set_empty_value(LED_OFF)
        self._all_buttons = []
        for button in self._side_buttons + self._nav_buttons:
            self._all_buttons.append(button)

        self._sub_modes = SubSelectorComponent(matrix, side_buttons, self._session)
        self._sub_modes.name = 'Mixer_Modes'
        self._sub_modes.set_update_callback(self._update_control_channels)
        self._init_session()
        self._all_buttons = tuple(self._all_buttons)
        self.set_modes_buttons(top_buttons[4:])

    def disconnect(self):
        for button in self._modes_buttons:
            button.remove_value_listener(self._mode_value)

        self._session = None
        self._zooming = None
        for button in self._all_buttons:
            button.set_on_off_values(127, LED_OFF)

        self._config_button.turn_off()
        self._matrix = None
        self._side_buttons = None
        self._nav_buttons = None
        self._config_button = None
        ModeSelectorComponent.disconnect(self)

    def session_component(self):
        return self._session

    def set_modes_buttons(self, buttons):
        raise buttons == None or isinstance(buttons, tuple) or len(buttons) == self.number_of_modes() or AssertionError
        identify_sender = True
        for button in self._modes_buttons:
            button.remove_value_listener(self._mode_value)

        self._modes_buttons = []
        if buttons != None:
            for button in buttons:
                raise isinstance(button, ButtonElement) or AssertionError
                self._modes_buttons.append(button)
                button.add_value_listener(self._mode_value, identify_sender)

        self.set_mode(0)

    def number_of_modes(self):
        return 4

    def on_enabled_changed(self):
        self.update()

    def set_mode(self, mode):
        if not mode in range(self.number_of_modes()):
            raise AssertionError
            self._mode_index = (self._mode_index != mode or mode == 3) and mode
            self.update()

    def channel_for_current_mode(self):
        new_channel = self._mode_index + self._sub_modes.mode()
        if new_channel > 0:
            new_channel += 3
        return new_channel

    def update(self):
        if not self._modes_buttons != None:
            raise AssertionError
            if self.is_enabled():
                for index in range(len(self._modes_buttons)):
                    self._modes_buttons[index].set_force_next_value()
                    if index == self._mode_index:
                        self._modes_buttons[index].turn_on()
                    else:
                        self._modes_buttons[index].turn_off()

                for scene_index in range(8):
                    self._side_buttons[scene_index].set_enabled(True)
                    for track_index in range(8):
                        self._matrix.get_button(track_index, scene_index).set_enabled(True)

                for button in self._nav_buttons:
                    button.set_enabled(True)

                as_active = True
                as_enabled = True
                self._session.set_allow_update(False)
                self._zooming.set_allow_update(False)
                self._config_button.send_value(40)
                self._config_button.send_value(1)
                release_buttons = self._mode_index == 1
                self._mode_index == 0 and self._setup_mixer(not as_active)
                self._setup_session(as_active, as_enabled)
            elif self._mode_index == 1:
                self._setup_session(not as_active, not as_enabled)
                self._setup_mixer(not as_active)
                self._setup_user(release_buttons)
            elif self._mode_index == 2:
                self._setup_session(not as_active, not as_enabled)
                self._setup_mixer(not as_active)
                self._setup_user(release_buttons)
            elif self._mode_index == 3:
                self._setup_session(not as_active, as_enabled)
                self._setup_mixer(as_active)
            else:
                raise False or AssertionError
            self._session.set_allow_update(True)
            self._zooming.set_allow_update(True)
            self._update_control_channels()

    def _update_control_channels(self):
        new_channel = self.channel_for_current_mode()
        for button in self._all_buttons:
            button.set_channel(new_channel)
            button.set_force_next_value()

    def _setup_session(self, as_active, as_enabled):
        if not isinstance(as_active, type(False)):
            raise AssertionError
            for button in self._nav_buttons:
                if as_enabled:
                    button.set_on_off_values(GREEN_FULL, GREEN_THIRD)
                else:
                    button.set_on_off_values(127, LED_OFF)

            for scene_index in range(8):
                scene = self._session.scene(scene_index)
                if as_active:
                    scene_button = self._side_buttons[scene_index]
                    scene_button.set_on_off_values(127, LED_OFF)
                    scene.set_launch_button(scene_button)
                else:
                    scene.set_launch_button(None)
                for track_index in range(8):
                    if as_active:
                        button = self._matrix.get_button(track_index, scene_index)
                        button.set_on_off_values(127, LED_OFF)
                        scene.clip_slot(track_index).set_launch_button(button)
                    else:
                        scene.clip_slot(track_index).set_launch_button(None)

            if as_active:
                self._zooming.set_zoom_button(self._modes_buttons[0])
                self._zooming.set_button_matrix(self._matrix)
                self._zooming.set_scene_bank_buttons(self._side_buttons)
                self._zooming.set_nav_buttons(self._nav_buttons[0], self._nav_buttons[1], self._nav_buttons[2], self._nav_buttons[3])
                self._zooming.update()
            else:
                self._zooming.set_zoom_button(None)
                self._zooming.set_button_matrix(None)
                self._zooming.set_scene_bank_buttons(None)
                self._zooming.set_nav_buttons(None, None, None, None)
            as_enabled and self._session.set_track_bank_buttons(self._nav_buttons[3], self._nav_buttons[2])
            self._session.set_scene_bank_buttons(self._nav_buttons[1], self._nav_buttons[0])
        else:
            self._session.set_track_bank_buttons(None, None)
            self._session.set_scene_bank_buttons(None, None)

    def _setup_mixer(self, as_active):
        if not isinstance(as_active, type(False)):
            raise AssertionError
            as_active and self._sub_modes.is_enabled() and self._sub_modes.set_mode(-1)
        self._sub_modes.set_enabled(as_active)

    def _setup_user(self, release_buttons):
        for scene_index in range(8):
            scene_button = self._side_buttons[scene_index]
            scene_button.set_on_off_values(127, LED_OFF)
            scene_button.turn_off()
            scene_button.set_enabled(not release_buttons)
            for track_index in range(8):
                button = self._matrix.get_button(track_index, scene_index)
                button.set_on_off_values(127, LED_OFF)
                button.turn_off()
                button.set_enabled(not release_buttons)

        for button in self._nav_buttons:
            button.set_on_off_values(127, LED_OFF)
            button.turn_off()
            button.set_enabled(not release_buttons)

        if release_buttons:
            self._config_button.send_value(2)
        self._config_button.send_value(32, force=True)

    def _init_session(self):
        self._session.set_stop_track_clip_value(AMBER_BLINK)
        for scene_index in range(self._matrix.height()):
            scene = self._session.scene(scene_index)
            scene.set_triggered_value(GREEN_BLINK)
            scene.name = 'Scene_' + str(scene_index)
            for track_index in range(self._matrix.width()):
                clip_slot = scene.clip_slot(track_index)
                clip_slot.set_triggered_to_play_value(GREEN_BLINK)
                clip_slot.set_triggered_to_record_value(RED_BLINK)
                clip_slot.set_stopped_value(AMBER_FULL)
                clip_slot.set_started_value(GREEN_FULL)
                clip_slot.set_recording_value(RED_FULL)
                clip_slot.name = str(track_index) + '_Clip_Slot_' + str(scene_index)
                self._all_buttons.append(self._matrix.get_button(track_index, scene_index))

        self._zooming.set_stopped_value(RED_FULL)
        self._zooming.set_selected_value(AMBER_FULL)
        self._zooming.set_playing_value(GREEN_FULL)
########NEW FILE########
__FILENAME__ = PreciseButtonSliderElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launchpad/PreciseButtonSliderElement.py
from _Framework.ButtonSliderElement import ButtonSliderElement
from _Framework.InputControlElement import *
SLIDER_MODE_SINGLE = 0
SLIDER_MODE_VOLUME = 1
SLIDER_MODE_PAN = 2

class PreciseButtonSliderElement(ButtonSliderElement):
    """ Class representing a set of buttons used as a slider """

    def __init__(self, buttons):
        ButtonSliderElement.__init__(self, buttons)
        num_buttons = len(buttons)
        self._disabled = False
        self._mode = SLIDER_MODE_VOLUME
        self._value_map = tuple([ float(index / num_buttons) for index in range(num_buttons) ])

    def set_disabled(self, disabled):
        raise isinstance(disabled, type(False)) or AssertionError
        self._disabled = disabled

    def set_mode(self, mode):
        if not mode in (SLIDER_MODE_SINGLE, SLIDER_MODE_VOLUME, SLIDER_MODE_PAN):
            raise AssertionError
            self._mode = mode != self._mode and mode

    def set_value_map(self, map):
        raise isinstance(map, (tuple, type(None))) or AssertionError
        raise len(map) == len(self._buttons) or AssertionError
        self._value_map = map

    def send_value(self, value):
        raise self._disabled or value != None or AssertionError
        raise isinstance(value, int) or AssertionError
        if not value in range(128):
            raise AssertionError
            if value != self._last_sent_value:
                if self._mode == SLIDER_MODE_SINGLE:
                    ButtonSliderElement.send_value(self, value)
                elif self._mode == SLIDER_MODE_VOLUME:
                    self._send_value_volume(value)
                elif self._mode == SLIDER_MODE_PAN:
                    self._send_value_pan(value)
                else:
                    raise False or AssertionError
                self._last_sent_value = value

    def connect_to(self, parameter):
        ButtonSliderElement.connect_to(self, parameter)
        if self._parameter_to_map_to != None:
            self._last_sent_value = -1
            self._on_parameter_changed()

    def release_parameter(self):
        old_param = self._parameter_to_map_to
        ButtonSliderElement.release_parameter(self)
        if not self._disabled and old_param != None:
            for button in self._buttons:
                button.reset()

    def reset(self):
        if not self._disabled and self._buttons != None:
            for button in self._buttons:
                if button != None:
                    button.reset()

    def _send_value_volume(self, value):
        index_to_light = -1
        normalised_value = float(value) / 127.0
        if normalised_value > 0.0:
            for index in range(len(self._value_map)):
                if normalised_value <= self._value_map[index]:
                    index_to_light = index
                    break

        self._send_mask(tuple([ index <= index_to_light for index in range(len(self._buttons)) ]))

    def _send_value_pan(self, value):
        num_buttons = len(self._buttons)
        button_bits = [ False for index in range(num_buttons) ]
        normalised_value = float(2 * value / 127.0) - 1.0
        if value in (63, 64):
            normalised_value = 0.0
        if normalised_value < 0.0:
            for index in range(len(self._buttons)):
                button_bits[index] = self._value_map[index] >= normalised_value
                if self._value_map[index] >= 0:
                    break

        elif normalised_value > 0.0:
            for index in range(len(self._buttons)):
                r_index = len(self._buttons) - 1 - index
                button_bits[r_index] = self._value_map[r_index] <= normalised_value
                if self._value_map[r_index] <= 0:
                    break

        else:
            for index in range(len(self._buttons)):
                button_bits[index] = self._value_map[index] == normalised_value

        self._send_mask(tuple(button_bits))

    def _send_mask(self, mask):
        raise isinstance(mask, tuple) or AssertionError
        raise len(mask) == len(self._buttons) or AssertionError
        for index in range(len(self._buttons)):
            if mask[index]:
                self._buttons[index].turn_on()
            else:
                self._buttons[index].turn_off()

    def _button_value(self, value, sender):
        if not isinstance(value, int):
            raise AssertionError
            if not sender in self._buttons:
                raise AssertionError
                self._last_sent_value = -1
                index_of_sender = (value != 0 or not sender.is_momentary()) and list(self._buttons).index(sender)
                self._parameter_to_map_to.value = self._parameter_to_map_to != None and self._parameter_to_map_to.is_enabled and self._value_map[index_of_sender]
            self.notify_value(value)

    def _on_parameter_changed(self):
        raise self._parameter_to_map_to != None or AssertionError
        param_range = abs(self._parameter_to_map_to.max - self._parameter_to_map_to.min)
        param_value = self._parameter_to_map_to.value
        param_min = self._parameter_to_map_to.min
        param_mid = param_range / 2 + param_min
        midi_value = 0
        if self._mode == SLIDER_MODE_PAN:
            if param_value == param_mid:
                midi_value = 64
            else:
                diff = abs(param_value - param_mid) / param_range * 127
                if param_value > param_mid:
                    midi_value = 64 + int(diff)
                else:
                    midi_value = 63 - int(diff)
        else:
            midi_value = int(127 * abs(param_value - self._parameter_to_map_to.min) / param_range)
        self.send_value(midi_value)
########NEW FILE########
__FILENAME__ = SpecialMixerComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launchpad/SpecialMixerComponent.py
import Live
from _Framework.MixerComponent import MixerComponent
from DefChannelStripComponent import DefChannelStripComponent
from _Framework.ButtonElement import ButtonElement

class SpecialMixerComponent(MixerComponent):
    """ Class encompassing several defaultable channel strips to form a mixer """

    def __init__(self, num_tracks, num_returns = 0, with_eqs = False, with_filters = False):
        MixerComponent.__init__(self, num_tracks, num_returns, with_eqs, with_filters)
        self._unarm_all_button = None
        self._unsolo_all_button = None
        self._unmute_all_button = None

    def disconnect(self):
        if self._unarm_all_button != None:
            self._unarm_all_button.remove_value_listener(self._unarm_all_value)
            self._unarm_all_button = None
        if self._unsolo_all_button != None:
            self._unsolo_all_button.remove_value_listener(self._unsolo_all_value)
            self._unsolo_all_button = None
        if self._unmute_all_button != None:
            self._unmute_all_button.remove_value_listener(self._unmute_all_value)
            self._unmute_all_button = None
        MixerComponent.disconnect(self)

    def set_global_buttons(self, unarm_all, unsolo_all, unmute_all):
        if not isinstance(unarm_all, (ButtonElement, type(None))):
            raise AssertionError
            raise isinstance(unsolo_all, (ButtonElement, type(None))) or AssertionError
            if not isinstance(unmute_all, (ButtonElement, type(None))):
                raise AssertionError
                if self._unarm_all_button != None:
                    self._unarm_all_button.remove_value_listener(self._unarm_all_value)
                self._unarm_all_button = unarm_all
                if self._unarm_all_button != None:
                    self._unarm_all_button.add_value_listener(self._unarm_all_value)
                    self._unarm_all_button.turn_off()
                if self._unsolo_all_button != None:
                    self._unsolo_all_button.remove_value_listener(self._unsolo_all_value)
                self._unsolo_all_button = unsolo_all
                if self._unsolo_all_button != None:
                    self._unsolo_all_button.add_value_listener(self._unsolo_all_value)
                    self._unsolo_all_button.turn_off()
                self._unmute_all_button != None and self._unmute_all_button.remove_value_listener(self._unmute_all_value)
            self._unmute_all_button = unmute_all
            self._unmute_all_button != None and self._unmute_all_button.add_value_listener(self._unmute_all_value)
            self._unmute_all_button.turn_off()

    def _create_strip(self):
        return DefChannelStripComponent()

    def _unarm_all_value(self, value):
        raise self.is_enabled() or AssertionError
        raise self._unarm_all_button != None or AssertionError
        raise value in range(128) or AssertionError
        if value != 0 or not self._unarm_all_button.is_momentary():
            for track in self.song().tracks:
                if track.can_be_armed and track.arm:
                    track.arm = False

    def _unsolo_all_value(self, value):
        raise self.is_enabled() or AssertionError
        raise self._unsolo_all_button != None or AssertionError
        raise value in range(128) or AssertionError
        if value != 0 or not self._unsolo_all_button.is_momentary():
            for track in tuple(self.song().tracks) + tuple(self.song().return_tracks):
                if track.solo:
                    track.solo = False

    def _unmute_all_value(self, value):
        raise self.is_enabled() or AssertionError
        raise self._unmute_all_button != None or AssertionError
        raise value in range(128) or AssertionError
        if value != 0 or not self._unmute_all_button.is_momentary():
            for track in tuple(self.song().tracks) + tuple(self.song().return_tracks):
                if track.mute:
                    track.mute = False
########NEW FILE########
__FILENAME__ = SpecialSessionComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launchpad/SpecialSessionComponent.py
import Live
from _Framework.SessionComponent import SessionComponent
from _Framework.ButtonElement import ButtonElement
from ConfigurableButtonElement import ConfigurableButtonElement

class SpecialSessionComponent(SessionComponent):
    """ Special session subclass that handles ConfigurableButtons """

    def __init__(self, num_tracks, num_scenes):
        self._tracks_and_listeners = []
        SessionComponent.__init__(self, num_tracks, num_scenes)

    def disconnect(self):
        for index in range(len(self._tracks_and_listeners)):
            track = self._tracks_and_listeners[index][0]
            fire_listener = self._tracks_and_listeners[index][1]
            playing_listener = self._tracks_and_listeners[index][2]
            if track != None:
                if track.fired_slot_index_has_listener(fire_listener):
                    track.remove_fired_slot_index_listener(fire_listener)
                if track.playing_slot_index_has_listener(playing_listener):
                    track.remove_playing_slot_index_listener(playing_listener)

        SessionComponent.disconnect(self)

    def _reassign_tracks(self):
        for index in range(len(self._tracks_and_listeners)):
            track = self._tracks_and_listeners[index][0]
            fire_listener = self._tracks_and_listeners[index][1]
            playing_listener = self._tracks_and_listeners[index][2]
            if track != None:
                if track.fired_slot_index_has_listener(fire_listener):
                    track.remove_fired_slot_index_listener(fire_listener)
                if track.playing_slot_index_has_listener(playing_listener):
                    track.remove_playing_slot_index_listener(playing_listener)

        self._tracks_and_listeners = []
        tracks_to_use = self.tracks_to_use()
        for index in range(self._num_tracks):
            fire_listener = lambda index = index: self._on_fired_slot_index_changed(index)
            playing_listener = lambda index = index: self._on_playing_slot_index_changed(index)
            track = None
            if self._track_offset + index < len(tracks_to_use):
                track = tracks_to_use[self._track_offset + index]
            if track != None:
                self._tracks_and_listeners.append((track, fire_listener, playing_listener))
                track.add_fired_slot_index_listener(fire_listener)
                track.add_playing_slot_index_listener(playing_listener)
            self._update_stop_clips_led(index)

    def _on_fired_slot_index_changed(self, index):
        self._update_stop_clips_led(index)

    def _on_playing_slot_index_changed(self, index):
        self._update_stop_clips_led(index)

    def _update_stop_clips_led(self, index):
        if self.is_enabled() and self._stop_track_clip_buttons != None:
            button = self._stop_track_clip_buttons[index]
            if index in range(len(self._tracks_and_listeners)):
                track = self._tracks_and_listeners[index][0]
                if track.fired_slot_index == -2:
                    button.send_value(self._stop_track_clip_value)
                elif track.playing_slot_index >= 0:
                    button.send_value(21)
                else:
                    button.turn_off()
            else:
                button.send_value(4)
########NEW FILE########
__FILENAME__ = SubSelectorComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launchpad/SubSelectorComponent.py
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from _Framework.ButtonElement import ButtonElement
from _Framework.ButtonMatrixElement import ButtonMatrixElement
from _Framework.SessionComponent import SessionComponent
from SpecialMixerComponent import SpecialMixerComponent
from PreciseButtonSliderElement import *
LED_OFF = 4
RED_FULL = 7
RED_HALF = 6
RED_THIRD = 5
RED_BLINK = 11
GREEN_FULL = 52
GREEN_HALF = 36
GREEN_THIRD = 20
GREEN_BLINK = 56
AMBER_FULL = RED_FULL + GREEN_FULL - 4
AMBER_HALF = RED_HALF + GREEN_HALF - 4
AMBER_THIRD = RED_THIRD + GREEN_THIRD - 4
AMBER_BLINK = AMBER_FULL - 4 + 8
PAN_VALUE_MAP = (-1.0, -0.634921, -0.31746, 0.0, 0.0, 0.31746, 0.634921, 1.0)
VOL_VALUE_MAP = (0.0, 0.142882, 0.302414, 0.4, 0.55, 0.7, 0.85, 1.0)
SEND_VALUE_MAP = (0.0, 0.103536, 0.164219, 0.238439, 0.343664, 0.55, 0.774942, 1.0)

class SubSelectorComponent(ModeSelectorComponent):
    """ Class that handles different mixer modes """

    def __init__(self, matrix, side_buttons, session):
        raise isinstance(matrix, ButtonMatrixElement) or AssertionError
        raise matrix.width() == 8 and matrix.height() == 8 or AssertionError
        raise isinstance(side_buttons, tuple) or AssertionError
        raise len(side_buttons) == 8 or AssertionError
        raise isinstance(session, SessionComponent) or AssertionError
        ModeSelectorComponent.__init__(self)
        self._session = session
        self._mixer = SpecialMixerComponent(matrix.width())
        self._matrix = matrix
        self._sliders = []
        self._mixer.name = 'Mixer'
        self._mixer.master_strip().name = 'Master_Channel_strip'
        self._mixer.selected_strip().name = 'Selected_Channel_strip'
        for column in range(matrix.width()):
            self._mixer.channel_strip(column).name = 'Channel_Strip_' + str(column)
            self._sliders.append(PreciseButtonSliderElement(tuple([ matrix.get_button(column, 7 - row) for row in range(8) ])))
            self._sliders[-1].name = 'Button_Slider_' + str(column)

        self._side_buttons = side_buttons[4:]
        self._update_callback = None
        self._session.set_mixer(self._mixer)
        self.set_modes_buttons(side_buttons[:4])

    def disconnect(self):
        for button in self._modes_buttons:
            button.remove_value_listener(self._mode_value)

        self._session = None
        self._mixer = None
        for slider in self._sliders:
            slider.release_parameter()
            slider.set_disabled(True)

        self._sliders = None
        self._matrix = None
        self._side_buttons = None
        self._update_callback = None
        ModeSelectorComponent.disconnect(self)

    def set_update_callback(self, callback):
        raise dir(callback).count('im_func') is 1 or AssertionError
        self._update_callback = callback

    def set_modes_buttons(self, buttons):
        raise buttons == None or isinstance(buttons, tuple) or len(buttons) == self.number_of_modes() or AssertionError
        identify_sender = True
        for button in self._modes_buttons:
            button.remove_value_listener(self._mode_value)

        self._modes_buttons = []
        if buttons != None:
            for button in buttons:
                raise isinstance(button, ButtonElement) or AssertionError
                self._modes_buttons.append(button)
                button.add_value_listener(self._mode_value, identify_sender)

    def set_mode(self, mode):
        if not isinstance(mode, int):
            raise AssertionError
            raise mode in range(-1, self.number_of_modes()) or AssertionError
            self._mode_index = (self._mode_index != mode or mode == -1) and mode
            self.update()

    def mode(self):
        result = 0
        if self.is_enabled():
            result = self._mode_index + 1
        return result

    def number_of_modes(self):
        return 4

    def on_enabled_changed(self):
        enabled = self.is_enabled()
        for index in range(self._matrix.width()):
            self._sliders[index].set_disabled(not enabled)

        self._mixer.set_enabled(enabled)
        self.set_mode(-1)

    def release_controls(self):
        for track in range(self._matrix.width()):
            for row in range(self._matrix.height()):
                self._matrix.get_button(track, row).set_on_off_values(127, LED_OFF)

            strip = self._mixer.channel_strip(track)
            strip.set_default_buttons(None, None, None, None)
            strip.set_mute_button(None)
            strip.set_solo_button(None)
            strip.set_arm_button(None)
            strip.set_send_controls((None, None))
            strip.set_pan_control(None)
            strip.set_volume_control(None)

        self._session.set_stop_track_clip_buttons(None)
        self._mixer.set_global_buttons(None, None, None)
        self._session.set_stop_all_clips_button(None)

    def update(self):
        if not self._modes_buttons != None:
            raise AssertionError
            if self.is_enabled():
                if self._modes_buttons != None:
                    for index in range(len(self._modes_buttons)):
                        self._modes_buttons[index].set_on_off_values(GREEN_FULL, GREEN_THIRD)
                        if index == self._mode_index:
                            self._modes_buttons[index].turn_on()
                        else:
                            self._modes_buttons[index].turn_off()

                for button in self._side_buttons:
                    button.set_on_off_values(127, LED_OFF)
                    button.turn_off()

                for index in range(self._matrix.width()):
                    self._sliders[index].set_disabled(self._mode_index == -1)

                self._mixer.set_allow_update(False)
                self._session.set_allow_update(False)
                if self._mode_index == -1:
                    self._setup_mixer_overview()
                elif self._mode_index == 0:
                    self._setup_volume_mode()
                elif self._mode_index == 1:
                    self._setup_pan_mode()
                elif self._mode_index == 2:
                    self._setup_send1_mode()
                elif self._mode_index == 3:
                    self._setup_send2_mode()
                else:
                    raise False or AssertionError
                self._update_callback != None and self._update_callback()
            self._mixer.set_allow_update(True)
            self._session.set_allow_update(True)
        else:
            self.release_controls()

    def _setup_mixer_overview(self):
        trkon_index = 5
        stop_buttons = []
        for track in range(self._matrix.width()):
            strip = self._mixer.channel_strip(track)
            strip.set_send_controls((None, None))
            strip.set_pan_control(None)
            strip.set_volume_control(None)
            self._sliders[track].release_parameter()
            for row in range(self._matrix.height()):
                full_value = GREEN_THIRD
                third_value = GREEN_FULL
                if row == trkon_index:
                    full_value = AMBER_FULL
                    third_value = AMBER_THIRD
                elif row > 3:
                    full_value = RED_FULL
                    third_value = RED_THIRD
                self._matrix.get_button(track, row).set_on_off_values(full_value, third_value)

            strip.set_default_buttons(self._matrix.get_button(track, 0), self._matrix.get_button(track, 1), self._matrix.get_button(track, 2), self._matrix.get_button(track, 3))
            stop_buttons.append(self._matrix.get_button(track, 4))
            strip.set_mute_button(self._matrix.get_button(track, 5))
            strip.set_solo_button(self._matrix.get_button(track, 6))
            strip.set_arm_button(self._matrix.get_button(track, 7))

        for button in self._side_buttons:
            if list(self._side_buttons).index(button) == trkon_index - 4:
                button.set_on_off_values(AMBER_FULL, AMBER_THIRD)
            else:
                button.set_on_off_values(RED_FULL, RED_THIRD)
            button.set_force_next_value()
            button.turn_off()

        self._session.set_stop_track_clip_buttons(tuple(stop_buttons))
        self._session.set_stop_all_clips_button(self._side_buttons[0])
        self._mixer.set_global_buttons(self._side_buttons[3], self._side_buttons[2], self._side_buttons[1])

    def _setup_volume_mode(self):
        for track in range(self._matrix.width()):
            strip = self._mixer.channel_strip(track)
            strip.set_default_buttons(None, None, None, None)
            strip.set_mute_button(None)
            strip.set_solo_button(None)
            strip.set_arm_button(None)
            strip.set_send_controls((None, None))
            strip.set_pan_control(None)
            for row in range(self._matrix.height()):
                self._matrix.get_button(track, row).set_on_off_values(GREEN_FULL, LED_OFF)

            self._sliders[track].set_mode(SLIDER_MODE_VOLUME)
            self._sliders[track].set_value_map(VOL_VALUE_MAP)
            strip.set_volume_control(self._sliders[track])

        self._session.set_stop_track_clip_buttons(None)
        self._session.set_stop_all_clips_button(None)
        self._mixer.set_global_buttons(None, None, None)

    def _setup_pan_mode(self):
        for track in range(self._matrix.width()):
            strip = self._mixer.channel_strip(track)
            strip.set_default_buttons(None, None, None, None)
            strip.set_mute_button(None)
            strip.set_solo_button(None)
            strip.set_arm_button(None)
            strip.set_send_controls((None, None))
            strip.set_volume_control(None)
            for row in range(self._matrix.height()):
                self._matrix.get_button(track, row).set_on_off_values(AMBER_FULL, LED_OFF)

            self._sliders[track].set_mode(SLIDER_MODE_PAN)
            self._sliders[track].set_value_map(PAN_VALUE_MAP)
            strip.set_pan_control(self._sliders[track])

        self._session.set_stop_track_clip_buttons(None)
        self._session.set_stop_all_clips_button(None)
        self._mixer.set_global_buttons(None, None, None)

    def _setup_send1_mode(self):
        for track in range(self._matrix.width()):
            strip = self._mixer.channel_strip(track)
            strip.set_default_buttons(None, None, None, None)
            strip.set_mute_button(None)
            strip.set_solo_button(None)
            strip.set_arm_button(None)
            strip.set_volume_control(None)
            strip.set_pan_control(None)
            for row in range(self._matrix.height()):
                self._matrix.get_button(track, row).set_on_off_values(RED_FULL, LED_OFF)

            self._sliders[track].set_mode(SLIDER_MODE_VOLUME)
            self._sliders[track].set_value_map(SEND_VALUE_MAP)
            strip.set_send_controls((self._sliders[track], None))

        self._session.set_stop_track_clip_buttons(None)
        self._session.set_stop_all_clips_button(None)
        self._mixer.set_global_buttons(None, None, None)

    def _setup_send2_mode(self):
        for track in range(self._matrix.width()):
            strip = self._mixer.channel_strip(track)
            strip.set_default_buttons(None, None, None, None)
            strip.set_mute_button(None)
            strip.set_solo_button(None)
            strip.set_arm_button(None)
            strip.set_volume_control(None)
            strip.set_pan_control(None)
            for row in range(self._matrix.height()):
                self._matrix.get_button(track, row).set_on_off_values(RED_FULL, LED_OFF)

            self._sliders[track].set_mode(SLIDER_MODE_VOLUME)
            self._sliders[track].set_value_map(SEND_VALUE_MAP)
            strip.set_send_controls((None, self._sliders[track]))

        self._session.set_stop_track_clip_buttons(None)
        self._session.set_stop_all_clips_button(None)
        self._mixer.set_global_buttons(None, None, None)
########NEW FILE########
__FILENAME__ = ButtonSysexControl
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launch_Control/ButtonSysexControl.py
from _Framework.SysexValueControl import SysexValueControl

class ButtonSysexControl(SysexValueControl):
    """
    A SysexValueControl that behaves like a button so it can be used as a mode button of
    the ModesComponent.
    """

    def set_light(self, value):
        pass

    def is_momentary(self):
        return False
########NEW FILE########
__FILENAME__ = Colors
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launch_Control/Colors.py
LED_OFF = 4
LED_ON = 15
RED_FULL = 7
RED_HALF = 6
RED_THIRD = 5
RED_BLINK = 11
GREEN_FULL = 52
GREEN_HALF = 36
GREEN_THIRD = 20
GREEN_BLINK = 56
YELLOW_FULL = 62
AMBER_FULL = RED_FULL + GREEN_FULL - 4
AMBER_HALF = RED_HALF + GREEN_HALF - 4
AMBER_THIRD = RED_THIRD + GREEN_THIRD - 4
AMBER_BLINK = AMBER_FULL - 4 + 8
########NEW FILE########
__FILENAME__ = ConfigurableButtonElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launch_Control/ConfigurableButtonElement.py
from Launchpad.ConfigurableButtonElement import ConfigurableButtonElement as LaunchpadButtonElement
import Colors

class ConfigurableButtonElement(LaunchpadButtonElement):

    def set_light(self, value):
        if value is Colors.LED_OFF:
            self.send_value(value)
        else:
            super(ConfigurableButtonElement, self).set_light(value)
########NEW FILE########
__FILENAME__ = DeviceNavigationComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launch_Control/DeviceNavigationComponent.py
import Live
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.SubjectSlot import subject_slot

class DeviceNavigationComponent(ControlSurfaceComponent):
    _next_button = None
    _previous_button = None

    def set_next_device_button(self, button):
        self._next_button = button
        self._update_button_states()
        self._on_next_device.subject = button

    def set_previous_device_button(self, button):
        self._previous_button = button
        self._update_button_states()
        self._on_previous_device.subject = button

    @subject_slot('value')
    def _on_next_device(self, value):
        if value:
            self._scroll_device_view(Live.Application.Application.View.NavDirection.right)

    @subject_slot('value')
    def _on_previous_device(self, value):
        if value:
            self._scroll_device_view(Live.Application.Application.View.NavDirection.left)

    def _scroll_device_view(self, direction):
        self.application().view.show_view('Detail')
        self.application().view.show_view('Detail/DeviceChain')
        self.application().view.scroll_view(direction, 'Detail/DeviceChain', False)

    def _update_button_states(self):
        if self._next_button:
            self._next_button.turn_on()
        if self._previous_button:
            self._previous_button.turn_on()

    def update(self):
        if self.is_enabled():
            self._update_button_states()
########NEW FILE########
__FILENAME__ = LaunchControl
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launch_Control/LaunchControl.py
from __future__ import with_statement
from functools import partial
import Live
from _Framework import Task
from _Framework.ButtonMatrixElement import ButtonMatrixElement
from _Framework.ControlSurface import ControlSurface
from _Framework.DeviceBankRegistry import DeviceBankRegistry
from _Framework.DeviceComponent import DeviceComponent
from _Framework.EncoderElement import EncoderElement
from _Framework.InputControlElement import MIDI_NOTE_TYPE, MIDI_CC_TYPE
from _Framework.Layer import Layer
from _Framework.ModesComponent import ModesComponent, LayerMode
from _Framework.SubjectSlot import subject_slot
from _Framework.Util import nop
from Push.ViewControlComponent import ViewControlComponent
from ButtonSysexControl import ButtonSysexControl
from ConfigurableButtonElement import ConfigurableButtonElement
from DeviceNavigationComponent import DeviceNavigationComponent
from SpecialMixerComponent import SpecialMixerComponent
from SpecialSessionComponent import SpecialSessionComponent
import Colors
import Sysex

def make_launch_control_button(identifier, name, channel = 0, is_pad = False):
    button = ConfigurableButtonElement(True, MIDI_NOTE_TYPE if is_pad else MIDI_CC_TYPE, channel, identifier)
    button.name = name
    button.set_on_off_values(Colors.LED_ON, Colors.LED_OFF)
    return button


def make_launch_control_encoder(identifier, name, channel = 0):
    encoder = EncoderElement(MIDI_CC_TYPE, channel, identifier, Live.MidiMap.MapMode.absolute)
    encoder.reset = nop
    encoder.set_feedback_delay(-1)
    encoder.name = name
    return encoder


def make_all_encoders(name_prefix = '', make_encoder = make_launch_control_encoder):
    return ([ make_encoder(41 + index, name_prefix + '_Bottom_Encoder_' + str(index)) for index in xrange(8) ], [ make_encoder(21 + index, name_prefix + '_Top_Encoder_' + str(index)) for index in xrange(8) ])


pad_identifiers = [ (9 + i if i < 4 else 21 + i) for i in xrange(8) ]
CC_STATUS = 176
MODE_SYSEX_MAP = {'mixer': Sysex.MIXER_MODE,
 'session': Sysex.SESSION_MODE,
 'device': Sysex.DEVICE_MODE}
SYSEX_MODE_MAP = dict([ (v, k) for k, v in MODE_SYSEX_MAP.iteritems() ])

class LaunchControl(ControlSurface):

    def __init__(self, c_instance):
        super(LaunchControl, self).__init__(c_instance)
        with self.component_guard():
            self._device_selection_follows_track_selection = True
            self._init_mixer()
            self._init_session()
            self._init_device()
            self._init_modes()
            self._refresh_state_task = self._tasks.add(Task.sequence(Task.delay(3), Task.run(self._do_refresh_state)))
            self._refresh_state_task.kill()
        self.log_message('Launch Control script loaded')

    def disconnect(self):
        super(LaunchControl, self).disconnect()
        for channel in xrange(16):
            self._send_midi((CC_STATUS + channel, 0, 0))

    def refresh_state(self):
        self._refresh_state_task.restart()

    def _do_refresh_state(self):
        self._send_current_mode()
        self._update_hardware()
        self.schedule_message(3, super(LaunchControl, self).refresh_state)

    def _update_hardware(self):
        for channel in xrange(8, 11):
            self._send_midi(Sysex.make_automatic_flashing_message(channel))

    def _send_current_mode(self):
        try:
            self._send_midi(MODE_SYSEX_MAP[self._modes.selected_mode])
        except KeyError:
            pass

    def _init_mixer(self):
        make_button = partial(make_launch_control_button, channel=8)
        make_encoder = partial(make_launch_control_encoder, channel=8)
        bottom_encoders, top_encoders = make_all_encoders('Mixer', make_encoder)
        pan_volume_layer = Layer(volume_controls=ButtonMatrixElement(rows=[bottom_encoders]), pan_controls=ButtonMatrixElement(rows=[top_encoders]))
        sends_layer = Layer(sends_controls=ButtonMatrixElement(rows=[bottom_encoders, top_encoders]))
        modes_layer = Layer(pan_volume_button=make_button(114, 'Pan_Volume_Mode_Button'), sends_button=make_button(115, 'Sends_Mode_Button'))
        self._mixer = SpecialMixerComponent(8, modes_layer, pan_volume_layer, sends_layer)
        self._mixer.name = 'Mixer'
        self._mixer.selected_strip().name = 'Selected_Channel_Strip'
        self._mixer.master_strip().name = 'Master_Channel_Strip'
        self._mixer_track_nav_layer = Layer(track_bank_left_button=make_button(116, 'Mixer_Track_Left_Button'), track_bank_right_button=make_button(117, 'Mixer_Track_Right_Button'))
        for index in xrange(8):
            strip = self._mixer.channel_strip(index)
            strip.name = 'Channel_Strip_' + str(index)
            strip.empty_color = Colors.LED_OFF
            strip.set_invert_mute_feedback(True)
            mute_button = make_button(pad_identifiers[index], 'Track_Mute_Button_' + str(index), is_pad=True)
            mute_button.set_on_off_values(Colors.AMBER_FULL, Colors.AMBER_THIRD)
            strip.set_mute_button(mute_button)

        self._on_selected_send_index.subject = self._mixer
        self._on_selected_mixer_mode.subject = self._mixer

    def _init_session(self):
        make_button = partial(make_launch_control_button, channel=9)
        make_encoder = partial(make_launch_control_encoder, channel=9)
        bottom_encoders, top_encoders = make_all_encoders('Session_Mixer', make_encoder)
        pan_volume_layer = Layer(volume_controls=ButtonMatrixElement(rows=[bottom_encoders]), pan_controls=ButtonMatrixElement(rows=[top_encoders]))
        self._session_mixer = SpecialMixerComponent(8, Layer(), pan_volume_layer, Layer())
        self._session_mixer.set_enabled(False)
        self._session_mixer.name = 'Session_Mixer'
        clip_launch_buttons = [ make_button(identifier, 'Clip_Launch_Button_' + str(i), is_pad=True) for i, identifier in enumerate(pad_identifiers) ]
        self._session = SpecialSessionComponent(num_tracks=8, num_scenes=0, name='Session')
        self._session.set_enabled(False)
        self._session.set_mixer(self._session_mixer)
        self._session_layer = Layer(track_bank_left_button=make_button(116, 'Track_Bank_Left_Button'), track_bank_right_button=make_button(117, 'Track_Bank_Right_Button'), select_prev_button=make_button(114, 'Scene_Bank_Up_Button'), select_next_button=make_button(115, 'Scene_Bank_Down_Button'), clip_launch_buttons=ButtonMatrixElement(rows=[clip_launch_buttons]))
        scene = self._session.selected_scene()
        for index in range(8):
            clip_slot = scene.clip_slot(index)
            clip_slot.set_triggered_to_play_value(Colors.GREEN_BLINK)
            clip_slot.set_triggered_to_record_value(Colors.RED_BLINK)
            clip_slot.set_stopped_value(Colors.AMBER_FULL)
            clip_slot.set_started_value(Colors.GREEN_FULL)
            clip_slot.set_recording_value(Colors.RED_FULL)
            clip_slot.name = 'Selected_Clip_Slot_' + str(index)

        self._on_track_offset.subject = self._session

    def _init_device(self):
        make_button = partial(make_launch_control_button, channel=10)
        make_encoder = partial(make_launch_control_encoder, channel=10)
        bottom_encoders, top_encoders = make_all_encoders('Device', make_encoder)
        parameter_controls = top_encoders[:4] + bottom_encoders[:4]
        bank_buttons = [ make_button(identifier, 'Device_Bank_Button_' + str(i), is_pad=True) for i, identifier in enumerate(pad_identifiers) ]
        for button in bank_buttons:
            button.set_on_off_values(Colors.LED_ON, Colors.LED_OFF)

        self._device_bank_registry = DeviceBankRegistry()
        self._device = DeviceComponent(device_bank_registry=self._device_bank_registry, name='Device')
        self._device.set_enabled(False)
        self._device.layer = Layer(parameter_controls=ButtonMatrixElement(rows=[parameter_controls]), bank_buttons=ButtonMatrixElement(rows=[bank_buttons]))
        self.set_device_component(self._device)
        self._device_navigation = DeviceNavigationComponent()
        self._device_navigation.set_enabled(False)
        self._device_navigation.name = 'Device_Navigation'
        self._device_navigation.layer = Layer(next_device_button=make_button(115, 'Next_Device_Button'), previous_device_button=make_button(114, 'Prev_Device_Button'))
        self._view_control = ViewControlComponent()
        self._view_control.set_enabled(False)
        self._view_control.name = 'View_Control'
        self._view_control.layer = Layer(next_track_button=make_button(117, 'Device_Next_Track_Button'), prev_track_button=make_button(116, 'Device_Prev_Track_Button'))

    def _init_modes(self):
        self._modes = ModesComponent()
        self._modes.add_mode('mixer', [partial(self._session.set_mixer, self._mixer),
         LayerMode(self._session, self._mixer_track_nav_layer),
         self._mixer,
         self._session,
         self._show_controlled_tracks_message])
        self._modes.add_mode('session', [partial(self._session.set_mixer, self._session_mixer),
         LayerMode(self._session, self._session_layer),
         self._session_mixer,
         self._session,
         self._show_controlled_tracks_message])
        self._modes.add_mode('device', [self._device, self._device_navigation, self._view_control])
        self._modes.add_mode('user', None)
        self._modes.selected_mode = 'mixer'
        self._modes.layer = Layer(mixer_button=ButtonSysexControl(Sysex.MIXER_MODE), session_button=ButtonSysexControl(Sysex.SESSION_MODE), device_button=ButtonSysexControl(Sysex.DEVICE_MODE))

    @subject_slot('offset')
    def _on_track_offset(self):
        self._show_controlled_tracks_message()

    @subject_slot('selected_send_index')
    def _on_selected_send_index(self, index):
        self._show_controlled_sends_message()

    @subject_slot('selected_mixer_mode')
    def _on_selected_mixer_mode(self, mode):
        if mode == 'sends':
            self._show_controlled_sends_message()
        else:
            self.show_message('Controlling Pan and Volume')

    def _show_controlled_tracks_message(self):
        start = self._session.track_offset() + 1
        end = min(start + 8, len(self._session.tracks_to_use()))
        if start < end:
            self.show_message('Controlling Track %d to %d' % (start, end))
        else:
            self.show_message('Controlling Track %d' % start)

    def _show_controlled_sends_message(self):
        send_index = self._mixer.selected_send_index
        send_name1 = chr(ord('A') + send_index)
        if send_index + 1 < self._mixer.num_sends:
            send_name2 = chr(ord('A') + send_index + 1)
            self.show_message('Controlling Send %s and %s' % (send_name1, send_name2))
        else:
            self.show_message('Controlling Send %s' % send_name1)

    def handle_sysex(self, midi_bytes):
        super(LaunchControl, self).handle_sysex(midi_bytes)
        if self._is_user_mode_message(midi_bytes):
            self._modes.selected_mode = 'user'
            self.request_rebuild_midi_map()

    def _is_user_mode_message(self, midi_bytes):
        """
        True if midi_byes refer to a mode change, but none of the three
        predefined Live modes
        """
        return midi_bytes[:7] == Sysex.MODE_CHANGE_PREFIX and midi_bytes not in SYSEX_MODE_MAP
########NEW FILE########
__FILENAME__ = SpecialMixerComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launch_Control/SpecialMixerComponent.py
from _Framework.MixerComponent import MixerComponent
from _Framework.ModesComponent import ModesComponent, LayerMode, LatchingBehaviour
from _Framework.SubjectSlot import subject_slot
from _Framework.Util import clamp

class SendSelectButtonBehaviour(LatchingBehaviour):

    def __init__(self, mixer = None, *a, **k):
        super(SendSelectButtonBehaviour, self).__init__(*a, **k)
        self._mixer = mixer

    def press_immediate(self, component, mode):
        if component.selected_mode == 'sends':
            self._mixer.selected_send_index += 2
        else:
            super(SendSelectButtonBehaviour, self).press_immediate(component, mode)


class SpecialMixerComponent(MixerComponent):
    __subject_events__ = ('selected_send_index', 'selected_mixer_mode')

    def __init__(self, num_tracks, mode_layer = None, pan_volume_layer = None, sends_layer = None, *a, **k):
        super(SpecialMixerComponent, self).__init__(num_tracks, *a, **k)
        self.set_enabled(False)
        self._send_controls = None
        self._selected_send_index = 0
        self._modes = self.register_component(ModesComponent())
        self._modes.add_mode('pan_volume', [LayerMode(self, pan_volume_layer)])
        self._modes.add_mode('sends', [LayerMode(self, sends_layer)], behaviour=SendSelectButtonBehaviour(self))
        self._modes.selected_mode = 'pan_volume'
        self._modes.layer = mode_layer
        self._on_visible_tracks.subject = self.song()
        self._on_selected_mixer_mode.subject = self._modes

    def _get_selected_send_index(self):
        return self._selected_send_index

    def _set_selected_send_index(self, value):
        self._selected_send_index = value
        self._cycle_send_index()
        self._update_send_controls()
        self.notify_selected_send_index(self._selected_send_index)

    selected_send_index = property(_get_selected_send_index, _set_selected_send_index)

    def set_pan_controls(self, controls):
        for control, channel_strip in map(None, controls or [], self._channel_strips):
            if channel_strip:
                channel_strip.set_pan_control(control)

    def set_volume_controls(self, controls):
        for control, channel_strip in map(None, controls or [], self._channel_strips):
            if channel_strip:
                channel_strip.set_volume_control(control)

    def set_sends_controls(self, controls):
        self._send_controls = controls
        self._update_send_controls()

    @property
    def num_sends(self):
        return len(self.song().tracks[0].mixer_device.sends)

    def _cycle_send_index(self):
        if self._selected_send_index >= self.num_sends:
            self._selected_send_index = 0

    def _clamp_send_index(self):
        self._selected_send_index = clamp(self._selected_send_index, 0, self.num_sends - 1)
        if self._selected_send_index % 2 > 0:
            self._selected_send_index -= 1

    def _update_send_controls(self):
        for index, channel_strip in enumerate(self._channel_strips):
            send_controls = [ self._send_controls.get_button(index, i) for i in (1, 0) ] if self._send_controls else [None]
            skipped_sends = [ None for _ in xrange(self._selected_send_index) ]
            channel_strip.set_send_controls(skipped_sends + send_controls)

    @subject_slot('visible_tracks')
    def _on_visible_tracks(self):
        self._clamp_send_index()
        self._update_send_controls()

    @subject_slot('selected_mode')
    def _on_selected_mixer_mode(self, mode):
        self.notify_selected_mixer_mode(mode)

    def update(self):
        pass
########NEW FILE########
__FILENAME__ = SpecialSessionComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launch_Control/SpecialSessionComponent.py
from _Framework.SessionComponent import SessionComponent

class SpecialSessionComponent(SessionComponent):

    def set_clip_launch_buttons(self, buttons):
        for i, button in map(None, xrange(self._num_tracks), buttons or []):
            scene = self.selected_scene()
            slot = scene.clip_slot(i)
            slot.set_launch_button(button)
########NEW FILE########
__FILENAME__ = Sysex
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Launch_Control/Sysex.py
MODE_CHANGE_PREFIX = (240, 0, 32, 41, 2, 10, 119)
MIXER_MODE = (240, 0, 32, 41, 2, 10, 119, 8, 247)
SESSION_MODE = (240, 0, 32, 41, 2, 10, 119, 9, 247)
DEVICE_MODE = (240, 0, 32, 41, 2, 10, 119, 10, 247)

def make_automatic_flashing_message(channel):
    return (176 + channel, 0, 40)
########NEW FILE########
__FILENAME__ = copy_reg
"""Helper to provide extensibility for pickle/cPickle.

This is only useful to add pickle support for extension types defined in
C, not for instances of user-defined classes.
"""

from types import ClassType as _ClassType

__all__ = ["pickle", "constructor",
           "add_extension", "remove_extension", "clear_extension_cache"]

dispatch_table = {}

def pickle(ob_type, pickle_function, constructor_ob=None):
    if type(ob_type) is _ClassType:
        raise TypeError("copy_reg is not intended for use with classes")

    if not callable(pickle_function):
        raise TypeError("reduction functions must be callable")
    dispatch_table[ob_type] = pickle_function

    # The constructor_ob function is a vestige of safe for unpickling.
    # There is no reason for the caller to pass it anymore.
    if constructor_ob is not None:
        constructor(constructor_ob)

def constructor(object):
    if not callable(object):
        raise TypeError("constructors must be callable")

# Example: provide pickling support for complex numbers.

try:
    complex
except NameError:
    pass
else:

    def pickle_complex(c):
        return complex, (c.real, c.imag)

    pickle(complex, pickle_complex, complex)

# Support for pickling new-style objects

def _reconstructor(cls, base, state):
    if base is object:
        obj = object.__new__(cls)
    else:
        obj = base.__new__(cls, state)
        base.__init__(obj, state)
    return obj

_HEAPTYPE = 1<<9

# Python code for object.__reduce_ex__ for protocols 0 and 1

def _reduce_ex(self, proto):
    assert proto < 2
    for base in self.__class__.__mro__:
        if hasattr(base, '__flags__') and not base.__flags__ & _HEAPTYPE:
            break
    else:
        base = object # not really reachable
    if base is object:
        state = None
    else:
        if base is self.__class__:
            raise TypeError, "can't pickle %s objects" % base.__name__
        state = base(self)
    args = (self.__class__, base, state)
    try:
        getstate = self.__getstate__
    except AttributeError:
        if getattr(self, "__slots__", None):
            raise TypeError("a class that defines __slots__ without "
                            "defining __getstate__ cannot be pickled")
        try:
            dict = self.__dict__
        except AttributeError:
            dict = None
    else:
        dict = getstate()
    if dict:
        return _reconstructor, args, dict
    else:
        return _reconstructor, args

# Helper for __reduce_ex__ protocol 2

def __newobj__(cls, *args):
    return cls.__new__(cls, *args)

def _slotnames(cls):
    """Return a list of slot names for a given class.

    This needs to find slots defined by the class and its bases, so we
    can't simply return the __slots__ attribute.  We must walk down
    the Method Resolution Order and concatenate the __slots__ of each
    class found there.  (This assumes classes don't modify their
    __slots__ attribute to misrepresent their slots after the class is
    defined.)
    """

    # Get the value from a cache in the class if possible
    names = cls.__dict__.get("__slotnames__")
    if names is not None:
        return names

    # Not cached -- calculate the value
    names = []
    if not hasattr(cls, "__slots__"):
        # This class has no slots
        pass
    else:
        # Slots found -- gather slot names from all base classes
        for c in cls.__mro__:
            if "__slots__" in c.__dict__:
                slots = c.__dict__['__slots__']
                # if class has a single slot, it can be given as a string
                if isinstance(slots, basestring):
                    slots = (slots,)
                for name in slots:
                    # special descriptors
                    if name in ("__dict__", "__weakref__"):
                        continue
                    # mangled names
                    elif name.startswith('__') and not name.endswith('__'):
                        names.append('_%s%s' % (c.__name__, name))
                    else:
                        names.append(name)

    # Cache the outcome in the class if at all possible
    try:
        cls.__slotnames__ = names
    except:
        pass # But don't die if we can't

    return names

# A registry of extension codes.  This is an ad-hoc compression
# mechanism.  Whenever a global reference to <module>, <name> is about
# to be pickled, the (<module>, <name>) tuple is looked up here to see
# if it is a registered extension code for it.  Extension codes are
# universal, so that the meaning of a pickle does not depend on
# context.  (There are also some codes reserved for local use that
# don't have this restriction.)  Codes are positive ints; 0 is
# reserved.

_extension_registry = {}                # key -> code
_inverted_registry = {}                 # code -> key
_extension_cache = {}                   # code -> object
# Don't ever rebind those names:  cPickle grabs a reference to them when
# it's initialized, and won't see a rebinding.

def add_extension(module, name, code):
    """Register an extension code."""
    code = int(code)
    if not 1 <= code <= 0x7fffffff:
        raise ValueError, "code out of range"
    key = (module, name)
    if (_extension_registry.get(key) == code and
        _inverted_registry.get(code) == key):
        return # Redundant registrations are benign
    if key in _extension_registry:
        raise ValueError("key %s is already registered with code %s" %
                         (key, _extension_registry[key]))
    if code in _inverted_registry:
        raise ValueError("code %s is already in use for key %s" %
                         (code, _inverted_registry[code]))
    _extension_registry[key] = code
    _inverted_registry[code] = key

def remove_extension(module, name, code):
    """Unregister an extension code.  For testing only."""
    key = (module, name)
    if (_extension_registry.get(key) != code or
        _inverted_registry.get(code) != key):
        raise ValueError("key %s is not registered with code %s" %
                         (key, code))
    del _extension_registry[key]
    del _inverted_registry[code]
    if code in _extension_cache:
        del _extension_cache[code]

def clear_extension_cache():
    _extension_cache.clear()

# Standard extension code assignments

# Reserved ranges

# First  Last Count  Purpose
#     1   127   127  Reserved for Python standard library
#   128   191    64  Reserved for Zope
#   192   239    48  Reserved for 3rd parties
#   240   255    16  Reserved for private use (will never be assigned)
#   256   Inf   Inf  Reserved for future assignment

# Extension codes are assigned by the Python Software Foundation.

########NEW FILE########
__FILENAME__ = LC2ChannelDeviceComponent
#Embedded file name: /Applications/Ableton Live 9 Suite.app/Contents/App-Resources/MIDI Remote Scripts/LiveControl_2_0/LC2ChannelDeviceComponent.py
from _Framework.DeviceComponent import DeviceComponent
from LC2Sysex import LC2Sysex

class LC2ChannelDeviceComponent(DeviceComponent):

    def __init__(self):
        DeviceComponent.__init__(self)
        self._device_banks = {}

    def bank(self, ud):
        if self._device is not None:
            LC2Sysex.log_message('device')
            if ud:
                num_banks = self.number_of_parameter_banks(self._device)
                LC2Sysex.log_message('up' + str(num_banks))
                if num_banks > self._bank_index + 1:
                    self._bank_name = ''
                    self._bank_index += 1
                    self.update()
            elif self._bank_index > 0:
                self._bank_name = ''
                self._bank_index -= 1
                self.update()

    def number_of_parameter_banks(self, device):
        result = 0
        if device != None:
            param_count = len(list(device.parameters))
            result = param_count / 4
            if not param_count % 4 == 0:
                result += 1
        return result

    def _assign_parameters(self):
        raise self.is_enabled() or AssertionError
        raise self._device != None or AssertionError
        raise self._parameter_controls != None or AssertionError
        parameters = self._device_parameters_to_map()
        num_controls = len(self._parameter_controls)
        index = self._bank_index * num_controls
        for control in self._parameter_controls:
            if index < len(parameters):
                control.connect_to(parameters[index])
            else:
                control.release_parameter()
            index += 1
########NEW FILE########
__FILENAME__ = LC2ChannelStripComponent
#Embedded file name: /Applications/Ableton Live 9 Suite.app/Contents/App-Resources/MIDI Remote Scripts/LiveControl_2_0/LC2ChannelStripComponent.py
from _Framework.ChannelStripComponent import ChannelStripComponent
from LC2ChannelDeviceComponent import LC2ChannelDeviceComponent
from LC2Sysex import LC2Sysex

class LC2ChannelStripComponent(ChannelStripComponent):

    @staticmethod
    def set_get_offsets(func):
        LC2ChannelStripComponent._get_offset = func

    @staticmethod
    def set_playing_slot_changed(func):
        LC2ChannelStripComponent.playing_slot_changed = func

    @staticmethod
    def release_attributes():
        LC2ChannelStripComponent._get_offset = None
        LC2ChannelStripComponent.playing_slot_changed = None

    def __init__(self, id):
        self._monitor_toggle = None
        ChannelStripComponent.__init__(self)
        self._track_id = id
        self._device = LC2ChannelDeviceComponent()

    def _send_init(self):
        self._send_state()
        self._on_selected_device_changed()

    def set_track(self, track):
        if self._track is not None:
            try:
                self._track.remove_color_listener(self._on_color_changed)
                self._track.remove_devices_listener(self._on_devices_changed)
                self._track.view.remove_selected_device_listener(self._on_selected_device_changed)
            except:
                pass

            if self._track in self.song().tracks and not self._track.is_foldable:
                self._track.remove_current_monitoring_state_listener(self._on_monitor_changed)
                self._track.remove_playing_slot_index_listener(self._on_playing_slot_changed)
        ChannelStripComponent.set_track(self, track)
        if track is not None:
            self._track.add_color_listener(self._on_color_changed)
            self._track.add_devices_listener(self._on_devices_changed)
            self._track.view.add_selected_device_listener(self._on_selected_device_changed)
            if track in self.song().tracks and not track.is_foldable:
                self._track.add_current_monitoring_state_listener(self._on_monitor_changed)
                self._track.add_playing_slot_index_listener(self._on_playing_slot_changed)
        self._on_selected_device_changed()

    def _on_playing_slot_changed(self):
        if hasattr(self, 'playing_slot_changed'):
            if self._track is not None:
                if self._track.playing_slot_index > -1:
                    self.playing_slot_changed(self._track.playing_slot_index, self._track.name)

    def set_monitor_toggle(self, control):
        if self._monitor_toggle is not None:
            self._monitor_toggle.remove_value_listener(self._on_monitor_value)
        self._monitor_toggle = control
        if control is not None:
            self._monitor_toggle.add_value_listener(self._on_monitor_value)

    def _on_monitor_value(self, value):
        if self.is_enabled():
            if self._track is not None and self._track in self.song().tracks:
                if value != 0 or not self._monitor_toggle.is_momentary():
                    self._track.current_monitoring_state = (self._track.current_monitoring_state + 1) % 3

    def _on_monitor_changed(self):
        if self.is_enabled() and self._monitor_toggle != None:
            if self._track != None and self._track in self.song().tracks and not self._track.is_foldable:
                self._monitor_toggle.send_value(self._track.current_monitoring_state)
            else:
                self._monitor_toggle.send_value(1)

    def _on_routing_changed2(self):
        self._on_routing_changed()

    def _on_routing_changed3(self):
        self._on_routing_changed()

    def _on_routing_changed4(self):
        self._on_routing_changed()

    def _on_routing_changed(self):
        if self._track_id < 8:
            self._send_routings()
            sysex = LC2Sysex('TRACK_ROUTING')
            sysex.byte(self._track_id)
            if self._track is not None:
                objs = [self._track.input_routings,
                 self._track.current_input_routing,
                 self._track.input_sub_routings,
                 self._track.current_input_sub_routing,
                 self._track.output_routings,
                 self._track.current_output_routing,
                 self._track.output_sub_routings,
                 self._track.current_output_sub_routing]
                for i in range(4):
                    if objs[i * 2 + 1] in objs[i * 2]:
                        sysex.byte(list(objs[i * 2]).index(objs[i * 2 + 1]))
                    elif objs[i * 2 + 1] == 'None':
                        sysex.byte(len(objs[i * 2]) - 1)
                    else:
                        sysex.byte(127)

            else:
                sysex.byte(127)
                sysex.byte(127)
                sysex.byte(127)
                sysex.byte(127)
            sysex.send()

    def _send_routings(self):
        if self._track_id < 8:
            if self._track is not None:
                for id, type in enumerate([self._track.input_routings,
                 self._track.input_sub_routings,
                 self._track.output_routings,
                 self._track.output_sub_routings]):
                    sysex = LC2Sysex('TRACK_ROUTING_LIST')
                    sysex.byte(self._track_id)
                    sysex.byte(id)
                    sysex.byte(min(12, len(type)))
                    for i in range(12):
                        if i < len(type):
                            sysex.trim(type[i], 10)
                        else:
                            sysex.ascii(' ')

                    sysex.send()

            else:
                for i in range(4):
                    sysex = LC2Sysex('TRACK_ROUTING_LIST')
                    sysex.byte(self._track_id)
                    sysex.byte(i)
                    sysex.byte(0)
                    for j in range(12):
                        sysex.ascii('')

                    sysex.send()

    def _on_selected_device_changed(self):
        if self._track is not None:
            if hasattr(self._track, 'view'):
                self._device.set_device(self._track.view.selected_device)
            else:
                self._device.set_device(None)
        else:
            self._device.set_device(None)
        name = ''
        if self._track is not None:
            if self._track.view.selected_device is not None:
                name = self._track.view.selected_device.name
        sysex = LC2Sysex('TRACK_DEVICE_NAME')
        sysex.byte(self._track_id)
        sysex.ascii(name)
        sysex.send()

    def set_device_controls(self, controls):
        self._device.set_parameter_controls(controls)

    def set_device_bank_controls(self, up, down):
        self._device.set_bank_controls(up, down)

    def _on_track_name_changed(self):
        ChannelStripComponent._on_track_name_changed(self)
        self._send_state()

    def _on_color_changed(self):
        self._send_state()

    def _on_devices_changed(self):
        self._send_devices()

    def _send_state(self):
        if hasattr(self, '_get_offset'):
            offsets = self._get_offset()
            if self._track_id < offsets[2]:
                has_track = 0
                if self._track is not None and self._track in self.song().tracks:
                    has_track = 1
                    if self._track.has_midi_input:
                        has_track = 2
                sysex = LC2Sysex('TRACK')
                sysex.byte(self._track_id)
                sysex.byte(has_track)
                sysex.ascii(self._track is not None and self._track.name or '')
                sysex.rgb(self._track is not None and self._track.color or 0)
                if self._track in self.song().tracks:
                    sysex.ascii(str(list(self.song().tracks).index(self._track) + 1))
                elif self._track in self.song().return_tracks:
                    sysex.ascii(chr(list(self.song().return_tracks).index(self._track) + 65))
                else:
                    sysex.ascii(' ')
                sysex.send()
                self._send_devices()

    def _send_devices(self):
        if hasattr(self, '_get_offset'):
            offsets = self._get_offset()
            if self._track_id < 8 and self._track_id < offsets[2]:
                sysex = LC2Sysex('TRACK_DEVICES')
                sysex.byte(self._track_id)
                if self._track is not None:
                    sysex.byte(min(8, len(self._track.devices)))
                else:
                    sysex.byte(0)
                for i in range(8):
                    if self._track is not None:
                        if i < len(self._track.devices):
                            name = unicode(self._track.devices[i].name)
                        else:
                            name = ''
                    else:
                        name = ''
                    sysex.ascii(name)

                sysex.send()

    def playing_position(self):
        if self.is_enabled():
            if self._track is not None and self._track in self.song().visible_tracks:
                idx = self._track.playing_slot_index
            else:
                idx = -3
            if idx > -1:
                clip = self._track.clip_slots[idx].clip
                if clip is not None:
                    val = abs(int((clip.playing_position - clip.loop_start) / (clip.loop_end - clip.loop_start) * 127))
                    return val > 127 and 127 or val
                else:
                    return 0
            else:
                return 0

    def track_meters(self):
        if self._track is not None:
            if self._track.has_audio_output:
                l = int(self._track.output_meter_left * 127)
                r = int(self._track.output_meter_right * 127)
            else:
                l = 0
                r = 0
            return [l, r]
        else:
            return [0, 0]

    def update(self):
        ChannelStripComponent.update(self)
        if self._allow_updates:
            if self.is_enabled():
                if self._track in self.song().tracks:
                    self._on_monitor_changed()
                self._on_selected_device_changed()
                self._on_monitor_changed()
                self._send_state()
        else:
            self._update_requests += 1

    def select_device(self, id):
        if self._track is not None:
            if id < len(self._track.devices):
                self.song().view.select_device(self._track.devices[id])

    def device_bank(self, ud):
        if self._track is not None:
            self._device.bank(ud)

    def _on_cf_assign_changed(self):
        if self.is_enabled() and self._crossfade_toggle != None:
            if self._track != None and (self._track in self.song().tracks or self._track in self.song().return_tracks):
                self._crossfade_toggle.send_value(self._track.mixer_device.crossfade_assign)
            else:
                self._crossfade_toggle.send_value(1)

    def set_send_control(self, control):
        self._send_control = control
        self.set_send_controls(tuple([control] + [ None for i in range(11) ]))

    def select_send(self, id):
        controls = [ None for i in range(12) ]
        controls[id] = self._send_control
        self.set_send_controls(tuple(controls))

    def set_routing(self, type, val):
        return
        if self._track is not None:
            types = ['current_input_routing',
             'current_input_sub_routing',
             'current_output_routing',
             'current_output_sub_routing']
            vals = [self._track.input_routings,
             self._track.input_sub_routings,
             self._track.output_routings,
             self._track.output_sub_routings]
            if type < len(types):
                if val < len(vals[type]):
                    if getattr(self._track, types[type]) != vals[type][val]:
                        setattr(self._track, types[type], vals[type][val])

    def select(self):
        if self._track is not None:
            self.song().view.selected_track = self._track
########NEW FILE########
__FILENAME__ = LC2ClipSlotComponent
#Embedded file name: /Applications/Ableton Live 9 Suite.app/Contents/App-Resources/MIDI Remote Scripts/LiveControl_2_0/LC2ClipSlotComponent.py
from _Framework.ClipSlotComponent import ClipSlotComponent
from LC2Sysex import LC2Sysex

class LC2ClipSlotComponent(ClipSlotComponent):

    def set_get_offsets(func):
        LC2ClipSlotComponent._get_offset = func

    set_get_offsets = staticmethod(set_get_offsets)

    def release_attributes():
        LC2ClipSlotComponent._get_offset = None

    release_attributes = staticmethod(release_attributes)

    def __init__(self, tid, sid):
        ClipSlotComponent.__init__(self)
        self._tid = tid
        self._sid = sid

    def set_clip_slot(self, clip_slot):
        if clip_slot != self._clip_slot:
            if self._clip_slot is not None:
                try:
                    self._clip_slot.remove_has_stop_button_listener(self._send_state)
                    if self.has_clip():
                        self._clip_slot.clip.remove_color_listener(self._on_color_changed)
                        self._clip_slot.clip.remove_name_listener(self._on_name_changed)
                except:
                    pass

            ClipSlotComponent.set_clip_slot(self, clip_slot)
            if self._clip_slot is not None:
                self._clip_slot.add_has_stop_button_listener(self._send_state)
                if self.has_clip():
                    self._clip_slot.clip.add_color_listener(self._on_color_changed)
                    self._clip_slot.clip.add_name_listener(self._on_name_changed)

    def _on_clip_state_changed(self):
        ClipSlotComponent._on_clip_state_changed(self)
        if self.has_clip():
            if not self._clip_slot.clip.color_has_listener(self._on_color_changed):
                self._clip_slot.clip.add_color_listener(self._on_color_changed)
            if not self._clip_slot.clip.name_has_listener(self._on_name_changed):
                self._clip_slot.clip.add_name_listener(self._on_name_changed)
        self._send_state()

    def _on_color_changed(self):
        self._send_state()

    def _on_name_changed(self):
        self._send_state()

    def _on_playing_state_changed(self):
        self._send_state()

    def _send_state(self):
        if self._clip_slot is not None:
            if hasattr(self, '_get_offset'):
                if self._get_offset is not None:
                    offsets = self._get_offset()
                    if self._tid < offsets[2] and self._sid < offsets[3]:
                        sysex = LC2Sysex('CLIP')
                        sysex.byte(self._tid)
                        sysex.byte(self._sid)
                        sysex.trim(self.get_name(), 40)
                        sysex.rgb(self.color())
                        sysex.byte(self.state())
                        sysex.send()

    def get_name(self):
        if self._clip_slot is not None:
            if self._has_clip():
                name = unicode(self._clip_slot.clip.name)
            elif self._clip_slot.controls_other_clips:
                name = '>'
            elif self._clip_slot.has_stop_button:
                name = '[]'
            else:
                name = ''
        else:
            name = ''
        return name

    def state(self):
        playing = 0
        if self._has_clip():
            playing = 1
            if self._clip_slot.clip.is_playing:
                playing = 2
            elif self._clip_slot.clip.is_triggered:
                playing = 3
        elif self._clip_slot is not None:
            if self._clip_slot.is_playing:
                playing = 2
            elif self._clip_slot.is_triggered:
                playing = 3
        return playing

    def color(self):
        if self._clip_slot is not None:
            if self._has_clip():
                rgb = self._clip_slot.clip.color
            elif self._clip_slot.has_stop_button:
                rgb = 3289650
            else:
                rgb = 0
        else:
            rgb = 0
        return rgb

    def _has_clip(self):
        if self._clip_slot is not None:
            return self._clip_slot.has_clip
        else:
            return 0

    def launch(self):
        if self._clip_slot is not None:
            if self._has_clip():
                self._clip_slot.clip.fire()
                if self.song().select_on_launch:
                    self.select()
            else:
                self._clip_slot.fire()

    def select(self):
        if self._clip_slot is not None:
            if self._has_clip():
                self.song().view.selected_track = self._clip_slot.canonical_parent
                self.song().view.selected_scene = self.song().scenes[list(self._clip_slot.canonical_parent.clip_slots).index(self._clip_slot)]

    def update(self):
        if self._allow_updates:
            if self.is_enabled():
                self._send_state()
########NEW FILE########
__FILENAME__ = LC2MixerComponent
#Embedded file name: /Applications/Ableton Live 9 Suite.app/Contents/App-Resources/MIDI Remote Scripts/LiveControl_2_0/LC2MixerComponent.py
from _Framework.MixerComponent import MixerComponent
from LC2ChannelStripComponent import LC2ChannelStripComponent
from LC2Sysex import LC2Sysex, LC2SysexParser

class LC2MixerComponent(MixerComponent):

    def __init__(self, num_tracks):
        self._meter_cache = [ 0 for i in range(num_tracks * 2 + 2) ]
        self._pos_cache = [ 0 for i in range(num_tracks) ]
        MixerComponent.__init__(self, num_tracks)
        self._register_timer_callback(self._update_lemur)
        self._selected_strip = None

    def tracks_to_use(self):
        return tuple(list(self.song().visible_tracks) + list(self.song().return_tracks))

    def disconnect(self):
        self._unregister_timer_callback(self._update_lemur)
        MixerComponent.disconnect(self)

    def _create_strip(self):
        return LC2ChannelStripComponent(len(self._channel_strips))

    def handle_sysex(self, sysex):
        cmds = [self._select_device,
         self._device_bank,
         self._set_routing,
         self._select_track]
        if sysex[0] < len(cmds):
            cmds[sysex[0]](LC2SysexParser(sysex[1:]))

    def _select_track(self, sysex):
        id = sysex.parse('b')
        if id < len(self._channel_strips):
            self.channel_strip(id).select()

    def _set_routing(self, sysex):
        tid, type, val = sysex.parse('bbb')
        if tid < 8:
            self.channel_strip(tid).set_routing(type, val)

    def _device_bank(self, sysex):
        ch, ud = sysex.parse('bb')
        if ch < len(self._channel_strips):
            self.channel_strip(ch).device_bank(ud)

    def _select_device(self, sysex):
        tr, id = sysex.parse('bb')
        LC2Sysex.log_message('device select:' + str(tr) + ' ' + str(id))
        if tr < len(self._channel_strips):
            self.channel_strip(tr).select_device(id)

    def _send_init(self):
        for tr in self._channel_strips:
            tr._send_init()

    def _update_lemur(self):
        if self.is_enabled():
            update = 0
            sysex = LC2Sysex('CLIP_POSITION')
            update2 = 0
            sysex2 = LC2Sysex('TRACK_METERS')
            for id, tr in enumerate(self._channel_strips):
                pos = tr.playing_position()
                sysex.byte(pos)
                meter = tr.track_meters()
                sysex2.byte(meter[0])
                sysex2.byte(meter[1])
                if self._meter_cache[id * 2] != meter[0]:
                    self._meter_cache[id * 2] = meter[0]
                    update2 = 1
                if self._meter_cache[id * 2 + 1] != meter[1]:
                    self._meter_cache[id * 2 + 1] = meter[1]
                    update2 = 1
                if self._pos_cache[id] != pos:
                    self._pos_cache[id] = pos
                    update = 1

            mmeter = self._master_strip.track_meters()
            sysex2.byte(mmeter[0])
            sysex2.byte(mmeter[1])
            if self._meter_cache[16] != mmeter[0]:
                self._meter_cache[16] = mmeter[0]
                update2 = 1
            if self._meter_cache[17] != mmeter[1]:
                self._meter_cache[17] = mmeter[1]
                update2 = 1
            if update:
                sysex.send()
            if update2:
                sysex2.send()
########NEW FILE########
__FILENAME__ = LC2Modulator
#Embedded file name: /Applications/Ableton Live 9 Suite.app/Contents/App-Resources/MIDI Remote Scripts/LiveControl_2_0/LC2Modulator.py
from _Generic.Devices import *
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.DeviceComponent import DeviceComponent
from _Framework.InputControlElement import *
from LC2ParameterElement import LC2ParameterElement
from LC2Sysex import LC2Sysex, LC2SysexParser
import Live

class LC2Modulator(DeviceComponent):

    def __init__(self):
        self._parameter_offset = 0
        self._selected_param = 0
        self._selected_parameter = None
        DeviceComponent.__init__(self)
        LC2ParameterElement.set_select_param(self.select_parameter)
        self._xys = [ LC2ParameterElement(MIDI_PB_TYPE, i, 0) for i in range(8) ]
        self._device_banks = {}
        self.song().view.add_selected_parameter_listener(self._on_selected_parameter_changed)

    def send_xy_map(self):
        sysex = LC2Sysex('XY_MAP')
        for p in self._xys:
            sysex.byte(int(p.mapped_parameter() is not None))

        sysex.send()

    def send_params(self):
        if self._parameter_controls is not None:
            for p in self._parameter_controls:
                p._send_param_val(True)

        self._on_device_name_changed()

    def _on_device_name_changed(self):
        DeviceComponent._on_device_name_changed(self)
        name = 'Please select a device in Live'
        if self._device is not None:
            if self._device.canonical_parent.name:
                pre = self._device.canonical_parent.name
            else:
                pre = 'Chain'
            name = pre + ': ' + unicode(self._device.name)
        sysex = LC2Sysex('DEVICE_NAME')
        sysex.ascii(name)
        sysex.send()

    def select_parameter(self, param):
        self._selected_parameter = param
        self._send_id_param()

    def _on_selected_parameter_changed(self):
        self._selected_parameter = self.song().view.selected_parameter
        self._send_id_param()

    def handle_sysex(self, sysex):
        cmds = [self._select_xy,
         self._set_param,
         self._select_param,
         self._select_chain,
         self._select_chain_device,
         self._select_parent]
        if sysex[0] < len(cmds):
            cmds[sysex[0]](LC2SysexParser(sysex[1:]))

    def disconnect(self):
        self.song().view.remove_selected_parameter_listener(self._on_selected_parameter_changed)

    def _select_chain(self, sysex):
        self._selected_chain_id = sysex.parse('b')
        self._send_chain_devices()

    def _select_chain_device(self, sysex):
        id = sysex.parse('b')
        if self._device is not None:
            if self._selected_chain_id < len(self._device.chains):
                if id < len(self._device.chains[self._selected_chain_id].devices):
                    self.song().view.select_device(self._device.chains[self._selected_chain_id].devices[id])

    def _select_parent(self, sysex):
        if self._device is not None:
            parent = self._device.canonical_parent.canonical_parent
            if isinstance(parent, Live.Device.Device):
                self.song().view.select_device(parent)

    def _select_param(self, sysex):
        id = sysex.parse('b')
        if id < len(self._parameter_controls):
            p = self._parameter_controls[id].mapped_parameter()
            if p is not None:
                self._selected_parameter = p
                self._send_id_param()

    def _set_param(self, sysex):
        v = sysex.parse('b')
        if v:
            if self._selected_parameter is not None:
                for xy in self._xys:
                    if xy.mapped_parameter() == self._selected_parameter:
                        xy.release_parameter()

                self._xys[self._selected_param].connect_to(self._selected_parameter)
        else:
            self._xys[self._selected_param].release_parameter()
        self.send_xy_map()

    def _select_xy(self, sysex):
        pid = sysex.parse('b')
        LC2Sysex.log_message('SELECTING XY ' + str(pid))
        if pid < len(self._xys):
            self._selected_param = pid
            param = self._xys[pid]
            if param.mapped_parameter() is not None:
                if isinstance(param.mapped_parameter().canonical_parent, Live.Device.Device):
                    self.song().view.select_device(param.mapped_parameter().canonical_parent)
            self._send_id_param()

    def _send_id_param(self):
        param = self._xys[self._selected_param]
        if param.mapped_parameter() is not None:
            mapped = 1
            pid, name = param.settings()
        else:
            mapped = 0
            if self._selected_parameter is not None:
                if hasattr(self._selected_parameter, 'canonical_parent'):
                    parent = self._selected_parameter.canonical_parent
                    if not hasattr(parent, 'name'):
                        if hasattr(parent, 'canonical_parent'):
                            parent = parent.canonical_parent
                    pid = unicode(parent.name)
                    name = unicode(self._selected_parameter.name)
                else:
                    pid = ''
                    name = ''
            else:
                pid = ''
                name = ''
        sysex = LC2Sysex('XY_ID_NAME')
        sysex.byte(mapped)
        sysex.ascii(pid)
        sysex.ascii(name)
        sysex.send()

    def update(self):
        DeviceComponent.update(self)
        if self.is_enabled():
            if self._lock_button != None:
                if self._locked_to_device:
                    self._lock_button.turn_on()
                else:
                    self._lock_button.turn_off()
        self._on_on_off_changed()

    def set_device(self, device):
        DeviceComponent.set_device(self, device)
        if device is not None:
            if hasattr(device, 'chains'):
                LC2Sysex.log_message(str(len(device.chains)))
            if hasattr(device, 'drum_pads'):
                LC2Sysex.log_message(str(len(device.drum_pads)))
                LC2Sysex.log_message(str(len(device.drum_pads[0].chains)))
        cl = 0
        par = False
        if self._device is not None:
            if hasattr(self._device, 'canonical_parent'):
                if not isinstance(self._device.canonical_parent, Live.Device.Device):
                    par = isinstance(self._device.canonical_parent, Live.Chain.Chain)
                else:
                    par = False
                if hasattr(self._device, 'chains'):
                    chains = len(self._device.chains) > 0 and [ '' for i in range(8) if not (i < len(self._device.chains) and (self._device.chains[i].name == '' and 'Chain ' + str(i + 1) or self._device.chains[i].name)) ]
                    cl = min(8, len(self._device.chains))
                else:
                    chains = [ '' for i in range(8) ]
            else:
                chains = [ '' for i in range(8) ]
        else:
            chains = [ '' for i in range(8) ]
        sysex = LC2Sysex('CHAIN_NAMES')
        sysex.byte(cl)
        sysex.byte(int(par))
        for i in range(8):
            sysex.ascii(chains[i])

        sysex.send()
        self._selected_chain_id = 0
        self._send_chain_devices()

    def _send_chain_devices(self):
        cdl = 0
        if self._device is not None:
            if hasattr(self._device, 'chains'):
                if self._selected_chain_id < len(self._device.chains):
                    devices = [ '' for i in range(8) if not (i < len(self._device.chains[self._selected_chain_id].devices) and self._device.chains[self._selected_chain_id].devices[i].name) ]
                    cdl = min(8, len(self._device.chains[self._selected_chain_id].devices))
                else:
                    devices = [ '' for i in range(8) ]
            else:
                devices = [ '' for i in range(8) ]
        else:
            devices = [ '' for i in range(8) ]
        sysex = LC2Sysex('CHAIN_DEVICES')
        sysex.byte(cdl)
        for i in range(8):
            sysex.ascii(devices[i])

        sysex.send()

    def set_device_select_buttons(self, buttons):
        raise isinstance(tuple, buttons) or AssertionError
        self._device_select_buttons = buttons

    def _bank_up_value(self, value):
        if self.is_enabled():
            if not self._bank_up_button.is_momentary() or value is not 0:
                if self._device != None:
                    num_banks = self.number_of_parameter_banks(self._device)
                    if num_banks > self._bank_index + 1:
                        self._bank_index += 1
                        self.update()
                    if num_banks == self._bank_index + 1:
                        self._bank_up_button.turn_off()

    def _bank_down_value(self, value):
        DeviceComponent._bank_down_value(self, value)
        if self._bank_index == 0:
            self._bank_down_button.turn_off()

    def number_of_parameter_banks(self, device):
        result = 0
        if device != None:
            param_count = len(list(device.parameters))
            result = param_count / 16
            if not param_count % 16 == 0:
                result += 1
        return result

    def _assign_parameters(self):
        raise self.is_enabled() or AssertionError
        raise self._device != None or AssertionError
        raise self._parameter_controls != None or AssertionError
        parameters = self._device_parameters_to_map()
        num_controls = len(self._parameter_controls)
        index = self._bank_index * num_controls
        for control in self._parameter_controls:
            if index < len(parameters):
                control.connect_to(parameters[index])
            else:
                control.release_parameter()
            index += 1
########NEW FILE########
__FILENAME__ = LC2ParameterElement
#Embedded file name: /Applications/Ableton Live 9 Suite.app/Contents/App-Resources/MIDI Remote Scripts/LiveControl_2_0/LC2ParameterElement.py
from _Framework.SliderElement import SliderElement
from _Framework.InputControlElement import *
from LC2Sysex import LC2Sysex
import time

class LC2ParameterElement(SliderElement):

    @staticmethod
    def set_select_param(func):
        LC2ParameterElement.select_parameter = func

    def __init__(self, type, ch, msg, report = False):
        self._report_name_val = report
        self._last_time = 0
        SliderElement.__init__(self, type, ch, msg)

    def connect_to(self, param):
        if self._parameter_to_map_to is not None:
            try:
                self._parameter_to_map_to.remove_value_listener(self._on_value_changed)
            except:
                pass

        SliderElement.connect_to(self, param)
        if param is not None:
            if not self._parameter_to_map_to.value_has_listener(self._on_value_changed):
                self._parameter_to_map_to.add_value_listener(self._on_value_changed)
        self._send_param_val(True)

    def release_parameter(self):
        SliderElement.release_parameter(self)
        self._send_param_val(True)

    def disconnect(self):
        if self._parameter_to_map_to is not None:
            if hasattr(self._parameter_to_map_to, 'name'):
                self._parameter_to_map_to.remove_value_listener(self._on_value_changed)
        SliderElement.disconnect(self)

    def _on_value_changed(self):
        if self._report_name_val:
            self._send_param_val()

    def _send_param_val(self, force = False):
        if self._parameter_to_map_to is not None:
            if hasattr(self, 'select_parameter'):
                if self._report_name_val:
                    self.select_parameter(self._parameter_to_map_to)
        if time.clock() > self._last_time + 0.01 or force:
            if hasattr(self._parameter_to_map_to, 'name'):
                sysex = LC2Sysex('PARAM_VALS')
                if self.message_type() == MIDI_PB_TYPE:
                    sysex.byte(16)
                    sysex.byte(self.message_channel())
                else:
                    sysex.byte(self.message_channel())
                    sysex.byte(self.message_identifier())
                if self._parameter_to_map_to is not None:
                    sysex.ascii(unicode(self._parameter_to_map_to.name))
                    sysex.ascii(unicode(self._parameter_to_map_to))
                    sysex.byte(self._parameter_to_map_to.is_enabled)
                else:
                    sysex.ascii(' ')
                    sysex.ascii(' ')
                    sysex.byte(0)
                    self.send_value(0)
                sysex.send()
            self._last_time = time.clock()

    def settings(self):
        if self._parameter_to_map_to is not None:
            parent = self._parameter_to_map_to.canonical_parent
            if not hasattr(parent, 'name'):
                parent = parent.canonical_parent
            return [unicode(parent.name), unicode(self._parameter_to_map_to.name)]
        else:
            return ['', '']
########NEW FILE########
__FILENAME__ = LC2SceneComponent
#Embedded file name: /Applications/Ableton Live 9 Suite.app/Contents/App-Resources/MIDI Remote Scripts/LiveControl_2_0/LC2SceneComponent.py
from _Framework.SceneComponent import SceneComponent
from LC2ClipSlotComponent import LC2ClipSlotComponent
from LC2Sysex import LC2Sysex

class LC2SceneComponent(SceneComponent):

    def set_get_offsets(func):
        LC2SceneComponent._get_offset = func

    set_get_offsets = staticmethod(set_get_offsets)

    def release_attributes():
        LC2SceneComponent._get_offset = None

    release_attributes = staticmethod(release_attributes)

    def __init__(self, num_tracks, tracks_to_use, id):
        self._scene_id = id
        SceneComponent.__init__(self, num_tracks, tracks_to_use)

    def disconnect(self):
        if self._scene is not None:
            try:
                self._scene.remove_color_listener(self._on_color_changed)
                self._scene.remove_name_listener(self._on_name_changed)
            except:
                pass

        SceneComponent.disconnect(self)

    def _send_init(self):
        self._send_state()
        for clip in self._clip_slots:
            clip._send_state()

    def _create_clip_slot(self):
        return LC2ClipSlotComponent(len(self._clip_slots), self._scene_id)

    def set_scene(self, scene):
        if scene is not None:
            id = list(self.song().scenes).index(scene)
        else:
            id = -1
        if self._scene is not None:
            try:
                self._scene.remove_color_listener(self._on_color_changed)
                self._scene.remove_name_listener(self._on_name_changed)
            except:
                pass

        SceneComponent.set_scene(self, scene)
        if scene is not None:
            self._scene.add_color_listener(self._on_color_changed)
            self._scene.add_name_listener(self._on_name_changed)

    def _on_color_changed(self):
        self._send_state()

    def _on_name_changed(self):
        self._send_state()

    def _on_is_triggered_changed(self):
        self._send_state()

    def _send_state(self):
        if hasattr(self, '_get_offset'):
            if self._get_offset is not None:
                offsets = self._get_offset()
                if self._scene_id < offsets[3]:
                    sysex = LC2Sysex('SCENE')
                    sysex.byte(self._scene_id)
                    sysex.ascii(self.get_name())
                    sysex.rgb(self.color())
                    sysex.byte(self.state())
                    sysex.send()

    def get_name(self):
        if self._scene is not None:
            return self._scene.name
        else:
            return ''

    def state(self):
        if self._scene is not None:
            return self._scene.is_triggered
        else:
            return 0

    def color(self):
        if self._scene is not None:
            return self._scene.color
        else:
            return 0

    def fire(self):
        if self._scene is not None:
            self._scene.fire()

    def update(self):
        SceneComponent.update(self)
        if self._allow_updates:
            if self.is_enabled():
                self._send_state()
########NEW FILE########
__FILENAME__ = LC2Sequencer
#Embedded file name: /Applications/Ableton Live 9 Suite.app/Contents/App-Resources/MIDI Remote Scripts/LiveControl_2_0/LC2Sequencer.py
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from LC2Sysex import LC2Sysex, LC2SysexParser
import random
import math

class LC2Sequencer(ControlSurfaceComponent):

    def __init__(self):
        ControlSurfaceComponent.__init__(self)
        self._register_timer_callback(self._on_timer)
        self._refresh = 0
        self._clip = None
        self._note_cache = []
        self._last_note = 36
        self._last_pos = 0
        self._quantisation = 0.25
        self._default_length = 1
        self._default_velocity = 100
        self._time_offset = 0
        self._note_offset = 36
        self._num_steps = 16
        self._height = 16
        self._root = 0
        self._scale = 0
        self._scales = [[],
         [0,
          2,
          4,
          5,
          7,
          9,
          11],
         [0,
          2,
          3,
          5,
          7,
          8,
          10],
         [0,
          2,
          3,
          5,
          7,
          8,
          11],
         [0,
          2,
          4,
          7,
          9]]
        self._mutes = [ 0 for i in range(127) ]
        self._fader_type = 0
        self._fold_notes = 0
        self._save_note = 0
        self._ltime = ''
        self._chord_intervals = [[0, 4, 7],
         [0, 3, 7],
         [0, 4, 8],
         [0, 4, 6],
         [0, 3, 6],
         [0, 5, 7]]
        self._quick_chord = 127
        self._durations = [0.125,
         0.25,
         0.5,
         0.75,
         1,
         1.25,
         1.5,
         2,
         4]
        self._selection = [0,
         0,
         0,
         0]
        self._last_details = [-1,
         -1,
         -1,
         -1,
         -1]
        if LC2Sysex.l9():
            self._clisten = ('loop_start', 'loop_end', 'start_marker', 'end_marker')
        else:
            self._clisten = ('loop_start', 'loop_end')

    def select(self, slot):
        if slot.has_clip:
            self.set_clip(slot.clip, slot)
            self._selection = [-1,
             -1,
             -1,
             -1]
            self._send_selection(127)

    def set_clip(self, clip, slot):
        if self._clip is not None:
            try:
                if self._clip.playing_position_has_listener(self._on_playing_position_changed):
                    self._clip.remove_playing_position_listener(self._on_playing_position_changed)
                if self._clip.notes_has_listener(self._on_notes_changed):
                    self._clip.remove_notes_listener(self._on_notes_changed)
                if self._slot.has_clip_has_listener(self._on_slot_changed):
                    self._slot.remove_has_clip_listener(self._on_slot_changed)
                for l in self._clisten:
                    chk = getattr(self._clip, l + '_has_listener')
                    if chk(self._on_length_changed):
                        rem = getattr(self._clip, 'remove_' + l + '_listener')
                        rem(self._on_length_changed)

            except:
                pass

        self._clip = clip
        self._slot = slot
        if clip is not None:
            self._clip.add_playing_position_listener(self._on_playing_position_changed)
            self._clip.add_notes_listener(self._on_notes_changed)
            self._slot.add_has_clip_listener(self._on_slot_changed)
            for l in self._clisten:
                add = getattr(self._clip, 'add_' + l + '_listener')
                add(self._on_length_changed)

            LC2Sysex.log_message(str(self._clip.length))
            self._quantisation = 0.25
            self._time_offset = 0
        sysex = LC2Sysex('CLIP_TITLE')
        sysex.ascii(clip is not None and clip.canonical_parent.canonical_parent.name + ': ' + str(list(clip.canonical_parent.canonical_parent.clip_slots).index(clip.canonical_parent) + 1) + '. ' + (clip.name and clip.name or 'Unnamed') or '')
        sysex.rgb(clip is not None and clip.color or 0)
        sysex.send()
        self._cache_notes()
        if self._clip is not None:
            min = 128
            for note in self._note_cache:
                if note[0] < min:
                    min = note[0]

            self._note_offset = len(self._note_cache) == 0 and 36 or min
        self._fold_notes = 0
        self._save_note = 0
        self._send_offsets()
        self._on_playing_position_changed()
        self.update()

    def _on_length_changed(self):
        self.update()
        self._send_offsets()

    def _on_slot_changed(self):
        if not self._slot.has_clip:
            sysex = LC2Sysex('SEQ_CLOSE')
            sysex.send()

    def _cache_notes(self):
        if self._clip is not None:
            self._clip.select_all_notes()
            self._mutes = [ 0 for i in range(127) ]
            for n in self._clip.get_selected_notes():
                self._note_cache.append(list(n))
                if not self._mutes[n[0]]:
                    if n[4] == True:
                        self._mutes[n[0]] = 1

            self._note_cache = [ list(n) for n in self._clip.get_selected_notes() ]
            self._clip.deselect_all_notes()
        else:
            self._note_cache = []

    def handle_sysex(self, sysex):
        cmds = [self._note_press,
         self._fader_press,
         self._select_note,
         self._mute_note,
         self._scroll_time,
         self._scroll_note,
         self._zoom,
         self._set_quick_chord,
         self._set_selection,
         self._midi_action,
         self._set_root_scale,
         self._randomise_fader,
         self._set_defaults,
         self._set_fader_fn,
         self._set_height,
         self._set_fold,
         self._set_save]
        cmd = sysex[0]
        if cmd < len(cmds):
            if self._clip is not None:
                cmds[cmd](LC2SysexParser(sysex[1:]))

    def _set_save(self, sysex):
        self._save_note = not self._save_note
        self.update()

    def _set_fold(self, sysex):
        if self._fold_notes:
            self._fold_notes = 0
        else:
            self._fold_notes = 1
        self.update()

    def _set_height(self, sysex):
        self._height = sysex.parse('b') and 12 or 16
        self.update()

    def _set_fader_fn(self, sysex):
        self._fader_type = sysex.parse('b')
        self.update()

    def _set_defaults(self, sysex):
        len_pow, self._default_velocity = sysex.parse('bb')
        self._default_length = pow(2, int((len_pow / 100.0 - 0.5) * 4))

    def _zoom(self, sysex):
        ud = sysex.parse('b')
        if self._clip is not None:
            old = self._clip.length / (self._num_steps * self._quantisation)
        if ud:
            if self._quantisation > 0.0625:
                self._quantisation /= 2
                if self._clip is not None:
                    self._time_offset = int(self._time_offset / old * (self._clip.length / (self._num_steps * self._quantisation)))
        elif self._quantisation < 8:
            if self._clip is not None:
                if self._quantisation * self._num_steps < self._clip.length:
                    self._quantisation *= 2
                    self._time_offset = int(self._time_offset / old * (self._clip.length / (self._num_steps * self._quantisation)))
        self._send_selection(127)
        self._selection = [-1,
         -1,
         -1,
         -1]
        self._send_offsets()
        self.update()

    def _set_selection(self, sysex):
        self._selection = sysex.parse('bbbb')

    def _send_selection(self, x1 = 0, x2 = 0, y1 = 0, y2 = 0):
        sysex = LC2Sysex('SEQ_SEND_SELECTION')
        sysex.byte(x1)
        sysex.byte(x2)
        sysex.byte(y1)
        sysex.byte(y2)
        sysex.send()

    def _midi_action(self, sysex):
        acts = [self._arpeggiate,
         self._randomise_steps,
         self._duplicate,
         self._transpose,
         self._double,
         self._strum,
         self._flip,
         self._compress,
         self._harmonise,
         self._undo,
         self._move,
         self._clear,
         self._half]
        args = sysex.parse('bbbb')
        if args[0] < acts:
            acts[args[0]](args[1:])

    def _clear(self, args):
        if self._clip is not None:
            self._clip.select_all_notes()
            self._clip.replace_selected_notes(tuple())
            self.update()

    def _undo(self, args):
        self.song().undo()

    def _get_selection(self):
        time_lower = self._pos(self._selection[2])
        time_upper = self._pos(self._selection[3])
        pitch_upper = self._note(self._selection[0])
        pitch_lower = self._note(self._selection[1])
        selection = []
        remainder = []
        for note in self._note_cache:
            if note[0] >= pitch_lower and note[0] <= pitch_upper and note[1] >= time_lower and note[1] <= time_upper:
                selection.append(note)
            else:
                remainder.append(note)

        return [selection, remainder]

    def _in_selection(self, pos, pitch):
        sel, rem = self._get_selection()
        found = 0
        for note in sel:
            if pos == note[1] and pitch == note[0]:
                found = 1
                break

        return found

    def _arpeggiate(self, args):
        intervals = [0.125,
         0.25,
         0.5,
         1,
         2]
        idx, octaves, gate = args
        interval = intervals[idx]
        octaves += 1
        gate /= 127.0
        notes, left = self._get_selection()
        note = notes[0]
        new_notes = []
        steps = int((note[1] + note[2]) / interval)
        for step in range(steps):
            pitch = note[0] + step % octaves * 12
            new_notes.append([pitch,
             note[1] + step * interval,
             interval * gate,
             note[3],
             False])

        if self._clip is not None:
            self._clip.deselect_all_notes()
            self._clip.replace_selected_notes(tuple(new_notes))
            self._note_cache.extend(new_notes)

    def _duplicate(self, args):
        if self._clip is not None:
            new_notes = []
            for note in self._note_cache:
                new_notes.append([note[0],
                 note[1] + self._clip.length,
                 note[2],
                 note[3],
                 note[4]])

            self._clip.deselect_all_notes()
            self._clip.replace_selected_notes(tuple(new_notes))
            self._clip.loop_end += self._clip.length
            self._note_cache.extend(new_notes)
            self._send_offsets()

    def _double(self, args):
        if self._clip is not None:
            self._clip.loop_end += self._clip.length
            self._send_offsets()

    def _half(self, args):
        if self._clip is not None:
            self._clip.loop_end -= self._clip.length / 2
            if LC2Sysex.l9():
                if self._clip.end_marker > self._clip.loop_end:
                    self._clip.end_marker = self._clip.loop_end
            self._time_offset = 0
            self.update()
            self._send_offsets()

    def _move(self, args):
        dire = args[0] == 1 and 1 or -1
        selection, left = self._get_selection()
        for note in selection:
            note[1] = self._pos(self._step(note[1]) + dire)

        self._clip.select_all_notes()
        self._clip.replace_selected_notes(tuple(selection + left))
        self._selection[2] += dire
        self._selection[3] += dire
        self.update()

    def _transpose(self, args):
        if not self._fold_notes:
            pitch = args[0] == 1 and 1 or -1
            selection, left = self._get_selection()
            for note in selection:
                id = self._note_step(note[0])
                LC2Sysex.log_message('old ' + str(note[0]))
                note[0] = self._note(id + pitch)
                LC2Sysex.log_message('new ' + str(note[0]) + ' ' + str(id))

            self._clip.select_all_notes()
            self._clip.replace_selected_notes(tuple(selection + left))
            self._selection[0] += pitch
            self._selection[1] += pitch
            self.update()

    def _compress(self, args):
        sel, rem = self._get_selection()
        min = 99999
        for note in sel:
            if note[1] < min:
                min = note[1]

        for note in sel:
            LC2Sysex.log_message('before: ' + str(note))
            if not args[0]:
                note[1] = (note[1] - min) / 0.5 + min
                note[2] = note[2] / 0.5
            else:
                note[1] = (note[1] - min) * 0.5 + min
                note[2] = note[2] * 0.5
            LC2Sysex.log_message('after: ' + str(note))

        self._clip.select_all_notes()
        self._clip.replace_selected_notes(tuple(sel + rem))

    def _harmonise(self, args):
        if self._scale > 0:
            pass

    def _flip(self, args):
        dir = args[0]
        sel, rem = self._get_selection()
        LC2Sysex.log_message('Fliping ' + str(dir) + ' ' + str(sel) + ' ' + str(rem))
        if dir:
            if not self._fold_notes:
                min = 127
                max = 0
                for note in sel:
                    if note[0] > max:
                        max = note[0]
                    if note[0] < min:
                        min = note[0]

                cs = (self._note_step(max) - self._note_step(min)) / 2.0 + self._note_step(min)
                LC2Sysex.log_message(str(cs) + ' ' + str(self._note_step(max)) + ' ' + str(max) + ' ' + str(self._note_step(min)) + ' ' + str(min))
                for note in sel:
                    new_step = cs + (cs - self._note_step(note[0]))
                    note[0] = self._note(int(new_step))

                self._clip.select_all_notes()
                self._clip.replace_selected_notes(tuple(sel + rem))
        else:
            min = 99999
            max = -99999
            for note in sel:
                if note[1] > max:
                    max = note[1]
                if note[1] < min:
                    min = note[1]

            centre = (max - min) / 2 + min
            for note in sel:
                note[1] = centre + (centre - note[1])

            LC2Sysex.log_message('cent' + str(centre) + ' ' + str(min) + ' ' + str(max))
            self._clip.select_all_notes()
            self._clip.replace_selected_notes(tuple(sel + rem))

    def _strum(self, args):
        offset = 0.0625 / 2 * (args[0] / 127.0)
        sel, rem = self._get_selection()
        groups = {}
        for note in sel:
            if note[1] not in groups:
                groups[note[1]] = []
            groups[note[1]].append(note)

        for group in groups.itervalues():
            group.sort(lambda x, y: cmp(x[1::-1], y[1::-1]))
            for i, note in enumerate(group):
                note[1] += pow(i, 2) * offset

        self._clip.select_all_notes()
        self._clip.replace_selected_notes(tuple(sel + rem))

    def _randomise_steps(self, args):
        sel, rem = self._get_selection()
        notes = []
        for n in sel:
            if int(random.random() * 127) > 127 - args[0]:
                n[1] = self._pos(int(random.random() * (self._selection[3] - self._selection[2])) + self._selection[2])

        self._clip.select_all_notes()
        self._clip.replace_selected_notes(tuple(sel + rem))

    def _set_root_scale(self, sysex):
        self._root, self._scale = sysex.parse('bb')
        self.update()

    def _randomise_fader(self, sysex):
        u, l = sysex.parse('bb')
        for n in self._get_last_notes():
            if self._fader_type == 0:
                self._set_note_param(self._last_note, n[1], 3, int(random.random() * (u - l) + l))
            elif self._fader_type == 1:
                self._set_note_param(self._last_note, n[1], 2, pow(2, int((int(random.random() * (u - l) + l) - 64) / 11)))
            elif self._fader_type == 2:
                if random.random() > 0.5:
                    new = n[1] + int(random.random() * (u - l) + l) / 127.0 * (self._quantisation / 2)
                else:
                    new = n[1] - int(random.random() * (u - l) + l) / 127.0 * (self._quantisation / 2)
                self._set_note_param(self._last_note, n[1], 1, new)

        self.update()

    def _get_last_notes(self):
        notes = []
        for note in self._note_cache:
            if note[0] == self._last_note:
                notes.append(note)

        return notes

    def _set_quick_chord(self, sysex):
        self._quick_chord = sysex.parse('b')

    def _scroll_time(self, sysex):
        u, l = sysex.parse('bb')
        new = round(self._clip.length / (self._quantisation * self._num_steps) * u / 127.0, 4)
        new = round(new, 0)
        if new != self._time_offset:
            self._time_offset = new
            self.update()

    def _scroll_note(self, sysex):
        u, l = sysex.parse('bb')
        if u != self._note_offset:
            diff = u - self._note_offset
            self._last_note += diff
            self._note_offset = u
            self.update()

    def _fader_press(self, sysex):
        x, v = sysex.parse('bb')
        cur, act = self._get_fader(x)
        if self._fader_type == 0:
            if self._in_selection(act, self._last_note):
                if cur > 0:
                    pc = float(v) / float(cur)
                    sel, rem = self.f_get_selection()
                    for note in sel:
                        note[3] = min(127, note[3] * pc)

                    self._clip.select_all_notes()
                    self._clip.replace_selected_notes(tuple(sel + rem))
                    return
            id = 3
            val = v
        elif self._fader_type == 1:
            id = 2
            val = self._durations[int(round(v / 15.875, 0))]
        else:
            id = 1
            val = self._pos(x) + v / 127.0 * self._quantisation
        if not self._set_note_param(self._last_note, act, id, val):
            self.update()

    def _select_note(self, sysex):
        self._last_note = self._note(sysex.parse('b'))
        self.update()

    def _mute_note(self, sysex):
        y, state = sysex.parse('bb')
        pitch = self._note(y)
        self._mutes[pitch] = state
        found = 0
        for note in self._note_cache:
            if note[0] == pitch:
                found = 1
                note[4] = bool(state)

        if found:
            self._clip.select_all_notes()
            self._clip.replace_selected_notes(tuple(self._note_cache))
            self._clip.deselect_all_notes()

    def _note_press(self, sysex):
        x, y = sysex.parse('bb')
        pos = self._pos(x)
        pos2 = self._pos(x + 1)
        pitch = self._note(y)
        found = 0
        for note in self._note_cache:
            if note[1] >= pos and note[1] < pos2 and note[0] == pitch:
                LC2Sysex.log_message(str(note[1]) + ' ' + str(pos) + ' ' + str(pos2))
                found = 1

        if found:
            self.rem_note(pos, pos2, pitch)
        else:
            self.add_note(pos, pos2, pitch)

    def disconnect(self):
        self._unregister_timer_callback(self._on_timer)
        if self._clip is not None:
            try:
                if self._clip.playing_position_has_listener(self._on_playing_position_changed):
                    self._clip.remove_playing_position_listener(self._on_playing_position_changed)
                if self._clip.notes_has_listener(self._on_notes_changed):
                    self._clip.remove_notes_listener(self._on_notes_changed)
                for l in self._clisten:
                    chk = getattr(self._clip, l + '_has_listener')
                    if chk(self._on_length_changed):
                        rem = getattr(self._clip, 'remove_' + l + '_listener')
                        rem(self._on_length_changed)

            except:
                pass

        self._clip = None

    def on_enabled_changed(self):
        pass

    def _on_notes_changed(self):
        self._refresh = 5

    def _on_timer(self):
        if self._refresh > 0:
            if self._refresh == 1:
                self._cache_notes()
                self.update()
            self._refresh -= 1

    def add_note(self, pos, pos2, pitch):
        if self._clip is not None and pitch > -1:
            notes = []
            if self._quick_chord < 127:
                if self._scale == 0:
                    if self._quick_chord < len(self._chord_intervals):
                        for offset in self._chord_intervals[self._quick_chord]:
                            notes.append([pitch + offset,
                             pos,
                             self._quantisation * self._default_length,
                             self._default_velocity,
                             False])

                else:
                    for i in range(self._quick_chord + 3):
                        ns = self._note_step(pitch)
                        notes.append([self._note(ns + i * 2),
                         pos,
                         self._quantisation * self._default_length,
                         self._default_velocity,
                         False])

            elif self._last_details[1] >= pos and self._last_details[1] < pos2 and self._save_note:
                notes.append([pitch,
                 self._last_details[1],
                 self._last_details[2],
                 self._last_details[3],
                 self._mutes[pitch]])
                self._last_details = [-1,
                 -1,
                 -1,
                 -1,
                 -1]
            else:
                notes.append([pitch,
                 pos,
                 self._quantisation * self._default_length,
                 self._default_velocity,
                 self._mutes[pitch]])
            self._clip.deselect_all_notes()
            self._clip.replace_selected_notes(tuple(notes))
            self._note_cache.extend(notes)
            self._send_selection(127)
            self._selection = [-1,
             -1,
             -1,
             -1]
            self.update()

    def rem_note(self, pos, pos2, pitch):
        if self._clip is not None:
            new_notes = []
            for nt in self._note_cache:
                self._last_details = nt[0] == pitch and nt[1] >= pos and nt[1] < pos2 and nt
                continue
                new_notes.append(nt)

            self._clip.select_all_notes()
            self._clip.replace_selected_notes(tuple(new_notes))
            self._clip.deselect_all_notes()
            self._note_cache = new_notes
            if len(self._note_keys()) == 0:
                self._fold_notes = 0
            self.update()

    def update(self):
        array = [ 0 for i in range(self._height) ]
        array_l = [ 0 for i in range(self._height) ]
        for note in self._note_cache:
            step = self._step(note[1])
            nstep = self._note_step(note[0])
            if step in range(16) and nstep in range(self._height):
                array[self._height - 1 - nstep] |= 1 << step
                last = self._step(note[1] + note[2])
                for j in range(step + 1, min(last, 16)):
                    array_l[self._height - 1 - nstep] |= 1 << j

        sysex = LC2Sysex('STEPS')
        for b in array:
            sysex.int2(b)

        sysex.send()
        sysex = LC2Sysex('STEPS2')
        for b in array_l:
            sysex.int2(b)

        sysex.send()
        sysex = LC2Sysex('SEQ_FADERS')
        states = 0
        for i in range(16):
            fad = self._get_fader(i)[0]
            if fad == -1:
                sysex.byte(0)
            else:
                states |= 1 << i
                sysex.byte(fad)

        sysex.int2(states)
        sysex.send()
        self._get_timeline()
        self._get_note_line()
        sysex = LC2Sysex('SEQ_MUTES')
        mutes = 0
        for i in range(self._height):
            mutes |= self._mutes[self._note(i)] << self._height - 1 - i

        sysex.int2(mutes)
        sysex.send()
        sysex = LC2Sysex('SEQ_FOLD')
        sysex.byte(self._fold_notes)
        sysex.send()
        sysex = LC2Sysex('SEQ_QUANT')
        sysex.int(int(self._quantisation * 1000))
        LC2Sysex.log_message(str(int(self._quantisation * 1000)))
        sysex.send()
        sysex = LC2Sysex('SEQ_SAVE_NOTE')
        sysex.byte(self._save_note)
        sysex.send()

    def _send_offsets(self):
        sysex = LC2Sysex('SEQ_OFFSETS')
        if self._clip is not None:
            clen = self._clip.length
            if clen % 4 > 0:
                clen += 4 - clen % 4
            width = int(round(self._quantisation * self._num_steps))
            pc = width / clen * 127
            st = self._time_offset * self._quantisation * self._num_steps / clen * 127
            len = int(clen / (16 * self._quantisation))
            sysex.byte(len)
            sysex.byte(min(127, int(round(st))))
            sysex.byte(min(127, int(round(st + pc))))
            sysex.byte(min(127, self._note_offset))
            sysex.byte(min(127, self._note_offset + 11))
            sysex.send()

    def _get_fader(self, step):
        val = -1
        pos = -1
        for note in self._note_cache:
            if note[0] == self._last_note:
                if self._step(note[1]) == step:
                    pos = note[1]
                    if self._fader_type == 0:
                        val = note[3]
                    elif self._fader_type == 1:
                        val = int(round(self._nearest(self._durations, note[2]) * 15.875, 0))
                    else:
                        val = int(note[1] % self._quantisation / self._quantisation * 127)

        return [val, pos]

    def _nearest(self, list, val):
        for i, v in enumerate(list):
            if val <= v:
                return i

        return list[-1]

    def _pos(self, step):
        return self._time_offset * self._num_steps * self._quantisation + step * self._quantisation

    def _step(self, pos):
        return int((pos - self._time_offset * self._num_steps * self._quantisation) / self._quantisation)

    def _note_step(self, note):
        if self._scale == 0 and not self._fold_notes:
            return note - self._note_offset - self._root
        elif note in self._note_keys():
            return self._note_keys().index(note)
        else:
            start = 0 - self._note(0)
            below = [ self._note(i) for i in range(start, 0) ]
            end = 127 - self._note(self._height)
            above = [ self._note(i) for i in range(self._height, end) ]
            if note in below:
                return start + below.index(note)
            elif note in above:
                return self._height + above.index(note)
            else:
                return 16

    def _note(self, note_step):
        if self._fold_notes:
            notes = self._note_keys()
            if note_step < len(notes):
                return notes[note_step]
            else:
                return -1
        elif self._scale == 0:
            return min(self._note_offset, 115) + note_step + self._root
        else:
            offset = int(round(min(self._note_offset, 107) * (len(self._scales[self._scale]) / 12.0), 0))
            nid = (note_step + offset) % len(self._scales[self._scale])
            oid = int((note_step + offset) / len(self._scales[self._scale]))
            return self._root + self._scales[self._scale][nid] + 12 * oid

    def _note_keys(self):
        if self._fold_notes == 1:
            return sorted(dict(([note[0], 1] for note in self._note_cache)).keys())
        else:
            return [ self._note(i) for i in range(self._height) ]

    def _on_playing_position_changed(self):
        if self._clip is not None:
            step = self._step(self._clip.playing_position)
            if step != self._last_pos:
                if step not in range(16):
                    step = 16
                sysex = LC2Sysex('SEQ_POSITION')
                sysex.byte(step)
                sysex.send()
                self._last_pos = step

    def _set_note_param(self, pitch, start, param, val):
        found = 0
        for note in self._note_cache:
            if note[0] == pitch and note[1] == start:
                note[param] = val
                self._clip.select_all_notes()
                self._clip.replace_selected_notes(tuple(self._note_cache))
                self._clip.deselect_all_notes()
                found = 1

        return found

    def _get_timeline(self):
        sysex = LC2Sysex('SEQ_TIMELINE')
        for i in range(8):
            if self._clip != None:
                if self._pos(i * 2) < self._clip.length:
                    name = self._beat_time(self._pos(i * 2))
                    if name != self._ltime:
                        sysex.ascii(name)
                        self._ltime = name
                    else:
                        sysex.ascii('')
                else:
                    sysex.ascii('')
            else:
                sysex.ascii('')

        sysex.send()

    def _get_note_line(self):
        if self._fold_notes == 1:
            folded_notes = self._note_keys()
        sysex = LC2Sysex('SEQ_NOTELINE')
        for i in range(self._height - 1, -1, -1):
            if self._fold_notes == 1:
                if i < len(folded_notes):
                    sysex.ascii(self._to_note(folded_notes[i]))
                else:
                    sysex.ascii('')
            else:
                sysex.ascii(self._to_note(self._note(i)))

        sysex.send()

    def _beat_time(self, time):
        beats = int(time % 4)
        bars = int(time / 4)
        qb = int(time * 4 % 4)
        return str(bars + 1) + (self._quantisation < 2 and '.' + str(beats + 1) or '') + (self._quantisation < 0.5 and '.' + str(qb + 1) or '')

    def _to_note(self, note):
        notes = ['C',
         'C#',
         'D',
         'D#',
         'E',
         'F',
         'F#',
         'G',
         'G#',
         'A',
         'A#',
         'B']
        return notes[int(note % 12)] + str(int(note / 12) - 2)
########NEW FILE########
__FILENAME__ = LC2SessionComponent
#Embedded file name: /Applications/Ableton Live 9 Suite.app/Contents/App-Resources/MIDI Remote Scripts/LiveControl_2_0/LC2SessionComponent.py
from _Framework.SessionComponent import SessionComponent
from _Framework.SceneComponent import SceneComponent
from LC2SceneComponent import LC2SceneComponent
from LC2ClipSlotComponent import LC2ClipSlotComponent
from LC2ChannelStripComponent import LC2ChannelStripComponent
from LC2SessionSnapshot import LC2SessionBank
from LC2Sysex import LC2Sysex, LC2SysexParser
INITIAL_SCROLLING_DELAY = 5
INTERVAL_SCROLLING_DELAY = 1

class LC2SessionComponent(SessionComponent):

    def __init__(self, num_tracks, num_scenes):
        self._scene_count = LC2Sysex.l9() and -1 or 0
        self._num_tracks = num_tracks
        self._height = num_scenes
        self._width = num_tracks
        self._snapshot_bank = LC2SessionBank()
        SessionComponent.__init__(self, num_tracks, num_scenes)
        LC2SceneComponent.set_get_offsets(self._get_offset)
        LC2ChannelStripComponent.set_get_offsets(self._get_offset)
        LC2ClipSlotComponent.set_get_offsets(self._get_offset)
        LC2ChannelStripComponent.set_playing_slot_changed(self._playing_slot_changed)

    def set_sequencer(self, seq):
        self._sequencer = seq

    def _playing_slot_changed(self, index, name):
        self._snapshot_bank.playing_slot_changed(name, index)

    def send_size(self):
        sysex = LC2Sysex('SET_WIDTH')
        sysex.byte(len(self.tracks_to_use()))
        if len(self.song().visible_tracks) < 8:
            sysex.byte(len(self.song().visible_tracks))
            self._width = len(self.song().visible_tracks)
        else:
            sysex.byte(8)
            self._width = 8
        if len(self.song().scenes) < 12:
            sysex.byte(len(self.song().scenes))
            self._height = len(self.song().scenes)
        else:
            sysex.byte(12)
            self._height = 12
        sysex.send()

    def height(self):
        return self._height

    def width(self):
        return self._width

    def _send_init(self):
        for scene in self._scenes:
            scene._send_init()

        self.send_offsets()
        self.send_sends()

    def disconnect(self):
        self._sequencer = None
        LC2SceneComponent.release_attributes()
        LC2ChannelStripComponent.release_attributes()
        LC2ClipSlotComponent.release_attributes()
        SessionComponent.disconnect(self)

    def _create_scene(self, num_tracks = None):
        if self._scene_count == -1:
            sc = SceneComponent(self._num_tracks, self.tracks_to_use, self._scene_count)
        else:
            sc = LC2SceneComponent(self._num_tracks, self.tracks_to_use, self._scene_count)
        self._scene_count += 1
        return sc

    def handle_sysex(self, sysex):
        cmds = [self._launch_clip,
         self._launch_scene,
         self._jump_clip,
         self._set_rows,
         self._set_cols,
         self._track_stop,
         self._stop_all,
         self._set_size,
         self._select_clip,
         self._snapshot,
         self._select_send]
        if sysex[0] < len(cmds):
            cmds[sysex[0]](LC2SysexParser(sysex[1:]))

    def _select_send(self, sysex):
        tid, send = sysex.parse('bb')
        LC2Sysex.log_message(str(tid) + ' ' + str(send))
        self._mixer.channel_strip(tid).select_send(send)

    def _snapshot(self, sysex):
        id, save = sysex.parse('bb')
        if save:
            self._snapshot_bank.add(id)
        else:
            self._snapshot_bank.load(id)

    def _set_size(self, sysex):
        self._height, self._width = sysex.parse('bb')
        self._mixer._send_init()
        self._send_init()
        self.send_offsets()
        self._do_show_highlight()

    def _stop_all(self, sysex):
        self.song().stop_all_clips()

    def _get_offset(self):
        return (self._track_offset,
         self._scene_offset,
         self._width,
         self._height)

    def _set_rows(self, sysex):
        u, l = sysex.parse('bb')
        self.set_offsets(self._track_offset, int(round((127 - u) / 127.0 * len(self.song().scenes), 0)))

    def _set_cols(self, sysex):
        u, l = sysex.parse('bb')
        self.set_offsets(int(round(l / 127.0 * len(self.tracks_to_use()), 0)), self._scene_offset)

    def on_scene_list_changed(self):
        SessionComponent.on_scene_list_changed(self)
        self.send_size()
        self.send_offsets()

    def on_track_list_changed(self):
        SessionComponent.on_track_list_changed(self)
        self.send_size()
        self.send_offsets()
        self.send_sends()

    def send_sends(self):
        sysex = LC2Sysex('RETURN_NAMES')
        sysex.byte(len(self.song().return_tracks))
        for i in range(12):
            if i < len(self.song().return_tracks):
                sysex.trim(self.song().return_tracks[i].name, 15)
            else:
                sysex.ascii('')

        sysex.send()

    def send_offsets(self):
        sysex = LC2Sysex('SET_OFFSETS')
        sc = len(self.song().scenes)
        diff = float(self._height) / float(sc)
        st = float(self.scene_offset()) / float(sc)
        if self._height > sc:
            diff = 1
            st = 0
        sysex.byte(min(127, 127 - int((st + diff) * 127)))
        sysex.byte(min(127, 127 - int(st * 127)))
        tc = len(self.tracks_to_use())
        diff = float(self._width) / float(tc)
        st = float(self._track_offset) / float(tc)
        if self._width > tc:
            diff = 1
            st = 0
        sysex.byte(int(round(st * 127, 0)))
        sysex.byte(int(round((st + diff) * 127, 0)))
        sysex.send()

    def _track_stop(self, sysex):
        track_index = sysex.parse('b') + self._track_offset
        tracks = self.tracks_to_use()
        if track_index in range(len(tracks)) and tracks[track_index] in self.song().tracks:
            tracks[track_index].stop_all_clips()

    def _select_clip(self, sysex):
        x, y, state = sysex.parse('bbb')
        if state and self._sequencer is not None:
            if x + self._track_offset < len(self.tracks_to_use()):
                if y + self._scene_offset < len(self.song().scenes):
                    slot = self.tracks_to_use()[x + self._track_offset].clip_slots[y + self._scene_offset]
                    self._sequencer.select(slot)
                    if slot is not None:
                        if slot.has_clip:
                            self.song().view.selected_track = slot.canonical_parent
                            self.song().view.selected_scene = self.song().scenes[list(slot.canonical_parent.clip_slots).index(slot)]

    def _launch_clip(self, sysex):
        x, y, state = sysex.parse('bbb')
        if state == 1:
            self.scene(y).clip_slot(x).launch()

    def _launch_scene(self, sysex):
        id = sysex.parse('b')
        self.scene(id).fire()

    def _jump_clip(self, sysex):
        id = sysex.parse('b') + self._track_offset
        if id < len(self.song().visible_tracks):
            if self.tracks_to_use()[id].is_foldable:
                self.tracks_to_use()[id].fold_state = not self.tracks_to_use()[id].fold_state
            else:
                slot_idx = self.song().visible_tracks[id].playing_slot_index
                if slot_idx > -1:
                    self.set_offsets(self._track_offset, slot_idx)
                    self.send_offsets()

    def _bank_up(self):
        if LC2Sysex.l9():
            SessionComponent._bank_up(self)
            self.send_offsets()
            if self.scene_offset() == 0:
                self._bank_up_button.turn_off()

    def _bank_down(self):
        if LC2Sysex.l9():
            if len(self.song().scenes) > self.scene_offset() + self.height():
                SessionComponent._bank_down(self)
                self.send_offsets()
            LC2Sysex.log_message(str(len(self.song().scenes)) + ' ' + str(self.scene_offset() + self.height()))
            if len(self.song().scenes) == self.scene_offset() + self.height():
                self._bank_down_button.turn_off()

    def _bank_right(self):
        if LC2Sysex.l9():
            if len(self.tracks_to_use()) > self.track_offset() + self.width():
                SessionComponent._bank_right(self)
                self.send_offsets()
            if len(self.tracks_to_use()) == self.track_offset() + self.width():
                self._bank_right_button.turn_off()

    def _bank_left(self):
        if LC2Sysex.l9():
            if self.track_offset() > 0:
                SessionComponent._bank_left(self)
                self.send_offsets()
            else:
                self._bank_left_button.turn_off()

    def _bank_up_value(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._bank_up_button != None:
                raise AssertionError
                if self.is_enabled():
                    button_is_momentary = self._bank_up_button.is_momentary()
                    if button_is_momentary:
                        self._scroll_up_ticks_delay = value != 0 and INITIAL_SCROLLING_DELAY
                    else:
                        self._scroll_up_ticks_delay = -1
                not self._is_scrolling() and (value is not 0 or not button_is_momentary) and self.set_offsets(self._track_offset, min(len(self.song().scenes) - self.height(), self._scene_offset + self.height()))
                self.send_offsets()

    def _bank_down_value(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._bank_down_button != None:
                raise AssertionError
                if self.is_enabled():
                    button_is_momentary = self._bank_down_button.is_momentary()
                    if button_is_momentary:
                        self._scroll_down_ticks_delay = value != 0 and INITIAL_SCROLLING_DELAY
                    else:
                        self._scroll_down_ticks_delay = -1
                not self._is_scrolling() and (value is not 0 or not button_is_momentary) and self.set_offsets(self._track_offset, max(0, self._scene_offset - self.height()))
                self.send_offsets()

    def _bank_left_value(self, value):
        if self._track_offset > 0:
            SessionComponent._bank_left_value(self, value)
            self.send_offsets()
        else:
            self._bank_left_button.turn_off()

    def _bank_right_value(self, value):
        if self._track_offset < self._width and self._width + self._track_offset < len(self.tracks_to_use()) or self._width < len(self.tracks_to_use()) and self._width + self._track_offset < len(self.tracks_to_use()):
            SessionComponent._bank_right_value(self, value)
            self.send_offsets()
        else:
            self._bank_right_button.turn_off()
########NEW FILE########
__FILENAME__ = LC2SessionSnapshot
#Embedded file name: /Applications/Ableton Live 9 Suite.app/Contents/App-Resources/MIDI Remote Scripts/LiveControl_2_0/LC2SessionSnapshot.py
from LC2Sysex import LC2Sysex

class LC2SessionBank:

    def set_song(song):
        LC2SessionBank.song = song

    set_song = staticmethod(set_song)

    def set_timer_callback(func):
        LC2SessionBank.timer_callback = func

    set_timer_callback = staticmethod(set_timer_callback)

    def release_attributes():
        LC2SessionBank.song = None
        LC2SessionBank.timer_callback = None

    release_attributes = staticmethod(release_attributes)

    def __init__(self):
        self._snapshots = {}
        self._send_states()

    def add(self, id):
        self._snapshots[id] = LC2SessionSnapshot()
        self._send_states()

    def _send_states(self):
        sysex = LC2Sysex('SNAPSHOT_STATES')
        val = 0
        for t in self.get_states():
            sysex.byte(t)

        sysex.send()

    def load(self, id):
        if id in self._snapshots:
            self._snapshots[id].load()

    def get_states(self):
        states = []
        for i in range(16):
            states.append(i in self._snapshots and 1 or 0)

        return states

    def playing_slot_changed(self, name, slot_id):
        for id in self._snapshots:
            self._snapshots[id].playing_slot_changed(name, slot_id)


class LC2SessionSnapshot:

    def __init__(self):
        self._waiting_for_load = 0
        self._trigger_slot = -1
        self._trigger_name = None
        self._tracks = []
        self._tempo = LC2SessionBank.song().tempo
        for track in LC2SessionBank.song().tracks:
            self._tracks.append(LC2TrackSnapshot(track))
            if self._tracks[-1]._has_playing_clip() and self._trigger_slot == -1:
                self._trigger_slot = self._tracks[-1]._playing_slot_id()
                self._trigger_name = self._tracks[-1]._get_track_name()

    def load(self):
        self._waiting_for_load = 1
        if self._trigger_slot == -1:
            self._load_snapshot()
            self._waiting_for_load = 0
        for tr in self._tracks:
            tr._launch(LC2SessionBank.song().tracks)

    def playing_slot_changed(self, track_name, slot_id):
        if self._waiting_for_load and track_name == self._trigger_name and slot_id == self._trigger_slot:
            LC2SessionBank.timer_callback(1, self._load_snapshot)

    def _load_snapshot(self):
        for tr in self._tracks:
            tr._load(LC2SessionBank.song().tracks)

        LC2SessionBank.song().tempo = self._tempo
        self._waiting_for_load = 0


class LC2TrackSnapshot:

    def __init__(self, track):
        self._track_name = track.name
        self._playing_slot = track.playing_slot_index
        self._solo = track.solo
        self._mute = track.mute
        self._vol = track.mixer_device.volume.value
        self._pan = track.mixer_device.panning.value
        self._sends = []
        for send in track.mixer_device.sends:
            self._sends.append(send.value)

    def _has_playing_clip(self):
        return self._playing_slot > -1

    def _playing_slot_id(self):
        return self._playing_slot

    def _get_track_name(self):
        return self._track_name

    def _load(self, tracks):
        return
        track = self.find_track(tracks)
        if track is not None:
            track.solo = self._solo
            track.mute = self._mute
            track.mixer_device.volume.value = self._vol
            track.mixer_device.panning.value = self._pan
            for id, send in enumerate(track.mixer_device.sends):
                if id < len(self._sends):
                    send.value = self._sends[id]

    def _launch(self, tracks):
        track = self.find_track(tracks)
        if track is not None:
            if hasattr(track, 'clip_slots'):
                if self._playing_slot > -1:
                    if self._playing_slot < len(track.clip_slots):
                        if track.clip_slots[self._playing_slot].has_clip:
                            track.clip_slots[self._playing_slot].clip.fire()
                        else:
                            track.stop_all_clips()
                else:
                    track.stop_all_clips()

    def find_track(self, tracks):
        track = None
        for tr in tracks:
            if tr.name == self._track_name:
                track = tr
                break

        return track
########NEW FILE########
__FILENAME__ = LC2Sysex
#Embedded file name: /Applications/Ableton Live 9 Suite.app/Contents/App-Resources/MIDI Remote Scripts/LiveControl_2_0/LC2Sysex.py
import Live

class LC2Sysex:
    CLIP = [0, 0]
    SCENE = [0, 1]
    TRACK = [0, 2]
    CLIP_POSITION = [0, 8]
    TRACK_METERS = [0, 9]
    SET_OFFSETS = [0, 10]
    TRACK_DEVICE_NAME = [0, 11]
    SET_WIDTH = [0, 12]
    SNAPSHOT_STATES = [0, 13]
    RETURN_NAMES = [0, 14]
    TRACK_ROUTING = [0, 15]
    TRACK_ROUTING_LIST = [0, 16]
    STEPS = [1, 0]
    SEQ_POSITION = [1, 1]
    SEQ_FADERS = [1, 2]
    SEQ_TIMELINE = [1, 3]
    SEQ_NOTELINE = [1, 4]
    SEQ_OFFSETS = [1, 5]
    STEPS2 = [1, 6]
    SEQ_NOTELINE = [1, 7]
    SEQ_MUTES = [1, 8]
    CLIP_TITLE = [1, 9]
    SEQ_FOLD = [1, 10]
    SEQ_QUANT = [1, 11]
    SEQ_CLOSE = [1, 12]
    SEQ_SEND_SELECTION = [1, 13]
    SEQ_SAVE_NOTE = [1, 14]
    PARAM_VALS = [2, 0]
    DEVICE_NAME = [2, 1]
    XY_ID_NAME = [2, 2]
    TRACK_DEVICES = [2, 3]
    CHAIN_NAMES = [2, 4]
    CHAIN_DEVICES = [2, 5]
    XY_MAP = [2, 6]
    TEMPO = [5, 1]
    TIME = [5, 0]
    RESET = [5, 2]

    @staticmethod
    def l9():
        return Live.Application.get_application().get_major_version() >= 9

    @staticmethod
    def set_midi_callback(callback):
        raise dir(callback).count('im_func') is 1 or AssertionError
        LC2Sysex._midi_callback = callback

    @staticmethod
    def set_log(func):
        raise dir(func).count('im_func') is 1 or AssertionError
        LC2Sysex.log_message = func

    @staticmethod
    def release_attributes():
        LC2Sysex.log_message = None
        LC2Sysex._midi_callback = None

    def __init__(self, type):
        self._msg = [240] + getattr(self, type)

    def msg(self):
        return tuple(self._msg + [247])

    def int(self, int):
        self._msg += [int >> 7 & 127, int & 127]

    def int2(self, int):
        b1 = int >> 14 & 127
        b2 = int >> 7 & 127
        b3 = int & 127
        self._msg += [b1, b2, b3]

    def ascii(self, string):
        self._msg += [ ord(c) for c in string if not (ord(c) > 127 and 32) ]
        self._msg.append(127)

    def trim(self, display_string, length):
        if len(display_string) < length:
            self.ascii(display_string)
            return
        if len(display_string.strip()) > length and display_string.endswith('dB') and display_string.find('.') != -1:
            display_string = display_string[:-2]
        if len(display_string) > length:
            for um in [' ',
             'i',
             'o',
             'u',
             'e',
             'a']:
                while len(display_string) > length and display_string.rfind(um, 1) != -1:
                    um_pos = display_string.rfind(um, 1)
                    display_string = display_string[:um_pos] + display_string[um_pos + 1:]

        self.ascii(display_string[0:length])

    def byte(self, byte):
        self._msg.append(byte)

    def bool(self, val):
        if val:
            self._msg.append(1)
        else:
            self._msg.append(0)

    def rgb(self, rgb, inv = 0):
        byte1 = rgb >> 21 & 127
        byte2 = rgb >> 14 & 127
        byte3 = rgb >> 7 & 127
        byte4 = rgb & 127
        self._msg += [byte1,
         byte2,
         byte3,
         byte4]

    def send(self):
        if self._midi_callback is not None:
            valid = True
            if max(self.msg()[1:-2]) > 127:
                valid = False
            if valid:
                self._midi_callback(self.msg())
            else:
                self.log_message('INVALID SYSEX MESSAGE' + str(self.msg()))


class LC2SysexParser:

    def __init__(self, msg):
        self._msg = msg

    def _int(self, start):
        if start < len(self._msg) - 1:
            return (self._msg[start] << 7) + self._msg[start + 1]
        else:
            return 0

    def _byte(self, id):
        if id < len(self._msg):
            return self._msg[id]
        else:
            return 0

    def parse(self, types):
        out = []
        i = 0
        sysex_types = {'b': [self._byte, 1],
         'i': [self._int, 2]}
        for c in types:
            if c in sysex_types:
                fn, size = sysex_types[c]
                out.append(fn(i))
                i += size

        return len(out) > 1 and out or out[0]
########NEW FILE########
__FILENAME__ = LC2TransportComponent
#Embedded file name: /Applications/Ableton Live 9 Suite.app/Contents/App-Resources/MIDI Remote Scripts/LiveControl_2_0/LC2TransportComponent.py
from _Framework.TransportComponent import TransportComponent
from LC2Sysex import LC2Sysex
import Live

class LC2TransportComponent(TransportComponent):

    def __init__(self):
        self._launch_quant_button = None
        self._record_quant_button = None
        self._back_to_arranger_button = None
        self._follow_button = None
        self._tempo_up_button = None
        self._tempo_down_button = None
        TransportComponent.__init__(self)
        self.song().add_midi_recording_quantization_listener(self._on_record_quantisation_changed)
        self.song().add_clip_trigger_quantization_listener(self._on_launch_quantisation_changed)
        self.song().add_back_to_arranger_listener(self._on_back_to_arranger_changed)
        self.song().view.add_follow_song_listener(self._on_follow_changed)
        self.send_init()

    def send_init(self):
        self._on_record_quantisation_changed()
        self._on_launch_quantisation_changed()
        self._on_back_to_arranger_changed()
        self._on_follow_changed()

    def disconnect(self):
        self.song().remove_midi_recording_quantization_listener(self._on_record_quantisation_changed)
        self.song().remove_clip_trigger_quantization_listener(self._on_launch_quantisation_changed)
        self.song().remove_back_to_arranger_listener(self._on_back_to_arranger_changed)
        self.song().view.remove_follow_song_listener(self._on_follow_changed)
        if self._record_quant_button is not None:
            self._record_quant_button.remove_value_listener(self._record_quant_value)
        if self._launch_quant_button is not None:
            self._launch_quant_button.remove_value_listener(self._launch_quant_value)
        if self._back_to_arranger_button is not None:
            self._back_to_arranger_button.remove_value_listener(self._back_to_arranger_value)
        if self._follow_button is not None:
            self._follow_button.remove_value_listener(self._follow_value)

    def _on_launch_quantisation_changed(self):
        if self.is_enabled():
            if self._launch_quant_button is not None:
                self._launch_quant_button.send_value(list(Live.Song.Quantization.values).index(self.song().clip_trigger_quantization))

    def set_launch_quant_button(self, button):
        if self._launch_quant_button is not None:
            self._launch_quant_button.remove_value_listener(self._launch_quant_value)
        self._launch_quant_button = button
        if button is not None:
            self._launch_quant_button.add_value_listener(self._launch_quant_value)

    def _launch_quant_value(self, value):
        if self.is_enabled():
            if self._launch_quant_button is not None:
                LC2Sysex.log_message('valu' + str(value))
                self.song().clip_trigger_quantization = Live.Song.Quantization.values[value]

    def _on_record_quantisation_changed(self):
        if self.is_enabled():
            if self._record_quant_button is not None:
                self._record_quant_button.send_value(list(Live.Song.RecordingQuantization.values).index(self.song().midi_recording_quantization))

    def set_record_quant_button(self, button):
        if self._record_quant_button is not None:
            self._record_quant_button.remove_value_listener(self._record_quant_value)
        self._record_quant_button = button
        if button is not None:
            self._record_quant_button.add_value_listener(self._record_quant_value)

    def _record_quant_value(self, value):
        if self.is_enabled():
            if self._launch_quant_button is not None:
                self.song().midi_recording_quantization = Live.Song.RecordingQuantization.values[value]

    def _on_follow_changed(self):
        if self.is_enabled():
            if self._follow_button is not None:
                self._follow_button.send_value(self.song().view.follow_song)

    def set_follow_button(self, button):
        if self._follow_button is not None:
            self._follow_button.remove_value_listener(self._follow_value)
        self._follow_button = button
        if button is not None:
            self._follow_button.add_value_listener(self._follow_value)

    def _follow_value(self, value):
        if self.is_enabled():
            if self._follow_button is not None:
                self.song().view.follow_song = value

    def _on_back_to_arranger_changed(self):
        if self.is_enabled():
            if self._back_to_arranger_button is not None:
                self._back_to_arranger_button.send_value(self.song().back_to_arranger)

    def set_back_to_arranger_button(self, button):
        if self._back_to_arranger_button is not None:
            self._back_to_arranger_button.remove_value_listener(self._back_to_arranger_value)
        self._back_to_arranger_button = button
        if button is not None:
            self._back_to_arranger_button.add_value_listener(self._back_to_arranger_value)

    def _back_to_arranger_value(self, value):
        if self.is_enabled():
            self.song().back_to_arranger = value

    def set_tempo_buttons(self, up, down):
        if self._tempo_up_button is not None:
            self._tempo_up_button.remove_value_listener(self._tempo_up_value)
        if self._tempo_down_button is not None:
            self._tempo_down_button.remove_value_listener(self._tempo_down_value)
        self._tempo_up_button = up
        self._tempo_down_button = down
        if up is not None:
            self._tempo_up_button.add_value_listener(self._tempo_up_value)
        if down is not None:
            self._tempo_down_button.add_value_listener(self._tempo_down_value)

    def _tempo_up_value(self, value):
        if self.is_enabled():
            if value:
                if self.song().tempo < 999:
                    self.song().tempo = self.song().tempo + 1

    def _tempo_down_value(self, value):
        if self.is_enabled():
            if value:
                if self.song().tempo > 0:
                    self.song().tempo = self.song().tempo - 1
########NEW FILE########
__FILENAME__ = linecache
"""Cache lines from files.

This is intended to read lines from modules imported -- hence if a filename
is not found, it will look down the module search path for a file by
that name.
"""

import sys
import os

__all__ = ["getline", "clearcache", "checkcache"]

def getline(filename, lineno, module_globals=None):
    lines = getlines(filename, module_globals)
    if 1 <= lineno <= len(lines):
        return lines[lineno-1]
    else:
        return ''


# The cache

cache = {} # The cache


def clearcache():
    """Clear the cache entirely."""

    global cache
    cache = {}


def getlines(filename, module_globals=None):
    """Get the lines for a file from the cache.
    Update the cache if it doesn't contain an entry for this file already."""

    if filename in cache:
        return cache[filename][2]
    else:
        return updatecache(filename, module_globals)


def checkcache(filename=None):
    """Discard cache entries that are out of date.
    (This is not checked upon each call!)"""

    if filename is None:
        filenames = cache.keys()
    else:
        if filename in cache:
            filenames = [filename]
        else:
            return

    for filename in filenames:
        size, mtime, lines, fullname = cache[filename]
        if mtime is None:
            continue   # no-op for files loaded via a __loader__
        try:
            stat = os.stat(fullname)
        except os.error:
            del cache[filename]
            continue
        if size != stat.st_size or mtime != stat.st_mtime:
            del cache[filename]


def updatecache(filename, module_globals=None):
    """Update a cache entry and return its list of lines.
    If something's wrong, print a message, discard the cache entry,
    and return an empty list."""

    if filename in cache:
        del cache[filename]
    if not filename or filename[0] + filename[-1] == '<>':
        return []

    fullname = filename
    try:
        stat = os.stat(fullname)
    except os.error, msg:
        basename = os.path.split(filename)[1]

        # Try for a __loader__, if available
        if module_globals and '__loader__' in module_globals:
            name = module_globals.get('__name__')
            loader = module_globals['__loader__']
            get_source = getattr(loader, 'get_source', None)

            if name and get_source:
                if basename.startswith(name.split('.')[-1]+'.'):
                    try:
                        data = get_source(name)
                    except (ImportError, IOError):
                        pass
                    else:
                        if data is None:
                            # No luck, the PEP302 loader cannot find the source
                            # for this module.
                            return []
                        cache[filename] = (
                            len(data), None,
                            [line+'\n' for line in data.splitlines()], fullname
                        )
                        return cache[filename][2]

        # Try looking through the module search path.

        for dirname in sys.path:
            # When using imputil, sys.path may contain things other than
            # strings; ignore them when it happens.
            try:
                fullname = os.path.join(dirname, basename)
            except (TypeError, AttributeError):
                # Not sufficiently string-like to do anything useful with.
                pass
            else:
                try:
                    stat = os.stat(fullname)
                    break
                except os.error:
                    pass
        else:
            # No luck
##          print '*** Cannot stat', filename, ':', msg
            return []
    try:
        fp = open(fullname, 'rU')
        lines = fp.readlines()
        fp.close()
    except IOError, msg:
##      print '*** Cannot open', fullname, ':', msg
        return []
    size, mtime = stat.st_size, stat.st_mtime
    cache[filename] = size, mtime, lines, fullname
    return lines

########NEW FILE########
__FILENAME__ = LiveControl2
#Embedded file name: /Applications/Ableton Live 9 Suite.app/Contents/App-Resources/MIDI Remote Scripts/LiveControl_2_0/LiveControl2.py
from __future__ import with_statement
from _Framework.ControlSurface import ControlSurface
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.InputControlElement import *
from LC2Sysex import LC2Sysex, LC2SysexParser
from LC2SessionComponent import LC2SessionComponent
from LC2MixerComponent import LC2MixerComponent
from LC2Modulator import LC2Modulator
from LC2Sequencer import LC2Sequencer
from LC2SessionSnapshot import LC2SessionBank
from LC2TransportComponent import LC2TransportComponent
from LC2ParameterElement import LC2ParameterElement

class LiveControl2(ControlSurface):
    _active_instances = []

    def _combine_active_instances():
        track_offset = 0
        for instance in LiveControl2._active_instances:
            instance._activate_combination_mode(track_offset)
            track_offset += instance._session.width()

    _combine_active_instances = staticmethod(_combine_active_instances)

    def _do_combine(self):
        if self not in LiveControl2._active_instances:
            LiveControl2._active_instances.append(self)
            LiveControl2._combine_active_instances()

    def _activate_combination_mode(self, track_offset):
        if self._session._is_linked():
            self._session._unlink()
        self._session.set_offsets(track_offset, 0)
        self._session._link()

    def _do_uncombine(self):
        if self in LiveControl2._active_instances and LiveControl2._active_instances.remove(self):
            self._session.unlink()
            LiveControl2._combine_active_instances()

    def log_message(self, str):
        pass

    def __init__(self, c_instance):
        ControlSurface.__init__(self, c_instance)
        LC2Sysex.set_log(self.log_message)
        if LC2Sysex.l9():
            with self.component_guard():
                self.do_setup()
        else:
            self.do_setup()

    def do_setup(self):
        if LC2Sysex.l9():
            self._set_suppress_rebuild_requests(True)
        else:
            self.set_suppress_rebuild_requests(True)
        self._suppress_session_highlight = True
        self._suppress_send_midi = True
        LC2Sysex.set_midi_callback(self._send_midi)
        LC2SessionBank.set_song(self.song)
        LC2SessionBank.set_timer_callback(self.schedule_message)
        self._session = LC2SessionComponent(8, 12)
        self._mixer = LC2MixerComponent(8)
        self._session.set_mixer(self._mixer)
        if LC2Sysex.l9():
            self.set_highlighting_session_component(self._session)
        bank_buttons = [ ButtonElement(False, MIDI_NOTE_TYPE, 0, 40 + i) for i in range(4) ]
        self._session.set_scene_bank_buttons(bank_buttons[0], bank_buttons[1])
        self._session.set_track_bank_buttons(bank_buttons[2], bank_buttons[3])
        mixer_controls = [ SliderElement(MIDI_CC_TYPE, 0, i) for i in range(24) ]
        mixer_d_controls = [ LC2ParameterElement(MIDI_CC_TYPE, 0, i + 64) for i in range(32) ]
        toggle_controls = [ ButtonElement(True, MIDI_NOTE_TYPE, 0, i) for i in range(24) ]
        cf = [ ButtonElement(True, MIDI_NOTE_TYPE, 0, i + 30) for i in range(8) ]
        mt = [ ButtonElement(True, MIDI_NOTE_TYPE, 0, i + 50) for i in range(8) ]
        self._mixer.master_strip().set_volume_control(SliderElement(MIDI_CC_TYPE, 0, 33))
        self._mixer.master_strip().set_pan_control(SliderElement(MIDI_CC_TYPE, 0, 34))
        self._mixer.set_prehear_volume_control(SliderElement(MIDI_CC_TYPE, 0, 35))
        self._mixer.set_crossfader_control(SliderElement(MIDI_CC_TYPE, 0, 40))
        for i in range(8):
            idx = i * 3
            ch = self._mixer.channel_strip(i)
            ch.set_invert_mute_feedback(True)
            ch.set_mute_button(toggle_controls[idx])
            ch.set_solo_button(toggle_controls[idx + 1])
            ch.set_arm_button(toggle_controls[idx + 2])
            ch.set_volume_control(mixer_controls[idx])
            ch.set_pan_control(mixer_controls[idx + 1])
            ch.set_send_control(mixer_controls[idx + 2])
            ch.set_crossfade_toggle(cf[i])
            ch.set_monitor_toggle(mt[i])
            ch.set_device_controls(tuple(mixer_d_controls[i * 4:i * 4 + 4]))

        self._modulator = LC2Modulator()
        self.set_device_component(self._modulator)
        device_controls = [ LC2ParameterElement(MIDI_CC_TYPE, 1, i, True) for i in range(16) ]
        self._modulator.set_parameter_controls(tuple(device_controls))
        device_buttons = [ ButtonElement(False, MIDI_NOTE_TYPE, 1, i) for i in range(4) ]
        self._modulator.set_on_off_button(device_buttons[0])
        self._modulator.set_lock_button(device_buttons[1])
        self._modulator.set_bank_nav_buttons(device_buttons[2], device_buttons[3])
        self._sequencer = LC2Sequencer()
        self._session.set_sequencer(self._sequencer)
        self._transport = LC2TransportComponent()
        tbuttons = [ ButtonElement(False, MIDI_NOTE_TYPE, 0, 110 + i) for i in range(12) ]
        self._transport.set_stop_button(tbuttons[0])
        self._transport.set_play_button(tbuttons[1])
        self._transport.set_record_button(tbuttons[2])
        self._transport.set_overdub_button(tbuttons[3])
        self._transport.set_back_to_arranger_button(tbuttons[4])
        self._transport.set_follow_button(tbuttons[5])
        self._transport.set_metronome_button(tbuttons[6])
        self._transport.set_tap_tempo_button(tbuttons[7])
        self._transport.set_tempo_buttons(tbuttons[9], tbuttons[8])
        self._transport.set_launch_quant_button(SliderElement(MIDI_CC_TYPE, 0, 120))
        self._transport.set_record_quant_button(SliderElement(MIDI_CC_TYPE, 0, 121))
        self._do_combine()
        self._last_time = ''
        if LC2Sysex.l9():

            def wrapper(delta):
                self._on_time_changed()
                return Task.RUNNING

            self._tasks.add(Task.FuncTask(wrapper, self._on_time_changed))
        else:
            self._register_timer_callback(self._on_time_changed)
        self.song().add_tempo_listener(self._on_tempo_changed)
        for component in self.components:
            component.set_enabled(False)

        if LC2Sysex.l9():
            self._set_suppress_rebuild_requests(False)
        else:
            self.set_suppress_rebuild_requests(False)

    def refresh_state(self):
        ControlSurface.refresh_state(self)
        self.schedule_message(5, self._init)

    def disconnect(self):
        self._do_uncombine()
        if LC2Sysex.l9():
            task = self._tasks.find(self._on_time_changed)
            self._tasks.remove(task)
        else:
            self._unregister_timer_callback(self._on_time_changed)
        self.song().remove_tempo_listener(self._on_tempo_changed)
        ControlSurface.disconnect(self)
        LC2Sysex.release_attributes()
        LC2SessionBank.release_attributes()

    def handle_sysex(self, sysex):
        if list(sysex).count(247) == 0:
            count = 1
        else:
            count = list(sysex).count(247)
        LC2Sysex.log_message(str(sysex))
        LC2Sysex.log_message('sysex count' + str(count))
        msysex = [ [] for i in range(count + 1) ]
        id = 0
        start = list(sysex).index(240)
        for i, b in enumerate(sysex):
            if i >= start:
                msysex[id].append(b)
                if b == 247:
                    id += 1

        LC2Sysex.log_message(str(msysex))
        pages = [self._session,
         self._mixer,
         self._sequencer,
         self._modulator]
        for sysex in msysex:
            if len(sysex) > 1:
                if sysex[1] == 5:
                    if sysex[2] == 1:
                        self._init()
                    elif sysex[2] == 2:
                        sysex = LC2SysexParser(sysex[3:])
                        interface = sysex.parse('b')
                        LC2Sysex.log_message('interface change: ' + str(interface))
                        if interface == 0 or interface == 1 or interface == 2:
                            self._mixer.set_enabled(1)
                        else:
                            self._mixer.set_enabled(0)
                elif sysex[1] < len(pages):
                    pages[sysex[1]].handle_sysex(sysex[2:])

    def _init(self):
        self._suppress_send_midi = False
        self._suppress_session_highlight = False
        for component in self.components:
            component.set_enabled(True)

        self._session.send_size()
        self._on_time_changed()
        self._on_tempo_changed()
        self._transport.send_init()
        self._modulator.send_params()
        sysex = LC2Sysex('RESET')
        sysex.send()

    def suggest_input_port(self):
        return 'Daemon Input '

    def suggest_output_port(self):
        return 'Daemon Output '

    def _on_tempo_changed(self):
        sysex = LC2Sysex('TEMPO')
        sysex.ascii(str(int(round(self.song().tempo, 0))))
        sysex.send()

    def _on_time_changed(self):
        smpt = self.song().get_current_smpte_song_time(0)
        if smpt.hours > 0:
            time = smpt.hours < 10 and '0' + str(smpt.hours) or str(smpt.hours) + ':' or '' + (smpt.minutes < 10 and '0' + str(smpt.minutes) or str(smpt.minutes)) + ':' + (smpt.seconds < 10 and '0' + str(smpt.seconds) or str(smpt.seconds))
            sysex = time != self._last_time and LC2Sysex('TIME')
            sysex.ascii(time)
            sysex.send()
            self._last_time = time

    def _do_send_midi(self, midi_event_bytes):
        if not self._suppress_send_midi:
            self._c_instance.send_midi(midi_event_bytes)
            return True
########NEW FILE########
__FILENAME__ = ntpath
# Module 'ntpath' -- common operations on WinNT/Win95 pathnames
"""Common pathname manipulations, WindowsNT/95 version.

Instead of importing this module directly, import os and refer to this
module as os.path.
"""

import os
import stat
import sys

__all__ = ["normcase","isabs","join","splitdrive","split","splitext",
           "basename","dirname","commonprefix","getsize","getmtime",
           "getatime","getctime", "islink","exists","lexists","isdir","isfile",
           "ismount","walk","expanduser","expandvars","normpath","abspath",
           "splitunc","curdir","pardir","sep","pathsep","defpath","altsep",
           "extsep","devnull","realpath","supports_unicode_filenames"]

# strings representing various path-related bits and pieces
curdir = '.'
pardir = '..'
extsep = '.'
sep = '\\'
pathsep = ';'
altsep = '/'
defpath = '.;C:\\bin'
if 'ce' in sys.builtin_module_names:
    defpath = '\\Windows'
elif 'os2' in sys.builtin_module_names:
    # OS/2 w/ VACPP
    altsep = '/'
devnull = 'nul'

# Normalize the case of a pathname and map slashes to backslashes.
# Other normalizations (such as optimizing '../' away) are not done
# (this is done by normpath).

def normcase(s):
    """Normalize case of pathname.

    Makes all characters lowercase and all slashes into backslashes."""
    return s.replace("/", "\\").lower()


# Return whether a path is absolute.
# Trivial in Posix, harder on the Mac or MS-DOS.
# For DOS it is absolute if it starts with a slash or backslash (current
# volume), or if a pathname after the volume letter and colon / UNC resource
# starts with a slash or backslash.

def isabs(s):
    """Test whether a path is absolute"""
    s = splitdrive(s)[1]
    return s != '' and s[:1] in '/\\'


# Join two (or more) paths.

def join(a, *p):
    """Join two or more pathname components, inserting "\\" as needed"""
    path = a
    for b in p:
        b_wins = 0  # set to 1 iff b makes path irrelevant
        if path == "":
            b_wins = 1

        elif isabs(b):
            # This probably wipes out path so far.  However, it's more
            # complicated if path begins with a drive letter:
            #     1. join('c:', '/a') == 'c:/a'
            #     2. join('c:/', '/a') == 'c:/a'
            # But
            #     3. join('c:/a', '/b') == '/b'
            #     4. join('c:', 'd:/') = 'd:/'
            #     5. join('c:/', 'd:/') = 'd:/'
            if path[1:2] != ":" or b[1:2] == ":":
                # Path doesn't start with a drive letter, or cases 4 and 5.
                b_wins = 1

            # Else path has a drive letter, and b doesn't but is absolute.
            elif len(path) > 3 or (len(path) == 3 and
                                   path[-1] not in "/\\"):
                # case 3
                b_wins = 1

        if b_wins:
            path = b
        else:
            # Join, and ensure there's a separator.
            assert len(path) > 0
            if path[-1] in "/\\":
                if b and b[0] in "/\\":
                    path += b[1:]
                else:
                    path += b
            elif path[-1] == ":":
                path += b
            elif b:
                if b[0] in "/\\":
                    path += b
                else:
                    path += "\\" + b
            else:
                # path is not empty and does not end with a backslash,
                # but b is empty; since, e.g., split('a/') produces
                # ('a', ''), it's best if join() adds a backslash in
                # this case.
                path += '\\'

    return path


# Split a path in a drive specification (a drive letter followed by a
# colon) and the path specification.
# It is always true that drivespec + pathspec == p
def splitdrive(p):
    """Split a pathname into drive and path specifiers. Returns a 2-tuple
"(drive,path)";  either part may be empty"""
    if p[1:2] == ':':
        return p[0:2], p[2:]
    return '', p


# Parse UNC paths
def splitunc(p):
    """Split a pathname into UNC mount point and relative path specifiers.

    Return a 2-tuple (unc, rest); either part may be empty.
    If unc is not empty, it has the form '//host/mount' (or similar
    using backslashes).  unc+rest is always the input path.
    Paths containing drive letters never have an UNC part.
    """
    if p[1:2] == ':':
        return '', p # Drive letter present
    firstTwo = p[0:2]
    if firstTwo == '//' or firstTwo == '\\\\':
        # is a UNC path:
        # vvvvvvvvvvvvvvvvvvvv equivalent to drive letter
        # \\machine\mountpoint\directories...
        #           directory ^^^^^^^^^^^^^^^
        normp = normcase(p)
        index = normp.find('\\', 2)
        if index == -1:
            ##raise RuntimeError, 'illegal UNC path: "' + p + '"'
            return ("", p)
        index = normp.find('\\', index + 1)
        if index == -1:
            index = len(p)
        return p[:index], p[index:]
    return '', p


# Split a path in head (everything up to the last '/') and tail (the
# rest).  After the trailing '/' is stripped, the invariant
# join(head, tail) == p holds.
# The resulting head won't end in '/' unless it is the root.

def split(p):
    """Split a pathname.

    Return tuple (head, tail) where tail is everything after the final slash.
    Either part may be empty."""

    d, p = splitdrive(p)
    # set i to index beyond p's last slash
    i = len(p)
    while i and p[i-1] not in '/\\':
        i = i - 1
    head, tail = p[:i], p[i:]  # now tail has no slashes
    # remove trailing slashes from head, unless it's all slashes
    head2 = head
    while head2 and head2[-1] in '/\\':
        head2 = head2[:-1]
    head = head2 or head
    return d + head, tail


# Split a path in root and extension.
# The extension is everything starting at the last dot in the last
# pathname component; the root is everything before that.
# It is always true that root + ext == p.

def splitext(p):
    """Split the extension from a pathname.

    Extension is everything from the last dot to the end.
    Return (root, ext), either part may be empty."""

    i = p.rfind('.')
    if i<=max(p.rfind('/'), p.rfind('\\')):
        return p, ''
    else:
        return p[:i], p[i:]


# Return the tail (basename) part of a path.

def basename(p):
    """Returns the final component of a pathname"""
    return split(p)[1]


# Return the head (dirname) part of a path.

def dirname(p):
    """Returns the directory component of a pathname"""
    return split(p)[0]


# Return the longest prefix of all list elements.

def commonprefix(m):
    "Given a list of pathnames, returns the longest common leading component"
    if not m: return ''
    s1 = min(m)
    s2 = max(m)
    n = min(len(s1), len(s2))
    for i in xrange(n):
        if s1[i] != s2[i]:
            return s1[:i]
    return s1[:n]


# Get size, mtime, atime of files.

def getsize(filename):
    """Return the size of a file, reported by os.stat()"""
    return os.stat(filename).st_size

def getmtime(filename):
    """Return the last modification time of a file, reported by os.stat()"""
    return os.stat(filename).st_mtime

def getatime(filename):
    """Return the last access time of a file, reported by os.stat()"""
    return os.stat(filename).st_atime

def getctime(filename):
    """Return the creation time of a file, reported by os.stat()."""
    return os.stat(filename).st_ctime

# Is a path a symbolic link?
# This will always return false on systems where posix.lstat doesn't exist.

def islink(path):
    """Test for symbolic link.  On WindowsNT/95 always returns false"""
    return False


# Does a path exist?

def exists(path):
    """Test whether a path exists"""
    try:
        st = os.stat(path)
    except os.error:
        return False
    return True

lexists = exists


# Is a path a dos directory?
# This follows symbolic links, so both islink() and isdir() can be true
# for the same path.

def isdir(path):
    """Test whether a path is a directory"""
    try:
        st = os.stat(path)
    except os.error:
        return False
    return stat.S_ISDIR(st.st_mode)


# Is a path a regular file?
# This follows symbolic links, so both islink() and isdir() can be true
# for the same path.

def isfile(path):
    """Test whether a path is a regular file"""
    try:
        st = os.stat(path)
    except os.error:
        return False
    return stat.S_ISREG(st.st_mode)


# Is a path a mount point?  Either a root (with or without drive letter)
# or an UNC path with at most a / or \ after the mount point.

def ismount(path):
    """Test whether a path is a mount point (defined as root of drive)"""
    unc, rest = splitunc(path)
    if unc:
        return rest in ("", "/", "\\")
    p = splitdrive(path)[1]
    return len(p) == 1 and p[0] in '/\\'


# Directory tree walk.
# For each directory under top (including top itself, but excluding
# '.' and '..'), func(arg, dirname, filenames) is called, where
# dirname is the name of the directory and filenames is the list
# of files (and subdirectories etc.) in the directory.
# The func may modify the filenames list, to implement a filter,
# or to impose a different order of visiting.

def walk(top, func, arg):
    """Directory tree walk with callback function.

    For each directory in the directory tree rooted at top (including top
    itself, but excluding '.' and '..'), call func(arg, dirname, fnames).
    dirname is the name of the directory, and fnames a list of the names of
    the files and subdirectories in dirname (excluding '.' and '..').  func
    may modify the fnames list in-place (e.g. via del or slice assignment),
    and walk will only recurse into the subdirectories whose names remain in
    fnames; this can be used to implement a filter, or to impose a specific
    order of visiting.  No semantics are defined for, or required of, arg,
    beyond that arg is always passed to func.  It can be used, e.g., to pass
    a filename pattern, or a mutable object designed to accumulate
    statistics.  Passing None for arg is common."""

    try:
        names = os.listdir(top)
    except os.error:
        return
    func(arg, top, names)
    exceptions = ('.', '..')
    for name in names:
        if name not in exceptions:
            name = join(top, name)
            if isdir(name):
                walk(name, func, arg)


# Expand paths beginning with '~' or '~user'.
# '~' means $HOME; '~user' means that user's home directory.
# If the path doesn't begin with '~', or if the user or $HOME is unknown,
# the path is returned unchanged (leaving error reporting to whatever
# function is called with the expanded path as argument).
# See also module 'glob' for expansion of *, ? and [...] in pathnames.
# (A function should also be defined to do full *sh-style environment
# variable expansion.)

def expanduser(path):
    """Expand ~ and ~user constructs.

    If user or $HOME is unknown, do nothing."""
    if path[:1] != '~':
        return path
    i, n = 1, len(path)
    while i < n and path[i] not in '/\\':
        i = i + 1
    if i == 1:
        if 'HOME' in os.environ:
            userhome = os.environ['HOME']
        elif not 'HOMEPATH' in os.environ:
            return path
        else:
            try:
                drive = os.environ['HOMEDRIVE']
            except KeyError:
                drive = ''
            userhome = join(drive, os.environ['HOMEPATH'])
    else:
        return path
    return userhome + path[i:]


# Expand paths containing shell variable substitutions.
# The following rules apply:
#       - no expansion within single quotes
#       - no escape character, except for '$$' which is translated into '$'
#       - ${varname} is accepted.
#       - varnames can be made out of letters, digits and the character '_'
# XXX With COMMAND.COM you can use any characters in a variable name,
# XXX except '^|<>='.

def expandvars(path):
    """Expand shell variables of form $var and ${var}.

    Unknown variables are left unchanged."""
    if '$' not in path:
        return path
    import string
    varchars = string.ascii_letters + string.digits + '_-'
    res = ''
    index = 0
    pathlen = len(path)
    while index < pathlen:
        c = path[index]
        if c == '\'':   # no expansion within single quotes
            path = path[index + 1:]
            pathlen = len(path)
            try:
                index = path.index('\'')
                res = res + '\'' + path[:index + 1]
            except ValueError:
                res = res + path
                index = pathlen - 1
        elif c == '$':  # variable or '$$'
            if path[index + 1:index + 2] == '$':
                res = res + c
                index = index + 1
            elif path[index + 1:index + 2] == '{':
                path = path[index+2:]
                pathlen = len(path)
                try:
                    index = path.index('}')
                    var = path[:index]
                    if var in os.environ:
                        res = res + os.environ[var]
                except ValueError:
                    res = res + path
                    index = pathlen - 1
            else:
                var = ''
                index = index + 1
                c = path[index:index + 1]
                while c != '' and c in varchars:
                    var = var + c
                    index = index + 1
                    c = path[index:index + 1]
                if var in os.environ:
                    res = res + os.environ[var]
                if c != '':
                    res = res + c
        else:
            res = res + c
        index = index + 1
    return res


# Normalize a path, e.g. A//B, A/./B and A/foo/../B all become A\B.
# Previously, this function also truncated pathnames to 8+3 format,
# but as this module is called "ntpath", that's obviously wrong!

def normpath(path):
    """Normalize path, eliminating double slashes, etc."""
    path = path.replace("/", "\\")
    prefix, path = splitdrive(path)
    # We need to be careful here. If the prefix is empty, and the path starts
    # with a backslash, it could either be an absolute path on the current
    # drive (\dir1\dir2\file) or a UNC filename (\\server\mount\dir1\file). It
    # is therefore imperative NOT to collapse multiple backslashes blindly in
    # that case.
    # The code below preserves multiple backslashes when there is no drive
    # letter. This means that the invalid filename \\\a\b is preserved
    # unchanged, where a\\\b is normalised to a\b. It's not clear that there
    # is any better behaviour for such edge cases.
    if prefix == '':
        # No drive letter - preserve initial backslashes
        while path[:1] == "\\":
            prefix = prefix + "\\"
            path = path[1:]
    else:
        # We have a drive letter - collapse initial backslashes
        if path.startswith("\\"):
            prefix = prefix + "\\"
            path = path.lstrip("\\")
    comps = path.split("\\")
    i = 0
    while i < len(comps):
        if comps[i] in ('.', ''):
            del comps[i]
        elif comps[i] == '..':
            if i > 0 and comps[i-1] != '..':
                del comps[i-1:i+1]
                i -= 1
            elif i == 0 and prefix.endswith("\\"):
                del comps[i]
            else:
                i += 1
        else:
            i += 1
    # If the path is now empty, substitute '.'
    if not prefix and not comps:
        comps.append('.')
    return prefix + "\\".join(comps)


# Return an absolute path.
try:
    from nt import _getfullpathname

except ImportError: # not running on Windows - mock up something sensible
    def abspath(path):
        """Return the absolute version of a path."""
        if not isabs(path):
            path = join(os.getcwd(), path)
        return normpath(path)

else:  # use native Windows method on Windows
    def abspath(path):
        """Return the absolute version of a path."""

        if path: # Empty path must return current working directory.
            try:
                path = _getfullpathname(path)
            except WindowsError:
                pass # Bad path - return unchanged.
        else:
            path = os.getcwd()
        return normpath(path)

# realpath is a no-op on systems without islink support
realpath = abspath
# Win9x family and earlier have no Unicode filename support.
supports_unicode_filenames = (hasattr(sys, "getwindowsversion") and
                              sys.getwindowsversion()[3] >= 2)

########NEW FILE########
__FILENAME__ = os
r"""OS routines for Mac, NT, or Posix depending on what system we're on.

This exports:
  - all functions from posix, nt, os2, mac, or ce, e.g. unlink, stat, etc.
  - os.path is one of the modules posixpath, ntpath, or macpath
  - os.name is 'posix', 'nt', 'os2', 'mac', 'ce' or 'riscos'
  - os.curdir is a string representing the current directory ('.' or ':')
  - os.pardir is a string representing the parent directory ('..' or '::')
  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\')
  - os.extsep is the extension separator ('.' or '/')
  - os.altsep is the alternate pathname separator (None or '/')
  - os.pathsep is the component separator used in $PATH etc
  - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')
  - os.defpath is the default search path for executables
  - os.devnull is the file path of the null device ('/dev/null', etc.)

Programs that import and use 'os' stand a better chance of being
portable between different platforms.  Of course, they must then
only use functions that are defined by all platforms (e.g., unlink
and opendir), and leave all pathname manipulation to os.path
(e.g., split and join).
"""

#'

import sys

_names = sys.builtin_module_names

# Note:  more names are added to __all__ later.
__all__ = ["altsep", "curdir", "pardir", "sep", "pathsep", "linesep",
           "defpath", "name", "path", "devnull",
           "SEEK_SET", "SEEK_CUR", "SEEK_END"]

def _get_exports_list(module):
    try:
        return list(module.__all__)
    except AttributeError:
        return [n for n in dir(module) if n[0] != '_']

if 'posix' in _names:
    name = 'posix'
    linesep = '\n'
    from posix import *
    try:
        from posix import _exit
    except ImportError:
        pass
    import posixpath as path

    import posix
    __all__.extend(_get_exports_list(posix))
    del posix

elif 'nt' in _names:
    name = 'nt'
    linesep = '\r\n'
    from nt import *
    try:
        from nt import _exit
    except ImportError:
        pass
    import ntpath as path

    import nt
    __all__.extend(_get_exports_list(nt))
    del nt

elif 'os2' in _names:
    name = 'os2'
    linesep = '\r\n'
    from os2 import *
    try:
        from os2 import _exit
    except ImportError:
        pass
    if sys.version.find('EMX GCC') == -1:
        import ntpath as path
    else:
        import os2emxpath as path
        from _emx_link import link

    import os2
    __all__.extend(_get_exports_list(os2))
    del os2

elif 'mac' in _names:
    name = 'mac'
    linesep = '\r'
    from mac import *
    try:
        from mac import _exit
    except ImportError:
        pass
    import macpath as path

    import mac
    __all__.extend(_get_exports_list(mac))
    del mac

elif 'ce' in _names:
    name = 'ce'
    linesep = '\r\n'
    from ce import *
    try:
        from ce import _exit
    except ImportError:
        pass
    # We can use the standard Windows path.
    import ntpath as path

    import ce
    __all__.extend(_get_exports_list(ce))
    del ce

elif 'riscos' in _names:
    name = 'riscos'
    linesep = '\n'
    from riscos import *
    try:
        from riscos import _exit
    except ImportError:
        pass
    import riscospath as path

    import riscos
    __all__.extend(_get_exports_list(riscos))
    del riscos

else:
    raise ImportError, 'no os specific module found'

if sys.platform == "win32":
    import ntpath
    sys.modules['os.path'] = ntpath
    from ntpath import (curdir, pardir, sep, pathsep, defpath, extsep, altsep,
        devnull)
else:
    import posixpath
    sys.modules['os.path'] = posixpath
    from posixpath import (curdir, pardir, sep, pathsep, defpath, extsep, altsep,
        devnull)
        
del _names

# Python uses fixed values for the SEEK_ constants; they are mapped
# to native constants if necessary in posixmodule.c
SEEK_SET = 0
SEEK_CUR = 1
SEEK_END = 2

#'

# Super directory utilities.
# (Inspired by Eric Raymond; the doc strings are mostly his)

def makedirs(name, mode=0777):
    """makedirs(path [, mode=0777])

    Super-mkdir; create a leaf directory and all intermediate ones.
    Works like mkdir, except that any intermediate path segment (not
    just the rightmost) will be created if it does not exist.  This is
    recursive.

    """
    from errno import EEXIST
    head, tail = path.split(name)
    if not tail:
        head, tail = path.split(head)
    if head and tail and not path.exists(head):
        try:
            makedirs(head, mode)
        except OSError, e:
            # be happy if someone already created the path
            if e.errno != EEXIST:
                raise
        if tail == curdir:           # xxx/newdir/. exists if xxx/newdir exists
            return
    mkdir(name, mode)

def removedirs(name):
    """removedirs(path)

    Super-rmdir; remove a leaf directory and all empty intermediate
    ones.  Works like rmdir except that, if the leaf directory is
    successfully removed, directories corresponding to rightmost path
    segments will be pruned away until either the whole path is
    consumed or an error occurs.  Errors during this latter phase are
    ignored -- they generally mean that a directory was not empty.

    """
    rmdir(name)
    head, tail = path.split(name)
    if not tail:
        head, tail = path.split(head)
    while head and tail:
        try:
            rmdir(head)
        except error:
            break
        head, tail = path.split(head)

def renames(old, new):
    """renames(old, new)

    Super-rename; create directories as necessary and delete any left
    empty.  Works like rename, except creation of any intermediate
    directories needed to make the new pathname good is attempted
    first.  After the rename, directories corresponding to rightmost
    path segments of the old name will be pruned way until either the
    whole path is consumed or a nonempty directory is found.

    Note: this function can fail with the new directory structure made
    if you lack permissions needed to unlink the leaf directory or
    file.

    """
    head, tail = path.split(new)
    if head and tail and not path.exists(head):
        makedirs(head)
    rename(old, new)
    head, tail = path.split(old)
    if head and tail:
        try:
            removedirs(head)
        except error:
            pass

__all__.extend(["makedirs", "removedirs", "renames"])

def walk(top, topdown=True, onerror=None):
    """Directory tree generator.

    For each directory in the directory tree rooted at top (including top
    itself, but excluding '.' and '..'), yields a 3-tuple

        dirpath, dirnames, filenames

    dirpath is a string, the path to the directory.  dirnames is a list of
    the names of the subdirectories in dirpath (excluding '.' and '..').
    filenames is a list of the names of the non-directory files in dirpath.
    Note that the names in the lists are just names, with no path components.
    To get a full path (which begins with top) to a file or directory in
    dirpath, do os.path.join(dirpath, name).

    If optional arg 'topdown' is true or not specified, the triple for a
    directory is generated before the triples for any of its subdirectories
    (directories are generated top down).  If topdown is false, the triple
    for a directory is generated after the triples for all of its
    subdirectories (directories are generated bottom up).

    When topdown is true, the caller can modify the dirnames list in-place
    (e.g., via del or slice assignment), and walk will only recurse into the
    subdirectories whose names remain in dirnames; this can be used to prune
    the search, or to impose a specific order of visiting.  Modifying
    dirnames when topdown is false is ineffective, since the directories in
    dirnames have already been generated by the time dirnames itself is
    generated.

    By default errors from the os.listdir() call are ignored.  If
    optional arg 'onerror' is specified, it should be a function; it
    will be called with one argument, an os.error instance.  It can
    report the error to continue with the walk, or raise the exception
    to abort the walk.  Note that the filename is available as the
    filename attribute of the exception object.

    Caution:  if you pass a relative pathname for top, don't change the
    current working directory between resumptions of walk.  walk never
    changes the current directory, and assumes that the client doesn't
    either.

    Example:

    from os.path import join, getsize
    for root, dirs, files in walk('python/Lib/email'):
        print root, "consumes",
        print sum([getsize(join(root, name)) for name in files]),
        print "bytes in", len(files), "non-directory files"
        if 'CVS' in dirs:
            dirs.remove('CVS')  # don't visit CVS directories
    """

    from os.path import join, isdir, islink

    # We may not have read permission for top, in which case we can't
    # get a list of the files the directory contains.  os.path.walk
    # always suppressed the exception then, rather than blow up for a
    # minor reason when (say) a thousand readable directories are still
    # left to visit.  That logic is copied here.
    try:
        # Note that listdir and error are globals in this module due
        # to earlier import-*.
        names = listdir(top)
    except error, err:
        if onerror is not None:
            onerror(err)
        return

    dirs, nondirs = [], []
    for name in names:
        if isdir(join(top, name)):
            dirs.append(name)
        else:
            nondirs.append(name)

    if topdown:
        yield top, dirs, nondirs
    for name in dirs:
        path = join(top, name)
        if not islink(path):
            for x in walk(path, topdown, onerror):
                yield x
    if not topdown:
        yield top, dirs, nondirs

__all__.append("walk")

# Make sure os.environ exists, at least
try:
    environ
except NameError:
    environ = {}

def execl(file, *args):
    """execl(file, *args)

    Execute the executable file with argument list args, replacing the
    current process. """
    execv(file, args)

def execle(file, *args):
    """execle(file, *args, env)

    Execute the executable file with argument list args and
    environment env, replacing the current process. """
    env = args[-1]
    execve(file, args[:-1], env)

def execlp(file, *args):
    """execlp(file, *args)

    Execute the executable file (which is searched for along $PATH)
    with argument list args, replacing the current process. """
    execvp(file, args)

def execlpe(file, *args):
    """execlpe(file, *args, env)

    Execute the executable file (which is searched for along $PATH)
    with argument list args and environment env, replacing the current
    process. """
    env = args[-1]
    execvpe(file, args[:-1], env)

def execvp(file, args):
    """execp(file, args)

    Execute the executable file (which is searched for along $PATH)
    with argument list args, replacing the current process.
    args may be a list or tuple of strings. """
    _execvpe(file, args)

def execvpe(file, args, env):
    """execvpe(file, args, env)

    Execute the executable file (which is searched for along $PATH)
    with argument list args and environment env , replacing the
    current process.
    args may be a list or tuple of strings. """
    _execvpe(file, args, env)

__all__.extend(["execl","execle","execlp","execlpe","execvp","execvpe"])

def _execvpe(file, args, env=None):
    from errno import ENOENT, ENOTDIR

    if env is not None:
        func = execve
        argrest = (args, env)
    else:
        func = execv
        argrest = (args,)
        env = environ

    head, tail = path.split(file)
    if head:
        func(file, *argrest)
        return
    if 'PATH' in env:
        envpath = env['PATH']
    else:
        envpath = defpath
    PATH = envpath.split(pathsep)
    saved_exc = None
    saved_tb = None
    for dir in PATH:
        fullname = path.join(dir, file)
        try:
            func(fullname, *argrest)
        except error, e:
            tb = sys.exc_info()[2]
            if (e.errno != ENOENT and e.errno != ENOTDIR
                and saved_exc is None):
                saved_exc = e
                saved_tb = tb
    if saved_exc:
        raise error, saved_exc, saved_tb
    raise error, e, tb

# Change environ to automatically call putenv() if it exists
try:
    # This will fail if there's no putenv
    putenv
except NameError:
    pass
else:
    import UserDict

    # Fake unsetenv() for Windows
    # not sure about os2 here but
    # I'm guessing they are the same.

    if name in ('os2', 'nt'):
        def unsetenv(key):
            putenv(key, "")

    if name == "riscos":
        # On RISC OS, all env access goes through getenv and putenv
        from riscosenviron import _Environ
    elif name in ('os2', 'nt'):  # Where Env Var Names Must Be UPPERCASE
        # But we store them as upper case
        class _Environ(UserDict.IterableUserDict):
            def __init__(self, environ):
                UserDict.UserDict.__init__(self)
                data = self.data
                for k, v in environ.items():
                    data[k.upper()] = v
            def __setitem__(self, key, item):
                putenv(key, item)
                self.data[key.upper()] = item
            def __getitem__(self, key):
                return self.data[key.upper()]
            try:
                unsetenv
            except NameError:
                def __delitem__(self, key):
                    del self.data[key.upper()]
            else:
                def __delitem__(self, key):
                    unsetenv(key)
                    del self.data[key.upper()]
            def has_key(self, key):
                return key.upper() in self.data
            def __contains__(self, key):
                return key.upper() in self.data
            def get(self, key, failobj=None):
                return self.data.get(key.upper(), failobj)
            def update(self, dict=None, **kwargs):
                if dict:
                    try:
                        keys = dict.keys()
                    except AttributeError:
                        # List of (key, value)
                        for k, v in dict:
                            self[k] = v
                    else:
                        # got keys
                        # cannot use items(), since mappings
                        # may not have them.
                        for k in keys:
                            self[k] = dict[k]
                if kwargs:
                    self.update(kwargs)
            def copy(self):
                return dict(self)

    else:  # Where Env Var Names Can Be Mixed Case
        class _Environ(UserDict.IterableUserDict):
            def __init__(self, environ):
                UserDict.UserDict.__init__(self)
                self.data = environ
            def __setitem__(self, key, item):
                putenv(key, item)
                self.data[key] = item
            def update(self,  dict=None, **kwargs):
                if dict:
                    try:
                        keys = dict.keys()
                    except AttributeError:
                        # List of (key, value)
                        for k, v in dict:
                            self[k] = v
                    else:
                        # got keys
                        # cannot use items(), since mappings
                        # may not have them.
                        for k in keys:
                            self[k] = dict[k]
                if kwargs:
                    self.update(kwargs)
            try:
                unsetenv
            except NameError:
                pass
            else:
                def __delitem__(self, key):
                    unsetenv(key)
                    del self.data[key]
            def copy(self):
                return dict(self)


    environ = _Environ(environ)

def getenv(key, default=None):
    """Get an environment variable, return None if it doesn't exist.
    The optional second argument can specify an alternate default."""
    return environ.get(key, default)
__all__.append("getenv")

def _exists(name):
    try:
        eval(name)
        return True
    except NameError:
        return False

# Supply spawn*() (probably only for Unix)
if _exists("fork") and not _exists("spawnv") and _exists("execv"):

    P_WAIT = 0
    P_NOWAIT = P_NOWAITO = 1

    # XXX Should we support P_DETACH?  I suppose it could fork()**2
    # and close the std I/O streams.  Also, P_OVERLAY is the same
    # as execv*()?

    def _spawnvef(mode, file, args, env, func):
        # Internal helper; func is the exec*() function to use
        pid = fork()
        if not pid:
            # Child
            try:
                if env is None:
                    func(file, args)
                else:
                    func(file, args, env)
            except:
                _exit(127)
        else:
            # Parent
            if mode == P_NOWAIT:
                return pid # Caller is responsible for waiting!
            while 1:
                wpid, sts = waitpid(pid, 0)
                if WIFSTOPPED(sts):
                    continue
                elif WIFSIGNALED(sts):
                    return -WTERMSIG(sts)
                elif WIFEXITED(sts):
                    return WEXITSTATUS(sts)
                else:
                    raise error, "Not stopped, signaled or exited???"

    def spawnv(mode, file, args):
        """spawnv(mode, file, args) -> integer

Execute file with arguments from args in a subprocess.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. """
        return _spawnvef(mode, file, args, None, execv)

    def spawnve(mode, file, args, env):
        """spawnve(mode, file, args, env) -> integer

Execute file with arguments from args in a subprocess with the
specified environment.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. """
        return _spawnvef(mode, file, args, env, execve)

    # Note: spawnvp[e] is't currently supported on Windows

    def spawnvp(mode, file, args):
        """spawnvp(mode, file, args) -> integer

Execute file (which is looked for along $PATH) with arguments from
args in a subprocess.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. """
        return _spawnvef(mode, file, args, None, execvp)

    def spawnvpe(mode, file, args, env):
        """spawnvpe(mode, file, args, env) -> integer

Execute file (which is looked for along $PATH) with arguments from
args in a subprocess with the supplied environment.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. """
        return _spawnvef(mode, file, args, env, execvpe)

if _exists("spawnv"):
    # These aren't supplied by the basic Windows code
    # but can be easily implemented in Python

    def spawnl(mode, file, *args):
        """spawnl(mode, file, *args) -> integer

Execute file with arguments from args in a subprocess.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. """
        return spawnv(mode, file, args)

    def spawnle(mode, file, *args):
        """spawnle(mode, file, *args, env) -> integer

Execute file with arguments from args in a subprocess with the
supplied environment.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. """
        env = args[-1]
        return spawnve(mode, file, args[:-1], env)


    __all__.extend(["spawnv", "spawnve", "spawnl", "spawnle",])


if _exists("spawnvp"):
    # At the moment, Windows doesn't implement spawnvp[e],
    # so it won't have spawnlp[e] either.
    def spawnlp(mode, file, *args):
        """spawnlp(mode, file, *args) -> integer

Execute file (which is looked for along $PATH) with arguments from
args in a subprocess with the supplied environment.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. """
        return spawnvp(mode, file, args)

    def spawnlpe(mode, file, *args):
        """spawnlpe(mode, file, *args, env) -> integer

Execute file (which is looked for along $PATH) with arguments from
args in a subprocess with the supplied environment.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. """
        env = args[-1]
        return spawnvpe(mode, file, args[:-1], env)


    __all__.extend(["spawnvp", "spawnvpe", "spawnlp", "spawnlpe",])


# Supply popen2 etc. (for Unix)
if _exists("fork"):
    if not _exists("popen2"):
        def popen2(cmd, mode="t", bufsize=-1):
            """Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'
            may be a sequence, in which case arguments will be passed directly to
            the program without shell intervention (as with os.spawnv()).  If 'cmd'
            is a string it will be passed to the shell (as with os.system()). If
            'bufsize' is specified, it sets the buffer size for the I/O pipes.  The
            file objects (child_stdin, child_stdout) are returned."""
            import popen2
            stdout, stdin = popen2.popen2(cmd, bufsize)
            return stdin, stdout
        __all__.append("popen2")

    if not _exists("popen3"):
        def popen3(cmd, mode="t", bufsize=-1):
            """Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'
            may be a sequence, in which case arguments will be passed directly to
            the program without shell intervention (as with os.spawnv()).  If 'cmd'
            is a string it will be passed to the shell (as with os.system()). If
            'bufsize' is specified, it sets the buffer size for the I/O pipes.  The
            file objects (child_stdin, child_stdout, child_stderr) are returned."""
            import popen2
            stdout, stdin, stderr = popen2.popen3(cmd, bufsize)
            return stdin, stdout, stderr
        __all__.append("popen3")

    if not _exists("popen4"):
        def popen4(cmd, mode="t", bufsize=-1):
            """Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'
            may be a sequence, in which case arguments will be passed directly to
            the program without shell intervention (as with os.spawnv()).  If 'cmd'
            is a string it will be passed to the shell (as with os.system()). If
            'bufsize' is specified, it sets the buffer size for the I/O pipes.  The
            file objects (child_stdin, child_stdout_stderr) are returned."""
            import popen2
            stdout, stdin = popen2.popen4(cmd, bufsize)
            return stdin, stdout
        __all__.append("popen4")

import copy_reg as _copy_reg

def _make_stat_result(tup, dict):
    return stat_result(tup, dict)

def _pickle_stat_result(sr):
    (type, args) = sr.__reduce__()
    return (_make_stat_result, args)

try:
    _copy_reg.pickle(stat_result, _pickle_stat_result, _make_stat_result)
except NameError: # stat_result may not exist
    pass

def _make_statvfs_result(tup, dict):
    return statvfs_result(tup, dict)

def _pickle_statvfs_result(sr):
    (type, args) = sr.__reduce__()
    return (_make_statvfs_result, args)

try:
    _copy_reg.pickle(statvfs_result, _pickle_statvfs_result,
                     _make_statvfs_result)
except NameError: # statvfs_result may not exist
    pass

if not _exists("urandom"):
    def urandom(n):
        """urandom(n) -> str

        Return a string of n random bytes suitable for cryptographic use.

        """
        try:
            _urandomfd = open("/dev/urandom", O_RDONLY)
        except (OSError, IOError):
            raise NotImplementedError("/dev/urandom (or equivalent) not found")
        bytes = ""
        while len(bytes) < n:
            bytes += read(_urandomfd, n - len(bytes))
        close(_urandomfd)
        return bytes

########NEW FILE########
__FILENAME__ = posixpath
"""Common operations on Posix pathnames.

Instead of importing this module directly, import os and refer to
this module as os.path.  The "os.path" name is an alias for this
module on Posix systems; on other systems (e.g. Mac, Windows),
os.path provides the same operations in a manner specific to that
platform, and is an alias to another module (e.g. macpath, ntpath).

Some of this can actually be useful on non-Posix systems too, e.g.
for manipulation of the pathname component of URLs.
"""

import os
import stat

__all__ = ["normcase","isabs","join","splitdrive","split","splitext",
           "basename","dirname","commonprefix","getsize","getmtime",
           "getatime","getctime","islink","exists","lexists","isdir","isfile",
           "ismount","walk","expanduser","expandvars","normpath","abspath",
           "samefile","sameopenfile","samestat",
           "curdir","pardir","sep","pathsep","defpath","altsep","extsep",
           "devnull","realpath","supports_unicode_filenames"]

# strings representing various path-related bits and pieces
curdir = '.'
pardir = '..'
extsep = '.'
sep = '/'
pathsep = ':'
defpath = ':/bin:/usr/bin'
altsep = None
devnull = '/dev/null'

# Normalize the case of a pathname.  Trivial in Posix, string.lower on Mac.
# On MS-DOS this may also turn slashes into backslashes; however, other
# normalizations (such as optimizing '../' away) are not allowed
# (another function should be defined to do that).

def normcase(s):
    """Normalize case of pathname.  Has no effect under Posix"""
    return s


# Return whether a path is absolute.
# Trivial in Posix, harder on the Mac or MS-DOS.

def isabs(s):
    """Test whether a path is absolute"""
    return s.startswith('/')


# Join pathnames.
# Ignore the previous parts if a part is absolute.
# Insert a '/' unless the first part is empty or already ends in '/'.

def join(a, *p):
    """Join two or more pathname components, inserting '/' as needed"""
    path = a
    for b in p:
        if b.startswith('/'):
            path = b
        elif path == '' or path.endswith('/'):
            path +=  b
        else:
            path += '/' + b
    return path


# Split a path in head (everything up to the last '/') and tail (the
# rest).  If the path ends in '/', tail will be empty.  If there is no
# '/' in the path, head  will be empty.
# Trailing '/'es are stripped from head unless it is the root.

def split(p):
    """Split a pathname.  Returns tuple "(head, tail)" where "tail" is
    everything after the final slash.  Either part may be empty."""
    i = p.rfind('/') + 1
    head, tail = p[:i], p[i:]
    if head and head != '/'*len(head):
        head = head.rstrip('/')
    return head, tail


# Split a path in root and extension.
# The extension is everything starting at the last dot in the last
# pathname component; the root is everything before that.
# It is always true that root + ext == p.

def splitext(p):
    """Split the extension from a pathname.  Extension is everything from the
    last dot to the end.  Returns "(root, ext)", either part may be empty."""
    i = p.rfind('.')
    if i<=p.rfind('/'):
        return p, ''
    else:
        return p[:i], p[i:]


# Split a pathname into a drive specification and the rest of the
# path.  Useful on DOS/Windows/NT; on Unix, the drive is always empty.

def splitdrive(p):
    """Split a pathname into drive and path. On Posix, drive is always
    empty."""
    return '', p


# Return the tail (basename) part of a path.

def basename(p):
    """Returns the final component of a pathname"""
    return split(p)[1]


# Return the head (dirname) part of a path.

def dirname(p):
    """Returns the directory component of a pathname"""
    return split(p)[0]


# Return the longest prefix of all list elements.

def commonprefix(m):
    "Given a list of pathnames, returns the longest common leading component"
    if not m: return ''
    s1 = min(m)
    s2 = max(m)
    n = min(len(s1), len(s2))
    for i in xrange(n):
        if s1[i] != s2[i]:
            return s1[:i]
    return s1[:n]

# Get size, mtime, atime of files.

def getsize(filename):
    """Return the size of a file, reported by os.stat()."""
    return os.stat(filename).st_size

def getmtime(filename):
    """Return the last modification time of a file, reported by os.stat()."""
    return os.stat(filename).st_mtime

def getatime(filename):
    """Return the last access time of a file, reported by os.stat()."""
    return os.stat(filename).st_atime

def getctime(filename):
    """Return the metadata change time of a file, reported by os.stat()."""
    return os.stat(filename).st_ctime

# Is a path a symbolic link?
# This will always return false on systems where os.lstat doesn't exist.

def islink(path):
    """Test whether a path is a symbolic link"""
    try:
        st = os.lstat(path)
    except (os.error, AttributeError):
        return False
    return stat.S_ISLNK(st.st_mode)


# Does a path exist?
# This is false for dangling symbolic links.

def exists(path):
    """Test whether a path exists.  Returns False for broken symbolic links"""
    try:
        st = os.stat(path)
    except os.error:
        return False
    return True


# Being true for dangling symbolic links is also useful.

def lexists(path):
    """Test whether a path exists.  Returns True for broken symbolic links"""
    try:
        st = os.lstat(path)
    except os.error:
        return False
    return True


# Is a path a directory?
# This follows symbolic links, so both islink() and isdir() can be true
# for the same path.

def isdir(path):
    """Test whether a path is a directory"""
    try:
        st = os.stat(path)
    except os.error:
        return False
    return stat.S_ISDIR(st.st_mode)


# Is a path a regular file?
# This follows symbolic links, so both islink() and isfile() can be true
# for the same path.

def isfile(path):
    """Test whether a path is a regular file"""
    try:
        st = os.stat(path)
    except os.error:
        return False
    return stat.S_ISREG(st.st_mode)


# Are two filenames really pointing to the same file?

def samefile(f1, f2):
    """Test whether two pathnames reference the same actual file"""
    s1 = os.stat(f1)
    s2 = os.stat(f2)
    return samestat(s1, s2)


# Are two open files really referencing the same file?
# (Not necessarily the same file descriptor!)

def sameopenfile(fp1, fp2):
    """Test whether two open file objects reference the same file"""
    s1 = os.fstat(fp1)
    s2 = os.fstat(fp2)
    return samestat(s1, s2)


# Are two stat buffers (obtained from stat, fstat or lstat)
# describing the same file?

def samestat(s1, s2):
    """Test whether two stat buffers reference the same file"""
    return s1.st_ino == s2.st_ino and \
           s1.st_dev == s2.st_dev


# Is a path a mount point?
# (Does this work for all UNIXes?  Is it even guaranteed to work by Posix?)

def ismount(path):
    """Test whether a path is a mount point"""
    try:
        s1 = os.stat(path)
        s2 = os.stat(join(path, '..'))
    except os.error:
        return False # It doesn't exist -- so not a mount point :-)
    dev1 = s1.st_dev
    dev2 = s2.st_dev
    if dev1 != dev2:
        return True     # path/.. on a different device as path
    ino1 = s1.st_ino
    ino2 = s2.st_ino
    if ino1 == ino2:
        return True     # path/.. is the same i-node as path
    return False


# Directory tree walk.
# For each directory under top (including top itself, but excluding
# '.' and '..'), func(arg, dirname, filenames) is called, where
# dirname is the name of the directory and filenames is the list
# of files (and subdirectories etc.) in the directory.
# The func may modify the filenames list, to implement a filter,
# or to impose a different order of visiting.

def walk(top, func, arg):
    """Directory tree walk with callback function.

    For each directory in the directory tree rooted at top (including top
    itself, but excluding '.' and '..'), call func(arg, dirname, fnames).
    dirname is the name of the directory, and fnames a list of the names of
    the files and subdirectories in dirname (excluding '.' and '..').  func
    may modify the fnames list in-place (e.g. via del or slice assignment),
    and walk will only recurse into the subdirectories whose names remain in
    fnames; this can be used to implement a filter, or to impose a specific
    order of visiting.  No semantics are defined for, or required of, arg,
    beyond that arg is always passed to func.  It can be used, e.g., to pass
    a filename pattern, or a mutable object designed to accumulate
    statistics.  Passing None for arg is common."""

    try:
        names = os.listdir(top)
    except os.error:
        return
    func(arg, top, names)
    for name in names:
        name = join(top, name)
        try:
            st = os.lstat(name)
        except os.error:
            continue
        if stat.S_ISDIR(st.st_mode):
            walk(name, func, arg)


# Expand paths beginning with '~' or '~user'.
# '~' means $HOME; '~user' means that user's home directory.
# If the path doesn't begin with '~', or if the user or $HOME is unknown,
# the path is returned unchanged (leaving error reporting to whatever
# function is called with the expanded path as argument).
# See also module 'glob' for expansion of *, ? and [...] in pathnames.
# (A function should also be defined to do full *sh-style environment
# variable expansion.)

def expanduser(path):
    """Expand ~ and ~user constructions.  If user or $HOME is unknown,
    do nothing."""
    if not path.startswith('~'):
        return path
    i = path.find('/', 1)
    if i < 0:
        i = len(path)
    if i == 1:
        if 'HOME' not in os.environ:
            import pwd
            userhome = pwd.getpwuid(os.getuid()).pw_dir
        else:
            userhome = os.environ['HOME']
    else:
        import pwd
        try:
            pwent = pwd.getpwnam(path[1:i])
        except KeyError:
            return path
        userhome = pwent.pw_dir
    userhome = userhome.rstrip('/')
    return userhome + path[i:]


# Expand paths containing shell variable substitutions.
# This expands the forms $variable and ${variable} only.
# Non-existent variables are left unchanged.

_varprog = None

def expandvars(path):
    """Expand shell variables of form $var and ${var}.  Unknown variables
    are left unchanged."""
    global _varprog
    if '$' not in path:
        return path
    if not _varprog:
        import re
        _varprog = re.compile(r'\$(\w+|\{[^}]*\})')
    i = 0
    while True:
        m = _varprog.search(path, i)
        if not m:
            break
        i, j = m.span(0)
        name = m.group(1)
        if name.startswith('{') and name.endswith('}'):
            name = name[1:-1]
        if name in os.environ:
            tail = path[j:]
            path = path[:i] + os.environ[name]
            i = len(path)
            path += tail
        else:
            i = j
    return path


# Normalize a path, e.g. A//B, A/./B and A/foo/../B all become A/B.
# It should be understood that this may change the meaning of the path
# if it contains symbolic links!

def normpath(path):
    """Normalize path, eliminating double slashes, etc."""
    if path == '':
        return '.'
    initial_slashes = path.startswith('/')
    # POSIX allows one or two initial slashes, but treats three or more
    # as single slash.
    if (initial_slashes and
        path.startswith('//') and not path.startswith('///')):
        initial_slashes = 2
    comps = path.split('/')
    new_comps = []
    for comp in comps:
        if comp in ('', '.'):
            continue
        if (comp != '..' or (not initial_slashes and not new_comps) or
             (new_comps and new_comps[-1] == '..')):
            new_comps.append(comp)
        elif new_comps:
            new_comps.pop()
    comps = new_comps
    path = '/'.join(comps)
    if initial_slashes:
        path = '/'*initial_slashes + path
    return path or '.'


def abspath(path):
    """Return an absolute path."""
    if not isabs(path):
        path = join(os.getcwd(), path)
    return normpath(path)


# Return a canonical path (i.e. the absolute location of a file on the
# filesystem).

def realpath(filename):
    """Return the canonical path of the specified filename, eliminating any
symbolic links encountered in the path."""
    if isabs(filename):
        bits = ['/'] + filename.split('/')[1:]
    else:
        bits = [''] + filename.split('/')

    for i in range(2, len(bits)+1):
        component = join(*bits[0:i])
        # Resolve symbolic links.
        if islink(component):
            resolved = _resolve_link(component)
            if resolved is None:
                # Infinite loop -- return original component + rest of the path
                return abspath(join(*([component] + bits[i:])))
            else:
                newpath = join(*([resolved] + bits[i:]))
                return realpath(newpath)

    return abspath(filename)


def _resolve_link(path):
    """Internal helper function.  Takes a path and follows symlinks
    until we either arrive at something that isn't a symlink, or
    encounter a path we've seen before (meaning that there's a loop).
    """
    paths_seen = []
    while islink(path):
        if path in paths_seen:
            # Already seen this path, so we must have a symlink loop
            return None
        paths_seen.append(path)
        # Resolve where the link points to
        resolved = os.readlink(path)
        if not isabs(resolved):
            dir = dirname(path)
            path = normpath(join(dir, resolved))
        else:
            path = normpath(resolved)
    return path

supports_unicode_filenames = False

########NEW FILE########
__FILENAME__ = random
"""Random variable generators.

    integers
    --------
           uniform within range

    sequences
    ---------
           pick random element
           pick random sample
           generate random permutation

    distributions on the real line:
    ------------------------------
           uniform
           normal (Gaussian)
           lognormal
           negative exponential
           gamma
           beta
           pareto
           Weibull

    distributions on the circle (angles 0 to 2pi)
    ---------------------------------------------
           circular uniform
           von Mises

General notes on the underlying Mersenne Twister core generator:

* The period is 2**19937-1.
* It is one of the most extensively tested generators in existence.
* Without a direct way to compute N steps forward, the semantics of
  jumpahead(n) are weakened to simply jump to another distant state and rely
  on the large period to avoid overlapping sequences.
* The random() method is implemented in C, executes in a single Python step,
  and is, therefore, threadsafe.

"""

from warnings import warn as _warn
from types import MethodType as _MethodType, BuiltinMethodType as _BuiltinMethodType
from math import log as _log, exp as _exp, pi as _pi, e as _e, ceil as _ceil
from math import sqrt as _sqrt, acos as _acos, cos as _cos, sin as _sin
from os import urandom as _urandom
from binascii import hexlify as _hexlify

__all__ = ["Random","seed","random","uniform","randint","choice","sample",
           "randrange","shuffle","normalvariate","lognormvariate",
           "expovariate","vonmisesvariate","gammavariate",
           "gauss","betavariate","paretovariate","weibullvariate",
           "getstate","setstate","jumpahead", "WichmannHill", "getrandbits",
           "SystemRandom"]

NV_MAGICCONST = 4 * _exp(-0.5)/_sqrt(2.0)
TWOPI = 2.0*_pi
LOG4 = _log(4.0)
SG_MAGICCONST = 1.0 + _log(4.5)
BPF = 53        # Number of bits in a float
RECIP_BPF = 2**-BPF


# Translated by Guido van Rossum from C source provided by
# Adrian Baddeley.  Adapted by Raymond Hettinger for use with
# the Mersenne Twister  and os.urandom() core generators.

import _random

class Random(_random.Random):
    """Random number generator base class used by bound module functions.

    Used to instantiate instances of Random to get generators that don't
    share state.  Especially useful for multi-threaded programs, creating
    a different instance of Random for each thread, and using the jumpahead()
    method to ensure that the generated sequences seen by each thread don't
    overlap.

    Class Random can also be subclassed if you want to use a different basic
    generator of your own devising: in that case, override the following
    methods:  random(), seed(), getstate(), setstate() and jumpahead().
    Optionally, implement a getrandombits() method so that randrange()
    can cover arbitrarily large ranges.

    """

    VERSION = 2     # used by getstate/setstate

    def __init__(self, x=None):
        """Initialize an instance.

        Optional argument x controls seeding, as for Random.seed().
        """

        self.seed(x)
        self.gauss_next = None

    def seed(self, a=None):
        """Initialize internal state from hashable object.

        None or no argument seeds from current time or from an operating
        system specific randomness source if available.

        If a is not None or an int or long, hash(a) is used instead.
        """

        if a is None:
            try:
                a = long(_hexlify(_urandom(16)), 16)
            except NotImplementedError:
                import time
                a = long(time.time() * 256) # use fractional seconds

        super(Random, self).seed(a)
        self.gauss_next = None

    def getstate(self):
        """Return internal state; can be passed to setstate() later."""
        return self.VERSION, super(Random, self).getstate(), self.gauss_next

    def setstate(self, state):
        """Restore internal state from object returned by getstate()."""
        version = state[0]
        if version == 2:
            version, internalstate, self.gauss_next = state
            super(Random, self).setstate(internalstate)
        else:
            raise ValueError("state with version %s passed to "
                             "Random.setstate() of version %s" %
                             (version, self.VERSION))

## ---- Methods below this point do not need to be overridden when
## ---- subclassing for the purpose of using a different core generator.

## -------------------- pickle support  -------------------

    def __getstate__(self): # for pickle
        return self.getstate()

    def __setstate__(self, state):  # for pickle
        self.setstate(state)

    def __reduce__(self):
        return self.__class__, (), self.getstate()

## -------------------- integer methods  -------------------

    def randrange(self, start, stop=None, step=1, int=int, default=None,
                  maxwidth=1L<<BPF):
        """Choose a random item from range(start, stop[, step]).

        This fixes the problem with randint() which includes the
        endpoint; in Python this is usually not what you want.
        Do not supply the 'int', 'default', and 'maxwidth' arguments.
        """

        # This code is a bit messy to make it fast for the
        # common case while still doing adequate error checking.
        istart = int(start)
        if istart != start:
            raise ValueError, "non-integer arg 1 for randrange()"
        if stop is default:
            if istart > 0:
                if istart >= maxwidth:
                    return self._randbelow(istart)
                return int(self.random() * istart)
            raise ValueError, "empty range for randrange()"

        # stop argument supplied.
        istop = int(stop)
        if istop != stop:
            raise ValueError, "non-integer stop for randrange()"
        width = istop - istart
        if step == 1 and width > 0:
            # Note that
            #     int(istart + self.random()*width)
            # instead would be incorrect.  For example, consider istart
            # = -2 and istop = 0.  Then the guts would be in
            # -2.0 to 0.0 exclusive on both ends (ignoring that random()
            # might return 0.0), and because int() truncates toward 0, the
            # final result would be -1 or 0 (instead of -2 or -1).
            #     istart + int(self.random()*width)
            # would also be incorrect, for a subtler reason:  the RHS
            # can return a long, and then randrange() would also return
            # a long, but we're supposed to return an int (for backward
            # compatibility).

            if width >= maxwidth:
                return int(istart + self._randbelow(width))
            return int(istart + int(self.random()*width))
        if step == 1:
            raise ValueError, "empty range for randrange() (%d,%d, %d)" % (istart, istop, width)

        # Non-unit step argument supplied.
        istep = int(step)
        if istep != step:
            raise ValueError, "non-integer step for randrange()"
        if istep > 0:
            n = (width + istep - 1) // istep
        elif istep < 0:
            n = (width + istep + 1) // istep
        else:
            raise ValueError, "zero step for randrange()"

        if n <= 0:
            raise ValueError, "empty range for randrange()"

        if n >= maxwidth:
            return istart + istep*self._randbelow(n)
        return istart + istep*int(self.random() * n)

    def randint(self, a, b):
        """Return random integer in range [a, b], including both end points.
        """

        return self.randrange(a, b+1)

    def _randbelow(self, n, _log=_log, int=int, _maxwidth=1L<<BPF,
                   _Method=_MethodType, _BuiltinMethod=_BuiltinMethodType):
        """Return a random int in the range [0,n)

        Handles the case where n has more bits than returned
        by a single call to the underlying generator.
        """

        try:
            getrandbits = self.getrandbits
        except AttributeError:
            pass
        else:
            # Only call self.getrandbits if the original random() builtin method
            # has not been overridden or if a new getrandbits() was supplied.
            # This assures that the two methods correspond.
            if type(self.random) is _BuiltinMethod or type(getrandbits) is _Method:
                k = int(1.00001 + _log(n-1, 2.0))   # 2**k > n-1 > 2**(k-2)
                r = getrandbits(k)
                while r >= n:
                    r = getrandbits(k)
                return r
        if n >= _maxwidth:
            _warn("Underlying random() generator does not supply \n"
                "enough bits to choose from a population range this large")
        return int(self.random() * n)

## -------------------- sequence methods  -------------------

    def choice(self, seq):
        """Choose a random element from a non-empty sequence."""
        return seq[int(self.random() * len(seq))]  # raises IndexError if seq is empty

    def shuffle(self, x, random=None, int=int):
        """x, random=random.random -> shuffle list x in place; return None.

        Optional arg random is a 0-argument function returning a random
        float in [0.0, 1.0); by default, the standard random.random.
        """

        if random is None:
            random = self.random
        for i in reversed(xrange(1, len(x))):
            # pick an element in x[:i+1] with which to exchange x[i]
            j = int(random() * (i+1))
            x[i], x[j] = x[j], x[i]

    def sample(self, population, k):
        """Chooses k unique random elements from a population sequence.

        Returns a new list containing elements from the population while
        leaving the original population unchanged.  The resulting list is
        in selection order so that all sub-slices will also be valid random
        samples.  This allows raffle winners (the sample) to be partitioned
        into grand prize and second place winners (the subslices).

        Members of the population need not be hashable or unique.  If the
        population contains repeats, then each occurrence is a possible
        selection in the sample.

        To choose a sample in a range of integers, use xrange as an argument.
        This is especially fast and space efficient for sampling from a
        large population:   sample(xrange(10000000), 60)
        """

        # XXX Although the documentation says `population` is "a sequence",
        # XXX attempts are made to cater to any iterable with a __len__
        # XXX method.  This has had mixed success.  Examples from both
        # XXX sides:  sets work fine, and should become officially supported;
        # XXX dicts are much harder, and have failed in various subtle
        # XXX ways across attempts.  Support for mapping types should probably
        # XXX be dropped (and users should pass mapping.keys() or .values()
        # XXX explicitly).

        # Sampling without replacement entails tracking either potential
        # selections (the pool) in a list or previous selections in a set.

        # When the number of selections is small compared to the
        # population, then tracking selections is efficient, requiring
        # only a small set and an occasional reselection.  For
        # a larger number of selections, the pool tracking method is
        # preferred since the list takes less space than the
        # set and it doesn't suffer from frequent reselections.

        n = len(population)
        if not 0 <= k <= n:
            raise ValueError, "sample larger than population"
        random = self.random
        _int = int
        result = [None] * k
        setsize = 21        # size of a small set minus size of an empty list
        if k > 5:
            setsize += 4 ** _ceil(_log(k * 3, 4)) # table size for big sets
        if n <= setsize or hasattr(population, "keys"):
            # An n-length list is smaller than a k-length set, or this is a
            # mapping type so the other algorithm wouldn't work.
            pool = list(population)
            for i in xrange(k):         # invariant:  non-selected at [0,n-i)
                j = _int(random() * (n-i))
                result[i] = pool[j]
                pool[j] = pool[n-i-1]   # move non-selected item into vacancy
        else:
            try:
                selected = set()
                selected_add = selected.add
                for i in xrange(k):
                    j = _int(random() * n)
                    while j in selected:
                        j = _int(random() * n)
                    selected_add(j)
                    result[i] = population[j]
            except (TypeError, KeyError):   # handle (at least) sets
                if isinstance(population, list):
                    raise
                return self.sample(tuple(population), k)
        return result

## -------------------- real-valued distributions  -------------------

## -------------------- uniform distribution -------------------

    def uniform(self, a, b):
        """Get a random number in the range [a, b)."""
        return a + (b-a) * self.random()

## -------------------- normal distribution --------------------

    def normalvariate(self, mu, sigma):
        """Normal distribution.

        mu is the mean, and sigma is the standard deviation.

        """
        # mu = mean, sigma = standard deviation

        # Uses Kinderman and Monahan method. Reference: Kinderman,
        # A.J. and Monahan, J.F., "Computer generation of random
        # variables using the ratio of uniform deviates", ACM Trans
        # Math Software, 3, (1977), pp257-260.

        random = self.random
        while 1:
            u1 = random()
            u2 = 1.0 - random()
            z = NV_MAGICCONST*(u1-0.5)/u2
            zz = z*z/4.0
            if zz <= -_log(u2):
                break
        return mu + z*sigma

## -------------------- lognormal distribution --------------------

    def lognormvariate(self, mu, sigma):
        """Log normal distribution.

        If you take the natural logarithm of this distribution, you'll get a
        normal distribution with mean mu and standard deviation sigma.
        mu can have any value, and sigma must be greater than zero.

        """
        return _exp(self.normalvariate(mu, sigma))

## -------------------- exponential distribution --------------------

    def expovariate(self, lambd):
        """Exponential distribution.

        lambd is 1.0 divided by the desired mean.  (The parameter would be
        called "lambda", but that is a reserved word in Python.)  Returned
        values range from 0 to positive infinity.

        """
        # lambd: rate lambd = 1/mean
        # ('lambda' is a Python reserved word)

        random = self.random
        u = random()
        while u <= 1e-7:
            u = random()
        return -_log(u)/lambd

## -------------------- von Mises distribution --------------------

    def vonmisesvariate(self, mu, kappa):
        """Circular data distribution.

        mu is the mean angle, expressed in radians between 0 and 2*pi, and
        kappa is the concentration parameter, which must be greater than or
        equal to zero.  If kappa is equal to zero, this distribution reduces
        to a uniform random angle over the range 0 to 2*pi.

        """
        # mu:    mean angle (in radians between 0 and 2*pi)
        # kappa: concentration parameter kappa (>= 0)
        # if kappa = 0 generate uniform random angle

        # Based upon an algorithm published in: Fisher, N.I.,
        # "Statistical Analysis of Circular Data", Cambridge
        # University Press, 1993.

        # Thanks to Magnus Kessler for a correction to the
        # implementation of step 4.

        random = self.random
        if kappa <= 1e-6:
            return TWOPI * random()

        a = 1.0 + _sqrt(1.0 + 4.0 * kappa * kappa)
        b = (a - _sqrt(2.0 * a))/(2.0 * kappa)
        r = (1.0 + b * b)/(2.0 * b)

        while 1:
            u1 = random()

            z = _cos(_pi * u1)
            f = (1.0 + r * z)/(r + z)
            c = kappa * (r - f)

            u2 = random()

            if u2 < c * (2.0 - c) or u2 <= c * _exp(1.0 - c):
                break

        u3 = random()
        if u3 > 0.5:
            theta = (mu % TWOPI) + _acos(f)
        else:
            theta = (mu % TWOPI) - _acos(f)

        return theta

## -------------------- gamma distribution --------------------

    def gammavariate(self, alpha, beta):
        """Gamma distribution.  Not the gamma function!

        Conditions on the parameters are alpha > 0 and beta > 0.

        """

        # alpha > 0, beta > 0, mean is alpha*beta, variance is alpha*beta**2

        # Warning: a few older sources define the gamma distribution in terms
        # of alpha > -1.0
        if alpha <= 0.0 or beta <= 0.0:
            raise ValueError, 'gammavariate: alpha and beta must be > 0.0'

        random = self.random
        if alpha > 1.0:

            # Uses R.C.H. Cheng, "The generation of Gamma
            # variables with non-integral shape parameters",
            # Applied Statistics, (1977), 26, No. 1, p71-74

            ainv = _sqrt(2.0 * alpha - 1.0)
            bbb = alpha - LOG4
            ccc = alpha + ainv

            while 1:
                u1 = random()
                if not 1e-7 < u1 < .9999999:
                    continue
                u2 = 1.0 - random()
                v = _log(u1/(1.0-u1))/ainv
                x = alpha*_exp(v)
                z = u1*u1*u2
                r = bbb+ccc*v-x
                if r + SG_MAGICCONST - 4.5*z >= 0.0 or r >= _log(z):
                    return x * beta

        elif alpha == 1.0:
            # expovariate(1)
            u = random()
            while u <= 1e-7:
                u = random()
            return -_log(u) * beta

        else:   # alpha is between 0 and 1 (exclusive)

            # Uses ALGORITHM GS of Statistical Computing - Kennedy & Gentle

            while 1:
                u = random()
                b = (_e + alpha)/_e
                p = b*u
                if p <= 1.0:
                    x = p ** (1.0/alpha)
                else:
                    x = -_log((b-p)/alpha)
                u1 = random()
                if p > 1.0:
                    if u1 <= x ** (alpha - 1.0):
                        break
                elif u1 <= _exp(-x):
                    break
            return x * beta

## -------------------- Gauss (faster alternative) --------------------

    def gauss(self, mu, sigma):
        """Gaussian distribution.

        mu is the mean, and sigma is the standard deviation.  This is
        slightly faster than the normalvariate() function.

        Not thread-safe without a lock around calls.

        """

        # When x and y are two variables from [0, 1), uniformly
        # distributed, then
        #
        #    cos(2*pi*x)*sqrt(-2*log(1-y))
        #    sin(2*pi*x)*sqrt(-2*log(1-y))
        #
        # are two *independent* variables with normal distribution
        # (mu = 0, sigma = 1).
        # (Lambert Meertens)
        # (corrected version; bug discovered by Mike Miller, fixed by LM)

        # Multithreading note: When two threads call this function
        # simultaneously, it is possible that they will receive the
        # same return value.  The window is very small though.  To
        # avoid this, you have to use a lock around all calls.  (I
        # didn't want to slow this down in the serial case by using a
        # lock here.)

        random = self.random
        z = self.gauss_next
        self.gauss_next = None
        if z is None:
            x2pi = random() * TWOPI
            g2rad = _sqrt(-2.0 * _log(1.0 - random()))
            z = _cos(x2pi) * g2rad
            self.gauss_next = _sin(x2pi) * g2rad

        return mu + z*sigma

## -------------------- beta --------------------
## See
## http://sourceforge.net/bugs/?func=detailbug&bug_id=130030&group_id=5470
## for Ivan Frohne's insightful analysis of why the original implementation:
##
##    def betavariate(self, alpha, beta):
##        # Discrete Event Simulation in C, pp 87-88.
##
##        y = self.expovariate(alpha)
##        z = self.expovariate(1.0/beta)
##        return z/(y+z)
##
## was dead wrong, and how it probably got that way.

    def betavariate(self, alpha, beta):
        """Beta distribution.

        Conditions on the parameters are alpha > 0 and beta > 0.
        Returned values range between 0 and 1.

        """

        # This version due to Janne Sinkkonen, and matches all the std
        # texts (e.g., Knuth Vol 2 Ed 3 pg 134 "the beta distribution").
        y = self.gammavariate(alpha, 1.)
        if y == 0:
            return 0.0
        else:
            return y / (y + self.gammavariate(beta, 1.))

## -------------------- Pareto --------------------

    def paretovariate(self, alpha):
        """Pareto distribution.  alpha is the shape parameter."""
        # Jain, pg. 495

        u = 1.0 - self.random()
        return 1.0 / pow(u, 1.0/alpha)

## -------------------- Weibull --------------------

    def weibullvariate(self, alpha, beta):
        """Weibull distribution.

        alpha is the scale parameter and beta is the shape parameter.

        """
        # Jain, pg. 499; bug fix courtesy Bill Arms

        u = 1.0 - self.random()
        return alpha * pow(-_log(u), 1.0/beta)

## -------------------- Wichmann-Hill -------------------

class WichmannHill(Random):

    VERSION = 1     # used by getstate/setstate

    def seed(self, a=None):
        """Initialize internal state from hashable object.

        None or no argument seeds from current time or from an operating
        system specific randomness source if available.

        If a is not None or an int or long, hash(a) is used instead.

        If a is an int or long, a is used directly.  Distinct values between
        0 and 27814431486575L inclusive are guaranteed to yield distinct
        internal states (this guarantee is specific to the default
        Wichmann-Hill generator).
        """

        if a is None:
            try:
                a = long(_hexlify(_urandom(16)), 16)
            except NotImplementedError:
                import time
                a = long(time.time() * 256) # use fractional seconds

        if not isinstance(a, (int, long)):
            a = hash(a)

        a, x = divmod(a, 30268)
        a, y = divmod(a, 30306)
        a, z = divmod(a, 30322)
        self._seed = int(x)+1, int(y)+1, int(z)+1

        self.gauss_next = None

    def random(self):
        """Get the next random number in the range [0.0, 1.0)."""

        # Wichman-Hill random number generator.
        #
        # Wichmann, B. A. & Hill, I. D. (1982)
        # Algorithm AS 183:
        # An efficient and portable pseudo-random number generator
        # Applied Statistics 31 (1982) 188-190
        #
        # see also:
        #        Correction to Algorithm AS 183
        #        Applied Statistics 33 (1984) 123
        #
        #        McLeod, A. I. (1985)
        #        A remark on Algorithm AS 183
        #        Applied Statistics 34 (1985),198-200

        # This part is thread-unsafe:
        # BEGIN CRITICAL SECTION
        x, y, z = self._seed
        x = (171 * x) % 30269
        y = (172 * y) % 30307
        z = (170 * z) % 30323
        self._seed = x, y, z
        # END CRITICAL SECTION

        # Note:  on a platform using IEEE-754 double arithmetic, this can
        # never return 0.0 (asserted by Tim; proof too long for a comment).
        return (x/30269.0 + y/30307.0 + z/30323.0) % 1.0

    def getstate(self):
        """Return internal state; can be passed to setstate() later."""
        return self.VERSION, self._seed, self.gauss_next

    def setstate(self, state):
        """Restore internal state from object returned by getstate()."""
        version = state[0]
        if version == 1:
            version, self._seed, self.gauss_next = state
        else:
            raise ValueError("state with version %s passed to "
                             "Random.setstate() of version %s" %
                             (version, self.VERSION))

    def jumpahead(self, n):
        """Act as if n calls to random() were made, but quickly.

        n is an int, greater than or equal to 0.

        Example use:  If you have 2 threads and know that each will
        consume no more than a million random numbers, create two Random
        objects r1 and r2, then do
            r2.setstate(r1.getstate())
            r2.jumpahead(1000000)
        Then r1 and r2 will use guaranteed-disjoint segments of the full
        period.
        """

        if not n >= 0:
            raise ValueError("n must be >= 0")
        x, y, z = self._seed
        x = int(x * pow(171, n, 30269)) % 30269
        y = int(y * pow(172, n, 30307)) % 30307
        z = int(z * pow(170, n, 30323)) % 30323
        self._seed = x, y, z

    def __whseed(self, x=0, y=0, z=0):
        """Set the Wichmann-Hill seed from (x, y, z).

        These must be integers in the range [0, 256).
        """

        if not type(x) == type(y) == type(z) == int:
            raise TypeError('seeds must be integers')
        if not (0 <= x < 256 and 0 <= y < 256 and 0 <= z < 256):
            raise ValueError('seeds must be in range(0, 256)')
        if 0 == x == y == z:
            # Initialize from current time
            import time
            t = long(time.time() * 256)
            t = int((t&0xffffff) ^ (t>>24))
            t, x = divmod(t, 256)
            t, y = divmod(t, 256)
            t, z = divmod(t, 256)
        # Zero is a poor seed, so substitute 1
        self._seed = (x or 1, y or 1, z or 1)

        self.gauss_next = None

    def whseed(self, a=None):
        """Seed from hashable object's hash code.

        None or no argument seeds from current time.  It is not guaranteed
        that objects with distinct hash codes lead to distinct internal
        states.

        This is obsolete, provided for compatibility with the seed routine
        used prior to Python 2.1.  Use the .seed() method instead.
        """

        if a is None:
            self.__whseed()
            return
        a = hash(a)
        a, x = divmod(a, 256)
        a, y = divmod(a, 256)
        a, z = divmod(a, 256)
        x = (x + a) % 256 or 1
        y = (y + a) % 256 or 1
        z = (z + a) % 256 or 1
        self.__whseed(x, y, z)

## --------------- Operating System Random Source  ------------------

class SystemRandom(Random):
    """Alternate random number generator using sources provided
    by the operating system (such as /dev/urandom on Unix or
    CryptGenRandom on Windows).

     Not available on all systems (see os.urandom() for details).
    """

    def random(self):
        """Get the next random number in the range [0.0, 1.0)."""
        return (long(_hexlify(_urandom(7)), 16) >> 3) * RECIP_BPF

    def getrandbits(self, k):
        """getrandbits(k) -> x.  Generates a long int with k random bits."""
        if k <= 0:
            raise ValueError('number of bits must be greater than zero')
        if k != int(k):
            raise TypeError('number of bits should be an integer')
        bytes = (k + 7) // 8                    # bits / 8 and rounded up
        x = long(_hexlify(_urandom(bytes)), 16)
        return x >> (bytes * 8 - k)             # trim excess bits

    def _stub(self, *args, **kwds):
        "Stub method.  Not used for a system random number generator."
        return None
    seed = jumpahead = _stub

    def _notimplemented(self, *args, **kwds):
        "Method should not be called for a system random number generator."
        raise NotImplementedError('System entropy source does not have state.')
    getstate = setstate = _notimplemented

## -------------------- test program --------------------

def _test_generator(n, func, args):
    import time
    print n, 'times', func.__name__
    total = 0.0
    sqsum = 0.0
    smallest = 1e10
    largest = -1e10
    t0 = time.time()
    for i in range(n):
        x = func(*args)
        total += x
        sqsum = sqsum + x*x
        smallest = min(x, smallest)
        largest = max(x, largest)
    t1 = time.time()
    print round(t1-t0, 3), 'sec,',
    avg = total/n
    stddev = _sqrt(sqsum/n - avg*avg)
    print 'avg %g, stddev %g, min %g, max %g' % \
              (avg, stddev, smallest, largest)


def _test(N=2000):
    _test_generator(N, random, ())
    _test_generator(N, normalvariate, (0.0, 1.0))
    _test_generator(N, lognormvariate, (0.0, 1.0))
    _test_generator(N, vonmisesvariate, (0.0, 1.0))
    _test_generator(N, gammavariate, (0.01, 1.0))
    _test_generator(N, gammavariate, (0.1, 1.0))
    _test_generator(N, gammavariate, (0.1, 2.0))
    _test_generator(N, gammavariate, (0.5, 1.0))
    _test_generator(N, gammavariate, (0.9, 1.0))
    _test_generator(N, gammavariate, (1.0, 1.0))
    _test_generator(N, gammavariate, (2.0, 1.0))
    _test_generator(N, gammavariate, (20.0, 1.0))
    _test_generator(N, gammavariate, (200.0, 1.0))
    _test_generator(N, gauss, (0.0, 1.0))
    _test_generator(N, betavariate, (3.0, 3.0))

# Create one instance, seeded from current time, and export its methods
# as module-level functions.  The functions share state across all uses
#(both in the user's code and in the Python libraries), but that's fine
# for most programs and is easier for the casual user than making them
# instantiate their own Random() instance.

_inst = Random()
seed = _inst.seed
random = _inst.random
uniform = _inst.uniform
randint = _inst.randint
choice = _inst.choice
randrange = _inst.randrange
sample = _inst.sample
shuffle = _inst.shuffle
normalvariate = _inst.normalvariate
lognormvariate = _inst.lognormvariate
expovariate = _inst.expovariate
vonmisesvariate = _inst.vonmisesvariate
gammavariate = _inst.gammavariate
gauss = _inst.gauss
betavariate = _inst.betavariate
paretovariate = _inst.paretovariate
weibullvariate = _inst.weibullvariate
getstate = _inst.getstate
setstate = _inst.setstate
jumpahead = _inst.jumpahead
getrandbits = _inst.getrandbits

if __name__ == '__main__':
    _test()

########NEW FILE########
__FILENAME__ = stat
"""Constants/functions for interpreting results of os.stat() and os.lstat().

Suggested usage: from stat import *
"""

# XXX Strictly spoken, this module may have to be adapted for each POSIX
# implementation; in practice, however, the numeric constants used by
# stat() are almost universal (even for stat() emulations on non-UNIX
# systems like MS-DOS).

# Indices for stat struct members in tuple returned by os.stat()

ST_MODE  = 0
ST_INO   = 1
ST_DEV   = 2
ST_NLINK = 3
ST_UID   = 4
ST_GID   = 5
ST_SIZE  = 6
ST_ATIME = 7
ST_MTIME = 8
ST_CTIME = 9

# Extract bits from the mode

def S_IMODE(mode):
    return mode & 07777

def S_IFMT(mode):
    return mode & 0170000

# Constants used as S_IFMT() for various file types
# (not all are implemented on all systems)

S_IFDIR  = 0040000
S_IFCHR  = 0020000
S_IFBLK  = 0060000
S_IFREG  = 0100000
S_IFIFO  = 0010000
S_IFLNK  = 0120000
S_IFSOCK = 0140000

# Functions to test for each file type

def S_ISDIR(mode):
    return S_IFMT(mode) == S_IFDIR

def S_ISCHR(mode):
    return S_IFMT(mode) == S_IFCHR

def S_ISBLK(mode):
    return S_IFMT(mode) == S_IFBLK

def S_ISREG(mode):
    return S_IFMT(mode) == S_IFREG

def S_ISFIFO(mode):
    return S_IFMT(mode) == S_IFIFO

def S_ISLNK(mode):
    return S_IFMT(mode) == S_IFLNK

def S_ISSOCK(mode):
    return S_IFMT(mode) == S_IFSOCK

# Names for permission bits

S_ISUID = 04000
S_ISGID = 02000
S_ENFMT = S_ISGID
S_ISVTX = 01000
S_IREAD = 00400
S_IWRITE = 00200
S_IEXEC = 00100
S_IRWXU = 00700
S_IRUSR = 00400
S_IWUSR = 00200
S_IXUSR = 00100
S_IRWXG = 00070
S_IRGRP = 00040
S_IWGRP = 00020
S_IXGRP = 00010
S_IRWXO = 00007
S_IROTH = 00004
S_IWOTH = 00002
S_IXOTH = 00001

########NEW FILE########
__FILENAME__ = types
"""Define names for all type symbols known in the standard interpreter.

Types that are part of optional modules (e.g. array) are not listed.
"""
import sys

# Iterators in Python aren't a matter of type but of protocol.  A large
# and changing number of builtin types implement *some* flavor of
# iterator.  Don't check the type!  Use hasattr to check for both
# "__iter__" and "next" attributes instead.

NoneType = type(None)
TypeType = type
ObjectType = object

IntType = int
LongType = long
FloatType = float
BooleanType = bool
try:
    ComplexType = complex
except NameError:
    pass

StringType = str

# StringTypes is already outdated.  Instead of writing "type(x) in
# types.StringTypes", you should use "isinstance(x, basestring)".  But
# we keep around for compatibility with Python 2.2.
try:
    UnicodeType = unicode
    StringTypes = (StringType, UnicodeType)
except NameError:
    StringTypes = (StringType,)

BufferType = buffer

TupleType = tuple
ListType = list
DictType = DictionaryType = dict

def _f(): pass
FunctionType = type(_f)
LambdaType = type(lambda: None)         # Same as FunctionType
try:
    CodeType = type(_f.func_code)
except RuntimeError:
    # Execution in restricted environment
    pass

def _g():
    yield 1
GeneratorType = type(_g())

class _C:
    def _m(self): pass
ClassType = type(_C)
UnboundMethodType = type(_C._m)         # Same as MethodType
_x = _C()
InstanceType = type(_x)
MethodType = type(_x._m)

BuiltinFunctionType = type(len)
BuiltinMethodType = type([].append)     # Same as BuiltinFunctionType

ModuleType = type(sys)
FileType = file
XRangeType = xrange

try:
    raise TypeError
except TypeError:
    try:
        tb = sys.exc_info()[2]
        TracebackType = type(tb)
        FrameType = type(tb.tb_frame)
    except AttributeError:
        # In the restricted environment, exc_info returns (None, None,
        # None) Then, tb.tb_frame gives an attribute error
        pass
    tb = None; del tb

SliceType = slice
EllipsisType = type(Ellipsis)

DictProxyType = type(TypeType.__dict__)
NotImplementedType = type(NotImplemented)

# Extension types defined in a C helper module.  XXX There may be no
# equivalent in implementations other than CPython, so it seems better to
# leave them undefined then to set them to e.g. None.
try:
    import _types
except ImportError:
    pass
else:
    GetSetDescriptorType = type(_types.Helper.getter)
    MemberDescriptorType = type(_types.Helper.member)
    del _types

del sys, _f, _g, _C, _x                           # Not for export

########NEW FILE########
__FILENAME__ = UserDict
"""A more or less complete user-defined wrapper around dictionary objects."""

class UserDict:
    def __init__(self, dict=None, **kwargs):
        self.data = {}
        if dict is not None:
            self.update(dict)
        if len(kwargs):
            self.update(kwargs)
    def __repr__(self): return repr(self.data)
    def __cmp__(self, dict):
        if isinstance(dict, UserDict):
            return cmp(self.data, dict.data)
        else:
            return cmp(self.data, dict)
    def __len__(self): return len(self.data)
    def __getitem__(self, key):
        if key in self.data:
            return self.data[key]
        if hasattr(self.__class__, "__missing__"):
            return self.__class__.__missing__(self, key)
        raise KeyError(key)
    def __setitem__(self, key, item): self.data[key] = item
    def __delitem__(self, key): del self.data[key]
    def clear(self): self.data.clear()
    def copy(self):
        if self.__class__ is UserDict:
            return UserDict(self.data.copy())
        import copy
        data = self.data
        try:
            self.data = {}
            c = copy.copy(self)
        finally:
            self.data = data
        c.update(self)
        return c
    def keys(self): return self.data.keys()
    def items(self): return self.data.items()
    def iteritems(self): return self.data.iteritems()
    def iterkeys(self): return self.data.iterkeys()
    def itervalues(self): return self.data.itervalues()
    def values(self): return self.data.values()
    def has_key(self, key): return self.data.has_key(key)
    def update(self, dict=None, **kwargs):
        if dict is None:
            pass
        elif isinstance(dict, UserDict):
            self.data.update(dict.data)
        elif isinstance(dict, type({})) or not hasattr(dict, 'items'):
            self.data.update(dict)
        else:
            for k, v in dict.items():
                self[k] = v
        if len(kwargs):
            self.data.update(kwargs)
    def get(self, key, failobj=None):
        if not self.has_key(key):
            return failobj
        return self[key]
    def setdefault(self, key, failobj=None):
        if not self.has_key(key):
            self[key] = failobj
        return self[key]
    def pop(self, key, *args):
        return self.data.pop(key, *args)
    def popitem(self):
        return self.data.popitem()
    def __contains__(self, key):
        return key in self.data
    @classmethod
    def fromkeys(cls, iterable, value=None):
        d = cls()
        for key in iterable:
            d[key] = value
        return d

class IterableUserDict(UserDict):
    def __iter__(self):
        return iter(self.data)

class DictMixin:
    # Mixin defining all dictionary methods for classes that already have
    # a minimum dictionary interface including getitem, setitem, delitem,
    # and keys. Without knowledge of the subclass constructor, the mixin
    # does not define __init__() or copy().  In addition to the four base
    # methods, progressively more efficiency comes with defining
    # __contains__(), __iter__(), and iteritems().

    # second level definitions support higher levels
    def __iter__(self):
        for k in self.keys():
            yield k
    def has_key(self, key):
        try:
            value = self[key]
        except KeyError:
            return False
        return True
    def __contains__(self, key):
        return self.has_key(key)

    # third level takes advantage of second level definitions
    def iteritems(self):
        for k in self:
            yield (k, self[k])
    def iterkeys(self):
        return self.__iter__()

    # fourth level uses definitions from lower levels
    def itervalues(self):
        for _, v in self.iteritems():
            yield v
    def values(self):
        return [v for _, v in self.iteritems()]
    def items(self):
        return list(self.iteritems())
    def clear(self):
        for key in self.keys():
            del self[key]
    def setdefault(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            self[key] = default
        return default
    def pop(self, key, *args):
        if len(args) > 1:
            raise TypeError, "pop expected at most 2 arguments, got "\
                              + repr(1 + len(args))
        try:
            value = self[key]
        except KeyError:
            if args:
                return args[0]
            raise
        del self[key]
        return value
    def popitem(self):
        try:
            k, v = self.iteritems().next()
        except StopIteration:
            raise KeyError, 'container is empty'
        del self[k]
        return (k, v)
    def update(self, other=None, **kwargs):
        # Make progressively weaker assumptions about "other"
        if other is None:
            pass
        elif hasattr(other, 'iteritems'):  # iteritems saves memory and lookups
            for k, v in other.iteritems():
                self[k] = v
        elif hasattr(other, 'keys'):
            for k in other.keys():
                self[k] = other[k]
        else:
            for k, v in other:
                self[k] = v
        if kwargs:
            self.update(kwargs)
    def get(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            return default
    def __repr__(self):
        return repr(dict(self.iteritems()))
    def __cmp__(self, other):
        if other is None:
            return 1
        if isinstance(other, DictMixin):
            other = dict(other.iteritems())
        return cmp(dict(self.iteritems()), other)
    def __len__(self):
        return len(self.keys())

########NEW FILE########
__FILENAME__ = warnings
"""Python part of the warnings subsystem."""

# Note: function level imports should *not* be used
# in this module as it may cause import lock deadlock.
# See bug 683658.
import sys, types
import linecache

__all__ = ["warn", "showwarning", "formatwarning", "filterwarnings",
           "resetwarnings"]

# filters contains a sequence of filter 5-tuples
# The components of the 5-tuple are:
# - an action: error, ignore, always, default, module, or once
# - a compiled regex that must match the warning message
# - a class representing the warning category
# - a compiled regex that must match the module that is being warned
# - a line number for the line being warning, or 0 to mean any line
# If either if the compiled regexs are None, match anything.
filters = []
defaultaction = "default"
onceregistry = {}

def warn(message, category=None, stacklevel=1):
    """Issue a warning, or maybe ignore it or raise an exception."""
    # Check if message is already a Warning object
    if isinstance(message, Warning):
        category = message.__class__
    # Check category argument
    if category is None:
        category = UserWarning
    assert issubclass(category, Warning)
    # Get context information
    try:
        caller = sys._getframe(stacklevel)
    except ValueError:
        globals = sys.__dict__
        lineno = 1
    else:
        globals = caller.f_globals
        lineno = caller.f_lineno
    if '__name__' in globals:
        module = globals['__name__']
    else:
        module = "<string>"
    filename = globals.get('__file__')
    if filename:
        fnl = filename.lower()
        if fnl.endswith((".pyc", ".pyo")):
            filename = filename[:-1]
    else:
        if module == "__main__":
            try:
                filename = sys.argv[0]
            except AttributeError:
                # embedded interpreters don't have sys.argv, see bug #839151
                filename = '__main__'
        if not filename:
            filename = module
    registry = globals.setdefault("__warningregistry__", {})
    warn_explicit(message, category, filename, lineno, module, registry,
                  globals)

def warn_explicit(message, category, filename, lineno,
                  module=None, registry=None, module_globals=None):
    if module is None:
        module = filename or "<unknown>"
        if module[-3:].lower() == ".py":
            module = module[:-3] # XXX What about leading pathname?
    if registry is None:
        registry = {}
    if isinstance(message, Warning):
        text = str(message)
        category = message.__class__
    else:
        text = message
        message = category(message)
    key = (text, category, lineno)
    # Quick test for common case
    if registry.get(key):
        return
    # Search the filters
    for item in filters:
        action, msg, cat, mod, ln = item
        if ((msg is None or msg.match(text)) and
            issubclass(category, cat) and
            (mod is None or mod.match(module)) and
            (ln == 0 or lineno == ln)):
            break
    else:
        action = defaultaction
    # Early exit actions
    if action == "ignore":
        registry[key] = 1
        return

    # Prime the linecache for formatting, in case the
    # "file" is actually in a zipfile or something.
    linecache.getlines(filename, module_globals)

    if action == "error":
        raise message
    # Other actions
    if action == "once":
        registry[key] = 1
        oncekey = (text, category)
        if onceregistry.get(oncekey):
            return
        onceregistry[oncekey] = 1
    elif action == "always":
        pass
    elif action == "module":
        registry[key] = 1
        altkey = (text, category, 0)
        if registry.get(altkey):
            return
        registry[altkey] = 1
    elif action == "default":
        registry[key] = 1
    else:
        # Unrecognized actions are errors
        raise RuntimeError(
              "Unrecognized action (%r) in warnings.filters:\n %s" %
              (action, item))
    # Print message and context
    showwarning(message, category, filename, lineno)

def showwarning(message, category, filename, lineno, file=None):
    """Hook to write a warning to a file; replace if you like."""
    if file is None:
        file = sys.stderr
    try:
        file.write(formatwarning(message, category, filename, lineno))
    except IOError:
        pass # the file (probably stderr) is invalid - this warning gets lost.

def formatwarning(message, category, filename, lineno):
    """Function to format a warning the standard way."""
    s =  "%s:%s: %s: %s\n" % (filename, lineno, category.__name__, message)
    line = linecache.getline(filename, lineno).strip()
    if line:
        s = s + "  " + line + "\n"
    return s

def filterwarnings(action, message="", category=Warning, module="", lineno=0,
                   append=0):
    """Insert an entry into the list of warnings filters (at the front).

    Use assertions to check that all arguments have the right type."""
    import re
    assert action in ("error", "ignore", "always", "default", "module",
                      "once"), "invalid action: %r" % (action,)
    assert isinstance(message, basestring), "message must be a string"
    assert isinstance(category, (type, types.ClassType)), \
           "category must be a class"
    assert issubclass(category, Warning), "category must be a Warning subclass"
    assert isinstance(module, basestring), "module must be a string"
    assert isinstance(lineno, int) and lineno >= 0, \
           "lineno must be an int >= 0"
    item = (action, re.compile(message, re.I), category,
            re.compile(module), lineno)
    if append:
        filters.append(item)
    else:
        filters.insert(0, item)

def simplefilter(action, category=Warning, lineno=0, append=0):
    """Insert a simple entry into the list of warnings filters (at the front).

    A simple filter matches all modules and messages.
    """
    assert action in ("error", "ignore", "always", "default", "module",
                      "once"), "invalid action: %r" % (action,)
    assert isinstance(lineno, int) and lineno >= 0, \
           "lineno must be an int >= 0"
    item = (action, None, category, None, lineno)
    if append:
        filters.append(item)
    else:
        filters.insert(0, item)

def resetwarnings():
    """Clear the list of warning filters, so that no filters are active."""
    filters[:] = []

class _OptionError(Exception):
    """Exception used by option processing helpers."""
    pass

# Helper to process -W options passed via sys.warnoptions
def _processoptions(args):
    for arg in args:
        try:
            _setoption(arg)
        except _OptionError, msg:
            print >>sys.stderr, "Invalid -W option ignored:", msg

# Helper for _processoptions()
def _setoption(arg):
    import re
    parts = arg.split(':')
    if len(parts) > 5:
        raise _OptionError("too many fields (max 5): %r" % (arg,))
    while len(parts) < 5:
        parts.append('')
    action, message, category, module, lineno = [s.strip()
                                                 for s in parts]
    action = _getaction(action)
    message = re.escape(message)
    category = _getcategory(category)
    module = re.escape(module)
    if module:
        module = module + '$'
    if lineno:
        try:
            lineno = int(lineno)
            if lineno < 0:
                raise ValueError
        except (ValueError, OverflowError):
            raise _OptionError("invalid lineno %r" % (lineno,))
    else:
        lineno = 0
    filterwarnings(action, message, category, module, lineno)

# Helper for _setoption()
def _getaction(action):
    if not action:
        return "default"
    if action == "all": return "always" # Alias
    for a in ('default', 'always', 'ignore', 'module', 'once', 'error'):
        if a.startswith(action):
            return a
    raise _OptionError("invalid action: %r" % (action,))

# Helper for _setoption()
def _getcategory(category):
    import re
    if not category:
        return Warning
    if re.match("^[a-zA-Z0-9_]+$", category):
        try:
            cat = eval(category)
        except NameError:
            raise _OptionError("unknown warning category: %r" % (category,))
    else:
        i = category.rfind(".")
        module = category[:i]
        klass = category[i+1:]
        try:
            m = __import__(module, None, None, [klass])
        except ImportError:
            raise _OptionError("invalid module name: %r" % (module,))
        try:
            cat = getattr(m, klass)
        except AttributeError:
            raise _OptionError("unknown warning category: %r" % (category,))
    if not issubclass(cat, Warning):
        raise _OptionError("invalid warning category: %r" % (category,))
    return cat

# Module initialization
_processoptions(sys.warnoptions)
simplefilter("ignore", category=PendingDeprecationWarning, append=1)
simplefilter("ignore", category=ImportWarning, append=1)

########NEW FILE########
__FILENAME__ = __future__
"""Record of phased-in incompatible language changes.

Each line is of the form:

    FeatureName = "_Feature(" OptionalRelease "," MandatoryRelease ","
                              CompilerFlag ")"

where, normally, OptionalRelease < MandatoryRelease, and both are 5-tuples
of the same form as sys.version_info:

    (PY_MAJOR_VERSION, # the 2 in 2.1.0a3; an int
     PY_MINOR_VERSION, # the 1; an int
     PY_MICRO_VERSION, # the 0; an int
     PY_RELEASE_LEVEL, # "alpha", "beta", "candidate" or "final"; string
     PY_RELEASE_SERIAL # the 3; an int
    )

OptionalRelease records the first release in which

    from __future__ import FeatureName

was accepted.

In the case of MandatoryReleases that have not yet occurred,
MandatoryRelease predicts the release in which the feature will become part
of the language.

Else MandatoryRelease records when the feature became part of the language;
in releases at or after that, modules no longer need

    from __future__ import FeatureName

to use the feature in question, but may continue to use such imports.

MandatoryRelease may also be None, meaning that a planned feature got
dropped.

Instances of class _Feature have two corresponding methods,
.getOptionalRelease() and .getMandatoryRelease().

CompilerFlag is the (bitfield) flag that should be passed in the fourth
argument to the builtin function compile() to enable the feature in
dynamically compiled code.  This flag is stored in the .compiler_flag
attribute on _Future instances.  These values must match the appropriate
#defines of CO_xxx flags in Include/compile.h.

No feature line is ever to be deleted from this file.
"""

all_feature_names = [
    "nested_scopes",
    "generators",
    "division",
    "absolute_import",
    "with_statement",
]

__all__ = ["all_feature_names"] + all_feature_names

# The CO_xxx symbols are defined here under the same names used by
# compile.h, so that an editor search will find them here.  However,
# they're not exported in __all__, because they don't really belong to
# this module.
CO_NESTED            = 0x0010   # nested_scopes
CO_GENERATOR_ALLOWED = 0        # generators (obsolete, was 0x1000)
CO_FUTURE_DIVISION   = 0x2000   # division
CO_FUTURE_ABSOLUTE_IMPORT = 0x4000 # perform absolute imports by default
CO_FUTURE_WITH_STATEMENT  = 0x8000   # with statement

class _Feature:
    def __init__(self, optionalRelease, mandatoryRelease, compiler_flag):
        self.optional = optionalRelease
        self.mandatory = mandatoryRelease
        self.compiler_flag = compiler_flag

    def getOptionalRelease(self):
        """Return first release in which this feature was recognized.

        This is a 5-tuple, of the same form as sys.version_info.
        """

        return self.optional

    def getMandatoryRelease(self):
        """Return release in which this feature will become mandatory.

        This is a 5-tuple, of the same form as sys.version_info, or, if
        the feature was dropped, is None.
        """

        return self.mandatory

    def __repr__(self):
        return "_Feature" + repr((self.optional,
                                  self.mandatory,
                                  self.compiler_flag))

nested_scopes = _Feature((2, 1, 0, "beta",  1),
                         (2, 2, 0, "alpha", 0),
                         CO_NESTED)

generators = _Feature((2, 2, 0, "alpha", 1),
                      (2, 3, 0, "final", 0),
                      CO_GENERATOR_ALLOWED)

division = _Feature((2, 2, 0, "alpha", 2),
                    (3, 0, 0, "alpha", 0),
                    CO_FUTURE_DIVISION)

absolute_import = _Feature((2, 5, 0, "alpha", 1),
                           (2, 7, 0, "alpha", 0),
                           CO_FUTURE_ABSOLUTE_IMPORT)

with_statement = _Feature((2, 5, 0, "alpha", 1),
                          (2, 6, 0, "alpha", 0),
                          CO_FUTURE_WITH_STATEMENT)

########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LPD8/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': -1,
 'PLAY': -1,
 'REC': -1,
 'LOOP': -1,
 'RWD': -1,
 'FFWD': -1}
DEVICE_CONTROLS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
VOLUME_CONTROLS = ((-1, -1),
 (-1, -1),
 (-1, -1),
 (-1, -1),
 (-1, -1),
 (-1, -1),
 (-1, -1),
 (-1, -1))
TRACKARM_CONTROLS = (-1, -1, -1, -1, -1, -1, -1, -1)
BANK_CONTROLS = {'TOGGLELOCK': -1,
 'BANKDIAL': -1,
 'NEXTBANK': -1,
 'PREVBANK': -1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
PAD_TRANSLATION = ((0, 2, 40, 0),
 (1, 2, 41, 0),
 (2, 2, 42, 0),
 (3, 2, 43, 0),
 (0, 3, 36, 0),
 (1, 3, 37, 0),
 (2, 3, 38, 0),
 (3, 3, 39, 0))
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'LPD8',
 'OUTPUTPORT': 'LPD8',
 'CHANNEL': 0,
 'PAD_TRANSLATION': PAD_TRANSLATION}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': -1}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LPD8/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = 23
GENERIC_PLAY = 24
GENERIC_REC = 25
GENERIC_LOOP = 20
GENERIC_RWD = 21
GENERIC_FFWD = 22
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 1
GENERIC_ENC2 = 2
GENERIC_ENC3 = 3
GENERIC_ENC4 = 4
GENERIC_ENC5 = 5
GENERIC_ENC6 = 6
GENERIC_ENC7 = 7
GENERIC_ENC8 = 8
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 110
GENERIC_SLI2 = 111
GENERIC_SLI3 = 112
GENERIC_SLI4 = 113
GENERIC_SLI5 = 114
GENERIC_SLI6 = 115
GENERIC_SLI7 = 116
GENERIC_SLI8 = 117
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = 52
GENERIC_BUT2 = 53
GENERIC_BUT3 = 54
GENERIC_BUT4 = 55
GENERIC_BUT5 = 56
GENERIC_BUT6 = 57
GENERIC_BUT7 = 58
GENERIC_BUT8 = 59
GENERIC_BUT9 = 60
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = 80
GENERIC_PAD2 = 81
GENERIC_PAD3 = 82
GENERIC_PAD4 = 83
GENERIC_PAD5 = 85
GENERIC_PAD6 = 86
GENERIC_PAD7 = 87
GENERIC_PAD8 = 88
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = LV1_LX1
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LV1_LX1/LV1_LX1.py
from LV2_LX2_LC2_LD2.FaderfoxComponent import FaderfoxComponent
from LV2_LX2_LC2_LD2.FaderfoxScript import FaderfoxScript
from LV2_LX2_LC2_LD2.FaderfoxMixerController import FaderfoxMixerController
from LV2_LX2_LC2_LD2.FaderfoxDeviceController import FaderfoxDeviceController
from LV2_LX2_LC2_LD2.FaderfoxTransportController import FaderfoxTransportController

class LV1_LX1(FaderfoxScript):
    __module__ = __name__
    __doc__ = 'Automap script for LV1 Faderfox controllers'
    __name__ = 'LV1_LX1 Remote Script'

    def __init__(self, c_instance):
        LV1_LX1.realinit(self, c_instance)

    def realinit(self, c_instance):
        self.suffix = '1'
        FaderfoxScript.realinit(self, c_instance)
        self.is_lv1 = True
        self.log('lv1 lx1')
        self.mixer_controller = FaderfoxMixerController(self)
        self.device_controller = FaderfoxDeviceController(self)
        self.transport_controller = FaderfoxTransportController(self)
        self.components = [self.mixer_controller, self.device_controller, self.transport_controller]
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LV2_LX2_LC2_LD2/consts.py
TRACK_CHANNEL_SETUP1 = 9
AUX_CHANNEL_SETUP1 = 10
CHANNEL_SETUP1 = 11
TRACK_CHANNEL_SETUP2 = 12
AUX_CHANNEL_SETUP2 = 13
CHANNEL_SETUP2 = 14
SEND_CCS = [ [ x + i for x in [40,
 60,
 80,
 100] ] for i in range(0, 16) ]
PAN_X_CC = range(20, 36)
PAN_Y_CC = range(0, 16)
PAN_X_MASTER_CC = 36
PAN_Y_MASTER_CC = 16
LAUNCH_NOTES = [0,
 8,
 16,
 24,
 32,
 40,
 48,
 56,
 64,
 72,
 80,
 88,
 96,
 104,
 112,
 120]
STOP_NOTES = [1,
 9,
 17,
 25,
 33,
 41,
 49,
 57,
 65,
 73,
 81,
 89,
 97,
 105,
 113,
 121]
MUTE_NOTES = [2,
 10,
 18,
 26,
 34,
 42,
 50,
 58,
 66,
 74,
 82,
 90,
 98,
 106,
 114,
 122]
SOLO_NOTES = [3,
 11,
 19,
 27,
 35,
 43,
 51,
 59,
 67,
 75,
 83,
 91,
 99,
 107,
 115,
 123]
MONITOR_NOTES = [4,
 12,
 20,
 28,
 36,
 44,
 52,
 60,
 68,
 76,
 84,
 92,
 100,
 108,
 116,
 124]
ARM_NOTES = [5,
 13,
 21,
 29,
 37,
 45,
 53,
 61,
 69,
 77,
 85,
 93,
 101,
 109,
 117,
 125]
CROSS_AB_NOTES = [6,
 14,
 22,
 30,
 38,
 46,
 54,
 62,
 70,
 78,
 86,
 94,
 102,
 110,
 118,
 126]
LV1_FX3_CCS = [57,
 77,
 97,
 117]
LV1_FX4_CCS = [58,
 78,
 98,
 118]
LV1_FX1_JOY_X_CC = 37
LV1_FX1_JOY_Y_CC = 17
LV1_FX2_JOY_X_CC = 38
LV1_FX2_JOY_Y_CC = 18
FX1_JOY_X_CC = 38
FX1_JOY_Y_CC = 36
FX2_JOY_X_CC = 39
FX2_JOY_Y_CC = 37
SCENE_SCROLL_CC = 41
CUE_VOLUME_CC = 40
LV1_CUE_VOLUME_CC = 17
MAIN_VOLUME_CC = 17
LV1_MAIN_VOLUME_CC = 16
SCENE_UP_NOTE = 33
SCENE_DOWN_NOTE = 34
CROSSFADER_CC = 18
LV1_CROSSFADER_CC = 19
TRACK_SELECT_NOTES = range(16, 32)
MASTER_TRACK_SELECT_NOTE = 32
CLIP_SELECT_NOTE = 103
SCENE_LAUNCH_NOTE = 0
SCENE_STOP_NOTE = 1
MASTER_LAUNCH_NOTE = 0
MASTER_STOP_NOTE = 1
MASTER_MUTE_NOTE = 2
MASTER_SOLO_NOTE = 3
MASTER_MONITOR_NOTE = 4
MASTER_ARM_NOTE = 5
CLIP_TRANSPOSE_CC = 20
CLIP_GAIN_CC = 21
CLIP_LOOP_START_CC = 22
CLIP_LOOP_END_CC = 23
CLIP_CCS = [20,
 21,
 22,
 23]
CLIP_A_NOTE = 104
CLIP_STARTPOINT_NOTE = 105
CLIP_LOOP_STARTPOINT_NOTE = 106
CLIP_LOOP_ENDPOINT_NOTE = 107
FX3_CCS = [24,
 25,
 26,
 27]
FX3_NOTES = [108,
 109,
 110,
 111]
FX4_CCS = [28,
 29,
 30,
 31]
FX4_NOTES = [112,
 113,
 114,
 115]
FX5_CCS = [32,
 33,
 34,
 35]
FX5_NOTES = [116,
 117,
 118,
 119]
MASTER_EQ_CCS = [56,
 76,
 96,
 116]
VOLUME_CCS = range(0, 16)
SCENE_LAUNCH_NOTES = [8,
 9,
 10,
 11,
 12,
 13,
 14,
 15,
 39,
 40,
 41,
 42]
GLOBAL_PLAY_NOTE = 35
GLOBAL_STOP_NOTE = 36
SESSION_ARRANGE_SWITCH_NOTE = 37
CLIP_TRACK_SWITCH_NOTE = 38
MASTER_SEND_A_CC = 56
MASTER_SEND_B_CC = 76
MASTER_SEND_C_CC = 96
MASTER_SEND_D_CC = 116
MASTER_SEND_CCS = [56,
 76,
 96,
 116]
EQ_CCS = [ [ x + i for x in [40,
 60,
 80,
 100] ] for i in range(0, 16) ]
SLOT_LAUNCH_NOTES1 = [ range(i * 8, i * 8 + 6) for i in range(0, 16) ]
SLOT_LAUNCH_NOTES2 = [[6,
  7,
  55,
  56,
  57,
  58],
 [14,
  15,
  59,
  60,
  61,
  62],
 [22,
  23,
  63,
  64,
  65,
  66],
 [30,
  31,
  67,
  68,
  69,
  70],
 [38,
  39,
  71,
  72,
  73,
  74],
 [46,
  47,
  75,
  76,
  77,
  78],
 [54,
  55,
  79,
  80,
  81,
  82],
 [62,
  63,
  83,
  84,
  85,
  86],
 [70,
  71,
  87,
  88,
  89,
  90],
 [78,
  79,
  91,
  92,
  93,
  94],
 [86,
  87,
  95,
  96,
  97,
  98],
 [94,
  95,
  99,
  100,
  101,
  102],
 [102, 103],
 [110, 111],
 [118, 119],
 [126, 127]]
STATUS_MASK = 240
CHAN_MASK = 15
CC_STATUS = 176
NOTEON_STATUS = 144
NOTEOFF_STATUS = 128
STATUS_ON = 127
STATUS_OFF = 0
STATUS_OFF2 = 64
########NEW FILE########
__FILENAME__ = Devices
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LV2_LX2_LC2_LD2/Devices.py
import Live
RCK_BANK1 = ('Macro 1', 'Macro 2', 'Macro 3', 'Macro 4', 'Macro 5', 'Macro 6', 'Macro 7', 'Macro 8')
RCK_BANKS = RCK_BANK1
RCK_BOBS = RCK_BANK1
RCK_BNK_NAMES = 'Macros'
IMP_BANK1 = ('1 Start', '1 Transpose', '1 Stretch Factor', '1 Saturator Drive', '1 Filter Freq', '1 Filter Res', '1 Pan', '1 Volume')
IMP_BANK2 = ('2 Start', '2 Transpose', '2 Stretch Factor', '2 Saturator Drive', '2 Filter Freq', '2 Filter Res', '2 Pan', '2 Volume')
IMP_BANK3 = ('3 Start', '3 Transpose', '3 Stretch Factor', '3 Saturator Drive', '3 Filter Freq', '3 Filter Res', '3 Pan', '3 Volume')
IMP_BANK4 = ('4 Start', '4 Transpose', '4 Stretch Factor', '4 Saturator Drive', '4 Filter Freq', '4 Filter Res', '4 Pan', '4 Volume')
IMP_BANK5 = ('5 Start', '5 Transpose', '5 Stretch Factor', '5 Saturator Drive', '5 Filter Freq', '5 Filter Res', '5 Pan', '5 Volume')
IMP_BANK6 = ('6 Start', '6 Transpose', '6 Stretch Factor', '6 Saturator Drive', '6 Filter Freq', '6 Filter Res', '6 Pan', '6 Volume')
IMP_BANK7 = ('7 Start', '7 Transpose', '7 Stretch Factor', '7 Saturator Drive', '7 Filter Freq', '7 Filter Res', '7 Pan', '7 Volume')
IMP_BANK8 = ('8 Start', '8 Transpose', '8 Stretch Factor', '8 Saturator Drive', '8 Filter Freq', '8 Filter Res', '8 Pan', '8 Volume')
IMP_BOB = ('Global Time', 'Global Transpose', '1 Transpose', '2 Transpose', '3 Transpose', '4 Transpose', '5 Transpose', '6 Transpose')
IMP_BANKS = (IMP_BANK1,
 IMP_BANK2,
 IMP_BANK3,
 IMP_BANK4,
 IMP_BANK5,
 IMP_BANK6,
 IMP_BANK7,
 IMP_BANK8)
IMP_BOBS = IMP_BOB
IMP_BNK_NAMES = ('Pad 1', 'Pad 2', 'Pad 3', 'Pad 4', 'Pad 5', 'Pad 6', 'Pad 7', 'Pad 8')
OPR_BANK1 = ('Ae Attack', 'Ae Decay', 'Ae Sustain', 'Ae Release', 'A Coarse', 'A Fine', 'Osc-A Lev < Vel', 'Osc-A Level')
OPR_BANK2 = ('Be Attack', 'Be Decay', 'Be Sustain', 'Be Release', 'B Coarse', 'B Fine', 'Osc-B Lev < Vel', 'Osc-B Level')
OPR_BANK3 = ('Ce Attack', 'Ce Decay', 'Ce Sustain', 'Ce Release', 'C Coarse', 'C Fine', 'Osc-C Lev < Vel', 'Osc-C Level')
OPR_BANK4 = ('De Attack', 'De Decay', 'De Sustain', 'De Release', 'D Coarse', 'D Fine', 'Osc-D Lev < Vel', 'Osc-D Level')
OPR_BANK5 = ('Le Attack', 'Le Decay', 'Le Sustain', 'Le Release', 'LFO Rate', 'LFO Amt', 'LFO Type', 'LFO R < K')
OPR_BANK6 = ('Fe Attack', 'Fe Decay', 'Fe Sustain', 'Fe Release', 'Filter Freq', 'Filter Res', 'Fe R < Vel', 'Fe Amount')
OPR_BANK7 = ('Pe Attack', 'Pe Decay', 'Pe Sustain', 'Pe Release', 'Pe Init', 'Glide Time', 'Pe Amount', 'Spread')
OPR_BANK8 = ('Time < Key', 'Panorama', 'Pan < Key', 'Pan < Rnd', 'Algorithm', 'Time', 'Tone', 'Volume')
OPR_BOB = ('A Coarse', 'Osc-B Level', 'B Coarse', 'B Fine', 'Filter Freq', 'Filter Res', 'Time', 'Tone')
OPR_BANKS = (OPR_BANK1,
 OPR_BANK2,
 OPR_BANK3,
 OPR_BANK4,
 OPR_BANK5,
 OPR_BANK6,
 OPR_BANK7,
 OPR_BANK8)
OPR_BOBS = OPR_BOB
OPR_BNK_NAMES = ('Oscillator A', 'Oscillator B', 'Oscillator C', 'Oscillator D', 'LFO', 'Filter', 'Pitch Modulation', 'Routing')
TEN_BOB = ('Excitator Type', 'Exc ForceMassProt', 'String Decay', 'Str Damping', 'Vib Amount', 'Filter Freq', 'Filter Reso', 'Volume')
TEN_BOBS = TEN_BOB
ANA_BOB = ('F1 Freq', 'F1 Resonance', 'OSC1 Octave', 'Vib On/Off', 'AEG1 Attack', 'AEG1 Rel', 'Unison On/Off', 'Volume')
ANA_BOBS = ANA_BOB
ELEC_BOB = ('M Stiffness', 'M Force', 'Noise Amount', 'F Tine Vol', 'F Tone Vol', 'F Release', 'Damp Amount', 'Volume')
ELEC_BOBS = ELEC_BOB
SIM_BANK1 = ('Ve Attack', 'Ve Decay', 'Ve Sustain', 'Ve Release', 'S Start', 'S Loop Length', 'S Length', 'S Loop Fade')
SIM_BANK2 = ('Fe Attack', 'Fe Decay', 'Fe Sustain', 'Fe Release', 'Filter Freq', 'Filter Res', 'Filt < Vel', 'Fe < Env')
SIM_BANK3 = ('L Attack', 'L Rate', 'L R < Key', 'L Wave', 'Vol < LFO', 'Filt < LFO', 'Pitch < LFO', 'Pan < LFO')
SIM_BANK4 = ('Pe Attack', 'Pe Decay', 'Pe Sustain', 'Pe Release', 'Glide Time', 'Spread', 'Pan', 'Volume')
SIM_BOB = ('S Start', 'S Loop Length', 'S Length', 'Ve Attack', 'Ve Decay', 'Ve Release', 'Filter Freq', 'Filter Res')
SIM_BANKS = (SIM_BANK1,
 SIM_BANK2,
 SIM_BANK3,
 SIM_BANK4)
SIM_BOBS = SIM_BOB
SIM_BNK_NAMES = ('Amplitude', 'Filter', 'LFO', 'Pitch Modifiers')
SAM_BANK1 = ('Volume', 'Ve Attack', 'Ve Decay', 'Ve Sustain', 'Ve Release', 'Vol < Vel', 'Ve R < Vel', 'Time')
SAM_BANK2 = ('Filter Type', 'Filter Morph', 'Filter Freq', 'Filter Res', 'Filt < Vel', 'Filt < Key', 'Fe < Env', 'Shaper Amt')
SAM_BANK3 = ('Fe Attack', 'Fe Decay', 'Fe Sustain', 'Fe Release', 'Fe End', 'Fe Mode', 'Fe Loop', 'Fe Retrig')
SAM_BANK4 = ('L 1 Wave', 'L 1 Sync', 'L 1 Sync Rate', 'L 1 Rate', 'Vol < LFO', 'Filt < LFO', 'Pan < LFO', 'Pitch < LFO')
SAM_BANK5 = ('L 2 Wave', 'L 2 Sync', 'L 2 Sync Rate', 'L 2 Rate', 'L 2 R < Key', 'L 2 St Mode', 'L 2 Spin', 'L 2 Phase')
SAM_BANK6 = ('L 3 Wave', 'L 3 Sync', 'L 3 Sync Rate', 'L 3 Rate', 'L 3 R < Key', 'L 3 St Mode', 'L 3 Spin', 'L 3 Phase')
SAM_BANK7 = ('O Mode', 'O Volume', 'O Coarse', 'O Fine', 'Oe Attack', 'Oe Decay', 'Oe Sustain', 'Oe Release')
SAM_BANK8 = ('Transpose', 'Spread', 'Pe < Env', 'Pe Attack', 'Pe Peak', 'Pe Decay', 'Pe Sustain', 'Pe Release')
SAM_BOB = ('Ve Attack', 'Ve Decay', 'Ve Release', 'Filter Freq', 'Filter Res', 'Filter Morph', 'O Volume', 'O Coarse')
SAM_BANKS = (SAM_BANK1,
 SAM_BANK2,
 SAM_BANK3,
 SAM_BANK4,
 SAM_BANK5,
 SAM_BANK6,
 SAM_BANK7,
 SAM_BANK8)
SAM_BOBS = SAM_BOB
SAM_BNK_NAMES = ('Volume', 'Filter', 'Filter Envelope', 'LFO 1', 'LFO 2', 'LFO 3', 'Oscillator', 'Pitch')
EXTINST_BOB = ('Input Gain', '', '', '', '', '', '', '')
EXTINST_BOBS = EXTINST_BOB
ARP_BANK1 = ('Style', 'Groove', 'Offset', 'Synced Rate', 'Retrigger Mode', 'Ret. Interval', 'Repeats', 'Gate')
ARP_BANK2 = ('Tranpose Mode', 'Tranpose Key', 'Transp. Steps', 'Transp. Dist.', 'Velocity Decay', 'Velocity Target', 'Velocity On', 'Vel. Retrigger')
ARP_BOB = ('Synced Rate', 'Free Rate', 'Transp. Steps', 'Transp. Dist.', 'Gate', 'Tranpose Key', 'Velocity Decay', 'Velocity Target')
ARP_BANKS = (ARP_BANK1, ARP_BANK2)
ARP_BOBS = ARP_BOB
ARP_BNK_NAMES = ('Style', 'Pitch/Velocity')
CRD_BANK1 = ('Shift1', 'Shift2', 'Shift3', 'Shift4', 'Shift5', 'Shift6', '', '')
CRD_BANK2 = ('Velocity1', 'Velocity2', 'Velocity3', 'Velocity4', 'Velocity5', 'Velocity6', '', '')
CRD_BOB = ('Shift1', 'Shift2', 'Shift3', 'Shift4', 'Shift5', 'Velocity5', 'Shift6', 'Velocity6')
CRD_BANKS = (CRD_BANK1, CRD_BANK2)
CRD_BOBS = CRD_BOB
CRD_BNK_NAMES = ('Shift', 'Shift %')
NTL_BANK1 = ('Trigger Mode', 'Time Length', 'Synced Length', 'Gate', 'Decay Time', 'On/Off-Balance', 'Decay Key Scale', '')
NTL_BANKS = NTL_BANK1
NTL_BOBS = NTL_BANK1
PIT_BANK1 = ('Pitch', 'Range', 'Lowest', '', '', '', '', '')
PIT_BANKS = PIT_BANK1
PIT_BOBS = PIT_BANK1
RND_BANK1 = ('Chance', 'Choices', 'Scale', 'Sign', '', '', '', '')
RND_BANKS = RND_BANK1
RND_BOBS = RND_BANK1
SCL_BANK1 = ('Base', 'Transpose', 'Range', 'Lowest', '', '', '', '')
SCL_BANKS = SCL_BANK1
SCL_BOBS = SCL_BANK1
VEL_BANK1 = ('Drive', 'Compand', 'Random', 'Mode', 'Out Hi', 'Out Low', 'Range', 'Lowest')
VEL_BANKS = VEL_BANK1
VEL_BOBS = VEL_BANK1
AFL_BANK1 = ('Frequency', 'Resonance', 'Env. Attack', 'Env. Release', 'Env. Modulation', 'LFO Amount', 'LFO Frequency', 'LFO Phase')
AFL_BANKS = AFL_BANK1
AFL_BOBS = AFL_BANK1
APN_BANK1 = ('Amount', 'Frequency', 'Phase', 'Shape', 'Waveform', 'Sync Rate', 'Offset', 'Width (Random)')
APN_BANKS = APN_BANK1
APN_BOBS = APN_BANK1
BRP_BANK1 = ('Interval', 'Offset', 'Grid', 'Variation', 'Filter Freq', 'Filter Width', 'Volume', 'Decay')
BRP_BANK2 = ('Chance', 'Gate', 'Pitch', 'Pitch Decay', 'Filter Freq', 'Filter Width', 'Volume', 'Decay')
BRP_BOB = ('Interval', 'Offset', 'Gate', 'Chance', 'Grid', 'Variation', 'Pitch', 'Filter Freq')
BRP_BANKS = (BRP_BANK1, BRP_BANK2)
BRP_BOBS = BRP_BOB
BRP_BNK_NAMES = ('Repeat Rate', 'Gate/Pitch')
CHR_BANK1 = ('Delay 1 Time', 'Delay 2 Time', 'LFO Amount', 'Dry/Wet', 'Delay 1 HiPass', 'Delay 2 Mode', 'LFO Rate', 'Feedback')
CHR_BANKS = CHR_BANK1
CHR_BOBS = CHR_BANK1
CP1_BANK1 = ('Threshold', 'Ratio', 'Attack', 'Release', 'Output Gain', '', '', '')
CP1_BANKS = CP1_BANK1
CP1_BOBS = CP1_BANK1
CP2_BANK1 = ('Threshold', 'Ratio', 'Attack', 'Release', 'Output Gain', 'SideGain', 'Freq', 'PeakOn')
CP2_BANK1_LIVE7 = ('Threshold', 'Ratio', 'Attack', 'Release', 'Ext. In Gain', 'Ext. In Mix', 'EQ Freq', 'Output Gain')
CP2_BANKS = CP2_BANK1_LIVE7
CP2_BOBS = CP2_BANK1_LIVE7
DTB_BANK1 = ('Drive', 'Bias', 'Tone', 'Envelope', 'Attack', 'Release', 'Dry/Wet', 'Output')
DTB_BANKS = DTB_BANK1
DTB_BOBS = DTB_BANK1
EQ8_BOB = ('3 Frequency A', '3 Gain A', '4 Frequency A', '4 Gain A', '5 Frequency A', '5 Gain A', '6 Frequency A', '6 Gain A')
EQ8_BANK1 = ('1 Filter On A', '2 Filter On A', '3 Filter On A', '4 Filter On A', '5 Filter On A', '6 Filter On A', '7 Filter On A', '8 Filter On A')
EQ8_BANK2 = ('1 Frequency A', '2 Frequency A', '3 Frequency A', '4 Frequency A', '5 Frequency A', '6 Frequency A', '7 Frequency A', '8 Frequency A')
EQ8_BANK3 = ('1 Gain A', '2 Gain A', '3 Gain A', '4 Gain A', '5 Gain A', '6 Gain A', '7 Gain A', '8 Gain A')
EQ8_BANK4 = ('1 Resonance A', '2 Resonance A', '3 Resonance A', '4 Resonance A', '5 Resonance A', '6 Resonance A', '7 Resonance A', '8 Resonance A')
EQ8_BANK5 = ('1 Filter Type A', '2 Filter Type A', '3 Filter Type A', '4 Filter Type A', '5 Filter Type A', '6 Filter Type A', '7 Filter Type A', '8 Filter Type A')
EQ8_BANK6 = ('Output Gain', 'Scale', '', '', '', '', '', '')
EQ8_BANK7 = ('1 Gain A', '1 Frequency A', '1 Resonance A', '2 Gain A', '2 Frequency A', '2 Resonance A', '3 Gain A', '3 Frequency A')
EQ8_BANKS = (EQ8_BANK1,
 EQ8_BANK2,
 EQ8_BANK3,
 EQ8_BANK4,
 EQ8_BANK5,
 EQ8_BANK6,
 EQ8_BANK7)
EQ8_BOBS = EQ8_BOB
EQ8_BNK_NAMES = ('Band On/Off', 'Frequency', 'Gain', 'Resonance', 'Filter Type', 'General', 'EQs 1-3')
EQ3_BANK1 = ('GainLo', 'GainMid', 'GainHi', '', 'FreqLo', 'FreqHi', 'Slope', '')
EQ3_BANKS = EQ3_BANK1
EQ3_BOBS = EQ3_BANK1
ERO_BANK1 = ('Frequency', 'Width', 'Amount', 'Mode', '', '', '', '')
ERO_BANKS = ERO_BANK1
ERO_BOBS = ERO_BANK1
FLD_BANK1 = ('1 Filter Freq', '1 Filter Width', '1 Beat Delay', '1 Beat Swing', '1 Feedback', '1 Pan', '1 Volume', 'Dry')
FLD_BANK2 = ('2 Filter Freq', '2 Filter Width', '2 Beat Delay', '2 Beat Swing', '2 Feedback', '2 Pan', '2 Volume', 'Dry')
FLD_BANK3 = ('3 Filter Freq', '3 Filter Width', '3 Beat Delay', '3 Beat Swing', '3 Feedback', '3 Pan', '3 Volume', 'Dry')
FLD_BOB = ('1 Filter Freq', '1 Beat Delay', '1 Feedback', '1 Volume', '3 Filter Freq', '3 Beat Delay', '3 Feedback', '3 Volume')
FLD_BANKS = (FLD_BANK1, FLD_BANK2, FLD_BANK3)
FLD_BOBS = FLD_BOB
FLD_BNK_NAMES = ('Input L Filter', 'Input L+R Filter', 'Input R Filter')
FLG_BANK1 = ('Hi Pass', 'Dry/Wet', 'Delay Time', 'Feedback', 'Env. Modulation', 'Env. Attack', 'Env. Release', '')
FLG_BANK2 = ('LFO Amount', 'Frequency', 'LFO Phase', 'Sync', 'LFO Offset', 'Sync Rate', 'LFO Width (Random)', 'LFO Waveform')
FLG_BOB = ('Hi Pass', 'Delay Time', 'Feedback', 'LFO Amount', 'Frequency', 'Sync Rate', 'Env. Modulation', 'Dry/Wet')
FLG_BANKS = (FLG_BANK1, FLG_BANK2)
FLG_BOBS = FLG_BOB
FLG_BNK_NAMES = ('Frequency Controls', 'LFO / S&H')
GRD_BANK1 = ('Spray', 'Frequency', 'Pitch', 'Random', 'Feedback', 'DryWet', 'Beat Swing', 'Time Delay')
GRD_BANKS = GRD_BANK1
GRD_BOBS = GRD_BANK1
PHS_BANK1 = ('Poles', 'Color', 'Dry/Wet', 'Frequency', 'Env. Modulation', 'Env. Attack', 'Env. Release', 'Feedback')
PHS_BANK2 = ('LFO Amount', 'LFO Frequency', 'LFO Phase', 'LFO Sync', 'LFO Offset', 'LFO Sync Rate', 'LFO Spin', 'LFO Waveform')
PHS_BOB = ('Poles', 'Color', 'Frequency', 'Feedback', 'LFO Amount', 'LFO Frequency', 'Env. Modulation', 'Dry/Wet')
PHS_BANKS = (PHS_BANK1, PHS_BANK2)
PHS_BOBS = PHS_BOB
PHS_BNK_NAMES = ('Frequency Controls', 'LFO / S&H')
RDX_BANK1 = ('Bit Depth', 'Sample Mode', 'Sample Hard', 'Sample Soft', 'Bit On', '', '', '')
RDX_BANKS = RDX_BANK1
RDX_BOBS = RDX_BANK1
EXTEFFECT_BOB = ('Dry/Wet', 'Output Gain', 'Input Gain', '', '', '', '', '')
EXTEFFECT_BOBS = EXTEFFECT_BOB
SAT_BANK1 = ('Drive', 'Base', 'Frequency', 'Width', 'Depth', 'Output', 'Dry/Wet', 'Type')
SAT_BANK2 = ('WS Drive', 'WS Lin', 'WS Curve', 'WS Damp', 'WS Depth', 'WS Period', 'Dry/Wet', '')
SAT_BOB = ('Drive', 'Base', 'Frequency', 'Depth', 'WS Curve', 'WS Depth', 'WS Period', 'WS Damp')
SAT_BANKS = (SAT_BANK1, SAT_BANK2)
SAT_BOBS = SAT_BOB
SAT_BNK_NAMES = ('General Controls', 'Waveshaper Controls')
RSN_BANK1 = ('Frequency', 'Width', 'Global Gain', 'Dry/Wet', 'Decay', 'I Note', 'Color', 'I Gain')
RSN_BANK2 = ('II Gain', 'III Gain', 'IV Gain', 'V Gain', 'II Pitch', 'III Pitch', 'IV Pitch', 'V Pitch')
RSN_BOB = ('Decay', 'I Note', 'II Pitch', 'III Pitch', 'IV Pitch', 'V Pitch', 'Global Gain', 'Dry/Wet')
RSN_BANKS = (RSN_BANK1, RSN_BANK2)
RSN_BOBS = RSN_BOB
RSN_BNK_NAMES = ('General / Mode I', 'Modes II-IV')
SMD_BANK1 = ('L Beat Delay', 'L Beat Swing', 'L Time Delay', 'Dry/Wet', 'R Beat Delay', 'R Beat Swing', 'R Time Delay', 'Feedback')
SMD_BANKS = SMD_BANK1
SMD_BOBS = SMD_BANK1
UTL_BANK1 = ('StereoSeparation', 'Panorama', 'Mute', 'BlockDc', 'Signal Source', 'Gain', 'PhaseInvertL', 'PhaseInvertR')
UTL_BANKS = UTL_BANK1
UTL_BOBS = UTL_BANK1
RVB_BANK1 = ('In Filter Freq', 'In Filter Width', 'PreDelay', 'ER Spin On', 'ER Spin Rate', 'ER Spin Amount', 'ER Shape', 'DecayTime')
RVB_BANK2 = ('HiShelf Freq', 'LowShelf Freq', 'Chorus Rate', 'Density', 'HiShelf Gain', 'LowShelf Gain', 'Chorus Amount', 'Scale')
RVB_BANK3 = ('DecayTime', 'Freeze On', 'Room Size', 'Stereo Image', 'ER Level', 'Diffuse Level', 'Dry/Wet', 'Quality')
RVB_BOB = ('DecayTime', 'Room Size', 'Chorus Amount', 'In Filter Freq', 'HiShelf Freq', 'HiShelf Gain', 'Stereo Image', 'Dry/Wet')
RVB_BANKS = (RVB_BANK1, RVB_BANK2, RVB_BANK3)
RVB_BOBS = RVB_BOB
RVB_BNK_NAMES = ('Reflections', 'Diffusion Network', 'Global')
VDS_BANK1 = ('Tracing Freq.', 'Tracing Width', 'Tracing Drive', 'Crackle Density', 'Pinch Freq.', 'Pinch Width', 'Pinch Drive', 'Crackle Volume')
VDS_BANKS = VDS_BANK1
VDS_BOBS = VDS_BANK1
GTE_BANK1 = ('Threshold', 'Floor', '', '', 'Attack', 'Hold', 'Release', '')
GTE_BANKS = GTE_BANK1
GTE_BOBS = GTE_BANK1
PPG_BANK1 = ('Filter Freq', 'Filter Width', 'Time Delay', 'Beat Delay', 'Beat Swing', 'Delay Mode', 'Feedback', 'Dry/Wet')
PPG_BANKS = PPG_BANK1
PPG_BOBS = PPG_BANK1
DEVICE_DICT = {'AudioEffectGroupDevice': RCK_BANKS,
 'MidiEffectGroupDevice': RCK_BANKS,
 'DrumGroupDevice': RCK_BANKS,
 'InstrumentGroupDevice': RCK_BANKS,
 'InstrumentImpulse': IMP_BANKS,
 'Operator': OPR_BANKS,
 'OriginalSimpler': SIM_BANKS,
 'MultiSampler': SAM_BANKS,
 'MidiArpeggiator': ARP_BANKS,
 'MidiChord': CRD_BANKS,
 'MidiNoteLength': NTL_BANKS,
 'MidiPitcher': PIT_BANKS,
 'MidiRandom': RND_BANKS,
 'MidiScale': SCL_BANKS,
 'MidiVelocity': VEL_BANKS,
 'AutoFilter': AFL_BANKS,
 'AutoPan': APN_BANKS,
 'BeatRepeat': BRP_BANKS,
 'Chorus': CHR_BANKS,
 'Compressor2': CP2_BANKS,
 'Tube': DTB_BANKS,
 'Eq8': EQ8_BANKS,
 'FilterEQ3': EQ3_BANKS,
 'Erosion': ERO_BANKS,
 'FilterDelay': FLD_BANKS,
 'Flanger': FLG_BANKS,
 'GrainDelay': GRD_BANKS,
 'Phaser': PHS_BANKS,
 'Redux': RDX_BANKS,
 'Saturator': SAT_BANKS,
 'Resonator': RSN_BANKS,
 'CrossDelay': SMD_BANKS,
 'StereoGain': UTL_BANKS,
 'Tube': DTB_BANKS,
 'Reverb': RVB_BANKS,
 'Vinyl': VDS_BANKS,
 'Gate': GTE_BANKS,
 'PingPongDelay': PPG_BANKS}
DEVICE_BOB_DICT = {'AudioEffectGroupDevice': RCK_BOBS,
 'MidiEffectGroupDevice': RCK_BOBS,
 'InstrumentGroupDevice': RCK_BOBS,
 'DrumGroupDevice': RCK_BOBS,
 'InstrumentImpulse': IMP_BOBS,
 'Operator': OPR_BOBS,
 'OriginalSimpler': SIM_BOBS,
 'MultiSampler': SAM_BOBS,
 'UltraAnalog': ANA_BOBS,
 'StringStudio': TEN_BOBS,
 'LoungeLizard': ELEC_BOBS,
 'ProxyInstrumentDevice': EXTINST_BOBS,
 'MidiArpeggiator': ARP_BOBS,
 'MidiChord': CRD_BOBS,
 'MidiNoteLength': NTL_BOBS,
 'MidiPitcher': PIT_BOBS,
 'MidiRandom': RND_BOBS,
 'MidiScale': SCL_BOBS,
 'MidiVelocity': VEL_BOBS,
 'AutoFilter': AFL_BOBS,
 'AutoPan': APN_BOBS,
 'BeatRepeat': BRP_BOBS,
 'Chorus': CHR_BOBS,
 'Compressor2': CP2_BOBS,
 'Tube': DTB_BOBS,
 'Eq8': EQ8_BOBS,
 'FilterEQ3': EQ3_BOBS,
 'Erosion': ERO_BOBS,
 'FilterDelay': FLD_BOBS,
 'Flanger': FLG_BOBS,
 'GrainDelay': GRD_BOBS,
 'Phaser': PHS_BOBS,
 'Redux': RDX_BOBS,
 'Saturator': SAT_BOBS,
 'ProxyAudioEffectDevice': EXTEFFECT_BOBS,
 'Resonator': RSN_BOBS,
 'CrossDelay': SMD_BOBS,
 'StereoGain': UTL_BOBS,
 'Tube': DTB_BOBS,
 'Reverb': RVB_BOBS,
 'Vinyl': VDS_BOBS,
 'Gate': GTE_BOBS,
 'PingPongDelay': PPG_BOBS}
BANK_NAME_DICT = {'AudioEffectGroupDevice': RCK_BNK_NAMES,
 'MidiEffectGroupDevice': RCK_BNK_NAMES,
 'InstrumentGroupDevice': RCK_BNK_NAMES,
 'DrumGroupDevice': RCK_BNK_NAMES,
 'InstrumentImpulse': IMP_BNK_NAMES,
 'Operator': OPR_BNK_NAMES,
 'OriginalSimpler': SIM_BNK_NAMES,
 'MultiSampler': SAM_BNK_NAMES,
 'MidiArpeggiator': ARP_BNK_NAMES,
 'MidiChord': CRD_BNK_NAMES,
 'BeatRepeat': BRP_BNK_NAMES,
 'Eq8': EQ8_BNK_NAMES,
 'FilterDelay': FLD_BNK_NAMES,
 'Flanger': FLG_BNK_NAMES,
 'Phaser': PHS_BNK_NAMES,
 'Saturator': SAT_BNK_NAMES,
 'Resonator': RSN_BNK_NAMES,
 'Reverb': RVB_BNK_NAMES}
DEVICE_DICT = {'AudioEffectGroupDevice': RCK_BANKS,
 'MidiEffectGroupDevice': RCK_BANKS,
 'InstrumentGroupDevice': RCK_BANKS,
 'InstrumentImpulse': IMP_BANKS,
 'Operator': OPR_BANKS,
 'OriginalSimpler': SIM_BANKS,
 'MultiSampler': SAM_BANKS,
 'MidiArpeggiator': ARP_BANKS,
 'MidiChord': CRD_BANKS,
 'MidiNoteLength': NTL_BANKS,
 'MidiPitcher': PIT_BANKS,
 'MidiRandom': RND_BANKS,
 'MidiScale': SCL_BANKS,
 'MidiVelocity': VEL_BANKS,
 'AutoFilter': AFL_BANKS,
 'AutoPan': APN_BANKS,
 'BeatRepeat': BRP_BANKS,
 'Chorus': CHR_BANKS,
 'Compressor2': CP2_BANKS,
 'Tube': DTB_BANKS,
 'Eq8': EQ8_BANKS,
 'FilterEQ3': EQ3_BANKS,
 'Erosion': ERO_BANKS,
 'FilterDelay': FLD_BANKS,
 'Flanger': FLG_BANKS,
 'GrainDelay': GRD_BANKS,
 'Phaser': PHS_BANKS,
 'Redux': RDX_BANKS,
 'Saturator': SAT_BANKS,
 'Resonator': RSN_BANKS,
 'CrossDelay': SMD_BANKS,
 'StereoGain': UTL_BANKS,
 'Tube': DTB_BANKS,
 'Reverb': RVB_BANKS,
 'Vinyl': VDS_BANKS,
 'Gate': GTE_BANKS,
 'PingPongDelay': PPG_BANKS}
FIVETOSIX_DICT = {'Auto Filter': 'AutoFilter',
 'Auto Pan': 'AutoPan',
 'Beat Repeat': 'BeatRepeat',
 'Chorus': 'Chorus',
 'Compressor I': 'Compressor',
 'Compressor II': 'Compressor2',
 'EQ Four': 'Eq8',
 'EQ Three': 'FilterEQ3',
 'Erosion': 'Erosion',
 'Filter Delay': 'FilterDelay',
 'Flanger': 'Flanger',
 'Gate': 'Gate',
 'Grain Delay': 'GrainDelay',
 'Phaser': 'Phaser',
 'PingPong': 'PingPongDelay',
 'Ping Pong Delay': 'PingPongDelay',
 'Redux': 'Redux',
 'Resonators': 'Resonator',
 'Reverb': 'Reverb',
 'Saturator': 'Saturator',
 'Simple Delay': 'CrossDelay',
 'Utility': 'StereoGain',
 'Vinyl Distortion': 'Vinyl',
 'Arpeggiator': 'MidiArpeggiator',
 'Chord': 'MidiChord',
 'Pitch': 'MidiPitcher',
 'Random': 'MidiRandom',
 'Scale': 'MidiScale',
 'Velocity': 'MidiVelocity',
 'Simpler': 'OriginalSimpler',
 'Impulse': 'InstrumentImpulse',
 'Operator': 'Operator'}
INVERT_QUANT_PARAM = {'FilterDelay.1 Beat Delay': 1,
 'FilterDelay.2 Beat Delay': 1,
 'FilterDelay.3 Beat Delay': 1,
 'PingPongDelay.Beat Delay': 1,
 'CrossDelay.L Beat Delay': 1,
 'CrossDelay.R Beat Delay': 1}
########NEW FILE########
__FILENAME__ = DevicesXY
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LV2_LX2_LC2_LD2/DevicesXY.py
import Live
XY_DEVICE_DICT = {'AutoFilter': [['Frequency', 'Resonance']],
 'BeatRepeat': [['Filter Freq', 'Filter Width']],
 'Chorus': [['LFO Rate', 'LFO Amount']],
 'Erosion': [['Frequency', 'Width']],
 'FilterDelay': [['2 Filter Freq', '2 Filter Width']],
 'Flanger': [['Delay Time', 'Feedback']],
 'GrainDelay': [['Pitch', 'Frequency']],
 'Phaser': [['Frequency', 'Feedback']],
 'Reverb': [['In Filter Freq', 'In Filter Width'], ['ER Spin Rate', 'ER Spin Amount']],
 'Vinyl': [['Tracing Freq.', 'Tracing Drive'], ['Pinch Freq.', 'Pinch Drive']],
 'PingPongDelay': [['Filter Freq', 'Filter Width']]}
########NEW FILE########
__FILENAME__ = FaderfoxComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LV2_LX2_LC2_LD2/FaderfoxComponent.py
from consts import *

class FaderfoxComponent:
    __module__ = __name__
    __doc__ = 'Baseclass for a subcomponent for Faderfox controllers.'
    __filter_funcs__ = ['update_display', 'log']

    def __init__(self, parent):
        FaderfoxComponent.realinit(self, parent)

    def realinit(self, parent):
        self.parent = parent
        self.helper = parent.helper
        self.param_map = parent.param_map

    def log(self, string):
        self.parent.log(string)

    def logfmt(self, fmt, *args):
        args2 = []
        for i in range(0, len(args)):
            args2 += [args[i].__str__()]

        str = fmt % tuple(args2)
        return self.log(str)

    def application(self):
        return self.parent.application()

    def song(self):
        return self.parent.song()

    def send_midi(self, midi_event_bytes):
        self.parent.send_midi(midi_event_bytes)

    def request_rebuild_midi_map(self):
        self.parent.request_rebuild_midi_map()

    def disconnect(self):
        pass

    def build_midi_map(self, script_handle, midi_map_handle):
        pass

    def receive_midi_cc(channel, cc_no, cc_value):
        pass

    def receive_midi_note(channel, status, note, velocity):
        pass

    def refresh_state(self):
        pass

    def update_display(self):
        pass
########NEW FILE########
__FILENAME__ = FaderfoxDeviceController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LV2_LX2_LC2_LD2/FaderfoxDeviceController.py
import Live
from FaderfoxComponent import FaderfoxComponent
from consts import *
import sys
from Devices import *
from DevicesXY import *
from ParamMap import ParamMap

class FaderfoxDeviceController(FaderfoxComponent):
    __module__ = __name__
    __doc__ = 'Class representing the device controller section of Faderfox controllers'
    __filter_funcs__ = ['update_display', 'log']

    def __init__(self, parent):
        FaderfoxDeviceController.realinit(self, parent)

    def realinit(self, parent):
        FaderfoxComponent.realinit(self, parent)
        self.log('device controller %s' % parent)
        self.device = None
        if hasattr(self.parent.song(), 'appointed_device'):
            self.device = self.parent.song().appointed_device
        self.log('device %s' % self.device)
        self.device_locked = False
        self.bank = 0
        self.show_bank = False
        self.selected_clip = None
        self.on_track_selected_callback = lambda : self.on_track_selected()
        self.parent.song().view.add_selected_track_listener(self.on_track_selected_callback)
        self.parent.song().view.add_detail_clip_listener(self.on_selected_clip)
        self.selected_track = None

    def on_loop_end(self):
        pass

    def on_loop_pass(self):
        pass

    def on_pitch_change(self):
        pass

    def on_selected_clip(self):
        self.selected_clip = self.parent.song().view.detail_clip

    def build_midi_map(self, script_handle, midi_map_handle):

        def forward_note(chan, note):
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, chan, note)

        def forward_cc(chan, cc):
            Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, chan, cc)

        for note in FX3_NOTES:
            forward_note(CHANNEL_SETUP2, note)

        for note in FX4_NOTES:
            forward_note(CHANNEL_SETUP2, note)

        self.log('midi rebuild map')
        tracks = tuple(self.parent.song().tracks) + tuple(self.parent.song().return_tracks)
        for idx in range(0, 16):
            if len(tracks) > idx:
                track = tracks[idx]
                eq = self.helper.track_find_last_eq(track)
                self.log('found eq %s on track %s' % (eq, track))
                if eq:
                    params = self.helper.eq_params(eq)
                    for i in range(0, 4):
                        if params[i] != None:
                            self.log('map %s to %s' % (EQ_CCS[idx][i], params[i]))
                            ParamMap.map_with_feedback(midi_map_handle, AUX_CHANNEL_SETUP2, EQ_CCS[idx][i], params[i], Live.MidiMap.MapMode.absolute)

            master_eq = self.helper.track_find_last_eq(self.parent.song().master_track)
            if master_eq:
                params = self.helper.eq_params(master_eq)
                for i in range(0, 4):
                    if params[i] != None:
                        ParamMap.map_with_feedback(midi_map_handle, AUX_CHANNEL_SETUP2, MASTER_EQ_CCS[i], params[i], Live.MidiMap.MapMode.absolute)

        self.map_device_params(script_handle, midi_map_handle)
        forward_cc(CHANNEL_SETUP2, CLIP_TRANSPOSE_CC)

    def map_device_params(self, script_handle, midi_map_handle):

        def map_params_by_number(device):
            ccs = []
            channel = CHANNEL_SETUP2
            mode = Live.MidiMap.MapMode.relative_two_compliment
            if self.parent.is_lv1:
                ccs = LV1_FX3_CCS + LV1_FX4_CCS
                channel = TRACK_CHANNEL_SETUP2
                mode = Live.MidiMap.MapMode.absolute
            else:
                ccs = FX3_CCS + FX4_CCS
                channel = CHANNEL_SETUP2
            for encoder in range(8):
                if len(device.parameters) >= encoder + 1:
                    ParamMap.map_with_feedback(midi_map_handle, channel, ccs[encoder], device.parameters[encoder + 1], mode)

        def map_params_by_name(device, param_bank):
            ccs = []
            channel = CHANNEL_SETUP2
            mode = Live.MidiMap.MapMode.relative_two_compliment
            if self.parent.is_lv1:
                ccs = LV1_FX3_CCS + LV1_FX4_CCS
                channel = TRACK_CHANNEL_SETUP2
                mode = Live.MidiMap.MapMode.absolute
            else:
                ccs = FX3_CCS + FX4_CCS
                channel = CHANNEL_SETUP2
            for encoder in range(8):
                if len(params) >= encoder:
                    if param_bank[encoder] == '':
                        continue
                    param_name = param_bank[encoder]
                    parameter = None
                    parameter = self.helper.get_parameter_by_name(self.device, param_bank[encoder])
                    if parameter:
                        mode2 = mode
                        fullname = self.helper.device_name(device) + '.' + parameter.name
                        if parameter.is_quantized and not self.parent.is_lv1 and not INVERT_QUANT_PARAM.has_key(fullname):
                            mode2 = Live.MidiMap.MapMode.relative_binary_offset
                        self.logfmt('parameter %s %s to %s (quant %s)', parameter, parameter.name, ccs[encoder], parameter.is_quantized)
                        ParamMap.map_with_feedback(midi_map_handle, channel, ccs[encoder], parameter, mode2)
                    else:
                        self.log('Could not find parameter %s' % param_bank[encoder])

        self.log('map device params %s' % self.device)
        if self.device:
            params = self.device.parameters
            device_bank = 0
            param_bank = 0
            device_name = self.helper.device_name(self.device)
            self.log("device name '%s'" % device_name)
            if device_name in XY_DEVICE_DICT.keys():
                xys = XY_DEVICE_DICT[device_name]
                if len(xys) > 0:
                    param1 = self.helper.get_parameter_by_name(self.device, xys[0][0])
                    param2 = self.helper.get_parameter_by_name(self.device, xys[0][1])
                    ccx = FX1_JOY_X_CC
                    ccy = FX1_JOY_Y_CC
                    channel = CHANNEL_SETUP2
                    if self.parent.is_lv1:
                        ccx = LV1_FX1_JOY_X_CC
                        ccy = LV1_FX1_JOY_Y_CC
                        channel = TRACK_CHANNEL_SETUP2
                    if param1:
                        ParamMap.map_with_feedback(midi_map_handle, channel, ccx, param1, Live.MidiMap.MapMode.absolute)
                    if param2:
                        ParamMap.map_with_feedback(midi_map_handle, channel, ccy, param2, Live.MidiMap.MapMode.absolute)
                if len(xys) > 1:
                    param1 = self.helper.get_parameter_by_name(self.device, xys[1][0])
                    param2 = self.helper.get_parameter_by_name(self.device, xys[1][1])
                    ccx = FX2_JOY_X_CC
                    ccy = FX2_JOY_Y_CC
                    channel = CHANNEL_SETUP2
                    if self.parent.is_lv1:
                        ccx = LV1_FX2_JOY_X_CC
                        ccy = LV1_FX2_JOY_Y_CC
                        channel = TRACK_CHANNEL_SETUP2
                    ParamMap.map_with_feedback(midi_map_handle, channel, ccx, param1, Live.MidiMap.MapMode.absolute)
                    ParamMap.map_with_feedback(midi_map_handle, channel, ccy, param2, Live.MidiMap.MapMode.absolute)
            if device_name in DEVICE_BOB_DICT.keys():
                param_bank = DEVICE_BOB_DICT[device_name]
                if device_name == 'Compressor2' and self.helper.get_parameter_by_name(self.device, 'Ext. In Gain'):
                    param_bank = CP2_BANK1_LIVE7
                self.log('class %s bank: %s' % (device_name, param_bank))
                self.show_bank_select('Best of parameters')
                map_params_by_name(self.device, param_bank)
            elif self.helper.device_is_plugin(self.device):
                self.show_bank_select('First eight parameters')
                map_params_by_number(self.device)
            else:
                self.log('Could not find %s in %s' % (device_name, DEVICE_BOB_DICT.keys()))
                return

    def show_bank_select(self, bank_name):
        if self.show_bank:
            self.show_bank = False
            if self.device:
                self.parent.show_message(str(self.device.name + ' Bank: ' + bank_name))

    def receive_midi_note(self, channel, status, note_no, note_vel):

        def index_of(list, elt):
            for i in range(0, len(list)):
                if list[i] == elt:
                    return i

        if not self.device:
            return
        device_name = self.helper.device_name(self.device)
        if channel == CHANNEL_SETUP2 and status == NOTEON_STATUS:
            notes = FX3_NOTES + FX4_NOTES
            if note_no not in notes:
                return
            idx = index_of(notes, note_no)
            parameter = None
            if device_name in DEVICE_BOB_DICT.keys():
                param_bank = DEVICE_BOB_DICT[device_name]
                parameter = self.helper.get_parameter_by_name(self.device, param_bank[idx])
            elif self.helper.device_is_plugin(self.device):
                if len(self.device.parameters) >= idx + 1:
                    parameter = self.device.parameters[idx + 1]
            else:
                return
            if parameter:
                if parameter.is_quantized:
                    if parameter.value + 1 > parameter.max:
                        parameter.value = parameter.min
                    else:
                        parameter.value += 1
                else:
                    parameter.value = parameter.default_value
            self.log('device %s, index %s, parameter %s' % (self.device, idx, parameter.name))

    def receive_midi_cc(self, chan, cc_no, cc_value):

        def rel_to_offs(cc_value):
            if cc_value >= 64:
                return cc_value - 128
            else:
                return cc_value

        def round_to(x, step):
            return step * round(x / step)

        if chan == CHANNEL_SETUP2 and self.selected_clip:
            if cc_no == CLIP_TRANSPOSE_CC and self.selected_clip.is_audio_clip:
                self.selected_clip.pitch_coarse = max(-48, min(self.selected_clip.pitch_coarse + rel_to_offs(cc_value), 48))
            elif cc_no == CLIP_LOOP_START_CC:
                new_start = self.selected_clip.loop_start + rel_to_offs(cc_value) * self.helper.current_q_step()
                new_start = round_to(new_start, self.helper.current_q_step())
                if new_start >= self.selected_clip.length or new_start >= self.selected_clip.loop_end:
                    new_start = self.selected_clip.loop_start
                if new_start < 0.0:
                    new_start = 0.0
                self.selected_clip.loop_start = new_start
            elif cc_no == CLIP_LOOP_END_CC:
                new_end = self.selected_clip.loop_end + rel_to_offs(cc_value) * self.helper.current_q_step()
                new_end = round_to(new_end, self.helper.current_q_step())
                if new_end >= self.selected_clip.length:
                    new_end = self.selected_clip.length
                if new_end <= 0.0 or new_end <= self.selected_clip.loop_start:
                    new_end = self.selected_clip.loop_end
                self.selected_clip.loop_end = new_end

    def lock_to_device(self, device):
        if device:
            self.device_locked = True
            if not device == self.device:
                self.bank = 0
                self.show_bank = True
            self.device = device
            self.parent.request_rebuild_midi_map()

    def unlock_from_device(self, device):
        if device and device == self.device:
            self.device_locked = False
        if hasattr(self.parent.song(), 'appointed_device'):
            if not self.parent.song().appointed_device == self_device:
                self.parent.request_rebuild_midi_map()

    def set_appointed_device(self, device):
        if self.device_locked:
            self.device_locked = False
        if not device == self.device:
            self.bank = 0
            self.show_bank = True
        self.device = device
        self.parent.request_rebuild_midi_map()

    def refresh_state(self):
        pass

    def update_display(self):
        pass

    def disconnect(self):
        self.parent.song().view.remove_selected_track_listener(self.on_track_selected_callback)
        self.parent.song().view.remove_detail_clip_listener(self.on_selected_clip)

    def on_device_selected(self):
        self.log('selected device %s' % self.selected_track.view.selected_device)
        self.set_appointed_device(self.selected_track.view.selected_device)

    def on_track_selected(self):
        if self.parent.is_live_5():
            self.log('add a listener to selected device on track %s' % self.parent.song().view.selected_track)
            self.selected_track = self.parent.song().view.selected_track
        self.parent.request_rebuild_midi_map()
########NEW FILE########
__FILENAME__ = FaderfoxHelper
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LV2_LX2_LC2_LD2/FaderfoxHelper.py
import Live
from ParamMap import Callable
from Devices import *
from Params import *

class FaderfoxHelper:
    __module__ = __name__
    __doc__ = 'General Live helper'

    def __init__(self, parent):
        self.parent = parent

    def song(self):
        return self.parent.song()

    def selected_scene_idx(self):

        def tuple_idx(tuple, obj):
            for i in xrange(0, len(tuple)):
                if tuple[i] == obj:
                    return i

        return tuple_idx(self.song().scenes, self.song().view.selected_scene)

    def toggle_clip_playing(self, track_idx):
        scene = self.song().view.selected_scene
        max_track_idx = len(scene.clip_slots)
        if max_track_idx > track_idx and scene.clip_slots[track_idx].has_clip:
            clip = scene.clip_slots[track_idx].clip
            if clip.is_playing:
                clip.stop()
            else:
                clip.fire()

    def trigger_track_clip(self, track_idx, clip_idx):
        if track_idx < len(self.song().tracks):
            track = self.song().tracks[track_idx]
            if clip_idx < len(track.clip_slots):
                slot = track.clip_slots[clip_idx]
                if slot.has_clip:
                    clip = slot.clip
                    if not clip.is_playing:
                        clip.is_triggered or clip.fire()
                        return 1
                    else:
                        clip.stop()
                        return 0
                    self.song().view.selected_scene = self.song().scenes[clip_idx]
                else:
                    self.stop_track(track_idx)
                    return 0

    def stop_track(self, track_idx):
        if track_idx < len(self.song().tracks):
            track = self.song().tracks[track_idx]
            clip_idx = self.track_playing_slot_idx(track)
            if clip_idx >= 0:
                track.clip_slots[clip_idx].clip.stop()
                return (track_idx, clip_idx)
            else:
                return (None, None)
        return (None, None)

    def is_track_playing(self, track):
        for slot in track.clip_slots:
            if slot.has_clip and slot.clip.is_playing:
                return 1

        return 0

    def track_playing_slot_idx(self, track):
        idx = 0
        for slot in track.clip_slots:
            if slot.has_clip and slot.clip.is_playing:
                return idx
            idx += 1

        return -1

    def switch_monitor_track(self, track):
        if hasattr(track, 'current_monitoring_state'):
            track.current_monitoring_state = (track.current_monitoring_state + 1) % len(track.monitoring_states.values)

    def switch_crossfader_ab(self, track):
        if hasattr(track.mixer_device, 'crossfade_assign'):
            track.mixer_device.crossfade_assign = (track.mixer_device.crossfade_assign - 1) % len(track.mixer_device.crossfade_assignments.values)

    def toggle_track_attribute(self, track, attr):
        track.__setattr__(attr, not track.__getattribute__(attr))

    def solo_track(self, track):
        tracks = tuple(self.song().tracks) + tuple(self.song().return_tracks)
        if track.solo:
            for track2 in tracks:
                track2.solo = 0

        else:
            for track2 in tracks:
                if track2 != track:
                    track2.solo = 0

            track.solo = 1

    def arm_track(self, track):
        tracks = tuple(self.song().tracks) + tuple(self.song().return_tracks)
        if track.arm or not track.can_be_armed:
            for track2 in tracks:
                if track2.can_be_armed:
                    track2.arm = 0

        else:
            for track2 in tracks:
                if track2 != track and track2.can_be_armed:
                    track2.arm = 0

            track.arm = 1

    def is_master_track_selected(self):
        return not cmp(self.song().view.selected_track, self.song().master_track)

    def get_track(self, idx):
        real_idx = idx
        tracks = tuple(self.song().tracks) + tuple(self.song().return_tracks)
        if idx < len(tracks):
            return tracks[idx]
        elif self.is_master_track_selected():
            new_idx = min(15, len(tracks) - 1)
            return self.get_track(new_idx)
        else:
            return self.song().master_track

    def selected_track_idx(self):

        def tuple_idx(tuple, obj):
            for i in xrange(0, len(tuple)):
                if not cmp(tuple[i], obj):
                    return i

        return tuple_idx(tuple(self.song().tracks) + tuple(self.song().return_tracks), self.song().view.selected_track)

    def device_name(self, device):
        if hasattr(device, 'class_name'):
            return device.class_name
        elif FIVETOSIX_DICT.has_key(device.name):
            return FIVETOSIX_DICT[device.name]
        else:
            return device.name

    def track_find_last_eq(self, track):

        def is_eq(device):
            return self.device_name(device) == 'Eq8' or self.device_name(device) == 'FilterEQ3'

        result = None
        for device in track.devices:
            if is_eq(device):
                result = device

        return result

    def eq_params(self, eq):
        if self.device_name(eq) == 'Eq8':
            return [ self.get_parameter_by_name(eq, name) for name in ['3 Gain A',
             '4 Gain A',
             '5 Gain A',
             '6 Gain A'] ]
        elif self.device_name(eq) == 'FilterEQ3':
            return [ self.get_parameter_by_name(eq, name) for name in ['GainLo',
             'GainMid',
             'GainHi',
             ''] ]
        else:
            return [None,
             None,
             None,
             None]

    def device_is_plugin(self, device):
        return self.device_name(device) in ('AuPluginDevice', 'PluginDevice')

    def current_q_step(self):
        q_map = {Live.Song.Quantization.q_no_q: 0.03125,
         Live.Song.Quantization.q_8_bars: 32.0,
         Live.Song.Quantization.q_4_bars: 16.0,
         Live.Song.Quantization.q_2_bars: 8.0,
         Live.Song.Quantization.q_bar: 4.0,
         Live.Song.Quantization.q_half: 2.0,
         Live.Song.Quantization.q_half_triplet: 1.0 + 1.0 / 3,
         Live.Song.Quantization.q_quarter: 1.0,
         Live.Song.Quantization.q_quarter_triplet: 2 * (1.0 / 3),
         Live.Song.Quantization.q_eight: 0.5,
         Live.Song.Quantization.q_eight_triplet: 1.0 / 3,
         Live.Song.Quantization.q_sixtenth: 0.25,
         Live.Song.Quantization.q_sixtenth_triplet: 1.0 / 6,
         Live.Song.Quantization.q_thirtytwoth: 0.125}
        return q_map[self.song().clip_trigger_quantization]

    def number_of_parameter_banks(self, device):
        result = 0
        if self.device_name(device) in DEVICE_DICT.keys():
            device_bank = DEVICE_DICT[self.device_name(device)]
            result = len(device_bank)
        else:
            param_count = len(list(device.parameters))
            result = param_count / 8
            if not param_count % 8 == 0:
                result += 1
        return result

    def get_parameter_by_name(self, device, name):
        for i in device.parameters:
            if hasattr(i, 'original_name'):
                if i.original_name == name:
                    return i
            else:
                device_name = self.device_name(device)
                if FIVETOSIX_PARAMS_DICT.has_key(device_name) and FIVETOSIX_PARAMS_DICT[device_name].has_key(name):
                    name = FIVETOSIX_PARAMS_DICT[device_name][name]
                if i.name == name:
                    return i
########NEW FILE########
__FILENAME__ = FaderfoxMixerController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LV2_LX2_LC2_LD2/FaderfoxMixerController.py
import Live
from ParamMap import ParamMap
from FaderfoxComponent import FaderfoxComponent
from consts import *

class FaderfoxMixerController(FaderfoxComponent):
    __module__ = __name__
    __doc__ = 'Mixer parameters of LX2'
    __filter_funcs__ = ['update_display', 'log']

    def __init__(self, parent):
        FaderfoxMixerController.realinit(self, parent)

    def realinit(self, parent):
        FaderfoxComponent.realinit(self, parent)
        self.on_track_selected_callback = lambda : self.on_track_selected()
        self.parent.song().view.add_selected_track_listener(self.on_track_selected_callback)
        self.track_selected = 0
        self.lv1_track_idx = -1

    def disconnect(self):
        self.parent.song().view.remove_selected_track_listener(self.on_track_selected_callback)

    def receive_midi_cc(self, channel, cc_no, cc_value):
        pass

    def handle_status_note(self, note_no, arr, attr):

        def index_of(list, elt):
            for i in range(0, len(list)):
                if list[i] == elt:
                    return i

        if note_no in arr:
            idx = index_of(arr, note_no)
            tracks = tuple(self.parent.song().tracks) + tuple(self.parent.song().return_tracks)
            if len(tracks) > idx:
                track = tracks[idx]
                if attr == 'solo':
                    self.helper.solo_track(track)
                elif attr == 'arm':
                    self.helper.arm_track(track)
                elif attr == 'monitor':
                    self.helper.switch_monitor_track(track)
                elif attr == 'cross_ab':
                    self.helper.switch_crossfader_ab(track)
                else:
                    self.helper.toggle_track_attribute(track, attr)

    def receive_midi_note(self, channel, status, note_no, note_vel):
        if status == NOTEOFF_STATUS:
            return
        if channel == CHANNEL_SETUP2:
            self.log('received note %s' % note_no)
        if channel == CHANNEL_SETUP2 and note_no in TRACK_SELECT_NOTES:
            idx = note_no - TRACK_SELECT_NOTES[0]
            self.lv1_track_idx = note_no
            tracks = tuple(self.parent.song().tracks) + tuple(self.parent.song().return_tracks)
            if idx < len(tracks):
                track = tracks[idx]
            elif self.helper.is_master_track_selected():
                track = tracks[-1]
            else:
                track = self.parent.song().master_track
            self.set_selected_track(track)
        if channel == CHANNEL_SETUP2 and note_no == MASTER_TRACK_SELECT_NOTE:
            self.lv1_track_idx = note_no
            self.log('select master track')
            self.set_selected_track(self.parent.song().master_track)
        if channel == TRACK_CHANNEL_SETUP2 and status == NOTEON_STATUS:
            self.handle_status_note(note_no, MUTE_NOTES, 'mute')
            self.handle_status_note(note_no, ARM_NOTES, 'arm')
            self.handle_status_note(note_no, SOLO_NOTES, 'solo')
            self.handle_status_note(note_no, MONITOR_NOTES, 'monitor')
            self.handle_status_note(note_no, CROSS_AB_NOTES, 'cross_ab')

    def set_selected_track(self, track):
        if track and self.track_selected and not self.parent.song().view.selected_track == track:
            self.track_selected = 0
            self.parent.song().view.selected_track = track

    def build_midi_map(self, script_handle, midi_map_handle):

        def forward_note(chan, note):
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, chan, note)

        def forward_cc(chan, cc):
            Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, chan, cc)

        idx = 0
        self.map_track_params(script_handle, midi_map_handle)
        for note in TRACK_SELECT_NOTES:
            forward_note(CHANNEL_SETUP2, note)

        forward_note(CHANNEL_SETUP2, MASTER_TRACK_SELECT_NOTE)
        for note in MUTE_NOTES:
            forward_note(TRACK_CHANNEL_SETUP2, note)

        for note in SOLO_NOTES:
            forward_note(TRACK_CHANNEL_SETUP2, note)

        for note in ARM_NOTES:
            forward_note(TRACK_CHANNEL_SETUP2, note)

        for note in MONITOR_NOTES:
            forward_note(TRACK_CHANNEL_SETUP2, note)

        for note in CROSS_AB_NOTES:
            forward_note(TRACK_CHANNEL_SETUP2, note)

        self.on_track_selected()

    def refresh_state(self):
        pass

    def update_display(self):
        pass

    def on_track_selected(self):
        self.track_selected = 1
        if self.helper.is_master_track_selected():
            if self.lv1_track_idx == MASTER_TRACK_SELECT_NOTE:
                return
            self.lv1_track_idx = MASTER_TRACK_SELECT_NOTE
            self.parent.send_midi((175, 16, 16))
            if self.parent.is_live_5():
                self.parent.send_midi((NOTEON_STATUS + CHANNEL_SETUP2, MASTER_TRACK_SELECT_NOTE, 64))
        else:
            idx = self.helper.selected_track_idx()
            if idx < 16:
                note_no = TRACK_SELECT_NOTES[0] + idx
                if self.lv1_track_idx == note_no:
                    return
                self.lv1_track_idx = note_no
                self.parent.send_midi((175, 16, self.helper.selected_track_idx()))
                if self.parent.is_live_5():
                    self.log('send track note %s' % TRACK_SELECT_NOTES[self.helper.selected_track_idx()])
                    self.parent.send_midi((NOTEON_STATUS + CHANNEL_SETUP2, TRACK_SELECT_NOTES[self.helper.selected_track_idx()], 64))

    def map_track_params(self, script_handle, midi_map_handle):
        for idx in range(0, 16):
            tracks = tuple(self.parent.song().tracks) + tuple(self.parent.song().return_tracks)
            if len(tracks) > idx:
                track = tracks[idx]
                mixer_device = track.mixer_device
                parameter = mixer_device.volume
                ParamMap.map_with_feedback(midi_map_handle, CHANNEL_SETUP2, VOLUME_CCS[idx], parameter, Live.MidiMap.MapMode.absolute)
                sends = mixer_device.sends
                for send_idx in range(0, 4):
                    if len(sends) > send_idx:
                        parameter = sends[send_idx]
                        ParamMap.map_with_feedback(midi_map_handle, TRACK_CHANNEL_SETUP2, SEND_CCS[idx][send_idx], parameter, Live.MidiMap.MapMode.absolute)

                parameter = mixer_device.panning
                ParamMap.map_with_feedback(midi_map_handle, TRACK_CHANNEL_SETUP2, PAN_X_CC[idx], parameter, Live.MidiMap.MapMode.absolute)

        track = self.parent.song().master_track
        parameter = track.mixer_device.panning
        ParamMap.map_with_feedback(midi_map_handle, TRACK_CHANNEL_SETUP2, PAN_X_MASTER_CC, parameter, Live.MidiMap.MapMode.absolute)
        parameter = track.mixer_device.volume
        cc = MAIN_VOLUME_CC
        if self.parent.is_lv1:
            cc = LV1_MAIN_VOLUME_CC
        ParamMap.map_with_feedback(midi_map_handle, CHANNEL_SETUP2, cc, parameter, Live.MidiMap.MapMode.absolute)
        if hasattr(track.mixer_device, 'cue_volume'):
            parameter = track.mixer_device.cue_volume
            cc = CUE_VOLUME_CC
            if self.parent.is_lv1:
                cc = LV1_CUE_VOLUME_CC
            ParamMap.map_with_feedback(midi_map_handle, CHANNEL_SETUP2, cc, parameter, Live.MidiMap.MapMode.absolute)
        if hasattr(track.mixer_device, 'crossfader'):
            parameter = track.mixer_device.crossfader
            cc = CROSSFADER_CC
            ParamMap.map_with_feedback(midi_map_handle, CHANNEL_SETUP2, cc, parameter, Live.MidiMap.MapMode.absolute)
            if self.parent.is_lv1:
                cc = LV1_CROSSFADER_CC
                ParamMap.map_with_feedback(midi_map_handle, CHANNEL_SETUP2, cc, parameter, Live.MidiMap.MapMode.absolute)
########NEW FILE########
__FILENAME__ = FaderfoxScript
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LV2_LX2_LC2_LD2/FaderfoxScript.py
import Live
from consts import *
import sys
from FaderfoxHelper import FaderfoxHelper
from ParamMap import ParamMap
from Devices import *

class FaderfoxScript:
    __filter_funcs__ = ['update_display', 'log', 'song']
    __module__ = __name__
    __doc__ = 'Automap script for Faderfox controllers'
    __version__ = 'V1.1'
    __name__ = 'Generic Faderfox Script'

    def __init__(self, c_instance):
        self.suffix = ''
        self.is_lv1 = False
        FaderfoxScript.realinit(self, c_instance)

    def realinit(self, c_instance):
        self.c_instance = c_instance
        self.helper = FaderfoxHelper(self)
        self.param_map = ParamMap(self)
        self.mixer_controller = None
        self.device_controller = None
        self.transport_controller = None
        self.components = []
        live = 'Live 6 & 7'
        if self.is_live_5():
            live = 'Live 5'
        self.show_message(self.__name__ + ' ' + self.__version__ + ' for ' + live)
        self.is_lv1 = False

    def is_live_5(self):
        return hasattr(Live, 'is_live_5')

    def log(self, string):
        pass

    def logfmt(self, fmt, *args):
        pass

    def disconnect(self):
        for c in self.components:
            c.disconnect()

    def application(self):
        return Live.Application.get_application()

    def song(self):
        return self.c_instance.song()

    def suggest_input_port(self):
        return str('')

    def suggest_output_port(self):
        return str('')

    def can_lock_to_devices(self):
        return True

    def lock_to_device(self, device):
        if self.device_controller:
            self.device_controller.lock_to_device(device)

    def unlock_to_device(self, device):
        if self.device_controller:
            self.device_controller.unlock_from_device(device)

    def set_appointed_device(self, device):
        if self.device_controller:
            self.device_controller.set_appointed_device(device)

    def toggle_lock(self):
        self.c_instance.toggle_lock()

    def suggest_map_mode(self, cc_no, channel):
        return Live.MidiMap.MapMode.absolute

    def restore_bank(self, bank):
        pass

    def show_message(self, message):
        if hasattr(self.c_instance, 'show_message'):
            self.c_instance.show_message(message)

    def instance_identifier(self):
        return self.c_instance.instance_identifier()

    def connect_script_instances(self, instanciated_scripts):
        pass

    def request_rebuild_midi_map(self):
        self.c_instance.request_rebuild_midi_map()

    def send_midi(self, midi_event_bytes):
        self.c_instance.send_midi(midi_event_bytes)

    def refresh_state(self):
        for c in self.components:
            c.refresh_state()

    def build_midi_map(self, midi_map_handle):
        self.log('script build midi map')
        script_handle = self.c_instance.handle()
        self.param_map.remove_mappings()
        for c in self.components:
            self.log('build midi map on %s' % c)
            c.build_midi_map(script_handle, midi_map_handle)

    def update_display(self):
        for c in self.components:
            c.update_display()

    def receive_midi(self, midi_bytes):
        channel = midi_bytes[0] & CHAN_MASK
        status = midi_bytes[0] & STATUS_MASK
        if status == CC_STATUS:
            cc_no = midi_bytes[1]
            cc_value = midi_bytes[2]
            for c in self.components:
                c.receive_midi_cc(channel, cc_no, cc_value)

            self.param_map.receive_midi_cc(channel, cc_no, cc_value)
        elif status == NOTEON_STATUS or status == NOTEOFF_STATUS:
            note_no = midi_bytes[1]
            note_vel = midi_bytes[2]
            for c in self.components:
                c.receive_midi_note(channel, status, note_no, note_vel)

            self.param_map.receive_midi_note(channel, status, note_no, note_vel)
        else:
            raise False or AssertionError, 'Unknown MIDI message %s' % str(midi_bytes)
########NEW FILE########
__FILENAME__ = FaderfoxTransportController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LV2_LX2_LC2_LD2/FaderfoxTransportController.py
import Live
from FaderfoxComponent import FaderfoxComponent
from FaderfoxHelper import FaderfoxHelper
from consts import *

class FaderfoxTransportController(FaderfoxComponent):
    __module__ = __name__
    __doc__ = 'Class representing the transport section of faderfox controllers'
    __filter_funcs__ = ['update_display', 'log']

    def __init__(self, parent):
        FaderfoxTransportController.realinit(self, parent)

    def realinit(self, parent):
        FaderfoxComponent.realinit(self, parent)

    def receive_midi_cc(self, channel, cc_no, cc_value):
        if channel == CHANNEL_SETUP2 and cc_no == SCENE_SCROLL_CC:
            val = 0
            if cc_value >= 64:
                val = cc_value - 128
            else:
                val = cc_value
            idx = self.helper.selected_scene_idx() - val
            new_scene_idx = min(len(self.parent.song().scenes) - 1, max(0, idx))
            self.parent.song().view.selected_scene = self.parent.song().scenes[new_scene_idx]

    def receive_midi_note(self, channel, status, note_no, note_vel):

        def index_of(list, elt):
            for i in range(0, len(list)):
                if list[i] == elt:
                    return i

        if status == NOTEON_STATUS:
            if channel == CHANNEL_SETUP2:
                if note_no == SCENE_LAUNCH_NOTE:
                    self.parent.song().view.selected_scene.fire_as_selected()
                elif note_no == SCENE_STOP_NOTE:
                    self.parent.song().stop_all_clips()
                elif note_no == SCENE_UP_NOTE:
                    idx = self.helper.selected_scene_idx() - 1
                    new_scene_idx = min(len(self.parent.song().scenes) - 1, max(0, idx))
                    self.parent.song().view.selected_scene = self.parent.song().scenes[new_scene_idx]
                elif note_no == SCENE_DOWN_NOTE:
                    idx = self.helper.selected_scene_idx() + 1
                    new_scene_idx = min(len(self.parent.song().scenes) - 1, max(0, idx))
                    self.parent.song().view.selected_scene = self.parent.song().scenes[new_scene_idx]
                elif note_no == GLOBAL_PLAY_NOTE:
                    self.parent.song().start_playing()
                elif note_no == GLOBAL_STOP_NOTE:
                    self.parent.song().stop_playing()
                elif note_no == SESSION_ARRANGE_SWITCH_NOTE:
                    view = self.parent.application().view
                    if view.is_view_visible('Session'):
                        view.show_view('Arranger')
                    else:
                        view.show_view('Session')
                elif note_no == CLIP_TRACK_SWITCH_NOTE:
                    view = self.parent.application().view
                    if view.is_view_visible('Detail/Clip'):
                        view.show_view('Detail/DeviceChain')
                    else:
                        view.show_view('Detail/Clip')
                elif note_no == CLIP_SELECT_NOTE:
                    view = self.parent.application().view
                    if view.is_view_visible('Detail'):
                        view.hide_view('Detail')
                    else:
                        view.show_view('Detail')
                elif note_no in SCENE_LAUNCH_NOTES:
                    scene_idx = index_of(SCENE_LAUNCH_NOTES, note_no)
                    if scene_idx < len(self.parent.song().scenes):
                        self.parent.song().scenes[scene_idx].fire()
                else:
                    track_idx = 0
                    for notes in SLOT_LAUNCH_NOTES2:
                        if note_no in notes[2:]:
                            clip_idx = index_of(notes, note_no) + 6
                            self.trigger_track_clip(track_idx, clip_idx)
                        track_idx += 1

            elif channel == TRACK_CHANNEL_SETUP2:
                if note_no in LAUNCH_NOTES:
                    idx = index_of(LAUNCH_NOTES, note_no)
                    scene = self.parent.song().view.selected_scene
                    max_track_idx = len(scene.clip_slots)
                    if max_track_idx > idx:
                        scene.clip_slots[idx].fire()
                if note_no in STOP_NOTES:
                    idx = index_of(STOP_NOTES, note_no)
                    if len(self.parent.song().tracks) > idx:
                        self.stop_track(idx)
            elif channel == AUX_CHANNEL_SETUP2:
                track_idx = 0
                for notes in SLOT_LAUNCH_NOTES1:
                    if note_no in notes:
                        self.trigger_track_clip(track_idx, index_of(notes, note_no))
                    track_idx += 1

                track_idx = 0
                for notes in SLOT_LAUNCH_NOTES2:
                    if note_no in notes[0:2]:
                        self.trigger_track_clip(track_idx, index_of(notes, note_no) + 6)
                    track_idx += 1

    def trigger_track_clip(self, track_idx, clip_idx):
        self.helper.trigger_track_clip(track_idx, clip_idx)

    def stop_track(self, track_idx):
        self.helper.stop_track(track_idx)

    def build_midi_map(self, script_handle, midi_map_handle):

        def forward_note(chan, note):
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, chan, note)

        def forward_cc(chan, cc):
            Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, chan, cc)

        forward_cc(CHANNEL_SETUP2, SCENE_SCROLL_CC)
        forward_note(CHANNEL_SETUP2, SCENE_UP_NOTE)
        forward_note(CHANNEL_SETUP2, SCENE_DOWN_NOTE)
        for note in LAUNCH_NOTES:
            forward_note(TRACK_CHANNEL_SETUP2, note)

        for note in STOP_NOTES:
            forward_note(TRACK_CHANNEL_SETUP2, note)

        forward_note(CHANNEL_SETUP2, SCENE_LAUNCH_NOTE)
        forward_note(CHANNEL_SETUP2, SCENE_STOP_NOTE)
        for note in [CLIP_SELECT_NOTE,
         GLOBAL_STOP_NOTE,
         GLOBAL_PLAY_NOTE,
         SESSION_ARRANGE_SWITCH_NOTE,
         CLIP_TRACK_SWITCH_NOTE]:
            forward_note(CHANNEL_SETUP2, note)

        for note in SCENE_LAUNCH_NOTES:
            forward_note(CHANNEL_SETUP2, note)

        for notes in SLOT_LAUNCH_NOTES1:
            for note in notes:
                forward_note(AUX_CHANNEL_SETUP2, note)

        for notes in SLOT_LAUNCH_NOTES2:
            for note in notes[0:2]:
                forward_note(AUX_CHANNEL_SETUP2, note)

            for note in notes[2:]:
                forward_note(CHANNEL_SETUP2, note)

    def disconnect(self):
        pass
########NEW FILE########
__FILENAME__ = LV2DeviceController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LV2_LX2_LC2_LD2/LV2DeviceController.py
import Live
from FaderfoxDeviceController import FaderfoxDeviceController

class LV2DeviceController(FaderfoxDeviceController):
    __module__ = __name__

    def __init__(self, parent):
        LV2DeviceController.realinit(self, parent)

    def realinit(self, parent):
        FaderfoxDeviceController.realinit(self, parent)
########NEW FILE########
__FILENAME__ = LV2MixerController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LV2_LX2_LC2_LD2/LV2MixerController.py
import Live
from ParamMap import ParamMap
from FaderfoxMixerController import FaderfoxMixerController
from consts import *

class LV2MixerController(FaderfoxMixerController):
    __module__ = __name__
    __doc__ = 'Mixer parameters of LX2'
    __filter_funcs__ = ['update_display', 'log']

    def __init__(self, parent):
        LV2MixerController.realinit(self, parent)

    def realinit(self, parent):
        FaderfoxMixerController.realinit(self, parent)
        self.reset_status_cache()
        self.parent.song().add_tracks_listener(self.on_tracks_added_or_deleted)
        self.tracks_with_listener = []

    def reset_status_cache(self):
        self.status_cache = {'mute': [ -1 for i in range(0, 12) ],
         'solo': [ -1 for i in range(0, 12) ],
         'arm': [ -1 for i in range(0, 12) ],
         'current_monitoring_state': [ -1 for i in range(0, 12) ],
         'master': {'solo': -1,
                    'mute': -1,
                    'arm': -1},
         'master_note': {'solo': MASTER_SOLO_NOTE,
                         'mute': MASTER_MUTE_NOTE,
                         'arm': MASTER_ARM_NOTE}}
        self.set_tracks_arm_status()
        self.set_tracks_mute_status()
        self.set_tracks_solo_status()
        self.set_tracks_monitoring_status()

    def remove_track_listeners(self):
        for track in self.tracks_with_listener:
            if track:
                if track.can_be_armed:
                    track.remove_arm_listener(self.on_track_arm_changed)
                track.remove_mute_listener(self.on_track_mute_changed)
                track.remove_solo_listener(self.on_track_solo_changed)
                if hasattr(track, 'current_monitoring_state'):
                    track.remove_current_monitoring_state_listener(self.on_track_monitoring_changed)

        self.tracks_with_listener = []

    def disconnect(self):
        FaderfoxMixerController.disconnect(self)
        self.remove_track_listeners()
        self.parent.song().remove_tracks_listener(self.on_tracks_added_or_deleted)

    def receive_midi_note(self, channel, status, note_no, note_vel):
        if status == NOTEOFF_STATUS:
            return
        if channel == CHANNEL_SETUP2 and note_no in TRACK_SELECT_NOTES:
            idx = note_no - TRACK_SELECT_NOTES[0]
            track = self.helper.get_track(idx)
            self.set_selected_track(track)
        if channel == CHANNEL_SETUP2 and note_no == MASTER_TRACK_SELECT_NOTE:
            self.set_selected_track(self.parent.song().master_track)
        if channel == TRACK_CHANNEL_SETUP2 and status == NOTEON_STATUS:
            self.handle_status_note(note_no, MUTE_NOTES, 'mute')
            self.handle_status_note(note_no, ARM_NOTES, 'arm')
            self.handle_status_note(note_no, SOLO_NOTES, 'solo')
            self.handle_status_note(note_no, MONITOR_NOTES, 'monitor')

    def on_tracks_added_or_deleted(self):
        self.reset_status_cache()

    def map_track_params(self, script_handle, midi_map_handle):
        self.remove_track_listeners()
        for idx in range(0, 12):
            tracks = tuple(self.parent.song().tracks) + tuple(self.parent.song().return_tracks)
            if len(tracks) > idx:
                track = tracks[idx]
                if track.can_be_armed:
                    track.add_arm_listener(self.on_track_arm_changed)
                track.add_mute_listener(self.on_track_mute_changed)
                track.add_solo_listener(self.on_track_solo_changed)
                if hasattr(track, 'current_monitoring_state'):
                    track.add_current_monitoring_state_listener(self.on_track_monitoring_changed)
                    self.log('added track %s to monitoring')
                self.tracks_with_listener += [track]

        FaderfoxMixerController.map_track_params(self, script_handle, midi_map_handle)
        self.reset_status_cache()

    def send_track_status_midi(self, status, note):
        if status:
            self.parent.send_midi((TRACK_CHANNEL_SETUP2 + NOTEON_STATUS, note, STATUS_ON))
        else:
            self.parent.send_midi((TRACK_CHANNEL_SETUP2 + NOTEOFF_STATUS, note, STATUS_OFF2))

    def set_tracks_status(self, attr, notes):
        tracks = tuple(self.parent.song().tracks) + tuple(self.parent.song().return_tracks)
        for idx in range(0, 12):
            status = 0
            if len(tracks) > idx:
                track = tracks[idx]
                if not hasattr(track, attr):
                    continue
                if not track.can_be_armed and attr == 'arm':
                    continue
                status = track.__getattribute__(attr)
                if attr == 'mute':
                    status = not status
                if attr == 'current_monitoring_state':
                    self.log('current monitoring state of %s : %s' % (track, status))
                    status = status != 2
                    self.log('status is now %s' % track.monitoring_states.OFF)
            if self.status_cache[attr][idx] != status:
                self.send_track_status_midi(status, notes[idx])
                self.status_cache[attr][idx] = status

    def set_tracks_mute_status(self):
        self.set_tracks_status('mute', MUTE_NOTES)

    def set_tracks_arm_status(self):
        self.set_tracks_status('arm', ARM_NOTES)

    def set_tracks_solo_status(self):
        self.set_tracks_status('solo', SOLO_NOTES)

    def set_tracks_monitoring_status(self):
        self.set_tracks_status('current_monitoring_state', MONITOR_NOTES)

    def on_track_arm_changed(self):
        self.set_tracks_arm_status()

    def on_track_mute_changed(self):
        self.set_tracks_mute_status()

    def on_track_solo_changed(self):
        self.set_tracks_solo_status()

    def on_track_monitoring_changed(self):
        self.log('monitoring state changed')
        self.set_tracks_monitoring_status()
########NEW FILE########
__FILENAME__ = LV2TransportController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LV2_LX2_LC2_LD2/LV2TransportController.py
import Live
from FaderfoxTransportController import FaderfoxTransportController
from FaderfoxHelper import FaderfoxHelper
from consts import *

class LV2TransportController(FaderfoxTransportController):
    __module__ = __name__
    __doc__ = 'Class representing the transport section of LV2 controllers'
    __filter_funcs__ = ['update_display', 'log']
    __use_slot_led__ = True

    def __init__(self, parent):
        LV2TransportController.realinit(self, parent)

    def realinit(self, parent):
        FaderfoxTransportController.realinit(self, parent)
        if self.__use_slot_led__:
            self.tracks_with_listener = []
            self.slots_with_listener = []
            self.clips_with_listener = []
            self.slot_callbacks = []
            self.clip_callbacks = []
        self.first = 2

    def trigger_track_clip(self, track_idx, clip_idx):
        if self.helper.trigger_track_clip(track_idx, clip_idx) == 0:
            self.set_slot_launch_led(track_idx, clip_idx, False)

    def stop_track(self, track_idx):
        track_idx, clip_idx = self.helper.stop_track(track_idx)
        if track_idx and clip_idx:
            self.set_slot_launch_led(track_idx, clip_idx, False)

    def build_midi_map(self, script_handle, midi_map_handle):
        FaderfoxTransportController.build_midi_map(self, script_handle, midi_map_handle)
        if self.__use_slot_led__:
            self.remove_clip_listeners()
            self.add_clip_listeners()
            self.update_track_playing_status()
        if self.first > 0:
            self.first -= 1
            self.clear_all_leds()

    def clear_all_leds(self):
        for track_idx in range(0, 12):
            for clip_idx in range(0, 12):
                self.set_slot_launch_led(track_idx, clip_idx, False)

    def set_slot_launch_led(self, track_idx, clip_idx, playing):
        self.log('set slot launch led %s %s %s' % (track_idx, clip_idx, playing))
        channel = AUX_CHANNEL_SETUP2
        note_no = 0
        if clip_idx > 7:
            channel = CHANNEL_SETUP2
        if clip_idx < 6:
            note_no = SLOT_LAUNCH_NOTES1[track_idx][clip_idx]
        else:
            note_no = SLOT_LAUNCH_NOTES2[track_idx][clip_idx - 6]
        if playing:
            self.parent.send_midi((NOTEON_STATUS + channel, note_no, 127))
        else:
            self.parent.send_midi((NOTEOFF_STATUS + channel, note_no, 0))

    def on_slot_clip_changed(self, slot, track_idx, slot_idx):
        if slot.has_clip and slot.clip.is_playing:
            self.set_slot_launch_led(track_idx, slot_idx, True)
        else:
            self.set_slot_launch_led(track_idx, slot_idx, False)
        self.remove_clip_listeners()
        self.add_clip_listeners()

    def on_clip_playing_changed(self, clip, track_idx, clip_idx):
        if not clip.is_triggered:
            self.set_slot_launch_led(track_idx, clip_idx, clip.is_playing)
            self.update_track_playing_status()

    def update_track_playing_status(self):
        i = 0
        for track in self.parent.song().tracks:
            if i > 11:
                return
            if self.helper.is_track_playing(track):
                self.parent.send_midi((NOTEON_STATUS + TRACK_CHANNEL_SETUP2, LAUNCH_NOTES[i], 127))
            else:
                self.parent.send_midi((NOTEOFF_STATUS + TRACK_CHANNEL_SETUP2, LAUNCH_NOTES[i], 0))
            i += 1

    def clip_add_callback(self, clip, track_idx, clip_idx):
        callback = lambda : self.on_clip_playing_changed(clip, track_idx, clip_idx)
        clip.add_playing_status_listener(callback)
        self.clips_with_listener += [clip]
        self.clip_callbacks += [callback]

    def slot_add_callback(self, slot, track_idx, slot_idx):
        callback = lambda : self.on_slot_clip_changed(slot, track_idx, slot_idx)
        slot.add_has_clip_listener(callback)
        self.slots_with_listener += [slot]
        self.slot_callbacks += [callback]

    def add_clip_listeners(self):
        i = 0
        for track in self.parent.song().tracks:
            if i > 11:
                return
            sloti = 0
            for slot in track.clip_slots:
                if slot.has_clip:
                    self.slot_add_callback(slot, i, sloti)
                    self.clip_add_callback(slot.clip, i, sloti)
                sloti += 1

            i += 1

    def remove_slot_listeners(self):
        for i in range(0, len(self.slots_with_listener)):
            slot = self.slots_with_listener[i]
            callback = self.slot_callbacks[i]
            try:
                if slot.has_clip_has_listener(callback):
                    slot.remove_has_clip_listener(callback)
            except:
                continue

        self.slots_with_listener = []
        self.slot_callbacks = []

    def remove_clip_listeners(self):
        self.remove_slot_listeners()
        for i in range(0, len(self.clips_with_listener)):
            clip = self.clips_with_listener[i]
            callback = self.clip_callbacks[i]
            try:
                if clip.playing_status_has_listener(callback):
                    clip.remove_playing_status_listener(callback)
            except:
                continue

        self.clips_with_listener = []
        self.clip_callbacks = []

    def disconnect(self):
        if self.__use_slot_led__:
            self.remove_clip_listeners()
########NEW FILE########
__FILENAME__ = LV2_LX2_LC2_LD2
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LV2_LX2_LC2_LD2/LV2_LX2_LC2_LD2.py
import Live
from FaderfoxScript import FaderfoxScript
from LV2MixerController import LV2MixerController
from LV2DeviceController import LV2DeviceController
from FaderfoxDeviceController import FaderfoxDeviceController
from LV2TransportController import LV2TransportController
from consts import *

class LV2_LX2_LC2_LD2(FaderfoxScript):
    __module__ = __name__
    __doc__ = 'Automap script for LV2 Faderfox controllers'
    __name__ = 'LV2_LX2_LC2_LD2 Remote Script'

    def __init__(self, c_instance):
        LV2_LX2_LC2_LD2.realinit(self, c_instance)

    def realinit(self, c_instance):
        self.suffix = '2'
        FaderfoxScript.realinit(self, c_instance)
        self.mixer_controller = LV2MixerController(self)
        self.device_controller = LV2DeviceController(self)
        self.transport_controller = LV2TransportController(self)
        self.components = [self.mixer_controller, self.device_controller, self.transport_controller]

    def suggest_map_mode(self, cc_no, channel):
        return -1
########NEW FILE########
__FILENAME__ = ParamMap
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LV2_LX2_LC2_LD2/ParamMap.py
import Live

class Callable:

    def __init__(self, anycallable):
        self.__call__ = anycallable


class ParamMap:
    __module__ = __name__
    __doc__ = 'Class to help with device mapping'

    def __init__(self, parent):
        ParamMap.realinit(self, parent)

    def realinit(self, parent):
        self.parent = parent
        self.params_with_listener = []
        self.param_callbacks = []

    def log(self, string):
        self.parent.log(string)

    def logfmt(self, fmt, *args):
        args2 = []
        for i in range(0, len(args)):
            args2 += [args[i].__str__()]

        str = fmt % tuple(args2)
        return self.log(str)

    def param_add_callback(self, script_handle, midi_map_handle, param, min, max, cc, channel):
        callback = lambda : self.on_param_value_changed(param, min, max, cc, channel)
        param.add_value_listener(callback)
        self.params_with_listener += [param]
        self.param_callbacks += [callback]
        ParamMap.forward_cc(script_handle, midi_map_handle, channel, cc)

    def receive_midi_note(self, channel, status, note_no, note_vel):
        pass

    def receive_midi_cc(self, chan, cc_no, cc_value):
        pass

    def forward_cc(script_handle, midi_map_handle, chan, cc):
        Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, chan, cc)

    forward_cc = Callable(forward_cc)

    def forward_note(script_handle, midi_map_handle, chan, note):
        Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, chan, note)

    forward_note = Callable(forward_note)

    def map_with_feedback(midi_map_handle, channel, cc, parameter, mode):
        feedback_rule = Live.MidiMap.CCFeedbackRule()
        feedback_rule.channel = channel
        feedback_rule.cc_value_map = tuple()
        feedback_rule.delay_in_ms = -1.0
        feedback_rule.cc_no = cc
        Live.MidiMap.map_midi_cc_with_feedback_map(midi_map_handle, parameter, channel, cc, mode, feedback_rule, False)
        Live.MidiMap.send_feedback_for_parameter(midi_map_handle, parameter)

    map_with_feedback = Callable(map_with_feedback)

    def on_param_value_changed(self, param, min, max, cc, channel):
        pass

    def remove_mappings(self):
        for i in range(0, len(self.params_with_listener)):
            param = self.params_with_listener[i]
            callback = self.param_callbacks[i]
            try:
                if param.value_has_listener(callback):
                    param.remove_value_listener(callback)
            except:
                continue

        self.params_with_listener = []
        self.param_callbacks = []
########NEW FILE########
__FILENAME__ = Params
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/LV2_LX2_LC2_LD2/Params.py
AUTO_FILTER_PARAMS = {'LFO Sync Rate': 'LFO Synced Rate'}
AUTO_PAN_PARAMS = {'Sync Rate': 'Synced Rate'}
BEAT_REPEAT_PARAMS = {'Decay': 'Damp Volume',
 'Pitch Decay': 'Damp Pitch',
 'Volume': 'Wet Level',
 'Repeat': 'Instant Repeat'}
EQ_FOUR_PARAMS = {'1 Filter On A': '1 Filter On',
 '1 Frequency A': '1 Frequency',
 '1 Gain A': '1 Gain',
 '1 Filter Type A': '1 Filter Type',
 '1 Resonance A': '1 Resonance',
 '2 Filter On A': '2 Filter On',
 '2 Frequency A': '2 Frequency',
 '2 Gain A': '2 Gain',
 '2 Filter Type A': '2 Filter Type',
 '2 Resonance A': '2 Resonance',
 '3 Filter On A': '3 Filter On',
 '3 Frequency A': '3 Frequency',
 '3 Gain A': '3 Gain',
 '3 Filter Type A': '3 Filter Type',
 '3 Resonance A': '3 Resonance',
 '4 Filter On A': '4 Filter On',
 '4 Frequency A': '4 Frequency',
 '4 Gain A': '4 Gain',
 '4 Filter Type A': '4 Filter Type',
 '4 Resonance A': '4 Resonance'}
FLANGER_PARAMS = {'Frequency': 'LFO Frequency',
 'Sync': 'LFO Sync',
 'Sync Rate': 'LFO Synced Rate'}
PHASER_PARAMS = {'Sync': 'LFO Sync',
 'Sync Rate': 'LFO Synced Rate'}
SATURATOR_PARAMS = {'Base': 'BaseDrive',
 'Drive': 'PreDrive'}
FIVETOSIX_PARAMS_DICT = {'AutoFilter': AUTO_FILTER_PARAMS,
 'AutoPan': AUTO_PAN_PARAMS,
 'BeatRepeat': BEAT_REPEAT_PARAMS,
 'Eq8': EQ_FOUR_PARAMS,
 'Flanger': FLANGER_PARAMS,
 'Phaser': PHASER_PARAMS,
 'Saturator': SATURATOR_PARAMS}
########NEW FILE########
__FILENAME__ = ChannelStrip
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl/ChannelStrip.py
from MackieControlComponent import *
from itertools import chain

class ChannelStrip(MackieControlComponent):
    """Represets a Channel Strip of the Mackie Control, which consists out of the"""

    def __init__(self, main_script, strip_index):
        MackieControlComponent.__init__(self, main_script)
        self.__channel_strip_controller = None
        self.__is_touched = False
        self.__strip_index = strip_index
        self.__stack_offset = 0
        self.__bank_and_channel_offset = 0
        self.__assigned_track = None
        self.__v_pot_parameter = None
        self.__v_pot_display_mode = VPOT_DISPLAY_SINGLE_DOT
        self.__fader_parameter = None
        self.__signal_led_enabled = True
        self.__meters_enabled = False
        self.__last_meter_value = -1
        self.__send_meter_mode()
        self.__within_track_added_or_deleted = False
        self.__within_destroy = False
        self.set_bank_and_channel_offset(offset=0, show_return_tracks=False, within_track_added_or_deleted=False)

    def destroy(self):
        self.__within_destroy = True
        if self.__assigned_track:
            self.__remove_listeners()
        self.__assigned_track = None
        self.send_midi((208, 0 + (self.__strip_index << 4)))
        self.__signal_led_enabled = False
        self.__meters_enabled = False
        self.__send_meter_mode()
        self.refresh_state()
        MackieControlComponent.destroy(self)
        self.__within_destroy = False

    def set_channel_strip_controller(self, channel_strip_controller):
        self.__channel_strip_controller = channel_strip_controller

    def strip_index(self):
        return self.__strip_index

    def assigned_track(self):
        return self.__assigned_track

    def is_touched(self):
        return self.__is_touched

    def set_is_touched(self, touched):
        self.__is_touched = touched

    def stack_offset(self):
        return self.__stack_offset

    def set_stack_offset(self, offset):
        """This is the offset that one gets by 'stacking' several MackieControl XTs:
           the first is at index 0, the second at 8, etc ...
        """
        self.__stack_offset = offset

    def set_bank_and_channel_offset(self, offset, show_return_tracks, within_track_added_or_deleted):
        final_track_index = self.__strip_index + self.__stack_offset + offset
        self.__within_track_added_or_deleted = within_track_added_or_deleted
        if show_return_tracks:
            tracks = self.song().return_tracks
        else:
            tracks = self.song().visible_tracks
        if final_track_index < len(tracks):
            new_track = tracks[final_track_index]
        else:
            new_track = None
        if new_track != self.__assigned_track:
            if self.__assigned_track:
                self.__remove_listeners()
            self.__assigned_track = new_track
            if self.__assigned_track:
                self.__add_listeners()
        self.refresh_state()
        self.__within_track_added_or_deleted = False

    def v_pot_parameter(self):
        return self.__v_pot_parameter

    def set_v_pot_parameter(self, parameter, display_mode = VPOT_DISPLAY_SINGLE_DOT):
        self.__v_pot_display_mode = display_mode
        self.__v_pot_parameter = parameter
        if not parameter:
            self.unlight_vpot_leds()

    def fader_parameter(self):
        return self.__fader_parameter

    def set_fader_parameter(self, parameter):
        self.__fader_parameter = parameter
        if not parameter:
            self.reset_fader()

    def enable_meter_mode(self, Enabled):
        self.__meters_enabled = Enabled
        self.__send_meter_mode()

    def enable_signal_leds(self, Enable):
        self.__signal_led_enabled = Enable
        self.__send_meter_mode()

    def reset_fader(self):
        self.send_midi((PB_STATUS + self.__strip_index, 0, 0))

    def unlight_vpot_leds(self):
        self.send_midi((CC_STATUS + 0, 48 + self.__strip_index, 32))

    def show_full_enlighted_poti(self):
        self.send_midi((CC_STATUS + 0, 48 + self.__strip_index, VPOT_DISPLAY_WRAP * 16 + 11))

    def handle_channel_strip_switch_ids(self, sw_id, value):
        if sw_id in range(SID_RECORD_ARM_BASE, SID_RECORD_ARM_BASE + NUM_CHANNEL_STRIPS):
            if sw_id - SID_RECORD_ARM_BASE is self.__strip_index:
                if value == BUTTON_PRESSED:
                    if self.song().exclusive_arm:
                        exclusive = not self.control_is_pressed()
                    else:
                        exclusive = self.control_is_pressed()
                    self.__toggle_arm_track(exclusive)
        elif sw_id in range(SID_SOLO_BASE, SID_SOLO_BASE + NUM_CHANNEL_STRIPS):
            if sw_id - SID_SOLO_BASE is self.__strip_index:
                if value == BUTTON_PRESSED:
                    if self.song().exclusive_solo:
                        exclusive = not self.control_is_pressed()
                    else:
                        exclusive = self.control_is_pressed()
                    self.__toggle_solo_track(exclusive)
        elif sw_id in range(SID_MUTE_BASE, SID_MUTE_BASE + NUM_CHANNEL_STRIPS):
            if sw_id - SID_MUTE_BASE is self.__strip_index:
                if value == BUTTON_PRESSED:
                    self.__toggle_mute_track()
        elif sw_id in range(SID_SELECT_BASE, SID_SELECT_BASE + NUM_CHANNEL_STRIPS):
            if sw_id - SID_SELECT_BASE is self.__strip_index:
                if value == BUTTON_PRESSED:
                    self.__select_track()
        elif sw_id in range(SID_VPOD_PUSH_BASE, SID_VPOD_PUSH_BASE + NUM_CHANNEL_STRIPS):
            if sw_id - SID_VPOD_PUSH_BASE is self.__strip_index:
                if value == BUTTON_PRESSED and self.__channel_strip_controller != None:
                    self.__channel_strip_controller.handle_pressed_v_pot(self.__strip_index, self.__stack_offset)
        elif sw_id in fader_touch_switch_ids:
            if sw_id - SID_FADER_TOUCH_SENSE_BASE is self.__strip_index:
                if value == BUTTON_PRESSED or value == BUTTON_RELEASED:
                    if self.__channel_strip_controller != None:
                        touched = value == BUTTON_PRESSED
                        self.set_is_touched(touched)
                        self.__channel_strip_controller.handle_fader_touch(self.__strip_index, self.__stack_offset, touched)

    def handle_vpot_rotation(self, strip_index, cc_value):
        if strip_index is self.__strip_index and self.__channel_strip_controller != None:
            self.__channel_strip_controller.handle_vpot_rotation(self.__strip_index, self.__stack_offset, cc_value)

    def refresh_state(self):
        if not self.__within_track_added_or_deleted:
            self.__update_track_is_selected_led()
        self.__update_solo_led()
        self.__update_mute_led()
        self.__update_arm_led()
        if not self.__within_destroy and self.__assigned_track != None:
            self.__send_meter_mode()
            self.__last_meter_value = -1
        if not self.__assigned_track:
            self.reset_fader()
            self.unlight_vpot_leds()

    def on_update_display_timer(self):
        if self.__signal_led_enabled or self.__meters_enabled:
            if self.__assigned_track:
                if self.__assigned_track.can_be_armed and self.__assigned_track.arm:
                    meter_value = self.__assigned_track.input_meter_level
                else:
                    meter_value = self.__assigned_track.output_meter_level
            else:
                meter_value = 0.0
            meter_byte = int(meter_value * 12.0) + (self.__strip_index << 4)
            if self.__last_meter_value != meter_value or meter_value != 0.0:
                self.__last_meter_value = meter_value
                self.send_midi((208, meter_byte))

    def build_midi_map(self, midi_map_handle):
        needs_takeover = False
        if self.__fader_parameter:
            feeback_rule = Live.MidiMap.PitchBendFeedbackRule()
            feeback_rule.channel = self.__strip_index
            feeback_rule.value_pair_map = tuple()
            feeback_rule.delay_in_ms = 200.0
            Live.MidiMap.map_midi_pitchbend_with_feedback_map(midi_map_handle, self.__fader_parameter, self.__strip_index, feeback_rule, not needs_takeover)
            Live.MidiMap.send_feedback_for_parameter(midi_map_handle, self.__fader_parameter)
        else:
            channel = self.__strip_index
            Live.MidiMap.forward_midi_pitchbend(self.script_handle(), midi_map_handle, channel)
        if self.__v_pot_parameter:
            if self.__v_pot_display_mode == VPOT_DISPLAY_SPREAD:
                range_end = 7
            else:
                range_end = 12
            feeback_rule = Live.MidiMap.CCFeedbackRule()
            feeback_rule.channel = 0
            feeback_rule.cc_no = 48 + self.__strip_index
            feeback_rule.cc_value_map = tuple([ self.__v_pot_display_mode * 16 + x for x in range(1, range_end) ])
            feeback_rule.delay_in_ms = -1.0
            Live.MidiMap.map_midi_cc_with_feedback_map(midi_map_handle, self.__v_pot_parameter, 0, FID_PANNING_BASE + self.__strip_index, Live.MidiMap.MapMode.relative_signed_bit, feeback_rule, needs_takeover)
            Live.MidiMap.send_feedback_for_parameter(midi_map_handle, self.__v_pot_parameter)
        else:
            channel = 0
            cc_no = FID_PANNING_BASE + self.__strip_index
            Live.MidiMap.forward_midi_cc(self.script_handle(), midi_map_handle, channel, cc_no)

    def __assigned_track_index(self):
        index = 0
        for t in chain(self.song().visible_tracks, self.song().return_tracks):
            if t == self.__assigned_track:
                return index
            index += 1

        if not (self.__assigned_track and 0):
            raise AssertionError

    def __add_listeners(self):
        if self.__assigned_track.can_be_armed:
            self.__assigned_track.add_arm_listener(self.__update_arm_led)
        self.__assigned_track.add_mute_listener(self.__update_mute_led)
        self.__assigned_track.add_solo_listener(self.__update_solo_led)
        if not self.song().view.selected_track_has_listener(self.__update_track_is_selected_led):
            self.song().view.add_selected_track_listener(self.__update_track_is_selected_led)

    def __remove_listeners(self):
        if self.__assigned_track.can_be_armed:
            self.__assigned_track.remove_arm_listener(self.__update_arm_led)
        self.__assigned_track.remove_mute_listener(self.__update_mute_led)
        self.__assigned_track.remove_solo_listener(self.__update_solo_led)
        self.song().view.remove_selected_track_listener(self.__update_track_is_selected_led)

    def __send_meter_mode(self):
        on_mode = 0
        off_mode = 0
        if self.__signal_led_enabled:
            on_mode = on_mode | 1
        if self.__meters_enabled:
            on_mode = on_mode | 2
        if self.__assigned_track:
            mode = on_mode
        else:
            mode = off_mode
        if self.main_script().is_extension():
            device_type = SYSEX_DEVICE_TYPE_XT
        else:
            device_type = SYSEX_DEVICE_TYPE
        self.send_midi((240,
         0,
         0,
         102,
         device_type,
         32,
         self.__strip_index,
         mode,
         247))

    def __toggle_arm_track(self, exclusive):
        if self.__assigned_track and self.__assigned_track.can_be_armed:
            self.__assigned_track.arm = not self.__assigned_track.arm
            if exclusive:
                for t in self.song().tracks:
                    if t != self.__assigned_track:
                        t.arm = False

    def __toggle_mute_track(self):
        if self.__assigned_track:
            self.__assigned_track.mute = not self.__assigned_track.mute

    def __toggle_solo_track(self, exclusive):
        if self.__assigned_track:
            self.__assigned_track.solo = not self.__assigned_track.solo
            if exclusive:
                for t in chain(self.song().tracks, self.song().return_tracks):
                    if t != self.__assigned_track:
                        t.solo = False

    def __select_track(self):
        if self.__assigned_track:
            all_tracks = tuple(self.song().visible_tracks) + tuple(self.song().return_tracks)
            if self.song().view.selected_track != all_tracks[self.__assigned_track_index()]:
                self.song().view.selected_track = all_tracks[self.__assigned_track_index()]
            elif self.application().view.is_view_visible('Arranger'):
                if self.__assigned_track:
                    self.__assigned_track.view.is_collapsed = not self.__assigned_track.view.is_collapsed

    def __update_arm_led(self):
        track = self.__assigned_track
        if track and track.can_be_armed and track.arm:
            self.send_midi((NOTE_ON_STATUS, SID_RECORD_ARM_BASE + self.__strip_index, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_RECORD_ARM_BASE + self.__strip_index, BUTTON_STATE_OFF))

    def __update_mute_led(self):
        if self.__assigned_track and self.__assigned_track.mute:
            self.send_midi((NOTE_ON_STATUS, SID_MUTE_BASE + self.__strip_index, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_MUTE_BASE + self.__strip_index, BUTTON_STATE_OFF))

    def __update_solo_led(self):
        if self.__assigned_track and self.__assigned_track.solo:
            self.send_midi((NOTE_ON_STATUS, SID_SOLO_BASE + self.__strip_index, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_SOLO_BASE + self.__strip_index, BUTTON_STATE_OFF))

    def __update_track_is_selected_led(self):
        if self.song().view.selected_track == self.__assigned_track:
            self.send_midi((NOTE_ON_STATUS, SID_SELECT_BASE + self.__strip_index, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_SELECT_BASE + self.__strip_index, BUTTON_STATE_OFF))


class MasterChannelStrip(MackieControlComponent):

    def __init__(self, main_script):
        MackieControlComponent.__init__(self, main_script)
        self.__strip_index = MASTER_CHANNEL_STRIP_INDEX
        self.__assigned_track = self.song().master_track

    def destroy(self):
        self.reset_fader()
        MackieControlComponent.destroy(self)

    def set_channel_strip_controller(self, channel_strip_controller):
        pass

    def handle_channel_strip_switch_ids(self, sw_id, value):
        pass

    def refresh_state(self):
        pass

    def on_update_display_timer(self):
        pass

    def enable_meter_mode(self, Enabled):
        pass

    def reset_fader(self):
        self.send_midi((PB_STATUS + self.__strip_index, 0, 0))

    def build_midi_map(self, midi_map_handle):
        if self.__assigned_track:
            needs_takeover = False
            volume = self.__assigned_track.mixer_device.volume
            feeback_rule = Live.MidiMap.PitchBendFeedbackRule()
            feeback_rule.channel = self.__strip_index
            feeback_rule.value_pair_map = tuple()
            feeback_rule.delay_in_ms = 200.0
            Live.MidiMap.map_midi_pitchbend_with_feedback_map(midi_map_handle, volume, self.__strip_index, feeback_rule, not needs_takeover)
            Live.MidiMap.send_feedback_for_parameter(midi_map_handle, volume)
########NEW FILE########
__FILENAME__ = ChannelStripController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl/ChannelStripController.py
from MackieControlComponent import *
from _Generic.Devices import *
from itertools import chain

class ChannelStripController(MackieControlComponent):
    """
       Controls all channel-strips of the Mackie Control and controller extensions
       (Mackie Control XTs) if available: Maps and controls the faders, VPots and the
       displays depending on the assignemnt modes (Vol_Pan, PlugIn, IO, Send) and
       edit and flip mode.
    
       stack_offset vs. strip_index vs. bank_channel_offset:
    
       When using multiple sets of channel strips (stacking them), we will still only
       have one ChannelStripController which rules them all.
       To identify and seperate them, the implementation uses 3 different kind of
       indices or offsets:
    
       - strip_index: is the index of a channel_strip within its controller box,
         so strip no 1 on an extension (XT) and strip number one on the 'main' Mackie
         will both have a strip_index of 1.
         We need to preserve this index, because every device (extension or main controller
         will use a unique MIDI port to send out its MIDI messages which uses the
         strip_index, encoded into the MIDI messages channel, to tell the hardware which
         channel on the controller is meant.
    
       - stack_offset: descibes how many channels are left to the device that a
         channel_strip belongs to. For example: You have 3 Mackies: First, a XT, then
         the main Mackie, then another XT.
         The first XT will have the stack_index 0, the main Mackie, the stack_index 8,
         because 8 faders are on present before it. The second XT has a stack_index of 16
    
       - bank_cha_offset: this shifts all available channel strips within all the tracks
         that should be controlled. For example: If you have a song with 32 tracks, and
         a main Mackie Control + a XT on the right, then you want to shift the first fader
         of the main Mackie to Track 16, to be able to control Track 16 to 32.
    
       The master channel strip is hardcoded and not in the list of "normal" channel_strips,
       because its always mapped to the master_volume.
    """

    def __init__(self, main_script, channel_strips, master_strip, main_display_controller):
        MackieControlComponent.__init__(self, main_script)
        self.__left_extensions = []
        self.__right_extensions = []
        self.__own_channel_strips = channel_strips
        self.__master_strip = master_strip
        self.__channel_strips = channel_strips
        self.__main_display_controller = main_display_controller
        self.__meters_enabled = False
        self.__assignment_mode = CSM_VOLPAN
        self.__sub_mode_in_io_mode = CSM_IO_FIRST_MODE
        self.__plugin_mode = PCM_DEVICES
        self.__plugin_mode_offsets = [ 0 for x in range(PCM_NUMMODES) ]
        self.__chosen_plugin = None
        self.__ordered_plugin_parameters = []
        self.__displayed_plugins = []
        self.__last_attached_selected_track = None
        self.__send_mode_offset = 0
        self.__flip = False
        self.__view_returns = False
        self.__bank_cha_offset = 0
        self.__bank_cha_offset_returns = 0
        self.__within_track_added_or_deleted = False
        self.song().add_visible_tracks_listener(self.__on_tracks_added_or_deleted)
        self.song().view.add_selected_track_listener(self.__on_selected_track_changed)
        for t in chain(self.song().visible_tracks, self.song().return_tracks):
            if not t.solo_has_listener(self.__update_rude_solo_led):
                t.add_solo_listener(self.__update_rude_solo_led)
            if not t.has_audio_output_has_listener(self.__on_any_tracks_output_type_changed):
                t.add_has_audio_output_listener(self.__on_any_tracks_output_type_changed)

        self.__on_selected_track_changed()
        for s in self.__own_channel_strips:
            s.set_channel_strip_controller(self)

        self.__reassign_channel_strip_offsets()
        self.__reassign_channel_strip_parameters(for_display_only=False)

    def destroy(self):
        self.song().remove_visible_tracks_listener(self.__on_tracks_added_or_deleted)
        self.song().view.remove_selected_track_listener(self.__on_selected_track_changed)
        for t in chain(self.song().visible_tracks, self.song().return_tracks):
            if t.solo_has_listener(self.__update_rude_solo_led):
                t.remove_solo_listener(self.__update_rude_solo_led)
            if t.has_audio_output_has_listener(self.__on_any_tracks_output_type_changed):
                t.remove_has_audio_output_listener(self.__on_any_tracks_output_type_changed)

        st = self.__last_attached_selected_track
        if st and st.devices_has_listener(self.__on_selected_device_chain_changed):
            st.remove_devices_listener(self.__on_selected_device_chain_changed)
        for note in channel_strip_assignment_switch_ids:
            self.send_midi((NOTE_ON_STATUS, note, BUTTON_STATE_OFF))

        for note in channel_strip_control_switch_ids:
            self.send_midi((NOTE_ON_STATUS, note, BUTTON_STATE_OFF))

        self.send_midi((NOTE_ON_STATUS, SELECT_RUDE_SOLO, BUTTON_STATE_OFF))
        self.send_midi((CC_STATUS, 75, g7_seg_led_conv_table[' ']))
        self.send_midi((CC_STATUS, 74, g7_seg_led_conv_table[' ']))
        MackieControlComponent.destroy(self)

    def set_controller_extensions(self, left_extensions, right_extensions):
        """ Called from the main script (after all scripts where initialized), to let us
            know where and how many MackieControlXT are installed.
            There exists only one ChannelStripController, so we will take care about the
            extensions channel strips
        """
        self.__left_extensions = left_extensions
        self.__right_extensions = right_extensions
        self.__channel_strips = []
        stack_offset = 0
        for le in left_extensions:
            for s in le.channel_strips():
                self.__channel_strips.append(s)
                s.set_stack_offset(stack_offset)

            stack_offset += NUM_CHANNEL_STRIPS

        for s in self.__own_channel_strips:
            self.__channel_strips.append(s)
            s.set_stack_offset(stack_offset)

        stack_offset += NUM_CHANNEL_STRIPS
        for re in right_extensions:
            for s in re.channel_strips():
                self.__channel_strips.append(s)
                s.set_stack_offset(stack_offset)

            stack_offset += NUM_CHANNEL_STRIPS

        for s in self.__channel_strips:
            s.set_channel_strip_controller(self)

        self.refresh_state()

    def refresh_state(self):
        self.__update_assignment_mode_leds()
        self.__update_assignment_display()
        self.__update_rude_solo_led()
        self.__reassign_channel_strip_offsets()
        self.__on_flip_changed()
        self.__update_view_returns_mode()

    def request_rebuild_midi_map(self):
        """ Overridden to call also the extensions request_rebuild_midi_map"""
        MackieControlComponent.request_rebuild_midi_map(self)
        for ex in self.__left_extensions + self.__right_extensions:
            ex.request_rebuild_midi_map()

    def on_update_display_timer(self):
        self.__update_channel_strip_strings()

    def toggle_meter_mode(self):
        """ called from the main script when the display toggle button was pressed """
        self.__meters_enabled = not self.__meters_enabled
        self.__apply_meter_mode()

    def handle_assignment_switch_ids(self, switch_id, value):
        if switch_id == SID_ASSIGNMENT_IO:
            if value == BUTTON_PRESSED:
                self.__set_assignment_mode(CSM_IO)
        elif switch_id == SID_ASSIGNMENT_SENDS:
            if value == BUTTON_PRESSED:
                self.__set_assignment_mode(CSM_SENDS)
        elif switch_id == SID_ASSIGNMENT_PAN:
            if value == BUTTON_PRESSED:
                self.__set_assignment_mode(CSM_VOLPAN)
        elif switch_id == SID_ASSIGNMENT_PLUG_INS:
            if value == BUTTON_PRESSED:
                self.__set_assignment_mode(CSM_PLUGINS)
        elif switch_id == SID_ASSIGNMENT_EQ:
            if value == BUTTON_PRESSED:
                self.__switch_to_prev_page()
        elif switch_id == SID_ASSIGNMENT_DYNAMIC:
            if value == BUTTON_PRESSED:
                self.__switch_to_next_page()
        elif switch_id == SID_FADERBANK_PREV_BANK:
            if value == BUTTON_PRESSED:
                if self.shift_is_pressed():
                    self.__set_channel_offset(0)
                else:
                    self.__set_channel_offset(self.__strip_offset() - len(self.__channel_strips))
        elif switch_id == SID_FADERBANK_NEXT_BANK:
            if value == BUTTON_PRESSED:
                if self.shift_is_pressed():
                    last_possible_offset = (self.__controlled_num_of_tracks() - self.__strip_offset()) / len(self.__channel_strips) * len(self.__channel_strips) + self.__strip_offset()
                    if last_possible_offset == self.__controlled_num_of_tracks():
                        last_possible_offset -= len(self.__channel_strips)
                    self.__set_channel_offset(last_possible_offset)
                elif self.__strip_offset() < self.__controlled_num_of_tracks() - len(self.__channel_strips):
                    self.__set_channel_offset(self.__strip_offset() + len(self.__channel_strips))
        elif switch_id == SID_FADERBANK_PREV_CH:
            if value == BUTTON_PRESSED:
                if self.shift_is_pressed():
                    self.__set_channel_offset(0)
                else:
                    self.__set_channel_offset(self.__strip_offset() - 1)
        elif switch_id == SID_FADERBANK_NEXT_CH:
            if value == BUTTON_PRESSED:
                if self.shift_is_pressed():
                    self.__set_channel_offset(self.__controlled_num_of_tracks() - len(self.__channel_strips))
                elif self.__strip_offset() < self.__controlled_num_of_tracks() - len(self.__channel_strips):
                    self.__set_channel_offset(self.__strip_offset() + 1)
        elif switch_id == SID_FADERBANK_FLIP:
            if value == BUTTON_PRESSED:
                self.__toggle_flip()
        elif switch_id == SID_FADERBANK_EDIT:
            if value == BUTTON_PRESSED:
                self.__toggle_view_returns()

    def handle_vpot_rotation(self, strip_index, stack_offset, cc_value):
        """ forwarded to us by the channel_strips """
        if self.__assignment_mode == CSM_IO:
            if cc_value >= 64:
                direction = -1
            else:
                direction = 1
            channel_strip = self.__channel_strips[stack_offset + strip_index]
            current_routing = self.__routing_target(channel_strip)
            available_routings = self.__available_routing_targets(channel_strip)
            if current_routing and available_routings:
                if current_routing in available_routings:
                    i = list(available_routings).index(current_routing)
                    if direction == 1:
                        new_i = min(len(available_routings) - 1, i + direction)
                    else:
                        new_i = max(0, i + direction)
                    new_routing = available_routings[new_i]
                elif len(available_routings):
                    new_routing = available_routings[0]
                self.__set_routing_target(channel_strip, new_routing)
        elif self.__assignment_mode == CSM_PLUGINS:
            pass
        else:
            channel_strip = self.__channel_strips[stack_offset + strip_index]
            raise not channel_strip.assigned_track() or not channel_strip.assigned_track().has_audio_output or AssertionError, 'in every other mode, the midimap should handle the messages'

    def handle_fader_touch(self, strip_offset, stack_offset, touched):
        """ forwarded to us by the channel_strips """
        self.__reassign_channel_strip_parameters(for_display_only=True)

    def handle_pressed_v_pot(self, strip_index, stack_offset):
        """ forwarded to us by the channel_strips """
        if self.__assignment_mode == CSM_VOLPAN or self.__assignment_mode == CSM_SENDS or self.__assignment_mode == CSM_PLUGINS and self.__plugin_mode == PCM_PARAMETERS:
            if stack_offset + strip_index in range(0, len(self.__channel_strips)):
                param = self.__channel_strips[stack_offset + strip_index].v_pot_parameter()
            if param and param.is_enabled:
                if param.is_quantized:
                    if param.value + 1 > param.max:
                        param.value = param.min
                    else:
                        param.value = param.value + 1
                else:
                    param.value = param.default_value
        elif self.__assignment_mode == CSM_PLUGINS:
            if self.__plugin_mode == PCM_DEVICES:
                device_index = strip_index + stack_offset + self.__plugin_mode_offsets[PCM_DEVICES]
                if device_index >= 0 and device_index < len(self.song().view.selected_track.devices):
                    if self.__chosen_plugin != None:
                        self.__chosen_plugin.remove_parameters_listener(self.__on_parameter_list_of_chosen_plugin_changed)
                    self.__chosen_plugin = self.song().view.selected_track.devices[device_index]
                    self.__chosen_plugin != None and self.__chosen_plugin.add_parameters_listener(self.__on_parameter_list_of_chosen_plugin_changed)
                self.__reorder_parameters()
                self.__plugin_mode_offsets[PCM_PARAMETERS] = 0
                self.__set_plugin_mode(PCM_PARAMETERS)

    def __strip_offset(self):
        """ return the bank_channel offset depending if we are in return mode or not
        """
        if self.__view_returns:
            return self.__bank_cha_offset_returns
        else:
            return self.__bank_cha_offset

    def __controlled_num_of_tracks(self):
        """ return the number of tracks, depending on if we are in send_track
            mode or normal track mode
        """
        if self.__view_returns:
            return len(self.song().return_tracks)
        else:
            return len(self.song().visible_tracks)

    def __send_parameter(self, strip_index, stack_index):
        """ Return the send parameter that is assigned to the given channel strip
        """
        if not self.__assignment_mode == CSM_SENDS:
            raise AssertionError
            send_index = strip_index + stack_index + self.__send_mode_offset
            p = send_index < len(self.song().view.selected_track.mixer_device.sends) and self.song().view.selected_track.mixer_device.sends[send_index]
            return (p, p.name)
        return (None, None)

    def __plugin_parameter(self, strip_index, stack_index):
        """ Return the parameter that is assigned to the given channel strip
        """
        if not self.__assignment_mode == CSM_PLUGINS:
            raise AssertionError
            return self.__plugin_mode == PCM_DEVICES and (None, None)
        elif not (self.__plugin_mode == PCM_PARAMETERS and self.__chosen_plugin):
            raise AssertionError
            parameters = self.__ordered_plugin_parameters
            parameter_index = strip_index + stack_index + self.__plugin_mode_offsets[PCM_PARAMETERS]
            if parameter_index >= 0 and parameter_index < len(parameters):
                return parameters[parameter_index]
            else:
                return (None, None)
        else:
            raise 0 or AssertionError

    def __any_slider_is_touched(self):
        for s in self.__channel_strips:
            if s.is_touched():
                return True

        return False

    def __can_flip(self):
        if self.__assignment_mode == CSM_PLUGINS and self.__plugin_mode == PCM_DEVICES:
            return False
        elif self.__assignment_mode == CSM_IO:
            return False
        return True

    def __can_switch_to_prev_page(self):
        """ return true if pressing the "next" button will have any effect """
        if self.__assignment_mode == CSM_PLUGINS:
            return self.__plugin_mode_offsets[self.__plugin_mode] > 0
        elif self.__assignment_mode == CSM_SENDS:
            return self.__send_mode_offset > 0
        else:
            return False

    def __can_switch_to_next_page(self):
        """ return true if pressing the "prev" button will have any effect """
        if self.__assignment_mode == CSM_PLUGINS:
            sel_track = self.song().view.selected_track
            if self.__plugin_mode == PCM_DEVICES:
                return self.__plugin_mode_offsets[PCM_DEVICES] + len(self.__channel_strips) < len(sel_track.devices)
            elif not (self.__plugin_mode == PCM_PARAMETERS and self.__chosen_plugin):
                raise AssertionError
                parameters = self.__ordered_plugin_parameters
                return self.__plugin_mode_offsets[PCM_PARAMETERS] + len(self.__channel_strips) < len(parameters)
            else:
                raise 0 or AssertionError
        elif self.__assignment_mode == CSM_SENDS:
            return self.__send_mode_offset + len(self.__channel_strips) < len(self.song().return_tracks)
        else:
            return False

    def __available_routing_targets(self, channel_strip):
        raise self.__assignment_mode == CSM_IO or AssertionError
        t = channel_strip.assigned_track()
        if t:
            if self.__sub_mode_in_io_mode == CSM_IO_MODE_INPUT_MAIN:
                return t.input_routings
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_INPUT_SUB:
                return t.input_sub_routings
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_OUTPUT_MAIN:
                return t.output_routings
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_OUTPUT_SUB:
                return t.output_sub_routings
            else:
                raise 0 or AssertionError
        else:
            return None

    def __routing_target(self, channel_strip):
        raise self.__assignment_mode == CSM_IO or AssertionError
        t = channel_strip.assigned_track()
        if t:
            if self.__sub_mode_in_io_mode == CSM_IO_MODE_INPUT_MAIN:
                return t.current_input_routing
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_INPUT_SUB:
                return t.current_input_sub_routing
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_OUTPUT_MAIN:
                return t.current_output_routing
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_OUTPUT_SUB:
                return t.current_output_sub_routing
            else:
                raise 0 or AssertionError
        else:
            return None

    def __set_routing_target(self, channel_strip, target_string):
        raise self.__assignment_mode == CSM_IO or AssertionError
        t = channel_strip.assigned_track()
        if t:
            if self.__sub_mode_in_io_mode == CSM_IO_MODE_INPUT_MAIN:
                t.current_input_routing = target_string
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_INPUT_SUB:
                t.current_input_sub_routing = target_string
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_OUTPUT_MAIN:
                t.current_output_routing = target_string
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_OUTPUT_SUB:
                t.current_output_sub_routing = target_string
            else:
                raise 0 or AssertionError

    def __set_channel_offset(self, new_offset):
        """ Set and validate a new channel_strip offset, which shifts all available channel
            strips within all the available tracks or reutrn tracks
        """
        if new_offset < 0:
            new_offset = 0
        elif new_offset >= self.__controlled_num_of_tracks():
            new_offset = self.__controlled_num_of_tracks() - 1
        if self.__view_returns:
            self.__bank_cha_offset_returns = new_offset
        else:
            self.__bank_cha_offset = new_offset
        self.__main_display_controller.set_channel_offset(new_offset)
        self.__reassign_channel_strip_offsets()
        self.__reassign_channel_strip_parameters(for_display_only=False)
        self.__update_channel_strip_strings()
        self.request_rebuild_midi_map()

    def __set_assignment_mode(self, mode):
        for plugin in self.__displayed_plugins:
            if plugin != None:
                plugin.remove_name_listener(self.__update_plugin_names)

        self.__displayed_plugins = []
        if mode == CSM_PLUGINS:
            self.__assignment_mode = mode
            self.__main_display_controller.set_show_parameter_names(True)
            self.__set_plugin_mode(PCM_DEVICES)
        elif mode == CSM_SENDS:
            self.__main_display_controller.set_show_parameter_names(True)
            self.__assignment_mode = mode
        else:
            if mode == CSM_IO:
                for s in self.__channel_strips:
                    s.unlight_vpot_leds()

            self.__main_display_controller.set_show_parameter_names(False)
            if self.__assignment_mode != mode:
                self.__assignment_mode = mode
            elif self.__assignment_mode == CSM_IO:
                self.__switch_to_next_io_mode()
        self.__update_assignment_mode_leds()
        self.__update_assignment_display()
        self.__apply_meter_mode()
        self.__reassign_channel_strip_parameters(for_display_only=False)
        self.__update_channel_strip_strings()
        self.__update_page_switch_leds()
        if mode == CSM_PLUGINS:
            self.__update_vpot_leds_in_plugins_device_choose_mode()
        self.__update_flip_led()
        self.request_rebuild_midi_map()

    def __set_plugin_mode(self, new_mode):
        """ Set a new plugin sub-mode, which can be:
            1. Choosing the device to control (PCM_DEVICES)
            2. Controlling the chosen devices parameters (PCM_PARAMETERS)
        """
        if not (new_mode >= 0 and new_mode < PCM_NUMMODES):
            raise AssertionError
            if self.__plugin_mode != new_mode:
                self.__plugin_mode = new_mode
                self.__reassign_channel_strip_parameters(for_display_only=False)
                self.request_rebuild_midi_map()
                self.__plugin_mode == PCM_DEVICES and self.__update_vpot_leds_in_plugins_device_choose_mode()
            else:
                for plugin in self.__displayed_plugins:
                    if plugin != None:
                        plugin.remove_name_listener(self.__update_plugin_names)

                self.__displayed_plugins = []
            self.__update_page_switch_leds()
            self.__update_flip_led()
            self.__update_page_switch_leds()

    def __switch_to_prev_page(self):
        """ Switch to the previous page in the non track strip modes (choosing plugs, or
            controlling devices)
        """
        if self.__can_switch_to_prev_page():
            if self.__assignment_mode == CSM_PLUGINS:
                self.__plugin_mode_offsets[self.__plugin_mode] -= len(self.__channel_strips)
                if self.__plugin_mode == PCM_DEVICES:
                    self.__update_vpot_leds_in_plugins_device_choose_mode()
            elif self.__assignment_mode == CSM_SENDS:
                self.__send_mode_offset -= len(self.__channel_strips)
            self.__reassign_channel_strip_parameters(for_display_only=False)
            self.__update_channel_strip_strings()
            self.__update_page_switch_leds()
            self.request_rebuild_midi_map()

    def __switch_to_next_page(self):
        """ Switch to the next page in the non track strip modes (choosing plugs, or
            controlling devices)
        """
        if self.__can_switch_to_next_page():
            if self.__assignment_mode == CSM_PLUGINS:
                self.__plugin_mode_offsets[self.__plugin_mode] += len(self.__channel_strips)
                if self.__plugin_mode == PCM_DEVICES:
                    self.__update_vpot_leds_in_plugins_device_choose_mode()
            elif self.__assignment_mode == CSM_SENDS:
                self.__send_mode_offset += len(self.__channel_strips)
            else:
                raise 0 or AssertionError
            self.__reassign_channel_strip_parameters(for_display_only=False)
            self.__update_channel_strip_strings()
            self.__update_page_switch_leds()
            self.request_rebuild_midi_map()

    def __switch_to_next_io_mode(self):
        """ Step through the available IO modes (In/OutPut//Main/Sub)
        """
        self.__sub_mode_in_io_mode += 1
        if self.__sub_mode_in_io_mode > CSM_IO_LAST_MODE:
            self.__sub_mode_in_io_mode = CSM_IO_FIRST_MODE

    def __reassign_channel_strip_offsets(self):
        """ Update the channel strips bank_channel offset
        """
        for s in self.__channel_strips:
            s.set_bank_and_channel_offset(self.__strip_offset(), self.__view_returns, self.__within_track_added_or_deleted)

    def __reassign_channel_strip_parameters(self, for_display_only):
        """ Reevaluate all v-pot/fader -> parameter assignments
        """
        display_parameters = []
        for s in self.__channel_strips:
            vpot_param = (None, None)
            slider_param = (None, None)
            vpot_display_mode = VPOT_DISPLAY_SINGLE_DOT
            slider_display_mode = VPOT_DISPLAY_SINGLE_DOT
            if self.__assignment_mode == CSM_VOLPAN:
                if s.assigned_track() and s.assigned_track().has_audio_output:
                    vpot_param = (s.assigned_track().mixer_device.panning, 'Pan')
                    vpot_display_mode = VPOT_DISPLAY_BOOST_CUT
                    slider_param = (s.assigned_track().mixer_device.volume, 'Volume')
                    slider_display_mode = VPOT_DISPLAY_WRAP
            elif self.__assignment_mode == CSM_PLUGINS:
                vpot_param = self.__plugin_parameter(s.strip_index(), s.stack_offset())
                vpot_display_mode = VPOT_DISPLAY_WRAP
                if s.assigned_track() and s.assigned_track().has_audio_output:
                    slider_param = (s.assigned_track().mixer_device.volume, 'Volume')
                    slider_display_mode = VPOT_DISPLAY_WRAP
            elif self.__assignment_mode == CSM_SENDS:
                vpot_param = self.__send_parameter(s.strip_index(), s.stack_offset())
                vpot_display_mode = VPOT_DISPLAY_WRAP
                if s.assigned_track() and s.assigned_track().has_audio_output:
                    slider_param = (s.assigned_track().mixer_device.volume, 'Volume')
                    slider_display_mode = VPOT_DISPLAY_WRAP
            elif self.__assignment_mode == CSM_IO:
                if s.assigned_track() and s.assigned_track().has_audio_output:
                    slider_param = (s.assigned_track().mixer_device.volume, 'Volume')
            if self.__flip and self.__can_flip():
                if self.__any_slider_is_touched():
                    display_parameters.append(vpot_param)
                else:
                    display_parameters.append(slider_param)
                if not for_display_only:
                    s.set_v_pot_parameter(slider_param[0], slider_display_mode)
                    s.set_fader_parameter(vpot_param[0])
            else:
                if self.__any_slider_is_touched():
                    display_parameters.append(slider_param)
                else:
                    display_parameters.append(vpot_param)
                if not for_display_only:
                    s.set_v_pot_parameter(vpot_param[0], vpot_display_mode)
                    s.set_fader_parameter(slider_param[0])

        self.__main_display_controller.set_channel_offset(self.__strip_offset())
        if len(display_parameters):
            self.__main_display_controller.set_parameters(display_parameters)

    def __apply_meter_mode(self):
        """ Update the meter mode in the displays and channel strips """
        enabled = self.__meters_enabled and self.__assignment_mode is CSM_VOLPAN
        for s in self.__channel_strips:
            s.enable_meter_mode(enabled)

        self.__main_display_controller.enable_meters(enabled)

    def __toggle_flip(self):
        """ En/Disable V-Pot / Fader flipping
        """
        if self.__can_flip():
            self.__flip = not self.__flip
            self.__on_flip_changed()

    def __toggle_view_returns(self):
        """ Toggle if we want to control the return tracks or normal tracks
        """
        self.__view_returns = not self.__view_returns
        self.__update_view_returns_mode()

    def __update_assignment_mode_leds(self):
        """ Show which assignment mode is currently active """
        if self.__assignment_mode == CSM_IO:
            sid_on_switch = SID_ASSIGNMENT_IO
        elif self.__assignment_mode == CSM_SENDS:
            sid_on_switch = SID_ASSIGNMENT_SENDS
        elif self.__assignment_mode == CSM_VOLPAN:
            sid_on_switch = SID_ASSIGNMENT_PAN
        elif self.__assignment_mode == CSM_PLUGINS:
            sid_on_switch = SID_ASSIGNMENT_PLUG_INS
        else:
            raise 0 or AssertionError
            sid_on_switch = None
        for s in (SID_ASSIGNMENT_IO,
         SID_ASSIGNMENT_SENDS,
         SID_ASSIGNMENT_PAN,
         SID_ASSIGNMENT_PLUG_INS):
            if s == sid_on_switch:
                self.send_midi((NOTE_ON_STATUS, s, BUTTON_STATE_ON))
            else:
                self.send_midi((NOTE_ON_STATUS, s, BUTTON_STATE_OFF))

    def __update_assignment_display(self):
        """ Cryptically label the current assignment mode in the 2char display above
            the assignment buttons
        """
        if self.__assignment_mode == CSM_VOLPAN:
            ass_string = ['P', 'N']
        else:
            if self.__assignment_mode == CSM_PLUGINS or self.__assignment_mode == CSM_SENDS:
                ass_string = self.__last_attached_selected_track == self.song().master_track and ['M', 'A']
            for t in self.song().return_tracks:
                if t == self.__last_attached_selected_track:
                    ass_string = ['R', chr(ord('A') + list(self.song().return_tracks).index(t))]
                    break

            for t in self.song().visible_tracks:
                if t == self.__last_attached_selected_track:
                    ass_string = list('%.2d' % min(99, list(self.song().visible_tracks).index(t) + 1))
                    break

            if not ass_string:
                raise AssertionError
            elif self.__assignment_mode == CSM_IO:
                if self.__sub_mode_in_io_mode == CSM_IO_MODE_INPUT_MAIN:
                    ass_string = ['I', "'"]
                elif self.__sub_mode_in_io_mode == CSM_IO_MODE_INPUT_SUB:
                    ass_string = ['I', ',']
                elif self.__sub_mode_in_io_mode == CSM_IO_MODE_OUTPUT_MAIN:
                    ass_string = ['0', "'"]
                elif self.__sub_mode_in_io_mode == CSM_IO_MODE_OUTPUT_SUB:
                    ass_string = ['0', ',']
                else:
                    raise 0 or AssertionError
            else:
                raise 0 or AssertionError
        self.send_midi((CC_STATUS, 75, g7_seg_led_conv_table[ass_string[0]]))
        self.send_midi((CC_STATUS, 74, g7_seg_led_conv_table[ass_string[1]]))

    def __update_rude_solo_led(self):
        any_track_soloed = False
        for t in chain(self.song().tracks, self.song().return_tracks):
            if t.solo:
                any_track_soloed = True
                break

        if any_track_soloed:
            self.send_midi((NOTE_ON_STATUS, SELECT_RUDE_SOLO, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SELECT_RUDE_SOLO, BUTTON_STATE_OFF))

    def __update_page_switch_leds(self):
        """ visualize if the "prev" an "next" buttons can be pressed """
        if self.__can_switch_to_prev_page():
            self.send_midi((NOTE_ON_STATUS, SID_ASSIGNMENT_EQ, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_ASSIGNMENT_EQ, BUTTON_STATE_OFF))
        if self.__can_switch_to_next_page():
            self.send_midi((NOTE_ON_STATUS, SID_ASSIGNMENT_DYNAMIC, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_ASSIGNMENT_DYNAMIC, BUTTON_STATE_OFF))

    def __update_flip_led(self):
        if self.__flip and self.__can_flip():
            self.send_midi((NOTE_ON_STATUS, SID_FADERBANK_FLIP, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_FADERBANK_FLIP, BUTTON_STATE_OFF))

    def __update_vpot_leds_in_plugins_device_choose_mode(self):
        """ To be called in assignment mode CSM_PLUGINS, submode PCM_DEVICES only:
            This will enlighten all poties which can be pressed to choose a device
            for editing, and unlight all poties where pressing will have no effect
        """
        raise self.__assignment_mode == CSM_PLUGINS or AssertionError
        raise self.__plugin_mode == PCM_DEVICES or AssertionError
        sel_track = self.song().view.selected_track
        count = 0
        for s in self.__channel_strips:
            offset = self.__plugin_mode_offsets[self.__plugin_mode]
            if sel_track and offset + count >= 0 and offset + count < len(sel_track.devices):
                s.show_full_enlighted_poti()
            else:
                s.unlight_vpot_leds()
            count += 1

    def __update_channel_strip_strings(self):
        """ In IO mode, collect all strings that will be visible in the main display manually
        """
        if not self.__any_slider_is_touched():
            if self.__assignment_mode == CSM_IO:
                targets = []
                for s in self.__channel_strips:
                    if self.__routing_target(s):
                        targets.append(self.__routing_target(s))
                    else:
                        targets.append('')

                self.__main_display_controller.set_channel_strip_strings(targets)
            elif self.__assignment_mode == CSM_PLUGINS and self.__plugin_mode == PCM_DEVICES:
                for plugin in self.__displayed_plugins:
                    if plugin != None:
                        plugin.remove_name_listener(self.__update_plugin_names)

                self.__displayed_plugins = []
                sel_track = self.song().view.selected_track
                for i in range(len(self.__channel_strips)):
                    device_index = i + self.__plugin_mode_offsets[PCM_DEVICES]
                    if device_index >= 0 and device_index < len(sel_track.devices):
                        sel_track.devices[device_index].add_name_listener(self.__update_plugin_names)
                        self.__displayed_plugins.append(sel_track.devices[device_index])
                    else:
                        self.__displayed_plugins.append(None)

                self.__update_plugin_names()

    def __update_plugin_names(self):
        raise self.__assignment_mode == CSM_PLUGINS and self.__plugin_mode == PCM_DEVICES or AssertionError
        device_strings = []
        for plugin in self.__displayed_plugins:
            if plugin != None:
                device_strings.append(plugin.name)
            else:
                device_strings.append('')

        self.__main_display_controller.set_channel_strip_strings(device_strings)

    def __update_view_returns_mode(self):
        """ Update the control return tracks LED
        """
        if self.__view_returns:
            self.send_midi((NOTE_ON_STATUS, SID_FADERBANK_EDIT, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_FADERBANK_EDIT, BUTTON_STATE_OFF))
        self.__main_display_controller.set_show_return_track_names(self.__view_returns)
        self.__reassign_channel_strip_offsets()
        self.__reassign_channel_strip_parameters(for_display_only=False)
        self.request_rebuild_midi_map()

    def __on_selected_track_changed(self):
        """ Notifier, called as soon as the selected track has changed
        """
        st = self.__last_attached_selected_track
        if st and st.devices_has_listener(self.__on_selected_device_chain_changed):
            st.remove_devices_listener(self.__on_selected_device_chain_changed)
        self.__last_attached_selected_track = self.song().view.selected_track
        st = self.__last_attached_selected_track
        if st:
            st.add_devices_listener(self.__on_selected_device_chain_changed)
        if self.__assignment_mode == CSM_PLUGINS:
            self.__plugin_mode_offsets = [ 0 for x in range(PCM_NUMMODES) ]
            if self.__chosen_plugin != None:
                self.__chosen_plugin.remove_parameters_listener(self.__on_parameter_list_of_chosen_plugin_changed)
            self.__chosen_plugin = None
            self.__ordered_plugin_parameters = []
            self.__update_assignment_display()
            if self.__plugin_mode == PCM_DEVICES:
                self.__update_vpot_leds_in_plugins_device_choose_mode()
            else:
                self.__set_plugin_mode(PCM_DEVICES)
        elif self.__assignment_mode == CSM_SENDS:
            self.__reassign_channel_strip_parameters(for_display_only=False)
            self.__update_assignment_display()
            self.request_rebuild_midi_map()

    def __on_flip_changed(self):
        """ Update the flip button LED when the flip mode changed
        """
        self.__update_flip_led()
        if self.__can_flip():
            self.__update_assignment_display()
            self.__reassign_channel_strip_parameters(for_display_only=False)
            self.request_rebuild_midi_map()

    def __on_selected_device_chain_changed(self):
        if self.__assignment_mode == CSM_PLUGINS:
            if self.__plugin_mode == PCM_DEVICES:
                self.__update_vpot_leds_in_plugins_device_choose_mode()
                self.__update_page_switch_leds()
            elif self.__plugin_mode == PCM_PARAMETERS:
                if not self.__chosen_plugin:
                    self.__set_plugin_mode(PCM_DEVICES)
                elif self.__chosen_plugin not in self.__last_attached_selected_track.devices:
                    if self.__chosen_plugin != None:
                        self.__chosen_plugin.remove_parameters_listener(self.__on_parameter_list_of_chosen_plugin_changed)
                    self.__chosen_plugin = None
                    self.__set_plugin_mode(PCM_DEVICES)

    def __on_tracks_added_or_deleted(self):
        """ Notifier, called as soon as tracks where added, removed or moved
        """
        self.__within_track_added_or_deleted = True
        for t in chain(self.song().visible_tracks, self.song().return_tracks):
            if not t.solo_has_listener(self.__update_rude_solo_led):
                t.add_solo_listener(self.__update_rude_solo_led)
            if not t.has_audio_output_has_listener(self.__on_any_tracks_output_type_changed):
                t.add_has_audio_output_listener(self.__on_any_tracks_output_type_changed)

        if self.__send_mode_offset >= len(self.song().return_tracks):
            self.__send_mode_offset = 0
            self.__reassign_channel_strip_parameters(for_display_only=False)
            self.__update_channel_strip_strings()
        if self.__strip_offset() + len(self.__channel_strips) >= self.__controlled_num_of_tracks():
            self.__set_channel_offset(max(0, self.__controlled_num_of_tracks() - len(self.__channel_strips)))
        self.__reassign_channel_strip_parameters(for_display_only=False)
        self.__update_channel_strip_strings()
        if self.__assignment_mode == CSM_SENDS:
            self.__update_page_switch_leds()
        self.refresh_state()
        self.__main_display_controller.refresh_state()
        self.__within_track_added_or_deleted = False
        self.request_rebuild_midi_map()

    def __on_any_tracks_output_type_changed(self):
        """ called as soon as any device chain has changed (devices where
            added/removed/swapped...)
        """
        self.__reassign_channel_strip_parameters(for_display_only=False)
        self.request_rebuild_midi_map()

    def __on_parameter_list_of_chosen_plugin_changed(self):
        raise self.__chosen_plugin != None or AssertionError
        raise self.__plugin_mode == PCM_PARAMETERS or AssertionError
        self.__reorder_parameters()
        self.__reassign_channel_strip_parameters(for_display_only=False)
        self.request_rebuild_midi_map()

    def __reorder_parameters(self):
        result = []
        if self.__chosen_plugin:
            if self.__chosen_plugin.class_name in DEVICE_DICT.keys():
                device_banks = DEVICE_DICT[self.__chosen_plugin.class_name]
                for bank in device_banks:
                    for param_name in bank:
                        parameter_name = ''
                        parameter = get_parameter_by_name(self.__chosen_plugin, param_name)
                        if parameter:
                            parameter_name = parameter.name
                        result.append((parameter, parameter_name))

            else:
                result = [ (p, p.name) for p in self.__chosen_plugin.parameters[1:] ]
        self.__ordered_plugin_parameters = result
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl/consts.py
NOTE_OFF_STATUS = 128
NOTE_ON_STATUS = 144
CC_STATUS = 176
PB_STATUS = 224
SYSEX_DEVICE_TYPE = 20
SYSEX_DEVICE_TYPE_XT = 21
NUM_CHANNEL_STRIPS = 8
MASTER_CHANNEL_STRIP_INDEX = 8
BUTTON_STATE_OFF = 0
BUTTON_STATE_ON = 127
BUTTON_STATE_BLINKING = 1
BUTTON_PRESSED = 1
BUTTON_RELEASED = 0
NUM_CHARS_PER_DISPLAY_LINE = 54
SELECT_SMPTE_NOTE = 113
SELECT_BEATS_NOTE = 114
SELECT_RUDE_SOLO = 115
FID_PANNING_BASE = 16
JOG_WHEEL_CC_NO = 60
VPOT_DISPLAY_SINGLE_DOT = 0
VPOT_DISPLAY_BOOST_CUT = 1
VPOT_DISPLAY_WRAP = 2
VPOT_DISPLAY_SPREAD = 3
CSM_VOLPAN = 0
CSM_PLUGINS = 1
CSM_IO = 2
CSM_SENDS = 3
CSM_IO_MODE_INPUT_MAIN = 0
CSM_IO_MODE_INPUT_SUB = 1
CSM_IO_MODE_OUTPUT_MAIN = 2
CSM_IO_MODE_OUTPUT_SUB = 3
CSM_IO_FIRST_MODE = CSM_IO_MODE_INPUT_MAIN
CSM_IO_LAST_MODE = CSM_IO_MODE_OUTPUT_SUB
PCM_DEVICES = 0
PCM_PARAMETERS = 1
PCM_NUMMODES = 2
CLIP_STATE_INVALID = -1
CLIP_STOPPED = 0
CLIP_TRIGGERED = 1
CLIP_PLAYING = 2
g7_seg_led_conv_table = {' ': 0,
 'A': 1,
 'B': 2,
 'C': 3,
 'D': 4,
 'E': 5,
 'F': 6,
 'G': 7,
 'H': 8,
 'I': 9,
 'J': 10,
 'K': 11,
 'L': 12,
 'M': 13,
 'N': 14,
 'O': 15,
 'P': 16,
 'Q': 17,
 'R': 18,
 'S': 19,
 'T': 20,
 'U': 21,
 'V': 22,
 'W': 23,
 'X': 24,
 'Y': 25,
 'Z': 26,
 '\\': 34,
 '#': 35,
 '$': 36,
 '%': 37,
 '&': 38,
 "'": 39,
 '(': 40,
 ')': 41,
 '*': 42,
 '+': 43,
 ',': 44,
 '0': 48,
 '1': 49,
 '2': 50,
 '3': 51,
 '4': 52,
 '5': 53,
 '6': 54,
 '7': 55,
 '8': 56,
 '9': 57,
 ';': 59,
 '<': 60}
SID_FIRST = 0
SID_RECORD_ARM_BASE = 0
SID_RECORD_ARM_CH1 = 0
SID_RECORD_ARM_CH2 = 1
SID_RECORD_ARM_CH3 = 2
SID_RECORD_ARM_CH4 = 3
SID_RECORD_ARM_CH5 = 4
SID_RECORD_ARM_CH6 = 5
SID_RECORD_ARM_CH7 = 6
SID_RECORD_ARM_CH8 = 7
SID_SOLO_BASE = 8
SID_SOLO_CH1 = 8
SID_SOLO_CH2 = 9
SID_SOLO_CH3 = 10
SID_SOLO_CH4 = 11
SID_SOLO_CH5 = 12
SID_SOLO_CH6 = 13
SID_SOLO_CH7 = 14
SID_SOLO_CH8 = 15
SID_MUTE_BASE = 16
SID_MUTE_CH1 = 16
SID_MUTE_CH2 = 17
SID_MUTE_CH3 = 18
SID_MUTE_CH4 = 19
SID_MUTE_CH5 = 20
SID_MUTE_CH6 = 21
SID_MUTE_CH7 = 22
SID_MUTE_CH8 = 23
SID_SELECT_BASE = 24
SID_SELECT_CH1 = 24
SID_SELECT_CH2 = 25
SID_SELECT_CH3 = 26
SID_SELECT_CH4 = 27
SID_SELECT_CH5 = 28
SID_SELECT_CH6 = 29
SID_SELECT_CH7 = 30
SID_SELECT_CH8 = 31
SID_VPOD_PUSH_BASE = 32
SID_VPOD_PUSH_CH1 = 32
SID_VPOD_PUSH_CH2 = 33
SID_VPOD_PUSH_CH3 = 34
SID_VPOD_PUSH_CH4 = 35
SID_VPOD_PUSH_CH5 = 36
SID_VPOD_PUSH_CH6 = 37
SID_VPOD_PUSH_CH7 = 38
SID_VPOD_PUSH_CH8 = 39
channel_strip_switch_ids = range(SID_RECORD_ARM_BASE, SID_VPOD_PUSH_CH8 + 1)
SID_ASSIGNMENT_IO = 40
SID_ASSIGNMENT_SENDS = 41
SID_ASSIGNMENT_PAN = 42
SID_ASSIGNMENT_PLUG_INS = 43
SID_ASSIGNMENT_EQ = 44
SID_ASSIGNMENT_DYNAMIC = 45
channel_strip_assignment_switch_ids = range(SID_ASSIGNMENT_IO, SID_ASSIGNMENT_DYNAMIC + 1)
SID_FADERBANK_PREV_BANK = 46
SID_FADERBANK_NEXT_BANK = 47
SID_FADERBANK_PREV_CH = 48
SID_FADERBANK_NEXT_CH = 49
SID_FADERBANK_FLIP = 50
SID_FADERBANK_EDIT = 51
channel_strip_control_switch_ids = range(SID_ASSIGNMENT_IO, SID_FADERBANK_EDIT + 1)
SID_DISPLAY_NAME_VALUE = 52
SID_DISPLAY_SMPTE_BEATS = 53
display_switch_ids = range(SID_DISPLAY_NAME_VALUE, SID_DISPLAY_SMPTE_BEATS + 1)
SID_SOFTWARE_F1 = 54
SID_SOFTWARE_F2 = 55
SID_SOFTWARE_F3 = 56
SID_SOFTWARE_F4 = 57
SID_SOFTWARE_F5 = 58
SID_SOFTWARE_F6 = 59
SID_SOFTWARE_F7 = 60
SID_SOFTWARE_F8 = 61
SID_SOFTWARE_F9 = 62
SID_SOFTWARE_F10 = 63
SID_SOFTWARE_F11 = 64
SID_SOFTWARE_F12 = 65
SID_SOFTWARE_F13 = 66
SID_SOFTWARE_F14 = 67
SID_SOFTWARE_F15 = 68
SID_SOFTWARE_F16 = 69
function_key_control_switch_ids = range(SID_SOFTWARE_F1, SID_SOFTWARE_F16 + 1)
SID_MOD_SHIFT = 70
SID_MOD_OPTION = 71
SID_MOD_CTRL = 72
SID_MOD_ALT = 73
SID_AUTOMATION_ON = 74
SID_AUTOMATION_RECORD = 75
SID_AUTOMATION_SNAPSHOT = 77
SID_AUTOMATION_TOUCH = 78
SID_FUNC_UNDO = 76
SID_FUNC_CANCEL = 80
SID_FUNC_ENTER = 81
SID_FUNC_REDO = 79
SID_FUNC_MARKER = 82
SID_FUNC_MIXER = 83
software_controls_switch_ids = (SID_MOD_SHIFT,
 SID_MOD_OPTION,
 SID_MOD_CTRL,
 SID_MOD_ALT,
 SID_AUTOMATION_ON,
 SID_AUTOMATION_RECORD,
 SID_AUTOMATION_SNAPSHOT,
 SID_AUTOMATION_TOUCH,
 SID_FUNC_UNDO,
 SID_FUNC_CANCEL,
 SID_FUNC_ENTER,
 SID_FUNC_REDO,
 SID_FUNC_MARKER,
 SID_FUNC_MIXER)
SID_TRANSPORT_REWIND = 91
SID_TRANSPORT_FAST_FORWARD = 92
SID_TRANSPORT_STOP = 93
SID_TRANSPORT_PLAY = 94
SID_TRANSPORT_RECORD = 95
transport_control_switch_ids = range(SID_TRANSPORT_REWIND, SID_TRANSPORT_RECORD + 1)
SID_MARKER_FROM_PREV = 84
SID_MARKER_FROM_NEXT = 85
SID_MARKER_LOOP = 86
SID_MARKER_PI = 87
SID_MARKER_PO = 88
SID_MARKER_HOME = 89
SID_MARKER_END = 90
marker_control_switch_ids = (SID_MARKER_FROM_PREV,
 SID_MARKER_FROM_NEXT,
 SID_MARKER_LOOP,
 SID_MARKER_PI,
 SID_MARKER_PO,
 SID_MARKER_HOME,
 SID_MARKER_END)
SID_JOG_CURSOR_UP = 96
SID_JOG_CURSOR_DOWN = 97
SID_JOG_CURSOR_LEFT = 98
SID_JOG_CURSOR_RIGHT = 99
SID_JOG_ZOOM = 100
SID_JOG_SCRUB = 101
jog_wheel_switch_ids = range(SID_JOG_CURSOR_UP, SID_JOG_SCRUB + 1)
SID_USER_FOOT_SWITCHA = 102
SID_USER_FOOT_SWITCHB = 103
SID_FADER_TOUCH_SENSE_BASE = 104
SID_FADER_TOUCH_SENSE_CH1 = 104
SID_FADER_TOUCH_SENSE_CH2 = 105
SID_FADER_TOUCH_SENSE_CH3 = 106
SID_FADER_TOUCH_SENSE_CH4 = 107
SID_FADER_TOUCH_SENSE_CH5 = 108
SID_FADER_TOUCH_SENSE_CH6 = 109
SID_FADER_TOUCH_SENSE_CH7 = 110
SID_FADER_TOUCH_SENSE_CH8 = 111
SID_FADER_TOUCH_SENSE_MASTER = 112
fader_touch_switch_ids = range(SID_FADER_TOUCH_SENSE_CH1, SID_FADER_TOUCH_SENSE_MASTER + 1)
SID_LAST = 112
########NEW FILE########
__FILENAME__ = MackieControl
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl/MackieControl.py
from consts import *
from MainDisplay import MainDisplay
from MainDisplayController import MainDisplayController
from TimeDisplay import TimeDisplay
from ChannelStrip import ChannelStrip, MasterChannelStrip
from ChannelStripController import ChannelStripController
from SoftwareController import SoftwareController
from Transport import Transport
import Live
import MidiRemoteScript

class MackieControl:
    """Main class that establishes the Mackie Control <-> Live interaction. It acts
       as a container/manager for all the Mackie Control sub-components like ChannelStrips,
       Displays and so on.
       Futher it is glued to Lives MidiRemoteScript C instance, which will forward some
       notifications to us, and lets us forward some requests that are needed beside the
       general Live API (see 'send_midi' or 'request_rebuild_midi_map').
    """

    def __init__(self, c_instance):
        self.__c_instance = c_instance
        self.__components = []
        self.__main_display = MainDisplay(self)
        self.__components.append(self.__main_display)
        self.__main_display_controller = MainDisplayController(self, self.__main_display)
        self.__components.append(self.__main_display_controller)
        self.__time_display = TimeDisplay(self)
        self.__components.append(self.__time_display)
        self.__software_controller = SoftwareController(self)
        self.__components.append(self.__software_controller)
        self.__transport = Transport(self)
        self.__components.append(self.__transport)
        self.__channel_strips = [ ChannelStrip(self, i) for i in range(NUM_CHANNEL_STRIPS) ]
        for s in self.__channel_strips:
            self.__components.append(s)

        self.__master_strip = MasterChannelStrip(self)
        self.__components.append(self.__master_strip)
        self.__channel_strip_controller = ChannelStripController(self, self.__channel_strips, self.__master_strip, self.__main_display_controller)
        self.__components.append(self.__channel_strip_controller)
        self.__shift_is_pressed = False
        self.__option_is_pressed = False
        self.__ctrl_is_pressed = False
        self.__alt_is_pressed = False

    def disconnect(self):
        for c in self.__components:
            c.destroy()

    def connect_script_instances(self, instanciated_scripts):
        """Called by the Application as soon as all scripts are initialized.
           You can connect yourself to other running scripts here, as we do it
           connect the extension modules (MackieControlXTs).
        """
        try:
            from MackieControlXT.MackieControlXT import MackieControlXT
        except:
            print 'failed to load the MackieControl XT script (might not be installed)'

        found_self = False
        right_extensions = []
        left_extensions = []
        for s in instanciated_scripts:
            if s is self:
                found_self = True
            elif isinstance(s, MackieControlXT):
                s.set_mackie_control_main(self)
                if found_self:
                    right_extensions.append(s)
                else:
                    left_extensions.append(s)

        raise found_self or AssertionError
        self.__main_display_controller.set_controller_extensions(left_extensions, right_extensions)
        self.__channel_strip_controller.set_controller_extensions(left_extensions, right_extensions)

    def application(self):
        """returns a reference to the application that we are running in"""
        return Live.Application.get_application()

    def song(self):
        """returns a reference to the Live Song that we do interact with"""
        return self.__c_instance.song()

    def handle(self):
        """returns a handle to the c_interface that is needed when forwarding MIDI events
           via the MIDI map
        """
        return self.__c_instance.handle()

    def refresh_state(self):
        for c in self.__components:
            c.refresh_state()

    def is_extension(self):
        return False

    def request_rebuild_midi_map(self):
        """ To be called from any components, as soon as their internal state changed in a
        way, that we do need to remap the mappings that are processed directly by the
        Live engine.
        Dont assume that the request will immediately result in a call to
        your build_midi_map function. For performance reasons this is only
        called once per GUI frame."""
        self.__c_instance.request_rebuild_midi_map()

    def build_midi_map(self, midi_map_handle):
        """New MIDI mappings can only be set when the scripts 'build_midi_map' function
        is invoked by our C instance sibling. Its either invoked when we have requested it
        (see 'request_rebuild_midi_map' above) or when due to a change in Lives internal state,
        a rebuild is needed."""
        for s in self.__channel_strips:
            s.build_midi_map(midi_map_handle)

        self.__master_strip.build_midi_map(midi_map_handle)
        for i in range(SID_FIRST, SID_LAST + 1):
            if i not in function_key_control_switch_ids:
                Live.MidiMap.forward_midi_note(self.handle(), midi_map_handle, 0, i)

        Live.MidiMap.forward_midi_cc(self.handle(), midi_map_handle, 0, JOG_WHEEL_CC_NO)

    def update_display(self):
        for c in self.__components:
            c.on_update_display_timer()

    def send_midi(self, midi_event_bytes):
        """Use this function to send MIDI events through Live to the _real_ MIDI devices
        that this script is assigned to."""
        self.__c_instance.send_midi(midi_event_bytes)

    def receive_midi(self, midi_bytes):
        if midi_bytes[0] & 240 == NOTE_ON_STATUS or midi_bytes[0] & 240 == NOTE_OFF_STATUS:
            note = midi_bytes[1]
            value = BUTTON_PRESSED if midi_bytes[2] > 0 else BUTTON_RELEASED
            if note in range(SID_FIRST, SID_LAST + 1):
                if note in display_switch_ids:
                    self.__handle_display_switch_ids(note, value)
                if note in channel_strip_switch_ids + fader_touch_switch_ids:
                    for s in self.__channel_strips:
                        s.handle_channel_strip_switch_ids(note, value)

                if note in channel_strip_control_switch_ids:
                    self.__channel_strip_controller.handle_assignment_switch_ids(note, value)
                if note in function_key_control_switch_ids:
                    self.__software_controller.handle_function_key_switch_ids(note, value)
                if note in software_controls_switch_ids:
                    self.__software_controller.handle_software_controls_switch_ids(note, value)
                if note in transport_control_switch_ids:
                    self.__transport.handle_transport_switch_ids(note, value)
                if note in marker_control_switch_ids:
                    self.__transport.handle_marker_switch_ids(note, value)
                if note in jog_wheel_switch_ids:
                    self.__transport.handle_jog_wheel_switch_ids(note, value)
        elif midi_bytes[0] & 240 == CC_STATUS:
            cc_no = midi_bytes[1]
            cc_value = midi_bytes[2]
            if cc_no == JOG_WHEEL_CC_NO:
                self.__transport.handle_jog_wheel_rotation(cc_value)
            elif cc_no in range(FID_PANNING_BASE, FID_PANNING_BASE + NUM_CHANNEL_STRIPS):
                for s in self.__channel_strips:
                    s.handle_vpot_rotation(cc_no - FID_PANNING_BASE, cc_value)

    def can_lock_to_devices(self):
        return False

    def suggest_input_port(self):
        return ''

    def suggest_output_port(self):
        return ''

    def suggest_map_mode(self, cc_no, channel):
        result = Live.MidiMap.MapMode.absolute
        if cc_no in range(FID_PANNING_BASE, FID_PANNING_BASE + NUM_CHANNEL_STRIPS):
            result = Live.MidiMap.MapMode.relative_signed_bit
        return result

    def shift_is_pressed(self):
        return self.__shift_is_pressed

    def set_shift_is_pressed(self, pressed):
        self.__shift_is_pressed = pressed

    def option_is_pressed(self):
        return self.__option_is_pressed

    def set_option_is_pressed(self, pressed):
        self.__option_is_pressed = pressed

    def control_is_pressed(self):
        return self.__control_is_pressed

    def set_control_is_pressed(self, pressed):
        self.__control_is_pressed = pressed

    def alt_is_pressed(self):
        return self.__alt_is_pressed

    def set_alt_is_pressed(self, pressed):
        self.__alt_is_pressed = pressed

    def __handle_display_switch_ids(self, switch_id, value):
        if switch_id == SID_DISPLAY_NAME_VALUE:
            if value == BUTTON_PRESSED:
                self.__channel_strip_controller.toggle_meter_mode()
        elif switch_id == SID_DISPLAY_SMPTE_BEATS:
            if value == BUTTON_PRESSED:
                self.__time_display.toggle_mode()
########NEW FILE########
__FILENAME__ = MackieControlComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl/MackieControlComponent.py
from consts import *
import Live

class MackieControlComponent:
    """Baseclass for every 'sub component' of the Mackie Control. Just offers some """

    def __init__(self, main_script):
        self.__main_script = main_script

    def destroy(self):
        self.__main_script = None

    def main_script(self):
        return self.__main_script

    def shift_is_pressed(self):
        return self.__main_script.shift_is_pressed()

    def option_is_pressed(self):
        return self.__main_script.option_is_pressed()

    def control_is_pressed(self):
        return self.__main_script.control_is_pressed()

    def alt_is_pressed(self):
        return self.__main_script.alt_is_pressed()

    def song(self):
        return self.__main_script.song()

    def script_handle(self):
        return self.__main_script.handle()

    def application(self):
        return self.__main_script.application()

    def send_midi(self, bytes):
        self.__main_script.send_midi(bytes)

    def request_rebuild_midi_map(self):
        self.__main_script.request_rebuild_midi_map()
########NEW FILE########
__FILENAME__ = MainDisplay
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl/MainDisplay.py
from MackieControlComponent import *

class MainDisplay(MackieControlComponent):
    """ Representing one main 2 row display of a Mackie Control or Extension
    """

    def __init__(self, main_script):
        MackieControlComponent.__init__(self, main_script)
        self.__stack_offset = 0
        self.__last_send_messages = [[], []]

    def destroy(self):
        NUM_CHARS_PER_DISPLAY_LINE = 54
        upper_message = 'Ableton Live'.center(NUM_CHARS_PER_DISPLAY_LINE)
        self.send_display_string(upper_message, 0, 0)
        lower_message = 'Device is offline'.center(NUM_CHARS_PER_DISPLAY_LINE)
        self.send_display_string(lower_message, 1, 0)
        MackieControlComponent.destroy(self)

    def stack_offset(self):
        return self.__stack_offset

    def set_stack_offset(self, offset):
        """This is the offset that one gets by 'stacking' several MackieControl XTs:
           the first is at index 0, the second at 8, etc ...
        """
        self.__stack_offset = offset

    def send_display_string(self, display_string, display_row, cursor_offset):
        if display_row == 0:
            offset = cursor_offset
        elif display_row == 1:
            offset = NUM_CHARS_PER_DISPLAY_LINE + 2 + cursor_offset
        else:
            raise 0 or AssertionError
        message_string = [ ord(c) for c in display_string ]
        for i in range(len(message_string)):
            if message_string[i] >= 128:
                message_string[i] = 0

        if self.__last_send_messages[display_row] != message_string:
            self.__last_send_messages[display_row] = message_string
            if self.main_script().is_extension():
                device_type = SYSEX_DEVICE_TYPE_XT
            else:
                device_type = SYSEX_DEVICE_TYPE
            display_sysex = (240,
             0,
             0,
             102,
             device_type,
             18,
             offset) + tuple(message_string) + (247,)
            self.send_midi(display_sysex)

    def refresh_state(self):
        self.__last_send_messages = [[], []]

    def on_update_display_timer(self):
        pass
########NEW FILE########
__FILENAME__ = MainDisplayController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl/MainDisplayController.py
from MackieControlComponent import *

class MainDisplayController(MackieControlComponent):
    """ Controlling all available main displays (the display above the channel strips),
        which will be only one when only using the 'main' Mackie Control, and severals
        when using at least one Mackie Control XT, attached to the main Mackie Control
    
        The Displays can be run in two modes: Channel and Global mode:
        - In channel mode 2*6 characters can be shown for each channel strip
        - In global mode, you can setup the two 54 charchter lines to whatever you want
    
        See 'class ChannelStripController' for descriptions of the stack_index or details
        about the different assignment modes.
    """

    def __init__(self, main_script, display):
        MackieControlComponent.__init__(self, main_script)
        self.__left_extensions = []
        self.__right_extensions = []
        self.__displays = [display]
        self.__own_display = display
        self.__parameters = [ [] for x in range(NUM_CHANNEL_STRIPS) ]
        self.__channel_strip_strings = [ '' for x in range(NUM_CHANNEL_STRIPS) ]
        self.__channel_strip_mode = True
        self.__show_parameter_names = False
        self.__bank_channel_offset = 0
        self.__meters_enabled = False
        self.__show_return_tracks = False

    def destroy(self):
        self.enable_meters(False)
        MackieControlComponent.destroy(self)

    def set_controller_extensions(self, left_extensions, right_extensions):
        """ Called from the main script (after all scripts where initialized), to let us
            know where and how many MackieControlXT are installed.
        """
        self.__left_extensions = left_extensions
        self.__right_extensions = right_extensions
        self.__displays = []
        stack_offset = 0
        for le in left_extensions:
            self.__displays.append(le.main_display())
            le.main_display().set_stack_offset(stack_offset)
            stack_offset += NUM_CHANNEL_STRIPS

        self.__displays.append(self.__own_display)
        self.__own_display.set_stack_offset(stack_offset)
        stack_offset += NUM_CHANNEL_STRIPS
        for re in right_extensions:
            self.__displays.append(re.main_display())
            re.main_display().set_stack_offset(stack_offset)
            stack_offset += NUM_CHANNEL_STRIPS

        self.__parameters = [ [] for x in range(len(self.__displays) * NUM_CHANNEL_STRIPS) ]
        self.__channel_strip_strings = [ '' for x in range(len(self.__displays) * NUM_CHANNEL_STRIPS) ]
        self.refresh_state()

    def enable_meters(self, enabled):
        if self.__meters_enabled != enabled:
            self.__meters_enabled = enabled
            self.refresh_state()

    def set_show_parameter_names(self, enable):
        self.__show_parameter_names = enable

    def set_channel_offset(self, channel_offset):
        self.__bank_channel_offset = channel_offset

    def parameters(self):
        return self.__parameters

    def set_parameters(self, parameters):
        if parameters:
            self.set_channel_strip_strings(None)
        for d in self.__displays:
            self.__parameters = parameters

    def channel_strip_strings(self):
        return self.__channel_strip_strings

    def set_channel_strip_strings(self, channel_strip_strings):
        if channel_strip_strings:
            self.set_parameters(None)
        self.__channel_strip_strings = channel_strip_strings

    def set_show_return_track_names(self, show_returns):
        self.__show_return_tracks = show_returns

    def refresh_state(self):
        for d in self.__displays:
            d.refresh_state()

    def on_update_display_timer(self):
        strip_index = 0
        for display in self.__displays:
            if self.__channel_strip_mode:
                upper_string = u''
                lower_string = u''
                track_index_range = range(self.__bank_channel_offset + display.stack_offset(), self.__bank_channel_offset + display.stack_offset() + NUM_CHANNEL_STRIPS)
                if self.__show_return_tracks:
                    tracks = self.song().return_tracks
                else:
                    tracks = self.song().visible_tracks
                for t in track_index_range:
                    if self.__parameters and self.__show_parameter_names:
                        if self.__parameters[strip_index]:
                            upper_string += self.__generate_6_char_string(self.__parameters[strip_index][1])
                        else:
                            upper_string += self.__generate_6_char_string('')
                    elif t < len(tracks):
                        upper_string += self.__generate_6_char_string(tracks[t].name)
                    else:
                        upper_string += self.__generate_6_char_string('')
                    upper_string += ' '
                    if self.__parameters and self.__parameters[strip_index]:
                        if self.__parameters[strip_index][0]:
                            lower_string += self.__generate_6_char_string(unicode(self.__parameters[strip_index][0]))
                        else:
                            lower_string += self.__generate_6_char_string('')
                    elif self.__channel_strip_strings and self.__channel_strip_strings[strip_index]:
                        lower_string += self.__generate_6_char_string(self.__channel_strip_strings[strip_index])
                    else:
                        lower_string += self.__generate_6_char_string('')
                    lower_string += ' '
                    strip_index += 1

                display.send_display_string(upper_string, 0, 0)
                if not self.__meters_enabled:
                    display.send_display_string(lower_string, 1, 0)
            else:
                ascii_message = '< _1234 guck ma #!?:;_ >'
                if not self.__test:
                    self.__test = 0
                self.__test = self.__test + 1
                if self.__test > NUM_CHARS_PER_DISPLAY_LINE - len(ascii_message):
                    self.__test = 0
                self.send_display_string(ascii_message, 0, self.__test)

    def __generate_6_char_string(self, display_string):
        if not display_string:
            return '      '
        if len(display_string.strip()) > 6 and display_string.endswith('dB') and display_string.find('.') != -1:
            display_string = display_string[:-2]
        if len(display_string) > 6:
            for um in [' ',
             'i',
             'o',
             'u',
             'e',
             'a']:
                while len(display_string) > 6 and display_string.rfind(um, 1) != -1:
                    um_pos = display_string.rfind(um, 1)
                    display_string = display_string[:um_pos] + display_string[um_pos + 1:]

        else:
            display_string = display_string.center(6)
        ret = u''
        for i in range(6):
            ret += display_string[i]

        raise len(ret) == 6 or AssertionError
        return ret
########NEW FILE########
__FILENAME__ = SoftwareController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl/SoftwareController.py
from MackieControlComponent import *

class SoftwareController(MackieControlComponent):
    """Representing the buttons above the transport, including the basic: """

    def __init__(self, main_script):
        MackieControlComponent.__init__(self, main_script)
        self.__last_can_undo_state = False
        self.__last_can_redo_state = False
        av = self.application().view
        av.add_is_view_visible_listener('Session', self.__update_session_arranger_button_led)
        av.add_is_view_visible_listener('Detail/Clip', self.__update_detail_sub_view_button_led)
        av.add_is_view_visible_listener('Browser', self.__update_browser_button_led)
        av.add_is_view_visible_listener('Detail', self.__update_detail_button_led)
        self.song().view.add_draw_mode_listener(self.__update_draw_mode_button_led)
        self.song().add_back_to_arranger_listener(self.__update_back_to_arranger_button_led)

    def destroy(self):
        av = self.application().view
        av.remove_is_view_visible_listener('Session', self.__update_session_arranger_button_led)
        av.remove_is_view_visible_listener('Detail/Clip', self.__update_detail_sub_view_button_led)
        av.remove_is_view_visible_listener('Browser', self.__update_browser_button_led)
        av.remove_is_view_visible_listener('Detail', self.__update_detail_button_led)
        self.song().view.remove_draw_mode_listener(self.__update_draw_mode_button_led)
        self.song().remove_back_to_arranger_listener(self.__update_back_to_arranger_button_led)
        for note in software_controls_switch_ids:
            self.send_midi((NOTE_ON_STATUS, note, BUTTON_STATE_OFF))

        for note in function_key_control_switch_ids:
            self.send_midi((NOTE_ON_STATUS, note, BUTTON_STATE_OFF))

        MackieControlComponent.destroy(self)

    def handle_function_key_switch_ids(self, switch_id, value):
        raise 0 or AssertionError

    def handle_software_controls_switch_ids(self, switch_id, value):
        if switch_id == SID_MOD_SHIFT:
            self.main_script().set_shift_is_pressed(value == BUTTON_PRESSED)
        elif switch_id == SID_MOD_OPTION:
            self.main_script().set_option_is_pressed(value == BUTTON_PRESSED)
        elif switch_id == SID_MOD_CTRL:
            self.main_script().set_control_is_pressed(value == BUTTON_PRESSED)
        elif switch_id == SID_MOD_ALT:
            self.main_script().set_alt_is_pressed(value == BUTTON_PRESSED)
        elif switch_id == SID_AUTOMATION_ON:
            if value == BUTTON_PRESSED:
                self.__toggle_session_arranger_is_visible()
        elif switch_id == SID_AUTOMATION_RECORD:
            if value == BUTTON_PRESSED:
                self.__toggle_detail_sub_view()
        elif switch_id == SID_AUTOMATION_SNAPSHOT:
            if value == BUTTON_PRESSED:
                self.__toggle_browser_is_visible()
        elif switch_id == SID_AUTOMATION_TOUCH:
            if value == BUTTON_PRESSED:
                self.__toggle_detail_is_visible()
        elif switch_id == SID_FUNC_UNDO:
            if value == BUTTON_PRESSED:
                self.song().undo()
        elif switch_id == SID_FUNC_REDO:
            if value == BUTTON_PRESSED:
                self.song().redo()
        elif switch_id == SID_FUNC_CANCEL:
            if value == BUTTON_PRESSED:
                self.__toggle_back_to_arranger()
        elif switch_id == SID_FUNC_ENTER:
            if value == BUTTON_PRESSED:
                self.__toggle_draw_mode()
        elif switch_id == SID_FUNC_MARKER:
            if value == BUTTON_PRESSED:
                self.song().set_or_delete_cue()
        elif switch_id == SID_FUNC_MIXER:
            if value == BUTTON_PRESSED:
                self.__toggle_follow_song()

    def refresh_state(self):
        self.main_script().set_shift_is_pressed(False)
        self.main_script().set_option_is_pressed(False)
        self.main_script().set_control_is_pressed(False)
        self.main_script().set_alt_is_pressed(False)
        self.__update_session_arranger_button_led()
        self.__update_detail_sub_view_button_led()
        self.__update_browser_button_led()
        self.__update_detail_button_led()
        self.__update_undo_button_led()
        self.__update_redo_button_led()
        self.__update_draw_mode_button_led()
        self.__update_back_to_arranger_button_led()

    def on_update_display_timer(self):
        if self.__last_can_undo_state != self.song().can_undo:
            self.__last_can_undo_state = self.song().can_undo
            self.__update_undo_button_led()
        if self.__last_can_redo_state != self.song().can_redo:
            self.__last_can_redo_state = self.song().can_redo
            self.__update_redo_button_led()

    def __toggle_session_arranger_is_visible(self):
        if self.application().view.is_view_visible('Session'):
            if self.shift_is_pressed():
                self.application().view.focus_view('Session')
            else:
                self.application().view.hide_view('Session')
        elif not self.application().view.is_view_visible('Arranger'):
            raise AssertionError
            self.shift_is_pressed() and self.application().view.focus_view('Arranger')
        else:
            self.application().view.hide_view('Arranger')

    def __toggle_detail_sub_view(self):
        if self.application().view.is_view_visible('Detail/Clip'):
            if self.shift_is_pressed():
                self.application().view.focus_view('Detail/Clip')
            else:
                self.application().view.show_view('Detail/DeviceChain')
        elif self.shift_is_pressed():
            self.application().view.focus_view('Detail/DeviceChain')
        else:
            self.application().view.show_view('Detail/Clip')

    def __toggle_browser_is_visible(self):
        if self.application().view.is_view_visible('Browser'):
            if self.shift_is_pressed():
                self.application().view.focus_view('Browser')
            else:
                self.application().view.hide_view('Browser')
        else:
            self.application().view.show_view('Browser')

    def __toggle_detail_is_visible(self):
        if self.application().view.is_view_visible('Detail'):
            if self.shift_is_pressed():
                self.application().view.focus_view('Detail')
            else:
                self.application().view.hide_view('Detail')
        else:
            self.application().view.show_view('Detail')

    def __toggle_back_to_arranger(self):
        self.song().back_to_arranger = not self.song().back_to_arranger

    def __toggle_draw_mode(self):
        self.song().view.draw_mode = not self.song().view.draw_mode

    def __toggle_follow_song(self):
        self.song().view.follow_song = not self.song().view.follow_song

    def __update_session_arranger_button_led(self):
        if self.application().view.is_view_visible('Session'):
            self.send_midi((NOTE_ON_STATUS, SID_AUTOMATION_ON, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_AUTOMATION_ON, BUTTON_STATE_OFF))

    def __update_detail_sub_view_button_led(self):
        if self.application().view.is_view_visible('Detail/Clip'):
            self.send_midi((NOTE_ON_STATUS, SID_AUTOMATION_RECORD, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_AUTOMATION_RECORD, BUTTON_STATE_OFF))

    def __update_browser_button_led(self):
        if self.application().view.is_view_visible('Browser'):
            self.send_midi((NOTE_ON_STATUS, SID_AUTOMATION_SNAPSHOT, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_AUTOMATION_SNAPSHOT, BUTTON_STATE_OFF))

    def __update_detail_button_led(self):
        if self.application().view.is_view_visible('Detail'):
            self.send_midi((NOTE_ON_STATUS, SID_AUTOMATION_TOUCH, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_AUTOMATION_TOUCH, BUTTON_STATE_OFF))

    def __update_undo_button_led(self):
        if self.song().can_undo:
            self.send_midi((NOTE_ON_STATUS, SID_FUNC_UNDO, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_FUNC_UNDO, BUTTON_STATE_OFF))

    def __update_redo_button_led(self):
        if self.song().can_redo:
            self.send_midi((NOTE_ON_STATUS, SID_FUNC_REDO, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_FUNC_REDO, BUTTON_STATE_OFF))

    def __update_back_to_arranger_button_led(self):
        if self.song().back_to_arranger:
            self.send_midi((NOTE_ON_STATUS, SID_FUNC_CANCEL, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_FUNC_CANCEL, BUTTON_STATE_OFF))

    def __update_draw_mode_button_led(self):
        if self.song().view.draw_mode:
            self.send_midi((NOTE_ON_STATUS, SID_FUNC_ENTER, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_FUNC_ENTER, BUTTON_STATE_OFF))
########NEW FILE########
__FILENAME__ = TimeDisplay
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl/TimeDisplay.py
from MackieControlComponent import *

class TimeDisplay(MackieControlComponent):
    """Represents the Mackie Controls Time-Display, plus the two LED's that show the"""

    def __init__(self, main_script):
        MackieControlComponent.__init__(self, main_script)
        self.__main_script = main_script
        self.__show_beat_time = False
        self.__smpt_format = Live.Song.TimeFormat.smpte_25
        self.__last_send_time = []
        self.show_beats()

    def destroy(self):
        self.clear_display()
        MackieControlComponent.destroy(self)

    def show_beats(self):
        self.__show_beat_time = True
        self.send_midi((NOTE_ON_STATUS, SELECT_BEATS_NOTE, BUTTON_STATE_ON))
        self.send_midi((NOTE_ON_STATUS, SELECT_SMPTE_NOTE, BUTTON_STATE_OFF))

    def show_smpte(self, smpte_mode):
        self.__show_beat_time = False
        self.__smpt_format = smpte_mode
        self.send_midi((NOTE_ON_STATUS, SELECT_BEATS_NOTE, BUTTON_STATE_OFF))
        self.send_midi((NOTE_ON_STATUS, SELECT_SMPTE_NOTE, BUTTON_STATE_ON))

    def toggle_mode(self):
        if self.__show_beat_time:
            self.show_smpte(self.__smpt_format)
        else:
            self.show_beats()

    def clear_display(self):
        time_string = [ ' ' for i in range(10) ]
        self.__send_time_string(time_string, show_points=False)
        self.send_midi((NOTE_ON_STATUS, SELECT_BEATS_NOTE, BUTTON_STATE_OFF))
        self.send_midi((NOTE_ON_STATUS, SELECT_SMPTE_NOTE, BUTTON_STATE_OFF))

    def refresh_state(self):
        self.show_beats()
        self.__last_send_time = []

    def on_update_display_timer(self):
        """Called by a timer which gets called every 100 ms. We will simply check if the"""
        if self.__show_beat_time:
            time_string = str(self.song().get_current_beats_song_time())
        else:
            time_string = str(self.song().get_current_smpte_song_time(self.__smpt_format))
        time_string = [ c for c in time_string if c not in ('.', ':') ]
        if self.__last_send_time != time_string:
            self.__last_send_time = time_string
            self.__send_time_string(time_string, show_points=True)

    def __send_time_string(self, time_string, show_points):
        raise len(time_string) >= 10 or AssertionError
        for c in range(0, 10):
            char = time_string[9 - c].upper()
            char_code = g7_seg_led_conv_table[char]
            if show_points and c in (3, 5, 7):
                char_code += 64
            self.send_midi((176, 64 + c, char_code))
########NEW FILE########
__FILENAME__ = Transport
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl/Transport.py
from MackieControlComponent import *

class Transport(MackieControlComponent):
    """Representing the transport section of the Mackie Control: """

    def __init__(self, main_script):
        MackieControlComponent.__init__(self, main_script)
        self.__forward_button_down = False
        self.____rewind_button_down = False
        self.__zoom_button_down = False
        self.__scrub_button_down = False
        self.__cursor_left_is_down = False
        self.__cursor_right_is_down = False
        self.__cursor_up_is_down = False
        self.__cursor_down_is_down = False
        self.__cursor_repeat_delay = 0
        self.__transport_repeat_delay = 0
        self.____fast_forward_counter = 0
        self.__fast___rewind_counter = 0
        self.__jog_step_count_forward = 0
        self.__jog_step_count_backwards = 0
        self.__last_focussed_clip_play_state = CLIP_STATE_INVALID
        self.song().add_record_mode_listener(self.__update_record_button_led)
        self.song().add_is_playing_listener(self.__update_play_button_led)
        self.song().add_loop_listener(self.__update_loop_button_led)
        self.song().add_punch_out_listener(self.__update_punch_out_button_led)
        self.song().add_punch_in_listener(self.__update_punch_in_button_led)
        self.song().add_can_jump_to_prev_cue_listener(self.__update_prev_cue_button_led)
        self.song().add_can_jump_to_next_cue_listener(self.__update_next_cue_button_led)
        self.application().view.add_is_view_visible_listener('Session', self.__on_session_is_visible_changed)
        self.refresh_state()

    def destroy(self):
        self.song().remove_record_mode_listener(self.__update_record_button_led)
        self.song().remove_is_playing_listener(self.__update_play_button_led)
        self.song().remove_loop_listener(self.__update_loop_button_led)
        self.song().remove_punch_out_listener(self.__update_punch_out_button_led)
        self.song().remove_punch_in_listener(self.__update_punch_in_button_led)
        self.song().remove_can_jump_to_prev_cue_listener(self.__update_prev_cue_button_led)
        self.song().remove_can_jump_to_next_cue_listener(self.__update_next_cue_button_led)
        self.application().view.remove_is_view_visible_listener('Session', self.__on_session_is_visible_changed)
        for note in transport_control_switch_ids:
            self.send_midi((NOTE_ON_STATUS, note, BUTTON_STATE_OFF))

        for note in jog_wheel_switch_ids:
            self.send_midi((NOTE_ON_STATUS, note, BUTTON_STATE_OFF))

        for note in marker_control_switch_ids:
            self.send_midi((NOTE_ON_STATUS, note, BUTTON_STATE_OFF))

        MackieControlComponent.destroy(self)

    def refresh_state(self):
        self.__update_play_button_led()
        self.__update_record_button_led()
        self.__update_prev_cue_button_led()
        self.__update_next_cue_button_led()
        self.__update_loop_button_led()
        self.__update_punch_in_button_led()
        self.__update_punch_out_button_led()
        self.__forward_button_down = False
        self.____rewind_button_down = False
        self.__zoom_button_down = False
        self.__scrub_button_down = False
        self.__cursor_left_is_down = False
        self.__cursor_right_is_down = False
        self.__cursor_up_is_down = False
        self.__cursor_down_is_down = False
        self.__cursor_repeat_delay = 0
        self.__transport_repeat_delay = 0
        self.____fast_forward_counter = 0
        self.__fast___rewind_counter = 0
        self.__jog_step_count_forward = 0
        self.__jog_step_count_backwards = 0
        self.__last_focussed_clip_play_state = CLIP_STATE_INVALID
        self.__update_forward_rewind_leds()
        self.__update_zoom_button_led()
        self.__update_scrub_button_led()

    def session_is_visible(self):
        return self.application().view.is_view_visible('Session')

    def selected_clip_slot(self):
        return self.song().view.highlighted_clip_slot

    def on_update_display_timer(self):
        if self.__transport_repeat_delay > 2:
            if self.alt_is_pressed():
                base_acceleration = 1
            else:
                base_acceleration = self.song().signature_numerator
            if self.song().is_playing:
                base_acceleration *= 4
            if self.__forward_button_down:
                if not self.____rewind_button_down:
                    if self.__forward_button_down:
                        self.____fast_forward_counter += 1
                        self.__fast___rewind_counter -= 4
                        if not self.alt_is_pressed():
                            self.__fast_forward(base_acceleration + max(1, self.____fast_forward_counter / 4))
                        else:
                            self.__fast_forward(base_acceleration)
                    if self.____rewind_button_down:
                        self.__fast___rewind_counter += 1
                        self.____fast_forward_counter -= 4
                        if not self.alt_is_pressed():
                            self.__rewind(base_acceleration + max(1, self.__fast___rewind_counter / 4))
                        else:
                            self.__rewind(base_acceleration)
            else:
                self.__transport_repeat_delay += 1
            if self.__cursor_repeat_delay > 2:
                if self.__cursor_left_is_down:
                    self.__on_cursor_left_pressed()
                if self.__cursor_right_is_down:
                    self.__on_cursor_right_pressed()
                if self.__cursor_up_is_down:
                    self.__on_cursor_up_pressed()
                if self.__cursor_down_is_down:
                    self.__on_cursor_down_pressed()
            else:
                self.__cursor_repeat_delay += 1
            self.session_is_visible() and self.__update_zoom_led_in_session()

    def handle_marker_switch_ids(self, switch_id, value):
        if switch_id == SID_MARKER_FROM_PREV:
            if value == BUTTON_PRESSED:
                self.__jump_to_prev_cue()
        elif switch_id == SID_MARKER_FROM_NEXT:
            if value == BUTTON_PRESSED:
                self.__jump_to_next_cue()
        elif switch_id == SID_MARKER_LOOP:
            if value == BUTTON_PRESSED:
                self.__toggle_loop()
        elif switch_id == SID_MARKER_PI:
            if value == BUTTON_PRESSED:
                if self.control_is_pressed():
                    self.__set_loopstart_from_cur_position()
                else:
                    self.__toggle_punch_in()
        elif switch_id == SID_MARKER_PO:
            if value == BUTTON_PRESSED:
                if self.control_is_pressed():
                    self.__set_loopend_from_cur_position()
                else:
                    self.__toggle_punch_out()
        elif switch_id == SID_MARKER_HOME:
            if value == BUTTON_PRESSED:
                self.__goto_home()
        elif switch_id == SID_MARKER_END:
            if value == BUTTON_PRESSED:
                self.__goto_end()

    def handle_transport_switch_ids(self, switch_id, value):
        if switch_id == SID_TRANSPORT_REWIND:
            if value == BUTTON_PRESSED:
                self.__rewind()
                self.____rewind_button_down = True
            elif value == BUTTON_RELEASED:
                self.____rewind_button_down = False
                self.__fast___rewind_counter = 0
            self.__update_forward_rewind_leds()
        elif switch_id == SID_TRANSPORT_FAST_FORWARD:
            if value == BUTTON_PRESSED:
                self.__fast_forward()
                self.__forward_button_down = True
            elif value == BUTTON_RELEASED:
                self.__forward_button_down = False
                self.____fast_forward_counter = 0
            self.__update_forward_rewind_leds()
        elif switch_id == SID_TRANSPORT_STOP:
            if value == BUTTON_PRESSED:
                self.__stop_song()
        elif switch_id == SID_TRANSPORT_PLAY:
            if value == BUTTON_PRESSED:
                self.__start_song()
        elif switch_id == SID_TRANSPORT_RECORD:
            if value == BUTTON_PRESSED:
                self.__toggle_record()

    def handle_jog_wheel_rotation(self, value):
        backwards = value >= 64
        if self.control_is_pressed():
            if self.alt_is_pressed():
                step = 0.1
            else:
                step = 1.0
            if backwards:
                amount = -(value - 64)
            else:
                amount = value
            tempo = max(20, min(999, self.song().tempo + amount * step))
            self.song().tempo = tempo
        elif self.session_is_visible():
            num_steps_per_session_scroll = 4
            if backwards:
                self.__jog_step_count_backwards += 1
                if self.__jog_step_count_backwards >= num_steps_per_session_scroll:
                    self.__jog_step_count_backwards = 0
                    step = -1
                else:
                    step = 0
            else:
                self.__jog_step_count_forward += 1
                if self.__jog_step_count_forward >= num_steps_per_session_scroll:
                    self.__jog_step_count_forward = 0
                    step = 1
                else:
                    step = 0
            if step:
                new_index = list(self.song().scenes).index(self.song().view.selected_scene) + step
                new_index = min(len(self.song().scenes) - 1, max(0, new_index))
                self.song().view.selected_scene = self.song().scenes[new_index]
        else:
            if backwards:
                step = max(1.0, (value - 64) / 2.0)
            else:
                step = max(1.0, value / 2.0)
            if self.song().is_playing:
                step *= 4.0
            if self.alt_is_pressed():
                step /= 4.0
            if self.__scrub_button_down:
                if backwards:
                    self.song().scrub_by(-step)
                else:
                    self.song().scrub_by(step)
            elif backwards:
                self.song().jump_by(-step)
            else:
                self.song().jump_by(step)

    def handle_jog_wheel_switch_ids(self, switch_id, value):
        if switch_id == SID_JOG_CURSOR_UP:
            if value == BUTTON_PRESSED:
                self.__cursor_up_is_down = True
                self.__cursor_repeat_delay = 0
                self.__on_cursor_up_pressed()
            elif value == BUTTON_RELEASED:
                self.__cursor_up_is_down = False
        elif switch_id == SID_JOG_CURSOR_DOWN:
            if value == BUTTON_PRESSED:
                self.__cursor_down_is_down = True
                self.__cursor_repeat_delay = 0
                self.__on_cursor_down_pressed()
            elif value == BUTTON_RELEASED:
                self.__cursor_down_is_down = False
        elif switch_id == SID_JOG_CURSOR_LEFT:
            if value == BUTTON_PRESSED:
                self.__cursor_left_is_down = True
                self.__cursor_repeat_delay = 0
                self.__on_cursor_left_pressed()
            elif value == BUTTON_RELEASED:
                self.__cursor_left_is_down = False
        elif switch_id == SID_JOG_CURSOR_RIGHT:
            if value == BUTTON_PRESSED:
                self.__cursor_right_is_down = True
                self.__cursor_repeat_delay = 0
                self.__on_cursor_right_pressed()
            elif value == BUTTON_RELEASED:
                self.__cursor_right_is_down = False
        elif switch_id == SID_JOG_ZOOM:
            if value == BUTTON_PRESSED:
                if self.session_is_visible():
                    if self.selected_clip_slot():
                        if self.alt_is_pressed():
                            self.selected_clip_slot().has_stop_button = not self.selected_clip_slot().has_stop_button
                        elif self.option_is_pressed():
                            self.selected_clip_slot().stop()
                        else:
                            self.selected_clip_slot().fire()
                else:
                    self.__zoom_button_down = not self.__zoom_button_down
                    self.__update_zoom_button_led()
        elif switch_id == SID_JOG_SCRUB:
            if value == BUTTON_PRESSED:
                if self.session_is_visible():
                    if self.option_is_pressed():
                        self.song().stop_all_clips()
                    else:
                        self.song().view.selected_scene.fire_as_selected()
                else:
                    self.__scrub_button_down = not self.__scrub_button_down
                    self.__update_scrub_button_led()

    def __on_cursor_up_pressed(self):
        nav = Live.Application.Application.View.NavDirection
        if self.__zoom_button_down:
            self.application().view.zoom_view(nav.up, '', self.alt_is_pressed())
        else:
            self.application().view.scroll_view(nav.up, '', self.alt_is_pressed())

    def __on_cursor_down_pressed(self):
        nav = Live.Application.Application.View.NavDirection
        if self.__zoom_button_down:
            self.application().view.zoom_view(nav.down, '', self.alt_is_pressed())
        else:
            self.application().view.scroll_view(nav.down, '', self.alt_is_pressed())

    def __on_cursor_left_pressed(self):
        nav = Live.Application.Application.View.NavDirection
        if self.__zoom_button_down:
            self.application().view.zoom_view(nav.left, '', self.alt_is_pressed())
        else:
            self.application().view.scroll_view(nav.left, '', self.alt_is_pressed())

    def __on_cursor_right_pressed(self):
        nav = Live.Application.Application.View.NavDirection
        if self.__zoom_button_down:
            self.application().view.zoom_view(nav.right, '', self.alt_is_pressed())
        else:
            self.application().view.scroll_view(nav.right, '', self.alt_is_pressed())

    def __toggle_record(self):
        self.song().record_mode = not self.song().record_mode

    def __rewind(self, acceleration = 1):
        beats = acceleration
        self.song().jump_by(-beats)

    def __fast_forward(self, acceleration = 1):
        beats = acceleration
        self.song().jump_by(beats)

    def __stop_song(self):
        self.song().stop_playing()

    def __start_song(self):
        if self.shift_is_pressed():
            if not self.song().is_playing:
                self.song().continue_playing()
            else:
                self.song().stop_playing()
        elif self.control_is_pressed():
            self.song().play_selection()
        else:
            self.song().start_playing()

    def __toggle_follow(self):
        self.song().follow_song = not self.song().follow_song

    def __toggle_loop(self):
        self.song().loop = not self.song().loop

    def __toggle_punch_in(self):
        self.song().punch_in = not self.song().punch_in

    def __toggle_punch_out(self):
        self.song().punch_out = not self.song().punch_out

    def __jump_to_prev_cue(self):
        self.song().jump_to_prev_cue()

    def __jump_to_next_cue(self):
        self.song().jump_to_next_cue()

    def __set_loopstart_from_cur_position(self):
        if self.song().current_song_time < self.song().loop_start + self.song().loop_length:
            old_loop_start = self.song().loop_start
            self.song().loop_start = self.song().current_song_time
            self.song().loop_length += old_loop_start - self.song().loop_start

    def __set_loopend_from_cur_position(self):
        if self.song().current_song_time > self.song().loop_start:
            self.song().loop_length = self.song().current_song_time - self.song().loop_start

    def __goto_home(self):
        self.song().current_song_time = 0

    def __goto_end(self):
        self.song().current_song_time = self.song().last_event_time

    def __on_session_is_visible_changed(self):
        if not self.session_is_visible():
            self.__update_zoom_button_led()

    def __update_zoom_led_in_session(self):
        if self.session_is_visible():
            clip_slot = self.selected_clip_slot()
            if clip_slot and clip_slot.clip:
                if clip_slot.clip.is_triggered:
                    state = CLIP_TRIGGERED
                elif clip_slot.clip.is_playing:
                    state = CLIP_PLAYING
                else:
                    state = CLIP_STOPPED
            else:
                state = CLIP_STOPPED
            if state != self.__last_focussed_clip_play_state:
                self.__last_focussed_clip_play_state = state
                if state == CLIP_PLAYING:
                    self.send_midi((NOTE_ON_STATUS, SID_JOG_ZOOM, BUTTON_STATE_ON))
                elif state == CLIP_TRIGGERED:
                    self.send_midi((NOTE_ON_STATUS, SID_JOG_ZOOM, BUTTON_STATE_BLINKING))
                else:
                    self.send_midi((NOTE_ON_STATUS, SID_JOG_ZOOM, BUTTON_STATE_OFF))

    def __update_forward_rewind_leds(self):
        if self.__forward_button_down:
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_FAST_FORWARD, BUTTON_STATE_ON))
            self.__transport_repeat_delay = 0
        else:
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_FAST_FORWARD, BUTTON_STATE_OFF))
        if self.____rewind_button_down:
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_REWIND, BUTTON_STATE_ON))
            self.__transport_repeat_delay = 0
        else:
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_REWIND, BUTTON_STATE_OFF))

    def __update_zoom_button_led(self):
        if self.__zoom_button_down:
            self.send_midi((NOTE_ON_STATUS, SID_JOG_ZOOM, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_JOG_ZOOM, BUTTON_STATE_OFF))

    def __update_scrub_button_led(self):
        if self.__scrub_button_down:
            self.send_midi((NOTE_ON_STATUS, SID_JOG_SCRUB, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_JOG_SCRUB, BUTTON_STATE_OFF))

    def __update_play_button_led(self):
        if self.song().is_playing:
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_PLAY, BUTTON_STATE_ON))
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_STOP, BUTTON_STATE_OFF))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_PLAY, BUTTON_STATE_OFF))
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_STOP, BUTTON_STATE_ON))

    def __update_record_button_led(self):
        if self.song().record_mode:
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_RECORD, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_RECORD, BUTTON_STATE_OFF))

    def __update_follow_song_button_led(self):
        if self.song().follow_song:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_FROM_PREV, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_FROM_PREV, BUTTON_STATE_OFF))

    def __update_prev_cue_button_led(self):
        if self.song().can_jump_to_prev_cue:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_FROM_PREV, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_FROM_PREV, BUTTON_STATE_OFF))

    def __update_next_cue_button_led(self):
        if self.song().can_jump_to_next_cue:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_FROM_NEXT, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_FROM_NEXT, BUTTON_STATE_OFF))

    def __update_loop_button_led(self):
        if self.song().loop:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_LOOP, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_LOOP, BUTTON_STATE_OFF))

    def __update_punch_in_button_led(self):
        if self.song().punch_in:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_PI, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_PI, BUTTON_STATE_OFF))

    def __update_punch_out_button_led(self):
        if self.song().punch_out:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_PO, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_PO, BUTTON_STATE_OFF))
########NEW FILE########
__FILENAME__ = MackieControlXT
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControlXT/MackieControlXT.py
from MackieControl.consts import *
from MackieControl.MainDisplay import MainDisplay
from MackieControl.ChannelStrip import ChannelStrip
import Live

class MackieControlXT:
    """Extension for a Mackie Control.
       Only works hand in hand with a 'main' Mackie Control as master
    """

    def __init__(self, c_instance):
        self.__c_instance = c_instance
        self.__components = []
        self.__main_display = MainDisplay(self)
        self.__components.append(self.__main_display)
        self.__channel_strips = [ ChannelStrip(self, i) for i in range(NUM_CHANNEL_STRIPS) ]
        for s in self.__channel_strips:
            self.__components.append(s)

        self.__mackie_control_main = None

    def disconnect(self):
        for c in self.__components:
            c.destroy()

    def connect_script_instances(self, instanciated_scripts):
        pass

    def is_extension(self):
        return True

    def mackie_control_main(self, mackie_control_main):
        return self.__mackie_control_main

    def set_mackie_control_main(self, mackie_control_main):
        self.__mackie_control_main = mackie_control_main

    def channel_strips(self):
        return self.__channel_strips

    def main_display(self):
        return self.__main_display

    def shift_is_pressed(self):
        is_pressed = False
        if self.__mackie_control_main != None:
            is_pressed = self.__mackie_control_main.shift_is_pressed()
        return is_pressed

    def option_is_pressed(self):
        is_pressed = False
        if self.__mackie_control_main != None:
            is_pressed = self.__mackie_control_main.option_is_pressed()
        return is_pressed

    def control_is_pressed(self):
        is_pressed = False
        if self.__mackie_control_main != None:
            is_pressed = self.__mackie_control_main.control_is_pressed()
        return is_pressed

    def alt_is_pressed(self):
        is_pressed = False
        if self.__mackie_control_main != None:
            is_pressed = self.__mackie_control_main.alt_is_pressed()
        return is_pressed

    def application(self):
        return Live.Application.get_application()

    def song(self):
        return self.__c_instance.song()

    def handle(self):
        return self.__c_instance.handle()

    def refresh_state(self):
        for c in self.__components:
            c.refresh_state()

    def request_rebuild_midi_map(self):
        self.__c_instance.request_rebuild_midi_map()

    def build_midi_map(self, midi_map_handle):
        for s in self.__channel_strips:
            s.build_midi_map(midi_map_handle)

        for i in channel_strip_switch_ids + fader_touch_switch_ids:
            Live.MidiMap.forward_midi_note(self.handle(), midi_map_handle, 0, i)

    def update_display(self):
        for c in self.__components:
            c.on_update_display_timer()

    def send_midi(self, midi_event_bytes):
        self.__c_instance.send_midi(midi_event_bytes)

    def receive_midi(self, midi_bytes):
        if midi_bytes[0] & 240 == NOTE_ON_STATUS or midi_bytes[0] & 240 == NOTE_OFF_STATUS:
            note = midi_bytes[1]
            value = BUTTON_PRESSED if midi_bytes[2] > 0 else BUTTON_RELEASED
            if note in range(SID_FIRST, SID_LAST + 1):
                if note in channel_strip_switch_ids + fader_touch_switch_ids:
                    for s in self.__channel_strips:
                        s.handle_channel_strip_switch_ids(note, value)

        elif midi_bytes[0] & 240 == CC_STATUS:
            cc_no = midi_bytes[1]
            cc_value = midi_bytes[2]
            if cc_no in range(FID_PANNING_BASE, FID_PANNING_BASE + NUM_CHANNEL_STRIPS):
                for s in self.__channel_strips:
                    s.handle_vpot_rotation(cc_no - FID_PANNING_BASE, cc_value)

    def can_lock_to_devices(self):
        return False

    def suggest_input_port(self):
        return ''

    def suggest_output_port(self):
        return ''

    def suggest_map_mode(self, cc_no, channel):
        result = Live.MidiMap.MapMode.absolute
        if cc_no in range(FID_PANNING_BASE, FID_PANNING_BASE + NUM_CHANNEL_STRIPS):
            result = Live.MidiMap.MapMode.relative_signed_bit
        return result
########NEW FILE########
__FILENAME__ = ChannelStrip
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl_Classic/ChannelStrip.py
from MackieControlComponent import *
from itertools import chain

class ChannelStrip(MackieControlComponent):
    """Represets a Channel Strip of the Mackie Control, which consists out of the"""

    def __init__(self, main_script, strip_index):
        MackieControlComponent.__init__(self, main_script)
        self.__channel_strip_controller = None
        self.__is_touched = False
        self.__strip_index = strip_index
        self.__stack_offset = 0
        self.__bank_and_channel_offset = 0
        self.__assigned_track = None
        self.__v_pot_parameter = None
        self.__v_pot_display_mode = VPOT_DISPLAY_SINGLE_DOT
        self.__fader_parameter = None
        self.__signal_led_enabled = True
        self.__meters_enabled = False
        self.__last_meter_value = -1
        self.__send_meter_mode()
        self.__within_track_added_or_deleted = False
        self.__within_destroy = False
        self.set_bank_and_channel_offset(offset=0, show_return_tracks=False, within_track_added_or_deleted=False)

    def destroy(self):
        self.__within_destroy = True
        if self.__assigned_track:
            self.__remove_listeners()
        self.__assigned_track = None
        self.send_midi((208, 0 + (self.__strip_index << 4)))
        self.__signal_led_enabled = False
        self.__meters_enabled = False
        self.__send_meter_mode()
        self.refresh_state()
        MackieControlComponent.destroy(self)
        self.__within_destroy = False

    def set_channel_strip_controller(self, channel_strip_controller):
        self.__channel_strip_controller = channel_strip_controller

    def strip_index(self):
        return self.__strip_index

    def assigned_track(self):
        return self.__assigned_track

    def is_touched(self):
        return self.__is_touched

    def set_is_touched(self, touched):
        self.__is_touched = touched

    def stack_offset(self):
        return self.__stack_offset

    def set_stack_offset(self, offset):
        """This is the offset that one gets by 'stacking' several MackieControl XTs:
           the first is at index 0, the second at 8, etc ...
        """
        self.__stack_offset = offset

    def set_bank_and_channel_offset(self, offset, show_return_tracks, within_track_added_or_deleted):
        final_track_index = self.__strip_index + self.__stack_offset + offset
        self.__within_track_added_or_deleted = within_track_added_or_deleted
        if show_return_tracks:
            tracks = self.song().return_tracks
        else:
            tracks = self.song().visible_tracks
        if final_track_index < len(tracks):
            new_track = tracks[final_track_index]
        else:
            new_track = None
        if new_track != self.__assigned_track:
            if self.__assigned_track:
                self.__remove_listeners()
            self.__assigned_track = new_track
            if self.__assigned_track:
                self.__add_listeners()
        self.refresh_state()
        self.__within_track_added_or_deleted = False

    def v_pot_parameter(self):
        return self.__v_pot_parameter

    def set_v_pot_parameter(self, parameter, display_mode = VPOT_DISPLAY_SINGLE_DOT):
        self.__v_pot_display_mode = display_mode
        self.__v_pot_parameter = parameter
        if not parameter:
            self.unlight_vpot_leds()

    def fader_parameter(self):
        return self.__fader_parameter

    def set_fader_parameter(self, parameter):
        self.__fader_parameter = parameter
        if not parameter:
            self.reset_fader()

    def enable_meter_mode(self, Enabled):
        self.__meters_enabled = Enabled
        self.__send_meter_mode()

    def enable_signal_leds(self, Enable):
        self.__signal_led_enabled = Enable
        self.__send_meter_mode()

    def reset_fader(self):
        self.send_midi((PB_STATUS + self.__strip_index, 0, 0))

    def unlight_vpot_leds(self):
        self.send_midi((CC_STATUS + 0, 48 + self.__strip_index, 32))

    def show_full_enlighted_poti(self):
        self.send_midi((CC_STATUS + 0, 48 + self.__strip_index, VPOT_DISPLAY_WRAP * 16 + 11))

    def handle_channel_strip_switch_ids(self, sw_id, value):
        if sw_id in range(SID_RECORD_ARM_BASE, SID_RECORD_ARM_BASE + NUM_CHANNEL_STRIPS):
            if sw_id - SID_RECORD_ARM_BASE is self.__strip_index:
                if value == BUTTON_PRESSED:
                    if self.song().exclusive_arm:
                        exclusive = not self.control_is_pressed()
                    else:
                        exclusive = self.control_is_pressed()
                    self.__toggle_arm_track(exclusive)
        elif sw_id in range(SID_SOLO_BASE, SID_SOLO_BASE + NUM_CHANNEL_STRIPS):
            if sw_id - SID_SOLO_BASE is self.__strip_index:
                if value == BUTTON_PRESSED:
                    if self.song().exclusive_solo:
                        exclusive = not self.control_is_pressed()
                    else:
                        exclusive = self.control_is_pressed()
                    self.__toggle_solo_track(exclusive)
        elif sw_id in range(SID_MUTE_BASE, SID_MUTE_BASE + NUM_CHANNEL_STRIPS):
            if sw_id - SID_MUTE_BASE is self.__strip_index:
                if value == BUTTON_PRESSED:
                    self.__toggle_mute_track()
        elif sw_id in range(SID_SELECT_BASE, SID_SELECT_BASE + NUM_CHANNEL_STRIPS):
            if sw_id - SID_SELECT_BASE is self.__strip_index:
                if value == BUTTON_PRESSED:
                    self.__select_track()
        elif sw_id in range(SID_VPOD_PUSH_BASE, SID_VPOD_PUSH_BASE + NUM_CHANNEL_STRIPS):
            if sw_id - SID_VPOD_PUSH_BASE is self.__strip_index:
                if value == BUTTON_PRESSED:
                    self.__channel_strip_controller.handle_pressed_v_pot(self.__strip_index, self.__stack_offset)
        elif sw_id in fader_touch_switch_ids:
            if sw_id - SID_FADER_TOUCH_SENSE_BASE is self.__strip_index:
                if value == BUTTON_PRESSED or value == BUTTON_RELEASED:
                    touched = value == BUTTON_PRESSED
                    self.set_is_touched(touched)
                    self.__channel_strip_controller.handle_fader_touch(self.__strip_index, self.__stack_offset, touched)

    def handle_vpot_rotation(self, strip_index, cc_value):
        if strip_index is self.__strip_index:
            self.__channel_strip_controller.handle_vpot_rotation(self.__strip_index, self.__stack_offset, cc_value)

    def refresh_state(self):
        if not self.__within_track_added_or_deleted:
            self.__update_track_is_selected_led()
        self.__update_solo_led()
        self.__update_mute_led()
        self.__update_arm_led()
        if not self.__within_destroy and self.__assigned_track != None:
            self.__send_meter_mode()
            self.__last_meter_value = -1
        if not self.__assigned_track:
            self.reset_fader()
            self.unlight_vpot_leds()

    def on_update_display_timer(self):
        if self.__signal_led_enabled or self.__meters_enabled:
            if self.__assigned_track:
                if self.__assigned_track.can_be_armed and self.__assigned_track.arm:
                    meter_value = self.__assigned_track.input_meter_level
                else:
                    meter_value = self.__assigned_track.output_meter_level
            else:
                meter_value = 0.0
            meter_byte = int(meter_value * 12.0) + (self.__strip_index << 4)
            if self.__last_meter_value != meter_value or meter_value != 0.0:
                self.__last_meter_value = meter_value
                self.send_midi((208, meter_byte))

    def build_midi_map(self, midi_map_handle):
        needs_takeover = False
        if self.__fader_parameter:
            feeback_rule = Live.MidiMap.PitchBendFeedbackRule()
            feeback_rule.channel = self.__strip_index
            feeback_rule.value_pair_map = tuple()
            feeback_rule.delay_in_ms = 200.0
            Live.MidiMap.map_midi_pitchbend_with_feedback_map(midi_map_handle, self.__fader_parameter, self.__strip_index, feeback_rule, not needs_takeover)
            Live.MidiMap.send_feedback_for_parameter(midi_map_handle, self.__fader_parameter)
        else:
            channel = self.__strip_index
            Live.MidiMap.forward_midi_pitchbend(self.script_handle(), midi_map_handle, channel)
        if self.__v_pot_parameter:
            if self.__v_pot_display_mode == VPOT_DISPLAY_SPREAD:
                range_end = 7
            else:
                range_end = 12
            feeback_rule = Live.MidiMap.CCFeedbackRule()
            feeback_rule.channel = 0
            feeback_rule.cc_no = 48 + self.__strip_index
            feeback_rule.cc_value_map = tuple([ self.__v_pot_display_mode * 16 + x for x in range(1, range_end) ])
            feeback_rule.delay_in_ms = -1.0
            Live.MidiMap.map_midi_cc_with_feedback_map(midi_map_handle, self.__v_pot_parameter, 0, FID_PANNING_BASE + self.__strip_index, Live.MidiMap.MapMode.relative_signed_bit, feeback_rule, needs_takeover)
            Live.MidiMap.send_feedback_for_parameter(midi_map_handle, self.__v_pot_parameter)
        else:
            channel = 0
            cc_no = FID_PANNING_BASE + self.__strip_index
            Live.MidiMap.forward_midi_cc(self.script_handle(), midi_map_handle, channel, cc_no)

    def __assigned_track_index(self):
        index = 0
        for t in chain(self.song().visible_tracks, self.song().return_tracks):
            if t == self.__assigned_track:
                return index
            index += 1

        if not (self.__assigned_track and 0):
            raise AssertionError

    def __add_listeners(self):
        if self.__assigned_track.can_be_armed:
            self.__assigned_track.add_arm_listener(self.__update_arm_led)
        self.__assigned_track.add_mute_listener(self.__update_mute_led)
        self.__assigned_track.add_solo_listener(self.__update_solo_led)
        if not self.song().view.selected_track_has_listener(self.__update_track_is_selected_led):
            self.song().view.add_selected_track_listener(self.__update_track_is_selected_led)

    def __remove_listeners(self):
        if self.__assigned_track.can_be_armed:
            self.__assigned_track.remove_arm_listener(self.__update_arm_led)
        self.__assigned_track.remove_mute_listener(self.__update_mute_led)
        self.__assigned_track.remove_solo_listener(self.__update_solo_led)
        self.song().view.remove_selected_track_listener(self.__update_track_is_selected_led)

    def __send_meter_mode(self):
        on_mode = 0
        off_mode = 0
        if self.__signal_led_enabled:
            on_mode = on_mode | 1
        if self.__meters_enabled:
            on_mode = on_mode | 2
        if self.__assigned_track:
            mode = on_mode
        else:
            mode = off_mode
        if self.main_script().is_extension():
            device_type = SYSEX_DEVICE_TYPE_XT
        else:
            device_type = SYSEX_DEVICE_TYPE
        self.send_midi((240,
         0,
         0,
         102,
         device_type,
         32,
         self.__strip_index,
         mode,
         247))

    def __toggle_arm_track(self, exclusive):
        if self.__assigned_track and self.__assigned_track.can_be_armed:
            self.__assigned_track.arm = not self.__assigned_track.arm
            if exclusive:
                for t in self.song().tracks:
                    if t != self.__assigned_track:
                        t.arm = False

    def __toggle_mute_track(self):
        if self.__assigned_track:
            self.__assigned_track.mute = not self.__assigned_track.mute

    def __toggle_solo_track(self, exclusive):
        if self.__assigned_track:
            self.__assigned_track.solo = not self.__assigned_track.solo
            if exclusive:
                for t in chain(self.song().tracks, self.song().return_tracks):
                    if t != self.__assigned_track:
                        t.solo = False

    def __select_track(self):
        if self.__assigned_track:
            all_tracks = tuple(self.song().visible_tracks) + tuple(self.song().return_tracks)
            if self.song().view.selected_track != all_tracks[self.__assigned_track_index()]:
                self.song().view.selected_track = all_tracks[self.__assigned_track_index()]
            elif self.application().view.is_view_visible('Arranger'):
                if self.__assigned_track:
                    self.__assigned_track.view.is_collapsed = not self.__assigned_track.view.is_collapsed

    def __update_arm_led(self):
        track = self.__assigned_track
        if track and track.can_be_armed and track.arm:
            self.send_midi((NOTE_ON_STATUS, SID_RECORD_ARM_BASE + self.__strip_index, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_RECORD_ARM_BASE + self.__strip_index, BUTTON_STATE_OFF))

    def __update_mute_led(self):
        if self.__assigned_track and self.__assigned_track.mute:
            self.send_midi((NOTE_ON_STATUS, SID_MUTE_BASE + self.__strip_index, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_MUTE_BASE + self.__strip_index, BUTTON_STATE_OFF))

    def __update_solo_led(self):
        if self.__assigned_track and self.__assigned_track.solo:
            self.send_midi((NOTE_ON_STATUS, SID_SOLO_BASE + self.__strip_index, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_SOLO_BASE + self.__strip_index, BUTTON_STATE_OFF))

    def __update_track_is_selected_led(self):
        if self.song().view.selected_track == self.__assigned_track:
            self.send_midi((NOTE_ON_STATUS, SID_SELECT_BASE + self.__strip_index, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_SELECT_BASE + self.__strip_index, BUTTON_STATE_OFF))


class MasterChannelStrip(MackieControlComponent):

    def __init__(self, main_script):
        MackieControlComponent.__init__(self, main_script)
        self.__strip_index = MASTER_CHANNEL_STRIP_INDEX
        self.__assigned_track = self.song().master_track

    def destroy(self):
        self.reset_fader()
        MackieControlComponent.destroy(self)

    def set_channel_strip_controller(self, channel_strip_controller):
        pass

    def handle_channel_strip_switch_ids(self, sw_id, value):
        pass

    def refresh_state(self):
        pass

    def on_update_display_timer(self):
        pass

    def enable_meter_mode(self, Enabled):
        pass

    def reset_fader(self):
        self.send_midi((PB_STATUS + self.__strip_index, 0, 0))

    def build_midi_map(self, midi_map_handle):
        needs_takeover = False
        if self.__assigned_track:
            volume = self.__assigned_track.mixer_device.volume
            feeback_rule = Live.MidiMap.PitchBendFeedbackRule()
            feeback_rule.channel = self.__strip_index
            feeback_rule.value_pair_map = tuple()
            feeback_rule.delay_in_ms = 200.0
            Live.MidiMap.map_midi_pitchbend_with_feedback_map(midi_map_handle, volume, self.__strip_index, feeback_rule, not needs_takeover)
            Live.MidiMap.send_feedback_for_parameter(midi_map_handle, volume)
########NEW FILE########
__FILENAME__ = ChannelStripController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl_Classic/ChannelStripController.py
from MackieControlComponent import *
from _Generic.Devices import *
from itertools import chain

class ChannelStripController(MackieControlComponent):
    """
       Controls all channel-strips of the Mackie Control and controller extensions
       (Mackie Control XTs) if available: Maps and controls the faders, VPots and the
       displays depending on the assignemnt modes (Vol_Pan, PlugIn, IO, Send) and
       edit and flip mode.
    
       stack_offset vs. strip_index vs. bank_channel_offset:
    
       When using multiple sets of channel strips (stacking them), we will still only
       have one ChannelStripController which rules them all.
       To identify and seperate them, the implementation uses 3 different kind of
       indices or offsets:
    
       - strip_index: is the index of a channel_strip within its controller box,
         so strip no 1 on an extension (XT) and strip number one on the 'main' Mackie
         will both have a strip_index of 1.
         We need to preserve this index, because every device (extension or main controller
         will use a unique MIDI port to send out its MIDI messages which uses the
         strip_index, encoded into the MIDI messages channel, to tell the hardware which
         channel on the controller is meant.
    
       - stack_offset: descibes how many channels are left to the device that a
         channel_strip belongs to. For example: You have 3 Mackies: First, a XT, then
         the main Mackie, then another XT.
         The first XT will have the stack_index 0, the main Mackie, the stack_index 8,
         because 8 faders are on present before it. The second XT has a stack_index of 16
    
       - bank_cha_offset: this shifts all available channel strips within all the tracks
         that should be controlled. For example: If you have a song with 32 tracks, and
         a main Mackie Control + a XT on the right, then you want to shift the first fader
         of the main Mackie to Track 16, to be able to control Track 16 to 32.
    
       The master channel strip is hardcoded and not in the list of "normal" channel_strips,
       because its always mapped to the master_volume.
    """

    def __init__(self, main_script, channel_strips, master_strip, main_display_controller):
        MackieControlComponent.__init__(self, main_script)
        self.__left_extensions = []
        self.__right_extensions = []
        self.__own_channel_strips = channel_strips
        self.__master_strip = master_strip
        self.__channel_strips = channel_strips
        self.__main_display_controller = main_display_controller
        self.__meters_enabled = False
        self.__assignment_mode = CSM_VOLPAN
        self.__sub_mode_in_io_mode = CSM_IO_FIRST_MODE
        self.__plugin_mode = PCM_DEVICES
        self.__plugin_mode_offsets = [ 0 for x in range(PCM_NUMMODES) ]
        self.__chosen_plugin = None
        self.__ordered_plugin_parameters = []
        self.__displayed_plugins = []
        self.__last_attached_selected_track = None
        self.__send_mode_offset = 0
        self.__flip = False
        self.__view_returns = False
        self.__bank_cha_offset = 0
        self.__bank_cha_offset_returns = 0
        self.__within_track_added_or_deleted = False
        self.song().add_visible_tracks_listener(self.__on_tracks_added_or_deleted)
        self.song().view.add_selected_track_listener(self.__on_selected_track_changed)
        for t in chain(self.song().visible_tracks, self.song().return_tracks):
            if not t.solo_has_listener(self.__update_rude_solo_led):
                t.add_solo_listener(self.__update_rude_solo_led)
            if not t.has_audio_output_has_listener(self.__on_any_tracks_output_type_changed):
                t.add_has_audio_output_listener(self.__on_any_tracks_output_type_changed)

        self.__on_selected_track_changed()
        for s in self.__own_channel_strips:
            s.set_channel_strip_controller(self)

        self.__reassign_channel_strip_offsets()
        self.__reassign_channel_strip_parameters(for_display_only=False)

    def destroy(self):
        self.song().remove_visible_tracks_listener(self.__on_tracks_added_or_deleted)
        self.song().view.remove_selected_track_listener(self.__on_selected_track_changed)
        for t in chain(self.song().visible_tracks, self.song().return_tracks):
            if t.solo_has_listener(self.__update_rude_solo_led):
                t.remove_solo_listener(self.__update_rude_solo_led)
            if t.has_audio_output_has_listener(self.__on_any_tracks_output_type_changed):
                t.remove_has_audio_output_listener(self.__on_any_tracks_output_type_changed)

        st = self.__last_attached_selected_track
        if st and st.devices_has_listener(self.__on_selected_device_chain_changed):
            st.remove_devices_listener(self.__on_selected_device_chain_changed)
        for note in channel_strip_assignment_switch_ids:
            self.send_midi((NOTE_ON_STATUS, note, BUTTON_STATE_OFF))

        for note in channel_strip_control_switch_ids:
            self.send_midi((NOTE_ON_STATUS, note, BUTTON_STATE_OFF))

        self.send_midi((NOTE_ON_STATUS, SELECT_RUDE_SOLO, BUTTON_STATE_OFF))
        self.send_midi((CC_STATUS, 75, g7_seg_led_conv_table[' ']))
        self.send_midi((CC_STATUS, 74, g7_seg_led_conv_table[' ']))
        MackieControlComponent.destroy(self)

    def set_controller_extensions(self, left_extensions, right_extensions):
        """ Called from the main script (after all scripts where initialized), to let us
            know where and how many MackieControlXT are installed.
            There exists only one ChannelStripController, so we will take care about the
            extensions channel strips
        """
        self.__left_extensions = left_extensions
        self.__right_extensions = right_extensions
        self.__channel_strips = []
        stack_offset = 0
        for le in left_extensions:
            for s in le.channel_strips():
                self.__channel_strips.append(s)
                s.set_stack_offset(stack_offset)

            stack_offset += NUM_CHANNEL_STRIPS

        for s in self.__own_channel_strips:
            self.__channel_strips.append(s)
            s.set_stack_offset(stack_offset)

        stack_offset += NUM_CHANNEL_STRIPS
        for re in right_extensions:
            for s in re.channel_strips():
                self.__channel_strips.append(s)
                s.set_stack_offset(stack_offset)

            stack_offset += NUM_CHANNEL_STRIPS

        for s in self.__channel_strips:
            s.set_channel_strip_controller(self)

        self.refresh_state()

    def refresh_state(self):
        self.__update_assignment_mode_leds()
        self.__update_assignment_display()
        self.__update_rude_solo_led()
        self.__reassign_channel_strip_offsets()
        self.__on_flip_changed()
        self.__update_view_returns_mode()

    def request_rebuild_midi_map(self):
        """ Overridden to call also the extensions request_rebuild_midi_map"""
        MackieControlComponent.request_rebuild_midi_map(self)
        for ex in self.__left_extensions + self.__right_extensions:
            ex.request_rebuild_midi_map()

    def on_update_display_timer(self):
        self.__update_channel_strip_strings()

    def toggle_meter_mode(self):
        """ called from the main script when the display toggle button was pressed """
        self.__meters_enabled = not self.__meters_enabled
        self.__apply_meter_mode()

    def handle_assignment_switch_ids(self, switch_id, value):
        if switch_id == SID_ASSIGNMENT_IO:
            if value == BUTTON_PRESSED:
                self.__set_assignment_mode(CSM_IO)
        elif switch_id == SID_ASSIGNMENT_SENDS:
            if value == BUTTON_PRESSED:
                self.__set_assignment_mode(CSM_SENDS)
        elif switch_id == SID_ASSIGNMENT_PAN:
            if value == BUTTON_PRESSED:
                self.__set_assignment_mode(CSM_VOLPAN)
        elif switch_id == SID_ASSIGNMENT_PLUG_INS:
            if value == BUTTON_PRESSED:
                self.__set_assignment_mode(CSM_PLUGINS)
        elif switch_id == SID_ASSIGNMENT_EQ:
            if value == BUTTON_PRESSED:
                self.__switch_to_prev_page()
        elif switch_id == SID_ASSIGNMENT_DYNAMIC:
            if value == BUTTON_PRESSED:
                self.__switch_to_next_page()
        elif switch_id == SID_FADERBANK_PREV_BANK:
            if value == BUTTON_PRESSED:
                if self.shift_is_pressed():
                    self.__set_channel_offset(0)
                else:
                    self.__set_channel_offset(self.__strip_offset() - len(self.__channel_strips))
        elif switch_id == SID_FADERBANK_NEXT_BANK:
            if value == BUTTON_PRESSED:
                if self.shift_is_pressed():
                    last_possible_offset = (self.__controlled_num_of_tracks() - self.__strip_offset()) / len(self.__channel_strips) * len(self.__channel_strips) + self.__strip_offset()
                    if last_possible_offset == self.__controlled_num_of_tracks():
                        last_possible_offset -= len(self.__channel_strips)
                    self.__set_channel_offset(last_possible_offset)
                elif self.__strip_offset() < self.__controlled_num_of_tracks() - len(self.__channel_strips):
                    self.__set_channel_offset(self.__strip_offset() + len(self.__channel_strips))
        elif switch_id == SID_FADERBANK_PREV_CH:
            if value == BUTTON_PRESSED:
                if self.shift_is_pressed():
                    self.__set_channel_offset(0)
                else:
                    self.__set_channel_offset(self.__strip_offset() - 1)
        elif switch_id == SID_FADERBANK_NEXT_CH:
            if value == BUTTON_PRESSED:
                if self.shift_is_pressed():
                    self.__set_channel_offset(self.__controlled_num_of_tracks() - len(self.__channel_strips))
                elif self.__strip_offset() < self.__controlled_num_of_tracks() - len(self.__channel_strips):
                    self.__set_channel_offset(self.__strip_offset() + 1)
        elif switch_id == SID_FADERBANK_FLIP:
            if value == BUTTON_PRESSED:
                self.__toggle_flip()
        elif switch_id == SID_FADERBANK_EDIT:
            if value == BUTTON_PRESSED:
                self.__toggle_view_returns()

    def handle_vpot_rotation(self, strip_index, stack_offset, cc_value):
        """ forwarded to us by the channel_strips """
        if self.__assignment_mode == CSM_IO:
            if cc_value >= 64:
                direction = -1
            else:
                direction = 1
            channel_strip = self.__channel_strips[stack_offset + strip_index]
            current_routing = self.__routing_target(channel_strip)
            available_routings = self.__available_routing_targets(channel_strip)
            if current_routing and available_routings:
                if current_routing in available_routings:
                    i = list(available_routings).index(current_routing)
                    if direction == 1:
                        new_i = min(len(available_routings) - 1, i + direction)
                    else:
                        new_i = max(0, i + direction)
                    new_routing = available_routings[new_i]
                elif len(available_routings):
                    new_routing = available_routings[0]
                self.__set_routing_target(channel_strip, new_routing)
        elif self.__assignment_mode == CSM_PLUGINS:
            pass
        else:
            channel_strip = self.__channel_strips[stack_offset + strip_index]
            raise not channel_strip.assigned_track() or not channel_strip.assigned_track().has_audio_output or AssertionError, 'in every other mode, the midimap should handle the messages'

    def handle_fader_touch(self, strip_offset, stack_offset, touched):
        """ forwarded to us by the channel_strips """
        self.__reassign_channel_strip_parameters(for_display_only=True)

    def handle_pressed_v_pot(self, strip_index, stack_offset):
        """ forwarded to us by the channel_strips """
        if self.__assignment_mode == CSM_VOLPAN or self.__assignment_mode == CSM_SENDS or self.__assignment_mode == CSM_PLUGINS and self.__plugin_mode == PCM_PARAMETERS:
            if stack_offset + strip_index in range(0, len(self.__channel_strips)):
                param = self.__channel_strips[stack_offset + strip_index].v_pot_parameter()
            if param and param.is_enabled:
                if param.is_quantized:
                    if param.value + 1 > param.max:
                        param.value = param.min
                    else:
                        param.value = param.value + 1
                else:
                    param.value = param.default_value
        elif self.__assignment_mode == CSM_PLUGINS:
            if self.__plugin_mode == PCM_DEVICES:
                device_index = strip_index + stack_offset + self.__plugin_mode_offsets[PCM_DEVICES]
                if device_index >= 0 and device_index < len(self.song().view.selected_track.devices):
                    if self.__chosen_plugin != None:
                        self.__chosen_plugin.remove_parameters_listener(self.__on_parameter_list_of_chosen_plugin_changed)
                    self.__chosen_plugin = self.song().view.selected_track.devices[device_index]
                    self.__chosen_plugin != None and self.__chosen_plugin.add_parameters_listener(self.__on_parameter_list_of_chosen_plugin_changed)
                self.__reorder_parameters()
                self.__plugin_mode_offsets[PCM_PARAMETERS] = 0
                self.__set_plugin_mode(PCM_PARAMETERS)

    def __strip_offset(self):
        """ return the bank_channel offset depending if we are in return mode or not
        """
        if self.__view_returns:
            return self.__bank_cha_offset_returns
        else:
            return self.__bank_cha_offset

    def __controlled_num_of_tracks(self):
        """ return the number of tracks, depending on if we are in send_track
            mode or normal track mode
        """
        if self.__view_returns:
            return len(self.song().return_tracks)
        else:
            return len(self.song().visible_tracks)

    def __send_parameter(self, strip_index, stack_index):
        """ Return the send parameter that is assigned to the given channel strip
        """
        if not self.__assignment_mode == CSM_SENDS:
            raise AssertionError
            send_index = strip_index + stack_index + self.__send_mode_offset
            p = send_index < len(self.song().view.selected_track.mixer_device.sends) and self.song().view.selected_track.mixer_device.sends[send_index]
            return (p, p.name)
        return (None, None)

    def __plugin_parameter(self, strip_index, stack_index):
        """ Return the parameter that is assigned to the given channel strip
        """
        if not self.__assignment_mode == CSM_PLUGINS:
            raise AssertionError
            return self.__plugin_mode == PCM_DEVICES and (None, None)
        elif not (self.__plugin_mode == PCM_PARAMETERS and self.__chosen_plugin):
            raise AssertionError
            parameters = self.__ordered_plugin_parameters
            parameter_index = strip_index + stack_index + self.__plugin_mode_offsets[PCM_PARAMETERS]
            if parameter_index >= 0 and parameter_index < len(parameters):
                return parameters[parameter_index]
            else:
                return (None, None)
        else:
            raise 0 or AssertionError

    def __any_slider_is_touched(self):
        for s in self.__channel_strips:
            if s.is_touched():
                return True

        return False

    def __can_flip(self):
        if self.__assignment_mode == CSM_PLUGINS and self.__plugin_mode == PCM_DEVICES:
            return False
        elif self.__assignment_mode == CSM_IO:
            return False
        return True

    def __can_switch_to_prev_page(self):
        """ return true if pressing the "next" button will have any effect """
        if self.__assignment_mode == CSM_PLUGINS:
            return self.__plugin_mode_offsets[self.__plugin_mode] > 0
        elif self.__assignment_mode == CSM_SENDS:
            return self.__send_mode_offset > 0
        else:
            return False

    def __can_switch_to_next_page(self):
        """ return true if pressing the "prev" button will have any effect """
        if self.__assignment_mode == CSM_PLUGINS:
            sel_track = self.song().view.selected_track
            if self.__plugin_mode == PCM_DEVICES:
                return self.__plugin_mode_offsets[PCM_DEVICES] + len(self.__channel_strips) < len(sel_track.devices)
            elif not (self.__plugin_mode == PCM_PARAMETERS and self.__chosen_plugin):
                raise AssertionError
                parameters = self.__ordered_plugin_parameters
                return self.__plugin_mode_offsets[PCM_PARAMETERS] + len(self.__channel_strips) < len(parameters)
            else:
                raise 0 or AssertionError
        elif self.__assignment_mode == CSM_SENDS:
            return self.__send_mode_offset + len(self.__channel_strips) < len(self.song().return_tracks)
        else:
            return False

    def __available_routing_targets(self, channel_strip):
        raise self.__assignment_mode == CSM_IO or AssertionError
        t = channel_strip.assigned_track()
        if t:
            if self.__sub_mode_in_io_mode == CSM_IO_MODE_INPUT_MAIN:
                return t.input_routings
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_INPUT_SUB:
                return t.input_sub_routings
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_OUTPUT_MAIN:
                return t.output_routings
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_OUTPUT_SUB:
                return t.output_sub_routings
            else:
                raise 0 or AssertionError
        else:
            return None

    def __routing_target(self, channel_strip):
        raise self.__assignment_mode == CSM_IO or AssertionError
        t = channel_strip.assigned_track()
        if t:
            if self.__sub_mode_in_io_mode == CSM_IO_MODE_INPUT_MAIN:
                return t.current_input_routing
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_INPUT_SUB:
                return t.current_input_sub_routing
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_OUTPUT_MAIN:
                return t.current_output_routing
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_OUTPUT_SUB:
                return t.current_output_sub_routing
            else:
                raise 0 or AssertionError
        else:
            return None

    def __set_routing_target(self, channel_strip, target_string):
        raise self.__assignment_mode == CSM_IO or AssertionError
        t = channel_strip.assigned_track()
        if t:
            if self.__sub_mode_in_io_mode == CSM_IO_MODE_INPUT_MAIN:
                t.current_input_routing = target_string
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_INPUT_SUB:
                t.current_input_sub_routing = target_string
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_OUTPUT_MAIN:
                t.current_output_routing = target_string
            elif self.__sub_mode_in_io_mode == CSM_IO_MODE_OUTPUT_SUB:
                t.current_output_sub_routing = target_string
            else:
                raise 0 or AssertionError

    def __set_channel_offset(self, new_offset):
        """ Set and validate a new channel_strip offset, which shifts all available channel
            strips within all the available tracks or reutrn tracks
        """
        if new_offset < 0:
            new_offset = 0
        elif new_offset >= self.__controlled_num_of_tracks():
            new_offset = self.__controlled_num_of_tracks() - 1
        if self.__view_returns:
            self.__bank_cha_offset_returns = new_offset
        else:
            self.__bank_cha_offset = new_offset
        self.__main_display_controller.set_channel_offset(new_offset)
        self.__reassign_channel_strip_offsets()
        self.__reassign_channel_strip_parameters(for_display_only=False)
        self.__update_channel_strip_strings()
        self.request_rebuild_midi_map()

    def __set_assignment_mode(self, mode):
        for plugin in self.__displayed_plugins:
            if plugin != None:
                plugin.remove_name_listener(self.__update_plugin_names)

        self.__displayed_plugins = []
        if mode == CSM_PLUGINS:
            self.__assignment_mode = mode
            self.__main_display_controller.set_show_parameter_names(True)
            self.__set_plugin_mode(PCM_DEVICES)
        elif mode == CSM_SENDS:
            self.__main_display_controller.set_show_parameter_names(True)
            self.__assignment_mode = mode
        else:
            if mode == CSM_IO:
                for s in self.__channel_strips:
                    s.unlight_vpot_leds()

            self.__main_display_controller.set_show_parameter_names(False)
            if self.__assignment_mode != mode:
                self.__assignment_mode = mode
            elif self.__assignment_mode == CSM_IO:
                self.__switch_to_next_io_mode()
        self.__update_assignment_mode_leds()
        self.__update_assignment_display()
        self.__apply_meter_mode()
        self.__reassign_channel_strip_parameters(for_display_only=False)
        self.__update_channel_strip_strings()
        self.__update_page_switch_leds()
        if mode == CSM_PLUGINS:
            self.__update_vpot_leds_in_plugins_device_choose_mode()
        self.__update_flip_led()
        self.request_rebuild_midi_map()

    def __set_plugin_mode(self, new_mode):
        """ Set a new plugin sub-mode, which can be:
            1. Choosing the device to control (PCM_DEVICES)
            2. Controlling the chosen devices parameters (PCM_PARAMETERS)
        """
        if not (new_mode >= 0 and new_mode < PCM_NUMMODES):
            raise AssertionError
            if self.__plugin_mode != new_mode:
                self.__plugin_mode = new_mode
                self.__reassign_channel_strip_parameters(for_display_only=False)
                self.request_rebuild_midi_map()
                self.__plugin_mode == PCM_DEVICES and self.__update_vpot_leds_in_plugins_device_choose_mode()
            else:
                for plugin in self.__displayed_plugins:
                    if plugin != None:
                        plugin.remove_name_listener(self.__update_plugin_names)

                self.__displayed_plugins = []
            self.__update_page_switch_leds()
            self.__update_flip_led()
            self.__update_page_switch_leds()

    def __switch_to_prev_page(self):
        """ Switch to the previous page in the non track strip modes (choosing plugs, or
            controlling devices)
        """
        if self.__can_switch_to_prev_page():
            if self.__assignment_mode == CSM_PLUGINS:
                self.__plugin_mode_offsets[self.__plugin_mode] -= len(self.__channel_strips)
                if self.__plugin_mode == PCM_DEVICES:
                    self.__update_vpot_leds_in_plugins_device_choose_mode()
            elif self.__assignment_mode == CSM_SENDS:
                self.__send_mode_offset -= len(self.__channel_strips)
            self.__reassign_channel_strip_parameters(for_display_only=False)
            self.__update_channel_strip_strings()
            self.__update_page_switch_leds()
            self.request_rebuild_midi_map()

    def __switch_to_next_page(self):
        """ Switch to the next page in the non track strip modes (choosing plugs, or
            controlling devices)
        """
        if self.__can_switch_to_next_page():
            if self.__assignment_mode == CSM_PLUGINS:
                self.__plugin_mode_offsets[self.__plugin_mode] += len(self.__channel_strips)
                if self.__plugin_mode == PCM_DEVICES:
                    self.__update_vpot_leds_in_plugins_device_choose_mode()
            elif self.__assignment_mode == CSM_SENDS:
                self.__send_mode_offset += len(self.__channel_strips)
            else:
                raise 0 or AssertionError
            self.__reassign_channel_strip_parameters(for_display_only=False)
            self.__update_channel_strip_strings()
            self.__update_page_switch_leds()
            self.request_rebuild_midi_map()

    def __switch_to_next_io_mode(self):
        """ Step through the available IO modes (In/OutPut//Main/Sub)
        """
        self.__sub_mode_in_io_mode += 1
        if self.__sub_mode_in_io_mode > CSM_IO_LAST_MODE:
            self.__sub_mode_in_io_mode = CSM_IO_FIRST_MODE

    def __reassign_channel_strip_offsets(self):
        """ Update the channel strips bank_channel offset
        """
        for s in self.__channel_strips:
            s.set_bank_and_channel_offset(self.__strip_offset(), self.__view_returns, self.__within_track_added_or_deleted)

    def __reassign_channel_strip_parameters(self, for_display_only):
        """ Reevaluate all v-pot/fader -> parameter assignments
        """
        display_parameters = []
        for s in self.__channel_strips:
            vpot_param = (None, None)
            slider_param = (None, None)
            vpot_display_mode = VPOT_DISPLAY_SINGLE_DOT
            slider_display_mode = VPOT_DISPLAY_SINGLE_DOT
            if self.__assignment_mode == CSM_VOLPAN:
                if s.assigned_track() and s.assigned_track().has_audio_output:
                    vpot_param = (s.assigned_track().mixer_device.panning, 'Pan')
                    vpot_display_mode = VPOT_DISPLAY_BOOST_CUT
                    slider_param = (s.assigned_track().mixer_device.volume, 'Volume')
                    slider_display_mode = VPOT_DISPLAY_WRAP
            elif self.__assignment_mode == CSM_PLUGINS:
                vpot_param = self.__plugin_parameter(s.strip_index(), s.stack_offset())
                vpot_display_mode = VPOT_DISPLAY_WRAP
                if s.assigned_track() and s.assigned_track().has_audio_output:
                    slider_param = (s.assigned_track().mixer_device.volume, 'Volume')
                    slider_display_mode = VPOT_DISPLAY_WRAP
            elif self.__assignment_mode == CSM_SENDS:
                vpot_param = self.__send_parameter(s.strip_index(), s.stack_offset())
                vpot_display_mode = VPOT_DISPLAY_WRAP
                if s.assigned_track() and s.assigned_track().has_audio_output:
                    slider_param = (s.assigned_track().mixer_device.volume, 'Volume')
                    slider_display_mode = VPOT_DISPLAY_WRAP
            elif self.__assignment_mode == CSM_IO:
                if s.assigned_track() and s.assigned_track().has_audio_output:
                    slider_param = (s.assigned_track().mixer_device.volume, 'Volume')
            if self.__flip and self.__can_flip():
                if self.__any_slider_is_touched():
                    display_parameters.append(vpot_param)
                else:
                    display_parameters.append(slider_param)
                if not for_display_only:
                    s.set_v_pot_parameter(slider_param[0], slider_display_mode)
                    s.set_fader_parameter(vpot_param[0])
            else:
                if self.__any_slider_is_touched():
                    display_parameters.append(slider_param)
                else:
                    display_parameters.append(vpot_param)
                if not for_display_only:
                    s.set_v_pot_parameter(vpot_param[0], vpot_display_mode)
                    s.set_fader_parameter(slider_param[0])

        self.__main_display_controller.set_channel_offset(self.__strip_offset())
        if len(display_parameters):
            self.__main_display_controller.set_parameters(display_parameters)

    def __apply_meter_mode(self):
        """ Update the meter mode in the displays and channel strips """
        enabled = self.__meters_enabled and self.__assignment_mode is CSM_VOLPAN
        for s in self.__channel_strips:
            s.enable_meter_mode(enabled)

        self.__main_display_controller.enable_meters(enabled)

    def __toggle_flip(self):
        """ En/Disable V-Pot / Fader flipping
        """
        if self.__can_flip():
            self.__flip = not self.__flip
            self.__on_flip_changed()

    def __toggle_view_returns(self):
        """ Toggle if we want to control the return tracks or normal tracks
        """
        self.__view_returns = not self.__view_returns
        self.__update_view_returns_mode()

    def __update_assignment_mode_leds(self):
        """ Show which assignment mode is currently active """
        if self.__assignment_mode == CSM_IO:
            sid_on_switch = SID_ASSIGNMENT_IO
        elif self.__assignment_mode == CSM_SENDS:
            sid_on_switch = SID_ASSIGNMENT_SENDS
        elif self.__assignment_mode == CSM_VOLPAN:
            sid_on_switch = SID_ASSIGNMENT_PAN
        elif self.__assignment_mode == CSM_PLUGINS:
            sid_on_switch = SID_ASSIGNMENT_PLUG_INS
        else:
            raise 0 or AssertionError
            sid_on_switch = None
        for s in (SID_ASSIGNMENT_IO,
         SID_ASSIGNMENT_SENDS,
         SID_ASSIGNMENT_PAN,
         SID_ASSIGNMENT_PLUG_INS):
            if s == sid_on_switch:
                self.send_midi((NOTE_ON_STATUS, s, BUTTON_STATE_ON))
            else:
                self.send_midi((NOTE_ON_STATUS, s, BUTTON_STATE_OFF))

    def __update_assignment_display(self):
        """ Cryptically label the current assignment mode in the 2char display above
            the assignment buttons
        """
        if self.__assignment_mode == CSM_VOLPAN:
            ass_string = ['P', 'N']
        else:
            if self.__assignment_mode == CSM_PLUGINS or self.__assignment_mode == CSM_SENDS:
                ass_string = self.__last_attached_selected_track == self.song().master_track and ['M', 'A']
            for t in self.song().return_tracks:
                if t == self.__last_attached_selected_track:
                    ass_string = ['R', chr(ord('A') + list(self.song().return_tracks).index(t))]
                    break

            for t in self.song().visible_tracks:
                if t == self.__last_attached_selected_track:
                    ass_string = list('%.2d' % min(99, list(self.song().visible_tracks).index(t) + 1))
                    break

            if not ass_string:
                raise AssertionError
            elif self.__assignment_mode == CSM_IO:
                if self.__sub_mode_in_io_mode == CSM_IO_MODE_INPUT_MAIN:
                    ass_string = ['I', "'"]
                elif self.__sub_mode_in_io_mode == CSM_IO_MODE_INPUT_SUB:
                    ass_string = ['I', ',']
                elif self.__sub_mode_in_io_mode == CSM_IO_MODE_OUTPUT_MAIN:
                    ass_string = ['0', "'"]
                elif self.__sub_mode_in_io_mode == CSM_IO_MODE_OUTPUT_SUB:
                    ass_string = ['0', ',']
                else:
                    raise 0 or AssertionError
            else:
                raise 0 or AssertionError
        self.send_midi((CC_STATUS, 75, g7_seg_led_conv_table[ass_string[0]]))
        self.send_midi((CC_STATUS, 74, g7_seg_led_conv_table[ass_string[1]]))

    def __update_rude_solo_led(self):
        any_track_soloed = False
        for t in chain(self.song().tracks, self.song().return_tracks):
            if t.solo:
                any_track_soloed = True
                break

        if any_track_soloed:
            self.send_midi((NOTE_ON_STATUS, SELECT_RUDE_SOLO, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SELECT_RUDE_SOLO, BUTTON_STATE_OFF))

    def __update_page_switch_leds(self):
        """ visualize if the "prev" an "next" buttons can be pressed """
        if self.__can_switch_to_prev_page():
            self.send_midi((NOTE_ON_STATUS, SID_ASSIGNMENT_EQ, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_ASSIGNMENT_EQ, BUTTON_STATE_OFF))
        if self.__can_switch_to_next_page():
            self.send_midi((NOTE_ON_STATUS, SID_ASSIGNMENT_DYNAMIC, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_ASSIGNMENT_DYNAMIC, BUTTON_STATE_OFF))

    def __update_flip_led(self):
        if self.__flip and self.__can_flip():
            self.send_midi((NOTE_ON_STATUS, SID_FADERBANK_FLIP, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_FADERBANK_FLIP, BUTTON_STATE_OFF))

    def __update_vpot_leds_in_plugins_device_choose_mode(self):
        """ To be called in assignment mode CSM_PLUGINS, submode PCM_DEVICES only:
            This will enlighten all poties which can be pressed to choose a device
            for editing, and unlight all poties where pressing will have no effect
        """
        raise self.__assignment_mode == CSM_PLUGINS or AssertionError
        raise self.__plugin_mode == PCM_DEVICES or AssertionError
        sel_track = self.song().view.selected_track
        count = 0
        for s in self.__channel_strips:
            offset = self.__plugin_mode_offsets[self.__plugin_mode]
            if sel_track and offset + count >= 0 and offset + count < len(sel_track.devices):
                s.show_full_enlighted_poti()
            else:
                s.unlight_vpot_leds()
            count += 1

    def __update_channel_strip_strings(self):
        """ In IO mode, collect all strings that will be visible in the main display manually
        """
        if not self.__any_slider_is_touched():
            if self.__assignment_mode == CSM_IO:
                targets = []
                for s in self.__channel_strips:
                    if self.__routing_target(s):
                        targets.append(self.__routing_target(s))
                    else:
                        targets.append('')

                self.__main_display_controller.set_channel_strip_strings(targets)
            elif self.__assignment_mode == CSM_PLUGINS and self.__plugin_mode == PCM_DEVICES:
                for plugin in self.__displayed_plugins:
                    if plugin != None:
                        plugin.remove_name_listener(self.__update_plugin_names)

                self.__displayed_plugins = []
                sel_track = self.song().view.selected_track
                for i in range(len(self.__channel_strips)):
                    device_index = i + self.__plugin_mode_offsets[PCM_DEVICES]
                    if device_index >= 0 and device_index < len(sel_track.devices):
                        sel_track.devices[device_index].add_name_listener(self.__update_plugin_names)
                        self.__displayed_plugins.append(sel_track.devices[device_index])
                    else:
                        self.__displayed_plugins.append(None)

                self.__update_plugin_names()

    def __update_plugin_names(self):
        raise self.__assignment_mode == CSM_PLUGINS and self.__plugin_mode == PCM_DEVICES or AssertionError
        device_strings = []
        for plugin in self.__displayed_plugins:
            if plugin != None:
                device_strings.append(plugin.name)
            else:
                device_strings.append('')

        self.__main_display_controller.set_channel_strip_strings(device_strings)

    def __update_view_returns_mode(self):
        """ Update the control return tracks LED
        """
        if self.__view_returns:
            self.send_midi((NOTE_ON_STATUS, SID_FADERBANK_EDIT, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_FADERBANK_EDIT, BUTTON_STATE_OFF))
        self.__main_display_controller.set_show_return_track_names(self.__view_returns)
        self.__reassign_channel_strip_offsets()
        self.__reassign_channel_strip_parameters(for_display_only=False)
        self.request_rebuild_midi_map()

    def __on_selected_track_changed(self):
        """ Notifier, called as soon as the selected track has changed
        """
        st = self.__last_attached_selected_track
        if st and st.devices_has_listener(self.__on_selected_device_chain_changed):
            st.remove_devices_listener(self.__on_selected_device_chain_changed)
        self.__last_attached_selected_track = self.song().view.selected_track
        st = self.__last_attached_selected_track
        if st:
            st.add_devices_listener(self.__on_selected_device_chain_changed)
        if self.__assignment_mode == CSM_PLUGINS:
            self.__plugin_mode_offsets = [ 0 for x in range(PCM_NUMMODES) ]
            if self.__chosen_plugin != None:
                self.__chosen_plugin.remove_parameters_listener(self.__on_parameter_list_of_chosen_plugin_changed)
            self.__chosen_plugin = None
            self.__ordered_plugin_parameters = []
            self.__update_assignment_display()
            if self.__plugin_mode == PCM_DEVICES:
                self.__update_vpot_leds_in_plugins_device_choose_mode()
            else:
                self.__set_plugin_mode(PCM_DEVICES)
        elif self.__assignment_mode == CSM_SENDS:
            self.__reassign_channel_strip_parameters(for_display_only=False)
            self.__update_assignment_display()
            self.request_rebuild_midi_map()

    def __on_flip_changed(self):
        """ Update the flip button LED when the flip mode changed
        """
        self.__update_flip_led()
        if self.__can_flip():
            self.__update_assignment_display()
            self.__reassign_channel_strip_parameters(for_display_only=False)
            self.request_rebuild_midi_map()

    def __on_selected_device_chain_changed(self):
        if self.__assignment_mode == CSM_PLUGINS:
            if self.__plugin_mode == PCM_DEVICES:
                self.__update_vpot_leds_in_plugins_device_choose_mode()
                self.__update_page_switch_leds()
            elif self.__plugin_mode == PCM_PARAMETERS:
                if not self.__chosen_plugin:
                    self.__set_plugin_mode(PCM_DEVICES)
                elif self.__chosen_plugin not in self.__last_attached_selected_track.devices:
                    if self.__chosen_plugin != None:
                        self.__chosen_plugin.remove_parameters_listener(self.__on_parameter_list_of_chosen_plugin_changed)
                    self.__chosen_plugin = None
                    self.__set_plugin_mode(PCM_DEVICES)

    def __on_tracks_added_or_deleted(self):
        """ Notifier, called as soon as tracks where added, removed or moved
        """
        self.__within_track_added_or_deleted = True
        for t in chain(self.song().visible_tracks, self.song().return_tracks):
            if not t.solo_has_listener(self.__update_rude_solo_led):
                t.add_solo_listener(self.__update_rude_solo_led)
            if not t.has_audio_output_has_listener(self.__on_any_tracks_output_type_changed):
                t.add_has_audio_output_listener(self.__on_any_tracks_output_type_changed)

        if self.__send_mode_offset >= len(self.song().return_tracks):
            self.__send_mode_offset = 0
            self.__reassign_channel_strip_parameters(for_display_only=False)
            self.__update_channel_strip_strings()
        if self.__strip_offset() + len(self.__channel_strips) >= self.__controlled_num_of_tracks():
            self.__set_channel_offset(max(0, self.__controlled_num_of_tracks() - len(self.__channel_strips)))
        self.__reassign_channel_strip_parameters(for_display_only=False)
        self.__update_channel_strip_strings()
        if self.__assignment_mode == CSM_SENDS:
            self.__update_page_switch_leds()
        self.refresh_state()
        self.__main_display_controller.refresh_state()
        self.__within_track_added_or_deleted = False
        self.request_rebuild_midi_map()

    def __on_any_tracks_output_type_changed(self):
        """ called as soon as any device chain has changed (devices where
            added/removed/swapped...)
        """
        self.__reassign_channel_strip_parameters(for_display_only=False)
        self.request_rebuild_midi_map()

    def __on_parameter_list_of_chosen_plugin_changed(self):
        raise self.__chosen_plugin != None or AssertionError
        raise self.__plugin_mode == PCM_PARAMETERS or AssertionError
        self.__reorder_parameters()
        self.__reassign_channel_strip_parameters(for_display_only=False)
        self.request_rebuild_midi_map()

    def __reorder_parameters(self):
        result = []
        if self.__chosen_plugin:
            result = [ (p, p.name) for p in self.__chosen_plugin.parameters[1:] ]
        self.__ordered_plugin_parameters = result
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl_Classic/consts.py
NOTE_OFF_STATUS = 128
NOTE_ON_STATUS = 144
CC_STATUS = 176
PB_STATUS = 224
SYSEX_DEVICE_TYPE = 20
SYSEX_DEVICE_TYPE_XT = 21
NUM_CHANNEL_STRIPS = 8
MASTER_CHANNEL_STRIP_INDEX = 8
BUTTON_STATE_OFF = 0
BUTTON_STATE_ON = 127
BUTTON_STATE_BLINKING = 1
BUTTON_PRESSED = 1
BUTTON_RELEASED = 0
NUM_CHARS_PER_DISPLAY_LINE = 54
SELECT_SMPTE_NOTE = 113
SELECT_BEATS_NOTE = 114
SELECT_RUDE_SOLO = 115
FID_PANNING_BASE = 16
JOG_WHEEL_CC_NO = 60
VPOT_DISPLAY_SINGLE_DOT = 0
VPOT_DISPLAY_BOOST_CUT = 1
VPOT_DISPLAY_WRAP = 2
VPOT_DISPLAY_SPREAD = 3
CSM_VOLPAN = 0
CSM_PLUGINS = 1
CSM_IO = 2
CSM_SENDS = 3
CSM_IO_MODE_INPUT_MAIN = 0
CSM_IO_MODE_INPUT_SUB = 1
CSM_IO_MODE_OUTPUT_MAIN = 2
CSM_IO_MODE_OUTPUT_SUB = 3
CSM_IO_FIRST_MODE = CSM_IO_MODE_INPUT_MAIN
CSM_IO_LAST_MODE = CSM_IO_MODE_OUTPUT_SUB
PCM_DEVICES = 0
PCM_PARAMETERS = 1
PCM_NUMMODES = 2
CLIP_STATE_INVALID = -1
CLIP_STOPPED = 0
CLIP_TRIGGERED = 1
CLIP_PLAYING = 2
g7_seg_led_conv_table = {' ': 0,
 'A': 1,
 'B': 2,
 'C': 3,
 'D': 4,
 'E': 5,
 'F': 6,
 'G': 7,
 'H': 8,
 'I': 9,
 'J': 10,
 'K': 11,
 'L': 12,
 'M': 13,
 'N': 14,
 'O': 15,
 'P': 16,
 'Q': 17,
 'R': 18,
 'S': 19,
 'T': 20,
 'U': 21,
 'V': 22,
 'W': 23,
 'X': 24,
 'Y': 25,
 'Z': 26,
 '\\': 34,
 '#': 35,
 '$': 36,
 '%': 37,
 '&': 38,
 "'": 39,
 '(': 40,
 ')': 41,
 '*': 42,
 '+': 43,
 ',': 44,
 '0': 48,
 '1': 49,
 '2': 50,
 '3': 51,
 '4': 52,
 '5': 53,
 '6': 54,
 '7': 55,
 '8': 56,
 '9': 57,
 ';': 59,
 '<': 60}
SID_FIRST = 0
SID_RECORD_ARM_BASE = 0
SID_RECORD_ARM_CH1 = 0
SID_RECORD_ARM_CH2 = 1
SID_RECORD_ARM_CH3 = 2
SID_RECORD_ARM_CH4 = 3
SID_RECORD_ARM_CH5 = 4
SID_RECORD_ARM_CH6 = 5
SID_RECORD_ARM_CH7 = 6
SID_RECORD_ARM_CH8 = 7
SID_SOLO_BASE = 8
SID_SOLO_CH1 = 8
SID_SOLO_CH2 = 9
SID_SOLO_CH3 = 10
SID_SOLO_CH4 = 11
SID_SOLO_CH5 = 12
SID_SOLO_CH6 = 13
SID_SOLO_CH7 = 14
SID_SOLO_CH8 = 15
SID_MUTE_BASE = 16
SID_MUTE_CH1 = 16
SID_MUTE_CH2 = 17
SID_MUTE_CH3 = 18
SID_MUTE_CH4 = 19
SID_MUTE_CH5 = 20
SID_MUTE_CH6 = 21
SID_MUTE_CH7 = 22
SID_MUTE_CH8 = 23
SID_SELECT_BASE = 24
SID_SELECT_CH1 = 24
SID_SELECT_CH2 = 25
SID_SELECT_CH3 = 26
SID_SELECT_CH4 = 27
SID_SELECT_CH5 = 28
SID_SELECT_CH6 = 29
SID_SELECT_CH7 = 30
SID_SELECT_CH8 = 31
SID_VPOD_PUSH_BASE = 32
SID_VPOD_PUSH_CH1 = 32
SID_VPOD_PUSH_CH2 = 33
SID_VPOD_PUSH_CH3 = 34
SID_VPOD_PUSH_CH4 = 35
SID_VPOD_PUSH_CH5 = 36
SID_VPOD_PUSH_CH6 = 37
SID_VPOD_PUSH_CH7 = 38
SID_VPOD_PUSH_CH8 = 39
channel_strip_switch_ids = range(SID_RECORD_ARM_BASE, SID_VPOD_PUSH_CH8 + 1)
SID_ASSIGNMENT_IO = 40
SID_ASSIGNMENT_SENDS = 41
SID_ASSIGNMENT_PAN = 42
SID_ASSIGNMENT_PLUG_INS = 43
SID_ASSIGNMENT_EQ = 44
SID_ASSIGNMENT_DYNAMIC = 45
channel_strip_assignment_switch_ids = range(SID_ASSIGNMENT_IO, SID_ASSIGNMENT_DYNAMIC + 1)
SID_FADERBANK_PREV_BANK = 46
SID_FADERBANK_NEXT_BANK = 47
SID_FADERBANK_PREV_CH = 48
SID_FADERBANK_NEXT_CH = 49
SID_FADERBANK_FLIP = 50
SID_FADERBANK_EDIT = 51
channel_strip_control_switch_ids = range(SID_ASSIGNMENT_IO, SID_FADERBANK_EDIT + 1)
SID_DISPLAY_NAME_VALUE = 52
SID_DISPLAY_SMPTE_BEATS = 53
display_switch_ids = range(SID_DISPLAY_NAME_VALUE, SID_DISPLAY_SMPTE_BEATS + 1)
SID_SOFTWARE_F1 = 54
SID_SOFTWARE_F2 = 55
SID_SOFTWARE_F3 = 56
SID_SOFTWARE_F4 = 57
SID_SOFTWARE_F5 = 58
SID_SOFTWARE_F6 = 59
SID_SOFTWARE_F7 = 60
SID_SOFTWARE_F8 = 61
SID_SOFTWARE_F9 = 62
SID_SOFTWARE_F10 = 63
SID_SOFTWARE_F11 = 64
SID_SOFTWARE_F12 = 65
SID_SOFTWARE_F13 = 66
SID_SOFTWARE_F14 = 67
SID_SOFTWARE_F15 = 68
SID_SOFTWARE_F16 = 69
function_key_control_switch_ids = range(SID_SOFTWARE_F1, SID_SOFTWARE_F16 + 1)
SID_MOD_SHIFT = 70
SID_MOD_OPTION = 71
SID_MOD_CTRL = 72
SID_MOD_ALT = 73
SID_AUTOMATION_ON = 74
SID_AUTOMATION_RECORD = 75
SID_AUTOMATION_SNAPSHOT = 77
SID_AUTOMATION_TOUCH = 78
SID_FUNC_UNDO = 76
SID_FUNC_CANCEL = 80
SID_FUNC_ENTER = 81
SID_FUNC_REDO = 79
SID_FUNC_MARKER = 82
SID_FUNC_MIXER = 83
software_controls_switch_ids = (SID_MOD_SHIFT,
 SID_MOD_OPTION,
 SID_MOD_CTRL,
 SID_MOD_ALT,
 SID_AUTOMATION_ON,
 SID_AUTOMATION_RECORD,
 SID_AUTOMATION_SNAPSHOT,
 SID_AUTOMATION_TOUCH,
 SID_FUNC_UNDO,
 SID_FUNC_CANCEL,
 SID_FUNC_ENTER,
 SID_FUNC_REDO,
 SID_FUNC_MARKER,
 SID_FUNC_MIXER)
SID_TRANSPORT_REWIND = 91
SID_TRANSPORT_FAST_FORWARD = 92
SID_TRANSPORT_STOP = 93
SID_TRANSPORT_PLAY = 94
SID_TRANSPORT_RECORD = 95
transport_control_switch_ids = range(SID_TRANSPORT_REWIND, SID_TRANSPORT_RECORD + 1)
SID_MARKER_FROM_PREV = 84
SID_MARKER_FROM_NEXT = 85
SID_MARKER_LOOP = 86
SID_MARKER_PI = 87
SID_MARKER_PO = 88
SID_MARKER_HOME = 89
SID_MARKER_END = 90
marker_control_switch_ids = (SID_MARKER_FROM_PREV,
 SID_MARKER_FROM_NEXT,
 SID_MARKER_LOOP,
 SID_MARKER_PI,
 SID_MARKER_PO,
 SID_MARKER_HOME,
 SID_MARKER_END)
SID_JOG_CURSOR_UP = 96
SID_JOG_CURSOR_DOWN = 97
SID_JOG_CURSOR_LEFT = 98
SID_JOG_CURSOR_RIGHT = 99
SID_JOG_ZOOM = 100
SID_JOG_SCRUB = 101
jog_wheel_switch_ids = range(SID_JOG_CURSOR_UP, SID_JOG_SCRUB + 1)
SID_USER_FOOT_SWITCHA = 102
SID_USER_FOOT_SWITCHB = 103
SID_FADER_TOUCH_SENSE_BASE = 104
SID_FADER_TOUCH_SENSE_CH1 = 104
SID_FADER_TOUCH_SENSE_CH2 = 105
SID_FADER_TOUCH_SENSE_CH3 = 106
SID_FADER_TOUCH_SENSE_CH4 = 107
SID_FADER_TOUCH_SENSE_CH5 = 108
SID_FADER_TOUCH_SENSE_CH6 = 109
SID_FADER_TOUCH_SENSE_CH7 = 110
SID_FADER_TOUCH_SENSE_CH8 = 111
SID_FADER_TOUCH_SENSE_MASTER = 112
fader_touch_switch_ids = range(SID_FADER_TOUCH_SENSE_CH1, SID_FADER_TOUCH_SENSE_MASTER + 1)
SID_LAST = 112
########NEW FILE########
__FILENAME__ = MackieControl
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl_Classic/MackieControl.py
from consts import *
from MainDisplay import MainDisplay
from MainDisplayController import MainDisplayController
from TimeDisplay import TimeDisplay
from ChannelStrip import ChannelStrip, MasterChannelStrip
from ChannelStripController import ChannelStripController
from SoftwareController import SoftwareController
from Transport import Transport
import Live
import MidiRemoteScript

class MackieControl:
    """Main class that establishes the Mackie Control <-> Live interaction. It acts
       as a container/manager for all the Mackie Control sub-components like ChannelStrips,
       Displays and so on.
       Futher it is glued to Lives MidiRemoteScript C instance, which will forward some
       notifications to us, and lets us forward some requests that are needed beside the
       general Live API (see 'send_midi' or 'request_rebuild_midi_map').
    """

    def __init__(self, c_instance):
        self.__c_instance = c_instance
        self.__components = []
        self.__main_display = MainDisplay(self)
        self.__components.append(self.__main_display)
        self.__main_display_controller = MainDisplayController(self, self.__main_display)
        self.__components.append(self.__main_display_controller)
        self.__time_display = TimeDisplay(self)
        self.__components.append(self.__time_display)
        self.__software_controller = SoftwareController(self)
        self.__components.append(self.__software_controller)
        self.__transport = Transport(self)
        self.__components.append(self.__transport)
        self.__channel_strips = [ ChannelStrip(self, i) for i in range(NUM_CHANNEL_STRIPS) ]
        for s in self.__channel_strips:
            self.__components.append(s)

        self.__master_strip = MasterChannelStrip(self)
        self.__components.append(self.__master_strip)
        self.__channel_strip_controller = ChannelStripController(self, self.__channel_strips, self.__master_strip, self.__main_display_controller)
        self.__components.append(self.__channel_strip_controller)
        self.__shift_is_pressed = False
        self.__option_is_pressed = False
        self.__ctrl_is_pressed = False
        self.__alt_is_pressed = False

    def disconnect(self):
        for c in self.__components:
            c.destroy()

    def connect_script_instances(self, instanciated_scripts):
        """Called by the Application as soon as all scripts are initialized.
           You can connect yourself to other running scripts here, as we do it
           connect the extension modules (MackieControlXTs).
        """
        try:
            from MackieControlXT.MackieControlXT import MackieControlXT
        except:
            print 'failed to load the MackieControl XT script (might not be installed)'

        found_self = False
        right_extensions = []
        left_extensions = []
        for s in instanciated_scripts:
            if s is self:
                found_self = True
            elif isinstance(s, MackieControlXT):
                s.set_mackie_control_main(self)
                if found_self:
                    right_extensions.append(s)
                else:
                    left_extensions.append(s)

        raise found_self or AssertionError
        self.__main_display_controller.set_controller_extensions(left_extensions, right_extensions)
        self.__channel_strip_controller.set_controller_extensions(left_extensions, right_extensions)

    def application(self):
        """returns a reference to the application that we are running in"""
        return Live.Application.get_application()

    def song(self):
        """returns a reference to the Live Song that we do interact with"""
        return self.__c_instance.song()

    def handle(self):
        """returns a handle to the c_interface that is needed when forwarding MIDI events
           via the MIDI map
        """
        return self.__c_instance.handle()

    def refresh_state(self):
        for c in self.__components:
            c.refresh_state()

    def is_extension(self):
        return False

    def request_rebuild_midi_map(self):
        """ To be called from any components, as soon as their internal state changed in a
        way, that we do need to remap the mappings that are processed directly by the
        Live engine.
        Dont assume that the request will immediately result in a call to
        your build_midi_map function. For performance reasons this is only
        called once per GUI frame."""
        self.__c_instance.request_rebuild_midi_map()

    def build_midi_map(self, midi_map_handle):
        """New MIDI mappings can only be set when the scripts 'build_midi_map' function
        is invoked by our C instance sibling. Its either invoked when we have requested it
        (see 'request_rebuild_midi_map' above) or when due to a change in Lives internal state,
        a rebuild is needed."""
        for s in self.__channel_strips:
            s.build_midi_map(midi_map_handle)

        self.__master_strip.build_midi_map(midi_map_handle)
        for i in range(SID_FIRST, SID_LAST + 1):
            if i not in function_key_control_switch_ids:
                Live.MidiMap.forward_midi_note(self.handle(), midi_map_handle, 0, i)

        Live.MidiMap.forward_midi_cc(self.handle(), midi_map_handle, 0, JOG_WHEEL_CC_NO)

    def update_display(self):
        for c in self.__components:
            c.on_update_display_timer()

    def send_midi(self, midi_event_bytes):
        """Use this function to send MIDI events through Live to the _real_ MIDI devices
        that this script is assigned to."""
        self.__c_instance.send_midi(midi_event_bytes)

    def receive_midi(self, midi_bytes):
        if midi_bytes[0] & 240 == NOTE_ON_STATUS or midi_bytes[0] & 240 == NOTE_OFF_STATUS:
            note = midi_bytes[1]
            value = BUTTON_PRESSED if midi_bytes[2] > 0 else BUTTON_RELEASED
            if note in range(SID_FIRST, SID_LAST + 1):
                if note in display_switch_ids:
                    self.__handle_display_switch_ids(note, value)
                if note in channel_strip_switch_ids + fader_touch_switch_ids:
                    for s in self.__channel_strips:
                        s.handle_channel_strip_switch_ids(note, value)

                if note in channel_strip_control_switch_ids:
                    self.__channel_strip_controller.handle_assignment_switch_ids(note, value)
                if note in function_key_control_switch_ids:
                    self.__software_controller.handle_function_key_switch_ids(note, value)
                if note in software_controls_switch_ids:
                    self.__software_controller.handle_software_controls_switch_ids(note, value)
                if note in transport_control_switch_ids:
                    self.__transport.handle_transport_switch_ids(note, value)
                if note in marker_control_switch_ids:
                    self.__transport.handle_marker_switch_ids(note, value)
                if note in jog_wheel_switch_ids:
                    self.__transport.handle_jog_wheel_switch_ids(note, value)
        elif midi_bytes[0] & 240 == CC_STATUS:
            cc_no = midi_bytes[1]
            cc_value = midi_bytes[2]
            if cc_no == JOG_WHEEL_CC_NO:
                self.__transport.handle_jog_wheel_rotation(cc_value)
            elif cc_no in range(FID_PANNING_BASE, FID_PANNING_BASE + NUM_CHANNEL_STRIPS):
                for s in self.__channel_strips:
                    s.handle_vpot_rotation(cc_no - FID_PANNING_BASE, cc_value)

    def can_lock_to_devices(self):
        return False

    def suggest_input_port(self):
        return ''

    def suggest_output_port(self):
        return ''

    def suggest_map_mode(self, cc_no, channel):
        result = Live.MidiMap.MapMode.absolute
        if cc_no in range(FID_PANNING_BASE, FID_PANNING_BASE + NUM_CHANNEL_STRIPS):
            result = Live.MidiMap.MapMode.relative_signed_bit
        return result

    def shift_is_pressed(self):
        return self.__shift_is_pressed

    def set_shift_is_pressed(self, pressed):
        self.__shift_is_pressed = pressed

    def option_is_pressed(self):
        return self.__option_is_pressed

    def set_option_is_pressed(self, pressed):
        self.__option_is_pressed = pressed

    def control_is_pressed(self):
        return self.__control_is_pressed

    def set_control_is_pressed(self, pressed):
        self.__control_is_pressed = pressed

    def alt_is_pressed(self):
        return self.__alt_is_pressed

    def set_alt_is_pressed(self, pressed):
        self.__alt_is_pressed = pressed

    def __handle_display_switch_ids(self, switch_id, value):
        if switch_id == SID_DISPLAY_NAME_VALUE:
            if value == BUTTON_PRESSED:
                self.__channel_strip_controller.toggle_meter_mode()
        elif switch_id == SID_DISPLAY_SMPTE_BEATS:
            if value == BUTTON_PRESSED:
                self.__time_display.toggle_mode()
########NEW FILE########
__FILENAME__ = MackieControlComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl_Classic/MackieControlComponent.py
from consts import *
import Live

class MackieControlComponent:
    """Baseclass for every 'sub component' of the Mackie Control. Just offers some """

    def __init__(self, main_script):
        self.__main_script = main_script

    def destroy(self):
        self.__main_script = None

    def main_script(self):
        return self.__main_script

    def shift_is_pressed(self):
        return self.__main_script.shift_is_pressed()

    def option_is_pressed(self):
        return self.__main_script.option_is_pressed()

    def control_is_pressed(self):
        return self.__main_script.control_is_pressed()

    def alt_is_pressed(self):
        return self.__main_script.alt_is_pressed()

    def song(self):
        return self.__main_script.song()

    def script_handle(self):
        return self.__main_script.handle()

    def application(self):
        return self.__main_script.application()

    def send_midi(self, bytes):
        self.__main_script.send_midi(bytes)

    def request_rebuild_midi_map(self):
        self.__main_script.request_rebuild_midi_map()
########NEW FILE########
__FILENAME__ = MainDisplay
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl_Classic/MainDisplay.py
from MackieControlComponent import *

class MainDisplay(MackieControlComponent):
    """ Representing one main 2 row display of a Mackie Control or Extension
    """

    def __init__(self, main_script):
        MackieControlComponent.__init__(self, main_script)
        self.__stack_offset = 0
        self.__last_send_messages = [[], []]

    def destroy(self):
        NUM_CHARS_PER_DISPLAY_LINE = 54
        upper_message = 'Ableton Live'.center(NUM_CHARS_PER_DISPLAY_LINE)
        self.send_display_string(upper_message, 0, 0)
        lower_message = 'Device is offline'.center(NUM_CHARS_PER_DISPLAY_LINE)
        self.send_display_string(lower_message, 1, 0)
        MackieControlComponent.destroy(self)

    def stack_offset(self):
        return self.__stack_offset

    def set_stack_offset(self, offset):
        """This is the offset that one gets by 'stacking' several MackieControl XTs:
           the first is at index 0, the second at 8, etc ...
        """
        self.__stack_offset = offset

    def send_display_string(self, display_string, display_row, cursor_offset):
        if display_row == 0:
            offset = cursor_offset
        elif display_row == 1:
            offset = NUM_CHARS_PER_DISPLAY_LINE + 2 + cursor_offset
        else:
            raise 0 or AssertionError
        message_string = [ ord(c) for c in display_string ]
        for i in range(len(message_string)):
            if message_string[i] >= 128:
                message_string[i] = 0

        if self.__last_send_messages[display_row] != message_string:
            self.__last_send_messages[display_row] = message_string
            if self.main_script().is_extension():
                device_type = SYSEX_DEVICE_TYPE_XT
            else:
                device_type = SYSEX_DEVICE_TYPE
            display_sysex = (240,
             0,
             0,
             102,
             device_type,
             18,
             offset) + tuple(message_string) + (247,)
            self.send_midi(display_sysex)

    def refresh_state(self):
        self.__last_send_messages = [[], []]

    def on_update_display_timer(self):
        pass
########NEW FILE########
__FILENAME__ = MainDisplayController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl_Classic/MainDisplayController.py
from MackieControlComponent import *

class MainDisplayController(MackieControlComponent):
    """ Controlling all available main displays (the display above the channel strips),
        which will be only one when only using the 'main' Mackie Control, and severals
        when using at least one Mackie Control XT, attached to the main Mackie Control
    
        The Displays can be run in two modes: Channel and Global mode:
        - In channel mode 2*6 characters can be shown for each channel strip
        - In global mode, you can setup the two 54 charchter lines to whatever you want
    
        See 'class ChannelStripController' for descriptions of the stack_index or details
        about the different assignment modes.
    """

    def __init__(self, main_script, display):
        MackieControlComponent.__init__(self, main_script)
        self.__left_extensions = []
        self.__right_extensions = []
        self.__displays = [display]
        self.__own_display = display
        self.__parameters = [ [] for x in range(NUM_CHANNEL_STRIPS) ]
        self.__channel_strip_strings = [ '' for x in range(NUM_CHANNEL_STRIPS) ]
        self.__channel_strip_mode = True
        self.__show_parameter_names = False
        self.__bank_channel_offset = 0
        self.__meters_enabled = False
        self.__show_return_tracks = False

    def destroy(self):
        self.enable_meters(False)
        MackieControlComponent.destroy(self)

    def set_controller_extensions(self, left_extensions, right_extensions):
        """ Called from the main script (after all scripts where initialized), to let us
            know where and how many MackieControlXT are installed.
        """
        self.__left_extensions = left_extensions
        self.__right_extensions = right_extensions
        self.__displays = []
        stack_offset = 0
        for le in left_extensions:
            self.__displays.append(le.main_display())
            le.main_display().set_stack_offset(stack_offset)
            stack_offset += NUM_CHANNEL_STRIPS

        self.__displays.append(self.__own_display)
        self.__own_display.set_stack_offset(stack_offset)
        stack_offset += NUM_CHANNEL_STRIPS
        for re in right_extensions:
            self.__displays.append(re.main_display())
            re.main_display().set_stack_offset(stack_offset)
            stack_offset += NUM_CHANNEL_STRIPS

        self.__parameters = [ [] for x in range(len(self.__displays) * NUM_CHANNEL_STRIPS) ]
        self.__channel_strip_strings = [ '' for x in range(len(self.__displays) * NUM_CHANNEL_STRIPS) ]
        self.refresh_state()

    def enable_meters(self, enabled):
        if self.__meters_enabled != enabled:
            self.__meters_enabled = enabled
            self.refresh_state()

    def set_show_parameter_names(self, enable):
        self.__show_parameter_names = enable

    def set_channel_offset(self, channel_offset):
        self.__bank_channel_offset = channel_offset

    def parameters(self):
        return self.__parameters

    def set_parameters(self, parameters):
        if parameters:
            self.set_channel_strip_strings(None)
        for d in self.__displays:
            self.__parameters = parameters

    def channel_strip_strings(self):
        return self.__channel_strip_strings

    def set_channel_strip_strings(self, channel_strip_strings):
        if channel_strip_strings:
            self.set_parameters(None)
        self.__channel_strip_strings = channel_strip_strings

    def set_show_return_track_names(self, show_returns):
        self.__show_return_tracks = show_returns

    def refresh_state(self):
        for d in self.__displays:
            d.refresh_state()

    def on_update_display_timer(self):
        strip_index = 0
        for display in self.__displays:
            if self.__channel_strip_mode:
                upper_string = u''
                lower_string = u''
                track_index_range = range(self.__bank_channel_offset + display.stack_offset(), self.__bank_channel_offset + display.stack_offset() + NUM_CHANNEL_STRIPS)
                if self.__show_return_tracks:
                    tracks = self.song().return_tracks
                else:
                    tracks = self.song().visible_tracks
                for t in track_index_range:
                    if self.__parameters and self.__show_parameter_names:
                        if self.__parameters[strip_index]:
                            upper_string += self.__generate_6_char_string(self.__parameters[strip_index][1])
                        else:
                            upper_string += self.__generate_6_char_string('')
                    elif t < len(tracks):
                        upper_string += self.__generate_6_char_string(tracks[t].name)
                    else:
                        upper_string += self.__generate_6_char_string('')
                    upper_string += ' '
                    if self.__parameters and self.__parameters[strip_index]:
                        if self.__parameters[strip_index][0]:
                            lower_string += self.__generate_6_char_string(unicode(self.__parameters[strip_index][0]))
                        else:
                            lower_string += self.__generate_6_char_string('')
                    elif self.__channel_strip_strings and self.__channel_strip_strings[strip_index]:
                        lower_string += self.__generate_6_char_string(self.__channel_strip_strings[strip_index])
                    else:
                        lower_string += self.__generate_6_char_string('')
                    lower_string += ' '
                    strip_index += 1

                display.send_display_string(upper_string, 0, 0)
                if not self.__meters_enabled:
                    display.send_display_string(lower_string, 1, 0)
            else:
                ascii_message = '< _1234 guck ma #!?:;_ >'
                if not self.__test:
                    self.__test = 0
                self.__test = self.__test + 1
                if self.__test > NUM_CHARS_PER_DISPLAY_LINE - len(ascii_message):
                    self.__test = 0
                self.send_display_string(ascii_message, 0, self.__test)

    def __generate_6_char_string(self, display_string):
        if not display_string:
            return '      '
        if len(display_string.strip()) > 6 and display_string.endswith('dB') and display_string.find('.') != -1:
            display_string = display_string[:-2]
        if len(display_string) > 6:
            for um in [' ',
             'i',
             'o',
             'u',
             'e',
             'a']:
                while len(display_string) > 6 and display_string.rfind(um, 1) != -1:
                    um_pos = display_string.rfind(um, 1)
                    display_string = display_string[:um_pos] + display_string[um_pos + 1:]

        else:
            display_string = display_string.center(6)
        ret = u''
        for i in range(6):
            ret += display_string[i]

        raise len(ret) == 6 or AssertionError
        return ret
########NEW FILE########
__FILENAME__ = SoftwareController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl_Classic/SoftwareController.py
from MackieControlComponent import *

class SoftwareController(MackieControlComponent):
    """Representing the buttons above the transport, including the basic: """

    def __init__(self, main_script):
        MackieControlComponent.__init__(self, main_script)
        self.__last_can_undo_state = False
        self.__last_can_redo_state = False
        av = self.application().view
        av.add_is_view_visible_listener('Session', self.__update_session_arranger_button_led)
        av.add_is_view_visible_listener('Detail/Clip', self.__update_detail_sub_view_button_led)
        av.add_is_view_visible_listener('Browser', self.__update_browser_button_led)
        av.add_is_view_visible_listener('Detail', self.__update_detail_button_led)
        self.song().view.add_draw_mode_listener(self.__update_draw_mode_button_led)
        self.song().add_back_to_arranger_listener(self.__update_back_to_arranger_button_led)

    def destroy(self):
        av = self.application().view
        av.remove_is_view_visible_listener('Session', self.__update_session_arranger_button_led)
        av.remove_is_view_visible_listener('Detail/Clip', self.__update_detail_sub_view_button_led)
        av.remove_is_view_visible_listener('Browser', self.__update_browser_button_led)
        av.remove_is_view_visible_listener('Detail', self.__update_detail_button_led)
        self.song().view.remove_draw_mode_listener(self.__update_draw_mode_button_led)
        self.song().remove_back_to_arranger_listener(self.__update_back_to_arranger_button_led)
        for note in software_controls_switch_ids:
            self.send_midi((NOTE_ON_STATUS, note, BUTTON_STATE_OFF))

        for note in function_key_control_switch_ids:
            self.send_midi((NOTE_ON_STATUS, note, BUTTON_STATE_OFF))

        MackieControlComponent.destroy(self)

    def handle_function_key_switch_ids(self, switch_id, value):
        raise 0 or AssertionError

    def handle_software_controls_switch_ids(self, switch_id, value):
        if switch_id == SID_MOD_SHIFT:
            self.main_script().set_shift_is_pressed(value == BUTTON_PRESSED)
        elif switch_id == SID_MOD_OPTION:
            self.main_script().set_option_is_pressed(value == BUTTON_PRESSED)
        elif switch_id == SID_MOD_CTRL:
            self.main_script().set_control_is_pressed(value == BUTTON_PRESSED)
        elif switch_id == SID_MOD_ALT:
            self.main_script().set_alt_is_pressed(value == BUTTON_PRESSED)
        elif switch_id == SID_AUTOMATION_ON:
            if value == BUTTON_PRESSED:
                self.__toggle_session_arranger_is_visible()
        elif switch_id == SID_AUTOMATION_RECORD:
            if value == BUTTON_PRESSED:
                self.__toggle_detail_sub_view()
        elif switch_id == SID_AUTOMATION_SNAPSHOT:
            if value == BUTTON_PRESSED:
                self.__toggle_browser_is_visible()
        elif switch_id == SID_AUTOMATION_TOUCH:
            if value == BUTTON_PRESSED:
                self.__toggle_detail_is_visible()
        elif switch_id == SID_FUNC_UNDO:
            if value == BUTTON_PRESSED:
                self.song().undo()
        elif switch_id == SID_FUNC_REDO:
            if value == BUTTON_PRESSED:
                self.song().redo()
        elif switch_id == SID_FUNC_CANCEL:
            if value == BUTTON_PRESSED:
                self.__toggle_back_to_arranger()
        elif switch_id == SID_FUNC_ENTER:
            if value == BUTTON_PRESSED:
                self.__toggle_draw_mode()
        elif switch_id == SID_FUNC_MARKER:
            if value == BUTTON_PRESSED:
                self.song().set_or_delete_cue()
        elif switch_id == SID_FUNC_MIXER:
            if value == BUTTON_PRESSED:
                self.__toggle_follow_song()

    def refresh_state(self):
        self.main_script().set_shift_is_pressed(False)
        self.main_script().set_option_is_pressed(False)
        self.main_script().set_control_is_pressed(False)
        self.main_script().set_alt_is_pressed(False)
        self.__update_session_arranger_button_led()
        self.__update_detail_sub_view_button_led()
        self.__update_browser_button_led()
        self.__update_detail_button_led()
        self.__update_undo_button_led()
        self.__update_redo_button_led()
        self.__update_draw_mode_button_led()
        self.__update_back_to_arranger_button_led()

    def on_update_display_timer(self):
        if self.__last_can_undo_state != self.song().can_undo:
            self.__last_can_undo_state = self.song().can_undo
            self.__update_undo_button_led()
        if self.__last_can_redo_state != self.song().can_redo:
            self.__last_can_redo_state = self.song().can_redo
            self.__update_redo_button_led()

    def __toggle_session_arranger_is_visible(self):
        if self.application().view.is_view_visible('Session'):
            if self.shift_is_pressed():
                self.application().view.focus_view('Session')
            else:
                self.application().view.hide_view('Session')
        elif not self.application().view.is_view_visible('Arranger'):
            raise AssertionError
            self.shift_is_pressed() and self.application().view.focus_view('Arranger')
        else:
            self.application().view.hide_view('Arranger')

    def __toggle_detail_sub_view(self):
        if self.application().view.is_view_visible('Detail/Clip'):
            if self.shift_is_pressed():
                self.application().view.focus_view('Detail/Clip')
            else:
                self.application().view.show_view('Detail/DeviceChain')
        elif self.shift_is_pressed():
            self.application().view.focus_view('Detail/DeviceChain')
        else:
            self.application().view.show_view('Detail/Clip')

    def __toggle_browser_is_visible(self):
        if self.application().view.is_view_visible('Browser'):
            if self.shift_is_pressed():
                self.application().view.focus_view('Browser')
            else:
                self.application().view.hide_view('Browser')
        else:
            self.application().view.show_view('Browser')

    def __toggle_detail_is_visible(self):
        if self.application().view.is_view_visible('Detail'):
            if self.shift_is_pressed():
                self.application().view.focus_view('Detail')
            else:
                self.application().view.hide_view('Detail')
        else:
            self.application().view.show_view('Detail')

    def __toggle_back_to_arranger(self):
        self.song().back_to_arranger = not self.song().back_to_arranger

    def __toggle_draw_mode(self):
        self.song().view.draw_mode = not self.song().view.draw_mode

    def __toggle_follow_song(self):
        self.song().view.follow_song = not self.song().view.follow_song

    def __update_session_arranger_button_led(self):
        if self.application().view.is_view_visible('Session'):
            self.send_midi((NOTE_ON_STATUS, SID_AUTOMATION_ON, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_AUTOMATION_ON, BUTTON_STATE_OFF))

    def __update_detail_sub_view_button_led(self):
        if self.application().view.is_view_visible('Detail/Clip'):
            self.send_midi((NOTE_ON_STATUS, SID_AUTOMATION_RECORD, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_AUTOMATION_RECORD, BUTTON_STATE_OFF))

    def __update_browser_button_led(self):
        if self.application().view.is_view_visible('Browser'):
            self.send_midi((NOTE_ON_STATUS, SID_AUTOMATION_SNAPSHOT, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_AUTOMATION_SNAPSHOT, BUTTON_STATE_OFF))

    def __update_detail_button_led(self):
        if self.application().view.is_view_visible('Detail'):
            self.send_midi((NOTE_ON_STATUS, SID_AUTOMATION_TOUCH, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_AUTOMATION_TOUCH, BUTTON_STATE_OFF))

    def __update_undo_button_led(self):
        if self.song().can_undo:
            self.send_midi((NOTE_ON_STATUS, SID_FUNC_UNDO, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_FUNC_UNDO, BUTTON_STATE_OFF))

    def __update_redo_button_led(self):
        if self.song().can_redo:
            self.send_midi((NOTE_ON_STATUS, SID_FUNC_REDO, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_FUNC_REDO, BUTTON_STATE_OFF))

    def __update_back_to_arranger_button_led(self):
        if self.song().back_to_arranger:
            self.send_midi((NOTE_ON_STATUS, SID_FUNC_CANCEL, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_FUNC_CANCEL, BUTTON_STATE_OFF))

    def __update_draw_mode_button_led(self):
        if self.song().view.draw_mode:
            self.send_midi((NOTE_ON_STATUS, SID_FUNC_ENTER, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_FUNC_ENTER, BUTTON_STATE_OFF))
########NEW FILE########
__FILENAME__ = TimeDisplay
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl_Classic/TimeDisplay.py
from MackieControlComponent import *

class TimeDisplay(MackieControlComponent):
    """Represents the Mackie Controls Time-Display, plus the two LED's that show the"""

    def __init__(self, main_script):
        MackieControlComponent.__init__(self, main_script)
        self.__main_script = main_script
        self.__show_beat_time = False
        self.__smpt_format = Live.Song.TimeFormat.smpte_25
        self.__last_send_time = []
        self.show_beats()

    def destroy(self):
        self.clear_display()
        MackieControlComponent.destroy(self)

    def show_beats(self):
        self.__show_beat_time = True
        self.send_midi((NOTE_ON_STATUS, SELECT_BEATS_NOTE, BUTTON_STATE_ON))
        self.send_midi((NOTE_ON_STATUS, SELECT_SMPTE_NOTE, BUTTON_STATE_OFF))

    def show_smpte(self, smpte_mode):
        self.__show_beat_time = False
        self.__smpt_format = smpte_mode
        self.send_midi((NOTE_ON_STATUS, SELECT_BEATS_NOTE, BUTTON_STATE_OFF))
        self.send_midi((NOTE_ON_STATUS, SELECT_SMPTE_NOTE, BUTTON_STATE_ON))

    def toggle_mode(self):
        if self.__show_beat_time:
            self.show_smpte(self.__smpt_format)
        else:
            self.show_beats()

    def clear_display(self):
        time_string = [ ' ' for i in range(10) ]
        self.__send_time_string(time_string, show_points=False)
        self.send_midi((NOTE_ON_STATUS, SELECT_BEATS_NOTE, BUTTON_STATE_OFF))
        self.send_midi((NOTE_ON_STATUS, SELECT_SMPTE_NOTE, BUTTON_STATE_OFF))

    def refresh_state(self):
        self.show_beats()
        self.__last_send_time = []

    def on_update_display_timer(self):
        """Called by a timer which gets called every 100 ms. We will simply check if the"""
        if self.__show_beat_time:
            time_string = str(self.song().get_current_beats_song_time())
        else:
            time_string = str(self.song().get_current_smpte_song_time(self.__smpt_format))
        time_string = [ c for c in time_string if c not in ('.', ':') ]
        if self.__last_send_time != time_string:
            self.__last_send_time = time_string
            self.__send_time_string(time_string, show_points=True)

    def __send_time_string(self, time_string, show_points):
        raise len(time_string) >= 10 or AssertionError
        for c in range(0, 10):
            char = time_string[9 - c].upper()
            char_code = g7_seg_led_conv_table[char]
            if show_points and c in (3, 5, 7):
                char_code += 64
            self.send_midi((176, 64 + c, char_code))
########NEW FILE########
__FILENAME__ = Transport
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MackieControl_Classic/Transport.py
from MackieControlComponent import *

class Transport(MackieControlComponent):
    """Representing the transport section of the Mackie Control: """

    def __init__(self, main_script):
        MackieControlComponent.__init__(self, main_script)
        self.__forward_button_down = False
        self.____rewind_button_down = False
        self.__zoom_button_down = False
        self.__scrub_button_down = False
        self.__cursor_left_is_down = False
        self.__cursor_right_is_down = False
        self.__cursor_up_is_down = False
        self.__cursor_down_is_down = False
        self.__cursor_repeat_delay = 0
        self.__transport_repeat_delay = 0
        self.____fast_forward_counter = 0
        self.__fast___rewind_counter = 0
        self.__jog_step_count_forward = 0
        self.__jog_step_count_backwards = 0
        self.__last_focussed_clip_play_state = CLIP_STATE_INVALID
        self.song().add_record_mode_listener(self.__update_record_button_led)
        self.song().add_is_playing_listener(self.__update_play_button_led)
        self.song().add_loop_listener(self.__update_loop_button_led)
        self.song().add_punch_out_listener(self.__update_punch_out_button_led)
        self.song().add_punch_in_listener(self.__update_punch_in_button_led)
        self.song().add_can_jump_to_prev_cue_listener(self.__update_prev_cue_button_led)
        self.song().add_can_jump_to_next_cue_listener(self.__update_next_cue_button_led)
        self.application().view.add_is_view_visible_listener('Session', self.__on_session_is_visible_changed)
        self.refresh_state()

    def destroy(self):
        self.song().remove_record_mode_listener(self.__update_record_button_led)
        self.song().remove_is_playing_listener(self.__update_play_button_led)
        self.song().remove_loop_listener(self.__update_loop_button_led)
        self.song().remove_punch_out_listener(self.__update_punch_out_button_led)
        self.song().remove_punch_in_listener(self.__update_punch_in_button_led)
        self.song().remove_can_jump_to_prev_cue_listener(self.__update_prev_cue_button_led)
        self.song().remove_can_jump_to_next_cue_listener(self.__update_next_cue_button_led)
        self.application().view.remove_is_view_visible_listener('Session', self.__on_session_is_visible_changed)
        for note in transport_control_switch_ids:
            self.send_midi((NOTE_ON_STATUS, note, BUTTON_STATE_OFF))

        for note in jog_wheel_switch_ids:
            self.send_midi((NOTE_ON_STATUS, note, BUTTON_STATE_OFF))

        for note in marker_control_switch_ids:
            self.send_midi((NOTE_ON_STATUS, note, BUTTON_STATE_OFF))

        MackieControlComponent.destroy(self)

    def refresh_state(self):
        self.__update_play_button_led()
        self.__update_record_button_led()
        self.__update_prev_cue_button_led()
        self.__update_next_cue_button_led()
        self.__update_loop_button_led()
        self.__update_punch_in_button_led()
        self.__update_punch_out_button_led()
        self.__forward_button_down = False
        self.____rewind_button_down = False
        self.__zoom_button_down = False
        self.__scrub_button_down = False
        self.__cursor_left_is_down = False
        self.__cursor_right_is_down = False
        self.__cursor_up_is_down = False
        self.__cursor_down_is_down = False
        self.__cursor_repeat_delay = 0
        self.__transport_repeat_delay = 0
        self.____fast_forward_counter = 0
        self.__fast___rewind_counter = 0
        self.__jog_step_count_forward = 0
        self.__jog_step_count_backwards = 0
        self.__last_focussed_clip_play_state = CLIP_STATE_INVALID
        self.__update_forward_rewind_leds()
        self.__update_zoom_button_led()
        self.__update_scrub_button_led()

    def session_is_visible(self):
        return self.application().view.is_view_visible('Session')

    def selected_clip_slot(self):
        return self.song().view.highlighted_clip_slot

    def on_update_display_timer(self):
        if self.__transport_repeat_delay > 2:
            if self.alt_is_pressed():
                base_acceleration = 1
            else:
                base_acceleration = self.song().signature_numerator
            if self.song().is_playing:
                base_acceleration *= 4
            if self.__forward_button_down:
                if not self.____rewind_button_down:
                    if self.__forward_button_down:
                        self.____fast_forward_counter += 1
                        self.__fast___rewind_counter -= 4
                        if not self.alt_is_pressed():
                            self.__fast_forward(base_acceleration + max(1, self.____fast_forward_counter / 4))
                        else:
                            self.__fast_forward(base_acceleration)
                    if self.____rewind_button_down:
                        self.__fast___rewind_counter += 1
                        self.____fast_forward_counter -= 4
                        if not self.alt_is_pressed():
                            self.__rewind(base_acceleration + max(1, self.__fast___rewind_counter / 4))
                        else:
                            self.__rewind(base_acceleration)
            else:
                self.__transport_repeat_delay += 1
            if self.__cursor_repeat_delay > 2:
                if self.__cursor_left_is_down:
                    self.__on_cursor_left_pressed()
                if self.__cursor_right_is_down:
                    self.__on_cursor_right_pressed()
                if self.__cursor_up_is_down:
                    self.__on_cursor_up_pressed()
                if self.__cursor_down_is_down:
                    self.__on_cursor_down_pressed()
            else:
                self.__cursor_repeat_delay += 1
            self.session_is_visible() and self.__update_zoom_led_in_session()

    def handle_marker_switch_ids(self, switch_id, value):
        if switch_id == SID_MARKER_FROM_PREV:
            if value == BUTTON_PRESSED:
                self.__jump_to_prev_cue()
        elif switch_id == SID_MARKER_FROM_NEXT:
            if value == BUTTON_PRESSED:
                self.__jump_to_next_cue()
        elif switch_id == SID_MARKER_LOOP:
            if value == BUTTON_PRESSED:
                self.__toggle_loop()
        elif switch_id == SID_MARKER_PI:
            if value == BUTTON_PRESSED:
                if self.control_is_pressed():
                    self.__set_loopstart_from_cur_position()
                else:
                    self.__toggle_punch_in()
        elif switch_id == SID_MARKER_PO:
            if value == BUTTON_PRESSED:
                if self.control_is_pressed():
                    self.__set_loopend_from_cur_position()
                else:
                    self.__toggle_punch_out()
        elif switch_id == SID_MARKER_HOME:
            if value == BUTTON_PRESSED:
                self.__goto_home()
        elif switch_id == SID_MARKER_END:
            if value == BUTTON_PRESSED:
                self.__goto_end()

    def handle_transport_switch_ids(self, switch_id, value):
        if switch_id == SID_TRANSPORT_REWIND:
            if value == BUTTON_PRESSED:
                self.__rewind()
                self.____rewind_button_down = True
            elif value == BUTTON_RELEASED:
                self.____rewind_button_down = False
                self.__fast___rewind_counter = 0
            self.__update_forward_rewind_leds()
        elif switch_id == SID_TRANSPORT_FAST_FORWARD:
            if value == BUTTON_PRESSED:
                self.__fast_forward()
                self.__forward_button_down = True
            elif value == BUTTON_RELEASED:
                self.__forward_button_down = False
                self.____fast_forward_counter = 0
            self.__update_forward_rewind_leds()
        elif switch_id == SID_TRANSPORT_STOP:
            if value == BUTTON_PRESSED:
                self.__stop_song()
        elif switch_id == SID_TRANSPORT_PLAY:
            if value == BUTTON_PRESSED:
                self.__start_song()
        elif switch_id == SID_TRANSPORT_RECORD:
            if value == BUTTON_PRESSED:
                self.__toggle_record()

    def handle_jog_wheel_rotation(self, value):
        backwards = value >= 64
        if self.control_is_pressed():
            if self.alt_is_pressed():
                step = 0.1
            else:
                step = 1.0
            if backwards:
                amount = -(value - 64)
            else:
                amount = value
            tempo = max(20, min(999, self.song().tempo + amount * step))
            self.song().tempo = tempo
        elif self.session_is_visible():
            num_steps_per_session_scroll = 4
            if backwards:
                self.__jog_step_count_backwards += 1
                if self.__jog_step_count_backwards >= num_steps_per_session_scroll:
                    self.__jog_step_count_backwards = 0
                    step = -1
                else:
                    step = 0
            else:
                self.__jog_step_count_forward += 1
                if self.__jog_step_count_forward >= num_steps_per_session_scroll:
                    self.__jog_step_count_forward = 0
                    step = 1
                else:
                    step = 0
            if step:
                new_index = list(self.song().scenes).index(self.song().view.selected_scene) + step
                new_index = min(len(self.song().scenes) - 1, max(0, new_index))
                self.song().view.selected_scene = self.song().scenes[new_index]
        else:
            if backwards:
                step = max(1.0, (value - 64) / 2.0)
            else:
                step = max(1.0, value / 2.0)
            if self.song().is_playing:
                step *= 4.0
            if self.alt_is_pressed():
                step /= 4.0
            if self.__scrub_button_down:
                if backwards:
                    self.song().scrub_by(-step)
                else:
                    self.song().scrub_by(step)
            elif backwards:
                self.song().jump_by(-step)
            else:
                self.song().jump_by(step)

    def handle_jog_wheel_switch_ids(self, switch_id, value):
        if switch_id == SID_JOG_CURSOR_UP:
            if value == BUTTON_PRESSED:
                self.__cursor_up_is_down = True
                self.__cursor_repeat_delay = 0
                self.__on_cursor_up_pressed()
            elif value == BUTTON_RELEASED:
                self.__cursor_up_is_down = False
        elif switch_id == SID_JOG_CURSOR_DOWN:
            if value == BUTTON_PRESSED:
                self.__cursor_down_is_down = True
                self.__cursor_repeat_delay = 0
                self.__on_cursor_down_pressed()
            elif value == BUTTON_RELEASED:
                self.__cursor_down_is_down = False
        elif switch_id == SID_JOG_CURSOR_LEFT:
            if value == BUTTON_PRESSED:
                self.__cursor_left_is_down = True
                self.__cursor_repeat_delay = 0
                self.__on_cursor_left_pressed()
            elif value == BUTTON_RELEASED:
                self.__cursor_left_is_down = False
        elif switch_id == SID_JOG_CURSOR_RIGHT:
            if value == BUTTON_PRESSED:
                self.__cursor_right_is_down = True
                self.__cursor_repeat_delay = 0
                self.__on_cursor_right_pressed()
            elif value == BUTTON_RELEASED:
                self.__cursor_right_is_down = False
        elif switch_id == SID_JOG_ZOOM:
            if value == BUTTON_PRESSED:
                if self.session_is_visible():
                    if self.selected_clip_slot():
                        if self.alt_is_pressed():
                            self.selected_clip_slot().has_stop_button = not self.selected_clip_slot().has_stop_button
                        elif self.option_is_pressed():
                            self.selected_clip_slot().stop()
                        else:
                            self.selected_clip_slot().fire()
                else:
                    self.__zoom_button_down = not self.__zoom_button_down
                    self.__update_zoom_button_led()
        elif switch_id == SID_JOG_SCRUB:
            if value == BUTTON_PRESSED:
                if self.session_is_visible():
                    if self.option_is_pressed():
                        self.song().stop_all_clips()
                    else:
                        self.song().view.selected_scene.fire_as_selected()
                else:
                    self.__scrub_button_down = not self.__scrub_button_down
                    self.__update_scrub_button_led()

    def __on_cursor_up_pressed(self):
        nav = Live.Application.Application.View.NavDirection
        if self.__zoom_button_down:
            self.application().view.zoom_view(nav.up, '', self.alt_is_pressed())
        else:
            self.application().view.scroll_view(nav.up, '', self.alt_is_pressed())

    def __on_cursor_down_pressed(self):
        nav = Live.Application.Application.View.NavDirection
        if self.__zoom_button_down:
            self.application().view.zoom_view(nav.down, '', self.alt_is_pressed())
        else:
            self.application().view.scroll_view(nav.down, '', self.alt_is_pressed())

    def __on_cursor_left_pressed(self):
        nav = Live.Application.Application.View.NavDirection
        if self.__zoom_button_down:
            self.application().view.zoom_view(nav.left, '', self.alt_is_pressed())
        else:
            self.application().view.scroll_view(nav.left, '', self.alt_is_pressed())

    def __on_cursor_right_pressed(self):
        nav = Live.Application.Application.View.NavDirection
        if self.__zoom_button_down:
            self.application().view.zoom_view(nav.right, '', self.alt_is_pressed())
        else:
            self.application().view.scroll_view(nav.right, '', self.alt_is_pressed())

    def __toggle_record(self):
        self.song().record_mode = not self.song().record_mode

    def __rewind(self, acceleration = 1):
        beats = acceleration
        self.song().jump_by(-beats)

    def __fast_forward(self, acceleration = 1):
        beats = acceleration
        self.song().jump_by(beats)

    def __stop_song(self):
        self.song().stop_playing()

    def __start_song(self):
        if self.shift_is_pressed():
            if not self.song().is_playing:
                self.song().continue_playing()
            else:
                self.song().stop_playing()
        elif self.control_is_pressed():
            self.song().play_selection()
        else:
            self.song().start_playing()

    def __toggle_follow(self):
        self.song().follow_song = not self.song().follow_song

    def __toggle_loop(self):
        self.song().loop = not self.song().loop

    def __toggle_punch_in(self):
        self.song().punch_in = not self.song().punch_in

    def __toggle_punch_out(self):
        self.song().punch_out = not self.song().punch_out

    def __jump_to_prev_cue(self):
        self.song().jump_to_prev_cue()

    def __jump_to_next_cue(self):
        self.song().jump_to_next_cue()

    def __set_loopstart_from_cur_position(self):
        if self.song().current_song_time < self.song().loop_start + self.song().loop_length:
            old_loop_start = self.song().loop_start
            self.song().loop_start = self.song().current_song_time
            self.song().loop_length += old_loop_start - self.song().loop_start

    def __set_loopend_from_cur_position(self):
        if self.song().current_song_time > self.song().loop_start:
            self.song().loop_length = self.song().current_song_time - self.song().loop_start

    def __goto_home(self):
        self.song().current_song_time = 0

    def __goto_end(self):
        self.song().current_song_time = self.song().last_event_time

    def __on_session_is_visible_changed(self):
        if not self.session_is_visible():
            self.__update_zoom_button_led()

    def __update_zoom_led_in_session(self):
        if self.session_is_visible():
            clip_slot = self.selected_clip_slot()
            if clip_slot and clip_slot.clip:
                if clip_slot.clip.is_triggered:
                    state = CLIP_TRIGGERED
                elif clip_slot.clip.is_playing:
                    state = CLIP_PLAYING
                else:
                    state = CLIP_STOPPED
            else:
                state = CLIP_STOPPED
            if state != self.__last_focussed_clip_play_state:
                self.__last_focussed_clip_play_state = state
                if state == CLIP_PLAYING:
                    self.send_midi((NOTE_ON_STATUS, SID_JOG_ZOOM, BUTTON_STATE_ON))
                elif state == CLIP_TRIGGERED:
                    self.send_midi((NOTE_ON_STATUS, SID_JOG_ZOOM, BUTTON_STATE_BLINKING))
                else:
                    self.send_midi((NOTE_ON_STATUS, SID_JOG_ZOOM, BUTTON_STATE_OFF))

    def __update_forward_rewind_leds(self):
        if self.__forward_button_down:
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_FAST_FORWARD, BUTTON_STATE_ON))
            self.__transport_repeat_delay = 0
        else:
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_FAST_FORWARD, BUTTON_STATE_OFF))
        if self.____rewind_button_down:
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_REWIND, BUTTON_STATE_ON))
            self.__transport_repeat_delay = 0
        else:
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_REWIND, BUTTON_STATE_OFF))

    def __update_zoom_button_led(self):
        if self.__zoom_button_down:
            self.send_midi((NOTE_ON_STATUS, SID_JOG_ZOOM, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_JOG_ZOOM, BUTTON_STATE_OFF))

    def __update_scrub_button_led(self):
        if self.__scrub_button_down:
            self.send_midi((NOTE_ON_STATUS, SID_JOG_SCRUB, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_JOG_SCRUB, BUTTON_STATE_OFF))

    def __update_play_button_led(self):
        if self.song().is_playing:
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_PLAY, BUTTON_STATE_ON))
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_STOP, BUTTON_STATE_OFF))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_PLAY, BUTTON_STATE_OFF))
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_STOP, BUTTON_STATE_ON))

    def __update_record_button_led(self):
        if self.song().record_mode:
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_RECORD, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_TRANSPORT_RECORD, BUTTON_STATE_OFF))

    def __update_follow_song_button_led(self):
        if self.song().follow_song:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_FROM_PREV, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_FROM_PREV, BUTTON_STATE_OFF))

    def __update_prev_cue_button_led(self):
        if self.song().can_jump_to_prev_cue:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_FROM_PREV, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_FROM_PREV, BUTTON_STATE_OFF))

    def __update_next_cue_button_led(self):
        if self.song().can_jump_to_next_cue:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_FROM_NEXT, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_FROM_NEXT, BUTTON_STATE_OFF))

    def __update_loop_button_led(self):
        if self.song().loop:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_LOOP, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_LOOP, BUTTON_STATE_OFF))

    def __update_punch_in_button_led(self):
        if self.song().punch_in:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_PI, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_PI, BUTTON_STATE_OFF))

    def __update_punch_out_button_led(self):
        if self.song().punch_out:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_PO, BUTTON_STATE_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, SID_MARKER_PO, BUTTON_STATE_OFF))
########NEW FILE########
__FILENAME__ = ControlHandler
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk1\ControlHandler.py
import Live
import time
from _Generic.Devices import *
from _Framework.ButtonElement import *
from _Framework.CompoundComponent import *
from MIDI_Map import *
from SceneElement import SceneElement
N_PARM_RANGE = 127

class ControlHandler:
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, surface, matrix):
        self.surface = surface
        self.matrix = matrix
        self.mode = CONTROL_LEVEL
        self.sel_track_parm_index = 0
        self.track = None
        self.selected_sends_index = 0
        self.selected_device = None
        self.selected_bank = 0
        self.selected_device_parm_index = 0
        self.parm = None
        self.parm_is_quant = False
        self.parm_raster_value = 0
        self.parm_range = 0

    def get_mode_color(self, value, mode):
        if value == 0:
            bright = 8
        else:
            bright = 127
        if mode == CONTROL_LEVEL:
            return [27, 127, bright]
        elif mode == CONTROL_PAN:
            return [4, 127, bright]
        elif mode == CONTROL_SEND:
            return [10, 127, bright]
        elif mode == CONTROL_DEVICE:
            return [85, 127, bright]

    def nr_of_parms_in_bank(self):
        if self.selected_device == None:
            return 0
        nr_of_parms = len(self.selected_device.parameters)
        bip = nr_of_parms - 8 * self.selected_bank
        if bip < 8:
            return bip
        return 8

    def inc_bank_nr(self):
        if self.selected_device == None or self.selected_bank + 1 >= self.nr_of_banks():
            return False
        self.selected_bank += 1
        self.surface.show_message('Bank ' + str(self.selected_bank + 1) + ' : ' + str(self.selected_device.name))
        self.reassign_device_parm()
        parminfo = ''
        if self.parm != None:
            parminfo = str(self.parm.name)
        self.surface.show_message(str(self.selected_device.name) + 'Bank ' + str(self.selected_bank + 1) + ' : ' + parminfo)
        return True

    def dec_bank_nr(self):
        if self.selected_device == None or self.selected_bank == 0:
            return False
        self.selected_bank -= 1
        self.reassign_device_parm()
        parminfo = ''
        if self.parm != None:
            parminfo = str(self.parm.name)
        self.surface.show_message(str(self.selected_device.name) + 'Bank ' + str(self.selected_bank + 1) + ' : ' + parminfo)
        return True

    def nr_of_banks(self):
        if self.selected_device == None:
            return 0
        parms = len(self.selected_device.parameters)
        if parms == 0:
            return 0
        return parms / 8 + 1

    def index_parm_id(self, index):
        if index > 11:
            return index - 12
        else:
            return index - 4
        return 0

    def index_mode_id(self, index):
        if index > 4 and index < 8:
            return index - 4
        return 0

    def set_device(self, device):
        self.selected_device = device
        self.selected_bank = 0
        self.reassign_device_parm()

    def set_track(self, index):
        self.track = self.surface._mixer._channel_strips[index]._track

    def reassign_mix_parm(self):
        self.assign_mix_parm(self.track, self.sel_track_parm_index)

    def message_current_parm(self):
        if self.track == None:
            return
        message = 'Control Track : ' + str(self.track.name) + ': '
        if self.mode == CONTROL_LEVEL:
            self.surface.show_message(message + 'Volume')
        elif self.mode == CONTROL_PAN:
            self.surface.show_message(message + 'Pan')
        elif self.mode == CONTROL_SEND:
            self.surface.show_message(message + 'Send ' + SENDS[self.selected_sends_index])
        elif self.mode == CONTROL_DEVICE:
            return 'Device'

    def assign_mix_parm(self, track, index):
        prev = self.parm
        if track == None:
            self.parm = None
            return prev != self.parm
        self.track = track
        self.parm_is_quant = False
        if self.mode == CONTROL_LEVEL:
            self.parm = track.mixer_device.volume
        elif self.mode == CONTROL_PAN:
            self.parm = track.mixer_device.panning
        elif self.mode == CONTROL_SEND:
            nr_of_ret_tracks = len(track.mixer_device.sends)
            if self.selected_sends_index < nr_of_ret_tracks and self.selected_sends_index != -1:
                self.parm = track.mixer_device.sends[self.selected_sends_index]
        self.set_knob_int_value(self.parm)
        self.sel_track_parm_index = index
        return prev != self.parm

    def reassign_device_parm(self):
        self.assign_device_parm(self.selected_device_parm_index, False)

    def assign_device_parm(self, index, showmessage = True):
        prev = self.parm
        if self.mode != CONTROL_DEVICE or self.selected_device == None:
            self.parm = None
            return prev != self.parm
        parms = self.selected_device.parameters
        self.selected_device_parm_index = min(index, self.nr_of_parms_in_bank() - 1)
        parm = parms[self.selected_bank * 8 + self.selected_device_parm_index]
        if parm.is_quantized:
            self.parm_is_quant = True
        else:
            self.parm_is_quant = False
            self.set_knob_int_value(parm)
        if showmessage:
            self.surface.show_message('Device : ' + str(self.selected_device.name) + ' : ' + str(parm.name))
        self.parm = parm
        self.parm_range = parm.max - parm.min
        return prev != self.parm

    def set_knob_int_value(self, parm):
        parm_range = parm.max - parm.min
        self.parm_raster_value = int((parm.value - parm.min) / parm_range * N_PARM_RANGE + 0.1)

    def is_quantized(self, parm):
        self.set_knob_int_value(parm)
        return False

    def mod_value(self, delta, shift):
        if self.parm == None:
            return
        if self.mode == CONTROL_DEVICE:
            if self.parm_is_quant:
                self.parm.value = self.change_parm(self.parm, delta)
                if shift and self.parm_range > 30:
                    self.repeat(self.parm, delta)
            else:
                new_value = self.change_parm(self.parm, delta)
                self.parm.value = new_value
                if not self.is_equal(self.parm.value, new_value):
                    self.parm_is_quant = True
                if not self.parm_is_quant and shift:
                    self.repeat(self.parm, delta)
            self.surface.show_message(' ' + str(self.selected_device.name) + ' : ' + str(self.parm.name) + ' : ' + str(self.parm))
        else:
            self.parm.value = self.change_parm(self.parm, delta)
            if shift:
                self.repeat(self.parm, delta)

    def is_equal(self, val1, val2):
        if val1 == val2:
            return True
        if abs(val1 - val2) < 0.005:
            return True
        return False

    def repeat(self, parm, delta):
        count = 0
        while count < SHIFT_INC - 1:
            parm.value = self.change_parm(parm, delta)
            count += 1

    def change_parm(self, parm, delta):
        if self.parm_is_quant:
            parm_range = parm.max - parm.min + 1
            new_val = min(parm.max, max(parm.min, parm.value + delta))
            return float(new_val)
        else:
            parm_range = parm.max - parm.min
            self.parm_raster_value = min(N_PARM_RANGE, max(0, self.parm_raster_value + delta))
            return float(self.parm_raster_value) / float(N_PARM_RANGE) * parm_range + parm.min

    def disconnect(self):
        self.surface = None
        self.matrix = None
        self.track = None
        self.selected_device = None
        self.parm = None
########NEW FILE########
__FILENAME__ = MainKnobControl
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk1\MainKnobControl.py
import Live
import time
from MIDI_Map import *
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import *
from VarButtonElement import ColorButton
from StateButton import StateButton, ToggleButton
KN2_MODE_VOLUME = 1
KN2_MODE_CUE = 2
KN2_MODE_QUANT = 3
KN2_MODE_TEMPO_COARSE = 4
KN2_MODE_TEMPO_FINE = 5
KN2_MODE_CLIP_QUANT = 6
KN2_MODE_CLIPN_HOR = 7
KN2_MODE_CLIPN_VER = 8
KN2_MODE_XFADE = 9
KN2_MODE_GENERAL = 10
KN2_P_SCALES = 11
LEFT_DOWN = 1
RIGHT_DOWN = 2
PARM_RANGE = 127
QUANT_DESCR = (' No Rec Quantize', ' 1/4 Rec Quantize', ' 1/8 Rec Quantize', ' 1/8 Rec Triplet Quantize', '1/8 & 1/8 Triplet Quantize', ' 1/16 Rec Quantize', ' 1/16 Triplet Rec Quantize', ' 1/16 & 1/16 Triplet Rec Quantize', '1/32 Rec Quantize')
QUANT_CONST = (Live.Song.RecordingQuantization.rec_q_no_q,
 Live.Song.RecordingQuantization.rec_q_quarter,
 Live.Song.RecordingQuantization.rec_q_eight,
 Live.Song.RecordingQuantization.rec_q_eight_triplet,
 Live.Song.RecordingQuantization.rec_q_eight_eight_triplet,
 Live.Song.RecordingQuantization.rec_q_sixtenth,
 Live.Song.RecordingQuantization.rec_q_sixtenth_triplet,
 Live.Song.RecordingQuantization.rec_q_sixtenth_sixtenth_triplet,
 8)
CLIQ_DESCR = ('None', '8 Bars', '4 Bars', '2 Bars', '1 Bar', '1/2', '1/2T', '1/4', '1/4T', '1/8', '1/8T', '1/16', '1/16T', '1/32')
LR_CONTROL_CLIP = 0
LR_CONTROL_SEL = 1
LR_CONTROL_DEV = 2
LR_CONTROL_LOOP = 3
LR_MODE_HUES = (6, 14, 39, 90)
L_MODE_FUNCTION = ('Clip Horizontal', 'Track Selection', 'Track Selection', 'Loop Start')
R_MODE_FUNCTION = ('Clip Vertical', 'Scene Selection', 'Device Selection', 'Loop Length')
LOOP_KNOB_DIVISION = (4.0, 1.0, 0.5)
PAD_KNOB_OCTAVE = 1
PAD_KNOB_SCALE = 2
PAD_KNOB_BASEN = 4

class MainKnobControl:
    __module__ = __name__
    __doc__ = 'Mk2 Module for Controlling Parameters with Master Knob'

    def __init__(self, parent):
        self._parent = parent
        self.master_track = parent.song().master_track
        self.the_slider = SliderElement(MIDI_CC_TYPE, 1, 86)
        self.the_slider.add_value_listener(self._do_main_slider, True)
        self.volume_button = None
        self._set_volume_button(StateButton(True, MIDI_CC_TYPE, 1, 80))
        self.xfade_button = None
        self._set_xfade_button(StateButton(True, MIDI_CC_TYPE, 1, 99))
        self.swing_button = None
        self._set_swing_button(StateButton(True, MIDI_CC_TYPE, 1, 81))
        self.mode = KN2_MODE_VOLUME
        self.previous_mode = -1
        self.tempo_button = None
        self._set_tempo_button(StateButton(True, MIDI_CC_TYPE, 1, 82))
        self.push_button = None
        self._set_push_button(StateButton(True, MIDI_CC_TYPE, 1, 87))
        self.clipn_v_button = None
        self.clipn_h_button = None
        self._set_clipn_h_button(StateButton(True, MIDI_CC_TYPE, 1, 90))
        self._set_clipn_v_button(StateButton(True, MIDI_CC_TYPE, 1, 91))
        self.toggle_buttons = [self.volume_button,
         self.xfade_button,
         self.swing_button,
         self.tempo_button,
         self.clipn_h_button,
         self.clipn_v_button]
        self.shift_button = None
        self._set_shift_button(StateButton(True, MIDI_CC_TYPE, 1, 85))
        self.shift_on = False
        self.scroll_mod_left_button = None
        self.scroll_mod_right_button = None
        self._set_scroll_mod_left_button(ButtonElement(True, MIDI_CC_TYPE, 0, 105))
        self._set_scroll_mod_right_button(ButtonElement(True, MIDI_CC_TYPE, 0, 106))
        self._prev_mode = KN2_MODE_VOLUME
        self.lrmode = LR_CONTROL_CLIP
        self.loop_div_index = 0
        self.loop_incdex = 4.0
        self.arrow_mode_button = ColorButton(True, MIDI_CC_TYPE, 30)
        self.arrow_mode_button.add_value_listener(self.toggle_arrow_mode)
        self.arrow_mode_button.send_value(1, True)
        self.navflags = 0
        self.octave_mod_button = ButtonElement(True, MIDI_CC_TYPE, 1, 70)
        self.octave_mod_button.add_value_listener(self._action_octave)
        self.scale_mod_button = ButtonElement(True, MIDI_CC_TYPE, 1, 71)
        self.scale_mod_button.add_value_listener(self._action_scale)
        self.basenote_mod_button = ButtonElement(True, MIDI_CC_TYPE, 1, 72)
        self.basenote_mod_button.add_value_listener(self._action_base_note)
        self.pad_to_mainknob_mode = 0
        self.octave_dwn_button = ButtonElement(True, MIDI_CC_TYPE, 3, 120)
        self.octave_upp_button = ButtonElement(True, MIDI_CC_TYPE, 3, 121)
        self.scale_dwn_button = ButtonElement(True, MIDI_CC_TYPE, 3, 118)
        self.scale_upp_button = ButtonElement(True, MIDI_CC_TYPE, 3, 119)
        self.basent_dwn_button = ButtonElement(True, MIDI_CC_TYPE, 3, 124)
        self.basent_upp_button = ButtonElement(True, MIDI_CC_TYPE, 3, 125)
        self.octave_dwn_button.add_value_listener(self._action_oct_down)
        self.octave_upp_button.add_value_listener(self._action_oct_up)
        self.scale_dwn_button.add_value_listener(self._action_scale_down)
        self.scale_upp_button.add_value_listener(self._action_scale_up)
        self.basent_dwn_button.add_value_listener(self._action_base_down)
        self.basent_upp_button.add_value_listener(self._action_base_up)
        self._measure_left_click = 0
        self._measure_right_click = 0
        self.mode_assign_map = {KN2_MODE_VOLUME: (self.chg_volume,
                           0,
                           'Master Knob controls MASTER Volume',
                           KN2_MODE_CUE),
         KN2_MODE_CUE: (self.chg_cue,
                        0,
                        'Master Knob controls Cue Level',
                        KN2_MODE_VOLUME),
         KN2_MODE_TEMPO_COARSE: (self.chg_tempo,
                                 3,
                                 'Master Knob controls TEMPO Coarse',
                                 KN2_MODE_TEMPO_FINE),
         KN2_MODE_TEMPO_FINE: (self.chg_tempo_fine,
                               3,
                               'Master Knob controls TEMPO Fine',
                               KN2_MODE_TEMPO_COARSE),
         KN2_MODE_XFADE: (self.chg_xfade,
                          1,
                          'Master Knob controls Crossfader',
                          -1),
         KN2_MODE_QUANT: (self.chg_quant,
                          2,
                          'Master Knob controls Recording Quantize',
                          KN2_MODE_CLIP_QUANT),
         KN2_MODE_CLIP_QUANT: (self.chg_clip_q,
                               2,
                               'Master Knob controls Clip Start Quantize',
                               KN2_MODE_QUANT),
         KN2_MODE_CLIPN_HOR: (self.nav_c_hor,
                              4,
                              'Master Knob Clip View horizontally',
                              -1),
         KN2_MODE_CLIPN_VER: (self.nav_c_ver,
                              5,
                              'Master Knob Clip View vertically',
                              -1),
         KN2_MODE_GENERAL: (self.chg_general,
                            -1,
                            None,
                            -1),
         KN2_P_SCALES: (self.modify_pad_scaling,
                        -1,
                        None,
                        -1)}

    def start_up(self):
        self._set_mode(KN2_MODE_VOLUME)
        self.arrow_mode_button.send_value(127, True)

    def toggle_arrow_mode(self, value):
        if value > 0:
            self.lrmode = (self.lrmode + 1) % 4
            self.arrow_mode_button.send_hue(LR_MODE_HUES[self.lrmode])
            self._parent.show_message('Left/Right Buttons Control:    ' + L_MODE_FUNCTION[self.lrmode] + ' / ' + R_MODE_FUNCTION[self.lrmode])

    def switch_to_matrix_mode(self):
        if self.mode != KN2_MODE_GENERAL:
            self.previous_mode = self.mode
            self._set_mode(KN2_MODE_GENERAL)

    def exit_matrix_mode(self):
        if self.mode == KN2_MODE_GENERAL:
            self._set_mode(self.previous_mode)
            self.previous_mode = -1

    def update_shift(self):
        if self.shift_on:
            self.shift_button.send_value(127, True)
        else:
            self.shift_button.send_value(0, True)

    def _set_mode(self, mode):
        if not mode in range(11):
            raise AssertionError
            self.update_shift()
            if mode == self.mode:
                return
            self._prev_mode = mode
            self.mode = mode
            self.switch_radio_buttons(self.mode_assign_map[self.mode][1])
            message = self.mode_assign_map[self.mode][2]
            message != None and self._parent.show_message(message)

    def switch_radio_buttons(self, which):
        for index in range(len(self.toggle_buttons)):
            if index == which:
                self.toggle_buttons[index].send_value(127, True)
            else:
                self.toggle_buttons[index].send_value(0, True)

    def update(self):
        self.switch_radio_buttons(self.mode_assign_map[self.mode][1])
        self.arrow_mode_button.send_color(LR_MODE_HUES[self.lrmode])
        self.arrow_mode_button.send_value(127, True)

    def _do_main_slider(self, value, encoder):
        if not value in range(128):
            raise AssertionError
            if not isinstance(encoder, EncoderElement):
                raise AssertionError
                if value == 1:
                    delta = 1
                else:
                    delta = -1
                if self.pad_to_mainknob_mode != 0:
                    self.mode_assign_map[KN2_P_SCALES][0](delta)
                elif self.navflags == 0:
                    self.mode_assign_map[self.mode][0](delta)
                if self.lrmode == LR_CONTROL_CLIP:
                    self.navflags & LEFT_DOWN != 0 and self.nav_c_hor(delta)
                self.navflags & RIGHT_DOWN != 0 and self.nav_c_ver(delta)
        elif self.lrmode == LR_CONTROL_SEL:
            if self.navflags & LEFT_DOWN != 0:
                self.nav_track(delta)
            if self.navflags & RIGHT_DOWN != 0:
                self._parent.scroll_scene(delta)
        elif self.lrmode == LR_CONTROL_DEV:
            if self.navflags & LEFT_DOWN != 0:
                self.nav_track(delta)
            if self.navflags & RIGHT_DOWN != 0:
                self._parent.scroll_device(delta)
        elif self.lrmode == LR_CONTROL_LOOP:
            if self.navflags & LEFT_DOWN != 0:
                self.adjust_loop_start(delta)
            if self.navflags & RIGHT_DOWN != 0:
                self.adjust_loop_length(delta)

    def modify_pad_scaling(self, delta):
        if self.pad_to_mainknob_mode & PAD_KNOB_OCTAVE != 0:
            self._parent.inc_octave(delta)
        if self.pad_to_mainknob_mode & PAD_KNOB_SCALE != 0:
            self._parent.inc_scale(delta)
        if self.pad_to_mainknob_mode & PAD_KNOB_BASEN != 0:
            self._parent.inc_base_note(delta)

    def adjust_loop_start(self, delta):
        loopval = self._parent.song().loop_start
        loopval += self.loop_incdex * delta
        if loopval < 0:
            loopval = 0
        elif loopval > 999:
            loopval = 999
        self._parent.song().loop_start = loopval

    def adjust_loop_length(self, delta):
        loopval = self._parent.song().loop_length
        loopval += self.loop_incdex * delta
        if loopval < self.loop_incdex:
            loopval = self.loop_incdex
        elif loopval > 999:
            loopval = 999
        self._parent.song().loop_length = loopval

    def chg_general(self, delta):
        self._parent._scenematrix.control_handler.mod_value(delta, self.shift_on)

    def nav_track(self, direction):
        if direction == 1:
            self._parent._a_trk_right(1)
        else:
            self._parent._a_trk_left(1)

    def nav_c_hor(self, direction):
        self._parent.move_view_horizontal(direction)

    def nav_c_ver(self, direction):
        if direction == 1:
            self._parent._session.bank_up()
        else:
            self._parent._session.bank_down()

    def chg_volume(self, diff):
        if self.shift_on:
            self.repeat(self.master_track.mixer_device.volume, diff)
        else:
            self.master_track.mixer_device.volume.value = self.calc_new_parm(self.master_track.mixer_device.volume, diff)

    def chg_xfade(self, diff):
        if self.shift_on:
            self.repeat(self.master_track.mixer_device.crossfader, diff)
        else:
            self.master_track.mixer_device.crossfader.value = self.calc_new_parm(self.master_track.mixer_device.crossfader, diff)

    def chg_cue(self, diff):
        if self.shift_on:
            self.repeat(self.master_track.mixer_device.cue_volume, diff)
        else:
            self.master_track.mixer_device.cue_volume.value = self.calc_new_parm(self.master_track.mixer_device.cue_volume, diff)

    def repeat(self, parm, delta):
        count = 0
        while count < SHIFT_INC:
            parm.value = self.calc_new_parm(parm, delta)
            count += 1

    def calc_new_parm(self, parm, delta):
        parm_range = parm.max - parm.min
        int_val = int((parm.value - parm.min) / parm_range * PARM_RANGE + 0.1)
        inc_val = min(PARM_RANGE, max(0, int_val + delta))
        return float(inc_val) / float(PARM_RANGE) * parm_range + parm.min

    def chg_quant(self, diff):
        rec_quant = self._parent.song().midi_recording_quantization
        index = self.get_quant_index(rec_quant)
        new_index = index + diff
        if new_index >= 0 and new_index < len(QUANT_CONST):
            self._parent.song().midi_recording_quantization = QUANT_CONST[new_index]
            self._parent.show_message(QUANT_DESCR[new_index])

    def chg_clip_q(self, diff):
        quant = self._parent.song().clip_trigger_quantization
        self._parent.song().clip_trigger_quantization = max(0, min(13, quant + diff))
        self._parent.show_message('Clip Quantize ' + CLIQ_DESCR[self._parent.song().clip_trigger_quantization])

    def chg_tempo_fine(self, diff):
        if diff < 0:
            amount = -0.01
        else:
            amount = 0.01
        self.chg_tempo(amount)

    def chg_tempo(self, diff):
        self._parent.song().tempo = max(20, min(999, self._parent.song().tempo + diff))

    def get_quant_index(self, const):
        for index in range(len(QUANT_CONST)):
            if const == QUANT_CONST[index]:
                return index

        return -1

    def _action_octave(self, value):
        if value != 0:
            self.pad_to_mainknob_mode |= PAD_KNOB_OCTAVE
        else:
            self.pad_to_mainknob_mode &= ~PAD_KNOB_OCTAVE

    def _action_scale(self, value):
        if value != 0:
            self.pad_to_mainknob_mode |= PAD_KNOB_SCALE
        else:
            self.pad_to_mainknob_mode &= ~PAD_KNOB_SCALE

    def _action_base_note(self, value):
        if value != 0:
            self.pad_to_mainknob_mode |= PAD_KNOB_BASEN
        else:
            self.pad_to_mainknob_mode &= ~PAD_KNOB_BASEN

    def _set_volume_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.volume_button != None:
                self.volume_button.remove_value_listener(self._action_volume)
            self.volume_button = button
            self.volume_button != None and self.volume_button.add_value_listener(self._action_volume)

    def _action_volume(self, value):
        if not self.volume_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_VOLUME and self._set_mode(KN2_MODE_VOLUME)

    def _set_xfade_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.xfade_button != None:
                self.xfade_button.remove_value_listener(self._action_xfade)
            self.xfade_button = button
            self.xfade_button != None and self.xfade_button.add_value_listener(self._action_xfade)

    def _action_xfade(self, value):
        if not self.xfade_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_XFADE and self._set_mode(KN2_MODE_XFADE)

    def _set_swing_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.swing_button != None:
                self.swing_button.remove_value_listener(self._action_swing)
            self.swing_button = button
            self.swing_button != None and self.swing_button.add_value_listener(self._action_swing)

    def _action_swing(self, value):
        if not self.swing_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_QUANT and self._set_mode(KN2_MODE_QUANT)

    def _set_tempo_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.tempo_button != None:
                self.tempo_button.remove_value_listener(self._action_tempo)
            self.tempo_button = button
            self.tempo_button != None and self.tempo_button.add_value_listener(self._action_tempo)

    def _action_tempo(self, value):
        if not self.tempo_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_TEMPO_COARSE and self._set_mode(KN2_MODE_TEMPO_COARSE)

    def _set_clipn_h_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.clipn_h_button != None:
                self.clipn_h_button.remove_value_listener(self._action_clipnh)
            self.clipn_h_button = button
            self.clipn_h_button != None and self.clipn_h_button.add_value_listener(self._action_clipnh)

    def _action_clipnh(self, value):
        if not self.clipn_h_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_CLIPN_HOR and self._set_mode(KN2_MODE_CLIPN_HOR)

    def _set_clipn_v_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.clipn_v_button != None:
                self.clipn_v_button.remove_value_listener(self._action_clipnv)
            self.clipn_v_button = button
            self.clipn_v_button != None and self.clipn_v_button.add_value_listener(self._action_clipnv)

    def _action_clipnv(self, value):
        if not self.clipn_v_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_CLIPN_VER and self._set_mode(KN2_MODE_CLIPN_VER)

    def _set_shift_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.shift_button != None:
                self.shift_button.remove_value_listener(self._action_shift)
            self.shift_button = button
            self.shift_button != None and self.shift_button.add_value_listener(self._action_shift)

    def _action_shift(self, value):
        if not self.shift_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            self.shift_on = value != 0 and not self.shift_on
            self.update_shift()

    def _set_scroll_mod_left_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.scroll_mod_left_button != None:
                self.scroll_mod_left_button.remove_value_listener(self._action_scroll_left)
            self.scroll_mod_left_button = button
            self.scroll_mod_left_button != None and self.scroll_mod_left_button.add_value_listener(self._action_scroll_left)

    def _set_scroll_mod_right_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.scroll_mod_right_button != None:
                self.scroll_mod_right_button.remove_value_listener(self._action_scroll_right)
            self.scroll_mod_right_button = button
            self.scroll_mod_right_button != None and self.scroll_mod_right_button.add_value_listener(self._action_scroll_right)

    def _action_scroll_left(self, value):
        if not self.scroll_mod_left_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.scroll_mod_left_button.send_value(127, True)
            self.navflags |= LEFT_DOWN
            self._measure_left_click = int(round(time.time() * 1000))
        else:
            self.scroll_mod_left_button.send_value(0, True)
            self.navflags &= ~LEFT_DOWN
            clicktime = int(round(time.time() * 1000)) - self._measure_left_click
            if clicktime < CLICK_TIME:
                if self._parent._modifier_down:
                    self._parent.modify_track_offset(-1)
                elif self._parent._mode == PAD_MODE:
                    self._do_lr_as_scale_mode(-1)
                elif self._parent._mode == SCENE_MODE:
                    self._parent.modify_scene_offset(-1)
                elif self._parent._mode == CLIP_MODE:
                    self._parent.move_view_horizontal(-1)
                elif self._parent._mode == CONTROL_MODE:
                    self._parent.move_view_horizontal(-1)

    def _action_scroll_right(self, value):
        if not self.scroll_mod_right_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.scroll_mod_right_button.send_value(1)
            self.navflags |= RIGHT_DOWN
            self._measure_right_click = int(round(time.time() * 1000))
        else:
            self.scroll_mod_right_button.send_value(0, True)
            self.navflags &= ~RIGHT_DOWN
            clicktime = int(round(time.time() * 1000)) - self._measure_right_click
            if clicktime < CLICK_TIME:
                if self._parent._modifier_down:
                    self._parent.modify_track_offset(1)
                elif self._parent._mode == PAD_MODE:
                    self._do_lr_as_scale_mode(1)
                elif self._parent._mode == SCENE_MODE:
                    self._parent.modify_scene_offset(1)
                elif self._parent._mode == CLIP_MODE:
                    self._parent.move_view_horizontal(1)
                elif self._parent._mode == CONTROL_MODE:
                    self._parent.move_view_horizontal(1)

    def _do_lr_as_scale_mode(self, delta):
        if self.pad_to_mainknob_mode == PAD_KNOB_SCALE:
            self._parent.inc_scale(delta)
        elif self.pad_to_mainknob_mode == PAD_KNOB_BASEN:
            self._parent.inc_base_note(delta)
        else:
            self._parent.inc_octave(delta)

    def _action_oct_down(self, value):
        if value != 0:
            self._parent.inc_octave(-1)

    def _action_oct_up(self, value):
        if value != 0:
            self._parent.inc_octave(1)

    def _action_scale_down(self, value):
        if value != 0:
            self._parent.inc_scale(-1)

    def _action_scale_up(self, value):
        if value != 0:
            self._parent.inc_scale(1)

    def _action_base_down(self, value):
        if value != 0:
            self._parent.inc_base_note(-1)

    def _action_base_up(self, value):
        if value != 0:
            self._parent.inc_base_note(1)

    def _set_push_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.push_button != None:
                self.push_button.remove_value_listener(self._action_push)
            self.push_button = button
            self.push_button != None and self.push_button.add_value_listener(self._action_push)

    def _action_push(self, value):
        if not self.push_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                next_mode = self.mode_assign_map[self.mode][3]
                next_mode != -1 and self._set_mode(next_mode)
            self.loop_div_index = self.lrmode == LR_CONTROL_LOOP and self.navflags != 0 and (self.loop_div_index + 1) % len(LOOP_KNOB_DIVISION)
            self._parent.show_message('Loop Selection Granularity : ' + str(LOOP_KNOB_DIVISION[self.loop_div_index]) + ' beats ')
            self.loop_incdex = LOOP_KNOB_DIVISION[self.loop_div_index]

    def remove_listener(self, control, callback):
        if control != None and control.value_has_listener(callback):
            control.remove_value_listener(callback)
        control.disconnect()

    def disconnect(self):
        self.remove_listener(self.the_slider, self._do_main_slider)
        self.remove_listener(self.arrow_mode_button, self.toggle_arrow_mode)
        self.remove_listener(self.volume_button, self._action_volume)
        self.remove_listener(self.xfade_button, self._action_xfade)
        self.remove_listener(self.swing_button, self._action_swing)
        self.remove_listener(self.clipn_h_button, self._action_clipnh)
        self.remove_listener(self.clipn_v_button, self._action_clipnv)
        self.remove_listener(self.shift_button, self._action_shift)
        self.remove_listener(self.scroll_mod_left_button, self._action_scroll_left)
        self.remove_listener(self.scroll_mod_right_button, self._action_scroll_right)
        self.remove_listener(self.push_button, self._action_push)
        self.remove_listener(self.octave_mod_button, self._action_octave)
        self.remove_listener(self.scale_mod_button, self._action_scale)
        self.remove_listener(self.basenote_mod_button, self._action_base_note)
        self.remove_listener(self.octave_dwn_button, self._action_oct_down)
        self.remove_listener(self.octave_upp_button, self._action_oct_up)
        self.remove_listener(self.scale_dwn_button, self._action_scale_down)
        self.remove_listener(self.scale_upp_button, self._action_scale_up)
        self.remove_listener(self.basent_dwn_button, self._action_base_down)
        self.remove_listener(self.basent_upp_button, self._action_base_up)
        self._parent = None
        self.master_track = None
        self.the_slider = None
        self.mode_assign_map = None
########NEW FILE########
__FILENAME__ = Maschine
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk1\Maschine.py
from __future__ import with_statement
import Live
import MidiRemoteScript
import time
from VarButtonElement import VarButtonElement, TwinButton
from StateButton import StateButton, ToggleButton
from MaschineSessionComponent import MaschineSessionComponent
from MaschineDeviceComponent import MaschineDeviceComponent
from PadScale import *
from SceneMatrix import SceneMatrix
from MainKnobControl import MainKnobControl
from MIDI_Map import *
from _Framework.ControlSurface import ControlSurface, _scheduled_method
from _Framework.InputControlElement import *
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import EncoderElement
from _Framework.ButtonMatrixElement import ButtonMatrixElement
from _Framework.ChannelTranslationSelector import ChannelTranslationSelector
from _Framework.TransportComponent import TransportComponent
from _Framework.MixerComponent import MixerComponent

class Maschine(ControlSurface):
    __module__ = __name__
    __doc__ = 'Control Script for Maschine and Maschine Mikro'

    def __init__(self, c_instance):
        ControlSurface.__init__(self, c_instance, False)
        with self.component_guard():
            self._c_ref = c_instance
            register_sender(self)
            self._set_suppress_rebuild_requests(True)
            self._active = True
            self._midi_pause_count = 0
            self._suggested_input_port = str('Maschine Controller In')
            self._suggested_output_port = str('Maschine Controller Out')
            self.value_encoder_tempo = None
            self.enc_tempo_mode = None
            self.nav_index = 0
            self.blink_state = 1
            self._scenematrix = SceneMatrix(self)
            self._master_knob = MainKnobControl(self)
            self.md_select_pressed = False
            self.md_solo_pressed = False
            self._rec_quant = Live.Song.RecordingQuantization.rec_q_no_q
            self.adjust_time = None
            self.modelegacy = False
            self.test_value = 1
            self._mode = CLIP_MODE
            self._modifier_down = False
            self.time_callback = None
            self._device_nav_button_left = None
            self._device_nav_button_right = None
            self._return_mode = 0
            self._returntopad = False
            self._pad_mode = PM_OFF
            self._device = self._set_up_device_control()
            self._base_note = 0
            self._octave = 0.55
            self._scale_select_mode = MODE_PRESS_NONE
            self.show_message(str(''))
            self.request_rebuild_midi_map()
            self.send_sliders = []
            for track in range(8):
                self.send_sliders.append(SliderElement(MIDI_CC_TYPE, BASIC_CHANNEL, SEND_CC_OFF + track))

            self.send_slider_index = 0
            self.send_slider_toggle_button = StateButton(False, MIDI_CC_TYPE, 0, 90)
            self.send_slider_toggle_button.add_value_listener(self._do_toggle_send)
            self._set_up_controls()
            self._setup_transport()
            self._set_up_session()
            self._set_up_mixer()
            self._set_up_machine_knobs()
            self.current_scale_index = 0
            self.assign_transpose(SCALES[self.current_scale_index])
            self.set_highlighting_session_component(self._session)
            self._set_mode()
            self._set_suppress_rebuild_requests(False)
            self.timer_repeat = 0
            self.time_callback = None
            self.schedule_message(3, self._start_display)
            self.song().view.add_detail_clip_listener(self.clip_handle)
            self.song().add_visible_tracks_listener(self.clip_handle)
            self.song().add_scenes_listener(self.clip_handle)
            self.application().view.add_view_focus_changed_listener(self.focus_changed)
            self.log_message('##### LIVE 9 Maschine & Machine Mikro Controller - Version: 1.00')

    def _start_display(self):
        self._set_mode()
        self._master_knob.update()
        self.clip_mode_button.send_value(127, True)
        if self._scenematrix.soloexclusive:
            self._armsolomode_button.send_value(127, True)
        else:
            self._armsolomode_button.send_value(0, True)
        self._master_knob.start_up()
        self.current_scale_to_display()

    def _set_up_controls(self):
        is_momentary = True
        self.scene_mode_button = None
        self._set_scene_mode_button(StateButton(False, MIDI_CC_TYPE, 0, 112))
        self.clip_mode_button = None
        self._set_clip_mode_button(StateButton(False, MIDI_CC_TYPE, 0, 113))
        self.pad_mode_button = None
        self._set_pad_mode_button(StateButton(False, MIDI_CC_TYPE, 0, 114))
        self.control_mode_button = None
        self._set_control_mode_button(StateButton(False, MIDI_CC_TYPE, 0, 115))
        self.xfade_assign_button = None
        self._set_xfade_assign_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 116))
        self._undo_button = None
        self._set_undo_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 85))
        self._redo_button = None
        self._set_redo_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 87))
        self._armsolomode_button = None
        self._set_armsolomode_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 89))
        self._pad_scale_up = None
        self._pad_scale_down = None
        self._set_scale_up_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 83))
        self._set_scale_down_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 94))
        self._mode_octave_button = None
        self._mode_base_button = None
        self._fire_button = None
        self._set_mode_select_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 117))
        self._set_mode_solo_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 118))
        self._set_fire_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 119))
        self._pad_solo_button = None
        self._mute_button = None
        self._pad_select_button = None
        self._group_d_button = None
        self._group_h_button = None
        self._fire_dedictated_button = None
        self._set_mikro_select_button(StateButton(False, MIDI_CC_TYPE, 1, 117))
        self._set_mikro_solo_button(StateButton(False, MIDI_CC_TYPE, 1, 118))
        self._set_mute_button(StateButton(is_momentary, MIDI_CC_TYPE, 1, 119))
        self._set_group_d_button(StateButton(is_momentary, MIDI_CC_TYPE, 1, 120))
        self._set_group_h_button(StateButton(is_momentary, MIDI_CC_TYPE, 1, 121))
        self._set_dedictated_fire_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 9))
        self.test_button = StateButton(is_momentary, MIDI_CC_TYPE, 5, 60)
        self.note_repeat_button = StateButton(is_momentary, MIDI_CC_TYPE, 5, 61)
        self.test_button.add_value_listener(self.do_test)
        self.note_repeat_button.add_value_listener(self.do_note_repeat)
        self.track_left_button = None
        self._set_track_left_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 0, 120))
        self.track_right_button = None
        self._set_track_right_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 0, 121))
        self._navigate_button = None
        self._set_navigate_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 127))
        self.display_update_button = None
        self._set_display_update_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 86))

    def _set_up_device_control(self):
        is_momentary = True
        device = MaschineDeviceComponent(self)
        device.set_device_changed_listener(self._handle_device_changed)
        device.set_device_parm_listener(self._hande_device_parm_changed)
        param_controls = []
        for index in range(8):
            param_controls.append(SliderElement(MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_CC_OFF + index))

        device.set_parameter_controls(tuple(param_controls))
        device.set_on_off_button(StateButton(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_BUTTON_CC_OFF))
        device.set_bank_nav_buttons(StateButton(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_BUTTON_CC_OFF + 4), StateButton(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_BUTTON_CC_OFF + 5))
        self._device_nav_button_left = StateButton(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_BUTTON_CC_OFF + 6)
        self._device_nav_button_right = StateButton(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_BUTTON_CC_OFF + 7)
        self._device_nav_button_left.add_value_listener(self._nav_value_left)
        self._device_nav_button_right.add_value_listener(self._nav_value_right)
        device.name = 'Device_Component'
        self.set_device_component(device)
        return device

    def _set_up_mixer(self):
        self._mixer = MixerComponent(8)
        for track in range(8):
            strip = self._mixer.channel_strip(track)
            strip.set_arm_button(StateButton(True, MIDI_CC_TYPE, BASIC_CHANNEL, ARM_CC_OFF + track))
            strip.set_solo_button(StateButton(True, MIDI_CC_TYPE, BASIC_CHANNEL, SOLO_CC_OFF + track))
            strip.set_mute_button(StateButton(True, MIDI_CC_TYPE, BASIC_CHANNEL, MUTE_CC_OFF + track))
            strip.set_volume_control(SliderElement(MIDI_CC_TYPE, BASIC_CHANNEL, LEVEL_CC_OFF + track))
            strip.set_pan_control(SliderElement(MIDI_CC_TYPE, BASIC_CHANNEL, PAN_CC_OFF + track))
            strip.set_select_button(StateButton(True, MIDI_CC_TYPE, BASIC_CHANNEL, SELECT_CC_OFF + track))
            st = tuple([self.send_sliders[track]])
            strip.set_send_controls(st)

        self._session.set_mixer(self._mixer)

    def update_display(self):
        with self.component_guard():
            with self._is_sending_scheduled_messages():
                self._task_group.update(0.1)
            if self._mode == CLIP_MODE and not self._modifier_down:
                self._session.notify_b(self.blink_state)
            elif self._mode == PAD_MODE:
                pass
            else:
                self._scenematrix.notify_scene_mode(self.blink_state)
            self.blink_state = (self.blink_state + 1) % 8

    def _set_mode(self, mode = None):
        selMode = self._mode
        if selMode != None:
            selMode = mode
        if selMode == SCENE_MODE:
            self.clip_mode_button.send_value(0, True)
            self.pad_mode_button.send_value(0, True)
            self.control_mode_button.send_value(0, True)
            self.scene_mode_button.send_value(127, True)
        elif selMode == CLIP_MODE:
            self.scene_mode_button.send_value(0, True)
            self.pad_mode_button.send_value(0, True)
            self.control_mode_button.send_value(0, True)
            self.clip_mode_button.send_value(100, True)
        elif selMode == PAD_MODE:
            self.scene_mode_button.send_value(0, True)
            self.clip_mode_button.send_value(0, True)
            self.control_mode_button.send_value(0, True)
            self.pad_mode_button.send_value(127, True)
        elif selMode == CONTROL_MODE:
            self.scene_mode_button.send_value(0, True)
            self.clip_mode_button.send_value(0, True)
            self.pad_mode_button.send_value(0, True)
            self.control_mode_button.send_value(127, True)

    def song(self):
        return ControlSurface.song(self)

    def _set_up_session(self):
        self._session = MaschineSessionComponent()
        self._session.add_offset_listener(self.notify_track_scroll)
        self._session.set_scene_bank_buttons(StateButton(True, MIDI_CC_TYPE, 0, 92), StateButton(True, MIDI_CC_TYPE, 0, 81))
        self._session.set_track_bank_buttons(StateButton(True, MIDI_CC_TYPE, 0, 93), StateButton(True, MIDI_CC_TYPE, 0, 91))
        self._session.set_stop_all_clips_button(StateButton(True, MIDI_CC_TYPE, 0, 111))
        track_stop_buttons = [ StateButton(True, MIDI_CC_TYPE, BASIC_CHANNEL, index + STOP_CC_OFF) for index in range(4) ]
        self._session.set_stop_track_clip_buttons(tuple(track_stop_buttons))
        self._init_matrix()
        self._set_up_buttons()
        self._session._link()
        self._session.set_advance(STEP4)

    def _init_matrix(self):
        self._button_sequence = []
        self._matrix = []
        for scene_index in range(4):
            button_row = []
            for track_index in range(4):
                button = VarButtonElement(True, 0, scene_index, track_index, self)
                partner = TwinButton(True, 1, button)
                partner.add_value_listener(self.ox, True)
                button_row.append(button)

            self._matrix.append(tuple(button_row))

        for scene_index in [3,
         2,
         1,
         0]:
            for track_index in range(4):
                self._button_sequence.append(self._matrix[scene_index][track_index])

        self._session.set_matrix(self._matrix)

    def ox(self, value, button):
        if not isinstance(button, TwinButton):
            raise AssertionError
            self._mode == PAD_MODE and button.fire(value)

    def _set_up_buttons(self):
        self._bmatrix = None
        self._bmatrix = ButtonMatrixElement()
        for scene_index in range(4):
            button_row = []
            scene = self._session.scene(scene_index)
            for track_index in range(4):
                button = self._matrix[scene_index][track_index]
                clip_slot = scene.clip_slot(track_index)
                clip_slot.set_launch_button(button)
                clip_slot.set_triggered_to_play_value(1)
                clip_slot.set_triggered_to_record_value(1)
                clip_slot.set_started_value(1)
                clip_slot.set_recording_value(1)
                clip_slot.set_stopped_value(1)

            self._bmatrix.add_row(tuple(button_row))

    def _reset_matrix(self):
        for scene_index in range(4):
            scene = self._session.scene(scene_index)
            for track_index in range(4):
                button = self._matrix[scene_index][track_index]
                clip_slot = scene.clip_slot(track_index)
                clip_slot.set_launch_button(button)

    def update_button_matrix(self):
        self._session.update()
        for scene_index in range(4):
            scene = self._session.scene(scene_index)
            for track_index in range(4):
                button = self._matrix[scene_index][track_index]
                clip_slot = scene.clip_slot(track_index)
                if clip_slot._clip_slot != None and clip_slot._clip_slot.clip != None:
                    button.send_value(1, True)
                else:
                    button.send_value(0, True)

    def set_appointed_device(self, device):
        with self.component_guard():
            self._device.set_device(device)

    def _deassign_matrix(self):
        for scene_index in range(4):
            scene = self._session.scene(scene_index)
            for track_index in range(4):
                clip_slot = scene.clip_slot(track_index)
                clip_slot.set_launch_button(None)

    def _setup_transport(self):
        is_momentary = True
        transport = TransportComponent()
        transport.set_play_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 108))
        transport.set_stop_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 110))
        transport.set_record_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 109))
        transport.set_overdub_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 107))
        transport.set_metronome_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 104))
        transport.set_nudge_buttons(StateButton(is_momentary, MIDI_CC_TYPE, 1, 51), StateButton(is_momentary, MIDI_CC_TYPE, 1, 50))
        transport.set_punch_buttons(ToggleButton(MIDI_CC_TYPE, 1, 52), ToggleButton(MIDI_CC_TYPE, 1, 53))
        transport.set_loop_button(StateButton(is_momentary, MIDI_CC_TYPE, 1, 54))
        transport.set_seek_buttons(StateButton(is_momentary, MIDI_CC_TYPE, 1, 59), StateButton(is_momentary, MIDI_CC_TYPE, 1, 58))
        self.xfadeKnob = SliderElement(MIDI_CC_TYPE, 1, 100)
        self.xfadeKnob.connect_to(self.song().master_track.mixer_device.crossfader)
        self.tap_button = StateButton(is_momentary, MIDI_CC_TYPE, 0, 88)
        self.tap_button.add_value_listener(self._do_tap_tempo)
        self.cue_add_delete_button = StateButton(is_momentary, MIDI_CC_TYPE, 1, 55)
        self.cue_prev_button = StateButton(is_momentary, MIDI_CC_TYPE, 1, 56)
        self.cue_next_button = StateButton(is_momentary, MIDI_CC_TYPE, 1, 57)
        self.cue_add_delete_button.add_value_listener(self._do_toggle_cue)
        self.cue_prev_button.add_value_listener(self._do_toggle_prev_cue)
        self.cue_next_button.add_value_listener(self._do_toggle_next_cue)

    def _invoke_track_edit(self, mode):
        self._deassign_matrix()
        self._scenematrix.assign()
        self._scenematrix.set_mode(mode)
        self._scenematrix.set_active(True)
        self._pad_mode = PM_ON
        self._set_suppress_rebuild_requests(True)
        self.request_rebuild_midi_map()
        self._set_suppress_rebuild_requests(False)
        self._scenematrix.update()

    def _enter_control_mode(self):
        self._set_mode(CONTROL_MODE)
        if self._mode == CLIP_MODE:
            self._deassign_matrix()
        elif self._mode == PAD_MODE:
            self._register_buttons()
        self._scenematrix.assign()
        self._scenematrix.set_mode(SCENE_MODE_CONTROL)
        self._scenematrix.set_active(True)
        self._return_mode = SCENE_MODE_CONTROL
        self._set_suppress_rebuild_requests(True)
        self.request_rebuild_midi_map()
        self._set_suppress_rebuild_requests(False)
        self._scenematrix.update()
        self._master_knob.switch_to_matrix_mode()
        self._mode = CONTROL_MODE

    def _enter_scene_mode(self):
        self._set_mode(SCENE_MODE)
        if self._mode == CLIP_MODE:
            self._deassign_matrix()
        elif self._mode == PAD_MODE:
            self._register_buttons()
        elif self._mode == CONTROL_MODE:
            self._master_knob.exit_matrix_mode()
        self._scenematrix.assign()
        self._scenematrix.set_mode(SCENE_MODE_NORMAL)
        self._scenematrix.set_active(True)
        self._return_mode = SCENE_MODE_NORMAL
        self._set_suppress_rebuild_requests(True)
        self.request_rebuild_midi_map()
        self._set_suppress_rebuild_requests(False)
        self._scenematrix.update()
        self._mode = SCENE_MODE

    def _from_pad_mode(self, matrix_mode):
        self._register_buttons()
        self._scenematrix.assign()
        self._scenematrix.set_mode(matrix_mode)
        self._scenematrix.set_active(True)
        self._set_suppress_rebuild_requests(True)
        self.request_rebuild_midi_map()
        self._set_suppress_rebuild_requests(False)
        self._scenematrix.update()
        self._mode = SCENE_MODE

    def _enter_pad_mode(self):
        self._set_mode(PAD_MODE)
        if self._mode == CLIP_MODE:
            self._deassign_matrix()
        elif self._mode == SCENE_MODE:
            self._scenematrix.deassign()
        elif self._mode == CONTROL_MODE:
            self._scenematrix.deassign()
            self._master_knob.exit_matrix_mode()
        self._scenematrix.set_active(False)
        self._mode = PAD_MODE
        for row in range(4):
            for column in range(4):
                button = self._matrix[row][column]
                button.send_value(0, True)
                button.set_to_notemode(True)
                self._forwarding_registry[MIDI_NOTE_ON_STATUS, button.get_identifier()] = button
                self._forwarding_registry[MIDI_NOTE_OFF_STATUS, button.get_identifier()] = button

        self._mode = PAD_MODE

    def _register_buttons(self):
        for row in range(4):
            for column in range(4):
                button = self._matrix[row][column]
                button.set_to_notemode(False)
                button.send_value(0)
                fwkey = [MIDI_NOTE_ON_STATUS]
                fwkey.append(button.get_identifier())
                self._forwarding_registry[tuple(fwkey)] = button
                self._forwarding_registry[MIDI_NOTE_OFF_STATUS, button.get_identifier()] = button

    def _back_to_clip_mode(self):
        self._pad_mode = PM_OFF
        self._scenematrix.set_mode(SCENE_MODE_NORMAL)
        self._scenematrix.deassign()
        self._scenematrix.set_active(False)
        self._set_up_clip_matrix()

    def _enter_clip_mode(self):
        self._set_mode(CLIP_MODE)
        if self._mode == SCENE_MODE:
            self._scenematrix.deassign()
            self._scenematrix.set_active(False)
        elif self._mode == CONTROL_MODE:
            self._master_knob.exit_matrix_mode()
            self._scenematrix.set_active(False)
        self._set_up_clip_matrix()
        self._mode = CLIP_MODE

    def _set_up_clip_matrix(self):
        for row in range(4):
            for column in range(4):
                button = self._matrix[row][column]
                button.set_to_notemode(False)

        self.request_rebuild_midi_map()
        self._reset_matrix()
        self.update_button_matrix()

    def modify_track_offset(self, delta):
        self._scenematrix.mod_track_offset(delta)

    def modify_scene_offset(self, delta):
        self._scenematrix.mod_scene_offset(delta)

    def move_view_horizontal(self, delta):
        if delta == 1:
            self._session.bank_right()
        else:
            self._session.bank_left()
        if self._mode == CONTROL_MODE:
            self._scenematrix.update()

    def _set_up_machine_knobs(self):
        master_track = self.song().master_track
        self.recordQuantSlider = SliderElement(MIDI_CC_TYPE, 0, 42)
        self.recordQuantSlider.add_value_listener(self._on_rec_quant, True)
        self.master_volume = SliderElement(MIDI_CC_TYPE, 0, 40)
        self.prehear = SliderElement(MIDI_CC_TYPE, 0, 41)
        self.master_volume.connect_to(master_track.mixer_device.volume)
        self.prehear.connect_to(master_track.mixer_device.cue_volume)

    def _on_rec_quant(self, value, encoder):
        if not value in range(128):
            raise AssertionError
            raise isinstance(encoder, EncoderElement) or AssertionError
            self._scale_select_mode == MODE_PRESS_NONE and self.set_quant(value)
            self.value_encoder_tempo = value
            self.enc_tempo = self.song().tempo
        elif self._scale_select_mode == MODE_PRESS_SELECT or self._scale_select_mode == MODE_PRESS_SOLO:
            if self.value_encoder_tempo == None:
                self.value_encoder_tempo = value
                self.enc_tempo = self.song().tempo
                self.enc_tempo_mode = self._scale_select_mode
            else:
                if self.enc_tempo_mode != self._scale_select_mode:
                    self.value_encoder_tempo = value
                diff = value - self.value_encoder_tempo
                if self._scale_select_mode == MODE_PRESS_SOLO:
                    diff *= 0.01
                self.song().tempo = max(20, min(999, self.enc_tempo + diff))
                self.enc_tempo_mode = self._scale_select_mode
            if value == 127 or value == 0:
                encoder.send_value(63, True)
                self.value_encoder_tempo = 63
                self.enc_tempo = self.song().tempo

    def set_quant(self, value):
        req_q = None
        msg = None
        if value < 15:
            msg = ' No Rec Quant '
            self._rec_quant = self.song().midi_recording_quantization
            req_q = Live.Song.RecordingQuantization.rec_q_no_q
        elif value < 30:
            msg = ' 1/4 Rec Quant'
            req_q = Live.Song.RecordingQuantization.rec_q_quarter
        elif value < 45:
            msg = ' 1/8 Rec Quant'
            req_q = Live.Song.RecordingQuantization.rec_q_eight
        elif value < 60:
            msg = ' 1/8 Triplet Quant'
            req_q = Live.Song.RecordingQuantization.rec_q_eight_triplet
        elif value < 75:
            msg = ' 1/8 & 1/8 Triplet Quant'
            req_q = Live.Song.RecordingQuantization.rec_q_eight_eight_triplet
        elif value < 90:
            msg = ' 1/16 Quant'
            req_q = Live.Song.RecordingQuantization.rec_q_sixtenth
        elif value < 105:
            msg = ' 1/16 Triplet Quant'
            req_q = Live.Song.RecordingQuantization.rec_q_sixtenth_triplet
        else:
            msg = ' 1/16 & 1/16 Triplet Quant'
            req_q = Live.Song.RecordingQuantization.rec_q_sixtenth_sixtenth_triplet
        if req_q != self._rec_quant:
            self.song().midi_recording_quantization = req_q
            self._rec_quant = req_q
            self.show_message(str(msg))

    def _set_undo_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._undo_button != None:
                self._undo_button.remove_value_listener(self._do_undo)
            self._undo_button = button
            self._undo_button != None and self._undo_button.add_value_listener(self._do_undo)

    def _do_undo(self, value):
        if not self._undo_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                (value != 0 or not self._undo_button.is_momentary()) and self.song().can_undo == 1 and self.song().undo()
                self.show_message(str('UNDO'))

    def _set_redo_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._redo_button != None:
                self._redo_button.remove_value_listener(self._do_redo)
            self._redo_button = button
            self._redo_button != None and self._redo_button.add_value_listener(self._do_redo)

    def _do_redo(self, value):
        if not self._redo_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                (value != 0 or not self._redo_button.is_momentary()) and self.song().can_redo == 1 and self.song().redo()
                self.show_message(str('Redo'))

    def _set_armsolomode_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._armsolomode_button != None:
                self._armsolomode_button.remove_value_listener(self._do_armsolo_mode)
            self._armsolomode_button = button
            self._armsolomode_button != None and self._armsolomode_button.add_value_listener(self._do_armsolo_mode)

    def _do_armsolo_mode(self, value):
        if not self._armsolomode_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self._scenematrix.set_armsolo_exclusive(self._armsolomode_button)

    def _set_navigate_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._navigate_button != None:
                self._navigate_button.remove_value_listener(self._do_navigate)
            self._navigate_button = button
            self._navigate_button != None and self._navigate_button.add_value_listener(self._do_navigate)

    def _do_navigate(self, value):
        if not self._navigate_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            self.nav_index = value != 0 and (self.nav_index + 1) % len(VIEWS_ALL)
            self.application().view.focus_view(VIEWS_ALL[self.nav_index])
            self.show_message('Focus on : ' + str(VIEWS_ALL[self.nav_index]))

    def _set_fire_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._fire_button != None:
                self._fire_button.remove_value_listener(self._do_mute_fire_button)
            self._fire_button = button
            self._fire_button != None and self._fire_button.add_value_listener(self._do_mute_fire_button)

    def _do_mute_fire_button(self, value):
        raise self._fire_button != None or AssertionError
        raise value in range(128) or AssertionError
        self._handle_mute(value, True)

    def _set_mute_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._mute_button != None:
                self._mute_button.remove_value_listener(self._do_mute_button)
            self._mute_button = button
            self._mute_button != None and self._mute_button.add_value_listener(self._do_mute_button)

    def _do_mute_button(self, value):
        raise self._mute_button != None or AssertionError
        raise value in range(128) or AssertionError
        self._handle_mute(value, self.modelegacy)

    def _handle_mute(self, value, legacymode = False):
        self._modifier_down = value != 0
        if legacymode and self._mode == PAD_MODE:
            if value != 0 or not self._mute_button.is_momentary():
                clip_slot = self.song().view.highlighted_clip_slot
                if clip_slot:
                    clip_slot.fire()
        if not legacymode and (self._mode == PAD_MODE or self._returntopad):
            if value != 0:
                self._from_pad_mode(SCENE_MODE_MUTE)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == SCENE_MODE or self._mode == CONTROL_MODE:
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
                self._pad_mode = PM_OFF
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_MUTE)
                self._pad_mode = PM_ON
        elif self._mode == CLIP_MODE:
            if value > 0:
                self._invoke_track_edit(SCENE_MODE_MUTE)
            else:
                self._back_to_clip_mode()
                self._pad_mode = PM_OFF

    def _set_dedictated_fire_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._fire_dedictated_button != None:
                self._fire_dedictated_button.remove_value_listener(self._do_dedictated_fire_button)
            self._fire_dedictated_button = button
            self._fire_dedictated_button != None and self._fire_dedictated_button.add_value_listener(self._do_dedictated_fire_button)

    def _do_dedictated_fire_button(self, value):
        if not self._fire_dedictated_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                clip_slot = (value != 0 or not self._mute_button.is_momentary()) and self.song().view.highlighted_clip_slot
                clip_slot and clip_slot.fire()

    def _set_mode_solo_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._mode_base_button != None:
                self._mode_base_button.remove_value_listener(self._do_pad_mode_base)
            self._mode_base_button = button
            self._mode_base_button != None and self._mode_base_button.add_value_listener(self._do_pad_mode_base)

    def _do_pad_mode_base(self, value):
        raise self._mode_base_button != None or AssertionError
        raise value in range(128) or AssertionError
        self._handle_solo(value, True)

    def _set_mikro_solo_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._pad_solo_button != None:
                self._pad_solo_button.remove_value_listener(self._do_pad_solo_multi)
            self._pad_solo_button = button
            self._pad_solo_button != None and self._pad_solo_button.add_value_listener(self._do_pad_solo_multi)

    def _do_pad_solo_multi(self, value):
        raise value in range(128) or AssertionError
        self._handle_solo(value, self.modelegacy)

    def _handle_solo(self, value, asmodifier = False):
        self._modifier_down = value != 0
        if asmodifier and self._mode == PAD_MODE:
            if value == 0:
                self._scale_select_mode = MODE_PRESS_NONE
            else:
                self._scale_select_mode = MODE_PRESS_SOLO
        elif not asmodifier and (self._mode == PAD_MODE or self._returntopad):
            if value != 0:
                self._from_pad_mode(SCENE_MODE_SOLO)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == CLIP_MODE:
            if value != 0:
                self._invoke_track_edit(SCENE_MODE_SOLO)
            else:
                self._back_to_clip_mode()
        elif self._mode != PAD_MODE:
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_SOLO)

    def _set_mode_select_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._mode_octave_button != None:
                self._mode_octave_button.remove_value_listener(self._do_pad_mode_octave)
            self._mode_octave_button = button
            self._mode_octave_button != None and self._mode_octave_button.add_value_listener(self._do_pad_mode_octave)

    def _do_pad_mode_octave(self, value):
        raise self._mode_octave_button != None or AssertionError
        raise value in range(128) or AssertionError
        self._handle_select(value, True)

    def _set_mikro_select_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._pad_select_button != None:
                self._pad_select_button.remove_value_listener(self._do_pad_select_multi)
            self._pad_select_button = button
            self._pad_select_button != None and self._pad_select_button.add_value_listener(self._do_pad_select_multi)

    def _do_pad_select_multi(self, value):
        raise value in range(128) or AssertionError
        self._handle_select(value, self.modelegacy)

    def _handle_select(self, value, asmodifer = False):
        self._modifier_down = value != 0
        if asmodifer and self._mode == PAD_MODE:
            if value == 0:
                self._scale_select_mode = MODE_PRESS_NONE
            else:
                self._scale_select_mode = MODE_PRESS_SELECT
        elif not asmodifer and (self._mode == PAD_MODE or self._returntopad):
            if value != 0:
                self._from_pad_mode(SCENE_MODE_SELECT)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == CLIP_MODE:
            if value != 0:
                self._invoke_track_edit(SCENE_MODE_SELECT)
            else:
                self._back_to_clip_mode()
        elif self._mode != PAD_MODE:
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_SELECT)

    def _set_scale_up_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._pad_scale_up != None:
                self._pad_scale_up.remove_value_listener(self._do_pad_note_up)
            self._pad_scale_up = button
            self._pad_scale_up != None and self._pad_scale_up.add_value_listener(self._do_pad_note_up)

    def _do_pad_note_up(self, value):
        raise self._pad_scale_up != None or AssertionError
        raise value in range(128) or AssertionError
        self._handle_groupd_up(value, True)

    def _set_group_d_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._group_d_button != None:
                self._group_d_button.remove_value_listener(self._do_arm)
            self._group_d_button = button
            self._group_d_button != None and self._group_d_button.add_value_listener(self._do_arm)

    def _do_arm(self, value):
        raise self._pad_scale_up != None or AssertionError
        raise value in range(128) or AssertionError
        self._handle_groupd_up(value, self.modelegacy)

    def _handle_groupd_up(self, value, legacymode = False):
        self._modifier_down = value != 0
        if legacymode and self._mode == PAD_MODE:
            if value != 0:
                if self._scale_select_mode == MODE_PRESS_SELECT:
                    self.inc_scale(1)
                elif self._scale_select_mode == MODE_PRESS_SOLO:
                    self.inc_base_note(1)
                else:
                    self.inc_octave(1)
        elif not legacymode and (self._mode == PAD_MODE or self._returntopad):
            if value != 0:
                self._from_pad_mode(SCENE_MODE_ARM)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == CLIP_MODE:
            self.show_message('Arm tracks with pads')
            if value != 0:
                self._invoke_track_edit(SCENE_MODE_ARM)
            else:
                self._back_to_clip_mode()
        elif self._mode == SCENE_MODE or self._mode == CONTROL_MODE:
            self.show_message('Arm tracks with pads')
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_ARM)

    def _set_scale_down_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._pad_scale_down != None:
                self._pad_scale_down.remove_value_listener(self._do_pad_note_down)
            self._pad_scale_down = button
            self._pad_scale_down != None and self._pad_scale_down.add_value_listener(self._do_pad_note_down)

    def _do_pad_note_down(self, value):
        raise self._pad_scale_down != None or AssertionError
        raise value in range(128) or AssertionError
        self._handle_grouph_down(value, True)

    def _set_group_h_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._group_h_button != None:
                self._group_h_button.remove_value_listener(self._do_stop)
            self._group_h_button = button
            self._group_h_button != None and self._group_h_button.add_value_listener(self._do_stop)

    def _do_stop(self, value):
        raise self._group_h_button != None or AssertionError
        raise value in range(128) or AssertionError
        self._handle_grouph_down(value)

    def _handle_grouph_down(self, value, legacymode = False):
        self._modifier_down = value != 0
        if legacymode and self._mode == PAD_MODE:
            if value != 0:
                if self._scale_select_mode == MODE_PRESS_SELECT:
                    self.inc_scale(-1)
                elif self._scale_select_mode == MODE_PRESS_SOLO:
                    self.inc_base_note(-1)
                else:
                    self.inc_octave(-1)
        elif not legacymode and (self._mode == PAD_MODE or self._returntopad):
            if value != 0:
                self._from_pad_mode(SCENE_MODE_STOP)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == CLIP_MODE:
            self.show_message('Stop tracks with pads')
            if value != 0:
                self._invoke_track_edit(SCENE_MODE_STOP)
            else:
                self._back_to_clip_mode()
        elif self._mode == SCENE_MODE or self._mode == CONTROL_MODE:
            self.show_message('Stop tracks with pads')
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_STOP)

    def _send_midi(self, midi_bytes, **keys):
        self._c_ref.send_midi(midi_bytes)
        if self._midi_pause_count == 2:
            time.sleep(0.002)
            self._midi_pause_count = 0
        else:
            self._midi_pause_count = self._midi_pause_count + 1
        return True

    def do_test(self, value):
        if value == 0:
            return
        for row in range(4):
            for column in range(4):
                button = self._matrix[row][column]
                if self.test_value == 0:
                    button.send_value(0, True)
                else:
                    button.send_value(120, True)

        self.scene_mode_button.send_value(self.test_value, True)
        self.clip_mode_button.send_value(self.test_value, True)
        self.pad_mode_button.send_value(self.test_value, True)
        self.control_mode_button.send_value(self.test_value, True)
        if self.test_value == 1:
            self.test_value = 0
        else:
            self.test_value = 1

    def do_note_repeat(self, value):
        nrvalue = 0
        if value != 0:
            nrvalue = 1
        debug_out(' REPEAT HOLD ' + str(nrvalue))

    def inc_octave(self, inc):
        scale = SCALES[self.current_scale_index]
        octave = scale.to_octave(self._octave)
        newoctave = octave + inc
        if newoctave < 0:
            newoctave = 0
        elif newoctave > scale.octave_range:
            newoctave = scale.octave_range
        self._octave = scale.to_relative(newoctave, self._octave)
        scale = SCALES[self.current_scale_index]
        self.assign_transpose(scale)
        self.show_message(' OCTAVE ' + BASE_NOTE[self._base_note] + str(newoctave - 2) + ' to ' + scale.name)
        self.current_scale_to_display()

    def inc_base_note(self, inc):
        newbase = self._base_note + inc
        if newbase < 0:
            self._base_note = 11
        elif newbase > 11:
            self._base_note = 0
        else:
            self._base_note = newbase
        scale = SCALES[self.current_scale_index]
        self.assign_transpose(scale)
        self.show_message(' Base Note ' + BASE_NOTE[self._base_note] + ' to ' + scale.name)
        self.current_scale_to_display()

    def inc_scale(self, inc):
        nr_of_scales = len(SCALES)
        newindex = self.current_scale_index + inc
        if newindex >= 0 and newindex < nr_of_scales:
            self.current_scale_index += inc
        elif newindex < 0:
            self.current_scale_index = nr_of_scales - 1
        else:
            self.current_scale_index = 0
        newscale = SCALES[self.current_scale_index]
        self.assign_transpose(newscale)
        self.show_message(' PAD Scale ' + newscale.name + ' ' + BASE_NOTE[self._base_note] + str(newscale.to_octave(self._octave) - 2))
        self.current_scale_to_display()

    def assign_transpose(self, scale):
        raise isinstance(scale, PadScale) or AssertionError
        scale_len = len(scale.notevalues)
        octave = scale.to_octave(self._octave)
        last_note_val = None
        for note_index in range(16):
            button = self._button_sequence[note_index]
            scale_index = note_index % scale_len
            octave_offset = note_index / scale_len
            note_value = scale.notevalues[scale_index] + self._base_note + octave * 12 + octave_offset * 12
            if note_value < 128:
                last_note_val = note_value
            elif last_note_val != None:
                note_value = last_note_val
            button.set_send_note(note_value)
            button.send_value(0)

        self.update_transpose()

    def set_device_nav_button_left(self, button):
        if self._device_nav_button_left != None:
            self._device_nav_button_left.remove_value_listener(self._nav_value_left)
        self._device_nav_button_left = button
        if self._device_nav_button_left != None:
            self._device_nav_button_left.add_value_listener(self._nav_value_left)

    def set_device_nav_button_right(self, button):
        if self._device_nav_button_right != None:
            self._device_nav_button_right.remove_value_listener(self._nav_value_right)
        self._device_nav_button_right = button
        if self._device_nav_button_right != None:
            self._device_nav_button_right.add_value_listener(self._nav_value_right)

    def _nav_value_left(self, value):
        if not self._device_nav_button_left != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                modifier_pressed = True
                value > 0 and (not self.application().view.is_view_visible('Detail') or not self.application().view.is_view_visible('Detail/DeviceChain')) and self.application().view.show_view('Detail')
                self.application().view.show_view('Detail/DeviceChain')
            else:
                direction = Live.Application.Application.View.NavDirection.left
                self.application().view.scroll_view(direction, 'Detail/DeviceChain', not modifier_pressed)

    def _nav_value_right(self, value):
        if not self._device_nav_button_right != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                modifier_pressed = value > 0 and True
                (not self.application().view.is_view_visible('Detail') or not self.application().view.is_view_visible('Detail/DeviceChain')) and self.application().view.show_view('Detail')
                self.application().view.show_view('Detail/DeviceChain')
            else:
                direction = Live.Application.Application.View.NavDirection.right
                self.application().view.scroll_view(direction, 'Detail/DeviceChain', not modifier_pressed)

    def _set_xfade_assign_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.xfade_assign_button != None:
                self.xfade_assign_button.remove_value_listener(self._do_xfade_assign)
            self.xfade_assign_button = button
            self.xfade_assign_button != None and self.xfade_assign_button.add_value_listener(self._do_xfade_assign)

    def _do_xfade_assign(self, value):
        if not self.xfade_assign_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                self._modifier_down = value != 0
                (self._mode == PAD_MODE or self._returntopad) and value != 0 and self._from_pad_mode(SCENE_MODE_XFADE)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == CLIP_MODE:
            if value != 0:
                self._invoke_track_edit(SCENE_MODE_XFADE)
            else:
                self._back_to_clip_mode()
        elif self._mode == SCENE_MODE or self._mode == CONTROL_MODE:
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_XFADE)

    def _set_track_left_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.track_left_button != None:
                self.track_left_button.remove_value_listener(self._a_trk_left)
            self.track_left_button = button
            self.track_left_button != None and self.track_left_button.add_value_listener(self._a_trk_left)

    def _set_track_right_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.track_right_button != None:
                self.track_right_button.remove_value_listener(self._a_trk_right)
            self.track_right_button = button
            self.track_right_button != None and self.track_right_button.add_value_listener(self._a_trk_right)

    def _set_display_update_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.display_update_button != None:
                self.display_update_button.remove_value_listener(self._a_display_update)
            self.display_update_button = button
            self.display_update_button != None and self.display_update_button.add_value_listener(self._a_display_update)

    def _set_scene_mode_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.scene_mode_button != None:
                self.scene_mode_button.remove_value_listener(self._a_mode_scene)
            self.scene_mode_button = button
            self.scene_mode_button != None and self.scene_mode_button.add_value_listener(self._a_mode_scene)

    def _set_clip_mode_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.clip_mode_button != None:
                self.clip_mode_button.remove_value_listener(self._a_mode_clip)
            self.clip_mode_button = button
            self.clip_mode_button != None and self.clip_mode_button.add_value_listener(self._a_mode_clip)

    def _set_pad_mode_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.pad_mode_button != None:
                self.pad_mode_button.remove_value_listener(self._a_mode_pad)
            self.pad_mode_button = button
            self.pad_mode_button != None and self.pad_mode_button.add_value_listener(self._a_mode_pad)

    def _set_control_mode_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.control_mode_button != None:
                self.control_mode_button.remove_value_listener(self._a_mode_control)
            self.control_mode_button = button
            self.control_mode_button != None and self.control_mode_button.add_value_listener(self._a_mode_control)

    def _a_mode_control(self, value):
        if not self.control_mode_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.show_message('CONTROL MODE')
            self._set_mode(CONTROL_MODE)
            self._enter_control_mode()

    def _a_mode_scene(self, value):
        if not self.scene_mode_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.show_message('SCENE MODE')
            self._enter_scene_mode()

    def _a_mode_clip(self, value):
        if not self.clip_mode_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.show_message('CLIP MODE')
            self._enter_clip_mode()

    def _a_mode_pad(self, value):
        if not self.pad_mode_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.show_message('PAD MODE')
            self._set_mode(PAD_MODE)
            self._enter_pad_mode()

    def clip_handle(self):
        if self._mode == SCENE_MODE or self._mode == CONTROL_MODE or self._modifier_down:
            self._scenematrix.update()

    def focus_changed(self):
        pass

    def scroll_focus(self, delta):
        if delta == 1:
            self.nav_index = (self.nav_index + 1) % len(VIEWS_ALL)
        elif self.nav_index == 0:
            self.nav_index = len(VIEWS_ALL) - 1
        else:
            self.nav_index -= 1
        self.show_message('Focus on : ' + str(VIEWS_ALL[self.nav_index]))
        self.application().view.focus_view(VIEWS_ALL[self.nav_index])

    def scroll_device(self, delta):
        if not (delta == 1 or delta == -1):
            raise AssertionError
            direction = delta == 1 and Live.Application.Application.View.NavDirection.right
        else:
            direction = Live.Application.Application.View.NavDirection.left
        self.application().view.scroll_view(direction, 'Detail/DeviceChain', True)

    def scroll_scene(self, delta):
        if not self.track_left_button != None:
            raise AssertionError
            raise delta == 1 or delta == -1 or AssertionError
            direction = delta == 1 and Live.Application.Application.View.NavDirection.down
        else:
            direction = Live.Application.Application.View.NavDirection.up
        self.application().view.scroll_view(direction, 'Session', True)

    def _a_trk_left(self, value):
        if not self.track_left_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                direction = value != 0 and self.application().view.is_view_visible('Session') and Live.Application.Application.View.NavDirection.left
                self.application().view.scroll_view(direction, 'Session', True)

    def _a_trk_right(self, value):
        if not self.track_left_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                direction = value != 0 and self.application().view.is_view_visible('Session') and Live.Application.Application.View.NavDirection.right
                self.application().view.scroll_view(direction, 'Session', True)

    def update_transpose(self):
        self._set_suppress_rebuild_requests(True)
        self.request_rebuild_midi_map()
        self._set_suppress_rebuild_requests(False)

    def _a_display_update(self, value):
        if not self.display_update_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if value != 0 or not self.display_update_button.is_momentary():
                    self.show_message(' Maschine Display Updated ')
                    self._master_knob.update()
                    self._set_mode()
                    self._mode == PAD_MODE and self.assign_transpose(SCALES[self.current_scale_index])
                elif self._mode == SCENE_MODE:
                    self._enter_scene_mode()
                elif self._mode == CONTROL_MODE:
                    self._enter_control_mode()
                self._master_knob.start_up()
                self.current_scale_to_display()
                self._scenematrix.soloexclusive and self._armsolomode_button.send_value(127, True)
            else:
                self._armsolomode_button.send_value(0, True)
            self._session.update()
            self.refresh_state()
            self.update_display()

    def _do_tap_tempo(self, value):
        if not value in range(128):
            raise AssertionError
            value > 0 and self.song().tap_tempo()

    def _do_toggle_cue(self, value):
        if not value in range(128):
            raise AssertionError
            value > 0 and self.song().set_or_delete_cue()

    def _do_toggle_prev_cue(self, value):
        if not value in range(128):
            raise AssertionError
            value > 0 and self.song().jump_to_prev_cue()

    def _do_toggle_next_cue(self, value):
        if not value in range(128):
            raise AssertionError
            value > 0 and self.song().jump_to_next_cue()

    def index_in_strip(self, track):
        for ind in range(len(self._mixer._channel_strips)):
            strack = self._mixer._channel_strips[ind]._track
            if strack == track:
                return ind

        return -1

    def notify_track_scroll(self):
        self._scenematrix.update_control_selection()
        if self._mode == CONTROL_MODE:
            self._scenematrix.eval_matrix()
            self._scenematrix.fire_values()

    def _do_toggle_send(self, value):
        nr_of_tracks = len(self.song().return_tracks)
        if value == 0 or nr_of_tracks < 1:
            return
        prev = self.send_slider_index
        self.send_slider_index += 1
        if self.send_slider_index >= nr_of_tracks:
            self.send_slider_index = 0
        self.show_message(' Set Send ' + str(SENDS[self.send_slider_index]))
        if prev != self.send_slider_index:
            for track in range(8):
                strip = self._mixer.channel_strip(track)
                slider_list = []
                for index in range(self.send_slider_index + 1):
                    if index < self.send_slider_index - 1:
                        slider_list.append(None)
                    else:
                        slider_list.append(self.send_sliders[track])
                    strip.set_send_controls(tuple(slider_list))

    def handle_sysex(self, midi_bytes):
        pass

    def turn_off_matrix(self):
        for row in range(4):
            for column in range(4):
                button = self._matrix[row][column]
                button.set_to_notemode(False)
                button.send_value(0, True)
                button.send_value(0, True)

    def _handle_device_changed(self, device):
        self._scenematrix.update_on_device(device)

    def _hande_device_parm_changed(self):
        self._scenematrix.update_on_device_parm_changed()

    def remove_listener(self, control, callback):
        if control != None and control.value_has_listener(callback):
            control.remove_value_listener(callback)
        control.disconnect()

    def current_scale_to_display(self):
        scale = SCALES[self.current_scale_index]
        text = scale.name + ' ' + BASE_NOTE[self._base_note] + str(scale.to_octave(self._octave))
        self.send_to_display(text)

    def send_to_display(self, text, grid = 0):
        if not USE_DISPLAY:
            return
        if len(text) > 28:
            text = text[:27]
        msgsysex = [240,
         0,
         0,
         102,
         23,
         18,
         min(grid, 3) * 28]
        filled = text.ljust(28)
        for c in filled:
            msgsysex.append(ord(c))

        msgsysex.append(247)
        self._send_midi(tuple(msgsysex))

    def disconnect(self):
        self.turn_off_matrix()
        self._active = False
        self.send_to_display('', 0)
        self.send_to_display('', 1)
        self.send_to_display('', 2)
        self.send_to_display('', 3)
        self._set_suppress_rebuild_requests(True)
        self._master_knob.disconnect()
        self.xfadeKnob.disconnect()
        self.remove_listener(self.tap_button, self._do_tap_tempo)
        self.remove_listener(self.cue_add_delete_button, self._do_toggle_cue)
        self.remove_listener(self.cue_prev_button, self._do_toggle_prev_cue)
        self.remove_listener(self.cue_next_button, self._do_toggle_next_cue)
        self.remove_listener(self.send_slider_toggle_button, self._do_toggle_send)
        self.remove_listener(self.recordQuantSlider, self._on_rec_quant)
        self.remove_listener(self._undo_button, self._do_undo)
        self.remove_listener(self._redo_button, self._do_redo)
        self.remove_listener(self._armsolomode_button, self._do_armsolo_mode)
        self.remove_listener(self._navigate_button, self._do_navigate)
        self.remove_listener(self._fire_button, self._do_mute_fire_button)
        self.remove_listener(self._mode_base_button, self._do_pad_mode_base)
        self.remove_listener(self._mode_octave_button, self._do_pad_mode_octave)
        self.remove_listener(self._pad_scale_up, self._do_pad_note_up)
        self.remove_listener(self._pad_scale_down, self._do_pad_note_down)
        self.remove_listener(self._device_nav_button_left, self._nav_value_left)
        self.remove_listener(self._device_nav_button_right, self._nav_value_right)
        self.remove_listener(self.xfade_assign_button, self._do_xfade_assign)
        self.remove_listener(self.track_left_button, self._a_trk_left)
        self.remove_listener(self.track_right_button, self._a_trk_right)
        self.remove_listener(self.display_update_button, self._a_display_update)
        self.remove_listener(self.scene_mode_button, self._a_mode_scene)
        self.remove_listener(self.clip_mode_button, self._a_mode_clip)
        self.remove_listener(self.pad_mode_button, self._a_mode_pad)
        self.remove_listener(self.control_mode_button, self._a_mode_control)
        self.remove_listener(self._pad_solo_button, self._do_pad_solo_multi)
        self.remove_listener(self._mute_button, self._do_mute_button)
        self.remove_listener(self._pad_select_button, self._do_pad_select_multi)
        self.remove_listener(self._group_d_button, self._do_arm)
        self.remove_listener(self._group_h_button, self._do_stop)
        self.remove_listener(self._fire_dedictated_button, self._do_dedictated_fire_button)
        self.xfadeKnob.disconnect()
        self.master_volume.disconnect()
        self.prehear.disconnect()
        self._mixer.disconnect()
        self.song().view.remove_detail_clip_listener(self.clip_handle)
        self.song().remove_visible_tracks_listener(self.clip_handle)
        self.song().remove_scenes_listener(self.clip_handle)
        self.application().view.remove_view_focus_changed_listener(self.focus_changed)
        self._button_sequence = None
        self._matrix = None
        self._bmatrix = None
        self.time_callback = None
        self._device_nav_button_left = None
        self._device_nav_button_right = None
        self.send_sliders = None
        self.send_slider_toggle_button = None
        self.timer_repeat = None
        ControlSurface.disconnect(self)
        self._scenematrix.disconnect()
        self._scenematrix = None
        self._device = None
########NEW FILE########
__FILENAME__ = MaschineDeviceComponent
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk1\MaschineDeviceComponent.py
import Live
from _Generic.Devices import *
from _Framework.DeviceComponent import DeviceComponent
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.EncoderElement import EncoderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.ChannelTranslationSelector import ChannelTranslationSelector
from MIDI_Map import *

class MaschineDeviceComponent(DeviceComponent):
    """ Class representing a device in Live """

    def __init__(self, surface):
        DeviceComponent.__init__(self)
        self.surface = surface
        self.device_listener = None
        self.device_parm_listener = None
        self._control_translation_selector = ChannelTranslationSelector(8)

    def set_device(self, device):
        DeviceComponent.set_device(self, device)
        if self.device_listener != None:
            self.device_listener(device)

    def set_parameter_controls(self, controls):
        DeviceComponent.set_parameter_controls(self, controls)
        self._control_translation_selector.set_controls_to_translate(controls)
        self._control_translation_selector.set_mode(self._bank_index)

    def _on_parameters_changed(self):
        DeviceComponent._on_parameters_changed(self)
        if self.device_parm_listener != None:
            self.device_parm_listener()

    def set_device_changed_listener(self, listener):
        self.device_listener = listener

    def set_device_parm_listener(self, listener):
        self.device_parm_listener = listener

    def disconnect(self):
        DeviceComponent.disconnect(self)
        self._control_translation_selector.disconnect()
        self.surface = None
        self.device_listener = None
        self.device_parm_listener = None
########NEW FILE########
__FILENAME__ = MaschineSessionComponent
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk1\MaschineSessionComponent.py
import Live
from MIDI_Map import *
from _Framework.InputControlElement import *
from _Framework.ButtonElement import *
from _Framework.SessionComponent import *

class MaschineSessionComponent(SessionComponent):
    __module__ = __name__
    __doc__ = 'Controller Map for Soft Step Foot Controller'

    def __init__(self):
        SessionComponent.__init__(self, 4, 4)
        self._matrix = None
        self._advance = STEP4
        self._mode_button = None
        self._set_mode_button(ButtonElement(False, MIDI_CC_TYPE, 0, 80))
        self._linkoff = 0
        self.set_track_banking_increment(STEP4)

    def _link(self):
        pass

    def get_track_offset(self):
        return self._track_offset + self._linkoff

    def get_scene_offset(self):
        return self._scene_offset

    def set_matrix(self, matrix):
        self._matrix = matrix

    def _set_mode_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._mode_button != None:
                self._mode_button.remove_value_listener(self._do_matrix_adv_mode)
            self._mode_button = button
            if self._mode_button != None:
                self._mode_button.add_value_listener(self._do_matrix_adv_mode)
            self._advance == STEP4 and self._mode_button.send_value(127)
        else:
            self._mode_button.send_value(0)

    def _do_matrix_adv_mode(self, value):
        if not self._mode_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                self._advance = value != 0 and self._advance == STEP1 and STEP4
                self._mode_button.send_value(127, True)
                self.set_track_banking_increment(STEP4)
            else:
                self._advance = STEP1
                self._mode_button.send_value(0, True)
                self.set_track_banking_increment(STEP1)

    def set_advance(self, val):
        self._advance = val
        if self._advance == STEP4:
            self._mode_button.send_value(127)
        else:
            self._mode_button.send_value(0)

    def update(self):
        SessionComponent.update(self)
        try:
            self._advance
        except AttributeError:
            pass
        else:
            if self._advance == STEP4:
                self._mode_button.send_value(127)
            else:
                self._mode_button.send_value(0)

    def notify_b(self, blink):
        if blink > 5:
            blinkslow = 0
        else:
            blinkslow = 1
        blinkfast = blink % 2
        for scene_index in range(4):
            scene = self.scene(scene_index)
            for track_index in range(4):
                clip_slot = scene.clip_slot(track_index)._clip_slot
                if clip_slot != None and clip_slot.has_clip:
                    button = self._matrix[scene_index][track_index]
                    if button != None:
                        if clip_slot.clip.is_triggered:
                            button.send_value(blinkfast * 1)
                        elif clip_slot.clip.is_playing:
                            button.send_value(blinkslow * 1)
                elif clip_slot != None:
                    button = self._matrix[scene_index][track_index]
                    if button != None:
                        if clip_slot.is_triggered:
                            button.send_value(blinkfast * 1)
                        elif clip_slot.is_playing:
                            button.send_value(blinkslow * 1)

    def bank_down(self):
        if self.is_enabled():
            newoff = max(0, self._scene_offset - 1)
            self.set_offsets(self._track_offset, newoff)

    def bank_up(self):
        if self.is_enabled():
            self.set_offsets(self._track_offset, self._scene_offset + 1)

    def bank_left(self):
        if self.is_enabled():
            self.set_offsets(max(0, self._track_offset - 1), self._scene_offset)

    def bank_right(self):
        if self.is_enabled():
            self.set_offsets(self._track_offset + 1, self._scene_offset)

    def disconnect(self):
        self._matrix = None
        self._mode_button = None
        SessionComponent.disconnect(self)
########NEW FILE########
__FILENAME__ = MIDI_Map
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk1\MIDI_Map.py
from PadScale import PadScale
USE_DISPLAY = False
PM_OFF = 0
PM_ON = 1
SCENE_MODE = 1
CLIP_MODE = 2
PAD_MODE = 3
CONTROL_MODE = 4
STEP1 = 1
STEP4 = 4
MODE_PRESS_NONE = 0
MODE_PRESS_SELECT = 1
MODE_PRESS_SOLO = 2
SCENE_MODE_NORMAL = 0
SCENE_MODE_MUTE = 1
SCENE_MODE_SELECT = 2
SCENE_MODE_SOLO = 3
SCENE_MODE_ARM = 4
SCENE_MODE_STOP = 5
SCENE_MODE_CONTROL = 6
SCENE_MODE_XFADE = 7
BASIC_CHANNEL = 3
DEVICE_CC_OFF = 40
DEVICE_BUTTON_CC_OFF = 100
LEVEL_CC_OFF = 10
PAN_CC_OFF = 20
SEND_CC_OFF = 30
STOP_CC_OFF = 50
MUTE_CC_OFF = 80
SOLO_CC_OFF = 90
ARM_CC_OFF = 60
SELECT_CC_OFF = 70
COLOR_OFF = 0
COLOR_ON = 1
COLOR_BLINK = 2
COLOR_FBLINK = 3
CONTROL_LEVEL = 0
CONTROL_PAN = 1
CONTROL_SEND = 2
CONTROL_DEVICE = 3
CLICK_TIME = 500
msg_sender = None

def register_sender(sender):
    global msg_sender
    msg_sender = sender


def debug_out(message):
    if msg_sender != None:
        msg_sender.log_message(message)


SHIFT_INC = 4
INIT_SLOT = 10
SENDS = ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P')
BASE_NOTE = ('C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B')
VIEWS_ALL = ('Session', 'Detail/Clip', 'Detail/DeviceChain', 'Browser', 'Arranger')
VIEWS = ('Browser', 'Detail/Clip', 'Detail/DeviceChain', 'Session')
CLIPNOTEMAP = ((24, 25, 26, 27),
 (20, 21, 22, 23),
 (16, 17, 18, 19),
 (12, 13, 14, 15))
SCALES = (PadScale('Chromatic', (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)),
 PadScale('Ionian/Major', (0, 2, 4, 5, 7, 9, 11)),
 PadScale('Aeolian/Minor', (0, 2, 3, 5, 7, 8, 10)),
 PadScale('Pentatonic', (0, 2, 4, 7, 9)),
 PadScale('Pentatonic Minor', (0, 3, 5, 7, 10)),
 PadScale('Dorian (B/g)', (0, 2, 3, 5, 7, 9, 10)),
 PadScale('Phrygian (A-flat/f)', (0, 1, 3, 5, 7, 8, 10)),
 PadScale('Lydian (D/e)', (0, 2, 4, 6, 7, 9, 11)),
 PadScale('Mixolydian (F/d)', (0, 2, 4, 5, 7, 9, 10)),
 PadScale('Locrian (D-flat/b-flat)', (0, 1, 3, 5, 6, 8, 10)),
 PadScale('Diminish', (0, 2, 3, 5, 6, 8, 9, 10, 11)),
 PadScale('Major Blues', (0, 3, 4, 7, 9, 10)),
 PadScale('Minor Blues', (0, 3, 4, 6, 7, 10)),
 PadScale('Whole', (0, 2, 4, 6, 8, 10)),
 PadScale('Arabian', (0, 2, 4, 5, 6, 8, 10)),
 PadScale('Egyptian', (0, 2, 5, 7, 10)),
 PadScale('Gypsi', (0, 2, 3, 6, 7, 8, 11)),
 PadScale('Spanish Scale', (0, 1, 3, 4, 5, 7, 8, 10)),
 PadScale('Raga Bhairav', (0, 1, 4, 5, 7, 8, 11)),
 PadScale('Raga Gamanasrama', (0, 1, 4, 6, 7, 9, 11)),
 PadScale('Rag Todi', (0, 1, 3, 6, 7, 8, 11)),
 PadScale('3rd (C,E,G#)', (0, 4, 8)),
 PadScale('4th (C,F,A#)', (0, 5, 10)),
 PadScale('5th', (0, 7)),
 PadScale('Octave', tuple([0])))
PADCHANNEL = 0
DRUM_PADS = (-1, 12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3)
########NEW FILE########
__FILENAME__ = PadScale
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk1\PadScale.py


class PadScale:
    __module__ = __name__
    __doc__ = ' scale '

    def __init__(self, name, notevalues):
        isinstance(notevalues, tuple)
        self.name = name
        self.notevalues = notevalues
        scale_len = len(self.notevalues)
        rel_range = 16.0 / scale_len
        self.octave_range = int(10 - rel_range + 0.5)
        if self.octave_range < 0:
            self.octave_range = 0

    def to_octave(self, value):
        if self.octave_range == 0:
            return 0
        return int(value * self.octave_range)

    def to_relative(self, value, prev):
        if self.octave_range == 0:
            return prev
        relvalue = value / float(self.octave_range)
        if relvalue > 1.0:
            return 1.0
        elif relvalue < 0.0:
            return 0.0
        return relvalue
########NEW FILE########
__FILENAME__ = SceneElement
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk1\SceneElement.py
import Live
import time
from _Framework.ButtonElement import *
from _Framework.CompoundComponent import *
from MIDI_Map import *

class SceneElement:
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, index, matrix):
        self._matrix = matrix
        self._launch_button = None
        self.index = index
        self._scene = None
        self._track = None
        self._pressAction = self._launch_scene
        self.eval = self._eval_scene_states
        self.color = COLOR_OFF

    def set_launch_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if button != self._launch_button:
                if self._launch_button != None:
                    self._launch_button.remove_value_listener(self._launch_value)
                self._launch_button = button
                self._launch_button != None and self._launch_button.add_value_listener(self._launch_value)

    def notify(self, blink):
        if blink > 5:
            blinkslow = 0
        else:
            blinkslow = 1
        blinkfast = blink % 2
        if self.color == COLOR_BLINK:
            self._launch_button.send_value(1 * blinkslow)
        elif self.color == COLOR_FBLINK:
            self._launch_button.send_value(1 * blinkfast)

    def set_value(self):
        if self._launch_button != None:
            if self.color == COLOR_OFF:
                self._launch_button.send_value(0)
            else:
                self._launch_button.send_value(1)

    def force_value(self, value):
        if self._launch_button != None:
            self._launch_button.send_value(value)

    def set_scene(self, scene):
        self._scene = scene

    def set_track(self, track):
        if self._track != None:
            if self._track.can_be_armed:
                self._track.remove_arm_listener(self._got_arm)
            self._track.remove_mute_listener(self._got_mute)
            self._track.remove_solo_listener(self._got_solo)
            self._track.remove_playing_slot_index_listener(self._got_playing)
            self._track.remove_fired_slot_index_listener(self._got_slot_fired)
            if self._track.mixer_device.crossfade_assign_has_listener(self._got_xfade):
                self._track.mixer_device.remove_crossfade_assign_listener(self._got_xfade)
        self._track = track
        if track != None:
            if self._track.can_be_armed:
                self._track.add_arm_listener(self._got_arm)
            self._track.add_mute_listener(self._got_mute)
            self._track.add_solo_listener(self._got_solo)
            self._track.add_playing_slot_index_listener(self._got_playing)
            self._track.mixer_device.add_crossfade_assign_listener(self._got_xfade)
            self._track.add_fired_slot_index_listener(self._got_slot_fired)

    def _got_xfade(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_XFADE:
            self.eval()
            self.set_value()

    def _got_arm(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_ARM:
            self.eval()

    def _got_mute(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_MUTE:
            self.eval()

    def _got_solo(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_SOLO:
            self.eval()

    def _got_playing(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_STOP:
            self._matrix.update()

    def _got_slot_fired(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_STOP:
            self._matrix.update()

    def assign_mode(self, mode):
        if mode == SCENE_MODE_NORMAL:
            self.eval = self._eval_scene_states
        elif mode == SCENE_MODE_CONTROL:
            self.eval = self._eval_control_mode
        elif mode == SCENE_MODE_MUTE:
            self.eval = self._eval_mute
        elif mode == SCENE_MODE_SOLO:
            self.eval = self._eval_solo
        elif mode == SCENE_MODE_SELECT:
            self.eval = self._eval_select
        elif mode == SCENE_MODE_ARM:
            self.eval = self._eval_arm
        elif mode == SCENE_MODE_STOP:
            self.eval = self._eval_stop
        elif mode == SCENE_MODE_XFADE:
            self.eval = self._eval_xfade_assign

    def _eval_xfade_assign(self):
        if self._track != None and self._track.mixer_device != None:
            xfade = self._track.mixer_device.crossfade_assign
            if xfade == 0:
                self.color = COLOR_ON
            elif xfade == 1:
                self.color = COLOR_OFF
            elif xfade == 2:
                self.color = COLOR_BLINK
            self._pressAction = self._switch_xfade_assign
        else:
            self.color = COLOR_OFF
            self._pressAction = self._inaktion

    def _switch_xfade_assign(self, value):
        if self._track != None:
            xfade = (self._track.mixer_device.crossfade_assign + 1) % 3
            if xfade == 0:
                self.color = COLOR_ON
            elif xfade == 1:
                self.color = COLOR_OFF
            elif xfade == 2:
                self.color = COLOR_BLINK
            self._track.mixer_device.crossfade_assign = xfade
            self.set_value()

    def _eval_stop(self):
        self._pressAction = self._stop_track
        if self._track != None:
            clipslots = self._track.clip_slots
            stop_fired = self._track.fired_slot_index == -2
            play_fired = self._track.fired_slot_index >= 0
            clip_playing = False
            has_clip = False
            if clipslots != None:
                for cs_index in range(len(clipslots)):
                    clip_slot = clipslots[cs_index]
                    if clip_slot.has_clip:
                        has_clip = True
                        if clip_slot.clip.is_playing:
                            clip_playing = True
                    elif clip_slot.controls_other_clips:
                        has_clip = True
                        if clip_slot.is_playing:
                            clip_playing = True
                        if clip_slot.is_triggered:
                            play_fired = True
                    elif clip_slot.is_triggered:
                        stop_fired = True

            is_group = self._track.is_foldable
            if stop_fired or play_fired:
                self.color = COLOR_FBLINK
            elif is_group:
                if clip_playing:
                    self.color = COLOR_BLINK
                elif has_clip:
                    self.color = COLOR_ON
                else:
                    self.color = COLOR_OFF
            elif clip_playing:
                self.color = COLOR_BLINK
            elif has_clip:
                self.color = COLOR_ON
            else:
                self.color = COLOR_OFF
        else:
            self.color = COLOR_OFF

    def _eval_arm(self):
        prevcolor = self.color
        self._pressAction = self._arm_track
        if self._track == None:
            self.color = COLOR_OFF
        elif self._track.can_be_armed:
            if self._track.arm:
                self.color = COLOR_ON
            else:
                self.color = COLOR_OFF
        else:
            self.color = COLOR_OFF
        if prevcolor != self.color:
            self.set_value()

    def _eval_mute(self):
        prevcolor = self.color
        self._pressAction = self._mute_track
        if self._track == None:
            self.color = COLOR_OFF
        elif self._track.mute:
            self.color = COLOR_OFF
        else:
            self.color = COLOR_ON
        if prevcolor != self.color:
            self.set_value()

    def _eval_solo(self):
        prevcolor = self.color
        self._pressAction = self._solo_track
        if self._track == None:
            self.color = COLOR_OFF
        elif self._track.solo:
            self.color = COLOR_ON
        else:
            self.color = COLOR_OFF
        if prevcolor != self.color:
            self.set_value()

    def _eval_select(self):
        prevcolor = self.color
        self._pressAction = self._select_track
        if self._track == None:
            self.color = COLOR_OFF
        elif self._track == self._matrix.getSelectedTrack():
            self.color = COLOR_ON
        else:
            self.color = COLOR_OFF
        if prevcolor != self.color:
            self.set_value()

    def _eval_control_mode(self):
        prevcolor = self.color
        if self.index > 7:
            if self._matrix.control_handler.mode == CONTROL_DEVICE:
                parm_index = self._matrix.control_handler.index_parm_id(self.index)
                self._eval_device_buttons(parm_index)
            else:
                track_index = self._matrix.control_handler.index_parm_id(self.index)
                self._eval_mixer_button(track_index)
        elif self.index > 3:
            mode = self.index - 4
            self.color = COLOR_ON
            if mode == self._matrix.control_handler.mode:
                self.color = COLOR_ON
            else:
                self.color = COLOR_OFF
            self._pressAction = self._select_dev_mode
        elif self._matrix.control_handler.mode == CONTROL_SEND:
            self._set_up_control_send()
        elif self._matrix.control_handler.mode == CONTROL_DEVICE:
            self._set_up_device_nav()
        else:
            self.color = COLOR_OFF
            self._pressAction = self._inaktion
        if prevcolor != self.color:
            self.set_value()

    def _eval_device_buttons(self, index):
        valid = True
        if self._matrix.control_handler.selected_device == None:
            valid = False
        elif index >= self._matrix.control_handler.nr_of_parms_in_bank():
            valid = False
        if valid:
            if index == 0 and self._matrix.control_handler.selected_bank == 0:
                self.color = COLOR_OFF
            else:
                self.color = COLOR_ON
            if index == self._matrix.control_handler.selected_device_parm_index:
                self.color = COLOR_BLINK
            else:
                self.color = COLOR_ON
            self._pressAction = self._select_knob_assign_device
        else:
            self.color = COLOR_OFF
            self._pressAction = self._inaktion

    def _eval_mixer_button(self, index):
        track = self._matrix._control._mixer._channel_strips[index]._track
        if track == None:
            self.color = COLOR_OFF
            self._pressAction = self._inaktion
        else:
            if index == self._matrix.control_handler.sel_track_parm_index:
                self.color = COLOR_ON
            else:
                self.color = COLOR_OFF
            self._pressAction = self._select_knob_assign

    def _set_up_device_nav(self):
        if self.index == 0:
            self.color = COLOR_ON
            self._pressAction = self._nav_device_left
        elif self.index == 1:
            self.color = COLOR_ON
            self._pressAction = self._nav_device_right
        elif self.index == 2:
            self._pressAction = self._nav_bank_left
            if self._matrix.control_handler.selected_bank == 0:
                self.color = COLOR_OFF
            else:
                self.color = COLOR_ON
        elif self.index == 3:
            self._pressAction = self._nav_bank_right
            if self._matrix.control_handler.selected_bank < self._matrix.control_handler.nr_of_banks() - 1:
                self.color = COLOR_ON
            else:
                self.color = COLOR_OFF

    def _nav_device_left(self, value):
        if value > 0:
            self._matrix._control._nav_value_left(1)

    def _nav_device_right(self, value):
        if value > 0:
            self._matrix._control._nav_value_right(1)

    def _nav_bank_left(self, value):
        if value > 0 and self._matrix.control_handler.dec_bank_nr():
            self._matrix.update_on_device_parm_changed()

    def _nav_bank_right(self, value):
        if value > 0 and self._matrix.control_handler.inc_bank_nr():
            self._matrix.update_on_device_parm_changed()

    def disable_color(self):
        self.color = COLOR_OFF

    def _set_up_control_send(self):
        nr_of_tracks = len(self._matrix._control.song().return_tracks)
        if self.index < nr_of_tracks:
            if nr_of_tracks > 3 and self.index == 3:
                self.color = COLOR_ON
            if self.index == self._matrix.control_handler.selected_sends_index:
                self.color = COLOR_BLINK
            elif self.index == 3 and self._matrix.control_handler.selected_sends_index >= 3:
                self.color = COLOR_BLINK
            else:
                self.color = COLOR_OFF
            self._pressAction = self._select_sub_sends
        else:
            self.color = COLOR_OFF
            self._pressAction = self._inaktion

    def _select_sub_sends(self, value):
        self._matrix._control._master_knob.switch_to_matrix_mode()
        nr_of_tracks = len(self._matrix._control.song().return_tracks)
        new_index = self.index
        fire = False
        if self.index == 3:
            fire = True
            if self._matrix.control_handler.selected_sends_index < 3:
                new_index = 3
            elif self._matrix.control_handler.selected_sends_index < nr_of_tracks - 1:
                new_index = self._matrix.control_handler.selected_sends_index + 1
            else:
                new_index = 3
        self._matrix.control_handler.selected_sends_index = new_index
        self._matrix.control_handler.message_current_parm()
        self._matrix.control_handler.reassign_mix_parm()
        self._matrix.eval_matrix()
        if fire:
            self.set_value()

    def _select_knob_assign(self, value):
        self._matrix._control._master_knob.switch_to_matrix_mode()
        ip = self._matrix.control_handler.index_parm_id(self.index)
        track = self._matrix._control._mixer._channel_strips[ip]._track
        if self._matrix.control_handler.assign_mix_parm(track, ip):
            self._matrix.eval_matrix()
            self._matrix.control_handler.message_current_parm()

    def _select_knob_assign_device(self, value):
        self._matrix._control._master_knob.switch_to_matrix_mode()
        ip = self._matrix.control_handler.index_parm_id(self.index)
        if self._matrix.control_handler.assign_device_parm(ip):
            self._matrix.eval_matrix()

    def _select_dev_mode(self, value):
        self._matrix._control._master_knob.switch_to_matrix_mode()
        mode_index = self._matrix.control_handler.index_mode_id(self.index)
        if mode_index == CONTROL_DEVICE:
            device = self._matrix._control._device._device
            if device != None:
                self._matrix.control_handler.mode = mode_index
                self._matrix.control_handler.selected_device = device
                self._matrix._control.show_message('Control Device: ' + str(device.name))
                self._matrix.control_handler.reassign_device_parm()
                self._update_matrix()
        elif mode_index != self._matrix.control_handler.mode:
            self._matrix.control_handler.mode = mode_index
            self._matrix.control_handler.reassign_mix_parm()
            self._update_matrix()
            self._matrix.control_handler.message_current_parm()

    def _update_matrix(self):
        self._matrix.eval_matrix()
        self._matrix.fire_values()

    def _inaktion(self, value):
        pass

    def _eval_scene_states(self):
        prevcolor = self.color
        self._pressAction = self._launch_scene
        if self._scene == None:
            self.color = COLOR_OFF
        else:
            clip_slots = self._scene.clip_slots
            count = 0
            playcount = 0
            if self._scene.is_triggered:
                self.color = COLOR_FBLINK
            else:
                for cs_index in range(len(clip_slots)):
                    clip_slot = clip_slots[cs_index]
                    if clip_slot.has_clip:
                        count = count + 1
                        if clip_slot.clip.is_playing:
                            playcount = playcount + 1

                if playcount > 0:
                    self.color = COLOR_BLINK
                elif count > 0:
                    self.color = COLOR_ON
                else:
                    self.color = COLOR_OFF
        if prevcolor != self.color:
            self.set_value()

    def unbind(self):
        if self._launch_button != None and self._track != None:
            if self._track.can_be_armed:
                self._track.remove_arm_listener(self._got_arm)
            self._track.remove_mute_listener(self._got_mute)
            self._track.remove_solo_listener(self._got_solo)
            self._track.remove_playing_slot_index_listener(self._got_playing)
            self._track.mixer_device.remove_crossfade_assign_listener(self._got_xfade)
            self._track.remove_fired_slot_index_listener(self._got_slot_fired)
        self._launch_button = None
        self._scene = None

    def disconnect(self):
        if self._launch_button != None and self._launch_button.value_has_listener(self._launch_value):
            self._launch_button.remove_value_listener(self._launch_value)

    def _launch_value(self, value):
        raise self._launch_button != None or AssertionError
        raise self._pressAction != None or AssertionError
        raise value in range(128) or AssertionError
        self._pressAction(value)

    def _launch_scene(self, value):
        if not value in range(128):
            raise AssertionError
            if self._scene != None:
                pass
            self._launch_button.is_momentary() and self._scene.set_fire_button_state(value != 0)
        elif value != 0:
            self._scene.fire()

    def _mute_track(self, value):
        if value == 0:
            return
        if self._track != None:
            if self._track.mute:
                self._track.mute = False
                self.color = COLOR_ON
                self._launch_button.send_value(1)
            else:
                self._track.mute = True
                self.color = COLOR_OFF
                self._launch_button.send_value(0)

    def _arm_track(self, value):
        if value == 0:
            return
        if self._track != None and self._track.can_be_armed:
            if self._track.arm:
                self._track.arm = False
                self.color = COLOR_OFF
                self._launch_button.send_value(0)
            else:
                self._track.arm = True
                self.color = COLOR_ON
                self._launch_button.send_value(1)
            self._matrix.do_arm(self.index)

    def _stop_track(self, value):
        if self._track != None:
            self._track.stop_all_clips()

    def _solo_track(self, value):
        if value == 0:
            return
        if self._track != None:
            if self._track.solo:
                self._track.solo = False
                self.color = COLOR_OFF
                self._launch_button.send_value(0)
            else:
                self._track.solo = True
                self.color = COLOR_ON
                self._launch_button.send_value(1)
            self._matrix.do_solo(self.index)

    def _select_track(self, value):
        if self._track != None:
            self._matrix.setSelectedTrack(self._track)

    def debug(self, message):
        self._matrix._control.log_message(message)
########NEW FILE########
__FILENAME__ = SceneMatrix
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk1\SceneMatrix.py
import Live
from _Framework.ButtonElement import *
from _Framework.CompoundComponent import *
from MIDI_Map import *
from SceneElement import SceneElement
from ControlHandler import ControlHandler
from MainKnobControl import *

class SceneMatrix:
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, ctrl):
        self.track_offset = 0
        self.scene_offset = 0
        self._scenes = []
        self._control = ctrl
        self.mode = SCENE_MODE_NORMAL
        self.receives_notify = True
        self.control_handler = ControlHandler(ctrl, self)
        self.soloexclusive = True
        self.mutedsolo = False
        for index in range(16):
            self._scenes.append(SceneElement(index, self))

        self._control.song().view.add_selected_track_listener(self._sel_track_changed)
        self.active = False

    def notify_scene_mode(self, blinkstate):
        if self.receives_notify and self.active:
            num_scenes = len(self._scenes)
            for index in range(num_scenes):
                self._scenes[index].eval()
                self._scenes[index].notify(blinkstate)

    def update_control_selection(self):
        trindex = self._control.index_in_strip(self.control_handler.track)
        self.control_handler.sel_track_parm_index = trindex

    def mod_track_offset(self, delta):
        nr_of_tracks = len(self._control.song().tracks)
        newoffset = self.track_offset + delta * 16
        if newoffset > -1 and newoffset < nr_of_tracks:
            self.track_offset = newoffset
            self.show_track_control_message(nr_of_tracks)
            self.update()

    def mod_scene_offset(self, delta):
        scenes = self._control.song().scenes
        nr_of_scenes = len(scenes)
        newoffset = self.scene_offset + delta
        if newoffset > -1 and newoffset + 15 < nr_of_scenes:
            self.scene_offset = newoffset
            self.show_scene_control_message(nr_of_scenes)
            self.update()

    def show_scene_control_message(self, nr_of_scenes):
        self._control.show_message('Pads control Scenes ' + str(self.scene_offset + 1) + ' to ' + str(min(nr_of_scenes, self.scene_offset + 16)) + ' in Scene Mode')

    def show_track_control_message(self, nr_of_tracks):
        self._control.show_message('Pads control Tracks ' + str(self.track_offset + 1) + ' to ' + str(min(nr_of_tracks, self.track_offset + 16)))

    def _sel_track_changed(self):
        if self.mode == SCENE_MODE_SELECT:
            self.update()

    def in_main_mode(self):
        if self.mode == SCENE_MODE_NORMAL or self.mode == SCENE_MODE_CONTROL:
            return True
        return False

    def get_element(self, col, row):
        index = (3 - col) * 4 + row
        return self._scenes[index]

    def set_knob_mode(self, mode):
        self._control._master_knob._set_mode(KN2_MODE_GENERAL)

    def set_armsolo_exclusive(self, button):
        if self.soloexclusive:
            self.soloexclusive = False
            self._control.show_message(str('Exclusive Mode Arm/Solo Off'))
            button.send_value(0, True)
        else:
            self.soloexclusive = True
            self._control.show_message(str('Exclusive Mode Arm/Solo On'))
            button.send_value(127, True)

    def unbind(self):
        self._control.song().view.remove_selected_track_listener(self._sel_track_changed)
        num_scenes = len(self._scenes)
        for index in range(num_scenes):
            self._scenes[index].disable_color()
            self._scenes[index].force_value(0)
            self._scenes[index].unbind()

    def deassign(self):
        num_scenes = len(self._scenes)
        for index in range(num_scenes):
            self._scenes[index].set_launch_button(None)
            self._scenes[index].set_scene(None)
            self._scenes[index].set_track(None)
            self._scenes[index].eval()

    def assign(self):
        scenes = self._control.song().scenes
        tracks = self._control.song().tracks
        for index in range(16):
            tr_index = index + self.track_offset
            sc_index = index + self.scene_offset
            self._scenes[index].set_launch_button(self._control._button_sequence[index])
            if sc_index < len(scenes):
                self._scenes[index].set_scene(scenes[sc_index])
            else:
                self._scenes[index].set_scene(None)
            if tr_index < len(tracks):
                self._scenes[index].set_track(tracks[tr_index])
            else:
                self._scenes[index].set_track(None)
            self._scenes[index].eval()

    def set_mode(self, mode):
        self.mode = mode
        if self.mode == SCENE_MODE_NORMAL or self.mode == SCENE_MODE_STOP or self.mode == SCENE_MODE_CONTROL or self.mode == SCENE_MODE_XFADE:
            self.receives_notify = True
        else:
            self.receives_notify = False
        num_scenes = len(self._scenes)
        for index in range(num_scenes):
            self._scenes[index].assign_mode(mode)

        if mode == SCENE_MODE_CONTROL and self.control_handler.parm == None:
            trindex = self.control_handler.sel_track_parm_index
            track = self._control._mixer._channel_strips[trindex]._track
            if track != None:
                self.control_handler.track = track
                self.control_handler.reassign_mix_parm()
        self.update()

    def set_active(self, active):
        self.active = active

    def do_solo(self, track_index):
        if self.soloexclusive:
            tracks = self._control.song().tracks
            for index in range(len(tracks)):
                if index != track_index and tracks[index].solo:
                    tracks[index].solo = False

    def do_arm(self, track_index):
        if self.soloexclusive:
            tracks = self._control.song().tracks
            for index in range(len(tracks)):
                if index != track_index and tracks[index].can_be_armed and tracks[index].arm:
                    tracks[index].arm = False

    def eval_matrix(self):
        for index in range(16):
            self._scenes[index].eval()

    def fire_values(self):
        for index in range(16):
            self._scenes[index].set_value()

    def eval_control(self):
        nr_of_tracks = len(self._control.song().return_tracks)
        if self.control_handler.selected_sends_index >= nr_of_tracks:
            self.control_handler.selected_sends_index = nr_of_tracks - 1

    def setSelectedTrack(self, track):
        self._control.song().view.selected_track = track

    def getSelectedTrack(self):
        return self._control.song().view.selected_track

    def update_on_device(self, device):
        if self.mode == SCENE_MODE_CONTROL and self.control_handler.mode == CONTROL_DEVICE:
            self.control_handler.set_device(device)
            self.update()

    def update_on_device_parm_changed(self):
        if self.mode == SCENE_MODE_CONTROL and self.control_handler.mode == CONTROL_DEVICE:
            self.update()

    def disconnect(self):
        num_scenes = len(self._scenes)
        for index in range(num_scenes):
            self._scenes[index].disconnect()

        self.unbind()
        self._scenes = None
        self._control = None
        self.mode = None
        self.receives_notify = None
        self.control_handler.disconnect()
        self.soloexclusive = None
        self.mutedsolo = None

    def fix_track_offset(self, nr_of_tracks):
        while self.track_offset >= nr_of_tracks:
            self.track_offset -= 16

        self.show_track_control_message(nr_of_tracks)

    def fix_scene_offset(self, nr_of_scenes, showMessage = True):
        while self.scene_offset + 15 >= nr_of_scenes and self.scene_offset > 0:
            self.scene_offset -= 1

        if showMessage:
            self.show_scene_control_message(nr_of_scenes)

    def update(self):
        if not self.active:
            return
        scenes = self._control.song().scenes
        tracks = self._control.song().tracks
        nr_of_tracks = len(tracks)
        nr_of_scenes = len(scenes)
        if self.track_offset < 0:
            self.track_offset = 0
        elif self.track_offset >= nr_of_tracks:
            self.fix_track_offset(nr_of_tracks)
        if self.scene_offset < 0:
            self.scene_offset = 0
        elif self.scene_offset + 15 >= nr_of_scenes:
            self.fix_scene_offset(nr_of_scenes, False)
        self.eval_control()
        for index in range(16):
            tr_index = index + self.track_offset
            sc_index = index + self.scene_offset
            if sc_index < nr_of_scenes:
                self._scenes[index].set_scene(scenes[sc_index])
            else:
                self._scenes[index].set_scene(None)
            if tr_index < nr_of_tracks:
                self._scenes[index].set_track(tracks[tr_index])
            else:
                self._scenes[index].set_track(None)
            self._scenes[index].eval()
            self._scenes[index].set_value()
########NEW FILE########
__FILENAME__ = StateButton
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk1\StateButton.py
import Live
from _Framework.ButtonElement import *
from _Framework.InputControlElement import *
from MIDI_Map import *

class StateButton(ButtonElement):
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, is_momentary, msg_type, channel, identifier):
        ButtonElement.__init__(self, is_momentary, msg_type, channel, identifier)
        self._is_enabled = True
        self._is_notifying = False
        self._force_next_value = False

    def turn_off(self):
        self.send_value(0, True)

    def turn_on(self):
        self.send_value(127, True)

    def set_enabled(self, enabled):
        self._is_enabled = enabled

    def reset(self):
        self.send_value(0, True)

    def install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback):
        if self._is_enabled:
            ButtonElement.install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback)
        elif self._msg_channel != self._original_channel or self._msg_identifier != self._original_identifier:
            install_translation_callback(self._msg_type, self._original_identifier, self._original_channel, self._msg_identifier, self._msg_channel)


class ToggleButton(ButtonElement):
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, msg_type, channel, identifier):
        ButtonElement.__init__(self, True, msg_type, channel, identifier)
        self._is_enabled = True
        self._is_notifying = False
        self._force_next_value = False
        self._value = 0

    def turn_off(self):
        self._value = 0
        self.send_value(0, True)

    def turn_on(self):
        self._value = 1
        self.send_value(127, True)

    def set_enabled(self, enabled):
        self._is_enabled = enabled

    def reset(self):
        self.send_value(0, True)

    def receive_value(self, value):
        if value > 0:
            if self._value == 0:
                self._value = 1
                InputControlElement.receive_value(self, 127)
            else:
                self._value = 0
                InputControlElement.receive_value(self, 0)

    def install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback):
        if self._is_enabled:
            ButtonElement.install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback)
        elif self._msg_channel != self._original_channel or self._msg_identifier != self._original_identifier:
            install_translation_callback(self._msg_type, self._original_identifier, self._original_channel, self._msg_identifier, self._msg_channel)
########NEW FILE########
__FILENAME__ = VarButtonElement
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk1\VarButtonElement.py
import Live
from _Framework.ButtonElement import *
from _Framework.InputControlElement import *
from MIDI_Map import *
import time

class VarButtonElement(ButtonElement):
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, is_momentary, channel, scene_index, track_index, parent):
        ButtonElement.__init__(self, is_momentary, MIDI_NOTE_TYPE, channel, CLIPNOTEMAP[scene_index][track_index])
        self._is_enabled = True
        self._is_notifying = False
        self.surface = parent
        self._report_input = False
        self._scene_index = scene_index
        self._track_index = track_index

    def get_identifier(self):
        return self._msg_identifier

    def turn_off(self):
        self.send_value(0)

    def turn_on(self):
        self.send_value(127)

    def message_map_mode(self):
        raise self.message_type() is MIDI_CC_TYPE or AssertionError
        return Live.MidiMap.MapMode.absolute

    def set_enabled(self, enabled):
        self._is_enabled = enabled

    def set_send_note(self, note):
        if note in range(128):
            self._msg_identifier = note
            if not self._is_enabled:
                self.surface._translate_message(self._msg_type, self._original_identifier, self._original_channel, self._msg_identifier, self._msg_channel)

    def receive_value(self, value):
        if self._is_enabled:
            ButtonElement.receive_value(self, value)

    def send_value(self, value, force_send = False):
        raise value != None or AssertionError
        raise isinstance(value, int) or AssertionError
        raise value in range(128) or AssertionError
        ButtonElement.send_value(self, value, True)

    def set_to_notemode(self, notemode):
        self._is_enabled = not notemode
        if notemode:
            self.surface._translate_message(self._msg_type, self._original_identifier, self._original_channel, self._msg_identifier, self._msg_channel)

    def disconnect(self):
        ButtonElement.disconnect(self)
        self._is_enabled = None
        self._is_notifying = None
        self.surface = None
        self._report_input = None
        self._scene_index = None
        self._track_index = None


class TwinButton(ButtonElement):
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, is_momentary, channel, partner):
        raise isinstance(partner, VarButtonElement) or AssertionError
        ButtonElement.__init__(self, is_momentary, MIDI_NOTE_TYPE, channel, partner._original_identifier)
        self._partner = partner

    def fire(self, value):
        self._partner.send_value(value, True)


class ColorButton(ButtonElement):
    __module__ = __name__
    __doc__ = ' Special button class that dealwith Colors '

    def __init__(self, is_momentary, midi_type, identifier):
        ButtonElement.__init__(self, is_momentary, midi_type, 0, identifier)
        self.hue = 2
        self.sat = 127
        self.bright = 127
        self._msg_identifier = identifier

    def send_value(self, value, force_send = False):
        if not value != None:
            raise AssertionError
            raise isinstance(value, int) or AssertionError
            if not value in range(128):
                raise AssertionError
                (force_send or self._is_being_forwarded) and self.send_color(value)
                is_input = self._report_output and True
                self._report_value(value, not is_input)

    def send_hue(self, hue):
        data_byte1 = self._original_identifier
        self.hue = hue
        self.send_midi((MIDI_CC_STATUS + 0, data_byte1, hue))

    def send_bright(self, brightness):
        data_byte1 = self._original_identifier
        self.bright = brightness
        self.send_midi((MIDI_CC_STATUS + 0, data_byte1, brightness))

    def send_color(self, value):
        data_byte1 = self._original_identifier
        self.send_midi((MIDI_CC_STATUS + 2, data_byte1, self.bright))
        self.send_midi((MIDI_CC_STATUS + 1, data_byte1, self.sat))
        self.send_midi((MIDI_CC_STATUS + 0, data_byte1, self.hue))

    def disconnect(self):
        ButtonElement.disconnect(self)
########NEW FILE########
__FILENAME__ = ControlHandler
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk2\ControlHandler.py
import Live
import time
from _Framework.ButtonElement import *
from MIDI_Map import *
from SceneElement import SceneElement
N_PARM_RANGE = 127

class ControlHandler:
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, surface, matrix):
        self.surface = surface
        self.matrix = matrix
        self.mode = CONTROL_LEVEL
        self.sel_track_parm_index = 0
        self.track = None
        self.selected_sends_index = 0
        self.selected_device = None
        self.selected_bank = 0
        self.selected_device_parm_index = 0
        self.parm = None
        self.parm_is_quant = False
        self.parm_raster_value = 0
        self.parm_range = 0

    def get_color(self, ind):
        if self.mode == CONTROL_LEVEL:
            return PColor.MIX_SEL_VOLUME[ind]
        elif self.mode == CONTROL_PAN:
            return PColor.MIX_SEL_PANNING[ind]
        elif self.mode == CONTROL_SEND:
            return PColor.MIX_SEL_SEND[ind]
        elif self.mode == CONTROL_DEVICE:
            return PColor.MIX_SEL_DEVICE[ind]

    def get_mode_color(self, ind, mode):
        if mode == CONTROL_LEVEL:
            return PColor.MIX_MODE_VOLUME[ind]
        elif mode == CONTROL_PAN:
            return PColor.MIX_MODE_PANNING[ind]
        elif mode == CONTROL_SEND:
            return PColor.MIX_MODE_SEND[ind]
        elif mode == CONTROL_DEVICE:
            return PColor.MIX_MODE_DEVICE[ind]

    def nr_of_parms_in_bank(self):
        if self.selected_device == None:
            return 0
        nr_of_parms = len(self.selected_device.parameters)
        bip = nr_of_parms - 8 * self.selected_bank
        if bip < 8:
            return bip
        return 8

    def inc_bank_nr(self):
        if self.selected_device == None or self.selected_bank + 1 >= self.nr_of_banks():
            return False
        self.selected_bank += 1
        self.surface.show_message('Bank ' + str(self.selected_bank + 1) + ' : ' + str(self.selected_device.name))
        self.reassign_device_parm()
        parminfo = ''
        if self.parm != None:
            parminfo = str(self.parm.name)
        self.surface.show_message(str(self.selected_device.name) + 'Bank ' + str(self.selected_bank + 1) + ' : ' + parminfo)
        return True

    def dec_bank_nr(self):
        if self.selected_device == None or self.selected_bank == 0:
            return False
        self.selected_bank -= 1
        self.reassign_device_parm()
        parminfo = ''
        if self.parm != None:
            parminfo = str(self.parm.name)
        self.surface.show_message(str(self.selected_device.name) + 'Bank ' + str(self.selected_bank + 1) + ' : ' + parminfo)
        return True

    def nr_of_banks(self):
        if self.selected_device == None:
            return 0
        parms = len(self.selected_device.parameters)
        if parms == 0:
            return 0
        return parms / 8 + 1

    def index_parm_id(self, index):
        if index > 11:
            return index - 12
        else:
            return index - 4
        return 0

    def index_mode_id(self, index):
        if index > 4 and index < 8:
            return index - 4
        return 0

    def set_device(self, device):
        self.selected_device = device
        self.selected_bank = 0
        self.reassign_device_parm()

    def set_track(self, index):
        self.track = self.surface._mixer._channel_strips[index]._track

    def reassign_mix_parm(self):
        self.assign_mix_parm(self.track, self.sel_track_parm_index)

    def message_current_parm(self):
        if self.track == None:
            return
        message = 'Control Track : ' + str(self.track.name) + ': '
        if self.mode == CONTROL_LEVEL:
            self.surface.show_message(message + 'Volume')
        elif self.mode == CONTROL_PAN:
            self.surface.show_message(message + 'Pan')
        elif self.mode == CONTROL_SEND:
            self.surface.show_message(message + 'Send ' + SENDS[self.selected_sends_index])
        elif self.mode == CONTROL_DEVICE:
            return 'Device'

    def assign_mix_parm(self, track, index):
        prev = self.parm
        if track == None:
            self.parm = None
            return prev != self.parm
        self.track = track
        self.parm_is_quant = False
        if self.mode == CONTROL_LEVEL:
            self.parm = track.mixer_device.volume
        elif self.mode == CONTROL_PAN:
            self.parm = track.mixer_device.panning
        elif self.mode == CONTROL_SEND:
            nr_of_ret_tracks = len(track.mixer_device.sends)
            if self.selected_sends_index < nr_of_ret_tracks and self.selected_sends_index != -1:
                self.parm = track.mixer_device.sends[self.selected_sends_index]
        self.set_knob_int_value(self.parm)
        self.sel_track_parm_index = index
        return prev != self.parm

    def reassign_device_parm(self):
        self.assign_device_parm(self.selected_device_parm_index, False)

    def assign_device_parm(self, index, showmessage = True):
        prev = self.parm
        if self.mode != CONTROL_DEVICE or self.selected_device == None:
            self.parm = None
            return prev != self.parm
        parms = self.selected_device.parameters
        self.selected_device_parm_index = min(index, self.nr_of_parms_in_bank() - 1)
        parm = parms[self.selected_bank * 8 + self.selected_device_parm_index]
        if parm.is_quantized:
            self.parm_is_quant = True
        else:
            self.parm_is_quant = False
            self.set_knob_int_value(parm)
        if showmessage:
            self.surface.show_message('Device : ' + str(self.selected_device.name) + ' : ' + str(parm.name))
        self.parm = parm
        self.parm_range = parm.max - parm.min
        return prev != self.parm

    def set_knob_int_value(self, parm):
        parm_range = parm.max - parm.min
        self.parm_raster_value = int((parm.value - parm.min) / parm_range * N_PARM_RANGE + 0.1)

    def is_quantized(self, parm):
        self.set_knob_int_value(parm)
        return False

    def mod_value(self, delta, shift):
        if self.parm == None:
            return
        if self.mode == CONTROL_DEVICE:
            if self.parm_is_quant:
                self.parm.value = self.change_parm(self.parm, delta)
                if shift and self.parm_range > 30:
                    self.repeat(self.parm, delta)
            else:
                new_value = self.change_parm(self.parm, delta)
                self.parm.value = new_value
                if not self.is_equal(self.parm.value, new_value):
                    self.parm_is_quant = True
                if not self.parm_is_quant and shift:
                    self.repeat(self.parm, delta)
            self.surface.show_message(' ' + str(self.selected_device.name) + ' : ' + str(self.parm.name) + ' : ' + str(self.parm))
        else:
            self.parm.value = self.change_parm(self.parm, delta)
            if shift:
                self.repeat(self.parm, delta)

    def is_equal(self, val1, val2):
        if val1 == val2:
            return True
        if abs(val1 - val2) < 0.005:
            return True
        return False

    def repeat(self, parm, delta):
        count = 0
        while count < SHIFT_INC - 1:
            parm.value = self.change_parm(parm, delta)
            count += 1

    def change_parm(self, parm, delta):
        if self.parm_is_quant:
            parm_range = parm.max - parm.min + 1
            new_val = min(parm.max, max(parm.min, parm.value + delta))
            return float(new_val)
        else:
            parm_range = parm.max - parm.min
            self.parm_raster_value = min(N_PARM_RANGE, max(0, self.parm_raster_value + delta))
            return float(self.parm_raster_value) / float(N_PARM_RANGE) * parm_range + parm.min

    def disconnect(self):
        self.surface = None
        self.matrix = None
        self.track = None
        self.selected_device = None
        self.parm = None
########NEW FILE########
__FILENAME__ = MaschineDeviceComponent
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk2\MaschineDeviceComponent.py
import Live
from _Generic.Devices import *
from _Framework.DeviceComponent import DeviceComponent
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.EncoderElement import EncoderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.ChannelTranslationSelector import ChannelTranslationSelector
from MIDI_Map import *

class MaschineDeviceComponent(DeviceComponent):
    """ Class representing a device in Live """

    def __init__(self, surface):
        DeviceComponent.__init__(self)
        self.surface = surface
        self.device_listener = None
        self.device_parm_listener = None
        self._control_translation_selector = ChannelTranslationSelector(8)

    def set_device(self, device):
        DeviceComponent.set_device(self, device)
        if self.device_listener != None:
            self.device_listener(device)

    def set_parameter_controls(self, controls):
        DeviceComponent.set_parameter_controls(self, controls)
        self._control_translation_selector.set_controls_to_translate(controls)
        self._control_translation_selector.set_mode(self._bank_index)

    def _on_parameters_changed(self):
        DeviceComponent._on_parameters_changed(self)
        if self.device_parm_listener != None:
            self.device_parm_listener()

    def set_device_changed_listener(self, listener):
        self.device_listener = listener

    def set_device_parm_listener(self, listener):
        self.device_parm_listener = listener

    def show_message(self, message):
        self.surface.show_message(message)

    def disconnect(self):
        DeviceComponent.disconnect(self)
        self._control_translation_selector.disconnect()
        self.surface = None
        self.device_listener = None
        self.device_parm_listener = None
########NEW FILE########
__FILENAME__ = MaschineMk2
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk2\MaschineMk2.py
from __future__ import with_statement
import Live
import MidiRemoteScript
import time
from functools import partial
from _Framework.Task import Task
from _Framework.SubjectSlot import subject_slot
from PadScale import *
from MIDI_Map import *
from MaschineSessionComponent import MaschineSessionComponent
from MaschineDeviceComponent import MaschineDeviceComponent
from VarButtonElement import VarButtonElement
from VarButtonElement import GatedColorButton
from VarButtonElement import TwinButton
from ControlHandler import ControlHandler
from SceneMatrix import SceneMatrix
from Mk2KnobControl import Mk2KnobControl
from StateButton import StateButton, ToggleButton
from _Framework.ControlSurface import ControlSurface, _scheduled_method
from _Framework.InputControlElement import *
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement, ON_VALUE, OFF_VALUE
from _Framework.EncoderElement import EncoderElement
from _Framework.ButtonMatrixElement import ButtonMatrixElement
from _Framework.ChannelTranslationSelector import ChannelTranslationSelector
from _Framework.TransportComponent import TransportComponent
from _Framework.MixerComponent import MixerComponent
from _Framework.DeviceComponent import DeviceComponent

class MaschineMk2(ControlSurface):
    __module__ = __name__
    __doc__ = 'Control Script for Maschine Mk2 and Maschine Mikro Mk2'

    def __init__(self, c_instance):
        ControlSurface.__init__(self, c_instance, False)
        with self.component_guard():
            self._suppress_send_midi = True
            self.togglecolor = (10, 30, 50, 70, 90)
            self.toggleindex = 0
            self._c_ref = c_instance
            self._challenge = Live.Application.get_random_int(0, 400000000) & 2139062143
            self._c_inst = c_instance
            is_momentary = True
            self._active = True
            self._modifier_down = False
            self._return_mode = 0
            self._returntopad = False
            self._mode = CLIP_MODE
            self.init_slot = 0
            self.init_done = False
            self._midi_pause_count = 0
            self.nav_index = 0
            self._base_note = 0
            self._octave = 0.55
            self._scale_select_mode = MODE_PRESS_NONE
            self.send_slider_index = 0
            self._pad_mode = PM_OFF
            self._note_display_mode = ND_KEYBOARD1
            self._set_suppress_rebuild_requests(True)
            self._scenematrix = SceneMatrix(self)
            self._master_knob = Mk2KnobControl(self)
            self._device = self._set_up_device_control()
            self.show_message(str(''))
            self.request_rebuild_midi_map()
            self._set_global_buttons()
            self._set_mode_buttons()
            self._setup_transport()
            self._set_modecontrol()
            self._set_up_session()
            self._set_up_mixer()
            self._set_up_timer()
            self._set_up_machine_knobs()
            self.current_scale_index = 0
            self.assign_transpose(SCALES[self.current_scale_index])
            self.set_highlighting_session_component(self._session)
            self._navigate_button = StateButton(is_momentary, MIDI_CC_TYPE, 0, 127)
            self._navigate_button.add_value_listener(self._do_focus_navigate)
            self.display_update_button = ButtonElement(is_momentary, MIDI_CC_TYPE, 0, 86)
            self.display_update_button.add_value_listener(self._a_display_update)
            self._set_suppress_rebuild_requests(False)
            self.song().view.add_detail_clip_listener(self.clip_handle)
            self.song().add_visible_tracks_listener(self.clip_handle)
            self.song().add_scenes_listener(self.clip_handle)
            self.application().view.add_view_focus_changed_listener(self.focus_changed)
            self.log_message('########## LIVE 9 MASCHINE MK2 V 1.02 #############')
            self._suppress_send_midi = False

    def _set_up_mixer(self):
        is_momentary = True
        self._mixer = MixerComponent(8)
        self.send_sliders = []
        for track in range(8):
            self.send_sliders.append(SliderElement(MIDI_CC_TYPE, BASIC_CHANNEL, SEND_CC_OFF + track))

        for track in range(8):
            strip = self._mixer.channel_strip(track)
            strip.set_arm_button(StateButton(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, ARM_CC_OFF + track))
            strip.set_solo_button(StateButton(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, SOLO_CC_OFF + track))
            strip.set_mute_button(StateButton(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, MUTE_CC_OFF + track))
            strip.set_volume_control(SliderElement(MIDI_CC_TYPE, BASIC_CHANNEL, LEVEL_CC_OFF + track))
            strip.set_pan_control(SliderElement(MIDI_CC_TYPE, BASIC_CHANNEL, PAN_CC_OFF + track))
            strip.set_select_button(StateButton(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, SELECT_CC_OFF + track))
            st = tuple([self.send_sliders[track]])
            strip.set_send_controls(st)

        self.send_slider_toggle_button = StateButton(False, MIDI_CC_TYPE, 0, 90)
        self.send_slider_toggle_button.add_value_listener(self._do_toggle_send)
        self._session.set_mixer(self._mixer)

    def _set_global_buttons(self):
        is_momentary = True
        self._undo_button = StateButton(is_momentary, MIDI_CC_TYPE, 0, 85)
        self._undo_button.add_value_listener(self._do_undo)
        self._redo_button = StateButton(is_momentary, MIDI_CC_TYPE, 0, 87)
        self._redo_button.add_value_listener(self._do_redo)
        self._armsolomode_button = StateButton(is_momentary, MIDI_CC_TYPE, 0, 89)
        self._armsolomode_button.add_value_listener(self._do_armsolo_mode)
        self._fire_button = StateButton(is_momentary, MIDI_CC_TYPE, 0, 9)
        self._fire_button.add_value_listener(self._do_fire_button)
        self.track_left_button = StateButton(is_momentary, MIDI_CC_TYPE, 0, 120)
        self.track_right_button = StateButton(is_momentary, MIDI_CC_TYPE, 0, 121)
        self.track_left_button.add_value_listener(self._a_trk_left)
        self.track_right_button.add_value_listener(self._a_trk_right)
        self.test_button = StateButton(True, MIDI_CC_TYPE, 5, 60)
        self.note_repeat_button = StateButton(True, MIDI_CC_TYPE, 5, 61)
        self.test_button.add_value_listener(self.do_test)
        self.note_repeat_button.add_value_listener(self.do_note_repeat)
        self.reset_test_button = StateButton(True, MIDI_CC_TYPE, 5, 62)
        self.reset_test_button.add_value_listener(self.do_reset)

    def _set_mode_buttons(self):
        self.xfade_assign_button = StateButton(True, MIDI_CC_TYPE, 0, 116)
        self._pad_select_button = StateButton(False, MIDI_CC_TYPE, 0, 117)
        self._pad_solo_button = StateButton(False, MIDI_CC_TYPE, 0, 118)
        self._mute_button = StateButton(False, MIDI_CC_TYPE, 0, 119)
        self._pad_scale_up = GatedColorButton(True, MIDI_CC_TYPE, 83, 0)
        self._pad_scale_down = GatedColorButton(True, MIDI_CC_TYPE, 94, 16)
        self._pad_select_button.add_value_listener(self._do_pad_select_multi)
        self._mute_button.add_value_listener(self._do_mute_button)
        self._pad_solo_button.add_value_listener(self._do_pad_solo_multi)
        self.xfade_assign_button.add_value_listener(self._do_xfade_assign)
        self._pad_scale_up.add_value_listener(self._do_pad_note_up)
        self._pad_scale_down.add_value_listener(self._do_pad_note_down)

    def set_appointed_device(self, device):
        with self.component_guard():
            self._device_component.set_device(device)

    def _set_up_device_control(self):
        is_momentary = True
        device = MaschineDeviceComponent(self)
        device.set_device_changed_listener(self._handle_device_changed)
        device.set_device_parm_listener(self._hande_device_parm_changed)
        param_controls = []
        for index in range(8):
            param_controls.append(SliderElement(MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_CC_OFF + index))

        device.set_parameter_controls(tuple(param_controls))
        device.set_on_off_button(StateButton(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_BUTTON_CC_OFF))
        device.set_bank_nav_buttons(StateButton(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_BUTTON_CC_OFF + 4), ButtonElement(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_BUTTON_CC_OFF + 5))
        self._device_nav_button_left = StateButton(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_BUTTON_CC_OFF + 6)
        self._device_nav_button_right = StateButton(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, DEVICE_BUTTON_CC_OFF + 7)
        self._device_nav_button_left.add_value_listener(self._nav_value_left)
        self._device_nav_button_right.add_value_listener(self._nav_value_right)
        device.name = 'Device_Component'
        self.set_device_component(device)
        return device

    def _setup_transport(self):
        is_momentary = True
        transport = TransportComponent()
        playButton = StateButton(is_momentary, MIDI_CC_TYPE, 0, 108)
        stopButton = StateButton(not is_momentary, MIDI_CC_TYPE, 0, 110)
        recordButton = StateButton(is_momentary, MIDI_CC_TYPE, 0, 109)
        overdubButton = StateButton(is_momentary, MIDI_CC_TYPE, 0, 107)
        metrononmeButton = StateButton(is_momentary, MIDI_CC_TYPE, 0, 104)
        playButton.name = 'Play'
        stopButton.name = 'Stop'
        recordButton.name = 'Record'
        overdubButton.name = 'Overdub'
        metrononmeButton.name = 'Metronome'
        transport.set_play_button(playButton)
        transport.set_stop_button(stopButton)
        transport.set_record_button(recordButton)
        transport.set_overdub_button(overdubButton)
        transport.set_metronome_button(metrononmeButton)
        transport.set_nudge_buttons(StateButton(is_momentary, MIDI_CC_TYPE, 1, 51), StateButton(is_momentary, MIDI_CC_TYPE, 1, 50))
        punchinbutton = ToggleButton(MIDI_CC_TYPE, 1, 52)
        punchoutbutton = ToggleButton(MIDI_CC_TYPE, 1, 53)
        punchinbutton.name = 'Punch In'
        punchoutbutton.name = 'Punch Out'
        transport.set_punch_buttons(punchinbutton, punchoutbutton)
        transport.set_loop_button(StateButton(is_momentary, MIDI_CC_TYPE, 1, 54))
        self.transp_ff_button = ButtonElement(True, MIDI_CC_TYPE, 1, 59)
        self.transp_rw_button = ButtonElement(True, MIDI_CC_TYPE, 1, 58)
        transport.set_seek_buttons(self.transp_ff_button, self.transp_rw_button)
        self.xfadeKnob = SliderElement(MIDI_CC_TYPE, 1, 100)
        self.xfadeKnob.connect_to(self.song().master_track.mixer_device.crossfader)
        self.tap_button = StateButton(is_momentary, MIDI_CC_TYPE, 0, 88)
        self.tap_button.add_value_listener(self._do_tap_tempo)
        self.cue_add_delete_button = StateButton(is_momentary, MIDI_CC_TYPE, 1, 55)
        self.cue_prev_button = StateButton(is_momentary, MIDI_CC_TYPE, 1, 56)
        self.cue_next_button = StateButton(is_momentary, MIDI_CC_TYPE, 1, 57)
        self.cue_add_delete_button.add_value_listener(self._do_toggle_cue)
        self.cue_prev_button.add_value_listener(self._do_toggle_prev_cue)
        self.cue_next_button.add_value_listener(self._do_toggle_next_cue)

    def _set_up_machine_knobs(self):
        master_track = self.song().master_track
        self.master_volume = SliderElement(MIDI_CC_TYPE, 0, 40)
        self.prehear = SliderElement(MIDI_CC_TYPE, 0, 41)
        self.master_volume.connect_to(master_track.mixer_device.volume)
        self.prehear.connect_to(master_track.mixer_device.cue_volume)

    def _set_up_session(self):
        is_momentary = True
        self._session = MaschineSessionComponent()
        self._session.add_offset_listener(self.notify_track_scroll)
        nhue = COLOR_HUE_NAV
        self.nav_buttons = (GatedColorButton(True, MIDI_CC_TYPE, 92, nhue),
         GatedColorButton(True, MIDI_CC_TYPE, 81, nhue),
         GatedColorButton(True, MIDI_CC_TYPE, 93, nhue),
         GatedColorButton(True, MIDI_CC_TYPE, 91, nhue))
        self._session.set_scene_bank_buttons(self.nav_buttons[0], self.nav_buttons[1])
        self._session.set_track_bank_buttons(self.nav_buttons[2], self.nav_buttons[3])
        self._session.set_stop_all_clips_button(StateButton(is_momentary, MIDI_CC_TYPE, 0, 111))
        track_stop_buttons = [ StateButton(is_momentary, MIDI_CC_TYPE, BASIC_CHANNEL, index + STOP_CC_OFF) for index in range(4) ]
        self._session.set_stop_track_clip_buttons(tuple(track_stop_buttons))
        self._init_matrix()
        self._set_up_buttons()
        self._session._link()
        self._session.set_advance(STEP4)

    def _set_up_buttons(self):
        self._bmatrix = ButtonMatrixElement()
        for scene_index in range(4):
            button_row = []
            scene = self._session.scene(scene_index)
            for track_index in range(4):
                button = self._matrix[scene_index][track_index]
                clip_slot = scene.clip_slot(track_index)
                clip_slot.set_launch_button(button)
                clip_slot.set_triggered_to_play_value(1)
                clip_slot.set_triggered_to_record_value(1)
                clip_slot.set_started_value(1)
                clip_slot.set_recording_value(1)
                clip_slot.set_stopped_value(1)

            self._bmatrix.add_row(tuple(button_row))

    def _init_matrix(self):
        is_momentary = True
        self._button_sequence = []
        self._matrix = []
        for scene_index in range(4):
            button_row = []
            for track_index in range(4):
                button = VarButtonElement(is_momentary, 0, scene_index, track_index, self)
                partner = TwinButton(is_momentary, 1, button)
                partner.add_value_listener(self.ox, True)
                button_row.append(button)

            self._matrix.append(tuple(button_row))

        for scene_index in [3,
         2,
         1,
         0]:
            for track_index in range(4):
                self._button_sequence.append(self._matrix[scene_index][track_index])

        self._session.set_matrix(self._matrix)

    def set_pad_translations(self, pad_translations):
        ControlSurface.set_pad_translations(pad_translations)

    def refresh_state(self):
        ControlSurface.refresh_state(self)
        self._update_hardware()

    def ox(self, value, button):
        if not isinstance(button, TwinButton):
            raise AssertionError
            self._mode == PAD_MODE and button.fire(value)

    def _update_hardware(self):
        self._session.update()
        self._set_suppress_rebuild_requests(True)
        self._set_mode()
        self._master_knob.update()
        if self._scenematrix.soloexclusive:
            self._armsolomode_button.send_value(1, True)
        else:
            self._armsolomode_button.send_value(0, True)
        self._master_knob.start_up()
        self._pad_scale_up.activate()
        self._pad_scale_down.activate()
        self.current_scale_to_display()
        self.send_to_display(KEY_COLOR_MODES_STRINGS[self._note_display_mode], 1)
        for scene_index in range(4):
            scene = self._session.scene(scene_index)
            for track_index in range(4):
                button = self._matrix[scene_index][track_index]
                button.refresh()

        self._set_suppress_rebuild_requests(False)

    def get_color(self, value, track_index, scene_index):
        if not self._active:
            return
        if self._mode == SCENE_MODE or self._mode == CONTROL_MODE or self._pad_mode == PM_ON:
            element = self._scenematrix.get_element(scene_index, track_index)
            return element.get_color(value)
        elif self._mode == CLIP_MODE:
            scene = self._session.scene(scene_index)
            clip_slot = scene.clip_slot(track_index)._clip_slot
            cindex = 0
            if value == 0:
                cindex = 1
            if clip_slot != None:
                if clip_slot.has_clip:
                    if clip_slot.clip.is_recording or clip_slot.clip.will_record_on_start:
                        return PColor.CLIP_RECORD[cindex]
                    if clip_slot.clip.is_playing:
                        return PColor.CLIP_PLAY[cindex]
                    elif clip_slot.clip.is_triggered:
                        return PColor.CLIP_PLAY[cindex]
                    else:
                        return PColor.CLIP_STOPPED[cindex]
                elif clip_slot.will_record_on_start:
                    return PColor.CLIP_RECORD[cindex]
                elif clip_slot.is_playing:
                    return PColor.CLIP_GROUP_PLAY[cindex]
                elif clip_slot.controls_other_clips:
                    return PColor.CLIP_GROUP_CONTROL[cindex]
                elif clip_slot.is_triggered:
                    return PColor.CLIP_GROUP_TRIGGER[cindex]
        elif self._mode == PAD_MODE:
            button = self._matrix[scene_index][track_index]
            return self.get_color_by_note_mode(button.get_identifier(), value > 0)

    def step_key_color_mode(self):
        self._note_display_mode = (self._note_display_mode + 1) % len(KEY_COLOR_MODES_STRINGS)
        self.show_message('Pad Mode Key Color = ' + KEY_COLOR_MODES_STRINGS[self._note_display_mode])
        self.send_to_display('Colors: ' + KEY_COLOR_MODES_STRINGS[self._note_display_mode], 1)
        if self._mode == PAD_MODE:
            for note_index in range(16):
                button = self._button_sequence[note_index]
                button.send_color_direct(self.get_color_by_note_mode(button.get_identifier(), False))

    def get_color_by_note_mode(self, midi_note, on):
        if self._note_display_mode == ND_BASE_OTHER:
            interval = (midi_note + 12 - self._base_note) % 12
            if on:
                return INTERVAL_COLOR_MAP[interval][0]
            else:
                return INTERVAL_COLOR_MAP[interval][1]
        elif on:
            return KEY_COLOR_MAP[midi_note % 12][0]
        else:
            return KEY_COLOR_MAP[midi_note % 12][1]

    def _send_midi(self, midi_bytes, **keys):
        self._c_ref.send_midi(midi_bytes)
        if self._midi_pause_count == 2:
            time.sleep(0.002)
            self._midi_pause_count = 0
        else:
            self._midi_pause_count = self._midi_pause_count + 1
        return True

    def clip_handle(self):
        if self._mode == SCENE_MODE or self._mode == CONTROL_MODE or self._modifier_down:
            self._scenematrix.update()

    def _a_display_update(self, value):
        if not self.display_update_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            (value != 0 or not self.display_update_button.is_momentary()) and self._update_hardware()
            self.show_message('Maschine Display Updated')

    def _set_up_timer(self):
        self.blink_state = 1

    def update_display(self):
        with self.component_guard():
            with self._is_sending_scheduled_messages():
                self._task_group.update(0.1)
            if self._mode == CLIP_MODE and not self._modifier_down:
                if self.blink_state == 0:
                    self._session.notify(1, 0)
                elif self.blink_state == 1:
                    self._session.notify(1, 1)
                elif self.blink_state == 3:
                    self._session.notify(2, 0)
                elif self.blink_state == 4:
                    self._session.notify(2, 1)
            elif self._mode == PAD_MODE:
                pass
            elif self.blink_state == 0:
                self._scenematrix.notify_scene_mode(1)
            elif self.blink_state == 2:
                self._scenematrix.notify_scene_mode(0)
            self.blink_state = (self.blink_state + 1) % 4
            self.init_slot += 1

    def _invoke_track_edit(self, mode):
        self._deassign_matrix()
        self._scenematrix.assign()
        self._scenematrix.set_mode(mode)
        self._pad_mode = PM_ON
        self.request_rebuild_midi_map()
        self._scenematrix.update()

    def _set_modecontrol(self):
        is_momentary = True
        self.scene_mode_button = StateButton(is_momentary, MIDI_CC_TYPE, 0, 112)
        self.clip_mode_button = StateButton(is_momentary, MIDI_CC_TYPE, 0, 113)
        self.pad_mode_button = StateButton(is_momentary, MIDI_CC_TYPE, 0, 114)
        self.control_mode_button = StateButton(is_momentary, MIDI_CC_TYPE, 0, 115)
        self.xfade_assign_button = StateButton(is_momentary, MIDI_CC_TYPE, 0, 116)
        self.scene_mode_button.add_value_listener(self._a_mode_scene)
        self.clip_mode_button.add_value_listener(self._a_mode_clip)
        self.pad_mode_button.add_value_listener(self._a_mode_pad)
        self.control_mode_button.add_value_listener(self._a_mode_control)

    def _set_mode(self, mode = None):
        if mode == None:
            mode = self._mode
        if mode == SCENE_MODE:
            self.clip_mode_button.send_value(OFF_VALUE, True)
            self.pad_mode_button.send_value(OFF_VALUE, True)
            self.control_mode_button.send_value(OFF_VALUE, True)
            self.scene_mode_button.send_value(ON_VALUE, True)
        elif mode == CLIP_MODE:
            self.scene_mode_button.send_value(OFF_VALUE, True)
            self.pad_mode_button.send_value(OFF_VALUE, True)
            self.control_mode_button.send_value(OFF_VALUE, True)
            self.clip_mode_button.send_value(ON_VALUE, True)
        elif mode == PAD_MODE:
            self.scene_mode_button.send_value(OFF_VALUE, True)
            self.clip_mode_button.send_value(OFF_VALUE, True)
            self.control_mode_button.send_value(OFF_VALUE, True)
            self.pad_mode_button.send_value(ON_VALUE, True)
        elif mode == CONTROL_MODE:
            self.scene_mode_button.send_value(OFF_VALUE, True)
            self.clip_mode_button.send_value(OFF_VALUE, True)
            self.pad_mode_button.send_value(OFF_VALUE, True)
            self.control_mode_button.send_value(ON_VALUE, True)

    def _reset_matrix(self):
        for scene_index in range(4):
            scene = self._session.scene(scene_index)
            for track_index in range(4):
                button = self._matrix[scene_index][track_index]
                clip_slot = scene.clip_slot(track_index)
                clip_slot.set_launch_button(button)

    def update_button_matrix(self):
        self._session.update()
        for scene_index in range(4):
            scene = self._session.scene(scene_index)
            for track_index in range(4):
                button = self._matrix[scene_index][track_index]
                clip_slot = scene.clip_slot(track_index)
                if clip_slot._clip_slot != None and clip_slot._clip_slot.clip != None:
                    button.send_value(1, True)
                else:
                    button.send_value(0, True)

    def _deassign_matrix(self):
        for scene_index in range(4):
            scene = self._session.scene(scene_index)
            for track_index in range(4):
                clip_slot = scene.clip_slot(track_index)
                clip_slot.set_launch_button(None)

    def _from_pad_mode(self, matrix_mode):
        self._mode = SCENE_MODE
        self._register_buttons()
        self._scenematrix.assign()
        self._scenematrix.set_mode(matrix_mode)
        self._set_suppress_rebuild_requests(True)
        self.request_rebuild_midi_map()
        self._scenematrix.update()
        self._set_suppress_rebuild_requests(False)

    def _enter_pad_mode(self):
        self._set_mode(PAD_MODE)
        if self._mode == CLIP_MODE:
            self._deassign_matrix()
        elif self._mode == SCENE_MODE:
            self._scenematrix.deassign()
        elif self._mode == CONTROL_MODE:
            self._scenematrix.deassign()
            self._master_knob.exit_matrix_mode()
        self._mode = PAD_MODE
        self._set_suppress_rebuild_requests(True)
        for row in range(4):
            for column in range(4):
                button = self._matrix[row][column]
                button.send_value(0, True)
                button.set_to_notemode(True)
                self._forwarding_registry[MIDI_NOTE_ON_STATUS, button.get_identifier()] = button
                self._forwarding_registry[MIDI_NOTE_OFF_STATUS, button.get_identifier()] = button

        self._set_suppress_rebuild_requests(False)

    def _register_buttons(self, update = False):
        self._set_suppress_rebuild_requests(True)
        for row in range(4):
            for column in range(4):
                button = self._matrix[row][column]
                button.set_to_notemode(False)
                if update:
                    button.send_value(127, True)
                fwkey = [MIDI_NOTE_ON_STATUS]
                fwkey.append(button.get_identifier())
                self._forwarding_registry[tuple(fwkey)] = button
                self._forwarding_registry[MIDI_NOTE_OFF_STATUS, button.get_identifier()] = button

        self._set_suppress_rebuild_requests(False)

    def _back_to_clip_mode(self):
        self._pad_mode = PM_OFF
        self._scenematrix.set_mode(SCENE_MODE_NORMAL)
        self._scenematrix.deassign()
        self._set_up_clip_matrix()

    def _set_up_clip_matrix(self):
        for row in range(4):
            for column in range(4):
                button = self._matrix[row][column]
                button.set_to_notemode(False)

        self._set_suppress_rebuild_requests(True)
        self.request_rebuild_midi_map()
        self._reset_matrix()
        self.update_button_matrix()
        self._set_suppress_rebuild_requests(False)

    def _enter_scene_mode(self):
        self._set_mode(SCENE_MODE)
        if self._mode == CLIP_MODE:
            self._deassign_matrix()
        elif self._mode == CONTROL_MODE:
            self._master_knob.exit_matrix_mode()
        elif self._mode == PAD_MODE:
            self._register_buttons()
        self._mode = SCENE_MODE
        self._scenematrix.assign()
        self._scenematrix.set_mode(SCENE_MODE_NORMAL)
        self._return_mode = SCENE_MODE_NORMAL
        self.request_rebuild_midi_map()

    def _enter_clip_mode(self):
        self._set_suppress_rebuild_requests(True)
        self._set_mode(CLIP_MODE)
        if self._mode == SCENE_MODE:
            self._scenematrix.deassign()
        elif self._mode == CONTROL_MODE:
            self._master_knob.exit_matrix_mode()
        self._mode = CLIP_MODE
        self._set_up_clip_matrix()
        self.request_rebuild_midi_map()
        self._set_suppress_rebuild_requests(False)

    def _enter_control_mode(self):
        self._set_mode(CONTROL_MODE)
        if self._mode == CLIP_MODE:
            self._deassign_matrix()
        elif self._mode == PAD_MODE:
            self._mode = CONTROL_MODE
            self._register_buttons()
        self._mode = CONTROL_MODE
        self._set_suppress_rebuild_requests(True)
        self._scenematrix.set_mode(SCENE_MODE_CONTROL)
        self._return_mode = SCENE_MODE_CONTROL
        self._scenematrix.assign()
        self._master_knob.switch_to_matrix_mode()
        self._set_suppress_rebuild_requests(False)
        self.request_rebuild_midi_map()
        self._scenematrix.update()

    def _a_mode_scene(self, value):
        if not self.scene_mode_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.show_message('SCENE MODE')
            self._enter_scene_mode()

    def _a_mode_clip(self, value):
        if not self.clip_mode_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.show_message('CLIP MODE')
            self._enter_clip_mode()

    def _a_mode_pad(self, value):
        if not self.pad_mode_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.show_message('PAD MODE')
            self._enter_pad_mode()

    def _a_mode_control(self, value):
        if not self.control_mode_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.show_message('CONTROL MODE')
            self._enter_control_mode()

    def _do_pad_select_multi(self, value):
        if not value in range(128):
            raise AssertionError
            self._modifier_down = value != 0
            if self._mode == PAD_MODE or self._returntopad:
                value != 0 and self._from_pad_mode(SCENE_MODE_SELECT)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == CLIP_MODE:
            if value != 0:
                self._invoke_track_edit(SCENE_MODE_SELECT)
            else:
                self._back_to_clip_mode()
        elif self._mode != PAD_MODE:
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_SELECT)

    def _do_mute_button(self, value):
        if not self._mute_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                self._modifier_down = value != 0
                (self._mode == PAD_MODE or self._returntopad) and value != 0 and self._from_pad_mode(SCENE_MODE_MUTE)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == SCENE_MODE or self._mode == CONTROL_MODE:
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
                self._pad_mode = PM_OFF
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_MUTE)
                self._pad_mode = PM_ON
        elif self._mode == CLIP_MODE:
            if value > 0:
                self._invoke_track_edit(SCENE_MODE_MUTE)
            else:
                self._back_to_clip_mode()
                self._pad_mode = PM_OFF

    def _do_pad_solo_multi(self, value):
        if not value in range(128):
            raise AssertionError
            self._modifier_down = value != 0
            if self._mode == PAD_MODE or self._returntopad:
                value != 0 and self._from_pad_mode(SCENE_MODE_SOLO)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == CLIP_MODE:
            if value != 0:
                self._invoke_track_edit(SCENE_MODE_SOLO)
            else:
                self._back_to_clip_mode()
        elif self._mode != PAD_MODE:
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_SOLO)

    def _do_xfade_assign(self, value):
        if not self.xfade_assign_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                (self._mode == PAD_MODE or self._returntopad) and value != 0 and self._from_pad_mode(SCENE_MODE_XFADE)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == CLIP_MODE:
            if value != 0:
                self._invoke_track_edit(SCENE_MODE_XFADE)
            else:
                self._back_to_clip_mode()
        elif self._mode == SCENE_MODE or self._mode == CONTROL_MODE:
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_XFADE)

    def _do_pad_note_up(self, value):
        if not self._pad_scale_up != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                self._pad_scale_up.send_value(value, True)
                self._modifier_down = value != 0
                (self._mode == PAD_MODE or self._returntopad) and value != 0 and self._from_pad_mode(SCENE_MODE_ARM)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == CLIP_MODE:
            self.show_message('Arm tracks with pads')
            if value != 0:
                self._invoke_track_edit(SCENE_MODE_ARM)
            else:
                self._back_to_clip_mode()
        elif self._mode == SCENE_MODE or self._mode == CONTROL_MODE:
            self.show_message('Arm tracks with pads')
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_ARM)

    def _do_pad_note_down(self, value):
        if not self._pad_scale_down != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                self._pad_scale_down.send_value(value, True)
                self._modifier_down = value != 0
                (self._mode == PAD_MODE or self._returntopad) and value != 0 and self._from_pad_mode(SCENE_MODE_STOP)
                self._returntopad = True
            else:
                self._returntopad = False
                self._enter_pad_mode()
        elif self._mode == CLIP_MODE:
            self.show_message('Stop tracks with pads')
            if value != 0:
                self._invoke_track_edit(SCENE_MODE_STOP)
            else:
                self._back_to_clip_mode()
        elif self._mode == SCENE_MODE or self._mode == CONTROL_MODE:
            self.show_message('Stop tracks with pads')
            if value == 0:
                self._scenematrix.set_mode(self._return_mode)
            else:
                if self._scenematrix.in_main_mode():
                    self._return_mode = self._scenematrix.mode
                self._scenematrix.set_mode(SCENE_MODE_STOP)

    def modify_track_offset(self, delta):
        self._scenematrix.mod_track_offset(delta)

    def modify_scene_offset(self, delta):
        self._scenematrix.mod_scene_offset(delta)

    def move_view_horizontal(self, delta):
        if delta == 1:
            self._session.bank_right()
        else:
            self._session.bank_left()
        if self._mode == CONTROL_MODE:
            self._scenematrix.update()

    def inc_octave(self, inc):
        scale = SCALES[self.current_scale_index]
        octave = scale.to_octave(self._octave)
        newoctave = octave + inc
        if newoctave < 0:
            newoctave = 0
        elif newoctave > scale.octave_range:
            newoctave = scale.octave_range
        self._octave = scale.to_relative(newoctave, self._octave)
        scale = SCALES[self.current_scale_index]
        self.show_message(' OCTAVE ' + BASE_NOTE[self._base_note] + str(newoctave - 2) + ' to ' + scale.name)
        self.current_scale_to_display()

    def inc_base_note(self, inc):
        newbase = self._base_note + inc
        if newbase < 0:
            self._base_note = 0
        elif newbase > 11:
            self._base_note = 11
        else:
            self._base_note = newbase
        scale = SCALES[self.current_scale_index]
        self.show_message(' Base Note ' + BASE_NOTE[self._base_note] + ' to ' + scale.name)
        self.current_scale_to_display()

    def current_scale_to_display(self):
        scale = SCALES[self.current_scale_index]
        text = scale.name + ' ' + BASE_NOTE[self._base_note] + str(scale.to_octave(self._octave))
        self.send_to_display(text)

    def inc_scale(self, inc):
        nr_of_scales = len(SCALES)
        newindex = self.current_scale_index + inc
        if newindex < 0:
            newindex = 0
        elif newindex >= nr_of_scales:
            newindex = nr_of_scales - 1
        else:
            self.current_scale_index += inc
        newscale = SCALES[self.current_scale_index]
        self.show_message(' PAD Scale ' + newscale.name + ' ' + BASE_NOTE[self._base_note] + str(newscale.to_octave(self._octave) - 2))
        self.current_scale_to_display()

    def update_transpose(self):
        self.assign_transpose(SCALES[self.current_scale_index])
        self._set_suppress_rebuild_requests(True)
        self.request_rebuild_midi_map()
        self._set_suppress_rebuild_requests(False)

    def set_scale(self, scale):
        raise isinstance(scale, PadScale) or AssertionError
        scale_len = len(scale.notevalues)
        octave = scale.to_octave(self._octave)

    def assign_transpose(self, scale):
        raise isinstance(scale, PadScale) or AssertionError
        scale_len = len(scale.notevalues)
        octave = scale.to_octave(self._octave)
        last_note_val = None
        for note_index in range(16):
            button = self._button_sequence[note_index]
            scale_index = note_index % scale_len
            octave_offset = note_index / scale_len
            note_value = scale.notevalues[scale_index] + self._base_note + octave * 12 + octave_offset * 12
            if note_value < 128:
                last_note_val = note_value
            elif last_note_val != None:
                note_value = last_note_val
            button.set_send_note(note_value)
            if self._mode == PAD_MODE:
                button.send_color_direct(self.get_color_by_note_mode(note_value, False))

    def do_reset(self, value):
        if value == 0:
            return
        for row in range(4):
            for column in range(4):
                button = self._matrix[row][column]
                data_byte1 = button._original_identifier
                button.send_midi((MIDI_CC_STATUS + 2, data_byte1, 0))

    def do_test(self, value):
        color = self.togglecolor[self.toggleindex]
        self.toggleindex = (self.toggleindex + 1) % len(self.togglecolor)
        if value == 0:
            return
        for row in range(4):
            for column in range(4):
                button = self._matrix[row][column]
                self.schedule_message(1, self.dosend, (color,
                 127,
                 127,
                 row,
                 column))

    def dosend(self, parm = None):
        button = self._matrix[parm[3]][parm[4]]
        data_byte1 = button._original_identifier
        button.send_midi((MIDI_CC_STATUS + 0, data_byte1, parm[0]))
        button.send_midi((MIDI_CC_STATUS + 1, data_byte1, parm[1]))
        button.send_midi((MIDI_CC_STATUS + 2, data_byte1, parm[2]))

    def do_note_repeat(self, value):
        nrvalue = 0
        if value != 0:
            nrvalue = 1
        self._c_ref.set_note_repeat_state(nrvalue)

    def _do_toggle_send(self, value):
        nr_of_tracks = len(self.song().return_tracks)
        if value == 0 or nr_of_tracks < 1:
            return
        prev = self.send_slider_index
        self.send_slider_index += 1
        if self.send_slider_index >= nr_of_tracks:
            self.send_slider_index = 0
        self.show_message(' Set Send ' + str(SENDS[self.send_slider_index]))
        if prev != self.send_slider_index:
            for track in range(8):
                strip = self._mixer.channel_strip(track)
                slider_list = []
                for index in range(self.send_slider_index + 1):
                    if index < self.send_slider_index - 1:
                        slider_list.append(None)
                    else:
                        slider_list.append(self.send_sliders[track])
                    strip.set_send_controls(tuple(slider_list))

    def _do_armsolo_mode(self, value):
        if not self._armsolomode_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self._scenematrix.set_armsolo_exclusive(self._armsolomode_button)

    def _do_fire_button(self, value):
        if not self._fire_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                clip_slot = (value != 0 or not self._mute_button.is_momentary()) and self.song().view.highlighted_clip_slot
                clip_slot and clip_slot.fire()

    def _do_undo(self, value):
        if not self._undo_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                (value != 0 or not self._undo_button.is_momentary()) and self.song().can_undo == 1 and self.song().undo()
                self.show_message(str('UNDO'))

    def _do_redo(self, value):
        if not self._redo_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                (value != 0 or not self._redo_button.is_momentary()) and self.song().can_redo == 1 and self.song().redo()
                self.show_message(str('REDO'))

    def _a_trk_left(self, value):
        if not value in range(128):
            raise AssertionError
            if value != 0:
                direction = self.application().view.is_view_visible('Session') and Live.Application.Application.View.NavDirection.left
                self.application().view.scroll_view(direction, 'Session', True)

    def _a_trk_right(self, value):
        if not value in range(128):
            raise AssertionError
            if value != 0:
                direction = self.application().view.is_view_visible('Session') and Live.Application.Application.View.NavDirection.right
                self.application().view.scroll_view(direction, 'Session', True)

    def _nav_value_left(self, value):
        if not self._device_nav_button_left != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                modifier_pressed = True
                value > 0 and (not self.application().view.is_view_visible('Detail') or not self.application().view.is_view_visible('Detail/DeviceChain')) and self.application().view.show_view('Detail')
                self.application().view.show_view('Detail/DeviceChain')
            else:
                direction = Live.Application.Application.View.NavDirection.left
                self.application().view.scroll_view(direction, 'Detail/DeviceChain', not modifier_pressed)

    def _nav_value_right(self, value):
        if not self._device_nav_button_right != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                modifier_pressed = value > 0 and True
                (not self.application().view.is_view_visible('Detail') or not self.application().view.is_view_visible('Detail/DeviceChain')) and self.application().view.show_view('Detail')
                self.application().view.show_view('Detail/DeviceChain')
            else:
                direction = Live.Application.Application.View.NavDirection.right
                self.application().view.scroll_view(direction, 'Detail/DeviceChain', not modifier_pressed)

    def _do_tap_tempo(self, value):
        if not value in range(128):
            raise AssertionError
            value > 0 and self.song().tap_tempo()

    def _do_toggle_cue(self, value):
        if not value in range(128):
            raise AssertionError
            value > 0 and self.song().set_or_delete_cue()

    def _do_toggle_prev_cue(self, value):
        if not value in range(128):
            raise AssertionError
            value > 0 and self.song().jump_to_prev_cue()

    def _do_toggle_next_cue(self, value):
        if not value in range(128):
            raise AssertionError
            value > 0 and self.song().jump_to_next_cue()

    def focus_changed(self):
        pass

    def _handle_device_changed(self, device):
        pass

    def _hande_device_parm_changed(self):
        pass

    def _do_focus_navigate(self, value):
        if not self._navigate_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            self.nav_index = value != 0 and (self.nav_index + 1) % len(VIEWS_ALL)
            self.application().view.focus_view(VIEWS_ALL[self.nav_index])
            self.show_message('Focus on : ' + str(VIEWS_ALL[self.nav_index]))

    def scroll_focus(self, delta):
        if delta == 1:
            self.nav_index = (self.nav_index + 1) % len(VIEWS_ALL)
        elif self.nav_index == 0:
            self.nav_index = len(VIEWS_ALL) - 1
        else:
            self.nav_index -= 1
        self.show_message('Focus on : ' + str(VIEWS_ALL[self.nav_index]))
        self.application().view.focus_view(VIEWS_ALL[self.nav_index])

    def scroll_device(self, delta):
        if not (delta == 1 or delta == -1):
            raise AssertionError
            direction = delta == 1 and Live.Application.Application.View.NavDirection.right
        else:
            direction = Live.Application.Application.View.NavDirection.left
        self.application().view.scroll_view(direction, 'Detail/DeviceChain', True)

    def scroll_scene(self, delta):
        if not self.track_left_button != None:
            raise AssertionError
            raise delta == 1 or delta == -1 or AssertionError
            direction = delta == 1 and Live.Application.Application.View.NavDirection.down
        else:
            direction = Live.Application.Application.View.NavDirection.up
        self.application().view.scroll_view(direction, 'Session', True)

    def index_in_strip(self, track):
        for ind in range(len(self._mixer._channel_strips)):
            strack = self._mixer._channel_strips[ind]._track
            if strack == track:
                return ind

        return -1

    def notify_track_scroll(self):
        self._scenematrix.update_control_selection()
        if self._mode == CONTROL_MODE:
            self._scenematrix.eval_matrix()
            self._scenematrix.fire_values()

    def send_to_display(self, text, grid = 0):
        if USE_DISPLAY == False:
            return
        if len(text) > 28:
            text = text[:27]
        msgsysex = [240,
         0,
         0,
         102,
         23,
         18,
         min(grid, 3) * 28]
        filled = text.ljust(28)
        for c in filled:
            msgsysex.append(ord(c))

        msgsysex.append(247)
        self._send_midi(tuple(msgsysex))

    def send_color(self, button, hue, sat, bright):
        raise isinstance(button, ButtonElement) or AssertionError
        raise hue in range(128) or AssertionError
        raise sat in range(128) or AssertionError
        raise bright in range(128) or AssertionError
        data_byte1 = button._original_identifier
        button.send_midi((MIDI_CC_STATUS + 2, data_byte1, bright))
        button.send_midi((MIDI_CC_STATUS + 1, data_byte1, sat))
        button.send_midi((MIDI_CC_STATUS + 0, data_byte1, hue))

    def turn_off_matrix(self):
        for row in range(4):
            for column in range(4):
                button = self._matrix[row][column]
                self.send_color(button, 2, 0, 0)
                button.set_to_notemode(False)

    def remove_listener(self, control, callback):
        if control != None and control.value_has_listener(callback):
            control.remove_value_listener(callback)
        control.disconnect()

    def disconnect(self):
        self.turn_off_matrix()
        self.scene_mode_button.send_value(0, True)
        self.clip_mode_button.send_value(0, True)
        self.pad_mode_button.send_value(0, True)
        self.control_mode_button.send_value(0, True)
        time.sleep(0.2)
        self._active = False
        self._suppress_send_midi = True
        self.remove_listener(self.scene_mode_button, self._a_mode_scene)
        self.remove_listener(self.clip_mode_button, self._a_mode_clip)
        self.remove_listener(self.pad_mode_button, self._a_mode_pad)
        self.remove_listener(self.control_mode_button, self._a_mode_control)
        self.remove_listener(self._undo_button, self._do_undo)
        self.remove_listener(self._redo_button, self._do_redo)
        self.remove_listener(self._armsolomode_button, self._do_armsolo_mode)
        self.remove_listener(self.xfade_assign_button, self._do_xfade_assign)
        self.remove_listener(self._fire_button, self._do_fire_button)
        self._session.remove_offset_listener(self.notify_track_scroll)
        self._mixer.disconnect()
        ControlSurface.disconnect(self)
########NEW FILE########
__FILENAME__ = MaschineSessionComponent
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk2\MaschineSessionComponent.py
from MIDI_Map import *
from _Framework.InputControlElement import *
from _Framework.ButtonElement import *
from _Framework.SessionComponent import *

class MaschineSessionComponent(SessionComponent):
    __module__ = __name__
    __doc__ = 'Controller Map for Soft Step Foot Controller'

    def __init__(self):
        SessionComponent.__init__(self, 4, 4)
        self._matrix = None
        self._advance = STEP4
        self._mode_button = None
        self._set_mode_button(ButtonElement(False, MIDI_CC_TYPE, 0, 80))
        self.set_track_banking_increment(STEP4)

    def start_up(self):
        self.set_enabled(True)

    def _link(self):
        pass

    def get_track_offset(self):
        return self._track_offset

    def get_scene_offset(self):
        return self._scene_offset

    def set_matrix(self, matrix):
        self._matrix = matrix

    def _set_mode_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._mode_button != None:
                self._mode_button.remove_value_listener(self._do_matrix_adv_mode)
            self._mode_button = button
            if self._mode_button != None:
                self._mode_button.add_value_listener(self._do_matrix_adv_mode)
            self._advance == STEP4 and self._mode_button.send_value(127, True)
        else:
            self._mode_button.send_value(0, True)

    def _do_matrix_adv_mode(self, value):
        if not self._mode_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                self._advance = value != 0 and self._advance == STEP1 and STEP4
                self._mode_button.send_value(127, True)
                self.set_track_banking_increment(STEP4)
            else:
                self._advance = STEP1
                self._mode_button.send_value(0, True)
                self.set_track_banking_increment(STEP1)

    def set_advance(self, val):
        self._advance = val
        if self._advance == STEP4:
            self._mode_button.send_value(127)
        else:
            self._mode_button.send_value(0)

    def update(self):
        SessionComponent.update(self)
        try:
            self._advance
        except AttributeError:
            pass
        else:
            if self._advance == STEP4:
                self._mode_button.send_value(127, True)
            else:
                self._mode_button.send_value(0, True)

    def notify(self, blink_type, blinking_state):
        for scene_index in range(4):
            scene = self.scene(scene_index)
            for track_index in range(4):
                clip_slot = scene.clip_slot(track_index)._clip_slot
                if clip_slot != None:
                    button = self._matrix[scene_index][track_index]
                    if button != None and clip_slot.has_clip:
                        if blink_type == 1 and clip_slot.clip.is_triggered:
                            button.send_value_bright(blinking_state)
                        if blink_type == 2 and clip_slot.clip.is_triggered:
                            button.send_value_bright(blinking_state)
                    elif clip_slot.is_triggered:
                        if blink_type == 1 or blink_type == 2:
                            button.send_value_bright(blinking_state)

    def bank_down(self):
        if self.is_enabled():
            newoff = max(0, self._scene_offset - 1)
            self.set_offsets(self._track_offset, newoff)

    def bank_up(self):
        if self.is_enabled():
            self.set_offsets(self._track_offset, self._scene_offset + 1)

    def bank_left(self):
        if self.is_enabled():
            self.set_offsets(max(0, self._track_offset - 1), self._scene_offset)

    def bank_right(self):
        if self.is_enabled():
            self.set_offsets(self._track_offset + 1, self._scene_offset)

    def disconnect(self):
        self._matrix = None
        self._mode_button = None
        SessionComponent.disconnect(self)
########NEW FILE########
__FILENAME__ = MIDI_Map
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk2\MIDI_Map.py
from PadScale import PadScale
msg_sender = None

def register_sender(sender):
    global msg_sender
    msg_sender = sender


def debug_out(message):
    msg_sender.log_message(message)


USE_DISPLAY = False
PM_OFF = 0
PM_ON = 1
SCENE_MODE = 1
CLIP_MODE = 2
PAD_MODE = 3
CONTROL_MODE = 4
STEP1 = 1
STEP4 = 4
MODE_PRESS_NONE = 0
MODE_PRESS_SELECT = 1
MODE_PRESS_SOLO = 2
SCENE_MODE_NORMAL = 0
SCENE_MODE_MUTE = 1
SCENE_MODE_SELECT = 2
SCENE_MODE_SOLO = 3
SCENE_MODE_ARM = 4
SCENE_MODE_STOP = 5
SCENE_MODE_CONTROL = 6
SCENE_MODE_XFADE = 7
BASIC_CHANNEL = 3
DEVICE_CC_OFF = 40
DEVICE_BUTTON_CC_OFF = 100
LEVEL_CC_OFF = 10
PAN_CC_OFF = 20
SEND_CC_OFF = 30
STOP_CC_OFF = 50
MUTE_CC_OFF = 80
SOLO_CC_OFF = 90
ARM_CC_OFF = 60
SELECT_CC_OFF = 70
CONTROL_LEVEL = 0
CONTROL_PAN = 1
CONTROL_SEND = 2
CONTROL_DEVICE = 3
SHIFT_INC = 4
INIT_SLOT = 10
CLICK_TIME = 500
ND_BASE_OTHER = 0
ND_KEYBOARD1 = 1
ND_INTERVAL = 2
SENDS = ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P')
BASE_NOTE = ('C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B')
VIEWS_ALL = ('Session', 'Detail/Clip', 'Detail/DeviceChain', 'Browser', 'Arranger')
VIEWS = ('Browser', 'Detail/Clip', 'Detail/DeviceChain', 'Session')
CLIPNOTEMAP = ((24, 25, 26, 27),
 (20, 21, 22, 23),
 (16, 17, 18, 19),
 (12, 13, 14, 15))
SCALES = (PadScale('Chromatic', (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)),
 PadScale('Ionian/Major', (0, 2, 4, 5, 7, 9, 11)),
 PadScale('Aeolian/Minor', (0, 2, 3, 5, 7, 8, 10)),
 PadScale('Pentatonic', (0, 2, 4, 7, 9)),
 PadScale('Pentatonic Minor', (0, 3, 5, 7, 10)),
 PadScale('Dorian (B/g)', (0, 2, 3, 5, 7, 9, 10)),
 PadScale('Phrygian (A-flat/f)', (0, 1, 3, 5, 7, 8, 10)),
 PadScale('Lydian (D/e)', (0, 2, 4, 6, 7, 9, 11)),
 PadScale('Mixolydian (F/d)', (0, 2, 4, 5, 7, 9, 10)),
 PadScale('Locrian (D-flat/b-flat)', (0, 1, 3, 5, 6, 8, 10)),
 PadScale('Diminish', (0, 2, 3, 5, 6, 8, 9, 10, 11)),
 PadScale('Major Blues', (0, 3, 4, 7, 9, 10)),
 PadScale('Minor Blues', (0, 3, 4, 6, 7, 10)),
 PadScale('Whole', (0, 2, 4, 6, 8, 10)),
 PadScale('Arabian', (0, 2, 4, 5, 6, 8, 10)),
 PadScale('Egyptian', (0, 2, 5, 7, 10)),
 PadScale('Gypsi', (0, 2, 3, 6, 7, 8, 11)),
 PadScale('Spanish Scale', (0, 1, 3, 4, 5, 7, 8, 10)),
 PadScale('Raga Bhairav', (0, 1, 4, 5, 7, 8, 11)),
 PadScale('Raga Gamanasrama', (0, 1, 4, 6, 7, 9, 11)),
 PadScale('Rag Todi', (0, 1, 3, 6, 7, 8, 11)),
 PadScale('3rd (C,E,G#)', (0, 4, 8)),
 PadScale('4th (C,F,A#)', (0, 5, 10)),
 PadScale('5th', (0, 7)),
 PadScale('Octave', tuple([0])))
PADCHANNEL = 0
DRUM_PADS = (-1, 12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3)
KEY_COLOR_MODES_STRINGS = ('Intervals', 'Individual Colors')
COLOR_HUE_NAV = 84
COLOR_BRIGHTNESS_OFF = 30
KEY_COLOR_MAP = {0: ((0, 127, 127), (0, 127, 50)),
 1: ((0, 100, 115), (0, 100, 30)),
 2: ((8, 127, 127), (8, 127, 50)),
 3: ((8, 127, 115), (8, 100, 30)),
 4: ((20, 127, 127), (20, 127, 50)),
 5: ((40, 127, 127), (40, 127, 30)),
 6: ((48, 100, 115), (48, 100, 30)),
 7: ((60, 127, 127), (60, 127, 50)),
 8: ((75, 90, 115), (75, 90, 50)),
 9: ((86, 127, 127), (86, 127, 50)),
 10: ((100, 10, 115), (100, 10, 30)),
 11: ((115, 127, 127), (115, 127, 50))}
INTERVAL_COLOR_MAP = {0: ((0, 127, 127), (0, 127, 30)),
 1: ((0, 40, 100), (0, 40, 30)),
 2: ((8, 127, 127), (8, 127, 30)),
 3: ((16, 127, 127), (16, 127, 30)),
 4: ((40, 127, 127), (40, 127, 30)),
 5: ((30, 127, 127), (30, 127, 30)),
 6: ((60, 127, 127), (60, 127, 30)),
 7: ((120, 127, 127), (120, 127, 30)),
 8: ((60, 60, 127), (60, 60, 30)),
 9: ((85, 127, 127), (85, 127, 30)),
 10: ((75, 127, 127), (75, 127, 30)),
 11: ((100, 127, 127), (100, 127, 30))}

def enum(**enums):
    return type('Enum', (), enums)


PColor = enum(CLIP_PLAY=((36, 127, 127), (36, 100, 30)), CLIP_STOPPED=((14, 127, 127), (14, 100, 30)), CLIP_RECORD=((0, 127, 127), (0, 127, 30)), CLIP_GROUP_PLAY=((43, 127, 110), (43, 127, 10)), CLIP_GROUP_CONTROL=((6, 127, 110), (6, 127, 10)), CLIP_GROUP_TRIGGER=((36, 127, 110), (36, 127, 10)), XFADE_A=((10, 127, 127), (10, 127, 127)), XFADE_BOTH=((65, 127, 5), (65, 127, 5)), XFADE_B=((4, 127, 127), (4, 127, 127)), STOP_G_PLAY=((96, 127, 127), (96, 127, 20)), STOP_G_NO_PLAY=((9, 127, 127), (9, 127, 20)), STOP_PLAY=((80, 127, 127), (80, 127, 20)), STOP_NO_PLAY=((14, 127, 127), (14, 127, 20)), STOP_NO_CLIPS=((16, 100, 40), (16, 100, 20)), ARM_MIDI=((0, 127, 127), (0, 127, 20)), ARM_AUDIO=((125, 127, 127), (125, 127, 20)), ARM_OTHER=((2, 127, 127), (0, 127, 20)), ARM_NO_ARM=((2, 80, 30), (2, 80, 30)), MUTE_TRACK=((22, 127, 127), (22, 127, 20)), SOLO_TRACK=((85, 127, 127), (85, 127, 25)), SELECT=((64, 127, 127), (64, 127, 10)), DEVICE_ON_OFF=((97, 80, 120), (97, 80, 50)), DEVICE_LEFT=((3, 127, 127), (3, 127, 110)), DEVICE_RIGHT=((5, 127, 127), (5, 127, 110)), BANK_LEFT=((90, 127, 127), (90, 127, 20)), BANK_RIGHT=((90, 127, 127), (90, 127, 20)), MIX_SELECT_SEND=((21, 127, 127), (21, 127, 20)), SCENE_PLAYING=((36, 127, 127), (36, 100, 25)), SCENE_HASCLIPS=((27, 127, 127), (27, 127, 25)), SCENE_NO_CLIPS=((65, 127, 127), (65, 127, 8)), MIX_SEL_VOLUME=((45, 127, 127), (45, 127, 20)), MIX_SEL_PANNING=((3, 127, 127), (3, 127, 20)), MIX_SEL_SEND=((70, 127, 127), (70, 127, 20)), MIX_SEL_DEVICE=((110, 127, 127), (110, 100, 20)), MIX_MODE_VOLUME=((32, 127, 127), (32, 127, 8)), MIX_MODE_PANNING=((0, 127, 127), (0, 127, 8)), MIX_MODE_SEND=((60, 127, 127), (60, 127, 8)), MIX_MODE_DEVICE=((95, 127, 127), (95, 100, 8)))

def device_get_color(mode, ind):
    if mode == CONTROL_LEVEL:
        return PColor.MIX_SEL_VOLUME[ind]
    elif mode == CONTROL_PAN:
        return PColor.MIX_SEL_PANNING[ind]
    elif mode == CONTROL_SEND:
        return PColor.MIX_SEL_SEND[ind]
    elif mode == CONTROL_DEVICE:
        return PColor.MIX_SEL_DEVICE[ind]


def device_get_mode_color(mode, ind):
    if mode == CONTROL_LEVEL:
        return PColor.MIX_MODE_VOLUME[ind]
    elif mode == CONTROL_PAN:
        return PColor.MIX_MODE_PANNING[ind]
    elif mode == CONTROL_SEND:
        return PColor.MIX_MODE_SEND[ind]
    elif mode == CONTROL_DEVICE:
        return PColor.MIX_MODE_DEVICE[ind]
########NEW FILE########
__FILENAME__ = Mk2KnobControl
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk2\Mk2KnobControl.py
import Live
import time
from MIDI_Map import *
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import *
from VarButtonElement import ColorButton
from StateButton import StateButton
KN2_MODE_VOLUME = 1
KN2_MODE_CUE = 2
KN2_MODE_QUANT = 3
KN2_MODE_TEMPO_COARSE = 4
KN2_MODE_TEMPO_FINE = 5
KN2_MODE_CLIP_QUANT = 6
KN2_MODE_CLIPN_HOR = 7
KN2_MODE_CLIPN_VER = 8
KN2_MODE_XFADE = 9
KN2_MODE_GENERAL = 10
KN2_P_SCALES = 11
LEFT_DOWN = 1
RIGHT_DOWN = 2
PARM_RANGE = 127
QUANT_DESCR = (' No Rec Quantize', ' 1/4 Rec Quantize', ' 1/8 Rec Quantize', ' 1/8 Rec Triplet Quantize', '1/8 & 1/8 Triplet Quantize', ' 1/16 Rec Quantize', ' 1/16 Triplet Rec Quantize', ' 1/16 & 1/16 Triplet Rec Quantize', '1/32 Rec Quantize')
QUANT_CONST = (Live.Song.RecordingQuantization.rec_q_no_q,
 Live.Song.RecordingQuantization.rec_q_quarter,
 Live.Song.RecordingQuantization.rec_q_eight,
 Live.Song.RecordingQuantization.rec_q_eight_triplet,
 Live.Song.RecordingQuantization.rec_q_eight_eight_triplet,
 Live.Song.RecordingQuantization.rec_q_sixtenth,
 Live.Song.RecordingQuantization.rec_q_sixtenth_triplet,
 Live.Song.RecordingQuantization.rec_q_sixtenth_sixtenth_triplet,
 8)
CLIQ_DESCR = ('None', '8 Bars', '4 Bars', '2 Bars', '1 Bar', '1/2', '1/2T', '1/4', '1/4T', '1/8', '1/8T', '1/16', '1/16T', '1/32')
LR_CONTROL_CLIP = 0
LR_CONTROL_SEL = 1
LR_CONTROL_DEV = 2
LR_CONTROL_LOOP = 3
LR_MODE_HUES = (6, 14, 39, 90)
L_MODE_FUNCTION = ('Clip Horizontal', 'Track Selection', 'Track Selection', 'Loop Start')
R_MODE_FUNCTION = ('Clip Vertical', 'Scene Selection', 'Device Selection', 'Loop Length')
LOOP_KNOB_DIVISION = (4.0, 1.0, 0.5)
PAD_KNOB_OCTAVE = 1
PAD_KNOB_SCALE = 2
PAD_KNOB_BASEN = 4

class Mk2KnobControl:
    __module__ = __name__
    __doc__ = 'Mk2 Module for Controlling Parameters with Master Knob'

    def __init__(self, parent):
        self._parent = parent
        self.master_track = parent.song().master_track
        self.volume_button = None
        self._set_volume_button(StateButton(True, MIDI_CC_TYPE, 3, 110))
        self.the_slider = SliderElement(MIDI_CC_TYPE, 1, 86)
        self.the_slider.add_value_listener(self._do_main_slider, True)
        self.xfade_button = None
        self._set_xfade_button(StateButton(True, MIDI_CC_TYPE, 3, 116))
        self.swing_button = None
        self._set_swing_button(StateButton(True, MIDI_CC_TYPE, 3, 111))
        self.mode = KN2_MODE_VOLUME
        self.previous_mode = -1
        self.tempo_button = None
        self._set_tempo_button(StateButton(True, MIDI_CC_TYPE, 3, 112))
        self.push_button = None
        self._set_push_button(StateButton(True, MIDI_CC_TYPE, 1, 87))
        self.clipn_v_button = None
        self.clipn_h_button = None
        self._set_clipn_h_button(StateButton(True, MIDI_CC_TYPE, 3, 114))
        self._set_clipn_v_button(StateButton(True, MIDI_CC_TYPE, 3, 115))
        self.toggle_buttons = [self.volume_button,
         self.xfade_button,
         self.swing_button,
         self.tempo_button,
         self.clipn_h_button,
         self.clipn_v_button]
        self.shift_button = None
        self._set_shift_button(StateButton(True, MIDI_CC_TYPE, 3, 113))
        self.shift_on = False
        self.scroll_mod_left_button = None
        self.scroll_mod_right_button = None
        self._set_scroll_mod_left_button(StateButton(True, MIDI_CC_TYPE, 0, 105))
        self._set_scroll_mod_right_button(StateButton(True, MIDI_CC_TYPE, 0, 106))
        self._prev_mode = KN2_MODE_VOLUME
        self.lrmode = LR_CONTROL_CLIP
        self._challenge = Live.Application.get_random_int(0, 400000000) & 2139062143
        self.loop_div_index = 0
        self.loop_incdex = 4.0
        self.arrow_mode_button = ColorButton(True, MIDI_CC_TYPE, 30)
        self.arrow_mode_button.add_value_listener(self.toggle_arrow_mode)
        self.arrow_mode_button.send_color(LR_MODE_HUES[self.lrmode])
        self.arrow_mode_button.send_value(127, True)
        self.navflags = 0
        self.octave_mod_button = StateButton(True, MIDI_CC_TYPE, 1, 70)
        self.octave_mod_button.add_value_listener(self._action_octave)
        self.scale_mod_button = StateButton(True, MIDI_CC_TYPE, 1, 71)
        self.scale_mod_button.add_value_listener(self._action_scale)
        self.basenote_mod_button = StateButton(True, MIDI_CC_TYPE, 1, 72)
        self.basenote_mod_button.add_value_listener(self._action_base_note)
        self.keycolor_mod_button = StateButton(True, MIDI_CC_TYPE, 1, 73)
        self.keycolor_mod_button.add_value_listener(self._action_key_color)
        self.pad_to_mainknob_mode = 0
        self._measure_left_click = 0
        self._measure_right_click = 0
        self.mode_assign_map = {KN2_MODE_VOLUME: (self.chg_volume,
                           0,
                           'Master Knob controls MASTER Volume',
                           KN2_MODE_CUE),
         KN2_MODE_CUE: (self.chg_cue,
                        0,
                        'Master Knob controls Cue Level',
                        KN2_MODE_VOLUME),
         KN2_MODE_TEMPO_COARSE: (self.chg_tempo,
                                 3,
                                 'Master Knob controls TEMPO Coarse',
                                 KN2_MODE_TEMPO_FINE),
         KN2_MODE_TEMPO_FINE: (self.chg_tempo_fine,
                               3,
                               'Master Knob controls TEMPO Fine',
                               KN2_MODE_TEMPO_COARSE),
         KN2_MODE_XFADE: (self.chg_xfade,
                          1,
                          'Master Knob controls Crossfader',
                          -1),
         KN2_MODE_QUANT: (self.chg_quant,
                          2,
                          'Master Knob controls Recording Quantize',
                          KN2_MODE_CLIP_QUANT),
         KN2_MODE_CLIP_QUANT: (self.chg_clip_q,
                               2,
                               'Master Knob controls Clip Start Quantize',
                               KN2_MODE_QUANT),
         KN2_MODE_CLIPN_HOR: (self.nav_c_hor,
                              4,
                              'Master Knob Clip View horizontally',
                              -1),
         KN2_MODE_CLIPN_VER: (self.nav_c_ver,
                              5,
                              'Master Knob Clip View vertically',
                              -1),
         KN2_MODE_GENERAL: (self.chg_general,
                            -1,
                            None,
                            -1),
         KN2_P_SCALES: (self.modify_pad_scaling,
                        -1,
                        None,
                        -1)}

    def start_up(self):
        self._set_mode(KN2_MODE_VOLUME)
        self.arrow_mode_button.send_value(127, True)

    def toggle_arrow_mode(self, value):
        if value > 0:
            self.lrmode = (self.lrmode + 1) % 4
            self.arrow_mode_button.send_hue(LR_MODE_HUES[self.lrmode])
            self._parent.show_message('Left/Right Buttons Control:    ' + L_MODE_FUNCTION[self.lrmode] + ' / ' + R_MODE_FUNCTION[self.lrmode])

    def switch_to_matrix_mode(self):
        if self.mode != KN2_MODE_GENERAL:
            self.previous_mode = self.mode
            self._set_mode(KN2_MODE_GENERAL)

    def exit_matrix_mode(self):
        if self.mode == KN2_MODE_GENERAL:
            self._set_mode(self.previous_mode)
            self.previous_mode = -1

    def update_shift(self):
        if self.shift_on:
            self.shift_button.send_value(127, True)
        else:
            self.shift_button.send_value(0, True)

    def _set_mode(self, mode):
        if not mode in range(11):
            raise AssertionError
            self.update_shift()
            if mode == self.mode:
                return
            self._prev_mode = mode
            self.mode = mode
            self.switch_radio_buttons(self.mode_assign_map[self.mode][1])
            message = self.mode_assign_map[self.mode][2]
            message != None and self._parent.show_message(message)

    def switch_radio_buttons(self, which):
        for index in range(len(self.toggle_buttons)):
            if index == which:
                self.toggle_buttons[index].send_value(127, True)
            else:
                self.toggle_buttons[index].send_value(0, True)

    def update(self):
        self.switch_radio_buttons(self.mode_assign_map[self.mode][1])
        self.arrow_mode_button.send_color(LR_MODE_HUES[self.lrmode])
        self.arrow_mode_button.send_value(127, True)

    def _do_main_slider(self, value, encoder):
        if not value in range(128):
            raise AssertionError
            if not isinstance(encoder, EncoderElement):
                raise AssertionError
                if value == 1:
                    delta = 1
                else:
                    delta = -1
                if self.pad_to_mainknob_mode != 0:
                    self.mode_assign_map[KN2_P_SCALES][0](delta)
                elif self.navflags == 0:
                    self.mode_assign_map[self.mode][0](delta)
                if self.lrmode == LR_CONTROL_CLIP:
                    self.navflags & LEFT_DOWN != 0 and self.nav_c_hor(delta)
                self.navflags & RIGHT_DOWN != 0 and self.nav_c_ver(delta)
        elif self.lrmode == LR_CONTROL_SEL:
            if self.navflags & LEFT_DOWN != 0:
                self.nav_track(delta)
            if self.navflags & RIGHT_DOWN != 0:
                self._parent.scroll_scene(delta)
        elif self.lrmode == LR_CONTROL_DEV:
            if self.navflags & LEFT_DOWN != 0:
                self.nav_track(delta)
            if self.navflags & RIGHT_DOWN != 0:
                self._parent.scroll_device(delta)
        elif self.lrmode == LR_CONTROL_LOOP:
            if self.navflags & LEFT_DOWN != 0:
                self.adjust_loop_start(delta)
            if self.navflags & RIGHT_DOWN != 0:
                self.adjust_loop_length(delta)

    def modify_pad_scaling(self, delta):
        if self.pad_to_mainknob_mode & PAD_KNOB_OCTAVE != 0:
            self._parent.inc_octave(delta)
        if self.pad_to_mainknob_mode & PAD_KNOB_SCALE != 0:
            self._parent.inc_scale(delta)
        if self.pad_to_mainknob_mode & PAD_KNOB_BASEN != 0:
            self._parent.inc_base_note(delta)
        self._parent.update_transpose()

    def adjust_loop_start(self, delta):
        loopval = self._parent.song().loop_start
        loopval += self.loop_incdex * delta
        if loopval < 0:
            loopval = 0
        elif loopval > 999:
            loopval = 999
        self._parent.song().loop_start = loopval

    def adjust_loop_length(self, delta):
        loopval = self._parent.song().loop_length
        loopval += self.loop_incdex * delta
        if loopval < self.loop_incdex:
            loopval = self.loop_incdex
        elif loopval > 999:
            loopval = 999
        self._parent.song().loop_length = loopval

    def chg_general(self, delta):
        self._parent._scenematrix.control_handler.mod_value(delta, self.shift_on)

    def nav_track(self, direction):
        if direction == 1:
            self._parent._a_trk_right(1)
        else:
            self._parent._a_trk_left(1)

    def nav_c_hor(self, direction):
        self._parent.move_view_horizontal(direction)

    def nav_c_ver(self, direction):
        if direction == 1:
            self._parent._session.bank_up()
        else:
            self._parent._session.bank_down()

    def chg_volume(self, diff):
        if self.shift_on:
            self.repeat(self.master_track.mixer_device.volume, diff)
        else:
            self.master_track.mixer_device.volume.value = self.calc_new_parm(self.master_track.mixer_device.volume, diff)

    def chg_xfade(self, diff):
        if self.shift_on:
            self.repeat(self.master_track.mixer_device.crossfader, diff)
        else:
            self.master_track.mixer_device.crossfader.value = self.calc_new_parm(self.master_track.mixer_device.crossfader, diff)

    def chg_cue(self, diff):
        if self.shift_on:
            self.repeat(self.master_track.mixer_device.cue_volume, diff)
        else:
            self.master_track.mixer_device.cue_volume.value = self.calc_new_parm(self.master_track.mixer_device.cue_volume, diff)

    def repeat(self, parm, delta):
        count = 0
        while count < SHIFT_INC:
            parm.value = self.calc_new_parm(parm, delta)
            count += 1

    def calc_new_parm(self, parm, delta):
        parm_range = parm.max - parm.min
        int_val = int((parm.value - parm.min) / parm_range * PARM_RANGE + 0.1)
        inc_val = min(PARM_RANGE, max(0, int_val + delta))
        return float(inc_val) / float(PARM_RANGE) * parm_range + parm.min

    def chg_quant(self, diff):
        rec_quant = self._parent.song().midi_recording_quantization
        index = self.get_quant_index(rec_quant)
        new_index = index + diff
        if new_index >= 0 and new_index < len(QUANT_CONST):
            self._parent.song().midi_recording_quantization = QUANT_CONST[new_index]
            self._parent.show_message(QUANT_DESCR[new_index])

    def chg_clip_q(self, diff):
        quant = self._parent.song().clip_trigger_quantization
        self._parent.song().clip_trigger_quantization = max(0, min(13, quant + diff))
        self._parent.show_message('Clip Quantize ' + CLIQ_DESCR[self._parent.song().clip_trigger_quantization])

    def chg_tempo_fine(self, diff):
        if diff < 0:
            amount = -0.01
        else:
            amount = 0.01
        self.chg_tempo(amount)

    def chg_tempo(self, diff):
        self._parent.song().tempo = max(20, min(999, self._parent.song().tempo + diff))

    def get_quant_index(self, const):
        for index in range(len(QUANT_CONST)):
            if const == QUANT_CONST[index]:
                return index

        return -1

    def _action_octave(self, value):
        if value != 0:
            self.pad_to_mainknob_mode |= PAD_KNOB_OCTAVE
        else:
            self.pad_to_mainknob_mode &= ~PAD_KNOB_OCTAVE

    def _action_scale(self, value):
        if value != 0:
            self.pad_to_mainknob_mode |= PAD_KNOB_SCALE
        else:
            self.pad_to_mainknob_mode &= ~PAD_KNOB_SCALE

    def _action_base_note(self, value):
        if value != 0:
            self.pad_to_mainknob_mode |= PAD_KNOB_BASEN
        else:
            self.pad_to_mainknob_mode &= ~PAD_KNOB_BASEN

    def _action_key_color(self, value):
        if value != 0:
            self._parent.step_key_color_mode()

    def _set_volume_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.volume_button != None:
                self.volume_button.remove_value_listener(self._action_volume)
            self.volume_button = button
            self.volume_button != None and self.volume_button.add_value_listener(self._action_volume)

    def _action_volume(self, value):
        if not self.volume_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_VOLUME and self._set_mode(KN2_MODE_VOLUME)

    def _set_xfade_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.xfade_button != None:
                self.xfade_button.remove_value_listener(self._action_xfade)
            self.xfade_button = button
            self.xfade_button != None and self.xfade_button.add_value_listener(self._action_xfade)

    def _action_xfade(self, value):
        if not self.xfade_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_XFADE and self._set_mode(KN2_MODE_XFADE)

    def _set_swing_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.swing_button != None:
                self.swing_button.remove_value_listener(self._action_swing)
            self.swing_button = button
            self.swing_button != None and self.swing_button.add_value_listener(self._action_swing)

    def _action_swing(self, value):
        if not self.swing_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_QUANT and self._set_mode(KN2_MODE_QUANT)

    def _set_tempo_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.tempo_button != None:
                self.tempo_button.remove_value_listener(self._action_tempo)
            self.tempo_button = button
            self.tempo_button != None and self.tempo_button.add_value_listener(self._action_tempo)

    def _action_tempo(self, value):
        if not self.tempo_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_TEMPO_COARSE and self._set_mode(KN2_MODE_TEMPO_COARSE)

    def _set_clipn_h_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.clipn_h_button != None:
                self.clipn_h_button.remove_value_listener(self._action_clipnh)
            self.clipn_h_button = button
            self.clipn_h_button != None and self.clipn_h_button.add_value_listener(self._action_clipnh)

    def _action_clipnh(self, value):
        if not self.clipn_h_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_CLIPN_HOR and self._set_mode(KN2_MODE_CLIPN_HOR)

    def _set_clipn_v_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.clipn_v_button != None:
                self.clipn_v_button.remove_value_listener(self._action_clipnv)
            self.clipn_v_button = button
            self.clipn_v_button != None and self.clipn_v_button.add_value_listener(self._action_clipnv)

    def _action_clipnv(self, value):
        if not self.clipn_v_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.mode != KN2_MODE_CLIPN_VER and self._set_mode(KN2_MODE_CLIPN_VER)

    def _set_shift_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.shift_button != None:
                self.shift_button.remove_value_listener(self._action_shift)
            self.shift_button = button
            self.shift_button != None and self.shift_button.add_value_listener(self._action_shift)

    def _action_shift(self, value):
        if not self.shift_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            self.shift_on = value != 0 and not self.shift_on
            self.update_shift()

    def _set_scroll_mod_left_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.scroll_mod_left_button != None:
                self.scroll_mod_left_button.remove_value_listener(self._action_scroll_left)
            self.scroll_mod_left_button = button
            self.scroll_mod_left_button != None and self.scroll_mod_left_button.add_value_listener(self._action_scroll_left)

    def _set_scroll_mod_right_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.scroll_mod_right_button != None:
                self.scroll_mod_right_button.remove_value_listener(self._action_scroll_right)
            self.scroll_mod_right_button = button
            self.scroll_mod_right_button != None and self.scroll_mod_right_button.add_value_listener(self._action_scroll_right)

    def _action_scroll_left(self, value):
        if not self.scroll_mod_left_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.scroll_mod_left_button.send_value(127, True)
            self.navflags |= LEFT_DOWN
            self._measure_left_click = int(round(time.time() * 1000))
        else:
            self.scroll_mod_left_button.send_value(0, True)
            self.navflags &= ~LEFT_DOWN
            clicktime = int(round(time.time() * 1000)) - self._measure_left_click
            if clicktime < CLICK_TIME:
                if self._parent._modifier_down:
                    self._parent.modify_track_offset(-1)
                elif self._parent._mode == PAD_MODE:
                    self._do_lr_as_scale_mode(-1)
                elif self._parent._mode == SCENE_MODE:
                    self._parent.modify_scene_offset(-1)
                elif self._parent._mode == CLIP_MODE:
                    self._parent.move_view_horizontal(-1)
                elif self._parent._mode == CONTROL_MODE:
                    self._parent.move_view_horizontal(-1)

    def _action_scroll_right(self, value):
        if not self.scroll_mod_right_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value != 0 and self.scroll_mod_right_button.send_value(127, True)
            self.navflags |= RIGHT_DOWN
            self._measure_right_click = int(round(time.time() * 1000))
        else:
            self.scroll_mod_right_button.send_value(0, True)
            self.navflags &= ~RIGHT_DOWN
            clicktime = int(round(time.time() * 1000)) - self._measure_right_click
            if clicktime < CLICK_TIME:
                if self._parent._modifier_down:
                    self._parent.modify_track_offset(1)
                elif self._parent._mode == PAD_MODE:
                    self._do_lr_as_scale_mode(1)
                elif self._parent._mode == SCENE_MODE:
                    self._parent.modify_scene_offset(1)
                elif self._parent._mode == CLIP_MODE:
                    self._parent.move_view_horizontal(1)
                elif self._parent._mode == CONTROL_MODE:
                    self._parent.move_view_horizontal(1)

    def _do_lr_as_scale_mode(self, delta):
        if self.pad_to_mainknob_mode == PAD_KNOB_SCALE:
            self._parent.inc_scale(delta)
        elif self.pad_to_mainknob_mode == PAD_KNOB_BASEN:
            self._parent.inc_base_note(delta)
        else:
            self._parent.inc_octave(delta)
        self._parent.update_transpose()

    def _set_push_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.push_button != None:
                self.push_button.remove_value_listener(self._action_push)
            self.push_button = button
            self.push_button != None and self.push_button.add_value_listener(self._action_push)

    def _action_push(self, value):
        if not self.push_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                next_mode = self.mode_assign_map[self.mode][3]
                next_mode != -1 and self._set_mode(next_mode)
            self.loop_div_index = self.lrmode == LR_CONTROL_LOOP and self.navflags != 0 and (self.loop_div_index + 1) % len(LOOP_KNOB_DIVISION)
            self._parent.show_message('Loop Selection Granularity : ' + str(LOOP_KNOB_DIVISION[self.loop_div_index]) + ' beats ')
            self.loop_incdex = LOOP_KNOB_DIVISION[self.loop_div_index]

    def remove_listener(self, control, callback):
        if control != None and control.value_has_listener(callback):
            control.remove_value_listener(callback)
        control.disconnect()

    def disconnect(self):
        self.remove_listener(self.the_slider, self._do_main_slider)
        self.remove_listener(self.arrow_mode_button, self.toggle_arrow_mode)
        self.remove_listener(self.volume_button, self._action_volume)
        self.remove_listener(self.xfade_button, self._action_xfade)
        self.remove_listener(self.swing_button, self._action_swing)
        self.remove_listener(self.clipn_h_button, self._action_clipnh)
        self.remove_listener(self.clipn_v_button, self._action_clipnv)
        self.remove_listener(self.shift_button, self._action_shift)
        self.remove_listener(self.scroll_mod_left_button, self._action_scroll_left)
        self.remove_listener(self.scroll_mod_right_button, self._action_scroll_right)
        self.remove_listener(self.push_button, self._action_push)
        self.remove_listener(self.octave_mod_button, self._action_octave)
        self.remove_listener(self.scale_mod_button, self._action_scale)
        self.remove_listener(self.basenote_mod_button, self._action_base_note)
        self.remove_listener(self.keycolor_mod_button, self._action_key_color)
        self._parent = None
        self.master_track = None
        self.the_slider = None
        self.mode_assign_map = None
########NEW FILE########
__FILENAME__ = PadScale
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk2\PadScale.py


class PadScale:
    __module__ = __name__
    __doc__ = ' scale '

    def __init__(self, name, notevalues):
        isinstance(notevalues, tuple)
        self.name = name
        self.notevalues = notevalues
        scale_len = len(self.notevalues)
        rel_range = 16.0 / scale_len
        self.octave_range = int(10 - rel_range + 0.5)
        if self.octave_range < 0:
            self.octave_range = 0

    def to_octave(self, value):
        if self.octave_range == 0:
            return 0
        return int(value * self.octave_range)

    def to_relative(self, value, prev):
        if self.octave_range == 0:
            return prev
        relvalue = value / float(self.octave_range)
        if relvalue > 1.0:
            return 1.0
        elif relvalue < 0.0:
            return 0.0
        return relvalue
########NEW FILE########
__FILENAME__ = SceneElement
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk2\SceneElement.py
import time
from _Framework.ButtonElement import *
from MIDI_Map import *

class SceneElement:
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, index, matrix):
        self._matrix = matrix
        self._launch_button = None
        self.index = index
        self._scene = None
        self.active = False
        self.blinking = False
        self._track = None
        self._pressAction = self._launch_scene
        self.oncolor = None
        self.offcolor = None
        self.eval = self._eval_scene_states

    def set_launch_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if button != self._launch_button:
                if self._launch_button != None:
                    self._launch_button.remove_value_listener(self._launch_value)
                self._launch_button = button
                self._launch_button != None and self._launch_button.add_value_listener(self._launch_value)

    def notify(self, blinking_state):
        if blinking_state == 0 and self.blinking:
            self._launch_button.send_value_bright(0)
        elif blinking_state > 0 and self.blinking:
            self._launch_button.send_value_bright(1)
        elif self.active:
            self._launch_button.send_value_bright(1)

    def set_value(self, force = False):
        if self._launch_button != None:
            if self.active:
                self._launch_button.send_value(1, force)
            else:
                self._launch_button.send_value(0, force)

    def force_value(self, value):
        if self._launch_button != None:
            if self.active:
                self._launch_button.send_value(value, True)

    def set_scene(self, scene):
        self._scene = scene

    def set_track(self, track):
        if self._track != None:
            if self._track.can_be_armed:
                self._track.remove_arm_listener(self._got_arm)
            self._track.remove_mute_listener(self._got_mute)
            self._track.remove_solo_listener(self._got_solo)
            self._track.remove_playing_slot_index_listener(self._got_playing)
            self._track.remove_fired_slot_index_listener(self._got_slot_fired)
            if self._track.mixer_device.crossfade_assign_has_listener(self._got_xfade):
                self._track.mixer_device.remove_crossfade_assign_listener(self._got_xfade)
        self._track = track
        if track != None:
            if self._track.can_be_armed:
                self._track.add_arm_listener(self._got_arm)
            self._track.add_mute_listener(self._got_mute)
            self._track.add_solo_listener(self._got_solo)
            self._track.add_playing_slot_index_listener(self._got_playing)
            self._track.mixer_device.add_crossfade_assign_listener(self._got_xfade)
            self._track.add_fired_slot_index_listener(self._got_slot_fired)

    def _got_xfade(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_XFADE:
            self.eval()
            self.set_value()

    def _got_arm(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_ARM:
            self.eval()

    def _got_mute(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_MUTE:
            self.eval()

    def _got_solo(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_SOLO:
            self.eval()

    def _got_playing(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_STOP:
            self._matrix.update()

    def _got_slot_fired(self):
        if self._track != None and self._matrix.mode == SCENE_MODE_STOP:
            self._matrix.update()

    def assign_mode(self, mode):
        self.active = False
        if mode == SCENE_MODE_NORMAL:
            self.eval = self._eval_scene_states
        elif mode == SCENE_MODE_CONTROL:
            self.eval = self._eval_control_mode
        elif mode == SCENE_MODE_MUTE:
            self.eval = self._eval_mute
        elif mode == SCENE_MODE_SOLO:
            self.eval = self._eval_solo
        elif mode == SCENE_MODE_SELECT:
            self.eval = self._eval_select
        elif mode == SCENE_MODE_ARM:
            self.eval = self._eval_arm
        elif mode == SCENE_MODE_STOP:
            self.eval = self._eval_stop
        elif mode == SCENE_MODE_XFADE:
            self.eval = self._eval_xfade_assign

    def get_color(self, value):
        if value == 0:
            return self.offcolor
        else:
            return self.oncolor

    def _eval_xfade_assign(self):
        self.blinking = False
        self._pressAction = self._inaktion
        if self._track != None and self._track.mixer_device != None:
            xfade = self._track.mixer_device.crossfade_assign
            if xfade == 0:
                self.assign_color(PColor.XFADE_A)
            elif xfade == 1:
                self.assign_color(PColor.XFADE_BOTH)
            elif xfade == 2:
                self.assign_color(PColor.XFADE_B)
            self._pressAction = self._switch_xfade_assign
        else:
            self.disable_color()
            self._pressAction = self._inaktion

    def _switch_xfade_assign(self, value):
        if self._track != None:
            self._track.mixer_device.crossfade_assign = (self._track.mixer_device.crossfade_assign + 1) % 3
            if self._track.mixer_device.crossfade_assign == 0:
                self.assign_color(PColor.XFADE_A)
            elif self._track.mixer_device.crossfade_assign == 1:
                self.assign_color(PColor.XFADE_BOTH)
            elif self._track.mixer_device.crossfade_assign == 2:
                self.assign_color(PColor.XFADE_B)
            self.set_value()

    def _eval_stop(self):
        self._pressAction = self._stop_track
        self.blinking = False
        self.active = True
        if self._track != None:
            clipslots = self._track.clip_slots
            stop_fired = self._track.fired_slot_index == -2
            play_fired = self._track.fired_slot_index >= 0
            clip_playing = False
            has_clip = False
            if clipslots != None:
                for cs_index in range(len(clipslots)):
                    clip_slot = clipslots[cs_index]
                    if clip_slot.has_clip:
                        has_clip = True
                        if clip_slot.clip.is_playing:
                            clip_playing = True
                    elif clip_slot.controls_other_clips:
                        has_clip = True
                        if clip_slot.is_playing:
                            clip_playing = True
                        if clip_slot.is_triggered:
                            play_fired = True
                    elif clip_slot.is_triggered:
                        stop_fired = True

            is_group = self._track.is_foldable
            if stop_fired or play_fired:
                self.blinking = True
            if is_group:
                if clip_playing:
                    self.assign_color(PColor.STOP_G_PLAY)
                else:
                    self.assign_color(PColor.STOP_G_NO_PLAY)
            elif clip_playing:
                self.assign_color(PColor.STOP_PLAY)
            elif has_clip:
                self.assign_color(PColor.STOP_NO_PLAY)
            else:
                self.assign_color(PColor.STOP_NO_CLIPS)
        else:
            self.disable_color()
        self.set_value()

    def _eval_arm(self):
        prevstate = self.active
        self._pressAction = self._arm_track
        self.blinking = False
        if self._track == None:
            self.active = False
            self.disable_color()
        elif self._track.can_be_armed:
            if self._track.arm:
                self.active = True
            else:
                self.active = False
            if self._track.has_midi_input:
                self.assign_color(PColor.ARM_MIDI)
            elif self._track.has_audio_input:
                self.assign_color(PColor.ARM_AUDIO)
            else:
                self.assign_color(PColor.ARM_OTHER)
        else:
            self.active = False
            self.assign_color(PColor.ARM_NO_ARM)
        if prevstate != self.active:
            self.set_value()

    def _eval_mute(self):
        prevstate = self.active
        self._pressAction = self._mute_track
        self.blinking = False
        if self._track == None:
            self.active = False
            self.disable_color()
        elif self._track.mute:
            self.active = False
            self.assign_color(PColor.MUTE_TRACK)
        else:
            self.active = True
            self.assign_color(PColor.MUTE_TRACK)
        if prevstate != self.active:
            self.set_value()

    def _eval_solo(self):
        prevstate = self.active
        self._pressAction = self._solo_track
        self.blinking = False
        if self._track == None:
            self.active = False
            self.disable_color()
        elif self._track.solo:
            self.active = True
            self.assign_color(PColor.SOLO_TRACK)
        else:
            self.active = False
            self.assign_color(PColor.SOLO_TRACK)
        if prevstate != self.active:
            self.set_value()

    def _eval_select(self):
        prevstate = self.active
        self._pressAction = self._select_track
        self.blinking = False
        if self._track == None:
            self.active = False
            self.disable_color()
        elif self._track == self._matrix.getSelectedTrack():
            self.active = True
            self.assign_color(PColor.SELECT)
        else:
            self.active = False
            self.assign_color(PColor.SELECT)
        if prevstate != self.active:
            self.set_value()

    def _eval_control_mode(self):
        prevstate = self.active
        self.active = False
        if self.index > 7:
            if self._matrix.control_handler.mode == CONTROL_DEVICE:
                parm_index = self._matrix.control_handler.index_parm_id(self.index)
                self._eval_device_buttons(parm_index)
            else:
                track_index = self._matrix.control_handler.index_parm_id(self.index)
                self._eval_mixer_button(track_index)
        elif self.index > 3:
            mode = self.index - 4
            self.oncolor = device_get_mode_color(mode, 0)
            self.offcolor = device_get_mode_color(mode, 1)
            if mode == self._matrix.control_handler.mode:
                self.active = True
                self.value = 1
            else:
                self.active = False
                self.value = 0
            self._pressAction = self._select_dev_mode
        elif self._matrix.control_handler.mode == CONTROL_SEND:
            self._set_up_control_send()
        elif self._matrix.control_handler.mode == CONTROL_DEVICE:
            self._set_up_device_nav()
        else:
            self.disable_color()
            self._pressAction = self._inaktion
        self.blinking = False
        if prevstate != self.active:
            self.set_value()

    def _eval_device_buttons(self, index):
        valid = True
        if self._matrix.control_handler.selected_device == None:
            valid = False
        elif index >= self._matrix.control_handler.nr_of_parms_in_bank():
            valid = False
        if valid:
            if index == 0 and self._matrix.control_handler.selected_bank == 0:
                self.assign_color(PColor.DEVICE_ON_OFF)
            else:
                mode = self._matrix.control_handler.mode
                self.oncolor = device_get_color(mode, 0)
                self.offcolor = device_get_color(mode, 1)
            if index == self._matrix.control_handler.selected_device_parm_index:
                self.active = True
                self.value = 1
            else:
                self.active = False
                self.value = 0
            self._pressAction = self._select_knob_assign_device
        else:
            self.disable_color()
            self.active = True
            self.value = 1
            self._pressAction = self._inaktion

    def _eval_mixer_button(self, index):
        track = self._matrix._control._mixer._channel_strips[index]._track
        if track == None:
            self.disable_color()
            self._pressAction = self._inaktion
        else:
            mode = self._matrix.control_handler.mode
            self.oncolor = device_get_color(mode, 0)
            self.offcolor = device_get_color(mode, 1)
            if index == self._matrix.control_handler.sel_track_parm_index:
                self.active = True
                self.value = 1
            else:
                self.active = False
                self.value = 0
            self._pressAction = self._select_knob_assign

    def _set_up_device_nav(self):
        if self.index == 0:
            self.assign_color(PColor.DEVICE_LEFT)
            self._pressAction = self._nav_device_left
        elif self.index == 1:
            self.assign_color(PColor.DEVICE_RIGHT)
            self._pressAction = self._nav_device_right
        elif self.index == 2:
            self.assign_color(PColor.BANK_LEFT)
            self._pressAction = self._nav_bank_left
            if self._matrix.control_handler.selected_bank == 0:
                self.mark_off()
            else:
                self.mark_on()
        elif self.index == 3:
            self.assign_color(PColor.BANK_RIGHT)
            self._pressAction = self._nav_bank_right
            if self._matrix.control_handler.selected_bank < self._matrix.control_handler.nr_of_banks() - 1:
                self.mark_on()
            else:
                self.mark_off()

    def mark_off(self):
        self.active = False
        self.value = 0

    def mark_on(self):
        self.active = True
        self.value = 1

    def disable_color(self):
        self.oncolor = None
        self.offcolor = None

    def assign_color(self, color):
        self.oncolor = color[0]
        self.offcolor = color[1]

    def _nav_device_left(self, value):
        if value > 0:
            self._matrix._control._nav_value_left(1)

    def _nav_device_right(self, value):
        if value > 0:
            self._matrix._control._nav_value_right(1)

    def _nav_bank_left(self, value):
        if value > 0 and self._matrix.control_handler.dec_bank_nr():
            self._matrix.update_on_device_parm_changed()

    def _nav_bank_right(self, value):
        if value > 0 and self._matrix.control_handler.inc_bank_nr():
            self._matrix.update_on_device_parm_changed()

    def _set_up_control_send(self):
        nr_of_tracks = len(self._matrix._control.song().return_tracks)
        self.assign_color(PColor.MIX_SELECT_SEND)
        if self.index < nr_of_tracks:
            if nr_of_tracks > 3 and self.index == 3:
                col = max(21, (21 + (self._matrix.control_handler.selected_sends_index - 3) * 20) % 127)
                self.oncolor = (col, 120, 127)
                self.offcolor = (21, 120, 30)
            if self.index == self._matrix.control_handler.selected_sends_index:
                self.value = 1
                self.active = True
            elif self.index == 3 and self._matrix.control_handler.selected_sends_index >= 3:
                self.value = 1
                self.active = True
            else:
                self.value = 0
                self.active = False
        else:
            self.disable_color()
            self._pressAction = self._inaktion
        self._pressAction = self._select_sub_sends

    def _select_sub_sends(self, value):
        self._matrix._control._master_knob.switch_to_matrix_mode()
        nr_of_tracks = len(self._matrix._control.song().return_tracks)
        new_index = self.index
        fire = False
        if self.index == 3:
            fire = True
            if self._matrix.control_handler.selected_sends_index < 3:
                new_index = 3
            elif self._matrix.control_handler.selected_sends_index < nr_of_tracks - 1:
                new_index = self._matrix.control_handler.selected_sends_index + 1
            else:
                new_index = 3
        self._matrix.control_handler.message_current_parm()
        self._matrix.control_handler.selected_sends_index = new_index
        self._matrix.control_handler.reassign_mix_parm()
        self._matrix.eval_matrix()
        if fire:
            self.set_value()

    def _select_knob_assign(self, value):
        self._matrix._control._master_knob.switch_to_matrix_mode()
        ip = self._matrix.control_handler.index_parm_id(self.index)
        track = self._matrix._control._mixer._channel_strips[ip]._track
        if self._matrix.control_handler.assign_mix_parm(track, ip):
            self._matrix.eval_matrix()
            self._matrix.control_handler.message_current_parm()

    def _select_knob_assign_device(self, value):
        self._matrix._control._master_knob.switch_to_matrix_mode()
        ip = self._matrix.control_handler.index_parm_id(self.index)
        if self._matrix.control_handler.assign_device_parm(ip):
            self._matrix.eval_matrix()

    def _select_dev_mode(self, value):
        self._matrix._control._master_knob.switch_to_matrix_mode()
        mode_index = self._matrix.control_handler.index_mode_id(self.index)
        if mode_index == CONTROL_DEVICE:
            device = self._matrix._control._device._device
            if device != None:
                self._matrix.control_handler.mode = mode_index
                self._matrix.control_handler.selected_device = device
                self._matrix._control.show_message('Control Device: ' + str(device.name))
                self._matrix.control_handler.reassign_device_parm()
                self._update_matrix()
        elif mode_index != self._matrix.control_handler.mode:
            self._matrix.control_handler.mode = mode_index
            self._matrix.control_handler.reassign_mix_parm()
            self._update_matrix()
            self._matrix.control_handler.message_current_parm()

    def _update_matrix(self):
        self._matrix.eval_matrix()
        self._matrix.fire_values()

    def _inaktion(self, value):
        pass

    def _eval_scene_states(self):
        prevstate = self.active
        self._pressAction = self._launch_scene
        if self._scene == None:
            self.active = False
            self.blinking = False
            self.disable_color()
        else:
            clip_slots = self._scene.clip_slots
            count = 0
            playcount = 0
            if self._scene.is_triggered:
                self.blinking = True
            else:
                self.blinking = False
            for cs_index in range(len(clip_slots)):
                clip_slot = clip_slots[cs_index]
                if clip_slot.has_clip:
                    count = count + 1
                    if clip_slot.clip.is_playing:
                        playcount = playcount + 1

            if playcount > 0:
                self.active = True
                self.assign_color(PColor.SCENE_PLAYING)
            elif count > 0:
                self.active = False
                self.assign_color(PColor.SCENE_HASCLIPS)
            else:
                self.active = False
                self.assign_color(PColor.SCENE_NO_CLIPS)
        if prevstate != self.active:
            self.set_value()

    def unbind(self):
        if self._launch_button != None and self._track != None:
            if self._track.can_be_armed:
                self._track.remove_arm_listener(self._got_arm)
            self._track.remove_mute_listener(self._got_mute)
            self._track.remove_solo_listener(self._got_solo)
            self._track.remove_playing_slot_index_listener(self._got_playing)
            self._track.mixer_device.remove_crossfade_assign_listener(self._got_xfade)
            self._track.remove_fired_slot_index_listener(self._got_slot_fired)
        self._launch_button = None
        self._scene = None

    def disconnect(self):
        if self._launch_button != None and self._launch_button.value_has_listener(self._launch_value):
            self._launch_button.remove_value_listener(self._launch_value)
        self._matrix = None
        self._launch_button = None
        self.index = None
        self._scene = None
        self.active = None
        self.blinking = None
        self._track = None
        self._pressAction = None
        self.oncolor = None
        self.offcolor = None
        self.eval = None

    def _launch_value(self, value):
        if not self._launch_button != None:
            raise AssertionError
            raise self._pressAction != None or AssertionError
            raise value in range(128) or AssertionError
            value > 0 and self._pressAction(value)

    def _launch_scene(self, value):
        if not value in range(128):
            raise AssertionError
            if value == 0:
                return
            if self._scene != None:
                pass
            self._launch_button.is_momentary() and self._scene.set_fire_button_state(value != 0)
        elif value != 0:
            self._scene.fire()

    def _mute_track(self, value):
        if self._track != None and value > 0:
            if self._track.mute:
                self._track.mute = False
                self.active = True
                self._launch_button.send_value(100)
            else:
                self._track.mute = True
                self.active = False
                self._launch_button.send_value(0)

    def _arm_track(self, value):
        if self._track != None and self._track.can_be_armed and value > 0:
            if self._track.arm:
                self._track.arm = False
                self.active = False
                self._launch_button.send_value(0)
            else:
                self._track.arm = True
                self.active = True
                self._launch_button.send_value(100)
            self._matrix.do_arm(self.index)

    def _stop_track(self, value):
        if self._track != None and value > 0:
            self._track.stop_all_clips()

    def _solo_track(self, value):
        if self._track != None and value > 0:
            if self._track.solo:
                self._track.solo = False
                self.active = False
                self._launch_button.send_value(0)
            else:
                self._track.solo = True
                self.active = True
                self._launch_button.send_value(100)
            self._matrix.do_solo(self.index)

    def _select_track(self, value):
        if self._track != None and value > 0:
            self._matrix.setSelectedTrack(self._track)
########NEW FILE########
__FILENAME__ = SceneMatrix
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk2\SceneMatrix.py
import Live
from MIDI_Map import *
from _Framework.CompoundComponent import *
from _Framework.ButtonElement import ButtonElement
from SceneElement import SceneElement
from ControlHandler import ControlHandler
from Mk2KnobControl import *

class SceneMatrix:
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, ctrl):
        self.track_offset = 0
        self.scene_offset = 0
        self._scenes = []
        self._control = ctrl
        self.mode = SCENE_MODE_NORMAL
        self.receives_notify = True
        self.control_handler = ControlHandler(ctrl, self)
        self.soloexclusive = True
        self.mutedsolo = False
        for index in range(16):
            self._scenes.append(SceneElement(index, self))

        self._control.song().view.add_selected_track_listener(self._sel_track_changed)

    def notify_scene_mode(self, value):
        if self.receives_notify:
            num_scenes = len(self._scenes)
            for index in range(num_scenes):
                if value == 1:
                    self._scenes[index].eval()
                self._scenes[index].notify(value)

    def update_control_selection(self):
        trindex = self._control.index_in_strip(self.control_handler.track)
        self.control_handler.sel_track_parm_index = trindex

    def mod_track_offset(self, delta):
        nr_of_tracks = len(self._control.song().tracks)
        newoffset = self.track_offset + delta * 16
        if newoffset > -1 and newoffset < nr_of_tracks:
            self.track_offset = newoffset
            self.show_track_control_message(nr_of_tracks)
            self.update()

    def mod_scene_offset(self, delta):
        scenes = self._control.song().scenes
        nr_of_scenes = len(scenes)
        newoffset = self.scene_offset + delta
        if newoffset > -1 and newoffset + 15 < nr_of_scenes:
            self.scene_offset = newoffset
            self.show_scene_control_message(nr_of_scenes)
            self.update()

    def show_scene_control_message(self, nr_of_scenes):
        self._control.show_message('Pads control Scenes ' + str(self.scene_offset + 1) + ' to ' + str(min(nr_of_scenes, self.scene_offset + 16)) + ' in Scene Mode')

    def show_track_control_message(self, nr_of_tracks):
        self._control.show_message('Pads control Tracks ' + str(self.track_offset + 1) + ' to ' + str(min(nr_of_tracks, self.track_offset + 16)))

    def _sel_track_changed(self):
        if self.mode == SCENE_MODE_SELECT:
            self.update()

    def in_main_mode(self):
        if self.mode == SCENE_MODE_NORMAL or self.mode == SCENE_MODE_CONTROL:
            return True
        return False

    def get_element(self, col, row):
        index = (3 - col) * 4 + row
        return self._scenes[index]

    def set_knob_mode(self, mode):
        self._control._master_knob._set_mode(KN2_MODE_GENERAL)

    def set_armsolo_exclusive(self, button):
        if self.soloexclusive:
            self.soloexclusive = False
            self._control.show_message(str('Exclusive Mode Arm/Solo Off'))
            button.send_value(0)
        else:
            self.soloexclusive = True
            self._control.show_message(str('Exclusive Mode Arm/Solo On'))
            button.send_value(100)

    def unbind(self):
        self._control.song().view.remove_selected_track_listener(self._sel_track_changed)
        num_scenes = len(self._scenes)
        for index in range(num_scenes):
            self._scenes[index].disable_color()
            self._scenes[index].force_value(0)
            self._scenes[index].unbind()

    def deassign(self):
        num_scenes = len(self._scenes)
        for index in range(num_scenes):
            self._scenes[index].set_launch_button(None)
            self._scenes[index].set_scene(None)
            self._scenes[index].set_track(None)
            self._scenes[index].eval()

    def assign(self):
        scenes = self._control.song().scenes
        tracks = self._control.song().tracks
        for index in range(16):
            tr_index = index + self.track_offset
            sc_index = index + self.scene_offset
            self._scenes[index].set_launch_button(self._control._button_sequence[index])
            if sc_index < len(scenes):
                self._scenes[index].set_scene(scenes[sc_index])
            else:
                self._scenes[index].set_scene(None)
            if tr_index < len(tracks):
                self._scenes[index].set_track(tracks[tr_index])
            else:
                self._scenes[index].set_track(None)
            self._scenes[index].eval()

    def set_mode(self, mode):
        self.mode = mode
        if self.mode == SCENE_MODE_NORMAL or self.mode == SCENE_MODE_STOP:
            self.receives_notify = True
        else:
            self.receives_notify = False
        num_scenes = len(self._scenes)
        for index in range(num_scenes):
            self._scenes[index].assign_mode(mode)

        if mode == SCENE_MODE_CONTROL and self.control_handler.parm == None:
            trindex = self.control_handler.sel_track_parm_index
            track = self._control._mixer._channel_strips[trindex]._track
            if track != None:
                self.control_handler.track = track
                self.control_handler.reassign_mix_parm()
        self.update()

    def do_solo(self, track_index):
        if self.soloexclusive:
            tracks = self._control.song().tracks
            for index in range(len(tracks)):
                if index != track_index and tracks[index].solo:
                    tracks[index].solo = False

    def do_arm(self, track_index):
        if self.soloexclusive:
            tracks = self._control.song().tracks
            for index in range(len(tracks)):
                if index != track_index and tracks[index].can_be_armed and tracks[index].arm:
                    tracks[index].arm = False

    def eval_matrix(self):
        for index in range(16):
            self._scenes[index].eval()

    def fire_values(self):
        for index in range(16):
            self._scenes[index].set_value()

    def eval_control(self):
        nr_of_tracks = len(self._control.song().return_tracks)
        if self.control_handler.selected_sends_index >= nr_of_tracks:
            self.control_handler.selected_sends_index = nr_of_tracks - 1

    def setSelectedTrack(self, track):
        self._control.song().view.selected_track = track

    def getSelectedTrack(self):
        return self._control.song().view.selected_track

    def update_on_device(self, device):
        if self.mode == SCENE_MODE_CONTROL and self.control_handler.mode == CONTROL_DEVICE:
            self.control_handler.set_device(device)
            self.update()

    def update_on_device_parm_changed(self):
        if self.mode == SCENE_MODE_CONTROL and self.control_handler.mode == CONTROL_DEVICE:
            self.update()

    def disconnect(self):
        num_scenes = len(self._scenes)
        for index in range(num_scenes):
            self._scenes[index].disconnect()

        self.unbind()
        self._scenes = None
        self._control = None
        self.mode = None
        self.receives_notify = None
        self.control_handler.disconnect()
        self.soloexclusive = None
        self.mutedsolo = None
        self.control_handler = None

    def fix_track_offset(self, nr_of_tracks):
        while self.track_offset >= nr_of_tracks:
            self.track_offset -= 16

        self.show_track_control_message(nr_of_tracks)

    def fix_scene_offset(self, nr_of_scenes, show_message = True):
        while self.scene_offset + 15 >= nr_of_scenes and self.scene_offset > 0:
            self.scene_offset -= 1

        if show_message:
            self.show_scene_control_message(nr_of_scenes)

    def update(self, force = False):
        scenes = self._control.song().scenes
        tracks = self._control.song().tracks
        nr_of_tracks = len(tracks)
        nr_of_scenes = len(scenes)
        if self.track_offset < 0:
            self.track_offset = 0
        elif self.track_offset >= nr_of_tracks:
            self.fix_track_offset(nr_of_tracks)
        if self.scene_offset < 0:
            self.scene_offset = 0
        elif self.scene_offset + 15 >= nr_of_scenes:
            self.fix_scene_offset(nr_of_scenes, False)
        self.eval_control()
        for index in range(16):
            tr_index = index + self.track_offset
            sc_index = index + self.scene_offset
            if sc_index < nr_of_scenes:
                self._scenes[index].set_scene(scenes[sc_index])
            else:
                self._scenes[index].set_scene(None)
            if tr_index < nr_of_tracks:
                self._scenes[index].set_track(tracks[tr_index])
            else:
                self._scenes[index].set_track(None)
            self._scenes[index].eval()
            self._scenes[index].set_value(force)
########NEW FILE########
__FILENAME__ = StateButton
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk2\StateButton.py
import Live
from _Framework.ButtonElement import *
from _Framework.InputControlElement import *
from MIDI_Map import *

class StateButton(ButtonElement):
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, is_momentary, msg_type, channel, identifier):
        ButtonElement.__init__(self, is_momentary, msg_type, channel, identifier)
        self._is_enabled = True
        self._is_notifying = False
        self._force_next_value = False

    def turn_off(self):
        self.send_value(0, True)

    def turn_on(self):
        self.send_value(127, True)

    def set_enabled(self, enabled):
        self._is_enabled = enabled

    def reset(self):
        self.send_value(0, True)

    def install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback):
        if self._is_enabled:
            ButtonElement.install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback)
        elif self._msg_channel != self._original_channel or self._msg_identifier != self._original_identifier:
            install_translation_callback(self._msg_type, self._original_identifier, self._original_channel, self._msg_identifier, self._msg_channel)


class ToggleButton(ButtonElement):
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, msg_type, channel, identifier):
        ButtonElement.__init__(self, True, msg_type, channel, identifier)
        self._is_enabled = True
        self._is_notifying = False
        self._force_next_value = False
        self._value = 0

    def turn_off(self):
        self._value = 0
        self.send_value(0, True)

    def turn_on(self):
        self._value = 1
        self.send_value(127, True)

    def set_enabled(self, enabled):
        self._is_enabled = enabled

    def reset(self):
        self.send_value(0, True)

    def receive_value(self, value):
        if value > 0:
            if self._value == 0:
                self._value = 1
                InputControlElement.receive_value(self, 127)
            else:
                self._value = 0
                InputControlElement.receive_value(self, 0)

    def install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback):
        if self._is_enabled:
            ButtonElement.install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback)
        elif self._msg_channel != self._original_channel or self._msg_identifier != self._original_identifier:
            install_translation_callback(self._msg_type, self._original_identifier, self._original_channel, self._msg_identifier, self._msg_channel)
########NEW FILE########
__FILENAME__ = VarButtonElement
#Embedded file name: C:\ProgramData\Ableton\Live 9 Beta\Resources\MIDI Remote Scripts\Maschine_Mk2\VarButtonElement.py
import Live
from _Framework.ButtonElement import *
from _Framework.InputControlElement import *
from MIDI_Map import *
import time

class VarButtonElement(ButtonElement):
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, is_momentary, channel, scene_index, track_index, parent):
        ButtonElement.__init__(self, is_momentary, MIDI_NOTE_TYPE, channel, CLIPNOTEMAP[scene_index][track_index])
        self._is_enabled = True
        self._is_notifying = False
        self.surface = parent
        self._report_input = False
        self._scene_index = scene_index
        self._track_index = track_index
        self.last_value = 0
        self.last_color = [None, None, None]

    def get_identifier(self):
        return self._msg_identifier

    def reset(self):
        self.last_color = [None, None, None]

    def turn_off(self):
        self.send_value(0, True)

    def turn_on(self):
        self.send_value(1, True)

    def refresh(self):
        self.send_value(self.last_value, True)

    def message_map_mode(self):
        raise self.message_type() is MIDI_CC_TYPE or AssertionError
        return Live.MidiMap.MapMode.absolute

    def set_enabled(self, enabled):
        self._is_enabled = enabled

    def set_send_note(self, note):
        if note in range(128):
            self._msg_identifier = note
            if not self._is_enabled:
                self.surface._translate_message(self._msg_type, self._original_identifier, self._original_channel, self._msg_identifier, self._msg_channel)

    def receive_value(self, value):
        if self._is_enabled:
            ButtonElement.receive_value(self, value)

    def set_to_notemode(self, notemode):
        self._is_enabled = not notemode
        if notemode:
            self.surface._translate_message(self._msg_type, self._original_identifier, self._original_channel, self._msg_identifier, self._msg_channel)
        else:
            self._is_being_forwarded = True

    def send_value_bright(self, value, force_send = False):
        if not value != None:
            raise AssertionError
            raise isinstance(value, int) or AssertionError
            raise value in range(128) or AssertionError
            self.last_value = value
            (force_send or self._is_being_forwarded) and self.send_color_brightness(value)
            self.last_value = value

    def send_value(self, value, force_send = False):
        if not value != None:
            raise AssertionError
            raise isinstance(value, int) or AssertionError
            raise value in range(128) or AssertionError
            (force_send or self._is_being_forwarded) and self.send_color(value)
            self.last_value = value

    def send_color_brightness(self, value):
        data_byte1 = self._original_identifier
        color = self.surface.get_color(value, self._track_index, self._scene_index)
        if color == None:
            self.send_c_midi(2, 0)
        else:
            self.send_c_midi(2, color[2])

    def send_color(self, value):
        data_byte1 = self._original_identifier
        color = self.surface.get_color(value, self._track_index, self._scene_index)
        if color == None:
            self.send_c_midi(0, 0, True)
            self.send_c_midi(1, 0, True)
            self.send_c_midi(2, 0, True)
        else:
            self.send_c_midi(0, color[0])
            self.send_c_midi(1, color[1])
            self.send_c_midi(2, color[2])

    def send_color_direct(self, color):
        data_byte1 = self._original_identifier
        if color == None:
            self.send_c_midi(0, 0, True)
            self.send_c_midi(1, 0, True)
            self.send_c_midi(2, 0, True)
        else:
            self.send_c_midi(2, color[2])
            self.send_c_midi(1, color[1])
            self.send_c_midi(0, color[0])

    def send_c_midi(self, channel, colorvalue, force = False):
        stat = MIDI_CC_STATUS + channel
        prevColor = self.last_color[channel]
        self.send_midi((stat, self._original_identifier, colorvalue))

    def send_hue(self, noteval, value):
        self.send_midi((MIDI_CC_STATUS + 0, noteval, value), False)

    def disconnect(self):
        ButtonElement.disconnect(self)
        self._is_enabled = None
        self._is_notifying = None
        self.surface = None
        self._report_input = None
        self._scene_index = None
        self._track_index = None
        self.surface = None


class TwinButton(ButtonElement):
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, is_momentary, channel, partner):
        raise isinstance(partner, VarButtonElement) or AssertionError
        ButtonElement.__init__(self, is_momentary, MIDI_NOTE_TYPE, channel, partner._original_identifier)
        self._partner = partner

    def fire(self, value):
        self._partner.send_value(value, True)


class GatedColorButton(ButtonElement):
    __module__ = __name__
    __doc__ = ' Special button class that has on, off, color an can also be a None Color Button '

    def __init__(self, is_momentary, midi_type, identifier, hue):
        ButtonElement.__init__(self, is_momentary, midi_type, 0, identifier)
        self._msg_identifier = identifier
        self.hue = hue
        self.last_value = 0

    def send_value(self, value, force_send = False):
        if not value != None:
            raise AssertionError
            raise isinstance(value, int) or AssertionError
            raise value in range(128) or AssertionError
            (force_send or self._is_being_forwarded) and self.send_color(value)

    def send_color(self, value):
        data_byte1 = self._msg_identifier
        self.last_value = value
        if value == 0:
            brightness = 10
        else:
            brightness = 127
        self.send_midi((MIDI_CC_STATUS + 0, data_byte1, self.hue))
        self.send_midi((MIDI_CC_STATUS + 2, data_byte1, brightness))
        self.send_midi((MIDI_CC_STATUS + 1, data_byte1, 127))

    def switch_off(self):
        data_byte = self._msg_identifier
        self.send_midi((MIDI_CC_STATUS + 2, data_byte, 0))
        self.send_midi((MIDI_CC_STATUS + 1, data_byte, 0))
        self.send_midi((MIDI_CC_STATUS + 0, data_byte, 0))

    def activate(self):
        self.send_value(0)

    def update(self):
        self.state_init = False
        self.send_value(self.last_value, True)

    def disconnect(self):
        InputControlElement.disconnect(self)


class ColorButton(ButtonElement):
    __module__ = __name__
    __doc__ = ' Special button class that deals with Colors '

    def __init__(self, is_momentary, midi_type, identifier):
        ButtonElement.__init__(self, is_momentary, midi_type, 0, identifier)
        self.hue = 2
        self.sat = 127
        self.bright = 127
        self._msg_identifier = identifier

    def send_value(self, value, force_send = False):
        if not value != None:
            raise AssertionError
            raise isinstance(value, int) or AssertionError
            raise value in range(128) or AssertionError
            (force_send or self._is_being_forwarded) and self.send_color(value)

    def set_color(self, hue, sat, bright):
        self.hue = hue
        self.bright = bright
        self.sat = sat

    def send_hue(self, hue):
        data_byte1 = self._original_identifier
        self.hue = hue
        self.send_midi((MIDI_CC_STATUS + 0, data_byte1, hue))

    def send_color(self, value):
        data_byte1 = self._original_identifier
        self.send_midi((MIDI_CC_STATUS + 2, data_byte1, self.bright))
        self.send_midi((MIDI_CC_STATUS + 1, data_byte1, self.sat))
        self.send_midi((MIDI_CC_STATUS + 0, data_byte1, self.hue))

    def disconnect(self):
        ButtonElement.disconnect(self)
########NEW FILE########
__FILENAME__ = MasterControl
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MasterControl/MasterControl.py
from MackieControl.MackieControl import MackieControl

class MasterControl(MackieControl):
    """ Main class derived from MackieControl """

    def __init__(self, c_instance):
        MackieControl.__init__(self, c_instance)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/microKONTROL/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = ((GENERIC_ENC1, 0),
 (GENERIC_ENC2, 1),
 (GENERIC_ENC3, 2),
 (GENERIC_ENC4, 3),
 (GENERIC_ENC5, 4),
 (GENERIC_ENC6, 5),
 (GENERIC_ENC7, 6),
 (GENERIC_ENC8, 7))
VOLUME_CONTROLS = ((GENERIC_SLI1, 0),
 (GENERIC_SLI2, 1),
 (GENERIC_SLI3, 2),
 (GENERIC_SLI4, 3),
 (GENERIC_SLI5, 4),
 (GENERIC_SLI6, 5),
 (GENERIC_SLI7, 6),
 (GENERIC_SLI8, 7))
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': GENERIC_PAD5,
 'PREVBANK': GENERIC_PAD1,
 'BANK1': (47, 1),
 'BANK2': (46, 8),
 'BANK3': (45, 8),
 'BANK4': (44, 8),
 'BANK5': (85, 8),
 'BANK6': (86, 8),
 'BANK7': (87, 8),
 'BANK8': (88, 8)}
PAD_TRANSLATION = ((0, 0, 61, 9),
 (1, 0, 69, 9),
 (2, 0, 65, 9),
 (3, 0, 63, 9),
 (0, 1, 60, 9),
 (1, 1, 59, 9),
 (2, 1, 57, 9),
 (3, 1, 55, 9),
 (0, 2, 49, 9),
 (1, 2, 51, 9),
 (2, 2, 68, 9),
 (3, 2, 56, 9),
 (0, 3, 48, 9),
 (1, 3, 52, 9),
 (2, 3, 54, 9),
 (3, 3, 58, 9))
CONTROLLER_DESCRIPTIONS = {'INPUTPORT': 'microKONTROL (PORT B)',
 'OUTPUTPORT': 'microKONTROL (CTRL)',
 'CHANNEL': 8,
 'PAD_TRANSLATION': PAD_TRANSLATION}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': -1}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/microKONTROL/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = -1
GENERIC_PLAY = -1
GENERIC_REC = -1
GENERIC_LOOP = -1
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 10
GENERIC_ENC2 = 10
GENERIC_ENC3 = 10
GENERIC_ENC4 = 10
GENERIC_ENC5 = 10
GENERIC_ENC6 = 10
GENERIC_ENC7 = 10
GENERIC_ENC8 = 10
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 7
GENERIC_SLI2 = 7
GENERIC_SLI3 = 7
GENERIC_SLI4 = 7
GENERIC_SLI5 = 7
GENERIC_SLI6 = 7
GENERIC_SLI7 = 7
GENERIC_SLI8 = 7
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MidAir25/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
VOLUME_CONTROLS = GENERIC_SLIDERS
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': -1,
 'PREVBANK': -1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'MidAir',
 'OUTPUTPORT': 'MidAir',
 'CHANNEL': 0}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MidAir25/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = -1
GENERIC_PLAY = -1
GENERIC_REC = -1
GENERIC_LOOP = -1
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 71
GENERIC_ENC2 = 74
GENERIC_ENC3 = 84
GENERIC_ENC4 = 2
GENERIC_ENC5 = 91
GENERIC_ENC6 = 93
GENERIC_ENC7 = 5
GENERIC_ENC8 = 10
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = -1
GENERIC_SLI2 = -1
GENERIC_SLI3 = -1
GENERIC_SLI4 = -1
GENERIC_SLI5 = -1
GENERIC_SLI6 = -1
GENERIC_SLI7 = -1
GENERIC_SLI8 = -1
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MPD18/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD,
 'NORELEASE': 0}
DEVICE_CONTROLS = ((GENERIC_ENC1, 0),
 (GENERIC_ENC2, 0),
 (GENERIC_ENC3, 0),
 (GENERIC_ENC4, 0),
 (GENERIC_ENC5, 0),
 (GENERIC_ENC6, 0),
 (GENERIC_ENC7, 0),
 (GENERIC_ENC8, 0))
VOLUME_CONTROLS = ((GENERIC_SLI1, 0),
 (GENERIC_SLI2, 0),
 (GENERIC_SLI3, 0),
 (GENERIC_SLI4, 0),
 (GENERIC_SLI5, 0),
 (GENERIC_SLI6, 0),
 (GENERIC_SLI7, 0),
 (GENERIC_SLI8, 0))
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': -1,
 'BANKDIAL': -1,
 'NEXTBANK': -1,
 'PREVBANK': -1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
PAD_TRANSLATION = ((0, 0, 48, 0),
 (1, 0, 49, 0),
 (2, 0, 50, 0),
 (3, 0, 51, 0),
 (0, 1, 44, 0),
 (1, 1, 45, 0),
 (2, 1, 46, 0),
 (3, 1, 47, 0),
 (0, 2, 40, 0),
 (1, 2, 41, 0),
 (2, 2, 42, 0),
 (3, 2, 43, 0),
 (0, 3, 36, 0),
 (1, 3, 37, 0),
 (2, 3, 38, 0),
 (3, 3, 39, 0))
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'Akai MPD18',
 'OUTPUTPORT': 'Akai MPD18',
 'CHANNEL': 0,
 'PAD_TRANSLATION': PAD_TRANSLATION}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': 1}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MPD18/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = -1
GENERIC_PLAY = -1
GENERIC_REC = -1
GENERIC_LOOP = -1
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = -1
GENERIC_ENC2 = -1
GENERIC_ENC3 = -1
GENERIC_ENC4 = -1
GENERIC_ENC5 = -1
GENERIC_ENC6 = -1
GENERIC_ENC7 = -1
GENERIC_ENC8 = -1
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = -1
GENERIC_SLI2 = -1
GENERIC_SLI3 = -1
GENERIC_SLI4 = -1
GENERIC_SLI5 = -1
GENERIC_SLI6 = -1
GENERIC_SLI7 = -1
GENERIC_SLI8 = -1
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MPD24/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD,
 'NORELEASE': 0}
DEVICE_CONTROLS = GENERIC_ENCODERS
VOLUME_CONTROLS = ((GENERIC_SLI1, -1),
 (GENERIC_SLI2, -1),
 (GENERIC_SLI3, -1),
 (GENERIC_SLI4, -1),
 (GENERIC_SLI5, -1),
 (GENERIC_SLI6, -1),
 (GENERIC_SLI7, -1),
 (GENERIC_SLI8, -1))
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': -1,
 'BANKDIAL': -1,
 'NEXTBANK': -1,
 'PREVBANK': -1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
PAD_TRANSLATION = ((0, 0, 48, 0),
 (1, 0, 49, 0),
 (2, 0, 50, 0),
 (3, 0, 51, 0),
 (0, 1, 44, 0),
 (1, 1, 45, 0),
 (2, 1, 46, 0),
 (3, 1, 47, 0),
 (0, 2, 40, 0),
 (1, 2, 41, 0),
 (2, 2, 42, 0),
 (3, 2, 43, 0),
 (0, 3, 36, 0),
 (1, 3, 37, 0),
 (2, 3, 38, 0),
 (3, 3, 39, 0))
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'Akai MPD24',
 'OUTPUTPORT': 'Akai MPD24',
 'CHANNEL': 0,
 'PAD_TRANSLATION': PAD_TRANSLATION}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': -1}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MPD24/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = 117
GENERIC_PLAY = 118
GENERIC_REC = 119
GENERIC_LOOP = -1
GENERIC_RWD = 115
GENERIC_FFWD = 116
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 15
GENERIC_ENC2 = 16
GENERIC_ENC3 = 13
GENERIC_ENC4 = 14
GENERIC_ENC5 = 11
GENERIC_ENC6 = 12
GENERIC_ENC7 = 10
GENERIC_ENC8 = 7
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 1
GENERIC_SLI2 = 2
GENERIC_SLI3 = 3
GENERIC_SLI4 = 4
GENERIC_SLI5 = 5
GENERIC_SLI6 = 6
GENERIC_SLI7 = -1
GENERIC_SLI8 = -1
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MPD32/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD,
 'NORELEASE': 0}
DEVICE_CONTROLS = ((GENERIC_ENC1, 0),
 (GENERIC_ENC2, 0),
 (GENERIC_ENC3, 0),
 (GENERIC_ENC4, 0),
 (GENERIC_ENC5, 0),
 (GENERIC_ENC6, 0),
 (GENERIC_ENC7, 0),
 (GENERIC_ENC8, 0))
VOLUME_CONTROLS = ((GENERIC_SLI1, 0),
 (GENERIC_SLI2, 0),
 (GENERIC_SLI3, 0),
 (GENERIC_SLI4, 0),
 (GENERIC_SLI5, 0),
 (GENERIC_SLI6, 0),
 (GENERIC_SLI7, 0),
 (GENERIC_SLI8, 0))
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': GENERIC_PAD5,
 'PREVBANK': GENERIC_PAD1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
PAD_TRANSLATION = ((0, 0, 67, 1),
 (1, 0, 69, 1),
 (2, 0, 71, 1),
 (3, 0, 72, 1),
 (0, 1, 60, 1),
 (1, 1, 62, 1),
 (2, 1, 64, 1),
 (3, 1, 65, 1),
 (0, 2, 67, 0),
 (1, 2, 69, 0),
 (2, 2, 71, 0),
 (3, 2, 72, 0),
 (0, 3, 60, 0),
 (1, 3, 62, 0),
 (2, 3, 64, 0),
 (3, 3, 65, 0))
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'Akai MPD32',
 'OUTPUTPORT': 'Akai MPD32',
 'CHANNEL': 0,
 'PAD_TRANSLATION': PAD_TRANSLATION}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': -1}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MPD32/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = 117
GENERIC_PLAY = 118
GENERIC_REC = 119
GENERIC_LOOP = -1
GENERIC_RWD = 115
GENERIC_FFWD = 116
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 22
GENERIC_ENC2 = 23
GENERIC_ENC3 = 24
GENERIC_ENC4 = 25
GENERIC_ENC5 = 26
GENERIC_ENC6 = 27
GENERIC_ENC7 = 28
GENERIC_ENC8 = 29
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 12
GENERIC_SLI2 = 13
GENERIC_SLI3 = 14
GENERIC_SLI4 = 15
GENERIC_SLI5 = 16
GENERIC_SLI6 = 17
GENERIC_SLI7 = 18
GENERIC_SLI8 = 19
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = 32
GENERIC_BUT2 = 33
GENERIC_BUT3 = 34
GENERIC_BUT4 = 35
GENERIC_BUT5 = 36
GENERIC_BUT6 = 37
GENERIC_BUT7 = 38
GENERIC_BUT8 = 39
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MPK25/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD,
 'NORELEASE': 0}
DEVICE_CONTROLS = ((GENERIC_ENC1, 0),
 (GENERIC_ENC2, 0),
 (GENERIC_ENC3, 0),
 (GENERIC_ENC4, 0),
 (GENERIC_ENC5, 0),
 (GENERIC_ENC6, 0),
 (GENERIC_ENC7, 0),
 (GENERIC_ENC8, 0))
VOLUME_CONTROLS = ((GENERIC_SLI1, 0),
 (GENERIC_SLI2, 0),
 (GENERIC_SLI3, 0),
 (GENERIC_SLI4, 0),
 (GENERIC_SLI5, 0),
 (GENERIC_SLI6, 0),
 (GENERIC_SLI7, 0),
 (GENERIC_SLI8, 0))
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': -1,
 'BANKDIAL': -1,
 'NEXTBANK': -1,
 'PREVBANK': -1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
PAD_TRANSLATION = ((0, 0, 76, 1),
 (1, 0, 77, 1),
 (2, 0, 78, 1),
 (0, 1, 71, 1),
 (1, 1, 72, 1),
 (2, 1, 74, 1),
 (0, 2, 65, 1),
 (1, 2, 67, 1),
 (2, 2, 69, 1),
 (0, 3, 60, 1),
 (1, 3, 62, 1),
 (2, 3, 64, 1))
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'Akai MPK25',
 'OUTPUTPORT': 'Akai MPK25',
 'CHANNEL': 0,
 'PAD_TRANSLATION': PAD_TRANSLATION}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': -1,
 'NOTOGGLE': 0}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MPK25/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = 117
GENERIC_PLAY = 118
GENERIC_REC = 119
GENERIC_LOOP = -1
GENERIC_RWD = 115
GENERIC_FFWD = 116
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 22
GENERIC_ENC2 = 23
GENERIC_ENC3 = 24
GENERIC_ENC4 = 25
GENERIC_ENC5 = 12
GENERIC_ENC6 = 13
GENERIC_ENC7 = 14
GENERIC_ENC8 = 15
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 26
GENERIC_SLI2 = 27
GENERIC_SLI3 = 28
GENERIC_SLI4 = 29
GENERIC_SLI5 = 34
GENERIC_SLI6 = 35
GENERIC_SLI7 = 36
GENERIC_SLI8 = 37
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = 38
GENERIC_BUT2 = 39
GENERIC_BUT3 = 40
GENERIC_BUT4 = 41
GENERIC_BUT5 = 42
GENERIC_BUT6 = 43
GENERIC_BUT7 = 44
GENERIC_BUT8 = 45
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MPK49/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD,
 'NORELEASE': 0}
DEVICE_CONTROLS = ((GENERIC_ENC1, 0),
 (GENERIC_ENC2, 0),
 (GENERIC_ENC3, 0),
 (GENERIC_ENC4, 0),
 (GENERIC_ENC5, 0),
 (GENERIC_ENC6, 0),
 (GENERIC_ENC7, 0),
 (GENERIC_ENC8, 0))
VOLUME_CONTROLS = ((GENERIC_SLI1, 0),
 (GENERIC_SLI2, 0),
 (GENERIC_SLI3, 0),
 (GENERIC_SLI4, 0),
 (GENERIC_SLI5, 0),
 (GENERIC_SLI6, 0),
 (GENERIC_SLI7, 0),
 (GENERIC_SLI8, 0))
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': GENERIC_PAD5,
 'PREVBANK': GENERIC_PAD1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
PAD_TRANSLATION = ((0, 0, 76, 1),
 (1, 0, 77, 1),
 (2, 0, 78, 1),
 (0, 1, 71, 1),
 (1, 1, 72, 1),
 (2, 1, 74, 1),
 (0, 2, 65, 1),
 (1, 2, 67, 1),
 (2, 2, 69, 1),
 (0, 3, 60, 1),
 (1, 3, 62, 1),
 (2, 3, 64, 1))
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'Akai MPK49',
 'OUTPUTPORT': 'Akai MPK49',
 'CHANNEL': 0,
 'PAD_TRANSLATION': PAD_TRANSLATION}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': -1,
 'NOTOGGLE': 0}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MPK49/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = 117
GENERIC_PLAY = 118
GENERIC_REC = 119
GENERIC_LOOP = -1
GENERIC_RWD = 115
GENERIC_FFWD = 116
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 22
GENERIC_ENC2 = 23
GENERIC_ENC3 = 24
GENERIC_ENC4 = 25
GENERIC_ENC5 = 26
GENERIC_ENC6 = 27
GENERIC_ENC7 = 28
GENERIC_ENC8 = 29
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 12
GENERIC_SLI2 = 13
GENERIC_SLI3 = 14
GENERIC_SLI4 = 15
GENERIC_SLI5 = 16
GENERIC_SLI6 = 17
GENERIC_SLI7 = 18
GENERIC_SLI8 = 19
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = 32
GENERIC_BUT2 = 33
GENERIC_BUT3 = 34
GENERIC_BUT4 = 35
GENERIC_BUT5 = 36
GENERIC_BUT6 = 37
GENERIC_BUT7 = 38
GENERIC_BUT8 = 39
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MPK61/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD,
 'NORELEASE': 0}
DEVICE_CONTROLS = ((GENERIC_ENC1, 0),
 (GENERIC_ENC2, 0),
 (GENERIC_ENC3, 0),
 (GENERIC_ENC4, 0),
 (GENERIC_ENC5, 0),
 (GENERIC_ENC6, 0),
 (GENERIC_ENC7, 0),
 (GENERIC_ENC8, 0))
VOLUME_CONTROLS = ((GENERIC_SLI1, 0),
 (GENERIC_SLI2, 0),
 (GENERIC_SLI3, 0),
 (GENERIC_SLI4, 0),
 (GENERIC_SLI5, 0),
 (GENERIC_SLI6, 0),
 (GENERIC_SLI7, 0),
 (GENERIC_SLI8, 0))
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': GENERIC_PAD5,
 'PREVBANK': GENERIC_PAD1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
PAD_TRANSLATION = ((0, 0, 81, 1),
 (1, 0, 83, 1),
 (2, 0, 84, 1),
 (3, 0, 86, 1),
 (0, 1, 74, 1),
 (1, 1, 76, 1),
 (2, 1, 77, 1),
 (3, 1, 79, 1),
 (0, 2, 67, 1),
 (1, 2, 69, 1),
 (2, 2, 71, 1),
 (3, 2, 72, 1),
 (0, 3, 60, 1),
 (1, 3, 62, 1),
 (2, 3, 64, 1),
 (3, 3, 65, 1))
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'Akai MPK61',
 'OUTPUTPORT': 'Akai MPK61',
 'CHANNEL': 0,
 'PAD_TRANSLATION': PAD_TRANSLATION}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': -1,
 'NOTOGGLE': 0}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MPK61/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = 117
GENERIC_PLAY = 118
GENERIC_REC = 119
GENERIC_LOOP = -1
GENERIC_RWD = 115
GENERIC_FFWD = 116
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 22
GENERIC_ENC2 = 23
GENERIC_ENC3 = 24
GENERIC_ENC4 = 25
GENERIC_ENC5 = 26
GENERIC_ENC6 = 27
GENERIC_ENC7 = 28
GENERIC_ENC8 = 29
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 12
GENERIC_SLI2 = 13
GENERIC_SLI3 = 14
GENERIC_SLI4 = 15
GENERIC_SLI5 = 16
GENERIC_SLI6 = 17
GENERIC_SLI7 = 18
GENERIC_SLI8 = 19
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = 32
GENERIC_BUT2 = 33
GENERIC_BUT3 = 34
GENERIC_BUT4 = 35
GENERIC_BUT5 = 36
GENERIC_BUT6 = 37
GENERIC_BUT7 = 38
GENERIC_BUT8 = 39
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MPK88/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD,
 'NORELEASE': 0}
DEVICE_CONTROLS = ((GENERIC_ENC1, 0),
 (GENERIC_ENC2, 0),
 (GENERIC_ENC3, 0),
 (GENERIC_ENC4, 0),
 (GENERIC_ENC5, 0),
 (GENERIC_ENC6, 0),
 (GENERIC_ENC7, 0),
 (GENERIC_ENC8, 0))
VOLUME_CONTROLS = ((GENERIC_SLI1, 0),
 (GENERIC_SLI2, 0),
 (GENERIC_SLI3, 0),
 (GENERIC_SLI4, 0),
 (GENERIC_SLI5, 0),
 (GENERIC_SLI6, 0),
 (GENERIC_SLI7, 0),
 (GENERIC_SLI8, 0))
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': GENERIC_PAD5,
 'PREVBANK': GENERIC_PAD1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
PAD_TRANSLATION = ((0, 0, 81, 1),
 (1, 0, 83, 1),
 (2, 0, 84, 1),
 (3, 0, 86, 1),
 (0, 1, 74, 1),
 (1, 1, 76, 1),
 (2, 1, 77, 1),
 (3, 1, 79, 1),
 (0, 2, 67, 1),
 (1, 2, 69, 1),
 (2, 2, 71, 1),
 (3, 2, 72, 1),
 (0, 3, 60, 1),
 (1, 3, 62, 1),
 (2, 3, 64, 1),
 (3, 3, 65, 1))
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'Akai MPK88',
 'OUTPUTPORT': 'Akai MPK88',
 'CHANNEL': 0,
 'PAD_TRANSLATION': PAD_TRANSLATION}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': -1,
 'NOTOGGLE': 0}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MPK88/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = 117
GENERIC_PLAY = 118
GENERIC_REC = 119
GENERIC_LOOP = -1
GENERIC_RWD = 115
GENERIC_FFWD = 116
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 22
GENERIC_ENC2 = 23
GENERIC_ENC3 = 24
GENERIC_ENC4 = 25
GENERIC_ENC5 = 26
GENERIC_ENC6 = 27
GENERIC_ENC7 = 28
GENERIC_ENC8 = 29
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 12
GENERIC_SLI2 = 13
GENERIC_SLI3 = 14
GENERIC_SLI4 = 15
GENERIC_SLI5 = 16
GENERIC_SLI6 = 17
GENERIC_SLI7 = 18
GENERIC_SLI8 = 19
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = 32
GENERIC_BUT2 = 33
GENERIC_BUT3 = 34
GENERIC_BUT4 = 35
GENERIC_BUT5 = 36
GENERIC_BUT6 = 37
GENERIC_BUT7 = 38
GENERIC_BUT8 = 39
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MPK_mini/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': -1,
 'PLAY': -1,
 'REC': -1,
 'LOOP': -1,
 'RWD': -1,
 'FFWD': -1}
DEVICE_CONTROLS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
VOLUME_CONTROLS = ((-1, -1),
 (-1, -1),
 (-1, -1),
 (-1, -1),
 (-1, -1),
 (-1, -1),
 (-1, -1),
 (-1, -1))
TRACKARM_CONTROLS = (-1, -1, -1, -1, -1, -1, -1, -1)
BANK_CONTROLS = {'TOGGLELOCK': -1,
 'BANKDIAL': -1,
 'NEXTBANK': -1,
 'PREVBANK': -1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
PAD_TRANSLATION = ((0, 0, 36, 0),
 (1, 0, 37, 0),
 (2, 0, 38, 0),
 (3, 0, 39, 0),
 (0, 1, 32, 0),
 (1, 1, 33, 0),
 (2, 1, 34, 0),
 (3, 1, 35, 0),
 (0, 2, 48, 0),
 (1, 2, 49, 0),
 (2, 2, 50, 0),
 (3, 2, 51, 0),
 (0, 3, 44, 0),
 (1, 3, 45, 0),
 (2, 3, 46, 0),
 (3, 3, 47, 0))
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'MPK mini',
 'OUTPUTPORT': 'MPK mini',
 'CHANNEL': -1,
 'PAD_TRANSLATION': PAD_TRANSLATION}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': -1}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/MPK_mini/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = 23
GENERIC_PLAY = 24
GENERIC_REC = 25
GENERIC_LOOP = 20
GENERIC_RWD = 21
GENERIC_FFWD = 22
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 1
GENERIC_ENC2 = 2
GENERIC_ENC3 = 3
GENERIC_ENC4 = 4
GENERIC_ENC5 = 5
GENERIC_ENC6 = 6
GENERIC_ENC7 = 7
GENERIC_ENC8 = 8
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 110
GENERIC_SLI2 = 111
GENERIC_SLI3 = 112
GENERIC_SLI4 = 113
GENERIC_SLI5 = 114
GENERIC_SLI6 = 115
GENERIC_SLI7 = 116
GENERIC_SLI8 = 117
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = 52
GENERIC_BUT2 = 53
GENERIC_BUT3 = 54
GENERIC_BUT4 = 55
GENERIC_BUT5 = 56
GENERIC_BUT6 = 57
GENERIC_BUT7 = 58
GENERIC_BUT8 = 59
GENERIC_BUT9 = 60
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = 80
GENERIC_PAD2 = 81
GENERIC_PAD3 = 82
GENERIC_PAD4 = 83
GENERIC_PAD5 = 85
GENERIC_PAD6 = 86
GENERIC_PAD7 = 87
GENERIC_PAD8 = 88
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = ._DeviceController
                        	   2          R  :TEXT!Rch                                  2                                                                                                                                                                                                                                                     /Applications/TextMate.app                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                2<    2  usro   
      4
########NEW FILE########
__FILENAME__ = apihelper

def print_api(object, object_name, path):
	inf = info(object)
	if (inf != ""):
		file = open(path+object_name+".txt", 'w')
		print type(object)
		file.write(inf)
		file.close()
		for oname in dir(object):
			if (oname.find("__") < 0):
				o = getattr(object, oname)
				c = 0
				if ("ABCDEFGHIJKLMNOPQRSTVWXYZ".find(oname[0]) < 0):
					c += 1
				else:
					for ooname in dir(o):
						if (ooname == "__call__"):
							c += 1
						if (ooname == object_name):
							c += 1
				if (c == 0):
					print_api(o, oname, path+object_name+".")

def info(object, spacing = 30, collapse = 1, built_in = False):
	processFunc = collapse and (lambda s: " ".join(s.split())) or (lambda s: s)
	methods = "";
	properties = "";
	for oname in dir(object):
		if ((built_in) or (oname.find("__") < 0)):
			o = getattr(object, oname)
			line = "\n"+oname.ljust(spacing)+" "+processFunc(str(o.__doc__))
			if (callable(o)):
				methods += line
			else:
				properties += line
	text = ""
	if (methods):
		text += methods+"\n"
	if (properties):
		text += properties+"\n"
	return text

def info2(object, spacing=10, collapse=1):
	"""Print methods and doc strings.

	Takes module, class, list, dictionary, or string."""
	methodList = [e for e in dir(object) if callable(getattr(object, e))]
	processFunc = collapse and (lambda s: " ".join(s.split())) or (lambda s: s)
	methods = ("\n".join(["%s %s" %
					 (method.ljust(spacing),
					  processFunc(str(getattr(object, method).__doc__)))
					 for method in methodList]))

	attribList = [e for e in dir(object) if (not callable(getattr(object, e)))]
	processFunc = collapse and (lambda s: " ".join(s.split())) or (lambda s: s)
	attribs = ("\n".join(["%s %s" %
					 (attrib.ljust(spacing),
					  processFunc(str(getattr(object, attrib).__doc__)))
					 for attrib in attribList]))
	return methods+"\n\n"+attribs+"\n\n"

#if __name__ == "__main__":
#	print help.__doc__

########NEW FILE########
__FILENAME__ = consts
#
# Copyright (C) 2009 Guillermo Ruiz Troyano
#
# This file is part of Nocturn Remote Script for Live (Nocturn RS4L).
#
#    Nocturn RS4L is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Nocturn RS4L is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Nocturn RS4L.  If not, see <http://www.gnu.org/licenses/>.
#
# Contact info:
#    Guillermo Ruiz Troyano, ruiztroyano@gmail.com
#

NOTE_OFF_STATUS = 128
NOTE_ON_STATUS = 144
CC_STATUS = 176
PB_STATUS = 224
NUM_NOTES = 127
NUM_CC_NO = 127
NUM_CHANNELS = 16
STATUS_ON = 127
STATUS_OFF = 0

NUM_STRIPS = 8

VOL_CH = 0
PAN_CH = 0
MASTER_CH = 0
DEV_CH = 1
SEND_CH = 2
SCENE_CH = 3
PLAYING_CH = 3
TRANSPORT_CH = 3
ARM_CH = 1
SOLO_CH = 0
MUTE_CH = 0
BANK_CH = 2
DEV_BANK_CH = 1
VOL_BASE_CC = 0
PAN_BASE_CC = 8
MASTER_BASE_CC = 16
SEND_BASE_CC = 0
DEV_BASE_CC = 0
SCENE_BASE_CC = 0
ARM_BASE_NO = 0
SOLO_BASE_NO = 8
MUTE_BASE_NO = 16
BANK_BASE_NO = 32
DEV_BANK_BASE_NO = 24
MASTER_BASE_NO = 40
SCENE_BASE_NO = 56
PLAYING_BASE_NO = 64
TRANSPORT_BASE_NO = 91

########NEW FILE########
__FILENAME__ = DeviceController
#
# Copyright (C) 2009 Guillermo Ruiz Troyano
#
# This file is part of Nocturn Remote Script for Live (Nocturn RS4L).
#
#    Nocturn RS4L is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Nocturn RS4L is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Nocturn RS4L.  If not, see <http://www.gnu.org/licenses/>.
#
# Contact info:
#    Guillermo Ruiz Troyano, ruiztroyano@gmail.com
# Revision 2009-09-01:
#    Bug fixed, Guillermo Ruiz Troyano
#

import Live
from NocturnComponent import NocturnComponent
from _Generic.Devices import *
from consts import *
class DeviceController(NocturnComponent):
    __module__ = __name__
    __doc__ = "Control device parameters."
    
    def __init__(self, nocturn_parent):
        NocturnComponent.__init__(self, nocturn_parent)
        self._bank_index = 0
        self._num_banks = 0

    def disconnect(self):
        pass

    def device(self):
        return self.song().appointed_device
        
    def set_appointed_device(self, device):
        self.request_rebuild_midi_map()

    def lock_to_device(self, device):
        pass

    def unlock_from_device(self, device):
        pass

    def receive_note(self, channel, note, vel):
        if (channel == DEV_BANK_CH):
            index = note-DEV_BANK_BASE_NO
            if ((index >= 0) and (index < NUM_STRIPS)):
                if (index < self._num_banks):
                    self._bank_index = index
                    self.request_rebuild_midi_map()
                else:
                    self.send_midi((NOTE_ON_STATUS+DEV_BANK_CH,DEV_BANK_BASE_NO+index,0))

    def build_midi_map(self, script_handle, midi_map_handle):
        dev = self.device()
        if (dev):
            map_mode = Live.MidiMap.MapMode.absolute
            feedback_rule = Live.MidiMap.CCFeedbackRule()
            feedback_rule.delay_in_ms = 0
            feedback_rule.cc_value_map = tuple()
            feedback_rule.channel = DEV_CH
            
            params = 0
            if (list(DEVICE_DICT.keys()).count(dev.class_name) > 0):
                param_banks = DEVICE_DICT[dev.class_name]
                self._num_banks = len(param_banks)
                params = param_banks[self._bank_index]
            else:
                self._num_banks = int((len(dev.parameters)+NUM_STRIPS-2)/NUM_STRIPS)

            for index in range(0,NUM_STRIPS):
                if ((params and (index < len(params))) or (index+self._bank_index*NUM_STRIPS+1 < len(dev.parameters))):
                    parameter = 0
                    if (params):
                        parameter = get_parameter_by_name(dev, params[index])
                    else:
                        parameter = dev.parameters[index+self._bank_index*NUM_STRIPS+1]
                    feedback_rule.cc_no = DEV_BASE_CC+index
                    if (parameter):
                        self.map_parameter(midi_map_handle, parameter, feedback_rule)
                else:
                    Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, DEV_CH, DEV_BASE_CC+index)
                    self.send_midi((CC_STATUS+DEV_CH,DEV_BASE_CC+index,0))

                Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, DEV_BANK_CH, DEV_BANK_BASE_NO+index)
                is_bank = (index == self._bank_index)
                self.send_midi((NOTE_ON_STATUS+DEV_BANK_CH,DEV_BANK_BASE_NO+index,is_bank and 127))


########NEW FILE########
__FILENAME__ = MixerController
#
# Copyright (C) 2009 Guillermo Ruiz Troyano
#
# This file is part of Nocturn Remote Script for Live (Nocturn RS4L).
#
#    Nocturn RS4L is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Nocturn RS4L is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Nocturn RS4L.  If not, see <http://www.gnu.org/licenses/>.
#
# Contact info:
#    Guillermo Ruiz Troyano, ruiztroyano@gmail.com
#

import Live
import Nocturn
from NocturnComponent import NocturnComponent
from consts import *
class MixerController(NocturnComponent):
    __module__ = __name__
    __doc__ = "Control volume, panning, sends, mute, solo, channel bank, return and master section."
    
    def __init__(self, nocturn_parent):
        NocturnComponent.__init__(self, nocturn_parent)
        self._arm_enabled = True
        self.tracks = self.bank_tracks()
        self._add_listeners()

    def disconnect(self):
        self._remove_listeners()

    def _add_listeners(self):
        if (not self.song().visible_tracks_has_listener(self._on_visible_tracks_changed)):
            self.song().add_visible_tracks_listener(self._on_visible_tracks_changed)
        if (not self.song().view.selected_track_has_listener(self._on_selected_track)):
            self.song().add_nudge_down_listener(self._on_nudge_down)
        if (not self.song().nudge_down_has_listener(self._on_nudge_down)):
            self.song().add_nudge_up_listener(self._on_nudge_up)
        if (not self.song().nudge_up_has_listener(self._on_nudge_up)):
            self.song().view.add_selected_track_listener(self._on_selected_track)
    
    def _remove_listeners(self):
        self._remove_track_listeners()
        if (self.song().visible_tracks_has_listener(self._on_visible_tracks_changed)):
            self.song().remove_visible_tracks_listener(self._on_visible_tracks_changed)
        if (self.song().view.selected_track_has_listener(self._on_selected_track)):
            self.song().view.remove_selected_track_listener(self._on_selected_track)
        if (self.song().nudge_down_has_listener(self._on_nudge_down)):
            self.song().remove_nudge_down_listener(self._on_nudge_down)
        if (self.song().nudge_up_has_listener(self._on_nudge_up)):
            self.song().remove_nudge_up_listener(self._on_nudge_up)
    
    def _add_track_listeners(self):
        for t in self.tracks:
            if (t.can_be_armed and (not t.arm_has_listener(self._on_arm_changed))):
                t.add_arm_listener(self._on_arm_changed)
            if (not t.solo_has_listener(self._on_solo_changed)):
                t.add_solo_listener(self._on_solo_changed)
            if (not t.mute_has_listener(self._on_mute_changed)):
                t.add_mute_listener(self._on_mute_changed)
            if (not t.current_input_routing_has_listener(self._on_input_routing_changed)):
                t.add_current_input_routing_listener(self._on_input_routing_changed)
    
    def _remove_track_listeners(self):
        for t in self.tracks:
            if (t):
                if (t.can_be_armed and t.arm_has_listener(self._on_arm_changed)):
                    t.remove_arm_listener(self._on_arm_changed)
                if (t.mute_has_listener(self._on_mute_changed)):
                    t.remove_mute_listener(self._on_mute_changed)
                if (t.solo_has_listener(self._on_solo_changed)):
                    t.remove_solo_listener(self._on_solo_changed)
                if (t.current_input_routing_has_listener(self._on_input_routing_changed)):
                    t.remove_current_input_routing_listener(self._on_input_routing_changed)
    
    
    def receive_pitchbend(self, channel, pb_value):
        val = (pb_value-8192.0)/8192.0
        self.song().master_track.mixer_device.crossfader.value = val
    
    def receive_midi_cc(self, channel, cc_no, cc_value):
        if ((channel == MASTER_CH) and (cc_no == MASTER_BASE_CC+7)):
            if (cc_value < 64):
                self.song().tempo += 1
            else:
                self.song().tempo -= 1
    
    def receive_note(self, channel, note, velocity):
        if ((channel == ARM_CH) and (note >= ARM_BASE_NO) and (note < ARM_BASE_NO+NUM_STRIPS)):
            i = note-ARM_BASE_NO
            if (i < len(self.tracks)):
                t = self.tracks[i]
                if (self._arm_enabled):
                    arm = (velocity > 0)
                    self.arm_track(t, arm)
                    if (not t.can_be_armed):
                        self.send_midi((NOTE_ON_STATUS+ARM_CH, ARM_BASE_NO+i, 0))
                self.select_track(t)
            elif (velocity > 0):
                self.send_midi((NOTE_ON_STATUS+ARM_CH, ARM_BASE_NO+i, 0))
        elif ((channel == SOLO_CH) and (note >= SOLO_BASE_NO) and (note < SOLO_BASE_NO+NUM_STRIPS)):
            i = note-SOLO_BASE_NO;
            if (i < len(self.tracks)):
                solo = (velocity > 0)
                self.solo_track(self.tracks[i], solo)
            elif (velocity > 0):
                self.send_midi((NOTE_ON_STATUS+SOLO_CH, SOLO_BASE_NO+i, 0))
        elif ((channel == MUTE_CH) and (note >= MUTE_BASE_NO) and (note < MUTE_BASE_NO+NUM_STRIPS)):
            i = note-MUTE_BASE_NO;
            if (i < len(self.tracks)):
                mute = (velocity == 0)
                self.mute_track(self.tracks[i], mute)   
            elif (velocity > 0):
                self.send_midi((NOTE_ON_STATUS+MUTE_CH, MUTE_BASE_NO+i, 0))
        elif ((channel == BANK_CH) and (note >= BANK_BASE_NO) and (note < BANK_BASE_NO+NUM_STRIPS)):
            i = note-BANK_BASE_NO;
            if (i*NUM_STRIPS < len(self.song().visible_tracks)):
                self.set_track_bank(i)
                if (velocity == 0):
                    self.send_midi((NOTE_ON_STATUS+BANK_CH, BANK_BASE_NO+i, 127))
            else:
                self.send_midi((NOTE_ON_STATUS+BANK_CH, BANK_BASE_NO+i, 0))
        elif (channel == MASTER_CH):
            if ((note >= MASTER_BASE_NO) and (note < MASTER_BASE_NO+4)):
                i = note-MASTER_BASE_NO;
                if (i < len(self.song().return_tracks)):
                    mute = (velocity == 0)
                    self.mute_track(self.song().return_tracks[i], mute) 
                elif (velocity > 0):
                    self.send_midi((NOTE_ON_STATUS+MASTER_CH, MASTER_BASE_NO+i, 0))
            elif (note == MASTER_BASE_NO+4):
                self._arm_enabled = (velocity > 0)
            elif (note == MASTER_BASE_NO+5):
                self.song().nudge_down = (velocity > 0)
            elif (note == MASTER_BASE_NO+6):
                self.song().nudge_up = (velocity > 0)
            elif (note == MASTER_BASE_NO+7):
                self.song().tap_tempo()
                self.send_midi((NOTE_ON_STATUS+MASTER_CH,MASTER_BASE_NO+7,0))
        
    
    def select_track(self, track):
        if (not self._arm_enabled):
            for i in range(0,NUM_STRIPS):
                if ((i >= len(self.tracks)) or (track != self.tracks[i])):
                    self.send_midi((NOTE_ON_STATUS+ARM_CH,ARM_BASE_NO+i,0))
        track.view.select_instrument()
        self.song().view.selected_track = track
    
    def arm_track(self, track, arm):
        if (self.song().exclusive_arm):
            for t in self.tracks:
                if ((t.can_be_armed) and (t != track) and (t.arm)):
                    t.arm = False
        if ((track.can_be_armed) and (track.arm != arm)):
            track.arm = arm

    def mute_track(self, track, mute):
        if (track.mute != mute):
            track.mute = mute

    def solo_track(self, track, solo):
        if (self.song().exclusive_solo):
            for t in self.song().tracks:
                if ((t != track) and (t.solo)):
                    t.solo = 0
        if (track.solo != solo):
            track.solo = solo


    def build_midi_map(self, script_handle, midi_map_handle):
        self._remove_track_listeners()
        self.tracks = self.bank_tracks()
        self._add_track_listeners()

        map_mode = Live.MidiMap.MapMode.absolute
        num_sends = 0
        feedback_rule = Live.MidiMap.CCFeedbackRule()
        feedback_rule.delay_in_ms = 0
        feedback_rule.cc_value_map = tuple()
        
        for index in range(0,NUM_STRIPS):
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, ARM_CH, ARM_BASE_NO+index)
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, SOLO_CH, SOLO_BASE_NO+index)
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, MUTE_CH, MUTE_BASE_NO+index)
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, BANK_CH, BANK_BASE_NO+index)
            Live.MidiMap.forward_midi_pitchbend(script_handle, midi_map_handle, VOL_CH)
            if (DEV_CH != VOL_CH):
                Live.MidiMap.forward_midi_pitchbend(script_handle, midi_map_handle, DEV_CH)
            if ((SEND_CH != VOL_CH) and (SEND_CH != DEV_CH)):
                Live.MidiMap.forward_midi_pitchbend(script_handle, midi_map_handle, SEND_CH)
            if ((SCENE_CH != VOL_CH) and (SCENE_CH != DEV_CH) and (SCENE_CH != SEND_CH)):
                Live.MidiMap.forward_midi_pitchbend(script_handle, midi_map_handle, SCENE_CH)

            if (index < len(self.tracks)):
                t = self.tracks[index]
                feedback_rule.channel = VOL_CH
                feedback_rule.cc_no = VOL_BASE_CC+index
                self.map_parameter(midi_map_handle, t.mixer_device.volume, feedback_rule)
                feedback_rule.channel = PAN_CH
                feedback_rule.cc_no = PAN_BASE_CC+index;
                self.map_parameter(midi_map_handle, t.mixer_device.panning, feedback_rule)
                feedback_rule.channel = SEND_CH
                for send_index in range(0,4):
                    cc_no = SEND_BASE_CC+index+(send_index*NUM_STRIPS)
                    if (send_index < len(t.mixer_device.sends)):
                        feedback_rule.cc_no = cc_no
                        self.map_parameter(midi_map_handle, t.mixer_device.sends[send_index], feedback_rule)
                    else:
                        self.send_midi((CC_STATUS+SEND_CH,SEND_BASE_CC+index+(send_index*NUM_STRIPS),0))
            else:
                self.send_midi((CC_STATUS+VOL_CH,VOL_BASE_CC+index,0))          
                self.send_midi((CC_STATUS+PAN_CH,PAN_BASE_CC+index,64))         
                for i in range(0,num_sends):
                    self.send_midi((CC_STATUS+SEND_CH,SEND_BASE_CC+index+(i*NUM_STRIPS),0))
        
        feedback_rule.channel = MASTER_CH
        feedback_rule.cc_no = MASTER_BASE_CC
        for index in range(0,4):
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, MASTER_CH, MASTER_BASE_NO+index)
            vel = 0
            if (index < len(self.song().return_tracks)):
                rtn_track = self.song().return_tracks[index]
                self.map_parameter(midi_map_handle, rtn_track.mixer_device.volume, feedback_rule)
                if (not rtn_track.mute):
                    vel = 127
            else:
                self.send_midi((CC_STATUS+MASTER_CH,MASTER_BASE_CC+index,0))
            self.send_midi((NOTE_ON_STATUS+MASTER_CH,MASTER_BASE_NO+index,vel))
            feedback_rule.cc_no += 1
        
        self.map_parameter(midi_map_handle, self.song().master_track.mixer_device.volume, feedback_rule)
        feedback_rule.cc_no += 1
        self.map_parameter(midi_map_handle, self.song().master_track.mixer_device.panning, feedback_rule)
        feedback_rule.cc_no += 1
        self.map_parameter(midi_map_handle, self.song().master_track.mixer_device.cue_volume, feedback_rule)
        Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, MASTER_CH, MASTER_BASE_CC+7)
        self.send_midi((CC_STATUS,MASTER_BASE_CC+7,64))
        for index in range(0,4):
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, MASTER_CH, MASTER_BASE_NO+4+index)
        self.send_midi((NOTE_ON_STATUS,MASTER_BASE_NO+4,self._arm_enabled and 127))
        self._on_nudge_down()
        self._on_nudge_up()
        self.send_midi((NOTE_ON_STATUS,MASTER_BASE_NO+7,0))
        
        self.update_arm_buttons()
        self.update_solo_buttons()
        self.update_mute_buttons()
        self.update_bank_buttons()

    
    def update_arm_buttons(self):
        if (self._arm_enabled):
            for i in range(0,NUM_STRIPS):
                vel = 0
                if (i < len(self.tracks)):
                    t = self.tracks[i]
                    if (t and t.can_be_armed and t.arm):
                        vel = 127
                self.send_midi((NOTE_ON_STATUS+ARM_CH, ARM_BASE_NO+i, vel))
        else:
            for i in range(0,NUM_STRIPS):
                sel = ((i < len(self.tracks)) and (self.tracks[i] == self.song().view.selected_track))
                self.send_midi((NOTE_ON_STATUS+ARM_CH, ARM_BASE_NO+i, sel and 127))

    def update_solo_buttons(self):
        for i in range(0,NUM_STRIPS):
            solo = ((i < len(self.tracks)) and (self.tracks[i].solo))
            self.send_midi((NOTE_ON_STATUS+SOLO_CH, SOLO_BASE_NO+i, solo and 127))

    def update_mute_buttons(self):
        for i in range(0,NUM_STRIPS):
            on = ((i < len(self.tracks)) and (not self.tracks[i].mute))
            self.send_midi((NOTE_ON_STATUS+MUTE_CH, MUTE_BASE_NO+i, on and 127))

    def update_bank_buttons(self):
        for i in range(0,NUM_STRIPS):
            is_bank = (i == self.track_bank_index())
            self.send_midi((NOTE_ON_STATUS+BANK_CH, BANK_BASE_NO+i, is_bank and 127))
    
    
    def on_selected_track_bank(self):
        self.request_rebuild_midi_map()

    def _on_visible_tracks_changed(self):
        self.request_rebuild_midi_map()

    def _on_arm_changed(self):
        self.update_arm_buttons()

    def _on_solo_changed(self):
        self.update_solo_buttons()

    def _on_mute_changed(self):
        self.update_mute_buttons()
    
    def _on_bank_changed(self):
        self.update_bank_buttons()
        
    def _on_input_routing_changed(self):
        self._remove_track_listeners()
        self._add_track_listeners()
    
    def _on_nudge_down(self):
        state = (self.song().nudge_down)
        self.send_midi((NOTE_ON_STATUS,MASTER_BASE_NO+5,state and 127))

    def _on_nudge_up(self):
        state = (self.song().nudge_up)
        self.send_midi((NOTE_ON_STATUS,MASTER_BASE_NO+6,state and 127))

    def _on_selected_track(self):
        self.update_arm_buttons()



########NEW FILE########
__FILENAME__ = Nocturn
#
# Copyright (C) 2009 Guillermo Ruiz Troyano
#
# This file is part of Nocturn Remote Script for Live (Nocturn RS4L).
#
#    Nocturn RS4L is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Nocturn RS4L is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Nocturn RS4L.  If not, see <http://www.gnu.org/licenses/>.
#
# Contact info:
#    Guillermo Ruiz Troyano, ruiztroyano@gmail.com
#

import Live
import MidiRemoteScript
from consts import *
from MixerController import MixerController
from DeviceController import DeviceController
from SceneController import SceneController
from PlayingController import PlayingController
class Nocturn:
	__module__ = __name__
	__doc__ = 'Automap script for the Novation Nocturn.'

	def __init__(self, c_instance):
		self._c_instance = c_instance
		self._base_track_index = 0
		self.mixer_controller = MixerController(self)
		self.device_controller = DeviceController(self)
		self.scene_controller = SceneController(self)
		self.playing_controller = PlayingController(self)
		self._components = [ self.mixer_controller, self.device_controller,
		                     self.scene_controller, self.playing_controller ]
		self.song().add_visible_tracks_listener(self._on_visible_tracks_changed)


	def disconnect(self):
		if (self.song().visible_tracks_has_listener(self._on_visible_tracks_changed)):
			self.song().remove_visible_tracks_listener(self._on_visible_tracks_changed)
		for c in self._components:
			c.disconnect()

	def application(self):
		return Live.Application.get_application()

	def song(self):
		return self._c_instance.song()
	
	def show_message(self, message):
		self._c_instance.show_message(message)
		
	def log(self, message):
	    self._c_instance.log_message(message)

	def suggest_input_port(self):
		return 'Automap MIDI'

	def suggest_output_port(self):
		return 'Automap MIDI'

	def can_lock_to_devices(self):
		return True

	def lock_to_device(self, device):
		if (self.device_controller):
			self.device_controller.lock_to_device(device)
		
	def unlock_from_device(self, device):
		if (self.device_controller):
			self.device_controller.unlock_from_device(device)

	def set_appointed_device(self, device):
		if (self.device_controller):
			self.device_controller.set_appointed_device(device)

	def toggle_lock(self):
	    self._c_instance.toggle_lock()

	def suggest_map_mode(self, cc_no, channel):
		return Live.MidiMap.MapMode.absolute

	def supports_pad_translation(self):
		return False

	def instance_identifier(self):
		return self._c_instance.instance_identifier()

	def connect_script_instances(self, instanciated_scripts):
		pass

	def request_rebuild_midi_map(self):
		self._c_instance.request_rebuild_midi_map()

	def send_midi(self, midi_event_bytes):
		self._c_instance.send_midi(midi_event_bytes)

	def refresh_state(self):
		self.request_rebuild_midi_map()

	def build_midi_map(self, midi_map_handle):
		script_handle = self._c_instance.handle()
		for c in self._components:
			c.build_midi_map(script_handle, midi_map_handle)

	def update_display(self):
		for c in self._components:
			c.update_display()

	def receive_midi(self, midi_bytes):
		if (((midi_bytes[0] & 240) == NOTE_ON_STATUS) or ((midi_bytes[0] & 240) == NOTE_OFF_STATUS)):
			channel = (midi_bytes[0] & 15)
			note = midi_bytes[1]
			velocity = midi_bytes[2]
			for c in self._components:
				c.receive_note(channel, note, velocity)
		elif ((midi_bytes[0] & 240) == CC_STATUS):
			channel = (midi_bytes[0] & 15)
			cc_no = midi_bytes[1]
			cc_value = midi_bytes[2]
			for c in self._components:
				c.receive_midi_cc(channel, cc_no, cc_value)
		elif ((midi_bytes[0] & 240) == PB_STATUS):
			channel = (midi_bytes[0] & 15)
			pb_value = (midi_bytes[2]<<7)+midi_bytes[1]
			for c in self._components:
				c.receive_pitchbend(channel, pb_value)

	
	def bank_tracks(self):
		end = min(self._base_track_index+NUM_STRIPS,len(self.song().visible_tracks));
		return self.song().visible_tracks[self._base_track_index:end]
	
	def bank_clip_slots(self):
		scn_index = list(self.song().scenes).index(self.song().view.selected_scene)
		tracks = self.bank_tracks()
		slots = list()
		for t in tracks:
			slots.append(t.clip_slots[scn_index])
		return slots
		
	def track_bank_index(self):
		return self._base_track_index/NUM_STRIPS
	
	def set_track_bank(self, index):
		index *= NUM_STRIPS
		old_index = self._base_track_index
		self._base_track_index = (index < len(self.song().visible_tracks)) and index
		if (self._base_track_index != old_index):
			for c in self._components:
				c.on_selected_track_bank()


	def _on_visible_tracks_changed(self):
		self.set_track_bank(self.track_bank_index())


########NEW FILE########
__FILENAME__ = NocturnComponent
#
# Copyright (C) 2009 Guillermo Ruiz Troyano
#
# This file is part of Nocturn Remote Script for Live (Nocturn RS4L).
#
#    Nocturn RS4L is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Nocturn RS4L is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Nocturn RS4L.  If not, see <http://www.gnu.org/licenses/>.
#
# Contact info:
#    Guillermo Ruiz Troyano, ruiztroyano@gmail.com
#

import Live
from consts import *
class NocturnComponent:
    __module__ = __name__
    __doc__ = "Base class for a component."
    
    def __init__(self, nocturn_parent):
        self._parent = nocturn_parent

    def disconnect(self):
        pass

    def parent(self):
        return self._parent
    
    def application(self):
        return self._parent.application()

    def song(self):
        return self._parent.song()
        
    def show_message(self, message):
        self._parent.show_message(message)
        
    def log(self, message):
        self._parent.log(message)

    def request_rebuild_midi_map(self):
        self._parent.request_rebuild_midi_map()
    
    def refresh_state(self):
        pass

    def update_display(self):
        pass

    def send_midi(self, midi_event_bytes):
        self._parent.send_midi(midi_event_bytes)

    
    def track_bank_index(self):
        return self._parent.track_bank_index()
    
    def bank_tracks(self):
        return self._parent.bank_tracks()
    
    def bank_clip_slots(self):
        return self._parent.bank_clip_slots()
    
    def set_track_bank(self, index):
        self._parent.set_track_bank(index)
    
    def map_parameter(self, midi_map_handle, parameter, feedback_rule):
        Live.MidiMap.map_midi_cc_with_feedback_map(midi_map_handle, parameter, feedback_rule.channel, feedback_rule.cc_no, Live.MidiMap.MapMode.absolute, feedback_rule, False)
        Live.MidiMap.send_feedback_for_parameter(midi_map_handle, parameter)


    def receive_pitchbend(self, channel, pb_value):
        pass
    
    def receive_midi_cc(self, channel, cc_no, cc_value):
        pass
        
    def receive_note(self, channel, note, velocity):
        pass        
    
    def build_midi_map(self, script_handle, midi_map_handle):
        pass
        
    def on_selected_track_bank(self):
        pass

########NEW FILE########
__FILENAME__ = PlayingController
#
# Copyright (C) 2009 Guillermo Ruiz Troyano
#
# This file is part of Nocturn Remote Script for Live (Nocturn RS4L).
#
#    Nocturn RS4L is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Nocturn RS4L is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Nocturn RS4L.  If not, see <http://www.gnu.org/licenses/>.
#
# Contact info:
#    Guillermo Ruiz Troyano, ruiztroyano@gmail.com
# Revision 2009-10-12:
#    Transport controls added.
#    Free buttons of User section (last page) now stop all clips.
#

import Live
from consts import *
from NocturnComponent import NocturnComponent
class PlayingController(NocturnComponent):
    __module__ = __name__
    __doc__ = "Buttons that show when a track is playing a clip."
    
    def __init__(self, nocturn_parent):
        NocturnComponent.__init__(self, nocturn_parent)
        self._refresh_count = 0
        self.playing_slots = list()
        self._add_listeners()

    def disconnect(self):
        self._remove_listeners()

    
    def _add_listeners(self):
        if (not self.song().visible_tracks_has_listener(self._on_visible_tracks_changed)):
            self.song().add_visible_tracks_listener(self._on_visible_tracks_changed)
        if (not self.song().view.selected_scene_has_listener(self._on_selected_scene)):
            self.song().view.add_selected_scene_listener(self._on_selected_scene)
        if (not self.song().metronome_has_listener(self._on_metronome)):
            self.song().add_metronome_listener(self._on_metronome)
        if (not self.song().is_playing_has_listener(self._on_is_playing)):
            self.song().add_is_playing_listener(self._on_is_playing)
        if (not self.song().record_mode_has_listener(self._on_record_mode)):
            self.song().add_record_mode_listener(self._on_record_mode)
        if (not self.song().overdub_has_listener(self._on_overdub)):
            self.song().add_overdub_listener(self._on_overdub)
        if (not self.song().punch_in_has_listener(self._on_punch_in)):
            self.song().add_punch_in_listener(self._on_punch_in)
        if (not self.song().loop_has_listener(self._on_loop)):
            self.song().add_loop_listener(self._on_loop)
        if (not self.song().punch_out_has_listener(self._on_punch_out)):
            self.song().add_punch_out_listener(self._on_punch_out)
        
    def _remove_listeners(self):
        self._remove_clip_listeners()
        if (self.song().view.selected_scene_has_listener(self._on_selected_scene)):
            self.song().view.remove_selected_scene_listener(self._on_selected_scene)
        if (self.song().visible_tracks_has_listener(self._on_visible_tracks_changed)):
            self.song().remove_visible_tracks_listener(self._on_visible_tracks_changed)
        if (self.song().metronome_has_listener(self._on_metronome)):
            self.song().remove_metronome_listener(self._on_metronome)
        if (self.song().is_playing_has_listener(self._on_is_playing)):
            self.song().remove_is_playing_listener(self._on_is_playing)
        if (self.song().record_mode_has_listener(self._on_record_mode)):
            self.song().remove_record_mode_listener(self._on_record_mode)
        if (self.song().overdub_has_listener(self._on_overdub)):
            self.song().remove_overdub_listener(self._on_overdub)
        if (self.song().punch_in_has_listener(self._on_punch_in)):
            self.song().remove_punch_in_listener(self._on_punch_in)
        if (self.song().loop_has_listener(self._on_loop)):
            self.song().remove_loop_listener(self._on_loop)
        if (self.song().punch_out_has_listener(self._on_punch_out)):
            self.song().remove_punch_out_listener(self._on_punch_out)
    
    def _add_clip_listeners(self):
        for slot in self.playing_slots:
            if (not slot.has_clip_has_listener(self._on_has_clip)):
                slot.add_has_clip_listener(self._on_has_clip)
            if (slot.has_clip):
                if (not slot.clip.playing_status_has_listener(self._on_playing_status)):
                    slot.clip.add_playing_status_listener(self._on_playing_status)
            else:
                if (not slot.playing_status_has_listener(self._on_playing_status)):
                    slot.add_playing_status_listener(self._on_playing_status)

    def _remove_clip_listeners(self):
        for slot in self.playing_slots:
            if (slot):
                if (slot.has_clip_has_listener(self._on_has_clip)):
                    slot.remove_has_clip_listener(self._on_has_clip)
                if (slot.has_clip):
                    if (slot.clip.playing_status_has_listener(self._on_playing_status)):
                        slot.clip.remove_playing_status_listener(self._on_playing_status)
                else:
                    if (slot.playing_status_has_listener(self._on_playing_status)):
                        slot.remove_playing_status_listener(self._on_playing_status)

    def _setup_playing_clips(self):
        self._remove_clip_listeners()
        self.playing_slots = self.bank_clip_slots()
        tracks = self.bank_tracks()
        for i in range(0,len(self.playing_slots)):
            for s in tracks[i].clip_slots:
                if ((s.playing_status > 0) or (s.has_clip and s.clip.is_playing)):
                    self.playing_slots[i] = s
        self._add_clip_listeners()
        
    
    def build_midi_map(self, script_handle, midi_map_handle):
        self._setup_playing_clips()
        for index in range(0,NUM_STRIPS):
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, PLAYING_CH, PLAYING_BASE_NO+index)
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, TRANSPORT_CH, TRANSPORT_BASE_NO+index)
        self.update_metronome()
        self.update_is_playing()
        self.update_record_mode()
        self.update_overdub()
        self.update_punch_in()
        self.update_loop()
        self.update_punch_out()
        self.update_playing_buttons()

    
    def receive_note(self, channel, note, vel):
        if (channel == PLAYING_CH):
            index = note-PLAYING_BASE_NO
            if ((index >= 0) and (index < NUM_STRIPS)):
                vel = 0
                if (index < len(self.playing_slots)):
                    slot = self.playing_slots[index]
                    playing = (((slot.has_clip) and (slot.clip.is_playing)) or (slot.playing_status > 0))
                    if (playing):
                        slot.stop()
                        vel = 127
                    else:
                        slot.fire()
                else:
                    self.song().master_track.stop_all_clips()
                self.send_midi((NOTE_ON_STATUS+PLAYING_CH, note, vel))
        if (channel == TRANSPORT_CH):
            index = note-TRANSPORT_BASE_NO
            if ((index >= 0) and (index < NUM_STRIPS)):
                if (index == 0):
                    self.song().metronome = vel and True
                elif (index == 1):
                    self.song().start_playing()
                    if (vel == 0):
                        self.update_is_playing()
                elif (index == 2):
                    self.song().stop_playing()
                elif (index == 3):
                    self.song().record_mode = vel and True
                elif (index == 4):
                    self.song().overdub = vel and True
                elif (index == 5):
                    self.song().punch_in = vel and True
                elif (index == 6):
                    self.song().loop = vel and True
                elif (index == 7):
                    self.song().punch_out = vel and True

    def update_display(self):
        self._refresh_count += 1
        tracks = self.bank_tracks()
        for index in range(0,len(self.playing_slots)):
            track = tracks[index]
            if (track.fired_slot_index != -1):
                vel = 0
                if (self._refresh_count&3 == 0):
                    self._refresh_count = 0
                    self.send_midi((NOTE_ON_STATUS+PLAYING_CH, PLAYING_BASE_NO+index, 127))
                elif (self._refresh_count&1 == 0):
                    self.send_midi((NOTE_ON_STATUS+PLAYING_CH, PLAYING_BASE_NO+index, 0))
    
    def update_playing_buttons(self):
        for index in range(0,NUM_STRIPS):
            state = False
            if (index < len(self.playing_slots)):
                slot = self.playing_slots[index]
                state = (((slot.has_clip) and (slot.clip.is_playing)) or (slot.playing_status > 0))
            self.send_midi((NOTE_ON_STATUS+PLAYING_CH, PLAYING_BASE_NO+index, state and 127))
    
    def _on_visible_tracks_changed(self):
        self._setup_playing_clips()
        self.update_playing_buttons()
 
    def on_selected_track_bank(self):
        self._setup_playing_clips()
        self.update_playing_buttons()

    def _on_selected_scene(self):
        self._setup_playing_clips()
            
    def _on_playing_status(self):
        self._setup_playing_clips()
        self.update_playing_buttons()
    
    def _on_has_clip(self):
        self._remove_clip_listeners()
        self._add_clip_listeners()
        
    def update_metronome(self):
        state = self.song().metronome
        self.send_midi((NOTE_ON_STATUS+TRANSPORT_CH, TRANSPORT_BASE_NO, state and 127))

    def update_is_playing(self):
        state = self.song().is_playing
        self.send_midi((NOTE_ON_STATUS+TRANSPORT_CH, TRANSPORT_BASE_NO+1, state and 127))

    def update_record_mode(self):
        state = self.song().record_mode
        self.send_midi((NOTE_ON_STATUS+TRANSPORT_CH, TRANSPORT_BASE_NO+3, state and 127))

    def update_overdub(self):
        state = self.song().overdub
        self.send_midi((NOTE_ON_STATUS+TRANSPORT_CH, TRANSPORT_BASE_NO+4, state and 127))

    def update_punch_in(self):
        state = self.song().punch_in
        self.send_midi((NOTE_ON_STATUS+TRANSPORT_CH, TRANSPORT_BASE_NO+5, state and 127))

    def update_loop(self):
        state = self.song().loop
        self.send_midi((NOTE_ON_STATUS+TRANSPORT_CH, TRANSPORT_BASE_NO+6, state and 127))

    def update_punch_out(self):
        state = self.song().punch_out
        self.send_midi((NOTE_ON_STATUS+TRANSPORT_CH, TRANSPORT_BASE_NO+7, state and 127))
        
    def _on_metronome(self):
        self.update_metronome()

    def _on_is_playing(self):
        self.update_is_playing()

    def _on_record_mode(self):
        self.update_record_mode()

    def _on_overdub(self):
        self.update_overdub()

    def _on_punch_in(self):
        self.update_punch_in()
        
    def _on_loop(self):
        self.update_loop()

    def _on_punch_out(self):
        self.update_punch_out()

########NEW FILE########
__FILENAME__ = SceneController
#
# Copyright (C) 2009 Guillermo Ruiz Troyano
#
# This file is part of Nocturn Remote Script for Live (Nocturn RS4L).
#
#    Nocturn RS4L is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Nocturn RS4L is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Nocturn RS4L.  If not, see <http://www.gnu.org/licenses/>.
#
# Contact info:
#    Guillermo Ruiz Troyano, ruiztroyano@gmail.com
# Revision 2009-10-14:
#    Loop control improvements, Guillermo R. Troyano
# Revision 2009-10-18:
#    Now it transports MIDI clips, Guillermo R. Troyano
#

import Live
from consts import *
from NocturnComponent import NocturnComponent
class SceneController(NocturnComponent):
    __module__ = __name__
    __doc__ = "Buttons show the playing state of a scene, encoders control scene, track and clip parameters."
    
    def __init__(self, nocturn_parent):
        NocturnComponent.__init__(self, nocturn_parent)
        self._scene_sel_count = 0
        self._track_sel_count = 0
        self._quant_sel_count = 0
        self._refresh_count = 0
        self.scene_slots = self.bank_clip_slots()
        beat = 4.0
        triplet = beat*4.0/3.0
        self._quant_values = [ beat/64.0,
            beat*8, beat*4, beat*2, beat,
            beat/2, triplet/2,
            beat/4, triplet/4.0,
            beat/8.0, triplet/8.0,
            beat/16.0, triplet/16.0,
            beat/32.0 ]
        self._add_listeners()

    def disconnect(self):
        self._remove_listeners()

    
    def _add_listeners(self):
        if (not self.song().visible_tracks_has_listener(self._on_visible_tracks_changed)):
            self.song().add_visible_tracks_listener(self._on_visible_tracks_changed)
        if (not self.song().view.selected_scene_has_listener(self._on_selected_scene)):
            self.song().view.add_selected_scene_listener(self._on_selected_scene)
    
    def _remove_listeners(self):
        self._remove_clip_listeners()
        if (self.song().view.selected_scene_has_listener(self._on_selected_scene)):
            self.song().view.remove_selected_scene_listener(self._on_selected_scene)
        if (self.song().visible_tracks_has_listener(self._on_visible_tracks_changed)):
            self.song().remove_visible_tracks_listener(self._on_visible_tracks_changed)
    
    def _add_clip_listeners(self):
        for slot in self.scene_slots:
            if (not slot.has_clip_has_listener(self._on_has_clip)):
                slot.add_has_clip_listener(self._on_has_clip)
            if (slot.has_clip):
                if (not slot.clip.playing_status_has_listener(self._on_playing_status)):
                    slot.clip.add_playing_status_listener(self._on_playing_status)
            else:
                if (not slot.playing_status_has_listener(self._on_playing_status)):
                    slot.add_playing_status_listener(self._on_playing_status)

    def _remove_clip_listeners(self):
        for slot in self.scene_slots:
            if (slot):
                if (slot.has_clip_has_listener(self._on_has_clip)):
                    slot.remove_has_clip_listener(self._on_has_clip)
                if (slot.has_clip):
                    if (slot.clip.playing_status_has_listener(self._on_playing_status)):
                        slot.clip.remove_playing_status_listener(self._on_playing_status)
                else:
                    if (slot.playing_status_has_listener(self._on_playing_status)):
                        slot.remove_playing_status_listener(self._on_playing_status)

    def setup_clip_slots(self):
        self._remove_clip_listeners()
        self.scene_slots = self.bank_clip_slots()
        self._add_clip_listeners()
    
    
    def build_midi_map(self, script_handle, midi_map_handle):
        self.setup_clip_slots()
        for index in range(0,NUM_STRIPS):
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, SCENE_CH, SCENE_BASE_NO+index)
        for index in range(0,NUM_STRIPS):
            Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, SCENE_CH, SCENE_BASE_CC+index)
            self.send_midi((CC_STATUS+SCENE_CH,SCENE_BASE_CC+index,64))
        self.update_fire_buttons()

    
    def receive_midi_cc(self, channel, cc_no, cc_value):
        if (channel == SCENE_CH):
            if (cc_no == SCENE_BASE_CC):
                self._scene_sel_count += 1
                if (self._scene_sel_count >= 4):
                    index = list(self.song().scenes).index(self.song().view.selected_scene)
                    if (cc_value < 64):
                        index += 1
                    else:
                        index -= 1
                    index = max(0,min(index,len(self.song().scenes)-1))
                    self.song().view.selected_scene = self.song().scenes[index]             
                    self._scene_sel_count = 0
            elif (cc_no == SCENE_BASE_CC+1):
                self._track_sel_count += 1
                if (self._track_sel_count >= 4):
                    tracks = list(self.song().visible_tracks)
                    returns = self.song().return_tracks
                    if (len(returns) > 0):
                        tracks.extend(returns)
                    tracks.append(self.song().master_track)
                    index = tracks.index(self.song().view.selected_track)
                    if (cc_value < 64):
                        index += 1
                    else:
                        index -= 1
                    index = max(0,min(index,len(tracks)-1))
                    detail_clip = self.application().view.is_view_visible('Detail/Clip')
                    self.song().view.selected_track = tracks[index]             
                    self.song().view.selected_track.view.select_instrument()
                    if (detail_clip):
                        self.application().view.show_view('Detail/Clip')
                    self._track_sel_count = 0
            elif (cc_no == SCENE_BASE_CC+2):
                self._quant_sel_count += 1
                if (self._quant_sel_count >= 4):
                    quant = self.song().clip_trigger_quantization
                    index = list(quant.values).index(quant)
                    if (cc_value < 64):
                        index += 1
                    else:
                        index -= 1
                    index = max(0,min(index,len(quant.values)-1))
                    self.song().clip_trigger_quantization = quant.values[index]
                    self._quant_sel_count = 0
            elif (cc_no == SCENE_BASE_CC+3):
                step = self.quantization_step()
                if (cc_value < 64):
                    self.song().scrub_by(step)
                else:
                    self.song().scrub_by(-step)
            elif (cc_no == SCENE_BASE_CC+4):
                clip = self.song().view.detail_clip
                if (clip):
                    step = self.quantization_step()
                    if (cc_value < 64):
                        clip.move_playing_pos(step)
                    else:
                        clip.move_playing_pos(-step)
            elif (cc_no == SCENE_BASE_CC+5):
                clip = self.song().view.detail_clip
                step = self.quantization_step()
                if (clip):
                    div,mod = divmod(clip.loop_start, step)
                    if (cc_value < 64):
                        clip.loop_end += step-mod
                        clip.loop_start += step-mod
                    elif (mod):
                        clip.loop_start -= mod
                        clip.loop_end -= mod
                    elif (div > 0):
                        clip.loop_start -= step
                        clip.loop_end -= step
                else:
                    div,mod = divmod(self.song().loop_start, step)
                    if (cc_value < 64):
                        self.song().loop_start += step-mod
                    elif (mod):
                        self.song().loop_start -= mod
                    elif (div > 0):
                        self.song().loop_start -= step
            elif (cc_no == SCENE_BASE_CC+6):
                clip = self.song().view.detail_clip
                step = self.quantization_step()
                if (clip):
                    div,mod = divmod(clip.loop_end-clip.loop_start, step)
                    if ((cc_value < 64) or (div < 1)):
                        clip.loop_end += step-mod
                    elif (mod):
                        clip.loop_end -= mod
                    elif (div > 1):
                        clip.loop_end -= step
                else:
                    div,mod = divmod(self.song().loop_length, step)
                    if ((cc_value < 64) or (div < 1)):
                        self.song().loop_length += step-mod
                    elif (mod):
                        self.song().loop_length -= mod
                    elif (div > 1):
                        self.song().loop_length -= step
            elif (cc_no == SCENE_BASE_CC+7):
                clip = self.song().view.detail_clip
                if (clip):
                    if (clip.is_audio_clip):
                        if ((cc_value < 64) and (clip.pitch_coarse < 48)):
                            clip.pitch_coarse += 1
                        elif (clip.pitch_coarse > -48):
                            clip.pitch_coarse -= 1
                    else:
                        trans = 1
                        if (cc_value >= 64):
                            trans = -1
                        notes = clip.get_selected_notes()
                        if (len(notes) > 0):
                            notes = self.transpose_notes(notes, trans)
                            if (len(notes) > 0):
                                clip.replace_selected_notes(notes)
                        else:
                            notes = clip.select_all_notes()
                            notes = clip.get_selected_notes()
                            notes = self.transpose_notes(notes, trans)
                            if (len(notes) > 0):
                                clip.replace_selected_notes(notes)
                            clip.deselect_all_notes()
    
    def transpose_notes(self, selection, trans):
        notes = list()
        for note in selection:
            pitch = note[0]+trans
            if ((pitch > 127) or (pitch < 0)):
                return ()
            else:
                notes.append((pitch, note[1], note[2], note[3], note[4]))
        return tuple(notes)
    
    def quantization_step(self):
        index = int(self.song().clip_trigger_quantization)
        step = self._quant_values[index]
        step *= float(self.song().signature_numerator)/self.song().signature_denominator
        return step
    
    def receive_note(self, channel, note, vel):
        if (channel == SCENE_CH):
            index = note-SCENE_BASE_NO
            vel = 0
            if (index < len(self.scene_slots)):
                slot = self.scene_slots[index]
                playing = (((slot.has_clip) and (slot.clip.is_playing)) or (slot.playing_status > 0))
                if (playing):
                    slot.stop()
                    vel = 127
                else:
                    slot.fire()
            elif (index < NUM_STRIPS):
                self.song().view.selected_scene.fire()
            self.send_midi((NOTE_ON_STATUS+SCENE_CH, note, vel)) 
    

    def update_display(self):
        self._refresh_count += 1
        num_slots = len(self.scene_slots)
        for index in range(0,num_slots):
            slot = self.scene_slots[index]
            track = self.bank_tracks()[index]
            if ((slot.is_triggered) or (track.fired_slot_index == -2)):
                vel = 0
                if (self._refresh_count&3 == 0):
                    self._refresh_count = 0
                    self.send_midi((NOTE_ON_STATUS+SCENE_CH, SCENE_BASE_NO+index, 127))
                elif (self._refresh_count&1 == 0):
                    self.send_midi((NOTE_ON_STATUS+SCENE_CH, SCENE_BASE_NO+index, 0))
    
    def update_fire_buttons(self):
        for index in range(0,NUM_STRIPS):
            state = False
            if (index < len(self.scene_slots)):
                slot = self.scene_slots[index]
                state = (((slot.has_clip) and (slot.clip.is_playing)) or (slot.playing_status > 0))
            self.send_midi((NOTE_ON_STATUS+SCENE_CH, SCENE_BASE_NO+index, state and 127))

    def on_selected_track_bank(self):
        self.setup_clip_slots()
        self.update_fire_buttons()

    def _on_selected_scene(self):
        self.setup_clip_slots()
        self.update_fire_buttons()
            
    def _on_playing_status(self):
        self.update_fire_buttons()
    
    def _on_has_clip(self):
        self.setup_clip_slots()
        self.update_fire_buttons()
        
    def _on_visible_tracks_changed(self):
        self.setup_clip_slots()
        self.update_fire_buttons()

########NEW FILE########
__FILENAME__ = EncoderModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Novation_Impulse/EncoderModeSelector.py
import Live
from _Framework.ModeSelectorComponent import ModeSelectorComponent

class EncoderModeSelector(ModeSelectorComponent):
    """ Class that reassigns the given encoders to either device- or mixer control """

    def __init__(self, device, mixer, bank_up_button, bank_down_button, encoders):
        ModeSelectorComponent.__init__(self)
        self._mixer = mixer
        self._device = device
        self._bank_up_button = bank_up_button
        self._bank_down_button = bank_down_button
        self._encoders = encoders
        self._device_button = None
        self._mixer_button = None
        self._device_mode = True
        self._mode_index = 0
        self._number_of_modes = 5
        self._bank_down_button.add_value_listener(self._bank_down_value)
        self._bank_up_button.add_value_listener(self._bank_up_value)
        self.update()

    def disconnect(self):
        self._bank_down_button.remove_value_listener(self._bank_down_value)
        self._bank_up_button.remove_value_listener(self._bank_up_value)
        self.set_device_mixer_buttons(None, None)
        ModeSelectorComponent.disconnect(self)
        self._mixer = None
        self._device = None
        self._bank_up_button = None
        self._bank_down_button = None
        self._encoders = None

    def set_device_mixer_buttons(self, device_button, mixer_button):
        if self._device_button != None:
            if not self._mixer_button != None:
                raise AssertionError
                self._device_button.remove_value_listener(self._device_value)
                self._mixer_button.remove_value_listener(self._mixer_value)
            self._device_button = device_button
            self._mixer_button = mixer_button
            raise self._device_button != None and (self._mixer_button != None or AssertionError)
            self._device_button.add_value_listener(self._device_value)
            self._mixer_button.add_value_listener(self._mixer_value)

    def set_provide_volume_mode(self, provide_volume_mode):
        self._number_of_modes = 6 if provide_volume_mode else 5

    def number_of_modes(self):
        return self._number_of_modes

    def update(self):
        if not self._mode_index in range(self.number_of_modes()):
            raise AssertionError
            if self.is_enabled():
                self._device.set_allow_update(False)
                self._mixer.set_allow_update(False)
                self._device.set_bank_nav_buttons(None, None)
                self._device.set_parameter_controls(())
                for index in range(len(self._encoders)):
                    strip = self._mixer.channel_strip(index)
                    strip.set_pan_control(None)
                    strip.set_send_controls(None)
                    if self.number_of_modes() > 5:
                        strip.set_volume_control(None)

                self._device_mode and self._device.set_bank_nav_buttons(self._bank_down_button, self._bank_up_button)
                self._device.set_parameter_controls(self._encoders)
            else:
                for index in range(len(self._encoders)):
                    strip = self._mixer.channel_strip(index)
                    if self._mode_index == 0:
                        strip.set_pan_control(self._encoders[index])
                    elif self._mode_index < 5:
                        sends = [None,
                         None,
                         None,
                         None]
                        sends[self._mode_index - 1] = self._encoders[index]
                        strip.set_send_controls(tuple(sends))
                    else:
                        strip.set_volume_control(self._encoders[index])

            self._device.set_allow_update(True)
            self._mixer.set_allow_update(True)

    def _bank_down_value(self, value):
        if not value in range(128):
            raise AssertionError
            if self.is_enabled() and not self._device_mode:
                new_mode = (value > 0 or not self._bank_down_button.is_momentary()) and max(self._mode_index - 1, 0)
                self.set_mode(new_mode)

    def _bank_up_value(self, value):
        if not value in range(128):
            raise AssertionError
            if self.is_enabled() and not self._device_mode:
                new_mode = (value > 0 or not self._bank_up_button.is_momentary()) and min(self._mode_index + 1, self.number_of_modes() - 1)
                self.set_mode(new_mode)

    def _device_value(self, value):
        if not value in range(128):
            raise AssertionError
            if self.is_enabled() and not self._device_mode:
                self._device_mode = (value > 0 or not self._device_button.is_momentary()) and True
                self.update()

    def _mixer_value(self, value):
        if not value in range(128):
            raise AssertionError
            if self.is_enabled() and self._device_mode:
                self._device_mode = (value > 0 or not self._mixer_button.is_momentary()) and False
                self.update()
########NEW FILE########
__FILENAME__ = Novation_Impulse
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Novation_Impulse/Novation_Impulse.py
from __future__ import with_statement
import Live
from _Framework.ControlSurface import ControlSurface
from _Framework.InputControlElement import *
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.PhysicalDisplayElement import PhysicalDisplayElement
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.SessionComponent import SessionComponent
from _Framework.DeviceComponent import DeviceComponent
from TransportViewModeSelector import TransportViewModeSelector
from SpecialMixerComponent import SpecialMixerComponent
from ShiftableTransportComponent import ShiftableTransportComponent
from PeekableEncoderElement import PeekableEncoderElement
from EncoderModeSelector import EncoderModeSelector
INITIAL_DISPLAY_DELAY = 30
STANDARD_DISPLAY_DELAY = 20
IS_MOMENTARY = True
SYSEX_START = (240, 0, 32, 41, 103)
PAD_TRANSLATIONS = ((0, 3, 60, 0),
 (1, 3, 62, 0),
 (2, 3, 64, 0),
 (3, 3, 65, 0),
 (0, 2, 67, 0),
 (1, 2, 69, 0),
 (2, 2, 71, 0),
 (3, 2, 72, 0))
LED_OFF = 4
RED_FULL = 7
RED_BLINK = 11
GREEN_FULL = 52
GREEN_BLINK = 56
AMBER_FULL = RED_FULL + GREEN_FULL - 4
AMBER_BLINK = AMBER_FULL - 4 + 8

class Novation_Impulse(ControlSurface):
    """ Script for Novation's Impulse keyboards """

    def __init__(self, c_instance):
        ControlSurface.__init__(self, c_instance)
        with self.component_guard():
            self.set_pad_translations(PAD_TRANSLATIONS)
            self._device_selection_follows_track_selection = True
            self._suggested_input_port = 'Impulse'
            self._suggested_output_port = 'Impulse'
            self._has_sliders = True
            self._current_midi_map = None
            self._display_reset_delay = -1
            self._shift_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 39)
            self._preview_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 41)
            self._master_slider = SliderElement(MIDI_CC_TYPE, 0, 8)
            self._shift_button.name = 'Shift_Button'
            self._master_slider.name = 'Master_Volume_Control'
            self._master_slider.add_value_listener(self._slider_value, identify_sender=True)
            self._preview_button.add_value_listener(self._preview_value)
            self._setup_mixer()
            self._setup_session()
            self._setup_transport()
            self._setup_device()
            self._setup_name_display()
            device_button = ButtonElement(not IS_MOMENTARY, MIDI_CC_TYPE, 1, 10)
            mixer_button = ButtonElement(not IS_MOMENTARY, MIDI_CC_TYPE, 1, 9)
            device_button.name = 'Encoder_Device_Mode'
            mixer_button.name = 'Encoder_Mixer_Mode'
            self._encoder_modes = EncoderModeSelector(self._device_component, self._mixer, self._next_bank_button, self._prev_bank_button, self._encoders)
            self._encoder_modes.set_device_mixer_buttons(device_button, mixer_button)
            self._string_to_display = None
            for component in self.components:
                component.set_enabled(False)

    def refresh_state(self):
        ControlSurface.refresh_state(self)
        self.schedule_message(3, self._send_midi, SYSEX_START + (6, 1, 1, 1, 247))

    def handle_sysex(self, midi_bytes):
        if midi_bytes[0:-2] == SYSEX_START + (7,) and midi_bytes[-2] != 0:
            self._has_sliders = midi_bytes[-2] != 25
            self.schedule_message(1, self._show_startup_message)
            for control in self.controls:
                if isinstance(control, InputControlElement):
                    control.clear_send_cache()

            for component in self.components:
                component.set_enabled(True)

            if self._has_sliders:
                self._mixer.master_strip().set_volume_control(self._master_slider)
                self._mixer.update()
            else:
                self._mixer.master_strip().set_volume_control(None)
                self._mixer.selected_strip().set_volume_control(self._master_slider)
                for index in range(len(self._sliders)):
                    self._mixer.channel_strip(index).set_volume_control(None)
                    slider = self._sliders[index]
                    slider.release_parameter()
                    if slider.value_has_listener(self._slider_value):
                        slider.remove_value_listener(self._slider_value)

            self._encoder_modes.set_provide_volume_mode(not self._has_sliders)
            self.request_rebuild_midi_map()

    def disconnect(self):
        self._name_display_data_source.set_display_string('  ')
        for encoder in self._encoders:
            encoder.remove_value_listener(self._encoder_value)

        self._master_slider.remove_value_listener(self._slider_value)
        if self._has_sliders:
            for slider in tuple(self._sliders):
                slider.remove_value_listener(self._slider_value)

        for button in self._strip_buttons:
            button.remove_value_listener(self._mixer_button_value)

        self._preview_button.remove_value_listener(self._preview_value)
        ControlSurface.disconnect(self)
        self._encoders = None
        self._sliders = None
        self._strip_buttons = None
        self._master_slider = None
        self._current_midi_map = None
        self._shift_button = None
        self._name_display = None
        self._prev_bank_button = None
        self._next_bank_button = None
        self._encoder_modes = None
        self._transport_view_modes = None
        self._send_midi(SYSEX_START + (6, 0, 0, 0, 247))

    def build_midi_map(self, midi_map_handle):
        self._current_midi_map = midi_map_handle
        ControlSurface.build_midi_map(self, midi_map_handle)

    def update_display(self):
        ControlSurface.update_display(self)
        if self._string_to_display != None:
            self._name_display_data_source.set_display_string(self._string_to_display)
            self._string_to_display = None
        if self._display_reset_delay >= 0:
            self._display_reset_delay -= 1
            if self._display_reset_delay == -1:
                self._show_current_track_name()

    def _setup_mixer(self):
        mute_solo_flip_button = ButtonElement(not IS_MOMENTARY, MIDI_CC_TYPE, 0, 34)
        self._next_nav_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 37)
        self._prev_nav_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 38)
        self._strip_buttons = []
        mute_solo_flip_button.name = 'Mute_Solo_Flip_Button'
        self._next_nav_button.name = 'Next_Track_Button'
        self._prev_nav_button.name = 'Prev_Track_Button'
        self._mixer = SpecialMixerComponent(8)
        self._mixer.name = 'Mixer'
        self._mixer.set_select_buttons(self._next_nav_button, self._prev_nav_button)
        self._mixer.selected_strip().name = 'Selected_Channel_Strip'
        self._mixer.master_strip().name = 'Master_Channel_Strip'
        self._mixer.master_strip().set_volume_control(self._master_slider)
        self._sliders = []
        for index in range(8):
            strip = self._mixer.channel_strip(index)
            strip.name = 'Channel_Strip_' + str(index)
            strip.set_invert_mute_feedback(True)
            self._sliders.append(SliderElement(MIDI_CC_TYPE, 0, index))
            self._sliders[-1].name = str(index) + '_Volume_Control'
            self._sliders[-1].set_feedback_delay(-1)
            self._sliders[-1].add_value_listener(self._slider_value, identify_sender=True)
            strip.set_volume_control(self._sliders[-1])
            self._strip_buttons.append(ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 9 + index))
            self._strip_buttons[-1].name = str(index) + '_Mute_Button'
            self._strip_buttons[-1].add_value_listener(self._mixer_button_value, identify_sender=True)

        self._mixer.master_strip().set_mute_button(ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 1, 17))
        self._mixer.set_strip_mute_solo_buttons(tuple(self._strip_buttons), mute_solo_flip_button)

    def _setup_session(self):
        num_pads = len(PAD_TRANSLATIONS)
        self._session = SessionComponent(8, 0)
        self._session.name = 'Session_Control'
        self._session.selected_scene().name = 'Selected_Scene'
        self._session.set_mixer(self._mixer)
        self._session.set_track_banking_increment(num_pads)
        self._session.set_track_bank_buttons(ButtonElement(not IS_MOMENTARY, MIDI_CC_TYPE, 0, 35), ButtonElement(not IS_MOMENTARY, MIDI_CC_TYPE, 0, 36))
        pads = []
        for index in range(num_pads):
            pads.append(ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 60 + index))
            pads[-1].name = 'Pad_' + str(index)
            clip_slot = self._session.selected_scene().clip_slot(index)
            clip_slot.set_triggered_to_play_value(GREEN_BLINK)
            clip_slot.set_triggered_to_record_value(RED_BLINK)
            clip_slot.set_stopped_value(AMBER_FULL)
            clip_slot.set_started_value(GREEN_FULL)
            clip_slot.set_recording_value(RED_FULL)
            clip_slot.set_launch_button(pads[-1])
            clip_slot.name = str(index) + '_Selected_Clip_Slot'

    def _setup_transport(self):
        rwd_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 27)
        ffwd_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 28)
        stop_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 29)
        play_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 30)
        loop_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 31)
        rec_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 32)
        ffwd_button.name = 'FFwd_Button'
        rwd_button.name = 'Rwd_Button'
        loop_button.name = 'Loop_Button'
        play_button.name = 'Play_Button'
        stop_button.name = 'Stop_Button'
        rec_button.name = 'Record_Button'
        transport = ShiftableTransportComponent()
        transport.name = 'Transport'
        transport.set_stop_button(stop_button)
        transport.set_play_button(play_button)
        transport.set_record_button(rec_button)
        transport.set_shift_button(self._shift_button)
        self._transport_view_modes = TransportViewModeSelector(transport, self._session, ffwd_button, rwd_button, loop_button)
        self._transport_view_modes.name = 'Transport_View_Modes'

    def _setup_device(self):
        encoders = []
        for index in range(8):
            encoders.append(PeekableEncoderElement(MIDI_CC_TYPE, 1, index, Live.MidiMap.MapMode.relative_binary_offset))
            encoders[-1].set_feedback_delay(-1)
            encoders[-1].add_value_listener(self._encoder_value, identify_sender=True)
            encoders[-1].name = 'Device_Control_' + str(index)

        self._encoders = tuple(encoders)
        self._prev_bank_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 1, 12)
        self._next_bank_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 1, 11)
        self._prev_bank_button.name = 'Device_Bank_Down_Button'
        self._next_bank_button.name = 'Device_Bank_Up_Button'
        device = DeviceComponent()
        device.name = 'Device_Component'
        self.set_device_component(device)
        device.set_parameter_controls(self._encoders)
        device.set_bank_nav_buttons(self._prev_bank_button, self._next_bank_button)

    def _setup_name_display(self):
        self._name_display = PhysicalDisplayElement(16, 1)
        self._name_display.name = 'Display'
        self._name_display.set_message_parts(SYSEX_START + (8,), (247,))
        self._name_display_data_source = DisplayDataSource()
        self._name_display.segment(0).set_data_source(self._name_display_data_source)

    def _encoder_value(self, value, sender):
        if not sender in self._encoders:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                display_string = self._device_component.is_enabled() and ' - '
                display_string = sender.mapped_parameter() != None and sender.mapped_parameter().name
            self._set_string_to_display(display_string)

    def _slider_value(self, value, sender):
        if not sender in tuple(self._sliders) + (self._master_slider,):
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self._mixer.is_enabled():
                    display_string = ' - '
                    if sender.mapped_parameter() != None:
                        master = self.song().master_track
                        tracks = self.song().tracks
                        returns = self.song().return_tracks
                        track = None
                        if sender == self._master_slider:
                            track = self._has_sliders and master
                        else:
                            track = self.song().view.selected_track
                    else:
                        track = self._mixer.channel_strip(self._sliders.index(sender))._track
                    display_string = track == master and 'Master'
                elif track in tracks:
                    display_string = str(list(tracks).index(track) + 1)
                elif track in returns:
                    display_string = str(chr(ord('A') + list(returns).index(track)))
                else:
                    raise False or AssertionError
                display_string += ' Volume'
            self._set_string_to_display(display_string)

    def _mixer_button_value(self, value, sender):
        if not value in range(128):
            raise AssertionError
            if self._mixer.is_enabled() and value > 0:
                strip = self._mixer.channel_strip(self._strip_buttons.index(sender))
                self._string_to_display = strip != None and None
                self._name_display.segment(0).set_data_source(strip.track_name_data_source())
                self._name_display.update()
                self._display_reset_delay = STANDARD_DISPLAY_DELAY
            else:
                self._set_string_to_display(' - ')

    def _preview_value(self, value):
        raise value in range(128) or AssertionError
        for encoder in self._encoders:
            encoder.set_peek_mode(value > 0)

    def _show_current_track_name(self):
        if self._name_display != None and self._mixer != None:
            self._string_to_display = None
            self._name_display.segment(0).set_data_source(self._mixer.selected_strip().track_name_data_source())
            self._name_display.update()

    def _show_startup_message(self):
        self._name_display.display_message('LIVE')
        self._display_reset_delay = INITIAL_DISPLAY_DELAY

    def _set_string_to_display(self, string_to_display):
        raise isinstance(string_to_display, (str, unicode)) or AssertionError
        self._name_display.segment(0).set_data_source(self._name_display_data_source)
        self._string_to_display = string_to_display
        self._display_reset_delay = STANDARD_DISPLAY_DELAY

    def _on_selected_track_changed(self):
        ControlSurface._on_selected_track_changed(self)
        self._show_current_track_name()
        all_tracks = self._has_sliders or self._session.tracks_to_use()
        selected_track = self.song().view.selected_track
        num_strips = self._session.width()
        if selected_track in all_tracks:
            track_index = list(all_tracks).index(selected_track)
            new_offset = track_index - track_index % num_strips
            if not new_offset / num_strips == int(new_offset / num_strips):
                raise AssertionError
                self._session.set_offsets(new_offset, self._session.scene_offset())
########NEW FILE########
__FILENAME__ = PeekableEncoderElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Novation_Impulse/PeekableEncoderElement.py
import Live
from _Framework.EncoderElement import EncoderElement
from _Framework.InputControlElement import *

class PeekableEncoderElement(EncoderElement):
    """ Encoder that can be connected and disconnected to a specific parameter """

    def __init__(self, msg_type, channel, identifier, map_mode):
        EncoderElement.__init__(self, msg_type, channel, identifier, map_mode)
        self._peek_mode = False

    def set_peek_mode(self, peek_mode):
        if not isinstance(peek_mode, type(False)):
            raise AssertionError
            self._peek_mode = self._peek_mode != peek_mode and peek_mode
            self._request_rebuild()

    def get_peek_mode(self):
        return self._peek_mode

    def install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback):
        current_parameter = self._parameter_to_map_to
        if self._peek_mode:
            self._parameter_to_map_to = None
        InputControlElement.install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback)
        self._parameter_to_map_to = current_parameter
########NEW FILE########
__FILENAME__ = ShiftableTransportComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Novation_Impulse/ShiftableTransportComponent.py
import Live
from _Framework.ButtonElement import ButtonElement
from _Framework.TransportComponent import TransportComponent

class ShiftableTransportComponent(TransportComponent):
    """ Special transport class handling the seek buttons differently based on a shift button"""

    def __init__(self):
        self._shift_button = None
        self._shift_pressed = False
        TransportComponent.__init__(self)

    def disconnect(self):
        if self._shift_button != None:
            self._shift_button.remove_value_listener(self._shift_value)
            self._shift_button = None
        TransportComponent.disconnect(self)

    def set_shift_button(self, button):
        if not (button == None or isinstance(button, ButtonElement) and button.is_momentary()):
            raise AssertionError
            if self._shift_button != button:
                if self._shift_button != None:
                    self._shift_button.remove_value_listener(self._shift_value)
                    self._shift_pressed = False
                self._shift_button = button
                self._shift_button != None and self._shift_button.add_value_listener(self._shift_value)

    def _shift_value(self, value):
        if not self._shift_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            self._shift_pressed = self.is_enabled() and value > 0

    def _ffwd_value(self, value):
        if not self._ffwd_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            self.song().current_song_time = self._shift_pressed and self.song().last_event_time
        else:
            TransportComponent._ffwd_value(self, value)

    def _rwd_value(self, value):
        if not self._rwd_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            self.song().current_song_time = self._shift_pressed and 0.0
        else:
            TransportComponent._rwd_value(self, value)
########NEW FILE########
__FILENAME__ = SpecialMixerComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Novation_Impulse/SpecialMixerComponent.py
from _Framework.MixerComponent import MixerComponent
from _Framework.ButtonElement import ButtonElement

class SpecialMixerComponent(MixerComponent):
    """ Special mixer class that reassigns buttons to mute or solo based on a toggle """

    def __init__(self, num_tracks):
        self._shift_button = None
        self._selected_mute_solo_button = None
        self._strip_mute_solo_buttons = None
        self._mute_solo_flip_button = None
        MixerComponent.__init__(self, num_tracks)
        self._selected_tracks = []
        self._register_timer_callback(self._on_timer)

    def disconnect(self):
        self._unregister_timer_callback(self._on_timer)
        self._selected_tracks = None
        MixerComponent.disconnect(self)
        if self._shift_button != None:
            self._shift_button.remove_value_listener(self._shift_value)
            self._shift_button = None
        if self._mute_solo_flip_button != None:
            self._mute_solo_flip_button.remove_value_listener(self._mute_solo_flip_value)
            self._mute_solo_flip_button = None
        self._selected_mute_solo_button = None
        self._strip_mute_solo_buttons = None

    def set_shift_button(self, shift_button):
        if not (shift_button == None or shift_button.is_momentary()):
            raise AssertionError
            if self._shift_button != None:
                self._shift_button.remove_value_listener(self._shift_value)
            self._shift_button = shift_button
            self._shift_button != None and self._shift_button.add_value_listener(self._shift_value)

    def set_selected_mute_solo_button(self, button):
        raise isinstance(button, (type(None), ButtonElement)) or AssertionError
        self._selected_mute_solo_button = button
        self.selected_strip().set_mute_button(self._selected_mute_solo_button)
        self.selected_strip().set_solo_button(None)

    def set_strip_mute_solo_buttons(self, buttons, flip_button):
        if not (buttons is None or isinstance(buttons, tuple) and len(buttons) == len(self._channel_strips)):
            raise AssertionError
            if not isinstance(flip_button, (type(None), ButtonElement)):
                raise AssertionError
                self._mute_solo_flip_button != None and self._mute_solo_flip_button.remove_value_listener(self._mute_solo_flip_value)
            self._mute_solo_flip_button = flip_button
            self._mute_solo_flip_button != None and self._mute_solo_flip_button.add_value_listener(self._mute_solo_flip_value)
        self._strip_mute_solo_buttons = buttons
        for index in range(len(self._channel_strips)):
            strip = self.channel_strip(index)
            button = None
            if self._strip_mute_solo_buttons != None:
                button = self._strip_mute_solo_buttons[index]
            strip.set_mute_button(button)
            strip.set_solo_button(None)

    def tracks_to_use(self):
        return tuple(self.song().visible_tracks) + tuple(self.song().return_tracks)

    def _shift_value(self, value):
        if not self._shift_button != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            value > 0 and self.selected_strip().set_mute_button(None)
            self.selected_strip().set_solo_button(self._selected_mute_solo_button)
        else:
            self.selected_strip().set_solo_button(None)
            self.selected_strip().set_mute_button(self._selected_mute_solo_button)

    def _mute_solo_flip_value(self, value):
        raise self._mute_solo_flip_button != None or AssertionError
        raise value in range(128) or AssertionError
        if self._strip_mute_solo_buttons != None:
            for index in range(len(self._strip_mute_solo_buttons)):
                strip = self.channel_strip(index)
                if value == 0:
                    strip.set_mute_button(None)
                    strip.set_solo_button(self._strip_mute_solo_buttons[index])
                else:
                    strip.set_solo_button(None)
                    strip.set_mute_button(self._strip_mute_solo_buttons[index])

    def _on_timer(self):
        sel_track = None
        while len(self._selected_tracks) > 0:
            track = self._selected_tracks[-1]
            if track != None and track.has_midi_input and track.can_be_armed and not track.arm:
                sel_track = track
                break
            del self._selected_tracks[-1]

        if sel_track != None:
            found_recording_clip = False
            song = self.song()
            tracks = song.tracks
            if song.is_playing:
                check_arrangement = song.record_mode
                for track in tracks:
                    if track.can_be_armed and track.arm:
                        if check_arrangement:
                            found_recording_clip = True
                            break
                        else:
                            playing_slot_index = track.playing_slot_index
                            if playing_slot_index in range(len(track.clip_slots)):
                                slot = track.clip_slots[playing_slot_index]
                                if slot.has_clip and slot.clip.is_recording:
                                    found_recording_clip = True
                                    break

                if found_recording_clip or song.exclusive_arm:
                    for track in tracks:
                        if track.can_be_armed and track.arm and track != sel_track:
                            track.arm = False

                sel_track.arm = True
                sel_track.view.select_instrument()
        self._selected_tracks = []

    def _next_track_value(self, value):
        MixerComponent._next_track_value(self, value)
        self._selected_tracks.append(self.song().view.selected_track)

    def _prev_track_value(self, value):
        MixerComponent._prev_track_value(self, value)
        self._selected_tracks.append(self.song().view.selected_track)
########NEW FILE########
__FILENAME__ = TransportViewModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Novation_Impulse/TransportViewModeSelector.py
import Live
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from _Framework.ButtonElement import ButtonElement
from _Framework.TransportComponent import TransportComponent
from _Framework.SessionComponent import SessionComponent

class TransportViewModeSelector(ModeSelectorComponent):
    """ Class that reassigns specific buttons based on the views visible in Live """

    def __init__(self, transport, session, ffwd_button, rwd_button, loop_button):
        raise isinstance(transport, TransportComponent) or AssertionError
        raise isinstance(session, SessionComponent) or AssertionError
        raise isinstance(ffwd_button, ButtonElement) or AssertionError
        raise isinstance(rwd_button, ButtonElement) or AssertionError
        raise isinstance(loop_button, ButtonElement) or AssertionError
        ModeSelectorComponent.__init__(self)
        self._transport = transport
        self._session = session
        self._ffwd_button = ffwd_button
        self._rwd_button = rwd_button
        self._loop_button = loop_button
        self.application().view.add_is_view_visible_listener('Session', self._on_view_changed)
        self.update()

    def disconnect(self):
        ModeSelectorComponent.disconnect(self)
        self._transport = None
        self._session = None
        self._ffwd_button = None
        self._rwd_button = None
        self._loop_button = None
        self.application().view.remove_is_view_visible_listener('Session', self._on_view_changed)

    def update(self):
        if self.is_enabled():
            if self._mode_index == 0:
                self._transport.set_seek_buttons(self._ffwd_button, self._rwd_button)
                self._transport.set_loop_button(self._loop_button)
                self._session.set_select_buttons(None, None)
                self._session.selected_scene().set_launch_button(None)
            else:
                self._transport.set_seek_buttons(None, None)
                self._transport.set_loop_button(None)
                self._session.set_select_buttons(self._ffwd_button, self._rwd_button)
                self._session.selected_scene().set_launch_button(self._loop_button)

    def _on_view_changed(self):
        if self.application().view.is_view_visible('Session'):
            self._mode_index = 1
        else:
            self._mode_index = 0
        self.update()
########NEW FILE########
__FILENAME__ = EncoderModeSelector
#Embedded file name: /Users/versonator/Hudson/live/Projects/AppLive/Resources/MIDI Remote Scripts/Novation_Impulse/EncoderModeSelector.py
import Live
from _Framework.ModeSelectorComponent import ModeSelectorComponent

class EncoderModeSelector(ModeSelectorComponent):
    """ Class that reassigns the given encoders to either device- or mixer control """

    def __init__(self, device, mixer, bank_up_button, bank_down_button, encoders):
        ModeSelectorComponent.__init__(self)
        self._mixer = mixer
        self._device = device
        self._bank_up_button = bank_up_button
        self._bank_down_button = bank_down_button
        self._encoders = encoders
        self._device_button = None
        self._mixer_button = None
        self._device_mode = True
        self._mode_index = 0
        self._number_of_modes = 5
        self._bank_down_button.add_value_listener(self._bank_down_value)
        self._bank_up_button.add_value_listener(self._bank_up_value)
        self.update()

    def disconnect(self):
        self._bank_down_button.remove_value_listener(self._bank_down_value)
        self._bank_up_button.remove_value_listener(self._bank_up_value)
        self.set_device_mixer_buttons(None, None)
        ModeSelectorComponent.disconnect(self)
        self._mixer = None
        self._device = None
        self._bank_up_button = None
        self._bank_down_button = None
        self._encoders = None

    def set_device_mixer_buttons(self, device_button, mixer_button):
        #if not self._device_button != None:
        #    if not self._mixer_button != None:
        #        raise AssertionError
        if self._device_button != None:
            self._device_button.remove_value_listener(self._device_value)
        if self._mixer_button!= None:
            self._mixer_button.remove_value_listener(self._mixer_value)
        self._device_button = device_button
        self._mixer_button = mixer_button
        #raise self._device_button != None and (self._mixer_button != None or AssertionError)
        self._device_button.add_value_listener(self._device_value)
        self._mixer_button.add_value_listener(self._mixer_value)

    def set_provide_volume_mode(self, provide_volume_mode):
        self._number_of_modes = 6 if provide_volume_mode else 5

    def number_of_modes(self):
        return self._number_of_modes

    def update(self):
        if not self._mode_index in range(self.number_of_modes()):
            raise AssertionError
        if self.is_enabled():
            self._device.set_allow_update(False)
            self._mixer.set_allow_update(False)
            self._device.set_bank_nav_buttons(None, None)
            self._device.set_parameter_controls(())
            for index in range(len(self._encoders)):
                strip = self._mixer.channel_strip(index)
                strip.set_pan_control(None)
                strip.set_send_controls(None)
                if self.number_of_modes() > 5:
                    strip.set_volume_control(None)

            if  self._device_mode:
                self._device.set_bank_nav_buttons(self._bank_down_button, self._bank_up_button)
                self._device.set_parameter_controls(self._encoders)
            else:
                for index in range(len(self._encoders)):
                    strip = self._mixer.channel_strip(index)
                    if self._mode_index == 0:
                        strip.set_pan_control(self._encoders[index])
                    elif self._mode_index < 5:
                        sends = [None,
                            None,
                            None,
                            None]
                        sends[self._mode_index - 1] = self._encoders[index]
                        strip.set_send_controls(tuple(sends))
                    else:
                        strip.set_volume_control(self._encoders[index])

            self._device.set_allow_update(True)
            self._mixer.set_allow_update(True)

    def _bank_down_value(self, value):
        if not value in range(128):
            raise AssertionError
        if self.is_enabled() and not self._device_mode:
            new_mode = (value > 0 or not self._bank_down_button.is_momentary()) and max(self._mode_index - 1, 0)
            self.set_mode(new_mode)

    def _bank_up_value(self, value):
        if not value in range(128):
            raise AssertionError
        if self.is_enabled() and not self._device_mode:
            new_mode = (value > 0 or not self._bank_up_button.is_momentary()) and min(self._mode_index + 1, self.number_of_modes() - 1)
            self.set_mode(new_mode)

    def _device_value(self, value):
        if not value in range(128):
            raise AssertionError
        if self.is_enabled() and not self._device_mode:
            self._device_mode = (value > 0 or not self._device_button.is_momentary()) and True
            self.update()

    def _mixer_value(self, value):
        if not value in range(128):
            raise AssertionError
        if self.is_enabled() and self._device_mode:
            self._device_mode = (value > 0 or not self._mixer_button.is_momentary()) and False
            self.update()
########NEW FILE########
__FILENAME__ = Novation_Impulse2
#Embedded file name: /Users/versonator/Hudson/live/Projects/AppLive/Resources/MIDI Remote Scripts/Novation_Impulse/Novation_Impulse.py
from __future__ import with_statement
import Live
from _Framework.ControlSurface import ControlSurface
from _Framework.InputControlElement import *
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.PhysicalDisplayElement import PhysicalDisplayElement
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.SessionComponent import SessionComponent
from _Framework.DeviceComponent import DeviceComponent
from TransportViewModeSelector import TransportViewModeSelector
from SpecialMixerComponent import SpecialMixerComponent
from ShiftableTransportComponent import ShiftableTransportComponent
from PeekableEncoderElement import PeekableEncoderElement
from EncoderModeSelector import EncoderModeSelector
INITIAL_DISPLAY_DELAY = 30
STANDARD_DISPLAY_DELAY = 20
IS_MOMENTARY = True
SYSEX_START = (240, 0, 32, 41, 103)
PAD_TRANSLATIONS = ((0, 3, 60, 0),
 (1, 3, 62, 0),
 (2, 3, 64, 0),
 (3, 3, 65, 0),
 (0, 2, 67, 0),
 (1, 2, 69, 0),
 (2, 2, 71, 0),
 (3, 2, 72, 0))
LED_OFF = 4
RED_FULL = 7
RED_BLINK = 11
GREEN_FULL = 52
GREEN_BLINK = 56
AMBER_FULL = RED_FULL + GREEN_FULL - 4
AMBER_BLINK = AMBER_FULL - 4 + 8

class Novation_Impulse2(ControlSurface):
    """ Script for Novation's Impulse keyboards """

    def __init__(self, c_instance):
        ControlSurface.__init__(self, c_instance)
        self.c_instance = c_instance
        with self.component_guard():
            self.set_pad_translations(PAD_TRANSLATIONS)
            self._device_selection_follows_track_selection = True
            self._suggested_input_port = 'Impulse'
            self._suggested_output_port = 'Impulse'
            self._has_sliders = True
            self._current_midi_map = None
            self._display_reset_delay = -1
            self._shift_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 39)
            self._preview_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 41)
            self._master_slider = SliderElement(MIDI_CC_TYPE, 0, 8)
            self._shift_button.name = 'Shift_Button'
            self._master_slider.name = 'Master_Volume_Control'
            self._master_slider.add_value_listener(self._slider_value, identify_sender=True)
            self._preview_button.add_value_listener(self._preview_value)
            self._setup_mixer()
            self._setup_session()
            self._setup_transport()
            self._setup_device()
            self._setup_name_display()
            device_button = ButtonElement(not IS_MOMENTARY, MIDI_CC_TYPE, 1, 10)
            mixer_button = ButtonElement(not IS_MOMENTARY, MIDI_CC_TYPE, 1, 9)
            device_button.name = 'Encoder_Device_Mode'
            mixer_button.name = 'Encoder_Mixer_Mode'
            self._encoder_modes = EncoderModeSelector(self._device_component, self._mixer, self._next_bank_button, self._prev_bank_button, self._encoders)
            self._encoder_modes.set_device_mixer_buttons(device_button, mixer_button)
            self._string_to_display = None
            for component in self.components:
                component.set_enabled(False)

    def refresh_state(self):
        ControlSurface.refresh_state(self)
        self.schedule_message(3, self._send_midi, SYSEX_START + (6, 1, 1, 1, 247))

    def handle_sysex(self, midi_bytes):
        if midi_bytes[0:-2] == SYSEX_START + (7,) and midi_bytes[-2] != 0:
            self._has_sliders = midi_bytes[-2] != 25
            self.schedule_message(1, self._show_startup_message)
            for control in self.controls:
                if isinstance(control, InputControlElement):
                    control.clear_send_cache()

            for component in self.components:
                component.set_enabled(True)

            if self._has_sliders:
                self._mixer.master_strip().set_volume_control(self._master_slider)
                self._mixer.update()
            else:
                self._mixer.master_strip().set_volume_control(None)
                self._mixer.selected_strip().set_volume_control(self._master_slider)
                for index in range(len(self._sliders)):
                    self._mixer.channel_strip(index).set_volume_control(None)
                    slider = self._sliders[index]
                    slider.release_parameter()
                    if slider.value_has_listener(self._slider_value):
                        slider.remove_value_listener(self._slider_value)

            self._encoder_modes.set_provide_volume_mode(not self._has_sliders)
            self.request_rebuild_midi_map()

    def disconnect(self):
        self._name_display_data_source.set_display_string('  ')
        for encoder in self._encoders:
            encoder.remove_value_listener(self._encoder_value)

        self._master_slider.remove_value_listener(self._slider_value)
        if self._has_sliders:
            for slider in tuple(self._sliders):
                slider.remove_value_listener(self._slider_value)

        for button in self._strip_buttons:
            button.remove_value_listener(self._mixer_button_value)

        self._preview_button.remove_value_listener(self._preview_value)
        ControlSurface.disconnect(self)
        self._encoders = None
        self._sliders = None
        self._strip_buttons = None
        self._master_slider = None
        self._current_midi_map = None
        self._shift_button = None
        self._name_display = None
        self._prev_bank_button = None
        self._next_bank_button = None
        self._encoder_modes = None
        self._transport_view_modes = None
        self._send_midi(SYSEX_START + (6, 0, 0, 0, 247))

    def build_midi_map(self, midi_map_handle):
        self._current_midi_map = midi_map_handle
        ControlSurface.build_midi_map(self, midi_map_handle)

    def update_display(self):
        ControlSurface.update_display(self)
        if self._string_to_display != None:
            self._name_display_data_source.set_display_string(self._string_to_display)
            self._string_to_display = None
        if self._display_reset_delay >= 0:
            self._display_reset_delay -= 1
            if self._display_reset_delay == -1:
                self._show_current_track_name()

    def _setup_mixer(self):
        mute_solo_flip_button = ButtonElement(not IS_MOMENTARY, MIDI_CC_TYPE, 0, 34)
        self._next_nav_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 37)
        self._prev_nav_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 38)
        self._strip_buttons = []
        mute_solo_flip_button.name = 'Mute_Solo_Flip_Button'
        self._next_nav_button.name = 'Next_Track_Button'
        self._prev_nav_button.name = 'Prev_Track_Button'
        self._mixer = SpecialMixerComponent(8, self.c_instance)
        self._mixer.name = 'Mixer'
        self._mixer.set_select_buttons(self._next_nav_button, self._prev_nav_button)
        self._mixer.selected_strip().name = 'Selected_Channel_Strip'
        self._mixer.master_strip().name = 'Master_Channel_Strip'
        self._mixer.master_strip().set_volume_control(self._master_slider)
        self._sliders = []
        for index in range(8):
            strip = self._mixer.channel_strip(index)
            strip.name = 'Channel_Strip_' + str(index)
            strip.set_invert_mute_feedback(True)
            self._sliders.append(SliderElement(MIDI_CC_TYPE, 0, index))
            self._sliders[-1].name = str(index) + '_Volume_Control'
            self._sliders[-1].set_feedback_delay(-1)
            self._sliders[-1].add_value_listener(self._slider_value, identify_sender=True)
            strip.set_volume_control(self._sliders[-1])
            self._strip_buttons.append(ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 9 + index))
            self._strip_buttons[-1].name = str(index) + '_Mute_Button'
            self._strip_buttons[-1].add_value_listener(self._mixer_button_value, identify_sender=True)

        self._mixer.master_strip().set_mute_button(ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 1, 17))
        self._mixer.set_strip_mute_solo_buttons(tuple(self._strip_buttons), mute_solo_flip_button)
        self._mixer.set_shift_button(self._shift_button)

        self._button9 = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 9 + 8)
        self._mixer.set_selected_mute_solo_button(self._button9)

    def _setup_session(self):
        num_pads = len(PAD_TRANSLATIONS)
        self._session = SessionComponent(8, 0)
        self._session.name = 'Session_Control'
        self._session.selected_scene().name = 'Selected_Scene'
        self._session.set_mixer(self._mixer)
        self._session.set_track_banking_increment(num_pads)
        self._session.set_track_bank_buttons(ButtonElement(not IS_MOMENTARY, MIDI_CC_TYPE, 0, 35), ButtonElement(not IS_MOMENTARY, MIDI_CC_TYPE, 0, 36))
        pads = []
        for index in range(num_pads):
            pads.append(ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 60 + index))
            pads[-1].name = 'Pad_' + str(index)
            clip_slot = self._session.selected_scene().clip_slot(index)
            clip_slot.set_triggered_to_play_value(GREEN_BLINK)
            clip_slot.set_triggered_to_record_value(RED_BLINK)
            clip_slot.set_stopped_value(AMBER_FULL)
            clip_slot.set_started_value(GREEN_FULL)
            clip_slot.set_recording_value(RED_FULL)
            clip_slot.set_launch_button(pads[-1])
            clip_slot.name = str(index) + '_Selected_Clip_Slot'

    def _setup_transport(self):
        rwd_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 27)
        ffwd_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 28)
        stop_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 29)
        play_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 30)
        loop_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 31)
        rec_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 0, 32)
        ffwd_button.name = 'FFwd_Button'
        rwd_button.name = 'Rwd_Button'
        loop_button.name = 'Loop_Button'
        play_button.name = 'Play_Button'
        stop_button.name = 'Stop_Button'
        rec_button.name = 'Record_Button'
        transport = ShiftableTransportComponent(self.c_instance)
        transport.name = 'Transport'
        transport.set_stop_button(stop_button)
        transport.set_play_button(play_button)
        transport.set_record_buttonOnInit(rec_button)
        transport.set_shift_button(self._shift_button)
        self._transport_view_modes = TransportViewModeSelector(transport, self._session, ffwd_button, rwd_button, loop_button)
        self._transport_view_modes.name = 'Transport_View_Modes'

    def _setup_device(self):
        encoders = []
        for index in range(8):
            encoders.append(PeekableEncoderElement(MIDI_CC_TYPE, 1, index, Live.MidiMap.MapMode.relative_binary_offset))
            encoders[-1].set_feedback_delay(-1)
            encoders[-1].add_value_listener(self._encoder_value, identify_sender=True)
            encoders[-1].name = 'Device_Control_' + str(index)

        self._encoders = tuple(encoders)
        self._prev_bank_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 1, 12)
        self._next_bank_button = ButtonElement(IS_MOMENTARY, MIDI_CC_TYPE, 1, 11)
        self._prev_bank_button.name = 'Device_Bank_Down_Button'
        self._next_bank_button.name = 'Device_Bank_Up_Button'
        device = DeviceComponent()
        device.name = 'Device_Component'
        self.set_device_component(device)
        device.set_parameter_controls(self._encoders)
        device.set_bank_nav_buttons(self._prev_bank_button, self._next_bank_button)

    def _setup_name_display(self):
        self._name_display = PhysicalDisplayElement(16, 1)
        self._name_display.name = 'Display'
        self._name_display.set_message_parts(SYSEX_START + (8,), (247,))
        self._name_display_data_source = DisplayDataSource()
        self._name_display.segment(0).set_data_source(self._name_display_data_source)

    def _encoder_value(self, value, sender):
        if not sender in self._encoders:
            raise AssertionError
        if not value in range(128):
            raise AssertionError
#        display_string = self._device_component.is_enabled() and ' - '
#        display_string = sender.mapped_parameter() != None and sender.mapped_parameter().name
        display_string = ''
        if self._device_component.is_enabled():
#            display_string = sender.name
#            track = self.song().view.selected_track
#            display_string = str(list(tracks).index(track) + 1)
            pass
        if (sender.mapped_parameter() != None):
#            display_string = display_string + '-'
            display_string =  display_string + sender.mapped_parameter().name
        self._set_string_to_display(display_string)

    def _slider_value(self, value, sender):
        if not sender in tuple(self._sliders) + (self._master_slider,):
            raise AssertionError
        if not value in range(128):
            raise AssertionError
        if self._mixer.is_enabled():
            display_string = ' - '
            master = self.song().master_track
            tracks = self.song().tracks
            returns = self.song().return_tracks
            track = None
            if sender.mapped_parameter() != None:
                if sender == self._master_slider:
                    track = self._has_sliders and master
                else:
                    track = self._mixer.channel_strip(self._sliders.index(sender))._track
            else:
                track = self.song().view.selected_track
            if track == master:
                display_string  = 'Master'
            elif track in tracks:
                display_string = str(list(tracks).index(track) + 1)
            elif track in returns:
                display_string = str(chr(ord('A') + list(returns).index(track)))
            else:
#            raise False or AssertionError
                raise AssertionError
            display_string += ' Volume'
            self._set_string_to_display(display_string)

    def _mixer_button_value(self, value, sender):
        if not value in range(128):
            raise AssertionError
        #if self._mixer.is_enabled() and value > 0:
        if self._mixer.is_enabled():
            strip = self._mixer.channel_strip(self._strip_buttons.index(sender))
            #self._string_to_display = strip != None and None
            self._name_display.segment(0).set_data_source(strip.track_name_data_source())
            self._name_display.update()
            self._display_reset_delay = STANDARD_DISPLAY_DELAY
        else:
            self._set_string_to_display(' - ')

    def _preview_value(self, value):
        if not value in range(128):
            raise AssertionError
        for encoder in self._encoders:
            encoder.set_peek_mode(value > 0)

    def _show_current_track_name(self):
        if self._name_display != None and self._mixer != None:
            self._string_to_display = None
            self._name_display.segment(0).set_data_source(self._mixer.selected_strip().track_name_data_source())
            self._name_display.update()

    def _show_startup_message(self):
        self._name_display.display_message('LIVE')
        self._display_reset_delay = INITIAL_DISPLAY_DELAY

    def _set_string_to_display(self, string_to_display):
        if not isinstance(string_to_display, (str, unicode)):
            raise AssertionError
        self._name_display.segment(0).set_data_source(self._name_display_data_source)
        self._string_to_display = string_to_display
        self._display_reset_delay = STANDARD_DISPLAY_DELAY

    def _on_selected_track_changed(self):
        ControlSurface._on_selected_track_changed(self)
        self._show_current_track_name()
        #all_tracks = self._has_sliders or self._session.tracks_to_use()
        all_tracks2 = self._session.tracks_to_use()
        selected_track = self.song().view.selected_track
        num_strips = self._session.width()
        for selected_track in all_tracks2:
            track_index = list(all_tracks2).index(selected_track)
            new_offset = track_index - track_index % num_strips
            if not new_offset / num_strips == int(new_offset / num_strips):
                raise AssertionError
            self._session.set_offsets(new_offset, self._session.scene_offset())

    def log(self, message):
        pass
#	    self.c_instance.log_message(message)

########NEW FILE########
__FILENAME__ = PeekableEncoderElement
#Embedded file name: /Users/versonator/Hudson/live/Projects/AppLive/Resources/MIDI Remote Scripts/Novation_Impulse/PeekableEncoderElement.py
import Live
from _Framework.EncoderElement import EncoderElement
from _Framework.InputControlElement import *

class PeekableEncoderElement(EncoderElement):
    """ Encoder that can be connected and disconnected to a specific parameter """

    def __init__(self, msg_type, channel, identifier, map_mode):
        EncoderElement.__init__(self, msg_type, channel, identifier, map_mode)
        self._peek_mode = False

    def set_peek_mode(self, peek_mode):
        if not isinstance(peek_mode, type(False)):
            raise AssertionError
        self._peek_mode = self._peek_mode != peek_mode and peek_mode
        self._request_rebuild()

    def get_peek_mode(self):
        return self._peek_mode

    def install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback):
        current_parameter = self._parameter_to_map_to
        if self._peek_mode:
            self._parameter_to_map_to = None
        InputControlElement.install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback)
        self._parameter_to_map_to = current_parameter
########NEW FILE########
__FILENAME__ = ShiftableTransportComponent
#Embedded file name: /Users/versonator/Hudson/live/Projects/AppLive/Resources/MIDI Remote Scripts/Novation_Impulse/ShiftableTransportComponent.py
import Live
from _Framework.ButtonElement import ButtonElement
from _Framework.TransportComponent import TransportComponent

class ShiftableTransportComponent(TransportComponent):
    """ Special transport class handling the seek buttons differently based on a shift button"""

    def __init__(self, c_instance):
        self.c_instance = c_instance
        self._shift_button = None
        self._shift_pressed = False
        TransportComponent.__init__(self)

    def disconnect(self):
        if self._shift_button != None:
            self._shift_button.remove_value_listener(self._shift_value)
            self._shift_button = None
        TransportComponent.disconnect(self)

    def set_shift_button(self, button):
        self.log("set_shift_button (transport)")
        if not (button == None or isinstance(button, ButtonElement) and button.is_momentary()):
            raise AssertionError
        self.log("set_shift_button 2 (transport)")
        if self._shift_button != button:
            if self._shift_button != None:
                self._shift_button.remove_value_listener(self._shift_value)
                self._shift_pressed = False
            self._shift_button = button
            self.log("set_shift_button 3 (transport)")
            self._shift_button != None and self._shift_button.add_value_listener(self._shift_value)
            self.log("set_shift_button 4 (transport)")

    def set_record_buttonOnInit(self, button):
        self.log("set_record_buttonOnInit 1")
        self.record_button = button
        self.set_record_button(self.record_button)
        self.log("set_record_buttonOnInit 2")

    def _shift_value(self, value):
        self.log("shift handler")
        if not self._shift_button != None:
            raise AssertionError
        if not value in range(128):
            raise AssertionError
        self.log("shift handler 2")
        self._shift_pressed = self.is_enabled() and value > 0
        self.log("shift handler 3")
        if self._shift_pressed:
            self.log("shift handler pressed")
            self.set_overdub_button(self.record_button)
            self.set_record_button(None)
        else:
            self.log("shift handler unpressed")
            self.set_overdub_button(None)
            self.set_record_button(self.record_button)



    def _ffwd_value(self, value):
        self.log("ffwd handler main")
        if not self._ffwd_button != None:
            raise AssertionError
        if not value in range(128):
            raise AssertionError
        else:
            if self._shift_pressed:
                self.log("ffwd shifted handler")
                self.song().current_song_time = self._shift_pressed and self.song().last_event_time
            else:
                self.log("ffwd normal handler")
                TransportComponent._ffwd_value(self, value)

    def _rwd_value(self, value):
        self.log("rwd handler main")
        if not self._rwd_button != None:
            raise AssertionError
        if not value in range(128):
            raise AssertionError
        else:
            if self._shift_pressed:
                self.song().current_song_time = self._shift_pressed and 0.0
                self.log("rwd shifted handler")
            else:
                self.log("rwd normal handler")
                TransportComponent._rwd_value(self, value)

    def log(self, message):
        pass
#	    self.c_instance.log_message(message)

########NEW FILE########
__FILENAME__ = SpecialMixerComponent
#Embedded file name: /Users/versonator/Hudson/live/Projects/AppLive/Resources/MIDI Remote Scripts/Novation_Impulse/SpecialMixerComponent.py
from _Framework.MixerComponent import MixerComponent
from _Framework.ButtonElement import ButtonElement

class SpecialMixerComponent(MixerComponent):
    """ Special mixer class that reassigns buttons to mute or solo based on a toggle """

    def __init__(self, num_tracks, c_instance):
        self.c_instance = c_instance
        self._shift_button = None
        self._selected_mute_solo_button = None
        self._strip_mute_solo_buttons = None
        self._mute_solo_flip_button = None
        MixerComponent.__init__(self, num_tracks)
        self._selected_tracks = []
        self._register_timer_callback(self._on_timer)
        self._shift_pressed = False
        self._mute_solo_raw_value = 127


    def disconnect(self):
        self._unregister_timer_callback(self._on_timer)
        self._selected_tracks = None
        MixerComponent.disconnect(self)
        if self._shift_button != None:
            self._shift_button.remove_value_listener(self._shift_value)
            self._shift_button = None
        if self._mute_solo_flip_button != None:
            self._mute_solo_flip_button.remove_value_listener(self._mute_solo_flip_value)
            self._mute_solo_flip_button = None
        self._selected_mute_solo_button = None
        self._strip_mute_solo_buttons = None

    def set_shift_button(self, shift_button):
        self.log("set_shift_button - mixer")
        if not (shift_button == None or shift_button.is_momentary()):
            raise AssertionError
        if self._shift_button != None:
            self._shift_button.remove_value_listener(self._shift_value)
        self._shift_button = shift_button
        self._shift_button != None and self._shift_button.add_value_listener(self._shift_value)

    def set_selected_mute_solo_button(self, button):
        if not isinstance(button, (type(None), ButtonElement)):
            raise AssertionError
        self._selected_mute_solo_button = button
        #self.selected_strip().set_mute_button(self._selected_mute_solo_button)
        #self.selected_strip().set_solo_button(None)
        #self.selected_strip().set_arm_button(None)
        self.selected_strip().set_mute_button(None)
        self.selected_strip().set_solo_button(None)
        self.selected_strip().set_arm_button(self._selected_mute_solo_button)

    def set_strip_mute_solo_buttons(self, buttons, flip_button):
        self.log("set_strip_mute_solo_buttons")
        if not (buttons is None or isinstance(buttons, tuple) and len(buttons) == len(self._channel_strips)):
            raise AssertionError
        if not isinstance(flip_button, (type(None), ButtonElement)):
            raise AssertionError
        self._mute_solo_flip_button = flip_button
        self._strip_mute_solo_buttons = buttons
        if self._mute_solo_flip_button != None:
           self._mute_solo_flip_button.remove_value_listener(self._mute_solo_flip_value)
        if self._mute_solo_flip_button != None:
           self._mute_solo_flip_button.add_value_listener(self._mute_solo_flip_value)
        for index in range(len(self._channel_strips)):
            strip = self.channel_strip(index)
            button = None
            if self._strip_mute_solo_buttons != None:
                button = self._strip_mute_solo_buttons[index]
            strip.set_mute_button(button)
            strip.set_solo_button(None)

    def tracks_to_use(self):
        return tuple(self.song().visible_tracks) + tuple(self.song().return_tracks)

    def _shift_value(self, value):
        if (value > 0):
            self._shift_pressed = True
        else:
            self._shift_pressed = False
        self.updateMixerButtons()
        pass
        return
        self.log("_shift_value " + str(value))
        if not self._shift_button != None:
            raise AssertionError
        if not value in range(128):
            raise AssertionError
        if value > 0:
            self.selected_strip().set_mute_button(None)
#            self.selected_strip().set_solo_button(self._selected_mute_solo_button)
            self.selected_strip().set_arm_button(self._selected_mute_solo_button)
        else:
#            self.selected_strip().set_solo_button(None)
            self.selected_strip().set_arm_button(None)
            self.selected_strip().set_mute_button(self._selected_mute_solo_button)

    def _mute_solo_flip_value(self, value):
        #self.log(value)
        if not self._mute_solo_flip_button != None:
            raise AssertionError
        if not value in range(128):
            raise AssertionError
        self._mute_solo_raw_value = value
        self.updateMixerButtons()


    def updateMixerButtons(self):
        if self._strip_mute_solo_buttons != None:
            for index in range(len(self._strip_mute_solo_buttons)):
                strip = self.channel_strip(index)
                self.log("setting strip")
                if self._shift_pressed:
                        strip.set_mute_button(None)
                        strip.set_solo_button(None)
                        strip.set_arm_button(self._strip_mute_solo_buttons[index])
                else:
                    if self._mute_solo_raw_value == 0:
                        strip.set_mute_button(None)
                        strip.set_solo_button(self._strip_mute_solo_buttons[index])
                        strip.set_arm_button(None)
                    else:
                        strip.set_solo_button(None)
                        strip.set_mute_button(self._strip_mute_solo_buttons[index])
                        strip.set_arm_button(None)

    def _on_timer(self):
        sel_track = None
        while len(self._selected_tracks) > 0:
            track = self._selected_tracks[-1]
            if track != None and track.has_midi_input and track.can_be_armed and not track.arm:
                sel_track = track
                break
            del self._selected_tracks[-1]

        if sel_track != None:
            found_recording_clip = False
            song = self.song()
            tracks = song.tracks
            if song.is_playing:
                check_arrangement = song.record_mode
                for track in tracks:
                    if track.can_be_armed and track.arm:
                        if check_arrangement:
                            found_recording_clip = True
                            break
                        else:
                            playing_slot_index = track.playing_slot_index
                            if playing_slot_index in range(len(track.clip_slots)):
                                slot = track.clip_slots[playing_slot_index]
                                if slot.has_clip and slot.clip.is_recording:
                                    found_recording_clip = True
                                    break

                if found_recording_clip or song.exclusive_arm:
                    for track in tracks:
                        if track.can_be_armed and track.arm and track != sel_track:
                            track.arm = False

                sel_track.arm = True
                sel_track.view.select_instrument()
        self._selected_tracks = []
        self.updateMixerButtons()

    def _next_track_value(self, value):
        MixerComponent._next_track_value(self, value)
        self._selected_tracks.append(self.song().view.selected_track)
        self.updateMixerButtons()

    def _prev_track_value(self, value):
        MixerComponent._prev_track_value(self, value)
        self._selected_tracks.append(self.song().view.selected_track)
        self.updateMixerButtons()

    def log(self, message):
        pass
#	    self.c_instance.log_message(message)

########NEW FILE########
__FILENAME__ = TransportViewModeSelector
#Embedded file name: /Users/versonator/Hudson/live/Projects/AppLive/Resources/MIDI Remote Scripts/Novation_Impulse/TransportViewModeSelector.py
import Live
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from _Framework.ButtonElement import ButtonElement
from _Framework.TransportComponent import TransportComponent
from _Framework.SessionComponent import SessionComponent

class TransportViewModeSelector(ModeSelectorComponent):
    """ Class that reassigns specific buttons based on the views visible in Live """

    def __init__(self, transport, session, ffwd_button, rwd_button, loop_button):
        if not isinstance(transport, TransportComponent):
            raise AssertionError
        if not isinstance(session, SessionComponent):
            raise AssertionError
        if not isinstance(ffwd_button, ButtonElement):
            raise AssertionError
        if not isinstance(rwd_button, ButtonElement): 
            raise AssertionError
        if not isinstance(loop_button, ButtonElement): 
            raise AssertionError
        ModeSelectorComponent.__init__(self)
        self._transport = transport
        self._session = session
        self._ffwd_button = ffwd_button
        self._rwd_button = rwd_button
        self._loop_button = loop_button
        self.application().view.add_is_view_visible_listener('Session', self._on_view_changed)
        self.update()

    def disconnect(self):
        ModeSelectorComponent.disconnect(self)
        self._transport = None
        self._session = None
        self._ffwd_button = None
        self._rwd_button = None
        self._loop_button = None
        self.application().view.remove_is_view_visible_listener('Session', self._on_view_changed)

    def update(self):
        if self.is_enabled():
            if self._mode_index == 0:
                self._transport.set_seek_buttons(self._ffwd_button, self._rwd_button)
                self._transport.set_loop_button(self._loop_button)
                self._session.set_select_buttons(None, None)
                self._session.selected_scene().set_launch_button(None)
            else:
                self._transport.set_seek_buttons(None, None)
                self._transport.set_loop_button(None)
                self._session.set_select_buttons(self._ffwd_button, self._rwd_button)
                self._session.selected_scene().set_launch_button(self._loop_button)

    def _on_view_changed(self):
        if self.application().view.is_view_visible('Session'):
            self._mode_index = 1
        else:
            self._mode_index = 0
        self.update()
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/O2/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
VOLUME_CONTROLS = GENERIC_SLIDERS
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': -1,
 'PREVBANK': -1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'USB O2',
 'OUTPUTPORT': 'USB O2',
 'CHANNEL': 0}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': 7}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/O2/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = -1
GENERIC_PLAY = -1
GENERIC_REC = -1
GENERIC_LOOP = -1
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 73
GENERIC_ENC2 = 72
GENERIC_ENC3 = 74
GENERIC_ENC4 = 71
GENERIC_ENC5 = 5
GENERIC_ENC6 = 84
GENERIC_ENC7 = 93
GENERIC_ENC8 = 10
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = -1
GENERIC_SLI2 = -1
GENERIC_SLI3 = -1
GENERIC_SLI4 = -1
GENERIC_SLI5 = -1
GENERIC_SLI6 = -1
GENERIC_SLI7 = -1
GENERIC_SLI8 = -1
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = OpenLabs
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/OpenLabs/OpenLabs.py
from __future__ import with_statement
import Live
from _Framework.ControlSurface import ControlSurface
from _Framework.InputControlElement import *
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import EncoderElement
from _Framework.MixerComponent import MixerComponent
from _Framework.ClipSlotComponent import ClipSlotComponent
from _Framework.ChannelStripComponent import ChannelStripComponent
from _Framework.SceneComponent import SceneComponent
from _Framework.SessionComponent import SessionComponent
from SpecialTransportComponent import SpecialTransportComponent
from SpecialDeviceComponent import SpecialDeviceComponent

class OpenLabs(ControlSurface):
    """ Script for OpenLabs Controllers """

    def __init__(self, c_instance):
        ControlSurface.__init__(self, c_instance)
        with self.component_guard():
            self._suppress_session_highlight = True
            self._suggested_input_port = 'Open Labs Midi Driver'
            self._suggested_output_port = ''
            self.set_pad_translations(((0, 0, 12, 15),
             (1, 0, 13, 15),
             (2, 0, 14, 15),
             (3, 0, 15, 15),
             (0, 1, 8, 15),
             (1, 1, 9, 15),
             (2, 1, 10, 15),
             (3, 1, 11, 15),
             (0, 2, 4, 15),
             (1, 2, 5, 15),
             (2, 2, 6, 15),
             (3, 2, 7, 15),
             (0, 3, 0, 15),
             (1, 3, 1, 15),
             (2, 3, 2, 15),
             (3, 3, 3, 15)))
            self._setup_mixer_control()
            self._setup_device_and_transport_control()

    def handle_sysex(self, midi_bytes):
        pass

    def _setup_mixer_control(self):
        is_momentary = True
        num_tracks = 8
        num_returns = 7
        mixer = MixerComponent(num_tracks, num_returns)
        for track in range(num_tracks):
            strip = mixer.channel_strip(track)
            strip.set_volume_control(SliderElement(MIDI_CC_TYPE, 15, 54 - track))
            strip.set_pan_control(SliderElement(MIDI_CC_TYPE, 15, 80 - track))
            strip.set_mute_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 117 - track))
            strip.set_invert_mute_feedback(True)

        for track in range(num_returns):
            strip = mixer.return_strip(track)
            strip.set_volume_control(SliderElement(MIDI_CC_TYPE, 15, 10 + track))

        mixer.set_bank_buttons(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 108), ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 109))
        mixer.set_crossfader_control(SliderElement(MIDI_CC_TYPE, 15, 9))
        mixer.master_strip().set_volume_control(SliderElement(MIDI_CC_TYPE, 15, 46))
        session = SessionComponent(0, 0)
        session.set_select_buttons(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 95), ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 92))
        session.selected_scene().set_launch_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 91))

    def _setup_device_and_transport_control(self):
        is_momentary = True
        device_param_controls = []
        for index in range(8):
            device_param_controls.append(EncoderElement(MIDI_CC_TYPE, 15, 62 - index, Live.MidiMap.MapMode.absolute))

        device = SpecialDeviceComponent()
        device.set_bank_nav_buttons(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 107), ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 106))
        device.set_parameter_controls(tuple(device_param_controls))
        self.set_device_component(device)
        transport = SpecialTransportComponent()
        transport.set_play_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 20))
        transport.set_stop_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 21))
        transport.set_record_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 22))
        transport.set_seek_buttons(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 24), ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 25))
        transport.set_tap_tempo_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 94))
        transport.set_undo_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 23))
        transport.set_redo_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 27))
        transport.set_bts_button(ButtonElement(is_momentary, MIDI_CC_TYPE, 15, 26))
########NEW FILE########
__FILENAME__ = SpecialDeviceComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/OpenLabs/SpecialDeviceComponent.py
import Live
from _Framework.DeviceComponent import DeviceComponent

class SpecialDeviceComponent(DeviceComponent):

    def __init__(self):
        DeviceComponent.__init__(self)

    def _device_parameters_to_map(self):
        raise self.is_enabled() or AssertionError
        raise self._device != None or AssertionError
        raise self._parameter_controls != None or AssertionError
        return self._device.parameters[1:]
########NEW FILE########
__FILENAME__ = SpecialTransportComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/OpenLabs/SpecialTransportComponent.py
import Live
from _Framework.TransportComponent import TransportComponent
from _Framework.InputControlElement import *
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import EncoderElement

class SpecialTransportComponent(TransportComponent):
    """ Transport component that takes buttons for Undo and Redo """

    def __init__(self):
        TransportComponent.__init__(self)
        self._undo_button = None
        self._redo_button = None
        self._bts_button = None

    def disconnect(self):
        TransportComponent.disconnect(self)
        if self._undo_button != None:
            self._undo_button.remove_value_listener(self._undo_value)
            self._undo_button = None
        if self._redo_button != None:
            self._redo_button.remove_value_listener(self._redo_value)
            self._redo_button = None
        if self._bts_button != None:
            self._bts_button.remove_value_listener(self._bts_value)
            self._bts_button = None

    def set_undo_button(self, undo_button):
        if not isinstance(undo_button, (ButtonElement, type(None))):
            raise AssertionError
            if undo_button != self._undo_button:
                if self._undo_button != None:
                    self._undo_button.remove_value_listener(self._undo_value)
                self._undo_button = undo_button
                self._undo_button != None and self._undo_button.add_value_listener(self._undo_value)
            self.update()

    def set_redo_button(self, redo_button):
        if not isinstance(redo_button, (ButtonElement, type(None))):
            raise AssertionError
            if redo_button != self._redo_button:
                if self._redo_button != None:
                    self._redo_button.remove_value_listener(self._redo_value)
                self._redo_button = redo_button
                self._redo_button != None and self._redo_button.add_value_listener(self._redo_value)
            self.update()

    def set_bts_button(self, bts_button):
        if not isinstance(bts_button, (ButtonElement, type(None))):
            raise AssertionError
            if bts_button != self._bts_button:
                if self._bts_button != None:
                    self._bts_button.remove_value_listener(self._bts_value)
                self._bts_button = bts_button
                self._bts_button != None and self._bts_button.add_value_listener(self._bts_value)
            self.update()

    def _undo_value(self, value):
        if not self._undo_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self.is_enabled():
                    (value != 0 or not self._undo_button.is_momentary()) and self.song().can_undo and self.song().undo()

    def _redo_value(self, value):
        if not self._redo_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self.is_enabled():
                    (value != 0 or not self._redo_button.is_momentary()) and self.song().can_redo and self.song().redo()

    def _bts_value(self, value):
        if not self._bts_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                self.song().current_song_time = self.is_enabled() and (value != 0 or not self._bts_button.is_momentary()) and 0.0
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Oxygen49_61/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = (GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8,
 GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4)
VOLUME_CONTROLS = GENERIC_SLIDERS
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': -1,
 'PREVBANK': -1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'USB Oxygen',
 'OUTPUTPORT': 'USB Oxygen',
 'CHANNEL': 0}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': 7}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Oxygen49_61/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = 23
GENERIC_PLAY = 24
GENERIC_REC = 25
GENERIC_LOOP = 20
GENERIC_RWD = 21
GENERIC_FFWD = 22
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 75
GENERIC_ENC2 = 76
GENERIC_ENC3 = 92
GENERIC_ENC4 = 95
GENERIC_ENC5 = 10
GENERIC_ENC6 = 2
GENERIC_ENC7 = 12
GENERIC_ENC8 = 13
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 74
GENERIC_SLI2 = 71
GENERIC_SLI3 = 91
GENERIC_SLI4 = 93
GENERIC_SLI5 = 73
GENERIC_SLI6 = 72
GENERIC_SLI7 = 5
GENERIC_SLI8 = 84
GENERIC_SLI9 = 7
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8,
 GENERIC_SLI9)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Oxygen8/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
VOLUME_CONTROLS = GENERIC_SLIDERS
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': -1,
 'PREVBANK': -1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'Keystation (Port 1)',
 'OUTPUTPORT': 'Keystation (Port 1)',
 'CHANNEL': 0}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': -1}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Oxygen8/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = -1
GENERIC_PLAY = -1
GENERIC_REC = -1
GENERIC_LOOP = -1
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 10
GENERIC_ENC2 = 11
GENERIC_ENC3 = 12
GENERIC_ENC4 = 13
GENERIC_ENC5 = 14
GENERIC_ENC6 = 15
GENERIC_ENC7 = 16
GENERIC_ENC8 = 17
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = -1
GENERIC_SLI2 = -1
GENERIC_SLI3 = -1
GENERIC_SLI4 = -1
GENERIC_SLI5 = -1
GENERIC_SLI6 = -1
GENERIC_SLI7 = -1
GENERIC_SLI8 = -1
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Oxygen8v2/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD,
 'NORELEASE': 0}
DEVICE_CONTROLS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
VOLUME_CONTROLS = GENERIC_SLIDERS
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': -1,
 'PREVBANK': -1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'USB Oxygen 8 v2',
 'OUTPUTPORT': 'USB Oxygen 8 v2',
 'CHANNEL': 0}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': -1}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Oxygen8v2/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = 23
GENERIC_PLAY = 24
GENERIC_REC = 25
GENERIC_LOOP = 20
GENERIC_RWD = 21
GENERIC_FFWD = 22
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 71
GENERIC_ENC2 = 74
GENERIC_ENC3 = 84
GENERIC_ENC4 = 7
GENERIC_ENC5 = 91
GENERIC_ENC6 = 93
GENERIC_ENC7 = 5
GENERIC_ENC8 = 10
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = -1
GENERIC_SLI2 = -1
GENERIC_SLI3 = -1
GENERIC_SLI4 = -1
GENERIC_SLI5 = -1
GENERIC_SLI6 = -1
GENERIC_SLI7 = -1
GENERIC_SLI8 = -1
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = Oxygen_3rd_Gen
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Oxygen_3rd_Gen/Oxygen_3rd_Gen.py
from __future__ import with_statement
import Live
from _Framework.ControlSurface import ControlSurface
from _Framework.ControlElement import ControlElement
from _Framework.InputControlElement import *
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import EncoderElement
from _Framework.ChannelStripComponent import ChannelStripComponent
from _Framework.TransportComponent import TransportComponent
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from _Framework.ClipSlotComponent import ClipSlotComponent
from _Framework.SceneComponent import SceneComponent
from _Framework.SessionComponent import SessionComponent
from _Framework.DeviceComponent import DeviceComponent
from TransportViewModeSelector import TransportViewModeSelector
from SpecialMixerComponent import SpecialMixerComponent
IDENTITY_REQUEST = (240, 126, 127, 6, 1, 247)
IDENTITY_RESPONSE = (240, 126, 127, 6, 2)
NUM_TRACKS = 8
GLOBAL_CHANNEL = 15

class Oxygen_3rd_Gen(ControlSurface):
    """ Script for the 3rd generation of M-Audio's Oxygen controllers """

    def __init__(self, c_instance):
        ControlSurface.__init__(self, c_instance)
        with self.component_guard():
            is_momentary = True
            self._suggested_input_port = 'Oxygen'
            self._suggested_output_port = 'Oxygen'
            self._has_slider_section = True
            self._device_selection_follows_track_selection = True
            self._shift_button = ButtonElement(is_momentary, MIDI_CC_TYPE, GLOBAL_CHANNEL, 57)
            self._shift_button.add_value_listener(self._shift_value)
            self._mixer = SpecialMixerComponent(NUM_TRACKS)
            self._mute_solo_buttons = []
            self._track_up_button = ButtonElement(is_momentary, MIDI_CC_TYPE, GLOBAL_CHANNEL, 111)
            self._track_down_button = ButtonElement(is_momentary, MIDI_CC_TYPE, GLOBAL_CHANNEL, 110)
            self._master_slider = SliderElement(MIDI_CC_TYPE, GLOBAL_CHANNEL, 41)
            for index in range(NUM_TRACKS):
                self._mute_solo_buttons.append(ButtonElement(is_momentary, MIDI_CC_TYPE, GLOBAL_CHANNEL, 49 + index))
                self._mixer.channel_strip(index).set_volume_control(SliderElement(MIDI_CC_TYPE, GLOBAL_CHANNEL, 33 + index))

            self._shift_value(0)
            self._mixer.master_strip().set_volume_control(self._master_slider)
            self._mixer.selected_strip().set_volume_control(None)
            device = DeviceComponent()
            device.set_parameter_controls(tuple([ EncoderElement(MIDI_CC_TYPE, GLOBAL_CHANNEL, 17 + index, Live.MidiMap.MapMode.absolute) for index in range(8) ]))
            self.set_device_component(device)
            ffwd_button = ButtonElement(is_momentary, MIDI_CC_TYPE, GLOBAL_CHANNEL, 115)
            rwd_button = ButtonElement(is_momentary, MIDI_CC_TYPE, GLOBAL_CHANNEL, 114)
            loop_button = ButtonElement(is_momentary, MIDI_CC_TYPE, GLOBAL_CHANNEL, 113)
            transport = TransportComponent()
            transport.set_stop_button(ButtonElement(is_momentary, MIDI_CC_TYPE, GLOBAL_CHANNEL, 116))
            transport.set_play_button(ButtonElement(is_momentary, MIDI_CC_TYPE, GLOBAL_CHANNEL, 117))
            transport.set_record_button(ButtonElement(is_momentary, MIDI_CC_TYPE, GLOBAL_CHANNEL, 118))
            session = SessionComponent(0, 0)
            transport_view_modes = TransportViewModeSelector(transport, session, ffwd_button, rwd_button, loop_button)

    def disconnect(self):
        self._shift_button.remove_value_listener(self._shift_value)
        self._shift_button = None
        ControlSurface.disconnect(self)

    def refresh_state(self):
        ControlSurface.refresh_state(self)
        self.schedule_message(5, self._send_midi, IDENTITY_REQUEST)

    def handle_sysex(self, midi_bytes):
        if midi_bytes[0:5] == IDENTITY_RESPONSE:
            if midi_bytes[10] == 38:
                self._mixer.master_strip().set_volume_control(None)
                self._mixer.selected_strip().set_volume_control(self._master_slider)

    def _shift_value(self, value):
        raise value in range(128) or AssertionError
        for index in range(NUM_TRACKS):
            if value == 0:
                self._mixer.channel_strip(index).set_solo_button(None)
                self._mixer.channel_strip(index).set_mute_button(self._mute_solo_buttons[index])
                self._mixer.set_bank_buttons(None, None)
                self._mixer.set_select_buttons(self._track_up_button, self._track_down_button)
            else:
                self._mixer.channel_strip(index).set_mute_button(None)
                self._mixer.channel_strip(index).set_solo_button(self._mute_solo_buttons[index])
                self._mixer.set_select_buttons(None, None)
                self._mixer.set_bank_buttons(self._track_up_button, self._track_down_button)
########NEW FILE########
__FILENAME__ = SpecialMixerComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Oxygen_3rd_Gen/SpecialMixerComponent.py
from _Framework.MixerComponent import MixerComponent

class SpecialMixerComponent(MixerComponent):
    """ Special mixer class that uses return tracks alongside midi and audio tracks """

    def __init__(self, num_tracks):
        MixerComponent.__init__(self, num_tracks)
        self._selected_tracks = []
        self._register_timer_callback(self._on_timer)

    def disconnect(self):
        self._unregister_timer_callback(self._on_timer)
        self._selected_tracks = None
        MixerComponent.disconnect(self)

    def tracks_to_use(self):
        return tuple(self.song().visible_tracks) + tuple(self.song().return_tracks)

    def _on_timer(self):
        sel_track = None
        while len(self._selected_tracks) > 0:
            track = self._selected_tracks[-1]
            if track != None and track.has_midi_input and track.can_be_armed and not track.arm:
                sel_track = track
                break
            del self._selected_tracks[-1]

        if sel_track != None:
            found_recording_clip = False
            song = self.song()
            tracks = song.tracks
            if song.is_playing:
                check_arrangement = song.record_mode
                for track in tracks:
                    if track.can_be_armed and track.arm:
                        if check_arrangement:
                            found_recording_clip = True
                            break
                        else:
                            playing_slot_index = track.playing_slot_index
                            if playing_slot_index in range(len(track.clip_slots)):
                                slot = track.clip_slots[playing_slot_index]
                                if slot.has_clip and slot.clip.is_recording:
                                    found_recording_clip = True
                                    break

                if found_recording_clip or song.exclusive_arm:
                    for track in tracks:
                        if track.can_be_armed and track.arm and track != sel_track:
                            track.arm = False

                sel_track.arm = True
                sel_track.view.select_instrument()
        self._selected_tracks = []

    def _next_track_value(self, value):
        MixerComponent._next_track_value(self, value)
        self._selected_tracks.append(self.song().view.selected_track)

    def _prev_track_value(self, value):
        MixerComponent._prev_track_value(self, value)
        self._selected_tracks.append(self.song().view.selected_track)
########NEW FILE########
__FILENAME__ = TransportViewModeSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Oxygen_3rd_Gen/TransportViewModeSelector.py
import Live
from _Framework.ModeSelectorComponent import ModeSelectorComponent
from _Framework.ButtonElement import ButtonElement
from _Framework.TransportComponent import TransportComponent
from _Framework.SessionComponent import SessionComponent

class TransportViewModeSelector(ModeSelectorComponent):
    """ Class that reassigns specific buttons based on the views visible in Live """

    def __init__(self, transport, session, ffwd_button, rwd_button, loop_button):
        raise isinstance(transport, TransportComponent) or AssertionError
        raise isinstance(session, SessionComponent) or AssertionError
        raise isinstance(ffwd_button, ButtonElement) or AssertionError
        raise isinstance(rwd_button, ButtonElement) or AssertionError
        raise isinstance(loop_button, ButtonElement) or AssertionError
        ModeSelectorComponent.__init__(self)
        self._transport = transport
        self._session = session
        self._ffwd_button = ffwd_button
        self._rwd_button = rwd_button
        self._loop_button = loop_button
        self.application().view.add_is_view_visible_listener('Session', self._on_view_changed)
        self.update()

    def disconnect(self):
        ModeSelectorComponent.disconnect(self)
        self._transport = None
        self._session = None
        self._ffwd_button = None
        self._rwd_button = None
        self._loop_button = None
        self.application().view.remove_is_view_visible_listener('Session', self._on_view_changed)

    def update(self):
        if self.is_enabled():
            if self._mode_index == 0:
                self._transport.set_seek_buttons(self._ffwd_button, self._rwd_button)
                self._transport.set_loop_button(self._loop_button)
                self._session.set_select_buttons(None, None)
                self._session.selected_scene().set_launch_button(None)
            else:
                self._transport.set_seek_buttons(None, None)
                self._transport.set_loop_button(None)
                self._session.set_select_buttons(self._ffwd_button, self._rwd_button)
                self._session.selected_scene().set_launch_button(self._loop_button)

    def _on_view_changed(self):
        if self.application().view.is_view_visible('Session'):
            self._mode_index = 1
        else:
            self._mode_index = 0
        self.update()
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Ozone/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
VOLUME_CONTROLS = ((GENERIC_SLI1, -1),
 (GENERIC_SLI2, -1),
 (GENERIC_SLI3, -1),
 (GENERIC_SLI4, -1),
 (GENERIC_SLI5, -1),
 (GENERIC_SLI6, -1),
 (GENERIC_SLI7, -1),
 (GENERIC_SLI8, -1))
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': GENERIC_PAD5,
 'PREVBANK': GENERIC_PAD1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
CONTROLLER_DESCRIPTIONS = {'INPUTPORT': 'Ozone',
 'OUTPUTPORT': 'Ozone',
 'CHANNEL': 0}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': 7}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Ozone/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = -1
GENERIC_PLAY = -1
GENERIC_REC = -1
GENERIC_LOOP = -1
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 74
GENERIC_ENC2 = 71
GENERIC_ENC3 = 81
GENERIC_ENC4 = 91
GENERIC_ENC5 = 16
GENERIC_ENC6 = 80
GENERIC_ENC7 = 19
GENERIC_ENC8 = 2
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = -1
GENERIC_SLI2 = -1
GENERIC_SLI3 = -1
GENERIC_SLI4 = -1
GENERIC_SLI5 = -1
GENERIC_SLI6 = -1
GENERIC_SLI7 = -1
GENERIC_SLI8 = -1
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Ozonic/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
VOLUME_CONTROLS = GENERIC_SLIDERS
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': -1,
 'PREVBANK': -1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'Ozonic (Keyboard)',
 'OUTPUTPORT': 'Ozonic (Keyboard)',
 'CHANNEL': 0}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': 7}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Ozonic/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = -1
GENERIC_PLAY = -1
GENERIC_REC = -1
GENERIC_LOOP = -1
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 10
GENERIC_ENC2 = 2
GENERIC_ENC3 = 92
GENERIC_ENC4 = 95
GENERIC_ENC5 = 16
GENERIC_ENC6 = 17
GENERIC_ENC7 = 18
GENERIC_ENC8 = 19
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 73
GENERIC_SLI2 = 9
GENERIC_SLI3 = 12
GENERIC_SLI4 = 72
GENERIC_SLI5 = 91
GENERIC_SLI6 = 93
GENERIC_SLI7 = 5
GENERIC_SLI8 = 84
GENERIC_SLI9 = 7
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8,
 GENERIC_SLI9)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/padKONTROL/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
VOLUME_CONTROLS = GENERIC_SLIDERS
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': -1,
 'PREVBANK': -1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
PAD_TRANSLATION = ((0, 0, 61, 9),
 (1, 0, 69, 9),
 (2, 0, 65, 9),
 (3, 0, 63, 9),
 (0, 1, 60, 9),
 (1, 1, 59, 9),
 (2, 1, 57, 9),
 (3, 1, 55, 9),
 (0, 2, 49, 9),
 (1, 2, 51, 9),
 (2, 2, 68, 9),
 (3, 2, 56, 9),
 (0, 3, 48, 9),
 (1, 3, 52, 9),
 (2, 3, 54, 9),
 (3, 3, 58, 9))
CONTROLLER_DESCRIPTIONS = {'INPUTPORT': 'padKONTROL (Port 2)',
 'OUTPUTPORT': 'padKONTROL (Port 2)',
 'CHANNEL': 9,
 'PAD_TRANSLATION': PAD_TRANSLATION}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': 21}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/padKONTROL/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = -1
GENERIC_PLAY = -1
GENERIC_REC = -1
GENERIC_LOOP = -1
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = -1
GENERIC_ENC2 = -1
GENERIC_ENC3 = -1
GENERIC_ENC4 = -1
GENERIC_ENC5 = -1
GENERIC_ENC6 = -1
GENERIC_ENC7 = -1
GENERIC_ENC8 = -1
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = -1
GENERIC_SLI2 = -1
GENERIC_SLI3 = -1
GENERIC_SLI4 = -1
GENERIC_SLI5 = -1
GENERIC_SLI6 = -1
GENERIC_SLI7 = -1
GENERIC_SLI8 = -1
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Photon_25/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
VOLUME_CONTROLS = ((GENERIC_SLI1, -1),
 (GENERIC_SLI2, -1),
 (GENERIC_SLI3, -1),
 (GENERIC_SLI4, -1),
 (GENERIC_SLI5, -1),
 (GENERIC_SLI6, -1),
 (GENERIC_SLI7, -1),
 (GENERIC_SLI8, -1))
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': GENERIC_PAD5,
 'PREVBANK': GENERIC_PAD1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
CONTROLLER_DESCRIPTIONS = {'INPUTPORT': 'Photon 25',
 'OUTPUTPORT': 'Photon 25',
 'CHANNEL': 0}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': -1}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Photon_25/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = -1
GENERIC_PLAY = -1
GENERIC_REC = -1
GENERIC_LOOP = -1
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 10
GENERIC_ENC2 = 14
GENERIC_ENC3 = 16
GENERIC_ENC4 = 18
GENERIC_ENC5 = 7
GENERIC_ENC6 = 15
GENERIC_ENC7 = 17
GENERIC_ENC8 = 19
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = -1
GENERIC_SLI2 = -1
GENERIC_SLI3 = -1
GENERIC_SLI4 = -1
GENERIC_SLI5 = -1
GENERIC_SLI6 = -1
GENERIC_SLI7 = -1
GENERIC_SLI8 = -1
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Photon_X25/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = ((GENERIC_ENC1, 0),
 (GENERIC_ENC2, 1),
 (GENERIC_ENC3, 2),
 (GENERIC_ENC4, 3),
 (GENERIC_ENC5, 0),
 (GENERIC_ENC6, 1),
 (GENERIC_ENC7, 2),
 (GENERIC_ENC8, 3))
VOLUME_CONTROLS = ((GENERIC_SLI1, -1),
 (GENERIC_SLI2, -1),
 (GENERIC_SLI3, -1),
 (GENERIC_SLI4, -1),
 (GENERIC_SLI5, -1),
 (GENERIC_SLI6, -1),
 (GENERIC_SLI7, -1),
 (GENERIC_SLI8, -1))
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': GENERIC_PAD5,
 'PREVBANK': GENERIC_PAD1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
CONTROLLER_DESCRIPTIONS = {'INPUTPORT': 'PhotonX25',
 'OUTPUTPORT': 'PhotonX25',
 'CHANNEL': 0}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': -1}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Photon_X25/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = -1
GENERIC_PLAY = -1
GENERIC_REC = -1
GENERIC_LOOP = -1
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 108
GENERIC_ENC2 = 108
GENERIC_ENC3 = 108
GENERIC_ENC4 = 108
GENERIC_ENC5 = 107
GENERIC_ENC6 = 107
GENERIC_ENC7 = 107
GENERIC_ENC8 = 107
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = -1
GENERIC_SLI2 = -1
GENERIC_SLI3 = -1
GENERIC_SLI4 = -1
GENERIC_SLI5 = -1
GENERIC_SLI6 = -1
GENERIC_SLI7 = -1
GENERIC_SLI8 = -1
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = ProjectMixIO
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/ProjectMixIO/ProjectMixIO.py
from MackieControl.consts import *
from MackieControl.MainDisplay import MainDisplay
from MackieControl.MainDisplayController import MainDisplayController
from MackieControl.ChannelStripController import ChannelStripController
from MackieControl.ChannelStrip import ChannelStrip
from MackieControl.ChannelStrip import MasterChannelStrip
from MackieControl.SoftwareController import SoftwareController
from MackieControl.Transport import Transport
import Live

class ProjectMixIO:
    """Subset of the Mackie Control Script, that works with the ProjectMix in
       Live Mackie Control Mode.
    """

    def __init__(self, c_instance):
        self.__c_instance = c_instance
        self.__components = []
        self.__main_display = MainDisplay(self)
        self.__components.append(self.__main_display)
        self.__main_display_controller = MainDisplayController(self, self.__main_display)
        self.__components.append(self.__main_display_controller)
        self.__software_controller = SoftwareController(self)
        self.__components.append(self.__software_controller)
        self.__transport = Transport(self)
        self.__components.append(self.__transport)
        self.__channel_strips = [ ChannelStrip(self, i) for i in range(NUM_CHANNEL_STRIPS) ]
        for s in self.__channel_strips:
            self.__components.append(s)

        self.__master_strip = MasterChannelStrip(self)
        self.__components.append(self.__master_strip)
        self.__channel_strip_controller = ChannelStripController(self, self.__channel_strips, self.__master_strip, self.__main_display_controller)
        self.__components.append(self.__channel_strip_controller)
        self.__shift_is_pressed = False
        self.__option_is_pressed = False
        self.__ctrl_is_pressed = False
        self.__alt_is_pressed = False

    def disconnect(self):
        for c in self.__components:
            c.destroy()

    def disconnect(self):
        for c in self.__components:
            c.destroy()

    def connect_script_instances(self, instanciated_scripts):
        pass

    def application(self):
        """returns a reference to the application that we are running in"""
        return Live.Application.get_application()

    def song(self):
        """returns a reference to the Live Song that we do interact with"""
        return self.__c_instance.song()

    def handle(self):
        """returns a handle to the c_interface that is needed when forwarding MIDI events
           via the MIDI map
        """
        return self.__c_instance.handle()

    def refresh_state(self):
        for c in self.__components:
            c.refresh_state()

    def is_extension(self):
        return False

    def request_rebuild_midi_map(self):
        self.__c_instance.request_rebuild_midi_map()

    def build_midi_map(self, midi_map_handle):
        for s in self.__channel_strips:
            s.build_midi_map(midi_map_handle)

        self.__master_strip.build_midi_map(midi_map_handle)
        for i in range(SID_FIRST, SID_LAST + 1):
            if i not in function_key_control_switch_ids:
                Live.MidiMap.forward_midi_note(self.handle(), midi_map_handle, 0, i)

        Live.MidiMap.forward_midi_cc(self.handle(), midi_map_handle, 0, JOG_WHEEL_CC_NO)

    def update_display(self):
        for c in self.__components:
            c.on_update_display_timer()

    def send_midi(self, midi_event_bytes):
        self.__c_instance.send_midi(midi_event_bytes)

    def receive_midi(self, midi_bytes):
        if midi_bytes[0] & 240 == NOTE_ON_STATUS or midi_bytes[0] & 240 == NOTE_OFF_STATUS:
            note = midi_bytes[1]
            value = BUTTON_PRESSED if midi_bytes[2] > 0 else BUTTON_RELEASED
            if note in range(SID_FIRST, SID_LAST + 1):
                if note in display_switch_ids:
                    self.handle_display_switch_ids(note, value)
                if note in channel_strip_switch_ids + fader_touch_switch_ids:
                    for s in self.__channel_strips:
                        s.handle_channel_strip_switch_ids(note, value)

                if note in channel_strip_control_switch_ids:
                    self.__channel_strip_controller.handle_assignment_switch_ids(note, value)
                if note in function_key_control_switch_ids:
                    self.__software_controller.handle_function_key_switch_ids(note, value)
                if note in software_controls_switch_ids:
                    self.__software_controller.handle_software_controls_switch_ids(note, value)
                if note in transport_control_switch_ids:
                    self.__transport.handle_transport_switch_ids(note, value)
                if note in marker_control_switch_ids:
                    self.__transport.handle_marker_switch_ids(note, value)
                if note in jog_wheel_switch_ids:
                    self.__transport.handle_jog_wheel_switch_ids(note, value)
        elif midi_bytes[0] & 240 == CC_STATUS:
            cc_no = midi_bytes[1]
            cc_value = midi_bytes[2]
            if cc_no == JOG_WHEEL_CC_NO:
                self.__transport.handle_jog_wheel_rotation(cc_value)
            elif cc_no in range(FID_PANNING_BASE, FID_PANNING_BASE + NUM_CHANNEL_STRIPS):
                for s in self.__channel_strips:
                    s.handle_vpot_rotation(cc_no - FID_PANNING_BASE, cc_value)

    def shift_is_pressed(self):
        return self.__shift_is_pressed

    def set_shift_is_pressed(self, pressed):
        self.__shift_is_pressed = pressed

    def option_is_pressed(self):
        return self.__option_is_pressed

    def set_option_is_pressed(self, pressed):
        self.__option_is_pressed = pressed

    def control_is_pressed(self):
        return self.__control_is_pressed or self.__option_is_pressed

    def set_control_is_pressed(self, pressed):
        self.__control_is_pressed = pressed

    def alt_is_pressed(self):
        return self.__alt_is_pressed

    def set_alt_is_pressed(self, pressed):
        self.__alt_is_pressed = pressed

    def force_time_display_update(self):
        pass

    def handle_display_switch_ids(self, switch_id, value):
        if switch_id == SID_DISPLAY_NAME_VALUE:
            if value == BUTTON_PRESSED:
                self.__channel_strip_controller.toggle_meter_mode()
########NEW FILE########
__FILENAME__ = AccentComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/AccentComponent.py
from _Framework.ModesComponent import ModesComponent

class DummyFullVelocity(object):
    enabled = False


class AccentComponent(ModesComponent):

    def __init__(self, *a, **k):
        super(AccentComponent, self).__init__(*a, **k)
        self._full_velocity = None
        self.add_mode('disabled', None)
        self.add_mode('enabled', (self._on_accent_on, self._on_accent_off), 'DefaultButton.On')
        self.selected_mode = 'disabled'
        self.set_full_velocity(None)

    def set_full_velocity(self, full_velocity):
        if not full_velocity:
            full_velocity = DummyFullVelocity()
            self._full_velocity.enabled = self._full_velocity != None and False
        self._full_velocity = full_velocity
        self._full_velocity.enabled = self.selected_mode == 'enabled'

    @property
    def activated(self):
        return self._full_velocity.enabled

    def _on_accent_off(self):
        self._full_velocity.enabled = False

    def _on_accent_on(self):
        self._full_velocity.enabled = True
########NEW FILE########
__FILENAME__ = Actions
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/Actions.py
import Live
_Q = Live.Song.Quantization
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.CompoundComponent import CompoundComponent
from _Framework.SubjectSlot import subject_slot
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.ModesComponent import SetAttributeMode, ModesComponent
from _Framework import Task
from _Framework.Util import forward_property
from _Framework.Dependency import depends
from MessageBoxComponent import Messenger
from ActionWithOptionsComponent import ActionWithSettingsComponent, OptionsComponent
from ClipControlComponent import convert_length_to_bars_beats_sixteenths
from BrowserModes import BrowserAddEffectMode
from consts import MessageBoxText

def convert_length_to_mins_secs(length_in_secs):
    if length_in_secs is None:
        return '-'
    mins = int(length_in_secs / 60.0)
    secs = int(length_in_secs % 60.0)
    return str(mins) + ':' + str('%02d' % secs)


def convert_beats_to_mins_secs(length_in_beats, tempo = 120.0):
    if length_in_beats is None:
        return '-'
    length_in_secs = length_in_beats / tempo * 60.0
    return convert_length_to_mins_secs(length_in_secs)


class CaptureAndInsertSceneComponent(ActionWithSettingsComponent, Messenger):

    def post_trigger_action(self):
        try:
            self.song().capture_and_insert_scene()
            self.show_notification(MessageBoxText.CAPTURE_AND_INSERT_SCENE % self.song().view.selected_scene.name.strip())
        except Live.Base.LimitationError:
            self.expect_dialog(MessageBoxText.SCENE_LIMIT_REACHED)


class DuplicateDetailClipComponent(ActionWithSettingsComponent, Messenger):

    def post_trigger_action(self):
        view = self.song().view
        clip = view.detail_clip
        if clip != None:
            slot = clip.canonical_parent
            track = slot.canonical_parent
            try:
                start_duplicate = clip.is_playing
                target_index = list(track.clip_slots).index(slot)
                destination_index = track.duplicate_clip_slot(target_index)
                view.highlighted_clip_slot = track.clip_slots[destination_index]
                view.detail_clip = view.highlighted_clip_slot.clip
                if start_duplicate:
                    view.highlighted_clip_slot.fire(force_legato=True, launch_quantization=_Q.q_no_q)
                self.show_notification(MessageBoxText.DUPLICATE_CLIP % clip.name)
            except Live.Base.LimitationError:
                self.expect_dialog(MessageBoxText.SCENE_LIMIT_REACHED)
            except RuntimeError:
                self.show_notification(MessageBoxText.CLIP_DUPLICATION_FAILED)


class DuplicateLoopComponent(ActionWithSettingsComponent, Messenger):

    def __init__(self, *a, **k):
        super(DuplicateLoopComponent, self).__init__(*a, **k)
        self._on_detail_clip_changed.subject = self.song().view

    @subject_slot('detail_clip')
    def _on_detail_clip_changed(self):
        self._update_action_button()

    @property
    def can_duplicate_loop(self):
        clip = self.song().view.detail_clip
        return clip and clip.is_midi_clip

    def _update_action_button(self):
        if self.can_duplicate_loop:
            super(DuplicateLoopComponent, self)._update_action_button()
        elif self._action_button and self.is_enabled():
            self._action_button.set_light('DefaultButton.Disabled')

    def trigger_action(self):
        if self.can_duplicate_loop:
            clip = self.song().view.detail_clip
            if clip != None:
                try:
                    clip.duplicate_loop()
                    self.show_notification(MessageBoxText.DUPLICATE_LOOP % dict(length=convert_length_to_bars_beats_sixteenths(clip.loop_end - clip.loop_start)))
                except RuntimeError:
                    pass


class DeleteSelectedClipComponent(ActionWithSettingsComponent, Messenger):
    """
    Component that deletes the selected clip when tapping
    """

    def post_trigger_action(self):
        slot = self.song().view.highlighted_clip_slot
        if slot != None and slot.has_clip:
            name = slot.clip.name
            slot.delete_clip()
            self.show_notification(MessageBoxText.DELETE_CLIP % name)


class DeleteSelectedSceneComponent(ActionWithSettingsComponent, Messenger):
    """
    Component for deleting the selected scene and launch the previous
    one in scene list mode
    """

    def post_trigger_action(self):
        try:
            song = self.song()
            name = song.view.selected_scene.name
            selected_scene_index = list(song.scenes).index(song.view.selected_scene)
            song.delete_scene(selected_scene_index)
            self.show_notification(MessageBoxText.DELETE_SCENE % name)
            new_scene = song.scenes[max(selected_scene_index - 1, 0)]
            song.view.selected_scene = new_scene
            new_scene.fire(force_legato=True)
        except RuntimeError:
            pass


class SelectionDisplayComponent(ControlSurfaceComponent):
    """
    This component handles display of selected objects.
    """
    num_segments = 4

    def __init__(self, *a, **k):
        super(SelectionDisplayComponent, self).__init__(*a, **k)
        self._data_sources = [ DisplayDataSource() for _ in range(self.num_segments) ]

    def set_display_line(self, display_line):
        if display_line != None:
            display_line.set_num_segments(self.num_segments)
            for idx in xrange(self.num_segments):
                display_line.segment(idx).set_data_source(self._data_sources[idx])

    def set_display_string(self, string, segment = 0):
        if segment < self.num_segments:
            self._data_sources[segment].set_display_string(string)

    def reset_display(self):
        for idx in xrange(self.num_segments):
            self._data_sources[idx].set_display_string(' ')

    def reset_display_right(self):
        for idx in xrange(self.num_segments / 2, self.num_segments):
            self._data_sources[idx].set_display_string(' ')

    def update(self):
        pass


class SelectComponent(CompoundComponent):
    """
    This component handles selection of objects.
    """

    def __init__(self, *a, **k):
        super(SelectComponent, self).__init__(*a, **k)
        self._selected_clip = None
        self._select_button = None
        self._selection_display = self.register_component(SelectionDisplayComponent())
        self._selection_display.set_enabled(False)

    selection_display_layer = forward_property('_selection_display')('layer')

    def set_select_button(self, button):
        if self._select_button != button:
            self._select_button = button
            self._on_select_value.subject = button

    def set_selected_clip(self, clip):
        self._selected_clip = clip
        self._on_playing_position_changed.subject = clip

    def on_select_clip(self, clip_slot):
        if clip_slot != None:
            if self.song().view.highlighted_clip_slot != clip_slot:
                self.song().view.highlighted_clip_slot = clip_slot
            if clip_slot.has_clip:
                clip = clip_slot.clip
                clip_name = clip.name if clip.name != '' else '[unnamed]'
                self.set_selected_clip(clip)
            else:
                clip_name = '[empty slot]'
                self.set_selected_clip(None)
        else:
            clip_name = '[none]'
        self._selection_display.set_display_string('Clip Selection:')
        self._selection_display.set_display_string(clip_name, 1)
        self._do_show_time_remaining()
        self._selection_display.set_enabled(True)

    @subject_slot('playing_position')
    def _on_playing_position_changed(self):
        self._do_show_time_remaining()

    def _do_show_time_remaining(self):
        clip = self._selected_clip
        if clip != None and (clip.is_triggered or clip.is_playing):
            if clip.is_recording:
                label = 'Record Count:'
                length = (clip.playing_position - clip.loop_start) * clip.signature_denominator / clip.signature_numerator
                time = convert_length_to_bars_beats_sixteenths(length)
            else:
                label = 'Time Remaining:'
                length = clip.loop_end - clip.playing_position
                if clip.is_audio_clip and not clip.warping:
                    time = convert_length_to_mins_secs(length)
                else:
                    time = convert_beats_to_mins_secs(length, self.song().tempo)
        else:
            label = ' '
            time = ' '
        self._selection_display.set_display_string(label, 2)
        self._selection_display.set_display_string(time, 3)

    def on_select_scene(self, scene):
        if scene != None:
            if self.song().view.selected_scene != scene:
                self.song().view.selected_scene = scene
            scene_name = scene.name if scene.name != '' else '[unnamed]'
        else:
            scene_name = '[none]'
        self._selection_display.set_display_string('Scene Selection:')
        self._selection_display.set_display_string(scene_name, 1)
        self._selection_display.reset_display_right()
        self._selection_display.set_enabled(True)

    def on_select_track(self, track):
        if track != None:
            track_name = track.name if track.name != '' else '[unnamed]'
        else:
            track_name = '[none]'
        self._selection_display.set_display_string('Track Selection:')
        self._selection_display.set_display_string(track_name, 1)
        self._selection_display.reset_display_right()
        self._selection_display.set_enabled(True)

    def on_select_drum_pad(self, drum_pad):
        if drum_pad != None:
            drum_pad_name = drum_pad.name if drum_pad.name != '' else '[unnamed]'
        else:
            drum_pad_name = '[none]'
        self._selection_display.set_display_string('Pad Selection:')
        self._selection_display.set_display_string(drum_pad_name, 1)
        self._selection_display.reset_display_right()
        self._selection_display.set_enabled(True)

    @subject_slot('value')
    def _on_select_value(self, value):
        if value == 0:
            self._selection_display.set_enabled(False)
            self._selection_display.reset_display()
            self.set_selected_clip(None)

    def update(self):
        pass


class DeleteComponent(ControlSurfaceComponent, Messenger):
    """
    Component for handling deletion of parameters
    """

    def __init__(self, *a, **k):
        super(DeleteComponent, self).__init__(*a, **k)
        self._delete_button = None

    def set_delete_button(self, button):
        self._delete_button = button

    @property
    def is_deleting(self):
        return self._delete_button and self._delete_button.is_pressed()

    def delete_clip_envelope(self, parameter):
        playing_clip = self._get_playing_clip()
        if playing_clip:
            playing_clip.clear_envelope(parameter)
            self.show_notification(MessageBoxText.DELETE_ENVELOPE % dict(automation=parameter.name))

    def _get_playing_clip(self):
        selected_track = self.song().view.selected_track
        playing_slot_index = selected_track.playing_slot_index
        if playing_slot_index >= 0:
            return selected_track.clip_slots[playing_slot_index].clip

    def update(self):
        pass


class CreateDefaultTrackComponent(CompoundComponent, Messenger):

    @depends(selection=None)
    def __init__(self, selection = None, *a, **k):
        super(CreateDefaultTrackComponent, self).__init__(*a, **k)
        self.options = self.register_component(OptionsComponent())
        self.options.selected_option = None
        self.options.option_names = ('Audio', 'Midi', 'Return')
        self.options.labels = ('Create track:', '', '', '')
        self.options.selected_color = 'Browser.Load'
        self.options.unselected_color = 'Browser.Load'
        self._on_option_selected.subject = self.options
        self._selection = selection

    @subject_slot('selected_option')
    def _on_option_selected(self, option):
        if option is not None:
            self.create_track()
            self.options.selected_option = None

    def create_track(self):
        try:
            song = self.song()
            selected_track = self._selection.selected_track
            idx = list(song.tracks).index(selected_track) + 1 if selected_track in song.tracks else -1
            selected_option = self.options.selected_option
            if selected_option == 0:
                song.create_audio_track(idx)
            elif selected_option == 1:
                song.create_midi_track(idx)
            elif selected_option == 2:
                song.create_return_track()
        except Live.Base.LimitationError:
            self.expect_dialog(MessageBoxText.TRACK_LIMIT_REACHED)
        except RuntimeError:
            self.expect_dialog(MessageBoxText.MAX_RETURN_TRACKS_REACHED)

    def on_enabled_changed(self):
        self.options.selected_option = None

    def update(self):
        pass


class CreateInstrumentTrackComponent(CompoundComponent, Messenger):

    @depends(selection=None)
    def __init__(self, selection = None, browser_mode = None, browser_component = None, browser_hotswap_mode = None, *a, **k):
        super(CreateInstrumentTrackComponent, self).__init__(*a, **k)
        self._selection = selection
        self._with_browser_modes = self.register_component(ModesComponent())
        self._with_browser_modes.add_mode('create', [self._prepare_browser,
         SetAttributeMode(self.application().browser, 'filter_type', Live.Browser.FilterType.instrument_hotswap),
         SetAttributeMode(browser_component, 'do_load_item', self._do_browser_load_item),
         browser_mode,
         browser_component.reset_load_memory])
        self._with_browser_modes.add_mode('hotswap', [browser_hotswap_mode, browser_mode])
        self._go_to_hotswap_task = self._tasks.add(Task.sequence(Task.delay(1), Task.run(self._go_to_hotswap)))
        self._go_to_hotswap_task.kill()

    def on_enabled_changed(self):
        self._with_browser_modes.selected_mode = 'create' if self.is_enabled() else None
        self._go_to_hotswap_task.kill()

    def _prepare_browser(self):
        self.application().browser.hotswap_target = None

    def _do_browser_load_item(self, item):
        song = self.song()
        selected_track = self._selection.selected_track
        idx = list(song.tracks).index(selected_track) + 1 if selected_track in song.tracks else -1
        try:
            song.create_midi_track(idx)
        except Live.Base.LimitationError:
            self.expect_dialog(MessageBoxText.TRACK_LIMIT_REACHED)

        item.action()
        self._go_to_hotswap_task.restart()

    def _go_to_hotswap(self):
        self._with_browser_modes.selected_mode = 'hotswap'

    def update(self):
        pass


class CreateDeviceComponent(CompoundComponent):

    @depends(selection=None)
    def __init__(self, selection = None, browser_component = None, browser_mode = None, browser_hotswap_mode = None, insert_left = False, *a, **k):
        super(CreateDeviceComponent, self).__init__(*a, **k)
        self._selection = selection
        self._add_effect_mode = BrowserAddEffectMode(selection=selection, browser=self.application().browser, application_view=self.application().view, insert_left=insert_left)
        self._create_device_modes = self.register_component(ModesComponent())
        self._create_device_modes.add_mode('create', [SetAttributeMode(browser_component, 'do_load_item', self._do_browser_load_item),
         self._add_effect_mode,
         browser_mode,
         browser_component.reset_load_memory])
        self._create_device_modes.add_mode('hotswap', [browser_hotswap_mode, browser_mode])
        self._go_to_hotswap_task = self._tasks.add(Task.sequence(Task.delay(1), Task.run(self._go_to_hotswap)))
        self._go_to_hotswap_task.kill()

    def on_enabled_changed(self):
        self._go_to_hotswap_task.kill()
        if self.is_enabled():
            selected = self._selection.selected_object
            if isinstance(selected, Live.DrumPad.DrumPad) and (not selected.chains or not selected.chains[0].devices):
                self._create_device_modes.selected_mode = 'hotswap'
            else:
                self._create_device_modes.selected_mode = 'create'

    def update(self):
        pass

    def _go_to_hotswap(self):
        self._create_device_modes.selected_mode = 'hotswap'

    def _do_browser_load_item(self, item):
        selection = self._add_effect_mode.get_selection_for_insert()
        if selection:
            self._selection.selected_object = selection
        item.action()
        self._go_to_hotswap_task.restart()
########NEW FILE########
__FILENAME__ = ActionWithOptionsComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/ActionWithOptionsComponent.py
from _Framework.CompoundComponent import CompoundComponent
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.SubjectSlot import subject_slot, subject_slot_group
from _Framework.Util import in_range, clamp
from _Framework import Task
from _Framework import Defaults
import consts

class ActionWithSettingsComponent(CompoundComponent):
    SETTINGS_DELAY = Defaults.MOMENTARY_DELAY

    def __init__(self, *a, **k):
        super(ActionWithSettingsComponent, self).__init__(*a, **k)
        self._is_showing_settings = False
        self._action_button = None
        self._settings_task = Task.Task()

    def set_action_button(self, action_button):
        raise not action_button or action_button.is_momentary() or AssertionError
        self._action_button = action_button
        self._on_action_button_value.subject = action_button
        self._update_action_button()

    def show_settings(self):
        """ Please override. Returns True if succeeded to show settings """
        return True

    def hide_settings(self):
        """ Please override """
        pass

    def trigger_action(self):
        """ Called whenever action button is pressed. """
        pass

    def post_trigger_action(self):
        """ Called whenever action button is released. Unless settings
        are shown."""
        pass

    def _do_show_settings(self):
        self._is_showing_settings = self.show_settings()

    def _do_hide_settings(self):
        self.hide_settings()
        self._is_showing_settings = False

    @subject_slot('value')
    def _on_action_button_value(self, value):
        if self.is_enabled():
            self._settings_task.kill()
            if value:
                self._settings_task = self._tasks.add(Task.sequence(Task.wait(self.SETTINGS_DELAY), Task.run(self._do_show_settings)))
                self.trigger_action()
            elif self._is_showing_settings:
                self.hide_settings()
                self._is_showing_settings = False
            else:
                self.post_trigger_action()
            self._update_action_button()

    def update(self):
        self._update_action_button()

    def _update_action_button(self):
        """ Can be overridden """
        if self.is_enabled() and self._action_button:
            self._action_button.set_light(self._action_button.is_pressed())


class OptionsComponent(ControlSurfaceComponent):
    __subject_events__ = ('selected_option',)
    unselected_color = 'Option.Unselected'
    selected_color = 'Option.Selected'
    _selected_option = None

    def __init__(self, num_options = 8, num_labels = 4, num_display_segments = None, *a, **k):
        super(OptionsComponent, self).__init__(*a, **k)
        num_display_segments = num_display_segments or num_options
        self._label_data_sources = [ DisplayDataSource() for _ in xrange(num_labels) ]
        self._data_sources = [ DisplayDataSource() for _ in xrange(num_display_segments) ]
        self._select_buttons = None
        self._option_names = []

    def _get_option_names(self):
        return self._option_names

    def _set_option_names(self, value):
        self._option_names = value
        if self._selected_option:
            currently_selected_option = self.selected_option
            self.selected_option = clamp(self._selected_option, 0, len(self._option_names) - 1)
            if currently_selected_option != self.selected_option:
                self.notify_selected_option(self.selected_option)
        self._update_data_sources()

    option_names = property(_get_option_names, _set_option_names)

    def _get_selected_option(self):
        return self._selected_option

    def _set_selected_option(self, selected_option):
        raise in_range(selected_option, 0, len(self.option_names)) or selected_option is None or AssertionError
        self._selected_option = selected_option
        self._update_select_buttons()
        self._update_data_sources()

    selected_option = property(_get_selected_option, _set_selected_option)

    def update(self):
        self._update_select_buttons()

    def set_display_line(self, line):
        if line:
            self._update_data_sources()
            line.set_num_segments(len(self._data_sources))
            for segment in xrange(len(self._data_sources)):
                line.segment(segment).set_data_source(self._data_sources[segment])

    def set_label_display_line(self, line):
        if line:
            line.set_num_segments(len(self._label_data_sources))
            for segment in xrange(len(self._label_data_sources)):
                line.segment(segment).set_data_source(self._label_data_sources[segment])

    def _get_labels(self):
        return map(lambda segment: segment.display_string(), self._label_data_sources)

    def _set_labels(self, labels):
        for segment, label in map(None, self._label_data_sources, labels or []):
            segment.set_display_string(label)

    labels = property(_get_labels, _set_labels)

    def set_blank_display_line1(self, line):
        if line:
            line.reset()

    def set_blank_display_line2(self, line):
        if line:
            line.reset()

    def set_select_buttons(self, buttons):
        buttons = buttons or []
        self._select_buttons = buttons
        self._on_select_value.replace_subjects(buttons)
        self._update_select_buttons()

    def set_state_buttons(self, buttons):
        if buttons:
            buttons.reset()

    @subject_slot_group('value')
    def _on_select_value(self, value, sender):
        if value:
            index = list(self._select_buttons).index(sender)
            if in_range(index, 0, len(self.option_names)):
                self.selected_option = index
                self.notify_selected_option(self.selected_option)

    def _update_select_buttons(self):
        if self.is_enabled() and self._select_buttons:
            for index, button in enumerate(self._select_buttons):
                if button:
                    if index == self._selected_option:
                        button.set_light(self.selected_color)
                    elif in_range(index, 0, len(self.option_names)):
                        button.set_light(self.unselected_color)
                    else:
                        button.set_light('DefaultButton.Disabled')

    def _update_data_sources(self):
        for index, (source, name) in enumerate(map(None, self._data_sources, self.option_names)):
            if name:
                source.set_display_string((consts.CHAR_SELECT if index == self._selected_option else ' ') + name)
            else:
                source.set_display_string('')


class ActionWithOptionsComponent(ActionWithSettingsComponent):

    def __init__(self, num_options = 8, *a, **k):
        super(ActionWithOptionsComponent, self).__init__(*a, **k)
        self._options = self.register_component(OptionsComponent(num_options=num_options))
        self._options.set_enabled(False)

    @property
    def options(self):
        return self._options

    def show_settings(self):
        self._options.set_enabled(True)
        return True

    def hide_settings(self):
        self._options.set_enabled(False)


class ToggleWithOptionsComponent(ActionWithOptionsComponent):
    __subject_events__ = ('toggle_option',)
    _is_active = False
    _just_activated = False

    def _get_is_active(self):
        return self._is_active

    def _set_is_active(self, value):
        if value != self._is_active:
            self._is_active = value
            self._update_action_button()

    is_active = property(_get_is_active, _set_is_active)

    def trigger_action(self):
        if self._is_active:
            self._just_activated = False
        else:
            self._is_active = True
            self._just_activated = True
            self.notify_toggle_option(True)
            self._update_action_button()

    def post_trigger_action(self):
        if not self._just_activated:
            self._is_active = False
            self.notify_toggle_option(False)
            self._update_action_button()

    def _update_action_button(self):
        if self.is_enabled() and self._action_button:
            self._action_button.set_light(self._is_active)
########NEW FILE########
__FILENAME__ = AutoArmComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/AutoArmComponent.py
"""
Component that automatically arms the selected track.
"""
from itertools import ifilter
from _Framework.SubjectSlot import subject_slot, subject_slot_group
from _Framework.CompoundComponent import CompoundComponent
from _Framework.ModesComponent import LatchingBehaviour
from _Framework.Util import forward_property, mixin
from MessageBoxComponent import NotificationComponent

class AutoArmRestoreBehaviour(LatchingBehaviour):
    """
    Mode button behaviour that auto-arm is enabled when the mode is
    activated. If it is not, then it will make the button blink and
    restore it in the second press.
    
    Note that this interface is passive, you have to manually call
    update() to make sure the light is update when the auto-arm
    condition changes.
    """

    def __init__(self, auto_arm = None, *a, **k):
        super(AutoArmRestoreBehaviour, self).__init__(*a, **k)
        self._auto_arm = auto_arm
        self._last_update_params = None
        self._skip_super = False

    def _mode_is_active(self, component, mode, selected_mode):
        groups = component.get_mode_groups(mode)
        selected_groups = component.get_mode_groups(selected_mode)
        return mode == selected_mode or bool(groups & selected_groups)

    def press_immediate(self, component, mode):
        called_super = False
        if component.selected_mode != mode:
            called_super = True
            super(AutoArmRestoreBehaviour, self).press_immediate(component, mode)
        if self._auto_arm.needs_restore_auto_arm:
            self._auto_arm.restore_auto_arm()
        elif not called_super:
            called_super = True
            super(AutoArmRestoreBehaviour, self).press_immediate(component, mode)
        self._skip_super = not called_super

    def press_delayed(self, component, mode):
        if not self._skip_super:
            super(AutoArmRestoreBehaviour, self).press_delayed(component, mode)

    def release_immediate(self, component, mode):
        if not self._skip_super:
            super(AutoArmRestoreBehaviour, self).release_immediate(component, mode)

    def release_delayed(self, component, mode):
        if not self._skip_super:
            super(AutoArmRestoreBehaviour, self).release_delayed(component, mode)

    def update_button(self, component, mode, selected_mode):
        self._last_update_params = (component, mode, selected_mode)
        button = component.get_mode_button(mode)
        if button:
            if self._mode_is_active(component, mode, selected_mode):
                button.set_light('DefaultButton.Alert' if self._auto_arm.needs_restore_auto_arm else True)
            else:
                button.set_light(False)

    def update(self):
        if self._last_update_params:
            self.update_button(*self._last_update_params)


class AutoArmComponent(CompoundComponent):
    """
    Component that implictly arms tracks to keep the selected track
    always armed while there is no compatible red-armed track.
    """

    def __init__(self, *a, **k):
        super(AutoArmComponent, self).__init__(*a, **k)
        self._auto_arm_restore_behaviour = None
        self._notification = self.register_component(NotificationComponent(notification_time=10.0))
        self._on_tracks_changed.subject = self.song()
        self._on_exclusive_arm_changed.subject = self.song()
        self._on_tracks_changed()

    notification_layer = forward_property('_notification')('message_box_layer')

    def auto_arm_restore_behaviour(self, *extra_classes, **extra_params):
        if not self._auto_arm_restore_behaviour:
            self._auto_arm_restore_behaviour = mixin(AutoArmRestoreBehaviour, *extra_classes)(auto_arm=self, **extra_params)
        else:
            raise not extra_params and not extra_classes or AssertionError
        return self._auto_arm_restore_behaviour

    def track_can_be_armed(self, track):
        return track.can_be_armed and track.has_midi_input

    def can_auto_arm_track(self, track):
        return self.track_can_be_armed(track)

    def on_selected_track_changed(self):
        self.update()

    def _update_notification(self):
        if self.needs_restore_auto_arm:
            self._notification.show_notification('  Press [Note] to arm the track:    ' + self.song().view.selected_track.name, blink_text='  Press        to arm the track:    ' + self.song().view.selected_track.name)
        else:
            self._notification.hide_notification()

    def update(self):
        song = self.song()
        if self.is_enabled():
            enabled = not self.needs_restore_auto_arm
            selected_track = song.view.selected_track
            for track in song.tracks:
                if self.track_can_be_armed(track):
                    track.implicit_arm = enabled and selected_track == track and self.can_auto_arm_track(track)

            self._auto_arm_restore_behaviour and self._auto_arm_restore_behaviour.update()
        self._update_notification()

    def restore_auto_arm(self):
        song = self.song()
        exclusive_arm = song.exclusive_arm
        for track in song.tracks:
            if exclusive_arm or self.can_auto_arm_track(track):
                if track.can_be_armed:
                    track.arm = False

    @property
    def needs_restore_auto_arm(self):
        song = self.song()
        exclusive_arm = song.exclusive_arm
        return self.is_enabled() and self.can_auto_arm_track(song.view.selected_track) and not song.view.selected_track.arm and any(ifilter(lambda track: (exclusive_arm or self.can_auto_arm_track(track)) and track.can_be_armed and track.arm, song.tracks))

    @subject_slot('tracks')
    def _on_tracks_changed(self):
        tracks = filter(lambda t: t.can_be_armed, self.song().tracks)
        self._on_arm_changed.replace_subjects(tracks)
        self._on_current_input_routing_changed.replace_subjects(tracks)
        self._on_frozen_state_changed.replace_subjects(tracks)

    @subject_slot('exclusive_arm')
    def _on_exclusive_arm_changed(self):
        self.update()

    @subject_slot_group('arm')
    def _on_arm_changed(self, track):
        self.update()

    @subject_slot_group('current_input_routing')
    def _on_current_input_routing_changed(self, track):
        self.update()

    @subject_slot_group('is_frozen')
    def _on_frozen_state_changed(self, track):
        self.update()
########NEW FILE########
__FILENAME__ = AutomationComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/AutomationComponent.py
from itertools import count
import Live
AutomationState = Live.DeviceParameter.AutomationState
from _Framework import Task
from _Framework.Util import clamp
from _Framework.SubjectSlot import subject_slot_group
from DeviceParameterComponent import DeviceParameterComponent
from Setting import EnumerableSetting

class AutomationComponent(DeviceParameterComponent):
    _clip = None

    def __init__(self, *a, **k):
        super(AutomationComponent, self).__init__(*a, **k)
        self._selected_time = []
        self._parameter_floats = []
        self._update_parameter_values_task = self._tasks.add(Task.run(self._update_parameter_values))
        self._update_parameter_values_task.kill()

    def _get_clip(self):
        return self._clip

    def _set_clip(self, value):
        self._clip = value
        self._update_parameter_values_task.restart()

    clip = property(_get_clip, _set_clip)

    def _get_selected_time(self):
        return self._selected_time

    def _set_selected_time(self, value):
        self._selected_time = value or []
        self._update_parameter_values()
        self._update_parameter_floats()

    selected_time = property(_get_selected_time, _set_selected_time)

    @property
    def can_automate_parameters(self):
        return self.parameter_provider.parameters and self._clip and not self._clip.is_arrangement_clip

    def set_parameter_controls(self, encoders):
        self._on_encoder_value.replace_subjects(encoders or [], count())
        self._on_encoder_touch.replace_subjects(encoders or [], count())

    def _update_parameters(self):
        super(AutomationComponent, self)._update_parameters()
        self._update_parameter_floats()

    def _connect_parameters(self):
        pass

    def parameter_to_string(self, parameter):
        if not parameter:
            return ''
        elif len(self._selected_time) == 0:
            return '-'
        return parameter.str_for_value(self.parameter_to_value(parameter))

    def parameter_to_value(self, parameter):
        if self._clip and len(self.selected_time) > 0:
            envelope = self._clip.automation_envelope(parameter)
            if envelope != None:
                return self._value_at_time(envelope, self.selected_time[0])
        return 0.0

    def _value_at_time(self, envelope, time_range):
        return envelope.value_at_time((time_range[0] + time_range[1]) / 2)

    @subject_slot_group('normalized_value')
    def _on_encoder_value(self, value, index):
        if self.is_enabled():
            parameters = self.parameters
            if 0 <= index < len(parameters) and self._clip and parameters[index]:
                param = parameters[index]
                envelope = self._clip.automation_envelope(param)
                if envelope != None:
                    if param.automation_state == AutomationState.overridden:
                        param.re_enable_automation()
                    self._clip.view.select_envelope_parameter(param)
                    for time_index, time_range in enumerate(self.selected_time):
                        self._insert_step(time_range, time_index, index, envelope, value)

                self._update_parameter_values()

    @subject_slot_group('touch_value')
    def _on_encoder_touch(self, value, index):
        if self.is_enabled() and value:
            parameters = self.parameters
            if 0 <= index < len(parameters) and parameters[index] and self._clip:
                self._clip.view.select_envelope_parameter(parameters[index])
                self._update_parameter_floats()

    def _update_parameter_floats(self):
        if self._clip and self.is_enabled():
            envelopes = [ (self._clip.automation_envelope(param) if param != None else None) for param in self.parameters ]
            self._parameter_floats = [ [ (self._value_at_time(envelope, step) if envelope != None else 0.0) for envelope in envelopes ] for step in self.selected_time ]
        else:
            self._parameter_floats = []

    def _insert_step(self, time_range, time_index, param_index, envelope, value):
        param = self.parameters[param_index]
        envelope_value = self._parameter_floats[time_index][param_index]
        if param.is_quantized:
            value_to_insert = clamp(envelope_value + value / EnumerableSetting.STEP_SIZE, param.min, param.max)
        else:
            value_range = param.max - param.min
            value_to_insert = clamp(envelope_value + value * value_range, param.min, param.max)
        self._parameter_floats[time_index][param_index] = value_to_insert
        envelope.insert_step(time_range[0], time_range[1] - time_range[0], value_to_insert)
########NEW FILE########
__FILENAME__ = BackgroundComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/BackgroundComponent.py
from functools import partial
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.SubjectSlot import SubjectSlotError

class BackgroundComponent(ControlSurfaceComponent):
    """
    This component resets and adds a no-op listener to every control
    that it receives via arbitrary set_* methods.  It is specially
    useful to give it a layer with every control and low priority such
    that it prevents leaking LED lights or midi notes slipping into
    the midi track.
    """

    def __init__(self, *a, **k):
        super(BackgroundComponent, self).__init__(*a, **k)
        self._control_slots = {}
        self._control_map = {}

    def __getattr__(self, name):
        if len(name) > 4 and name[:4] == 'set_':
            return partial(self._clear_control, name[4:])
        raise AttributeError, name

    def _clear_control(self, name, control):
        slot = self._control_slots.get(name, None)
        if slot:
            del self._control_slots[name]
            self.disconnect_disconnectable(slot)
        if control:
            self._reset_control(control)
            self._control_map[name] = control
            try:
                self._control_slots[name] = self.register_slot(control, lambda *a, **k: self._on_value_listener(control, *a, **k), 'value')
            except SubjectSlotError:
                pass

        else:
            del self._control_map[name]

    def _reset_control(self, control):
        control.reset()

    def _on_value_listener(self, *a, **k):
        pass

    def update(self):
        if self.is_enabled():
            for control in self._control_map.itervalues():
                self._reset_control(control)


class ModifierBackgroundComponent(BackgroundComponent):
    """
    This component lights up modifiers IFF they have other owners as
    well.  Only give configurable buttons with prioritized resources
    to this component.
    """

    def __init__(self, *a, **k):
        super(ModifierBackgroundComponent, self).__init__(*a, **k)

    def _reset_control(self, control):
        if len(control.resource.owners) > 1:
            control.set_light(control.is_pressed())
        else:
            control.reset()

    def _on_value_listener(self, sender, value, *a, **k):
        if len(sender.resource.owners) > 1:
            sender.set_light(sender.is_pressed())
########NEW FILE########
__FILENAME__ = BrowserComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/BrowserComponent.py
from __future__ import with_statement
from functools import partial
from itertools import izip, chain, imap
import string
import re
import consts
import Live
FilterType = Live.Browser.FilterType
DeviceType = Live.Device.DeviceType
from _Framework import Task
from _Framework.CompoundComponent import CompoundComponent
from _Framework.Util import first, find_if, index_if, clamp, in_range, BooleanContext, nop, const, lazy_attribute, memoize
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.SubjectSlot import subject_slot, subject_slot_group, SlotManager, Subject
from ScrollableList import ActionListItem, ActionList, ListComponent, DefaultItemFormatter

class VirtualBrowserItem(object):
    """
    Quacks like a Live.Browser.BrowserItem
    """
    source = ''
    is_device = False
    is_loadable = False

    def __init__(self, name = '', children_query = nop, is_folder = False):
        self.name = name
        self.is_folder = is_folder
        self.children_query = children_query

    @lazy_attribute
    def children(self):
        return self.children_query()

    @property
    def is_selected(self):
        return find_if(lambda x: x.is_selected, self.children)

    def __str__(self):
        return self.name


class BrowserListItem(ActionListItem):
    """
    List item representing a browser element
    """

    def __str__(self):
        import os
        return os.path.splitext(self.content.name)[0] if self.content else ''

    def action(self):
        if self.container and self.container.browser:
            self.container.browser.load_item(self.content)

    @property
    def supports_action(self):
        return self.container and self.container.browser and self.content != None and self.content.is_loadable


class BrowserList(ActionList):
    """
    Component for representing lists of browser items
    """
    browser = None
    item_type = BrowserListItem

    def __init__(self, browser = None, *a, **k):
        super(BrowserList, self).__init__(*a, **k)
        self.browser = browser


class BrowserModel(Subject, SlotManager):
    """
    A browser model provides the data to a browser component as a
    sequence of BrowserLists.
    
    The BrowserComponent will use equality to discard equivalent
    models and prevent unnecessary updating, override it when
    neccesary.
    """
    __subject_events__ = ('content_lists', 'selection_updated')
    empty_list_messages = []

    def __init__(self, browser = None, *a, **k):
        super(BrowserModel, self).__init__(*a, **k)
        self._browser = browser

    def can_be_exchanged(self, model):
        return isinstance(model, BrowserModel)

    def exchange_model(self, model):
        """
        Tries to replace itself with the settings of a given
        model. Returns true if it succeeds or false if the current
        model can not represent the same set of values.
        """
        if self.can_be_exchanged(model):
            self._browser = model._browser
            return True
        return False

    @property
    def content_lists(self):
        """
        Returns a set of ActionLists that hold the hierarchy of
        content for the browser.
        """
        return NotImplementedError

    def update_content(self):
        """
        Called when the browser contents have changed.
        """
        raise NotImplementedError

    def update_selection(self):
        """
        Called when the browser selection might have changed.
        """
        raise NotImplementedError

    @property
    def browser(self):
        return self._browser

    def make_content_list(self):
        return BrowserList(browser=self._browser)


class EmptyBrowserModel(BrowserModel):
    """
    A browser model that never returns anything, to be used for
    hotswap targets that do not make sense in the L9C.
    """
    empty_list_messages = ['Nothing to browse']

    @property
    def content_lists(self):
        return tuple()

    def update_content(self):
        self.notify_content_lists()

    def update_selection(self):
        pass

    def can_be_exchanged(self, model):
        return isinstance(model, EmptyBrowserModel) and super(EmptyBrowserModel, self).can_be_exchanged(model)


class FullBrowserModel(BrowserModel):
    """
    A browser model that provides an abstract hierarchical query model
    for simpler implementation.  Note that this can result in endless
    nesting, which the BrowserComponent does not support so far.
    It always provides at least two columns.
    """
    empty_list_messages = ['<no tags>',
     '<no devices>',
     '<no presets>',
     '<no presets>']

    def __init__(self, *a, **k):
        super(FullBrowserModel, self).__init__(*a, **k)
        self._contents = []
        self._num_contents = 0
        self._push_content_list()
        self._inside_item_activated_notification = BooleanContext()

    def get_root_children(self):
        """
        Query for the initial items.
        """
        return self.browser.tags

    def get_children(self, item, level):
        """
        Query for children of node.
        """
        return item.children

    @property
    def content_lists(self):
        return map(first, self._contents[:self._num_contents])

    def can_be_exchanged(self, model):
        return isinstance(model, FullBrowserModel) and super(FullBrowserModel, self).can_be_exchanged(model)

    def update_content(self):
        root, _ = self._contents[0]
        root.assign_items(self.get_root_children())
        self.update_selection()

    def update_selection(self):
        target = self._browser.hotswap_target
        last_seleced_list_index = None
        if self._browser.hotswap_target != None:
            if isinstance(target, Live.DrumPad.DrumPad) and (not target.chains or not target.chains[0].devices):
                for content_list in self.content_lists:
                    content_list.select_item_index_with_offset(0, 0)

            else:
                list_index = 0
                while list_index < self._num_contents:
                    content_list, _ = self._contents[list_index]
                    items = content_list.items
                    index = index_if(lambda x: x.content.is_selected, items)
                    if in_range(index, 0, len(items)):
                        content_list.select_item_index_with_offset(index, 2)
                        last_seleced_list_index = list_index
                    list_index += 1

        if last_seleced_list_index != None:
            self.notify_selection_updated(last_seleced_list_index)

    def _push_content_list(self):
        if self._num_contents < len(self._contents):
            self._num_contents += 1
            content = self._contents[self._num_contents - 1]
        else:
            raise self._num_contents == len(self._contents) or AssertionError
            content = self.make_content_list()
            level = len(self._contents)
            slot = self.register_slot(content, partial(self._on_item_activated, level), 'item_activated')
            self._contents.append((content, slot))
            self._num_contents = len(self._contents)
        return content

    def _pop_content_list(self):
        raise self._num_contents > 1 or AssertionError
        self._num_contents -= 1

    def _fit_content_lists(self, requested_lists):
        """
        Ensures that there are exactly 'request_lists' number of
        content lists. Returns whether a change was needed or not.
        """
        raise requested_lists > 0 or AssertionError
        if requested_lists != self._num_contents:
            while requested_lists < self._num_contents:
                self._pop_content_list()

            while requested_lists > self._num_contents:
                self._push_content_list()

    def _finalize_content_lists_change(self):
        """
        After a series of push/pop/fit operations, this makes sure
        that we only have as many content lists referenced as
        necessary.
        """
        while self._num_contents < len(self._contents):
            _, slot = self._contents.pop()
            self.disconnect_disconnectable(slot)

        raise self._num_contents == len(self._contents) or AssertionError

    def _on_item_activated(self, level):
        old_num_contents = self._num_contents
        with self._inside_item_activated_notification():
            contents, _ = self._contents[level]
            selected = contents.selected_item
            if selected != None:
                is_folder = selected.content.is_folder
                children = self.get_children(selected.content, level) if selected != None else []
                (children or is_folder or level < 1) and self._fit_content_lists(level + 2)
                child_contents, _ = self._contents[level + 1]
                child_contents.assign_items(children)
            else:
                self._fit_content_lists(level + 1)
        if not self._inside_item_activated_notification:
            self._finalize_content_lists_change()
            if old_num_contents != self._num_contents:
                self.notify_content_lists()


class BrowserQuery(object):
    """
    Base class for browser queries. Is capable of creating a subfolder for wrapping
    all results of the query.
    """

    def __init__(self, subfolder = None, *a, **k):
        self.subfolder = subfolder

    def __call__(self, browser):
        if self.subfolder:
            return [VirtualBrowserItem(name=self.subfolder, children_query=partial(self.query, browser), is_folder=True)]
        else:
            return self.query(browser)

    def query(self, browser):
        raise NotImplementedError


class PathBrowserQuery(BrowserQuery):
    """
    Includes the element for the given path.
    """

    def __init__(self, path = tuple(), *a, **k):
        super(PathBrowserQuery, self).__init__(*a, **k)
        raise path or AssertionError
        self.path = path

    def query(self, browser):
        return self._find_item(self.path, browser.tags, browser) or []

    def _find_item(self, path, items = None, browser = None):
        name = path[0]
        elem = find_if(lambda x: x.name == name, items)
        if elem:
            return [elem] if len(path) == 1 else self._find_item(path[1:], elem.children)


class TagBrowserQuery(BrowserQuery):
    """
    Query that merges the contents of the specified subtrees of
    the browser.  It will first merge the contents of all the paths
    specified in the 'include' list. A path is either the name of a
    tag or a list with the name of the tag/folders that describe the
    path. Then it drops the items that are in the 'exclude' list.
    """

    def __init__(self, include = tuple(), exclude = tuple(), *a, **k):
        super(TagBrowserQuery, self).__init__(*a, **k)
        self.include = include
        self.exclude = exclude

    def query(self, browser):
        return filter(lambda item: item.name not in self.exclude, sum(map(partial(self._extract_path, browser=browser), self.include), tuple()))

    def _extract_path(self, path, items = None, browser = None):
        if isinstance(path, (str, unicode)):
            path = [path]
        if items is None:
            items = browser.tags
        if path:
            name = path[0]
            elem = find_if(lambda x: x.name == name, items)
            if elem:
                items = self._extract_path(path[1:], elem.children)
        return tuple(items)


class SourceBrowserQuery(TagBrowserQuery):
    """
    Like TagBrowserQuery, but adds a top-level source selection.
    """

    def __init__(self, *a, **k):
        super(SourceBrowserQuery, self).__init__(*a, **k)

    def query(self, browser):
        root = super(SourceBrowserQuery, self).query(browser)
        groups = dict()
        for item in root:
            groups.setdefault(item.source, []).append(item)

        return map(lambda (k, g): VirtualBrowserItem(name=k, children_query=const(g)), sorted(groups.items(), key=first))


class PlacesBrowserQuery(BrowserQuery):
    """
    Query that fetches all places of the browser
    """

    def __init__(self, *a, **k):
        super(PlacesBrowserQuery, self).__init__(*a, **k)

    def query(self, browser):
        return tuple(browser.packs) + tuple(browser.places)


class QueryingBrowserModel(FullBrowserModel):
    """
    Browser model that takes query objects to build up the model hierarchy
    """
    empty_list_messages = ['<no devices>',
     '<no presets>',
     '<no presets>',
     '<no presets>']

    def __init__(self, queries = [], *a, **k):
        super(QueryingBrowserModel, self).__init__(*a, **k)
        self.queries = queries

    def get_root_children(self):
        browser = self.browser
        return chain(*imap(lambda q: q(browser), self.queries))

    def can_be_exchanged(self, model):
        return isinstance(model, QueryingBrowserModel) and super(QueryingBrowserModel, self).can_be_exchanged(model)

    def exchange_model(self, model):
        if super(QueryingBrowserModel, self).exchange_model(model):
            self.queries = model.queries
            return True


PLACES_LABEL = 'Places'

def make_midi_effect_browser_model(browser):
    midi_effects = TagBrowserQuery(include=['MIDI Effects'])
    max = TagBrowserQuery(include=[['Max for Live', 'Max MIDI Effect']], subfolder='Max for Live')
    places = PlacesBrowserQuery(subfolder=PLACES_LABEL)
    return QueryingBrowserModel(browser=browser, queries=[midi_effects, max, places])


def make_audio_effect_browser_model(browser):
    audio_effects = TagBrowserQuery(include=['Audio Effects'])
    max = TagBrowserQuery(include=[['Max for Live', 'Max Audio Effect']], subfolder='Max for Live')
    places = PlacesBrowserQuery(subfolder=PLACES_LABEL)
    return QueryingBrowserModel(browser=browser, queries=[audio_effects, max, places])


def make_instruments_browser_model(browser):
    instrument_rack = PathBrowserQuery(path=['Instruments', 'Instrument Rack'])
    drums = SourceBrowserQuery(include=['Drums'], exclude=['Drum Hits'], subfolder='Drum Rack')
    instruments = TagBrowserQuery(include=['Instruments'], exclude=['Drum Rack', 'Instrument Rack'])
    drum_hits = TagBrowserQuery(include=[['Drums', 'Drum Hits']], subfolder='Drum Hits')
    max = TagBrowserQuery(include=[['Max for Live', 'Max Instrument']], subfolder='Max for Live')
    places = PlacesBrowserQuery(subfolder=PLACES_LABEL)
    return QueryingBrowserModel(browser=browser, queries=[instrument_rack,
     drums,
     instruments,
     max,
     drum_hits,
     places])


def make_drum_pad_browser_model(browser):
    drums = TagBrowserQuery(include=[['Drums', 'Drum Hits']])
    samples = SourceBrowserQuery(include=['Samples'], subfolder='Samples')
    instruments = TagBrowserQuery(include=['Instruments'])
    max = TagBrowserQuery(include=[['Max for Live', 'Max Instrument']], subfolder='Max for Live')
    places = PlacesBrowserQuery(subfolder=PLACES_LABEL)
    return QueryingBrowserModel(browser=browser, queries=[drums,
     samples,
     instruments,
     max,
     places])


def make_fallback_browser_model(browser):
    return EmptyBrowserModel(browser=browser)


def filter_type_for_hotswap_target(target):
    """
    Returns the appropriate browser filter type for a given hotswap target.
    """
    if isinstance(target, Live.Device.Device):
        if target.type == DeviceType.instrument:
            return FilterType.instrument_hotswap
        elif target.type == DeviceType.audio_effect:
            return FilterType.audio_effect_hotswap
        elif target.type == DeviceType.midi_effect:
            return FilterType.midi_effect_hotswap
        else:
            FilterType.disabled
    elif isinstance(target, Live.DrumPad.DrumPad):
        return FilterType.drum_pad_hotswap
    elif isinstance(target, Live.Chain.Chain):
        return filter_type_for_hotswap_target(target.canonical_parent) if target else FilterType.disabled
    return FilterType.disabled


def make_browser_model(browser, filter_type = None):
    """
    Factory that returns an appropriate browser model depending on the
    browser filter type and hotswap target.
    """
    factories = {FilterType.instrument_hotswap: make_instruments_browser_model,
     FilterType.drum_pad_hotswap: make_drum_pad_browser_model,
     FilterType.audio_effect_hotswap: make_audio_effect_browser_model,
     FilterType.midi_effect_hotswap: make_midi_effect_browser_model}
    if filter_type == None:
        filter_type = filter_type_for_browser(browser)
    return factories.get(filter_type, make_fallback_browser_model)(browser)


def filter_type_for_browser(browser):
    filter_type = filter_type_for_hotswap_target(browser.hotswap_target)
    if filter_type == FilterType.disabled:
        filter_type = browser.filter_type
    return filter_type


def make_stem_cleaner(stem):
    """ Returns a function that can be used to remove the stem from a sentence """
    if stem[-1] == 's':
        stem = stem[:-1]
    if len(stem) > 2:
        return _memoized_stem_cleaner(stem)
    return nop


@memoize
def _memoized_stem_cleaner(stem):
    ellipsis = consts.CHAR_ELLIPSIS
    stem = re.escape(stem)
    rule1 = re.compile(u'([a-z])' + stem + u's?([ A-Z])')
    rule2 = re.compile(u'[' + ellipsis + ' \\-]' + stem + u's?([\\-' + ellipsis + u' A-Z])')
    rule3 = re.compile(u'' + stem + u's?$')

    def cleaner(short_name):
        short_name = ' ' + short_name
        short_name = rule1.sub(u'\\1' + ellipsis + u'\\2', short_name)
        short_name = rule2.sub(ellipsis + u'\\1', short_name)
        short_name = rule3.sub(ellipsis, short_name)
        return short_name.strip(' ')

    return cleaner


def split_stem(sentence):
    """ Splits camel cased sentence into words """
    sentence = re.sub('([a-z])([A-Z])', u'\\1 \\2', sentence)
    return sentence.split()


_stripper_double_spaces = re.compile(u' [\\- ]*')
_stripper_double_ellipsis = re.compile(consts.CHAR_ELLIPSIS + u'+')
_stripper_space_ellipsis = re.compile(u'[\\- ]?' + consts.CHAR_ELLIPSIS + u'[\\- ]?')

def full_strip(string):
    """ Strip string for double spaces and dashes """
    string = _stripper_double_spaces.sub(' ', string)
    string = _stripper_double_ellipsis.sub(consts.CHAR_ELLIPSIS, string)
    string = _stripper_space_ellipsis.sub(consts.CHAR_ELLIPSIS, string)
    return string.strip(' ')


class BrowserComponent(CompoundComponent):
    """
    Component for controlling the Live library browser.  It has 4
    browsing columns that are controlled by encoders and state
    buttons.  The contents of these lists are provided by a browser
    model -- see BrowserModel and derivatives.
    """
    __subject_events__ = ('load_item',)
    NUM_COLUMNS = 4
    COLUMN_SIZE = 4

    def __init__(self, browser = None, *a, **k):
        super(BrowserComponent, self).__init__(*a, **k)
        self._browser = browser or self.application().browser
        self._browser_model = make_fallback_browser_model(self._browser)
        num_data_sources = self.NUM_COLUMNS * self.COLUMN_SIZE
        self._data_sources = map(DisplayDataSource, ('',) * num_data_sources)
        self._last_loaded_item = None
        self._default_item_formatter = DefaultItemFormatter()
        self._list_components = self.register_components(*[ ListComponent() for _ in xrange(self.NUM_COLUMNS) ])
        for i, component in enumerate(self._list_components):
            component.do_trigger_action = lambda item: self._do_load_item(item)
            component.last_action_item = lambda : self._last_loaded_item
            component.item_formatter = partial(self._item_formatter, i)

        self._select_buttons = []
        self._state_buttons = []
        self._encoder_controls = []
        self._enter_button = None
        self._exit_button = None
        self._shift_button = None
        self._on_list_item_action.replace_subjects(self._list_components)
        self._on_hotswap_target_changed.subject = self._browser
        self._on_filter_type_changed.subject = self._browser
        self._on_browser_full_refresh.subject = self._browser
        self._scroll_offset = 0
        self._max_scroll_offset = 0
        self._max_hierarchy = 0
        self._last_filter_type = None
        self._skip_next_preselection = False
        self._browser_model_dirty = True
        self._on_content_lists_changed()

    def set_display_line1(self, display):
        self.set_display_line_with_index(display, 0)

    def set_display_line2(self, display):
        self.set_display_line_with_index(display, 1)

    def set_display_line3(self, display):
        self.set_display_line_with_index(display, 2)

    def set_display_line4(self, display):
        self.set_display_line_with_index(display, 3)

    def set_enter_button(self, button):
        self._enter_button = button
        self._on_enter_value.subject = button
        self._update_navigation_button_state()

    def set_exit_button(self, button):
        self._exit_button = button
        self._on_exit_value.subject = button
        self._update_navigation_button_state()

    def set_display_line_with_index(self, display, index):
        if display:
            sources = self._data_sources[index::self.COLUMN_SIZE]
            display.set_data_sources(sources)

    def set_select_buttons(self, buttons):
        for button in buttons or []:
            if button:
                button.reset()

        self._on_select_matrix_value.subject = buttons or None
        self._select_buttons = buttons
        buttons = buttons or (None, None, None, None, None, None, None, None)
        for component, button in izip(self._list_components, buttons[1::2]):
            self._set_button_if_enabled(component, 'action_button', button)

        for component, button in izip(self._list_components, buttons[::2]):
            if self._shift_button and self._shift_button.is_pressed():
                self._set_button_if_enabled(component, 'prev_page_button', button)
                self._set_button_if_enabled(component, 'select_prev_button', None)
            else:
                self._set_button_if_enabled(component, 'prev_page_button', None)
                self._set_button_if_enabled(component, 'select_prev_button', button)

    def set_state_buttons(self, buttons):
        for button in buttons or []:
            if button:
                button.reset()

        self._on_state_matrix_value.subject = buttons or None
        self._state_buttons = buttons
        buttons = buttons or (None, None, None, None, None, None, None, None)
        for component, button in izip(self._list_components, buttons[::2]):
            if self._shift_button and self._shift_button.is_pressed():
                self._set_button_if_enabled(component, 'next_page_button', button)
                self._set_button_if_enabled(component, 'select_next_button', None)
            else:
                self._set_button_if_enabled(component, 'next_page_button', None)
                self._set_button_if_enabled(component, 'select_next_button', button)

        for button in buttons[1::2]:
            if button and self.is_enabled():
                button.set_light('DefaultButton.Disabled')

    def set_shift_button(self, button):
        self._shift_button = button
        self._on_shift_button.subject = button

    @subject_slot('value')
    def _on_shift_button(self, value):
        self.set_select_buttons(self._select_buttons)
        self.set_state_buttons(self._state_buttons)

    def _set_button_if_enabled(self, component, name, button):
        setter = getattr(component, 'set_' + name)
        if component.is_enabled(explicit=True):
            setter(button)
        else:
            setter(None)
            if button and self.is_enabled():
                button.set_light('DefaultButton.Disabled')

    def set_encoder_controls(self, encoder_controls):
        if encoder_controls:
            num_active_lists = len(self._browser_model.content_lists) - self._scroll_offset
            num_assignable_lists = min(num_active_lists, len(encoder_controls) / 2)
            index = 0
            for component in self._list_components[:num_assignable_lists - 1]:
                component.set_encoder_controls(encoder_controls[index:index + 2])
                index += 2

            self._list_components[num_assignable_lists - 1].set_encoder_controls(encoder_controls[index:])
        else:
            for component in self._list_components:
                component.set_encoder_controls([])

        self._encoder_controls = encoder_controls

    def update(self):
        if self.is_enabled():
            self.set_state_buttons(self._state_buttons)
            self.set_select_buttons(self._select_buttons)
            self._update_browser_model()
            self._update_navigation_button_state()

    def reset_load_memory(self):
        self._update_load_memory(None)

    def _do_load_item(self, item):
        self.do_load_item(item)
        self._update_load_memory(item)
        self._skip_next_preselection = True

        def reset_skip_next_preselection():
            self._skip_next_preselection = False

        self._tasks.add(Task.run(reset_skip_next_preselection))

    def _update_load_memory(self, item):
        self._last_loaded_item = item
        for component in self._list_components:
            component.update()

    def do_load_item(self, item):
        item.action()
        self.notify_load_item(item.content)

    def back_to_top(self):
        self._set_scroll_offset(0)

    def _set_scroll_offset(self, offset):
        self._scroll_offset = offset
        self._on_content_lists_changed()
        scrollable_list = self._list_components[-1].scrollable_list
        if scrollable_list:
            scrollable_list.request_notify_item_activated()

    def _update_navigation_button_state(self):
        if self._exit_button:
            self._exit_button.set_light(self._scroll_offset > 0)
        if self._enter_button:
            self._enter_button.set_light(self._scroll_offset < self._max_scroll_offset)

    def _shorten_item_name(self, shortening_limit, list_index, item_name):
        """
        Creates the name of an item shortened by removing words from the parents name
        """

        def is_short_enough(item_name):
            return len(item_name) <= 9

        content_lists = self._browser_model.content_lists
        parent_lists = reversed(content_lists[max(0, list_index - 3):list_index])
        for content_list in parent_lists:
            if is_short_enough(item_name):
                break
            parent_name = unicode(content_list.selected_item)
            stems = split_stem(parent_name)
            for stem in stems:
                short_name = make_stem_cleaner(stem)(item_name)
                short_name = full_strip(short_name)
                item_name = short_name if len(short_name) > 4 else item_name
                if is_short_enough(item_name):
                    break

        return item_name[:-1] if len(item_name) >= shortening_limit and item_name[-1] == consts.CHAR_ELLIPSIS else item_name

    def _item_formatter(self, depth, index, item, action_in_progress):
        display_string = ''
        separator_length = len(self._data_sources[self.COLUMN_SIZE * depth].separator)
        shortening_limit = 16 - separator_length
        if item:
            item_name = 'Loading...' if action_in_progress else self._shorten_item_name(shortening_limit, depth + self._scroll_offset, unicode(item))
            display_string = consts.CHAR_SELECT if item and item.is_selected else ' '
            display_string += item_name
            if depth == len(self._list_components) - 1 and item.is_selected and self._scroll_offset < self._max_hierarchy:
                display_string = string.ljust(display_string, consts.DISPLAY_LENGTH / 4 - 1)
                shortening_limit += 1
                display_string = display_string[:shortening_limit] + consts.CHAR_ARROW_RIGHT
            if depth == 0 and self._scroll_offset > 0:
                prefix = consts.CHAR_ARROW_LEFT if index == 0 else ' '
                display_string = prefix + display_string
        return display_string[:shortening_limit + 1]

    @subject_slot('value')
    def _on_enter_value(self, value):
        if value:
            self._set_scroll_offset(min(self._max_scroll_offset, self._scroll_offset + 1))

    @subject_slot('value')
    def _on_exit_value(self, value):
        if value:
            self._set_scroll_offset(max(0, self._scroll_offset - 1))

    @subject_slot('hotswap_target')
    def _on_hotswap_target_changed(self):
        if not self._skip_next_preselection:
            self._set_scroll_offset(0)
        self._update_browser_model()

    @subject_slot('filter_type')
    def _on_filter_type_changed(self):
        self._update_browser_model()

    @subject_slot('full_refresh')
    def _on_browser_full_refresh(self):
        self._browser_model_dirty = True

    def _update_browser_model(self):
        if self.is_enabled():
            self._do_update_browser_model()

    def _do_update_browser_model(self):
        filter_type = filter_type_for_browser(self._browser)
        if filter_type != self._last_filter_type:
            self._last_filter_type = filter_type
            new_model = make_browser_model(self._browser, filter_type)
            if self._browser_model and self._browser_model.can_be_exchanged(new_model) and new_model.can_be_exchanged(self._browser_model):
                self._browser_model.exchange_model(new_model)
                new_model.disconnect()
            else:
                self.disconnect_disconnectable(self._browser_model)
                self._browser_model = self.register_slot_manager(new_model)
                self._on_content_lists_changed.subject = self._browser_model
                self._on_selection_updated.subject = self._browser_model
            for contents in self._browser_model.content_lists:
                contents.selected_item_index = 0

            self._browser_model.update_content()
        elif self._browser_model_dirty:
            self._browser_model.update_content()
        elif not self._skip_next_preselection:
            self._browser_model.update_selection()
        self._skip_next_preselection = False
        self._browser_model_dirty = False

    @subject_slot_group('item_action')
    def _on_list_item_action(self, item, _):
        self.notify_load_item(item.content)

    @subject_slot('selection_updated')
    def _on_selection_updated(self, index):
        more_content_available = len(self._browser_model.content_lists) > self.NUM_COLUMNS + self._scroll_offset
        required_scroll_offset = index - (self.NUM_COLUMNS - 1)
        if more_content_available and required_scroll_offset > self._scroll_offset:
            self._set_scroll_offset(self._scroll_offset + 1)
            self._browser_model.update_selection()

    @subject_slot('content_lists')
    def _on_content_lists_changed(self):
        components = self._list_components
        contents = self._browser_model.content_lists[self._scroll_offset:]
        messages = self._browser_model.empty_list_messages
        scroll_depth = len(self._browser_model.content_lists) - len(self._list_components)
        self._max_scroll_offset = max(0, scroll_depth + 2)
        self._max_hierarchy = max(0, scroll_depth)
        for component, content, message in map(None, components, contents, messages):
            if component != None:
                component.scrollable_list = content
                component.empty_list_message = message

        active_lists = len(contents)
        num_head = clamp(active_lists - 1, 0, self.NUM_COLUMNS - 1)
        head = components[:num_head]
        last = components[num_head:]

        def set_data_sources_with_separator(component, sources, separator):
            for source in sources:
                source.separator = separator

            component.set_data_sources(sources)
            component.set_enabled(True)

        for idx, component in enumerate(head):
            offset = idx * self.COLUMN_SIZE
            sources = self._data_sources[offset:offset + self.COLUMN_SIZE]
            set_data_sources_with_separator(component, sources, '|')

        if last:
            offset = num_head * self.COLUMN_SIZE
            scrollable_list = last[0].scrollable_list
            if scrollable_list and find_if(lambda item: item.content.is_folder, scrollable_list.items):
                sources = self._data_sources[offset:offset + self.COLUMN_SIZE]
                map(DisplayDataSource.clear, self._data_sources[offset + self.COLUMN_SIZE:])
            else:
                sources = self._data_sources[offset:]
            set_data_sources_with_separator(last[0], sources, '')
            for component in last[1:]:
                component.set_enabled(False)

        self.set_select_buttons(self._select_buttons)
        self.set_state_buttons(self._state_buttons)
        self.set_encoder_controls(self._encoder_controls)
        self._update_navigation_button_state()

    @subject_slot('value')
    def _on_select_matrix_value(self, value, *_):
        pass

    @subject_slot('value')
    def _on_state_matrix_value(self, value, *_):
        pass

    @subject_slot('value')
    def _on_encoder_matrix_value(self, value, *_):
        pass
########NEW FILE########
__FILENAME__ = BrowserModes
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/BrowserModes.py
"""
Different mode objects that turn live into different browsing modes.
"""
import Live
DeviceType = Live.Device.DeviceType
from _Framework.Dependency import depends
from _Framework.Util import index_if
from _Framework.ModesComponent import Mode

def can_browse_for_object(obj):
    return obj != None


class BrowserHotswapMode(Mode):

    @depends(selection=None)
    def __init__(self, selection = None, application = None, *a, **k):
        super(BrowserHotswapMode, self).__init__(*a, **k)
        self._selection = selection
        self._application = application

    def can_hotswap(self):
        return can_browse_for_object(self._selection.selected_object) or can_browse_for_object(self._selection.selected_device)

    def enter_mode(self):
        try:
            self._set_hotswap_target(self._selection.selected_object)
        except RuntimeError:
            try:
                self._set_hotswap_target(self._selection.selected_device)
            except RuntimeError:
                pass

    def leave_mode(self):
        self._application.browser.hotswap_target = None

    def _set_hotswap_target(self, hotswap_object):
        self._application.browser.hotswap_target = hotswap_object
        self._application.view.show_view('Detail/DeviceChain')


class BrowserAddEffectMode(Mode):
    insert_left = False

    @depends(selection=None)
    def __init__(self, selection = None, browser = None, insert_left = None, application_view = None, *a, **k):
        super(BrowserAddEffectMode, self).__init__(*a, **k)
        self._selection = selection
        self._browser = browser
        self._application_view = application_view
        self._track_to_add_effect = None
        self._selection_for_insert = None
        if insert_left is not None:
            self.insert_left = insert_left

    def enter_mode(self):
        self._track_to_add_effect = self._selection.selected_track
        self._selection_for_insert = self._do_get_selection_for_insert()
        self._track_to_add_effect.view.device_insert_mode = self.get_insert_mode()
        self._browser.filter_type = self.get_filter_type()
        if self._application_view.browse_mode:
            self._browser.hotswap_target = None

    def leave_mode(self):
        disabled = Live.Track.DeviceInsertMode.default
        self._track_to_add_effect.view.device_insert_mode = disabled
        self._browser.filter_type = Live.Browser.FilterType.disabled

    def get_insert_mode(self):
        return Live.Track.DeviceInsertMode.selected_left if self.insert_left else Live.Track.DeviceInsertMode.selected_right

    def get_selection_for_insert(self):
        """
        Device to use for reference of where to insert the device.
        """
        return self._selection_for_insert

    def _do_get_selection_for_insert(self):
        selected = self._selection.selected_object
        if isinstance(selected, Live.DrumPad.DrumPad) and selected.chains and selected.chains[0].devices:
            index = 0 if self.insert_left else -1
            selected = selected.chains[0].devices[index]
        elif not isinstance(selected, Live.Device.Device):
            selected = self._selection.selected_device
        return selected

    def get_filter_type(self):
        selected = self.get_selection_for_insert()
        chain = selected.canonical_parent if selected else self._selection.selected_track
        chain_len = len(chain.devices)
        index = index_if(lambda device: device == selected, chain.devices)
        is_drum_pad = isinstance(chain.canonical_parent, Live.DrumPad.DrumPad)
        midi_support = chain.has_midi_input
        if not is_drum_pad:
            supports_instrument = chain.has_midi_input and (chain.has_audio_output or isinstance(chain, Live.Track.Track))
            left = self.insert_left and (chain.devices[index - 1] if index > 0 else None)
            return filter_type_between(left, selected, midi_support, is_drum_pad, supports_instrument)
        else:
            right = chain.devices[index + 1] if index < chain_len - 1 else None
            return filter_type_between(selected, right, midi_support, is_drum_pad, supports_instrument)


def filter_type_between(left, right, supports_midi = False, is_drum_pad = False, supports_instrument = False):
    """
    Given 'left' and 'right' are two consecutive devices in a valid
    device chain, returns the appropriate browser filter type for valid
    devices fitting between them. Either 'left' or 'right' can be None
    to indicate chain boundaries.
    
    A valid device chain with MIDI support has the following structure:
    
        <midi effect>* <instrument> <audio effect>*
    
    A valid device chain without MIDI support has the following structure:
    
        <audio effect>*
    """
    Types = Live.Browser.FilterType
    if right and right.type in (DeviceType.instrument, DeviceType.midi_effect):
        return Types.midi_effect_hotswap
    if left and left.type in (DeviceType.instrument, DeviceType.audio_effect):
        return Types.audio_effect_hotswap
    if supports_midi:
        if supports_instrument:
            return Types.drum_pad_hotswap if is_drum_pad else Types.instrument_hotswap
        else:
            return Types.midi_effect_hotswap
    return Types.audio_effect_hotswap
########NEW FILE########
__FILENAME__ = ClipControlComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/ClipControlComponent.py
from __future__ import with_statement
import Live
from contextlib import contextmanager
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.SubjectSlot import subject_slot
from _Framework.ModesComponent import ModesComponent
from _Framework.Util import clamp, second
ONE_THIRTYSECOND_IN_BEATS = 0.125
ONE_SIXTEENTH_IN_BEATS = 0.25
ONE_YEAR_AT_120BPM_IN_BEATS = 63072000.0
GRID_QUANTIZATION_LIST = [Live.Clip.GridQuantization.no_grid,
 Live.Clip.GridQuantization.g_thirtysecond,
 Live.Clip.GridQuantization.g_sixteenth,
 Live.Clip.GridQuantization.g_eighth,
 Live.Clip.GridQuantization.g_quarter,
 Live.Clip.GridQuantization.g_half,
 Live.Clip.GridQuantization.g_bar,
 Live.Clip.GridQuantization.g_2_bars,
 Live.Clip.GridQuantization.g_4_bars,
 Live.Clip.GridQuantization.g_8_bars]

def convert_time_to_bars_beats_sixteenths(time):
    if time is None:
        return '-'
    if time >= 0:
        bars = 1 + int(time / 4.0)
    else:
        bars = int(time / 4.0) if time % 4.0 == 0 else int(time / 4.0) - 1
    beats = 1 + int(time % 4.0)
    sixteenths = 1 + int(time % 1.0 * 4)
    return str(bars) + '.' + str(beats) + '.' + str(sixteenths)


def convert_length_to_bars_beats_sixteenths(length):
    if length is None:
        return '-'
    bars = int(length / 4.0)
    beats = int(length % 4.0)
    sixteenths = int(length % 1.0 * 4)
    return str(bars) + '.' + str(beats) + '.' + str(sixteenths)


def is_new_recording(clip):
    return clip.is_recording and not clip.is_overdubbing


class LoopSettingsComponent(ControlSurfaceComponent):
    """
    Component for managing loop settings of a clip
    """

    def __init__(self, *a, **k):
        super(LoopSettingsComponent, self).__init__(*a, **k)
        self._clip = None
        self._name_sources = [ DisplayDataSource() for _ in xrange(4) ]
        self._value_sources = [ DisplayDataSource() for _ in xrange(4) ]
        self._clip_is_looping = False
        self._clip_loop_start = None
        self._clip_loop_end = None
        self._clip_loop_length = None
        self._lowest_note_time = 0.0
        self._encoder_factor = 4.0
        self._shift_button = None

    def _get_clip(self):
        return self._clip

    def _set_clip(self, clip):
        self._clip = clip
        self._on_looping_changed.subject = clip
        self._on_loop_start_changed.subject = clip
        self._on_loop_end_changed.subject = clip
        self._on_clip_notes_changed.subject = clip if clip != None and clip.is_midi_clip else None
        self.update()

    clip = property(_get_clip, _set_clip)

    def set_shift_button(self, button):
        self._shift_button = button
        self._on_shift_value.subject = button
        self._update_encoder_factor()

    def set_encoders(self, encoders):
        self._on_clip_start_value.subject = encoders[0] if encoders else None
        self._on_clip_position_value.subject = encoders[1] if encoders else None
        self._on_clip_end_value.subject = encoders[2] if encoders else None
        self._on_clip_looping_value.subject = encoders[3] if encoders else None

    def set_name_display(self, display):
        if display:
            display.set_data_sources(self._name_sources)

    def set_value_display(self, display):
        if display:
            display.set_data_sources(self._value_sources)

    @subject_slot('value')
    def _on_shift_value(self, value):
        self._update_encoder_factor()

    def _update_encoder_factor(self):
        if self.is_enabled():
            old_factor = self._encoder_factor
            if self._shift_button and self._shift_button.is_pressed() and self._clip != None:
                self._encoder_factor = 2.0
            else:
                self._encoder_factor = self._one_measure_in_beats() * 2.0
            if old_factor != self._encoder_factor and self._clip != None:
                self._clip_loop_start = self._clip.loop_start
                self._clip_loop_end = self._clip.loop_end
                self._update_loop_length()

    def _calc_new_loop_start(self, value):
        self._clip_loop_start = max(self._clip_loop_start + value * self._one_measure_in_beats() * self._encoder_factor, min(0.0, self._clip_loop_start))
        round_up = value > 0
        loop_start = self._round_beats(self._clip_loop_start, round_up)
        if loop_start < 0.0:
            lowest_event_time = min(0, self._clip.start_marker, self._lowest_note_time)
            if lowest_event_time >= self._clip_loop_start:
                loop_start = max(self._clip_loop_start, loop_start)
        return loop_start

    def _round_beats(self, value, round_up = False):
        factor = 0.5 if round_up else -0.5
        rounded = 0.0
        if self._shift_button and self._shift_button.is_pressed():
            rounded = int(round(value + factor))
        else:
            measure = self._one_measure_in_beats()
            rounded = int(round(value / measure + factor) * measure)
        return float(rounded)

    @contextmanager
    def _clip_view_update_guard(self):
        clip = self._clip
        old_loop_start, old_loop_end = clip.loop_start, clip.loop_end
        yield
        if clip.loop_start < old_loop_start or clip.loop_end > old_loop_end:
            self._clip.view.show_loop()

    @subject_slot('normalized_value')
    def _on_clip_start_value(self, value):
        if self._clip != None:
            with self._clip_view_update_guard():
                loop_start = self._calc_new_loop_start(value)
                if loop_start < self._clip.loop_end:
                    self._clip.loop_start = loop_start
                elif not self._clip.looping:
                    self._clip_loop_start = self._clip.loop_end - ONE_SIXTEENTH_IN_BEATS
                    self._clip.loop_start = self._clip_loop_start
                else:
                    self._clip_loop_start = self._clip.loop_start

    @subject_slot('normalized_value')
    def _on_clip_position_value(self, value):
        if self._clip != None and not is_new_recording(self._clip):
            loop_start = self._calc_new_loop_start(value)
            loop_end = loop_start + self._clip_loop_length
            self._clip_loop_start = loop_start
            self._clip_loop_end = loop_end
            if value > 0:
                self._clip.loop_end = loop_end
                self._clip.loop_start = loop_start
            else:
                self._clip.loop_start = loop_start
                self._clip.loop_end = loop_end
            self._clip.view.show_loop()

    @subject_slot('looping')
    def _on_looping_changed(self):
        if self.is_enabled():
            if self._clip != None:
                self._clip_is_looping = True if self._clip.looping else False
            self._update_is_looping_source()
            self._update_loop_end_source()

    @subject_slot('loop_start')
    def _on_loop_start_changed(self):
        if self._clip != None:
            self._clip_loop_start = self._on_clip_start_value.subject and not self._on_clip_start_value.subject.is_pressed() and self._on_clip_position_value.subject and not self._on_clip_position_value.subject.is_pressed() and self._clip.loop_start
        self._update_loop_length()
        self._update_loop_start_source()
        self._update_position_source()
        self._update_loop_end_source()

    @subject_slot('loop_end')
    def _on_loop_end_changed(self):
        if self._clip != None:
            self._clip_loop_end = self._on_clip_end_value.subject and not self._on_clip_end_value.subject.is_pressed() and self._on_clip_position_value.subject and not self._on_clip_position_value.subject.is_pressed() and self._clip.loop_end
        self._update_loop_length()
        self._update_position_source()
        self._update_loop_end_source()

    @subject_slot('notes')
    def _on_clip_notes_changed(self):
        self._lowest_note_time = 0.0
        if self._clip != None and self._clip.is_midi_clip:
            earliest_time = -ONE_YEAR_AT_120BPM_IN_BEATS
            negative_notes = self._clip.get_notes(earliest_time, 0, -earliest_time, 128)
            self._lowest_note_time = min([0.0] + map(second, negative_notes))

    @subject_slot('normalized_value')
    def _on_clip_end_value(self, value):
        if self._clip != None and not is_new_recording(self._clip):
            self._clip_loop_end += value * self._one_measure_in_beats() * self._encoder_factor
            if self._clip_loop_end <= self._clip.loop_start:
                if not self._clip.looping:
                    self._clip_loop_end = self._clip.loop_start + ONE_SIXTEENTH_IN_BEATS
                    self._clip.loop_end = self._clip_loop_end
            else:
                loop_end = self._round_beats(self._clip_loop_end, value > 0)
                if loop_end > self._clip.loop_start:
                    self._clip.loop_end = loop_end
                    self._clip.view.show_loop()

    @subject_slot('normalized_value')
    def _on_clip_looping_value(self, value):
        if self._clip != None:
            if self._clip.is_midi_clip or self._clip.is_audio_clip and self._clip.warping:
                if value >= 0 and not self._clip_is_looping or value < 0 and self._clip_is_looping:
                    self._clip.looping = not self._clip.looping
                    self._on_looping_changed()

    def _update_is_looping_source(self):
        self._name_sources[0].set_display_string('LoopStrt' if self._clip_is_looping else 'ClipStrt')
        self._name_sources[2].set_display_string('Length' if self._clip_is_looping else 'End')

    def _update_loop_length(self):
        if self._clip and self._clip_loop_end is not None and self._clip_loop_start is not None:
            self._clip_loop_length = self._clip.loop_end - self._clip.loop_start

    def _update_loop_start_source(self):
        self._value_sources[0].set_display_string(convert_time_to_bars_beats_sixteenths(self._clip.loop_start) if self._clip else '-')

    def _update_loop_end_source(self):
        if self._clip and not is_new_recording(self._clip):
            self._value_sources[2].set_display_string(convert_length_to_bars_beats_sixteenths(self._clip_loop_length) if self._clip_is_looping else convert_time_to_bars_beats_sixteenths(self._clip.loop_end))
            self._value_sources[3].set_display_string('On' if self._clip_is_looping else 'Off')
        else:
            self._value_sources[2].set_display_string('-')
            self._value_sources[3].set_display_string('-')

    def _update_position_source(self):
        self._value_sources[1].set_display_string(convert_time_to_bars_beats_sixteenths(self._clip.loop_start) if self._clip else '-')

    def _one_measure_in_beats(self):
        return 4.0 * self.song().signature_numerator / self.song().signature_denominator

    def update(self):
        if self.is_enabled():
            for index, label in enumerate(['Start',
             'Position',
             'Length',
             'Loop']):
                self._name_sources[index].set_display_string(label)

            self._update_encoder_factor()
            self._on_loop_start_changed()
            self._on_loop_end_changed()
            self._on_looping_changed()
            self._on_clip_notes_changed()


class AudioClipSettingsComponent(ControlSurfaceComponent):
    """
    Component for managing settings of an audio clip
    """

    def __init__(self, *a, **k):
        super(AudioClipSettingsComponent, self).__init__(*a, **k)
        self._clip = None
        self._warp_mode_names = {Live.Clip.WarpMode.beats: 'Beats',
         Live.Clip.WarpMode.tones: 'Tones',
         Live.Clip.WarpMode.texture: 'Texture',
         Live.Clip.WarpMode.repitch: 'Repitch',
         Live.Clip.WarpMode.complex: 'Complex',
         Live.Clip.WarpMode.complex_pro: 'ComplexPro',
         Live.Clip.WarpMode.rex: 'Rex'}
        self._available_warp_modes = []
        self._pitch_fine = None
        self._pitch_coarse = None
        self._gain = None
        self._warping = None
        self._warp_mode = None
        self._warp_mode_encoder_value = 0.0
        self._encoder_factor = 1.0
        self._name_sources = [ DisplayDataSource() for _ in xrange(4) ]
        self._value_sources = [ DisplayDataSource() for _ in xrange(4) ]
        self._shift_button = None

    def _get_clip(self):
        return self._clip

    def _set_clip(self, clip):
        self._clip = clip
        if clip:
            self._available_warp_modes = list(clip.available_warp_modes)
            self._update_warp_mode()
            self._warping = clip.warping
            self._gain = clip.gain
            self._pitch_fine = clip.pitch_fine
            self._pitch_coarse = clip.pitch_coarse
        self._on_pitch_fine_changed.subject = clip
        self._on_pitch_coarse_changed.subject = clip
        self._on_gain_changed.subject = clip
        self._on_warp_mode_changed.subject = clip
        self._on_warping_changed.subject = clip
        self._shift_button = None
        self.update()

    clip = property(_get_clip, _set_clip)

    def set_encoders(self, encoders):
        self._on_clip_warp_mode_value.subject = encoders[0] if encoders else None
        self._on_clip_detune_value.subject = encoders[1] if encoders else None
        self._on_clip_transpose_value.subject = encoders[2] if encoders else None
        self._on_clip_gain_value.subject = encoders[3] if encoders else None

    def set_shift_button(self, button):
        self._shift_button = button
        self._on_shift_value.subject = button
        self._update_encoder_factor()

    def set_name_display(self, display):
        if display:
            display.set_data_sources(self._name_sources)

    def set_value_display(self, display):
        if display:
            display.set_data_sources(self._value_sources)

    @subject_slot('value')
    def _on_shift_value(self, value):
        self._update_encoder_factor()

    def _update_encoder_factor(self):
        if self.is_enabled():
            if self._shift_button and self._shift_button.is_pressed():
                self._encoder_factor = 0.1
            else:
                self._encoder_factor = 1.0

    @subject_slot('normalized_value')
    def _on_clip_warp_mode_value(self, value):
        if self._clip != None:
            self._warp_mode_encoder_value = clamp(self._warp_mode_encoder_value + value, 0.0, 1.0)
            if self._clip.warping:
                warp_mode_index = int(self._warp_mode_encoder_value * (len(self._available_warp_modes) - 1))
                self._clip.warp_mode = self._available_warp_modes[warp_mode_index]

    @subject_slot('normalized_value')
    def _on_clip_gain_value(self, value):
        if self._clip != None:
            delta = value * self._encoder_factor
            new_gain = self._clip.gain + delta
            self._clip.gain = clamp(new_gain, 0.0, 1.0)

    @subject_slot('normalized_value')
    def _on_clip_transpose_value(self, value):
        if self._clip != None:
            self._pitch_coarse = clamp(self._pitch_coarse + value * 96 * self._encoder_factor, -48.0, 48.0)
            self._clip.pitch_coarse = int(self._pitch_coarse)

    @subject_slot('normalized_value')
    def _on_clip_detune_value(self, value):
        if self._clip != None:
            self._pitch_fine = self._pitch_fine + value * 100.0 * self._encoder_factor
            self._clip.pitch_fine = int(self._pitch_fine)
            if self._pitch_fine < -50.0:
                if self._clip.pitch_coarse > -48:
                    self._pitch_fine += 50
                else:
                    self._pitch_fine = -49
            elif self._pitch_fine > 50:
                if self._clip.pitch_coarse < 48:
                    self._pitch_fine -= 50
                else:
                    self._pitch_fine = 49.0

    @subject_slot('warp_mode')
    def _on_warp_mode_changed(self):
        if self.is_enabled():
            self._update_warp_mode()
            self._update_warp_mode_source()

    @subject_slot('warping')
    def _on_warping_changed(self):
        if self.is_enabled():
            if self._clip:
                self._warping = self._clip.warping
            self._update_warp_mode_source()

    @subject_slot('gain')
    def _on_gain_changed(self):
        if self.is_enabled():
            if self._clip:
                self._gain = self._clip.gain
            self._update_gain_source()

    @subject_slot('pitch_fine')
    def _on_pitch_fine_changed(self):
        if self.is_enabled():
            if self._clip:
                self._pitch_fine = self._on_clip_detune_value.subject and not self._on_clip_detune_value.subject.is_pressed() and self._clip.pitch_fine
            self._update_pitch_fine_source()

    @subject_slot('pitch_coarse')
    def _on_pitch_coarse_changed(self):
        if self.is_enabled():
            if self._clip:
                self._pitch_coarse = self._on_clip_transpose_value.subject and not self._on_clip_transpose_value.subject.is_pressed() and self._clip.pitch_coarse
            self._update_pitch_coarse_source()

    def _update_warp_mode(self):
        if self.is_enabled() and self._clip:
            warp_mode = self._clip.warp_mode
            if warp_mode in self._available_warp_modes:
                self._warp_mode = warp_mode
                if self._on_clip_warp_mode_value.subject:
                    if not self._on_clip_warp_mode_value.subject.is_pressed():
                        self._warp_mode_encoder_value = len(self._available_warp_modes) > 1 and self._warping and float(self._available_warp_modes.index(self._warp_mode)) / float(len(self._available_warp_modes) - 1)
                    else:
                        self._warp_mode_encoder_value = 0.0

    def _update_warp_mode_source(self):
        if self._clip and self._warp_mode != None:
            value = self._warp_mode_names[self._warp_mode] if self._warping else 'Off'
        else:
            value = '-'
        self._value_sources[0].set_display_string(value)

    def _update_gain_source(self):
        value = self._clip.gain_display_string if self._clip and self._gain != None else '-'
        self._value_sources[3].set_display_string(value)

    def _update_pitch_fine_source(self):
        value = str(int(self._pitch_fine)) + ' ct' if self._clip and self._clip.pitch_fine != None else '-'
        self._value_sources[1].set_display_string(value)

    def _update_pitch_coarse_source(self):
        value = str(int(self._pitch_coarse)) + ' st' if self._clip and self._clip.pitch_coarse != None else '-'
        self._value_sources[2].set_display_string(value)

    def update(self):
        if self.is_enabled():
            for index, label in enumerate(['WarpMode',
             'Detune',
             'Transpose',
             'Gain']):
                self._name_sources[index].set_display_string(label)

            self._update_warp_mode()
            self._update_warp_mode_source()
            self._update_gain_source()
            self._update_pitch_fine_source()
            self._update_pitch_coarse_source()
            self._update_encoder_factor()


class ClipNameComponent(ControlSurfaceComponent):
    """
    Component for showing the clip name
    """
    num_label_segments = 4

    def __init__(self, *a, **k):
        super(ClipNameComponent, self).__init__(*a, **k)
        self._clip = None
        self._name_data_sources = [ DisplayDataSource() for _ in xrange(self.num_label_segments) ]
        self._name_data_sources[0].set_display_string('Clip Selection:')

    def _get_clip(self):
        return self._clip

    def _set_clip(self, clip):
        self._clip = clip
        self._update_clip_name()
        self._on_name_changed.subject = clip
        self.update()

    clip = property(_get_clip, _set_clip)

    def set_display(self, display):
        if display:
            display.set_num_segments(self.num_label_segments)
            for idx in xrange(self.num_label_segments):
                display.segment(idx).set_data_source(self._name_data_sources[idx])

    @subject_slot('name')
    def _on_name_changed(self):
        if self.is_enabled():
            self._update_clip_name()

    def _name_for_clip(self, clip):
        if clip:
            return clip.name if clip.name else '[unnamed]'
        else:
            return '[none]'

    def _update_clip_name(self):
        self._name_data_sources[1].set_display_string(self._name_for_clip(self._clip))

    def update(self):
        if self.is_enabled():
            self._update_clip_name()


class ClipControlComponent(ModesComponent):
    """
    Component that modifies clip properties
    """

    def __init__(self, loop_layer = None, audio_layer = None, clip_name_layer = None, *a, **k):
        super(ClipControlComponent, self).__init__(*a, **k)
        self._audio_clip_settings, self._loop_settings, self._clip_name = self.register_components(AudioClipSettingsComponent(is_enabled=False, layer=audio_layer), LoopSettingsComponent(is_enabled=False, layer=loop_layer), ClipNameComponent(is_enabled=False, layer=clip_name_layer))
        self.add_mode('no_clip', (self._clip_name,))
        self.add_mode('midi', (self._loop_settings, self._clip_name))
        self.add_mode('audio', (self._loop_settings, self._audio_clip_settings, self._clip_name))
        self.selected_mode = 'no_clip'
        self._update_clip()
        self._on_detail_clip_changed.subject = self.song().view

    def on_selected_scene_changed(self):
        self._update_clip()

    def on_selected_track_changed(self):
        self._update_clip()

    @subject_slot('detail_clip')
    def _on_detail_clip_changed(self):
        self._update_clip()

    def update(self):
        if self.is_enabled():
            self._update_clip()

    def _update_mode(self):
        selected_track = self.song().view.selected_track
        if selected_track.has_midi_input and selected_track.can_be_armed:
            self.selected_mode = 'midi'
        elif selected_track.has_audio_input and selected_track.can_be_armed:
            self.selected_mode = 'audio'
        else:
            self.selected_mode = 'no_clip'

    def _update_clip(self):
        self._update_mode()
        clip = self.song().view.detail_clip if self.is_enabled() else None
        audio_clip = clip if clip and clip.is_audio_clip else None
        self._clip_name.clip = clip
        self._loop_settings.clip = clip
        self._audio_clip_settings.clip = audio_clip
########NEW FILE########
__FILENAME__ = ClipCreator
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/ClipCreator.py
import Live
_Q = Live.Song.Quantization

class ClipCreator(object):
    """
    Manages clip creation over all components.
    """
    grid_quantization = None
    is_grid_triplet = False
    fixed_length = 8

    def create(self, slot, length = None):
        if not slot.clip == None:
            raise AssertionError
            if length is None:
                length = self.fixed_length
            slot.create_clip(length)
            slot.clip.view.grid_quantization = self.grid_quantization != None and self.grid_quantization
            slot.clip.view.grid_is_triplet = self.is_grid_triplet
        slot.fire(force_legato=True, launch_quantization=_Q.q_no_q)
########NEW FILE########
__FILENAME__ = Colors
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/Colors.py
"""
Module for the color interfaces defining all posible ways of turning
on buttons in the L9C.
"""
from itertools import izip, repeat
from _Framework.ButtonElement import ButtonValue

class NotDrawableError(Exception):
    pass


class Color(ButtonValue):
    """
    Basic interface for the different color types.
    """

    def draw(self, interface):
        """
        Draws the color into the interface.  Depending on the color
        type, interface might be required special capabilities.
        """
        interface.send_value(self.midi_value)


class RgbColor(Color):
    """
    An a RGB color drawable in RGB pads represented.
    """
    _rgb_value = (0, 0, 0)

    def __init__(self, midi_value = None, rgb_value = None, *a, **k):
        super(RgbColor, self).__init__(midi_value=midi_value, *a, **k)
        if rgb_value is not None:
            self._rgb_value = rgb_value

    def shade(self, shade_level):
        """
        Generate a new shaded RGB from this color.
        """
        raise shade_level > 0 and shade_level <= 2 or AssertionError
        shade_factor = 1.0 / 2.0 * (2 - shade_level)
        return RgbColor(self.midi_value + shade_level, [ a * b for a, b in izip(self._rgb_value, repeat(shade_factor)) ])

    def highlight(self):
        """
        Generate a new highlighted RGB from this color.
        """
        return RgbColor(self.midi_value - 1, [ a * b for a, b in izip(self._rgb_value, repeat(1.5)) ])

    def draw(self, interface):
        if interface.is_rgb:
            super(RgbColor, self).draw(interface)
        else:
            raise NotDrawableError, 'Rgb color ' + str(self._rgb_value) + ' not drawable in ' + interface.name

    def __iter__(self):
        return iter(self._rgb_value)

    def __getitem__(self, index_or_slice):
        return self._rgb_value[index_or_slice]


class FallbackColor(Color):
    """
    Tries to draw the color with a default color object but uses the own midi value if
    it fails. This can be used to define a color that can be either used by a bi-led
    or rgb button.
    """

    def __init__(self, default_color = None, *a, **k):
        super(FallbackColor, self).__init__(*a, **k)
        self.default_color = default_color

    def draw(self, interface):
        try:
            self.default_color.draw(interface)
        except NotDrawableError:
            super(FallbackColor, self).draw(interface)


class AnimatedColor(Color):
    """
    Creates an animation between two RGB colors.
    The animation is defined by the channel2.
    """

    @property
    def midi_value(self):
        return self.convert_to_midi_value()

    def __init__(self, color1 = RgbColor(), color2 = RgbColor(), channel2 = 7, *a, **k):
        super(AnimatedColor, self).__init__(*a, **k)
        self.color1 = color1
        self.color2 = color2
        self.channel2 = channel2

    def draw(self, interface):
        raise interface.num_delayed_messages >= 2 or AssertionError
        interface.send_value(self.color1.midi_value)
        interface.send_value(self.color2.midi_value, channel=self.channel2)

    def convert_to_midi_value(self):
        raise NotImplementedError, 'Animations cannot be serialized'


class Pulse(AnimatedColor):
    """
    Smoothly pulsates between two colors.
    """

    def __init__(self, color1 = RgbColor(), color2 = RgbColor(), speed = 6, *a, **k):
        channel2 = [4,
         6,
         12,
         24,
         48].index(speed) + 6
        super(Pulse, self).__init__(color1=color1, color2=color2, channel2=channel2, *a, **k)


class Blink(AnimatedColor):
    """
    Blinks jumping between two colors.
    """

    def __init__(self, color1 = 0, color2 = 0, speed = 6, *a, **k):
        channel2 = [4,
         6,
         12,
         24,
         48].index(speed) + 11
        super(Blink, self).__init__(color1=color1, color2=color2, channel2=channel2, *a, **k)


class Basic:
    """
    Table of basic colors for side buttons.
    """
    HALF = Color(1)
    HALF_BLINK_SLOW = Color(2)
    HALF_BLINK_FAST = Color(3)
    FULL = Color(4)
    FULL_BLINK_SLOW = Color(5)
    FULL_BLINK_FAST = Color(6)
    OFF = Color(0)
    ON = Color(127)


class Rgb:
    """
    Table of RgbColors for main matrix.
    """
    BLACK = RgbColor(0)
    DARK_GREY = RgbColor(1)
    GREY = RgbColor(2)
    WHITE = RgbColor(3)
    RED = RgbColor(5)
    AMBER = RgbColor(9)
    YELLOW = RgbColor(13)
    LIME = RgbColor(17)
    GREEN = RgbColor(21)
    SPRING = RgbColor(25)
    TURQUOISE = RgbColor(29)
    CYAN = RgbColor(33)
    SKY = RgbColor(37)
    OCEAN = RgbColor(41)
    BLUE = RgbColor(45)
    ORCHID = RgbColor(49)
    MAGENTA = RgbColor(53)
    PINK = RgbColor(57)


class BiLed:
    """
    Table of colors for scene launch buttons.
    """
    GREEN = FallbackColor(RgbColor(122), 22)
    GREEN_HALF = FallbackColor(RgbColor(123), 19)
    GREEN_BLINK_SLOW = FallbackColor(Blink(RgbColor(122), Rgb.BLACK, 4), 23)
    GREEN_BLINK_FAST = FallbackColor(Blink(RgbColor(122), Rgb.BLACK, 24), 24)
    RED = FallbackColor(RgbColor(120), 4)
    RED_HALF = FallbackColor(RgbColor(121), 1)
    RED_BLINK_SLOW = FallbackColor(Blink(RgbColor(120), Rgb.BLACK, 4), 5)
    RED_BLINK_FAST = FallbackColor(Blink(RgbColor(120), Rgb.BLACK, 24), 6)
    YELLOW = FallbackColor(RgbColor(124), 16)
    YELLOW_HALF = FallbackColor(RgbColor(125), 13)
    YELLOW_BLINK_SLOW = FallbackColor(Blink(RgbColor(124), Rgb.BLACK, 4), 17)
    YELLOW_BLINK_FAST = FallbackColor(Blink(RgbColor(124), Rgb.BLACK, 24), 18)
    AMBER = FallbackColor(RgbColor(126), 10)
    AMBER_HALF = FallbackColor(RgbColor(127), 7)
    AMBER_BLINK_SLOW = FallbackColor(Blink(RgbColor(126), Rgb.BLACK, 4), 11)
    AMBER_BLINK_FAST = FallbackColor(Blink(RgbColor(126), Rgb.BLACK, 24), 12)
    OFF = FallbackColor(Rgb.BLACK, 0)
    ON = FallbackColor(Rgb.WHITE, 127)


CLIP_COLOR_TABLE = {15549221: 60,
 12411136: 61,
 11569920: 62,
 8754719: 63,
 5480241: 64,
 695438: 65,
 31421: 66,
 197631: 67,
 3101346: 68,
 6441901: 69,
 8092539: 70,
 3947580: 71,
 16712965: 72,
 12565097: 73,
 10927616: 74,
 8046132: 75,
 4047616: 76,
 49071: 77,
 1090798: 78,
 5538020: 79,
 8940772: 80,
 10701741: 81,
 12008809: 82,
 9852725: 83,
 16149507: 84,
 12581632: 85,
 8912743: 86,
 1769263: 87,
 2490280: 88,
 6094824: 89,
 1698303: 90,
 9160191: 91,
 9611263: 92,
 12094975: 93,
 14183652: 94,
 16726484: 95,
 16753961: 96,
 16773172: 97,
 14939139: 98,
 14402304: 99,
 12492131: 100,
 9024637: 101,
 8962746: 102,
 10204100: 103,
 8758722: 104,
 13011836: 105,
 15810688: 106,
 16749734: 107,
 16753524: 108,
 16772767: 109,
 13821080: 110,
 12243060: 111,
 11119017: 112,
 13958625: 113,
 13496824: 114,
 12173795: 115,
 13482980: 116,
 13684944: 117,
 14673637: 118,
 16777215: 119}
RGB_COLOR_TABLE = ((0, 0),
 (1, 1973790),
 (2, 8355711),
 (3, 16777215),
 (4, 16731212),
 (5, 16711680),
 (6, 5832704),
 (7, 1638400),
 (8, 16760172),
 (9, 16733184),
 (10, 5840128),
 (11, 2562816),
 (12, 16777036),
 (13, 16776960),
 (14, 5855488),
 (15, 1644800),
 (16, 8978252),
 (17, 5570304),
 (18, 1923328),
 (19, 1321728),
 (20, 5046092),
 (21, 65280),
 (22, 22784),
 (23, 6400),
 (24, 5046110),
 (25, 65305),
 (26, 22797),
 (27, 6402),
 (28, 5046152),
 (29, 65365),
 (30, 22813),
 (31, 7954),
 (32, 5046199),
 (33, 65433),
 (34, 22837),
 (35, 6418),
 (36, 5030911),
 (37, 43519),
 (38, 16722),
 (39, 4121),
 (40, 5015807),
 (41, 22015),
 (42, 7513),
 (43, 2073),
 (44, 5000447),
 (45, 255),
 (46, 89),
 (47, 25),
 (48, 8867071),
 (49, 5505279),
 (50, 1638500),
 (51, 983088),
 (52, 16731391),
 (53, 16711935),
 (54, 5832793),
 (55, 1638425),
 (56, 16731271),
 (57, 16711764),
 (58, 5832733),
 (59, 2228243),
 (60, 16717056),
 (61, 10040576),
 (62, 7950592),
 (63, 4416512),
 (64, 211200),
 (65, 22325),
 (66, 21631),
 (67, 255),
 (68, 17743),
 (69, 2425036),
 (70, 8355711),
 (71, 2105376),
 (72, 16711680),
 (73, 12451629),
 (74, 11529478),
 (75, 6618889),
 (76, 1084160),
 (77, 65415),
 (78, 43519),
 (79, 11007),
 (80, 4129023),
 (81, 7995647),
 (82, 11672189),
 (83, 4202752),
 (84, 16730624),
 (85, 8970502),
 (86, 7536405),
 (87, 65280),
 (88, 3931942),
 (89, 5898097),
 (90, 3735500),
 (91, 5999359),
 (92, 3232198),
 (93, 8880105),
 (94, 13835775),
 (95, 16711773),
 (96, 16744192),
 (97, 12169216),
 (98, 9502464),
 (99, 8609031),
 (100, 3746560),
 (101, 1330192),
 (102, 872504),
 (103, 1381674),
 (104, 1450074),
 (105, 6896668),
 (106, 11010058),
 (107, 14569789),
 (108, 14182940),
 (109, 16769318),
 (110, 10412335),
 (111, 6796559),
 (112, 1973808),
 (113, 14483307),
 (114, 8454077),
 (115, 10131967),
 (116, 9332479),
 (117, 4210752),
 (118, 7697781),
 (119, 14745599),
 (120, 10485760),
 (121, 3473408),
 (122, 1757184),
 (123, 475648),
 (124, 12169216),
 (125, 4141312),
 (126, 11755264),
 (127, 4920578))
########NEW FILE########
__FILENAME__ = ComboElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/ComboElement.py
from __future__ import with_statement
from itertools import imap
from contextlib import contextmanager
from _Framework import Task, Defaults
from _Framework.Util import const, find_if, lazy_attribute, nop
from _Framework.Dependency import depends
from _Framework.CompoundElement import CompoundElement
from _Framework.SubjectSlot import SlotManager, Subject, subject_slot
from _Framework.ButtonElement import ButtonElementMixin
from _Framework.NotifyingControlElement import NotifyingControlElement
from _Framework.InputControlElement import ParameterSlot
from _Framework.Proxy import ProxyBase

class WrapperElement(CompoundElement, ProxyBase):
    """
    Helper class for implementing a wrapper for a specific control,
    forwarding most basic operations to it.
    
    Note that the wrapped control element is not registered to allow
    this flexibly specific implementations.
    """

    class ProxiedInterface(CompoundElement.ProxiedInterface):

        def __getattr__(self, name):
            wrapped = self.outer.__dict__['_wrapped_control']
            return getattr(wrapped.proxied_interface, name)

    def __init__(self, wrapped_control = None, *a, **k):
        super(WrapperElement, self).__init__(*a, **k)
        self._wrapped_control = wrapped_control
        self._parameter_slot = ParameterSlot()

    @property
    def proxied_object(self):
        if self._is_initialized() and self.owns_control_element(self._wrapped_control):
            return self._wrapped_control

    def _is_initialized(self):
        return '_wrapped_control' in self.__dict__

    def register_wrapped(self):
        self.register_control_element(self._wrapped_control)

    def unregister_wrapped(self):
        self.unregister_control_element(self._wrapped_control)

    @property
    def wrapped_control(self):
        return self._wrapped_control

    def __nonzero__(self):
        return self.owns_control_element(self._wrapped_control)

    def on_nested_control_element_grabbed(self, control):
        if control == self._wrapped_control:
            self._parameter_slot.control = control

    def on_nested_control_element_released(self, control):
        if control == self._wrapped_control:
            self._parameter_slot.control = None

    def on_nested_control_element_value(self, value, control):
        if control == self._wrapped_control:
            self.notify_value(value)

    def connect_to(self, parameter):
        if self._parameter_slot.parameter == None:
            self.request_listen_nested_control_elements()
        self._parameter_slot.parameter = parameter

    def release_parameter(self):
        if self._parameter_slot.parameter != None:
            self.unrequest_listen_nested_control_elements()
        self._parameter_slot.parameter = None


class ComboElement(WrapperElement):
    """
    An element representing a combination of buttons.  It will forward
    the button values when all the modifiers have the specified state,
    and silently discard them when they are not. If no state is provided
    for the modifiers, being pressed is assumed as the target state.
    
    When using resources, this element:
      - Grabs the modifiers at all times.
      - Grabs the action button only when all modifiers have the right state.
    
    This means that the action button can be used at the same time in
    the same Layer in a combined and un-combined fashion.  The setters
    of the layer buttons will be called properly so the button gets
    the right light updated when the modifiers are pressed.  For
    example see how the SessionRecording takes the automation_button
    in a combo and raw.
    """

    def __init__(self, control = None, modifiers = [], negative_modifiers = [], *a, **k):
        super(ComboElement, self).__init__(wrapped_control=control, *a, **k)
        raise all(imap(lambda x: x.is_momentary(), modifiers + negative_modifiers)) or AssertionError
        self._combo_modifiers = dict(map(lambda x: (x, True), modifiers) + map(lambda x: (x, False), negative_modifiers))
        self.register_control_elements(*self._combo_modifiers.keys())
        self.request_listen_nested_control_elements()

    def reset(self):
        if self.owns_control_element(self._wrapped_control):
            self._wrapped_control.reset()

    def on_nested_control_element_grabbed(self, control):
        if control != self._wrapped_control:
            self._enforce_control_invariant()
        else:
            super(ComboElement, self).on_nested_control_element_grabbed(control)

    def on_nested_control_element_released(self, control):
        if control != self._wrapped_control:
            self._enforce_control_invariant()
        else:
            super(ComboElement, self).on_nested_control_element_released(control)

    def on_nested_control_element_value(self, value, control):
        if control != self._wrapped_control:
            self._enforce_control_invariant()
        else:
            super(ComboElement, self).on_nested_control_element_value(value, control)

    def _enforce_control_invariant(self):
        if self._combo_is_on():
            if not self.has_control_element(self._wrapped_control):
                self.register_control_element(self._wrapped_control)
        elif self.has_control_element(self._wrapped_control):
            self.unregister_control_element(self._wrapped_control)

    def _combo_is_on(self):
        return all(imap(self._modifier_is_valid, self._combo_modifiers))

    def _modifier_is_valid(self, mod):
        return self.owns_control_element(mod) and mod.is_pressed() == self._combo_modifiers[mod]


class EventElement(NotifyingControlElement, SlotManager, ProxyBase, ButtonElementMixin):
    """
    Translate an arbitrary subject event into a notifying control
    element interface.
    """
    event_value = 1
    _subject = None

    def __init__(self, subject = None, event = None, *a, **k):
        raise subject is not None or AssertionError
        raise event is not None or AssertionError
        super(EventElement, self).__init__(*a, **k)
        self._subject = subject
        self.register_slot(subject, self._on_event, event)

    @property
    def proxied_object(self):
        return self._subject

    @property
    def proxied_interface(self):
        return getattr(self._subject, 'proxied_interface', self._subject)

    def _on_event(self, *a, **k):
        self.notify_value(self.event_value)

    def is_momentary(self):
        return False

    def reset(self):
        getattr(self._subject, 'reset', nop)()

    def send_value(self, *a, **k):
        try:
            send_value = super(EventElement, self).__getattr__('send_value')
        except AttributeError:
            send_value = nop

        send_value(*a, **k)

    def set_light(self, *a, **k):
        try:
            set_light = super(EventElement, self).__getattr__('set_light')
        except AttributeError:
            set_light = nop

        set_light(*a, **k)


class DoublePressContext(Subject):
    """
    Determines the context of double press.  Every double press element
    in the same scope can not be interleaved -- i.e. let buttons B1
    and B2, the sequence press(B1), press(B2), press(B1) does not
    trigger a double press event regardless of how fast it happens.
    """
    __subject_events__ = ('break_double_press',)

    @contextmanager
    def breaking_double_press(self):
        self._broke_double_press = False
        yield
        if not self._broke_double_press:
            self.break_double_press()

    def break_double_press(self):
        self.notify_break_double_press()
        self._broke_double_press = True


GLOBAL_DOUBLE_PRESS_CONTEXT_PROVIDER = const(DoublePressContext())

class DoublePressElement(WrapperElement):
    """
    Element wrapper that provides a facade with two events,
    single_press and double_press.
    
    The single_press() and double_press() methods create non-momentary
    button-like controls that represent these events.  Note that these
    controls are individual and have their own ownership, put the
    original DoublePressElement as a hidden element of the layer where
    these are used if ownership is to be taken into account.
    """
    __subject_events__ = ('single_press', 'double_press')
    DOUBLE_PRESS_MAX_DELAY = Defaults.MOMENTARY_DELAY

    @depends(double_press_context=GLOBAL_DOUBLE_PRESS_CONTEXT_PROVIDER)
    def __init__(self, wrapped_control = None, double_press_context = None, *a, **k):
        super(DoublePressElement, self).__init__(wrapped_control=wrapped_control, *a, **k)
        self.register_control_element(self._wrapped_control)
        self._double_press_context = double_press_context
        self._double_press_task = self._tasks.add(Task.sequence(Task.wait(self.DOUBLE_PRESS_MAX_DELAY), Task.run(self.finish_single_press))).kill()
        self.request_listen_nested_control_elements()

    def on_nested_control_element_value(self, value, control):
        if not control.is_momentary() or value:
            if self._double_press_task.is_killed:
                self._double_press_context.break_double_press()
                self._on_break_double_press.subject = self._double_press_context
                self._double_press_task.restart()
            else:
                self.finish_double_press()
                self._double_press_task.kill()
        super(DoublePressElement, self).on_nested_control_element_value(value, control)

    @subject_slot('break_double_press')
    def _on_break_double_press(self):
        if not self._double_press_task.is_killed:
            self._double_press_task.kill()
            self.finish_single_press()

    def finish_single_press(self):
        self._on_break_double_press.subject = None
        self.notify_single_press()

    def finish_double_press(self):
        self._on_break_double_press.subject = None
        self.notify_double_press()

    @lazy_attribute
    def single_press(self):
        return EventElement(self, 'single_press')

    @lazy_attribute
    def double_press(self):
        return EventElement(self, 'double_press')


class MultiElement(CompoundElement, ButtonElementMixin):
    """
    Makes several elements behave as single one. Useful when it is
    desired to map several buttons to single one.
    """

    class ProxiedInterface(CompoundElement.ProxiedInterface):

        def __getattr__(self, name):
            found = find_if(lambda x: x is not None, imap(lambda c: getattr(c.proxied_interface, name, None), self.outer.nested_control_elements()))
            if found is not None:
                return found
            raise AttributeError

    def __init__(self, *controls, **k):
        super(MultiElement, self).__init__(**k)
        self.register_control_elements(*controls)

    def send_value(self, value):
        for control in self.owned_control_elements():
            control.send_value(value)

    def set_light(self, value):
        for control in self.owned_control_elements():
            control.set_light(value)

    def on_nested_control_element_value(self, value, control):
        if not self.is_pressed() or value:
            self.notify_value(value)

    def is_pressed(self):
        return find_if(lambda c: getattr(c, 'is_pressed', const(False))(), self.owned_control_elements()) != None

    def is_momentary(self):
        return find_if(lambda c: getattr(c, 'is_momentary', const(False))(), self.nested_control_elements()) != None

    def on_nested_control_element_grabbed(self, control):
        pass

    def on_nested_control_element_released(self, control):
        pass
########NEW FILE########
__FILENAME__ = ConfigurableButtonElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/ConfigurableButtonElement.py
from _Framework.ButtonElement import ButtonElement, ON_VALUE, OFF_VALUE
from Skin import Skin, SkinColorMissingError
from Colors import Basic
from MatrixMaps import NON_FEEDBACK_CHANNEL

class ConfigurableButtonElement(ButtonElement):
    """
    Special button class that can be configured with custom on-
    and off-values.
    
    A ConfigurableButtonElement can have states other than True or
    False, which can be defined by setting the 'states' property.
    Thus 'set_light' can take any state or skin color.
    """

    class Colors:

        class DefaultButton:
            On = Basic.ON
            Off = Basic.HALF
            Disabled = Basic.OFF
            Alert = Basic.FULL_BLINK_FAST

    default_skin = Skin(Colors)
    default_states = {True: 'DefaultButton.On',
     False: 'DefaultButton.Off'}
    num_delayed_messages = 2
    send_depends_on_forwarding = False

    def __init__(self, is_momentary, msg_type, channel, identifier, skin = None, is_rgb = False, default_states = None, *a, **k):
        super(ConfigurableButtonElement, self).__init__(is_momentary, msg_type, channel, identifier, *a, **k)
        if default_states is not None:
            self.default_states = default_states
        self.states = dict(self.default_states)
        self.is_rgb = is_rgb
        self._skin = skin or self.default_skin
        self._is_enabled = True
        self._force_next_value = False
        self.set_channel(NON_FEEDBACK_CHANNEL)

    @property
    def _on_value(self):
        return self.states[True]

    @property
    def _off_value(self):
        return self.states[False]

    @property
    def on_value(self):
        return self._try_fetch_skin_value(self._on_value)

    @property
    def off_value(self):
        return self._try_fetch_skin_value(self._off_value)

    def _try_fetch_skin_value(self, value):
        try:
            return self._skin[value]
        except SkinColorMissingError:
            return value

    def reset(self):
        self.states = dict(self.default_states)
        self.set_light('DefaultButton.Disabled')
        self.set_identifier(self._original_identifier)
        self.set_channel(NON_FEEDBACK_CHANNEL)
        self.set_enabled(True)

    def set_on_off_values(self, on_value, off_value):
        self.states[True] = on_value
        self.states[False] = off_value

    def set_force_next_value(self):
        self._force_next_value = True

    def set_enabled(self, enabled):
        if self._is_enabled != enabled:
            self._is_enabled = enabled
            self._request_rebuild()

    def is_enabled(self):
        return self._is_enabled

    def set_light(self, value):
        self._set_skin_light(self.states.get(value, value))

    def _set_skin_light(self, value):
        try:
            color = self._skin[value]
            color.draw(self)
        except SkinColorMissingError:
            super(ConfigurableButtonElement, self).set_light(value)

    def send_value(self, value, **k):
        if value is ON_VALUE:
            self._do_send_on_value()
        elif value is OFF_VALUE:
            self._do_send_off_value()
        else:
            super(ConfigurableButtonElement, self).send_value(value, **k)

    def _do_send_on_value(self):
        self._skin[self._on_value].draw(self)

    def _do_send_off_value(self):
        self._skin[self._off_value].draw(self)

    def script_wants_forwarding(self):
        return self._is_enabled


class PadButtonElement(ConfigurableButtonElement):
    """
    Button element for holding Push pressure-sensitive pad. The pad_id
    parameter defines the Pad coordine id used in the sysex protocol.
    """

    def __init__(self, pad_id = None, pad_sensitivity_update = None, *a, **k):
        raise pad_id is not None or AssertionError
        super(PadButtonElement, self).__init__(*a, **k)
        self._sensitivity_profile = 'default'
        self._pad_id = pad_id
        self._pad_sensitivity_update = pad_sensitivity_update

    def _get_sensitivity_profile(self):
        return self._sensitivity_profile

    def _set_sensitivity_profile(self, profile):
        if profile != self._sensitivity_profile:
            self._sensitivity_profile = profile
            self._pad_sensitivity_update.set_pad(self._pad_id, profile)

    sensitivity_profile = property(_get_sensitivity_profile, _set_sensitivity_profile)

    def reset(self):
        self.sensitivity_profile = 'default'
        super(PadButtonElement, self).reset()
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/consts.py
from _Framework.Resource import PrioritizedResource
import sys
DISPLAY_LENGTH = 72
DISPLAY_BLOCK_LENGTH = 18
SCROLL_SIDE_BUTTON_STATES = {'Pressed': 'DefaultButton.On',
 'Enabled': 'DefaultButton.Off',
 True: 'DefaultButton.On',
 False: 'DefaultButton.Disabled'}
MUSICAL_MODES = ['Major',
 [0,
  2,
  4,
  5,
  7,
  9,
  11],
 'Minor',
 [0,
  2,
  3,
  5,
  7,
  8,
  10],
 'Dorian',
 [0,
  2,
  3,
  5,
  7,
  9,
  10],
 'Mixolydian',
 [0,
  2,
  4,
  5,
  7,
  9,
  10],
 'Lydian',
 [0,
  2,
  4,
  6,
  7,
  9,
  11],
 'Phrygian',
 [0,
  1,
  3,
  5,
  7,
  8,
  10],
 'Locrian',
 [0,
  1,
  3,
  5,
  6,
  8,
  10],
 'Diminished',
 [0,
  1,
  3,
  4,
  6,
  7,
  9,
  10],
 'Whole-half',
 [0,
  2,
  3,
  5,
  6,
  8,
  9,
  11],
 'Whole Tone',
 [0,
  2,
  4,
  6,
  8,
  10],
 'Minor Blues',
 [0,
  3,
  5,
  6,
  7,
  10],
 'Minor Pentatonic',
 [0,
  3,
  5,
  7,
  10],
 'Major Pentatonic',
 [0,
  2,
  4,
  7,
  9],
 'Harmonic Minor',
 [0,
  2,
  3,
  5,
  7,
  8,
  11],
 'Melodic Minor',
 [0,
  2,
  3,
  5,
  7,
  9,
  11],
 'Super Locrian',
 [0,
  1,
  3,
  4,
  6,
  8,
  10],
 'Bhairav',
 [0,
  1,
  4,
  5,
  7,
  8,
  11],
 'Hungarian Minor',
 [0,
  2,
  3,
  6,
  7,
  8,
  11],
 'Minor Gypsy',
 [0,
  1,
  4,
  5,
  7,
  8,
  10],
 'Hirojoshi',
 [0,
  2,
  3,
  7,
  8],
 'In-Sen',
 [0,
  1,
  5,
  7,
  10],
 'Iwato',
 [0,
  1,
  5,
  6,
  10],
 'Kumoi',
 [0,
  2,
  3,
  7,
  9],
 'Pelog',
 [0,
  1,
  3,
  4,
  7,
  8],
 'Spanish',
 [0,
  1,
  3,
  4,
  5,
  6,
  8,
  10]]
MIN_OFF_THRESHOLD = 10
MAX_OFF_THRESHOLD = 370
MIN_ON_THRESHOLD = 10
MAX_ON_THRESHOLD = 410
MIN_THRESHOLD_STEP = -20
MAX_THRESHOLD_STEP = 20
CRITICAL_THRESHOLD_LIMIT = 0
PROTO_FAST_DEVICE_NAVIGATION = False
PROTO_AUDIO_NOTE_MODE = False
PROTO_SONG_IS_ROOT = False
PROTO_TOUCH_ENCODER_TO_STRIP = False
DEFAULT_PRIORITY = PrioritizedResource.default_priority
SHARED_PRIORITY = DEFAULT_PRIORITY
M4L_PRIORITY = DEFAULT_PRIORITY + 6
MESSAGE_BOX_PRIORITY = DEFAULT_PRIORITY + 5
DIALOG_PRIORITY = DEFAULT_PRIORITY + 4
MODAL_DIALOG_PRIORITY = DEFAULT_PRIORITY + 3
BROWSER_PRIORITY = DEFAULT_PRIORITY + 2
NOTIFICATION_PRIORITY = DEFAULT_PRIORITY + 1
HIDDEN_SESSION_PRIORITY = DEFAULT_PRIORITY - 2
BACKGROUND_PRIORITY = DEFAULT_PRIORITY - 3
ENCODER_SENSITIVITY = 0.5
CONTINUOUS_MAPPING_SENSITIVITY = 2.0
QUANTIZED_MAPPING_SENSITIVITY = 1.0 / 15.0
CHAR_ARROW_UP = '\x00'
CHAR_ARROW_DOWN = '\x01'
CHAR_ARROW_RIGHT = '\x1e'
CHAR_ARROW_LEFT = '\x1f'
CHAR_RACK = '\x02'
CHAR_BAR_LEFT = '\x03'
CHAR_BAR_RIGHT = '\x04'
CHAR_SPLIT_BLOCK = '\x05'
CHAR_SPLIT_DASH = '\x06'
CHAR_FOLDER = '\x07'
CHAR_ELLIPSIS = '\x1c'
CHAR_FLAT_SIGN = '\x1b'
CHAR_ELLIPSIS = '\x1c'
CHAR_FULL_BLOCK = '\x1d'
CHAR_SELECT = '\x7f'
GRAPH_VOL = ('\x03\x06\x06\x06\x06\x06\x06\x06', '\x05\x06\x06\x06\x06\x06\x06\x06', '\x05\x03\x06\x06\x06\x06\x06\x06', '\x05\x05\x06\x06\x06\x06\x06\x06', '\x05\x05\x03\x06\x06\x06\x06\x06', '\x05\x05\x05\x06\x06\x06\x06\x06', '\x05\x05\x05\x03\x06\x06\x06\x06', '\x05\x05\x05\x05\x06\x06\x06\x06', '\x05\x05\x05\x05\x03\x06\x06\x06', '\x05\x05\x05\x05\x05\x06\x06\x06', '\x05\x05\x05\x05\x05\x03\x06\x06', '\x05\x05\x05\x05\x05\x05\x06\x06', '\x05\x05\x05\x05\x05\x05\x03\x06', '\x05\x05\x05\x05\x05\x05\x05\x06', '\x05\x05\x05\x05\x05\x05\x05\x03', '\x05\x05\x05\x05\x05\x05\x05\x05')
GRAPH_PAN = ('\x05\x05\x05\x05\x06\x06\x06\x06', '\x04\x05\x05\x05\x06\x06\x06\x06', '\x06\x05\x05\x05\x06\x06\x06\x06', '\x06\x04\x05\x05\x06\x06\x06\x06', '\x06\x06\x05\x05\x06\x06\x06\x06', '\x06\x06\x04\x05\x06\x06\x06\x06', '\x06\x06\x06\x05\x06\x06\x06\x06', '\x06\x06\x06\x04\x06\x06\x06\x06', '\x06\x06\x06\x04\x03\x06\x06\x06', '\x06\x06\x06\x06\x03\x06\x06\x06', '\x06\x06\x06\x06\x05\x06\x06\x06', '\x06\x06\x06\x06\x05\x03\x06\x06', '\x06\x06\x06\x06\x05\x05\x06\x06', '\x06\x06\x06\x06\x05\x05\x03\x06', '\x06\x06\x06\x06\x05\x05\x05\x06', '\x06\x06\x06\x06\x05\x05\x05\x03', '\x06\x06\x06\x06\x05\x05\x05\x05')
GRAPH_SIN = ('\x03\x06\x06\x06\x06\x06\x06\x06', '\x04\x06\x06\x06\x06\x06\x06\x06', '\x06\x03\x06\x06\x06\x06\x06\x06', '\x06\x04\x06\x06\x06\x06\x06\x06', '\x06\x06\x03\x06\x06\x06\x06\x06', '\x06\x06\x04\x06\x06\x06\x06\x06', '\x06\x06\x06\x03\x06\x06\x06\x06', '\x06\x06\x06\x04\x06\x06\x06\x06', '\x06\x06\x06\x06\x03\x06\x06\x06', '\x06\x06\x06\x06\x04\x06\x06\x06', '\x06\x06\x06\x06\x06\x03\x06\x06', '\x06\x06\x06\x06\x06\x04\x06\x06', '\x06\x06\x06\x06\x06\x06\x03\x06', '\x06\x06\x06\x06\x06\x06\x04\x06', '\x06\x06\x06\x06\x06\x06\x06\x03', '\x06\x06\x06\x06\x06\x06\x06\x04')

class MessageBoxText:
    LIVE_DIALOG = '\n                    Live is showing a dialog' + '\n                    that needs your attention.'
    CLIP_DUPLICATION_FAILED = '\n                     The clip could not be duplicated' + '\n                      because it is recording'
    SCENE_LIMIT_REACHED = '\n                  No more scene can be inserted' + '\n                   for this version of Live'
    SCENE_DUPLICATION_FAILED = '\n                  This scene cannot be duplicated' + '\n                      because it is recording'
    TRACK_LIMIT_REACHED = '\n                  No more track can be inserted' + '\n                   for this version of Live'
    MAX_RETURN_TRACKS_REACHED = '\n                  Maximum number of return tracks' + '\n                  reached'
    TRACK_DUPLICATION_FAILED = '\n                  This track cannot be duplicated' + '\n                      because it is recording'
    TRACK_DELETE_FAILED = '\n                  This track cannot be deleted' + '\n                      because it is recording'
    DELETE_TRACK = '                  Track deleted:    %s'
    DUPLICATE_TRACK = '                  Track duplicated: %s'
    DELETE_CLIP = '                  Clip deleted:     %s'
    DUPLICATE_CLIP = '                  Clip duplicated:  %s'
    QUANTIZE_CLIP = '                  Quantized to:     %(to)s, %(amount)s'
    QUANTIZE_CLIP_PITCH = '                  Quantized pad to: %(to)s, %(amount)s'
    DELETE_NOTES = '                  Notes deleted:    %s'
    CAPTURE_AND_INSERT_SCENE = '                      Duplicated to scene %s'
    DUPLICATE_LOOP = '                   New loop length: %(length)s'
    DELETE_SCENE = '                  Scene deleted:    %s'
    DUPLICATE_SCENE = '                  Scene duplicated: %s'
    DELETE_ENVELOPE = '                  Delete automation %(automation)s'
    EMPTY_DEVICE_CHAIN = '\n\n               No Devices.    Press [Browse] to add a device.'
    STUCK_PAD_WARNING = '         Warning: Low threshold may cause stuck pads'
    UNDO = '            Undo:     Reverted last action'
    REDO = '            Redo: Re-performed last undone action'
    TRACK_FROZEN_INFO = '                    ' + 'Cannot modify a frozen track'
    SELECTED_CLIP_BLINK = ' Press            to edit playing   clip'
    PLAYING_CLIP_ABOVE_SELECTED_CLIP = ' Press Up Arrow   to edit playing   clip'
    PLAYING_CLIP_BELOW_SELECTED_CLIP = ' Press Down Arrow to edit playing   clip'


_test_mode = __builtins__.get('TEST_MODE', False)
if not _test_mode:
    try:
        _this_module = sys.modules[__name__]
        _proto_list = filter(lambda a: a.startswith('PROTO_'), dir(_this_module))
        for attr in _proto_list:
            try:
                _local_consts = __import__('local_consts', globals(), locals(), [attr], -1)
                setattr(_this_module, attr, getattr(_local_consts, attr))
            except AttributeError:
                pass

    except ImportError:
        pass
########NEW FILE########
__FILENAME__ = DeviceNavigationComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/DeviceNavigationComponent.py
from __future__ import with_statement
from functools import partial
from contextlib import contextmanager
import Live.DrumPad
from _Framework.CompoundComponent import CompoundComponent
from _Framework.SubjectSlot import subject_slot
from _Framework.Util import find_if, in_range, NamedTuple, const
from _Framework.Disconnectable import disconnectable
from _Framework.Dependency import depends, inject
from MessageBoxComponent import MessageBoxComponent
from ScrollableListComponent import ScrollableListWithTogglesComponent
from NavigationNode import make_navigation_node
import consts

class DeviceNavigationComponent(CompoundComponent):
    """
    Component that displays an overview of the devices in the current
    track and navigates in its hierarchy.
    """

    def __init__(self, device_bank_registry = None, info_layer = None, delete_handler = None, *a, **k):
        super(DeviceNavigationComponent, self).__init__(*a, **k)
        self._make_navigation_node = partial(make_navigation_node, device_bank_registry=device_bank_registry)
        self._state_buttons = None
        self._delete_handler = delete_handler
        self._device_list = self.register_component(ScrollableListWithTogglesComponent())
        self._on_selection_clicked_in_controller.subject = self._device_list
        self._on_selection_changed_in_controller.subject = self._device_list
        self._on_state_changed_in_controller.subject = self._device_list
        self._current_node = None
        self._message_box = self.register_component(MessageBoxComponent(layer=info_layer, is_enabled=False))
        self._message_box.text = consts.MessageBoxText.EMPTY_DEVICE_CHAIN
        self._selected_track = None
        self._on_selected_track_changed.subject = self.song().view
        with inject(selection=const(NamedTuple(selected_device=None))).everywhere():
            self._on_selected_track_changed()

    @property
    def current_node(self):
        return self._current_node

    def set_select_buttons(self, select_buttons):
        self._device_list.set_select_buttons(select_buttons)

    def set_state_buttons(self, state_buttons):
        self._state_buttons = state_buttons
        self._device_list.set_state_buttons(state_buttons)

    def set_exit_button(self, exit_button):
        raise not exit_button or exit_button.is_momentary() or AssertionError
        self._on_exit_value.subject = exit_button
        self._update_exit_button()

    def set_enter_button(self, enter_button):
        raise not enter_button or enter_button.is_momentary() or AssertionError
        self._on_enter_value.subject = enter_button
        self._update_enter_button()

    def set_display_line(self, line):
        self._device_list.set_display_line(line)

    def set_blank_display_line(self, line):
        if line:
            line.reset()

    @property
    def selected_object(self):
        selected = None
        if self._current_node:
            children = self._current_node.children
            option = self._device_list.selected_option
            if children and in_range(option, 0, len(children)):
                _, selected = children[option]
        return selected

    def back_to_top(self):
        if consts.PROTO_SONG_IS_ROOT:
            self._set_current_node(self._make_navigation_node(self.song()))
        else:
            self._set_current_node(self._make_navigation_node(self._selected_track))

    @subject_slot('selected_track')
    def _on_selected_track_changed(self):
        self._selected_track = self.song().view.selected_track
        self._on_selected_device_changed.subject = self._selected_track.view
        self.back_to_top()

    @subject_slot('selected_device')
    def _on_selected_device_changed(self):
        selected_device = self._selected_track.view.selected_device
        if selected_device == None:
            self._set_current_node(self._make_exit_node())
            return
        is_just_default_child_selection = False
        if self._current_node and self._current_node.children:
            selected = self.selected_object
            if isinstance(selected, Live.DrumPad.DrumPad) and find_if(lambda pad: pad.chains and pad.chains[0].devices and pad.chains[0].devices[0] == selected_device, selected.canonical_parent.drum_pads):
                is_just_default_child_selection = True
            if isinstance(selected, Live.Chain.Chain) and selected_device and selected_device.canonical_parent == selected and selected.devices[0] == selected_device:
                is_just_default_child_selection = True
        if not is_just_default_child_selection:
            if selected_device:
                target = selected_device.canonical_parent
                node = (not self._current_node or self._current_node.object != target) and self._make_navigation_node(target, is_entering=False)
                self._set_current_node(node)

    def _set_current_node(self, node):
        if node is None:
            return
        self.disconnect_disconnectable(self._current_node)
        self._current_node = node
        self.register_slot_manager(node)
        self._on_children_changed_in_node.subject = node
        self._on_selected_child_changed_in_node.subject = node
        self._on_state_changed_in_node.subject = node
        self._on_children_changed_in_node()
        for index, value in enumerate(node.state):
            self._on_state_changed_in_node(index, value)

        node.preselect()

    @depends(selection=lambda : NamedTuple(selected_device=None))
    def _update_info(self, selection = None):
        if self._selected_track != None and len(self._selected_track.devices) == 0 and selection.selected_device == None:
            self._message_box.set_enabled(True)
        else:
            self._message_box.set_enabled(False)

    def update(self):
        if self.is_enabled():
            self._update_enter_button()
            self._update_exit_button()
            self._update_info()

    @contextmanager
    def _deactivated_option_listener(self):
        old_subject = self._on_state_changed_in_controller.subject
        self._on_state_changed_in_controller.subject = None
        yield
        self._on_state_changed_in_controller.subject = old_subject

    @subject_slot('state')
    def _on_state_changed_in_node(self, index, value):
        with self._deactivated_option_listener():
            self._device_list.set_option_state(index, value)

    @subject_slot('children')
    def _on_children_changed_in_node(self):
        names = map(lambda x: x[0], self._current_node.children)
        self._device_list.option_names = names
        self._device_list.selected_option = self._current_node.selected_child
        self._update_enter_button()
        self._update_exit_button()

    @subject_slot('selected_child')
    def _on_selected_child_changed_in_node(self, index):
        self._device_list.selected_option = index
        self._update_enter_button()
        self._update_exit_button()
        self._update_info()

    @property
    def _is_deleting(self):
        return self._delete_handler and self._delete_handler.is_deleting

    @subject_slot('toggle_option')
    def _on_state_changed_in_controller(self, index, value):
        if self._current_node:
            if self._is_deleting:
                _, child = self._current_node.children[index]
                if child != None and isinstance(child, Live.Device.Device):
                    self._delete_handler.delete_clip_envelope(child.parameters[0])
            else:
                self._current_node.set_state(index, value)
            if self._current_node.state[index] != value:
                with self._deactivated_option_listener():
                    self._device_list.set_option_state(index, self._current_node.state[index])

    @subject_slot('change_option')
    def _on_selection_changed_in_controller(self, value):
        self._current_node.selected_child = value
        self._update_hotswap_target()
        self._update_enter_button()
        self._update_exit_button()

    @subject_slot('press_option', in_front=True)
    def _on_selection_clicked_in_controller(self, index):
        if self._is_deleting:
            if self._current_node:
                self._current_node.delete_child(index)
            return True
        elif consts.PROTO_FAST_DEVICE_NAVIGATION:
            if self._device_list.selected_option == index:
                self._set_current_node(self._make_enter_node())
                return True
            elif not in_range(index, 0, len(self._device_list.option_names)):
                self._set_current_node(self._make_exit_node())
                return True
        return index == None

    @subject_slot('value')
    def _on_enter_value(self, value):
        if self.is_enabled():
            self._update_enter_button()
            if value:
                self._set_current_node(self._make_enter_node())
                self._update_hotswap_target()

    @subject_slot('value')
    def _on_exit_value(self, value):
        if self.is_enabled():
            self._update_exit_button()
            if value:
                self._set_current_node(self._make_exit_node())
                self._update_hotswap_target()

    def _update_hotswap_target(self):
        try:
            browser = self.application().browser
            if self.selected_object != None and browser.hotswap_target != None:
                browser.hotswap_target = self.selected_object
        except RuntimeError:
            pass

    def _make_enter_node(self):
        if self._device_list.selected_option >= 0:
            if self._device_list.selected_option < len(self._current_node.children):
                child = self._current_node.children[self._device_list.selected_option][1]
                return self._make_navigation_node(child, is_entering=True)

    def _make_exit_node(self):
        return self._make_navigation_node(self._current_node and self._current_node.parent, is_entering=False)

    def _update_enter_button(self):
        button = self._on_enter_value.subject
        if self.is_enabled() and button:
            with disconnectable(self._make_enter_node()) as node:
                if node:
                    button.set_light(button.is_pressed())
                else:
                    button.set_light('DefaultButton.Disabled')

    def _update_exit_button(self):
        button = self._on_exit_value.subject
        if self.is_enabled() and button:
            with disconnectable(self._make_exit_node()) as node:
                if node:
                    button.set_light(button.is_pressed())
                else:
                    button.set_light('DefaultButton.Disabled')
########NEW FILE########
__FILENAME__ = DeviceParameterComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/DeviceParameterComponent.py
from itertools import chain, repeat
import Live
AutomationState = Live.DeviceParameter.AutomationState
from _Framework.Util import first, second
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.SubjectSlot import subject_slot_group, subject_slot, Subject
import consts

def graphic_bar_for_parameter(parameter):
    if parameter.min == -1 * parameter.max:
        return consts.GRAPH_PAN
    elif parameter.is_quantized:
        return consts.GRAPH_SIN
    return consts.GRAPH_VOL


def convert_parameter_value_to_graphic(param, param_to_value = lambda p: p.value):
    if param != None:
        param_range = param.max - param.min
        param_bar = graphic_bar_for_parameter(param)
        graph_range = len(param_bar) - 1
        value = int((param_to_value(param) - param.min) / param_range * graph_range)
        graphic_display_string = param_bar[value]
    else:
        graphic_display_string = ' '
    return graphic_display_string


DISCRETE_PARAMETERS_DICT = {'GlueCompressor': ('Ratio', 'Attack', 'Release', 'Peak Clip In')}

def is_parameter_quantized(parameter, parent_device):
    is_quantized = False
    if parameter != None:
        device_class = getattr(parent_device, 'class_name', None)
        is_quantized = parameter.is_quantized or device_class in DISCRETE_PARAMETERS_DICT and parameter.name in DISCRETE_PARAMETERS_DICT[device_class]
    return is_quantized


def parameter_mapping_sensitivity(parameter):
    is_quantized = is_parameter_quantized(parameter, parameter and parameter.canonical_parent)
    return consts.QUANTIZED_MAPPING_SENSITIVITY if is_quantized else consts.CONTINUOUS_MAPPING_SENSITIVITY


class ParameterProvider(Subject):
    __subject_events__ = ('parameters',)

    @property
    def parameters(self):
        return []


class DeviceParameterComponent(ControlSurfaceComponent):
    """
    Maps the display and encoders to the parameters provided by a
    ParameterProvider.
    """

    def __init__(self, parameter_provider = None, *a, **k):
        super(DeviceParameterComponent, self).__init__(*a, **k)
        self._parameter_controls = []
        self._parameter_name_data_sources = map(DisplayDataSource, ('', '', '', '', '', '', '', ''))
        self._parameter_value_data_sources = map(DisplayDataSource, ('', '', '', '', '', '', '', ''))
        self._parameter_graphic_data_sources = map(DisplayDataSource, ('', '', '', '', '', '', '', ''))
        self.parameter_provider = parameter_provider

    @property
    def parameters(self):
        return map(second, self._parameter_provider.parameters)

    @property
    def parameter_names(self):
        return map(first, self._parameter_provider.parameters)

    def _get_parameter_provider(self):
        return self._parameter_provider

    def _set_parameter_provider(self, provider):
        self._parameter_provider = provider or ParameterProvider()
        self._on_parameters_changed.subject = self._parameter_provider
        self._update_parameters()

    parameter_provider = property(_get_parameter_provider, _set_parameter_provider)

    def set_parameter_controls(self, encoders):
        self._release_parameters()
        self._parameter_controls = encoders or []
        self._connect_parameters()

    def set_name_display_line(self, line):
        self._set_display_line(line, self._parameter_name_data_sources)

    def set_value_display_line(self, line):
        self._set_display_line(line, self._parameter_value_data_sources)

    def set_graphic_display_line(self, line):
        self._set_display_line(line, self._parameter_graphic_data_sources)

    def _set_display_line(self, line, sources):
        if line:
            line.set_num_segments(len(sources))
            for segment in xrange(len(sources)):
                line.segment(segment).set_data_source(sources[segment])

    def clear_display(self):
        for source in chain(self._parameter_name_data_sources, self._parameter_value_data_sources, self._parameter_graphic_data_sources):
            source.set_display_string('')

    def _release_parameters(self):
        for encoder in self._parameter_controls or []:
            encoder.release_parameter()

    def _connect_parameters(self):
        for parameter, encoder in zip(self.parameters, self._parameter_controls):
            if encoder:
                encoder.connect_to(parameter)
                encoder.mapping_sensitivity = parameter_mapping_sensitivity(parameter)

    def _update_parameters(self):
        if self.is_enabled():
            parameters = self.parameters
            self._on_parameter_value_changed.replace_subjects(parameters)
            self._on_parameter_automation_state_changed.replace_subjects(parameters)
            self._update_parameter_names()
            self._update_parameter_values()
            self._connect_parameters()

    @subject_slot('parameters')
    def _on_parameters_changed(self):
        self._update_parameters()

    @subject_slot_group('value')
    def _on_parameter_value_changed(self, parameter):
        self._update_parameter_values()

    @subject_slot_group('automation_state')
    def _on_parameter_automation_state_changed(self, parameter):
        self._update_parameter_names()
        self._update_parameter_values()

    def _update_parameter_names(self):
        if self.is_enabled():
            params = zip(chain(self.parameter_provider.parameters, repeat(('', None))), self._parameter_name_data_sources)
            for (name, parameter), name_data_source in params:
                if parameter and parameter.automation_state != AutomationState.none:
                    name = consts.CHAR_FULL_BLOCK + name
                name_data_source.set_display_string(name or '')

    def _update_parameter_values(self):
        if self.is_enabled():
            for parameter, data_source in map(None, self.parameters, self._parameter_value_data_sources):
                value_string = self.parameter_to_string(parameter)
                if parameter and parameter.automation_state == AutomationState.overridden:
                    value_string = '[%s]' % value_string
                if data_source:
                    data_source.set_display_string(value_string)

            for param, data_source in map(None, self.parameters, self._parameter_graphic_data_sources):
                graph = convert_parameter_value_to_graphic(param, self.parameter_to_value)
                if data_source:
                    data_source.set_display_string(graph)

    def parameter_to_string(self, parameter):
        return '' if parameter == None else unicode(parameter)

    def parameter_to_value(self, parameter):
        return parameter.value

    def update(self):
        if self.is_enabled():
            self._update_parameters()
########NEW FILE########
__FILENAME__ = DisplayingDeviceComponent
#Embedded file name: /Users/versonator/Hudson/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/DisplayingDeviceComponent.py
from itertools import chain
from _Framework.SubjectSlot import subject_slot, subject_slot_group
from _Framework.DeviceComponent import DeviceComponent
from _Framework.DisplayDataSource import DisplayDataSource
import consts
DISCRETE_PARAMETERS_DICT = {'GlueCompressor': ('Ratio', 'Attack', 'Release', 'Peak Clip In')}

def is_parameter_quantized(parameter, parent_device):
    is_quantized = False
    if parameter != None:
        device_class = parent_device.class_name
        is_quantized = parameter.is_quantized or device_class in DISCRETE_PARAMETERS_DICT and parameter.name in DISCRETE_PARAMETERS_DICT[device_class]
    return is_quantized


def graphic_bar_for_parameter(parameter):
    if parameter.min == -1 * parameter.max:
        return consts.GRAPH_PAN
    elif parameter.is_quantized:
        return consts.GRAPH_SIN
    return consts.GRAPH_VOL


def convert_parameter_value_to_graphic(param):
    if param != None:
        param_range = param.max - param.min
        param_bar = graphic_bar_for_parameter(param)
        graph_range = len(param_bar) - 1
        value = int((param.value - param.min) / param_range * graph_range)
        graphic_display_string = param_bar[value]
    else:
        graphic_display_string = ' '
    return graphic_display_string


class DisplayingDeviceComponent(DeviceComponent):
    """
    Special device class that displays parameter values
    """

    def __init__(self, *a, **k):
        super(DisplayingDeviceComponent, self).__init__(*a, **k)
        self._parameter_name_data_sources = [ DisplayDataSource(' ') for _ in xrange(8) ]
        self._parameter_value_data_sources = [ DisplayDataSource(' ') for _ in xrange(8) ]
        self._parameter_graphic_data_sources = [ DisplayDataSource(' ') for _ in xrange(8) ]
        self._blank_data_sources = [ DisplayDataSource(' ') for _ in xrange(8) ]
        self._mapped_parameters = []
        self._alternating_display = None
        self._encoder_touch_buttons = []

    def set_device(self, device):
        super(DisplayingDeviceComponent, self).set_device(device)
        if self._device == None:
            for source in chain(self._parameter_name_data_sources, self._parameter_value_data_sources, self._parameter_graphic_data_sources):
                source.set_display_string(' ')

    def set_encoder_touch_buttons(self, encoder_touch_buttons):
        if not encoder_touch_buttons:
            encoder_touch_buttons = []
            self._encoder_touch_buttons = self._encoder_touch_buttons != encoder_touch_buttons and encoder_touch_buttons
        self._on_encoder_touch_value.subject = encoder_touch_buttons or None
        self._try_set_alternate_display()

    def set_alternating_display(self, display):
        if not display:
            display = None
            self._alternating_display = self._alternating_display != display and display
        self._try_set_alternate_display()

    def set_name_display_line(self, line):
        self._set_display_line(line, self._parameter_name_data_sources)

    def set_value_display_line(self, line):
        self._set_display_line(line, self._parameter_value_data_sources)

    def set_graphic_display_line(self, line):
        self._set_display_line(line, self._parameter_graphic_data_sources)

    def _set_display_line(self, line, sources):
        if line:
            line.set_num_segments(len(sources))
            for segment in xrange(len(sources)):
                line.segment(segment).set_data_source(sources[segment])

    def parameter_value_data_source(self, index):
        return self._parameter_value_data_sources[index]

    def parameter_name_data_source(self, index):
        return self._parameter_name_data_sources[index]

    def _is_banking_enabled(self):
        return True

    def _assign_parameters(self):
        super(DisplayingDeviceComponent, self)._assign_parameters()
        self._update_mapping_sensitivity()
        _, self._mapped_parameters = self._current_bank_details()
        parameters = map(self._mapped_parameter, xrange(len(self._parameter_name_data_sources)))
        self._on_parameter_value_changed.replace_subjects(parameters)
        self._update_parameter_values()
        for parameter, name_data_source in zip(parameters, self._parameter_name_data_sources):
            param_name = parameter.name if parameter else ' '
            name_data_source.set_display_string(param_name)

    def _on_device_name_changed(self):
        if self._device_name_data_source != None:
            if self.is_enabled() and self._device != None:
                self._device_name_data_source.set_display_string(self._device.name)
            else:
                self._device_name_data_source.set_display_string('No Device')

    @subject_slot_group('value')
    def _on_parameter_value_changed(self, parameter):
        self._update_parameter_values()

    def _update_parameter_values(self):
        if self.is_enabled():
            for index, data_source in enumerate(self._parameter_value_data_sources):
                parameter = self._mapped_parameter(index)
                data_source.set_display_string(' ' if parameter == None else unicode(parameter))

            for index, data_source in enumerate(self._parameter_graphic_data_sources):
                param = self._mapped_parameter(index)
                graph = convert_parameter_value_to_graphic(param)
                data_source.set_display_string(graph)

    def _update_mapping_sensitivity(self):
        device = self.device()
        if device != None:
            for control in self._parameter_controls:
                if control != None:
                    parameter = control.mapped_parameter()
                    is_quantized = is_parameter_quantized(parameter, device)
                    control.mapping_sensitivity = consts.QUANTIZED_MAPPING_SENSITIVITY if is_quantized else consts.CONTINUOUS_MAPPING_SENSITIVITY

    def _mapped_parameter(self, index):
        return self._mapped_parameters[index] if index < len(self._mapped_parameters) else None

    @subject_slot('value')
    def _on_encoder_touch_value(self, value, x, y, is_momentary):
        self._try_set_alternate_display()

    def _try_set_alternate_display(self):
        if self._alternating_display != None:
            for button in self._encoder_touch_buttons:
                if button and button.is_pressed():
                    self.set_graphic_display_line(self._alternating_display)
                    return
            else:
                self._set_display_line(self._alternating_display, self._blank_data_sources)
########NEW FILE########
__FILENAME__ = DrumGroupComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/DrumGroupComponent.py
from itertools import imap, ifilter
from _Framework.SubjectSlot import subject_slot
from _Framework.Util import find_if, first
from consts import MessageBoxText
from MatrixMaps import PAD_FEEDBACK_CHANNEL
from MessageBoxComponent import Messenger
from SlideComponent import SlideComponent, Slideable

class DrumGroupComponent(SlideComponent, Slideable, Messenger):
    """
    Class representing a drum group pads in a matrix.
    """
    __subject_events__ = ('pressed_pads',)

    def __init__(self, *a, **k):
        super(DrumGroupComponent, self).__init__(dragging_enabled=True, *a, **k)
        self._select_button = None
        self._quantize_button = None
        self._delete_button = None
        self._mute_button = None
        self._solo_button = None
        self._drum_matrix = None
        self._drum_group_device = None
        self._visible_drum_pads = []
        self._all_drum_pads = []
        self._selected_drum_pad = None
        self._selected_pads = []
        self._visible_drum_pad_slots = self.register_slot_manager()
        self._takeover_drums = False

    position_count = 32
    page_length = 4
    page_offset = 1

    def contents_range(self, pmin, pmax):
        pos_count = self.position_count
        first_pos = max(int(pmin - 0.05), 0)
        last_pos = min(int(pmax + 0.2), pos_count)
        return xrange(first_pos, last_pos)

    def contents(self, index):
        drum = self._drum_group_device
        if drum:
            return any(imap(lambda pad: pad.chains, drum.drum_pads[index * 4:index * 4 + 4]))
        return False

    def _get_position(self):
        if self._drum_group_device:
            return self._drum_group_device.view.drum_pads_scroll_position
        return 0

    def _set_position(self, index):
        if not 0 <= index <= 28:
            raise AssertionError
            self._drum_group_device.view.drum_pads_scroll_position = self._drum_group_device and index

    position = property(_get_position, _set_position)

    @property
    def pressed_pads(self):
        return self._selected_pads

    def update(self):
        super(DrumGroupComponent, self).update()
        self._set_control_pads_from_script(False)
        self._update_drum_pad_leds()

    def set_drum_group_device(self, drum_group_device):
        if drum_group_device and not drum_group_device.can_have_drum_pads:
            drum_group_device = None
        if drum_group_device != self._drum_group_device:
            drum_group_view = drum_group_device.view if drum_group_device else None
            self._on_chains_changed.subject = drum_group_device
            self._on_visible_drum_pads_changed.subject = drum_group_device
            self._on_selected_drum_pad_changed.subject = drum_group_view
            self._on_drum_pads_scroll_position_changed.subject = drum_group_view
            self._drum_group_device = drum_group_device
            self._update_drum_pad_listeners()
            self._on_selected_drum_pad_changed()
            self.notify_contents()
            super(DrumGroupComponent, self).update()

    def set_drum_matrix(self, matrix):
        self._drum_matrix = matrix
        self._on_drum_matrix_value.subject = matrix
        if self._selected_pads:
            self._selected_pads = []
            self.notify_pressed_pads()
        if matrix:
            matrix.reset()
        self._update_control_from_script()
        self._update_drum_pad_leds()

    def set_select_button(self, button):
        self._select_button = button
        self._on_select_value.subject = button

    def set_mute_button(self, button):
        self._mute_button = button
        self._on_mute_value.subject = button

    def set_solo_button(self, button):
        self._solo_button = button
        self._on_solo_value.subject = button

    def set_quantize_button(self, button):
        self._quantize_button = button
        self._on_quantize_value.subject = button

    def set_delete_button(self, button):
        self._delete_button = button
        self._on_delete_value.subject = button

    @subject_slot('drum_pads_scroll_position')
    def _on_drum_pads_scroll_position_changed(self):
        self.notify_position()

    @subject_slot('chains')
    def _on_chains_changed(self):
        self._update_drum_pad_leds()
        self.notify_contents()

    @subject_slot('visible_drum_pads')
    def _on_visible_drum_pads_changed(self):
        self._update_drum_pad_listeners()
        self._update_drum_pad_leds()

    def _update_drum_pad_listeners(self):
        """
        add and remove listeners for visible drum pads, including
        mute and solo state
        """
        if self._drum_group_device:
            self._all_drum_pads = self._drum_group_device.drum_pads
            self._visible_drum_pads = self._drum_group_device.visible_drum_pads
            self._visible_drum_pad_slots.disconnect()
            for pad in self._visible_drum_pads:
                self._visible_drum_pad_slots.register_slot(pad, self._update_drum_pad_leds, 'mute')
                self._visible_drum_pad_slots.register_slot(pad, self._update_drum_pad_leds, 'solo')

    def _update_drum_pad_leds(self):
        """ update hardware LEDs for drum pads """
        if self.is_enabled() and self._drum_matrix and self._drum_group_device:
            soloed_pads = find_if(lambda pad: pad.solo, self._all_drum_pads)
            for button, (col, row) in ifilter(first, self._drum_matrix.iterbuttons()):
                index = (self._drum_matrix.height() - 1 - row) * self._drum_matrix.width() + col
                if self._visible_drum_pads:
                    pad = self._visible_drum_pads[index]
                    self._update_pad_led(pad, button, soloed_pads)
                else:
                    button.set_light('DrumGroup.PadInvisible')

    def _update_pad_led(self, pad, button, soloed_pads):
        button_color = 'DrumGroup.PadEmpty'
        if pad == self._selected_drum_pad:
            if soloed_pads and not pad.solo and not pad.mute:
                button_color = 'DrumGroup.PadSelectedNotSoloed'
            elif pad.mute and not pad.solo:
                button_color = 'DrumGroup.PadMutedSelected'
            elif soloed_pads and pad.solo:
                button_color = 'DrumGroup.PadSoloedSelected'
            else:
                button_color = 'DrumGroup.PadSelected'
        elif pad.chains:
            if soloed_pads and not pad.solo:
                if not pad.mute:
                    button_color = 'DrumGroup.PadFilled'
                else:
                    button_color = 'DrumGroup.PadMuted'
            elif not soloed_pads and pad.mute:
                button_color = 'DrumGroup.PadMuted'
            elif soloed_pads and pad.solo:
                button_color = 'DrumGroup.PadSoloed'
            else:
                button_color = 'DrumGroup.PadFilled'
        else:
            button_color = 'DrumGroup.PadEmpty'
        button.set_on_off_values('DrumGroup.PadAction', button_color)
        button.force_next_send()
        button.turn_off()

    @subject_slot('selected_drum_pad')
    def _on_selected_drum_pad_changed(self):
        self._selected_drum_pad = self._drum_group_device.view.selected_drum_pad if self._drum_group_device else None
        self._update_drum_pad_leds()

    @subject_slot('value')
    def _on_drum_matrix_value(self, value, x, y, is_momentary):
        if self.is_enabled() and self._visible_drum_pads != None:
            drum_index = (3 - y) * 4 + x
            if len(self._visible_drum_pads) > drum_index:
                selected_drum_pad = self._visible_drum_pads[drum_index]
                pad = self._drum_matrix.get_button(x, y)
                if value != 0 or not is_momentary:
                    self._on_press_pad(selected_drum_pad, pad)
                else:
                    self._on_release_pad(selected_drum_pad, pad)

    def _on_release_pad(self, selected_drum_pad, pad):
        self._indicate_action(False, pad)
        if selected_drum_pad in self._selected_pads:
            self._selected_pads.remove(selected_drum_pad)
            if not self._selected_pads:
                self._update_control_from_script()
            self.notify_pressed_pads()

    def _on_press_pad(self, selected_drum_pad, pad):
        if self._mute_button and self._mute_button.is_pressed():
            selected_drum_pad.mute = not selected_drum_pad.mute
        if self._solo_button and self._solo_button.is_pressed():
            selected_drum_pad.solo = not selected_drum_pad.solo
        if self._quantize_button and self._quantize_button.is_pressed():
            self._indicate_action(True, pad)
            self._do_quantize_pitch(selected_drum_pad.note)
        if self._delete_button and self._delete_button.is_pressed():
            self._indicate_action(True, pad)
            self._do_delete_pitch(selected_drum_pad)
        if self._select_button and self._select_button.is_pressed():
            self._drum_group_device.view.selected_drum_pad = selected_drum_pad
            self._do_select_drum_pad(selected_drum_pad)
            self._selected_pads.append(selected_drum_pad)
            if len(self._selected_pads) == 1:
                self._update_control_from_script()
            self.notify_pressed_pads()

    def _indicate_action(self, indicate, pad):
        if pad:
            pad.set_light(indicate)

    def _do_select_drum_pad(self, drum_pad):
        """ Override when you give it a select button """
        pass

    def _do_quantize_pitch(self, note):
        """ Override when you give it a quantize button """
        pass

    def _do_delete_pitch(self, drum_pad):
        clip = self.song().view.detail_clip
        if clip:
            loop_length = clip.loop_end - clip.loop_start
            clip.remove_notes(clip.loop_start, drum_pad.note, loop_length, 1)
            self.show_notification(MessageBoxText.DELETE_NOTES % drum_pad.name)

    @subject_slot('value')
    def _on_delete_value(self, value):
        self._set_control_pads_from_script(bool(value))

    @subject_slot('value')
    def _on_quantize_value(self, value):
        self._set_control_pads_from_script(bool(value))

    @subject_slot('value')
    def _on_select_value(self, value):
        self._set_control_pads_from_script(bool(value))

    @subject_slot('value')
    def _on_mute_value(self, value):
        self._set_control_pads_from_script(bool(value))

    @subject_slot('value')
    def _on_solo_value(self, value):
        self._set_control_pads_from_script(bool(value))

    def _set_control_pads_from_script(self, takeover_drums):
        """
        If takeover_drums, the matrix buttons will be controlled from
        the script. Otherwise they send midi notes to the track
        associated to this drum group.
        """
        if takeover_drums != self._takeover_drums:
            self._takeover_drums = takeover_drums
            self._update_control_from_script()

    def _update_control_from_script(self):
        takeover_drums = self._takeover_drums or self._selected_pads
        profile = 'default' if takeover_drums else 'drums'
        if self._drum_matrix:
            for button, _ in ifilter(first, self._drum_matrix.iterbuttons()):
                translation_channel = PAD_FEEDBACK_CHANNEL
                button.set_channel(translation_channel)
                button.set_enabled(takeover_drums)
                button.sensitivity_profile = profile
########NEW FILE########
__FILENAME__ = FirmwareHandling
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/FirmwareHandling.py
from __future__ import with_statement
from os import path
VERSION_PREFIX = '10F4000041444139204E69636F6C6C73'
NUM_VERSION_BYTES = 8
PRESET_FILE_NAME = 'Preset.syx'

def get_version_number_from_string(version_string):
    result = 0.0
    if version_string:
        figures = [ version_string[i:i + 2] for i in xrange(0, len(version_string), 2) ]
        result = sum([ int(fig) * 10 ** (1 - i) for i, fig in enumerate(figures) ])
    return result


def get_version_string_from_file_content(content):
    result = None
    if VERSION_PREFIX in content:
        number_start = content.find(VERSION_PREFIX) + len(VERSION_PREFIX)
        if len(content) >= number_start + NUM_VERSION_BYTES:
            result = content[number_start:number_start + NUM_VERSION_BYTES]
    return result


def get_provided_firmware_version():
    result = 0.0
    try:
        mod_path = path.dirname(path.realpath(__file__))
        with open(path.join(mod_path, PRESET_FILE_NAME), 'r') as f:
            version_string = get_version_string_from_file_content(f.read())
            result = get_version_number_from_string(version_string)
    except IOError:
        pass

    return result
########NEW FILE########
__FILENAME__ = GridResolution
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/GridResolution.py
import Live
GridQuantization = Live.Clip.GridQuantization
from _Framework.SubjectSlot import subject_slot, SlotManager, Subject
from _Framework.Util import product
QUANTIZATION_FACTOR = 24
QUANTIZATION_LIST = [2.0,
 3.0,
 4.0,
 6.0,
 8.0,
 12.0,
 16.0,
 24.0]
CLIP_VIEW_GRID_LIST = tuple(product([GridQuantization.g_thirtysecond,
 GridQuantization.g_sixteenth,
 GridQuantization.g_eighth,
 GridQuantization.g_quarter], [True, False]))
CLIP_LENGTH_LIST = [2.0,
 4.0,
 4.0,
 8.0,
 8.0,
 16.0,
 16.0,
 32.0]
DEFAULT_INDEX = 3

class GridResolution(SlotManager, Subject):
    __subject_events__ = ('index',)

    def __init__(self, *a, **k):
        super(GridResolution, self).__init__(*a, **k)
        self._index = DEFAULT_INDEX
        self._quantization_buttons = []
        self._quantization_button_slots = self.register_slot_manager()

    def _get_index(self):
        return self._index

    def _set_index(self, index):
        self._index = index
        self.notify_index()

    index = property(_get_index, _set_index)

    @property
    def step_length(self):
        return QUANTIZATION_LIST[self._index] / QUANTIZATION_FACTOR

    @property
    def clip_grid(self):
        return CLIP_VIEW_GRID_LIST[self._index]

    @property
    def clip_length(self):
        return CLIP_LENGTH_LIST[self._index]

    def set_buttons(self, buttons):
        self._quantization_button_slots.disconnect()
        self._quantization_buttons = buttons or []
        for button in self._quantization_buttons:
            if button:
                button.set_on_off_values('NoteEditor.QuantizationSelected', 'NoteEditor.QuantizationUnselected')
            self._quantization_button_slots.register_slot(button, self._on_quantization_button_value, 'value', dict(identify_sender=True))

        self._update_quantization_buttons()

    @subject_slot('value')
    def _on_quantization_button_value(self, value, sender):
        if value or not sender.is_momentary():
            self.index = list(self._quantization_buttons).index(sender)
            self._update_quantization_buttons()

    def _update_quantization_buttons(self):
        for index, button in enumerate(self._quantization_buttons):
            if button != None:
                if index is self.index:
                    button.turn_on()
                else:
                    button.turn_off()

    def update(self):
        self._update_quantization_buttons()
########NEW FILE########
__FILENAME__ = HandshakeComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/HandshakeComponent.py
"""
Component for handling the initialization process of Push.
"""
import Live
from _Framework import Task
from _Framework.SubjectSlot import subject_slot
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.Util import NamedTuple
from FirmwareHandling import get_version_number_from_string
from functools import partial
HANDSHAKE_TIMEOUT = 10.0
DONGLE_SIZE = 16

def to_bytes(dongle):
    return tuple([ dongle >> 4 * (7 - index) & 15 for index in xrange(8) ])


def to_integral(dongle):
    length = len(dongle)
    return sum([ long(dongle[index] & 15) << 4 * (length - 1 - index) for index in xrange(length) ])


def make_dongle_message(dongle_prefix, random_generator = Live.Application):
    dongle_one = random_generator.get_random_int(0, 2000000)
    dongle_two = random_generator.get_random_int(2000001, 4000000)
    return (dongle_prefix + (0, DONGLE_SIZE) + to_bytes(dongle_one) + to_bytes(dongle_two) + (247,), (dongle_one, dongle_two))


class HardwareIdentity(NamedTuple):
    """
    Stores the identity of the hardware.
    """
    firmware = None
    serial = None
    manufacturing = None


class HandshakeComponent(ControlSurfaceComponent):
    """
    Component for retrieving the hardware identity and checking that
    it is a Ableton certified device.
    """
    __subject_events__ = ('success', 'failure')
    encryptor = partial(Live.Application.encrypt_challenge, key_index=1)
    _handshake_succeeded = None
    _hardware_identity = None

    def __init__(self, identity_control = None, presentation_control = None, dongle_control = None, dongle = (0, 0), *a, **k):
        super(HandshakeComponent, self).__init__(*a, **k)
        self._identity_control = identity_control
        self._presentation_control = presentation_control
        self._dongle_control = dongle_control
        self._dongle_one, self._dongle_two = dongle
        self._on_identity_value.subject = identity_control
        self._on_dongle_value.subject = dongle_control
        self._identification_timeout_task = self._tasks.add(Task.sequence(Task.wait(HANDSHAKE_TIMEOUT), Task.run(self._do_fail)))
        self._identification_timeout_task.kill()

    @property
    def handshake_succeeded(self):
        """
        This will return None if the handshake process has not
        finished, otherwise True or False.
        """
        return self._handshake_succeeded

    @property
    def hardware_identity(self):
        return self._hardware_identity

    @property
    def firmware_version(self):
        version_bytes = self._hardware_identity.firmware if self._hardware_identity != None else 4 * (0,)
        return get_version_number_from_string(' %d %d %d %d' % version_bytes)

    def on_enabled_changed(self):
        super(HandshakeComponent, self).on_enabled_changed()
        if self._handshake_succeeded == None:
            self._do_fail()

    def update(self):
        pass

    def _start_handshake(self):
        self._handshake_succeeded = None
        self._identification_timeout_task.restart()
        self._identity_control.enquire_value()

    @subject_slot('value')
    def _on_identity_value(self, value):
        if len(value) == 25:
            if value[9:] == tuple(range(1, 17)):
                self._do_fail(bootloader_mode=True)
            else:
                self._hardware_identity = HardwareIdentity(firmware=value[:4], serial=value[4:8], manufacturing=value[8:25])
                self._presentation_control.enquire_value()
                self._dongle_control.enquire_value()
        else:
            self._do_fail()

    @subject_slot('value')
    def _on_dongle_value(self, value):
        success = False
        if len(value) >= 18:
            result = (to_integral(value[2:10]), to_integral(value[10:18]))
            expected = self.encryptor(self._dongle_one, self._dongle_two)
            success = tuple(expected) == tuple(result)
        if success:
            self._do_succeed()
        else:
            self._do_fail()

    def _do_succeed(self):
        if self._handshake_succeeded == None:
            self._handshake_succeeded = True
            self._identification_timeout_task.kill()
            self.notify_success()

    def _do_fail(self, bootloader_mode = False):
        if self._handshake_succeeded == None:
            self._handshake_succeeded = False
            self._identification_timeout_task.kill()
            self.notify_failure(bootloader_mode)
########NEW FILE########
__FILENAME__ = InstrumentComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/InstrumentComponent.py
from itertools import ifilter
from functools import partial
from _Framework.CompoundComponent import CompoundComponent
from _Framework.ModesComponent import DisplayingModesComponent, EnablingModesComponent
from _Framework.DisplayDataSource import DisplayDataSource, adjust_string_crop
from _Framework.Util import recursive_map, index_if, forward_property, first
from _Framework.SubjectSlot import subject_slot
from MessageBoxComponent import Messenger
from ScrollableList import ListComponent
from SlideComponent import SlideComponent, Slideable
from MelodicPattern import MelodicPattern, Modus, pitch_index_to_string
from MatrixMaps import NON_FEEDBACK_CHANNEL
import Sysex
import consts

class InstrumentPresetsComponent(DisplayingModesComponent):
    is_horizontal = True
    interval = 3
    __subject_events__ = ('scale_mode',)

    def __init__(self, *a, **k):
        super(InstrumentPresetsComponent, self).__init__(*a, **k)
        self._line_names = recursive_map(DisplayDataSource, (('Scale layout:',), ('4th ^', '4th >', '3rd ^', '3rd >', 'Sequent ^', 'Sequent >', '', '')))
        self.add_mode('scale_p4_vertical', partial(self._set_scale_mode, True, 3), self._line_names[1][0])
        self.add_mode('scale_p4_horizontal', partial(self._set_scale_mode, False, 3), self._line_names[1][1])
        self.add_mode('scale_m3_vertical', partial(self._set_scale_mode, True, 2), self._line_names[1][2])
        self.add_mode('scale_m3_horizontal', partial(self._set_scale_mode, False, 2), self._line_names[1][3])
        self.add_mode('scale_m6_vertical', partial(self._set_scale_mode, True, None), self._line_names[1][4])
        self.add_mode('scale_m6_horizontal', partial(self._set_scale_mode, False, None), self._line_names[1][5])

    def _update_data_sources(self, selected):
        if self.is_enabled():
            for name, (source, string) in self._mode_data_sources.iteritems():
                source.set_display_string(consts.CHAR_SELECT + string if name == selected else string)

    def _set_scale_mode(self, is_horizontal, interval):
        if self.is_horizontal != is_horizontal or self.interval != interval:
            self.is_horizontal = is_horizontal
            self.interval = interval
            self.notify_scale_mode()

    def set_top_display_line(self, display):
        if display:
            self._set_display_line(display, 0)

    def set_bottom_display_line(self, display):
        if display:
            self._set_display_line(display, 1)

    def _set_display_line(self, display, line):
        if display:
            display.set_data_sources(self._line_names[line])

    def set_top_buttons(self, buttons):
        if buttons:
            buttons.reset()
        self._set_scales_preset_buttons(buttons[:6] if buttons else None)

    def _set_scales_preset_buttons(self, buttons):
        modes = ('scale_p4_vertical', 'scale_p4_horizontal', 'scale_m3_vertical', 'scale_m3_horizontal', 'scale_m6_vertical', 'scale_m6_horizontal')
        self._set_mode_buttons(buttons, modes)

    def _set_mode_buttons(self, buttons, modes):
        if buttons:
            for button, mode in zip(buttons, modes):
                self.set_mode_button(mode, button)
                if button:
                    button.set_on_off_values('Scales.Selected', 'Scales.Unselected')

        else:
            for mode in modes:
                self.set_mode_button(mode, None)

        self.update()


CIRCLE_OF_FIFTHS = tuple([ 7 * k % 12 for k in range(12) ])
KEY_CENTERS = CIRCLE_OF_FIFTHS[0:6] + CIRCLE_OF_FIFTHS[-1:5:-1]

class InstrumentScalesComponent(CompoundComponent):
    __subject_events__ = ('scales_changed',)
    is_absolute = False
    is_diatonic = True
    key_center = 0

    def __init__(self, *a, **k):
        super(InstrumentScalesComponent, self).__init__(*a, **k)
        self._key_center_slots = self.register_slot_manager()
        self._key_center_buttons = []
        self._encoder_touch_button_slots = self.register_slot_manager()
        self._encoder_touch_buttons = []
        self._top_key_center_buttons = None
        self._bottom_key_center_buttons = None
        self._absolute_relative_button = None
        self._diatonic_chromatic_button = None
        table = consts.MUSICAL_MODES
        self._info_sources = map(DisplayDataSource, ('Scale selection:', '', ''))
        self._line_sources = recursive_map(DisplayDataSource, (('', '', '', '', '', '', ''), ('', '', '', '', '', '', '')))
        self._modus_sources = map(partial(DisplayDataSource, adjust_string_fn=adjust_string_crop), ('', '', '', ''))
        self._presets = self.register_component(InstrumentPresetsComponent())
        self._presets_enabler = self.register_component(EnablingModesComponent(component=self._presets, toggle_value='Scales.PresetsEnabled'))
        self._presets_enabler.momentary_toggle = True
        self._presets.selected_mode = 'scale_p4_vertical'
        self._modus_list = self.register_component(ListComponent(data_sources=self._modus_sources))
        self._modus_list.scrollable_list.fixed_offset = 1
        self._modus_list.scrollable_list.assign_items([ Modus(name=table[i], notes=table[i + 1]) for i in xrange(0, len(consts.MUSICAL_MODES), 2) ])
        self._on_selected_modus.subject = self._modus_list.scrollable_list
        self._update_data_sources()

    presets_layer = forward_property('_presets')('layer')

    @property
    def modus(self):
        return self._modus_list.scrollable_list.selected_item.content

    @property
    def available_scales(self):
        return self.modus.scales(KEY_CENTERS)

    @property
    def notes(self):
        return self.modus.scale(self.key_center).notes

    def set_modus_line1(self, display):
        self._set_modus_line(display, 0)

    def set_modus_line2(self, display):
        self._set_modus_line(display, 1)

    def set_modus_line3(self, display):
        self._set_modus_line(display, 2)

    def set_modus_line4(self, display):
        self._set_modus_line(display, 3)

    def _set_modus_line(self, display, index):
        if display:
            display.set_data_sources([self._modus_sources[index]])
            for segment in display.segments:
                segment.separator = ''

    def set_info_line(self, display):
        if display:
            display.set_data_sources(self._info_sources)

    def set_top_display_line(self, display):
        self._set_display_line(display, 0)

    def set_bottom_display_line(self, display):
        self._set_display_line(display, 1)

    def _set_display_line(self, display, line):
        if display:
            display.set_data_sources(self._line_sources[line])

    def set_presets_toggle_button(self, button):
        raise button is None or button.is_momentary() or AssertionError
        self._presets_enabler.set_toggle_button(button)

    def set_top_buttons(self, buttons):
        if buttons:
            buttons.reset()
            self.set_absolute_relative_button(buttons[7])
            self._top_key_center_buttons = buttons[1:7]
            self.set_modus_up_button(buttons[0])
        else:
            self.set_absolute_relative_button(None)
            self._top_key_center_buttons = None
            self.set_modus_up_button(None)
        if self._top_key_center_buttons and self._bottom_key_center_buttons:
            self.set_key_center_buttons(self._top_key_center_buttons + self._bottom_key_center_buttons)
        else:
            self.set_key_center_buttons(tuple())

    def set_bottom_buttons(self, buttons):
        if buttons:
            buttons.reset()
            self.set_diatonic_chromatic_button(buttons[7])
            self._bottom_key_center_buttons = buttons[1:7]
            self.set_modus_down_button(buttons[0])
        else:
            self.set_diatonic_chromatic_button(None)
            self._bottom_key_center_buttons = None
            self.set_modus_down_button(None)
        if self._top_key_center_buttons and self._bottom_key_center_buttons:
            self.set_key_center_buttons(self._top_key_center_buttons + self._bottom_key_center_buttons)
        else:
            self.set_key_center_buttons([])

    def set_modus_down_button(self, button):
        self._modus_list.set_select_next_button(button)

    def set_modus_up_button(self, button):
        self._modus_list.set_select_prev_button(button)

    def set_encoder_controls(self, encoders):
        self._modus_list.set_encoder_controls([encoders[0]] if encoders else [])

    def set_key_center_buttons(self, buttons):
        if not (not buttons or len(buttons) == 12):
            raise AssertionError
            buttons = buttons or []
            self._key_center_buttons = self._key_center_buttons != buttons and buttons
            self._key_center_slots.disconnect()
            for button in buttons:
                self._key_center_slots.register_slot(button, self._on_key_center_button_value, 'value', extra_kws=dict(identify_sender=True))

            self._update_key_center_buttons()

    def set_absolute_relative_button(self, absolute_relative_button):
        if absolute_relative_button != self._absolute_relative_button:
            self._absolute_relative_button = absolute_relative_button
            self._on_absolute_relative_value.subject = absolute_relative_button
            self._update_absolute_relative_button()

    def set_diatonic_chromatic_button(self, diatonic_chromatic_button):
        if diatonic_chromatic_button != self._diatonic_chromatic_button:
            self._diatonic_chromatic_button = diatonic_chromatic_button
            self._on_diatonic_chromatic_value.subject = diatonic_chromatic_button
            self._update_diatonic_chromatic_button()

    def _on_key_center_button_value(self, value, sender):
        if self.is_enabled() and (value or not sender.is_momentary()):
            index = list(self._key_center_buttons).index(sender)
            self.key_center = KEY_CENTERS[index]
            self._update_key_center_buttons()
            self._update_data_sources()
            self.notify_scales_changed()

    @subject_slot('value')
    def _on_absolute_relative_value(self, value):
        if self.is_enabled():
            if value != 0 or not self._absolute_relative_button.is_momentary():
                self.is_absolute = not self.is_absolute
                self._update_absolute_relative_button()
                self._update_data_sources()
                self.notify_scales_changed()

    @subject_slot('value')
    def _on_diatonic_chromatic_value(self, value):
        if self.is_enabled():
            if value != 0 or not self._diatonic_chromatic_button.is_momentary():
                self.is_diatonic = not self.is_diatonic
                self._update_diatonic_chromatic_button()
                self._update_data_sources()
                self.notify_scales_changed()

    @subject_slot('selected_item')
    def _on_selected_modus(self):
        self._update_data_sources()
        self.notify_scales_changed()

    def update(self):
        if self.is_enabled():
            self._update_key_center_buttons()
            self._update_absolute_relative_button()
            self._update_diatonic_chromatic_button()

    def _update_key_center_buttons(self):
        if self.is_enabled():
            for index, button in enumerate(self._key_center_buttons):
                if button:
                    button.set_on_off_values('Scales.Selected', 'Scales.Unselected')
                    button.set_light(self.key_center == KEY_CENTERS[index])

    def _update_absolute_relative_button(self):
        if self.is_enabled() and self._absolute_relative_button != None:
            self._absolute_relative_button.set_on_off_values('Scales.FixedOn', 'Scales.FixedOff')
            self._absolute_relative_button.set_light(self.is_absolute)

    def _update_diatonic_chromatic_button(self):
        if self.is_enabled() and self._diatonic_chromatic_button != None:
            self._diatonic_chromatic_button.set_on_off_values('Scales.Diatonic', 'Scales.Chromatic')
            self._diatonic_chromatic_button.set_light(self.is_diatonic)

    def _update_data_sources(self):
        key_index = list(KEY_CENTERS).index(self.key_center)
        key_sources = self._line_sources[0][:6] + self._line_sources[1][:6]
        key_names = [ scale.name for scale in self.available_scales ]
        for idx, (source, orig) in enumerate(zip(key_sources, key_names)):
            source.set_display_string('   ' + consts.CHAR_SELECT + orig if idx == key_index else '    ' + orig)

        self._line_sources[0][6].set_display_string('Fixed: Y' if self.is_absolute else 'Fixed: N')
        self._line_sources[1][6].set_display_string('In Key' if self.is_diatonic else 'Chromatc')
        self._info_sources[1].set_display_string(str(self._modus_list.scrollable_list.selected_item))


class InstrumentComponent(CompoundComponent, Slideable, Messenger):
    """
    Class that sets up the button matrix as a piano, using different
    selectable layouts for the notes.
    """
    midi_channels = range(5, 13)

    def __init__(self, *a, **k):
        super(InstrumentComponent, self).__init__(*a, **k)
        self._scales = self.register_component(InstrumentScalesComponent())
        self._scales_menu = self.register_component(EnablingModesComponent(component=self._scales, toggle_value='DefaultButton.On'))
        self._slider = self.register_component(SlideComponent(self))
        self._on_scales_changed.subject = self._scales
        self._on_scales_mode_changed.subject = self._scales._presets
        self._matrix = None
        self._delete_button = None
        self._first_note = self.page_length * 3 + self.page_offset
        self._last_page_length = self.page_length
        self._delete_button = None
        self._last_page_offset = self.page_offset
        self._detail_clip = None
        self._has_notes = [False] * 128
        self._has_notes_pattern = self._get_pattern(0)
        self._takeover_pads = False
        self._aftertouch_control = None
        self._update_pattern()

    def set_detail_clip(self, clip):
        if clip != self._detail_clip:
            self._detail_clip = clip
            self._on_clip_notes_changed.subject = clip
            self._on_loop_start_changed.subject = clip
            self._on_loop_end_changed.subject = clip
            self._on_clip_notes_changed()

    @subject_slot('notes')
    def _on_clip_notes_changed(self):
        if self._detail_clip:
            self._has_notes = [False] * 128
            loop_start = self._detail_clip.loop_start
            loop_length = self._detail_clip.loop_end - loop_start
            notes = self._detail_clip.get_notes(loop_start, 0, loop_length, 128)
            for note in notes:
                self._has_notes[note[0]] = True

        self.notify_contents()

    @subject_slot('loop_start')
    def _on_loop_start_changed(self):
        self._on_loop_selection_changed()

    @subject_slot('loop_end')
    def _on_loop_end_changed(self):
        self._on_loop_selection_changed()

    def _on_loop_selection_changed(self):
        self._on_clip_notes_changed()

    def contents(self, index):
        if self._detail_clip:
            note = self._has_notes_pattern[index].index
            return self._has_notes[note] if note is not None else False
        return False

    @property
    def page_length(self):
        return len(self._scales.notes) if self._scales.is_diatonic else 12

    @property
    def position_count(self):
        if not self._scales.is_diatonic:
            return 139
        else:
            offset = self.page_offset
            octaves = 11 if self._scales.notes[0] < 8 else 10
            return offset + len(self._scales.notes) * octaves

    def _first_scale_note_offset(self):
        if not self._scales.is_diatonic:
            return self._scales.notes[0]
        elif self._scales.notes[0] == 0:
            return 0
        else:
            return len(self._scales.notes) - index_if(lambda n: n >= 12, self._scales.notes)

    @property
    def page_offset(self):
        return 0 if self._scales.is_absolute else self._first_scale_note_offset()

    def _get_position(self):
        return self._first_note

    def _set_position(self, note):
        self._first_note = note
        self._update_pattern()
        self._update_matrix()
        self.notify_position()

    position = property(_get_position, _set_position)

    @property
    def scales(self):
        return self._scales

    @property
    def scales_menu(self):
        return self._scales_menu

    @property
    def pattern(self):
        return self._pattern

    @subject_slot('value')
    def _on_matrix_value(self, value, x, y, is_momentary):
        if self._delete_button and self._delete_button.is_pressed():
            if value:
                max_y = self._matrix.width() - 1
                pitch = self._get_pattern().note(x, max_y - y).index
                if pitch and self._detail_clip:
                    self._matrix.get_button(x, y).turn_on()
                    self._do_delete_pitch(pitch)
            else:
                self._matrix.get_button(x, y).turn_off()

    def _do_delete_pitch(self, pitch):
        clip = self._detail_clip
        if clip:
            note_name = pitch_index_to_string(pitch)
            loop_length = clip.loop_end - clip.loop_start
            clip.remove_notes(clip.loop_start, pitch, loop_length, 1)
            self.show_notification(consts.MessageBoxText.DELETE_NOTES % note_name)

    @subject_slot('value')
    def _on_delete_value(self, value):
        self._set_control_pads_from_script(bool(value))

    def set_matrix(self, matrix):
        self._matrix = matrix
        self._on_matrix_value.subject = matrix
        if matrix:
            matrix.reset()
        self._update_matrix()

    def set_touch_strip(self, control):
        if control:
            control.reset()

    def set_note_strip(self, strip):
        self._slider.set_scroll_strip(strip)

    def set_octave_strip(self, strip):
        self._slider.set_page_strip(strip)

    def set_scales_toggle_button(self, button):
        raise button is None or button.is_momentary() or AssertionError
        self._scales_menu.set_toggle_button(button)

    def set_presets_toggle_button(self, button):
        self._scales.set_presets_toggle_button(button)

    def set_octave_up_button(self, button):
        self._slider.set_scroll_page_up_button(button)

    def set_octave_down_button(self, button):
        self._slider.set_scroll_page_down_button(button)

    def set_scale_up_button(self, button):
        self._slider.set_scroll_up_button(button)

    def set_scale_down_button(self, button):
        self._slider.set_scroll_down_button(button)

    def set_aftertouch_control(self, control):
        self._aftertouch_control = control
        self._update_aftertouch()

    def set_delete_button(self, button):
        self._delete_button = button
        self._on_delete_value.subject = button
        self._set_control_pads_from_script(button and button.is_pressed())

    def _align_first_note(self):
        self._first_note = self.page_offset + (self._first_note - self._last_page_offset) * float(self.page_length) / float(self._last_page_length)
        if self._first_note >= self.position_count:
            self._first_note -= self.page_length
        self._last_page_length = self.page_length
        self._last_page_offset = self.page_offset

    @subject_slot('scales_changed')
    def _on_scales_changed(self):
        self._update_scale()

    @subject_slot('scale_mode')
    def _on_scales_mode_changed(self):
        self._update_scale()

    def _update_scale(self):
        self._align_first_note()
        self._update_pattern()
        self._update_matrix()
        self.notify_position_count()
        self.notify_position()
        self.notify_contents()

    def update(self):
        if self.is_enabled():
            self._update_matrix()
            self._update_aftertouch()

    def _update_pattern(self):
        self._pattern = self._get_pattern()
        self._has_notes_pattern = self._get_pattern(0)

    def _update_matrix(self):
        self._setup_instrument_mode()

    def _setup_instrument_mode(self):
        if self.is_enabled() and self._matrix:
            self._matrix.reset()
            pattern = self._pattern
            max_j = self._matrix.width() - 1
            for button, (i, j) in ifilter(first, self._matrix.iterbuttons()):
                profile = 'default' if self._takeover_pads else 'instrument'
                button.sensitivity_profile = profile
                note_info = pattern.note(i, max_j - j)
                if note_info.index != None:
                    button.set_on_off_values('Instrument.NoteAction', 'Instrument.' + note_info.color)
                    button.turn_off()
                    button.set_enabled(self._takeover_pads)
                    button.set_channel(note_info.channel)
                    button.set_identifier(note_info.index)
                else:
                    button.set_channel(NON_FEEDBACK_CHANNEL)
                    button.set_light('Instrument.' + note_info.color)
                    button.set_enabled(True)

    def _get_pattern(self, first_note = None):
        if first_note is None:
            first_note = int(round(self._first_note))
        interval = self._scales._presets.interval
        notes = self._scales.notes
        octave = first_note / self.page_length
        offset = first_note % self.page_length - self._first_scale_note_offset()
        if interval == None:
            interval = 8
        elif not self._scales.is_diatonic:
            interval = [0,
             2,
             4,
             5,
             7,
             9,
             10,
             11][interval]
        if self._scales._presets.is_horizontal:
            steps = [1, interval]
            origin = [offset, 0]
        else:
            steps = [interval, 1]
            origin = [0, offset]
        return MelodicPattern(steps=steps, scale=notes, origin=origin, base_note=octave * 12, chromatic_mode=not self._scales.is_diatonic)

    def _update_aftertouch(self):
        if self.is_enabled() and self._aftertouch_control != None:
            self._aftertouch_control.send_value(Sysex.MONO_AFTERTOUCH)

    def _set_control_pads_from_script(self, takeover_pads):
        """
        If takeover_pads is True, the matrix buttons will be controlled from
        the script. Otherwise they send midi notes to the track.
        """
        if takeover_pads != self._takeover_pads:
            self._takeover_pads = takeover_pads
            self._update_matrix()
########NEW FILE########
__FILENAME__ = LoopSelectorComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/LoopSelectorComponent.py
from __future__ import with_statement
from _Framework.SubjectSlot import subject_slot, Subject
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.Util import contextmanager, clamp
from itertools import izip

def create_clip_in_selected_slot(creator, song, clip_length = None):
    """
    Create a new clip in the selected slot of if none exists, using a
    given creator object.  Fires it if the song is playing and
    displays it in the detail view.
    """
    selected_slot = song.view.highlighted_clip_slot
    if creator and selected_slot and not selected_slot.has_clip:
        creator.create(selected_slot, clip_length)
        song.view.detail_clip = selected_slot.clip
    return selected_slot.clip


def clip_is_new_recording(clip):
    return clip.is_recording and not clip.is_overdubbing


class Paginator(Subject):
    """
    Paginator interface for objects that split continuous time into
    discrete pages.  This can be used as trivial paginator splits time
    into one single infinite-length page.
    """
    __subject_events__ = ('page', 'page_index', 'page_length')

    @property
    def can_change_page(self):
        return True

    @property
    def page_length(self):
        """
        Length of a given page.
        """
        return 2147483648.0

    @property
    def page_index(self):
        """
        Index of the currently selected page.
        """
        return 0

    def select_page_in_point(self, value):
        """
        Select the page that falls in the given time point. Returns True if page was
        selected.
        """
        return True


class LoopSelectorComponent(ControlSurfaceComponent):
    """
    Component that uses a button matrix to display the timeline of a
    clip. It allows you to select the loop of the clip and a page
    within it of a given Paginator object.
    """
    __subject_events__ = ('is_following',)

    def __init__(self, clip_creator = None, measure_length = 4.0, follow_detail_clip = False, paginator = None, *a, **k):
        super(LoopSelectorComponent, self).__init__(*a, **k)
        self._clip_creator = clip_creator
        self._sequencer_clip = None
        self._paginator = Paginator()
        self._loop_start = 0
        self._loop_end = 0
        self._loop_length = 0
        self._is_following = False
        self._follow_button = None
        self._select_button = None
        self._short_loop_selector_matrix = None
        self._loop_selector_matrix = None
        self._pressed_pages = []
        self._page_colors = []
        self._measure_length = measure_length
        self._last_playhead_page = -1
        if follow_detail_clip:
            self._on_detail_clip_changed.subject = self.song().view
        self._on_session_record_changed.subject = self.song()
        self._on_song_playback_status_changed.subject = self.song()
        if paginator is not None:
            self.set_paginator(paginator)

    def _get_is_following(self):
        return self._can_follow and self._is_following

    def _set_is_following(self, value):
        self._is_following = value
        self.notify_is_following(value)

    is_following = property(_get_is_following, _set_is_following)

    def set_paginator(self, paginator):
        self._paginator = paginator or Paginator()
        self._on_page_index_changed.subject = paginator
        self._on_page_length_changed.subject = paginator
        self._update_page_colors()

    @subject_slot('page_index')
    def _on_page_index_changed(self):
        self._update_page_colors()

    @subject_slot('page_length')
    def _on_page_length_changed(self):
        self._update_page_colors()
        self._update_follow_button()

    def set_follow_button(self, button):
        self._follow_button = button
        self._on_follow_value.subject = button
        self._update_follow_button()

    def set_select_button(self, button):
        self._select_button = button

    @subject_slot('detail_clip')
    def _on_detail_clip_changed(self):
        self.set_detail_clip(self.song().view.detail_clip)

    def set_detail_clip(self, clip):
        if clip != self._sequencer_clip:
            if clip != None:
                self._is_following = self._is_following or clip_is_new_recording(clip)
                self._on_playing_position_changed.subject = clip
                self._on_playing_status_changed.subject = clip
                self._on_loop_start_changed.subject = clip
                self._on_loop_end_changed.subject = clip
                self._on_is_recording_changed.subject = clip
                self._sequencer_clip = clip
                page_start = self._paginator.page_index * self._paginator.page_length
                clip and (page_start < clip.loop_start or page_start > clip.loop_end) and self._paginator.select_page_in_point(clip.loop_start)
            elif not clip:
                self._paginator.select_page_in_point(0)
            self._on_loop_changed()

    def _update_follow_button(self):
        if self.is_enabled() and self._follow_button:
            self._follow_button.set_light(self.is_following)

    @subject_slot('loop_start')
    def _on_loop_start_changed(self):
        self._on_loop_changed()

    @subject_slot('loop_end')
    def _on_loop_end_changed(self):
        self._on_loop_changed()

    def _on_loop_changed(self):
        if self._sequencer_clip:
            self._loop_start = self._sequencer_clip.loop_start
            self._loop_end = self._sequencer_clip.loop_end
            self._loop_length = self._loop_end - self._loop_start
        else:
            self._loop_start = 0
            self._loop_end = 0
            self._loop_length = 0
        self._update_page_colors()

    def set_loop_selector_matrix(self, matrix):
        self._loop_selector_matrix = matrix
        self._on_loop_selector_matrix_value.subject = matrix
        if matrix:
            matrix.reset()
        self._update_page_colors()

    def set_short_loop_selector_matrix(self, matrix):
        self._short_loop_selector_matrix = matrix
        self._on_short_loop_selector_matrix_value.subject = matrix
        if matrix:
            matrix.reset()
        self._update_page_colors()

    def update(self):
        self._update_page_and_playhead_leds()
        self._update_follow_button()

    @subject_slot('is_recording')
    def _on_is_recording_changed(self):
        self.is_following = self._is_following or clip_is_new_recording(self._sequencer_clip)

    @subject_slot('playing_position')
    def _on_playing_position_changed(self):
        self._update_page_and_playhead_leds()
        self._update_page_selection()

    @subject_slot('playing_status')
    def _on_playing_status_changed(self):
        self._update_page_and_playhead_leds()

    @subject_slot('session_record')
    def _on_session_record_changed(self):
        self._update_page_and_playhead_leds()

    @subject_slot('is_playing')
    def _on_song_playback_status_changed(self):
        self._update_page_and_playhead_leds()

    def _has_running_clip(self):
        return self._sequencer_clip != None and (self._sequencer_clip.is_playing or self._sequencer_clip.is_recording)

    def _update_page_selection(self):
        if self.is_enabled() and self.is_following and self._has_running_clip():
            position = self._sequencer_clip.playing_position
            self._paginator.select_page_in_point(position)

    def _update_page_and_playhead_leds(self):

        @contextmanager
        def save_page_color(page_colors, page):
            old_page_value = page_colors[page]
            yield
            page_colors[page] = old_page_value

        @contextmanager
        def replace_and_restore_tail_colors(page_colors, page):
            if clip_is_new_recording(self._sequencer_clip):
                old_tail_values = page_colors[page + 1:]
                page_colors[page + 1:] = ['LoopSelector.OutsideLoop'] * len(old_tail_values)
            yield
            if clip_is_new_recording(self._sequencer_clip):
                page_colors[page + 1:] = old_tail_values

        if self.is_enabled() and self._has_running_clip():
            position = self._sequencer_clip.playing_position
            visible_page = int(position / self._page_length_in_beats) - self.page_offset
            page_colors = self._page_colors
            if 0 <= visible_page < len(page_colors):
                with save_page_color(page_colors, visible_page):
                    if self.song().is_playing:
                        page_colors[visible_page] = 'LoopSelector.PlayheadRecord' if self.song().session_record else 'LoopSelector.Playhead'
                    with replace_and_restore_tail_colors(page_colors, visible_page):
                        self._update_page_leds()
            else:
                self._update_page_leds()
            self._last_playhead_page = visible_page
        else:
            self._update_page_leds()

    def _get_size(self):
        return max(len(self._loop_selector_matrix or []), len(self._short_loop_selector_matrix or []), 1)

    def _get_loop_in_pages(self):
        page_length = self._page_length_in_beats
        loop_start = int(self._loop_start / page_length)
        loop_end = int(self._loop_end / page_length)
        loop_length = loop_end - loop_start + int(self._loop_end % page_length != 0)
        return (loop_start, loop_length)

    def _selected_pages_range(self):
        size = self._get_size()
        page_length = self._page_length_in_beats
        seq_page_length = max(self._paginator.page_length / page_length, 1)
        seq_page_start = int(self._paginator.page_index * self._paginator.page_length / page_length)
        seq_page_end = int(min(seq_page_start + seq_page_length, self.page_offset + size))
        return (seq_page_start, seq_page_end)

    def _update_page_colors(self):
        """
        Update the offline array mapping the timeline of the clip to buttons.
        """
        page_length = self._page_length_in_beats
        size = self._get_size()

        def calculate_page_colors():
            l_start, l_length = self._get_loop_in_pages()
            page_offset = self.page_offset
            pages_per_measure = int(self._one_measure_in_beats / page_length)

            def color_for_page(absolute_page):
                if l_start <= absolute_page < l_start + l_length:
                    return 'LoopSelector.InsideLoopStartBar' if absolute_page % pages_per_measure == 0 else 'LoopSelector.InsideLoop'
                else:
                    return 'LoopSelector.OutsideLoop'

            return map(color_for_page, xrange(page_offset, page_offset + size))

        def mark_selected_pages(page_colors):
            for page_index in xrange(*self._selected_pages_range()):
                button_index = page_index - self.page_offset
                if page_colors[button_index].startswith('LoopSelector.InsideLoop'):
                    page_colors[button_index] = 'LoopSelector.SelectedPage'

        page_colors = calculate_page_colors()
        mark_selected_pages(page_colors)
        self._page_colors = page_colors
        self._update_page_and_playhead_leds()

    def _update_page_leds(self):
        self._update_page_leds_in_matrix(self._loop_selector_matrix)
        self._update_page_leds_in_matrix(self._short_loop_selector_matrix)

    def _update_page_leds_in_matrix(self, matrix):
        """ update hardware leds to match precomputed map """
        if self.is_enabled() and matrix:
            for button, color in izip(matrix, self._page_colors):
                if button:
                    button.set_light(color)

    @subject_slot('value')
    def _on_short_loop_selector_matrix_value(self, value, x, y, is_momentary):
        page = x + y * self._short_loop_selector_matrix.width()
        if self.is_enabled():
            if value or not is_momentary:
                self._pressed_pages = [page]
                self._try_set_loop()
                self._pressed_pages = []

    @subject_slot('value')
    def _on_loop_selector_matrix_value(self, value, x, y, is_momentary):
        page = x + y * self._loop_selector_matrix.width()
        if self.is_enabled():
            if value or not is_momentary:
                if page not in self._pressed_pages:
                    self._on_press_loop_selector_matrix(page)
        if (not is_momentary or not value) and page in self._pressed_pages:
            self._pressed_pages.remove(page)

    def _quantize_page_index(self, page_index, quant):
        page_length = self._page_length_in_beats
        return quant * float(int(page_length * page_index / quant))

    def _on_press_loop_selector_matrix(self, page):

        def create_clip(pages):
            measure = self._one_measure_in_beats
            length = self._quantize_page_index(pages, measure) + measure
            create_clip_in_selected_slot(self._clip_creator, self.song(), length)

        def handle_page_press_on_clip(page):
            l_start, l_length = self._get_loop_in_pages()
            page_in_loop = l_start <= page < l_start + l_length
            buttons_pressed = len(self._pressed_pages)
            if buttons_pressed == 1 and page_in_loop:
                self._try_select_page(page)
            elif buttons_pressed > 1 or not page_in_loop:
                self._try_set_loop()

        self._pressed_pages.append(page)
        absolute_page = page + self.page_offset
        if not self._select_button or not self._select_button.is_pressed():
            if self._sequencer_clip == None and not self.song().view.highlighted_clip_slot.has_clip:
                create_clip(absolute_page)
            elif self._sequencer_clip != None:
                handle_page_press_on_clip(absolute_page)
        elif not self.is_following:
            self._try_select_page(absolute_page)

    def _try_select_page(self, page):
        step_time = page * self._page_length_in_beats
        if self._paginator.select_page_in_point(step_time):
            self.is_following = False
            return True
        return False

    def _try_set_loop(self):
        did_set_loop = False
        if self._sequencer_clip:
            if not clip_is_new_recording(self._sequencer_clip):
                lowest_page = min(self._pressed_pages) + self.page_offset
                if self._try_select_page(lowest_page) == True:
                    self._set_loop_in_live()
                    did_set_loop = True
            if did_set_loop:
                self.is_following = True
        return did_set_loop

    def _set_loop_in_live(self):
        quant = self._page_length_in_beats
        start_page = min(self._pressed_pages) + self.page_offset
        end_page = max(self._pressed_pages) + self.page_offset
        loop_start = self._quantize_page_index(start_page, quant)
        loop_end = self._quantize_page_index(end_page, quant) + quant
        if loop_start >= self._sequencer_clip.loop_end:
            self._sequencer_clip.loop_end = loop_end
            self._sequencer_clip.loop_start = loop_start
            self._sequencer_clip.end_marker = loop_end
            self._sequencer_clip.start_marker = loop_start
        else:
            self._sequencer_clip.loop_start = loop_start
            self._sequencer_clip.loop_end = loop_end
            self._sequencer_clip.start_marker = loop_start
            self._sequencer_clip.end_marker = loop_end
        self._sequencer_clip.view.show_loop()

    @property
    def _can_follow(self):
        return True

    @property
    def _page_length_in_beats(self):
        return clamp(self._paginator.page_length, 0.5, self._one_measure_in_beats)

    @property
    def _one_measure_in_beats(self):
        return self._measure_length * self.song().signature_numerator / self.song().signature_denominator

    @property
    def page_offset(self):
        size = max(self._loop_selector_matrix.width() * self._loop_selector_matrix.height() if self._loop_selector_matrix else 0, 1)
        page_index = self._paginator.page_index
        page_length = self._paginator.page_length
        selected_page_index = int(page_index * page_length / self._page_length_in_beats)
        return size * int(selected_page_index / size)

    @subject_slot('value')
    def _on_follow_value(self, value):
        if self.is_enabled() and value:
            if self._can_follow:
                self.is_following = not self.is_following
                self._update_follow_button()
########NEW FILE########
__FILENAME__ = M4LInterfaceComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/M4LInterfaceComponent.py
from __future__ import with_statement
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
import consts

class M4LInterfaceComponent(ControlSurfaceComponent):
    """
    Simplified API for interaction from M4L as a high priority layer
    superposed on top of any L9C functionality.
    """

    def __init__(self, controls = None, component_guard = None, *a, **k):
        super(M4LInterfaceComponent, self).__init__(self, *a, **k)
        self._controls = dict(map(lambda x: (x.name, x), controls))
        self._grabbed_controls = []
        self._component_guard = component_guard

    def disconnect(self):
        for control in self._grabbed_controls[:]:
            self.release_control(control)

        super(M4LInterfaceComponent, self).disconnect()

    def set_control_element(self, control, grabbed):
        if hasattr(control, 'release_parameter'):
            control.release_parameter()
        control.reset()

    def get_control_names(self):
        return self._controls.keys()

    def get_control(self, control_name):
        return self._controls[control_name] if control_name in self._controls else None

    def grab_control(self, control):
        raise control in self._controls.values() or AssertionError
        with self._component_guard():
            if control not in self._grabbed_controls:
                control.resource.grab(self, priority=consts.M4L_PRIORITY)
                self._grabbed_controls.append(control)

    def release_control(self, control):
        raise control in self._controls.values() or AssertionError
        with self._component_guard():
            if control in self._grabbed_controls:
                self._grabbed_controls.remove(control)
                control.resource.release(self)

    def update(self):
        pass
########NEW FILE########
__FILENAME__ = MatrixMaps
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/MatrixMaps.py
"""
Pad Translations for Drum Rack (pad_x, pad_y, note, channel)
"""
PAD_TRANSLATIONS = ((0, 0, 60, 14),
 (1, 0, 61, 14),
 (2, 0, 62, 14),
 (3, 0, 63, 14),
 (0, 1, 52, 14),
 (1, 1, 53, 14),
 (2, 1, 54, 14),
 (3, 1, 55, 14),
 (0, 2, 44, 14),
 (1, 2, 45, 14),
 (2, 2, 46, 14),
 (3, 2, 47, 14),
 (0, 3, 36, 14),
 (1, 3, 37, 14),
 (2, 3, 38, 14),
 (3, 3, 39, 14))
FEEDBACK_CHANNELS = range(5, 15)
PAD_FEEDBACK_CHANNEL = FEEDBACK_CHANNELS[-1]
NON_FEEDBACK_CHANNEL = 15
########NEW FILE########
__FILENAME__ = MelodicComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/MelodicComponent.py
from __future__ import with_statement
from _Framework.Util import forward_property, find_if
from _Framework.SubjectSlot import subject_slot
from _Framework.ModesComponent import ModesComponent, LayerMode
from MessageBoxComponent import Messenger
from MatrixMaps import FEEDBACK_CHANNELS, NON_FEEDBACK_CHANNEL
from InstrumentComponent import InstrumentComponent
from NoteEditorComponent import NoteEditorComponent
from PlayheadComponent import PlayheadComponent
from MelodicPattern import pitch_index_to_string
from LoopSelectorComponent import LoopSelectorComponent
from NoteEditorPaginator import NoteEditorPaginator
NUM_NOTE_EDITORS = 7

class MelodicComponent(ModesComponent, Messenger):

    def __init__(self, clip_creator = None, parameter_provider = None, grid_resolution = None, note_editor_settings = None, skin = None, instrument_play_layer = None, instrument_sequence_layer = None, layer = None, *a, **k):
        super(MelodicComponent, self).__init__(*a, **k)
        self._matrices = None
        self._grid_resolution = grid_resolution
        self._instrument = self.register_component(InstrumentComponent())
        self._note_editors = self.register_components(*[ NoteEditorComponent(settings_mode=note_editor_settings, clip_creator=clip_creator, grid_resolution=self._grid_resolution, is_enabled=False) for _ in xrange(NUM_NOTE_EDITORS) ])
        self._paginator = NoteEditorPaginator(self._note_editors)
        self._loop_selector = self.register_component(LoopSelectorComponent(clip_creator=clip_creator, paginator=self._paginator, is_enabled=False))
        self._playhead = None
        self._playhead_component = self.register_component(PlayheadComponent(grid_resolution=grid_resolution, paginator=self._paginator, follower=self._loop_selector, is_enabled=False))
        self.add_mode('play', LayerMode(self._instrument, instrument_play_layer))
        self.add_mode('sequence', [LayerMode(self._instrument, instrument_sequence_layer),
         self._loop_selector,
         note_editor_settings,
         LayerMode(self, layer),
         self._playhead_component] + self._note_editors)
        self.selected_mode = 'play'
        scales = self._instrument.scales
        self._on_detail_clip_changed.subject = self.song().view
        self._on_scales_changed.subject = scales
        self._on_scales_preset_changed.subject = scales._presets
        self._on_notes_changed.subject = self._instrument
        self._on_selected_mode_changed.subject = self
        self._on_detail_clip_changed()
        self._update_note_editors()
        self._skin = skin
        self._playhead_color = 'Melodic.Playhead'
        self._update_playhead_color()

    scales_menu = forward_property('_instrument')('scales_menu')
    scales = forward_property('_instrument')('scales')

    def set_playhead(self, playhead):
        self._playhead = playhead
        self._playhead_component.set_playhead(playhead)
        self._update_playhead_color()

    @forward_property('_loop_selector')
    def set_loop_selector_matrix(self, matrix):
        pass

    @forward_property('_loop_selector')
    def set_short_loop_selector_matrix(self, matrix):
        pass

    def set_note_editor_matrices(self, matrices):
        raise not matrices or len(matrices) <= NUM_NOTE_EDITORS or AssertionError
        self._matrices = matrices
        for editor, matrix in map(None, self._note_editors, matrices or []):
            if editor:
                editor.set_button_matrix(matrix)

        self._update_matrix_channels_for_playhead()

    def _get_playhead_color(self):
        self._playhead_color

    def _set_playhead_color(self, value):
        self._playhead_color = 'Melodic.' + value
        self._update_playhead_color()

    playhead_color = property(_get_playhead_color, _set_playhead_color)

    @subject_slot('detail_clip')
    def _on_detail_clip_changed(self):
        if self.is_enabled():
            clip = self.song().view.detail_clip
            clip = clip if self.is_enabled() and clip and clip.is_midi_clip else None
            for note_editor in self._note_editors:
                note_editor.set_detail_clip(clip)

            self._loop_selector.set_detail_clip(clip)
            self._playhead_component.set_clip(clip)
            self._instrument.set_detail_clip(clip)

    def _set_full_velocity(self, enable):
        for note_editor in self._note_editors:
            note_editor.full_velocity = enable

    def _get_full_velocity(self):
        self._note_editors[0].full_velocity

    full_velocity = property(_get_full_velocity, _set_full_velocity)

    def set_quantization_buttons(self, buttons):
        self._grid_resolution.set_buttons(buttons)

    def set_mute_button(self, button):
        for e in self._note_editors:
            e.set_mute_button(button)

    @subject_slot('selected_mode')
    def _on_selected_mode_changed(self, mode):
        self._show_notes_information(mode)

    @subject_slot('position')
    def _on_notes_changed(self, *args):
        self._update_note_editors()
        self._show_notes_information()

    @subject_slot('selected_mode')
    def _on_scales_preset_changed(self, mode):
        self._update_note_editors()

    @subject_slot('scales_changed')
    def _on_scales_changed(self):
        self._update_note_editors()

    def _update_note_editors(self, *a):
        for row, note_editor in enumerate(self._note_editors):
            note_info = self._instrument.pattern[row]
            note_editor.background_color = 'NoteEditor.' + note_info.color
            note_editor.editing_note = note_info.index

        self._update_matrix_channels_for_playhead()

    def _update_matrix_channels_for_playhead(self):
        if self.is_enabled() and self._matrices != None:
            pattern = self._instrument.pattern
            for matrix, (y, _) in self._matrices.iterbuttons():
                if matrix:
                    for x, button in enumerate(matrix):
                        if button:
                            if pattern[y].index != None:
                                button.set_identifier(x)
                                button.set_channel(FEEDBACK_CHANNELS[y])
                            else:
                                button.set_identifier(button._original_identifier)
                                button.set_channel(NON_FEEDBACK_CHANNEL)

    def _update_playhead_color(self):
        if self.is_enabled() and self._skin and self._playhead:
            self._playhead.velocity = int(self._skin[self._playhead_color])

    def update(self):
        self._on_detail_clip_changed()
        self._update_playhead_color()

    def _show_notes_information(self, mode = None):
        if self.is_enabled():
            if mode is None:
                mode = self.selected_mode
            if mode == 'sequence':
                message = 'Sequence %s to %s'
                first = find_if(lambda editor: editor.editing_note != None, self._note_editors)
                last = find_if(lambda editor: editor.editing_note != None, reversed(self._note_editors))
                start_note = first.editing_note if first != None else None
                end_note = last.editing_note if last != None else None
            else:
                message = 'Play %s to %s'
                start_note = self._instrument._pattern.note(0, 0).index
                end_note = self._instrument._pattern.note(7, 7).index
            self.show_notification(message % (pitch_index_to_string(start_note), pitch_index_to_string(end_note)))
########NEW FILE########
__FILENAME__ = MelodicPattern
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/MelodicPattern.py
from _Framework.Util import NamedTuple, lazy_attribute, memoize
import consts
NOTE_NAMES = ('C', 'D\x1b', 'D', 'E\x1b', 'E', 'F', 'G\x1b', 'G', 'A\x1b', 'A', 'B\x1b', 'B')

def pitch_index_to_string(index):
    if 0 <= index < 128:
        return NOTE_NAMES[index % 12] + str(index / 12 - 2)
    return consts.CHAR_ELLIPSIS


class Scale(NamedTuple):
    name = ''
    notes = []


class Modus(Scale):

    def __str__(self):
        return self.name

    def scale(self, base_note):
        return Scale(name=NOTE_NAMES[base_note], notes=[ base_note + x for x in self.notes ])

    @memoize
    def scales(self, base_notes):
        return [ self.scale(b) for b in base_notes ]


class NoteInfo(NamedTuple):
    index = None
    channel = 0
    color = 'NoteInvalid'


class MelodicPattern(NamedTuple):
    steps = [0, 0]
    scale = range(12)
    base_note = 0
    origin = [0, 0]
    chromatic_mode = False

    @lazy_attribute
    def extended_scale(self):
        if self.chromatic_mode:
            first_note = self.scale[0]
            return range(first_note, first_note + 12)
        else:
            return self.scale

    @property
    def is_aligned(self):
        return not self.origin[0] and not self.origin[1] and abs(self.base_note) % 12 == self.extended_scale[0]

    def note(self, x, y):
        return self._get_note_info(self._octave_and_note(x, y), self.base_note, x + 5)

    def __getitem__(self, i):
        base_note = self.base_note
        if base_note <= -12:
            base_note = 0 if self.is_aligned else -12
        return self._get_note_info(self._octave_and_note_linear(i), base_note)

    def _octave_and_note_by_index(self, index):
        scale = self.extended_scale
        scale_size = len(scale)
        octave = index / scale_size
        note = scale[index % scale_size]
        return (octave, note)

    def _octave_and_note(self, x, y):
        index = self.steps[0] * (self.origin[0] + x) + self.steps[1] * (self.origin[1] + y)
        return self._octave_and_note_by_index(index)

    def _color_for_note(self, note):
        if note == self.scale[0]:
            return 'NoteBase'
        elif note in self.scale:
            return 'NoteScale'
        else:
            return 'NoteNotScale'

    def _get_note_info(self, (octave, note), base_note, channel = 0):
        note_index = 12 * octave + note + base_note
        if 0 <= note_index <= 127:
            return NoteInfo(index=note_index, channel=channel, color=self._color_for_note(note))
        else:
            return NoteInfo()

    def _octave_and_note_linear(self, i):
        origin = self.origin[0] or self.origin[1]
        index = origin + i
        return self._octave_and_note_by_index(index)
########NEW FILE########
__FILENAME__ = MessageBoxComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/MessageBoxComponent.py
from functools import partial
from _Framework.Dependency import dependency
from _Framework.CompoundComponent import CompoundComponent
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.SubjectSlot import subject_slot
from _Framework.Util import forward_property, const, nop, maybe
from _Framework import Task
from _Framework.ControlElement import ControlElement
from _Framework.Layer import Layer
from BackgroundComponent import BackgroundComponent
from consts import MessageBoxText, DISPLAY_LENGTH, DISPLAY_BLOCK_LENGTH
import consts
from _Framework.CompoundElement import CompoundElement

class Messenger(object):
    """
    Externally provided interface for those components that provide
    global Push feedback.
    """
    expect_dialog = dependency(expect_dialog=const(nop))
    show_notification = dependency(show_notification=const(nop))


class MessageBoxComponent(BackgroundComponent):
    """
    Component showing a temporary message in the display
    """
    __subject_events__ = ('cancel',)
    _cancel_button_index = 7
    num_lines = 4

    def __init__(self, *a, **k):
        super(MessageBoxComponent, self).__init__(*a, **k)
        self._current_text = None
        self._can_cancel = False
        self._top_row_buttons = None
        self.data_sources = map(DisplayDataSource, ('',) * self.num_lines)
        self._notification_display = None

    def _set_display_line(self, n, display_line):
        if display_line:
            display_line.set_data_sources((self.data_sources[n],))

    def set_display_line1(self, display_line):
        self._set_display_line(0, display_line)

    def set_display_line2(self, display_line):
        self._set_display_line(1, display_line)

    def set_display_line3(self, display_line):
        self._set_display_line(2, display_line)

    def set_display_line4(self, display_line):
        self._set_display_line(3, display_line)

    def set_top_buttons(self, buttons):
        self._top_row_buttons = buttons
        if buttons:
            buttons.reset()
        self.set_cancel_button(buttons[self._cancel_button_index] if buttons else None)

    def set_cancel_button(self, button):
        self._on_cancel_button_value.subject = button
        self._update_cancel_button()

    def _update_cancel_button(self):
        if self.is_enabled():
            button = self._on_cancel_button_value.subject
            if self._top_row_buttons:
                self._top_row_buttons.reset()
            if self._can_cancel and button:
                button.set_light('MessageBox.Cancel')

    def _update_display(self):
        if self._current_text != None:
            lines = self._current_text.split('\n')
            for source_line, line in map(None, self.data_sources, lines):
                if source_line:
                    source_line.set_display_string(line or '')

            if self._can_cancel:
                self.data_sources[-1].set_display_string('[  Ok  ]'.rjust(DISPLAY_LENGTH - 1))

    @subject_slot('value')
    def _on_cancel_button_value(self, value):
        if self.is_enabled() and self._can_cancel and value:
            self.notify_cancel()

    def _get_text(self):
        return self._current_text

    def _set_text(self, text):
        self._current_text = text
        self._update_display()

    text = property(_get_text, _set_text)

    def _get_can_cancel(self):
        return self._can_cancel

    def _set_can_cancel(self, can_cancel):
        self._can_cancel = can_cancel
        self._update_cancel_button()
        self._update_display()

    can_cancel = property(_get_can_cancel, _set_can_cancel)

    def update(self):
        self._update_cancel_button()
        self._update_display()


class _CallbackControl(CompoundElement):
    _is_resource_based = True

    def __init__(self, token = None, callback = None, *a, **k):
        super(_CallbackControl, self).__init__(*a, **k)
        self._callback = callback
        self.register_control_element(token)

    def on_nested_control_element_grabbed(self, control):
        self._callback()

    def on_nested_control_element_released(self, control):
        pass


class _TokenControlElement(ControlElement):

    def reset(self):
        pass


BLANK_BLOCK = ' ' * DISPLAY_BLOCK_LENGTH

def align_none(width, text):
    return text


def align_left(width, text):
    while text.startswith(BLANK_BLOCK):
        text = text[DISPLAY_BLOCK_LENGTH:]

    return text


def align_right(width, text):
    text = text.ljust(width)
    while text.endswith(BLANK_BLOCK):
        text = BLANK_BLOCK + text[:1 - DISPLAY_BLOCK_LENGTH]

    return text


class NotificationComponent(CompoundComponent):
    """
    Displays notifications to the user for a given amount of time. A notification time
    of -1 creates an infinite duration notification.
    
    To adjust the way notifications are shown in special cases, assign a generated
    control using use_single_line or use_full_display to a layer. If the layer is on
    top, it will set the preferred view.
    This will show the notification on line 1 if my_component is enabled and
    the priority premise of the layer is met:
    
        my_component.layer = Layer(
            _notification = notification_component.use_single_line(1))
    """
    _default_align_text_fn = partial(maybe(partial(align_none, DISPLAY_LENGTH)))

    def __init__(self, notification_time = 2.5, blinking_time = 0.3, display_lines = [], *a, **k):
        super(NotificationComponent, self).__init__(*a, **k)
        self._display_lines = display_lines
        self._token_control = _TokenControlElement()
        self._align_text_fn = self._default_align_text_fn
        self._message_box = self.register_component(MessageBoxComponent())
        self._message_box.set_enabled(False)
        self._notification_timeout_task = self._tasks.add(Task.sequence(Task.wait(notification_time), Task.run(self.hide_notification))).kill() if notification_time != -1 else self._tasks.add(Task.Task())
        self._blink_text_task = self._tasks.add(Task.loop(Task.sequence(Task.run(lambda : self._message_box.__setattr__('text', self._original_text)), Task.wait(blinking_time), Task.run(lambda : self._message_box.__setattr__('text', self._blink_text)), Task.wait(blinking_time)))).kill()
        self._original_text = None
        self._blink_text = None

    message_box_layer = forward_property('_message_box')('layer')

    def show_notification(self, text, blink_text = None):
        """
        Triggers a notification with the given text.
        """
        text = self._align_text_fn(text)
        blink_text = self._align_text_fn(blink_text)
        if blink_text is not None:
            self._original_text = text
            self._blink_text = blink_text
            self._blink_text_task.restart()
        self._message_box.text = text
        self._message_box.set_enabled(True)
        self._notification_timeout_task.restart()

    def hide_notification(self):
        """
        Hides the current notification, if any existing.
        """
        self._blink_text_task.kill()
        self._message_box.set_enabled(False)

    def use_single_line(self, line_index, line_slice = None, align = align_none):
        """
        Returns a control, that will change the notification to a single line view,
        if it is grabbed.
        """
        if not (line_index >= 0 and line_index < len(self._display_lines)):
            raise AssertionError
            display = self._display_lines[line_index]
            display = line_slice is not None and display.subdisplay[line_slice]
        layer = Layer(priority=consts.MESSAGE_BOX_PRIORITY, display_line1=display)
        return _CallbackControl(self._token_control, partial(self._set_message_box_layout, layer, maybe(partial(align, display.width))))

    def use_full_display(self, message_line_index = 2):
        """
        Returns a control, that will change the notification to use the whole display,
        if it is grabbed.
        """
        layer = Layer(priority=consts.MESSAGE_BOX_PRIORITY, **dict([ ('display_line1' if i == message_line_index else 'bg%d' % i, line) for i, line in enumerate(self._display_lines) ]))
        return _CallbackControl(self._token_control, partial(self._set_message_box_layout, layer))

    def _set_message_box_layout(self, layer, align_text_fn = None):
        self._message_box.layer = layer
        self._align_text_fn = partial(align_text_fn or self._default_align_text_fn)

    def update(self):
        pass


class DialogComponent(CompoundComponent):
    """
    Handles representing modal dialogs from the application.  The
    script can also request dialogs.
    """

    def __init__(self, *a, **k):
        super(DialogComponent, self).__init__(*a, **k)
        self._message_box = self.register_component(MessageBoxComponent())
        self._message_box.set_enabled(False)
        self._next_message = None
        self._on_open_dialog_count.subject = self.application()
        self._on_message_cancel.subject = self._message_box

    message_box_layer = forward_property('_message_box')('layer')

    def expect_dialog(self, message):
        """
        Expects a dialog from Live to appear soon.  The dialog will be
        shown on the controller with the given message regardless of
        wether a dialog actually appears.  This dialog can be
        cancelled.
        """
        self._next_message = message
        self._update_dialog()

    @subject_slot('open_dialog_count')
    def _on_open_dialog_count(self):
        self._update_dialog(open_dialog_changed=True)
        self._next_message = None

    @subject_slot('cancel')
    def _on_message_cancel(self):
        self._next_message = None
        try:
            self.application().press_current_dialog_button(0)
        except RuntimeError:
            pass

        self._update_dialog()

    def _update_dialog(self, open_dialog_changed = False):
        message = self._next_message or MessageBoxText.LIVE_DIALOG
        can_cancel = self._next_message != None
        self._message_box.text = message
        self._message_box.can_cancel = can_cancel
        self._message_box.set_enabled(self.application().open_dialog_count > 0 or not open_dialog_changed and self._next_message)

    def update(self):
        pass


class InfoComponent(BackgroundComponent):
    """
    Component that will show an info text and grab all components that should be unusable.
    """

    def __init__(self, info_text = '', *a, **k):
        super(InfoComponent, self).__init__(*a, **k)
        self._data_source = DisplayDataSource()
        self._data_source.set_display_string(info_text)

    def set_display(self, display):
        if display:
            display.set_data_sources([self._data_source])

    def update(self):
        pass
########NEW FILE########
__FILENAME__ = NavigationNode
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/NavigationNode.py
import Live.DrumPad
import Live.Song
import Live.Track
DeviceType = Live.Device.DeviceType
from itertools import imap
from functools import partial
from _Framework.SubjectSlot import SlotManager, Subject, subject_slot
from _Framework.Util import flatten, second, compose, in_range, find_if, index_if
from _Generic.Devices import parameter_bank_names
from SpecialMixerComponent import tracks_to_use_from_song
import consts

def make_navigation_node(model_object, is_entering = True, device_bank_registry = None):
    """
    Returns a proper navigation node wrapper for the model_object
    """
    node = None
    if model_object == None:
        node = None
    elif isinstance(model_object, Live.Song.Song):
        node = SongNode(model_object)
    elif isinstance(model_object, Live.Track.Track):
        node = TrackNode(object=model_object, device_bank_registry=device_bank_registry)
    elif isinstance(model_object, Live.Chain.Chain):
        node = ChainNode(object=model_object, device_bank_registry=device_bank_registry)
    elif isinstance(model_object, Live.DrumPad.DrumPad):
        node = ChainNode(object=model_object.chains[0], device_bank_registry=device_bank_registry) if model_object.chains else None
    elif isinstance(model_object, Live.Device.Device):
        if model_object.can_have_chains:
            if model_object.can_have_drum_pads:
                if is_entering:
                    node = None
                else:
                    node = make_navigation_node(model_object.canonical_parent, is_entering=is_entering, device_bank_registry=device_bank_registry)
            else:
                node = RackNode(model_object)
        else:
            raise device_bank_registry or AssertionError, 'Navigating a device needs a bank registry'
            node = SimpleDeviceNode(device_bank_registry, model_object)
    if node and node.parent and not node.children:
        node.disconnect()
        node = None
    if isinstance(node, RackNode) and len(node.children) == 1:
        actual_model_object = node.children[0][1] if is_entering else node.parent
        node.disconnect()
        node = make_navigation_node(actual_model_object, is_entering=is_entering, device_bank_registry=device_bank_registry)
    return node


class NavigationNode(SlotManager, Subject):
    """
    Navigation nodes provide a generic and observable interface for
    tree-like datastructures in the model. It can be used to implement
    generic navigation and browsing components on top of them.
    """
    __subject_events__ = ('children', 'selected_child', 'state')

    def get_selected_child(self):
        return None

    def set_selected_child(self, value):
        pass

    selected_child = property(lambda self: self.get_selected_child(), lambda self, x: self.set_selected_child(x))

    def get_state(self):
        pass

    state = property(lambda self: self.get_state())

    def set_state(self, index, value):
        pass

    def get_children(self):
        pass

    children = property(lambda self: self.get_children())

    def delete_child(self, index):
        pass

    def get_parent(self):
        pass

    parent = property(lambda self: self.get_parent())

    def get_object(self):
        pass

    object = property(lambda self: self.get_object())

    def preselect(self):
        """
        Choose a default selection for the node if it does not have
        one. Also make sure that the model is consistent with
        selection.
        """
        selected_child_index = self.selected_child
        if selected_child_index == None and self.children:
            self.selected_child = 0
        self.notify_selected_child(self.selected_child)

    def disconnect(self):
        self.clear_children_listeners()
        self.clear_selected_child_listeners()
        self.clear_state_listeners()
        super(NavigationNode, self).disconnect()


class ModelNode(NavigationNode):

    def __init__(self, object = None, *a, **k):
        super(ModelNode, self).__init__(*a, **k)
        self._object = object
        self._children = []
        self._state = []
        self._selected_child = None
        self._in_update_children = False

    def _get_children_from_model(self):
        pass

    def _get_selected_child_from_model(self):
        pass

    def _set_selected_child_in_model(self, child):
        pass

    def _get_state_from_model(self, child):
        pass

    def _set_state_in_model(self, child, value):
        pass

    def get_state(self):
        return self._state

    def get_children(self):
        return self._children

    def get_selected_child(self):
        return self._selected_child

    def set_selected_child(self, child):
        if not (in_range(child, 0, len(self._children)) or child == None):
            raise AssertionError
            _, obj = child >= 0 and child < len(self._children) and self._children[child]
            self._set_selected_child_in_model(obj)
            self._selected_child = child
        else:
            self._selected_child = None
            self._set_selected_child_in_model(None)

    def set_state(self, child, value):
        if child >= 0 and child < len(self._children):
            _, obj = self._children[child]
            self._state[child] = self._set_state_in_model(obj, value)

    def get_object(self):
        return self._object

    def get_parent(self):
        return self._object.canonical_parent if self._object != None else None

    def _get_song(self):
        return self._get_parent_with_class(Live.Song.Song)

    def _get_track(self):
        return self._get_parent_with_class(Live.Track.Track)

    def _get_parent_with_class(self, cls):
        node = self._object
        while node != None and not isinstance(node, cls):
            node = node.canonical_parent

        return node

    def _update_selected_child(self):
        selected = self._get_selected_child_from_model()
        children = [ c[1] for c in self._children ]
        self._selected_child = children.index(selected) if selected in children else None
        self.notify_selected_child(self._selected_child)

    def _update_state(self, child):
        children = map(second, self.children)
        if child in children:
            index = children.index(child)
            value = self._get_state_from_model(child)
            self._state[index] = value
            self.notify_state(index, value)

    def _update_children(self):
        raise not self._in_update_children or AssertionError
        self._in_update_children = True
        self._children = self._get_children_from_model()
        self._state = map(compose(self._get_state_from_model, second), self._children)
        self.notify_children()
        for idx, value in enumerate(self._state):
            self.notify_state(idx, value)

        self._in_update_children = False


class ChainNode(ModelNode):

    def __init__(self, device_bank_registry = None, *a, **k):
        super(ChainNode, self).__init__(*a, **k)
        self._device_bank_registry = device_bank_registry
        self._on_devices_changed_in_live.subject = self._object
        self._on_selected_device_changed_in_live.subject = self._get_track().view
        self._child_name_slots = self.register_slot_manager()
        self._child_state_slots = self.register_slot_manager()
        self._selected_drum_pad_slots = self.register_slot_manager()
        self._update_children()
        self._update_selected_child()

    def preselect(self):
        old_selected_child_index = self.selected_child
        if old_selected_child_index == None:
            devices = map(second, self.children)
            instrument = index_if(lambda d: isinstance(d, Live.Device.Device) and d.type == DeviceType.instrument, devices)
            if in_range(instrument, 0, len(devices)):
                if devices[instrument].can_have_drum_pads and devices[instrument].drum_pads and instrument + 1 < len(devices):
                    self.selected_child = instrument + 1
                else:
                    self.selected_child = instrument
        super(ChainNode, self).preselect()
        new_selected_child_index = self.selected_child
        track = self._get_track()
        if new_selected_child_index == old_selected_child_index:
            if new_selected_child_index != None:
                _, selected_object = self.children[new_selected_child_index]
                isinstance(selected_object, Live.Device.Device) and track and track.view.selected_device != selected_object and self._get_song().view.select_device(selected_object)
        self._device_bank_registry.set_device_bank(track.view.selected_device, None)

    def delete_child(self, index):
        if index >= 0 and index < len(self._children):
            if not isinstance(self._children[index][1], Live.DrumPad.DrumPad):
                drumpads_before = len(filter(lambda (_, x): isinstance(x, Live.DrumPad.DrumPad), self._children[:index]))
                delete_index = index - drumpads_before
                len(self.object.devices) > delete_index and self.object.delete_device(delete_index)

    def _get_children_from_model(self):

        def expand_device(d):
            drum_pad = d.view.selected_drum_pad if d.can_have_drum_pads else None
            if drum_pad:
                drum_pad_name = drum_pad.name if len(drum_pad.chains) > 0 else 'EmptyPad'
                return [(d.name, d), (drum_pad_name, drum_pad)]
            else:
                return [(d.name, d)]

        return list(flatten(imap(expand_device, self._object.devices)))

    def _set_selected_child_in_model(self, selected):
        song = self._get_song()
        if selected and isinstance(selected, Live.DrumPad.DrumPad):
            if selected.chains and selected.chains[0].devices:
                song.view.select_device(selected.chains[0].devices[0])
            selected.canonical_parent.view.selected_drum_pad = selected
        elif selected and isinstance(selected, Live.Device.Device):
            song.view.select_device(selected)
            self._device_bank_registry.set_device_bank(selected, None)

    def _get_selected_child_from_model(self):
        devices = map(second, self.children)
        selected = self._get_track().view.selected_device
        if selected == None:
            return find_if(lambda d: isinstance(d, Live.DrumPad.DrumPad), devices)
        is_deeper = False
        while selected:
            if selected in devices:
                if isinstance(selected, Live.DrumPad.DrumPad):
                    self._on_selected_drum_pad()
                    self._update_child_slots()
                    return selected
                if is_deeper and selected.can_have_drum_pads:
                    self._on_selected_drum_pad()
                    self._update_child_slots()
                    return selected.view.selected_drum_pad
                return selected
            selected = selected.canonical_parent
            is_deeper = True

    def _get_state_from_model(self, child):
        if isinstance(child, Live.DrumPad.DrumPad):
            return not bool(child.mute)
        if isinstance(child, Live.Device.Device) and child.parameters:
            return bool(child.parameters[0].value)
        return False

    def _set_state_in_model(self, child, value):
        if child == None:
            return False
        elif isinstance(child, Live.DrumPad.DrumPad):
            if child.mute == value:
                child.mute = not value
                return value
            return not child.mute
        elif child.parameters:
            on_off = child.parameters[0]
            if value != on_off.value and on_off.is_enabled:
                child.parameters[0].value = int(value)
                return value
            return bool(on_off.value)

    @subject_slot('devices')
    def _on_devices_changed_in_live(self):
        self._update_children()
        self._update_selected_child()
        self._update_child_slots()

    @subject_slot('selected_device')
    def _on_selected_device_changed_in_live(self):
        self._update_selected_child()

    def _on_selected_drum_pad(self):
        self._update_children()

    def _update_children(self):
        super(ChainNode, self)._update_children()
        self._update_child_slots()

    def _update_child_slots(self):
        self._child_name_slots.disconnect()
        self._child_state_slots.disconnect()
        self._selected_drum_pad_slots.disconnect()
        for device in map(second, self.children):
            self._child_name_slots.register_slot(device, self._update_children, 'name')
            if isinstance(device, Live.DrumPad.DrumPad):
                self._child_state_slots.register_slot(device, partial(self._update_state, device), 'mute')
            elif isinstance(device, Live.Device.Device):
                if device.can_have_drum_pads:
                    self._selected_drum_pad_slots.register_slot(device.view, self._on_selected_drum_pad, 'selected_drum_pad')
                if device.parameters:
                    self._child_state_slots.register_slot(device.parameters[0], partial(self._update_state, device), 'value')


class TrackNode(ChainNode):
    if not consts.PROTO_SONG_IS_ROOT:

        def get_parent(self):
            return None


class SongNode(ModelNode):

    def __init__(self, *a, **k):
        super(SongNode, self).__init__(*a, **k)
        self.register_slot(self._object, self._update_children, 'visible_tracks')
        self.register_slot(self._object, self._update_children, 'return_tracks')
        self.register_slot(self._object.view, self._update_selected_child, 'selected_track')
        self._update_children()
        self._update_selected_child()

    def _get_selected_child_from_model(self):
        return self._object.view.selected_track

    def _set_selected_child_in_model(self, value):
        if value != None:
            self._object.view.selected_track = value

    def _get_children_from_model(self):
        tracks_to_use = tracks_to_use_from_song(self._object)
        return [ (t.name, t) for t in tracks_to_use ]


class SimpleDeviceNode(ModelNode):

    def __init__(self, device_bank_registry = None, *a, **k):
        super(SimpleDeviceNode, self).__init__(*a, **k)
        raise device_bank_registry or AssertionError, 'Need a device bank registry.'
        self._mute_next_update = False
        self._device_bank_registry = device_bank_registry
        self._on_device_bank_changed.subject = self._device_bank_registry
        self._update_children()
        self._update_selected_child()

    @subject_slot('device_bank')
    def _on_device_bank_changed(self, device, bank):
        self._update_selected_child()

    def _get_selected_child_from_model(self):
        return self._device_bank_registry.get_device_bank(self.object) if self.children else None

    def _set_selected_child_in_model(self, value):
        if value != None:
            self._device_bank_registry.set_device_bank(self.object, value)

    def _get_children_from_model(self):
        names = parameter_bank_names(self.object)
        return zip(names, range(len(names)))


class RackNode(ModelNode):

    def __init__(self, *a, **k):
        super(RackNode, self).__init__(*a, **k)
        self.register_slot(self._object, self._update_children, 'chains')
        self.register_slot(self._object.view, self._update_selected_child, 'selected_chain')
        self._update_children()
        self._update_selected_child()

    def _get_selected_child_from_model(self):
        return self._object.view.selected_chain

    def _set_selected_child_in_model(self, value):
        if value != None:
            self._object.view.selected_chain = value

    def _get_children_from_model(self):
        return map(lambda c: (c.name, c), self._object.chains)
########NEW FILE########
__FILENAME__ = NoteEditorComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/NoteEditorComponent.py
from __future__ import with_statement
from functools import partial
from itertools import chain, imap, ifilter
from _Framework.SubjectSlot import subject_slot, Subject
from _Framework.CompoundComponent import CompoundComponent
from _Framework.Util import sign, product, in_range, clamp, forward_property, first
from _Framework import Task, Defaults
from LoopSelectorComponent import create_clip_in_selected_slot
from MatrixMaps import PAD_FEEDBACK_CHANNEL
DEFAULT_VELOCITY = 100
BEAT_TIME_EPSILON = 1.0000000000000006e-05

def color_for_note(note):
    velocity = note[3]
    muted = note[4]
    if not muted:
        if velocity == 127:
            return 'Full'
        elif velocity >= 100:
            return 'High'
        else:
            return 'Low'
    else:
        return 'Muted'


def most_significant_note(notes):
    return max(notes, key=lambda n: n[3])


MAX_CLIP_LENGTH = 100000000
RELATIVE_OFFSET = 0.25

class TimeStep(object):
    """
    A fixed step (time range) for the step sequencer
    """

    def __init__(self, start, length, clip_start = 0.0, clip_end = MAX_CLIP_LENGTH, *a, **k):
        super(TimeStep, self).__init__(*a, **k)
        self.start = start
        self.length = length
        self.clip_start = clip_start
        self.clip_end = clip_end

    @property
    def offset(self):
        return self.length * RELATIVE_OFFSET

    def left_boundary(self):
        return max(0, self.start - self.offset + BEAT_TIME_EPSILON)

    def right_boundary(self):
        return max(0, self.start - self.offset + self.length - BEAT_TIME_EPSILON)

    def includes_note(self, note):
        return self.includes_time(note[1])

    def overlaps_note(self, note):
        time, length = note[1:3]
        step_start = self.left_boundary()
        step_end = self.start + self.length - BEAT_TIME_EPSILON
        note_start = int((time + self.offset) / self.length) * self.length
        note_end = note_start + length
        if step_start < note_start:
            return step_end > note_start
        else:
            return step_end < note_end

    def filter_notes(self, notes):
        return filter(self.includes_note, notes)

    def clamp(self, time, extra_time = 0.0):
        return clamp(time + extra_time, self.left_boundary(), self.right_boundary())

    def includes_time(self, time):
        return in_range(time - self.start + self.offset, 0, self.length)

    def connected_time_ranges(self):
        return [(self.start - self.offset, self.length)]


class LoopingTimeStep(TimeStep):

    def clamp(self, time, extra_time = 0.0):
        result = clamp(self._looped_time(time, extra_time), self.left_boundary(), self.start - self.offset + self.length - BEAT_TIME_EPSILON)
        if result < self.clip_start:
            return result - self.clip_start + self.clip_end
        else:
            return result

    def connected_time_ranges(self):
        """
        Returns a list of (start_time, length) ranges representing the
        step in terms of continuous time ranges that can be used by
        functions like clip.remove_notes
        """
        if self.start - self.offset < self.clip_start:
            return [(self.clip_start, self.length - self.offset), (self.clip_end - self.offset, self.offset)]
        else:
            return [(self.start - self.offset, self.length)]

    def _looped_time(self, time, extra_time = 0.0):
        if in_range(time, self.clip_end - self.offset, self.clip_end):
            time = time - self.clip_end + self.clip_start
        return time + extra_time

    def includes_time(self, time):
        return in_range(self._looped_time(time) + self.offset - self.start, 0, self.length) and in_range(time, self.clip_start, self.clip_end)


class NoteEditorComponent(CompoundComponent, Subject):
    __subject_events__ = ('page_length', 'active_steps', 'notes_changed')

    def __init__(self, settings_mode = None, clip_creator = None, grid_resolution = None, *a, **k):
        super(NoteEditorComponent, self).__init__(*a, **k)
        self.loop_steps = False
        self.full_velocity = False
        self._selected_page_point = 0
        self._page_index = 0
        self._clip_creator = clip_creator
        self._matrix = None
        self._width = 0
        self._height = 0
        self._sequencer_clip = None
        self._step_colors = []
        self._settings_mode = settings_mode
        self._mute_button = None
        self._pressed_steps = []
        self._modified_steps = []
        self._pressed_step_callback = None
        self._modify_task = self._tasks.add(Task.run(self._do_modification))
        self._modify_task.kill()
        self._modify_all_notes_enabled = False
        self._step_tap_tasks = {}
        self._clip_notes = []
        self._note_index = 36
        self._grid_resolution = grid_resolution
        self._on_resolution_changed.subject = self._grid_resolution
        self._nudge_offset = 0
        self._length_offset = 0
        self._velocity_offset = 0
        if self._settings_mode:
            self._settings_mode.add_editor(self)
            self._settings = settings_mode.settings
            self._on_setting_changed.subject = self._settings
        self._triplet_factor = 1.0
        self._update_from_grid()
        self.background_color = 'NoteEditor.StepEmpty'

    note_settings_layer = forward_property('_settings')('layer')

    @property
    def page_index(self):
        return self._page_index

    @property
    def page_length(self):
        return self._get_step_count() * self._get_step_length() * self._triplet_factor

    @property
    def can_change_page(self):
        return not self._pressed_steps and not self._modified_steps

    def set_selected_page_point(self, point):
        if not self.can_change_page:
            raise AssertionError
            self._selected_page_point = point
            index = int(point / self.page_length) if self.page_length != 0 else 0
            self._page_index = index != self._page_index and index
            self._on_clip_notes_changed()

    def _get_modify_all_notes_enabled(self):
        return self._modify_all_notes_enabled

    def _set_modify_all_notes_enabled(self, enabled):
        if enabled != self._modify_all_notes_enabled:
            self._modify_all_notes_enabled = enabled
            if self._settings_mode:
                self._settings_mode.selected_mode = 'enabled' if enabled else 'disabled'
                self._settings_mode.selected_setting = 'pad_settings'
            self._on_clip_notes_changed()

    modify_all_notes_enabled = property(_get_modify_all_notes_enabled, _set_modify_all_notes_enabled)

    def set_detail_clip(self, clip):
        self._sequencer_clip = clip
        self._on_clip_notes_changed.subject = clip
        self._on_clip_notes_changed()

    def _get_editing_note(self):
        return self._note_index

    def _set_editing_note(self, note_index):
        self._note_index = note_index
        self._on_clip_notes_changed()

    editing_note = property(_get_editing_note, _set_editing_note)

    def set_mute_button(self, button):
        self._mute_button = button
        self._on_mute_value.subject = button

    def set_button_matrix(self, matrix):
        last_page_length = self.page_length
        self._matrix = matrix
        self._on_matrix_value.subject = matrix
        if matrix:
            self._width = matrix.width()
            self._height = matrix.height()
            matrix.reset()
            for button, _ in ifilter(first, matrix.iterbuttons()):
                button.set_channel(PAD_FEEDBACK_CHANNEL)

        for task in self._step_tap_tasks.itervalues():
            task.kill()

        def trigger_modification_task(x, y):
            trigger = partial(self._trigger_modification, (x, y), done=True)
            return self._tasks.add(Task.sequence(Task.wait(Defaults.MOMENTARY_DELAY), Task.run(trigger))).kill()

        self._step_tap_tasks = dict([ ((x, y), trigger_modification_task(x, y)) for x, y in product(xrange(self._width), xrange(self._height)) ])
        if matrix and last_page_length != self.page_length:
            self._on_clip_notes_changed()
            self.notify_page_length()
        else:
            self._update_editor_matrix()

    def update(self):
        self._update_editor_matrix_leds()
        self._grid_resolution.update()

    def _get_clip_notes_time_range(self):
        if self._modify_all_notes_enabled:
            time_length = self._get_step_count() * 4.0
            time_start = 0
        else:
            time_length = self.page_length
            time_start = self._page_index * time_length
        return (time_start - self._time_step(0).offset, time_length)

    @subject_slot('notes')
    def _on_clip_notes_changed(self):
        """ get notes from clip for offline array """
        if self._sequencer_clip and self._note_index != None:
            time_start, time_length = self._get_clip_notes_time_range()
            self._clip_notes = self._sequencer_clip.get_notes(time_start, self._note_index, time_length, 1)
        else:
            self._clip_notes = []
        self._update_editor_matrix()
        self.notify_notes_changed()

    def _update_editor_matrix(self):
        """
        update offline array of button LED values, based on note
        velocity and mute states
        """
        step_colors = ['NoteEditor.StepDisabled'] * self._get_step_count()
        width = self._width
        coords_to_index = lambda (x, y): x + y * width
        editing_indices = set(map(coords_to_index, self._modified_steps))
        selected_indices = set(map(coords_to_index, self._pressed_steps))
        last_editing_notes = []
        for time_step, index in self._visible_steps():
            notes = time_step.filter_notes(self._clip_notes)
            if len(notes) > 0:
                last_editing_notes = []
                if index in selected_indices:
                    color = 'NoteEditor.StepSelected'
                elif index in editing_indices:
                    note_color = color_for_note(most_significant_note(notes))
                    color = 'NoteEditor.StepEditing.' + note_color
                    last_editing_notes = notes
                else:
                    note_color = color_for_note(most_significant_note(notes))
                    color = 'NoteEditor.Step.' + note_color
            elif any(imap(time_step.overlaps_note, last_editing_notes)):
                color = 'NoteEditor.StepEditing.' + note_color
            elif index in editing_indices or index in selected_indices:
                color = 'NoteEditor.StepSelected'
                last_editing_notes = []
            else:
                color = self.background_color
                last_editing_notes = []
            step_colors[index] = color

        self._step_colors = step_colors
        self._update_editor_matrix_leds()

    def _visible_steps(self):
        first_time = self.page_length * self._page_index
        steps_per_page = self._get_step_count()
        step_length = self._get_step_length()
        indices = range(steps_per_page)
        if self._is_triplet_quantization():
            indices = filter(lambda k: k % 8 not in (6, 7), indices)
        return [ (self._time_step(first_time + k * step_length), index) for k, index in enumerate(indices) ]

    def _update_editor_matrix_leds(self):
        """ update hardware LEDS to match offline array values """
        if self.is_enabled() and self._matrix:
            for row, col in product(xrange(self._height), xrange(self._width)):
                index = row * self._width + col
                color = self._step_colors[index]
                self._matrix.set_light(col, row, color)

    def _get_step_count(self):
        return self._width * self._height

    def _get_step_start_time(self, x, y):
        """ returns step starttime in beats, based on step coordinates """
        raise in_range(x, 0, self._width) or AssertionError
        raise in_range(y, 0, self._height) or AssertionError
        page_time = self._page_index * self._get_step_count() * self._triplet_factor
        step_time = x + y * self._width * self._triplet_factor
        return (page_time + step_time) * self._get_step_length()

    def _get_step_length(self):
        return self._grid_resolution.step_length

    def _update_from_grid(self):
        quantization, is_triplet = self._grid_resolution.clip_grid
        self._triplet_factor = 1.0 if not is_triplet else 0.75
        if self._clip_creator:
            self._clip_creator.grid_quantization = quantization
            self._clip_creator.is_grid_triplet = is_triplet
        if self._sequencer_clip:
            self._sequencer_clip.view.grid_quantization = quantization
            self._sequencer_clip.view.grid_is_triplet = is_triplet

    @subject_slot('value')
    def _on_mute_value(self, value):
        if self.is_enabled() and value:
            self._trigger_modification(immediate=True)

    @subject_slot('index')
    def _on_resolution_changed(self):
        self._release_active_steps()
        self._update_from_grid()
        self.set_selected_page_point(self._selected_page_point)
        self.notify_page_length()
        self._on_clip_notes_changed()

    @subject_slot('value')
    def _on_matrix_value(self, value, x, y, is_momentary):
        if self.is_enabled():
            if self._sequencer_clip == None and value or not is_momentary:
                clip = create_clip_in_selected_slot(self._clip_creator, self.song())
                self.set_detail_clip(clip)
            if self._note_index != None:
                width = self._width * self._triplet_factor if self._is_triplet_quantization() else self._width
                if x < width and y < self._height:
                    if value or not is_momentary:
                        self._on_press_step((x, y))
                    else:
                        self._on_release_step((x, y))
                    self._update_editor_matrix()

    @subject_slot('value')
    def _on_any_touch_value(self, value, x, y, is_momentary):
        pass

    @property
    def active_steps(self):

        def get_time_range((x, y)):
            time = self._get_step_start_time(x, y)
            return (time, time + self._get_step_length())

        return imap(get_time_range, chain(self._pressed_steps, self._modified_steps))

    def _release_active_steps(self):
        for step in self._pressed_steps + self._modified_steps:
            self._on_release_step(step, do_delete_notes=False)

    def _on_release_step(self, step, do_delete_notes = True):
        self._step_tap_tasks[step].kill()
        if step in self._pressed_steps:
            if do_delete_notes:
                self._delete_notes_in_step(step)
            self._pressed_steps.remove(step)
            self._add_note_in_step(step)
        if step in self._modified_steps:
            self._modified_steps.remove(step)
        self.notify_active_steps()

    def _on_press_step(self, step):
        if self._sequencer_clip != None and step not in self._pressed_steps and step not in self._modified_steps:
            self._step_tap_tasks[step].restart()
            self._pressed_steps.append(step)
        self.notify_active_steps()

    def _time_step(self, time):
        if self.loop_steps and self._sequencer_clip != None and self._sequencer_clip.looping:
            return LoopingTimeStep(time, self._get_step_length(), self._sequencer_clip.loop_start, self._sequencer_clip.loop_end)
        else:
            return TimeStep(time, self._get_step_length())

    def _add_note_in_step(self, step, modify_existing = True):
        """
        Add note in given step if there are none in there, otherwise
        select the step for potential deletion or modification
        """
        if self._sequencer_clip != None:
            x, y = step
            time = self._get_step_start_time(x, y)
            notes = self._time_step(time).filter_notes(self._clip_notes)
            if notes:
                if modify_existing:
                    most_significant_velocity = most_significant_note(notes)[3]
                    if self._mute_button and self._mute_button.is_pressed() or most_significant_velocity != 127 and self.full_velocity:
                        self._trigger_modification(step, immediate=True)
            else:
                pitch = self._note_index
                mute = self._mute_button and self._mute_button.is_pressed()
                velocity = 127 if self.full_velocity else DEFAULT_VELOCITY
                note = (pitch,
                 time,
                 self._get_step_length(),
                 velocity,
                 mute)
                self._sequencer_clip.set_notes((note,))
                self._sequencer_clip.deselect_all_notes()
                self._trigger_modification(step, done=True)
                return True
        return False

    def _delete_notes_in_step(self, (x, y)):
        """ Delete all notes in the given step """
        if self._sequencer_clip:
            time_step = self._time_step(self._get_step_start_time(x, y))
            for time, length in time_step.connected_time_ranges():
                self._sequencer_clip.remove_notes(time, self._note_index, length, 1)

    @subject_slot('setting_changed')
    def _on_setting_changed(self, index, value):
        if self.is_enabled():
            if index == 1:
                self._nudge_offset += value
            elif index == 2:
                self._length_offset += value
            elif index == 3:
                self._velocity_offset += value
            self._trigger_modification()

    def notify_modification(self):
        """
        Tell the note editor about changes to pressed steps, so further modifications
        by the note editor are ignored.
        """
        self._trigger_modification(done=True)

    def _trigger_modification(self, step = None, done = False, immediate = False):
        """
        Because the modification of notes is slow, we
        accumulate modification events and perform all of them
        alltogether in a task. Call this function whenever a given set
        of steps (or potentially all steps) are to be modified.
        
        If done=True, we just notify that the given steps have been
        modified without actually executing the task.
        """
        needs_update = False
        if step is None:
            needs_update = bool(self._pressed_steps)
            self._modified_steps += self._pressed_steps
            self._pressed_steps = []
        else:
            if step not in self._modified_steps:
                self._modified_steps.append(step)
            if step in self._pressed_steps:
                self._pressed_steps.remove(step)
            needs_update = True
        if not done:
            if immediate:
                self._do_modification()
                self._modify_task.kill()
            elif self._modify_task.is_killed:
                self._modify_task.restart()
        if needs_update:
            self._update_editor_matrix()

    def _reset_modifications(self):
        self._velocity_offset = 0
        self._length_offset = 0
        self._nudge_offset = 0

    def _do_modification(self):
        if self._modify_all_notes_enabled:
            new_notes = self._modify_all_notes()
            self._replace_notes(new_notes)
        elif self._modified_steps:
            notes_added = map(lambda s: self._add_note_in_step(s, False), self._modified_steps)
            if any(notes_added):
                self._modify_task.restart()
            else:
                new_notes = self._modify_step_notes(self._modified_steps)
                self._replace_notes(new_notes)
        self._reset_modifications()

    def _replace_notes(self, new_notes):
        if new_notes != self._clip_notes:
            clip = self._sequencer_clip
            time_start, time_length = self._get_clip_notes_time_range()
            clip.remove_notes(time_start, self._note_index, time_length, 1)
            clip.set_notes(tuple(new_notes))
            clip.deselect_all_notes()

    def _modify_all_notes(self):
        """ modify all notes in the current pitch """
        return self._modify_notes_in_time(TimeStep(0.0, MAX_CLIP_LENGTH), self._clip_notes)

    def _limited_nudge_offset(self, steps, notes, nudge_offset):
        limited_nudge_offset = MAX_CLIP_LENGTH
        for x, y in steps:
            time_step = self._time_step(self._get_step_start_time(x, y))
            for note in time_step.filter_notes(notes):
                time_after_nudge = time_step.clamp(note[1], nudge_offset)
                limited_nudge_offset = min(limited_nudge_offset, abs(note[1] - time_after_nudge))

        return sign(nudge_offset) * limited_nudge_offset

    def _modify_step_notes(self, steps):
        """ Return a new list with all notes within steps modified. """
        notes = self._clip_notes
        self._nudge_offset = self._limited_nudge_offset(steps, notes, self._nudge_offset)
        for x, y in steps:
            time_step = self._time_step(self._get_step_start_time(x, y))
            notes = self._modify_notes_in_time(time_step, notes)

        return notes

    def _modify_notes_in_time(self, time_step, notes):
        step_notes = time_step.filter_notes(self._clip_notes)
        step_mute = all(map(lambda note: note[4], step_notes))
        return map(partial(self._modify_single_note, step_mute, time_step), notes)

    def _modify_single_note(self, step_mute, time_step, (pitch, time, length, velocity, mute)):
        """
        Return a modified version of the passed in note taking into
        account current modifiers. If the note is not within
        the given step, returns the note as-is.
        
        If the time_step is inside a loop, the last part of the loop
        is considered as being the same as the part just before the
        loop, so the resulting note may, in this case, jump between
        the beginning and the end.
        """
        if time_step.includes_time(time):
            time = time_step.clamp(time, self._nudge_offset)
            if self._length_offset <= -time_step.length and length + self._length_offset < time_step.length:
                if length > time_step.length:
                    length = time_step.length
            else:
                length = max(0, length + self._length_offset)
            velocity = 127 if self.full_velocity else clamp(velocity + self._velocity_offset, 1, 127)
            mute = not step_mute if self._mute_button and self._mute_button.is_pressed() else mute
        return (pitch,
         time,
         length,
         velocity,
         mute)

    def _min_max_for_notes(self, notes, start_time, min_max_values = None):
        for note in notes:
            note_values = list(note[:4])
            note_values[1] -= start_time
            for index, value in enumerate(note_values):
                if not min_max_values:
                    min_max_values = [(99999, -99999)] * 4
                min_value, max_value = min_max_values[index]
                min_max_values[index] = (min(value, min_value), max(value, max_value))

        return min_max_values

    def get_min_max_note_values(self):
        if self._modify_all_notes_enabled and len(self._clip_notes) > 0:
            return self._min_max_for_notes(self._clip_notes, 0.0)
        elif len(self._pressed_steps) + len(self._modified_steps) > 0:
            min_max_values = None
            for x, y in chain(self._modified_steps, self._pressed_steps):
                start_time = self._get_step_start_time(x, y)
                min_max_values = self._min_max_for_notes(self._time_step(start_time).filter_notes(self._clip_notes), start_time, min_max_values)

            return min_max_values

    def _is_triplet_quantization(self):
        return self._triplet_factor == 0.75
########NEW FILE########
__FILENAME__ = NoteEditorPaginator
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/NoteEditorPaginator.py
from _Framework.Util import forward_property
from _Framework.SubjectSlot import subject_slot, SlotManager, subject_slot_group
from LoopSelectorComponent import Paginator

class NoteEditorPaginator(Paginator, SlotManager):

    def __init__(self, note_editors = None, *a, **k):
        super(NoteEditorPaginator, self).__init__(*a, **k)
        self._note_editors = note_editors
        self._last_page_index = -1
        self._on_page_length_changed.subject = self._reference_editor
        self._on_active_steps_changed.replace_subjects(note_editors)

    @property
    def _reference_editor(self):
        return self._note_editors[0]

    @forward_property('_reference_editor')
    def page_index():
        pass

    @forward_property('_reference_editor')
    def page_length():
        pass

    def _update_from_page_index(self):
        needed_update = self._last_page_index != self.page_index
        if needed_update:
            self._last_page_index = self.page_index
            self.notify_page_index()
        return needed_update

    @subject_slot_group('active_steps')
    def _on_active_steps_changed(self, editor):
        self.notify_page()

    @subject_slot('page_length')
    def _on_page_length_changed(self):
        self.notify_page()
        self.notify_page_length()
        self._update_from_page_index()

    @property
    def can_change_page(self):
        return all([ e.can_change_page for e in self._note_editors ])

    def select_page_in_point(self, value):
        can_change_page = self.can_change_page
        if can_change_page:
            map(lambda e: e.set_selected_page_point(value), self._note_editors)
            if self._update_from_page_index():
                self.notify_page()
        return can_change_page
########NEW FILE########
__FILENAME__ = NoteRepeatComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/NoteRepeatComponent.py
from _Framework.ModesComponent import ModesComponent
from _Framework import Task
from _Framework.CompoundComponent import CompoundComponent
from _Framework.SubjectSlot import subject_slot
from ActionWithOptionsComponent import OptionsComponent
t = 3.0 / 2.0
NOTE_REPEAT_FREQUENCIES = [32 * t,
 32,
 16 * t,
 16,
 8 * t,
 8,
 4 * t,
 4]
del t

class DummyNoteRepeat(object):
    repeat_rate = 1.0
    enabled = False


class NoteRepeatComponent(CompoundComponent):
    """
    Component for setting up the note repeat
    """

    def __init__(self, *a, **k):
        super(NoteRepeatComponent, self).__init__(*a, **k)
        self._aftertouch = None
        self._last_record_quantization = None
        self._note_repeat = None
        self._options = self.register_component(OptionsComponent())
        self._options.selected_color = 'NoteRepeat.RateSelected'
        self._options.unselected_color = 'NoteRepeat.RateUnselected'
        self._options.option_names = map(str, range(8))
        self._options.selected_option = 5
        self._on_selected_option_changed.subject = self._options
        self.set_note_repeat(None)

    def on_enabled_changed(self):
        if self.is_enabled():
            self._enable_note_repeat()
        else:
            self._disable_note_repeat()

    def update(self):
        self._update_aftertouch()

    def _update_aftertouch(self):
        if self._aftertouch:
            self._aftertouch.reset()

    def set_aftertouch_control(self, control):
        self._aftertouch = control
        self._update_aftertouch()

    def set_select_buttons(self, buttons):
        self._options.set_select_buttons(buttons)

    def set_note_repeat(self, note_repeat):
        if not note_repeat:
            note_repeat = DummyNoteRepeat()
            self._note_repeat.enabled = self._note_repeat != None and False
        self._note_repeat = note_repeat
        self._update_note_repeat(enabled=self.is_enabled())

    def _enable_note_repeat(self):
        self._last_record_quantization = self._song.midi_recording_quantization
        self._set_recording_quantization(False)
        self._update_note_repeat(enabled=True)

    def _disable_note_repeat(self):
        if not self.song().midi_recording_quantization and self._last_record_quantization:
            self._set_recording_quantization(self._last_record_quantization)
        self._update_note_repeat(enabled=False)

    def _set_recording_quantization(self, value):

        def doit():
            self.song().midi_recording_quantization = value

        self._tasks.parent_task.add(Task.run(doit))

    @subject_slot('selected_option')
    def _on_selected_option_changed(self, option):
        frequency = NOTE_REPEAT_FREQUENCIES[option]
        self._note_repeat.repeat_rate = 1.0 / frequency * 4.0

    def _update_note_repeat(self, enabled = False):
        self._on_selected_option_changed(self._options.selected_option)
        self._note_repeat.enabled = self.is_enabled()
########NEW FILE########
__FILENAME__ = NoteSettingsComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/NoteSettingsComponent.py
import math
from functools import partial
from itertools import imap
from _Framework.SubjectSlot import subject_slot, subject_slot_group, Subject, SlotManager
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.ModesComponent import ModesComponent, Mode, AddLayerMode
from _Framework.Util import find_if, forward_property, chain_from_iterable, sign, clamp
from _Framework import Task, Defaults
from AutomationComponent import AutomationComponent
from ActionWithOptionsComponent import OptionsComponent
from Setting import EnumerableSetting
from consts import CHAR_ELLIPSIS, GRAPH_VOL

class NoteSetting(SlotManager, Subject):
    __subject_events__ = ('setting_changed',)
    attribute_index = -1

    def __init__(self, grid_resolution = None, *a, **k):
        super(NoteSetting, self).__init__(*a, **k)
        self._encoder = None
        self._grid_resolution = grid_resolution
        self.value_source = DisplayDataSource()
        self.label_source = DisplayDataSource()
        self.label_source.set_display_string(self.get_label())

    def get_label(self):
        raise NotImplementedError

    def encoder_value_to_attribute(self, value):
        raise NotImplementedError

    def attribute_min_max_to_string(self, min_value, max_value):
        raise NotImplementedError

    @property
    def step_length(self):
        return self._grid_resolution.step_length if self._grid_resolution else 1.0

    def set_encoder(self, encoder):
        self._encoder = encoder
        self._on_value.subject = encoder

    def set_min_max(self, min_max_value):
        self.value_source.set_display_string(self.attribute_min_max_to_string(min_max_value[0], min_max_value[1]) if min_max_value else '-')

    @subject_slot('normalized_value')
    def _on_value(self, value):
        self.notify_setting_changed(self.attribute_index, self.encoder_value_to_attribute(value))


RANGE_STRING_FLOAT = '%.1f' + CHAR_ELLIPSIS + '%.1f'
RANGE_STRING_INT = '%d' + CHAR_ELLIPSIS + '%d'

def step_offset_percentage(step_length, value):
    return int(round((value - int(value / step_length) * step_length) / step_length * 100))


def step_offset_min_max_to_string(step_length, min_value, max_value):
    min_value = step_offset_percentage(step_length, min_value)
    max_value = step_offset_percentage(step_length, max_value)
    return '%d%%' % min_value if min_value == max_value else (RANGE_STRING_INT + '%%') % (min_value, max_value)


def convert_value_to_graphic(value, value_range):
    value_bar = GRAPH_VOL
    graph_range = float(len(value_bar))
    value = clamp(int(value / value_range * graph_range), 0, len(value_bar) - 1)
    display_string = value_bar[value]
    return display_string


class NoteNudgeSetting(NoteSetting):
    attribute_index = 1

    def get_label(self):
        return 'Nudge'

    def encoder_value_to_attribute(self, value):
        return self.step_length * value

    def attribute_min_max_to_string(self, min_value, max_value):
        return step_offset_min_max_to_string(self.step_length, min_value, max_value)


class NoteLengthCoarseSetting(NoteSetting):
    attribute_index = 2
    _step_accum = 0.0

    def get_label(self):
        return 'Length -'

    def attribute_min_max_to_string(self, min_value, max_value):
        min_value = min_value / self.step_length
        max_value = max_value / self.step_length

        def format_string(value):
            num_non_decimal_figures = int(math.log10(value)) if value > 0 else 0
            return '%%.%dg' % (num_non_decimal_figures + 2,)

        return (format_string(min_value) + ' stp') % min_value if min_value == max_value else (format_string(min_value) + CHAR_ELLIPSIS + format_string(max_value)) % (min_value, max_value)

    @subject_slot('normalized_value')
    def _on_value(self, value):
        self._step_accum += self.step_length * value / EnumerableSetting.STEP_SIZE
        while abs(self._step_accum) >= self.step_length:
            self.notify_setting_changed(self.attribute_index, sign(self._step_accum) * self.step_length)
            self._step_accum -= self.step_length * sign(self._step_accum)


class NoteLengthFineSetting(NoteSetting):
    attribute_index = 2

    def get_label(self):
        return 'Fine'

    def encoder_value_to_attribute(self, value):
        return self.step_length * value

    def attribute_min_max_to_string(self, min_value, max_value):
        value = step_offset_percentage(self.step_length, min_value)
        return convert_value_to_graphic(value, 100.0)


class NoteVelocitySetting(NoteSetting):
    attribute_index = 3

    def get_label(self):
        return 'Velocity'

    def encoder_value_to_attribute(self, value):
        return value * 128

    def attribute_min_max_to_string(self, min_value, max_value):
        return str(int(min_value)) if int(min_value) == int(max_value) else RANGE_STRING_INT % (min_value, max_value)


class NoteSettingsComponent(ControlSurfaceComponent):
    __subject_events__ = ('setting_changed',)

    def __init__(self, grid_resolution = None, *a, **k):
        super(NoteSettingsComponent, self).__init__(*a, **k)
        self._top_data_sources = [ DisplayDataSource() for _ in xrange(8) ]
        self._bottom_data_sources = [ DisplayDataSource() for _ in xrange(8) ]
        self._info_data_source = DisplayDataSource()
        self._settings = []
        self._encoders = []
        self._add_setting(NoteNudgeSetting(grid_resolution=grid_resolution))
        self._add_setting(NoteLengthCoarseSetting(grid_resolution=grid_resolution))
        self._add_setting(NoteLengthFineSetting(grid_resolution=grid_resolution))
        self._add_setting(NoteVelocitySetting(grid_resolution=grid_resolution))

    def _add_setting(self, setting):
        raise len(self._settings) < 8 or AssertionError, 'Cannot show more than 8 settings'
        self._settings.append(setting)
        self._update_encoders()
        self._top_data_sources = [ DisplayDataSource() for _ in xrange(8 - len(self._settings)) ] + [ s.label_source for s in self._settings ]
        self._bottom_data_sources = [ DisplayDataSource() for _ in xrange(8 - len(self._settings)) ] + [ s.value_source for s in self._settings ]
        self.register_disconnectable(setting)
        self.register_slot(setting, self.notify_setting_changed, 'setting_changed')

    def set_encoder_controls(self, encoders):
        self._encoders = encoders or []
        self._update_encoders()

    def set_top_display_line(self, display):
        if self.is_enabled() and display:
            display.set_data_sources(self._top_data_sources)

    def set_bottom_display_line(self, display):
        if self.is_enabled() and display:
            display.set_data_sources(self._bottom_data_sources)

    def set_info_display_line(self, display):
        if self.is_enabled() and display:
            display.set_data_sources([self._info_data_source])

    def set_clear_display_line(self, display):
        if self.is_enabled() and display:
            display.reset()

    def set_full_velocity_button(self, button):
        self._on_full_velocity.subject = button

    @subject_slot('value')
    def _on_full_velocity(self, value):
        if self.is_enabled():
            self.notify_setting_changed(3, 127)

    def set_min_max(self, index, min_max_value):
        setting_for_index = [ i for i in self._settings if i.attribute_index == index ]
        for setting in setting_for_index:
            setting.set_min_max(min_max_value)

    def set_info_message(self, message):
        self._info_data_source.set_display_string(message.rjust(62))

    def _update_encoders(self):
        if self.is_enabled() and self._encoders:
            for encoder, setting in map(None, self._encoders[-len(self._settings):], self._settings):
                setting.set_encoder(encoder)

        else:
            map(lambda setting: setting.set_encoder(None), self._settings)

    def update(self):
        self._update_encoders()


class DetailViewRestorerMode(Mode):
    """
    Restores the detail view if either only clip view or device view is visible.
    Has no effect if the detail view is hidden at the point the mode is entered.
    """

    def __init__(self, application = None, *a, **k):
        super(DetailViewRestorerMode, self).__init__(*a, **k)
        self._app = application
        self._view_to_restore = None

    def enter_mode(self):
        clip_view_visible = self._app.view.is_view_visible('Detail/Clip', False)
        device_chain_visible = self._app.view.is_view_visible('Detail/DeviceChain', False)
        if clip_view_visible != device_chain_visible:
            self._view_to_restore = 'Detail/Clip' if clip_view_visible else 'Detail/DeviceChain'

    def leave_mode(self):
        try:
            if self._view_to_restore:
                self._app.view.show_view(self._view_to_restore)
                self._view_to_restore = None
        except RuntimeError:
            pass


class NoteEditorSettingsComponent(ModesComponent):

    def __init__(self, grid_resolution = None, initial_encoder_layer = None, encoder_layer = None, settings_layer = None, *a, **k):
        super(NoteEditorSettingsComponent, self).__init__(*a, **k)
        raise encoder_layer or AssertionError
        self._bottom_data_sources = [ DisplayDataSource() for _ in xrange(8) ]
        self._request_hide = False
        self.settings = self.register_component(NoteSettingsComponent(grid_resolution=grid_resolution, layer=settings_layer))
        self.settings.set_enabled(False)
        self._automation = self.register_component(AutomationComponent())
        self._automation.set_enabled(False)
        self._mode_selector = self.register_component(OptionsComponent(num_options=2, num_labels=0, num_display_segments=8))
        self._mode_selector.set_enabled(False)
        self._on_selected_option.subject = self._mode_selector
        self._update_available_modes()
        self._mode_selector.selected_option = 0
        self._visible_detail_view = 'Detail/DeviceChain'
        self._show_settings_task = self._tasks.add(Task.sequence(Task.wait(Defaults.MOMENTARY_DELAY), Task.run(self._show_settings)))
        self._show_settings_task.kill()
        self._update_infos_task = self._tasks.add(Task.run(self._update_note_infos))
        self._update_infos_task.kill()
        self._settings_modes = self.register_component(ModesComponent())
        self._settings_modes.set_enabled(False)
        self._settings_modes.add_mode('automation', [self._automation,
         self._mode_selector,
         partial(self._set_envelope_view_visible, True),
         self._show_clip_view])
        self._settings_modes.add_mode('note_settings', [self.settings,
         self._update_note_infos,
         self._mode_selector,
         partial(self._set_envelope_view_visible, False),
         self._show_clip_view])
        self._settings_modes.add_mode('pad_settings', [self.settings, partial(self._set_envelope_view_visible, False), self._show_clip_view])
        self._encoders = None
        self._initial_encoders = None
        self.add_mode('disabled', [])
        self.add_mode('about_to_show', [AddLayerMode(self, initial_encoder_layer), (self._show_settings_task.restart, self._show_settings_task.kill)])
        self.add_mode('enabled', [DetailViewRestorerMode(self.application()),
         AddLayerMode(self, encoder_layer),
         self._update_available_modes,
         self._settings_modes])
        self.selected_mode = 'disabled'
        self._editors = []
        self._on_detail_clip_changed.subject = self.song().view
        self._on_selected_track_changed.subject = self.song().view

    automation_layer = forward_property('_automation')('layer')
    mode_selector_layer = forward_property('_mode_selector')('layer')
    selected_setting = forward_property('_settings_modes')('selected_mode')

    def add_editor(self, editor):
        raise editor != None or AssertionError
        self._editors.append(editor)
        self._on_active_steps_changed.add_subject(editor)
        self._on_notes_changed.replace_subjects(self._editors)

    def set_display_line(self, line):
        self._mode_selector.set_display_line(line)

    def set_initial_encoders(self, encoders):
        self._initial_encoders = encoders
        self._on_init_encoder_touch.replace_subjects(encoders or [])
        self._on_init_encoder_value.replace_subjects(encoders or [])
        self._try_immediate_show_settings()

    def set_encoders(self, encoders):
        self._encoders = encoders
        self._on_encoder_touch.replace_subjects(encoders or [])
        self._on_encoder_value.replace_subjects(encoders or [])
        self.settings.set_encoder_controls(encoders)
        self._automation.set_parameter_controls(encoders)

    def _get_parameter_provider(self):
        self._automation.parameter_provider

    def _set_parameter_provider(self, value):
        self._automation.parameter_provider = value
        if self.selected_mode != 'disabled':
            self._update_available_modes()

    parameter_provider = property(_get_parameter_provider, _set_parameter_provider)

    def _update_available_modes(self):
        available_modes = ['Notes']
        if self._automation.can_automate_parameters:
            available_modes.append('Automat')
        self._mode_selector.option_names = available_modes

    def _show_clip_view(self):
        try:
            view = self.application().view
            if view.is_view_visible('Detail/DeviceChain', False) and not view.is_view_visible('Detail/Clip', False):
                self.application().view.show_view('Detail/Clip')
        except RuntimeError:
            pass

    def _set_envelope_view_visible(self, visible):
        clip = self.song().view.detail_clip
        if clip:
            if visible:
                clip.view.show_envelope()
            else:
                clip.view.hide_envelope()

    def _try_immediate_show_settings(self):
        if self.selected_mode == 'about_to_show' and any(imap(lambda e: e and e.is_pressed(), self._initial_encoders or [])):
            self._show_settings()

    @subject_slot_group('active_steps')
    def _on_active_steps_changed(self, editor):
        if self.is_enabled():
            all_steps = list(set(chain_from_iterable(imap(lambda e: e.active_steps, self._editors))))
            self._automation.selected_time = all_steps
            self._update_note_infos()
            if len(all_steps) > 0:
                self._request_hide = False
                if self.selected_mode == 'disabled':
                    self.selected_mode = 'about_to_show'
                    self._try_immediate_show_settings()
            else:
                self._request_hide = True
                self._try_hide_settings()

    @subject_slot_group('notes_changed')
    def _on_notes_changed(self, editor):
        self._update_infos_task.restart()

    @subject_slot('detail_clip')
    def _on_detail_clip_changed(self):
        clip = self.song().view.detail_clip if self.is_enabled() else None
        self._automation.clip = clip

    @subject_slot('selected_track')
    def _on_selected_track_changed(self):
        self.selected_mode = 'disabled'

    @subject_slot('selected_option')
    def _on_selected_option(self, option):
        self._update_selected_setting(option)

    @subject_slot_group('touch_value')
    def _on_init_encoder_touch(self, value, encoder):
        self._show_settings()

    @subject_slot_group('value')
    def _on_init_encoder_value(self, value, encoder):
        self._show_settings()

    @subject_slot_group('touch_value')
    def _on_encoder_touch(self, value, encoder):
        if not value:
            self._try_hide_settings()

    @subject_slot_group('value')
    def _on_encoder_value(self, value, encoder):
        self._notify_modification()

    def _notify_modification(self):
        for editor in self._editors:
            editor.notify_modification()

    def _update_note_infos(self):
        if self.settings.is_enabled():

            def min_max((l_min, l_max), (r_min, r_max)):
                return (min(l_min, r_min), max(l_max, r_max))

            all_min_max_attributes = filter(None, imap(lambda e: e.get_min_max_note_values(), self._editors))
            min_max_values = [(99999, -99999)] * 4 if len(all_min_max_attributes) > 0 else None
            for min_max_attribute in all_min_max_attributes:
                for i, attribute in enumerate(min_max_attribute):
                    min_max_values[i] = min_max(min_max_values[i], attribute)

            for i in xrange(4):
                self.settings.set_min_max(i, min_max_values[i] if min_max_values else None)

            edit_all_notes_active = find_if(lambda e: e.modify_all_notes_enabled, self._editors) != None
            self.settings.set_info_message('Tweak to add note' if not edit_all_notes_active and not min_max_values else '')

    def _show_settings(self):
        if self.selected_mode != 'enabled':
            self.selected_mode = 'enabled'
            self._notify_modification()
            self._update_selected_setting(self._mode_selector.selected_option)

    def _update_selected_setting(self, option):
        if option == 0:
            self.selected_setting = 'note_settings'
        elif option == 1:
            self.selected_setting = 'automation'

    def _try_hide_settings(self):
        if self._request_hide and not any(imap(lambda e: e and e.is_pressed(), self._encoders or [])):
            self.selected_mode = 'disabled'
            self._request_hide = False

    def on_enabled_changed(self):
        super(NoteEditorSettingsComponent, self).on_enabled_changed()
        if not self.is_enabled():
            self.selected_mode = 'disabled'

    def update(self):
        if self.is_enabled():
            self._on_detail_clip_changed()
########NEW FILE########
__FILENAME__ = OptionalElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/OptionalElement.py
from ComboElement import WrapperElement
from _Framework.SubjectSlot import SlotManager, subject_slot

class ChoosingElement(WrapperElement, SlotManager):
    """
    An Element wrapper that enables one of the nested elements based on
    the value of the given setting.
    """

    def __init__(self, on_control = None, off_control = None, setting = None, *a, **k):
        super(ChoosingElement, self).__init__(*a, **k)
        self._on_control = on_control
        self._off_control = off_control
        self._on_setting_changed.subject = setting
        self._on_setting_changed(setting)

    @subject_slot('value')
    def _on_setting_changed(self, setting):
        if self.has_control_element(self._wrapped_control):
            self.unregister_control_element(self._wrapped_control)
        self._wrapped_control = self._on_control if setting.value else self._off_control
        if self._wrapped_control != None:
            self.register_control_element(self._wrapped_control)


class OptionalElement(ChoosingElement):
    """
    An Element wrapper that enables the nested element IFF some given
    setting is set to a specific value.
    """

    def __init__(self, control = None, setting = None, value = None, *a, **k):
        on_control = control if value else None
        off_control = None if value else control
        super(OptionalElement, self).__init__(on_control=on_control, off_control=off_control, setting=setting, *a, **k)
########NEW FILE########
__FILENAME__ = PadSensitivity
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/PadSensitivity.py
from itertools import repeat
from _Framework import Task
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.Util import find_if, second, lazy_attribute, in_range, nop, NamedTuple

def to_bytes(number, size):
    """
    turns the given value into tuple of 4bit bytes,
    ordered from most significant to least significant byte
    """
    raise in_range(number, 0, 1 << size * 4) or AssertionError
    return tuple([ number >> offset & 15 for offset in xrange((size - 1) * 4, -1, -4) ])


class PadParameters(NamedTuple):
    """
    Describes the properties of pad parameters.
    """
    off_threshold = 0
    on_threshold = 0
    gain = 0
    curve1 = 0
    curve2 = 0
    name = ''

    def __str__(self):
        return self.name

    @lazy_attribute
    def sysex_bytes(self):
        return to_bytes(self.off_threshold, 4) + to_bytes(self.on_threshold, 4) + to_bytes(self.gain, 8) + to_bytes(self.curve1, 8) + to_bytes(self.curve2, 8)


def pad_parameter_sender(global_control, pad_control):
    """
    Sends the sensitivity parameters for a given pad, or all pads (pad
    == None) over the given ValueControl.
    """

    def do_send(parameters, pad = None):
        if pad != None:
            pad_control.send_value((pad,) + parameters.sysex_bytes)
        else:
            global_control.send_value(parameters.sysex_bytes)

    return do_send


class PadUpdateComponent(ControlSurfaceComponent):
    """
    Sets a set of parameters for different pads.  It keeps a set of
    profiles, and maps a profile to each pad.  It caches all
    modifications to the pad profiles, updating later optimally.
    
    The all_pads parameter contains the pads identifiers.
    
    The parameter_sender is a function that is used to update the
    pads. It takes the parameters as first value and a second optional
    value indicating the pad to update, or None to update all possible
    pads.
    """

    def __init__(self, all_pads = tuple(), parameter_sender = nop, default_profile = PadParameters(), update_delay = 0, *a, **k):
        raise find_if(lambda pad: pad < 0 or pad > 63, all_pads or []) == None or AssertionError
        super(PadUpdateComponent, self).__init__(*a, **k)
        self.parameter_sender = parameter_sender
        self._all_pads = set(all_pads)
        self._modified_pads = set(all_pads)
        self._profiles = {'default': default_profile}
        self._profile_for = dict(zip(all_pads, repeat('default')))
        self._profile_count = {'default': len(all_pads)}
        self._update_task = self._tasks.add(Task.sequence(Task.wait(update_delay), Task.run(self._update_modified)))
        self._update_task.restart()

    def set_profile(self, profile_id, parameters):
        self._profiles[profile_id] = parameters
        self._profile_count.setdefault(profile_id, 0)
        affected = [ k for k, v in self._profile_for.iteritems() if v == profile_id ]
        self._add_modified_pads(affected)

    def get_profile(self, profile_id):
        return self._profiles[profile_id]

    def set_pad(self, pad, new_profile):
        if not pad in self._all_pads:
            raise AssertionError
            raise new_profile in self._profile_count or AssertionError
            old_profile = self._profile_for[pad]
            old_profile != new_profile and self._add_modified_pads([pad])
            self._profile_for[pad] = new_profile
            self._profile_count[old_profile] -= 1
            self._profile_count[new_profile] += 1

    def update(self):
        self._add_modified_pads(self._all_pads)
        self._update_modified()

    def _update_modified(self):
        if not (self.is_enabled() and self._modified_pads and sum(self._profile_count.itervalues()) == len(self._all_pads)):
            raise AssertionError
            largest_profile, largest_count = max(self._profile_count.iteritems(), key=second)
            if len(self._all_pads) - largest_count + 1 < len(self._modified_pads):
                self.parameter_sender(self._profiles[largest_profile])
                for pad in self._all_pads:
                    profile = self._profile_for[pad]
                    if profile != largest_profile:
                        self.parameter_sender(self._profiles[profile], pad)

            else:
                for pad in self._modified_pads:
                    self.parameter_sender(self._profiles[self._profile_for[pad]], pad)

            self._modified_pads.clear()
        self._update_task.kill()

    def _add_modified_pads(self, pads):
        self._modified_pads.update(pads)
        self._update_task.restart()
########NEW FILE########
__FILENAME__ = PlayheadComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/PlayheadComponent.py
from __future__ import with_statement
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.SubjectSlot import subject_slot

class PlayheadComponent(ControlSurfaceComponent):
    """
    Updates the contents of the Live playhead object.
    """

    def __init__(self, paginator = None, grid_resolution = None, follower = None, notes = range(8), triplet_notes = range(6), *a, **k):
        super(PlayheadComponent, self).__init__(*a, **k)
        self._playhead = None
        self._clip = None
        self._paginator = paginator
        self._grid_resolution = grid_resolution
        self._follower = follower
        self._notes = tuple(notes)
        self._triplet_notes = tuple(triplet_notes)
        self._on_page_changed.subject = self._paginator
        self._on_grid_resolution_changed.subject = self._grid_resolution
        self._on_follower_is_following_changed.subject = self._follower

    def set_playhead(self, playhead):
        self._playhead = playhead
        self.update()

    def set_clip(self, clip):
        self._clip = clip
        self._on_playing_status_changed.subject = clip
        self._on_song_is_playing_changed.subject = self.song() if clip else None
        self.update()

    @subject_slot('page')
    def _on_page_changed(self):
        self.update()

    @subject_slot('playing_status')
    def _on_playing_status_changed(self):
        self.update()

    @subject_slot('is_playing')
    def _on_song_is_playing_changed(self):
        self.update()

    @subject_slot('index')
    def _on_grid_resolution_changed(self):
        self.update()

    @subject_slot('is_following')
    def _on_follower_is_following_changed(self, value):
        self.update()

    def update(self):
        if self._playhead:
            if self.is_enabled() and self.song().is_playing and self._clip and self._clip.is_playing:
                clip_slot = self._clip.canonical_parent
                track = clip_slot.canonical_parent if clip_slot else None
            else:
                track = None
            self._playhead.track = track
            if track:
                is_triplet = self._grid_resolution.clip_grid[1]
                notes = self._triplet_notes if is_triplet else self._notes
                self._playhead.notes = list(notes)
                self._playhead.wrap_around = self._follower.is_following and self._paginator.can_change_page
                self._playhead.start_time = self._paginator.page_length * self._paginator.page_index
                self._playhead.step_length = self._paginator.page_length / len(notes)
########NEW FILE########
__FILENAME__ = PlayheadElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/PlayheadElement.py
from _Framework.ControlElement import ControlElement
from _Framework.Proxy import Proxy

class NullPlayhead(object):
    notes = []
    start_time = 0.0
    step_length = 1.0
    velocity = 0.0
    wrap_around = False
    track = None


class ProxyElement(Proxy, ControlElement):

    def reset(self):
        try:
            super(ProxyElement, self).__getattr__('reset')()
        except AttributeError:
            pass


class PlayheadElement(ProxyElement):

    def __init__(self, playhead = None, *a, **k):
        super(PlayheadElement, self).__init__(proxied_object=playhead, proxied_interface=NullPlayhead())

    def reset(self):
        self.track = None
########NEW FILE########
__FILENAME__ = ProviderDeviceComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/ProviderDeviceComponent.py
from _Framework.DeviceComponent import DeviceComponent
from DeviceParameterComponent import ParameterProvider

class ProviderDeviceComponent(ParameterProvider, DeviceComponent):
    """
    Device component that serves as parameter provider for the
    DeviceParameterComponent.
    """
    _provided_parameters = tuple()

    def __init__(self, *a, **k):
        super(ProviderDeviceComponent, self).__init__(*a, **k)
        self.set_parameter_controls([])

    @property
    def parameters(self):
        return self._provided_parameters

    def set_device(self, device):
        super(ProviderDeviceComponent, self).set_device(device)
        self._provided_parameters = self._get_provided_parameters()
        self.notify_parameters()

    def _is_banking_enabled(self):
        return True

    def _assign_parameters(self):
        super(ProviderDeviceComponent, self)._assign_parameters()
        self._provided_parameters = self._get_provided_parameters()
        self.notify_parameters()

    def _get_provided_parameters(self):
        _, parameters = self._current_bank_details() if self._device else (None, ())
        return zip([ (param.name if param else '') for param in parameters ], parameters)
########NEW FILE########
__FILENAME__ = Push
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/Push.py
from __future__ import with_statement
import Live
from contextlib import contextmanager
from functools import partial
from _Framework.Dependency import inject
from _Framework.ButtonElement import ButtonElement
from _Framework.ControlSurface import ControlSurface
from _Framework.ControlElement import OptimizedOwnershipHandler
from _Framework.InputControlElement import MIDI_CC_TYPE, MIDI_NOTE_TYPE
from _Framework.ButtonMatrixElement import ButtonMatrixElement
from _Framework.ModesComponent import AddLayerMode, MultiEntryMode, ModesComponent, SetAttributeMode, CancellableBehaviour, AlternativeBehaviour, ReenterBehaviour, DynamicBehaviourMixin, ExcludingBehaviourMixin, EnablingModesComponent
from _Framework.SysexValueControl import SysexValueControl
from _Framework.Layer import Layer
from _Framework.Resource import PrioritizedResource
from _Framework.DeviceBankRegistry import DeviceBankRegistry
from _Framework.SubjectSlot import subject_slot, subject_slot_group
from _Framework.Util import find_if, clamp, nop, mixin, const, recursive_map, NamedTuple, get_slice
from _Framework.Defaults import TIMER_DELAY
from OptionalElement import OptionalElement, ChoosingElement
from ComboElement import ComboElement, DoublePressElement, MultiElement, DoublePressContext
from HandshakeComponent import HandshakeComponent, make_dongle_message
from ValueComponent import ValueComponent, ParameterValueComponent
from ConfigurableButtonElement import ConfigurableButtonElement, PadButtonElement
from SpecialSessionComponent import SpecialSessionComponent, SpecialSessionZoomingComponent
from SpecialMixerComponent import SpecialMixerComponent
from SpecialTransportComponent import SpecialTransportComponent
from SpecialPhysicalDisplay import SpecialPhysicalDisplay
from MelodicComponent import MelodicComponent
from StepSeqComponent import StepSeqComponent, DrumGroupFinderComponent
from NoteSettingsComponent import NoteEditorSettingsComponent
from GridResolution import GridResolution
from LoopSelectorComponent import LoopSelectorComponent
from ViewControlComponent import ViewControlComponent
from ClipControlComponent import ClipControlComponent
from ProviderDeviceComponent import ProviderDeviceComponent
from DeviceNavigationComponent import DeviceNavigationComponent
from SessionRecordingComponent import SessionRecordingComponent
from SelectedTrackParameterProvider import SelectedTrackParameterProvider
from NoteRepeatComponent import NoteRepeatComponent
from ClipCreator import ClipCreator
from MatrixMaps import PAD_TRANSLATIONS, FEEDBACK_CHANNELS
from BackgroundComponent import BackgroundComponent, ModifierBackgroundComponent
from BrowserComponent import BrowserComponent
from BrowserModes import BrowserHotswapMode
from Actions import CreateInstrumentTrackComponent, CreateDefaultTrackComponent, CaptureAndInsertSceneComponent, DuplicateDetailClipComponent, DuplicateLoopComponent, SelectComponent, DeleteComponent, DeleteSelectedClipComponent, DeleteSelectedSceneComponent, CreateDeviceComponent
from M4LInterfaceComponent import M4LInterfaceComponent
from UserSettingsComponent import UserComponent
from MessageBoxComponent import DialogComponent, NotificationComponent, InfoComponent, align_right
from TouchEncoderElement import TouchEncoderElement
from TouchStripElement import TouchStripElement
from TouchStripController import TouchStripControllerComponent, TouchStripEncoderConnection
from TrackFrozenMode import TrackFrozenModesComponent
from Selection import L9CSelection
from AccentComponent import AccentComponent
from AutoArmComponent import AutoArmComponent
from QuantizationComponent import QuantizationComponent
from WithPriority import WithPriority, Resetting
from Settings import make_pad_parameters, SETTING_WORKFLOW, SETTING_THRESHOLD, SETTING_CURVE
from PadSensitivity import PadUpdateComponent, pad_parameter_sender
from PlayheadElement import PlayheadElement, NullPlayhead
from DeviceParameterComponent import DeviceParameterComponent
from SelectPlayingClipComponent import SelectPlayingClipComponent
import Skin
import consts
import Colors
import Sysex
import Settings
GLOBAL_MAP_MODE = Live.MidiMap.MapMode.relative_smooth_two_compliment

class Push(ControlSurface):
    """
    Push controller script.
    
    Disclaimer: Any use of the Push control surface code (the "Code")
    or parts thereof for commercial purposes or in a commercial context
    is not allowed. Though we do not grant a license for non-commercial
    use of the Code, you may use it in this regard but should be aware that
    (1) we reserve the right to deny the future use any time and
    (2) you need to check whether the use is allowed under the national law
    applicable to your use.
    """

    def __init__(self, c_instance):
        super(Push, self).__init__(c_instance)
        self._optimized_ownership_handler = OptimizedOwnershipHandler()
        self._double_press_context = DoublePressContext()
        injecting = inject(double_press_context=const(self._double_press_context), element_ownership_handler=const(self._optimized_ownership_handler), expect_dialog=const(self.expect_dialog), show_notification=const(self.show_notification), selection=lambda : L9CSelection(application=self.application(), device_component=self._device_parameter_provider, navigation_component=self._device_navigation))
        self._push_injector = injecting.everywhere()
        with self.component_guard():
            self._suppress_sysex = False
            self._skin = Skin.make_default_skin()
            self._clip_creator = ClipCreator()
            self._device_selection_follows_track_selection = True
            self._note_editor_settings = []
            self._create_pad_sensitivity_update()
            self._create_controls()
            self._init_settings()
            self._init_message_box()
            self._init_background()
            self._init_user()
            self._init_touch_strip_controller()
            self._init_accent()
            self._init_transport_and_recording()
            self._init_track_frozen()
            self._init_duplicate_actions()
            self._init_delete_actions()
            self._init_quantize_actions()
            self._init_value_components()
            self._init_mixer()
            self._init_track_mixer()
            self._init_session()
            self._init_grid_resolution()
            self._init_step_sequencer()
            self._init_instrument()
            self._init_scales()
            self._init_note_repeat()
            self._init_matrix_modes()
            self._init_track_modes()
            self._init_device()
            self._init_browser()
            self._init_clip_settings()
            self._init_main_modes()
            self._init_m4l_interface()
            self._init_handshake()
            self.set_pad_translations(PAD_TRANSLATIONS)
            self._on_selected_track_changed()
            self._on_session_record_changed.subject = self.song()
            self._on_session_record_changed()
            self._on_selected_track_is_frozen_changed.subject = self.song().view
            self.set_highlighting_session_component(self._session)
            self.set_feedback_channels(FEEDBACK_CHANNELS)
        self.log_message('Push script loaded')
        self._send_midi(Sysex.WELCOME_MESSAGE)

    def disconnect(self):
        self._pre_serialize()
        with self.component_guard():
            self._user.mode = Sysex.USER_MODE
        super(Push, self).disconnect()
        self._send_midi(Sysex.GOOD_BYE_MESSAGE)
        self.log_message('Push script unloaded')

    @contextmanager
    def component_guard(self):
        with super(Push, self).component_guard():
            with self._push_injector:
                song_view = self.song().view
                old_selected_track = song_view.selected_track
                yield
                if song_view.selected_track != old_selected_track:
                    self._track_selection_changed_by_action()
                self._optimized_ownership_handler.commit_ownership_changes()

    def _track_selection_changed_by_action(self):
        if self._matrix_modes.selected_mode == 'note':
            self._session_recording.deactivate_recording()
        if self._auto_arm.needs_restore_auto_arm:
            self._auto_arm.restore_auto_arm()

    def refresh_state(self):
        super(Push, self).refresh_state()
        if self._user.mode == Sysex.LIVE_MODE:
            self.schedule_message(5, self._start_handshake)

    def _pre_serialize(self):
        """
        This will pre-serialize all settings, as a later access to
        Push's objects might cause problems with Pickle
        """
        from pickle import dumps
        from encodings import ascii
        nop(ascii)
        preferences = self._c_instance.preferences('Push')
        dump = dumps(self._pref_dict)
        preferences.set_serializer(lambda : dump)

    def _init_settings(self):
        from pickle import loads, dumps
        from encodings import ascii
        nop(ascii)
        preferences = self._c_instance.preferences('Push')
        self._pref_dict = {}
        try:
            self._pref_dict = loads(str(preferences))
        except Exception:
            pass

        pref_dict = self._pref_dict
        preferences.set_serializer(lambda : dumps(pref_dict))
        self._settings = Settings.create_settings(preferences=self._pref_dict)
        self._on_pad_curve.subject = self._settings[SETTING_CURVE]
        self._on_pad_threshold.subject = self._settings[SETTING_THRESHOLD]

    def _init_handshake(self):
        dongle_message, dongle = make_dongle_message(Sysex.DONGLE_ENQUIRY_PREFIX)
        identity_control = SysexValueControl(Sysex.IDENTITY_PREFIX, Sysex.IDENTITY_ENQUIRY)
        dongle_control = SysexValueControl(Sysex.DONGLE_PREFIX, dongle_message)
        presentation_control = SysexValueControl(Sysex.DONGLE_PREFIX, Sysex.make_presentation_message(self.application()))
        self._handshake = HandshakeComponent(identity_control=identity_control, dongle_control=dongle_control, presentation_control=presentation_control, dongle=dongle)
        self._on_handshake_success.subject = self._handshake
        self._on_handshake_failure.subject = self._handshake

    def _start_handshake(self):
        self._playhead_element.proxied_object = self._c_instance.playhead
        self._note_repeat.set_note_repeat(self._c_instance.note_repeat)
        self._accent_component.set_full_velocity(self._c_instance.full_velocity)
        for control in self.controls:
            receive_value_backup = getattr(control, '_receive_value_backup', nop)
            if receive_value_backup != nop:
                control.receive_value = receive_value_backup
            send_midi_backup = getattr(control, '_send_midi_backup', nop)
            if send_midi_backup != nop:
                control.send_midi = send_midi_backup

        self._handshake._start_handshake()
        self.update()

    def update(self):
        self._on_session_record_changed()
        self.reset_controlled_track()
        self.set_feedback_channels(FEEDBACK_CHANNELS)
        self._update_calibration()
        super(Push, self).update()

    @subject_slot('success')
    def _on_handshake_success(self):
        self.log_message('Handshake succeded with firmware version %.2f!' % self._handshake.firmware_version)
        self.update()
        self._c_instance.set_firmware_version(self._handshake.firmware_version)

    @subject_slot('failure')
    def _on_handshake_failure(self, bootloader_mode):
        self.log_message('Handshake failed, performing harakiri!')
        if bootloader_mode:
            self._c_instance.set_firmware_version(0.0)
        self._c_instance.playhead.enabled = False
        self._playhead_element.proxied_object = NullPlayhead()
        self._note_repeat.set_note_repeat(None)
        self._accent_component.set_full_velocity(None)
        for control in self.controls:
            receive_value_backup = getattr(control, 'receive_value', nop)
            send_midi_backup = getattr(control, 'send_midi', nop)
            try:
                control.receive_value = nop
                if receive_value_backup != nop:
                    control._receive_value_backup = receive_value_backup
                control.send_midi = nop
                if send_midi_backup != nop:
                    control._send_midi_backup = send_midi_backup
            except AttributeError:
                pass

    def _update_calibration(self):
        self._send_midi(Sysex.CALIBRATION_SET)

    def _create_pad_sensitivity_update(self):
        all_pad_sysex_control = SysexValueControl(Sysex.ALL_PADS_SENSITIVITY_PREFIX)
        pad_sysex_control = SysexValueControl(Sysex.PAD_SENSITIVITY_PREFIX)
        sensitivity_sender = pad_parameter_sender(all_pad_sysex_control, pad_sysex_control)
        self._pad_sensitivity_update = PadUpdateComponent(all_pads=range(64), parameter_sender=sensitivity_sender, default_profile=Settings.action_pad_sensitivity, update_delay=TIMER_DELAY)

    def _create_controls(self):
        is_momentary = True

        def create_button(note, name, **k):
            button = ConfigurableButtonElement(is_momentary, MIDI_CC_TYPE, 0, note, name=name, skin=self._skin, **k)
            return button

        def create_modifier_button(note, name, **k):
            button = create_button(note, name, resource_type=PrioritizedResource, **k)
            return button

        undo_handler = self.song()
        self._foot_pedal_button = DoublePressElement(create_button(69, 'Foot_Pedal'))
        self._nav_up_button = create_button(46, 'Up_Arrow')
        self._nav_down_button = create_button(47, 'Down_Arrow')
        self._nav_left_button = create_button(44, 'Left_Arrow')
        self._nav_right_button = create_button(45, 'Right_Arrow')
        self._nav_up_button.default_states = consts.SCROLL_SIDE_BUTTON_STATES
        self._nav_down_button.default_states = consts.SCROLL_SIDE_BUTTON_STATES
        self._nav_left_button.default_states = consts.SCROLL_SIDE_BUTTON_STATES
        self._nav_right_button.default_states = consts.SCROLL_SIDE_BUTTON_STATES
        self._shift_button = create_modifier_button(49, 'Shift_Button')
        self._select_button = create_modifier_button(48, 'Select_Button')
        self._delete_button = create_modifier_button(118, 'Delete_Button', undo_step_handler=undo_handler)
        self._duplicate_button = create_modifier_button(88, 'Duplicate_Button', undo_step_handler=undo_handler)
        self._quantize_button = create_modifier_button(116, 'Quantization_Button', undo_step_handler=undo_handler)
        self._accent_button = create_modifier_button(57, 'Accent_Button')
        self._in_button = create_button(62, 'In_Button')
        self._out_button = create_button(63, 'Out_Button')
        self._master_select_button = create_button(28, 'Master_Select_Button')
        self._octave_down_button = create_button(54, 'Octave_Down_Button')
        self._octave_up_button = create_button(55, 'Octave_Up_Button')
        self._repeat_button = create_button(56, 'Repeat_Button')
        self._octave_up_button.default_states = consts.SCROLL_SIDE_BUTTON_STATES
        self._octave_down_button.default_states = consts.SCROLL_SIDE_BUTTON_STATES
        self._global_mute_button = create_modifier_button(60, 'Global_Mute_Button')
        self._global_solo_button = create_modifier_button(61, 'Global_Solo_Button')
        self._global_track_stop_button = create_modifier_button(29, 'Track_Stop_Button')
        self._scale_presets_button = create_button(58, 'Scale_Presets_Button')
        self._vol_mix_mode_button = create_button(114, 'Vol_Mix_Mode_Button')
        self._device_mode_button = create_button(110, 'Device_Mode_Button')
        self._clip_mode_button = create_button(113, 'Clip_Mode_Button')
        self._browse_mode_button = create_button(111, 'Browse_Mode_Button')
        self._single_track_mix_mode_button = create_button(112, 'Single_Track_Mode_Button')
        self._pan_send_mix_mode_button = create_button(115, 'Pan_Send_Mode_Button', resource_type=PrioritizedResource)
        self._note_mode_button = create_button(50, 'Note_Mode_Button')
        self._session_mode_button = create_button(51, 'Session_Mode_Button')
        self._play_button = create_button(85, 'Play_Button')
        self._new_button = create_button(87, 'New_Button')
        self._automation_button = create_button(89, 'Automation_Button')
        self._tap_tempo_button = create_button(3, 'Tap_Tempo_Button')
        self._metronome_button = create_button(9, 'Metronome_Button')
        self._fixed_length_button = create_button(90, 'Fixed_Length_Button')
        self._record_button = create_button(86, 'Record_Button')
        self._undo_button = create_button(119, 'Undo_Button')
        self._create_device_button = create_button(52, 'Create_Device_Button', undo_step_handler=undo_handler)
        self._create_track_button = create_button(53, 'Create_Track_Button', undo_step_handler=undo_handler)
        self._double_button = create_button(117, 'Double_Button', undo_step_handler=undo_handler)
        self._user_button = create_button(59, 'User_Button', undo_step_handler=undo_handler)
        self._select_buttons = ButtonMatrixElement(name='Track_Select_Buttons', rows=[[ create_button(20 + idx, 'Track_Select_Button' + str(idx)) for idx in xrange(8) ]])
        self._track_state_buttons = ButtonMatrixElement(name='Track_State_Buttons', rows=[[ create_button(102 + idx, 'Track_State_Button' + str(idx), is_rgb=True) for idx in xrange(8) ]])
        self._side_buttons = ButtonMatrixElement(name='Scene_Launch_Buttons', rows=[[ create_button(36 + idx, 'Scene_Launch_Button' + str(idx), default_states={True: 'Session.SceneSelected',
          False: 'Session.SceneUnselected'}) for idx in reversed(xrange(8)) ]])

        def create_display_line(clear_cmd, write_cmd, index):
            line = SpecialPhysicalDisplay(consts.DISPLAY_LENGTH, 1)
            line.set_clear_all_message(clear_cmd)
            line.set_message_parts(write_cmd, (247,))
            line.name = 'Display_Line_%d' % index
            line.reset()
            return line

        self._display_line1 = create_display_line(Sysex.CLEAR_LINE1, Sysex.WRITE_LINE1, 0)
        self._display_line2 = create_display_line(Sysex.CLEAR_LINE2, Sysex.WRITE_LINE2, 1)
        self._display_line3 = create_display_line(Sysex.CLEAR_LINE3, Sysex.WRITE_LINE3, 2)
        self._display_line4 = create_display_line(Sysex.CLEAR_LINE4, Sysex.WRITE_LINE4, 3)
        self._display_lines = [self._display_line1,
         self._display_line2,
         self._display_line3,
         self._display_line4]

        def create_pad_button(pad_id, name, **k):
            return PadButtonElement(pad_id, self._pad_sensitivity_update, is_momentary, MIDI_NOTE_TYPE, 0, (36 + pad_id), skin=self._skin, name=name, **k)

        matrix_rows = [ [ create_pad_button((7 - row) * 8 + column, str(column) + '_Clip_' + str(row) + '_Button', is_rgb=True, default_states={True: 'DefaultMatrix.On',
         False: 'DefaultMatrix.Off'}) for column in xrange(8) ] for row in xrange(8) ]
        double_press_rows = recursive_map(DoublePressElement, matrix_rows)
        self._matrix = ButtonMatrixElement(name='Button_Matrix', rows=matrix_rows)
        self._double_press_matrix = ButtonMatrixElement(name='Double_Press_Matrix', rows=double_press_rows)
        self._single_press_event_matrix = ButtonMatrixElement(name='Single_Press_Event_Matrix', rows=recursive_map(lambda x: x.single_press, double_press_rows))
        self._double_press_event_matrix = ButtonMatrixElement(name='Double_Press_Event_Matrix', rows=recursive_map(lambda x: x.double_press, double_press_rows))

        def create_note_button(note, name, **k):
            return ConfigurableButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, note, skin=self._skin, name=name, **k)

        self._touch_strip_tap = create_note_button(12, 'Touch_Strip_Tap')
        self._touch_strip_control = TouchStripElement(name='Touch_Strip_Control', touch_button=self._touch_strip_tap)
        self._touch_strip_control.set_feedback_delay(-1)
        self._touch_strip_control.set_needs_takeover(False)

        class Deleter(object):

            @property
            def is_deleting(_):
                return self._delete_component.is_deleting

            def delete_clip_envelope(_, param):
                return self._delete_component.delete_clip_envelope(param)

        deleter = Deleter()
        self._tempo_control_tap = create_note_button(10, 'Tempo_Control_Tap')
        self._tempo_control = TouchEncoderElement(MIDI_CC_TYPE, 0, 14, GLOBAL_MAP_MODE, name='Tempo_Control', undo_step_handler=self.song(), delete_handler=deleter, encoder_sensitivity=consts.ENCODER_SENSITIVITY, touch_button=self._tempo_control_tap)
        self._swing_control_tap = create_note_button(9, 'Swing_Control_Tap')
        self._swing_control = TouchEncoderElement(MIDI_CC_TYPE, 0, 15, GLOBAL_MAP_MODE, name='Swing_Control', undo_step_handler=self.song(), delete_handler=deleter, encoder_sensitivity=consts.ENCODER_SENSITIVITY, touch_button=self._swing_control_tap)
        self._master_volume_control_tap = create_note_button(8, 'Master_Volume_Tap')
        self._master_volume_control = TouchEncoderElement(MIDI_CC_TYPE, 0, 79, GLOBAL_MAP_MODE, undo_step_handler=self.song(), delete_handler=deleter, name='Master_Volume_Control', encoder_sensitivity=consts.ENCODER_SENSITIVITY, touch_button=self._master_volume_control_tap)
        self._global_param_touch_buttons_raw = [ create_note_button(index, 'Track_Control_Touch_' + str(index)) for index in range(8) ]
        self._global_param_touch_buttons = ButtonMatrixElement(name='Track_Control_Touches', rows=[self._global_param_touch_buttons_raw])
        self._global_param_controls = ButtonMatrixElement(name='Track_Controls', rows=[[ TouchEncoderElement(MIDI_CC_TYPE, 0, 71 + index, GLOBAL_MAP_MODE, undo_step_handler=self.song(), delete_handler=deleter, encoder_sensitivity=consts.ENCODER_SENSITIVITY, name='Track_Control_' + str(index), touch_button=self._global_param_touch_buttons_raw[index]) for index in xrange(8) ]])
        self._on_param_encoder_touched.replace_subjects(self._global_param_touch_buttons_raw)
        self._aftertouch_control = SysexValueControl(Sysex.SET_AFTERTOUCH_MODE, default_value=Sysex.POLY_AFTERTOUCH)
        self._any_touch_button = MultiElement(*self._global_param_touch_buttons.nested_control_elements())
        self._playhead_element = PlayheadElement(self._c_instance.playhead)

    def _init_background(self):
        self._background = BackgroundComponent()
        self._background.layer = Layer(display_line1=self._display_line1, display_line2=self._display_line2, display_line3=self._display_line3, display_line4=self._display_line4, top_buttons=self._select_buttons, bottom_buttons=self._track_state_buttons, scales_button=self._scale_presets_button, octave_up=self._octave_up_button, octave_down=self._octave_down_button, side_buttons=self._side_buttons, repeat_button=self._repeat_button, accent_button=self._accent_button, double_button=self._double_button, in_button=self._in_button, out_button=self._out_button, param_controls=self._global_param_controls, param_touch=self._global_param_touch_buttons, tempo_control_tap=self._tempo_control_tap, master_control_tap=self._master_volume_control_tap, touch_strip=self._touch_strip_control, touch_strip_tap=self._touch_strip_tap, nav_up_button=self._nav_up_button, nav_down_button=self._nav_down_button, nav_left_button=self._nav_left_button, nav_right_button=self._nav_right_button, aftertouch=self._aftertouch_control, _notification=self._notification.use_single_line(2))
        self._background.layer.priority = consts.BACKGROUND_PRIORITY
        self._matrix_background = BackgroundComponent()
        self._matrix_background.set_enabled(False)
        self._matrix_background.layer = Layer(matrix=self._matrix)
        self._mod_background = ModifierBackgroundComponent()
        self._mod_background.layer = Layer(shift_button=self._shift_button, select_button=self._select_button, delete_button=self._delete_button, duplicate_button=self._duplicate_button, quantize_button=self._quantize_button)

    def _can_auto_arm_track(self, track):
        routing = track.current_input_routing
        return routing == 'Ext: All Ins' or routing == 'All Ins' or routing.startswith('Push Input')

    def _init_touch_strip_controller(self):
        strip_controller = TouchStripControllerComponent()
        strip_controller.set_enabled(False)
        strip_controller.layer = Layer(touch_strip=self._touch_strip_control)
        strip_controller.layer.priority = consts.MODAL_DIALOG_PRIORITY
        self._strip_connection = TouchStripEncoderConnection(strip_controller, self._touch_strip_tap)
        self._tempo_control.set_observer(self._strip_connection)
        self._swing_control.set_observer(self._strip_connection)
        self._master_volume_control.set_observer(self._strip_connection)
        for encoder in self._global_param_controls.nested_control_elements():
            encoder.set_observer(self._strip_connection)

    def _init_matrix_modes(self):
        self._auto_arm = AutoArmComponent(name='Auto_Arm')
        self._auto_arm.can_auto_arm_track = self._can_auto_arm_track
        self._auto_arm.notification_layer = Layer(display_line1=self._display_line3)
        self._auto_arm.notification_layer.priority = consts.NOTIFICATION_PRIORITY
        self._select_playing_clip = SelectPlayingClipComponent(name='Select_Playing_Clip', playing_clip_above_layer=Layer(action_button=self._nav_up_button), playing_clip_below_layer=Layer(action_button=self._nav_down_button))
        self._select_playing_clip.notification_layer = Layer(display_line1=self._display_line3)
        self._select_playing_clip.notification_layer.priority = consts.NOTIFICATION_PRIORITY
        self._drum_group_finder = DrumGroupFinderComponent()
        self._on_drum_group_changed.subject = self._drum_group_finder
        self._note_modes = ModesComponent(name='Note_Modes')
        self._note_modes.add_mode('sequencer', [self._note_repeat_enabler, self._accent_component, self._step_sequencer])
        self._note_modes.add_mode('looper', self._audio_loop if consts.PROTO_AUDIO_NOTE_MODE else self._matrix_background)
        self._note_modes.add_mode('instrument', [self._note_repeat_enabler, self._accent_component, self._instrument])
        self._note_modes.add_mode('disabled', self._matrix_background)
        self._note_modes.selected_mode = 'disabled'
        self._note_modes.set_enabled(False)

        def switch_note_mode_layout():
            if self._note_modes.selected_mode == 'instrument':
                getattr(self._instrument, 'cycle_mode', nop)()

        self._matrix_modes = ModesComponent(name='Matrix_Modes')
        self._matrix_modes.add_mode('session', [(self._zooming, self._zooming_layer), (self._session, self._session_layer), AddLayerMode(self._session, self._restricted_session_layer)])
        self._matrix_modes.add_mode('note', [self._drum_group_finder,
         self._view_control,
         self._note_modes,
         self._delete_clip,
         self._select_playing_clip,
         (self._session, self._restricted_session_layer)], behaviour=self._auto_arm.auto_arm_restore_behaviour(ReenterBehaviour, on_reenter=switch_note_mode_layout))
        self._matrix_modes.selected_mode = 'note'
        self._matrix_modes.layer = Layer(session_button=self._session_mode_button, note_button=self._note_mode_button)
        self._on_matrix_mode_changed.subject = self._matrix_modes
        self._matrix_modes.selected_mode = 'note'

    def _init_accent(self):
        self._accent_component = AccentComponent()
        self._accent_component.set_full_velocity(self._c_instance.full_velocity)
        self._accent_component.set_enabled(False)
        self._accent_component.layer = Layer(toggle_button=self._accent_button)
        self._on_accent_mode_changed.subject = self._accent_component

    def _init_user(self):
        sysex_control = SysexValueControl(Sysex.MODE_CHANGE)
        self._user = UserComponent(value_control=sysex_control)
        self._user.layer = Layer(action_button=self._user_button)
        self._user.settings_layer = Layer(display_line1=self._display_line1, display_line2=self._display_line2, display_line3=self._display_line3, display_line4=self._display_line4, encoders=self._global_param_controls)
        self._user.settings_layer.priority = consts.DIALOG_PRIORITY
        self._user.settings = self._settings
        self._on_hardware_mode_changed.subject = self._user
        self._on_before_hardware_mode_sent.subject = self._user
        self._on_after_hardware_mode_sent.subject = self._user
        self._update_pad_params()

    def _init_session(self):
        self._session = SpecialSessionComponent(8, 8, name='Session_Control')
        self._session.set_mixer(self._mixer)
        for scene_index in xrange(8):
            scene = self._session.scene(scene_index)
            scene.set_triggered_value(self._skin['Session.SceneTriggered'])
            scene.name = 'Scene_' + str(scene_index)
            scene.layer = Layer(select_button=self._select_button, delete_button=self._delete_button)
            scene._do_select_scene = self._selector.on_select_scene
            for track_index in xrange(8):
                clip_slot = scene.clip_slot(track_index)
                clip_slot.name = str(track_index) + '_Clip_Slot_' + str(scene_index)
                clip_slot.set_triggered_to_play_value('Session.ClipTriggeredPlay')
                clip_slot.set_triggered_to_record_value('Session.ClipTriggeredRecord')
                clip_slot.set_clip_palette(Colors.CLIP_COLOR_TABLE)
                clip_slot.set_clip_rgb_table(Colors.RGB_COLOR_TABLE)
                clip_slot.set_record_button_value('Session.RecordButton')
                clip_slot.set_started_value('Session.ClipStarted')
                clip_slot.set_recording_value('Session.ClipRecording')
                clip_slot._do_select_clip = self._selector.on_select_clip
                clip_slot.layer = Layer(delete_button=self._delete_button, select_button=self._select_button, duplicate_button=self._duplicate_button)

        self._session_layer = Layer(page_up_button=self._octave_up_button, page_down_button=self._octave_down_button, track_bank_left_button=self._nav_left_button, track_bank_right_button=self._nav_right_button, scene_bank_up_button=self._nav_up_button, scene_bank_down_button=self._nav_down_button, clip_launch_buttons=self._matrix, scene_launch_buttons=self._side_buttons, duplicate_button=self._duplicate_button)
        self._restricted_session_layer = Layer(stop_all_clips_button=ComboElement(self._global_track_stop_button, [self._shift_button]))
        self._session_stop_track_layer = Layer(stop_track_clip_buttons=self._track_state_buttons)
        self._session.duplicate_layer = Layer(scene_buttons=self._side_buttons)
        self._zooming = SpecialSessionZoomingComponent(self._session, name='Session_Overview')
        self._zooming.set_enabled(False)
        self._zooming.set_stopped_value(self._skin['Zooming.Stopped'])
        self._zooming.set_selected_value(self._skin['Zooming.Selected'])
        self._zooming.set_playing_value(self._skin['Zooming.Playing'])
        self._zooming.set_empty_value(self._skin['Zooming.Empty'])
        self._zooming_layer = Layer(button_matrix=self._matrix, zoom_button=self._shift_button, nav_up_button=self._nav_up_button, nav_down_button=self._nav_down_button, nav_left_button=self._nav_left_button, nav_right_button=self._nav_right_button)
        self._session.set_enabled(True)
        self._zooming.set_enabled(True)

    def _init_track_modes(self):
        self._track_modes = ModesComponent(name='Track_Modes')
        self._track_modes.set_enabled(False)
        self._track_modes.add_mode('stop', AddLayerMode(self._session, self._session_stop_track_layer))
        self._track_modes.add_mode('solo', AddLayerMode(self._mixer, self._mixer_solo_layer))
        self._track_modes.add_mode('mute', AddLayerMode(self._mixer, self._mixer_mute_layer))
        self._track_modes.layer = Layer(stop_button=self._global_track_stop_button, mute_button=self._global_mute_button, solo_button=self._global_solo_button, shift_button=self._shift_button)
        self._track_modes.selected_mode = 'mute'

    def _init_main_modes(self):

        def configure_note_editor_settings(parameter_provider, mode):
            for note_editor_setting in self._note_editor_settings:
                note_editor_setting.component.parameter_provider = parameter_provider
                note_editor_setting.component.automation_layer = getattr(note_editor_setting, mode + '_automation_layer')

        def when_track_is_not_frozen(*modes):
            return TrackFrozenModesComponent(default_mode=[modes], frozen_mode=self._track_frozen_info, is_enabled=False)

        track_note_editor_mode = partial(configure_note_editor_settings, self._track_parameter_provider, 'track')
        device_note_editor_mode = partial(configure_note_editor_settings, self._device_parameter_provider, 'device')
        enable_stop_mute_solo_as_modifiers = AddLayerMode(self._mod_background, Layer(stop=self._global_track_stop_button, mute=self._global_mute_button, solo=self._global_solo_button))
        self._main_modes = ModesComponent()
        self._main_modes.add_mode('volumes', [self._track_modes, (self._mixer, self._mixer_volume_layer), track_note_editor_mode])
        self._main_modes.add_mode('pan_sends', [self._track_modes, (self._mixer, self._mixer_pan_send_layer), track_note_editor_mode])
        self._main_modes.add_mode('track', [self._track_modes,
         self._track_mixer,
         (self._mixer, self._mixer_track_layer),
         track_note_editor_mode])
        self._main_modes.add_mode('clip', [self._track_modes, (self._mixer, self._mixer_layer), when_track_is_not_frozen(partial(self._view_control.show_view, 'Detail/Clip'), self._clip_control)])
        self._main_modes.add_mode('device', [when_track_is_not_frozen(enable_stop_mute_solo_as_modifiers, partial(self._view_control.show_view, 'Detail/DeviceChain'), self._device_parameter_component, self._device_navigation, device_note_editor_mode)], behaviour=ReenterBehaviour(self._device_navigation.back_to_top))
        self._main_modes.add_mode('browse', [when_track_is_not_frozen(enable_stop_mute_solo_as_modifiers, partial(self._view_control.show_view, 'Browser'), self._browser.back_to_top, self._browser_hotswap_mode, self._browser_mode, self._browser.reset_load_memory)], groups=['add_effect', 'add_track', 'browse'], behaviour=mixin(DynamicBehaviourMixin, CancellableBehaviour)(lambda : not self._browser_hotswap_mode._mode.can_hotswap() and 'add_effect_left'))
        self._main_modes.add_mode('add_effect_right', [when_track_is_not_frozen(enable_stop_mute_solo_as_modifiers, self._browser.back_to_top, self._create_device_right)], behaviour=mixin(ExcludingBehaviourMixin, CancellableBehaviour)(['add_track', 'browse']), groups=['add_effect'])
        self._main_modes.add_mode('add_effect_left', [when_track_is_not_frozen(enable_stop_mute_solo_as_modifiers, self._browser.back_to_top, self._create_device_left)], behaviour=mixin(ExcludingBehaviourMixin, CancellableBehaviour)(['add_track', 'browse']), groups=['add_effect'])
        self._main_modes.add_mode('add_instrument_track', [enable_stop_mute_solo_as_modifiers, self._browser.back_to_top, self._create_instrument_track], behaviour=mixin(ExcludingBehaviourMixin, AlternativeBehaviour)(excluded_groups=['browse', 'add_effect'], alternative_mode='add_default_track'), groups=['add_track'])
        self._main_modes.add_mode('add_default_track', [enable_stop_mute_solo_as_modifiers, self._browser.back_to_top, self._create_default_track], groups=['add_track'])
        self._main_modes.selected_mode = 'device'
        self._main_modes.layer = Layer(volumes_button=self._vol_mix_mode_button, pan_sends_button=self._pan_send_mix_mode_button, track_button=self._single_track_mix_mode_button, clip_button=self._clip_mode_button, device_button=self._device_mode_button, browse_button=self._browse_mode_button, add_effect_right_button=self._create_device_button, add_effect_left_button=ComboElement(self._create_device_button, [self._shift_button]), add_instrument_track_button=self._create_track_button)
        self._on_main_mode_button_value.replace_subjects([self._vol_mix_mode_button,
         self._pan_send_mix_mode_button,
         self._single_track_mix_mode_button,
         self._clip_mode_button,
         self._device_mode_button,
         self._browse_mode_button])

    @subject_slot_group('value')
    def _on_main_mode_button_value(self, value, sender):
        if value:
            self._instrument.scales_menu.selected_mode = 'disabled'

    def _init_track_frozen(self):
        self._track_frozen_info = InfoComponent(info_text=consts.MessageBoxText.TRACK_FROZEN_INFO, is_enabled=False, layer=Layer(display=self._display_line2, _notification=self._notification.use_full_display(1)))

    def _init_mixer(self):
        self._mixer = SpecialMixerComponent(self._matrix.width())
        self._mixer.set_enabled(False)
        self._mixer.name = 'Mixer'
        self._mixer_layer = Layer(track_names_display=self._display_line4, track_select_buttons=self._select_buttons)
        self._mixer_pan_send_layer = Layer(track_names_display=self._display_line4, track_select_buttons=self._select_buttons, pan_send_toggle=self._pan_send_mix_mode_button, pan_send_controls=self._global_param_controls, pan_send_names_display=self._display_line1, pan_send_graphics_display=self._display_line2, selected_track_name_display=self._display_line3, pan_send_values_display=ComboElement(self._display_line3, [self._any_touch_button]))
        self._mixer_volume_layer = Layer(track_names_display=self._display_line4, track_select_buttons=self._select_buttons, volume_controls=self._global_param_controls, volume_names_display=self._display_line1, volume_graphics_display=self._display_line2, selected_track_name_display=self._display_line3, volume_values_display=ComboElement(self._display_line3, [self._any_touch_button]))
        self._mixer_track_layer = Layer(selected_track_name_display=self._display_line3, track_names_display=self._display_line4, track_select_buttons=self._select_buttons)
        self._mixer_solo_layer = Layer(solo_buttons=self._track_state_buttons)
        self._mixer_mute_layer = Layer(mute_buttons=self._track_state_buttons)
        for track in xrange(self._matrix.width()):
            strip = self._mixer.channel_strip(track)
            strip.name = 'Channel_Strip_' + str(track)
            strip.set_invert_mute_feedback(True)
            strip.set_delete_handler(self._delete_component)
            strip._do_select_track = self._selector.on_select_track
            strip.layer = Layer(shift_button=self._shift_button, duplicate_button=self._duplicate_button, selector_button=self._select_button)

        self._mixer.selected_strip().name = 'Selected_Channel_strip'
        self._mixer.master_strip().name = 'Master_Channel_strip'
        self._mixer.master_strip()._do_select_track = self._selector.on_select_track
        self._mixer.master_strip().layer = Layer(volume_control=self._master_volume_control, cue_volume_control=ComboElement(self._master_volume_control, [self._shift_button]), select_button=self._master_select_button, selector_button=self._select_button)
        self._mixer.set_enabled(True)

    def _init_track_mixer(self):
        self._track_parameter_provider = self.register_disconnectable(SelectedTrackParameterProvider())
        self._track_mixer = DeviceParameterComponent(parameter_provider=self._track_parameter_provider, is_enabled=False, layer=Layer(parameter_controls=self._global_param_controls, name_display_line=self._display_line1, graphic_display_line=self._display_line2, value_display_line=ComboElement(self._display_line3, [self._any_touch_button])))

    def _init_device(self):
        self._device_bank_registry = DeviceBankRegistry()
        self._device_parameter_provider = ProviderDeviceComponent(device_bank_registry=self._device_bank_registry, name='DeviceComponent', is_enabled=True)
        self.set_device_component(self._device_parameter_provider)
        self._device_parameter_component = DeviceParameterComponent(parameter_provider=self._device_parameter_provider, is_enabled=False, layer=Layer(parameter_controls=self._global_param_controls, name_display_line=self._display_line1, value_display_line=self._display_line2, graphic_display_line=ComboElement(self._display_line3, [self._any_touch_button])))
        self._device_navigation = DeviceNavigationComponent(device_bank_registry=self._device_bank_registry, is_enabled=False, layer=Layer(enter_button=self._in_button, exit_button=self._out_button, select_buttons=self._select_buttons, state_buttons=self._track_state_buttons, display_line=self._display_line4, _notification=self._notification.use_single_line(2)), info_layer=Layer(display_line1=self._display_line1, display_line2=self._display_line2, display_line3=self._display_line3, display_line4=self._display_line4, _notification=self._notification.use_full_display(2)), delete_handler=self._delete_component)

    def _init_transport_and_recording(self):
        self._view_control = ViewControlComponent(name='View_Control')
        self._view_control.set_enabled(False)
        self._view_control.layer = Layer(prev_track_button=self._nav_left_button, next_track_button=self._nav_right_button, prev_scene_button=OptionalElement(self._nav_up_button, self._settings[SETTING_WORKFLOW], False), next_scene_button=OptionalElement(self._nav_down_button, self._settings[SETTING_WORKFLOW], False), prev_scene_list_button=OptionalElement(self._nav_up_button, self._settings[SETTING_WORKFLOW], True), next_scene_list_button=OptionalElement(self._nav_down_button, self._settings[SETTING_WORKFLOW], True))
        self._session_recording = SessionRecordingComponent(self._clip_creator, self._view_control, name='Session_Recording')
        new_button = MultiElement(self._new_button, self._foot_pedal_button.double_press)
        record_button = MultiElement(self._record_button, self._foot_pedal_button.single_press)
        self._session_recording.layer = Layer(new_button=OptionalElement(new_button, self._settings[SETTING_WORKFLOW], False), scene_list_new_button=OptionalElement(new_button, self._settings[SETTING_WORKFLOW], True), record_button=record_button, automation_button=self._automation_button, new_scene_button=ComboElement(self._new_button, [self._shift_button]), re_enable_automation_button=ComboElement(self._automation_button, [self._shift_button]), delete_automation_button=ComboElement(self._automation_button, [self._delete_button]), length_button=self._fixed_length_button, _uses_foot_pedal=self._foot_pedal_button)
        self._session_recording.length_layer = Layer(display_line=self._display_line4, label_display_line=self._display_line3, blank_display_line2=self._display_line2, blank_display_line1=self._display_line1, select_buttons=self._select_buttons, state_buttons=self._track_state_buttons, _notification=self._notification.use_single_line(1))
        self._session_recording.length_layer.priority = consts.DIALOG_PRIORITY
        self._transport = SpecialTransportComponent(name='Transport')
        self._transport.layer = Layer(shift_button=self._shift_button, play_button=self._play_button, tap_tempo_button=self._tap_tempo_button, metronome_button=self._metronome_button, tempo_encoder=self._tempo_control, undo_button=self._undo_button)

    def _init_clip_settings(self):
        self._clip_control = ClipControlComponent(loop_layer=Layer(encoders=self._global_param_controls.submatrix[:4, :], shift_button=self._shift_button, name_display=self._display_line1.subdisplay[:36], value_display=self._display_line2.subdisplay[:36]), audio_layer=Layer(encoders=self._global_param_controls.submatrix[4:, :], shift_button=self._shift_button, name_display=self._display_line1.subdisplay[36:], value_display=self._display_line2.subdisplay[36:]), clip_name_layer=Layer(display=self._display_line3), name='Clip_Control', is_enabled=False)

    def _init_browser(self):
        self._browser_hotswap_mode = MultiEntryMode(BrowserHotswapMode(application=self.application()))
        self._browser = BrowserComponent(name='Browser')
        self._browser.set_enabled(False)
        self._browser.layer = Layer(encoder_controls=self._global_param_controls, display_line1=self._display_line1, display_line2=self._display_line2, display_line3=self._display_line3, display_line4=self._display_line4, select_buttons=self._select_buttons, state_buttons=self._track_state_buttons, enter_button=self._in_button, exit_button=self._out_button, shift_button=WithPriority(consts.SHARED_PRIORITY, self._shift_button), _notification=self._notification.use_full_display(2))
        self._browser.layer.priority = consts.BROWSER_PRIORITY
        self._browser_mode = MultiEntryMode(self._browser)
        self._browser_dialog_mode = MultiEntryMode([SetAttributeMode(self._browser.layer, 'priority', consts.MODAL_DIALOG_PRIORITY), self._browser_mode])
        self._create_device_right = CreateDeviceComponent(name='Create_Device_Right', browser_component=self._browser, browser_mode=self._browser_dialog_mode, browser_hotswap_mode=self._browser_hotswap_mode, insert_left=False)
        self._create_device_right.set_enabled(False)
        self._create_device_left = CreateDeviceComponent(name='Create_Device_Right', browser_component=self._browser, browser_mode=self._browser_dialog_mode, browser_hotswap_mode=self._browser_hotswap_mode, insert_left=True)
        self._create_device_left.set_enabled(False)
        self._create_default_track = CreateDefaultTrackComponent(name='Create_Default_Track')
        self._create_default_track.options.layer = Layer(display_line=self._display_line4, label_display_line=self._display_line3, blank_display_line2=self._display_line2, blank_display_line1=self._display_line1, select_buttons=self._select_buttons, state_buttons=self._track_state_buttons)
        self._create_default_track.options.layer.priority = consts.MODAL_DIALOG_PRIORITY
        self._create_default_track.set_enabled(False)
        self._create_instrument_track = CreateInstrumentTrackComponent(name='Create_Instrument_Track', browser_component=self._browser, browser_mode=self._browser_dialog_mode, browser_hotswap_mode=self._browser_hotswap_mode)
        self._create_instrument_track.set_enabled(False)
        self._on_browse_mode_changed.subject = self.application().view

    @subject_slot('browse_mode')
    def _on_browse_mode_changed(self):
        if not self.application().browser.hotswap_target:
            if self._main_modes.selected_mode == 'browse' or self._browser_hotswap_mode.is_entered:
                self._main_modes.selected_mode = 'device'

    def _init_grid_resolution(self):
        self._grid_resolution = self.register_disconnectable(GridResolution())

    def _add_note_editor_setting(self):
        note_editor_settings = NoteEditorSettingsComponent(self._grid_resolution, Layer(initial_encoders=self._global_param_controls, priority=consts.MODAL_DIALOG_PRIORITY), Layer(encoders=self._global_param_controls, priority=consts.MODAL_DIALOG_PRIORITY))
        note_editor_settings.settings.layer = Layer(top_display_line=self._display_line1, bottom_display_line=self._display_line2, info_display_line=self._display_line3, clear_display_line=self._display_line4, full_velocity_button=self._accent_button, priority=consts.MODAL_DIALOG_PRIORITY)
        note_editor_settings.mode_selector_layer = Layer(select_buttons=self._select_buttons, state_buttons=self._track_state_buttons, display_line=self._display_line4, priority=consts.MODAL_DIALOG_PRIORITY)
        self._note_editor_settings.append(NamedTuple(component=note_editor_settings, track_automation_layer=Layer(name_display_line=self._display_line1, graphic_display_line=self._display_line2, value_display_line=self._display_line3, priority=consts.MODAL_DIALOG_PRIORITY), device_automation_layer=Layer(name_display_line=self._display_line1, value_display_line=self._display_line2, graphic_display_line=self._display_line3, priority=consts.MODAL_DIALOG_PRIORITY)))
        return note_editor_settings

    def _init_instrument(self):
        instrument_basic_layer = Layer(octave_strip=ComboElement(self._touch_strip_control, [self._shift_button]), scales_toggle_button=self._scale_presets_button, presets_toggle_button=self._shift_button, octave_up_button=self._octave_up_button, octave_down_button=self._octave_down_button, scale_up_button=ComboElement(self._octave_up_button, [self._shift_button]), scale_down_button=ComboElement(self._octave_down_button, [self._shift_button]))
        self._instrument = MelodicComponent(skin=self._skin, is_enabled=False, clip_creator=self._clip_creator, name='Melodic_Component', grid_resolution=self._grid_resolution, note_editor_settings=self._add_note_editor_setting(), layer=Layer(playhead=self._playhead_element, mute_button=self._global_mute_button, quantization_buttons=self._side_buttons, loop_selector_matrix=self._double_press_matrix.submatrix[:, 0], short_loop_selector_matrix=self._double_press_event_matrix.submatrix[:, 0], note_editor_matrices=ButtonMatrixElement([[ self._matrix.submatrix[:, 7 - row] for row in xrange(7) ]])), instrument_play_layer=instrument_basic_layer + Layer(matrix=self._matrix, touch_strip=self._touch_strip_control, aftertouch_control=self._aftertouch_control, delete_button=self._delete_button), instrument_sequence_layer=instrument_basic_layer + Layer(note_strip=self._touch_strip_control))
        self._on_note_editor_layout_changed.subject = self._instrument

    def _init_scales(self):
        self._instrument.scales.layer = Layer(modus_line1=self._display_line1.subdisplay[:18], modus_line2=self._display_line2.subdisplay[:18], modus_line3=self._display_line3.subdisplay[:9], modus_line4=self._display_line4.subdisplay[:9], top_display_line=self._display_line3.subdisplay[9:], bottom_display_line=self._display_line4.subdisplay[9:], top_buttons=self._select_buttons, bottom_buttons=self._track_state_buttons, encoder_controls=self._global_param_controls, _blank_line1=Resetting(self._display_line1.subdisplay[18:]), _blank_line2=Resetting(self._display_line2.subdisplay[18:]), _notification=self._notification.use_single_line(0, get_slice[18:], align_right), priority=consts.MODAL_DIALOG_PRIORITY)
        self._instrument.scales.presets_layer = Layer(top_display_line=self._display_line3, bottom_display_line=self._display_line4, top_buttons=self._select_buttons, _bottom_buttons=Resetting(self._track_state_buttons), _encoders=Resetting(self._global_param_controls), _blank_line1=Resetting(self._display_line1), _blank_line2=Resetting(self._display_line2), _notification=self._notification.use_single_line(0), priority=consts.DIALOG_PRIORITY)

    def _init_step_sequencer(self):
        self._step_sequencer = StepSeqComponent(self._clip_creator, self._skin, name='Step_Sequencer', grid_resolution=self._grid_resolution, note_editor_settings=self._add_note_editor_setting())
        self._step_sequencer._drum_group._do_select_drum_pad = self._selector.on_select_drum_pad
        self._step_sequencer._drum_group._do_quantize_pitch = self._quantize.quantize_pitch
        self._step_sequencer.set_enabled(False)
        self._step_sequencer.layer = Layer(playhead=self._playhead_element, button_matrix=self._matrix.submatrix[:8, :4], drum_matrix=self._matrix.submatrix[:4, 4:8], loop_selector_matrix=self._double_press_matrix.submatrix[4:8, 4:8], short_loop_selector_matrix=self._double_press_event_matrix.submatrix[4:8, 4:8], touch_strip=self._touch_strip_control, detail_touch_strip=ComboElement(self._touch_strip_control, [self._shift_button]), quantization_buttons=self._side_buttons, solo_button=self._global_solo_button, select_button=self._select_button, delete_button=self._delete_button, shift_button=self._shift_button, drum_bank_up_button=self._octave_up_button, drum_bank_down_button=self._octave_down_button, quantize_button=self._quantize_button, mute_button=self._global_mute_button, drum_bank_detail_up_button=ComboElement(self._octave_up_button, [self._shift_button]), drum_bank_detail_down_button=ComboElement(self._octave_down_button, [self._shift_button]))
        self._audio_loop = LoopSelectorComponent(follow_detail_clip=True, measure_length=1.0, name='Loop_Selector')
        self._audio_loop.set_enabled(False)
        self._audio_loop.layer = Layer(loop_selector_matrix=self._matrix)

    def _init_note_repeat(self):
        self._note_repeat = NoteRepeatComponent(name='Note_Repeat')
        self._note_repeat.set_enabled(False)
        self._note_repeat.set_note_repeat(self._c_instance.note_repeat)
        self._note_repeat.layer = Layer(aftertouch_control=self._aftertouch_control, select_buttons=self._side_buttons)
        self._note_repeat.layer.priority = consts.DIALOG_PRIORITY
        self._note_repeat_enabler = EnablingModesComponent(name='Note_Repeat_Enabler', component=self._note_repeat, toggle_value='DiableButton.On')
        self._note_repeat_enabler.set_enabled(False)
        self._note_repeat_enabler.layer = Layer(toggle_button=self._repeat_button)

    def _init_message_box(self):
        self._notification = NotificationComponent(display_lines=self._display_lines)
        self._notification.set_enabled(True)
        self._dialog = DialogComponent()
        self._dialog.message_box_layer = Layer(display_line1=self._display_line1, display_line2=self._display_line2, display_line3=self._display_line3, display_line4=self._display_line4, top_buttons=self._select_buttons, bottom_buttons=self._track_state_buttons, scales_button=self._scale_presets_button, octave_up=self._octave_up_button, octave_down=self._octave_down_button, side_buttons=self._side_buttons, repeat_button=self._repeat_button, accent_button=self._accent_button, in_button=self._in_button, out_button=self._out_button, param_controls=self._global_param_controls, param_touch=self._global_param_touch_buttons, tempo_control_tap=self._tempo_control_tap, master_control_tap=self._master_volume_control_tap, touch_strip=self._touch_strip_control, touch_strip_tap=self._touch_strip_tap, matrix=self._matrix, nav_up_button=self._nav_up_button, nav_down_button=self._nav_down_button, nav_left_button=self._nav_left_button, nav_right_button=self._nav_right_button, shift_button=self._shift_button, select_button=self._select_button, delete_button=self._delete_button, duplicate_button=self._duplicate_button, double_button=self._double_button, quantize_button=self._quantize_button, play_button=self._play_button, new_button=self._new_button, automation_button=self._automation_button, tap_tempo_button=self._tap_tempo_button, metronome_button=self._metronome_button, fixed_length_button=self._fixed_length_button, record_button=self._record_button, undo_button=self._undo_button, tempo_control=self._tempo_control, swing_control=self._swing_control, master_volume_control=self._master_volume_control, global_param_controls=self._global_param_controls, swing_control_tap=self._swing_control_tap, master_volume_tap=self._master_volume_control_tap, global_param_tap=self._global_param_touch_buttons, volumes_button=self._vol_mix_mode_button, pan_sends_button=self._pan_send_mix_mode_button, track_button=self._single_track_mix_mode_button, clip_button=self._clip_mode_button, device_button=self._device_mode_button, browse_button=self._browse_mode_button, user_button=self._user_button, master_select_button=self._master_select_button, create_device_button=self._create_device_button, create_track_button=self._create_track_button, global_track_stop_button=self._global_track_stop_button, global_mute_button=self._global_mute_button, global_solo_button=self._global_solo_button, note_mode_button=self._note_mode_button, session_mode_button=self._session_mode_button)
        self._dialog.message_box_layer.priority = consts.MESSAGE_BOX_PRIORITY
        self._dialog.set_enabled(True)

    def _for_non_frozen_tracks(self, component):
        """ Wrap component into a mode that will only enable it when
        the track is not frozen """
        TrackFrozenModesComponent(default_mode=component, frozen_mode=self._track_frozen_info)
        return component

    def _init_duplicate_actions(self):
        capture_element = ChoosingElement(self._duplicate_button, ComboElement(self._duplicate_button, [self._shift_button]), self._settings[SETTING_WORKFLOW])
        self._capture_and_insert_scene = CaptureAndInsertSceneComponent(name='Capture_And_Insert_Scene')
        self._capture_and_insert_scene.set_enabled(True)
        self._capture_and_insert_scene.layer = Layer(action_button=capture_element)
        duplicate_element = OptionalElement(ComboElement(self._duplicate_button, negative_modifiers=[self._shift_button]), self._settings[SETTING_WORKFLOW], False)
        self._duplicate_detail_clip = DuplicateDetailClipComponent(name='Duplicate_Detail_Clip')
        self._duplicate_detail_clip.set_enabled(True)
        self._duplicate_detail_clip.layer = Layer(action_button=duplicate_element)
        self._duplicate_loop = self._for_non_frozen_tracks(DuplicateLoopComponent(name='Duplicate_Loop', layer=Layer(action_button=self._double_button), is_enabled=False))

    def _init_delete_actions(self):
        self._delete_component = DeleteComponent(name='Deleter')
        self._delete_component.layer = Layer(delete_button=self._delete_button)
        self._delete_clip = DeleteSelectedClipComponent(name='Selected_Clip_Deleter')
        self._delete_clip.layer = Layer(action_button=self._delete_button)
        self._delete_scene = DeleteSelectedSceneComponent(name='Selected_Scene_Deleter')
        self._delete_scene.layer = Layer(action_button=ComboElement(self._delete_button, [self._shift_button]))

    def _init_quantize_actions(self):
        self._quantize = self._for_non_frozen_tracks(QuantizationComponent(name='Selected_Clip_Quantize', is_enabled=False, layer=Layer(action_button=self._quantize_button)))
        self._quantize.settings_layer = Layer(encoder_controls=self._global_param_controls, display_line1=self._display_line1, display_line2=self._display_line2, display_line3=self._display_line3, display_line4=self._display_line4, select_buttons=self._select_buttons, state_buttons=self._track_state_buttons)
        self._quantize.settings_layer.priority = consts.DIALOG_PRIORITY

    def _init_value_components(self):
        self._selector = SelectComponent(name='Selector')
        self._selector.layer = Layer(select_button=self._select_button)
        self._selector.selection_display_layer = Layer(display_line=self._display_line3)
        self._selector.selection_display_layer.priority = consts.DIALOG_PRIORITY
        self._swing_amount = ValueComponent('swing_amount', self.song(), display_label='Swing Amount:', display_format='%d%%', model_transform=lambda x: clamp(x / 200.0, 0.0, 0.5), view_transform=lambda x: x * 200.0, encoder_factor=100.0, encoder=self._swing_control)
        self._swing_amount.layer = Layer(button=self._swing_control_tap, encoder=self._swing_control)
        self._swing_amount.display_layer = Layer(label_display=self._display_line1, value_display=self._display_line3, graphic_display=self._display_line2, clear_display1=self._display_line4)
        self._swing_amount.display_layer.priority = consts.DIALOG_PRIORITY
        self._tempo = ValueComponent('tempo', self.song(), display_label='Tempo:', display_format='%0.2f BPM', encoder=self._tempo_control)
        self._tempo.layer = Layer(button=self._tempo_control_tap)
        self._tempo.display_layer = Layer(label_display=self._display_line1, value_display=self._display_line2, clear_display1=self._display_line3, clear_display2=self._display_line4)
        self._tempo.display_layer.priority = consts.DIALOG_PRIORITY
        self._master_vol = ParameterValueComponent(self.song().master_track.mixer_device.volume, display_label='Master Volume:', display_seg_start=3, name='Master_Volume_Display', encoder=self._master_volume_control)
        self._master_vol.layer = Layer(button=self._master_volume_control_tap)
        self._master_vol.display_layer = Layer(label_display=self._display_line1, value_display=self._display_line3, graphic_display=self._display_line2, clear_display2=self._display_line4)
        self._master_vol.display_layer.priority = consts.DIALOG_PRIORITY
        self._master_cue_vol = ParameterValueComponent(self.song().master_track.mixer_device.cue_volume, display_label='Cue Volume:', display_seg_start=3, name='Cue_Volume_Display', encoder=ComboElement(self._master_volume_control, [self._shift_button]))
        self._master_cue_vol.layer = Layer(button=ComboElement(self._master_volume_control_tap, [self._shift_button]))
        self._master_cue_vol.display_layer = Layer(label_display=self._display_line1, value_display=self._display_line3, graphic_display=self._display_line2, clear_display2=self._display_line4)
        self._master_cue_vol.display_layer.priority = consts.DIALOG_PRIORITY
        self._value_components = [self._swing_amount,
         self._tempo,
         self._master_vol,
         self._master_cue_vol]

    def _init_m4l_interface(self):
        self._m4l_interface = M4LInterfaceComponent(controls=self.controls, component_guard=self.component_guard)
        self.get_control_names = self._m4l_interface.get_control_names
        self.get_control = self._m4l_interface.get_control
        self.grab_control = self._m4l_interface.grab_control
        self.release_control = self._m4l_interface.release_control

    @subject_slot('selected_mode')
    def _on_note_editor_layout_changed(self, mode):
        self.reset_controlled_track(mode)

    def reset_controlled_track(self, mode = None):
        if mode == None:
            mode = self._instrument.selected_mode
        if self._instrument.is_enabled() and mode == 'sequence':
            self.release_controlled_track()
        else:
            self.set_controlled_track(self.song().view.selected_track)

    @subject_slot('selected_track.is_frozen')
    def _on_selected_track_is_frozen_changed(self):
        self._select_note_mode()

    def _on_selected_track_changed(self):
        super(Push, self)._on_selected_track_changed()
        self.reset_controlled_track()
        self._select_note_mode()
        self._main_modes.pop_groups(['add_effect'])
        self._note_repeat_enabler.selected_mode = 'disabled'

    def _send_midi(self, midi_event_bytes, optimized = True):
        if not self._suppress_sysex or not self.is_sysex_message(midi_event_bytes):
            return super(Push, self)._send_midi(midi_event_bytes, optimized)

    @subject_slot('session_record')
    def _on_session_record_changed(self):
        status = self.song().session_record
        playhead_color = 'PlayheadRecord' if status else 'Playhead'
        feedback_color = int(self._skin['Instrument.FeedbackRecord'] if status else self._skin['Instrument.Feedback'])
        self._instrument.playhead_color = playhead_color
        self._step_sequencer.playhead_color = playhead_color
        self._c_instance.set_feedback_velocity(feedback_color)

    @subject_slot('selected_mode')
    def _on_accent_mode_changed(self, mode_name):
        accent_is_active = mode_name == 'enabled'
        self._step_sequencer.full_velocity = accent_is_active
        self._instrument.full_velocity = accent_is_active

    @subject_slot('value')
    def _on_pad_threshold(self, setting):
        self._user.set_settings_info_text('' if setting.value >= consts.CRITICAL_THRESHOLD_LIMIT else consts.MessageBoxText.STUCK_PAD_WARNING)
        self._update_pad_params()

    @subject_slot('value')
    def _on_pad_curve(self, setting):
        self._update_pad_params()

    def _update_pad_params(self):
        new_pad_parameters = make_pad_parameters(self._settings[SETTING_CURVE].value, self._settings[SETTING_THRESHOLD].value)
        self._pad_sensitivity_update.set_profile('instrument', new_pad_parameters)
        self._pad_sensitivity_update.set_profile('drums', new_pad_parameters)

    @subject_slot('before_mode_sent')
    def _on_before_hardware_mode_sent(self, mode):
        self._suppress_sysex = False

    @subject_slot('after_mode_sent')
    def _on_after_hardware_mode_sent(self, mode):
        if mode == Sysex.USER_MODE:
            self._suppress_sysex = True

    @subject_slot('mode')
    def _on_hardware_mode_changed(self, mode):
        if mode == Sysex.LIVE_MODE:
            self.update()
        elif mode == Sysex.USER_MODE:
            self._suppress_sysex = True
        self._update_auto_arm()

    @subject_slot('selected_mode')
    def _on_matrix_mode_changed(self, mode):
        self._update_auto_arm(selected_mode=mode)

    def _update_auto_arm(self, selected_mode = None):
        self._auto_arm.set_enabled(self._user.mode == Sysex.LIVE_MODE and (selected_mode or self._matrix_modes.selected_mode == 'note'))

    @subject_slot('drum_group')
    def _on_drum_group_changed(self):
        self._select_note_mode()

    def _select_note_mode(self):
        """
        Selects which note mode to use depending on the kind of
        current selected track and its device chain...
        """
        track = self.song().view.selected_track
        drum_device = self._drum_group_finder.drum_group
        self._step_sequencer.set_drum_group_device(drum_device)
        if track == None or track.is_foldable or track in self.song().return_tracks or track == self.song().master_track or track.is_frozen:
            self._note_modes.selected_mode = 'disabled'
        elif track and track.has_audio_input:
            self._note_modes.selected_mode = 'looper'
        elif drum_device:
            self._note_modes.selected_mode = 'sequencer'
        else:
            self._note_modes.selected_mode = 'instrument'
        self.reset_controlled_track()

    def _on_toggle_encoder(self, value):
        pass

    @subject_slot_group('value')
    def _on_param_encoder_touched(self, value, encoder):
        """
        When using the parameter encoders, other encoders around it are often accidentally
        touched and will take over the screen. By putting all ValueComponents into timer
        based displaying mode while touching a parameter, this noise is prevented.
        """
        param_encoder_touched = find_if(lambda encoder: encoder.is_pressed(), self._global_param_touch_buttons_raw) != None
        new_display_mode = ValueComponent.TIMER_BASED if param_encoder_touched else ValueComponent.TOUCH_BASED
        for value_component in self._value_components:
            value_component.display_mode = new_display_mode

    def expect_dialog(self, message):
        self.schedule_message(1, partial(self._dialog.expect_dialog, message))

    def show_notification(self, message):
        self._notification.show_notification(message)

    def handle_nonsysex(self, midi_bytes):
        _, _, value = midi_bytes
        recipient = self.get_recipient_for_nonsysex_midi_message(midi_bytes)
        if isinstance(recipient, ButtonElement) and value != 0:
            self._notification.hide_notification()
            with self._double_press_context.breaking_double_press():
                super(Push, self).handle_nonsysex(midi_bytes)
        else:
            super(Push, self).handle_nonsysex(midi_bytes)
########NEW FILE########
__FILENAME__ = QuantizationComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/QuantizationComponent.py
import Live
RecordingQuantization = Live.Song.RecordingQuantization
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.SubjectSlot import subject_slot
from _Framework.Util import clamp, forward_property, recursive_map
from ActionWithOptionsComponent import ActionWithSettingsComponent
from consts import MessageBoxText
from MessageBoxComponent import Messenger
QUANTIZATION_OPTIONS = [RecordingQuantization.rec_q_quarter,
 RecordingQuantization.rec_q_eight,
 RecordingQuantization.rec_q_eight_triplet,
 RecordingQuantization.rec_q_eight_eight_triplet,
 RecordingQuantization.rec_q_sixtenth,
 RecordingQuantization.rec_q_sixtenth_triplet,
 RecordingQuantization.rec_q_sixtenth_sixtenth_triplet,
 RecordingQuantization.rec_q_thirtysecond]
QUANTIZATION_NAMES = ('1/4', '1/8', '1/8t', '1/8+t', '1/16', '1/16t', '1/16+t', '1/32')

def record_quantization_to_float(quantize):
    return float(list(QUANTIZATION_OPTIONS).index(quantize)) / float(len(QUANTIZATION_OPTIONS) - 1)


def float_to_record_quantization(quantize):
    return QUANTIZATION_OPTIONS[int(quantize * (len(QUANTIZATION_OPTIONS) - 1))]


class QuantizationSettingsComponent(ControlSurfaceComponent):

    def __init__(self, *a, **k):
        super(QuantizationSettingsComponent, self).__init__(*a, **k)
        self._display_lines = recursive_map(DisplayDataSource, (('', '', '', '', '', '', '', ''),
         ('Swing', 'Quantize', 'Quantize', '', '', '', '', 'Record'),
         ('Amount', 'To', 'Amount', '', '', '', '', 'Quantize'),
         ('', '', '', '', '', '', '', '')))
        self._swing_amount_display = self._display_lines[0][0]
        self._quantize_to_display = self._display_lines[0][1]
        self._quantize_amount_display = self._display_lines[0][2]
        self._record_quantization_display = self._display_lines[0][7]
        self._record_quantization_on_display = self._display_lines[3][7]
        default_quantize = RecordingQuantization.rec_q_sixtenth
        self._record_quantization = default_quantize
        self._quantize_to = default_quantize
        self._quantize_amount = 1.0
        default_quantize_float = record_quantization_to_float(default_quantize)
        self._record_quantization_float = default_quantize_float
        self._quantize_to_float = default_quantize_float
        self._on_swing_amount_changed_in_live.subject = self.song()
        self._on_swing_amount_changed_in_live()
        self._on_record_quantization_changed_in_live.subject = self.song()
        self._on_record_quantization_changed_in_live()
        self._update_swing_amount_display()
        self._update_quantize_to_display()
        self._update_quantize_amount_display()

    def update(self):
        self._update_record_quantization_button()

    def set_display_line1(self, line):
        self._set_display_line(line, 0)

    def set_display_line2(self, line):
        self._set_display_line(line, 1)

    def set_display_line3(self, line):
        self._set_display_line(line, 2)

    def set_display_line4(self, line):
        self._set_display_line(line, 3)

    def _set_display_line(self, line, index):
        if line:
            line.set_num_segments(8)
            for segment in xrange(8):
                line.segment(segment).set_data_source(self._display_lines[index][segment])

    def set_encoder_controls(self, encoders):
        if encoders:
            self._on_swing_amount_value.subject = encoders[0]
            self._on_quantize_to_value.subject = encoders[1]
            self._on_quantize_amount_value.subject = encoders[2]
            self._on_record_quantization_value.subject = encoders[7]
        else:
            self._on_swing_amount_value.subject = None
            self._on_quantize_to_value.subject = None
            self._on_quantize_amount_value.subject = None
            self._on_record_quantization_value.subject = None

    def set_select_buttons(self, buttons):
        self._on_record_quantization_on_value.subject = buttons[7] if buttons else None
        if buttons:
            for button in filter(bool, buttons):
                button.reset()

        self._update_record_quantization_button()

    def set_state_buttons(self, buttons):
        if buttons:
            buttons.reset()

    def _update_record_quantization(self):
        self.song().midi_recording_quantization = self._record_quantization if self._record_quantization_on else RecordingQuantization.rec_q_no_q

    def _update_swing_amount_display(self):
        display = str(int(self.song().swing_amount * 200.0)) + '%'
        self._swing_amount_display.set_display_string(display)

    def _update_record_quantization_display(self):
        index = QUANTIZATION_OPTIONS.index(self._record_quantization)
        self._record_quantization_display.set_display_string(QUANTIZATION_NAMES[index])
        self._record_quantization_on_display.set_display_string('[  On  ]' if self._record_quantization_on else '[  Off ]')

    def _update_record_quantization_button(self):
        if self.is_enabled():
            button = self._on_record_quantization_on_value.subject
            if button:
                button.set_on_off_values('Option.On', 'Option.Off')
                if self._record_quantization_on:
                    self._on_record_quantization_on_value.subject.turn_on()
                else:
                    self._on_record_quantization_on_value.subject.turn_off()

    def _update_quantize_to_display(self):
        index = QUANTIZATION_OPTIONS.index(self._quantize_to)
        self._quantize_to_display.set_display_string(QUANTIZATION_NAMES[index])

    def _update_quantize_amount_display(self):
        self._quantize_amount_display.set_display_string(str(int(self._quantize_amount * 100)) + '%')

    @subject_slot('normalized_value')
    def _on_swing_amount_value(self, value):
        self.song().swing_amount = clamp(self.song().swing_amount + value * 0.5, 0.0, 0.5)

    @subject_slot('normalized_value')
    def _on_quantize_to_value(self, value):
        self._quantize_to_float = clamp(self._quantize_to_float + value, 0.0, 1.0)
        self._quantize_to = float_to_record_quantization(self._quantize_to_float)
        self._update_quantize_to_display()

    @subject_slot('normalized_value')
    def _on_quantize_amount_value(self, value):
        self._quantize_amount = clamp(self._quantize_amount + value, 0.0, 1.0)
        self._update_quantize_amount_display()

    @subject_slot('normalized_value')
    def _on_record_quantization_value(self, value):
        self._record_quantization_float = clamp(self._record_quantization_float + value, 0.0, 1.0)
        self._record_quantization = float_to_record_quantization(self._record_quantization_float)
        self._update_record_quantization()
        self._update_record_quantization_display()

    @subject_slot('value')
    def _on_record_quantization_on_value(self, value):
        if value:
            self._record_quantization_on = not self._record_quantization_on
            self._update_record_quantization()

    @subject_slot('swing_amount')
    def _on_swing_amount_changed_in_live(self):
        self._update_swing_amount_display()

    @subject_slot('midi_recording_quantization')
    def _on_record_quantization_changed_in_live(self):
        quant_value = self.song().midi_recording_quantization
        quant_on = quant_value != RecordingQuantization.rec_q_no_q
        if quant_value in QUANTIZATION_OPTIONS:
            self._record_quantization = quant_value
            if self._on_record_quantization_value.subject:
                quant_value_float = self._on_record_quantization_value.subject.is_pressed() or record_quantization_to_float(quant_value)
                self._record_quantization_float = quant_value_float
        self._record_quantization_on = quant_on
        self._update_record_quantization_display()
        self._update_record_quantization_button()


class QuantizationComponent(ActionWithSettingsComponent, Messenger):
    settings_layer = forward_property('_settings')('layer')

    def __init__(self, *a, **k):
        super(QuantizationComponent, self).__init__(*a, **k)
        self._settings = self.register_component(QuantizationSettingsComponent())
        self._settings.set_enabled(False)
        self._cancel_quantize = False

    def quantize_pitch(self, note):
        clip = self.song().view.detail_clip
        if clip:
            clip.quantize_pitch(note, self._settings._quantize_to, self._settings._quantize_amount)
            self.show_notification(MessageBoxText.QUANTIZE_CLIP_PITCH % dict(amount=self._settings._quantize_amount_display.display_string(), to=self._settings._quantize_to_display.display_string()))
        self._cancel_quantize = True

    def show_settings(self):
        self._settings.set_enabled(True)
        return True

    def hide_settings(self):
        self._settings.set_enabled(False)
        self._cancel_quantize = False

    def post_trigger_action(self):
        clip = self.song().view.detail_clip
        if clip and not self._cancel_quantize:
            clip.quantize(self._settings._quantize_to, self._settings._quantize_amount)
            self.show_notification(MessageBoxText.QUANTIZE_CLIP % dict(amount=self._settings._quantize_amount_display.display_string(), to=self._settings._quantize_to_display.display_string()))
        self._cancel_quantize = False
########NEW FILE########
__FILENAME__ = ScrollableList
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/ScrollableList.py
from __future__ import with_statement
from functools import partial
from _Framework.CompoundComponent import CompoundComponent
from _Framework.Util import in_range, clamp, BooleanContext, index_if
from _Framework.SubjectSlot import subject_slot, Subject, subject_slot_group
from _Framework import Task, Defaults
from _Framework.ScrollComponent import ScrollComponent, Scrollable
import consts

class ScrollableListItem(object):
    """
    Wrapper of an item of a scrollable list.
    """

    def __init__(self, index = None, content = None, scrollable_list = None, *a, **k):
        super(ScrollableListItem, self).__init__(*a, **k)
        self._content = content
        self._index = index
        self._scrollable_list = scrollable_list

    def __str__(self):
        return unicode(self._content)

    @property
    def content(self):
        return self._content

    @property
    def index(self):
        return self._index

    @property
    def container(self):
        return self._scrollable_list

    @property
    def is_selected(self):
        return self._scrollable_list and self._scrollable_list.is_selected(self)

    def select(self):
        return self._scrollable_list and self._scrollable_list.select_item(self)


class ScrollableList(Subject, Scrollable):
    """
    Class for managing a visual subset of a list of items.
    
    The items will be wrapped in an item_type instance.
    """
    __subject_events__ = ('selected_item', 'item_activated', 'scroll')
    item_type = ScrollableListItem
    fixed_offset = None

    def __init__(self, num_visible_items = 1, item_type = None, *a, **k):
        super(ScrollableList, self).__init__(*a, **k)
        if item_type != None:
            self.item_type = item_type
        self._items = []
        self._num_visible_items = num_visible_items
        self._selected_item_index = -1
        self._last_activated_item_index = None
        self._offset = 0
        self._pager = Scrollable()
        self._pager.scroll_up = self.prev_page
        self._pager.scroll_down = self.next_page
        self._pager.can_scroll_up = self.can_scroll_up
        self._pager.can_scroll_down = self.can_scroll_down

    @property
    def pager(self):
        return self._pager

    def scroll_up(self):
        if self.can_scroll_up():
            self.select_item_index_with_border(self.selected_item_index - 1, 1)
            self.notify_scroll()

    def can_scroll_up(self):
        return self._selected_item_index > 0

    def scroll_down(self):
        if self.can_scroll_down():
            self.select_item_index_with_border(self.selected_item_index + 1, 1)
            self.notify_scroll()

    def can_scroll_down(self):
        return self._selected_item_index < len(self._items) - 1

    def _get_num_visible_items(self):
        return self._num_visible_items

    def _set_num_visible_items(self, num_items):
        raise num_items >= 0 or AssertionError
        self._num_visible_items = num_items
        self._normalize_offset(self._selected_item_index)

    num_visible_items = property(_get_num_visible_items, _set_num_visible_items)

    @property
    def visible_items(self):
        return self.items[self._offset:self._offset + self._num_visible_items]

    def select_item_index_with_offset(self, index, offset):
        """
        Selects an item index but moves the view such that there are,
        if possible, 'offset' number of elements visible before the
        selected one.  Does nothing if the item was already selected.
        """
        if not (index != self.selected_item_index and index >= 0 and index < len(self._items) and self.selected_item_index != -1):
            raise AssertionError
            self._offset = clamp(index - offset, 0, len(self._items))
            self._normalize_offset(index)
            self._do_set_selected_item_index(index)

    def select_item_index_with_border(self, index, border_size):
        """
        Selects an item with an index. Moves the view if the selection would exceed the
        border of the current view.
        """
        if self.fixed_offset is not None:
            self.select_item_index_with_offset(index, self.fixed_offset)
        elif index >= 0 and index < len(self._items):
            if not in_range(index, self._offset + border_size, self._offset + self._num_visible_items - border_size):
                offset = index - (self._num_visible_items - 2 * border_size) if self.selected_item_index < index else index - border_size
                self._offset = clamp(offset, 0, len(self._items))
            self._normalize_offset(index)
            self._do_set_selected_item_index(index)

    def next_page(self):
        if self.can_scroll_down():
            current_page = self.selected_item_index / self.num_visible_items
            last_page_index = len(self.items) - self.num_visible_items
            if self.selected_item_index < last_page_index:
                index = clamp((current_page + 1) * self.num_visible_items, 0, len(self.items) - self.num_visible_items)
            else:
                index = len(self.items) - 1
            self.select_item_index_with_offset(index, 0)

    def prev_page(self):
        if self.can_scroll_up():
            current_page = self.selected_item_index / self.num_visible_items
            last_page_index = len(self.items) - self.num_visible_items
            if self.selected_item_index <= last_page_index:
                index = clamp((current_page - 1) * self.num_visible_items, 0, len(self.items) - self.num_visible_items)
            else:
                index = max(len(self.items) - self.num_visible_items, 0)
            self.select_item_index_with_offset(index, 0)

    def _set_selected_item_index(self, index):
        if not (index >= 0 and index < len(self._items) and self.selected_item_index != -1):
            raise AssertionError
            self._normalize_offset(index)
            self._do_set_selected_item_index(index)

    def _get_selected_item_index(self):
        return self._selected_item_index

    selected_item_index = property(_get_selected_item_index, _set_selected_item_index)

    def _normalize_offset(self, index):
        if index >= 0:
            if index >= self._offset + self._num_visible_items:
                self._offset = index - (self._num_visible_items - 1)
            elif index < self._offset:
                self._offset = index
            self._offset = clamp(self._offset, 0, len(self._items) - self._num_visible_items)

    @property
    def selected_item(self):
        return self._items[self.selected_item_index] if in_range(self._selected_item_index, 0, len(self._items)) else None

    @property
    def items(self):
        return self._items

    def assign_items(self, items):
        old_selection = unicode(self.selected_item)
        for item in self._items:
            item._scrollable_list = None

        self._items = tuple([ self.item_type(index=index, content=item, scrollable_list=self) for index, item in enumerate(items) ])
        if self._items:
            new_selection = index_if(lambda item: unicode(item) == old_selection, self._items)
            self._selected_item_index = new_selection if in_range(new_selection, 0, len(self._items)) else 0
            self._normalize_offset(self._selected_item_index)
        else:
            self._offset = 0
            self._selected_item_index = -1
        self._last_activated_item_index = None
        self.notify_selected_item()
        self.request_notify_item_activated()

    def select_item(self, item):
        self.selected_item_index = item.index

    def is_selected(self, item):
        return item and item.index == self.selected_item_index

    def request_notify_item_activated(self):
        if self._selected_item_index != self._last_activated_item_index:
            self._last_activated_item_index = self._selected_item_index
            self.notify_item_activated()

    def _do_set_selected_item_index(self, index):
        if index != self._selected_item_index:
            self._selected_item_index = index
            self.notify_selected_item()


class ActionListItem(ScrollableListItem):
    """
    Interface for an list element that can be actuated on.
    """
    supports_action = False

    def action(self):
        pass


class ActionList(ScrollableList):
    """
    A scrollable list of items that can be actuated on.
    """
    item_type = ActionListItem


class DefaultItemFormatter(object):
    """
    Item formatter that will indicate selection and show action_message if the item
    is currently performing an action
    """
    action_message = 'Loading...'

    def __call__(self, index, item, action_in_progress):
        display_string = ''
        if item:
            display_string += consts.CHAR_SELECT if item.is_selected else ' '
            display_string += self.action_message if action_in_progress else unicode(item)
        return display_string


class ListComponent(CompoundComponent):
    """
    Component that handles a ScrollableList.  If an action button is
    passed, it can handle an ActionList.
    """
    __subject_events__ = ('item_action',)
    DIRECTION_ON_COLOR = 'List.ScrollerOn'
    DIRECTION_OFF_COLOR = 'List.ScrollerOff'
    SELECTION_DELAY = 0.5
    ENCODER_FACTOR = 10.0
    empty_list_message = ''
    _current_action_item = None
    _last_action_item = None

    def __init__(self, scrollable_list = None, data_sources = tuple(), *a, **k):
        super(ListComponent, self).__init__(*a, **k)
        self._data_sources = data_sources
        self._activation_task = Task.Task()
        self._action_on_scroll_task = Task.Task()
        self._scrollable_list = None
        self._scroller = self.register_component(ScrollComponent())
        self._pager = self.register_component(ScrollComponent())
        self.last_action_item = lambda : self._last_action_item
        self.item_formatter = DefaultItemFormatter()
        if scrollable_list == None:
            self.scrollable_list = ActionList(num_visible_items=len(data_sources))
        else:
            self.scrollable_list = scrollable_list
        self._scrollable_list.num_visible_items = len(data_sources)
        self._delay_activation = BooleanContext()
        self._selected_index_float = 0.0
        self._in_encoder_selection = BooleanContext(False)
        self._execute_action_task = self._tasks.add(Task.sequence(Task.delay(1), Task.run(self._execute_action)))
        self._execute_action_task.kill()

    @property
    def _trigger_action_on_scrolling(self):
        button = self._on_action_button_value.subject
        return button != None and button.is_pressed()

    def _get_scrollable_list(self):
        return self._scrollable_list

    def _set_scrollable_list(self, new_list):
        if new_list != self._scrollable_list:
            self._scrollable_list = new_list
            if new_list != None:
                new_list.num_visible_items = len(self._data_sources)
                self._scroller.scrollable = new_list
                self._pager.scrollable = new_list.pager
                self._on_scroll.subject = new_list
                self._selected_index_float = new_list.selected_item_index
            else:
                self._scroller.scrollable = ScrollComponent.default_scrollable
                self._scroller.scrollable = ScrollComponent.default_pager
            self._on_selected_item_changed.subject = new_list
            self.update_all()

    scrollable_list = property(_get_scrollable_list, _set_scrollable_list)

    def set_data_sources(self, sources):
        self._data_sources = sources
        if self._scrollable_list:
            self._scrollable_list.num_visible_items = len(sources)
        self._update_display()

    def set_encoder_controls(self, encoder_controls):
        self._on_encoder_value.replace_subjects(encoder_controls)

    def set_selection_buttons(self, prev_button, next_button):
        self.set_select_prev_button(prev_button)
        self.set_select_next_button(next_button)

    def _set_scroll_button_colors(self, button):
        if button:
            button.set_on_off_values(self.DIRECTION_ON_COLOR, self.DIRECTION_OFF_COLOR)

    def set_select_prev_button(self, prev_button):
        self._scroller.set_scroll_up_button(prev_button)
        self._set_scroll_button_colors(prev_button)
        self._scroller.update()

    def set_select_next_button(self, next_button):
        self._scroller.set_scroll_down_button(next_button)
        self._set_scroll_button_colors(next_button)
        self._scroller.update()

    def set_next_page_button(self, next_button):
        self._pager.set_scroll_down_button(next_button)
        self._set_scroll_button_colors(next_button)
        self._pager.update()

    def set_prev_page_button(self, prev_button):
        self._pager.set_scroll_up_button(prev_button)
        self._set_scroll_button_colors(prev_button)
        self._pager.update()

    def set_action_button(self, button):
        if button:
            button.reset()
            button.set_on_off_values('Browser.Load', 'Browser.LoadNotPossible')
        self._on_action_button_value.subject = button
        self._update_action_feedback()

    def on_enabled_changed(self):
        super(ListComponent, self).on_enabled_changed()
        if not self.is_enabled():
            self._execute_action_task.kill()

    @subject_slot('scroll')
    def _on_scroll(self):
        if self._trigger_action_on_scrolling:
            trigger_selected = partial(self._trigger_action, self.selected_item)
            self._action_on_scroll_task.kill()
            self._action_on_scroll_task = self._tasks.add(Task.sequence(Task.wait(Defaults.MOMENTARY_DELAY), Task.delay(1), Task.run(trigger_selected)))

    @subject_slot('selected_item')
    def _on_selected_item_changed(self):
        self._scroller.update()
        self._pager.update()
        self._update_display()
        self._update_action_feedback()
        self._activation_task.kill()
        self._action_on_scroll_task.kill()
        if self.SELECTION_DELAY and self._delay_activation:
            self._activation_task = self._tasks.add(Task.sequence(Task.wait(self.SELECTION_DELAY), Task.run(self._scrollable_list.request_notify_item_activated)))
        else:
            self._scrollable_list.request_notify_item_activated()
        if not self._in_encoder_selection:
            self._selected_index_float = float(self._scrollable_list.selected_item_index)

    @subject_slot_group('normalized_value')
    def _on_encoder_value(self, value, encoder):
        self._add_offset_to_selected_index(value)

    def _add_offset_to_selected_index(self, offset):
        if self.is_enabled() and self._scrollable_list:
            with self._delay_activation():
                with self._in_encoder_selection():
                    self._selected_index_float = clamp(self._selected_index_float + offset * self.ENCODER_FACTOR, 0, len(self._scrollable_list.items))
                    self._scrollable_list.select_item_index_with_border(int(self._selected_index_float), 1)

    @subject_slot('value')
    def _on_action_button_value(self, value):
        if value != 0 and self._current_action_item == None:
            self._trigger_action(self.next_item if self._action_target_is_next_item() else self.selected_item)

    @subject_slot('value')
    def _on_next_page(self, value):
        if value:
            self._scrollable_list.next_page()

    @subject_slot('value')
    def _on_prev_page(self, value):
        if value:
            self._scrollable_list.prev_page()

    def do_trigger_action(self, item):
        item.action()
        self.notify_item_action(item)

    def _trigger_action(self, item):
        if self.is_enabled() and self._can_be_used_for_action(item):
            if self._scrollable_list != None:
                self._scrollable_list.select_item(item)
            self._current_action_item = item
            self.update()
            self._execute_action_task.restart()

    def _execute_action(self):
        """ Is called by the execute action task and should not be called directly
        use _trigger_action instead """
        if self._current_action_item != None:
            self.do_trigger_action(self._current_action_item)
            self._last_action_item = self._current_action_item
            self._current_action_item = None
            self.update()

    @property
    def selected_item(self):
        return self._scrollable_list.selected_item if self._scrollable_list != None else None

    @property
    def next_item(self):
        item = None
        if self._scrollable_list != None:
            all_items = self._scrollable_list.items
            next_index = self._scrollable_list.selected_item_index + 1
            item = all_items[next_index] if in_range(next_index, 0, len(all_items)) else None
        return item

    def _can_be_used_for_action(self, item):
        return item != None and item.supports_action and item != self.last_action_item()

    def _action_target_is_next_item(self):
        return self.selected_item == self.last_action_item() and self._can_be_used_for_action(self.next_item)

    def _update_action_feedback(self):
        if self._on_action_button_value.subject != None:
            action_light = 'Browser.Loading'
            if self._current_action_item == None:
                action_light = 'Browser.LoadNotPossible'
                if self._action_target_is_next_item():
                    action_light = 'Browser.LoadNext'
                elif self._can_be_used_for_action(self.selected_item):
                    action_light = 'Browser.Load'
            self._on_action_button_value.subject.set_light(action_light)

    def _update_display(self):
        visible_items = self._scrollable_list.visible_items if self._scrollable_list else []
        for index, data_source in enumerate(self._data_sources):
            item = visible_items[index] if index < len(visible_items) else None
            action_in_progress = item and item == self._current_action_item
            display_string = self.item_formatter(index, item, action_in_progress)
            data_source.set_display_string(display_string)

        if not visible_items and self._data_sources and self.empty_list_message:
            self._data_sources[0].set_display_string(self.empty_list_message)

    def update(self):
        if self.is_enabled():
            self._update_action_feedback()
            self._update_display()
########NEW FILE########
__FILENAME__ = ScrollableListComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/ScrollableListComponent.py
"""
Scrollable list component.
"""
from _Framework.SubjectSlot import SubjectEvent
from _Framework.Signal import short_circuit_signal
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.Util import in_range
from functools import partial
import consts

class ScrollableListComponent(ControlSurfaceComponent):
    """
    Component for handling a list of options with a limtied set of
    buttons and display segments.
    """
    __subject_events__ = (SubjectEvent(name='change_option', doc=' Event signaled when the selected option changes '), SubjectEvent(name='press_option', signal=short_circuit_signal, doc='\n       Event signaled when an option is pressed getting the option as\n       parameter.  The ScrollableListComponent is connected to it, if\n       you want to override selection behaviour, connect to the front\n       and return True from your handler.\n       '))
    num_segments = 8
    display_line = 3
    jump_size = 3
    ARROW_LEFT = '   <<   '
    ARROW_RIGHT = '   >>   '

    def __init__(self, *a, **k):
        super(ScrollableListComponent, self).__init__(*a, **k)
        self._data_sources = [ DisplayDataSource() for _ in range(self.num_segments) ]
        self._selected_option = None
        self._offset_index = 0
        self._option_names = []
        self._select_buttons = []
        self._select_button_slots = self.register_slot_manager()
        self.register_slot(self, self._set_selected_option, 'press_option')

    def set_display_line(self, line):
        if line:
            sources = self._data_sources
            line.set_num_segments(len(sources))
            for segment in xrange(len(sources)):
                line.segment(segment).set_data_source(sources[segment])

    def set_select_buttons(self, buttons):
        self._select_button_slots.disconnect()
        self._select_buttons = buttons or []
        for b in self._select_buttons:
            if b:
                b.set_on_off_values('Option.Selected', 'Option.Unselected')
            self._select_button_slots.register_slot(b, self._on_select_value, 'value', extra_kws=dict(identify_sender=True))

        self.update()

    @property
    def offset_index(self):
        return self._offset_index

    def scroll_right(self):
        return self._scroll(1)

    def scroll_left(self):
        return self._scroll(-self.jump_size)

    def _get_option_names(self):
        return self._option_names

    def _set_option_names(self, names):
        self._option_names = names
        self._normalize_offset()
        self.update()

    option_names = property(_get_option_names, lambda self, x: self._set_option_names(x))

    def _get_selected_option(self):
        return self._selected_option

    def _set_selected_option(self, selected_option):
        if not (selected_option != self._selected_option and (selected_option == None or in_range(selected_option, 0, self._option_names))):
            raise AssertionError
            self._selected_option = selected_option
            self.notify_change_option(selected_option)
            self.update()

    selected_option = property(_get_selected_option, _set_selected_option)

    def _has_select_button(self, index):
        return len(self._select_buttons) == self.num_segments and self._select_buttons[index] != None

    def _maximal_offset(self):
        if len(self._option_names) > self.num_segments:
            return len(self._option_names) - self.num_segments + 1
        else:
            return 0

    def _normalize_offset(self):
        quantized_offset = self._offset_index - self._offset_index % -self.jump_size
        self._offset_index = max(0, min(self._maximal_offset(), quantized_offset))

    def _scroll(self, delta):
        old_offset = self._offset_index
        self._offset_index += delta
        self._normalize_offset()
        if self._offset_index != old_offset:
            self.update()
            return True
        return False

    def _on_select_value(self, value, sender):
        if not self.is_enabled() or not value:
            return
        index = list(self._select_buttons).index(sender)
        if index == 0 and self._offset_index != 0:
            self.scroll_left()
        elif index == self.num_segments - 1 and self._offset_index < self._maximal_offset():
            self.scroll_right()
        elif self._offset_index == 0:
            self.notify_press_option(index if index < len(self._option_names) else None)
        else:
            self.notify_press_option(index + self._offset_index - 1)

    def _get_display_string(self, option_index):
        if option_index < len(self._option_names):
            decorator = consts.CHAR_SELECT if option_index == self.selected_option else ''
            return decorator + self._option_names[option_index]
        else:
            return ''

    def update(self):
        if not self.is_enabled():
            return
        first_segment, max_segment = 0, self.num_segments
        if self._offset_index > 0:
            self._data_sources[0].set_display_string(self.ARROW_LEFT)
            if self._has_select_button(0):
                self._select_buttons[0].set_light('List.ScrollerOn')
            first_segment = 1
        if self._offset_index < self._maximal_offset():
            self._data_sources[-1].set_display_string(self.ARROW_RIGHT)
            if self._has_select_button(-1):
                self._select_buttons[-1].set_light('List.ScrollerOn')
            max_segment -= 1
        for i, j in zip(xrange(first_segment, max_segment), xrange(self._offset_index, self._offset_index + self.num_segments)):
            self._data_sources[i].set_display_string(self._get_display_string(j))
            if self._has_select_button(i):
                if i < len(self.option_names):
                    if j == self.selected_option:
                        self._select_buttons[i].turn_on()
                    else:
                        self._select_buttons[i].turn_off()
                else:
                    self._select_buttons[i].set_light('Option.Unused')


class ScrollableListWithTogglesComponent(ScrollableListComponent):
    """
    Scrollable list that has a toggle button associated with every
    available option.
    """
    __subject_events__ = ('toggle_option',)

    def __init__(self, *a, **k):
        super(ScrollableListWithTogglesComponent, self).__init__(*a, **k)

        def create_state_slot(idx):
            return self.register_slot(None, partial(self._on_state_button_value, idx), 'value')

        self._state_button_slots = map(create_state_slot, xrange(self.num_segments))
        self._option_states = []

    def set_state_buttons(self, state_buttons):
        state_buttons = state_buttons or [ None for _ in range(self.num_segments) ]
        for slot, button in zip(self._state_button_slots, state_buttons):
            if button:
                button.set_on_off_values('Option.On', 'Option.Off')
            slot.subject = button

        self._update_state_buttons()

    def option_state(self, index):
        return self._option_states[index]

    def set_option_state(self, index, value):
        if index < len(self._option_states) and value != self._option_states[index]:
            self._option_states[index] = value
            self.notify_toggle_option(index, value)
            self._update_state_buttons()

    def _on_state_button_value(self, index, value):
        min_button_index = int(bool(self._offset_index))
        max_button_index = len(self._state_button_slots) - int(self._maximal_offset() > self._offset_index)
        if self.is_enabled() and value:
            if in_range(index, min_button_index, max_button_index):
                index += max(0, self._offset_index - 1)
                if index < len(self._option_states):
                    new_state = not self.option_state(index)
                    self.set_option_state(index, new_state)
                else:
                    self.notify_press_option(None)
            else:
                self.notify_press_option(None)

    def _set_option_names(self, names):
        """ overrides """
        if self.option_names != names:
            self._option_states = [ False for _ in range(len(names)) ]
            super(ScrollableListWithTogglesComponent, self)._set_option_names(names)

    def update(self):
        super(ScrollableListWithTogglesComponent, self).update()
        self._update_state_buttons()

    def _update_state_buttons(self):
        if not self.is_enabled():
            return
        buttons = [ slot.subject for slot in self._state_button_slots ]
        if buttons[0]:
            first_button, max_button = 0, len(buttons)
            if self._offset_index > 0:
                buttons[0].turn_off()
                first_button = 1
            if self._offset_index < self._maximal_offset():
                buttons[-1].turn_off()
                max_button -= 1
            for state, button in zip(self._option_states[self._offset_index:], buttons[first_button:max_button]):
                if button != None:
                    if state:
                        button.turn_on()
                    else:
                        button.turn_off()

            for button in buttons[len(self._option_states):]:
                if button != None:
                    button.turn_off()
########NEW FILE########
__FILENAME__ = SelectedTrackParameterProvider
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/SelectedTrackParameterProvider.py
from _Framework.Dependency import depends
from _Framework.SubjectSlot import subject_slot, SlotManager
from DeviceParameterComponent import ParameterProvider
from SpecialChanStripComponent import TRACK_PARAMETER_NAMES

class SelectedTrackParameterProvider(ParameterProvider, SlotManager):

    @depends(song=None)
    def __init__(self, song = None, *a, **k):
        super(SelectedTrackParameterProvider, self).__init__(*a, **k)
        self._track = None
        self._on_selected_track.subject = song.view
        self._on_visible_tracks.subject = song
        self._on_selected_track()

    @property
    def parameters(self):
        if self._track:
            return zip(TRACK_PARAMETER_NAMES, [self._track.mixer_device.volume, self._track.mixer_device.panning] + list(self._track.mixer_device.sends))
        return []

    @subject_slot('visible_tracks')
    def _on_visible_tracks(self):
        self.notify_parameters()

    @subject_slot('selected_track')
    def _on_selected_track(self):
        self._track = self._on_selected_track.subject.selected_track
        self.notify_parameters()
########NEW FILE########
__FILENAME__ = Selection
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/Selection.py
"""
Object that encapsulates selection in the L9C controller.
"""
import Live

class Selection(object):
    """
    Object that encapsulates selection.
    
    [jbo] The intent of this object is to grow its interface until no
    'view.selected_*' access are done in any part of the script.  This
    way, it should be easy to change our selection model such that
    multiple-L9C controllers can play together properly.  Also, feel
    free to make these properties listenables when neccesary.
    """

    @property
    def selected_device(self):
        """
        Device with the blue hand.
        """
        raise NotImplementedError

    @property
    def selected_object(self):
        """
        Current object that is selected.
        """
        raise NotImplementedError

    @property
    def selected_track(self):
        """
        Current track that is selected.
        """
        raise NotImplementedError

    @property
    def selected_scene(self):
        """
        Current scene that is selected.
        """
        raise NotImplementedError

    @property
    def hotswap_target(self):
        """
        Current object that is selected.
        """
        raise NotImplementedError


class L9CSelection(Selection):
    """
    L9C selection object.  So far it is read-only and just accesses
    the appropiate components.  Ideally we should refactor a bit and
    make all components set and query the selection via this object
    and not otherwise.
    """

    def __init__(self, application = None, device_component = None, navigation_component = None, *a, **k):
        super(L9CSelection, self).__init__(*a, **k)
        self._device_component = device_component
        self._navigation_component = navigation_component
        self._application = application
        self._browser = application.browser

    @property
    def selected_device(self):
        return self._device_component.device()

    def _get_selected_object(self):
        return self._navigation_component.selected_object

    def _set_selected_object(self, lom_object):
        if isinstance(lom_object, Live.DrumPad.DrumPad):
            lom_object.canonical_parent.view.selected_drum_pad = lom_object
        if isinstance(lom_object, Live.Chain.Chain):
            lom_object.canonical_parent.view.selected_chain = lom_object
        else:
            self._application.get_document().view.select_device(lom_object)

    selected_object = property(_get_selected_object, _set_selected_object)

    @property
    def selected_track(self):
        return self._application.get_document().view.selected_track

    @property
    def hotswap_target(self):
        """
        Current object that is selected.
        """
        return self._browser.hotswap_target
########NEW FILE########
__FILENAME__ = SelectPlayingClipComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/SelectPlayingClipComponent.py
"""
Component that automatically selects the playing clip in the selected track.
"""
from _Framework.ModesComponent import ModesComponent, AddLayerMode
from _Framework.SubjectSlot import subject_slot
from _Framework.Util import forward_property, index_if, partial
from _Framework import Task
from MessageBoxComponent import NotificationComponent
from consts import NOTIFICATION_PRIORITY, MessageBoxText
from itertools import imap

class SelectPlayingClipComponent(ModesComponent):

    def __init__(self, playing_clip_above_layer = None, playing_clip_below_layer = None, *a, **k):
        super(SelectPlayingClipComponent, self).__init__(*a, **k)
        self._update_mode_task = self._tasks.add(Task.sequence(Task.delay(1), Task.run(self._update_mode)))
        self._update_mode_task.kill()
        self._notification = self.register_component(NotificationComponent(notification_time=-1, is_enabled=False))
        self.add_mode('default', None)
        self.add_mode('above', [AddLayerMode(self, playing_clip_above_layer), self._notification, partial(self._show_notification, MessageBoxText.PLAYING_CLIP_ABOVE_SELECTED_CLIP)])
        self.add_mode('below', [AddLayerMode(self, playing_clip_below_layer), self._notification, partial(self._show_notification, MessageBoxText.PLAYING_CLIP_BELOW_SELECTED_CLIP)])
        self.selected_mode = 'default'
        self._on_detail_clip_changed.subject = self.song().view
        self._on_playing_slot_index_changed.subject = self.song().view.selected_track

    notification_layer = forward_property('_notification')('message_box_layer')

    def set_action_button(self, button):
        self._on_action_button_value.subject = button
        self._update_action_button()

    @subject_slot('value')
    def _on_action_button_value(self, value):
        self._go_to_playing_clip()

    @subject_slot('detail_clip')
    def _on_detail_clip_changed(self):
        self._update_mode_task.restart()

    @subject_slot('playing_slot_index')
    def _on_playing_slot_index_changed(self):
        self._update_mode_task.restart()

    def _go_to_playing_clip(self):
        song_view = self.song().view
        playing_clip_slot = self._playing_clip_slot()
        if playing_clip_slot:
            song_view.highlighted_clip_slot = playing_clip_slot
            song_view.detail_clip = playing_clip_slot.clip

    def _show_notification(self, display_text):
        self._notification.show_notification(display_text, blink_text=MessageBoxText.SELECTED_CLIP_BLINK)

    def _selected_track_clip_is_playing(self):
        playing_clip_slot = self._playing_clip_slot()
        return playing_clip_slot and not playing_clip_slot.clip != self.song().view.detail_clip

    def _playing_clip_slot(self):
        track = self.song().view.selected_track
        try:
            playing_slot_index = track.playing_slot_index
            slot = track.clip_slots[playing_slot_index] if 0 <= playing_slot_index < len(track.clip_slots) else None
            return slot
        except RuntimeError:
            pass

    def _selected_track_clip_is_above_playing_clip(self):
        song_view = self.song().view
        track = song_view.selected_track
        playing_slot_index = track.playing_slot_index
        selected_index = index_if(lambda slot: slot == song_view.highlighted_clip_slot, track.clip_slots)
        return playing_slot_index <= selected_index

    def _update_mode(self):
        if not self._selected_track_clip_is_playing():
            if self._selected_track_clip_is_above_playing_clip():
                self.selected_mode = 'above'
            else:
                self.selected_mode = 'below'
        else:
            self.selected_mode = 'default'

    def _update_action_button(self):
        action_button = self._on_action_button_value.subject
        if action_button:
            action_button.set_light('DefaultButton.Alert')

    def update(self):
        if self.is_enabled():
            self._update_action_button()
            self._update_mode()
########NEW FILE########
__FILENAME__ = SessionRecordingComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/SessionRecordingComponent.py
from functools import partial
from _Framework.SubjectSlot import subject_slot
from _Framework.CompoundComponent import CompoundComponent
from _Framework.Util import forward_property, find_if, index_if
from _Framework import Task
from _Framework.ToggleComponent import ToggleComponent
from ActionWithOptionsComponent import ToggleWithOptionsComponent
from consts import MessageBoxText
from MessageBoxComponent import Messenger
import Live
_Q = Live.Song.Quantization
LAUNCH_QUANTIZATION = (_Q.q_quarter,
 _Q.q_half,
 _Q.q_bar,
 _Q.q_2_bars,
 _Q.q_4_bars,
 _Q.q_8_bars,
 _Q.q_8_bars,
 _Q.q_8_bars)
LENGTH_OPTION_NAMES = ('1 Beat', '2 Beats', '1 Bar', '2 Bars', '4 Bars', '8 Bars', '16 Bars', '32 Bars')
LENGTH_LABELS = ('Recording length:', '', '', '')

def track_fired_slot(track):
    index = track.fired_slot_index
    if index >= 0:
        return track.clip_slots[index]


def track_playing_slot(track):
    index = track.playing_slot_index
    if index >= 0:
        return track.clip_slots[index]


def track_is_recording(track):
    playing_slot = track_playing_slot(track)
    return playing_slot and playing_slot.is_recording


def track_will_record(track):
    fired_slot = track_fired_slot(track)
    return fired_slot and fired_slot.will_record_on_start


def track_can_overdub(track):
    return not track.has_audio_input


def song_selected_slot(song):
    view = song.view
    scene = view.selected_scene
    track = view.selected_track
    scene_index = list(song.scenes).index(scene)
    try:
        slot = track.clip_slots[scene_index]
    except IndexError:
        slot = None

    return slot


class SessionRecordingComponent(CompoundComponent, Messenger):
    """
    Orchestrates the session recording (clip slot based) workflow.
    """

    def __init__(self, clip_creator = None, view_controller = None, *a, **k):
        super(SessionRecordingComponent, self).__init__(*a, **k)
        raise clip_creator or AssertionError
        raise view_controller or AssertionError
        self._target_slots = []
        self._clip_creator = clip_creator
        self._view_controller = view_controller
        self._new_button = None
        self._scene_list_new_button = None
        self._record_button = None
        self._length_press_state = None
        self._new_scene_button = None
        self._fixed_length = self.register_component(ToggleWithOptionsComponent())
        self._length_selector = self._fixed_length.options
        self._length_selector.option_names = LENGTH_OPTION_NAMES
        self._length_selector.selected_option = 3
        self._length_selector.labels = LENGTH_LABELS
        self._on_selected_fixed_length_option_changed.subject = self._length_selector
        length, _ = self._get_selected_length()
        self._clip_creator.fixed_length = length
        song = self.song()
        self._automation_toggle, self._re_enable_automation_toggle, self._delete_automation = self.register_components(ToggleComponent('session_automation_record', song), ToggleComponent('re_enable_automation_enabled', song, read_only=True), ToggleComponent('has_envelopes', None, read_only=True))
        self._on_tracks_changed_in_live.subject = song
        self._on_is_playing_changed_in_live.subject = song
        self._track_subject_slots = self.register_slot_manager()
        self._reconnect_track_listeners()
        self.register_slot(song, self.update, 'overdub')
        self.register_slot(song, self.update, 'session_record_status')
        self.register_slot(song.view, self.update, 'selected_track')
        self.register_slot(song.view, self.update, 'selected_scene')
        self.register_slot(song.view, self.update, 'detail_clip')

    length_layer = forward_property('_length_selector')('layer')

    def set_record_button(self, button):
        self._record_button = button
        self._on_record_button_value.subject = button
        self._update_record_button()

    def set_automation_button(self, button):
        self._automation_toggle.set_toggle_button(button)

    def set_re_enable_automation_button(self, button):
        self._re_enable_automation_toggle.set_toggle_button(button)
        self._on_re_enable_automation_value.subject = button

    def set_delete_automation_button(self, button):
        self._delete_automation.set_toggle_button(button)
        self._on_delete_automation_value.subject = button

    def set_scene_list_new_button(self, button):
        self._scene_list_new_button = button
        self._on_scene_list_new_button_value.subject = button
        self._update_scene_list_new_button()

    def set_new_button(self, button):
        self._new_button = button
        self._on_new_button_value.subject = button
        self._update_new_button()

    def set_length_button(self, button):
        self._fixed_length.set_action_button(button)
        self._on_length_value.subject = button
        self._length_press_state = None

    def set_new_scene_button(self, button):
        self._new_scene_button = button
        self._on_new_scene_button_value.subject = button
        self._update_new_scene_button()

    def deactivate_recording(self):
        self._stop_recording()

    def update(self):
        if self.is_enabled():
            self._delete_automation.subject = self._get_playing_clip()
            self._update_record_button()
            self._update_new_button()
            self._update_scene_list_new_button()
            self._update_new_scene_button()

    def _update_scene_list_new_button(self):
        self._update_generic_new_button(self._scene_list_new_button)

    def _update_new_button(self):
        self._update_generic_new_button(self._new_button)

    def _update_generic_new_button(self, new_button):
        if new_button and self.is_enabled():
            song = self.song()
            selected_track = song.view.selected_track
            clip_slot = song.view.highlighted_clip_slot
            can_new = clip_slot != None and clip_slot.clip or selected_track.can_be_armed and selected_track.playing_slot_index >= 0
            new_button.set_light(new_button.is_pressed() if can_new else 'DefaultButton.Disabled')

    def _update_new_scene_button(self):
        if self._new_scene_button and self.is_enabled():
            song = self.song()
            track_is_playing = find_if(lambda x: x.playing_slot_index >= 0, song.tracks)
            can_new = not song.view.selected_scene.is_empty or track_is_playing
            self._new_scene_button.set_light(self._new_scene_button.is_pressed() if can_new else 'DefaultButton.Disabled')

    def _update_record_button(self):
        if self._record_button and self.is_enabled():
            song = self.song()
            status = song.session_record_status
            if status == Live.Song.SessionRecordStatus.transition:
                self._record_button.set_light('Recording.Transition')
            elif status == Live.Song.SessionRecordStatus.on or song.session_record:
                self._record_button.turn_on()
            else:
                self._record_button.turn_off()

    @subject_slot('value')
    def _on_re_enable_automation_value(self, value):
        if self.is_enabled() and value:
            self.song().re_enable_automation()

    @subject_slot('value')
    def _on_delete_automation_value(self, value):
        if self.is_enabled() and value:
            clip = self._get_playing_clip()
            selected_track = self.song().view.selected_track
            if selected_track:
                track_frozen = selected_track.is_frozen
                clip and not track_frozen and clip.clear_all_envelopes()

    def _get_playing_clip(self):
        playing_clip = None
        selected_track = self.song().view.selected_track
        try:
            playing_slot_index = selected_track.playing_slot_index
            if playing_slot_index >= 0:
                playing_clip = selected_track.clip_slots[playing_slot_index].clip
        except RuntimeError:
            pass

        return playing_clip

    @subject_slot('tracks')
    def _on_tracks_changed_in_live(self):
        self._reconnect_track_listeners()

    @subject_slot('is_playing')
    def _on_is_playing_changed_in_live(self):
        if self.is_enabled():
            self._update_record_button()

    @subject_slot('value')
    def _on_record_button_value(self, value):
        if self.is_enabled() and value:
            if not self._stop_recording():
                self._start_recording()

    @subject_slot('value')
    def _on_new_scene_button_value(self, value):
        if self.is_enabled() and value and self._prepare_new_action():
            song = self.song()
            selected_scene_index = list(song.scenes).index(song.view.selected_scene)
            try:
                self._create_silent_scene(selected_scene_index)
            except Live.Base.LimitationError:
                self.expect_dialog(MessageBoxText.SCENE_LIMIT_REACHED)

    @subject_slot('value')
    def _on_scene_list_new_button_value(self, value):
        if self.is_enabled() and value and self._prepare_new_action():
            song = self.song()
            view = song.view
            try:
                if view.highlighted_clip_slot.clip != None:
                    song.capture_and_insert_scene(Live.Song.CaptureMode.all_except_selected)
                else:
                    view.selected_track.stop_all_clips(False)
            except Live.Base.LimitationError:
                self.expect_dialog(MessageBoxText.SCENE_LIMIT_REACHED)

            self._view_selected_clip_detail()

    @subject_slot('value')
    def _on_new_button_value(self, value):
        if self.is_enabled() and value and self._prepare_new_action():
            song = self.song()
            view = song.view
            try:
                selected_track = view.selected_track
                selected_scene_index = list(song.scenes).index(view.selected_scene)
                selected_track.stop_all_clips(False)
                self._jump_to_next_slot(selected_track, selected_scene_index)
            except Live.Base.LimitationError:
                self.expect_dialog(MessageBoxText.SCENE_LIMIT_REACHED)

            self._view_selected_clip_detail()

    def _prepare_new_action(self):
        song = self.song()
        selected_track = song.view.selected_track
        if selected_track.can_be_armed:
            song.overdub = False
            return True

    def _has_clip(self, scene_or_track):
        return find_if(lambda x: x.clip != None, scene_or_track.clip_slots) != None

    def _create_silent_scene(self, scene_index):
        song = self.song()
        song.stop_all_clips(False)
        selected_scene = song.view.selected_scene
        if not selected_scene.is_empty:
            new_scene_index = list(song.scenes).index(selected_scene) + 1
            song.view.selected_scene = song.create_scene(new_scene_index)

    def _jump_to_next_slot(self, track, start_index):
        song = self.song()
        new_scene_index = self._next_empty_slot(track, start_index)
        song.view.selected_scene = song.scenes[new_scene_index]

    def _stop_recording(self):
        """ Retriggers all new recordings and returns true if there
        was any recording at all """
        song = self.song()
        status = song.session_record_status
        if not status != Live.Song.SessionRecordStatus.off:
            was_recording = song.session_record
            song.session_record = was_recording and False
        return was_recording

    def _start_recording(self):
        song = self.song()
        song.overdub = True
        selected_scene = song.view.selected_scene
        scene_index = list(song.scenes).index(selected_scene)
        track = song.view.selected_track
        if track.can_be_armed and (track.arm or track.implicit_arm):
            self._record_in_slot(track, scene_index)
        if not song.is_playing:
            song.is_playing = True

    def _find_last_clip(self):
        """ Finds the last clip of the session and returns the scene index """
        scenes = self.song().scenes
        return len(scenes) - index_if(self._has_clip, reversed(scenes)) - 1

    def _next_empty_slot(self, track, scene_index):
        """ Finds an empty slot in the track after the given position,
        creating new scenes if needed, and returns the found scene
        index """
        song = self.song()
        scene_count = len(song.scenes)
        while track.clip_slots[scene_index].has_clip:
            scene_index += 1
            if scene_index == scene_count:
                song.create_scene(scene_count)

        return scene_index

    def _record_in_slot(self, track, scene_index):
        song = self.song()
        clip_slot = track.clip_slots[scene_index]
        if self._fixed_length.is_active and not clip_slot.has_clip:
            length, quant = self._get_selected_length()
            if track_can_overdub(track):
                self._clip_creator.create(clip_slot, length)
            else:
                clip_slot.fire(record_length=length, launch_quantization=quant)
        elif not clip_slot.is_playing:
            if clip_slot.has_clip:
                clip_slot.fire(force_legato=True, launch_quantization=_Q.q_no_q)
            else:
                clip_slot.fire()
        if song.view.selected_track == track:
            song.view.selected_scene = song.scenes[scene_index]
        self._view_selected_clip_detail()

    @subject_slot('value')
    def _on_length_value(self, value):
        if value:
            self._on_length_press()
        else:
            self._on_length_release()

    @subject_slot('selected_option')
    def _on_selected_fixed_length_option_changed(self, _):
        length, _ = self._get_selected_length()
        self._clip_creator.fixed_length = length

    def _on_length_press(self):
        song = self.song()
        slot = song_selected_slot(song)
        if slot == None:
            return
        clip = slot.clip
        if slot.is_recording and not clip.is_overdubbing:
            self._length_press_state = (slot, clip.playing_position)

    def _on_length_release(self):
        song = self.song()
        slot = song_selected_slot(song)
        if slot == None:
            return
        clip = slot.clip
        if self._length_press_state is not None:
            press_slot, press_position = self._length_press_state
            if press_slot == slot and self._fixed_length.is_active and slot.is_recording and not clip.is_overdubbing:
                length, _ = self._get_selected_length()
                one_bar = 4.0 * song.signature_numerator / song.signature_denominator
                loop_end = int(press_position / one_bar) * one_bar
                loop_start = loop_end - length
                if loop_start >= 0.0:
                    clip.loop_end = loop_end
                    clip.end_marker = loop_end
                    clip.loop_start = loop_start
                    clip.start_marker = loop_start
                    self._tasks.add(Task.sequence(Task.delay(0), Task.run(partial(slot.fire, force_legato=True, launch_quantization=_Q.q_no_q))))
                    self.song().overdub = False
                self._fixed_length.is_active = False
        self._length_press_state = None

    def _get_selected_length(self):
        song = self.song()
        length = 2.0 ** self._length_selector.selected_option
        quant = LAUNCH_QUANTIZATION[self._length_selector.selected_option]
        if self._length_selector.selected_option > 1:
            length = length * song.signature_numerator / song.signature_denominator
        return (length, quant)

    def _view_selected_clip_detail(self):
        view = self.song().view
        if view.highlighted_clip_slot.clip:
            view.detail_clip = view.highlighted_clip_slot.clip
        self._view_controller.show_view('Detail/Clip')

    def _reconnect_track_listeners(self):
        manager = self._track_subject_slots
        manager.disconnect()
        for track in self.song().tracks:
            if track.can_be_armed:
                manager.register_slot(track, self.update, 'arm')
                manager.register_slot(track, self.update, 'playing_slot_index')
                manager.register_slot(track, self.update, 'fired_slot_index')

    def _set_scene_list_mode(self, scene_list_mode):
        self._scene_list_mode = scene_list_mode
        self._update_new_button()

    def _get_scene_list_mode(self):
        return self._scene_list_mode

    scene_list_mode = property(_get_scene_list_mode, _set_scene_list_mode)
########NEW FILE########
__FILENAME__ = Setting
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/Setting.py
from math import fabs
from _Framework.Util import sign, clamp
from _Framework.SubjectSlot import Subject, SubjectEvent

class Setting(Subject):
    """
    Setting interface for writing to the preferences and all
    information for changing and displaying it.
    """
    __subject_events__ = (SubjectEvent(name='value', doc=' Called when the value of the\n                                                 setting changes '),)

    def __init__(self, name = '', values = None, default_value = None, preferences = None, *a, **k):
        super(Setting, self).__init__(*a, **k)
        self.name = name
        if not values:
            self.values = []
            self._preferences = preferences if preferences != None else {}
            default_value = name in self._preferences and self._preferences[name] in values and self._preferences[name]
        self._preferences[name] = None
        self.value = default_value

    def __str__(self):
        return self.value_to_string(self.value)

    def _set_value(self, value):
        if not value in self.values:
            raise AssertionError
            self._preferences[self.name] = self._preferences[self.name] != value and value
            self.on_value_changed(value)
            self.notify_value(self)

    def _get_value(self):
        return self._preferences[self.name]

    value = property(_get_value, _set_value)

    def on_value_changed(self, value):
        pass

    def change_relative(self, value):
        """ Given a value between -1.0 and 1.0, this will decide on a new value. """
        raise NotImplementedError

    def value_to_string(self, value):
        raise NotImplementedError


class OnOffSetting(Setting):
    """ Simple on/off setting represented by a boolean value """
    THRESHOLD = 0.01

    def __init__(self, value_labels = ['On', 'Off'], *a, **k):
        super(OnOffSetting, self).__init__(values=[True, False], *a, **k)
        self._value_labels = value_labels

    def change_relative(self, value):
        if fabs(value) >= self.THRESHOLD:
            self.value = value > 0.0
            return True

    def value_to_string(self, value):
        return self._value_labels[int(not self.value)]


class EnumerableSetting(Setting):
    """ Setting to go through a list of values """
    STEP_SIZE = 0.1

    def __init__(self, value_formatter = str, *a, **k):
        super(EnumerableSetting, self).__init__(*a, **k)
        self._relative_value = 0.0
        self._value_formatter = value_formatter

    def change_relative(self, value):
        if sign(value) != sign(self._relative_value):
            self._relative_value = 0.0
        self._relative_value += value
        if fabs(self._relative_value) >= self.STEP_SIZE:
            relative_position = int(sign(self._relative_value))
            self._relative_value -= self.STEP_SIZE
            return self._jump_relative(relative_position) != None

    def _jump_relative(self, relative_position):
        current_position = self.values.index(self.value)
        new_position = clamp(current_position + relative_position, 0, len(self.values) - 1)
        self.value = self.values[new_position]
        return new_position if current_position != new_position else None

    def on_value_changed(self, value):
        self._relative_value = 0.0

    def value_to_string(self, value):
        return self._value_formatter(value)
########NEW FILE########
__FILENAME__ = Settings
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/Settings.py
from Setting import OnOffSetting, EnumerableSetting
from PadSensitivity import PadParameters
import consts

def make_pad_parameters(curve_value, threshold_value):
    """
    Creates a valid PadParameters object merging the sensitivity curve
    and threshold settings.
    """
    threshold_range = consts.MAX_THRESHOLD_STEP - consts.MIN_THRESHOLD_STEP
    t = float(threshold_value - consts.MIN_THRESHOLD_STEP) / float(threshold_range)
    return PadParameters(curve_value, on_threshold=int((1 - t) * consts.MIN_ON_THRESHOLD + t * consts.MAX_ON_THRESHOLD), off_threshold=int((1 - t) * consts.MIN_OFF_THRESHOLD + t * consts.MAX_OFF_THRESHOLD))


action_pad_sensitivity = PadParameters(off_threshold=190, on_threshold=210, gain=85000, curve1=120000, curve2=60000)

def _create_pad_settings():
    return [PadParameters(gain=100000, curve1=45000, curve2=0, name='Linear'),
     PadParameters(gain=85000, curve1=120000, curve2=60000, name='Log 1 (Default)'),
     PadParameters(gain=85000, curve1=120000, curve2=50000, name='Log 2'),
     PadParameters(gain=100000, curve1=120000, curve2=50000, name='Log 3'),
     PadParameters(gain=130000, curve1=120000, curve2=50000, name='Log 4'),
     PadParameters(gain=140000, curve1=120000, curve2=0, name='Log 5')]


def _threshold_formatter(value):
    return str(value) if value != 0 else '0 (Default)'


SETTING_THRESHOLD = 0
SETTING_CURVE = 1
SETTING_WORKFLOW = 2

def create_settings(preferences = None):
    preferences = preferences if preferences != None else {}
    pad_settings = _create_pad_settings()
    return {SETTING_WORKFLOW: OnOffSetting(name='Workflow', value_labels=['Scene', 'Clip'], default_value=True, preferences=preferences),
     SETTING_THRESHOLD: EnumerableSetting(name='Pad Threshold', values=range(consts.MIN_THRESHOLD_STEP, consts.MAX_THRESHOLD_STEP + 1), default_value=0, preferences=preferences, value_formatter=_threshold_formatter),
     SETTING_CURVE: EnumerableSetting(name='Velocity Curve', values=pad_settings, default_value=pad_settings[1], preferences=preferences)}
########NEW FILE########
__FILENAME__ = Skin
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/Skin.py
import SkinDefault

class SkinColorMissingError(Exception):
    pass


class Skin(object):

    def __init__(self, colors = None, *a, **k):
        super(Skin, self).__init__(*a, **k)
        self._colors = {}
        self._fill_colors(colors)

    def _fill_colors(self, colors, pathname = ''):
        try:
            self._fill_colors(super(colors))
        except TypeError:
            map(self._fill_colors, colors.__bases__)

        for k, v in colors.__dict__.iteritems():
            if k[:1] != '_':
                if callable(v):
                    self._fill_colors(v, pathname + k + '.')
                else:
                    self._colors[pathname + k] = v

    def __getitem__(self, key):
        try:
            return self._colors[key]
        except KeyError:
            raise SkinColorMissingError, 'Skin color missing: %s' % str(key)

    def iteritems(self):
        return self._colors.iteritems()


def make_default_skin():
    skin = Skin(SkinDefault.Colors)
    return skin
########NEW FILE########
__FILENAME__ = SkinDefault
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/SkinDefault.py
from Colors import Basic, Rgb, Pulse, Blink, BiLed

class Colors:

    class Option:
        Selected = BiLed.AMBER
        Unselected = BiLed.YELLOW_HALF
        On = BiLed.YELLOW
        Off = BiLed.OFF
        Unused = BiLed.OFF

    class List:
        ScrollerOn = BiLed.AMBER
        ScrollerOff = BiLed.AMBER_HALF

    class DefaultButton:
        On = Basic.FULL
        Off = Basic.HALF
        Disabled = Basic.OFF
        Alert = Basic.FULL_BLINK_SLOW

    class DefaultMatrix:
        On = Rgb.WHITE
        Off = Rgb.BLACK

    class Scales:
        Selected = BiLed.YELLOW
        Unselected = BiLed.GREEN_HALF
        FixedOn = BiLed.AMBER
        FixedOff = BiLed.YELLOW_HALF
        Diatonic = BiLed.AMBER
        Chromatic = BiLed.YELLOW_HALF

    class Instrument:
        NoteBase = Rgb.OCEAN
        NoteScale = Rgb.WHITE
        NoteNotScale = Rgb.BLACK
        NoteInvalid = Rgb.BLACK
        Feedback = Rgb.GREEN
        FeedbackRecord = Rgb.RED.shade(1)
        NoteAction = Rgb.RED

    class Recording:
        On = Basic.FULL
        Off = Basic.HALF
        Transition = Basic.FULL_BLINK_FAST

    class Session:
        SceneSelected = BiLed.GREEN
        SceneUnselected = BiLed.OFF
        SceneTriggered = BiLed.GREEN_BLINK_FAST
        ClipStopped = Rgb.AMBER
        ClipStarted = Pulse(Rgb.GREEN.shade(1), Rgb.GREEN, 48)
        ClipRecording = Pulse(Rgb.BLACK, Rgb.RED, 48)
        ClipTriggeredPlay = Blink(Rgb.GREEN, Rgb.BLACK, 24)
        ClipTriggeredRecord = Blink(Rgb.RED, Rgb.BLACK, 24)
        ClipEmpty = Rgb.BLACK
        RecordButton = Rgb.RED.shade(2)

    class Zooming:
        Selected = Rgb.AMBER
        Stopped = Rgb.RED
        Playing = Rgb.GREEN
        Empty = Rgb.BLACK

    class TrackState:
        Common = Rgb.BLACK
        Stopped = Rgb.RED
        Disabled = Basic.OFF

    class DrumGroup:
        PadSelected = Rgb.OCEAN
        PadSelectedNotSoloed = Rgb.OCEAN
        PadFilled = Rgb.YELLOW
        PadEmpty = Rgb.YELLOW.shade(2)
        PadMuted = Rgb.AMBER.shade(1)
        PadMutedSelected = Rgb.OCEAN.shade(1)
        PadSoloed = Rgb.BLUE
        PadSoloedSelected = Rgb.OCEAN.highlight()
        PadInvisible = Rgb.BLACK
        PadAction = Rgb.RED

    class LoopSelector:
        Playhead = Rgb.GREEN
        PlayheadRecord = Rgb.RED
        SelectedPage = Rgb.YELLOW.highlight()
        InsideLoopStartBar = Rgb.WHITE
        InsideLoop = Rgb.WHITE
        OutsideLoop = Rgb.BLACK

    class NoteEditor:

        class Step:
            Low = Rgb.SKY.highlight()
            High = Rgb.OCEAN
            Full = Rgb.BLUE
            Muted = Rgb.AMBER.shade(2)

        class StepEditing:
            Low = Rgb.YELLOW.highlight()
            High = Rgb.YELLOW
            Full = Rgb.AMBER
            Muted = Rgb.WHITE

        StepSelected = Rgb.WHITE
        StepEmpty = Rgb.BLACK
        StepEmptyBase = Rgb.OCEAN.shade(2)
        StepEmptyScale = Rgb.DARK_GREY
        StepDisabled = Rgb.RED.shade(2)
        Playhead = Rgb.GREEN
        PlayheadRecord = Rgb.RED
        QuantizationSelected = BiLed.GREEN
        QuantizationUnselected = BiLed.YELLOW
        NoteBase = Rgb.OCEAN.shade(2)
        NoteScale = Rgb.DARK_GREY
        NoteNotScale = Rgb.BLACK
        NoteInvalid = Rgb.RED.shade(2)

    class Melodic:
        Playhead = Rgb.GREEN.shade(1)
        PlayheadRecord = Rgb.RED.shade(1)

    class NoteRepeat:
        RateSelected = BiLed.RED
        RateUnselected = BiLed.YELLOW

    class Mixer:
        SoloOn = Rgb.BLUE
        SoloOff = Rgb.DARK_GREY
        MuteOn = Rgb.DARK_GREY
        MuteOff = BiLed.YELLOW
        StopTrack = Rgb.RED
        StoppingTrack = Blink(Rgb.RED, Rgb.BLACK, 24)
        ArmSelected = BiLed.RED
        ArmUnselected = BiLed.RED_HALF

    class Browser:
        Load = BiLed.GREEN
        LoadNext = BiLed.YELLOW
        LoadNotPossible = BiLed.OFF
        Loading = BiLed.OFF

    class MessageBox:
        Cancel = BiLed.GREEN
########NEW FILE########
__FILENAME__ = SlideComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/SlideComponent.py
"""
Component that navigates a series of pages.
"""
from math import ceil
from itertools import imap
from _Framework.SubjectSlot import subject_slot, Subject
from _Framework.CompoundComponent import CompoundComponent
from _Framework.ScrollComponent import ScrollComponent, Scrollable
from _Framework.Util import clamp
from TouchStripElement import TouchStripElement, TouchStripHandle, DraggingBehaviour, SelectingBehaviour, MAX_PITCHBEND

class Slideable(Subject):
    """
    Models of an entity that has a position in a 1-D discrete axis,
    and that has some natural steps (called pages) of this axis.
    """
    __subject_events__ = ('page_offset', 'page_length', 'position', 'position_count', 'contents')

    def contents_range(self, pmin, pmax):
        """
        Tells whether there are any contents in the (min, max) range,
        wheren min and max are floats in the (0, position_count)
        range. Can be left unimplemented.
        """
        pos_count = self.position_count
        first_pos = max(int(pmin), 0)
        last_pos = min(int(pmax), pos_count)
        return xrange(first_pos, last_pos)

    def contents(self, position):
        return False

    @property
    def position_count(self):
        raise NotImplementedError

    @property
    def position(self):
        raise NotImplementedError

    @property
    def page_offset(self):
        raise NotImplementedError

    @property
    def page_length(self):
        raise NotImplementedError


class SlideComponent(CompoundComponent, Scrollable):

    def __init__(self, slideable = None, dragging_enabled = False, *a, **k):
        super(SlideComponent, self).__init__(*a, **k)
        slideable = slideable or self
        self._behaviour = DraggingBehaviour() if dragging_enabled else SelectingBehaviour()
        self._touch_strip_array = []
        self._slideable = slideable
        self._position_scroll, self._page_scroll = self.register_components(ScrollComponent(), ScrollComponent())
        self._position_scroll.scrollable = self
        self._page_scroll.can_scroll_up = self.can_scroll_page_up
        self._page_scroll.can_scroll_down = self.can_scroll_page_down
        self._page_scroll.scroll_down = self.scroll_page_down
        self._page_scroll.scroll_up = self.scroll_page_up
        self._on_page_length_changed.subject = slideable
        self._on_page_offset_changed.subject = slideable
        self._on_position_count_changed.subject = slideable
        self._on_position_changed.subject = slideable
        self._on_contents_changed.subject = slideable

    def set_page_strip(self, strip):
        self._on_page_touch_strip_value.subject = strip
        self._update_touch_strip_state(strip)

    def set_scroll_strip(self, strip):
        self._on_touch_strip_value.subject = strip
        self._update_touch_strip_state(strip)

    def set_scroll_up_button(self, button):
        self._position_scroll.set_scroll_up_button(button)

    def set_scroll_down_button(self, button):
        self._position_scroll.set_scroll_down_button(button)

    def set_scroll_page_up_button(self, button):
        self._page_scroll.set_scroll_up_button(button)

    def set_scroll_page_down_button(self, button):
        self._page_scroll.set_scroll_down_button(button)

    def scroll_page_up(self):
        self._scroll_page(1)

    def scroll_page_down(self):
        self._scroll_page(-1)

    def scroll_up(self):
        self._scroll_position(1)

    def scroll_down(self):
        self._scroll_position(-1)

    def can_scroll_page_up(self):
        model = self._slideable
        return model.position < model.position_count - model.page_length

    def can_scroll_page_down(self):
        return self._slideable.position > 0

    def can_scroll_up(self):
        return self.can_scroll_page_up()

    def can_scroll_down(self):
        return self.can_scroll_page_down()

    def update(self):
        self._touch_strip_array = []
        self._update_touch_strips()

    def _scroll_position(self, delta):
        if self.is_enabled():
            model = self._slideable
            model.position = clamp(model.position + delta, 0, model.position_count - model.page_length)

    def _scroll_page(self, sign):
        if self.is_enabled():
            model = self._slideable
            remainder = (model.position - model.page_offset) % model.page_length
            if sign > 0:
                delta = model.page_length - remainder
            elif remainder == 0:
                delta = -model.page_length
            else:
                delta = -remainder
            self._scroll_position(delta)

    def _update_touch_strips(self):
        self._update_touch_strip_state(self._on_touch_strip_value.subject)
        self._update_touch_strip_state(self._on_page_touch_strip_value.subject)

    def _scroll_to_led_position(self, scroll_pos, num_leds):
        scroll_pos += 1
        pos_count = self._slideable.position_count
        return min(int(float(scroll_pos) / pos_count * num_leds), num_leds)

    def _touch_strip_to_scroll_position(self, value):
        bank_size = self._slideable.page_length
        num_pad_rows = self._slideable.position_count
        max_pad_row = num_pad_rows - bank_size
        return min(int(float(value) / MAX_PITCHBEND * num_pad_rows), max_pad_row)

    def _touch_strip_to_page_position(self, value):
        bank_size = self._slideable.page_length
        num_pad_rows = self._slideable.position_count
        max_pad_row = num_pad_rows - bank_size
        offset = bank_size - self._slideable.page_offset
        return clamp(int(int(value / MAX_PITCHBEND * num_pad_rows + offset) / float(bank_size)) * bank_size - offset, 0, max_pad_row)

    def _scroll_to_touch_strip_position(self, scroll_pos):
        num_pad_rows = self._slideable.position_count
        return min(int(float(scroll_pos) / num_pad_rows * MAX_PITCHBEND), int(MAX_PITCHBEND))

    def _touch_strip_led_page_length(self, num_leds):
        return int(ceil(float(self._slideable.page_length) / self._slideable.position_count * num_leds))

    def _update_touch_strip_state(self, strip):
        if strip and self.is_enabled():
            strip.behaviour = self._behaviour
            if len(self._touch_strip_array) != strip.STATE_COUNT:
                self._update_touch_strip_array(strip.STATE_COUNT)
            model_pos = self._slideable.position
            led_pos = self._scroll_to_led_position(model_pos, strip.STATE_COUNT)
            strip_pos = self._scroll_to_touch_strip_position(model_pos)
            array = list(self._touch_strip_array)
            led_page_length = self._touch_strip_led_page_length(strip.STATE_COUNT)
            array[led_pos:led_pos + led_page_length] = [strip.STATE_FULL] * led_page_length
            led_size = MAX_PITCHBEND / strip.STATE_COUNT
            self._behaviour.handle = TouchStripHandle(range=(-led_size, led_size * led_page_length), position=strip_pos)
            strip.send_state(array[:strip.STATE_COUNT])

    def _update_touch_strip_array(self, num_leds):
        if self.is_enabled():
            model = self._slideable

            def led_contents(i):
                pmin = float(i) / num_leds * model.position_count
                pmax = pmin + float(model.position_count) / num_leds
                return any(imap(model.contents, model.contents_range(pmin, pmax)))

            array = [ (TouchStripElement.STATE_HALF if led_contents(i) else TouchStripElement.STATE_OFF) for i in xrange(num_leds) ]
            self._touch_strip_array = array

    @subject_slot('value')
    def _on_touch_strip_value(self, value):
        if self.is_enabled():
            position = self._touch_strip_to_scroll_position(value)
            self._slideable.position = position

    @subject_slot('value')
    def _on_page_touch_strip_value(self, value):
        if self.is_enabled():
            position = self._touch_strip_to_page_position(value)
            self._slideable.position = position

    @subject_slot('page_length')
    def _on_page_length_changed(self):
        self._update_touch_strips()

    @subject_slot('page_offset')
    def _on_page_offset_changed(self):
        pass

    @subject_slot('position')
    def _on_position_changed(self):
        self._update_touch_strips()
        self._position_scroll.update()
        self._page_scroll.update()

    @subject_slot('position_count')
    def _on_position_count_changed(self):
        pass

    @subject_slot('contents')
    def _on_contents_changed(self):
        self.update()
########NEW FILE########
__FILENAME__ = SpecialChanStripComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/SpecialChanStripComponent.py
from _Framework.Util import flatten
from _Framework import Task
from _Framework.SubjectSlot import subject_slot, subject_slot_group
from _Framework.ChannelStripComponent import ChannelStripComponent
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.InputControlElement import ParameterSlot
from _Framework.TrackArmState import TrackArmState
from MessageBoxComponent import Messenger
from consts import MessageBoxText
import consts
import Live
TRACK_FOLD_DELAY = 0.5
TRACK_PARAMETER_NAMES = ('Volume', 'Pan', 'Send A', 'Send B', 'Send C', 'Send D', 'Send E', 'Send F', 'Send G', 'Send H', 'Send I', 'Send J', 'Send K', 'Send L')

def param_value_to_graphic(param, graphic):
    if param != None:
        param_range = param.max - param.min
        graph_range = len(graphic) - 1
        value = int((param.value - param.min) / param_range * graph_range)
        graphic_display_string = graphic[value]
    else:
        graphic_display_string = ' '
    return graphic_display_string


class SpecialChanStripComponent(ChannelStripComponent, Messenger):
    """
    Channel strip component with press & hold mute solo and stop
    buttons
    """

    def __init__(self, *a, **k):
        super(SpecialChanStripComponent, self).__init__(*a, **k)
        self.empty_color = 'Option.Unused'
        self._invert_mute_feedback = True
        self._duplicate_button = None
        self._selector_button = None
        self._delete_handler = None
        self._track_parameter_name_sources = [ DisplayDataSource(' ') for _ in xrange(14) ]
        self._track_parameter_data_sources = [ DisplayDataSource(' ') for _ in xrange(14) ]
        self._track_parameter_graphic_sources = [ DisplayDataSource(' ') for _ in xrange(14) ]
        self._on_return_tracks_changed.subject = self.song()
        self._on_selected_track_changed.subject = self.song().view
        self._fold_task = self._tasks.add(Task.sequence(Task.wait(TRACK_FOLD_DELAY), Task.run(self._do_fold_track))).kill()
        self._cue_volume_slot = self.register_disconnectable(ParameterSlot())
        self._track_state = self.register_disconnectable(TrackArmState())
        self._on_arm_state_changed.subject = self._track_state

    def set_delete_handler(self, delete_handler):
        self._delete_handler = delete_handler

    def set_volume_control(self, control):
        if control != None:
            control.mapping_sensitivity = consts.CONTINUOUS_MAPPING_SENSITIVITY
        super(SpecialChanStripComponent, self).set_volume_control(control)

    def set_pan_control(self, control):
        if control != None:
            control.mapping_sensitivity = consts.CONTINUOUS_MAPPING_SENSITIVITY
        super(SpecialChanStripComponent, self).set_pan_control(control)

    def set_send_controls(self, controls):
        if controls != None:
            for control in controls:
                if control != None:
                    control.mapping_sensitivity = consts.CONTINUOUS_MAPPING_SENSITIVITY

        super(SpecialChanStripComponent, self).set_send_controls(controls)

    def set_cue_volume_control(self, control):
        if control != None:
            control.mapping_sensitivity = consts.CONTINUOUS_MAPPING_SENSITIVITY
        self._cue_volume_slot.control = control

    def set_duplicate_button(self, duplicate_button):
        self._duplicate_button = duplicate_button

    def set_selector_button(self, selector_button):
        self._selector_button = selector_button

    def track_parameter_data_sources(self, index):
        return self._track_parameter_data_sources[index]

    def track_parameter_graphic_sources(self, index):
        return self._track_parameter_graphic_sources[index]

    def track_parameter_name_sources(self, index):
        return self._track_parameter_name_sources[index]

    def get_track(self):
        return self._track

    def set_track(self, track):
        self._track_state.set_track(track)
        super(SpecialChanStripComponent, self).set_track(track)
        self._update_track_listeners()
        self._update_parameter_name_sources()
        self._update_parameter_values()

    @subject_slot('arm')
    def _on_arm_state_changed(self):
        if self.is_enabled() and self._track:
            self._update_track_button()

    @subject_slot('return_tracks')
    def _on_return_tracks_changed(self):
        self._update_track_listeners()
        self._update_parameter_name_sources()
        self._update_parameter_values()

    @subject_slot('selected_track')
    def _on_selected_track_changed(self):
        self.on_selected_track_changed()

    def on_selected_track_changed(self):
        self._update_track_listeners()
        self._update_track_name_data_source()
        self._update_track_button()

    def _update_track_button(self):
        if self.is_enabled() and self._select_button != None:
            if self._track == None:
                self._select_button.set_light(self.empty_color)
            elif self._track.can_be_armed and (self._track.arm or self._track.implicit_arm):
                if self._track == self.song().view.selected_track:
                    self._select_button.set_light('Mixer.ArmSelected')
                else:
                    self._select_button.set_light('Mixer.ArmUnselected')
            elif self._track == self.song().view.selected_track:
                self._select_button.turn_on()
            else:
                self._select_button.turn_off()

    def _update_track_listeners(self):
        mixer = self._track.mixer_device if self._track else None
        sends = mixer.sends if mixer and self._track != self.song().master_track else ()
        cue_volume = mixer.cue_volume if self._track == self.song().master_track else None
        self._cue_volume_slot.parameter = cue_volume
        self._on_volume_value_changed.subject = mixer and mixer.volume
        self._on_panning_value_changed.subject = mixer and mixer.panning
        self._on_sends_value_changed.replace_subjects(sends)

    def _update_parameter_name_sources(self):
        num_params = self._track and len(self._track.mixer_device.sends) + 2
        for index, source in enumerate(self._track_parameter_name_sources):
            if index < num_params:
                source.set_display_string(TRACK_PARAMETER_NAMES[index])
            else:
                source.set_display_string(' ')

    def _update_track_name_data_source(self):
        if self._track_name_data_source:
            if self._track != None:
                selected = self._track == self.song().view.selected_track
                prefix = consts.CHAR_SELECT if selected else ''
                self._track_name_data_source.set_display_string(prefix + self._track.name)
            else:
                self._track_name_data_source.set_display_string(' ')

    @property
    def _is_deleting(self):
        return self._delete_handler and self._delete_handler.is_deleting

    def _select_value(self, value):
        if self.is_enabled() and self._track:
            if value and self._duplicate_button and self._duplicate_button.is_pressed():
                self._do_duplicate_track(self._track)
            elif value and self._is_deleting:
                self._do_delete_track(self._track)
            elif value and self._shift_pressed:
                self._do_toggle_arm(exclusive=False)
            else:
                self._select_value_without_modifier(value)

    def _mute_value(self, value):
        if self.is_enabled() and self._track != None:
            if not self._mute_button.is_momentary() or value != 0:
                if self._is_deleting:
                    self._delete_handler.delete_clip_envelope(self._track.mixer_device.track_activator)
                else:
                    super(SpecialChanStripComponent, self)._mute_value(value)

    def _do_toggle_arm(self, exclusive = False):
        if self._track.can_be_armed:
            self._track.arm = not self._track.arm
            if exclusive and (self._track.implicit_arm or self._track.arm):
                for track in self.song().tracks:
                    if track.can_be_armed and track != self._track:
                        track.arm = False

    def _select_value_without_modifier(self, value):
        if value and self.song().view.selected_track == self._track:
            self._do_toggle_arm(exclusive=self.song().exclusive_arm)
        else:
            super(SpecialChanStripComponent, self)._select_value(value)
        if value and self._track.is_foldable and self._select_button.is_momentary():
            self._fold_task.restart()
        else:
            self._fold_task.kill()

    def _do_delete_track(self, track):
        try:
            track_index = list(self.song().tracks).index(track)
            name = track.name
            self.song().delete_track(track_index)
            self.show_notification(MessageBoxText.DELETE_TRACK % name)
        except RuntimeError:
            self.expect_dialog(MessageBoxText.TRACK_DELETE_FAILED)
        except ValueError:
            pass

    def _do_duplicate_track(self, track):
        try:
            track_index = list(self.song().tracks).index(track)
            self.song().duplicate_track(track_index)
            self.show_notification(MessageBoxText.DUPLICATE_TRACK % track.name)
        except Live.Base.LimitationError:
            self.expect_dialog(MessageBoxText.TRACK_LIMIT_REACHED)
        except RuntimeError:
            self.expect_dialog(MessageBoxText.TRACK_DUPLICATION_FAILED)
        except ValueError:
            pass

    def _do_select_track(self, track):
        pass

    def _do_fold_track(self):
        if self.is_enabled() and self._track != None and self._track.is_foldable:
            self._track.fold_state = not self._track.fold_state

    @subject_slot('value')
    def _on_volume_value_changed(self):
        if self.is_enabled() and self._track != None:
            param = self._track.mixer_device.volume
            text = self._track_parameter_data_sources[0]
            graph = self._track_parameter_graphic_sources[0]
            text.set_display_string(str(param))
            graph.set_display_string(param_value_to_graphic(param, consts.GRAPH_VOL))

    @subject_slot('value')
    def _on_panning_value_changed(self):
        if self.is_enabled() and self._track != None:
            param = self._track.mixer_device.panning
            text = self._track_parameter_data_sources[1]
            graph = self._track_parameter_graphic_sources[1]
            text.set_display_string(str(param))
            graph.set_display_string(param_value_to_graphic(param, consts.GRAPH_PAN))

    @subject_slot_group('value')
    def _on_sends_value_changed(self, send):
        if self.is_enabled() and self._track != None and self._track != self.song().master_track and send in list(self._track.mixer_device.sends):
            index = list(self._track.mixer_device.sends).index(send) + 2
            text = self._track_parameter_data_sources[index]
            graph = self._track_parameter_graphic_sources[index]
            text.set_display_string(str(send))
            graph.set_display_string(param_value_to_graphic(send, consts.GRAPH_VOL))

    def _update_parameter_values(self):
        for source in flatten(zip(self._track_parameter_data_sources, self._track_parameter_graphic_sources)):
            source.set_display_string(' ')

        self._on_volume_value_changed()
        self._on_panning_value_changed()
        if self._track and self._track != self.song().master_track:
            map(self._on_sends_value_changed, self._track.mixer_device.sends)
########NEW FILE########
__FILENAME__ = SpecialMixerComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/SpecialMixerComponent.py
from _Framework.SubjectSlot import subject_slot
from _Framework.MixerComponent import MixerComponent
from _Framework.DisplayDataSource import DisplayDataSource
from SpecialChanStripComponent import SpecialChanStripComponent

def tracks_to_use_from_song(song):
    return tuple(song.visible_tracks) + tuple(song.return_tracks)


class SpecialMixerComponent(MixerComponent):
    """
    Special mixer class that uses return tracks alongside midi and
    audio tracks.  This provides also a more convenient interface to
    set controls for the different modes of the L9C.
    """
    num_label_segments = 4

    def __init__(self, *a, **k):
        super(SpecialMixerComponent, self).__init__(*a, **k)
        self._pan_send_index = 0
        self._pan_send_controls = None
        self._pan_send_names_display = None
        self._pan_send_values_display = None
        self._pan_send_graphics_display = None
        self._pan_send_toggle_skip = False
        self._selected_track_data_sources = map(DisplayDataSource, ('',) * self.num_label_segments)
        self._selected_track_data_sources[0].set_display_string('Track Selection:')
        self._selected_track_name_data_source = self._selected_track_data_sources[1]
        self._on_selected_track_changed.subject = self.song().view
        self._update_selected_track_name()

    def tracks_to_use(self):
        return tracks_to_use_from_song(self.song())

    def _create_strip(self):
        return SpecialChanStripComponent()

    def set_pan_send_toggle(self, toggle):
        """
        The pan_send_toggle cycles through the different pan, or send
        modes changing the bejhaviour of the pan_send display and
        controls.
        """
        self._pan_send_toggle = toggle
        self._on_pan_send_value.subject = toggle
        self._pan_send_toggle_skip = True

    def set_selected_values_display(self, display):
        if display:
            sources = [ self.selected_strip().track_parameter_data_sources(index) for index in xrange(8) ]
            display.set_data_sources(sources)

    def set_selected_graphics_display(self, display):
        if display:
            sources = [ self.selected_strip().track_parameter_graphic_sources(index) for index in xrange(8) ]
            display.set_data_sources(sources)

    def set_selected_names_display(self, display):
        if display:
            sources = [ self.selected_strip().track_parameter_name_sources(index) for index in xrange(8) ]
            display.set_data_sources(sources)

    def set_selected_track_name_display(self, display):
        if display:
            display.set_data_sources(self._selected_track_data_sources)

    def set_track_select_buttons(self, buttons):
        for strip, button in map(None, self._channel_strips, buttons or []):
            if button:
                button.set_on_off_values('Option.Selected', 'Option.Unselected')
            strip.set_select_button(button)

    def set_solo_buttons(self, buttons):
        for strip, button in map(None, self._channel_strips, buttons or []):
            if button:
                button.set_on_off_values('Mixer.SoloOn', 'Mixer.SoloOff')
            strip.set_solo_button(button)

    def set_mute_buttons(self, buttons):
        for strip, button in map(None, self._channel_strips, buttons or []):
            if button:
                button.set_on_off_values('Mixer.MuteOff', 'Mixer.MuteOn')
            strip.set_mute_button(button)

    def set_track_names_display(self, display):
        if display:
            sources = [ strip.track_name_data_source() for strip in self._channel_strips ]
            display.set_data_sources(sources)

    def set_volume_names_display(self, display):
        self._set_parameter_names_display(display, 0)

    def set_volume_values_display(self, display):
        self._set_parameter_values_display(display, 0)

    def set_volume_graphics_display(self, display):
        self._set_parameter_graphics_display(display, 0)

    def set_volume_controls(self, controls):
        for strip, control in map(None, self._channel_strips, controls or []):
            strip.set_volume_control(control)

    def set_pan_send_names_display(self, display):
        self._normalize_pan_send_index()
        self._pan_send_names_display = display
        self._set_parameter_names_display(display, self._pan_send_index + 1)

    def set_pan_send_values_display(self, display):
        self._normalize_pan_send_index()
        self._pan_send_values_display = display
        self._set_parameter_values_display(display, self._pan_send_index + 1)

    def set_pan_send_graphics_display(self, display):
        self._normalize_pan_send_index()
        self._pan_send_graphics_display = display
        self._set_parameter_graphics_display(display, self._pan_send_index + 1)

    def set_pan_send_controls(self, controls):
        self.set_send_controls(None)
        self.set_pan_controls(None)
        self._pan_send_controls = controls
        self._normalize_pan_send_index()
        if self._pan_send_index == 0:
            self.set_pan_controls(controls)
        else:
            sends = self._pan_send_index - 1
            self.set_send_controls(map(lambda ctl: (None,) * sends + (ctl,), controls or []))

    def set_selected_controls(self, controls):
        strip = self.selected_strip()
        if controls:
            strip.set_volume_control(controls[0])
            strip.set_pan_control(controls[1])
            strip.set_send_controls(controls[2:])
        else:
            strip.set_volume_control(None)
            strip.set_pan_control(None)
            strip.set_send_controls(tuple())

    def on_track_list_changed(self):
        super(SpecialMixerComponent, self).on_track_list_changed()
        self._update_pan_sends()

    def set_pan_controls(self, controls):
        for strip, control in map(None, self._channel_strips, controls or []):
            strip.set_pan_control(control)

    def set_send_controls(self, controls):
        for strip, control in map(None, self._channel_strips, controls or []):
            strip.set_send_controls(control)

    def _set_parameter_names_display(self, display, parameter):
        if display:
            sources = [ strip.track_parameter_name_sources(parameter) for strip in self._channel_strips ]
            display.set_data_sources(sources)

    def _set_parameter_values_display(self, display, parameter):
        if display:
            sources = [ strip.track_parameter_data_sources(parameter) for strip in self._channel_strips ]
            display.set_data_sources(sources)

    def _set_parameter_graphics_display(self, display, parameter):
        if display:
            sources = [ strip.track_parameter_graphic_sources(parameter) for strip in self._channel_strips ]
            display.set_data_sources(sources)

    @subject_slot('value')
    def _on_pan_send_value(self, value):
        if not self._pan_send_toggle_skip and self.is_enabled() and (value or not self._pan_send_toggle.is_momentary()):
            self._pan_send_index += 1
            self._update_pan_sends()
        self._pan_send_toggle_skip = False

    def _update_pan_sends(self):
        self.set_pan_send_controls(self._pan_send_controls)
        self.set_pan_send_names_display(self._pan_send_names_display)
        self.set_pan_send_graphics_display(self._pan_send_graphics_display)

    def _normalize_pan_send_index(self):
        if len(self.song().tracks) == 0 or self._pan_send_index > len(self.song().tracks[0].mixer_device.sends):
            self._pan_send_index = 0

    def _reassign_tracks(self):
        tracks = self.tracks_to_use()
        returns = self.song().return_tracks
        num_empty_tracks = max(0, len(self._channel_strips) + self._track_offset - len(tracks))
        num_visible_tracks = max(0, len(tracks) - len(returns) - self._track_offset)
        num_visible_returns = len(self._channel_strips) - num_empty_tracks - num_visible_tracks
        for index in range(len(self._channel_strips)):
            track_index = self._track_offset + index
            if len(tracks) > track_index:
                track = tracks[track_index]
                if tracks[track_index] not in returns:
                    self._channel_strips[index].set_track(track)
                else:
                    self._channel_strips[index + num_empty_tracks].set_track(track)
            else:
                self._channel_strips[index - num_visible_returns].set_track(None)

    @subject_slot('selected_track.name')
    def _on_selected_track_changed(self):
        self._update_selected_track_name()

    def _update_selected_track_name(self):
        selected = self.song().view.selected_track
        self._selected_track_name_data_source.set_display_string(selected.name)
########NEW FILE########
__FILENAME__ = SpecialPhysicalDisplay
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/SpecialPhysicalDisplay.py
from _Framework.Util import group, flatten
from _Framework.PhysicalDisplayElement import PhysicalDisplayElement
from consts import DISPLAY_BLOCK_LENGTH

class SpecialPhysicalDisplay(PhysicalDisplayElement):
    """
    Special physical display subclass that handles custom and special characters
    """
    _ascii_translations = {'\x00': 0,
     '\x01': 1,
     '\x02': 2,
     '\x03': 3,
     '\x04': 4,
     '\x05': 5,
     '\x06': 6,
     '\x07': 7,
     unicode('\xc2\xa6', 'utf-8'): 8,
     unicode('\xc2\xb0', 'utf-8'): 9,
     unicode('\xc3\x84', 'utf-8'): 10,
     unicode('\xc3\x87', 'utf-8'): 11,
     unicode('\xc3\x96', 'utf-8'): 12,
     unicode('\xc3\x9c', 'utf-8'): 13,
     unicode('\xc3\x9f', 'utf-8'): 14,
     unicode('\xc3\xa0', 'utf-8'): 15,
     unicode('\xc3\xa4', 'utf-8'): 16,
     unicode('\xc3\xa7', 'utf-8'): 17,
     unicode('\xc3\xa8', 'utf-8'): 18,
     unicode('\xc3\xa9', 'utf-8'): 19,
     unicode('\xc3\xaa', 'utf-8'): 20,
     unicode('\xc3\xae', 'utf-8'): 21,
     unicode('\xc3\xb1', 'utf-8'): 22,
     unicode('\xc3\xb6', 'utf-8'): 23,
     unicode('\xc3\xb7', 'utf-8'): 24,
     unicode('\xc3\xb8', 'utf-8'): 25,
     unicode('\xc3\xbc', 'utf-8'): 26,
     unicode('\xd1\x8c', 'utf-8'): 27,
     '\x1b': 27,
     '\x1c': 28,
     '\x1d': 29,
     '\x1e': 30,
     '\x1f': 31,
     ' ': 32,
     '!': 33,
     '"': 34,
     '#': 35,
     '$': 36,
     '%': 37,
     '&': 38,
     "'": 39,
     '(': 40,
     ')': 41,
     '*': 42,
     '+': 43,
     ',': 44,
     '-': 45,
     '.': 46,
     '/': 47,
     '0': 48,
     '1': 49,
     '2': 50,
     '3': 51,
     '4': 52,
     '5': 53,
     '6': 54,
     '7': 55,
     '8': 56,
     '9': 57,
     ':': 58,
     ';': 59,
     '<': 60,
     '=': 61,
     '>': 62,
     '?': 63,
     '@': 64,
     'A': 65,
     'B': 66,
     'C': 67,
     'D': 68,
     'E': 69,
     'F': 70,
     'G': 71,
     'H': 72,
     'I': 73,
     'J': 74,
     'K': 75,
     'L': 76,
     'M': 77,
     'N': 78,
     'O': 79,
     'P': 80,
     'Q': 81,
     'R': 82,
     'S': 83,
     'T': 84,
     'U': 85,
     'V': 86,
     'W': 87,
     'X': 88,
     'Y': 89,
     'Z': 90,
     '[': 91,
     '\\': 92,
     ']': 93,
     '^': 94,
     '_': 95,
     '`': 96,
     'a': 97,
     'b': 98,
     'c': 99,
     'd': 100,
     'e': 101,
     'f': 102,
     'g': 103,
     'h': 104,
     'i': 105,
     'j': 106,
     'k': 107,
     'l': 108,
     'm': 109,
     'n': 110,
     'o': 111,
     'p': 112,
     'q': 113,
     'r': 114,
     's': 115,
     't': 116,
     'u': 117,
     'v': 118,
     'w': 119,
     'x': 120,
     'y': 121,
     'z': 122,
     '{': 125,
     '|': 124,
     '}': 125,
     '~': 126,
     '\x7f': 127}

    def set_num_segments(self, num_segments):
        super(SpecialPhysicalDisplay, self).set_num_segments(num_segments)
        for segment in self._logical_segments:
            segment.separator = ' '

    def _build_inner_message(self, message):
        message = super(SpecialPhysicalDisplay, self)._build_inner_message(message)
        return flatten([ g[:-1] for g in group(message, DISPLAY_BLOCK_LENGTH) ])
########NEW FILE########
__FILENAME__ = SpecialSessionComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/SpecialSessionComponent.py
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.SessionComponent import SessionComponent
from _Framework.ClipSlotComponent import ClipSlotComponent
from _Framework.SceneComponent import SceneComponent
from _Framework.SessionZoomingComponent import SessionZoomingComponent
from _Framework.SubjectSlot import subject_slot
from _Framework.ScrollComponent import ScrollComponent
from _Framework.Util import forward_property
from _Framework.ModesComponent import EnablingModesComponent
from MessageBoxComponent import Messenger
import consts
from consts import MessageBoxText
import Live

class SpecialSessionZoomingComponent(SessionZoomingComponent):
    """
    Zooming component that does not disable session, instead it sends
    it to the back by changing its priority.
    """

    def set_button_matrix(self, buttons):
        if buttons:
            buttons.reset()
        super(SpecialSessionZoomingComponent, self).set_button_matrix(buttons)

    def _session_set_enabled(self, is_enabled):
        layer = self._session.layer
        if layer:
            layer.priority = None if is_enabled else consts.HIDDEN_SESSION_PRIORITY


class DuplicateSceneComponent(ControlSurfaceComponent, Messenger):

    def __init__(self, session = None, *a, **k):
        super(DuplicateSceneComponent, self).__init__(*a, **k)
        raise session or AssertionError
        self._session = session
        self._scene_buttons = None

    def set_scene_buttons(self, buttons):
        self._scene_buttons = buttons
        self._on_scene_value.subject = buttons

    @subject_slot('value')
    def _on_scene_value(self, value, index, _, is_momentary):
        if self.is_enabled() and (value or not is_momentary):
            try:
                self.song().duplicate_scene(self._session._scene_offset + index)
                self.show_notification(MessageBoxText.DUPLICATE_SCENE % self.song().view.selected_scene.name)
            except Live.Base.LimitationError:
                self.expect_dialog(MessageBoxText.SCENE_LIMIT_REACHED)
            except RuntimeError:
                self.expect_dialog(MessageBoxText.SCENE_DUPLICATION_FAILED)
            except IndexError:
                pass

    def update(self):
        pass


class SpecialClipSlotComponent(ClipSlotComponent, Messenger):

    def _do_delete_clip(self):
        if self._clip_slot and self._clip_slot.has_clip:
            clip_name = self._clip_slot.clip.name
            self._clip_slot.delete_clip()
            self.show_notification(MessageBoxText.DELETE_CLIP % clip_name)

    def _do_select_clip(self, clip_slot):
        if self._clip_slot != None:
            if self.song().view.highlighted_clip_slot != self._clip_slot:
                self.song().view.highlighted_clip_slot = self._clip_slot

    def _do_duplicate_clip(self):
        if self._clip_slot and self._clip_slot.has_clip:
            try:
                slot_name = self._clip_slot.clip.name
                track = self._clip_slot.canonical_parent
                track.duplicate_clip_slot(list(track.clip_slots).index(self._clip_slot))
                self.show_notification(MessageBoxText.DUPLICATE_CLIP % slot_name)
            except Live.Base.LimitationError:
                self.expect_dialog(MessageBoxText.SCENE_LIMIT_REACHED)
            except RuntimeError:
                self.expect_dialog(MessageBoxText.CLIP_DUPLICATION_FAILED)


class SpecialSceneComponent(SceneComponent, Messenger):
    clip_slot_component_type = SpecialClipSlotComponent

    def _on_is_triggered_changed(self):
        if not self._scene != None:
            raise AssertionError
            if self.is_enabled() and self._launch_button != None:
                self._scene.is_triggered and self._launch_button.send_value(self._triggered_value)
            else:
                self._launch_button.turn_on()

    def _do_delete_scene(self, scene):
        try:
            if self._scene:
                song = self.song()
                name = self._scene.name
                song.delete_scene(list(song.scenes).index(self._scene))
                self.show_notification(MessageBoxText.DELETE_SCENE % name)
        except RuntimeError:
            pass


class SpecialSessionComponent(SessionComponent):
    """
    Special session subclass that handles ConfigurableButtons
    and has a button to fire the selected clip slot.
    """
    _session_component_ends_initialisation = False
    scene_component_type = SpecialSceneComponent

    def __init__(self, *a, **k):
        super(SpecialSessionComponent, self).__init__(*a, **k)
        self._slot_launch_button = None
        self._duplicate_button = None
        self._duplicate, self._paginator = self.register_components(DuplicateSceneComponent(self), ScrollComponent())
        self._duplicate_enabler = self.register_component(EnablingModesComponent(component=self._duplicate))
        self._duplicate_enabler.momentary_toggle = True
        self._paginator.can_scroll_up = self._can_scroll_page_up
        self._paginator.can_scroll_down = self._can_scroll_page_down
        self._paginator.scroll_up = self._scroll_page_up
        self._paginator.scroll_down = self._scroll_page_down
        self._track_playing_slots = self.register_slot_manager()
        self._end_initialisation()

    duplicate_layer = forward_property('_duplicate')('layer')

    def set_duplicate_button(self, button):
        self._duplicate_enabler.set_toggle_button(button)

    def set_page_up_button(self, page_up_button):
        self._paginator.set_scroll_up_button(page_up_button)

    def set_page_down_button(self, page_down_button):
        self._paginator.set_scroll_down_button(page_down_button)

    def set_slot_launch_button(self, button):
        self._slot_launch_button = button
        self._on_slot_launch_value.subject = button

    def set_stop_track_clip_buttons(self, buttons):
        for button in buttons or []:
            if button:
                button.set_on_off_values('Option.On', 'Option.Off')

        super(SpecialSessionComponent, self).set_stop_track_clip_buttons(buttons)

    def set_clip_launch_buttons(self, buttons):
        if buttons:
            buttons.reset()
        super(SpecialSessionComponent, self).set_clip_launch_buttons(buttons)

    def _reassign_scenes(self):
        super(SpecialSessionComponent, self)._reassign_scenes()
        self._paginator.update()

    def _reassign_tracks(self):
        super(SpecialSessionComponent, self)._reassign_tracks()
        self._track_playing_slots.disconnect()
        tracks_to_use = self.tracks_to_use()
        for index in range(self._num_tracks):
            listener = lambda index = index: self._on_playing_slot_index_changed(index)
            if self._track_offset + index < len(tracks_to_use):
                track = tracks_to_use[self._track_offset + index]
                if track in self.song().tracks:
                    self._track_slots.register_slot(track, listener, 'playing_slot_index')
            listener()

    def _on_fired_slot_index_changed(self, index):
        self._update_stop_clips_led(index)

    def _on_playing_slot_index_changed(self, index):
        self._update_stop_clips_led(index)

    def _update_stop_clips_led(self, index):
        track_index = index + self.track_offset()
        tracks_to_use = self.tracks_to_use()
        if self.is_enabled() and self._stop_track_clip_buttons != None and index < len(self._stop_track_clip_buttons):
            button = self._stop_track_clip_buttons[index]
            if button != None:
                if track_index < len(tracks_to_use) and tracks_to_use[track_index].clip_slots and tracks_to_use[track_index].fired_slot_index == -2:
                    button.set_light('Mixer.StoppingTrack')
                elif track_index < len(tracks_to_use) and tracks_to_use[track_index].clip_slots and tracks_to_use[track_index].playing_slot_index >= 0:
                    button.set_light('Mixer.StopTrack')
                else:
                    button.turn_off()

    @subject_slot('value')
    def _on_slot_launch_value(self, value):
        if self.is_enabled():
            if value != 0 or not self._slot_launch_button.is_momentary():
                if self.song().view.highlighted_clip_slot != None:
                    self.song().view.highlighted_clip_slot.fire()
                self._slot_launch_button.turn_on()
            else:
                self._slot_launch_button.turn_off()

    def _can_scroll_page_up(self):
        return self.scene_offset() > 0

    def _can_scroll_page_down(self):
        return self.scene_offset() < len(self.song().scenes) - self.height()

    def _scroll_page_up(self):
        height = self.height()
        track_offset = self.track_offset()
        scene_offset = self.scene_offset()
        if scene_offset > 0:
            new_scene_offset = scene_offset
            if scene_offset % height > 0:
                new_scene_offset -= scene_offset % height
            else:
                new_scene_offset = max(0, scene_offset - height)
            self.set_offsets(track_offset, new_scene_offset)

    def _scroll_page_down(self):
        height = self.height()
        track_offset = self.track_offset()
        scene_offset = self.scene_offset()
        new_scene_offset = scene_offset + height - scene_offset % height
        self.set_offsets(track_offset, new_scene_offset)
########NEW FILE########
__FILENAME__ = SpecialTransportComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/SpecialTransportComponent.py
import Live
from _Framework.SubjectSlot import subject_slot
from _Framework.TransportComponent import TransportComponent
from _Framework.Util import clamp
from consts import MessageBoxText
from MessageBoxComponent import Messenger
INITIAL_SCROLLING_DELAY = 5
INTERVAL_SCROLLING_DELAY = 1

class SpecialTransportComponent(TransportComponent, Messenger):
    """ Transport component that takes buttons for Undo and Redo """

    def __init__(self, *a, **k):
        super(SpecialTransportComponent, self).__init__(*a, **k)
        self._undo_button = None
        self._redo_button = None
        self._shift_button = None
        self._tempo_encoder_control = None
        self._shift_pressed = False
        self._seek_ticks_delay = -1
        self._play_toggle.model_transform = lambda val: False if self._shift_button and self._shift_button.is_pressed() else val

    def update(self):
        super(SpecialTransportComponent, self).update()
        self._update_undo_button()

    def set_shift_button(self, button):
        if self._shift_button != button:
            self._shift_button = button
            self._shift_value.subject = button
            self.update()

    def set_undo_button(self, undo_button):
        if undo_button != self._undo_button:
            self._undo_button = undo_button
            self._undo_value.subject = undo_button
            self._update_undo_button()

    def set_redo_button(self, redo_button):
        if redo_button != self._redo_button:
            self._redo_button = redo_button
            self._redo_value.subject = redo_button
            self.update()

    def set_tempo_encoder(self, control):
        if not (not control or control.message_map_mode() is Live.MidiMap.MapMode.relative_smooth_two_compliment):
            raise AssertionError
            self._tempo_encoder_control = control != self._tempo_encoder_control and control
            self._tempo_encoder_value.subject = control
            self.update()

    @subject_slot('value')
    def _shift_value(self, value):
        self._shift_pressed = value != 0
        if self.is_enabled():
            self.update()

    @subject_slot('value')
    def _undo_value(self, value):
        if self.is_enabled():
            if value != 0 or not self._undo_button.is_momentary():
                if self._shift_button and self._shift_button.is_pressed():
                    if self.song().can_redo:
                        self.song().redo()
                        self.show_notification(MessageBoxText.REDO)
                elif self.song().can_undo:
                    self.song().undo()
                    self.show_notification(MessageBoxText.UNDO)
            self._update_undo_button()

    def _update_undo_button(self):
        if self.is_enabled() and self._undo_button:
            self._undo_button.set_light(self._undo_button.is_pressed())

    @subject_slot('value')
    def _redo_value(self, value):
        if self.is_enabled():
            if value != 0 or not self._redo_button.is_momentary():
                if self.song().can_redo:
                    self.song().redo()

    @subject_slot('value')
    def _tempo_encoder_value(self, value):
        if self.is_enabled():
            step = 0.1 if self._shift_pressed else 1.0
            amount = value - 128 if value >= 64 else value
            self.song().tempo = clamp(self.song().tempo + amount * step, 20, 999)
########NEW FILE########
__FILENAME__ = StepSeqComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/StepSeqComponent.py
from __future__ import with_statement
import Live
from itertools import imap, chain, starmap
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.CompoundComponent import CompoundComponent
from _Framework.SubjectSlot import subject_slot, Subject, subject_slot_group
from _Framework.Util import forward_property, find_if
from DrumGroupComponent import DrumGroupComponent
from NoteEditorComponent import NoteEditorComponent
from GridResolution import GridResolution
from LoopSelectorComponent import LoopSelectorComponent
from PlayheadComponent import PlayheadComponent
from NoteEditorPaginator import NoteEditorPaginator

class DrumGroupFinderComponent(ControlSurfaceComponent, Subject):
    """
    Looks in the hierarchy of devices of the selected track, looking
    for the first available drum-rack (deep-first), updating as the
    device list changes.
    """
    __subject_events__ = ('drum_group',)
    _drum_group = None

    @property
    def drum_group(self):
        """
        The latest found drum rack.
        """
        return self._drum_group

    @property
    def root(self):
        """
        The currently observed track.
        """
        return self.song().view.selected_track

    @subject_slot_group('devices')
    def _on_devices_changed(self, chain):
        self.update()

    @subject_slot_group('chains')
    def _on_chains_changed(self, chain):
        self.update()

    def on_selected_track_changed(self):
        self.update()

    def update(self):
        if self.is_enabled():
            self._update_listeners()
            self._update_drum_group()

    def _update_listeners(self):
        root = self.root
        devices = list(find_instrument_devices(root))
        chains = list(chain([root], *[ d.chains for d in devices ]))
        self._on_chains_changed.replace_subjects(devices)
        self._on_devices_changed.replace_subjects(chains)

    def _update_drum_group(self):
        drum_group = find_drum_group_device(self.root)
        if type(drum_group) != type(self._drum_group) or drum_group != self._drum_group:
            self._drum_group = drum_group
            self.notify_drum_group()


def find_instrument_devices(track_or_chain):
    """
    Returns a list with all instrument rack descendants from a track
    or chain.
    """
    instrument = find_if(lambda d: d.type == Live.Device.DeviceType.instrument, track_or_chain.devices)
    if instrument and not instrument.can_have_drum_pads:
        if instrument.can_have_chains:
            return chain([instrument], *imap(find_instrument_devices, instrument.chains))
    return []


def find_drum_group_device(track_or_chain):
    """
    Looks up recursively for a drum_group device in the track.
    """
    instrument = find_if(lambda d: d.type == Live.Device.DeviceType.instrument, track_or_chain.devices)
    if instrument:
        if instrument.can_have_drum_pads:
            return instrument
        elif instrument.can_have_chains:
            return find_if(bool, imap(find_drum_group_device, instrument.chains))


class StepSeqComponent(CompoundComponent):
    """ Step Sequencer Component """

    def __init__(self, clip_creator = None, skin = None, grid_resolution = None, note_editor_settings = None, *a, **k):
        super(StepSeqComponent, self).__init__(*a, **k)
        raise clip_creator or AssertionError
        if not skin:
            raise AssertionError
            self._grid_resolution = grid_resolution
            note_editor_settings and self.register_component(note_editor_settings)
        self._note_editor, self._loop_selector, self._big_loop_selector, self._drum_group = self.register_components(NoteEditorComponent(settings_mode=note_editor_settings, clip_creator=clip_creator, grid_resolution=self._grid_resolution), LoopSelectorComponent(clip_creator=clip_creator), LoopSelectorComponent(clip_creator=clip_creator, measure_length=2.0), DrumGroupComponent())
        self._paginator = NoteEditorPaginator([self._note_editor])
        self._big_loop_selector.set_enabled(False)
        self._big_loop_selector.set_paginator(self._paginator)
        self._loop_selector.set_paginator(self._paginator)
        self._shift_button = None
        self._delete_button = None
        self._mute_button = None
        self._solo_button = None
        self._note_editor_matrix = None
        self._on_pressed_pads_changed.subject = self._drum_group
        self._on_detail_clip_changed.subject = self.song().view
        self._detail_clip = None
        self._playhead = None
        self._playhead_component = self.register_component(PlayheadComponent(grid_resolution=grid_resolution, paginator=self._paginator, follower=self._loop_selector, notes=chain(*starmap(range, ((92, 100),
         (84, 92),
         (76, 84),
         (68, 76)))), triplet_notes=chain(*starmap(range, ((92, 98),
         (84, 90),
         (76, 82),
         (68, 74))))))
        self._skin = skin
        self._playhead_color = 'NoteEditor.Playhead'

    def set_playhead(self, playhead):
        self._playhead = playhead
        self._playhead_component.set_playhead(playhead)
        self._update_playhead_color()

    def _get_playhead_color(self):
        return self._playhead_color

    def _set_playhead_color(self, value):
        self._playhead_color = 'NoteEditor.' + value
        self._update_playhead_color()

    playhead_color = property(_get_playhead_color, _set_playhead_color)

    def _is_triplet_quantization(self):
        return self._grid_resolution.clip_grid[1]

    def _update_playhead_color(self):
        if self.is_enabled() and self._skin and self._playhead:
            self._playhead.velocity = int(self._skin[self._playhead_color])

    def set_drum_group_device(self, drum_group_device):
        raise not drum_group_device or drum_group_device.can_have_drum_pads or AssertionError
        self._drum_group.set_drum_group_device(drum_group_device)
        self._on_selected_drum_pad_changed.subject = drum_group_device.view if drum_group_device else None
        self._on_selected_drum_pad_changed()

    def set_touch_strip(self, touch_strip):
        self._drum_group.set_page_strip(touch_strip)

    def set_detail_touch_strip(self, touch_strip):
        self._drum_group.set_scroll_strip(touch_strip)

    def set_quantize_button(self, button):
        self._drum_group.set_quantize_button(button)

    def set_full_velocity_button(self, button):
        self._note_editor.set_full_velocity_button(button)

    def set_select_button(self, button):
        self._drum_group.set_select_button(button)
        self._loop_selector.set_select_button(button)

    def set_mute_button(self, button):
        self._drum_group.set_mute_button(button)
        self._note_editor.set_mute_button(button)
        self._mute_button = button

    def set_solo_button(self, button):
        self._drum_group.set_solo_button(button)
        self._solo_button = button

    def set_shift_button(self, button):
        self._big_loop_selector.set_select_button(button)
        self._shift_button = button
        self._on_shift_value.subject = button

    def set_delete_button(self, button):
        self._delete_button = button
        self._drum_group.set_delete_button(button)

    def set_loop_selector_matrix(self, matrix):
        self._loop_selector.set_loop_selector_matrix(matrix)

    def set_short_loop_selector_matrix(self, matrix):
        self._loop_selector.set_short_loop_selector_matrix(matrix)

    def set_follow_button(self, button):
        self._loop_selector.set_follow_button(button)
        self._big_loop_selector.set_follow_button(button)

    def set_drum_matrix(self, matrix):
        self._drum_group.set_drum_matrix(matrix)

    def set_drum_bank_up_button(self, button):
        self._drum_group.set_scroll_page_up_button(button)

    def set_drum_bank_down_button(self, button):
        self._drum_group.set_scroll_page_down_button(button)

    def set_drum_bank_detail_up_button(self, button):
        self._drum_group.set_scroll_up_button(button)

    def set_drum_bank_detail_down_button(self, button):
        self._drum_group.set_scroll_down_button(button)

    def set_button_matrix(self, matrix):
        self._note_editor_matrix = matrix
        self._update_note_editor_matrix()

    def set_quantization_buttons(self, buttons):
        self._grid_resolution.set_buttons(buttons)

    def set_velocity_control(self, control):
        self._note_editor.set_velocity_control(control)

    def set_length_control(self, control):
        self._note_editor.set_length_control(control)

    def set_nudge_control(self, control):
        self._note_editor.set_nudge_control(control)

    @forward_property('_note_editor')
    def full_velocity(self):
        pass

    def update(self):
        self._on_detail_clip_changed()
        self._update_playhead_color()

    @subject_slot('detail_clip')
    def _on_detail_clip_changed(self):
        clip = self.song().view.detail_clip
        clip = clip if self.is_enabled() and clip and clip.is_midi_clip else None
        self._detail_clip = clip
        self._note_editor.set_detail_clip(clip)
        self._loop_selector.set_detail_clip(clip)
        self._big_loop_selector.set_detail_clip(clip)
        self._playhead_component.set_clip(self._detail_clip)

    @subject_slot('value')
    def _on_shift_value(self, value):
        if self.is_enabled():
            self._update_note_editor_matrix(enable_big_loop_selector=value and not self._loop_selector.is_following)

    @subject_slot('selected_drum_pad')
    def _on_selected_drum_pad_changed(self):
        drum_group_view = self._on_selected_drum_pad_changed.subject
        if drum_group_view:
            selected_drum_pad = drum_group_view.selected_drum_pad
            if selected_drum_pad:
                self._note_editor.editing_note = selected_drum_pad.note

    @subject_slot('pressed_pads')
    def _on_pressed_pads_changed(self):
        self._note_editor.modify_all_notes_enabled = bool(self._drum_group.pressed_pads)

    def _update_note_editor_matrix(self, enable_big_loop_selector = False):
        if enable_big_loop_selector:
            self._note_editor.set_enabled(False)
            self._note_editor.set_button_matrix(None)
            self._big_loop_selector.set_enabled(True)
            self._big_loop_selector.set_loop_selector_matrix(self._note_editor_matrix)
        else:
            self._big_loop_selector.set_enabled(False)
            self._big_loop_selector.set_loop_selector_matrix(None)
            self._note_editor.set_enabled(True)
            self._note_editor.set_button_matrix(self._note_editor_matrix)
########NEW FILE########
__FILENAME__ = Sysex
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/Sysex.py
START = (240, 71, 127, 21)
CLEAR_LINE1 = START + (28, 0, 0, 247)
CLEAR_LINE2 = START + (29, 0, 0, 247)
CLEAR_LINE3 = START + (30, 0, 0, 247)
CLEAR_LINE4 = START + (31, 0, 0, 247)
WRITE_LINE1 = START + (24, 0, 69, 0)
WRITE_LINE2 = START + (25, 0, 69, 0)
WRITE_LINE3 = START + (26, 0, 69, 0)
WRITE_LINE4 = START + (27, 0, 69, 0)
SET_AFTERTOUCH_MODE = START + (92, 0, 1)
POLY_AFTERTOUCH = (0,)
MONO_AFTERTOUCH = (1,)
CONTRAST_PREFIX = START + (122, 0, 1)
CONTRAST_ENQUIRY = START + (122, 0, 0, 247)
BRIGHTNESS_PREFIX = START + (124, 0, 1)
BRIGHTNESS_ENQUIRY = START + (124, 0, 0, 247)
ALL_PADS_SENSITIVITY_PREFIX = START + (93, 0, 32)
PAD_SENSITIVITY_PREFIX = START + (90, 0, 33)

def to_sysex_int(number, unused_parameter_name):
    return (number >> 12 & 15,
     number >> 8 & 15,
     number >> 4 & 15,
     number & 15)


CALIBRATION_SET = START + (87, 0, 20) + to_sysex_int(215, 'Preload Scale Factor') + to_sysex_int(1000, 'Recalibration Interval') + to_sysex_int(200, 'Stuck Pad Detection Threshold') + to_sysex_int(0, 'Stuck Pad NoteOff Threshold Adder') + to_sysex_int(200, 'Pad Ignore Time') + (247,)
MODE_CHANGE = START + (98, 0, 1)
USER_MODE = 1
LIVE_MODE = 0
WELCOME_MESSAGE = START + (1, 1, 247)
GOOD_BYE_MESSAGE = START + (1, 0, 247)
IDENTITY_PREFIX = START + (6, 2)
IDENTITY_ENQUIRY = START + (6, 1, 247)
DONGLE_PREFIX = START + (80, 0)

def make_presentation_message(application):
    return START + (96,
     0,
     4,
     65,
     application.get_major_version(),
     application.get_minor_version(),
     application.get_bugfix_version(),
     247)


IDENTITY_ENQUIRY = (240, 126, 0, 6, 1, 247)
IDENTITY_PREFIX = (240, 126, 0, 6, 2, 71, 21, 0, 25)
DONGLE_ENQUIRY_PREFIX = START + (80,)
DONGLE_PREFIX = START + (81,)
########NEW FILE########
__FILENAME__ = TouchEncoderElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/TouchEncoderElement.py
from _Framework.EncoderElement import EncoderElement
from _Framework.SubjectSlot import subject_slot, SlotManager

class TouchEncoderObserver(object):
    """ Interface for observing the state of one or more TouchEncoderElements """

    def on_encoder_touch(self, encoder):
        pass

    def on_encoder_parameter(self, encoder):
        pass


class TouchEncoderElement(EncoderElement, SlotManager):
    """ Class representing an encoder that is touch sensitive """
    __subject_events__ = ('touch_value',)

    def __init__(self, msg_type, channel, identifier, map_mode, undo_step_handler = None, delete_handler = None, touch_button = None, *a, **k):
        super(TouchEncoderElement, self).__init__(msg_type, channel, identifier, map_mode, *a, **k)
        raise touch_button is not None or AssertionError
        self.touch_button = touch_button
        self._trigger_undo_step = False
        self._undo_step_open = False
        self._undo_step_handler = undo_step_handler
        self._delete_handler = delete_handler
        self.set_touch_button(touch_button)
        self.set_observer(None)

    def is_pressed(self):
        return self.touch_button and self.touch_button.is_pressed()

    def set_touch_button(self, touch_button):
        self.touch_button = touch_button
        self._on_touch_button.subject = touch_button

    def set_observer(self, observer):
        if observer is None:
            observer = TouchEncoderObserver()
        self._observer = observer

    @subject_slot('value')
    def _on_touch_button(self, value):
        self._trigger_undo_step = value
        if value:
            param = self.mapped_parameter()
            if self._delete_handler and self._delete_handler.is_deleting and param:
                self._delete_handler.delete_clip_envelope(param)
            else:
                self.begin_gesture()
                self._observer.on_encoder_touch(self)
                self.notify_touch_value(value)
        else:
            if self._undo_step_handler and self._undo_step_open:
                self._undo_step_handler.end_undo_step()
            self._observer.on_encoder_touch(self)
            self.notify_touch_value(value)
            self.end_gesture()

    def connect_to(self, parameter):
        if parameter != self.mapped_parameter():
            self.last_mapped_parameter = parameter
            super(TouchEncoderElement, self).connect_to(parameter)
            self._observer.on_encoder_parameter(self)

    def release_parameter(self):
        if self.mapped_parameter() != None:
            super(TouchEncoderElement, self).release_parameter()
            self._observer.on_encoder_parameter(self)

    def receive_value(self, value):
        if self._undo_step_handler and self._trigger_undo_step:
            self._undo_step_handler.begin_undo_step()
            self._trigger_undo_step = False
            self._undo_step_open = True
        super(TouchEncoderElement, self).receive_value(value)
########NEW FILE########
__FILENAME__ = TouchStripController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/TouchStripController.py
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from TouchStripElement import TouchStripModes, SimpleBehaviour
from TouchEncoderElement import TouchEncoderObserver
import consts

class TouchStripControllerComponent(ControlSurfaceComponent):

    def __init__(self, *a, **k):
        super(TouchStripControllerComponent, self).__init__(*a, **k)
        self._touch_strip = None
        self._parameter = None

    def set_parameter(self, parameter):
        self._parameter = parameter
        self._update_strip_state()

    def update(self):
        pass

    def set_touch_strip(self, touch_strip):
        self._touch_strip = touch_strip
        self._update_strip_state()

    def _update_strip_state(self):
        if self._touch_strip != None:
            if self._parameter != None:
                self._touch_strip.behaviour = SimpleBehaviour(self._calculate_strip_mode())
                self._touch_strip.connect_to(self._parameter)
            else:
                self._touch_strip.release_parameter()

    def _calculate_strip_mode(self):
        if self._parameter.min == -1 * self._parameter.max:
            mode = TouchStripModes.CUSTOM_PAN
        else:
            mode = TouchStripModes.CUSTOM_DISCRETE if self._parameter.is_quantized else TouchStripModes.CUSTOM_VOLUME
        return mode


class TouchStripEncoderConnection(ControlSurfaceComponent, TouchEncoderObserver):

    def __init__(self, strip_controller, touch_button, *a, **k):
        super(TouchStripEncoderConnection, self).__init__(*a, **k)
        self._strip_controller = strip_controller
        self._touch_button = touch_button
        self._encoder = None

    def disconnect(self):
        self._set_touched_encoder(None)
        super(TouchStripEncoderConnection, self).disconnect()

    def on_encoder_touch(self, encoder):
        self._on_encoder_change(encoder)

    def on_encoder_parameter(self, encoder):
        self._on_encoder_change(encoder)

    def update(self):
        pass

    def _on_encoder_change(self, encoder):
        if consts.PROTO_TOUCH_ENCODER_TO_STRIP and self._encoder in (encoder, None):
            self._set_touched_encoder(encoder if self._can_use_touch_encoder(encoder) else None)

    def _can_use_touch_encoder(self, encoder):
        is_useable = encoder.is_pressed() and encoder.mapped_parameter() != None
        can_be_initial_encoder = self._encoder == None and not self._touch_button.is_pressed()
        should_trigger_update = self._encoder == encoder
        return is_useable and (can_be_initial_encoder or should_trigger_update)

    def _set_touched_encoder(self, encoder):
        self._encoder = encoder
        parameter = encoder.mapped_parameter() if encoder != None else None
        self._strip_controller.set_parameter(parameter)
        self._strip_controller.set_enabled(parameter != None)
########NEW FILE########
__FILENAME__ = TouchStripElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/TouchStripElement.py
import Live
import Sysex
from _Framework.Util import group, in_range, nop, NamedTuple, clamp
from _Framework.SubjectSlot import SlotManager
from _Framework.InputControlElement import InputControlElement, MIDI_PB_TYPE
MAX_PITCHBEND = 16384.0

class TouchStripModes:
    CUSTOM_PITCHBEND, CUSTOM_VOLUME, CUSTOM_PAN, CUSTOM_DISCRETE, CUSTOM_FREE, PITCHBEND, VOLUME, PAN, DISCRETE, COUNT = range(10)


class TouchStripBehaviour(object):
    mode = NotImplemented

    def handle_touch(self, value):
        raise NotImplementedError

    def handle_value(self, value, notify):
        raise NotImplementedError


class SimpleBehaviour(TouchStripBehaviour):
    """
    Behaviour with custom mode.
    """

    def __init__(self, mode = TouchStripModes.PITCHBEND, *a, **k):
        super(SimpleBehaviour, self).__init__(*a, **k)
        self._mode = mode

    @property
    def mode(self):
        return self._mode

    def handle_value(self, value, notify):
        notify(value)

    def handle_touch(self, value):
        pass


class TouchStripHandle(NamedTuple):
    range = (0, 2048)
    position = 0


class SelectingBehaviour(TouchStripBehaviour):
    """
    Behaviour for selecting objects at arbitrary parts of the touch-strip. A handle can
    be used to prevent jumping around the current value of the controlled parameter.
    """
    handle = TouchStripHandle()
    mode = TouchStripModes.CUSTOM_FREE
    _offset = 0
    _grabbed = False

    def handle_value(self, value, notify):
        range, position = self.handle.range, self.handle.position
        if not self._grabbed and range[0] <= value - position < range[1]:
            self._offset = value - position
            self._grabbed = True
        else:
            notify(clamp(value - self._offset, 0, MAX_PITCHBEND))

    def handle_touch(self, value):
        self._offset = 0
        self._grabbed = False


class DraggingBehaviour(SelectingBehaviour):
    """
    Can only be dragged when starting within the handle
    """

    def handle_value(self, value, notify):

        def notify_if_dragging(value):
            if self._grabbed:
                notify(value)

        super(DraggingBehaviour, self).handle_value(value, notify_if_dragging)


DEFAULT_BEHAVIOUR = SimpleBehaviour()

class TouchStripElement(InputControlElement, SlotManager):
    """
    Represents the Push TouchStrip.
    """

    class ProxiedInterface(InputControlElement.ProxiedInterface):
        turn_off = nop
        turn_on_index = nop
        send_state = nop
        is_pressed = nop
        behaviour = DEFAULT_BEHAVIOUR
        STATE_COUNT = 24
        STATE_OFF, STATE_HALF, STATE_FULL = (0, 1, 3)

    STATE_OFF = 0
    STATE_HALF = 1
    STATE_FULL = 3
    STATE_COUNT = 24

    def __init__(self, touch_button = None, *a, **k):
        super(TouchStripElement, self).__init__(MIDI_PB_TYPE, 0, 0, *a, **k)
        self._touch_button = touch_button
        self._touch_slot = self.register_slot(touch_button, None, 'value')
        self._behaviour = None
        self.behaviour = None

    @property
    def touch_button(self):
        return self._touch_button

    def _set_behaviour(self, behaviour):
        if not behaviour:
            behaviour = DEFAULT_BEHAVIOUR
            self._behaviour = behaviour != self._behaviour and behaviour
            self._touch_slot.listener = behaviour.handle_touch
            self._send_midi(Sysex.START + (99,
             0,
             1,
             behaviour.mode,
             247))

    def _get_behaviour(self):
        return self._behaviour

    behaviour = property(_get_behaviour, _set_behaviour)

    def message_map_mode(self):
        return Live.MidiMap.MapMode.absolute_14_bit

    def is_pressed(self):
        return self._touch_button != None and self._touch_button.is_pressed()

    def reset(self):
        self.behaviour = None

    def notify_value(self, value):
        notify = super(TouchStripElement, self).notify_value
        self._behaviour.handle_value(value, notify)

    def turn_on_index(self, index, on_state = STATE_FULL, off_state = STATE_OFF):
        raise in_range(index, 0, self.STATE_COUNT) or AssertionError
        states = [off_state] * self.STATE_COUNT
        states[index] = on_state
        self.send_state(states)

    def turn_off(self, off_state = STATE_OFF):
        self.send_state((off_state,) * self.STATE_COUNT)

    def send_state(self, state):
        if not (self._behaviour.mode == TouchStripModes.CUSTOM_FREE and len(state) == self.STATE_COUNT):
            raise AssertionError
            group_size = 3
            bytes = [ reduce(lambda byte, (i, state): byte | state << 2 * i, enumerate(state_group), 0) for state_group in group(state, group_size) ]
            self._send_midi(Sysex.START + (100, 0, 8) + tuple(bytes) + (247,))
########NEW FILE########
__FILENAME__ = TrackFrozenMode
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/TrackFrozenMode.py
from _Framework.ModesComponent import ModesComponent
from _Framework.SubjectSlot import subject_slot

class TrackFrozenModesComponent(ModesComponent):

    def __init__(self, default_mode = None, frozen_mode = None, *a, **k):
        super(TrackFrozenModesComponent, self).__init__(*a, **k)
        raise default_mode is not None or AssertionError
        if not frozen_mode is not None:
            raise AssertionError
            self.add_mode('default', default_mode)
            self.add_mode('frozen', frozen_mode)
            self._on_selected_track_is_frozen_changed.subject = self._song.view
            self.is_enabled() and self._update_selected_mode()

    def _update_selected_mode(self):
        self.selected_mode = 'frozen' if self._song.view.selected_track.is_frozen else 'default'

    @subject_slot('selected_track.is_frozen')
    def _on_selected_track_is_frozen_changed(self):
        self._update_selected_mode()

    def update(self):
        if self.is_enabled():
            self._update_selected_mode()
########NEW FILE########
__FILENAME__ = UserSettingsComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/UserSettingsComponent.py
from itertools import count
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.SubjectSlot import subject_slot_group, subject_slot, SubjectEvent
from _Framework.Util import forward_property
from ActionWithOptionsComponent import ActionWithSettingsComponent
import Sysex

class UserSettingsComponent(ControlSurfaceComponent):
    """ Component for changing a list of settings """

    def __init__(self, *a, **k):
        super(UserSettingsComponent, self).__init__(*a, **k)
        self._name_sources = [ DisplayDataSource() for _ in xrange(4) ]
        self._value_sources = [ DisplayDataSource() for _ in xrange(4) ]
        self._info_source = DisplayDataSource()
        self._settings = []
        self._encoders = []

    def set_display_line1(self, display):
        if display:
            display.set_data_sources(self._value_sources)

    def set_display_line2(self, display):
        if display:
            display.set_data_sources(self._name_sources)

    def set_display_line3(self, display):
        if display:
            display.reset()

    def set_display_line4(self, display):
        if display:
            display.set_data_sources([self._info_source])

    def set_encoders(self, encoders):
        self._encoders = encoders or []
        self._on_encoder_value.replace_subjects(self._encoders[::2], count())

    def _set_settings(self, settings):
        self._settings = settings.values()
        self._update_display()

    def _get_settings(self):
        return self._settings

    settings = property(_get_settings, _set_settings)

    def set_info_text(self, info_text):
        self._info_source.set_display_string(info_text)

    @subject_slot_group('normalized_value')
    def _on_encoder_value(self, value, index):
        if index >= 0 and index < len(self._settings) and self._settings[index].change_relative(value):
            self._update_display()

    def _update_display(self):
        for index, setting in enumerate(self._settings):
            self._name_sources[index].set_display_string(setting.name)
            self._value_sources[index].set_display_string(str(setting))

    def update(self):
        if self.is_enabled():
            self._update_display()


class UserComponent(ActionWithSettingsComponent):
    __subject_events__ = (SubjectEvent(name='mode', doc=' Called when the mode changes '), SubjectEvent(name='before_mode_sent', doc=' Called before the mode is sent'), SubjectEvent(name='after_mode_sent', doc=' Called after the mode is sent '))
    settings_layer = forward_property('_settings')('layer')
    settings = forward_property('_settings')('settings')

    def __init__(self, value_control = None, *a, **k):
        super(UserComponent, self).__init__(*a, **k)
        raise value_control != None or AssertionError
        self._settings = self.register_component(UserSettingsComponent())
        self._settings.set_enabled(False)
        self._value_control = value_control
        self._on_value.subject = self._value_control
        self._selected_mode = Sysex.LIVE_MODE

    def show_settings(self):
        self._settings.set_enabled(True)
        return True

    def hide_settings(self):
        self._settings.set_enabled(False)

    def set_settings_info_text(self, text):
        self._settings.set_info_text(text)

    def post_trigger_action(self):
        self.mode = Sysex.LIVE_MODE if self.mode == Sysex.USER_MODE else Sysex.USER_MODE

    @subject_slot('value')
    def _on_value(self, value):
        mode = value[0]
        self._selected_mode = mode
        self.notify_mode(mode)

    def _get_mode(self):
        return self._selected_mode

    def _set_mode(self, mode):
        if mode != self._selected_mode:
            self._selected_mode = mode
            if self.is_enabled():
                self._apply_mode(self._selected_mode)

    mode = property(_get_mode, _set_mode)

    def update(self):
        super(UserComponent, self).update()
        if self.is_enabled():
            self._apply_mode(self._selected_mode)

    def _apply_mode(self, mode):
        self.notify_before_mode_sent(mode)
        self._value_control.send_value((mode,))
        self.notify_after_mode_sent(mode)
########NEW FILE########
__FILENAME__ = ValueComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/ValueComponent.py
from functools import partial
from _Framework.CompoundComponent import CompoundComponent
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.DisplayDataSource import DisplayDataSource
from _Framework.SubjectSlot import subject_slot
from _Framework.Util import forward_property
from _Framework.InputControlElement import ParameterSlot
from _Framework import Task
from DeviceParameterComponent import convert_parameter_value_to_graphic
import consts
NUM_SEGMENTS = 4

def convert_value_to_graphic(value):
    index = int(value * (len(consts.GRAPH_VOL) - 1))
    if index != None and index < len(consts.GRAPH_VOL):
        graphic_display_string = consts.GRAPH_VOL[index]
    else:
        graphic_display_string = ' '
    return graphic_display_string


class ValueDisplayComponentBase(ControlSurfaceComponent):

    def __init__(self, display_label = ' ', display_seg_start = 0, *a, **k):
        super(ValueDisplayComponentBase, self).__init__(*a, **k)
        self._label_data_source = DisplayDataSource(display_label)
        self._value_data_source = DisplayDataSource()
        self._graphic_data_source = DisplayDataSource()
        self._display_label = display_label
        self._display_seg_start = display_seg_start

    def get_value_string(self):
        raise NotImplementedError

    def get_graphic_string(self):
        raise NotImplementedError

    def set_label_display(self, display):
        self._set_display(display, self._label_data_source)

    def set_value_display(self, display):
        self._set_display(display, self._value_data_source)

    def set_graphic_display(self, display):
        self._set_display(display, self._graphic_data_source)

    def set_clear_display1(self, display):
        self._clear_display(display)

    def set_clear_display2(self, display):
        self._clear_display(display)

    def set_clear_display3(self, display):
        self._clear_display(display)

    def set_clear_display4(self, display):
        self._clear_display(display)

    def _set_display(self, display, source):
        if display:
            display.set_data_sources((None,) * NUM_SEGMENTS)
            display.segment(self._display_seg_start).set_data_source(source)

    def _clear_display(self, display):
        if display:
            display.set_data_sources((None,))
            display.reset()

    def update(self):
        if self.is_enabled():
            self._value_data_source.set_display_string(self.get_value_string())
            self._graphic_data_source.set_display_string(self.get_graphic_string())


class ValueComponentBase(CompoundComponent):
    """
    Component to control one continuous property with a infinite
    touch-sensitive encoder. You can optionally give it a display and
    a button such that the value will be displayed while its pressed.
    """
    TOUCH_BASED = 0
    TIMER_BASED = 1
    AUTO_HIDE_IN_SEC = 0.5

    def create_display_component(self, *a, **k):
        raise NotImplementedError

    def __init__(self, display_label = ' ', display_seg_start = 0, encoder = None, *a, **k):
        super(ValueComponentBase, self).__init__(*a, **k)
        self._display_mode = self.TOUCH_BASED
        self._button = None
        self._on_encoder_changed.subject = encoder
        self._display = self.register_component(self.create_display_component(display_label=display_label, display_seg_start=display_seg_start))
        self._display.set_enabled(False)
        self._hide_display_task = self._tasks.add(Task.sequence(Task.wait(self.AUTO_HIDE_IN_SEC), Task.run(partial(self._display.set_enabled, False))))
        self._hide_display_task.kill()

    display_layer = forward_property('_display')('layer')

    def _get_display_mode(self):
        return self._display_mode

    def _set_display_mode(self, mode):
        if self._display_mode != mode:
            self._display_mode = mode
            self._update_display_state()

    display_mode = property(_get_display_mode, _set_display_mode)

    def set_encoder(self, encoder):
        raise NotImplementedError

    def set_button(self, button):
        self._button = button
        self._on_button_value.subject = button
        self._update_display_state()

    @subject_slot('value')
    def _on_button_value(self, value):
        self._update_display_state()

    @subject_slot('value')
    def _on_encoder_changed(self, value):
        if self.display_mode == self.TIMER_BASED:
            self._display.set_enabled(True)
            self._hide_display_task.restart()

    def _update_display_state(self):
        if self.display_mode == self.TOUCH_BASED:
            self._display.set_enabled(self._button and self._button.is_pressed())
            if self._button:
                self._hide_display_task.kill()
        elif self.display_mode == self.TIMER_BASED:
            self._display.set_enabled(False)

    def update(self):
        button = self._on_button_value.subject
        self._display.set_enabled(button and button.is_pressed())


class ValueDisplayComponent(ValueDisplayComponentBase):
    """
    Display for values from standard Python properties.
    """

    def __init__(self, property_name = None, subject = None, display_format = '%f', view_transform = None, graphic_transform = None, *a, **k):
        super(ValueDisplayComponent, self).__init__(*a, **k)
        self._subject = subject
        self._property_name = property_name
        self._display_format = display_format
        if view_transform is not None:
            self.view_transform = view_transform
        if graphic_transform is not None:
            self.graphic_transform = graphic_transform
        self.register_slot(subject, self._on_value_changed, property_name)
        self._on_value_changed()

    def view_transform(self, x):
        return x

    def graphic_transform(self, x):
        return self.view_transform(x)

    def get_value_string(self):
        value = getattr(self._subject, self._property_name)
        return self._display_format % self.view_transform(value)

    def get_graphic_string(self):
        value = getattr(self._subject, self._property_name)
        graph = self.graphic_transform(value)
        return convert_value_to_graphic(graph)

    def _on_value_changed(self):
        self.update()


class ValueComponent(ValueComponentBase):
    """
    Component to control one continuous property with a infinite
    touch-sensitive encoder. You can optionally give it a display and
    a button such that the value will be displayed while its pressed.
    """
    encoder_factor = 1.0

    def create_display_component(self, *a, **k):
        return ValueDisplayComponent(property_name=self._property_name, subject=self._subject, display_format=self._display_format, view_transform=(lambda x: self.view_transform(x)), graphic_transform=(lambda x: self.graphic_transform(x)), *a, **k)

    def __init__(self, property_name = None, subject = None, display_format = '%f', model_transform = None, view_transform = None, graphic_transform = None, encoder_factor = 1.0, *a, **k):
        self._property_name = property_name
        self._subject = subject
        self._display_format = display_format
        super(ValueComponent, self).__init__(*a, **k)
        if model_transform is not None:
            self.model_transform = model_transform
        if view_transform is not None:
            self.view_transform = view_transform
        if graphic_transform is not None:
            self.graphic_transform = graphic_transform
        if encoder_factor is not None:
            self.encoder_factor = encoder_factor

    def model_transform(self, x):
        """
        Tranform a value 'x' from the view domain to the domain as
        stored in the subject.
        """
        return x

    def view_transform(self, x):
        """
        Transform a value 'x' from the model domain to the view domain
        as represented to the user.
        """
        return x

    def graphic_transform(self, x):
        """
        Transform a value 'x' from the model domain to [0..1] range to
        be used in the slider-representation of the value.
        """
        return self.view_transform(x) / self.encoder_factor

    def set_encoder(self, encoder):
        self._on_encoder_value.subject = encoder

    @subject_slot('normalized_value')
    def _on_encoder_value(self, value):
        value = self.view_transform(getattr(self._subject, self._property_name)) + value * self.encoder_factor
        setattr(self._subject, self._property_name, self.model_transform(value))


class ParameterValueDisplayComponent(ValueDisplayComponentBase):
    """
    Display for values from device parameters.
    """

    def __init__(self, device_parameter = None, *a, **k):
        super(ParameterValueDisplayComponent, self).__init__(*a, **k)
        self._on_value_changed.subject = device_parameter
        self._on_value_changed()

    def get_value_string(self):
        return str(self._on_value_changed.subject)

    def get_graphic_string(self):
        return convert_parameter_value_to_graphic(self._on_value_changed.subject)

    @subject_slot('value')
    def _on_value_changed(self):
        self.update()


class ParameterValueComponent(ValueComponentBase):
    """
    Component to control a device parameter with a infinite
    touch-sensitive encoder. You can optionally give it a display and
    a button such that the value will be displayed while its pressed.
    """

    def create_display_component(self, *a, **k):
        return ParameterValueDisplayComponent(device_parameter=self._parameter_slot.parameter, *a, **k)

    def __init__(self, device_parameter = None, *a, **k):
        self._parameter_slot = ParameterSlot(device_parameter)
        super(ParameterValueComponent, self).__init__(*a, **k)
        self.register_disconnectable(self._parameter_slot)

    def set_encoder(self, encoder):
        self._parameter_slot.control = encoder
########NEW FILE########
__FILENAME__ = ViewControlComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/ViewControlComponent.py
import Live
NavDirection = Live.Application.Application.View.NavDirection
from _Framework.CompoundComponent import CompoundComponent
from _Framework.Dependency import depends
from _Framework.ScrollComponent import ScrollComponent, Scrollable
from _Framework.Util import in_range
from SpecialMixerComponent import tracks_to_use_from_song
VIEWS = ('Browser', 'Arranger', 'Session', 'Detail', 'Detail/Clip', 'Detail/DeviceChain')

class _DeltaSongScroller(Scrollable):

    @depends(song=None)
    def __init__(self, song = None, *a, **k):
        super(_DeltaSongScroller, self).__init__(*a, **k)
        self._song = song

    _do_scroll = NotImplemented
    _can_scroll = NotImplemented

    def scroll_up(self):
        if self.can_scroll_up():
            self._do_scroll(-1)

    def scroll_down(self):
        if self.can_scroll_down():
            self._do_scroll(1)

    def can_scroll_up(self):
        return self._can_scroll(-1)

    def can_scroll_down(self):
        return self._can_scroll(1)


def tracks_to_use(song):
    return list(tracks_to_use_from_song(song) + (song.master_track,))


def next_item(seq, item, delta):
    return seq[list(seq).index(item) + delta]


def has_next_item(seq, item, delta):
    return in_range(list(seq).index(item) + delta, 0, len(seq))


class TrackScroller(_DeltaSongScroller):

    def _do_scroll(self, delta):
        song = self._song
        tracks = tracks_to_use(song)
        track = next_item(tracks, song.view.selected_track, delta)
        song.view.selected_track = track
        if track.can_be_armed:
            playing_slot_index = track.playing_slot_index
            if playing_slot_index >= 0 and track.clip_slots[playing_slot_index].clip:
                song.view.highlighted_clip_slot = track.clip_slots[playing_slot_index]

    def _can_scroll(self, delta):
        tracks = tracks_to_use(self._song)
        try:
            return has_next_item(tracks, self._song.view.selected_track, delta)
        except ValueError:
            return False


class BasicSceneScroller(_DeltaSongScroller):

    def _do_scroll(self, delta):
        song = self._song
        view = song.view
        view.selected_scene = next_item(song.scenes, view.selected_scene, delta)

    def _can_scroll(self, delta):
        song = self._song
        view = song.view
        return has_next_item(song.scenes, view.selected_scene, delta)


class SceneScroller(BasicSceneScroller):

    def _do_scroll(self, delta):
        super(SceneScroller, self)._do_scroll(delta)
        if self._song.view.highlighted_clip_slot != None:
            if self._song.view.highlighted_clip_slot.has_clip:
                self._song.view.highlighted_clip_slot.fire(force_legato=True, launch_quantization=Live.Song.Quantization.q_no_q)
            else:
                self._song.view.selected_track.stop_all_clips(False)


class SceneListScroller(BasicSceneScroller):

    def _do_scroll(self, delta):
        super(SceneListScroller, self)._do_scroll(delta)
        self._song.view.selected_scene.fire(force_legato=True, can_select_scene_on_launch=False)


class ViewControlComponent(CompoundComponent):
    """
    Component that can toggle the device chain- and clip view of the
    selected track
    """

    def __init__(self, *a, **k):
        super(ViewControlComponent, self).__init__(*a, **k)
        self._scroll_tracks, self._scroll_scene_list, self._scroll_scenes = self.register_components(ScrollComponent(TrackScroller()), ScrollComponent(SceneListScroller()), ScrollComponent(SceneScroller()))
        song = self.song()
        view = song.view
        self.register_slot(song, self._scroll_tracks.update, 'visible_tracks')
        self.register_slot(song, self._scroll_tracks.update, 'return_tracks')
        self.register_slot(song, self._scroll_scenes.update, 'scenes')
        self.register_slot(song, self._scroll_scene_list.update, 'scenes')
        self.register_slot(view, self._scroll_tracks.update, 'selected_track')
        self.register_slot(view, self._scroll_scenes.update, 'selected_scene')
        self.register_slot(view, self._scroll_scene_list.update, 'selected_scene')

    def set_next_track_button(self, button):
        self._scroll_tracks.set_scroll_down_button(button)

    def set_prev_track_button(self, button):
        self._scroll_tracks.set_scroll_up_button(button)

    def set_next_scene_button(self, button):
        self._scroll_scenes.set_scroll_down_button(button)

    def set_prev_scene_button(self, button):
        self._scroll_scenes.set_scroll_up_button(button)

    def set_next_scene_list_button(self, button):
        self._scroll_scene_list.set_scroll_down_button(button)

    def set_prev_scene_list_button(self, button):
        self._scroll_scene_list.set_scroll_up_button(button)

    def show_view(self, view):
        raise view in VIEWS or AssertionError
        app_view = self.application().view
        try:
            if view == 'Detail/DeviceChain' or 'Detail/Clip':
                if not app_view.is_view_visible('Detail'):
                    app_view.show_view('Detail')
            if not app_view.is_view_visible(view):
                app_view.show_view(view)
        except RuntimeError:
            pass

    def focus_view(self, view):
        if not view in VIEWS:
            raise AssertionError
            app_view = self.application().view
            if view == 'Detail/DeviceChain' or 'Detail/Clip':
                if not app_view.is_view_visible('Detail'):
                    app_view.show_view('Detail')
            app_view.is_view_visible(view) or app_view.focus_view(view)

    def update(self):
        pass
########NEW FILE########
__FILENAME__ = WithPriority
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Push/WithPriority.py
from _Framework.Resource import PrioritizedResource
from _Framework.Util import nop
from ComboElement import WrapperElement

class WithPriority(WrapperElement):

    def __init__(self, wrapped_priority = PrioritizedResource.default_priority, *a, **k):
        super(WithPriority, self).__init__(*a, **k)
        self.wrapped_priority = wrapped_priority
        self.register_control_element(self.wrapped_control)

    def get_control_element_priority(self, element):
        return self.wrapped_priority


class Resetting(WrapperElement):
    _is_resource_based = True

    def __init__(self, *a, **k):
        super(Resetting, self).__init__(*a, **k)
        self.register_control_element(self.wrapped_control)

    def on_nested_control_element_grabbed(self, element):
        element.reset()
        getattr(element, 'release_parameter', nop)()
########NEW FILE########
__FILENAME__ = ConfigurableButtonElement
#Embedded file name: /Applications/Ableton Live 8.app/Contents/App-Resources/MIDI Remote Scripts/QuNeo/ConfigurableButtonElement.py
import Live
from _Framework.ButtonElement import *

class ConfigurableButtonElement(ButtonElement):
    __module__ = __name__
    __doc__ = ' Special button class that can be configured with custom on- and off-values '

    def __init__(self, is_momentary, msg_type, channel, identifier, vel):
        ButtonElement.__init__(self, is_momentary, msg_type, channel, identifier)
        if vel != 0:
            self._on_value = vel
        else:
            self._on_value = 127
        self._note = identifier
        self._off_value = 0
        self._blink_on = None
        self._blinking = False
        self._led_on = 0
        self._is_enabled = True
        self._is_notifying = False
        self._force_next_value = False
        self._pending_listeners = []
        self.count = 0

    def note_on(self):
        if self.count > 1:
            self.count = 0
        else:
            None
        if self.count == 1:
            self.turn_on()
        else:
            self.turn_off()

    def set_on_off_values(self, on_value, off_value):
        raise on_value in range(128) or AssertionError
        raise off_value in range(128) or AssertionError
        self._last_sent_value = -1
        self._on_value = on_value
        self._off_value = off_value

    def set_force_next_value(self):
        self._force_next_value = True

    def set_enabled(self, enabled):
        self._is_enabled = enabled

    def turn_on(self):
        self.send_value(self._on_value)

    def turn_off(self):
        self.send_value(self._off_value)

    def reset(self):
        self.send_value(0)

    def add_value_listener(self, callback, identify_sender = False):
        if not self._is_notifying:
            ButtonElement.add_value_listener(self, callback, identify_sender)
        else:
            self._pending_listeners.append((callback, identify_sender))

    def receive_value(self, value):
        self._is_notifying = True
        ButtonElement.receive_value(self, value)
        self._is_notifying = False
        for listener in self._pending_listeners:
            self.add_value_listener(listener[0], listener[1])

        self._pending_listeners = []

    def send_value(self, value, force = False):
        ButtonElement.send_value(self, value, force or self._force_next_value)
        self._force_next_value = False

    def install_connections(self):
        if self._is_enabled:
            ButtonElement.install_connections(self)
        elif self._msg_channel != self._original_channel or self._msg_identifier != self._original_identifier:
            self._install_translation(self._msg_type, self._original_identifier, self._original_channel, self._msg_identifier, self._msg_channel)
########NEW FILE########
__FILENAME__ = MIDI_Map
#Embedded file name: /Applications/Ableton Live 8.app/Contents/App-Resources/MIDI Remote Scripts/QuNeo/MIDI_Map.py
TRACK_OFFSET = -1
SCENE_OFFSET = 0
PAD_CHANNEL = 8
GRID_CHANNEL = 2
NOTE_OFFSET = 9
DRUM_RACK_CHANNEL = 5
METRO_CHANNEL = 5
RED_HI = 127
RED_LO = 110
GREEN_HI = 40
GREEN_LO = 10
ORANGE_HI = 80
ORANGE_LO = 60
ZERO_DB = 0.0
SHIFT_BUTTON = 45
PLAY = 35
STOP = 34
REC = 33
TAP_TEMPO = 36
LOOP = 39
OVERDUB = 39
METRONOME = 38
TEMPO_UP = 37
TEMPO_DOWN = 36
SEND_A = 6
SEND_B = 7
DEVICELOCK = -1
DEVICEONOFF = -1
DEVICENAVLEFT = -1
DEVICENAVRIGHT = -1
DEVICEBANKNAVLEFT = -1
DEVICEBANKNAVRIGHT = -1
DEVICEBANK = (-1, -1, -1, -1, -1, -1, -1, -1)
SEEKFWD = -1
SEEKRWD = -1
SESSION_LEFT = 42
SESSION_RIGHT = 43
SESSION_UP = 47
SESSION_DOWN = 46
TRACK_LEFT = 40
TRACK_RIGHT = 41
SCENE_UP = 48
SCENE_DOWN = 49
SLOT_LAUNCH = 14
SCENE_LAUNCH = [126,
 110,
 94,
 78,
 62,
 46,
 30]
MAJOR_SCALE = [0,
 2,
 4,
 5,
 7,
 9,
 11,
 12]
MAJOR_SCALE.reverse()
CHROMATIC_SCALE = [0,
 1,
 2,
 3,
 4,
 5,
 6,
 7]
CHROMATIC_SCALE.reverse()
STOP_ALL_CLIPS = 62
CLIP_NOTE_MAP = [[112,
  114,
  116,
  118,
  120,
  122,
  124,
  126],
 [96,
  98,
  100,
  102,
  104,
  106,
  108,
  110],
 [80,
  82,
  84,
  86,
  88,
  90,
  92,
  94],
 [64,
  66,
  68,
  70,
  72,
  74,
  76,
  78],
 [48,
  50,
  52,
  54,
  56,
  58,
  60,
  62],
 [32,
  34,
  36,
  38,
  40,
  42,
  44,
  46],
 [16,
  18,
  20,
  22,
  24,
  26,
  28,
  30],
 [0,
  2,
  4,
  6,
  8,
  10,
  12,
  14]]
STEP_SEQUENCER_MAP = CLIP_NOTE_MAP
MASTERSEL = -1
TRACK_MUTE = [32,
 34,
 36,
 38,
 40,
 42,
 44,
 46]
TRACK_SOLO = [16,
 18,
 20,
 22,
 24,
 26,
 28,
 30]
TRACK_ARM = [0,
 2,
 4,
 6,
 8,
 10,
 12,
 14]
STOP_TRACK = [48,
 50,
 52,
 54,
 56,
 58,
 60]
DRUM_PADS = [[12,
  13,
  14,
  15],
 [8,
  9,
  10,
  11],
 [4,
  5,
  6,
  7],
 [0,
  1,
  2,
  3]]
DRUM_RACK_UP = 46
DRUM_RACK_DOWN = 47
SLIDER_CHANNEL = 8
TEMPO_TOP = 140.0
TEMPO_BOTTOM = 40.0
TEMPO_CONTROL = 11
TEMPO_FINE = 10
MASTERVOLUME = -1
CUELEVEL = -1
CROSSFADER = 5
SELECTED_SENDS = [11, 10]
SELECTED_PAN = 9
SELECTED_VOL = 8
TRACK_VOL = [1,
 2,
 3,
 4]
########NEW FILE########
__FILENAME__ = QuNeo
#Embedded file name: /Applications/Ableton Live 8.app/Contents/App-Resources/MIDI Remote Scripts/QuNeo/QuNeo.py
import Live
import time
import math
from _Framework.ButtonElement import ButtonElement
from _Framework.ChannelStripComponent import ChannelStripComponent
from _Framework.DeviceComponent import DeviceComponent
from _Framework.ClipSlotComponent import ClipSlotComponent
from _Framework.EncoderElement import EncoderElement
from _Framework.ControlElement import ControlElement
from _Framework.ControlSurface import ControlSurface
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.InputControlElement import *
from _Framework.SceneComponent import SceneComponent
from _Framework.SliderElement import SliderElement
from ConfigurableButtonElement import ConfigurableButtonElement
from SpecialSessionComponent import SpecialSessionComponent
from SpecialTransportComponent import SpecialTransportComponent
from SpecialMixerComponent import SpecialMixerComponent
from MIDI_Map import *
from VUMeter import VUMeter

class QuNeo(ControlSurface):
    """ Script for Keith McMillen's QuNeo Multi-Touchpad Controller """
    __module__ = __name__
    _active_instances = []

    def _combine_active_instances():
        support_devices = False
        for instance in QuNeo._active_instances:
            support_devices |= instance._device_component != None

        track_offset = 0
        for instance in QuNeo._active_instances:
            instance._activate_combination_mode(track_offset, support_devices)
            track_offset += instance._session.width()

    _combine_active_instances = staticmethod(_combine_active_instances)

    def __init__(self, c_instance):
        ControlSurface.__init__(self, c_instance)
        self.set_suppress_rebuild_requests(True)
        self._suppress_session_highlight = True
        self._suppress_send_midi = True
        self._suggested_input_port = 'QUNEO'
        self._suggested_output_port = 'QUNEO'
        self.num_tracks = 7
        self.num_scenes = 4
        self.session = None
        self.mixer = None
        self.transport = None
        self.led_value = None
        self._note_input = []
        self.shift_button = None
        self.sequencer_button = None
        self.launch_button = None
        self.seq_offset_down = None
        self.seq_offset_up = None
        self.seq_offset_left = None
        self.seq_offset_right = None
        self.stop_all_clips = None
        self.track_bank_right = None
        self.track_bank_left = None
        self.scene_bank_down = None
        self.scene_bank_up = None
        self.beat_table = []
        self.sends = []
        self.arm_buttons = None
        self.mute_buttons = None
        self.solo_buttons = None
        self.shift_buttons = []
        self.sequencer_buttons = None
        self.scene_launch_buttons = None
        self.stop_track_buttons = None
        self.clip_slot_buttons = None
        self.instrument_buttons = None
        self.volume_control = None
        self.pan_control = None
        self.current_mode = 0
        self.set_shift_button(ConfigurableButtonElement(True, MIDI_NOTE_TYPE, PAD_CHANNEL, SHIFT_BUTTON, 127))
        self._setup_transport_control()
        self._setup_mixer_control()
        self._setup_session_control()
        self.session.set_mixer(self.mixer)
        self._shift_mode(0)
        self._set_mode(0)
        app = Live.Application.get_application()
        maj = app.get_major_version()
        min = app.get_minor_version()
        bug = app.get_bugfix_version()
        self.show_message(str(maj) + '.' + str(min) + '.' + str(bug))
        self.set_suppress_rebuild_requests(False)

    def disconnect(self):
        self.mixer
        self.session
        if self.shift_button != None:
            self.shift_button.remove_value_listener(self._shift_value)
            self.shift_button = None
        if self.shift_buttons != None:
            for button in self.shift_buttons:
                button.remove_value_listener(self._shift_buttons_value)

            self.shift_buttons = None
        self._note_input = None
        ControlSurface.disconnect(self)

    def refresh_state(self):
        ControlSurface.refresh_state(self)

    def set_shift_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self.shift_button != button:
                if self.shift_button != None:
                    self.shift_button.remove_value_listener(self._shift_value)
                self.shift_button = button
                self.shift_button != None and self.shift_button.add_value_listener(self._shift_value)

    def update_mode(self, mode):
        if mode != None:
            self._set_mode(mode)
            self.current_mode = mode

    def set_shift_buttons(self, buttons):
        if buttons != None:
            if self.shift_buttons != buttons:
                self.shift_buttons.remove_value_listener(self._shift_buttons_value)
            self.shift_buttons = buttons
            if self.shift_buttons != None:
                for button in self.shift_buttons:
                    raise isinstance(button, ButtonElement) or AssertionError
                    button.add_value_listener(self._shift_buttons_value, identify_sender=True)

        else:
            if self.shift_buttons != None:
                for button in self.shift_buttons:
                    button.remove_value_listener(self._shift_buttons_value)

            self.shift_buttons = None

    def _shift_buttons_value(self, value, sender):
        raise self.shift_buttons != None or AssertionError
        raise value in range(128) or AssertionError
        mode = int(sender._note * 0.5)
        self.update_mode(mode)

    def _shift_value(self, value):
        if not value in range(128):
            raise AssertionError
            raise self.shift_button != None or AssertionError
            value != 0 and self._shift_mode(1)
            self.shift_button.turn_on()
        else:
            self._shift_mode(0)
            self.shift_button.turn_off()

    def _shift_mode(self, value):
        if value != 0:
            self.set_suppress_rebuild_requests(True)
            self._reassign_grid(0)
            self._reassign_mixer_control(1)
            self.set_suppress_rebuild_requests(False)
        else:
            None
            self._set_mode(self.current_mode)
            self._reassign_mixer_control(1)

    def _update_grid(self):
        if self.sequencer_buttons != None:
            self.session.set_sequencer_buttons(self.sequencer_buttons)
        else:
            self.session.set_sequencer_buttons(None)
        if self.seq_offset_left != None and self.seq_offset_right != None:
            self.session.set_seq_measure_offset(self.seq_offset_left, self.seq_offset_right)
        else:
            self.session.set_seq_measure_offset(None, None)
        if self.seq_offset_up != None and self.seq_offset_down != None:
            self.session.set_seq_note_offset(self.seq_offset_up, self.seq_offset_down)
        else:
            self.session.set_seq_note_offset(None, None)
        if self.launch_button != None:
            self.session.set_slot_launch_button(self.launch_button)
        else:
            self.session.set_slot_launch_button(None)
        if self.scene_launch_buttons != None:
            for index in range(len(self.scene_launch_buttons)):
                self.session.scene(index).set_launch_button(self.scene_launch_buttons[index])

        else:
            for index in range(4):
                self.session.scene(index).set_launch_button(None)

        if self.stop_track_buttons != None:
            self.session.set_stop_track_clip_buttons(tuple(self.stop_track_buttons))
        else:
            self.session.set_stop_track_clip_buttons(None)
        if self.stop_all_clips != None:
            self.session.set_stop_all_clips_button(self.stop_all_clips)
        else:
            self.session.set_stop_all_clips_button(None)
        if self.track_bank_right != None and self.track_bank_left != None:
            self.session.set_track_bank_buttons(self.track_bank_right, self.track_bank_left)
        else:
            self.session.set_track_bank_buttons(None, None)
        if self.scene_bank_up != None and self.scene_bank_down != None:
            self.session.set_scene_bank_buttons(self.scene_bank_up, self.scene_bank_down)
        else:
            self.session.set_scene_bank_buttons(None, None)
        for row in range(4):
            for col in range(7):
                self.clip = self.session.scene(row).clip_slot(col)
                if self.clip_slot_buttons != None:
                    self.clip.set_triggered_to_play_value(30)
                    self.clip.set_triggered_to_record_value(RED_HI)
                    self.clip.set_started_value(30)
                    self.clip.set_recording_value(RED_HI)
                    self.clip.set_stopped_value(80)
                    self.clip.set_triggered_to_record_value(6)
                    self.clip.set_launch_button(self.clip_slot_buttons[row][col])
                else:
                    self.clip.set_launch_button(None)

    def turn_off_all_buttons(self):
        self.arm_buttons = None
        self.mute_buttons = None
        self.solo_buttons = None
        self.scene_launch_buttons = None
        self.stop_track_buttons = None
        if self.clip_slot_buttons != None:
            for row in range(4):
                for col in range(7):
                    button = self.clip_slot_buttons[row][col]
                    button.turn_off()

        self.clip_slot_buttons = None
        if self.shift_buttons != None:
            for button in self.shift_buttons:
                button.turn_off()
                button.remove_value_listener(self._shift_buttons_value)

        if self.sequencer_buttons != None:
            for button in self.sequencer_buttons:
                button.count = 0
                button.note_on()

        self.instrument_buttons = None
        self.shift_buttons = None
        self.sequencer_buttons = None
        self.clip_slot_buttons = None
        self.launch_button = None
        self.stop_all_clips = None
        self.track_bank_left = None
        self.track_bank_right = None
        self.scene_bank_up = None
        self.scene_bank_down = None
        self.seq_offset_left = None
        self.seq_offset_right = None
        self.seq_offset_up = None
        self.seq_offset_down = None

    def _set_mode(self, mode):
        self.turn_off_all_buttons()
        if mode == 0:
            self.stop_track_buttons = []
            self.scene_launch_buttons = []
            self.track_bank_left = self.button(PAD_CHANNEL, SESSION_LEFT)
            self.track_bank_right = self.button(PAD_CHANNEL, SESSION_RIGHT)
            self.scene_bank_up = self.button(PAD_CHANNEL, SESSION_UP)
            self.scene_bank_down = self.button(PAD_CHANNEL, SESSION_DOWN)
            self.stop_all_clips = self.led_button(GRID_CHANNEL, STOP_ALL_CLIPS, 100)
            self.launch_button = self.led_button(GRID_CHANNEL, SLOT_LAUNCH, RED_HI)
            self.clip_slot_buttons = []
            for row in range(4):
                self.clip_slot_buttons.append([])
                for col in range(7):
                    self.clip_slot_buttons[row].append(self.button(GRID_CHANNEL, CLIP_NOTE_MAP[row][col]))

            self.mute_buttons = []
            self.solo_buttons = []
            self.arm_buttons = []
            for index in range(7):
                self.mute_buttons.append(self.led_button(GRID_CHANNEL, TRACK_MUTE[index], GREEN_HI))
                self.solo_buttons.append(self.led_button(GRID_CHANNEL, TRACK_SOLO[index], ORANGE_HI))
                self.arm_buttons.append(self.led_button(GRID_CHANNEL, TRACK_ARM[index], RED_HI))
                self.stop_track_buttons.append(self.led_button(GRID_CHANNEL, STOP_TRACK[index], 100))

            for scene in range(4):
                self.scene_launch_buttons.append(self.led_button(GRID_CHANNEL, SCENE_LAUNCH[scene], GREEN_LO))

            self._update_session()
            self._update_grid()
        elif mode == 1:
            self.seq_offset_left = self.button(PAD_CHANNEL, SESSION_LEFT)
            self.seq_offset_right = self.button(PAD_CHANNEL, SESSION_RIGHT)
            self.seq_offset_up = self.button(PAD_CHANNEL, SESSION_UP)
            self.seq_offset_down = self.button(PAD_CHANNEL, SESSION_DOWN)
            self.sequencer_buttons = []
            for row in range(8):
                for col in range(8):
                    self.sequencer_buttons.append(self.led_button(GRID_CHANNEL, CLIP_NOTE_MAP[row][col], GREEN_HI))

            self._update_session()
            self._update_grid()
            self.session.clear_led()
            self.session.update_notes()
            self.session.on_device_changed()
        else:
            self.track_bank_left = self.button(PAD_CHANNEL, SESSION_LEFT)
            self.track_bank_right = self.button(PAD_CHANNEL, SESSION_RIGHT)
            self.scene_bank_up = self.button(PAD_CHANNEL, SESSION_UP)
            self.scene_bank_down = self.button(PAD_CHANNEL, SESSION_DOWN)
            self._update_session()
            self._update_grid()

    def _reassign_grid(self, value):
        if value == 0:
            self.turn_off_all_buttons()
            self.shift_buttons = []
            for index in range(2):
                self.shift_buttons.append(self.led_button(GRID_CHANNEL, TRACK_ARM[index], 127))
                if index == self.current_mode:
                    self.shift_buttons[index].send_value(127, True)
                else:
                    self.shift_buttons[index].send_value(40, True)

            self._update_session()
            self._update_grid()
        else:
            None

    def button(self, channel, value):
        is_momentary = True
        if value != -1:
            return ButtonElement(is_momentary, MIDI_NOTE_TYPE, channel, value)
        else:
            return None

    def led_button(self, channel, value, vel):
        is_momentary = True
        if value != -1:
            return ConfigurableButtonElement(is_momentary, MIDI_NOTE_TYPE, channel, value, vel)
        else:
            return None

    def slider(self, channel, value):
        if value != -1:
            return SliderElement(MIDI_CC_TYPE, channel, value)
        else:
            return None

    def assign_encoder(self, channel, value):
        if value != -1:
            return EncoderElement(MIDI_CC_TYPE, channel, value, Live.MidiMap.MapMode.relative_two_compliment)
        else:
            return None

    def _reassign_mixer_control(self, shift_value):
        if shift_value == 1:
            for index in range(2):
                self.sends.append(self.slider(SLIDER_CHANNEL, SELECTED_SENDS[index]))

            self.volume_control = self.slider(SLIDER_CHANNEL, SELECTED_VOL)
            self.pan_control = self.slider(SLIDER_CHANNEL, SELECTED_PAN)
        if self.sends != None:
            self.mixer.selected_strip().set_send_controls(tuple(self.sends))
        else:
            self.mixer.selected_strip().set_send_controls(tuple(None))
        if self.volume_control != None:
            self.mixer.selected_strip().set_volume_control(self.volume_control)
        else:
            self.mixer.selected_strip().set_volume_control(None)
        if self.pan_control != None:
            self.mixer.selected_strip().set_pan_control(self.pan_control)
        else:
            self.mixer.selected_strip().set_pan_control(None)

    def _update_session(self):
        if self.shift_buttons != None:
            self.set_shift_buttons(self.shift_buttons)
        else:
            self.set_shift_buttons(None)
        for index in range(7):
            if self.arm_buttons != None:
                self.mixer.channel_strip(index).set_arm_button(self.arm_buttons[index])
            else:
                self.mixer.channel_strip(index).set_arm_button(None)
            if self.solo_buttons != None:
                self.mixer.channel_strip(index).set_solo_button(self.solo_buttons[index])
            else:
                self.mixer.channel_strip(index).set_solo_button(None)
            if self.mute_buttons != None:
                self.mixer.channel_strip(index).set_invert_mute_feedback(True)
                self.mixer.channel_strip(index).set_mute_button(self.mute_buttons[index])
            else:
                self.mixer.channel_strip(index).set_mute_button(None)

    def _setup_transport_control(self):
        self.transport = SpecialTransportComponent()
        self.transport.set_metronome_button(self.led_button(PAD_CHANNEL, METRONOME, 127))
        self.transport.set_play_button(self.led_button(PAD_CHANNEL, PLAY, 127))
        self.transport.set_stop_button(self.led_button(PAD_CHANNEL, STOP, 127))
        self.transport.set_record_button(self.led_button(PAD_CHANNEL, REC, 127))
        self.transport.set_overdub_button(self.led_button(PAD_CHANNEL, OVERDUB, 127))
        self.transport.set_tempo_buttons(self.led_button(PAD_CHANNEL, TEMPO_UP, 127), self.led_button(PAD_CHANNEL, TEMPO_DOWN, 127))

    def _setup_mixer_control(self):
        self.mixer = SpecialMixerComponent(self.num_tracks, self)
        self.mixer.name = 'Mixer'
        self.mixer.set_track_offset(0)
        self.mixer.set_select_buttons(self.button(PAD_CHANNEL, TRACK_RIGHT), self.button(PAD_CHANNEL, TRACK_LEFT))
        self.mixer.set_crossfader_control(self.slider(SLIDER_CHANNEL, CROSSFADER))
        for index in range(4):
            self.mixer.channel_strip(index).set_volume_control(self.slider(SLIDER_CHANNEL, TRACK_VOL[index]))

        self.num_o_tracks = self.song().visible_tracks
        if self.num_o_tracks != None:
            index_count = -1
            index_table = []
            for index in self.song().visible_tracks:
                index_count += 1
                if index.has_midi_output != True:
                    index_table.append(index_count)
                else:
                    None

            if index_table != None:
                for index in range(len(index_table)):
                    x = index_table[index]
                    if x > 3:
                        None
                    else:
                        None

    def _setup_session_control(self):
        self.session = SpecialSessionComponent(self.num_tracks, self.num_scenes, self)
        self.session.set_offsets(0, 0)
        self.session.set_select_buttons(self.button(PAD_CHANNEL, SCENE_DOWN), self.button(PAD_CHANNEL, SCENE_UP))
        self.session.set_clip_loop_start(self.slider(SLIDER_CHANNEL, 6))
        self.session.set_clip_loop_length(self.slider(SLIDER_CHANNEL, 7))

    def _on_selected_scene_changed(self):
        ControlSurface._on_selected_scene_changed(self)

    def _on_selected_track_changed(self):
        ControlSurface._on_selected_track_changed(self)

    def _activate_combination_mode(self, track_offset, support_devices):
        self._session.link_with_track_offset(track_offset)
########NEW FILE########
__FILENAME__ = SequencerMetronome
#Embedded file name: /Applications/Ableton Live 8.app/Contents/App-Resources/MIDI Remote Scripts/QuNeo/SequencerMetronome.py
import Live
import time
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from ConfigurableButtonElement import ConfigurableButtonElement
from _Framework.InputControlElement import *
from MIDI_Map import *

class SequencerMetronome(ControlSurfaceComponent):

    def __init__(self, parent):
        ControlSurfaceComponent.__init__(self)
        self.parent = parent
        self.last_beat = None
        self.led_pad = []
        self.led_metro_buttons()
        self.last_time = None
        self.count = -1

    def update_time(self):
        if self.song().is_playing != False:
            self.new_time = self.song().get_current_beats_song_time().beats
            if self.new_time != self.last_time:
                self.count += 1
                if self.count > 3:
                    self.count = 0
            self.parent.log_message('Its been %f seconds' + str(self.new_time))
            self.led_pad[self.new_time - 1].send_value(127, True)
            self.led_pad[self.new_time - 2].send_value(0, True)
            self.led_pad[self.new_time + 2].send_value(0, True)
            self.last_time = self.new_time

    def disconnect(self):
        if self.led_pad != None:
            for row in range(4):
                self.led_pad[row].turn_off()

        self.led_pad = None

    def led_metro_buttons(self):
        for index in range(4):
            self.led_pad.append(ConfigurableButtonElement(True, MIDI_NOTE_TYPE, METRO_CHANNEL, LED_METRO_2[index], RED_HI))

    def update(self):
        pass
########NEW FILE########
__FILENAME__ = SpecialChannelStripComponent
#Embedded file name: /Applications/Ableton Live 8.app/Contents/App-Resources/MIDI Remote Scripts/QuNeo/SpecialChannelStripComponent.py
import Live
from _Framework.ChannelStripComponent import ChannelStripComponent
TRACK_FOLD_DELAY = 5

class SpecialChannelStripComponent(ChannelStripComponent):
    """ Subclass of channel strip component using select button for (un)folding tracks """
    __module__ = __name__

    def __init__(self):
        ChannelStripComponent.__init__(self)
        self._toggle_fold_ticks_delay = -1
        self._register_timer_callback(self._on_timer)

    def disconnect(self):
        self._unregister_timer_callback(self._on_timer)
        ChannelStripComponent.disconnect(self)

    def _select_value(self, value):
        ChannelStripComponent._select_value(self, value)
        if self.is_enabled() and self._track != None:
            if self._track.is_foldable and self._select_button.is_momentary() and value != 0:
                self._toggle_fold_ticks_delay = TRACK_FOLD_DELAY
            else:
                self._toggle_fold_ticks_delay = -1

    def _on_timer(self):
        if self.is_enabled() and self._track != None and self._toggle_fold_ticks_delay > -1:
            if not self._track.is_foldable:
                raise AssertionError
                if self._toggle_fold_ticks_delay == 0:
                    self._track.fold_state = not self._track.fold_state
                self._toggle_fold_ticks_delay -= 1
########NEW FILE########
__FILENAME__ = SpecialMixerComponent
#Embedded file name: /Applications/Ableton Live 8.app/Contents/App-Resources/MIDI Remote Scripts/QuNeo/SpecialMixerComponent.py
import Live
from _Framework.MixerComponent import MixerComponent
from SpecialChannelStripComponent import SpecialChannelStripComponent
from VUMeter import VUMeter

class SpecialMixerComponent(MixerComponent):
    """ Special mixer class that uses return tracks alongside midi and audio tracks """
    __module__ = __name__

    def __init__(self, num_tracks, parent):
        MixerComponent.__init__(self, num_tracks)
        self._parent = parent
        self._volume_encoder_control = None
        self._vu_meters = []
        for index in self.song().visible_tracks:
            if index.has_midi_output != True:
                self._vu_meters.append(self._create_vu_meter())
            else:
                None

        self.on_selected_track_changed()

    def disconnect(self):
        MixerComponent.disconnect(self)
        self._vu_meters = None

    def build_master(self, master):
        """ Build and assign master volume fader if set """
        if master is not None:
            master_strip = self.master_strip()
            master_strip.set_volume_control(self.encoder(master))

    def vu_meter(self, index):
        raise index in range(len(self._vu_meters)) or AssertionError
        return self._vu_meters[index]

    def tracks_to_use(self):
        return self.song().visible_tracks + self.song().return_tracks

    def _create_strip(self):
        return SpecialChannelStripComponent()

    def _create_vu_meter(self):
        return VUMeter(self)

    def on_selected_track_changed(self):
        MixerComponent.on_selected_track_changed(self)
########NEW FILE########
__FILENAME__ = SpecialSessionComponent
#Embedded file name: /Applications/Ableton Live 8.app/Contents/App-Resources/MIDI Remote Scripts/QuNeo/SpecialSessionComponent.py
import Live
from _Framework.EncoderElement import EncoderElement
from _Framework.SessionComponent import SessionComponent
from _Framework.ButtonElement import ButtonElement
from _Framework.SliderElement import SliderElement
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from ConfigurableButtonElement import ConfigurableButtonElement
from MIDI_Map import *

class SpecialSessionComponent(SessionComponent):
    __module__ = __name__

    def __init__(self, num_tracks, num_scenes, parent):
        SessionComponent.__init__(self, num_tracks, num_scenes)
        self._parent = parent
        self._slot_launch_button = None
        self._clip_loop_start = None
        self._clip_loop_length = None
        self._slot_step_sequencer_buttons = []
        self._note_up_button = None
        self._note_down_button = None
        self._measure_left_button = None
        self._measure_right_button = None
        self._sequencer_clip = None
        self.scale = CHROMATIC_SCALE
        self.notes = []
        self.key_offset = 7
        self._key_index = 36
        self._loc_offset = 0.0
        self.grid_size = 2.0
        self.loop_up_table = 8
        self._clip_slot = None
        self._clip_notes = None
        self.update_key_index(36)
        self.update_measure_offset(0.0)

    def disconnect(self):
        SessionComponent.disconnect(self)
        self._parent = None
        self._sequencer_clip = None
        if self._slot_launch_button != None:
            self._slot_launch_button.remove_value_listener(self._slot_launch_value)
            self._slot_launch_button = None
        if self._clip_loop_start != None:
            self._clip_loop_start.remove_value_listener(self._slot_launch_loop_value)
            self._clip_loop_start = None
        if self._slot_step_sequencer_buttons != None:
            for button in self._slot_step_sequencer_buttons:
                button.remove_value_listener(self._slot_step_sequencer_value)

            self._slot_step_sequencer_buttons = None
        if self._note_up_button != None:
            self._note_up_button.remove_value_listener(self._note_up_value)
            self._note_up_button = None
        if self._note_down_button != None:
            self._note_down_button.remove_value_listener(self._note_down_value)
            self._note_down_button = None

    def create_note(self, value, loc):
        if value:
            x = (value,
             loc,
             0.25,
             127,
             False)
        else:
            None
        return x

    def set_slot_launch_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._slot_launch_button != button:
                if self._slot_launch_button != None:
                    self._slot_launch_button.remove_value_listener(self._slot_launch_value)
                self._slot_launch_button = button
                self._slot_launch_button != None and self._slot_launch_button.add_value_listener(self._slot_launch_value)
            self.update()

    def set_seq_note_offset(self, up_button, down_button):
        if not (up_button == None or isinstance(up_button, ButtonElement)):
            raise AssertionError
            if not (down_button == None or isinstance(down_button, ButtonElement)):
                raise AssertionError
                if self._note_up_button != None:
                    self._note_up_button.remove_value_listener(self._note_up_value)
                self._note_up_button = up_button
                if self._note_up_button != None:
                    self._note_up_button.add_value_listener(self._note_up_value)
                self._note_down_button != None and self._note_down_button.remove_value_listener(self._note_down_value)
            self._note_down_button = down_button
            self._note_down_button != None and self._note_down_button.add_value_listener(self._note_down_value)
        self.update()

    def set_seq_measure_offset(self, left_button, right_button):
        if not (left_button == None or isinstance(left_button, ButtonElement)):
            raise AssertionError
            if not (right_button == None or isinstance(right_button, ButtonElement)):
                raise AssertionError
                if self._measure_left_button != None:
                    self._measure_left_button.remove_value_listener(self._measure_left)
                self._measure_left_button = left_button
                if self._measure_left_button != None:
                    self._measure_left_button.add_value_listener(self._measure_left)
                self._measure_right_button != None and self._measure_right_button.remove_value_listener(self._measure_right)
            self._measure_right_button = right_button
            self._measure_right_button != None and self._measure_right_button.add_value_listener(self._measure_right)
        self.update()

    def clear_led(self):
        if self._slot_step_sequencer_buttons != None:
            for button in self._slot_step_sequencer_buttons:
                button.count = 0
                button.note_on()

    def update_key_index(self, value):
        if value != None:
            new_value = value
            if new_value < 0.0 and new_value > 127.0:
                new_value = 0.0
            elif new_value > 127.0:
                new_value = 127.0
            else:
                new_value
            self._key_index = new_value
            if self._slot_step_sequencer_buttons != None:
                for button in self._slot_step_sequencer_buttons:
                    button.count = 0
                    button.note_on()

            self.clear_led()
            self.update_notes()

    def update_measure_offset(self, value):
        new_value = value
        if new_value < 0.0:
            new_value = 0.0
        elif new_value > 127.0:
            new_value = 127.0
        else:
            new_value
        self._loc_offset = new_value
        self.clear_led()
        self.update_notes()

    def update(self):
        if self.song().view.highlighted_clip_slot != None:
            self._sequencer_clip = self.song().view.highlighted_clip_slot.clip
        else:
            self._sequencer_clip = None

    def _measure_left(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._measure_left_button != None:
                raise AssertionError
                new_key_index = self.is_enabled() and value != 0 and -self.grid_size
                real_key_index = new_key_index + self._loc_offset
                self.update_measure_offset(real_key_index)
            else:
                None

    def _measure_right(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._measure_right_button != None:
                raise AssertionError
                new_key_index = self.is_enabled() and value != 0 and self.grid_size
                real_key_index = new_key_index + self._loc_offset
                self.update_measure_offset(real_key_index)
            else:
                None

    def _note_up_value(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._note_up_button != None:
                raise AssertionError
                if self.is_enabled():
                    new_key_index = value != 0 and -self.key_offset
                    real_key_index = new_key_index + self._key_index
                    real_key_index = real_key_index < 0 and 127
                self.update_key_index(real_key_index)
            else:
                None

    def _note_down_value(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._note_down_button != None:
                raise AssertionError
                if self.is_enabled():
                    new_key_index = value != 0 and self.key_offset
                    real_key_index = new_key_index + self._key_index
                    real_key_index = real_key_index > 127 and 0
                self.update_key_index(real_key_index)
            else:
                None

    def set_clip_loop_start(self, slider):
        if not (slider == None or isinstance(slider, EncoderElement)):
            raise AssertionError
            if self._clip_loop_start != slider:
                if self._clip_loop_start != None:
                    self._clip_loop_start.remove_value_listener(self._slot_launch_loop_value)
                self._clip_loop_start = slider
                self._clip_loop_start != None and self._clip_loop_start.add_value_listener(self._slot_launch_loop_value)
            self.update()

    def set_clip_loop_length(self, slider):
        if not (slider == None or isinstance(slider, EncoderElement)):
            raise AssertionError
            if self._clip_loop_length != slider:
                if self._clip_loop_length != None:
                    self._clip_loop_length.remove_value_listener(self._clip_loop_length_value)
                self._clip_loop_length = slider
                self._clip_loop_length != None and self._clip_loop_length.add_value_listener(self._clip_loop_length_value)
            self.update()

    def set_sequencer_buttons(self, buttons):
        if self._slot_step_sequencer_buttons != buttons:
            if self._slot_step_sequencer_buttons != None:
                for button in self._slot_step_sequencer_buttons:
                    button.remove_value_listener(self._slot_step_sequencer_value)

            self._slot_step_sequencer_buttons = buttons
            if self._slot_step_sequencer_buttons != None:
                for button in self._slot_step_sequencer_buttons:
                    raise isinstance(button, ButtonElement) or AssertionError
                    button.add_value_listener(self._slot_step_sequencer_value, identify_sender=True)

            self.update()

    def update_buttons(self):
        for row in range(64):
            for index in range(len(self.new_clip_notes)):
                if self.new_table[row][1] == self.new_clip_notes[index][0] and self.new_table[row][2] == self.new_clip_notes[index][1]:
                    if self._slot_step_sequencer_buttons != None:
                        for note in self._slot_step_sequencer_buttons:
                            if note._note == self.new_table[row][0]:
                                note.count = 1
                                note.note_on()

                    else:
                        None

    def update_quneo_matrix(self):
        self.new_table = []
        for row in range(8):
            for col in range(8):
                self.new_table.append([CLIP_NOTE_MAP[row][col], self._key_index + self.scale[row], self._loc_offset + col / 4.0])

        self.new_clip_notes = []
        if self._clip_notes != None:
            for note in self._clip_notes:
                if note[0] >= self._key_index and note[0] < self._key_index + self.loop_up_table and note[1] >= self._loc_offset and note[1] < self._loc_offset + self.grid_size:
                    self.new_clip_notes.append([note[0], note[1]])

        self.update_buttons()

    def update_notes(self):
        if self._sequencer_clip != None:
            if self._sequencer_clip.is_midi_clip:
                self._sequencer_clip.select_all_notes()
                note_cache = list(self._sequencer_clip.get_selected_notes())
                self._sequencer_clip.deselect_all_notes()
                if self._clip_notes != note_cache:
                    self._clip_notes = note_cache
            self.update_quneo_matrix()

    def _slot_launch_value(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._slot_launch_button != None:
                raise AssertionError
                if self.is_enabled():
                    (value != 0 or not self._slot_launch_button.is_momentary()) and self.song().view.highlighted_clip_slot != None and self.song().view.highlighted_clip_slot.fire()

    def _slot_launch_loop_value(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._clip_loop_start != None:
                raise AssertionError
                if self.is_enabled():
                    if value != 0:
                        if value > 1:
                            new_value = -0.25
                        else:
                            new_value = 0.25
                        if self.song().view.highlighted_clip_slot != None:
                            if self.song().view.highlighted_clip_slot.clip != None:
                                self.song().view.highlighted_clip_slot.clip.looping != False and self.song().view.highlighted_clip_slot.clip.add_loop_start_listener
                                loop_start_pos = self.song().view.highlighted_clip_slot.clip.loop_start
                                loop_end_pos = self.song().view.highlighted_clip_slot.clip.loop_end
                                loop_length = self.song().view.highlighted_clip_slot.clip.length
                                real_value = loop_start_pos + new_value
                                real_value < 0.0 and None
                            else:
                                self.song().view.highlighted_clip_slot.clip.loop_start = real_value
                    else:
                        None

    def _clip_loop_length_value(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._clip_loop_length != None:
                raise AssertionError
                if self.is_enabled():
                    if value != 0:
                        if value > 1:
                            new_value = -0.25
                        else:
                            new_value = 0.25
                        if self.song().view.highlighted_clip_slot != None:
                            if self.song().view.highlighted_clip_slot.clip != None:
                                self.song().view.highlighted_clip_slot.clip.looping != False and self.song().view.highlighted_clip_slot.clip.add_loop_end_listener
                                loop_end_pos = self.song().view.highlighted_clip_slot.clip.loop_end
                                loop_length = self.song().view.highlighted_clip_slot.clip.length
                                real_value = loop_end_pos + new_value
                                return real_value < 0.25 and None
                            else:
                                self.song().view.highlighted_clip_slot.clip.loop_end = real_value
                    else:
                        None

    def _slot_step_sequencer_value(self, value, sender):
        if not value in range(128):
            raise AssertionError
            if not self._slot_step_sequencer_buttons != None:
                raise AssertionError
                if self.is_enabled() and self._sequencer_clip != None and self._sequencer_clip.is_midi_clip and value != 0:
                    for row in range(8):
                        for col in range(8):
                            if sender._note == STEP_SEQUENCER_MAP[row][col]:
                                sender.count += 1
                                sender.note_on()
                                note_value = self._key_index + self.scale[row]
                                loc_value = self._loc_offset + col / 4.0
                                if self._clip_notes != None:
                                    if sender.count == 1:
                                        self._clip_notes.append(self.create_note(note_value, loc_value))
                                    else:
                                        for note in self._clip_notes:
                                            if note_value == note[0] and loc_value == note[1]:
                                                self._clip_notes.remove(note)

                                    self._sequencer_clip.select_all_notes()
                                    self._sequencer_clip.replace_selected_notes(tuple(self._clip_notes))
                                else:
                                    None

        self.update_notes()

    def set_drum_pad_mode(self, value):
        if value == 0:
            self._parent.log_message('!ST VALUE ' + str(value))
        elif value == 1:
            self._parent.log_message('2ND VALUE ' + str(value))
        else:
            None

    def on_selected_track_changed(self):
        if self._slot_step_sequencer_buttons != None:
            for button in self._slot_step_sequencer_buttons:
                button.count = 0
                button.note_on()

        self.on_device_changed()
        self.update()
        self.update_notes()

    def on_device_changed(self):
        if self.song().view.selected_track.view.selected_device != None:
            self.device = self.song().view.selected_track.view.selected_device
            self.device_name = self.device.class_name
            if self.device_name == 'InstrumentImpulse':
                self._key_index = 60
                self.scale = MAJOR_SCALE
                self.key_offset = 0
                self.loop_up_table = 13
            elif self.device_name == 'DrumGroupDevice':
                self._key_index = 36
                self.scale = CHROMATIC_SCALE
                self.key_offset = 7
                self.loop_up_table = 8
            elif self.device_name == 'Collision':
                self._key_index = 36
                self.scale = CHROMATIC_SCALE
                self.key_offset = 7
                self.loop_up_table = 8
            else:
                self.scale = CHROMATIC_SCALE
                self._key_index = 36
                self.key_offset = 7
                self.loop_up_table = 8
        self.update()
        self.update_notes()
########NEW FILE########
__FILENAME__ = SpecialTransportComponent
#Embedded file name: /Applications/Ableton Live 8.app/Contents/App-Resources/MIDI Remote Scripts/QuNeo/SpecialTransportComponent.py
import Live
from _Framework.TransportComponent import TransportComponent
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import EncoderElement
from _Framework.InputControlElement import InputControlElement
from MIDI_Map import TEMPO_TOP
from MIDI_Map import TEMPO_BOTTOM

class SpecialTransportComponent(TransportComponent):
    """ TransportComponent that only uses certain buttons if a shift button is pressed """

    def __init__(self):
        TransportComponent.__init__(self)
        self._tempo_encoder_control = None
        self._tempo_down_button = None
        self._tempo_up_button = None
        self._tempo_session_value = self.song().tempo

    def disconnect(self):
        TransportComponent.disconnect(self)
        if self._tempo_encoder_control != None:
            self._tempo_encoder_control.remove_value_listener(self._tempo_encoder_value)
            self._tempo_encoder_control = None
        if self._tempo_down_button != None:
            self._tempo_down_button.remove_value_listener(self._tempo_down_value)
            self._tempo_down_button = None
        if self._tempo_up_button != None:
            self._tempo_up_button.remove_value_listener(self._tempo_up_value)
            self._tempo_up_button = None

    def _tempo_encoder_value(self, value):
        if not self._tempo_encoder_control != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            backwards = value >= 64
            step = 0.1
            amount = backwards and value - 128
        else:
            amount = value
        tempo = max(20, min(999, self.song().tempo + amount * step))
        self.song().tempo = tempo

    def _tempo_up_value(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._tempo_up_button != None:
                raise AssertionError
                if self.is_enabled():
                    new_tempo = value != 0 and 1.0
                    real_tempo = new_tempo + self.song().tempo
                    real_tempo = real_tempo < 20.0 and 20.0
                self.update_tempo(real_tempo)
            else:
                None

    def _tempo_down_value(self, value):
        if not value in range(128):
            raise AssertionError
            if not self._tempo_up_button != None:
                raise AssertionError
                if self.is_enabled():
                    new_tempo = value != 0 and -1.0
                    real_tempo = new_tempo + self.song().tempo
                    real_tempo = real_tempo > 200.0 and 200.0
                self.update_tempo(real_tempo)
            else:
                None

    def update_tempo(self, value):
        if value != None:
            new_tempo = value
            self.song().tempo = new_tempo

    def set_tempo_buttons(self, up_button, down_button):
        if not (up_button == None or isinstance(up_button, ButtonElement)):
            raise AssertionError
            if not (down_button == None or isinstance(down_button, ButtonElement)):
                raise AssertionError
                if self._tempo_up_button != None:
                    self._tempo_up_button.remove_value_listener(self._tempo_up_value)
                self._tempo_up_button = up_button
                if self._tempo_up_button != None:
                    self._tempo_up_button.add_value_listener(self._tempo_up_value)
                self._tempo_down_button != None and self._tempo_down_button.remove_value_listener(self._tempo_down_value)
            self._tempo_down_button = down_button
            self._tempo_down_button != None and self._tempo_down_button.add_value_listener(self._tempo_down_value)
        self.update()

    def set_tempo_encoder(self, control):
        if not (control == None or isinstance(control, EncoderElement) and control.message_map_mode() is Live.MidiMap.MapMode.relative_two_compliment):
            raise AssertionError
            if self._tempo_encoder_control != None:
                self._tempo_encoder_control.remove_value_listener(self._tempo_encoder_value)
            self._tempo_encoder_control = control
            self._tempo_encoder_control != None and self._tempo_encoder_control.add_value_listener(self._tempo_encoder_value)
        self.update()

    def _tempo_value(self, value):
        if not self._tempo_control != None:
            raise AssertionError
            raise value in range(128) or AssertionError
            fraction = self.is_enabled() and (TEMPO_TOP - TEMPO_BOTTOM) / 127.0
            self.song().tempo = fraction * value + TEMPO_BOTTOM
########NEW FILE########
__FILENAME__ = VUMeter
#Embedded file name: /Applications/Ableton Live 8.app/Contents/App-Resources/MIDI Remote Scripts/QuNeo/VUMeter.py
import Live
import math
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.SliderElement import SliderElement
from _Framework.InputControlElement import *
from MIDI_Map import *
CHANNEL_SCALE_MAX = 1.0
CHANNEL_SCALE_MIN = 0.5
CHANNEL_SCALE_INCREMENTS = 128
RMS_FRAMES = 10
USE_RMS = False

class VUMeter(ControlSurfaceComponent):
    _active_instances = []

    def __init__(self, parent):
        ControlSurfaceComponent.__init__(self)
        VUMeter._active_instances.append(self)
        self.slider = None
        self._parent = parent
        self._vu_meter = None
        self.frames = [0.0] * RMS_FRAMES
        self.increments = CHANNEL_SCALE_INCREMENTS
        self.top = CHANNEL_SCALE_MAX
        self.bottom = CHANNEL_SCALE_MIN
        self.multiplier = self.calculate_multiplier(self.top, self.bottom, self.increments)
        self.current_level = 0

    def disconnect(self):
        VUMeter._active_instances.remove(self)
        if self._vu_meter != None:
            self._vu_meter.remove_output_meter_left_listener(self.observe)
            self._vu_meter = None

    def observe(self):
        new_frame = self.mean_peak()
        self.store_frame(new_frame)
        self.level = self.scale(new_frame)
        if self.level != self.current_level:
            self.current_level = self.level
            self.send_vu_value(self.level)
        else:
            None

    def store_frame(self, frame):
        self.frames.pop(0)
        self.frames.append(frame)

    def rms(self, frames):
        return math.sqrt(sum((frame * frame for frame in frames)) / len(frames))

    def mean_peak(self):
        return (self._vu_meter.output_meter_left + self._vu_meter.output_meter_right) / 2

    def scale(self, value):
        if value > self.top:
            value = self.top
        elif value < self.bottom:
            value = self.bottom
        value = value - self.bottom
        value = value * self.multiplier
        return int(round(value))

    def calculate_multiplier(self, top, bottom, increments):
        return increments / (top - bottom)

    def set_vu_meter(self, track):
        self.set_led_slider(track)
        self._vu_meter = self.song().tracks[track]
        if self._vu_meter != None:
            self._vu_meter.add_output_meter_left_listener(self.observe)
        else:
            None

    def set_led_slider(self, track):
        self.slider = SliderElement(MIDI_CC_TYPE, SLIDER_CHANNEL, track + 1)

    def send_vu_value(self, level):
        if level != None:
            if level < 1:
                None
            else:
                self.slider.send_value(level, True)
        else:
            None

    def update(self):
        pass
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Radium49_61/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
VOLUME_CONTROLS = GENERIC_SLIDERS
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': -1,
 'PREVBANK': -1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'Keystation',
 'OUTPUTPORT': 'Keystation',
 'CHANNEL': 0}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Radium49_61/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = -1
GENERIC_PLAY = -1
GENERIC_REC = -1
GENERIC_LOOP = -1
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 74
GENERIC_ENC2 = 71
GENERIC_ENC3 = 81
GENERIC_ENC4 = 91
GENERIC_ENC5 = 2
GENERIC_ENC6 = 10
GENERIC_ENC7 = 5
GENERIC_ENC8 = 21
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 82
GENERIC_SLI2 = 83
GENERIC_SLI3 = 28
GENERIC_SLI4 = 29
GENERIC_SLI5 = 16
GENERIC_SLI6 = 80
GENERIC_SLI7 = 18
GENERIC_SLI8 = 19
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/RemoteSL/consts.py
NOTE_OFF_STATUS = 128
NOTE_ON_STATUS = 144
CC_STATUS = 176
NUM_NOTES = 127
NUM_CC_NO = 127
NUM_CHANNELS = 15
NUM_CONTROLS_PER_ROW = 8
SL_MIDI_CHANNEL = 0
CC_VAL_BUTTON_PRESSED = 1
CC_VAL_BUTTON_RELEASED = 0
ABLETON_PID = 4
WELCOME_SYSEX_MESSAGE = (240,
 0,
 32,
 41,
 3,
 3,
 18,
 0,
 ABLETON_PID,
 0,
 1,
 1,
 247)
GOOD_BYE_SYSEX_MESSAGE = (240,
 0,
 32,
 41,
 3,
 3,
 18,
 0,
 ABLETON_PID,
 0,
 1,
 0,
 247)
ALL_LEDS_OFF_MESSAGE = (CC_STATUS + SL_MIDI_CHANNEL, 78, 0)
NUM_CHARS_PER_DISPLAY_STRIP = 9
NUM_CHARS_PER_DISPLAY_LINE = NUM_CHARS_PER_DISPLAY_STRIP * NUM_CONTROLS_PER_ROW

def __create_row_range(cc_base):
    return range(cc_base, cc_base + NUM_CONTROLS_PER_ROW)


FX_DISPLAY_PAGE_UP = 88
FX_DISPLAY_PAGE_DOWN = 89
fx_display_button_ccs = [FX_DISPLAY_PAGE_UP, FX_DISPLAY_PAGE_DOWN]
FX_SELECT_FIRST_BUTTON_ROW = 80
FX_SELECT_ENCODER_ROW = 81
FX_SELECT_SECOND_BUTTON_ROW = 82
FX_SELECT_POTIE_ROW = 83
FX_SELECT_DRUM_PAD_ROW = 84
fx_select_button_ccs = range(FX_SELECT_FIRST_BUTTON_ROW, FX_SELECT_DRUM_PAD_ROW + 1)
FX_RING_VOL_VALUE = 0
FX_RING_PAN_VALUE = 32
FX_RING_SIN_VALUE = 64
FX_UPPER_BUTTON_ROW_BASE_CC = 24
fx_upper_button_row_ccs = __create_row_range(FX_UPPER_BUTTON_ROW_BASE_CC)
FX_ENCODER_ROW_BASE_CC = 56
fx_encoder_row_ccs = __create_row_range(FX_ENCODER_ROW_BASE_CC)
FX_ENCODER_FEEDBACK_BASE_CC = 112
fx_encoder_feedback_ccs = __create_row_range(FX_ENCODER_FEEDBACK_BASE_CC)
FX_ENCODER_LED_MODE_BASE_CC = 120
fx_encoder_led_mode_ccs = __create_row_range(FX_ENCODER_LED_MODE_BASE_CC)
FX_LOWER_BUTTON_ROW_BASE_CC = 32
fx_lower_button_row_ccs = __create_row_range(FX_LOWER_BUTTON_ROW_BASE_CC)
FX_POTI_ROW_BASE_CC = 8
fx_poti_row_ccs = __create_row_range(FX_POTI_ROW_BASE_CC)
FX_DRUM_PAD_ROW_BASE_NOTE = 36
fx_drum_pad_row_notes = __create_row_range(FX_DRUM_PAD_ROW_BASE_NOTE)
fx_ccs = fx_display_button_ccs + fx_select_button_ccs + fx_upper_button_row_ccs + fx_encoder_row_ccs + fx_lower_button_row_ccs + fx_poti_row_ccs
fx_notes = fx_drum_pad_row_notes
fx_forwarded_ccs = fx_display_button_ccs + fx_select_button_ccs + fx_upper_button_row_ccs
fx_forwarded_notes = []
MX_DISPLAY_PAGE_UP = 90
MX_DISPLAY_PAGE_DOWN = 91
mx_display_button_ccs = [MX_DISPLAY_PAGE_UP, MX_DISPLAY_PAGE_DOWN]
MX_SELECT_SLIDER_ROW = 85
MX_SELECT_FIRST_BUTTON_ROW = 86
MX_SELECT_SECOND_BUTTON_ROW = 87
mx_select_button_ccs = range(MX_SELECT_SLIDER_ROW, MX_SELECT_SECOND_BUTTON_ROW + 1)
MX_SLIDER_ROW_BASE_CC = 16
mx_slider_row_ccs = __create_row_range(MX_SLIDER_ROW_BASE_CC)
MX_FIRST_BUTTON_ROW_BASE_CC = 40
mx_first_button_row_ccs = __create_row_range(MX_FIRST_BUTTON_ROW_BASE_CC)
MX_SECOND_BUTTON_ROW_BASE_CC = 48
mx_second_button_row_ccs = __create_row_range(MX_SECOND_BUTTON_ROW_BASE_CC)
TS_REWIND_CC = 72
TS_FORWARD_CC = 73
TS_STOP_CC = 74
TS_PLAY_CC = 75
TS_RECORD_CC = 76
TS_LOOP_CC = 77
TS_LOCK = 79
ts_ccs = [TS_REWIND_CC,
 TS_FORWARD_CC,
 TS_STOP_CC,
 TS_PLAY_CC,
 TS_RECORD_CC,
 TS_LOOP_CC,
 TS_LOCK,
 TS_LOCK + 1]
ts_notes = []
mx_ccs = mx_display_button_ccs + mx_select_button_ccs + mx_first_button_row_ccs + mx_second_button_row_ccs + mx_slider_row_ccs + ts_ccs
mx_notes = []
mx_forwarded_ccs = mx_display_button_ccs + mx_select_button_ccs + mx_first_button_row_ccs + mx_second_button_row_ccs
mx_forwarded_notes = []
PAD_TRANSLATION = ((0, 2, 36, 0),
 (1, 2, 37, 0),
 (2, 2, 38, 0),
 (3, 2, 39, 0),
 (0, 3, 40, 0),
 (1, 3, 41, 0),
 (2, 3, 42, 0),
 (3, 3, 43, 0))
########NEW FILE########
__FILENAME__ = DisplayController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/RemoteSL/DisplayController.py
from RemoteSLComponent import RemoteSLComponent
from consts import *

class DisplayController(RemoteSLComponent):
    """Controls the 4 display rows of the RemoteSL.
    The left and right display can be individually controlled. Both displays will
    show in the upper row a freely defineable string, per strip (the parameter or
    track name). The lower rows will always show parameter values.
    """

    def __init__(self, remote_sl_parent):
        RemoteSLComponent.__init__(self, remote_sl_parent)
        self.__left_strip_names = [ str() for x in range(NUM_CONTROLS_PER_ROW) ]
        self.__left_strip_parameters = [ None for x in range(NUM_CONTROLS_PER_ROW) ]
        self.__right_strip_names = [ str() for x in range(NUM_CONTROLS_PER_ROW) ]
        self.__right_strip_parameters = [ None for x in range(NUM_CONTROLS_PER_ROW) ]
        self.refresh_state()

    def disconnect(self):
        self.__send_clear_displays()

    def setup_left_display(self, names, parameters):
        """Shows the given strings on the upper left row, the parameters values
        in the lower left row.
        
        'names' can be an array of NUM_CONTROLS_PER_ROW strings, or a list with
        exactly one string, which then will fill up the whole display
        """
        raise len(parameters) == NUM_CONTROLS_PER_ROW or AssertionError
        raise len(names) == NUM_CONTROLS_PER_ROW or len(names) == 1 or AssertionError
        self.__left_strip_names = names
        self.__left_strip_parameters = parameters

    def setup_right_display(self, names, parameters):
        """Shows the given strings on the upper right row, the parameters values
        in the lower right row.
        
        'names' can be an array of NUM_CONTROLS_PER_ROW strings, or a list with
        exactly one string, which then will fill up the whole display
        """
        raise len(parameters) == NUM_CONTROLS_PER_ROW or AssertionError
        raise len(names) == NUM_CONTROLS_PER_ROW or len(names) == 1 or AssertionError
        self.__right_strip_names = names
        self.__right_strip_parameters = parameters

    def update_display(self):
        for row_id in (1, 2, 3, 4):
            message_string = ''
            if row_id == 1 or row_id == 2:
                if row_id == 1:
                    strip_names = self.__left_strip_names
                else:
                    strip_names = self.__right_strip_names
                if len(strip_names) == NUM_CONTROLS_PER_ROW:
                    for s in strip_names:
                        message_string += self.__generate_strip_string(s)

                else:
                    raise len(strip_names) == 1 or AssertionError
                    message_string += strip_names[0]
            else:
                if row_id == 3 or row_id == 4:
                    parameters = row_id == 3 and self.__left_strip_parameters
                else:
                    parameters = self.__right_strip_parameters
                if not len(parameters) == NUM_CONTROLS_PER_ROW:
                    raise AssertionError
                    for p in parameters:
                        if p:
                            message_string += self.__generate_strip_string(unicode(p))
                        else:
                            message_string += self.__generate_strip_string('')

                else:
                    raise False or AssertionError
            self.__send_display_string(message_string, row_id, offset=0)

    def refresh_state(self):
        self.__last_send_row_id_messages = [None,
         [],
         [],
         [],
         []]

    def __send_clear_displays(self):
        start_clear_sysex = (240, 0, 32, 41, 3, 3, 18, 0)
        left_end_sysex = (ABLETON_PID,
         0,
         2,
         2,
         4,
         247)
        right_end_sysex = (ABLETON_PID,
         0,
         2,
         2,
         5,
         247)
        self.send_midi(start_clear_sysex + left_end_sysex)
        self.send_midi(start_clear_sysex + right_end_sysex)

    def __send_display_string(self, message, row_id, offset = 0):
        """Sends a sysex to update a complete row.
        
        'message' must be smaller than NUM_CHARS_PER_DISPLAY_LINE,
        'offset' can be something form 0 to NUM_CHARS_PER_DISPLAY_LINE - 1
          (then the text is clipped)
        
        'row_id' is defined as followed: left_row1 = 1 | left_row2 = 2
           left_row1 = 3] | left_row2 = 4
        """
        if not row_id in (1, 2, 3, 4):
            raise AssertionError
            final_message = ' ' * offset + message
            if len(final_message) < NUM_CHARS_PER_DISPLAY_LINE:
                fill_up = NUM_CHARS_PER_DISPLAY_LINE - len(final_message)
                final_message = final_message + ' ' * fill_up
            elif len(final_message) >= NUM_CHARS_PER_DISPLAY_LINE:
                final_message = final_message[0:NUM_CHARS_PER_DISPLAY_LINE]
            final_offset = 0
            sysex_header = (240,
             0,
             32,
             41,
             3,
             3,
             18,
             0,
             ABLETON_PID,
             0,
             2,
             1)
            sysex_pos = (final_offset, row_id)
            sysex_text_command = (4,)
            sysex_text = tuple([ ord(c) for c in final_message ])
            sysex_close_up = (247,)
            full_sysex = sysex_header + sysex_pos + sysex_text_command + sysex_text + sysex_close_up
            self.__last_send_row_id_messages[row_id] = self.__last_send_row_id_messages[row_id] != full_sysex and full_sysex
            self.send_midi(full_sysex)

    def __generate_strip_string(self, display_string):
        """ Hack: Shamelessly stolen from the MainDisplayController of the Mackie Control.
        Should share this in future in a 'Common' package!
        
        returns a 6 char string for of the passed string, trying to remove not so important
        letters and signs first...
        """
        if not display_string:
            return ' ' * NUM_CHARS_PER_DISPLAY_STRIP
        if len(display_string.strip()) > NUM_CHARS_PER_DISPLAY_STRIP - 1 and display_string.endswith('dB') and display_string.find('.') != -1:
            display_string = display_string[:-2]
        if len(display_string) > NUM_CHARS_PER_DISPLAY_STRIP - 1:
            for um in [' ',
             'i',
             'o',
             'u',
             'e',
             'a']:
                while len(display_string) > NUM_CHARS_PER_DISPLAY_STRIP - 1 and display_string.rfind(um, 1) != -1:
                    um_pos = display_string.rfind(um, 1)
                    display_string = display_string[:um_pos] + display_string[um_pos + 1:]

        else:
            display_string = display_string.center(NUM_CHARS_PER_DISPLAY_STRIP - 1)
        ret = u''
        for i in range(NUM_CHARS_PER_DISPLAY_STRIP - 1):
            if ord(display_string[i]) > 127 or ord(display_string[i]) < 0:
                ret += ' '
            else:
                ret += display_string[i]

        ret += ' '
        raise len(ret) == NUM_CHARS_PER_DISPLAY_STRIP or AssertionError
        return ret
########NEW FILE########
__FILENAME__ = EffectController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/RemoteSL/EffectController.py
import Live
from RemoteSLComponent import RemoteSLComponent
from consts import *
from _Generic.Devices import *

class EffectController(RemoteSLComponent):
    """Representing the 'left side' of the RemoteSL:
    The upper two button rows with the encoders, and the row with the poties and drum pads.
    
    Only the First Button row with the Encoders are handled by this script. The rest will
    be forwarded to Live, so that it can be freely mapped with the RemoteMapper.
    
    The encoders and buttons are used to control devices in Live, by attaching to
    the selected one in Live, when the selection is not locked...
    Switching through more than 8 parameters is done by pressing the up/down bottons next
    to the left display. This will then shift the selected parameters by 8.
    """

    def __init__(self, remote_sl_parent, display_controller):
        RemoteSLComponent.__init__(self, remote_sl_parent)
        self.__display_controller = display_controller
        self.__parent = remote_sl_parent
        self.__last_selected_track = None
        self.__assigned_device_is_locked = False
        self.__assigned_device = None
        self.__change_assigned_device(self.__parent.song().appointed_device)
        self.__bank = 0
        self.__show_bank = False
        self.__strips = [ EffectChannelStrip(self) for x in range(NUM_CONTROLS_PER_ROW) ]
        self.__reassign_strips()

    def disconnect(self):
        self.__change_assigned_device(None)

    def receive_midi_cc(self, cc_no, cc_value):
        if cc_no in fx_display_button_ccs:
            self.__handle_page_up_down_ccs(cc_no, cc_value)
        elif cc_no in fx_select_button_ccs:
            self.__handle_select_button_ccs(cc_no, cc_value)
        elif cc_no in fx_upper_button_row_ccs:
            strip = self.__strips[cc_no - FX_UPPER_BUTTON_ROW_BASE_CC]
            if cc_value == CC_VAL_BUTTON_PRESSED:
                strip.on_button_pressed()
        elif cc_no in fx_encoder_row_ccs:
            strip = self.__strips[cc_no - FX_ENCODER_ROW_BASE_CC]
            strip.on_encoder_moved(cc_value)
        elif not (cc_no in fx_lower_button_row_ccs and False):
            raise AssertionError, 'Lower Button CCS should be passed to Live!'
        elif not (cc_no in fx_poti_row_ccs and False):
            raise AssertionError, 'Poti CCS should be passed to Live!'
        else:
            raise False or AssertionError, 'unknown FX midi message'

    def receive_midi_note(self, note, velocity):
        if not (note in fx_drum_pad_row_notes and False):
            raise AssertionError, 'DrumPad CCS should be passed to Live!'
        else:
            raise False or AssertionError, 'unknown FX midi message'

    def build_midi_map(self, script_handle, midi_map_handle):
        needs_takeover = True
        for s in self.__strips:
            strip_index = self.__strips.index(s)
            cc_no = fx_encoder_row_ccs[strip_index]
            if s.assigned_parameter():
                map_mode = Live.MidiMap.MapMode.relative_smooth_signed_bit
                parameter = s.assigned_parameter()
                if self.support_mkII():
                    feedback_rule = Live.MidiMap.CCFeedbackRule()
                    feedback_rule.cc_no = fx_encoder_feedback_ccs[strip_index]
                    feedback_rule.channel = SL_MIDI_CHANNEL
                    feedback_rule.delay_in_ms = 0
                    feedback_rule.cc_value_map = tuple([ int(1.5 + float(index) / 127.0 * 10.0) for index in range(128) ])
                    ring_mode_value = FX_RING_VOL_VALUE
                    if parameter.min == -1 * parameter.max:
                        ring_mode_value = FX_RING_PAN_VALUE
                    elif parameter.is_quantized:
                        ring_mode_value = FX_RING_SIN_VALUE
                    self.send_midi((self.cc_status_byte(), fx_encoder_led_mode_ccs[strip_index], ring_mode_value))
                    Live.MidiMap.map_midi_cc_with_feedback_map(midi_map_handle, parameter, SL_MIDI_CHANNEL, cc_no, map_mode, feedback_rule, not needs_takeover)
                    Live.MidiMap.send_feedback_for_parameter(midi_map_handle, parameter)
                else:
                    Live.MidiMap.map_midi_cc(midi_map_handle, parameter, SL_MIDI_CHANNEL, cc_no, map_mode, not needs_takeover)
            else:
                if self.support_mkII():
                    self.send_midi((self.cc_status_byte(), fx_encoder_led_mode_ccs[strip_index], 0))
                    self.send_midi((self.cc_status_byte(), fx_encoder_feedback_ccs[strip_index], 0))
                Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, SL_MIDI_CHANNEL, cc_no)

        for cc_no in fx_forwarded_ccs:
            Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, SL_MIDI_CHANNEL, cc_no)

        for note in fx_forwarded_notes:
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, SL_MIDI_CHANNEL, note)

    def refresh_state(self):
        self.__update_select_row_leds()
        self.__reassign_strips()

    def __reassign_strips(self):
        page_up_value = CC_VAL_BUTTON_RELEASED
        page_down_value = CC_VAL_BUTTON_RELEASED
        if not self.__assigned_device == None:
            param_index = 0
            param_banks = 0
            chosen_bank = 0
            param_names = []
            parameters = []
            if list(DEVICE_DICT.keys()).count(self.__assigned_device.class_name) > 0:
                param_banks = DEVICE_DICT[self.__assigned_device.class_name]
                chosen_bank = param_banks[self.__bank]
            for s in self.__strips:
                param = None
                name = ''
                if chosen_bank:
                    param = get_parameter_by_name(self.__assigned_device, chosen_bank[param_index])
                else:
                    new_index = param_index + 8 * self.__bank
                    device_parameters = self.__assigned_device.parameters[1:]
                    device_parameters = self.__assigned_device.parameters[1:]
                    if new_index < len(device_parameters):
                        param = device_parameters[new_index]
                if param:
                    name = param.name
                s.set_assigned_parameter(param)
                parameters.append(param)
                param_names.append(name)
                param_index += 1

            if self.__bank > 0:
                page_down_value = CC_VAL_BUTTON_PRESSED
            if self.__bank + 1 < number_of_parameter_banks(self.__assigned_device):
                page_up_value = CC_VAL_BUTTON_PRESSED
            self.__report_bank()
        else:
            for s in self.__strips:
                s.set_assigned_parameter(None)

            param_names = ['Please select a Device in Live to edit it...']
            parameters = [ None for x in range(NUM_CONTROLS_PER_ROW) ]
        self.__display_controller.setup_left_display(param_names, parameters)
        self.request_rebuild_midi_map()
        if self.support_mkII():
            self.send_midi((self.cc_status_byte(), FX_DISPLAY_PAGE_DOWN, page_down_value))
            self.send_midi((self.cc_status_byte(), FX_DISPLAY_PAGE_UP, page_up_value))
            for cc_no in fx_upper_button_row_ccs:
                self.send_midi((self.cc_status_byte(), cc_no, CC_VAL_BUTTON_RELEASED))

    def __handle_page_up_down_ccs(self, cc_no, cc_value):
        new_bank = self.__assigned_device != None and self.__bank
        if cc_value == CC_VAL_BUTTON_PRESSED:
            if cc_no == FX_DISPLAY_PAGE_UP:
                new_bank = min(self.__bank + 1, number_of_parameter_banks(self.__assigned_device) - 1)
            elif cc_no == FX_DISPLAY_PAGE_DOWN:
                new_bank = max(self.__bank - 1, 0)
            else:
                if not False:
                    raise AssertionError, 'unknown Display midi message'
                if not self.__bank == new_bank:
                    self.__show_bank = True
                    if not self.__assigned_device_is_locked:
                        self.__bank = new_bank
                        self.__reassign_strips()
                    else:
                        self.__assigned_device.store_chosen_bank(self.__parent.instance_identifier(), new_bank)

    def __handle_select_button_ccs(self, cc_no, cc_value):
        if cc_no == FX_SELECT_FIRST_BUTTON_ROW:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.__parent.toggle_lock()
        elif cc_no == FX_SELECT_ENCODER_ROW:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                new_index = min(len(self.song().scenes) - 1, max(0, list(self.song().scenes).index(self.song().view.selected_scene) - 1))
                self.song().view.selected_scene = self.song().scenes[new_index]
        elif cc_no == FX_SELECT_SECOND_BUTTON_ROW:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                new_index = min(len(self.song().scenes) - 1, max(0, list(self.song().scenes).index(self.song().view.selected_scene) + 1))
                self.song().view.selected_scene = self.song().scenes[new_index]
        elif cc_no == FX_SELECT_POTIE_ROW:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.song().view.selected_scene.fire_as_selected()
        elif cc_no == FX_SELECT_DRUM_PAD_ROW:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.song().stop_all_clips()
        else:
            raise False or AssertionError, 'unknown select row midi message'

    def __update_select_row_leds(self):
        if self.__assigned_device_is_locked:
            self.send_midi((self.cc_status_byte(), FX_SELECT_FIRST_BUTTON_ROW, CC_VAL_BUTTON_PRESSED))
        else:
            self.send_midi((self.cc_status_byte(), FX_SELECT_FIRST_BUTTON_ROW, CC_VAL_BUTTON_RELEASED))

    def lock_to_device(self, device):
        if device:
            self.__assigned_device_is_locked = True
            self.__change_assigned_device(device)
            self.__update_select_row_leds()
            self.__reassign_strips()

    def unlock_from_device(self, device):
        if device and device == self.__assigned_device:
            self.__assigned_device_is_locked = False
            self.__update_select_row_leds()
            if not self.__parent.song().appointed_device == self.__assigned_device:
                self.__reassign_strips()

    def set_appointed_device(self, device):
        if self.__assigned_device_is_locked:
            self.__assigned_device_is_locked = False
        self.__change_assigned_device(device)
        self.__update_select_row_leds()
        self.__reassign_strips()

    def __report_bank(self):
        if self.__show_bank:
            self.__show_bank = False
            if self.__assigned_device.class_name in DEVICE_DICT.keys():
                if self.__assigned_device.class_name in BANK_NAME_DICT.keys():
                    bank_names = BANK_NAME_DICT[self.__assigned_device.class_name]
                    if bank_names and len(bank_names) > self.__bank:
                        bank_name = bank_names[self.__bank]
                        self.__show_bank_select(bank_name)
                else:
                    self.__show_bank_select('Best of Parameters')
            else:
                self.__show_bank_select('Bank' + str(self.__bank + 1))

    def __show_bank_select(self, bank_name):
        if self.__assigned_device:
            self.__parent.show_message(str(self.__assigned_device.name + ' Bank: ' + bank_name))

    def restore_bank(self, bank):
        if self.__assigned_device_is_locked:
            self.__bank = bank
            self.__reassign_strips()

    def __change_assigned_device(self, device):
        if not device == self.__assigned_device:
            self.__bank = 0
            if not self.__assigned_device == None:
                self.__assigned_device.remove_parameters_listener(self.__parameter_list_of_device_changed)
            self.__show_bank = False
            self.__assigned_device = device
            if not self.__assigned_device == None:
                self.__assigned_device.add_parameters_listener(self.__parameter_list_of_device_changed)

    def __parameter_list_of_device_changed(self):
        self.__reassign_strips()


class EffectChannelStrip():
    """Represents one of the 8 strips in the Effect controls that we use for parameter
    controlling (one button, one encoder)
    """

    def __init__(self, mixer_controller_parent):
        self.__mixer_controller = mixer_controller_parent
        self.__assigned_parameter = None

    def assigned_parameter(self):
        return self.__assigned_parameter

    def set_assigned_parameter(self, parameter):
        self.__assigned_parameter = parameter

    def on_button_pressed(self):
        if self.__assigned_parameter and self.__assigned_parameter.is_enabled:
            if self.__assigned_parameter.is_quantized:
                if self.__assigned_parameter.value + 1 > self.__assigned_parameter.max:
                    self.__assigned_parameter.value = self.__assigned_parameter.min
                else:
                    self.__assigned_parameter.value = self.__assigned_parameter.value + 1
            else:
                self.__assigned_parameter.value = self.__assigned_parameter.default_value

    def on_encoder_moved(self, cc_value):
        raise self.__assigned_parameter == None or AssertionError, 'should only be reached when the encoder was not realtime mapped '
########NEW FILE########
__FILENAME__ = MixerController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/RemoteSL/MixerController.py
import Live
from RemoteSLComponent import RemoteSLComponent
from consts import *
SLIDER_MODE_VOLUME = 0
SLIDER_MODE_PAN = 1
SLIDER_MODE_SEND = 2
FORW_REW_JUMP_BY_AMOUNT = 1

class MixerController(RemoteSLComponent):
    """Represents the 'right side' of the RemoteSL:
    The sliders with the two button rows, and the transport buttons.
    All controls will be handled by this script: The sliders are mapped to volume/pan/sends
    of the underlying tracks, so that 8 tracks can be controlled at once.
    Banks can be switched via the up/down bottons next to the right display.
    """

    def __init__(self, remote_sl_parent, display_controller):
        RemoteSLComponent.__init__(self, remote_sl_parent)
        self.__display_controller = display_controller
        self.__parent = remote_sl_parent
        self.__forward_button_down = False
        self.__rewind_button_down = False
        self.__strip_offset = 0
        self.__slider_mode = SLIDER_MODE_VOLUME
        self.__strips = [ MixerChannelStrip(self, i) for i in range(NUM_CONTROLS_PER_ROW) ]
        self.__assigned_tracks = []
        self.__transport_locked = False
        self.__lock_enquiry_delay = 0
        self.song().add_visible_tracks_listener(self.__on_tracks_added_or_deleted)
        self.song().add_record_mode_listener(self.__on_record_mode_changed)
        self.song().add_is_playing_listener(self.__on_is_playing_changed)
        self.song().add_loop_listener(self.__on_loop_changed)
        self.__reassign_strips()

    def disconnect(self):
        self.song().remove_visible_tracks_listener(self.__on_tracks_added_or_deleted)
        self.song().remove_record_mode_listener(self.__on_record_mode_changed)
        self.song().remove_is_playing_listener(self.__on_is_playing_changed)
        self.song().remove_loop_listener(self.__on_loop_changed)
        for strip in self.__strips:
            strip.set_assigned_track(None)

        for track in self.__assigned_tracks:
            if track and track.name_has_listener(self.__on_track_name_changed):
                track.remove_name_listener(self.__on_track_name_changed)

    def remote_sl_parent(self):
        return self.__parent

    def slider_mode(self):
        return self.__slider_mode

    def receive_midi_cc(self, cc_no, cc_value):
        if cc_no in mx_display_button_ccs:
            self.__handle_page_up_down_ccs(cc_no, cc_value)
        elif cc_no in mx_select_button_ccs:
            self.__handle_select_button_ccs(cc_no, cc_value)
        elif cc_no in mx_first_button_row_ccs:
            channel_strip = self.__strips[cc_no - MX_FIRST_BUTTON_ROW_BASE_CC]
            if cc_value == CC_VAL_BUTTON_PRESSED:
                channel_strip.first_button_pressed()
        elif cc_no in mx_second_button_row_ccs:
            channel_strip = self.__strips[cc_no - MX_SECOND_BUTTON_ROW_BASE_CC]
            if cc_value == CC_VAL_BUTTON_PRESSED:
                channel_strip.second_button_pressed()
        elif cc_no in mx_slider_row_ccs:
            channel_strip = self.__strips[cc_no - MX_SLIDER_ROW_BASE_CC]
            channel_strip.slider_moved(cc_value)
        elif cc_no in ts_ccs:
            self.__handle_transport_ccs(cc_no, cc_value)
        else:
            raise False or AssertionError, 'unknown FX midi message'

    def build_midi_map(self, script_handle, midi_map_handle):
        needs_takeover = True
        for s in self.__strips:
            cc_no = MX_SLIDER_ROW_BASE_CC + self.__strips.index(s)
            if s.assigned_track() and s.slider_parameter():
                map_mode = Live.MidiMap.MapMode.absolute
                parameter = s.slider_parameter()
                Live.MidiMap.map_midi_cc(midi_map_handle, parameter, SL_MIDI_CHANNEL, cc_no, map_mode, not needs_takeover)
            else:
                Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, SL_MIDI_CHANNEL, cc_no)

        for cc_no in mx_forwarded_ccs + ts_ccs:
            Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, SL_MIDI_CHANNEL, cc_no)

        for note in mx_forwarded_notes + ts_notes:
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, SL_MIDI_CHANNEL, note)

    def refresh_state(self):
        self.__update_selected_row_leds()
        self.__reassign_strips()
        self.__lock_enquiry_delay = 3

    def update_display(self):
        if self.__lock_enquiry_delay > 0:
            self.__lock_enquiry_delay -= 1
            if self.__lock_enquiry_delay == 0:
                self.send_midi((176, 103, 1))
        if self.__rewind_button_down:
            self.song().jump_by(-FORW_REW_JUMP_BY_AMOUNT)
        if self.__forward_button_down:
            self.song().jump_by(FORW_REW_JUMP_BY_AMOUNT)

    def __reassign_strips(self):
        track_index = self.__strip_offset
        track_names = []
        parameters = []
        for track in self.__assigned_tracks:
            if track and track.name_has_listener(self.__on_track_name_changed):
                track.remove_name_listener(self.__on_track_name_changed)

        self.__assigned_tracks = []
        all_tracks = tuple(self.song().visible_tracks) + tuple(self.song().return_tracks) + (self.song().master_track,)
        for s in self.__strips:
            if track_index < len(all_tracks):
                track = all_tracks[track_index]
                s.set_assigned_track(track)
                track_names.append(track.name)
                parameters.append(s.slider_parameter())
                track.add_name_listener(self.__on_track_name_changed)
                self.__assigned_tracks.append(track)
            else:
                s.set_assigned_track(None)
                track_names.append('')
                parameters.append(None)
            track_index += 1

        self.__display_controller.setup_right_display(track_names, parameters)
        self.request_rebuild_midi_map()
        if self.support_mkII():
            page_up_value = CC_VAL_BUTTON_RELEASED
            page_down_value = CC_VAL_BUTTON_RELEASED
            if len(all_tracks) > NUM_CONTROLS_PER_ROW and self.__strip_offset < len(all_tracks) - NUM_CONTROLS_PER_ROW:
                page_up_value = CC_VAL_BUTTON_PRESSED
            if self.__strip_offset > 0:
                page_down_value = CC_VAL_BUTTON_PRESSED
            self.send_midi((self.cc_status_byte(), MX_DISPLAY_PAGE_UP, page_up_value))
            self.send_midi((self.cc_status_byte(), MX_DISPLAY_PAGE_DOWN, page_down_value))

    def __handle_page_up_down_ccs(self, cc_no, cc_value):
        all_tracks = tuple(self.song().visible_tracks) + tuple(self.song().return_tracks) + (self.song().master_track,)
        if cc_no == MX_DISPLAY_PAGE_UP:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                if len(all_tracks) > NUM_CONTROLS_PER_ROW and self.__strip_offset < len(all_tracks) - NUM_CONTROLS_PER_ROW:
                    self.__strip_offset += NUM_CONTROLS_PER_ROW
                    self.__validate_strip_offset()
                    self.__reassign_strips()
        elif cc_no == MX_DISPLAY_PAGE_DOWN:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                if len(all_tracks) > NUM_CONTROLS_PER_ROW and self.__strip_offset > 0:
                    self.__strip_offset -= NUM_CONTROLS_PER_ROW
                    self.__validate_strip_offset()
                    self.__reassign_strips()
        else:
            raise False or AssertionError, 'unknown Display midi message'

    def __handle_select_button_ccs(self, cc_no, cc_value):
        if cc_no == MX_SELECT_SLIDER_ROW:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.__set_slider_mode(SLIDER_MODE_VOLUME)
        elif cc_no == MX_SELECT_FIRST_BUTTON_ROW:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.__set_slider_mode(SLIDER_MODE_PAN)
        elif cc_no == MX_SELECT_SECOND_BUTTON_ROW:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.__set_slider_mode(SLIDER_MODE_SEND)
        else:
            raise False or AssertionError, 'unknown select row midi message'

    def __handle_transport_ccs(self, cc_no, cc_value):
        if cc_no == TS_REWIND_CC:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.__rewind_button_down = True
                self.song().jump_by(-FORW_REW_JUMP_BY_AMOUNT)
            else:
                self.__rewind_button_down = False
        elif cc_no == TS_FORWARD_CC:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.__forward_button_down = True
                self.song().jump_by(FORW_REW_JUMP_BY_AMOUNT)
            else:
                self.__forward_button_down = False
        elif cc_no == TS_STOP_CC:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.song().stop_playing()
        elif cc_no == TS_PLAY_CC:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.song().start_playing()
        elif cc_no == TS_LOOP_CC:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.song().loop = not self.song().loop
        elif cc_no == TS_RECORD_CC:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.song().record_mode = not self.song().record_mode
        elif cc_no == TS_LOCK:
            self.__transport_locked = cc_value != CC_VAL_BUTTON_RELEASED
            self.__on_transport_lock_changed()
        else:
            raise False or AssertionError, 'unknown Transport CC ' + str(cc_no)

    def __on_transport_lock_changed(self):
        for strip in self.__strips:
            strip.take_control_of_second_button(not self.__transport_locked)

        if self.__transport_locked:
            self.__on_is_playing_changed()
            self.__on_loop_changed()
            self.__on_record_mode_changed()

    def __on_tracks_added_or_deleted(self):
        self.__validate_strip_offset()
        self.__validate_slider_mode()
        self.__reassign_strips()

    def __on_track_name_changed(self):
        self.__reassign_strips()

    def __validate_strip_offset(self):
        all_tracks = tuple(self.song().visible_tracks) + tuple(self.song().return_tracks) + (self.song().master_track,)
        self.__strip_offset = min(self.__strip_offset, len(all_tracks) - 1)
        self.__strip_offset = max(0, self.__strip_offset)

    def __validate_slider_mode(self):
        if self.__slider_mode - SLIDER_MODE_SEND >= len(self.song().return_tracks):
            self.__slider_mode = SLIDER_MODE_VOLUME

    def __set_slider_mode(self, new_mode):
        if self.__slider_mode >= SLIDER_MODE_SEND and new_mode >= SLIDER_MODE_SEND:
            if self.__slider_mode - SLIDER_MODE_SEND + 1 < len(self.song().return_tracks):
                self.__slider_mode += 1
            else:
                self.__slider_mode = SLIDER_MODE_SEND
            self.__update_selected_row_leds()
            self.__reassign_strips()
        elif self.__slider_mode != new_mode:
            self.__slider_mode = new_mode
            self.__update_selected_row_leds()
            self.__reassign_strips()

    def __update_selected_row_leds(self):
        if self.__slider_mode == SLIDER_MODE_VOLUME:
            self.send_midi((self.cc_status_byte(), MX_SELECT_SLIDER_ROW, CC_VAL_BUTTON_PRESSED))
            self.send_midi((self.cc_status_byte(), MX_SELECT_FIRST_BUTTON_ROW, CC_VAL_BUTTON_RELEASED))
            self.send_midi((self.cc_status_byte(), MX_SELECT_SECOND_BUTTON_ROW, CC_VAL_BUTTON_RELEASED))
        elif self.__slider_mode == SLIDER_MODE_PAN:
            self.send_midi((self.cc_status_byte(), MX_SELECT_SLIDER_ROW, CC_VAL_BUTTON_RELEASED))
            self.send_midi((self.cc_status_byte(), MX_SELECT_FIRST_BUTTON_ROW, CC_VAL_BUTTON_PRESSED))
            self.send_midi((self.cc_status_byte(), MX_SELECT_SECOND_BUTTON_ROW, CC_VAL_BUTTON_RELEASED))
        elif self.__slider_mode >= SLIDER_MODE_SEND:
            self.send_midi((self.cc_status_byte(), MX_SELECT_SLIDER_ROW, CC_VAL_BUTTON_RELEASED))
            self.send_midi((self.cc_status_byte(), MX_SELECT_FIRST_BUTTON_ROW, CC_VAL_BUTTON_RELEASED))
            self.send_midi((self.cc_status_byte(), MX_SELECT_SECOND_BUTTON_ROW, CC_VAL_BUTTON_PRESSED))

    def __on_record_mode_changed(self):
        if self.__transport_locked or not self.support_mkII():
            record_cc = TS_RECORD_CC
            if self.support_mkII():
                record_cc = 53
            record_value = CC_VAL_BUTTON_PRESSED
            if not self.song().record_mode:
                record_value = CC_VAL_BUTTON_RELEASED
            self.send_midi((self.cc_status_byte(), record_cc, record_value))

    def __on_is_playing_changed(self):
        if self.__transport_locked and self.support_mkII():
            if self.song().is_playing:
                self.send_midi((self.cc_status_byte(), 51, CC_VAL_BUTTON_PRESSED))
                self.send_midi((self.cc_status_byte(), 50, CC_VAL_BUTTON_RELEASED))
            else:
                self.send_midi((self.cc_status_byte(), 51, CC_VAL_BUTTON_RELEASED))
                self.send_midi((self.cc_status_byte(), 50, CC_VAL_BUTTON_PRESSED))

    def __on_loop_changed(self):
        if self.__transport_locked and self.support_mkII():
            if self.song().loop:
                self.send_midi((self.cc_status_byte(), 52, CC_VAL_BUTTON_PRESSED))
            else:
                self.send_midi((self.cc_status_byte(), 52, CC_VAL_BUTTON_RELEASED))

    def is_arm_exclusive(self):
        return self.__parent.song().exclusive_arm

    def set_selected_track(self, track):
        if track:
            self.__parent.song().view.selected_track = track

    def track_about_to_arm(self, track):
        if track and self.__parent.song().exclusive_arm:
            for t in self.__parent.song().tracks:
                if t.can_be_armed and t.arm and not t == track:
                    t.arm = False


class MixerChannelStrip():
    """Represents one of the 8 track related strips in the Mixer controls (one slider,
    two buttons)
    """

    def __init__(self, mixer_controller_parent, index):
        self.__mixer_controller = mixer_controller_parent
        self.__index = index
        self.__assigned_track = None
        self.__control_second_button = True

    def song(self):
        return self.__mixer_controller.song()

    def assigned_track(self):
        return self.__assigned_track

    def set_assigned_track(self, track):
        if self.__assigned_track != None:
            if self.__assigned_track != self.song().master_track:
                self.__assigned_track.remove_mute_listener(self._on_mute_changed)
            if self.__assigned_track.can_be_armed:
                self.__assigned_track.remove_arm_listener(self._on_arm_changed)
        self.__assigned_track = track
        if self.__assigned_track != None:
            if self.__assigned_track != self.song().master_track:
                self.__assigned_track.add_mute_listener(self._on_mute_changed)
            if self.__assigned_track.can_be_armed:
                self.__assigned_track.add_arm_listener(self._on_arm_changed)
        self._on_mute_changed()
        self._on_arm_changed()

    def slider_parameter(self):
        slider_mode = self.__mixer_controller.slider_mode()
        if self.__assigned_track:
            if slider_mode == SLIDER_MODE_VOLUME:
                return self.__assigned_track.mixer_device.volume
            elif slider_mode == SLIDER_MODE_PAN:
                return self.__assigned_track.mixer_device.panning
            elif slider_mode >= SLIDER_MODE_SEND:
                send_index = slider_mode - SLIDER_MODE_SEND
                if send_index < len(self.__assigned_track.mixer_device.sends):
                    return self.__assigned_track.mixer_device.sends[send_index]
                else:
                    return None
        else:
            return None

    def slider_moved(self, cc_value):
        raise self.__assigned_track == None or self.slider_parameter() == None or AssertionError, 'should only be reached when the slider was not realtime mapped '

    def take_control_of_second_button(self, take_control):
        if self.__mixer_controller.support_mkII():
            self.__mixer_controller.remote_sl_parent().send_midi((self.__mixer_controller.cc_status_byte(), self.__index + MX_SECOND_BUTTON_ROW_BASE_CC, 0))
        self.__control_second_button = take_control
        self._on_mute_changed()
        self._on_arm_changed()

    def first_button_pressed(self):
        if self.__assigned_track:
            if self.__assigned_track in tuple(self.song().visible_tracks) + tuple(self.song().return_tracks):
                self.__assigned_track.mute = not self.__assigned_track.mute

    def second_button_pressed(self):
        if self.__assigned_track in self.song().visible_tracks:
            if self.__assigned_track.can_be_armed:
                self.__mixer_controller.track_about_to_arm(self.__assigned_track)
                self.__assigned_track.arm = not self.__assigned_track.arm
                if self.__assigned_track.arm:
                    self.__assigned_track.view.select_instrument() and self.__mixer_controller.set_selected_track(self.__assigned_track)

    def _on_mute_changed(self):
        if self.__mixer_controller.support_mkII():
            value = 0
            if self.__assigned_track in tuple(self.song().tracks) + tuple(self.song().return_tracks) and not self.__assigned_track.mute:
                value = 1
            self.__mixer_controller.remote_sl_parent().send_midi((self.__mixer_controller.cc_status_byte(), self.__index + MX_FIRST_BUTTON_ROW_BASE_CC, value))

    def _on_arm_changed(self):
        if self.__control_second_button and self.__mixer_controller.support_mkII():
            value = 0
            if self.__assigned_track and self.__assigned_track in self.song().tracks and self.__assigned_track.can_be_armed and self.__assigned_track.arm:
                value = 1
            self.__mixer_controller.remote_sl_parent().send_midi((self.__mixer_controller.cc_status_byte(), self.__index + MX_SECOND_BUTTON_ROW_BASE_CC, value))
########NEW FILE########
__FILENAME__ = RemoteSL
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/RemoteSL/RemoteSL.py
import Live
import MidiRemoteScript
from EffectController import EffectController
from MixerController import MixerController
from DisplayController import DisplayController
from consts import *

class RemoteSL:
    """ Automap script for the Novation Remote SL.
    TODO: Add some general comments about the mappings, FX, MX left/right side...
    """

    def __init__(self, c_instance):
        self.__c_instance = c_instance
        self.__automap_has_control = False
        self.__display_controller = DisplayController(self)
        self.__effect_controller = EffectController(self, self.__display_controller)
        self.__mixer_controller = MixerController(self, self.__display_controller)
        self.__components = [self.__effect_controller, self.__mixer_controller, self.__display_controller]
        self.__update_hardware_delay = -1

    def disconnect(self):
        """Called right before we get disconnected from Live
        """
        for c in self.__components:
            c.disconnect()

        self.send_midi(ALL_LEDS_OFF_MESSAGE)
        self.send_midi(GOOD_BYE_SYSEX_MESSAGE)

    def application(self):
        """returns a reference to the application that we are running in
        """
        return Live.Application.get_application()

    def song(self):
        """returns a reference to the Live song instance that we do control
        """
        return self.__c_instance.song()

    def suggest_input_port(self):
        """Live -> Script
        Live can ask the script for an input port name to find a suitable one.
        """
        return 'RemoteSL'

    def suggest_output_port(self):
        """Live -> Script
        Live can ask the script for an output port name to find a suitable one.
        """
        return 'RemoteSL'

    def can_lock_to_devices(self):
        """Live -> Script
        Live can ask the script whether it can be locked to devices
        """
        return True

    def lock_to_device(self, device):
        """Live -> Script
        Live can tell the script to lock to a given device
        """
        self.__effect_controller.lock_to_device(device)

    def unlock_from_device(self, device):
        """Live -> Script
        Live can tell the script to unlock from a given device
        """
        self.__effect_controller.unlock_from_device(device)

    def set_appointed_device(self, device):
        """Live -> Script
        Live can tell the script which device to use if it is not locked
        This is a substitute mechanism for the listeners used by older scripts
        """
        self.__effect_controller.set_appointed_device(device)

    def toggle_lock(self):
        """Script -> Live
        Use this function to toggle the script's lock on devices
        """
        self.__c_instance.toggle_lock()

    def suggest_map_mode(self, cc_no, channel):
        """Live -> Script
        Live can ask the script to suggest a map mode for the given CC
        """
        result = Live.MidiMap.MapMode.absolute
        if cc_no in fx_encoder_row_ccs:
            result = Live.MidiMap.MapMode.relative_smooth_signed_bit
        return result

    def restore_bank(self, bank):
        self.__effect_controller.restore_bank(bank)

    def supports_pad_translation(self):
        return True

    def show_message(self, message):
        self.__c_instance.show_message(message)

    def instance_identifier(self):
        return self.__c_instance.instance_identifier()

    def connect_script_instances(self, instanciated_scripts):
        """
        Called by the Application as soon as all scripts are initialized.
        You can connect yourself to other running scripts here, as we do it
        connect the extension modules (MackieControlXTs).
        """
        pass

    def request_rebuild_midi_map(self):
        """When the internal MIDI controller has changed in a way that you need to rebuild
        the MIDI mappings, request a rebuild by calling this function
        This is processed as a request, to be sure that its not too often called, because
        its time-critical.
        """
        self.__c_instance.request_rebuild_midi_map()

    def send_midi(self, midi_event_bytes):
        """Use this function to send MIDI events through Live to the _real_ MIDI devices
        that this script is assigned to.
        """
        if not self.__automap_has_control:
            self.__c_instance.send_midi(midi_event_bytes)

    def refresh_state(self):
        """Send out MIDI to completely update the attached MIDI controller.
        Will be called when requested by the user, after for example having reconnected
        the MIDI cables...
        """
        self.__update_hardware_delay = 5

    def __update_hardware(self):
        self.__automap_has_control = False
        self.send_midi(WELCOME_SYSEX_MESSAGE)
        for c in self.__components:
            c.refresh_state()

    def build_midi_map(self, midi_map_handle):
        """Build DeviceParameter Mappings, that are processed in Audio time, or
        forward MIDI messages explicitly to our receive_midi_functions.
        Which means that when you are not forwarding MIDI, nor mapping parameters, you will
        never get any MIDI messages at all.
        """
        if not self.__automap_has_control:
            for c in self.__components:
                c.build_midi_map(self.__c_instance.handle(), midi_map_handle)

        self.__c_instance.set_pad_translation(PAD_TRANSLATION)

    def update_display(self):
        """Aka on_timer. Called every 100 ms and should be used to update display relevant
        parts of the controller only...
        """
        if self.__update_hardware_delay > 0:
            self.__update_hardware_delay -= 1
            if self.__update_hardware_delay == 0:
                self.__update_hardware()
                self.__update_hardware_delay = -1
        for c in self.__components:
            c.update_display()

    def receive_midi(self, midi_bytes):
        """MIDI messages are only received through this function, when explicitly
        forwarded in 'build_midi_map'.
        """
        if midi_bytes[0] & 240 in (NOTE_ON_STATUS, NOTE_OFF_STATUS):
            channel = midi_bytes[0] & 15
            note = midi_bytes[1]
            velocity = midi_bytes[2]
            if note in fx_notes:
                self.__effect_controller.receive_midi_note(note, velocity)
            elif note in mx_notes:
                self.__mixer_controller.receive_midi_note(note, velocity)
            else:
                print 'unknown MIDI message %s' % str(midi_bytes)
        elif midi_bytes[0] & 240 == CC_STATUS:
            channel = midi_bytes[0] & 15
            cc_no = midi_bytes[1]
            cc_value = midi_bytes[2]
            if cc_no in fx_ccs:
                self.__effect_controller.receive_midi_cc(cc_no, cc_value)
            elif cc_no in mx_ccs:
                self.__mixer_controller.receive_midi_cc(cc_no, cc_value)
            else:
                print 'unknown MIDI message %s' % str(midi_bytes)
        elif midi_bytes[0] == 240:
            if len(midi_bytes) == 13 and midi_bytes[1:4] == (0, 32, 41):
                if midi_bytes[8] == ABLETON_PID and midi_bytes[10] == 1:
                    self.__automap_has_control = midi_bytes[11] == 0
                    support_mkII = midi_bytes[6] * 100 + midi_bytes[7] >= 1800
                    if not self.__automap_has_control:
                        self.send_midi(ALL_LEDS_OFF_MESSAGE)
                    for c in self.__components:
                        c.set_support_mkII(support_mkII)
                        if not self.__automap_has_control:
                            c.refresh_state()

                    self.request_rebuild_midi_map()
        else:
            print 'unknown MIDI message %s' % str(midi_bytes)
########NEW FILE########
__FILENAME__ = RemoteSLComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/RemoteSL/RemoteSLComponent.py
from consts import *

class RemoteSLComponent:
    """Baseclass for a subcomponent of the RemoteSL.
    Just defines some handy shortcuts to the main scripts functions...
    for more details about the methods, see the RemoteSLs doc strings
    """

    def __init__(self, remote_sl_parent):
        self.__parent = remote_sl_parent
        self.__support_mkII = False

    def application(self):
        return self.__parent.application()

    def song(self):
        return self.__parent.song()

    def send_midi(self, midi_event_bytes):
        self.__parent.send_midi(midi_event_bytes)

    def request_rebuild_midi_map(self):
        self.__parent.request_rebuild_midi_map()

    def disconnect(self):
        pass

    def build_midi_map(self, script_handle, midi_map_handle):
        pass

    def refresh_state(self):
        pass

    def update_display(self):
        pass

    def cc_status_byte(self):
        return CC_STATUS + SL_MIDI_CHANNEL

    def support_mkII(self):
        return self.__support_mkII

    def set_support_mkII(self, support_mkII):
        self.__support_mkII = support_mkII
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/RemoteSL_Classic/consts.py
NOTE_OFF_STATUS = 128
NOTE_ON_STATUS = 144
CC_STATUS = 176
NUM_NOTES = 127
NUM_CC_NO = 127
NUM_CHANNELS = 15
NUM_CONTROLS_PER_ROW = 8
SL_MIDI_CHANNEL = 0
CC_VAL_BUTTON_PRESSED = 1
CC_VAL_BUTTON_RELEASED = 0
ABLETON_PID = 4
WELCOME_SYSEX_MESSAGE = (240,
 0,
 32,
 41,
 3,
 3,
 18,
 0,
 ABLETON_PID,
 0,
 1,
 1,
 247)
GOOD_BYE_SYSEX_MESSAGE = (240,
 0,
 32,
 41,
 3,
 3,
 18,
 0,
 ABLETON_PID,
 0,
 1,
 0,
 247)
ALL_LEDS_OFF_MESSAGE = (CC_STATUS + SL_MIDI_CHANNEL, 78, 0)
NUM_CHARS_PER_DISPLAY_STRIP = 9
NUM_CHARS_PER_DISPLAY_LINE = NUM_CHARS_PER_DISPLAY_STRIP * NUM_CONTROLS_PER_ROW

def __create_row_range(cc_base):
    return range(cc_base, cc_base + NUM_CONTROLS_PER_ROW)


FX_DISPLAY_PAGE_UP = 88
FX_DISPLAY_PAGE_DOWN = 89
fx_display_button_ccs = [FX_DISPLAY_PAGE_UP, FX_DISPLAY_PAGE_DOWN]
FX_SELECT_FIRST_BUTTON_ROW = 80
FX_SELECT_ENCODER_ROW = 81
FX_SELECT_SECOND_BUTTON_ROW = 82
FX_SELECT_POTIE_ROW = 83
FX_SELECT_DRUM_PAD_ROW = 84
fx_select_button_ccs = range(FX_SELECT_FIRST_BUTTON_ROW, FX_SELECT_DRUM_PAD_ROW + 1)
FX_RING_VOL_VALUE = 0
FX_RING_PAN_VALUE = 32
FX_RING_SIN_VALUE = 64
FX_UPPER_BUTTON_ROW_BASE_CC = 24
fx_upper_button_row_ccs = __create_row_range(FX_UPPER_BUTTON_ROW_BASE_CC)
FX_ENCODER_ROW_BASE_CC = 56
fx_encoder_row_ccs = __create_row_range(FX_ENCODER_ROW_BASE_CC)
FX_ENCODER_FEEDBACK_BASE_CC = 112
fx_encoder_feedback_ccs = __create_row_range(FX_ENCODER_FEEDBACK_BASE_CC)
FX_ENCODER_LED_MODE_BASE_CC = 120
fx_encoder_led_mode_ccs = __create_row_range(FX_ENCODER_LED_MODE_BASE_CC)
FX_LOWER_BUTTON_ROW_BASE_CC = 32
fx_lower_button_row_ccs = __create_row_range(FX_LOWER_BUTTON_ROW_BASE_CC)
FX_POTI_ROW_BASE_CC = 8
fx_poti_row_ccs = __create_row_range(FX_POTI_ROW_BASE_CC)
FX_DRUM_PAD_ROW_BASE_NOTE = 36
fx_drum_pad_row_notes = __create_row_range(FX_DRUM_PAD_ROW_BASE_NOTE)
fx_ccs = fx_display_button_ccs + fx_select_button_ccs + fx_upper_button_row_ccs + fx_encoder_row_ccs + fx_lower_button_row_ccs + fx_poti_row_ccs
fx_notes = fx_drum_pad_row_notes
fx_forwarded_ccs = fx_display_button_ccs + fx_select_button_ccs + fx_upper_button_row_ccs
fx_forwarded_notes = []
MX_DISPLAY_PAGE_UP = 90
MX_DISPLAY_PAGE_DOWN = 91
mx_display_button_ccs = [MX_DISPLAY_PAGE_UP, MX_DISPLAY_PAGE_DOWN]
MX_SELECT_SLIDER_ROW = 85
MX_SELECT_FIRST_BUTTON_ROW = 86
MX_SELECT_SECOND_BUTTON_ROW = 87
mx_select_button_ccs = range(MX_SELECT_SLIDER_ROW, MX_SELECT_SECOND_BUTTON_ROW + 1)
MX_SLIDER_ROW_BASE_CC = 16
mx_slider_row_ccs = __create_row_range(MX_SLIDER_ROW_BASE_CC)
MX_FIRST_BUTTON_ROW_BASE_CC = 40
mx_first_button_row_ccs = __create_row_range(MX_FIRST_BUTTON_ROW_BASE_CC)
MX_SECOND_BUTTON_ROW_BASE_CC = 48
mx_second_button_row_ccs = __create_row_range(MX_SECOND_BUTTON_ROW_BASE_CC)
TS_REWIND_CC = 72
TS_FORWARD_CC = 73
TS_STOP_CC = 74
TS_PLAY_CC = 75
TS_RECORD_CC = 76
TS_LOOP_CC = 77
TS_LOCK = 79
ts_ccs = [TS_REWIND_CC,
 TS_FORWARD_CC,
 TS_STOP_CC,
 TS_PLAY_CC,
 TS_RECORD_CC,
 TS_LOOP_CC,
 TS_LOCK,
 TS_LOCK + 1]
ts_notes = []
mx_ccs = mx_display_button_ccs + mx_select_button_ccs + mx_first_button_row_ccs + mx_second_button_row_ccs + mx_slider_row_ccs + ts_ccs
mx_notes = []
mx_forwarded_ccs = mx_display_button_ccs + mx_select_button_ccs + mx_first_button_row_ccs + mx_second_button_row_ccs
mx_forwarded_notes = []
PAD_TRANSLATION = ((0, 2, 36, 0),
 (1, 2, 37, 0),
 (2, 2, 38, 0),
 (3, 2, 39, 0),
 (0, 3, 40, 0),
 (1, 3, 41, 0),
 (2, 3, 42, 0),
 (3, 3, 43, 0))
########NEW FILE########
__FILENAME__ = DisplayController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/RemoteSL_Classic/DisplayController.py
from RemoteSLComponent import RemoteSLComponent
from consts import *

class DisplayController(RemoteSLComponent):
    """Controls the 4 display rows of the RemoteSL.
    The left and right display can be individually controlled. Both displays will
    show in the upper row a freely defineable string, per strip (the parameter or
    track name). The lower rows will always show parameter values.
    """

    def __init__(self, remote_sl_parent):
        RemoteSLComponent.__init__(self, remote_sl_parent)
        self.__left_strip_names = [ str() for x in range(NUM_CONTROLS_PER_ROW) ]
        self.__left_strip_parameters = [ None for x in range(NUM_CONTROLS_PER_ROW) ]
        self.__right_strip_names = [ str() for x in range(NUM_CONTROLS_PER_ROW) ]
        self.__right_strip_parameters = [ None for x in range(NUM_CONTROLS_PER_ROW) ]
        self.refresh_state()

    def disconnect(self):
        self.__send_clear_displays()

    def setup_left_display(self, names, parameters):
        """Shows the given strings on the upper left row, the parameters values
        in the lower left row.
        
        'names' can be an array of NUM_CONTROLS_PER_ROW strings, or a list with
        exactly one string, which then will fill up the whole display
        """
        raise len(parameters) == NUM_CONTROLS_PER_ROW or AssertionError
        raise len(names) == NUM_CONTROLS_PER_ROW or len(names) == 1 or AssertionError
        self.__left_strip_names = names
        self.__left_strip_parameters = parameters

    def setup_right_display(self, names, parameters):
        """Shows the given strings on the upper right row, the parameters values
        in the lower right row.
        
        'names' can be an array of NUM_CONTROLS_PER_ROW strings, or a list with
        exactly one string, which then will fill up the whole display
        """
        raise len(parameters) == NUM_CONTROLS_PER_ROW or AssertionError
        raise len(names) == NUM_CONTROLS_PER_ROW or len(names) == 1 or AssertionError
        self.__right_strip_names = names
        self.__right_strip_parameters = parameters

    def update_display(self):
        for row_id in (1, 2, 3, 4):
            message_string = ''
            if row_id == 1 or row_id == 2:
                if row_id == 1:
                    strip_names = self.__left_strip_names
                else:
                    strip_names = self.__right_strip_names
                if len(strip_names) == NUM_CONTROLS_PER_ROW:
                    for s in strip_names:
                        message_string += self.__generate_strip_string(s)

                else:
                    raise len(strip_names) == 1 or AssertionError
                    message_string += strip_names[0]
            else:
                if row_id == 3 or row_id == 4:
                    parameters = row_id == 3 and self.__left_strip_parameters
                else:
                    parameters = self.__right_strip_parameters
                if not len(parameters) == NUM_CONTROLS_PER_ROW:
                    raise AssertionError
                    for p in parameters:
                        if p:
                            message_string += self.__generate_strip_string(unicode(p))
                        else:
                            message_string += self.__generate_strip_string('')

                else:
                    raise False or AssertionError
            self.__send_display_string(message_string, row_id, offset=0)

    def refresh_state(self):
        self.__last_send_row_id_messages = [None,
         [],
         [],
         [],
         []]

    def __send_clear_displays(self):
        start_clear_sysex = (240, 0, 32, 41, 3, 3, 18, 0)
        left_end_sysex = (ABLETON_PID,
         0,
         2,
         2,
         4,
         247)
        right_end_sysex = (ABLETON_PID,
         0,
         2,
         2,
         5,
         247)
        self.send_midi(start_clear_sysex + left_end_sysex)
        self.send_midi(start_clear_sysex + right_end_sysex)

    def __send_display_string(self, message, row_id, offset = 0):
        """Sends a sysex to update a complete row.
        
        'message' must be smaller than NUM_CHARS_PER_DISPLAY_LINE,
        'offset' can be something form 0 to NUM_CHARS_PER_DISPLAY_LINE - 1
          (then the text is clipped)
        
        'row_id' is defined as followed: left_row1 = 1 | left_row2 = 2
           left_row1 = 3] | left_row2 = 4
        """
        if not row_id in (1, 2, 3, 4):
            raise AssertionError
            final_message = ' ' * offset + message
            if len(final_message) < NUM_CHARS_PER_DISPLAY_LINE:
                fill_up = NUM_CHARS_PER_DISPLAY_LINE - len(final_message)
                final_message = final_message + ' ' * fill_up
            elif len(final_message) >= NUM_CHARS_PER_DISPLAY_LINE:
                final_message = final_message[0:NUM_CHARS_PER_DISPLAY_LINE]
            final_offset = 0
            sysex_header = (240,
             0,
             32,
             41,
             3,
             3,
             18,
             0,
             ABLETON_PID,
             0,
             2,
             1)
            sysex_pos = (final_offset, row_id)
            sysex_text_command = (4,)
            sysex_text = tuple([ ord(c) for c in final_message ])
            sysex_close_up = (247,)
            full_sysex = sysex_header + sysex_pos + sysex_text_command + sysex_text + sysex_close_up
            self.__last_send_row_id_messages[row_id] = self.__last_send_row_id_messages[row_id] != full_sysex and full_sysex
            self.send_midi(full_sysex)

    def __generate_strip_string(self, display_string):
        """ Hack: Shamelessly stolen from the MainDisplayController of the Mackie Control.
        Should share this in future in a 'Common' package!
        
        returns a 6 char string for of the passed string, trying to remove not so important
        letters and signs first...
        """
        if not display_string:
            return ' ' * NUM_CHARS_PER_DISPLAY_STRIP
        if len(display_string.strip()) > NUM_CHARS_PER_DISPLAY_STRIP - 1 and display_string.endswith('dB') and display_string.find('.') != -1:
            display_string = display_string[:-2]
        if len(display_string) > NUM_CHARS_PER_DISPLAY_STRIP - 1:
            for um in [' ',
             'i',
             'o',
             'u',
             'e',
             'a']:
                while len(display_string) > NUM_CHARS_PER_DISPLAY_STRIP - 1 and display_string.rfind(um, 1) != -1:
                    um_pos = display_string.rfind(um, 1)
                    display_string = display_string[:um_pos] + display_string[um_pos + 1:]

        else:
            display_string = display_string.center(NUM_CHARS_PER_DISPLAY_STRIP - 1)
        ret = u''
        for i in range(NUM_CHARS_PER_DISPLAY_STRIP - 1):
            if ord(display_string[i]) > 127 or ord(display_string[i]) < 0:
                ret += ' '
            else:
                ret += display_string[i]

        ret += ' '
        raise len(ret) == NUM_CHARS_PER_DISPLAY_STRIP or AssertionError
        return ret
########NEW FILE########
__FILENAME__ = EffectController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/RemoteSL_Classic/EffectController.py
import Live
from RemoteSLComponent import RemoteSLComponent
from consts import *

class EffectController(RemoteSLComponent):
    """Representing the 'left side' of the RemoteSL:
    The upper two button rows with the encoders, and the row with the poties and drum pads.
    
    Only the First Button row with the Encoders are handled by this script. The rest will
    be forwarded to Live, so that it can be freely mapped with the RemoteMapper.
    
    The encoders and buttons are used to control devices in Live, by attaching to
    the selected one in Live, when the selection is not locked...
    Switching through more than 8 parameters is done by pressing the up/down bottons next
    to the left display. This will then shift the selected parameters by 8.
    """

    def __init__(self, remote_sl_parent, display_controller):
        RemoteSLComponent.__init__(self, remote_sl_parent)
        self.__display_controller = display_controller
        self.__parent = remote_sl_parent
        self.__last_selected_track = None
        self.__assigned_device_is_locked = False
        self.__assigned_device = None
        self.__change_assigned_device(self.__parent.song().appointed_device)
        self.__bank = 0
        self.__show_bank = False
        self.__strips = [ EffectChannelStrip(self) for x in range(NUM_CONTROLS_PER_ROW) ]
        self.__reassign_strips()

    def disconnect(self):
        self.__change_assigned_device(None)

    def receive_midi_cc(self, cc_no, cc_value):
        if cc_no in fx_display_button_ccs:
            self.__handle_page_up_down_ccs(cc_no, cc_value)
        elif cc_no in fx_select_button_ccs:
            self.__handle_select_button_ccs(cc_no, cc_value)
        elif cc_no in fx_upper_button_row_ccs:
            strip = self.__strips[cc_no - FX_UPPER_BUTTON_ROW_BASE_CC]
            if cc_value == CC_VAL_BUTTON_PRESSED:
                strip.on_button_pressed()
        elif cc_no in fx_encoder_row_ccs:
            strip = self.__strips[cc_no - FX_ENCODER_ROW_BASE_CC]
            strip.on_encoder_moved(cc_value)
        elif not (cc_no in fx_lower_button_row_ccs and False):
            raise AssertionError, 'Lower Button CCS should be passed to Live!'
        elif not (cc_no in fx_poti_row_ccs and False):
            raise AssertionError, 'Poti CCS should be passed to Live!'
        else:
            raise False or AssertionError, 'unknown FX midi message'

    def receive_midi_note(self, note, velocity):
        if not (note in fx_drum_pad_row_notes and False):
            raise AssertionError, 'DrumPad CCS should be passed to Live!'
        else:
            raise False or AssertionError, 'unknown FX midi message'

    def build_midi_map(self, script_handle, midi_map_handle):
        needs_takeover = True
        for s in self.__strips:
            strip_index = self.__strips.index(s)
            cc_no = fx_encoder_row_ccs[strip_index]
            if s.assigned_parameter():
                map_mode = Live.MidiMap.MapMode.relative_smooth_signed_bit
                parameter = s.assigned_parameter()
                if self.support_mkII():
                    feedback_rule = Live.MidiMap.CCFeedbackRule()
                    feedback_rule.cc_no = fx_encoder_feedback_ccs[strip_index]
                    feedback_rule.channel = SL_MIDI_CHANNEL
                    feedback_rule.delay_in_ms = 0
                    feedback_rule.cc_value_map = tuple([ int(1.5 + float(index) / 127.0 * 10.0) for index in range(128) ])
                    ring_mode_value = FX_RING_VOL_VALUE
                    if parameter.min == -1 * parameter.max:
                        ring_mode_value = FX_RING_PAN_VALUE
                    elif parameter.is_quantized:
                        ring_mode_value = FX_RING_SIN_VALUE
                    self.send_midi((self.cc_status_byte(), fx_encoder_led_mode_ccs[strip_index], ring_mode_value))
                    Live.MidiMap.map_midi_cc_with_feedback_map(midi_map_handle, parameter, SL_MIDI_CHANNEL, cc_no, map_mode, feedback_rule, not needs_takeover)
                    Live.MidiMap.send_feedback_for_parameter(midi_map_handle, parameter)
                else:
                    Live.MidiMap.map_midi_cc(midi_map_handle, parameter, SL_MIDI_CHANNEL, cc_no, map_mode, not needs_takeover)
            else:
                if self.support_mkII():
                    self.send_midi((self.cc_status_byte(), fx_encoder_led_mode_ccs[strip_index], 0))
                    self.send_midi((self.cc_status_byte(), fx_encoder_feedback_ccs[strip_index], 0))
                Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, SL_MIDI_CHANNEL, cc_no)

        for cc_no in fx_forwarded_ccs:
            Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, SL_MIDI_CHANNEL, cc_no)

        for note in fx_forwarded_notes:
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, SL_MIDI_CHANNEL, note)

    def refresh_state(self):
        self.__update_select_row_leds()
        self.__reassign_strips()

    def __reassign_strips(self):
        page_up_value = CC_VAL_BUTTON_RELEASED
        page_down_value = CC_VAL_BUTTON_RELEASED
        if not self.__assigned_device == None:
            param_index = 0
            param_names = []
            parameters = []
            for s in self.__strips:
                param = None
                name = ''
                new_index = param_index + self.__bank * 8
                device_parameters = self.__assigned_device.parameters[1:]
                if new_index < len(device_parameters):
                    param = device_parameters[new_index]
                if param:
                    name = param.name
                s.set_assigned_parameter(param)
                parameters.append(param)
                param_names.append(name)
                param_index += 1

            if self.__bank > 0:
                page_down_value = CC_VAL_BUTTON_PRESSED
            if self.__bank + 1 < self.__number_of_parameter_banks():
                page_up_value = CC_VAL_BUTTON_PRESSED
            self.__report_bank()
        else:
            for s in self.__strips:
                s.set_assigned_parameter(None)

            param_names = ['Please select a Device in Live to edit it...']
            parameters = [ None for x in range(NUM_CONTROLS_PER_ROW) ]
        self.__display_controller.setup_left_display(param_names, parameters)
        self.request_rebuild_midi_map()
        if self.support_mkII():
            self.send_midi((self.cc_status_byte(), FX_DISPLAY_PAGE_DOWN, page_down_value))
            self.send_midi((self.cc_status_byte(), FX_DISPLAY_PAGE_UP, page_up_value))
            for cc_no in fx_upper_button_row_ccs:
                self.send_midi((self.cc_status_byte(), cc_no, CC_VAL_BUTTON_RELEASED))

    def __handle_page_up_down_ccs(self, cc_no, cc_value):
        new_bank = self.__assigned_device != None and self.__bank
        if cc_value == CC_VAL_BUTTON_PRESSED:
            if cc_no == FX_DISPLAY_PAGE_UP:
                new_bank = min(self.__bank + 1, self.__number_of_parameter_banks() - 1)
            elif cc_no == FX_DISPLAY_PAGE_DOWN:
                new_bank = max(self.__bank - 1, 0)
            else:
                if not False:
                    raise AssertionError, 'unknown Display midi message'
                if not self.__bank == new_bank:
                    self.__show_bank = True
                    if not self.__assigned_device_is_locked:
                        self.__bank = new_bank
                        self.__reassign_strips()
                    else:
                        self.__assigned_device.store_chosen_bank(self.__parent.instance_identifier(), new_bank)

    def __handle_select_button_ccs(self, cc_no, cc_value):
        if cc_no == FX_SELECT_FIRST_BUTTON_ROW:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.__parent.toggle_lock()
        elif cc_no == FX_SELECT_ENCODER_ROW:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                new_index = min(len(self.song().scenes) - 1, max(0, list(self.song().scenes).index(self.song().view.selected_scene) - 1))
                self.song().view.selected_scene = self.song().scenes[new_index]
        elif cc_no == FX_SELECT_SECOND_BUTTON_ROW:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                new_index = min(len(self.song().scenes) - 1, max(0, list(self.song().scenes).index(self.song().view.selected_scene) + 1))
                self.song().view.selected_scene = self.song().scenes[new_index]
        elif cc_no == FX_SELECT_POTIE_ROW:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.song().view.selected_scene.fire_as_selected()
        elif cc_no == FX_SELECT_DRUM_PAD_ROW:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.song().stop_all_clips()
        else:
            raise False or AssertionError, 'unknown select row midi message'

    def __update_select_row_leds(self):
        if self.__assigned_device_is_locked:
            self.send_midi((self.cc_status_byte(), FX_SELECT_FIRST_BUTTON_ROW, CC_VAL_BUTTON_PRESSED))
        else:
            self.send_midi((self.cc_status_byte(), FX_SELECT_FIRST_BUTTON_ROW, CC_VAL_BUTTON_RELEASED))

    def lock_to_device(self, device):
        if device:
            self.__assigned_device_is_locked = True
            self.__change_assigned_device(device)
            self.__update_select_row_leds()
            self.__reassign_strips()

    def unlock_from_device(self, device):
        if device and device == self.__assigned_device:
            self.__assigned_device_is_locked = False
            self.__update_select_row_leds()
            if not self.__parent.song().appointed_device == self.__assigned_device:
                self.__reassign_strips()

    def set_appointed_device(self, device):
        if self.__assigned_device_is_locked:
            self.__assigned_device_is_locked = False
        self.__change_assigned_device(device)
        self.__update_select_row_leds()
        self.__reassign_strips()

    def __report_bank(self):
        if self.__show_bank:
            self.__show_bank = False
            self.__show_bank_select('Bank' + str(self.__bank + 1))

    def __show_bank_select(self, bank_name):
        if self.__assigned_device:
            self.__parent.show_message(str(self.__assigned_device.name + ' Bank: ' + bank_name))

    def restore_bank(self, bank):
        if self.__assigned_device_is_locked:
            self.__bank = bank
            self.__reassign_strips()

    def __change_assigned_device(self, device):
        if not device == self.__assigned_device:
            self.__bank = 0
            if not self.__assigned_device == None:
                self.__assigned_device.remove_parameters_listener(self.__parameter_list_of_device_changed)
            self.__show_bank = False
            self.__assigned_device = device
            if not self.__assigned_device == None:
                self.__assigned_device.add_parameters_listener(self.__parameter_list_of_device_changed)

    def __parameter_list_of_device_changed(self):
        self.__reassign_strips()

    def __number_of_parameter_banks(self):
        result = 0
        if self.__assigned_device != None:
            param_count = len(self.__assigned_device.parameters)
            result = int(param_count / 8) + int(param_count % 8 != 0)
        return result


class EffectChannelStrip():
    """Represents one of the 8 strips in the Effect controls that we use for parameter
    controlling (one button, one encoder)
    """

    def __init__(self, mixer_controller_parent):
        self.__mixer_controller = mixer_controller_parent
        self.__assigned_parameter = None

    def assigned_parameter(self):
        return self.__assigned_parameter

    def set_assigned_parameter(self, parameter):
        self.__assigned_parameter = parameter

    def on_button_pressed(self):
        if self.__assigned_parameter and self.__assigned_parameter.is_enabled:
            if self.__assigned_parameter.is_quantized:
                if self.__assigned_parameter.value + 1 > self.__assigned_parameter.max:
                    self.__assigned_parameter.value = self.__assigned_parameter.min
                else:
                    self.__assigned_parameter.value = self.__assigned_parameter.value + 1
            else:
                self.__assigned_parameter.value = self.__assigned_parameter.default_value

    def on_encoder_moved(self, cc_value):
        raise self.__assigned_parameter == None or AssertionError, 'should only be reached when the encoder was not realtime mapped '
########NEW FILE########
__FILENAME__ = MixerController
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/RemoteSL_Classic/MixerController.py
import Live
from RemoteSLComponent import RemoteSLComponent
from consts import *
SLIDER_MODE_VOLUME = 0
SLIDER_MODE_PAN = 1
SLIDER_MODE_SEND = 2
FORW_REW_JUMP_BY_AMOUNT = 1

class MixerController(RemoteSLComponent):
    """Represents the 'right side' of the RemoteSL:
    The sliders with the two button rows, and the transport buttons.
    All controls will be handled by this script: The sliders are mapped to volume/pan/sends
    of the underlying tracks, so that 8 tracks can be controlled at once.
    Banks can be switched via the up/down bottons next to the right display.
    """

    def __init__(self, remote_sl_parent, display_controller):
        RemoteSLComponent.__init__(self, remote_sl_parent)
        self.__display_controller = display_controller
        self.__parent = remote_sl_parent
        self.__forward_button_down = False
        self.__rewind_button_down = False
        self.__strip_offset = 0
        self.__slider_mode = SLIDER_MODE_VOLUME
        self.__strips = [ MixerChannelStrip(self, i) for i in range(NUM_CONTROLS_PER_ROW) ]
        self.__assigned_tracks = []
        self.__transport_locked = False
        self.__lock_enquiry_delay = 0
        self.song().add_visible_tracks_listener(self.__on_tracks_added_or_deleted)
        self.song().add_record_mode_listener(self.__on_record_mode_changed)
        self.song().add_is_playing_listener(self.__on_is_playing_changed)
        self.song().add_loop_listener(self.__on_loop_changed)
        self.__reassign_strips()

    def disconnect(self):
        self.song().remove_visible_tracks_listener(self.__on_tracks_added_or_deleted)
        self.song().remove_record_mode_listener(self.__on_record_mode_changed)
        self.song().remove_is_playing_listener(self.__on_is_playing_changed)
        self.song().remove_loop_listener(self.__on_loop_changed)
        for strip in self.__strips:
            strip.set_assigned_track(None)

        for track in self.__assigned_tracks:
            if track and track.name_has_listener(self.__on_track_name_changed):
                track.remove_name_listener(self.__on_track_name_changed)

    def remote_sl_parent(self):
        return self.__parent

    def slider_mode(self):
        return self.__slider_mode

    def receive_midi_cc(self, cc_no, cc_value):
        if cc_no in mx_display_button_ccs:
            self.__handle_page_up_down_ccs(cc_no, cc_value)
        elif cc_no in mx_select_button_ccs:
            self.__handle_select_button_ccs(cc_no, cc_value)
        elif cc_no in mx_first_button_row_ccs:
            channel_strip = self.__strips[cc_no - MX_FIRST_BUTTON_ROW_BASE_CC]
            if cc_value == CC_VAL_BUTTON_PRESSED:
                channel_strip.first_button_pressed()
        elif cc_no in mx_second_button_row_ccs:
            channel_strip = self.__strips[cc_no - MX_SECOND_BUTTON_ROW_BASE_CC]
            if cc_value == CC_VAL_BUTTON_PRESSED:
                channel_strip.second_button_pressed()
        elif cc_no in mx_slider_row_ccs:
            channel_strip = self.__strips[cc_no - MX_SLIDER_ROW_BASE_CC]
            channel_strip.slider_moved(cc_value)
        elif cc_no in ts_ccs:
            self.__handle_transport_ccs(cc_no, cc_value)
        else:
            raise False or AssertionError, 'unknown FX midi message'

    def build_midi_map(self, script_handle, midi_map_handle):
        needs_takeover = True
        for s in self.__strips:
            cc_no = MX_SLIDER_ROW_BASE_CC + self.__strips.index(s)
            if s.assigned_track() and s.slider_parameter():
                map_mode = Live.MidiMap.MapMode.absolute
                parameter = s.slider_parameter()
                Live.MidiMap.map_midi_cc(midi_map_handle, parameter, SL_MIDI_CHANNEL, cc_no, map_mode, not needs_takeover)
            else:
                Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, SL_MIDI_CHANNEL, cc_no)

        for cc_no in mx_forwarded_ccs + ts_ccs:
            Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, SL_MIDI_CHANNEL, cc_no)

        for note in mx_forwarded_notes + ts_notes:
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, SL_MIDI_CHANNEL, note)

    def refresh_state(self):
        self.__update_selected_row_leds()
        self.__reassign_strips()
        self.__lock_enquiry_delay = 3

    def update_display(self):
        if self.__lock_enquiry_delay > 0:
            self.__lock_enquiry_delay -= 1
            if self.__lock_enquiry_delay == 0:
                self.send_midi((176, 103, 1))
        if self.__rewind_button_down:
            self.song().jump_by(-FORW_REW_JUMP_BY_AMOUNT)
        if self.__forward_button_down:
            self.song().jump_by(FORW_REW_JUMP_BY_AMOUNT)

    def __reassign_strips(self):
        track_index = self.__strip_offset
        track_names = []
        parameters = []
        for track in self.__assigned_tracks:
            if track and track.name_has_listener(self.__on_track_name_changed):
                track.remove_name_listener(self.__on_track_name_changed)

        self.__assigned_tracks = []
        all_tracks = tuple(self.song().visible_tracks) + tuple(self.song().return_tracks) + (self.song().master_track,)
        for s in self.__strips:
            if track_index < len(all_tracks):
                track = all_tracks[track_index]
                s.set_assigned_track(track)
                track_names.append(track.name)
                parameters.append(s.slider_parameter())
                track.add_name_listener(self.__on_track_name_changed)
                self.__assigned_tracks.append(track)
            else:
                s.set_assigned_track(None)
                track_names.append('')
                parameters.append(None)
            track_index += 1

        self.__display_controller.setup_right_display(track_names, parameters)
        self.request_rebuild_midi_map()
        if self.support_mkII():
            page_up_value = CC_VAL_BUTTON_RELEASED
            page_down_value = CC_VAL_BUTTON_RELEASED
            if len(all_tracks) > NUM_CONTROLS_PER_ROW and self.__strip_offset < len(all_tracks) - NUM_CONTROLS_PER_ROW:
                page_up_value = CC_VAL_BUTTON_PRESSED
            if self.__strip_offset > 0:
                page_down_value = CC_VAL_BUTTON_PRESSED
            self.send_midi((self.cc_status_byte(), MX_DISPLAY_PAGE_UP, page_up_value))
            self.send_midi((self.cc_status_byte(), MX_DISPLAY_PAGE_DOWN, page_down_value))

    def __handle_page_up_down_ccs(self, cc_no, cc_value):
        all_tracks = tuple(self.song().visible_tracks) + tuple(self.song().return_tracks) + (self.song().master_track,)
        if cc_no == MX_DISPLAY_PAGE_UP:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                if len(all_tracks) > NUM_CONTROLS_PER_ROW and self.__strip_offset < len(all_tracks) - NUM_CONTROLS_PER_ROW:
                    self.__strip_offset += NUM_CONTROLS_PER_ROW
                    self.__validate_strip_offset()
                    self.__reassign_strips()
        elif cc_no == MX_DISPLAY_PAGE_DOWN:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                if len(all_tracks) > NUM_CONTROLS_PER_ROW and self.__strip_offset > 0:
                    self.__strip_offset -= NUM_CONTROLS_PER_ROW
                    self.__validate_strip_offset()
                    self.__reassign_strips()
        else:
            raise False or AssertionError, 'unknown Display midi message'

    def __handle_select_button_ccs(self, cc_no, cc_value):
        if cc_no == MX_SELECT_SLIDER_ROW:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.__set_slider_mode(SLIDER_MODE_VOLUME)
        elif cc_no == MX_SELECT_FIRST_BUTTON_ROW:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.__set_slider_mode(SLIDER_MODE_PAN)
        elif cc_no == MX_SELECT_SECOND_BUTTON_ROW:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.__set_slider_mode(SLIDER_MODE_SEND)
        else:
            raise False or AssertionError, 'unknown select row midi message'

    def __handle_transport_ccs(self, cc_no, cc_value):
        if cc_no == TS_REWIND_CC:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.__rewind_button_down = True
                self.song().jump_by(-FORW_REW_JUMP_BY_AMOUNT)
            else:
                self.__rewind_button_down = False
        elif cc_no == TS_FORWARD_CC:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.__forward_button_down = True
                self.song().jump_by(FORW_REW_JUMP_BY_AMOUNT)
            else:
                self.__forward_button_down = False
        elif cc_no == TS_STOP_CC:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.song().stop_playing()
        elif cc_no == TS_PLAY_CC:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.song().start_playing()
        elif cc_no == TS_LOOP_CC:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.song().loop = not self.song().loop
        elif cc_no == TS_RECORD_CC:
            if cc_value == CC_VAL_BUTTON_PRESSED:
                self.song().record_mode = not self.song().record_mode
        elif cc_no == TS_LOCK:
            self.__transport_locked = cc_value != CC_VAL_BUTTON_RELEASED
            self.__on_transport_lock_changed()
        else:
            raise False or AssertionError, 'unknown Transport CC ' + str(cc_no)

    def __on_transport_lock_changed(self):
        for strip in self.__strips:
            strip.take_control_of_second_button(not self.__transport_locked)

        if self.__transport_locked:
            self.__on_is_playing_changed()
            self.__on_loop_changed()
            self.__on_record_mode_changed()

    def __on_tracks_added_or_deleted(self):
        self.__validate_strip_offset()
        self.__validate_slider_mode()
        self.__reassign_strips()

    def __on_track_name_changed(self):
        self.__reassign_strips()

    def __validate_strip_offset(self):
        all_tracks = tuple(self.song().visible_tracks) + tuple(self.song().return_tracks) + (self.song().master_track,)
        self.__strip_offset = min(self.__strip_offset, len(all_tracks) - 1)
        self.__strip_offset = max(0, self.__strip_offset)

    def __validate_slider_mode(self):
        if self.__slider_mode - SLIDER_MODE_SEND >= len(self.song().return_tracks):
            self.__slider_mode = SLIDER_MODE_VOLUME

    def __set_slider_mode(self, new_mode):
        if self.__slider_mode >= SLIDER_MODE_SEND and new_mode >= SLIDER_MODE_SEND:
            if self.__slider_mode - SLIDER_MODE_SEND + 1 < len(self.song().return_tracks):
                self.__slider_mode += 1
            else:
                self.__slider_mode = SLIDER_MODE_SEND
            self.__update_selected_row_leds()
            self.__reassign_strips()
        elif self.__slider_mode != new_mode:
            self.__slider_mode = new_mode
            self.__update_selected_row_leds()
            self.__reassign_strips()

    def __update_selected_row_leds(self):
        if self.__slider_mode == SLIDER_MODE_VOLUME:
            self.send_midi((self.cc_status_byte(), MX_SELECT_SLIDER_ROW, CC_VAL_BUTTON_PRESSED))
            self.send_midi((self.cc_status_byte(), MX_SELECT_FIRST_BUTTON_ROW, CC_VAL_BUTTON_RELEASED))
            self.send_midi((self.cc_status_byte(), MX_SELECT_SECOND_BUTTON_ROW, CC_VAL_BUTTON_RELEASED))
        elif self.__slider_mode == SLIDER_MODE_PAN:
            self.send_midi((self.cc_status_byte(), MX_SELECT_SLIDER_ROW, CC_VAL_BUTTON_RELEASED))
            self.send_midi((self.cc_status_byte(), MX_SELECT_FIRST_BUTTON_ROW, CC_VAL_BUTTON_PRESSED))
            self.send_midi((self.cc_status_byte(), MX_SELECT_SECOND_BUTTON_ROW, CC_VAL_BUTTON_RELEASED))
        elif self.__slider_mode >= SLIDER_MODE_SEND:
            self.send_midi((self.cc_status_byte(), MX_SELECT_SLIDER_ROW, CC_VAL_BUTTON_RELEASED))
            self.send_midi((self.cc_status_byte(), MX_SELECT_FIRST_BUTTON_ROW, CC_VAL_BUTTON_RELEASED))
            self.send_midi((self.cc_status_byte(), MX_SELECT_SECOND_BUTTON_ROW, CC_VAL_BUTTON_PRESSED))

    def __on_record_mode_changed(self):
        if self.__transport_locked or not self.support_mkII():
            record_cc = TS_RECORD_CC
            if self.support_mkII():
                record_cc = 53
            record_value = CC_VAL_BUTTON_PRESSED
            if not self.song().record_mode:
                record_value = CC_VAL_BUTTON_RELEASED
            self.send_midi((self.cc_status_byte(), record_cc, record_value))

    def __on_is_playing_changed(self):
        if self.__transport_locked and self.support_mkII():
            if self.song().is_playing:
                self.send_midi((self.cc_status_byte(), 51, CC_VAL_BUTTON_PRESSED))
                self.send_midi((self.cc_status_byte(), 50, CC_VAL_BUTTON_RELEASED))
            else:
                self.send_midi((self.cc_status_byte(), 51, CC_VAL_BUTTON_RELEASED))
                self.send_midi((self.cc_status_byte(), 50, CC_VAL_BUTTON_PRESSED))

    def __on_loop_changed(self):
        if self.__transport_locked and self.support_mkII():
            if self.song().loop:
                self.send_midi((self.cc_status_byte(), 52, CC_VAL_BUTTON_PRESSED))
            else:
                self.send_midi((self.cc_status_byte(), 52, CC_VAL_BUTTON_RELEASED))

    def is_arm_exclusive(self):
        return self.__parent.song().exclusive_arm

    def set_selected_track(self, track):
        if track:
            self.__parent.song().view.selected_track = track

    def track_about_to_arm(self, track):
        if track and self.__parent.song().exclusive_arm:
            for t in self.__parent.song().tracks:
                if t.can_be_armed and t.arm and not t == track:
                    t.arm = False


class MixerChannelStrip():
    """Represents one of the 8 track related strips in the Mixer controls (one slider,
    two buttons)
    """

    def __init__(self, mixer_controller_parent, index):
        self.__mixer_controller = mixer_controller_parent
        self.__index = index
        self.__assigned_track = None
        self.__control_second_button = True

    def song(self):
        return self.__mixer_controller.song()

    def assigned_track(self):
        return self.__assigned_track

    def set_assigned_track(self, track):
        if self.__assigned_track != None:
            if self.__assigned_track != self.song().master_track:
                self.__assigned_track.remove_mute_listener(self._on_mute_changed)
            if self.__assigned_track.can_be_armed:
                self.__assigned_track.remove_arm_listener(self._on_arm_changed)
        self.__assigned_track = track
        if self.__assigned_track != None:
            if self.__assigned_track != self.song().master_track:
                self.__assigned_track.add_mute_listener(self._on_mute_changed)
            if self.__assigned_track.can_be_armed:
                self.__assigned_track.add_arm_listener(self._on_arm_changed)
        self._on_mute_changed()
        self._on_arm_changed()

    def slider_parameter(self):
        slider_mode = self.__mixer_controller.slider_mode()
        if self.__assigned_track:
            if slider_mode == SLIDER_MODE_VOLUME:
                return self.__assigned_track.mixer_device.volume
            elif slider_mode == SLIDER_MODE_PAN:
                return self.__assigned_track.mixer_device.panning
            elif slider_mode >= SLIDER_MODE_SEND:
                send_index = slider_mode - SLIDER_MODE_SEND
                if send_index < len(self.__assigned_track.mixer_device.sends):
                    return self.__assigned_track.mixer_device.sends[send_index]
                else:
                    return None
        else:
            return None

    def slider_moved(self, cc_value):
        raise self.__assigned_track == None or self.slider_parameter() == None or AssertionError, 'should only be reached when the slider was not realtime mapped '

    def take_control_of_second_button(self, take_control):
        if self.__mixer_controller.support_mkII():
            self.__mixer_controller.remote_sl_parent().send_midi((self.__mixer_controller.cc_status_byte(), self.__index + MX_SECOND_BUTTON_ROW_BASE_CC, 0))
        self.__control_second_button = take_control
        self._on_mute_changed()
        self._on_arm_changed()

    def first_button_pressed(self):
        if self.__assigned_track:
            if self.__assigned_track in tuple(self.song().visible_tracks) + tuple(self.song().return_tracks):
                self.__assigned_track.mute = not self.__assigned_track.mute

    def second_button_pressed(self):
        if self.__assigned_track in self.song().visible_tracks:
            if self.__assigned_track.can_be_armed:
                self.__mixer_controller.track_about_to_arm(self.__assigned_track)
                self.__assigned_track.arm = not self.__assigned_track.arm
                if self.__assigned_track.arm:
                    self.__assigned_track.view.select_instrument() and self.__mixer_controller.set_selected_track(self.__assigned_track)

    def _on_mute_changed(self):
        if self.__mixer_controller.support_mkII():
            value = 0
            if self.__assigned_track in tuple(self.song().tracks) + tuple(self.song().return_tracks) and not self.__assigned_track.mute:
                value = 1
            self.__mixer_controller.remote_sl_parent().send_midi((self.__mixer_controller.cc_status_byte(), self.__index + MX_FIRST_BUTTON_ROW_BASE_CC, value))

    def _on_arm_changed(self):
        if self.__control_second_button and self.__mixer_controller.support_mkII():
            value = 0
            if self.__assigned_track and self.__assigned_track in self.song().tracks and self.__assigned_track.can_be_armed and self.__assigned_track.arm:
                value = 1
            self.__mixer_controller.remote_sl_parent().send_midi((self.__mixer_controller.cc_status_byte(), self.__index + MX_SECOND_BUTTON_ROW_BASE_CC, value))
########NEW FILE########
__FILENAME__ = RemoteSL
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/RemoteSL_Classic/RemoteSL.py
import Live
import MidiRemoteScript
from EffectController import EffectController
from MixerController import MixerController
from DisplayController import DisplayController
from consts import *

class RemoteSL:
    """ Automap script for the Novation Remote SL.
    TODO: Add some general comments about the mappings, FX, MX left/right side...
    """

    def __init__(self, c_instance):
        self.__c_instance = c_instance
        self.__automap_has_control = False
        self.__display_controller = DisplayController(self)
        self.__effect_controller = EffectController(self, self.__display_controller)
        self.__mixer_controller = MixerController(self, self.__display_controller)
        self.__components = [self.__effect_controller, self.__mixer_controller, self.__display_controller]
        self.__update_hardware_delay = -1

    def disconnect(self):
        """Called right before we get disconnected from Live
        """
        for c in self.__components:
            c.disconnect()

        self.send_midi(ALL_LEDS_OFF_MESSAGE)
        self.send_midi(GOOD_BYE_SYSEX_MESSAGE)

    def application(self):
        """returns a reference to the application that we are running in
        """
        return Live.Application.get_application()

    def song(self):
        """returns a reference to the Live song instance that we do control
        """
        return self.__c_instance.song()

    def suggest_input_port(self):
        """Live -> Script
        Live can ask the script for an input port name to find a suitable one.
        """
        return 'RemoteSL'

    def suggest_output_port(self):
        """Live -> Script
        Live can ask the script for an output port name to find a suitable one.
        """
        return 'RemoteSL'

    def can_lock_to_devices(self):
        """Live -> Script
        Live can ask the script whether it can be locked to devices
        """
        return True

    def lock_to_device(self, device):
        """Live -> Script
        Live can tell the script to lock to a given device
        """
        self.__effect_controller.lock_to_device(device)

    def unlock_from_device(self, device):
        """Live -> Script
        Live can tell the script to unlock from a given device
        """
        self.__effect_controller.unlock_from_device(device)

    def set_appointed_device(self, device):
        """Live -> Script
        Live can tell the script which device to use if it is not locked
        This is a substitute mechanism for the listeners used by older scripts
        """
        self.__effect_controller.set_appointed_device(device)

    def toggle_lock(self):
        """Script -> Live
        Use this function to toggle the script's lock on devices
        """
        self.__c_instance.toggle_lock()

    def suggest_map_mode(self, cc_no, channel):
        """Live -> Script
        Live can ask the script to suggest a map mode for the given CC
        """
        result = Live.MidiMap.MapMode.absolute
        if cc_no in fx_encoder_row_ccs:
            result = Live.MidiMap.MapMode.relative_smooth_signed_bit
        return result

    def restore_bank(self, bank):
        self.__effect_controller.restore_bank(bank)

    def supports_pad_translation(self):
        return True

    def show_message(self, message):
        self.__c_instance.show_message(message)

    def instance_identifier(self):
        return self.__c_instance.instance_identifier()

    def connect_script_instances(self, instanciated_scripts):
        """
        Called by the Application as soon as all scripts are initialized.
        You can connect yourself to other running scripts here, as we do it
        connect the extension modules (MackieControlXTs).
        """
        pass

    def request_rebuild_midi_map(self):
        """When the internal MIDI controller has changed in a way that you need to rebuild
        the MIDI mappings, request a rebuild by calling this function
        This is processed as a request, to be sure that its not too often called, because
        its time-critical.
        """
        self.__c_instance.request_rebuild_midi_map()

    def send_midi(self, midi_event_bytes):
        """Use this function to send MIDI events through Live to the _real_ MIDI devices
        that this script is assigned to.
        """
        if not self.__automap_has_control:
            self.__c_instance.send_midi(midi_event_bytes)

    def refresh_state(self):
        """Send out MIDI to completely update the attached MIDI controller.
        Will be called when requested by the user, after for example having reconnected
        the MIDI cables...
        """
        self.__update_hardware_delay = 5

    def __update_hardware(self):
        self.__automap_has_control = False
        self.send_midi(WELCOME_SYSEX_MESSAGE)
        for c in self.__components:
            c.refresh_state()

    def build_midi_map(self, midi_map_handle):
        """Build DeviceParameter Mappings, that are processed in Audio time, or
        forward MIDI messages explicitly to our receive_midi_functions.
        Which means that when you are not forwarding MIDI, nor mapping parameters, you will
        never get any MIDI messages at all.
        """
        if not self.__automap_has_control:
            for c in self.__components:
                c.build_midi_map(self.__c_instance.handle(), midi_map_handle)

        self.__c_instance.set_pad_translation(PAD_TRANSLATION)

    def update_display(self):
        """Aka on_timer. Called every 100 ms and should be used to update display relevant
        parts of the controller only...
        """
        if self.__update_hardware_delay > 0:
            self.__update_hardware_delay -= 1
            if self.__update_hardware_delay == 0:
                self.__update_hardware()
                self.__update_hardware_delay = -1
        for c in self.__components:
            c.update_display()

    def receive_midi(self, midi_bytes):
        """MIDI messages are only received through this function, when explicitly
        forwarded in 'build_midi_map'.
        """
        if midi_bytes[0] & 240 in (NOTE_ON_STATUS, NOTE_OFF_STATUS):
            channel = midi_bytes[0] & 15
            note = midi_bytes[1]
            velocity = midi_bytes[2]
            if note in fx_notes:
                self.__effect_controller.receive_midi_note(note, velocity)
            elif note in mx_notes:
                self.__mixer_controller.receive_midi_note(note, velocity)
            else:
                print 'unknown MIDI message %s' % str(midi_bytes)
        elif midi_bytes[0] & 240 == CC_STATUS:
            channel = midi_bytes[0] & 15
            cc_no = midi_bytes[1]
            cc_value = midi_bytes[2]
            if cc_no in fx_ccs:
                self.__effect_controller.receive_midi_cc(cc_no, cc_value)
            elif cc_no in mx_ccs:
                self.__mixer_controller.receive_midi_cc(cc_no, cc_value)
            else:
                print 'unknown MIDI message %s' % str(midi_bytes)
        elif midi_bytes[0] == 240:
            if len(midi_bytes) == 13 and midi_bytes[1:4] == (0, 32, 41):
                if midi_bytes[8] == ABLETON_PID and midi_bytes[10] == 1:
                    self.__automap_has_control = midi_bytes[11] == 0
                    support_mkII = midi_bytes[6] * 100 + midi_bytes[7] >= 1800
                    if not self.__automap_has_control:
                        self.send_midi(ALL_LEDS_OFF_MESSAGE)
                    for c in self.__components:
                        c.set_support_mkII(support_mkII)
                        if not self.__automap_has_control:
                            c.refresh_state()

                    self.request_rebuild_midi_map()
        else:
            print 'unknown MIDI message %s' % str(midi_bytes)
########NEW FILE########
__FILENAME__ = RemoteSLComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/RemoteSL_Classic/RemoteSLComponent.py
from consts import *

class RemoteSLComponent:
    """Baseclass for a subcomponent of the RemoteSL.
    Just defines some handy shortcuts to the main scripts functions...
    for more details about the methods, see the RemoteSLs doc strings
    """

    def __init__(self, remote_sl_parent):
        self.__parent = remote_sl_parent
        self.__support_mkII = False

    def application(self):
        return self.__parent.application()

    def song(self):
        return self.__parent.song()

    def send_midi(self, midi_event_bytes):
        self.__parent.send_midi(midi_event_bytes)

    def request_rebuild_midi_map(self):
        self.__parent.request_rebuild_midi_map()

    def disconnect(self):
        pass

    def build_midi_map(self, script_handle, midi_map_handle):
        pass

    def refresh_state(self):
        pass

    def update_display(self):
        pass

    def cc_status_byte(self):
        return CC_STATUS + SL_MIDI_CHANNEL

    def support_mkII(self):
        return self.__support_mkII

    def set_support_mkII(self, support_mkII):
        self.__support_mkII = support_mkII
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Tranzport/consts.py
NOTE_OFF_STATUS = 128
NOTE_ON_STATUS = 144
CC_STATUS = 176
NUM_NOTES = 127
NUM_CC_NO = 127
NUM_CHANNELS = 15
NUM_PAGES = 4
PAGES_NAMES = (('P', 'o', 's', 'i', 't', 'i', 'o', 'n', ' ', '&', ' ', 'T', 'e', 'm', 'p', 'o'),
 ('C', 'l', 'i', 'p', ' ', '&', ' ', 'T', 'e', 'm', 'p', 'o'),
 ('V', 'o', 'l', 'u', 'm', 'e', ' ', '&', ' ', 'P', 'a', 'n', 'n', 'i', 'n', 'g'),
 ('L', 'o', 'o', 'p', ' ', 'S', 'e', 't', 't', 'i', 'n', 'g', 's'),
 ('S', 'e', 'n', 'd', ' ', 'S', 'e', 't', 't', 'i', 'n', 'g', 's'))
TRANZ_NATIVE_MODE = (240, 0, 1, 64, 16, 1, 0, 247)
TRANZ_TRANS_SECTION = range(91, 96)
TRANZ_RWD = 91
TRANZ_FFWD = 92
TRANZ_STOP = 93
TRANZ_PLAY = 94
TRANZ_REC = 95
TRANZ_PREV_TRACK = 48
TRANZ_NEXT_TRACK = 49
TRANZ_ARM_TRACK = 0
TRANZ_MUTE_TRACK = 16
TRANZ_SOLO_TRACK = 8
TRANZ_ANY_SOLO = 115
TRANZ_TRACK_SECTION = (TRANZ_PREV_TRACK,
 TRANZ_NEXT_TRACK,
 TRANZ_ARM_TRACK,
 TRANZ_MUTE_TRACK,
 TRANZ_SOLO_TRACK,
 TRANZ_ANY_SOLO)
TRANZ_LOOP = 86
TRANZ_PUNCH_IN = 87
TRANZ_PUNCH_OUT = 88
TRANZ_PUNCH = 120
TRANZ_LOOP_SECTION = (TRANZ_LOOP,
 TRANZ_PUNCH_IN,
 TRANZ_PUNCH_OUT,
 TRANZ_PUNCH)
TRANZ_PREV_CUE = 84
TRANZ_ADD_CUE = 82
TRANZ_NEXT_CUE = 85
TRANZ_CUE_SECTION = (TRANZ_PREV_CUE, TRANZ_ADD_CUE, TRANZ_NEXT_CUE)
TRANZ_UNDO = 76
TRANZ_SHIFT = 121
TRANZ_DICT = {'0': 48,
 '1': 49,
 '2': 50,
 '3': 51,
 '4': 52,
 '5': 53,
 '6': 54,
 '7': 55,
 '8': 56,
 '9': 57,
 'A': 65,
 'B': 66,
 'C': 67,
 'D': 68,
 'E': 69,
 'F': 70,
 'G': 71,
 'H': 72,
 'I': 73,
 'J': 74,
 'K': 75,
 'L': 76,
 'M': 77,
 'N': 78,
 'O': 79,
 'P': 80,
 'Q': 81,
 'R': 82,
 'S': 83,
 'T': 84,
 'U': 85,
 'V': 86,
 'W': 87,
 'X': 88,
 'Y': 89,
 'Z': 90,
 'a': 97,
 'b': 98,
 'c': 99,
 'd': 100,
 'e': 101,
 'f': 102,
 'g': 103,
 'h': 104,
 'i': 105,
 'j': 106,
 'k': 107,
 'l': 108,
 'm': 109,
 'n': 110,
 'o': 111,
 'p': 112,
 'q': 113,
 'r': 114,
 's': 115,
 't': 116,
 'u': 117,
 'v': 118,
 'w': 119,
 'x': 120,
 'y': 121,
 'z': 122,
 '@': 64,
 ' ': 32,
 '.': 46,
 ',': 44,
 ':': 58,
 ';': 59,
 '<': 60,
 '>': 62,
 '[': 91,
 ']': 93,
 '_': 95,
 '-': 16,
 '|': 124,
 '&': 38}
SYSEX_START = (240, 0, 1, 64, 16, 0)
SYSEX_END = (247,)
CLEAR_LINE = (32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32)
LED_ON = 127
LED_OFF = 0
########NEW FILE########
__FILENAME__ = Tranzport
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/Tranzport/Tranzport.py
import Live
from consts import *
from itertools import chain

class Tranzport:
    """ A simple script to enable control over Live with the Tranzport controller """

    def __init__(self, c_instance):
        self.__c_instance = c_instance
        self.__current_track = self.song().view.selected_track
        self.__last_message = ()
        self.song().view.add_selected_scene_listener(self.__on_selected_scene_changed)
        self.song().add_record_mode_listener(self.__set_record_mode_led)
        self.song().view.add_selected_track_listener(self.__on_selected_track_changed)
        self.song().add_loop_listener(self.__set_loop_led)
        self.song().add_tracks_listener(self.__on_tracks_changed)
        self.application().view.add_is_view_visible_listener('Session', self.__on_view_changed)
        for i in chain(self.song().tracks, self.song().return_tracks):
            i.add_solo_listener(self.__set_any_solo_led)

        if self.__current_track in self.song().visible_tracks and self.__current_track.can_be_armed:
            self.__current_track.add_arm_listener(self.__set_track_armed_led)
        if self.__current_track in chain(self.song().visible_tracks, self.song().return_tracks):
            self.__current_track.add_mute_listener(self.__set_track_muted_led)
            self.__current_track.add_solo_listener(self.__set_track_soloed_led)
            self.__current_track.add_name_listener(self.__current_track_name_changed)
        self.__sends_in_current_track = len(self.__current_track.mixer_device.sends)
        self.__current_send_index = 0
        self.__rewind_pressed = False
        self.__ffwd_pressed = False
        self.__shift_pressed = False
        self.__nexttrack_pressed = False
        self.__prevtrack_pressed = False
        self.__nextmarker_pressed = False
        self.__prevmarker_pressed = False
        self.__showing_page_list = False
        self.__selected_page = 0
        self.__spooling_factor = 1.0
        self.__timer_count = 0
        self.__display_line_one = ()
        self.__display_line_two = ()
        self.__last_line_one = ()
        self.__last_line_two = ()
        self.send_midi(TRANZ_NATIVE_MODE)
        self.__display_line_one = self.__translate_string('    Ableton Live    ')
        self.__display_line_two = self.__translate_string('                    ')

    def application(self):
        """returns a reference to the application that we are running in
        """
        return Live.Application.get_application()

    def song(self):
        """returns a reference to the Live song instance that we do control
        """
        return self.__c_instance.song()

    def disconnect(self):
        """Live -> Script
        Called right before we get disconnected from Live.
        """
        NOTE_OFF_STATUS = 128
        TRANZ_REC = 95
        TRANZ_ARM_TRACK = 0
        TRANZ_MUTE_TRACK = 16
        TRANZ_SOLO_TRACK = 8
        TRANZ_ANY_SOLO = 115
        TRANZ_LOOP = 86
        TRANZ_PUNCH = 120
        SYSEX_START = (240, 0, 1, 64, 16, 0)
        SYSEX_END = (247,)
        CLEAR_LINE = (32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32)
        LED_OFF = 0
        self.send_midi(SYSEX_START + (0,) + CLEAR_LINE + CLEAR_LINE + SYSEX_END)
        self.song().view.remove_selected_scene_listener(self.__on_selected_scene_changed)
        self.song().remove_record_mode_listener(self.__set_record_mode_led)
        self.song().view.remove_selected_track_listener(self.__on_selected_track_changed)
        self.song().remove_loop_listener(self.__set_loop_led)
        self.song().remove_tracks_listener(self.__on_tracks_changed)
        if Live:
            self.application().view.remove_is_view_visible_listener('Session', self.__on_view_changed)
        for i in chain(self.song().tracks, self.song().return_tracks):
            i.remove_solo_listener(self.__set_any_solo_led)

        self.send_midi((NOTE_OFF_STATUS, TRANZ_REC, LED_OFF))
        self.send_midi((NOTE_OFF_STATUS, TRANZ_ARM_TRACK, LED_OFF))
        self.send_midi((NOTE_OFF_STATUS, TRANZ_MUTE_TRACK, LED_OFF))
        self.send_midi((NOTE_OFF_STATUS, TRANZ_SOLO_TRACK, LED_OFF))
        self.send_midi((NOTE_OFF_STATUS, TRANZ_ANY_SOLO, LED_OFF))
        self.send_midi((NOTE_OFF_STATUS, TRANZ_LOOP, LED_OFF))
        self.send_midi((NOTE_OFF_STATUS, TRANZ_PUNCH, LED_OFF))
        if (list(self.song().visible_tracks) + list(self.song().return_tracks)).count(self.__current_track) > 0:
            self.__current_track.remove_mute_listener(self.__set_track_muted_led)
            self.__current_track.remove_solo_listener(self.__set_track_soloed_led)
            self.__current_track.remove_name_listener(self.__current_track_name_changed)
            if self.__current_track in self.song().visible_tracks and self.__current_track.can_be_armed:
                self.__current_track.remove_arm_listener(self.__set_track_armed_led)

    def suggest_input_port(self):
        """Live -> Script
        Live can ask the script for an input port name to find a suitable one.
        """
        return 'TranzPort'

    def suggest_output_port(self):
        """Live -> Script
        Live can ask the script for an output port name to find a suitable one.
        """
        return 'TranzPort'

    def can_lock_to_devices(self):
        return False

    def connect_script_instances(self, instanciated_scripts):
        """Called by the Application as soon as all scripts are initialized.
        You can connect yourself to other running scripts here, as we do it
        connect the extension modules (MackieControlXTs).
        """
        pass

    def request_rebuild_midi_map(self):
        """Script -> Live
        When the internal MIDI controller has changed in a way that you need to rebuild
        the MIDI mappings, request a rebuild by calling this function
        This is processed as a request, to be sure that its not too often called, because
        its time-critical.
        """
        self.__c_instance.request_rebuild_midi_map()

    def send_midi(self, midi_event_bytes):
        """Script -> Live
        Use this function to send MIDI events through Live to the _real_ MIDI devices
        that this script is assigned to.
        """
        self.__c_instance.send_midi(midi_event_bytes)

    def refresh_state(self):
        """Live -> Script
        Send out MIDI to completely update the attached MIDI controller.
        Will be called when requested by the user, after for example having reconnected
        the MIDI cables...
        """
        self.__last_line_one = ()
        self.__last_line_two = ()
        if self.__timer_count >= 20:
            self.__show_track_and_scene()
        self.__set_record_mode_led()
        self.__set_track_armed_led()
        self.__set_track_muted_led()
        self.__set_track_soloed_led()
        self.__set_any_solo_led()
        self.__set_loop_led()

    def build_midi_map(self, midi_map_handle):
        """Live -> Script
        Build DeviceParameter Mappings, that are processed in Audio time, or
        forward MIDI messages explicitly to our receive_midi_functions.
        Which means that when you are not forwarding MIDI, nor mapping parameters, you will
        never get any MIDI messages at all.
        """
        script_handle = self.__c_instance.handle()
        for i in range(NUM_NOTES):
            Live.MidiMap.forward_midi_note(script_handle, midi_map_handle, 0, i)

        for channel in range(NUM_CHANNELS):
            for cc_no in range(NUM_CC_NO):
                Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, channel, cc_no)

    def update_display(self):
        """Live -> Script
        Aka on_timer. Called every 100 ms and should be used to update display relevant
        parts of the controller
        """
        if self.__timer_count < 21:
            self.__timer_count = self.__timer_count + 1
        if self.__timer_count == 10:
            self.__show_pos_and_tempo()
        if self.__timer_count == 20:
            self.__on_selected_track_changed()
        if self.__ffwd_pressed or self.__rewind_pressed:
            self.__spooling_factor = self.__spooling_factor + 0.2
            if self.__ffwd_pressed:
                self.song().jump_by(1 * self.__spooling_factor)
            if self.__rewind_pressed:
                self.song().jump_by(-1 * self.__spooling_factor)
        if not self.__display_line_one == self.__last_line_one:
            self.send_midi(SYSEX_START + (0,) + self.__display_line_one + SYSEX_END)
            self.__last_line_one = self.__display_line_one
        self.__show_selected_page()
        if not self.__display_line_two == self.__last_line_two:
            self.send_midi(SYSEX_START + (20,) + self.__display_line_two + SYSEX_END)
            self.__last_line_two = self.__display_line_two

    def receive_midi(self, midi_bytes):
        """Live -> Script
        MIDI messages are only received through this function, when explicitly
        forwarded in 'build_midi_map'.
        """
        if midi_bytes[0] & 240 == NOTE_ON_STATUS or midi_bytes[0] & 240 == NOTE_OFF_STATUS:
            note = midi_bytes[1]
            velocity = midi_bytes[2]
            if note == TRANZ_SHIFT:
                self.__shift_status_changed(velocity)
            elif note in TRANZ_TRANS_SECTION:
                self.__on_transport_button_pressed(note, velocity)
            elif note in TRANZ_TRACK_SECTION:
                self.__on_track_button_pressed(note, velocity)
            elif note in TRANZ_LOOP_SECTION:
                self.__on_loop_button_pressed(note, velocity)
            elif note in TRANZ_CUE_SECTION:
                self.__on_cue_button_pressed(note, velocity)
            elif note == TRANZ_UNDO:
                self.__on_undo_pressed(velocity)
        elif midi_bytes[0] & 240 == CC_STATUS:
            cc_no = midi_bytes[1]
            cc_value = midi_bytes[2]
            if midi_bytes[0] == 176 and cc_no == 60:
                self.__on_jogdial_changed(cc_value)

    def __on_transport_button_pressed(self, button, status):
        if button == TRANZ_PLAY:
            if status > 0:
                if not self.__shift_pressed:
                    self.song().is_playing = True
                else:
                    self.song().continue_playing()
        elif button == TRANZ_STOP:
            if status > 0:
                self.song().is_playing = False
        elif button == TRANZ_REC:
            if status > 0:
                if not self.__shift_pressed:
                    self.song().record_mode = not self.song().record_mode
        elif button == TRANZ_FFWD:
            if status > 0:
                if self.__shift_pressed:
                    self.song().jump_by(self.song().signature_denominator)
                else:
                    self.song().jump_by(1)
                    self.__ffwd_pressed = True
            else:
                self.__ffwd_pressed = False
                self.__spooling_factor = 1.0
        elif button == TRANZ_RWD:
            if status > 0:
                if self.__shift_pressed:
                    self.song().jump_by(-1 * self.song().signature_denominator)
                else:
                    self.song().jump_by(-1)
                    self.__rewind_pressed = True
            else:
                self.__rewind_pressed = False
                self.__spooling_factor = 1.0

    def __on_track_button_pressed(self, button, status):
        all_tracks = list(tuple(self.song().visible_tracks) + tuple(self.song().return_tracks) + (self.song().master_track,))
        index = all_tracks.index(self.__current_track)
        if button == TRANZ_PREV_TRACK:
            if status > 0:
                if self.__shift_pressed:
                    self.__handle_page_select(-1)
                else:
                    self.__prevtrack_pressed = True
                    if index > 0:
                        index = index - 1
                        self.song().view.selected_track = all_tracks[index]
            else:
                self.__prevtrack_pressed = False
        elif button == TRANZ_NEXT_TRACK:
            if status > 0:
                if self.__shift_pressed:
                    self.__handle_page_select(1)
                else:
                    self.__nexttrack_pressed = True
                    if index < len(all_tracks) - 1:
                        index = index + 1
                        self.song().view.selected_track = all_tracks[index]
            else:
                self.__nexttrack_pressed = False
        elif button == TRANZ_ARM_TRACK:
            if status > 0 and list(self.song().visible_tracks).count(self.__current_track) > 0:
                if self.song().exclusive_arm and not self.__shift_pressed or self.__shift_pressed and not self.song().exclusive_arm:
                    for i in self.song().tracks:
                        if i != self.__current_track and i.can_be_armed:
                            i.arm = False

                if self.__current_track and self.__current_track.can_be_armed:
                    self.__current_track.arm = not self.__current_track.arm
        elif button == TRANZ_MUTE_TRACK:
            if status > 0 and (list(self.song().visible_tracks) + list(self.song().return_tracks)).count(self.__current_track) > 0:
                if not self.__shift_pressed:
                    self.__current_track.mute = not self.__current_track.mute
                else:
                    for i in chain(self.song().tracks, self.song().return_tracks):
                        i.mute = False

        elif button == TRANZ_SOLO_TRACK:
            if status > 0:
                if (list(self.song().visible_tracks) + list(self.song().return_tracks)).count(self.__current_track) > 0 and (self.song().exclusive_solo and not self.__shift_pressed or self.__shift_pressed and not self.song().exclusive_solo):
                    for i in chain(self.song().tracks, self.song().return_tracks):
                        if i.solo and not i == self.__current_track:
                            i.solo = False

            for i in chain(self.song().tracks, self.song().return_tracks):
                self.__current_track.solo = not self.__current_track.solo

    def __on_loop_button_pressed(self, button, status):
        current_pos = self.song().current_song_time
        loop_start = self.song().loop_start
        loop_end = loop_start + self.song().loop_length
        if status > 0:
            if button == TRANZ_LOOP:
                if not self.__shift_pressed:
                    self.song().loop = not self.song().loop
                elif self.application().view.is_view_visible('Session'):
                    self.application().view.show_view('Arranger')
                elif self.application().view.is_view_visible('Arranger'):
                    self.application().view.show_view('Session')
            elif button == TRANZ_PUNCH_IN:
                if not self.__shift_pressed:
                    self.song().punch_in = not self.song().punch_in
                elif current_pos < loop_end:
                    self.song().loop_start = current_pos
                    self.song().loop_length = loop_end - current_pos
            elif button == TRANZ_PUNCH_OUT:
                if not self.__shift_pressed:
                    self.song().punch_out = not self.song().punch_out
                elif current_pos > loop_start:
                    self.song().loop_length = current_pos - loop_start
            elif button == TRANZ_PUNCH:
                if self.application().view.is_view_visible('Session'):
                    current_slot = self.song().view.highlighted_clip_slot
                    if not self.__shift_pressed and list(self.song().visible_tracks).count(self.__current_track) > 0:
                        current_slot.fire()
                    else:
                        self.song().view.selected_scene.fire_as_selected()

    def __on_cue_button_pressed(self, button, status):
        if status > 0:
            if button == TRANZ_PREV_CUE:
                if not self.__shift_pressed:
                    self.__prevmarker_pressed = True
                    if self.song().can_jump_to_prev_cue:
                        self.song().jump_to_prev_cue()
                else:
                    self.song().current_song_time = 0
            elif button == TRANZ_ADD_CUE:
                if not self.__shift_pressed:
                    self.song().set_or_delete_cue()
            elif button == TRANZ_NEXT_CUE:
                if not self.__shift_pressed:
                    self.__nextmarker_pressed = True
                    if self.song().can_jump_to_next_cue:
                        self.song().jump_to_next_cue()
                else:
                    self.song().current_song_time = self.song().last_event_time
        elif status == 0:
            if button == TRANZ_PREV_CUE:
                self.__prevmarker_pressed = False
            elif button == TRANZ_NEXT_CUE:
                self.__nextmarker_pressed = False

    def __on_jogdial_changed(self, value):
        neg_value = value - 64
        all_tracks = list(tuple(self.song().visible_tracks) + tuple(self.song().return_tracks) + (self.song().master_track,))
        index = all_tracks.index(self.__current_track)
        if value in range(1, 64):
            if not self.__shift_pressed:
                if self.__prevtrack_pressed or self.__nexttrack_pressed:
                    if index < len(all_tracks) - 1:
                        index = index + 1
                        self.song().view.selected_track = all_tracks[index]
                elif self.__prevmarker_pressed or self.__nextmarker_pressed:
                    if self.song().can_jump_to_next_cue:
                        self.song().jump_to_next_cue()
                elif self.__selected_page == 0:
                    if self.application().view.is_view_visible('Session'):
                        index = list(self.song().scenes).index(self.song().view.selected_scene)
                        if index < len(self.song().scenes) - 1:
                            index = index + 1
                            self.song().view.selected_scene = self.song().scenes[index]
                    else:
                        self.song().jump_by(value)
                elif self.__selected_page == 1:
                    if self.__current_track.mixer_device.volume.value <= self.__current_track.mixer_device.volume.max - 0.01 * value:
                        self.__current_track.mixer_device.volume.value = self.__current_track.mixer_device.volume.value + 0.01 * value
                    else:
                        self.__current_track.mixer_device.volume.value = self.__current_track.mixer_device.volume.max
                elif self.__selected_page == 2:
                    self.song().loop_start = self.song().loop_start + value
                elif self.__selected_page == 3:
                    if self.__current_track.mixer_device.sends[self.__current_send_index].value <= self.__current_track.mixer_device.sends[self.__current_send_index].max - 0.01 * value:
                        self.__current_track.mixer_device.sends[self.__current_send_index].value = self.__current_track.mixer_device.sends[self.__current_send_index].value + 0.01 * value
                    else:
                        self.__current_track.mixer_device.sends[self.__current_send_index].value = self.__current_track.mixer_device.sends[self.__current_send_index].max
            elif self.__selected_page == 0:
                self.song().tempo = self.song().tempo + 0.1 * value
            elif self.__selected_page == 1:
                if self.__current_track.mixer_device.panning.value <= self.__current_track.mixer_device.panning.max - 0.02 * value:
                    self.__current_track.mixer_device.panning.value = self.__current_track.mixer_device.panning.value + 0.02 * value
                else:
                    self.__current_track.mixer_device.panning.value = self.__current_track.mixer_device.panning.max
            elif self.__selected_page == 2:
                self.song().loop_length = self.song().loop_length + value
            elif self.__selected_page == 3:
                if self.__current_send_index < len(self.__current_track.mixer_device.sends) - 1:
                    self.__current_send_index = self.__current_send_index + 1
                else:
                    self.__current_send_index = len(self.__current_track.mixer_device.sends) - 1
        elif value in range(65, 128):
            if not self.__shift_pressed:
                if self.__prevtrack_pressed or self.__nexttrack_pressed:
                    if index > 0:
                        index = index - 1
                        self.song().view.selected_track = all_tracks[index]
                elif self.__prevmarker_pressed or self.__nextmarker_pressed:
                    if self.song().can_jump_to_prev_cue:
                        self.song().jump_to_prev_cue()
                elif self.__selected_page == 0:
                    if self.application().view.is_view_visible('Session'):
                        index = list(self.song().scenes).index(self.song().view.selected_scene)
                        if index > 0:
                            index = index - 1
                        self.song().view.selected_scene = self.song().scenes[index]
                    else:
                        self.song().jump_by(-1 * neg_value)
                elif self.__selected_page == 1:
                    if self.__current_track.mixer_device.volume.value >= self.__current_track.mixer_device.volume.min + 0.01 * neg_value:
                        self.__current_track.mixer_device.volume.value = self.__current_track.mixer_device.volume.value - 0.01 * neg_value
                    else:
                        self.__current_track.mixer_device.volume.value = self.__current_track.mixer_device.volume.min
                elif self.__selected_page == 2:
                    if self.song().loop_start >= neg_value:
                        self.song().loop_start = self.song().loop_start - neg_value
                elif self.__selected_page == 3:
                    if self.__current_track.mixer_device.sends[self.__current_send_index].value >= self.__current_track.mixer_device.sends[self.__current_send_index].min + 0.01 * neg_value:
                        self.__current_track.mixer_device.sends[self.__current_send_index].value = self.__current_track.mixer_device.sends[self.__current_send_index].value - 0.01 * neg_value
                    else:
                        self.__current_track.mixer_device.sends[self.__current_send_index].value = self.__current_track.mixer_device.sends[self.__current_send_index].min
            elif self.__selected_page == 0:
                self.song().tempo = self.song().tempo - 0.1 * neg_value
            elif self.__selected_page == 1:
                if self.__current_track.mixer_device.panning.value >= self.__current_track.mixer_device.panning.min + 0.02 * neg_value:
                    self.__current_track.mixer_device.panning.value = self.__current_track.mixer_device.panning.value - 0.02 * neg_value
                else:
                    self.__current_track.mixer_device.panning.value = self.__current_track.mixer_device.panning.min
            elif self.__selected_page == 2:
                if self.song().loop_length > neg_value:
                    self.song().loop_length = self.song().loop_length - neg_value
            elif self.__selected_page == 3:
                if self.__current_send_index > 0:
                    self.__current_send_index = self.__current_send_index - 1
                else:
                    self.__current_send_index = 0

    def __on_undo_pressed(self, status):
        if status > 0:
            if not self.__shift_pressed:
                if self.song().can_undo:
                    self.song().undo()
            elif self.song().can_redo:
                self.song().redo()

    def __on_selected_scene_changed(self):
        if self.application().view.is_view_visible('Session'):
            self.__show_track_and_scene()

    def __on_current_song_time_changed(self):
        if self.__selected_page == 0:
            self.__show_selected_page()

    def __on_current_song_tempo_changed(self):
        if self.__selected_page == 0:
            self.__show_selected_page()

    def __on_current_track_volume_changed(self):
        if self.__selected_page == 1:
            self.__show_selected_page()

    def __on_current_track_panning_changed(self):
        if self.__selected_page == 1:
            self.__show_selected_page()

    def __on_song_loop_start_changed(self):
        if self.__selected_page == 2:
            self.__show_selected_page()

    def __on_song_loop_length_changed(self):
        if self.__selected_page == 2:
            self.__show_selected_page()

    def __on_view_changed(self):
        self.__show_track_and_scene()
        self.__show_selected_page()

    def __on_tracks_changed(self):
        for i in chain(self.song().tracks, self.song().return_tracks):
            if not i.solo_has_listener(self.__set_any_solo_led):
                i.add_solo_listener(self.__set_any_solo_led)

    def __show_track_and_scene(self):
        line = ()
        if self.application().view.is_view_visible('Session'):
            line = self.__translate_string(self.__bring_string_to_length(self.__current_track.name, 11))
            line = line + self.__translate_string('  Scene%2d' % (list(self.song().scenes).index(self.song().view.selected_scene) + 1))
        elif self.application().view.is_view_visible('Arranger'):
            line = self.__translate_string(self.__bring_string_to_length(self.__current_track.name, 20))
        self.__display_line_one = line

    def __show_selected_page(self):
        if not self.__showing_page_list and self.__timer_count > 20:
            index = self.__selected_page
            if index == 0:
                self.__show_pos_and_tempo()
            elif index == 1:
                self.__show_vol_and_pan()
            elif index == 2:
                self.__show_loop_settings()
            elif index == 3:
                self.__show_send_settings()
        elif self.__showing_page_list:
            self.__show_page_select()

    def __show_pos_and_tempo(self):
        beat_time = self.song().get_current_beats_song_time()
        position_str = ()
        if self.application().view.is_view_visible('Session'):
            current_slot = self.song().view.highlighted_clip_slot
            position_str = self.__translate_string('[No Clip]  ')
            if current_slot:
                if current_slot.clip:
                    if current_slot.clip.name == '':
                        position_str = self.__translate_string('[No Name]  ')
                    else:
                        position_str = self.__translate_string(self.__bring_string_to_length(current_slot.clip.name, 9)) + self.__translate_string('  ')
        else:
            position_str = self.__translate_string(str('%3d.' % beat_time.bars)) + self.__translate_string(str('%02d.' % beat_time.beats)) + self.__translate_string(str('%02d  ' % beat_time.ticks))
        tempo_str = self.__translate_string('%3.2fbpm' % self.song().tempo)
        if len(tempo_str) == 8:
            tempo_str = (32,) + tempo_str
        self.__display_line_two = position_str + tempo_str

    def __show_vol_and_pan(self):
        volume = self.__current_track.mixer_device.volume
        panning = self.__current_track.mixer_device.panning
        if self.__current_track.has_audio_output:
            self.__display_line_two = self.__translate_string(self.__string_from_number_with_length(volume, 9)) + self.__translate_string('       ') + self.__translate_string(self.__string_from_number_with_length(panning, 3))
        else:
            self.__display_line_two = self.__translate_string('  No Audio Output   ')

    def __show_loop_settings(self):
        start_time = self.song().get_beats_loop_start()
        length_time = self.song().get_beats_loop_length()
        self.__display_line_two = self.__translate_string('S%3d.' % start_time.bars) + self.__translate_string('%02d.' % start_time.beats) + self.__translate_string('%02d ' % start_time.ticks) + self.__translate_string('L%2d.' % length_time.bars) + self.__translate_string('%02d.' % length_time.beats) + self.__translate_string('%02d' % length_time.ticks)

    def __show_send_settings(self):
        result = ()
        if len(self.__current_track.mixer_device.sends) > 0 and self.__current_track.has_audio_output:
            if self.__current_send_index >= len(self.__current_track.mixer_device.sends):
                self.__current_send_index = len(self.__current_track.mixer_device.sends) - 1
            elif self.__current_send_index < 0:
                self.__current_send_index = 0
            current_send = self.__current_track.mixer_device.sends[self.__current_send_index]
            result = self.__translate_string(self.__string_from_number_with_length(current_send, 8)) + self.__translate_string('  in  ') + self.__translate_string(current_send.name)
        else:
            result = self.__translate_string(' No Sends Available ')
        self.__display_line_two = result

    def __show_page_select(self):
        index = self.__selected_page
        if self.application().view.is_view_visible('Session') or index > 0:
            index = index + 1
        pages_list = ('<',) + PAGES_NAMES[index] + ('>',)
        position = 10 - len(pages_list) / 2
        message = ()
        for i in range(position):
            message = message + (32,)

        message = message + self.__translate_string(pages_list)
        for i in range(position):
            message = message + (32,)

        self.__display_line_two = message

    def __set_record_mode_led(self):
        if self.song().record_mode:
            self.send_midi((NOTE_ON_STATUS, TRANZ_REC, LED_ON))
        else:
            self.send_midi((NOTE_ON_STATUS, TRANZ_REC, LED_OFF))

    def __set_track_armed_led(self):
        status = LED_OFF
        if list(self.song().visible_tracks).count(self.__current_track) > 0:
            if self.song().view.selected_track.arm:
                status = LED_ON
        self.send_midi((NOTE_ON_STATUS, TRANZ_ARM_TRACK, status))

    def is_track_visible(self, track):
        return (list(self.song().visible_tracks) + list(self.song().return_tracks)).count(track) > 0

    def __set_track_muted_led(self):
        status = LED_OFF
        if self.is_track_visible(self.__current_track):
            if self.song().view.selected_track.mute:
                status = LED_ON
        self.send_midi((NOTE_ON_STATUS, TRANZ_MUTE_TRACK, status))

    def __set_track_soloed_led(self):
        status = LED_OFF
        if self.is_track_visible(self.__current_track):
            if self.song().view.selected_track.solo:
                status = LED_ON
        self.send_midi((NOTE_ON_STATUS, TRANZ_SOLO_TRACK, status))

    def __set_any_solo_led(self):
        status = LED_OFF
        for i in chain(self.song().tracks, self.song().return_tracks):
            if i.solo:
                status = LED_ON
                break

        self.send_midi((NOTE_ON_STATUS, TRANZ_ANY_SOLO, status))

    def __set_loop_led(self):
        status = LED_OFF
        if self.song().loop:
            status = LED_ON
        self.send_midi((NOTE_ON_STATUS, TRANZ_LOOP, status))

    def __current_track_name_changed(self):
        self.__show_track_and_scene()

    def __on_selected_track_changed(self):
        if self.is_track_visible(self.__current_track):
            self.__current_track.remove_mute_listener(self.__set_track_muted_led)
            self.__current_track.remove_solo_listener(self.__set_track_soloed_led)
            self.__current_track.remove_name_listener(self.__current_track_name_changed)
            if self.__current_track in self.song().tracks and self.__current_track.can_be_armed:
                self.__current_track.remove_arm_listener(self.__set_track_armed_led)
        self.__current_track = self.song().view.selected_track
        if (list(self.song().visible_tracks) + list(self.song().return_tracks)).count(self.__current_track) > 0:
            self.__current_track.add_solo_listener(self.__set_track_soloed_led)
            self.__current_track.add_mute_listener(self.__set_track_muted_led)
            self.__current_track.add_name_listener(self.__current_track_name_changed)
            if self.__current_track in self.song().visible_tracks and self.__current_track.can_be_armed:
                self.__current_track.add_arm_listener(self.__set_track_armed_led)
        self.__sends_in_current_track = len(self.__current_track.mixer_device.sends)
        self.__current_send_index = 0
        self.refresh_state()

    def __handle_page_select(self, direction):
        if self.__showing_page_list:
            self.__selected_page = self.__selected_page + direction
            if self.__selected_page >= NUM_PAGES:
                self.__selected_page = 0
            elif self.__selected_page < 0:
                self.__selected_page = NUM_PAGES - 1
        else:
            self.__showing_page_list = True
        self.__show_page_select()

    def __shift_status_changed(self, status):
        if status == 0:
            self.__shift_pressed = False
            self.__showing_page_list = False
        else:
            self.__shift_pressed = True
        self.__show_selected_page()

    def __translate_string(self, text):
        result = ()
        length = len(text)
        for i in range(0, length):
            char_code = self.__character_code(text[i])
            if char_code < 0:
                char_code = 32
            result = result + (char_code,)

        return result

    def __character_code(self, character):
        result = -1
        try:
            result = TRANZ_DICT[character]
        finally:
            return result

    def __bring_string_to_length(self, text, length):
        result = ()
        string_length = len(text)
        for i in range(length):
            if i < string_length:
                if i == length - 1:
                    result = result + ('>',)
                else:
                    result = result + (text[i],)
            else:
                result = result + (' ',)

        return result

    def __string_from_number_with_length(self, number, length):
        result = ()
        text = str(number)
        for i in range(len(text)):
            result = result + (text[i],)

        if len(result) < length:
            for i in range(length - len(result)):
                result = (' ',) + result

        return result
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/TriggerFinger/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
VOLUME_CONTROLS = GENERIC_SLIDERS
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': -1,
 'PREVBANK': -1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
PAD_TRANSLATION = ((0, 0, 49, 9),
 (1, 0, 57, 9),
 (2, 0, 51, 9),
 (3, 0, 53, 9),
 (0, 1, 56, 9),
 (1, 1, 39, 9),
 (2, 1, 42, 9),
 (3, 1, 46, 9),
 (0, 2, 50, 9),
 (1, 2, 48, 9),
 (2, 2, 45, 9),
 (3, 2, 41, 9),
 (0, 3, 36, 9),
 (1, 3, 38, 9),
 (2, 3, 40, 9),
 (3, 3, 37, 9))
CONTROLLER_DESCRIPTIONS = {'INPUTPORT': 'Trigger',
 'OUTPUTPORT': 'Trigger',
 'CHANNEL': 9,
 'PAD_TRANSLATION': PAD_TRANSLATION}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': 7}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/TriggerFinger/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = -1
GENERIC_PLAY = -1
GENERIC_REC = -1
GENERIC_LOOP = -1
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 91
GENERIC_ENC2 = 93
GENERIC_ENC3 = 71
GENERIC_ENC4 = 72
GENERIC_ENC5 = 10
GENERIC_ENC6 = 12
GENERIC_ENC7 = 5
GENERIC_ENC8 = 84
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = -1
GENERIC_SLI2 = -1
GENERIC_SLI3 = -1
GENERIC_SLI4 = -1
GENERIC_SLI5 = -1
GENERIC_SLI6 = -1
GENERIC_SLI7 = -1
GENERIC_SLI8 = -1
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/UC33e/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = ((GENERIC_ENC1, 0),
 (GENERIC_ENC2, 1),
 (GENERIC_ENC3, 2),
 (GENERIC_ENC4, 3),
 (GENERIC_ENC5, 4),
 (GENERIC_ENC6, 5),
 (GENERIC_ENC7, 6),
 (GENERIC_ENC8, 7))
VOLUME_CONTROLS = ((GENERIC_SLI1, 0),
 (GENERIC_SLI2, 1),
 (GENERIC_SLI3, 2),
 (GENERIC_SLI4, 3),
 (GENERIC_SLI5, 4),
 (GENERIC_SLI6, 5),
 (GENERIC_SLI7, 6),
 (GENERIC_SLI8, 7))
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': GENERIC_PAD5,
 'PREVBANK': GENERIC_PAD1,
 'BANK1': -1,
 'BANK2': -1,
 'BANK3': -1,
 'BANK4': -1,
 'BANK5': -1,
 'BANK6': -1,
 'BANK7': -1,
 'BANK8': -1}
CONTROLLER_DESCRIPTIONS = {'INPUTPORT': 'UC-33 USB MIDI Controller (Port 1)',
 'OUTPUTPORT': 'UC-33 USB MIDI Controller (Port 1)',
 'CHANNEL': 0}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': (-1, -1, -1, -1, -1, -1, -1, -1),
 'SEND2': (-1, -1, -1, -1, -1, -1, -1, -1),
 'MASTERVOLUME': 28}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/UC33e/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = -1
GENERIC_PLAY = -1
GENERIC_REC = -1
GENERIC_LOOP = -1
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 13
GENERIC_ENC2 = 13
GENERIC_ENC3 = 13
GENERIC_ENC4 = 13
GENERIC_ENC5 = 13
GENERIC_ENC6 = 13
GENERIC_ENC7 = 13
GENERIC_ENC8 = 13
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 7
GENERIC_SLI2 = 7
GENERIC_SLI3 = 7
GENERIC_SLI4 = 7
GENERIC_SLI5 = 7
GENERIC_SLI6 = 7
GENERIC_SLI7 = 7
GENERIC_SLI8 = 7
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = VCM600
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/VCM600/VCM600.py
from __future__ import with_statement
import Live
from _Framework.ControlSurface import ControlSurface
from _Framework.InputControlElement import *
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import EncoderElement
from _Framework.ChannelStripComponent import ChannelStripComponent
from _Framework.MixerComponent import MixerComponent
from _Framework.DeviceComponent import DeviceComponent
from _Framework.TransportComponent import TransportComponent
from _Framework.ClipSlotComponent import ClipSlotComponent
from _Framework.SceneComponent import SceneComponent
from _Framework.SessionComponent import SessionComponent
from _Framework.SessionZoomingComponent import SessionZoomingComponent
from _Framework.ChannelTranslationSelector import ChannelTranslationSelector
from ViewTogglerComponent import ViewTogglerComponent
NUM_TRACKS = 12

class VCM600(ControlSurface):
    """ Script for Vestax's VCM600 Controller """

    def __init__(self, c_instance):
        ControlSurface.__init__(self, c_instance)
        with self.component_guard():
            self._setup_session_control()
            self._setup_mixer_control()
            self._setup_device_control()
            self._setup_transport_control()
            self._setup_view_control()

    def _setup_session_control(self):
        is_momentary = True
        down_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 12, 89)
        up_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 12, 90)
        session = SessionComponent(NUM_TRACKS, 0)
        session.set_select_buttons(down_button, up_button)
        session.selected_scene().set_launch_button(ButtonElement(is_momentary, MIDI_NOTE_TYPE, 12, 87))
        track_stop_buttons = [ ButtonElement(is_momentary, MIDI_NOTE_TYPE, index, 68) for index in range(NUM_TRACKS) ]
        session.set_stop_track_clip_buttons(tuple(track_stop_buttons))
        for index in range(NUM_TRACKS):
            session.selected_scene().clip_slot(index).set_launch_button(ButtonElement(is_momentary, MIDI_NOTE_TYPE, index, 69))

    def _setup_mixer_control(self):
        is_momentary = True
        mixer = MixerComponent(NUM_TRACKS, 2, with_eqs=True, with_filters=True)
        for track in range(NUM_TRACKS):
            strip = mixer.channel_strip(track)
            strip.set_volume_control(SliderElement(MIDI_CC_TYPE, track, 23))
            strip.set_pan_control(EncoderElement(MIDI_CC_TYPE, track, 10, Live.MidiMap.MapMode.absolute))
            strip.set_send_controls((EncoderElement(MIDI_CC_TYPE, track, 19, Live.MidiMap.MapMode.absolute), EncoderElement(MIDI_CC_TYPE, track, 20, Live.MidiMap.MapMode.absolute)))
            strip.set_solo_button(ButtonElement(is_momentary, MIDI_NOTE_TYPE, track, 64))
            strip.set_mute_button(ButtonElement(is_momentary, MIDI_NOTE_TYPE, track, 63))
            strip.set_crossfade_toggle(ButtonElement(is_momentary, MIDI_NOTE_TYPE, track, 65))
            eq = mixer.track_eq(track)
            eq.set_gain_controls(tuple([ EncoderElement(MIDI_CC_TYPE, track, 18 - index, Live.MidiMap.MapMode.absolute) for index in range(3) ]))
            eq.set_cut_buttons(tuple([ ButtonElement(is_momentary, MIDI_NOTE_TYPE, track, 62 - index) for index in range(3) ]))
            filter = mixer.track_filter(track)
            filter.set_filter_controls(EncoderElement(MIDI_CC_TYPE, track, 22, Live.MidiMap.MapMode.absolute), EncoderElement(MIDI_CC_TYPE, track, 21, Live.MidiMap.MapMode.absolute))

        for ret_track in range(2):
            strip = mixer.return_strip(ret_track)
            strip.set_volume_control(SliderElement(MIDI_CC_TYPE, 12, 22 + ret_track))
            strip.set_pan_control(EncoderElement(MIDI_CC_TYPE, 12, 20 + ret_track, Live.MidiMap.MapMode.absolute))
            strip.set_mute_button(ButtonElement(is_momentary, MIDI_NOTE_TYPE, 12, 78 + ret_track))

        mixer.set_crossfader_control(SliderElement(MIDI_CC_TYPE, 12, 8))
        mixer.set_prehear_volume_control(EncoderElement(MIDI_CC_TYPE, 12, 24, Live.MidiMap.MapMode.absolute))
        mixer.master_strip().set_volume_control(SliderElement(MIDI_CC_TYPE, 12, 7))
        mixer.master_strip().set_pan_control(EncoderElement(MIDI_CC_TYPE, 12, 10, Live.MidiMap.MapMode.absolute))
        return mixer

    def _setup_device_control(self):
        is_momentary = True
        device_bank_buttons = []
        device_param_controls = []
        for index in range(8):
            device_bank_buttons.append(ButtonElement(is_momentary, MIDI_NOTE_TYPE, 12, 70 + index))
            device_param_controls.append(EncoderElement(MIDI_CC_TYPE, 12, 12 + index, Live.MidiMap.MapMode.absolute))

        device = DeviceComponent()
        device.set_bank_buttons(tuple(device_bank_buttons))
        device.set_parameter_controls(tuple(device_param_controls))
        device_translation_selector = ChannelTranslationSelector()
        device_translation_selector.set_controls_to_translate(tuple(device_param_controls))
        device_translation_selector.set_mode_buttons(tuple(device_bank_buttons))
        self.set_device_component(device)

    def _setup_transport_control(self):
        is_momentary = True
        transport = TransportComponent()
        transport.set_play_button(ButtonElement(is_momentary, MIDI_NOTE_TYPE, 12, 80))
        transport.set_record_button(ButtonElement(is_momentary, MIDI_NOTE_TYPE, 12, 81))
        transport.set_nudge_buttons(ButtonElement(is_momentary, MIDI_NOTE_TYPE, 12, 86), ButtonElement(is_momentary, MIDI_NOTE_TYPE, 12, 85))
        transport.set_loop_button(ButtonElement(is_momentary, MIDI_NOTE_TYPE, 12, 84))
        transport.set_punch_buttons(ButtonElement(is_momentary, MIDI_NOTE_TYPE, 12, 82), ButtonElement(is_momentary, MIDI_NOTE_TYPE, 12, 83))
        transport.set_tempo_control(SliderElement(MIDI_CC_TYPE, 12, 26), SliderElement(MIDI_CC_TYPE, 12, 25))

    def _setup_view_control(self):
        is_momentary = True
        view = ViewTogglerComponent(NUM_TRACKS)
        view.set_buttons(tuple([ ButtonElement(is_momentary, MIDI_NOTE_TYPE, track, 67) for track in range(NUM_TRACKS) ]), tuple([ ButtonElement(is_momentary, MIDI_NOTE_TYPE, track, 66) for track in range(NUM_TRACKS) ]))
########NEW FILE########
__FILENAME__ = ViewTogglerComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/VCM600/ViewTogglerComponent.py
import Live
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.ButtonElement import ButtonElement

class ViewTogglerComponent(ControlSurfaceComponent):
    """ Component that can toggle the device chain- and clip view of a number of tracks """

    def __init__(self, num_tracks):
        raise num_tracks > 0 or AssertionError
        ControlSurfaceComponent.__init__(self)
        self._num_tracks = num_tracks
        self._chain_buttons = None
        self._clip_buttons = None
        self._ignore_track_selection = False
        self.application().view.add_is_view_visible_listener('Detail', self._on_detail_view_changed)
        self.application().view.add_is_view_visible_listener('Detail/Clip', self._on_views_changed)

    def disconnect(self):
        self.application().view.remove_is_view_visible_listener('Detail', self._on_detail_view_changed)
        self.application().view.remove_is_view_visible_listener('Detail/Clip', self._on_views_changed)
        if self._chain_buttons != None:
            for button in self._chain_buttons:
                button.remove_value_listener(self._chain_value)

            self._chain_buttons = None
        if self._clip_buttons != None:
            for button in self._clip_buttons:
                button.remove_value_listener(self._clip_value)

            self._clip_buttons = None

    def set_buttons(self, chain_buttons, clip_buttons):
        raise chain_buttons == None or isinstance(chain_buttons, tuple) and len(chain_buttons) == self._num_tracks or AssertionError
        raise clip_buttons == None or isinstance(clip_buttons, tuple) and len(clip_buttons) == self._num_tracks or AssertionError
        if self._chain_buttons != None:
            for button in self._chain_buttons:
                button.remove_value_listener(self._chain_value)

        self._chain_buttons = chain_buttons
        if self._chain_buttons != None:
            for button in self._chain_buttons:
                raise isinstance(button, ButtonElement) or AssertionError
                button.add_value_listener(self._chain_value, identify_sender=True)

        if self._clip_buttons != None:
            for button in self._clip_buttons:
                button.remove_value_listener(self._clip_value)

        self._clip_buttons = clip_buttons
        if self._clip_buttons != None:
            for button in self._clip_buttons:
                raise isinstance(button, ButtonElement) or AssertionError
                button.add_value_listener(self._clip_value, identify_sender=True)

        self.on_selected_track_changed()

    def on_selected_track_changed(self):
        self._update_buttons()

    def on_enabled_changed(self):
        self.update()

    def update(self):
        if self.is_enabled():
            self._update_buttons()
        else:
            if self._chain_buttons != None:
                for button in self._chain_buttons:
                    button.turn_off()

            if self._clip_buttons != None:
                for button in self._clip_buttons:
                    button.turn_off()

    def _on_detail_view_changed(self):
        self._update_buttons()

    def _on_views_changed(self):
        self._update_buttons()

    def _update_buttons(self):
        tracks = self.song().visible_tracks
        for index in range(self._num_tracks):
            if len(tracks) > index and tracks[index] == self.song().view.selected_track and self.application().view.is_view_visible('Detail'):
                if self.application().view.is_view_visible('Detail/DeviceChain'):
                    self._chain_buttons[index].turn_on()
                else:
                    self._chain_buttons[index].turn_off()
                if self.application().view.is_view_visible('Detail/Clip'):
                    self._clip_buttons[index].turn_on()
                else:
                    self._clip_buttons[index].turn_off()
            else:
                if self._chain_buttons != None:
                    self._chain_buttons[index].turn_off()
                if self._clip_buttons != None:
                    self._clip_buttons[index].turn_off()

    def _chain_value(self, value, sender):
        raise sender in self._chain_buttons or AssertionError
        tracks = self.song().visible_tracks
        if not sender.is_momentary() or value != 0:
            index = list(self._chain_buttons).index(sender)
            self._ignore_track_selection = True
            if len(tracks) > index:
                if self.song().view.selected_track != tracks[index]:
                    self.song().view.selected_track = tracks[index]
                    if not self.application().view.is_view_visible('Detail') or not self.application().view.is_view_visible('Detail/DeviceChain'):
                        self.application().view.show_view('Detail')
                        self.application().view.show_view('Detail/DeviceChain')
                elif self.application().view.is_view_visible('Detail/DeviceChain') and self.application().view.is_view_visible('Detail'):
                    self.application().view.hide_view('Detail')
                else:
                    self.application().view.show_view('Detail')
                    self.application().view.show_view('Detail/DeviceChain')
            self._ignore_track_selection = False

    def _clip_value(self, value, sender):
        raise sender in self._clip_buttons or AssertionError
        tracks = self.song().visible_tracks
        if not sender.is_momentary() or value != 0:
            index = list(self._clip_buttons).index(sender)
            self._ignore_track_selection = True
            if len(tracks) > index:
                if self.song().view.selected_track != tracks[index]:
                    self.song().view.selected_track = tracks[index]
                    if not self.application().view.is_view_visible('Detail') or not self.application().view.is_view_visible('Detail/Clip'):
                        self.application().view.show_view('Detail')
                        self.application().view.show_view('Detail/Clip')
                elif self.application().view.is_view_visible('Detail/Clip') and self.application().view.is_view_visible('Detail'):
                    self.application().view.hide_view('Detail')
                else:
                    self.application().view.show_view('Detail')
                    self.application().view.show_view('Detail/Clip')
            self._ignore_track_selection = False
########NEW FILE########
__FILENAME__ = config
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/ZERO8/config.py
from consts import *
TRANSPORT_CONTROLS = {'STOP': GENERIC_STOP,
 'PLAY': GENERIC_PLAY,
 'REC': GENERIC_REC,
 'LOOP': GENERIC_LOOP,
 'RWD': GENERIC_RWD,
 'FFWD': GENERIC_FFWD}
DEVICE_CONTROLS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
VOLUME_CONTROLS = ((GENERIC_SLI1, 0),
 (GENERIC_SLI2, 1),
 (GENERIC_SLI3, 2),
 (GENERIC_SLI4, 3),
 (GENERIC_SLI5, 4),
 (GENERIC_SLI6, 5),
 (GENERIC_SLI7, 6),
 (GENERIC_SLI8, 7))
TRACKARM_CONTROLS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
BANK_CONTROLS = {'TOGGLELOCK': GENERIC_BUT9,
 'BANKDIAL': -1,
 'NEXTBANK': GENERIC_PAD5,
 'PREVBANK': GENERIC_PAD1,
 'BANK1': 80,
 'BANK2': 81,
 'BANK3': 82,
 'BANK4': 83,
 'BANK5': 84,
 'BANK6': 85,
 'BANK7': 86,
 'BANK8': 87}
CONTROLLER_DESCRIPTION = {'INPUTPORT': 'ZERO8 MIDI IN 2',
 'OUTPUTPORT': 'ZERO8 MIDI OUT 2',
 'CHANNEL': 0}
MIXER_OPTIONS = {'NUMSENDS': 2,
 'SEND1': ((5, 0),
           (5, 1),
           (5, 2),
           (5, 3),
           (5, 4),
           (5, 5),
           (5, 6),
           (5, 7)),
 'SEND2': ((6, 0),
           (6, 1),
           (6, 2),
           (6, 3),
           (6, 4),
           (6, 5),
           (6, 6),
           (6, 7)),
 'PANS': ((4, 0),
          (4, 1),
          (4, 2),
          (4, 3),
          (4, 4),
          (4, 5),
          (4, 6),
          (4, 7)),
 'MASTERVOLUME': -1}
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/ZERO8/consts.py
""" The following consts should be substituted with the Sys Ex messages for requesting
a controller's ID response and that response to allow for automatic lookup"""
ID_REQUEST = 0
ID_RESP = 0
GENERIC_STOP = -1
GENERIC_PLAY = -1
GENERIC_REC = -1
GENERIC_LOOP = -1
GENERIC_RWD = -1
GENERIC_FFWD = -1
GENERIC_TRANSPORT = (GENERIC_STOP,
 GENERIC_PLAY,
 GENERIC_REC,
 GENERIC_LOOP,
 GENERIC_RWD,
 GENERIC_FFWD)
GENERIC_ENC1 = 64
GENERIC_ENC2 = 65
GENERIC_ENC3 = 66
GENERIC_ENC4 = 67
GENERIC_ENC5 = 68
GENERIC_ENC6 = 69
GENERIC_ENC7 = 70
GENERIC_ENC8 = 71
GENERIC_ENCODERS = (GENERIC_ENC1,
 GENERIC_ENC2,
 GENERIC_ENC3,
 GENERIC_ENC4,
 GENERIC_ENC5,
 GENERIC_ENC6,
 GENERIC_ENC7,
 GENERIC_ENC8)
GENERIC_SLI1 = 11
GENERIC_SLI2 = 11
GENERIC_SLI3 = 11
GENERIC_SLI4 = 11
GENERIC_SLI5 = 11
GENERIC_SLI6 = 11
GENERIC_SLI7 = 11
GENERIC_SLI8 = 11
GENERIC_SLIDERS = (GENERIC_SLI1,
 GENERIC_SLI2,
 GENERIC_SLI3,
 GENERIC_SLI4,
 GENERIC_SLI5,
 GENERIC_SLI6,
 GENERIC_SLI7,
 GENERIC_SLI8)
GENERIC_BUT1 = -1
GENERIC_BUT2 = -1
GENERIC_BUT3 = -1
GENERIC_BUT4 = -1
GENERIC_BUT5 = -1
GENERIC_BUT6 = -1
GENERIC_BUT7 = -1
GENERIC_BUT8 = -1
GENERIC_BUT9 = -1
GENERIC_BUTTONS = (GENERIC_BUT1,
 GENERIC_BUT2,
 GENERIC_BUT3,
 GENERIC_BUT4,
 GENERIC_BUT5,
 GENERIC_BUT6,
 GENERIC_BUT7,
 GENERIC_BUT8)
GENERIC_PAD1 = -1
GENERIC_PAD2 = -1
GENERIC_PAD3 = -1
GENERIC_PAD4 = -1
GENERIC_PAD5 = -1
GENERIC_PAD6 = -1
GENERIC_PAD7 = -1
GENERIC_PAD8 = -1
GENERIC_PADS = (GENERIC_PAD1,
 GENERIC_PAD2,
 GENERIC_PAD3,
 GENERIC_PAD4,
 GENERIC_PAD5,
 GENERIC_PAD6,
 GENERIC_PAD7,
 GENERIC_PAD8)
########NEW FILE########
__FILENAME__ = consts
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Axiom/consts.py
NOTE_OFF_STATUS = 128
NOTE_ON_STATUS = 144
CC_STATUS = 176
NUM_NOTES = 128
NUM_CC_NO = 128
NUM_CHANNELS = 16
EXP_PEDAL_CC = 11
SYSEX_BEGIN = (240, 126, 127, 6)
SYSEX_END = (247,)
ID_REQUEST = (1,)
ID_RESP_BEGIN = (2, 0, 32, 8, 99, 14)
ID_RESP_25 = 24
ID_RESP_49 = 25
ID_RESP_61 = 26
AXIOM_LOOP = 20
AXIOM_RWD = 21
AXIOM_FFWD = 22
AXIOM_STOP = 23
AXIOM_PLAY = 24
AXIOM_REC = 25
AXIOM_TRANSPORT = (AXIOM_LOOP,
 AXIOM_RWD,
 AXIOM_FFWD,
 AXIOM_STOP,
 AXIOM_PLAY,
 AXIOM_REC)
AXIOM_ENC1 = 102
AXIOM_ENC2 = 103
AXIOM_ENC3 = 104
AXIOM_ENC4 = 105
AXIOM_ENC5 = 106
AXIOM_ENC6 = 107
AXIOM_ENC7 = 108
AXIOM_ENC8 = 109
AXIOM_ENCODERS = (AXIOM_ENC1,
 AXIOM_ENC2,
 AXIOM_ENC3,
 AXIOM_ENC4,
 AXIOM_ENC5,
 AXIOM_ENC6,
 AXIOM_ENC7,
 AXIOM_ENC8)
AXIOM_SLI1 = 110
AXIOM_SLI2 = 111
AXIOM_SLI3 = 112
AXIOM_SLI4 = 113
AXIOM_SLI5 = 114
AXIOM_SLI6 = 115
AXIOM_SLI7 = 116
AXIOM_SLI8 = 117
AXIOM_SLI9 = 118
AXIOM_SLIDERS = (AXIOM_SLI1,
 AXIOM_SLI2,
 AXIOM_SLI3,
 AXIOM_SLI4,
 AXIOM_SLI5,
 AXIOM_SLI6,
 AXIOM_SLI7,
 AXIOM_SLI8)
AXIOM_BUT1 = 52
AXIOM_BUT2 = 53
AXIOM_BUT3 = 54
AXIOM_BUT4 = 55
AXIOM_BUT5 = 56
AXIOM_BUT6 = 57
AXIOM_BUT7 = 58
AXIOM_BUT8 = 59
AXIOM_BUT9 = 60
AXIOM_BUTTONS = (AXIOM_BUT1,
 AXIOM_BUT2,
 AXIOM_BUT3,
 AXIOM_BUT4,
 AXIOM_BUT5,
 AXIOM_BUT6,
 AXIOM_BUT7,
 AXIOM_BUT8,
 AXIOM_BUT9)
AXIOM_PAD1 = 80
AXIOM_PAD2 = 81
AXIOM_PAD3 = 82
AXIOM_PAD4 = 83
AXIOM_PAD5 = 85
AXIOM_PAD6 = 86
AXIOM_PAD7 = 87
AXIOM_PAD8 = 88
AXIOM_PADS = (AXIOM_PAD1,
 AXIOM_PAD2,
 AXIOM_PAD3,
 AXIOM_PAD4,
 AXIOM_PAD5,
 AXIOM_PAD6,
 AXIOM_PAD7,
 AXIOM_PAD8)
PAD_TRANSLATION = ((0, 2, 67, 9),
 (1, 2, 69, 9),
 (2, 2, 71, 9),
 (3, 2, 72, 9),
 (0, 3, 60, 9),
 (1, 3, 62, 9),
 (2, 3, 64, 9),
 (3, 3, 65, 9))
########NEW FILE########
__FILENAME__ = Encoders
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Axiom/Encoders.py
import Live
from consts import *
from _Generic.Devices import *

class Encoders:
    """ Class representing the Encoder section on the Axiom controllers """

    def __init__(self, parent, extended):
        self.__parent = parent
        self.__bank = 0
        self.__selected_device = None
        self.__extended = extended
        self.__modifier = False
        self.__device_locked = False
        self.__show_bank = False

    def disconnect(self):
        if self.__selected_device != None:
            self.__selected_device.remove_parameters_listener(self.__on_device_parameters_changed)
            self.__selected_device = None

    def build_midi_map(self, script_handle, midi_map_handle):
        tracks = self.__parent.song().visible_tracks
        feedback_rule = Live.MidiMap.CCFeedbackRule()
        for channel in range(4):
            for encoder in range(8):
                track_index = encoder + channel * 8
                if len(tracks) > track_index:
                    feedback_rule.channel = 0
                    feedback_rule.cc_no = AXIOM_ENCODERS[encoder]
                    feedback_rule.cc_value_map = tuple()
                    feedback_rule.delay_in_ms = -1.0
                    if self.__extended or self.__modifier:
                        device_parameter = tracks[track_index].mixer_device.panning
                    else:
                        device_parameter = tracks[track_index].mixer_device.volume
                    avoid_takeover = True
                    Live.MidiMap.map_midi_cc_with_feedback_map(midi_map_handle, device_parameter, channel, AXIOM_ENCODERS[encoder], Live.MidiMap.MapMode.relative_smooth_binary_offset, feedback_rule, not avoid_takeover)
                else:
                    break

        self.__connect_to_device(midi_map_handle)

    def set_modifier(self, mod_state):
        self.__modifier = mod_state

    def __connect_to_device(self, midi_map_handle):
        feedback_rule = Live.MidiMap.CCFeedbackRule()
        assignment_necessary = True
        avoid_takeover = True
        if not self.__selected_device == None:
            device_parameters = self.__selected_device.parameters[1:]
            device_bank = 0
            param_bank = 0
            if self.__selected_device.class_name in DEVICE_DICT.keys():
                device_bank = DEVICE_DICT[self.__selected_device.class_name]
                if len(device_bank) > self.__bank:
                    param_bank = device_bank[self.__bank]
                else:
                    assignment_necessary = False
            if assignment_necessary:
                if self.__show_bank:
                    self.__show_bank = False
                    if self.__selected_device.class_name in DEVICE_DICT.keys():
                        if len(list(DEVICE_DICT[self.__selected_device.class_name])) > 1:
                            if self.__selected_device.class_name in BANK_NAME_DICT.keys():
                                bank_names = BANK_NAME_DICT[self.__selected_device.class_name]
                                if bank_names and len(bank_names) > self.__bank:
                                    bank_name = bank_names[self.__bank]
                                    self.__show_bank_select(bank_name)
                            else:
                                self.__show_bank_select('Best of Parameters')
                        else:
                            self.__show_bank_select('Bank' + str(self.__bank + 1))
                free_encoders = 0
                for encoder in range(8):
                    parameter_index = encoder + self.__bank * 8
                    if len(device_parameters) + free_encoders >= parameter_index:
                        feedback_rule.channel = 0
                        feedback_rule.cc_no = AXIOM_ENCODERS[encoder]
                        feedback_rule.cc_value_map = tuple()
                        feedback_rule.delay_in_ms = -1.0
                        parameter = 0
                        if param_bank:
                            if param_bank[encoder] != '':
                                parameter = get_parameter_by_name(self.__selected_device, param_bank[encoder])
                            else:
                                free_encoders += 1
                        elif len(device_parameters) > parameter_index:
                            parameter = device_parameters[parameter_index]
                        if parameter:
                            Live.MidiMap.map_midi_cc_with_feedback_map(midi_map_handle, parameter, 15, AXIOM_ENCODERS[encoder], Live.MidiMap.MapMode.relative_smooth_binary_offset, feedback_rule, not avoid_takeover)
                        elif not param_bank:
                            break
                    else:
                        break

    def receive_midi_cc(self, cc_no, cc_value, channel):
        pass

    def lock_to_device(self, device):
        if device:
            self.__device_locked = True
            self.__change_appointed_device(device)

    def unlock_from_device(self, device):
        if device and device == self.__selected_device:
            self.__device_locked = False
            if not self.__parent.song().appointed_device == self.__selected_device:
                self.__parent.request_rebuild_midi_map()

    def set_appointed_device(self, device):
        if self.__device_locked:
            self.__device_locked = False
        self.__change_appointed_device(device)

    def set_bank(self, new_bank):
        result = False
        if self.__selected_device:
            if number_of_parameter_banks(self.__selected_device) > new_bank:
                self.__show_bank = True
                if not self.__device_locked:
                    self.__bank = new_bank
                    result = True
                else:
                    self.__selected_device.store_chosen_bank(self.__parent.instance_identifier(), new_bank)
        return result

    def restore_bank(self, new_bank):
        self.__bank = new_bank
        self.__show_bank = True

    def reset_bank(self):
        self.__bank = 0

    def __show_bank_select(self, bank_name):
        if self.__selected_device:
            self.__parent.show_message(str(self.__selected_device.name + ' Bank: ' + bank_name))

    def __change_appointed_device(self, device):
        if not device == self.__selected_device:
            if self.__selected_device != None:
                self.__selected_device.remove_parameters_listener(self.__on_device_parameters_changed)
            if device != None:
                device.add_parameters_listener(self.__on_device_parameters_changed)
            self.__bank = 0
        self.__show_bank = False
        self.__selected_device = device
        self.__parent.request_rebuild_midi_map()

    def __on_device_parameters_changed(self):
        self.__parent.request_rebuild_midi_map()
########NEW FILE########
__FILENAME__ = Pads
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Axiom/Pads.py
import Live
from consts import *

class Pads:
    """ Class representing the Pads section on the Axiom controllers """

    def __init__(self, parent):
        self.__parent = parent

    def build_midi_map(self, script_handle, midi_map_handle):
        for channel in range(4):
            for pad in range(8):
                Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, channel, AXIOM_PADS[pad])

        for pad in range(8):
            Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, 15, AXIOM_PADS[pad])

    def receive_midi_cc(self, cc_no, cc_value, channel):
        if list(AXIOM_PADS).count(cc_no) > 0:
            pad_index = list(AXIOM_PADS).index(cc_no)
            index = pad_index + channel * 8
            if cc_value > 0:
                if channel in range(4):
                    if self.__parent.application().view.is_view_visible('Session'):
                        tracks = self.__parent.song().visible_tracks
                        if len(tracks) > index:
                            current_track = tracks[index]
                            clip_index = list(self.__parent.song().scenes).index(self.__parent.song().view.selected_scene)
                            current_track.clip_slots[clip_index].fire()
                    elif self.__parent.application().view.is_view_visible('Arranger'):
                        if len(self.__parent.song().cue_points) > index:
                            self.__parent.song().cue_points[index].jump()
                elif channel == 15:
                    self.__parent.bank_changed(pad_index)
########NEW FILE########
__FILENAME__ = Transport
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Axiom/Transport.py
import Live
from consts import *

class Transport:
    """ Class representing the transport section on the Axiom controllers """

    def __init__(self, parent):
        self.__parent = parent
        self.__ffwd_held = False
        self.__rwd_held = False
        self.__delay_counter = 0

    def build_midi_map(self, script_handle, midi_map_handle):
        for cc_no in AXIOM_TRANSPORT:
            Live.MidiMap.forward_midi_cc(script_handle, midi_map_handle, 15, cc_no)

    def receive_midi_cc(self, cc_no, cc_value):
        if cc_no == AXIOM_STOP:
            if cc_value > 0:
                self.__parent.song().is_playing = False
        elif cc_no == AXIOM_PLAY:
            if cc_value > 0:
                self.__parent.song().is_playing = True
        elif cc_no == AXIOM_REC:
            if cc_value > 0:
                self.__parent.song().record_mode = not self.__parent.song().record_mode
        elif self.__parent.application().view.is_view_visible('Session'):
            if cc_value > 0:
                self.__cc_in_session(cc_no)
        else:
            self.__cc_in_arranger(cc_no, cc_value)

    def __cc_in_session(self, cc_no):
        index = list(self.__parent.song().scenes).index(self.__parent.song().view.selected_scene)
        if cc_no == AXIOM_LOOP:
            self.__parent.song().view.selected_scene.fire_as_selected()
        elif cc_no == AXIOM_RWD:
            if index > 0:
                index = index - 1
                self.__parent.song().view.selected_scene = self.__parent.song().scenes[index]
        elif cc_no == AXIOM_FFWD:
            if index < len(self.__parent.song().scenes) - 1:
                index = index + 1
                self.__parent.song().view.selected_scene = self.__parent.song().scenes[index]

    def __cc_in_arranger(self, cc_no, cc_value):
        if cc_no == AXIOM_LOOP:
            if cc_value > 0:
                self.__parent.song().loop = not self.__parent.song().loop
        elif cc_no == AXIOM_RWD:
            if not self.__ffwd_held:
                if cc_value > 0:
                    self.__rwd_held = True
                    self.__delay_counter = 0
                    self.__parent.song().jump_by(-1 * self.__parent.song().signature_denominator)
                else:
                    self.__rwd_held = False
        elif cc_no == AXIOM_FFWD:
            if not self.__rwd_held:
                if cc_value > 0:
                    self.__ffwd_held = True
                    self.__delay_counter = 0
                    self.__parent.song().jump_by(self.__parent.song().signature_denominator)
                else:
                    self.__ffwd_held = False

    def refresh_state(self):
        if self.__ffwd_held:
            self.__delay_counter += 1
            if self.__delay_counter % 5 == 0:
                self.__parent.song().jump_by(self.__parent.song().signature_denominator)
        if self.__rwd_held:
            self.__delay_counter += 1
            if self.__delay_counter % 5 == 0:
                self.__parent.song().jump_by(-1 * self.__parent.song().signature_denominator)
########NEW FILE########
__FILENAME__ = ButtonElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/ButtonElement.py
import Live
from InputControlElement import InputControlElement, MIDI_CC_TYPE
from Util import nop

class ButtonValue(object):
    """
    Basic type for button values, so global constants are symbolically
    different from integers.
    """
    midi_value = 0

    def __init__(self, midi_value = None, *a, **k):
        super(ButtonValue, self).__init__(*a, **k)
        if midi_value is not None:
            self.midi_value = midi_value

    def __int__(self):
        return self.midi_value

    def __eq__(self, other):
        try:
            return id(self) == id(other) or self.midi_value == other
        except NotImplementedError:
            return False

    def __ne__(self, other):
        return not self.__eq__(other)


ON_VALUE = ButtonValue(127)
OFF_VALUE = ButtonValue(0)

class DummyUndoStepHandler(object):

    def begin_undo_step(self):
        pass

    def end_undo_step(self):
        pass


class ButtonElementMixin(object):
    """
    Mixin for sending values to button-like control-elements elements.
    """

    def set_light(self, is_turned_on):
        if is_turned_on:
            self.turn_on()
        else:
            self.turn_off()

    def turn_on(self):
        self.send_value(ON_VALUE)

    def turn_off(self):
        self.send_value(OFF_VALUE)


class ButtonElement(InputControlElement, ButtonElementMixin):
    """
    Class representing a button a the controller
    """

    class ProxiedInterface(InputControlElement.ProxiedInterface, ButtonElementMixin):
        is_momentary = nop
        is_pressed = nop

    def __init__(self, is_momentary, msg_type, channel, identifier, undo_step_handler = DummyUndoStepHandler(), *a, **k):
        super(ButtonElement, self).__init__(msg_type, channel, identifier, *a, **k)
        self.__is_momentary = bool(is_momentary)
        self._last_received_value = -1
        self._undo_step_handler = undo_step_handler

    def is_momentary(self):
        """ returns true if the buttons sends a message on being released """
        return self.__is_momentary

    def message_map_mode(self):
        raise self.message_type() is MIDI_CC_TYPE or AssertionError
        return Live.MidiMap.MapMode.absolute

    def is_pressed(self):
        return self.__is_momentary and int(self._last_received_value) > 0

    def receive_value(self, value):
        pressed_before = self.is_pressed()
        self._last_received_value = value
        if not pressed_before and self.is_pressed():
            self._undo_step_handler.begin_undo_step()
        super(ButtonElement, self).receive_value(value)
        if pressed_before and not self.is_pressed():
            self._undo_step_handler.end_undo_step()
########NEW FILE########
__FILENAME__ = ButtonMatrixElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/ButtonMatrixElement.py
from CompoundElement import CompoundElement
from Util import in_range, product, const, slicer, to_slice

class ButtonMatrixElement(CompoundElement):
    """
    Class representing a 2-dimensional set of buttons.
    
    When using as a resource, buttons might be individually grabbed at
    any time by other components. The matrix will automatically block
    messages coming from or sent to a button owned by them, and will
    return None when you try to query it.
    """

    def __init__(self, rows = [], *a, **k):
        super(ButtonMatrixElement, self).__init__(*a, **k)
        self._buttons = []
        self._orig_buttons = []
        self._button_coordinates = {}
        self._max_row_width = 0
        map(self.add_row, rows)

    @property
    @slicer(2)
    def submatrix(self, col_slice, row_slice):
        col_slice = to_slice(col_slice)
        row_slice = to_slice(row_slice)
        rows = [ row[col_slice] for row in self._orig_buttons[row_slice] ]
        return ButtonMatrixElement(rows=rows)

    def add_row(self, buttons):
        self._buttons.append([None] * len(buttons))
        self._orig_buttons.append(buttons)
        for index, button in enumerate(buttons):
            self._button_coordinates[button] = (index, len(self._buttons) - 1)
            self.register_control_element(button)

        if self._max_row_width < len(buttons):
            self._max_row_width = len(buttons)

    def width(self):
        return self._max_row_width

    def height(self):
        return len(self._buttons)

    def send_value(self, column, row, value, force = False):
        if not in_range(value, 0, 128):
            raise AssertionError
            raise in_range(column, 0, self.width()) or AssertionError
            if not in_range(row, 0, self.height()):
                raise AssertionError
                button = len(self._buttons[row]) > column and self._buttons[row][column]
                button and button.send_value(value, force=force)

    def set_light(self, column, row, value):
        if not in_range(column, 0, self.width()):
            raise AssertionError
            if not in_range(row, 0, self.height()):
                raise AssertionError
                button = len(self._buttons[row]) > column and self._buttons[row][column]
                button and button.set_light(value)

    def get_button(self, column, row):
        if not in_range(column, 0, self.width()):
            raise AssertionError
            raise in_range(row, 0, self.height()) or AssertionError
            return len(self._buttons[row]) > column and self._buttons[row][column]

    def reset(self):
        for button in self:
            if button:
                button.reset()

    def __iter__(self):
        for j, i in product(xrange(self.height()), xrange(self.width())):
            button = self.get_button(i, j)
            yield button

    def __getitem__(self, index):
        if isinstance(index, slice):
            indices = index.indices(len(self))
            return map(self._do_get_item, range(*indices))
        else:
            if index < 0:
                index += len(self)
            return self._do_get_item(index)

    def _do_get_item(self, index):
        raise in_range(index, 0, len(self)) or AssertionError, 'Index out of range'
        row, col = divmod(index, self.width())
        return self.get_button(col, row)

    def __len__(self):
        return self.width() * self.height()

    def iterbuttons(self):
        for j, i in product(xrange(self.height()), xrange(self.width())):
            button = self.get_button(i, j)
            yield (button, (i, j))

    def on_nested_control_element_value(self, value, sender):
        x, y = self._button_coordinates[sender]
        raise self._buttons[y][x] or AssertionError
        is_momentary = getattr(sender, 'is_momentary', const(None))()
        self.notify_value(value, x, y, is_momentary)

    def on_nested_control_element_grabbed(self, control):
        x, y = self._button_coordinates[control]
        self._buttons[y][x] = control

    def on_nested_control_element_released(self, control):
        x, y = self._button_coordinates[control]
        self._buttons[y][x] = None
########NEW FILE########
__FILENAME__ = ButtonSliderElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/ButtonSliderElement.py
from SliderElement import SliderElement
from InputControlElement import InputControlElement, MIDI_INVALID_TYPE
from ButtonElement import ButtonElement

class ButtonSliderElement(SliderElement):
    """ Class representing a set of buttons used as a slider """
    _last_sent_value = -1

    def __init__(self, buttons):
        raise buttons != None or AssertionError
        raise isinstance(buttons, tuple) or AssertionError
        raise len(buttons) > 1 or AssertionError
        SliderElement.__init__(self, MIDI_INVALID_TYPE, 0, 0)
        self._buttons = buttons
        self._last_button_lit = -1
        identify_sender = True
        for new_button in self._buttons:
            raise new_button != None or AssertionError
            raise isinstance(new_button, ButtonElement) or AssertionError
            new_button.add_value_listener(self._button_value, identify_sender)

    def disconnect(self):
        if self._parameter_to_map_to != None:
            self._parameter_to_map_to.remove_value_listener(self._on_parameter_changed)
        SliderElement.disconnect(self)
        self._buttons = None

    def message_channel(self):
        raise NotImplementedError, 'message_channel() should not be called directly on ButtonSliderElement'

    def message_identifier(self):
        raise NotImplementedError, 'message_identifier() should not be called directly on ButtonSliderElement'

    def message_map_mode(self):
        raise NotImplementedError, 'message_map_mode() should not be called directly on ButtonSliderElement'

    def install_connections(self, install_translation_callback, install_mapping_callback, install_forwarding_callback):
        pass

    def connect_to(self, parameter):
        if self._parameter_to_map_to != None:
            self._parameter_to_map_to.remove_value_listener(self._on_parameter_changed)
        InputControlElement.connect_to(self, parameter)
        if self._parameter_to_map_to != None:
            self._parameter_to_map_to.add_value_listener(self._on_parameter_changed)
            self._on_parameter_changed()

    def release_parameter(self):
        if self._parameter_to_map_to != None:
            self._parameter_to_map_to.remove_value_listener(self._on_parameter_changed)
        InputControlElement.release_parameter(self)

    def identifier_bytes(self):
        raise RuntimeWarning, 'identifier_bytes() should not be called on ButtonSliderElement'

    def send_value(self, value):
        if value != self._last_sent_value:
            index_to_light = 0
            if value > 0:
                index_to_light = int((len(self._buttons) - 1) * value / 127)
            for index in xrange(len(self._buttons)):
                if index == index_to_light:
                    self._buttons[index].turn_on()
                else:
                    self._buttons[index].turn_off()

            self._last_sent_value = value
            self._last_button_lit = index_to_light

    def _button_value(self, value, sender):
        self.clear_send_cache()
        if value != 0 or not sender.is_momentary():
            index_of_sender = list(self._buttons).index(sender)
            midi_value = int(127 * index_of_sender / (len(self._buttons) - 1))
            if self._parameter_to_map_to != None and self._parameter_to_map_to.is_enabled:
                param_range = self._parameter_to_map_to.max - self._parameter_to_map_to.min
                param_value = param_range * index_of_sender / (len(self._buttons) - 1) + self._parameter_to_map_to.min
                if index_of_sender > 0:
                    param_value += param_range / (4 * len(self._buttons))
                    if param_value > self._parameter_to_map_to.max:
                        param_value = self._parameter_to_map_to.max
                self._parameter_to_map_to.value = param_value
            self._last_button_lit = index_of_sender
            self.notify_value(midi_value)

    def _on_parameter_changed(self):
        raise self._parameter_to_map_to != None or AssertionError
        param_range = abs(self._parameter_to_map_to.max - self._parameter_to_map_to.min)
        midi_value = int(127 * abs(self._parameter_to_map_to.value - self._parameter_to_map_to.min) / param_range)
        self.send_value(midi_value)
########NEW FILE########
__FILENAME__ = Capabilities
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/Capabilities.py
PORTS_KEY = 'ports'
CONTROLLER_ID_KEY = 'controller_id'
TYPE_KEY = 'surface_type'
FIRMWARE_KEY = 'firmware_version'
AUTO_LOAD_KEY = 'auto_load'
VENDORID = 'vendor_id'
PRODUCTIDS = 'product_ids'
MODEL_NAME = 'model_name'
DIRECTIONKEY = 'direction'
PORTNAMEKEY = 'name'
MACNAMEKEY = 'mac_name'
PROPSKEY = 'props'
HIDDEN = 'hidden'
SYNC = 'sync'
SCRIPT = 'script'
NOTES_CC = 'notes_cc'
REMOTE = 'remote'
PLAIN_OLD_MIDI = 'plain_old_midi'

def __create_port_dict(direction, port_name, mac_name, props):
    if not type(direction) is str:
        raise AssertionError
        raise type(port_name) is str or AssertionError
        raise props == None or type(props) is list or AssertionError
        if props:
            for prop in props:
                raise type(prop) is str or AssertionError

        raise mac_name == None or type(mac_name) is str or AssertionError
        capabilities = {DIRECTIONKEY: direction,
         PORTNAMEKEY: port_name,
         PROPSKEY: props}
        capabilities[MACNAMEKEY] = mac_name and mac_name
    return capabilities


def inport(port_name = '', props = [], mac_name = None):
    """ Generate a ..."""
    return __create_port_dict('in', port_name, mac_name, props)


def outport(port_name = '', props = [], mac_name = None):
    """ Generate a ..."""
    return __create_port_dict('out', port_name, mac_name, props)


def controller_id(vendor_id, product_ids, model_name):
    """ Generate a hardwareId dict"""
    raise type(vendor_id) is int or AssertionError
    raise type(product_ids) is list or AssertionError
    for product_id in product_ids:
        raise type(product_id) is int or AssertionError

    raise type(model_name) is str or AssertionError
    return {VENDORID: vendor_id,
     PRODUCTIDS: product_ids,
     MODEL_NAME: model_name}
########NEW FILE########
__FILENAME__ = ChannelStripComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/ChannelStripComponent.py
import Live
from itertools import chain
from ControlSurfaceComponent import ControlSurfaceComponent
from ButtonElement import ButtonElement
from EncoderElement import EncoderElement
from DisplayDataSource import DisplayDataSource
from _Framework.Util import nop

class ChannelStripComponent(ControlSurfaceComponent):
    """ Class attaching to the mixer of a given track """
    _active_instances = []

    def number_of_arms_pressed():
        result = 0
        for strip in ChannelStripComponent._active_instances:
            if not isinstance(strip, ChannelStripComponent):
                raise AssertionError
                strip.arm_button_pressed() and result += 1

        return result

    number_of_arms_pressed = staticmethod(number_of_arms_pressed)

    def number_of_solos_pressed():
        result = 0
        for strip in ChannelStripComponent._active_instances:
            if not isinstance(strip, ChannelStripComponent):
                raise AssertionError
                strip.solo_button_pressed() and result += 1

        return result

    number_of_solos_pressed = staticmethod(number_of_solos_pressed)
    empty_color = None

    def __init__(self):
        ControlSurfaceComponent.__init__(self)
        ChannelStripComponent._active_instances.append(self)
        self._track = None
        self._send_controls = []
        self._pan_control = None
        self._volume_control = None
        self._select_button = None
        self._mute_button = None
        self._solo_button = None
        self._arm_button = None
        self._shift_button = None
        self._crossfade_toggle = None
        self._track_name_data_source = None
        self._shift_pressed = False
        self._solo_pressed = False
        self._arm_pressed = False
        self._invert_mute_feedback = False
        self._empty_control_slots = self.register_slot_manager()

    def disconnect(self):
        """ releasing references and removing listeners"""
        ChannelStripComponent._active_instances.remove(self)
        if self._select_button != None:
            self._select_button.remove_value_listener(self._select_value)
            self._select_button.reset()
            self._select_button = None
        if self._mute_button != None:
            self._mute_button.remove_value_listener(self._mute_value)
            self._mute_button.reset()
            self._mute_button = None
        if self._solo_button != None:
            self._solo_button.remove_value_listener(self._solo_value)
            self._solo_button.reset()
            self._solo_button = None
        if self._arm_button != None:
            self._arm_button.remove_value_listener(self._arm_value)
            self._arm_button.reset()
            self._arm_button = None
        if self._shift_button != None:
            self._shift_button.remove_value_listener(self._shift_value)
            self._shift_button.reset()
            self._shift_button = None
        if self._crossfade_toggle != None:
            self._crossfade_toggle.remove_value_listener(self._crossfade_toggle_value)
            self._crossfade_toggle.reset()
            self._crossfade_toggle = None
        if self._track_name_data_source != None:
            self._track_name_data_source.set_display_string('')
            self._track_name_data_source = None
        if self._track != None:
            if self._track != self.song().master_track:
                if self._track.mixer_device.sends_has_listener(self._on_sends_changed):
                    self._track.mixer_device.remove_sends_listener(self._on_sends_changed)
                if self._track.mute_has_listener(self._on_mute_changed):
                    self._track.remove_mute_listener(self._on_mute_changed)
                if self._track.name_has_listener(self._on_track_name_changed):
                    self._track.remove_name_listener(self._on_track_name_changed)
                if self._track.solo_has_listener(self._on_solo_changed):
                    self._track.remove_solo_listener(self._on_solo_changed)
                if self._track.mixer_device.crossfade_assign_has_listener(self._on_cf_assign_changed):
                    self._track.mixer_device.remove_crossfade_assign_listener(self._on_cf_assign_changed)
                if self._track not in self.song().return_tracks:
                    if self._track.can_be_armed and self._track.arm_has_listener(self._on_arm_changed):
                        self._track.remove_arm_listener(self._on_arm_changed)
                    if self._track.current_input_routing_has_listener(self._on_input_routing_changed):
                        self._track.remove_current_input_routing_listener(self._on_input_routing_changed)
            if self._pan_control != None:
                self._pan_control.release_parameter()
                self._pan_control = None
            if self._volume_control != None:
                self._volume_control.release_parameter()
                self._volume_control = None
            if self._send_controls != None:
                for send_control in self._send_controls:
                    if send_control != None:
                        send_control.release_parameter()

                self._send_controls = None
            self._track = None
        super(ChannelStripComponent, self).disconnect()

    def set_track(self, track):
        if not isinstance(track, (type(None), Live.Track.Track)):
            raise AssertionError
            if self._track != None:
                if self._track != self.song().master_track:
                    if self._track.mixer_device.sends_has_listener(self._on_sends_changed):
                        self._track.mixer_device.remove_sends_listener(self._on_sends_changed)
                    if self._track.mute_has_listener(self._on_mute_changed):
                        self._track.remove_mute_listener(self._on_mute_changed)
                    if self._track.name_has_listener(self._on_track_name_changed):
                        self._track.remove_name_listener(self._on_track_name_changed)
                    if self._track.solo_has_listener(self._on_solo_changed):
                        self._track.remove_solo_listener(self._on_solo_changed)
                    if self._track.mixer_device.crossfade_assign_has_listener(self._on_cf_assign_changed):
                        self._track.mixer_device.remove_crossfade_assign_listener(self._on_cf_assign_changed)
                    if self._track not in self.song().return_tracks:
                        if self._track.can_be_armed and self._track.arm_has_listener(self._on_arm_changed):
                            self._track.remove_arm_listener(self._on_arm_changed)
                        if self._track.current_input_routing_has_listener(self._on_input_routing_changed):
                            self._track.remove_current_input_routing_listener(self._on_input_routing_changed)
            if self._pan_control != None:
                self._pan_control.release_parameter()
            if self._volume_control != None:
                self._volume_control.release_parameter()
            if self._send_controls != None:
                for send_control in self._send_controls:
                    if send_control != None:
                        send_control.release_parameter()

            self._track = track
            raise self._track != None and (isinstance(self._track, Live.Track.Track) or AssertionError)
            if not self._track in tuple(self.song().tracks) + tuple(self.song().return_tracks) + (self.song().master_track,):
                raise AssertionError
                if self._track != self.song().master_track:
                    self._track.add_solo_listener(self._on_solo_changed)
                    self._track.mixer_device.add_sends_listener(self._on_sends_changed)
                    self._track.add_mute_listener(self._on_mute_changed)
                    self._track.add_name_listener(self._on_track_name_changed)
                    self._track.mixer_device.add_crossfade_assign_listener(self._on_cf_assign_changed)
                    if self._track not in self.song().return_tracks:
                        self._track.can_be_armed and self._track.add_arm_listener(self._on_arm_changed)
                    self._track.add_current_input_routing_listener(self._on_input_routing_changed)
            for button in (self._select_button,
             self._mute_button,
             self._solo_button,
             self._arm_button,
             self._crossfade_toggle):
                if button != None:
                    button.turn_off()

        self._update_track_name_data_source()
        self.update()

    def _update_track_name_data_source(self):
        if self._track_name_data_source != None:
            if self._track != None:
                self._track_name_data_source.set_display_string(self._track.name)
            else:
                self._track_name_data_source.set_display_string(' - ')

    def set_send_controls(self, controls):
        if self._send_controls != None:
            for send_control in self._send_controls:
                if send_control != None:
                    send_control.release_parameter()

        self._send_controls = controls
        self.update()

    def set_pan_control(self, control):
        if not isinstance(control, (type(None), EncoderElement)):
            raise AssertionError
            if control != self._pan_control:
                self._pan_control != None and self._pan_control.release_parameter()
            self._pan_control = control
            self.update()

    def set_volume_control(self, control):
        if not isinstance(control, (type(None), EncoderElement)):
            raise AssertionError
            if control != self._volume_control:
                self._volume_control != None and self._volume_control.release_parameter()
            self._volume_control = control
            self.update()

    def set_select_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if button != self._select_button:
                if self._select_button != None:
                    self._select_button.remove_value_listener(self._select_value)
                    self._select_button.reset()
                self._select_button = button
                self._select_button != None and self._select_button.add_value_listener(self._select_value)
            self.update()

    def set_mute_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if button != self._mute_button:
                if self._mute_button != None:
                    self._mute_button.remove_value_listener(self._mute_value)
                    self._mute_button.reset()
                self._mute_button = button
                self._mute_button != None and self._mute_button.add_value_listener(self._mute_value)
            self.update()

    def set_solo_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if button != self._solo_button:
                if self._solo_button != None:
                    self._solo_button.remove_value_listener(self._solo_value)
                    self._solo_button.reset()
                self._solo_pressed = False
                self._solo_button = button
                self._solo_button != None and self._solo_button.add_value_listener(self._solo_value)
            self.update()

    def set_arm_button(self, button):
        if not self._track != self.song().master_track:
            raise AssertionError
            if not (button == None or isinstance(button, ButtonElement)):
                raise AssertionError
                if button != self._arm_button:
                    self._arm_button != None and self._arm_button.remove_value_listener(self._arm_value)
                    self._arm_button.reset()
                self._arm_pressed = False
                self._arm_button = button
                self._arm_button != None and self._arm_button.add_value_listener(self._arm_value)
            self.update()

    def set_shift_button(self, button):
        if not self._track != self.song().master_track:
            raise AssertionError
            if not (button == None or isinstance(button, ButtonElement) and button.is_momentary()):
                raise AssertionError
                if button != self._shift_button:
                    self._shift_button != None and self._shift_button.remove_value_listener(self._shift_value)
                    self._shift_button.reset()
                self._shift_button = button
                self._shift_button != None and self._shift_button.add_value_listener(self._shift_value)
            self.update()

    def set_crossfade_toggle(self, button):
        if not self._track != self.song().master_track:
            raise AssertionError
            if not (button == None or isinstance(button, ButtonElement)):
                raise AssertionError
                if button != self._crossfade_toggle:
                    self._crossfade_toggle != None and self._crossfade_toggle.remove_value_listener(self._crossfade_toggle_value)
                    self._crossfade_toggle.reset()
                self._crossfade_toggle = button
                self._crossfade_toggle != None and self._crossfade_toggle.add_value_listener(self._crossfade_toggle_value)
            self.update()

    def set_invert_mute_feedback(self, invert_feedback):
        if not isinstance(invert_feedback, type(False)):
            raise AssertionError
            self._invert_mute_feedback = invert_feedback != self._invert_mute_feedback and invert_feedback
            self.update()

    def on_enabled_changed(self):
        self.update()

    def on_selected_track_changed(self):
        if self.is_enabled() and self._select_button != None:
            if self._track != None or self.empty_color == None:
                if self.song().view.selected_track == self._track:
                    self._select_button.turn_on()
                else:
                    self._select_button.turn_off()
            else:
                self._select_button.set_light(self.empty_color)

    def solo_button_pressed(self):
        return self._solo_pressed

    def arm_button_pressed(self):
        return self._arm_pressed

    def track_name_data_source(self):
        if self._track_name_data_source == None:
            self._track_name_data_source = DisplayDataSource()
            self._update_track_name_data_source()
        return self._track_name_data_source

    def _connect_parameters(self):
        if self._pan_control != None:
            self._pan_control.connect_to(self._track.mixer_device.panning)
        if self._volume_control != None:
            self._volume_control.connect_to(self._track.mixer_device.volume)
        if self._send_controls != None:
            index = 0
            for send_control in self._send_controls:
                if send_control != None:
                    if index < len(self._track.mixer_device.sends):
                        send_control.connect_to(self._track.mixer_device.sends[index])
                    else:
                        send_control.release_parameter()
                        self._empty_control_slots.register_slot(send_control, nop, 'value')
                index += 1

    def _disconnect_parameters(self):
        if self._pan_control != None:
            self._pan_control.release_parameter()
            self._empty_control_slots.register_slot(self._pan_control, nop, 'value')
        if self._volume_control != None:
            self._volume_control.release_parameter()
            self._empty_control_slots.register_slot(self._volume_control, nop, 'value')
        if self._send_controls != None:
            for send_control in self._send_controls:
                if send_control != None:
                    send_control.release_parameter()
                    self._empty_control_slots.register_slot(send_control, nop, 'value')

    def update(self):
        if self._allow_updates:
            if self.is_enabled():
                self._empty_control_slots.disconnect()
                if self._track != None:
                    self._connect_parameters()
                else:
                    self._disconnect_parameters()
                self.on_selected_track_changed()
                self._on_mute_changed()
                self._on_solo_changed()
                self._on_arm_changed()
                self._on_cf_assign_changed()
            else:
                self._disconnect_parameters()
        else:
            self._update_requests += 1

    def _select_value(self, value):
        if not self._select_button != None:
            raise AssertionError
            if not isinstance(value, int):
                raise AssertionError
                if self.is_enabled():
                    if self._track != None:
                        self.song().view.selected_track = (value != 0 or not self._select_button.is_momentary()) and self.song().view.selected_track != self._track and self._track

    def _mute_value(self, value):
        if not self._mute_button != None:
            raise AssertionError
            if not isinstance(value, int):
                raise AssertionError
                if self.is_enabled():
                    self._track.mute = self._track != None and self._track != self.song().master_track and (not self._mute_button.is_momentary() or value != 0) and not self._track.mute

    def update_solo_state(self, solo_exclusive, new_value, respect_multi_selection, track):
        if track == self._track or respect_multi_selection and track.is_part_of_selection:
            track.solo = new_value
        elif solo_exclusive and track.solo:
            track.solo = False

    def _solo_value(self, value):
        if not self._solo_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self.is_enabled():
                    if self._track != None and self._track != self.song().master_track:
                        self._solo_pressed = value != 0 and self._solo_button.is_momentary()
                        expected_solos_pressed = (value != 0 or not self._solo_button.is_momentary()) and 0
                        expected_solos_pressed = self._solo_pressed and 1
                    solo_exclusive = self.song().exclusive_solo != self._shift_pressed and (not self._solo_button.is_momentary() or ChannelStripComponent.number_of_solos_pressed() == expected_solos_pressed)
                    new_value = not self._track.solo
                    respect_multi_selection = self._track.is_part_of_selection
                    for track in self.song().tracks:
                        self.update_solo_state(solo_exclusive, new_value, respect_multi_selection, track)

                    for track in self.song().return_tracks:
                        self.update_solo_state(solo_exclusive, new_value, respect_multi_selection, track)

    def _arm_value(self, value):
        if not self._arm_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self.is_enabled():
                    if self._track != None and self._track.can_be_armed:
                        self._arm_pressed = value != 0 and self._arm_button.is_momentary()
                        expected_arms_pressed = (not self._arm_button.is_momentary() or value != 0) and 0
                        expected_arms_pressed = self._arm_pressed and 1
                    arm_exclusive = self.song().exclusive_arm != self._shift_pressed and (not self._arm_button.is_momentary() or ChannelStripComponent.number_of_arms_pressed() == expected_arms_pressed)
                    new_value = not self._track.arm
                    respect_multi_selection = self._track.is_part_of_selection
                    for track in self.song().tracks:
                        if track.can_be_armed:
                            if track == self._track or respect_multi_selection and track.is_part_of_selection:
                                track.arm = new_value
                            elif arm_exclusive and track.arm:
                                track.arm = False

    def _shift_value(self, value):
        raise self._shift_button != None or AssertionError
        self._shift_pressed = value != 0

    def _crossfade_toggle_value(self, value):
        if not self._crossfade_toggle != None:
            raise AssertionError
            if not isinstance(value, int):
                raise AssertionError
                if self.is_enabled():
                    self._track.mixer_device.crossfade_assign = self._track != None and (value != 0 or not self._crossfade_toggle.is_momentary()) and (self._track.mixer_device.crossfade_assign - 1) % len(self._track.mixer_device.crossfade_assignments.values)

    def _on_sends_changed(self):
        if self.is_enabled():
            self.update()

    def _on_mute_changed(self):
        if self.is_enabled() and self._mute_button != None:
            if self._track != None or self.empty_color == None:
                if self._track in chain(self.song().tracks, self.song().return_tracks) and self._track.mute != self._invert_mute_feedback:
                    self._mute_button.turn_on()
                else:
                    self._mute_button.turn_off()
            else:
                self._mute_button.set_light(self.empty_color)

    def _on_solo_changed(self):
        if self.is_enabled() and self._solo_button != None:
            if self._track != None or self.empty_color == None:
                if self._track in chain(self.song().tracks, self.song().return_tracks) and self._track.solo:
                    self._solo_button.turn_on()
                else:
                    self._solo_button.turn_off()
            else:
                self._solo_button.set_light(self.empty_color)

    def _on_arm_changed(self):
        if self.is_enabled() and self._arm_button != None:
            if self._track != None and self._track in self.song().tracks and self._track.can_be_armed and self._track.arm:
                self._arm_button.turn_on()
            else:
                self._arm_button.turn_off()

    def _on_track_name_changed(self):
        if self._track != None:
            self._update_track_name_data_source()

    def _on_cf_assign_changed(self):
        if self.is_enabled() and self._crossfade_toggle != None:
            if self._track != None and self._track in chain(self.song().tracks, self.song().return_tracks) and self._track.mixer_device.crossfade_assign != 1:
                self._crossfade_toggle.turn_on()
            else:
                self._crossfade_toggle.turn_off()

    def _on_input_routing_changed(self):
        if not self._track != None:
            raise AssertionError
            if self.is_enabled():
                self._track.can_be_armed and not self._track.arm_has_listener(self._on_arm_changed) and self._track.add_arm_listener(self._on_arm_changed)
            self._on_arm_changed()
########NEW FILE########
__FILENAME__ = ChannelTranslationSelector
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/ChannelTranslationSelector.py
from ModeSelectorComponent import ModeSelectorComponent
from InputControlElement import InputControlElement

class ChannelTranslationSelector(ModeSelectorComponent):
    """ Class switches modes by translating the given controls' message channel """

    def __init__(self, num_modes = 0):
        ModeSelectorComponent.__init__(self)
        self._controls_to_translate = None
        self._initial_num_modes = num_modes

    def disconnect(self):
        ModeSelectorComponent.disconnect(self)
        self._controls_to_translate = None

    def set_controls_to_translate(self, controls):
        raise self._controls_to_translate == None or AssertionError
        raise controls != None or AssertionError
        raise isinstance(controls, tuple) or AssertionError
        for control in controls:
            raise isinstance(control, InputControlElement) or AssertionError

        self._controls_to_translate = controls

    def number_of_modes(self):
        result = self._initial_num_modes
        if result == 0 and self._modes_buttons != None:
            result = len(self._modes_buttons)
        return result

    def update(self):
        if self._controls_to_translate != None:
            for control in self._controls_to_translate:
                control.use_default_message()
                if self.is_enabled():
                    control.set_channel((control.message_channel() + self._mode_index) % 16)
########NEW FILE########
__FILENAME__ = ClipSlotComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/ClipSlotComponent.py
import Live
from ControlSurfaceComponent import ControlSurfaceComponent
from Util import in_range
from SubjectSlot import subject_slot

def find_nearest_color(rgb_table, src_hex_color):

    def hex_to_channels(color_in_hex):
        return ((color_in_hex & 16711680) >> 16, (color_in_hex & 65280) >> 8, color_in_hex & 255)

    def squared_distance(color):
        return sum([ (a - b) ** 2 for a, b in zip(hex_to_channels(src_hex_color), hex_to_channels(color[1])) ])

    return min(rgb_table, key=squared_distance)[0]


class ClipSlotComponent(ControlSurfaceComponent):
    """
    Component representing a ClipSlot within Live.
    """

    def __init__(self, *a, **k):
        super(ClipSlotComponent, self).__init__(*a, **k)
        self._clip_slot = None
        self._triggered_to_play_value = 126
        self._triggered_to_record_value = 121
        self._started_value = 127
        self._recording_value = 120
        self._stopped_value = 0
        self._clip_palette = []
        self._clip_rgb_table = None
        self._record_button_value = None
        self._has_fired_slot = False
        self._delete_button = None
        self._select_button = None
        self._duplicate_button = None

    def on_enabled_changed(self):
        self.update()

    def set_clip_slot(self, clip_slot):
        self._clip_slot = clip_slot
        self._update_clip_property_slots()
        self._on_slot_triggered_changed.subject = clip_slot
        self._on_slot_playing_state_changed.subject = clip_slot
        self._on_clip_state_changed.subject = clip_slot
        self._on_controls_other_clips_changed.subject = clip_slot
        self._on_has_stop_button_changed.subject = clip_slot
        self._on_clip_slot_color_changed.subject = clip_slot
        track = clip_slot.canonical_parent if clip_slot else None
        if track and track.can_be_armed:
            self._on_arm_value_changed.subject = track
            self._on_implicit_arm_value_changed.subject = track
        self.update()

    def set_launch_button(self, button):
        self._launch_button_value.subject = button
        self.update()

    def set_delete_button(self, button):
        self._delete_button = button

    def set_select_button(self, button):
        self._select_button = button

    def set_duplicate_button(self, button):
        self._duplicate_button = button

    def set_triggered_to_play_value(self, value):
        self._triggered_to_play_value = value

    def set_triggered_to_record_value(self, value):
        self._triggered_to_record_value = value

    def set_started_value(self, value):
        self._started_value = value

    def set_recording_value(self, value):
        self._recording_value = value

    def set_stopped_value(self, value):
        self._stopped_value = value
        self._clip_palette = []

    def set_record_button_value(self, value):
        self._record_button_value = value

    def set_clip_palette(self, palette):
        raise palette != None or AssertionError
        self._stopped_value = None
        self._clip_palette = palette

    def set_clip_rgb_table(self, rgb_table):
        """ A list of velocity, hex-rgb color pairs that is used, if the color could not
        be matched to the clip palette """
        self._clip_rgb_table = rgb_table

    def has_clip(self):
        raise self._clip_slot != None or AssertionError
        return self._clip_slot.has_clip

    def update(self):
        self._has_fired_slot = False
        button = self._launch_button_value.subject
        if self._allow_updates:
            if self.is_enabled() and button != None:
                value_to_send = self._feedback_value()
                if value_to_send in (None, -1):
                    button.turn_off()
                elif in_range(value_to_send, 0, 128):
                    button.send_value(value_to_send)
                else:
                    button.set_light(value_to_send)
        else:
            self._update_requests += 1

    def _color_value(self, color):
        try:
            return self._clip_palette[color]
        except (KeyError, IndexError):
            if self._clip_rgb_table != None:
                return find_nearest_color(self._clip_rgb_table, color)
            else:
                return self._stopped_value

    def _track_is_armed(self, track):
        return track != None and track.can_be_armed and any([track.arm, track.implicit_arm])

    def _feedback_value(self):
        if self._clip_slot != None:
            track = self._clip_slot.canonical_parent
            slot_or_clip = self._clip_slot.clip if self.has_clip() else self._clip_slot
            if slot_or_clip.is_triggered:
                return self._triggered_to_record_value if slot_or_clip.will_record_on_start else self._triggered_to_play_value
            elif slot_or_clip.is_playing:
                return self._recording_value if slot_or_clip.is_recording else self._started_value
            elif slot_or_clip.color != None:
                return self._color_value(slot_or_clip.color)
            elif getattr(slot_or_clip, 'controls_other_clips', True) and self._stopped_value != None:
                return self._stopped_value
            elif self._track_is_armed(track) and self._clip_slot.has_stop_button:
                if self._record_button_value != None:
                    return self._record_button_value

    def _update_clip_property_slots(self):
        clip = self._clip_slot.clip if self._clip_slot else None
        self._on_clip_playing_state_changed.subject = clip
        self._on_recording_state_changed.subject = clip
        self._on_clip_color_changed.subject = clip

    @subject_slot('has_clip')
    def _on_clip_state_changed(self):
        self._update_clip_property_slots()
        self.update()

    @subject_slot('controls_other_clips')
    def _on_controls_other_clips_changed(self):
        self._update_clip_property_slots()
        self.update()

    @subject_slot('color')
    def _on_clip_color_changed(self):
        self.update()

    @subject_slot('color')
    def _on_clip_slot_color_changed(self):
        self.update()

    @subject_slot('playing_status')
    def _on_slot_playing_state_changed(self):
        self.update()

    @subject_slot('playing_status')
    def _on_clip_playing_state_changed(self):
        self.update()

    @subject_slot('is_recording')
    def _on_recording_state_changed(self):
        self.update()

    @subject_slot('arm')
    def _on_arm_value_changed(self):
        self.update()

    @subject_slot('implicit_arm')
    def _on_implicit_arm_value_changed(self):
        self.update()

    @subject_slot('has_stop_button')
    def _on_has_stop_button_changed(self):
        self.update()

    @subject_slot('is_triggered')
    def _on_slot_triggered_changed(self):
        if not self.has_clip():
            song = self.song()
            view = song.view
            if song.select_on_launch and self._clip_slot.is_triggered and self._has_fired_slot and self._clip_slot.will_record_on_start and self._clip_slot != view.highlighted_clip_slot:
                view.highlighted_clip_slot = self._clip_slot
            self.update()

    @subject_slot('value')
    def _launch_button_value(self, value):
        if self.is_enabled():
            if self._select_button and self._select_button.is_pressed() and value:
                self._do_select_clip(self._clip_slot)
            elif self._clip_slot != None:
                if self._duplicate_button and self._duplicate_button.is_pressed():
                    if value:
                        self._do_duplicate_clip()
                elif self._delete_button and self._delete_button.is_pressed():
                    if value:
                        self._do_delete_clip()
                else:
                    self._do_launch_clip(value)

    def _do_delete_clip(self):
        if self._clip_slot and self._clip_slot.has_clip:
            self._clip_slot.delete_clip()

    def _do_select_clip(self, clip_slot):
        if self._clip_slot != None:
            if self.song().view.highlighted_clip_slot != self._clip_slot:
                self.song().view.highlighted_clip_slot = self._clip_slot

    def _do_duplicate_clip(self):
        if self._clip_slot and self._clip_slot.has_clip:
            try:
                track = self._clip_slot.canonical_parent
                track.duplicate_clip_slot(list(track.clip_slots).index(self._clip_slot))
            except Live.Base.LimitationError:
                pass
            except RuntimeError:
                pass

    def _do_launch_clip(self, value):
        button = self._launch_button_value.subject
        object_to_launch = self._clip_slot
        if not value:
            launch_pressed = not button.is_momentary()
            if self.has_clip():
                object_to_launch = self._clip_slot.clip
            else:
                self._has_fired_slot = True
            if button.is_momentary():
                object_to_launch.set_fire_button_state(value != 0)
            elif launch_pressed:
                object_to_launch.fire()
            self.song().view.highlighted_clip_slot = launch_pressed and self.has_clip() and self.song().select_on_launch and self._clip_slot
########NEW FILE########
__FILENAME__ = CompoundComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/CompoundComponent.py
from ControlSurfaceComponent import ControlSurfaceComponent

class CompoundComponent(ControlSurfaceComponent):
    """ Base class for classes encompasing other components to form complex components """

    def __init__(self, *a, **k):
        super(CompoundComponent, self).__init__(*a, **k)
        self._sub_components = []

    def update_all(self):
        self.update()
        for component in self._sub_components:
            component.update_all()

    def register_component(self, component):
        raise component != None or AssertionError
        raise component not in self._sub_components or AssertionError
        component._set_enabled_recursive(self.is_enabled())
        self._sub_components.append(component)
        return component

    def register_components(self, *a):
        return map(self.register_component, a)

    def has_component(self, component):
        return component in self._sub_components

    def set_enabled(self, enable):
        """
        When disabling a compound component, its children are disabled. When
        enabled, these children are restored to whatever state they were
        explicitly set to.
        """
        super(CompoundComponent, self).set_enabled(enable)
        for component in self._sub_components:
            component._set_enabled_recursive(self.is_enabled())

    def _set_enabled_recursive(self, enable):
        super(CompoundComponent, self)._set_enabled_recursive(enable)
        for component in self._sub_components:
            component._set_enabled_recursive(self.is_enabled())

    def set_allow_update(self, allow_updates):
        allow = bool(allow_updates)
        if self._allow_updates != allow:
            for component in self._sub_components:
                component.set_allow_update(allow)

            super(CompoundComponent, self).set_allow_update(allow)
########NEW FILE########
__FILENAME__ = CompoundElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/CompoundElement.py
from __future__ import with_statement
from itertools import ifilter
from SubjectSlot import subject_slot_group, SlotManager
from NotifyingControlElement import NotifyingControlElement
from Util import BooleanContext, first, second

class CompoundElement(NotifyingControlElement, SlotManager):
    """
    Utility class that helps in writing Elements that act as a facade
    to nested elements, hiding the complexity oif making sure that
    resource ownership rules are preserved.
    """
    _is_resource_based = False

    def __init__(self, *a, **k):
        super(CompoundElement, self).__init__(*a, **k)
        self._nested_control_elements = dict()
        self._disable_notify_owner_on_button_ownership_change = BooleanContext()
        self._listen_nested_requests = 0

    def on_nested_control_element_grabbed(self, control):
        """
        Notifies that the nested control can be used by the compound
        """
        raise NotImplementedError

    def on_nested_control_element_released(self, control):
        """
        Notifies that we lost control over the control.
        """
        raise NotImplementedError

    def on_nested_control_element_value(self, control, value):
        """
        Notifies that an owned control element has received a value.
        """
        raise NotImplementedError

    def get_control_element_priority(self, element):
        """
        Override to change priority for control element.
        """
        raise self._has_resource or AssertionError
        return self.resource.max_priority

    def register_control_elements(self, *elements):
        return map(self.register_control_element, elements)

    def register_control_element(self, element):
        if not element not in self._nested_control_elements:
            raise AssertionError
            self._nested_control_elements[element] = False
            if self._listen_nested_requests > 0:
                self._on_nested_control_element_value.add_subject(element)
            priority = self._is_resource_based and self.resource.owner and self.get_control_element_priority(element)
            element.resource.grab(self, priority=priority)
        elif not self._is_resource_based:
            with self._disable_notify_owner_on_button_ownership_change():
                element.notify_ownership_change(self, True)
        return element

    def unregister_control_elements(self, *elements):
        return map(self.unregister_control_element, elements)

    def unregister_control_element(self, element):
        if not element in self._nested_control_elements:
            raise AssertionError
            if self._is_resource_based and self.resource.owner:
                element.resource.release(self)
            elif not self._is_resource_based:
                with self._disable_notify_owner_on_button_ownership_change():
                    element.notify_ownership_change(self, False)
            self._listen_nested_requests > 0 and self._on_nested_control_element_value.remove_subject(element)
        del self._nested_control_elements[element]
        return element

    def has_control_element(self, control):
        return control in self._nested_control_elements

    def owns_control_element(self, control):
        return self._nested_control_elements.get(control, False)

    def owned_control_elements(self):
        return map(first, ifilter(second, self._nested_control_elements.iteritems()))

    def nested_control_elements(self):
        return self._nested_control_elements.iterkeys()

    def reset(self):
        for element in self.owned_control_elements():
            element.reset()

    def add_value_listener(self, *a, **k):
        if self.value_listener_count() == 0:
            self.request_listen_nested_control_elements()
        super(CompoundElement, self).add_value_listener(*a, **k)

    def remove_value_listener(self, *a, **k):
        super(CompoundElement, self).remove_value_listener(*a, **k)
        if self.value_listener_count() == 0:
            self.unrequest_listen_nested_control_elements()

    def request_listen_nested_control_elements(self):
        """
        By default, the compound control element will listen to its
        nested control elements IFF he himself has listeners.  This is
        important, because for nested InputControlElements, the
        existence of listeners determine wether they will send the
        MIDI messages to Live or to the script.
        
        You can force the compound to listen to its nested elements
        using this methods.  The compound will then listen to them IFF
        the number of requests is greater than the number of
        unrequests OR it has listeners.
        """
        if self._listen_nested_requests == 0:
            self._connect_nested_control_elements()
        self._listen_nested_requests += 1

    def unrequest_listen_nested_control_elements(self):
        """
        See request_listen_nested_control_elements()
        """
        if self._listen_nested_requests == 1:
            self._disconnect_nested_control_elements()
        self._listen_nested_requests -= 1

    def _connect_nested_control_elements(self):
        self._on_nested_control_element_value.replace_subjects(self._nested_control_elements.keys())

    def _disconnect_nested_control_elements(self):
        self._on_nested_control_element_value.replace_subjects([])

    def _on_nested_control_element_grabbed(self, control):
        if control in self._nested_control_elements:
            if not self._nested_control_elements[control]:
                self._nested_control_elements[control] = True
        self.on_nested_control_element_grabbed(control)

    def _on_nested_control_element_released(self, control):
        if control in self._nested_control_elements:
            if self._nested_control_elements[control]:
                self._nested_control_elements[control] = False
        self.on_nested_control_element_released(control)

    @subject_slot_group('value')
    def _on_nested_control_element_value(self, value, sender):
        if self.owns_control_element(sender):
            self.on_nested_control_element_value(value, sender)

    def set_control_element(self, control, grabbed):
        if grabbed:
            self._on_nested_control_element_grabbed(control)
        else:
            self._on_nested_control_element_released(control)
        owner = self._resource.owner
        if owner and not self._disable_notify_owner_on_button_ownership_change:
            self.notify_ownership_change(owner, True)

    def _on_grab_resource(self, client, *a, **k):
        was_resource_based = self._is_resource_based
        self._is_resource_based = True
        with self._disable_notify_owner_on_button_ownership_change():
            for element in self._nested_control_elements:
                if not was_resource_based:
                    element.notify_ownership_change(self, False)
                priority = self.get_control_element_priority(element)
                element.resource.grab(self, priority=priority, *a, **k)

            super(CompoundElement, self)._on_grab_resource(client, *a, **k)

    def _on_release_resource(self, client):
        raise self._is_resource_based or AssertionError
        with self._disable_notify_owner_on_button_ownership_change():
            super(CompoundElement, self)._on_release_resource(client)
            for element in self._nested_control_elements.keys():
                element.resource.release(self)
########NEW FILE########
__FILENAME__ = ControlElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/ControlElement.py
import traceback
from Resource import StackingResource
from Util import lazy_attribute, nop, const, second, print_message
from Disconnectable import Disconnectable
from Dependency import depends
import Task

class ElementOwnershipHandler(object):
    """
    A ControlElementOwnershipHandler deals with the actual delivery of
    the control element to its clients.
    """

    def handle_ownership_change(self, control, client, status):
        client.set_control_element(control, status)


class OptimizedOwnershipHandler(ElementOwnershipHandler):
    """
    Control element ownership handler that delays notification of
    ownership changes and minimizes the number of actual owernship
    changes that are delivered.
    """

    def __init__(self, *a, **k):
        super(OptimizedOwnershipHandler, self).__init__(*a, **k)
        self._ownership_changes = {}
        self._sequence_number = 0

    def handle_ownership_change(self, control, client, status):
        if (control, client, not status) in self._ownership_changes:
            del self._ownership_changes[control, client, not status]
        else:
            self._ownership_changes[control, client, status] = self._sequence_number
        self._sequence_number += 1

    @depends(log_message=const(print_message), traceback=const(traceback))
    def commit_ownership_changes(self, log_message = None, traceback = None):
        notify = super(OptimizedOwnershipHandler, self).handle_ownership_change
        while self._ownership_changes:
            notifications = sorted(self._ownership_changes.iteritems(), key=second)
            self._ownership_changes.clear()
            for (control, client, status), _ in notifications:
                try:
                    notify(control, client, status)
                except Exception:
                    log_message('Error when trying to give control:', control.name)
                    traceback.print_exc()

        self._ownership_changes.clear()
        self._sequence_number = 0


class ControlElement(Disconnectable):
    """
    Base class for all classes representing control elements on a
    control surface
    """

    class ProxiedInterface(object):
        """
        Declaration of the interface to be used when the
        ControlElement is wrapped in any form of Proxy object.
        """
        send_midi = nop

        def __init__(self, outer = None, *a, **k):
            super(ControlElement.ProxiedInterface, self).__init__(*a, **k)
            self._outer = outer

        @property
        def outer(self):
            return self._outer

    @lazy_attribute
    def proxied_interface(self):
        return self.ProxiedInterface(outer=self)

    canonical_parent = None
    name = ''
    optimized_send_midi = True
    _has_resource = False
    _resource_type = StackingResource
    _has_task_group = False

    @depends(send_midi=None, register_control=None)
    def __init__(self, name = '', resource_type = None, optimized_send_midi = None, send_midi = None, register_control = None, *a, **k):
        super(ControlElement, self).__init__(*a, **k)
        self._send_midi = send_midi
        self.name = name
        if resource_type is not None:
            self._resource_type = resource_type
        if optimized_send_midi is not None:
            self.optimized_send_midi = optimized_send_midi
        register_control(self)

    def disconnect(self):
        self.reset()
        super(ControlElement, self).disconnect()

    def send_midi(self, message):
        raise message != None or AssertionError
        return self._send_midi(message, optimized=self.optimized_send_midi)

    def clear_send_cache(self):
        pass

    def reset(self):
        raise NotImplementedError

    @property
    def resource(self):
        return self._resource

    @lazy_attribute
    def _resource(self):
        self._has_resource = True
        return self._resource_type(self._on_grab_resource, self._on_release_resource)

    @lazy_attribute
    @depends(parent_task_group=Task.TaskGroup)
    def _tasks(self, parent_task_group = None):
        tasks = parent_task_group.add(Task.TaskGroup())
        self._has_task_group = True
        return tasks

    def _on_grab_resource(self, client, *a, **k):
        self.notify_ownership_change(client, True)

    def _on_release_resource(self, client):
        self.notify_ownership_change(client, False)

    @depends(element_ownership_handler=const(ElementOwnershipHandler()))
    def notify_ownership_change(self, client, grabbed, element_ownership_handler = None):
        element_ownership_handler.handle_ownership_change(self, client, grabbed)
########NEW FILE########
__FILENAME__ = ControlSurface
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/ControlSurface.py
from __future__ import with_statement
from functools import partial, wraps
from itertools import chain
from contextlib import contextmanager
import traceback
import Live
from Profile import profile
from Dependency import inject
from Util import BooleanContext, first, find_if, const, in_range
from Debug import debug_print
from SubjectSlot import SlotManager
from DeviceComponent import DeviceComponent
from PhysicalDisplayElement import PhysicalDisplayElement
from InputControlElement import InputControlElement, MIDI_CC_TYPE, MIDI_PB_TYPE, MIDI_NOTE_TYPE, MIDI_SYSEX_TYPE, MIDI_PB_STATUS
import Task
import Defaults

class _ModuleLoadedCheck(object):
    """
    This class is not to be instantiated.  We just use it to check
    whether the modules have been unloaded (showing leaking listeners).
    """
    pass


def _scheduled_method(method):
    """
    Methods from two control surfaces that use the component_guard can
    not live in the stack at the same time. Use this for methods that
    can be called implicitly by other control surfaces to delay
    execution.
    """

    @wraps(method)
    def wrapper(self, *a, **k):

        def doit():
            return method(self, *a, **k)

        self.schedule_message(1, doit)

    return wrapper


CS_LIST_KEY = 'control_surfaces'

def publish_control_surface(control_surface):
    if isinstance(__builtins__, dict):
        if CS_LIST_KEY not in __builtins__.keys():
            __builtins__[CS_LIST_KEY] = []
        __builtins__[CS_LIST_KEY].append(control_surface)
    else:
        if not hasattr(__builtins__, CS_LIST_KEY):
            setattr(__builtins__, CS_LIST_KEY, [])
        cs_list = getattr(__builtins__, CS_LIST_KEY)
        cs_list.append(control_surface)


class ControlSurface(SlotManager):
    """
    Central base class for scripts based on the new Framework. New
    scripts need to subclass this class and add special behavior.
    """

    def __init__(self, c_instance = None, publish_self = True, *a, **k):
        """ Define and Initialize standard behavior """
        super(ControlSurface, self).__init__(*a, **k)
        if not c_instance:
            raise AssertionError
            self.canonical_parent = None
            publish_self and publish_control_surface(self)
        self._c_instance = c_instance
        self.log_message('Initialising...')
        self._pad_translations = None
        self._suggested_input_port = str('')
        self._suggested_output_port = str('')
        self._components = []
        self._displays = []
        self.controls = []
        self._highlighting_session_component = None
        self._device_component = None
        self._device_selection_follows_track_selection = False
        self._forwarding_long_identifier_registry = {}
        self._forwarding_registry = {}
        self._is_sending_scheduled_messages = BooleanContext()
        self._remaining_scheduled_messages = []
        self._task_group = Task.TaskGroup(auto_kill=False)
        self._in_build_midi_map = BooleanContext()
        self._suppress_requests_counter = 0
        self._rebuild_requests_during_suppression = 0
        self._enabled = True
        self._in_component_guard = BooleanContext()
        self._accumulate_midi_messages = BooleanContext()
        self._midi_message_dict = {}
        self._midi_message_list = []
        self._midi_message_count = 0
        self._control_surface_injector = inject(parent_task_group=const(self._task_group), show_message=const(self.show_message), log_message=const(self.log_message), register_component=const(self._register_component), register_control=const(self._register_control), request_rebuild_midi_map=const(self.request_rebuild_midi_map), send_midi=const(self._send_midi), song=self.song).everywhere()
        with self.setting_listener_caller():
            self.song().add_visible_tracks_listener(self._on_track_list_changed)
            self.song().add_scenes_listener(self._on_scene_list_changed)
            self.song().view.add_selected_track_listener(self._on_selected_track_changed)
            self.song().view.add_selected_scene_listener(self._on_selected_scene_changed)

    @property
    def components(self):
        return tuple(filter(lambda comp: not comp.is_private, self._components))

    def _get_tasks(self):
        return self._task_group

    _tasks = property(_get_tasks)

    def application(self):
        """ Returns a reference to the application that we are running in """
        return Live.Application.get_application()

    def song(self):
        """ Returns a reference to the Live song instance that we control """
        return self._c_instance.song()

    def disconnect(self):
        """
        Live -> Script: Called right before we get disconnected from Live
        """
        with self.component_guard():
            for component in self._components:
                component.disconnect()

            for control in self.controls:
                control.disconnect()

        self._forwarding_registry = None
        self.controls = None
        self._components = None
        self._displays = None
        self._device_component = None
        self._pad_translations = None
        self.song().remove_visible_tracks_listener(self._on_track_list_changed)
        self.song().remove_scenes_listener(self._on_scene_list_changed)
        self.song().view.remove_selected_track_listener(self._on_selected_track_changed)
        self.song().view.remove_selected_scene_listener(self._on_selected_scene_changed)
        if isinstance(__builtins__, dict):
            cs_list = __builtins__.get(CS_LIST_KEY, [])
        else:
            cs_list = getattr(__builtins__, CS_LIST_KEY, [])
        if self in cs_list:
            cs_list.remove(self)
        self._task_group.clear()
        super(ControlSurface, self).disconnect()

    def _control_surfaces(self):
        """ Returns list of registered control surfaces """
        control_surfaces = []
        if isinstance(__builtins__, dict):
            if CS_LIST_KEY in __builtins__.keys():
                control_surfaces = __builtins__[CS_LIST_KEY]
        elif hasattr(__builtins__, CS_LIST_KEY):
            control_surfaces = getattr(__builtins__, CS_LIST_KEY)
        return control_surfaces

    def can_lock_to_devices(self):
        """
        Live -> Script
        """
        return self._device_component != None

    @_scheduled_method
    def lock_to_device(self, device):
        """
        Live -> Script
        Live tells the script which device to control
        """
        raise self._device_component != None or AssertionError
        with self.component_guard():
            self._device_component.set_lock_to_device(True, device)

    @_scheduled_method
    def unlock_from_device(self, device):
        """
        Live -> Script
        Live tells the script to unlock from a certain device
        """
        raise self._device_component != None or AssertionError
        with self.component_guard():
            self._device_component.set_lock_to_device(False, device)

    @_scheduled_method
    def restore_bank(self, bank_index):
        """
        Live -> Script
        Live tells the script which bank to use.
        """
        raise self._device_component != None or AssertionError
        with self.component_guard():
            self._device_component.restore_bank(bank_index)

    @_scheduled_method
    def set_appointed_device(self, device):
        """
        Live -> Script
        Live tells the script to unlock from a certain device
        """
        with self.component_guard():
            self._device_component.set_device(device)

    def suggest_input_port(self):
        """ Live -> Script: Live can ask for the name of the script's
        prefered input port"""
        return self._suggested_input_port

    def suggest_output_port(self):
        """ Live -> Script: Live can ask for the name of the script's
        prefered output port"""
        return self._suggested_output_port

    def suggest_map_mode(self, cc_no, channel):
        """ Live -> Script: Live can ask for a suitable mapping mode
        for a given CC"""
        raise in_range(cc_no, 0, 128) or AssertionError
        raise in_range(channel, 0, 16) or AssertionError
        suggested_map_mode = -1
        for control in self.controls:
            if isinstance(control, InputControlElement) and control.message_type() == MIDI_CC_TYPE and control.message_identifier() == cc_no and control.message_channel() == channel:
                suggested_map_mode = control.message_map_mode()
                break

        return suggested_map_mode

    def suggest_needs_takeover(self, cc_no, channel):
        """ Live -> Script: Live can ask whether a given CC needs takeover """
        raise in_range(cc_no, 0, 128) or AssertionError
        raise in_range(channel, 0, 16) or AssertionError
        needs_takeover = True
        for control in self._controls:
            if isinstance(control, InputControlElement) and control.message_type() == MIDI_CC_TYPE and control.message_identifier() == cc_no and control.message_channel() == channel:
                needs_takeover = control.needs_takeover()
                break

        return needs_takeover

    def supports_pad_translation(self):
        return self._pad_translations != None

    def set_highlighting_session_component(self, session_component):
        raise self._highlighting_session_component is None or AssertionError, 'There must be one session component only'
        self._highlighting_session_component = session_component
        self._highlighting_session_component.set_highlighting_callback(self._set_session_highlight)

    def highlighting_session_component(self):
        """ Return the session component showing the ring in Live session """
        return self._highlighting_session_component

    def show_message(self, message):
        """ Displays the given message in Live's status bar """
        raise isinstance(message, (str, unicode)) or AssertionError
        self._c_instance.show_message(message)

    def log_message(self, *message):
        """ Writes the given message into Live's main log file """
        message = '(%s) %s' % (self.__class__.__name__, ' '.join(map(str, message)))
        console_message = 'LOG: ' + message
        if debug_print != None:
            debug_print(console_message)
        else:
            print console_message
        if self._c_instance:
            self._c_instance.log_message(message)

    def instance_identifier(self):
        return self._c_instance.instance_identifier()

    def connect_script_instances(self, instanciated_scripts):
        """ Called by the Application as soon as all scripts are initialized.
            You can connect yourself to other running scripts here, as we do it
            connect the extension modules (MackieControlXTs).
        """
        pass

    def request_rebuild_midi_map(self):
        """ Script -> Live.
            When the internal MIDI controller has changed in a way that
            you need to rebuild the MIDI mappings, request a rebuild
            by calling this function This is processed as a request,
            to be sure that its not too often called, because its
            time-critical.
        """
        if not not self._in_build_midi_map:
            raise AssertionError
            self._suppress_requests_counter > 0 and self._rebuild_requests_during_suppression += 1
        else:
            self._c_instance.request_rebuild_midi_map()

    def build_midi_map(self, midi_map_handle):
        """ Live -> Script
            Build DeviceParameter Mappings, that are processed in Audio time, or
            forward MIDI messages explicitly to our receive_midi_functions.
            Which means that when you are not forwarding MIDI, nor mapping parameters,
            you will never get any MIDI messages at all.
        """
        with self._in_build_midi_map():
            self._forwarding_registry.clear()
            self._forwarding_long_identifier_registry.clear()
            for control in self.controls:
                if isinstance(control, InputControlElement):
                    control.install_connections(self._translate_message, partial(self._install_mapping, midi_map_handle), partial(self._install_forwarding, midi_map_handle))

            if self._pad_translations != None:
                self._c_instance.set_pad_translation(self._pad_translations)

    def toggle_lock(self):
        """ Script -> Live
            Use this function to toggle the script's lock on devices
        """
        self._c_instance.toggle_lock()

    def refresh_state(self):
        """ Live -> Script
            Send out MIDI to completely update the attached MIDI controller.
            Will be called when requested by the user, after for example having reconnected
            the MIDI cables...
        """
        self.update()

    def update(self):
        with self.component_guard():
            for control in self.controls:
                control.clear_send_cache()

            for component in self._components:
                component.update()

    @profile
    def update_display(self):
        """ Live -> Script
            Aka on_timer. Called every 100 ms and should be used to update display relevant
            parts of the controller
        """
        with self.component_guard():
            with self._is_sending_scheduled_messages():
                self._task_group.update(Defaults.TIMER_DELAY)

    @profile
    def receive_midi(self, midi_bytes):
        """ Live -> Script
            MIDI messages are only received through this function, when explicitly
            forwarded in 'build_midi_map'.
        """
        with self.component_guard():
            self._do_receive_midi(midi_bytes)

    def is_sysex_message(self, midi_bytes):
        return len(midi_bytes) != 3

    def _do_receive_midi(self, midi_bytes):
        if not self.is_sysex_message(midi_bytes):
            self.handle_nonsysex(midi_bytes)
        else:
            self.handle_sysex(midi_bytes)

    def get_recipient_for_nonsysex_midi_message(self, midi_bytes):
        is_pitchbend = midi_bytes[0] & 240 == MIDI_PB_STATUS
        forwarding_key = midi_bytes[:1 if is_pitchbend else 2]
        if forwarding_key in self._forwarding_registry:
            return self._forwarding_registry[forwarding_key]

    def handle_nonsysex(self, midi_bytes):
        is_pitchbend = midi_bytes[0] & 240 == MIDI_PB_STATUS
        value = midi_bytes[1] + (midi_bytes[2] << 7) if is_pitchbend else midi_bytes[2]
        recipient = self.get_recipient_for_nonsysex_midi_message(midi_bytes)
        if recipient is not None:
            recipient.receive_value(value)
        else:
            self.log_message('Got unknown message: ' + str(midi_bytes))

    def handle_sysex(self, midi_bytes):
        result = find_if(lambda (id, _): midi_bytes[:len(id)] == id, self._forwarding_long_identifier_registry.iteritems())
        if result != None:
            id, control = result
            control.receive_value(midi_bytes[len(id):-1])
        else:
            self.log_message('Got unknown sysex message: ', midi_bytes)

    def set_device_component(self, device_component):
        raise self._device_component == None or AssertionError
        raise device_component != None or AssertionError
        raise isinstance(device_component, DeviceComponent) or AssertionError
        self._device_component = device_component
        self._device_component.set_lock_callback(self._toggle_lock)

    @contextmanager
    def suppressing_rebuild_requests(self):
        """
        Delays requesting a MIDI map rebuild, if any, until the scope
        of the context manager is exited.
        """
        try:
            self._set_suppress_rebuild_requests(True)
            yield
        finally:
            self._set_suppress_rebuild_requests(False)

    def _set_suppress_rebuild_requests(self, suppress_requests):
        if not not self._in_build_midi_map:
            raise AssertionError
            suppress_requests and self._suppress_requests_counter += 1
        elif not self._suppress_requests_counter > 0:
            raise AssertionError
            self._suppress_requests_counter -= 1
            self._suppress_requests_counter == 0 and self._rebuild_requests_during_suppression > 0 and self.request_rebuild_midi_map()
            self._rebuild_requests_during_suppression = 0

    def set_pad_translations(self, pad_translations):
        raise self._pad_translations == None or AssertionError
        raise len(pad_translations) <= 16 or AssertionError

        def check_translation(translation):
            raise len(translation) == 4 or AssertionError
            raise in_range(translation[0], 0, 4) or AssertionError
            raise in_range(translation[1], 0, 4) or AssertionError
            raise in_range(translation[2], 0, 128) or AssertionError
            raise in_range(translation[3], 0, 16) or AssertionError
            return True

        raise all(map(check_translation, pad_translations)) or AssertionError
        self._pad_translations = pad_translations

    def set_enabled(self, enable):
        bool_enable = bool(enable)
        if self._enabled != bool_enable:
            with self.component_guard():
                self._enabled = bool_enable
                for component in self._components:
                    component._set_enabled_recursive(bool_enable)

    def schedule_message(self, delay_in_ticks, callback, parameter = None):
        """ Schedule a callback to be called after a specified time """
        if not delay_in_ticks > 0:
            raise AssertionError
            if not callable(callback):
                raise AssertionError
                self._is_sending_scheduled_messages or delay_in_ticks -= 1
            message_reference = [None]

            def message(delta):
                if parameter:
                    callback(parameter)
                else:
                    callback()
                self._remaining_scheduled_messages.remove(message_reference)

            message_reference[0] = message
            self._remaining_scheduled_messages.append(message_reference)
            delay_in_ticks and self._task_group.add(Task.sequence(Task.delay(delay_in_ticks), message))
        else:
            self._task_group.add(message)

    def _process_remaining_scheduled_messages(self):
        current_scheduled_messages = tuple(self._remaining_scheduled_messages)
        for message, in current_scheduled_messages:
            message(None)

    def set_feedback_channels(self, channels):
        self._c_instance.set_feedback_channels(channels)

    def set_controlled_track(self, track):
        """ Sets the track that will send its feedback to the control surface """
        raise track == None or isinstance(track, Live.Track.Track) or AssertionError
        self._c_instance.set_controlled_track(track)

    def release_controlled_track(self):
        """ Sets that no track will send its feedback to the control surface """
        self._c_instance.release_controlled_track()

    def _register_control(self, control):
        """ puts control into the list of controls for triggering updates """
        if not control != None:
            raise AssertionError
            raise control not in self.controls or AssertionError, 'Control registered twice'
            self.controls.append(control)
            control.canonical_parent = self
            isinstance(control, PhysicalDisplayElement) and self._displays.append(control)

    def _register_component(self, component):
        """ puts component into the list of controls for triggering updates """
        raise component != None or AssertionError
        raise component not in self._components or AssertionError, 'Component registered twice'
        self._components.append(component)
        component.canonical_parent = self

    @contextmanager
    def component_guard(self):
        """
        Context manager that guards user code.  This prevents
        unnecesary updating and enables several optimisations.  Should
        be used to guard calls to components or control elements.
        """
        if not self._in_component_guard:
            with self._in_component_guard():
                with self.setting_listener_caller():
                    with self._control_surface_injector:
                        with self.suppressing_rebuild_requests():
                            with self.accumulating_midi_messages():
                                yield
        else:
            yield

    @property
    def in_component_guard(self):
        return bool(self._in_component_guard)

    @contextmanager
    def setting_listener_caller(self):
        try:
            self._c_instance.set_listener_caller(self._call_guarded_listener)
            yield
        finally:
            self._c_instance.set_listener_caller(None)

    @profile
    def _call_guarded_listener(self, listener):
        if _ModuleLoadedCheck == None or self._c_instance == None:
            self.log_message('Disconnecting leaked listener at:', listener.name)
            listener.disconnect()
        else:
            try:
                with self.component_guard():
                    listener()
            except:
                self.log_message('Detected broken listener at:', listener.name)
                raise 

    @contextmanager
    def accumulating_midi_messages(self):
        with self._accumulate_midi_messages():
            try:
                yield
            finally:
                self._flush_midi_messages()

    def _send_midi(self, midi_event_bytes, optimized = True):
        """
        Script -> Live
        Use this function to send MIDI events through Live to the
        _real_ MIDI devices that this script is assigned to.
        
        When optimized=True it is assumed that messages can be
        dropped -- only the last message within an update for a
        given (channel, key) has visible effects.
        """
        if self._accumulate_midi_messages:
            sysex_status_byte = 240
            entry = (self._midi_message_count, midi_event_bytes)
            if optimized and midi_event_bytes[0] != sysex_status_byte:
                self._midi_message_dict[midi_event_bytes[0], midi_event_bytes[1]] = entry
            else:
                self._midi_message_list.append(entry)
            self._midi_message_count += 1
        else:
            self._do_send_midi(midi_event_bytes)
        return True

    def _flush_midi_messages(self):
        raise self._accumulate_midi_messages or AssertionError
        for _, message in sorted(chain(self._midi_message_list, self._midi_message_dict.itervalues()), key=first):
            self._do_send_midi(message)

        self._midi_message_dict.clear()
        self._midi_message_list[:] = []
        self._midi_message_count = 0

    def _do_send_midi(self, midi_event_bytes):
        try:
            self._c_instance.send_midi(midi_event_bytes)
        except:
            self.log_message('Error while sending midi message', midi_event_bytes)
            traceback.print_exc()
            return False

        return True

    def _install_mapping(self, midi_map_handle, control, parameter, feedback_delay, feedback_map):
        if not self._in_build_midi_map:
            raise AssertionError
            raise control != None and parameter != None or AssertionError
            raise isinstance(parameter, Live.DeviceParameter.DeviceParameter) or AssertionError
            raise isinstance(control, InputControlElement) or AssertionError
            raise isinstance(feedback_delay, int) or AssertionError
            if not isinstance(feedback_map, tuple):
                raise AssertionError
                success = False
                feedback_rule = None
                feedback_rule = control.message_type() is MIDI_NOTE_TYPE and Live.MidiMap.NoteFeedbackRule()
                feedback_rule.note_no = control.message_identifier()
                feedback_rule.vel_map = feedback_map
            elif control.message_type() is MIDI_CC_TYPE:
                feedback_rule = Live.MidiMap.CCFeedbackRule()
                feedback_rule.cc_no = control.message_identifier()
                feedback_rule.cc_value_map = feedback_map
            elif control.message_type() is MIDI_PB_TYPE:
                feedback_rule = Live.MidiMap.PitchBendFeedbackRule()
                feedback_rule.value_pair_map = feedback_map
            if not feedback_rule != None:
                raise AssertionError
                feedback_rule.channel = control.message_channel()
                feedback_rule.delay_in_ms = feedback_delay
                success = control.message_type() is MIDI_NOTE_TYPE and Live.MidiMap.map_midi_note_with_feedback_map(midi_map_handle, parameter, control.message_channel(), control.message_identifier(), feedback_rule)
            elif control.message_type() is MIDI_CC_TYPE:
                success = Live.MidiMap.map_midi_cc_with_feedback_map(midi_map_handle, parameter, control.message_channel(), control.message_identifier(), control.message_map_mode(), feedback_rule, not control.needs_takeover(), control.mapping_sensitivity)
            elif control.message_type() is MIDI_PB_TYPE:
                success = Live.MidiMap.map_midi_pitchbend_with_feedback_map(midi_map_handle, parameter, control.message_channel(), feedback_rule, not control.needs_takeover())
            success and Live.MidiMap.send_feedback_for_parameter(midi_map_handle, parameter)
        return success

    def _install_forwarding(self, midi_map_handle, control):
        if not self._in_build_midi_map:
            raise AssertionError
            raise control != None or AssertionError
            if not isinstance(control, InputControlElement):
                raise AssertionError
                success = False
                success = control.message_type() is MIDI_NOTE_TYPE and Live.MidiMap.forward_midi_note(self._c_instance.handle(), midi_map_handle, control.message_channel(), control.message_identifier())
            elif control.message_type() is MIDI_CC_TYPE:
                success = Live.MidiMap.forward_midi_cc(self._c_instance.handle(), midi_map_handle, control.message_channel(), control.message_identifier())
            elif control.message_type() is MIDI_PB_TYPE:
                success = Live.MidiMap.forward_midi_pitchbend(self._c_instance.handle(), midi_map_handle, control.message_channel())
            else:
                raise control.message_type() == MIDI_SYSEX_TYPE or AssertionError
                success = True
            forwarding_keys = success and control.identifier_bytes()
            for key in forwarding_keys:
                registry = self._forwarding_registry if control.message_type() != MIDI_SYSEX_TYPE else self._forwarding_long_identifier_registry
                raise key not in registry.keys() or AssertionError, 'Registry key %s registered twice. Check Midi messages!' % str(key)
                registry[key] = control

        return success

    def _translate_message(self, type, from_identifier, from_channel, to_identifier, to_channel):
        if not type in (MIDI_CC_TYPE, MIDI_NOTE_TYPE):
            raise AssertionError
            raise from_identifier in range(128) or AssertionError
            raise from_channel in range(16) or AssertionError
            raise to_identifier in range(128) or AssertionError
            raise to_channel in range(16) or AssertionError
            type == MIDI_CC_TYPE and self._c_instance.set_cc_translation(from_identifier, from_channel, to_identifier, to_channel)
        elif type == MIDI_NOTE_TYPE:
            self._c_instance.set_note_translation(from_identifier, from_channel, to_identifier, to_channel)
        else:
            raise False or AssertionError

    def _set_session_highlight(self, track_offset, scene_offset, width, height, include_return_tracks):
        raise list((track_offset,
         scene_offset,
         width,
         height)).count(-1) != 4 and (width > 0 or AssertionError)
        if not height > 0:
            raise AssertionError
        self._c_instance.set_session_highlight(track_offset, scene_offset, width, height, include_return_tracks)

    def _on_track_list_changed(self):
        for component in self._components:
            component.on_track_list_changed()

        self.schedule_message(1, self._on_selected_track_changed)

    def _on_scene_list_changed(self):
        for component in self._components:
            component.on_scene_list_changed()

    def _on_selected_track_changed(self):
        for component in self._components:
            component.on_selected_track_changed()

        if self._device_selection_follows_track_selection:
            self._update_device_selection()

    def _on_selected_scene_changed(self):
        for component in self._components:
            component.on_selected_scene_changed()

    def _toggle_lock(self):
        raise self._device_component != None or AssertionError
        self._c_instance.toggle_lock()

    def _refresh_displays(self):
        """
        Make sure the displays of the control surface display current
        data.
        """
        for display in self._displays:
            display.update()
            display._tasks.update(Defaults.TIMER_DELAY)

    def _update_device_selection(self):
        track = self.song().view.selected_track
        device_to_select = track.view.selected_device
        if device_to_select == None and len(track.devices) > 0:
            device_to_select = track.devices[0]
        if device_to_select != None:
            self.song().view.select_device(device_to_select)
            self._device_component.set_device(self.song().appointed_device)
        else:
            self._device_component.set_device(None)
########NEW FILE########
__FILENAME__ = ControlSurfaceComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/ControlSurfaceComponent.py
import Live
from Dependency import dependency, depends
from SubjectSlot import SlotManager, Subject
from Util import lazy_attribute
import Task

class ControlSurfaceComponent(SlotManager, Subject):
    """
    Base class for all classes encapsulating functions in Live
    """
    name = ''
    canonical_parent = None
    is_private = False
    _show_msg_callback = dependency(show_message=None)
    _has_task_group = False
    _layer = None

    @depends(register_component=None, song=None)
    def __init__(self, name = '', register_component = None, song = None, layer = None, is_enabled = True, *a, **k):
        if not callable(register_component):
            raise AssertionError
            super(ControlSurfaceComponent, self).__init__(*a, **k)
            self.name = name
            raise layer is None or not is_enabled or AssertionError
            self._explicit_is_enabled = is_enabled
            self._recursive_is_enabled = True
            self._is_enabled = self._explicit_is_enabled
            self._allow_updates = True
            self._update_requests = 0
            self._song = song
            self._layer = layer is not None and layer
        register_component(self)

    def disconnect(self):
        if self._has_task_group:
            self._tasks.kill()
            self._tasks.clear()
        super(ControlSurfaceComponent, self).disconnect()

    def _internal_on_enabled_changed(self):
        if self._layer:
            if self.is_enabled():
                grabbed = self._layer.grab(self)
                if not grabbed:
                    raise AssertionError, 'Only one component can use a layer at atime'
                else:
                    self._layer.release(self)
            if self._has_task_group:
                self.is_enabled() and self._tasks.resume()
            else:
                self._tasks.pause()

    def on_enabled_changed(self):
        self.update()

    def update(self):
        raise NotImplementedError, self.__class__

    def update_all(self):
        self.update()

    def set_enabled(self, enable):
        self._explicit_is_enabled = bool(enable)
        self._update_is_enabled()

    def _set_enabled_recursive(self, enable):
        self._recursive_is_enabled = bool(enable)
        self._update_is_enabled()

    def _update_is_enabled(self):
        if self._recursive_is_enabled:
            is_enabled = self._explicit_is_enabled
            self._is_enabled = is_enabled != self._is_enabled and is_enabled
            self._internal_on_enabled_changed()
            self.on_enabled_changed()

    def set_allow_update(self, allow_updates):
        allow = bool(allow_updates)
        if self._allow_updates != allow:
            self._allow_updates = allow
            if self._allow_updates and self._update_requests > 0:
                self._update_requests = 0
                self.update()

    def application(self):
        return Live.Application.get_application()

    def song(self):
        return self._song

    @lazy_attribute
    @depends(parent_task_group=None)
    def _tasks(self, parent_task_group = None):
        tasks = parent_task_group.add(Task.TaskGroup())
        if not self._is_enabled:
            tasks.pause()
        self._has_task_group = True
        return tasks

    def _get_layer(self):
        return self._layer

    def _set_layer(self, new_layer):
        if self._layer != new_layer:
            self._layer and self._layer.release(self)
        self._layer = new_layer
        if new_layer and self.is_enabled():
            grabbed = new_layer.grab(self)
            if not grabbed:
                raise AssertionError, 'Only one component can use a layer at atime'

    layer = property(_get_layer, _set_layer)

    def is_enabled(self, explicit = False):
        """
        Returns whether the component is enabled.
        If 'explicit' is True the parent state is ignored.
        """
        return self._is_enabled if not explicit else self._explicit_is_enabled

    def on_track_list_changed(self):
        """
        Called by the control surface if tracks are added/removed,
        to be overridden
        """
        pass

    def on_scene_list_changed(self):
        """
        Called by the control surface if scenes are added/removed, to
        be overridden
        """
        pass

    def on_selected_track_changed(self):
        """
        Called by the control surface when a track is selected, to be
        overridden
        """
        pass

    def on_selected_scene_changed(self):
        """
        Called by the control surface when a scene is selected, to be
        overridden
        """
        pass

    @depends(parent_task_group=None)
    def _register_timer_callback(self, callback, parent_task_group = None):
        """
        DEPRECATED. Use tasks instead
        """
        raise callable(callback) or AssertionError
        raise parent_task_group.find(callback) is None or AssertionError

        def wrapper(delta):
            callback()
            return Task.RUNNING

        parent_task_group.add(Task.FuncTask(wrapper, callback))

    @depends(parent_task_group=None)
    def _unregister_timer_callback(self, callback, parent_task_group = None):
        """
        DEPRECATED. Use tasks instead
        """
        raise callable(callback) or AssertionError
        task = parent_task_group.find(callback)
        raise task is not None or AssertionError
        parent_task_group.remove(task)
########NEW FILE########
__FILENAME__ = Debug
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/Debug.py
enable_debug_output = True

def debug_print(*a):
    """ Special function for debug output """
    if enable_debug_output:
        print ' '.join(map(str, a))
########NEW FILE########
__FILENAME__ = Defaults
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/Defaults.py
TIMER_DELAY = 0.1
MOMENTARY_DELAY = 0.3
MOMENTARY_DELAY_TICKS = int(MOMENTARY_DELAY / TIMER_DELAY)
########NEW FILE########
__FILENAME__ = Dependency
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/Dependency.py
"""
Dependency injection framework.

The framework provides lously coupled passing of dependencies from
providers to the objects that require them.

Dependencies are identified by keys, that are valid Python
identifiers.  Dependencies are provided via accessor functions, that
in general will be called whenever they are needed.
"""
__all__ = ('inject', 'depends', 'dependency')
from functools import wraps
from Util import union

class DependencyError(Exception):
    pass


class InjectionRegistry(object):

    def __init__(self, parent = None, *a, **k):
        super(InjectionRegistry, self).__init__(*a, **k)
        self._key_registry = {}

    def register_key(self, key, injector):
        self._key_registry.setdefault(key, []).append(injector)

    def unregister_key(self, key, injector):
        self._key_registry[key].remove(injector)
        if not self._key_registry[key]:
            del self._key_registry[key]

    def get(self, key, default = None):
        try:
            return self._key_registry[key][-1].provides[key]
        except KeyError:
            return default


_global_injection_registry = InjectionRegistry()

def get_dependency_for(obj, name, default = None):
    accessor = _global_injection_registry.get(name, default)
    if accessor is not None:
        return accessor()
    else:
        raise DependencyError('Required dependency %s not provided for %s' % (name, str(obj)))


class dependency(object):
    """
    Data descriptor that provides a given dependency looking as an
    attribute.  The depedency is specified as a keyword parameter,
    whose value can be a default accessor or None.  The attribute only
    tries to fetch the dependency on deman when needed.  Example::
    
         class HttpServer(object):
             connection_port = dependency(http_port = const(80))
    
         server = HttpServer()
         assert server.connection_port == 80
         with inject(connection_port = const(8000)).everywhere():
             assert server.connection_port == 8000
    """

    def __init__(self, **k):
        raise len(k) == 1 or AssertionError
        self._dependency_name, self._dependency_default = k.items()[0]

    def __get__(self, obj, cls = None):
        if obj is None:
            obj = cls
        return get_dependency_for(obj, self._dependency_name, self._dependency_default)


def depends(**dependencies):
    """
    Decorates a method where dependencies are passed as keyword
    parameters.  Dependencies are specified as keywords with an
    optional accessor function or None if required.  Dependencies can
    be injected or passed directly as keyword parameters.  Example::
    
        class HttpServer(object):
            @depends(http_port = const(80))
            def listen(http_port = None):
                print "Listening on", http_port
    
        server = HttpServer()
        server.listen()
        server.listen(http_port = 8000)
        with inject(http_port = const(8000)).everywhere():
            server.listen()
    
    Produces the output::
    
        Listening on port 80
        Listening on port 8000
        Listening on port 8000
    """

    def decorator(func):

        @wraps(func)
        def wrapper(self, *a, **explicit):
            deps = dict([ (k, get_dependency_for(self, k, v)) for k, v in dependencies.iteritems() if k not in explicit ])
            return func(self, *a, **union(deps, explicit))

        return wrapper

    return decorator


class Injector(object):

    @property
    def provides(self):
        return {}

    def register(self):
        pass

    def unregister(self):
        pass

    def __enter__(self):
        self.register()
        return self

    def __exit__(self, *a):
        self.unregister()


class RegistryInjector(Injector):

    def __init__(self, provides = None, registry = None, *a, **k):
        super(Injector, self).__init__(*a, **k)
        self._provides_dict = provides
        self._registry = registry

    @property
    def provides(self):
        return self._provides_dict

    def register(self):
        registry = self._registry
        for k in self._provides_dict:
            registry.register_key(k, self)

    def unregister(self):
        registry = self._registry
        for k in self._provides_dict:
            registry.unregister_key(k, self)


class InjectionFactory(object):

    def __init__(self, provides = None, *a, **k):
        super(InjectionFactory, self).__init__(*a, **k)
        self._provides_dict = provides

    def everywhere(self):
        return RegistryInjector(provides=self._provides_dict, registry=_global_injection_registry)

    into_object = NotImplemented
    into_class = NotImplemented


def inject(**k):
    """
    Inject returns a InjectorFactory that can generate Injectors to
    inject the provided keys at different levels.  The values to
    inject are specified as keyword parameters mapping keys to given
    nullary callables that will be used to access the dependency when
    needed.
    """
    return InjectionFactory(k)
########NEW FILE########
__FILENAME__ = DeviceBankRegistry
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/DeviceBankRegistry.py
"""
Classes to keep a global registry of the currently selected bank for
given device instances.

[jbo] After some though about this, I personally believe that moving
banking to the C++ code is the best mid-term solution.
"""
from SubjectSlot import Subject

class DeviceBankRegistry(Subject):
    __subject_events__ = ('device_bank',)

    def __init__(self, *a, **k):
        super(DeviceBankRegistry, self).__init__(*a, **k)
        self._device_bank_registry = {}
        self._device_bank_listeners = []

    def compact_registry(self):
        newreg = dict(filter(lambda (k, _): k != None, self._device_bank_registry.items()))
        self._device_bank_registry = newreg

    def set_device_bank(self, device, bank):
        if not self._find_device_bank_key(device):
            key = device
            old = self._device_bank_registry[key] if key in self._device_bank_registry else 0
            self._device_bank_registry[key] = old != bank and bank
            self.notify_device_bank(device, bank)

    def get_device_bank(self, device):
        return self._device_bank_registry.get(self._find_device_bank_key(device), 0)

    def _find_device_bank_key(self, device):
        for k in self._device_bank_registry.iterkeys():
            if k == device:
                return k
########NEW FILE########
__FILENAME__ = DeviceComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/DeviceComponent.py
import Live
from _Generic.Devices import device_parameters_to_map, number_of_parameter_banks, parameter_banks, parameter_bank_names, best_of_parameter_bank
from ControlSurfaceComponent import ControlSurfaceComponent
from ButtonElement import ButtonElement
from DisplayDataSource import DisplayDataSource
from DeviceBankRegistry import DeviceBankRegistry

class DeviceComponent(ControlSurfaceComponent):
    """ Class representing a device in Live """

    def __init__(self, device_bank_registry = None, *a, **k):
        super(DeviceComponent, self).__init__(*a, **k)
        self._device_bank_registry = device_bank_registry or DeviceBankRegistry()
        self._device_bank_registry.add_device_bank_listener(self._on_device_bank_changed)
        self._device = None
        self._device_listeners = []
        self._parameter_controls = None
        self._bank_up_button = None
        self._bank_down_button = None
        self._bank_buttons = None
        self._on_off_button = None
        self._lock_button = None
        self._lock_callback = None
        self._device_name_data_source = None
        self._bank_index = 0
        self._bank_name = '<No Bank>'
        self._locked_to_device = False

    def disconnect(self):
        self._device_bank_registry.remove_device_bank_listener(self._on_device_bank_changed)
        self._device_bank_registry = None
        self._lock_callback = None
        self._release_parameters(self._parameter_controls)
        self._parameter_controls = None
        if self._bank_up_button != None:
            self._bank_up_button.remove_value_listener(self._bank_up_value)
            self._bank_up_button = None
        if self._bank_down_button != None:
            self._bank_down_button.remove_value_listener(self._bank_down_value)
            self._bank_down_button = None
        if self._bank_buttons != None:
            for button in self._bank_buttons:
                button.remove_value_listener(self._bank_value)

        self._bank_buttons = None
        if self._on_off_button != None:
            self._on_off_button.remove_value_listener(self._on_off_value)
            self._on_off_button = None
        if self._lock_button != None:
            self._lock_button.remove_value_listener(self._lock_value)
            self._lock_button = None
        if self._device != None:
            parameter = self._on_off_parameter()
            if parameter != None:
                parameter.remove_value_listener(self._on_on_off_changed)
            self._device.remove_name_listener(self._on_device_name_changed)
            self._device.remove_parameters_listener(self._on_parameters_changed)
            self._device = None
        self._device_listeners = None
        super(DeviceComponent, self).disconnect()

    def on_enabled_changed(self):
        self.update()

    def device(self):
        return self._device

    def set_device(self, device):
        if not (device == None or isinstance(device, Live.Device.Device)):
            raise AssertionError
            if not self._locked_to_device and device != self._device:
                if self._device != None:
                    self._device.remove_name_listener(self._on_device_name_changed)
                    self._device.remove_parameters_listener(self._on_parameters_changed)
                    parameter = self._on_off_parameter()
                    if parameter != None:
                        parameter.remove_value_listener(self._on_on_off_changed)
                    self._release_parameters(self._parameter_controls)
                self._device = device
                if self._device != None:
                    self._bank_index = 0
                    self._device.add_name_listener(self._on_device_name_changed)
                    self._device.add_parameters_listener(self._on_parameters_changed)
                    parameter = self._on_off_parameter()
                    parameter != None and parameter.add_value_listener(self._on_on_off_changed)
            self._bank_index = self._device_bank_registry.get_device_bank(self._device)
            self._bank_name = '<No Bank>'
            self._on_device_name_changed()
            self.update()
            for listener in self._device_listeners:
                listener()

    def set_bank_nav_buttons(self, down_button, up_button):
        if not (up_button != None or down_button == None):
            raise AssertionError
            if not (up_button == None or isinstance(up_button, ButtonElement)):
                raise AssertionError
                if not (down_button == None or isinstance(down_button, ButtonElement)):
                    raise AssertionError
                    do_update = False
                    if up_button != self._bank_up_button:
                        do_update = True
                        if self._bank_up_button != None:
                            self._bank_up_button.remove_value_listener(self._bank_up_value)
                        self._bank_up_button = up_button
                        if self._bank_up_button != None:
                            self._bank_up_button.add_value_listener(self._bank_up_value)
                    if down_button != self._bank_down_button:
                        do_update = True
                        self._bank_down_button != None and self._bank_down_button.remove_value_listener(self._bank_down_value)
                    self._bank_down_button = down_button
                    self._bank_down_button != None and self._bank_down_button.add_value_listener(self._bank_down_value)
            do_update and self.update()

    def set_bank_buttons(self, buttons):
        if self._bank_buttons != None:
            for button in self._bank_buttons:
                button.remove_value_listener(self._bank_value)

        self._bank_buttons = buttons
        if self._bank_buttons != None:
            identify_sender = True
            for button in self._bank_buttons:
                button.add_value_listener(self._bank_value, identify_sender)

        self.update()

    def set_parameter_controls(self, controls):
        self._release_parameters(self._parameter_controls)
        self._parameter_controls = controls
        self.update()

    def set_lock_to_device(self, lock, device):
        if lock:
            self.set_device(device)
        self._locked_to_device = lock
        if self.is_enabled() and self._lock_button != None:
            self._lock_button.set_light(self._locked_to_device)

    def set_lock_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._lock_button != None:
                self._lock_button.remove_value_listener(self._lock_value)
                self._lock_button = None
            self._lock_button = button
            self._lock_button != None and self._lock_button.add_value_listener(self._lock_value)
        self.update()

    def set_on_off_button(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._on_off_button != None:
                self._on_off_button.remove_value_listener(self._on_off_value)
                self._on_off_button = None
            self._on_off_button = button
            self._on_off_button != None and self._on_off_button.add_value_listener(self._on_off_value)
        self.update()

    def set_lock_callback(self, callback):
        raise self._lock_callback == None or AssertionError
        raise callback != None or AssertionError
        raise dir(callback).count('im_func') is 1 or AssertionError
        self._lock_callback = callback

    def restore_bank(self, bank_index):
        if self._device != None and self._is_banking_enabled() and self._locked_to_device and self._number_of_parameter_banks() > bank_index and self._bank_index != bank_index:
            self._bank_index = bank_index
            self.update()

    def device_name_data_source(self):
        if self._device_name_data_source == None:
            self._device_name_data_source = DisplayDataSource()
            self._on_device_name_changed()
        return self._device_name_data_source

    def device_has_listener(self, listener):
        return listener in self._device_listeners

    def add_device_listener(self, listener):
        raise not self.device_has_listener(listener) or AssertionError
        self._device_listeners.append(listener)

    def remove_device_listener(self, listener):
        raise self.device_has_listener(listener) or AssertionError
        self._device_listeners.remove(listener)

    def update(self):
        if self.is_enabled() and self._device != None:
            self._device_bank_registry.set_device_bank(self._device, self._bank_index)
            if self._parameter_controls != None:
                old_bank_name = self._bank_name
                self._assign_parameters()
                if self._bank_name != old_bank_name:
                    self._show_msg_callback(self._device.name + ' Bank: ' + self._bank_name)
            if self._bank_up_button != None and self._bank_down_button != None:
                can_bank_up = self._bank_index == None or self._number_of_parameter_banks() > self._bank_index + 1
                can_bank_down = self._bank_index == None or self._bank_index > 0
                self._bank_up_button.set_light(can_bank_up)
                self._bank_down_button.set_light(can_bank_down)
            if self._bank_buttons != None:
                for index, button in enumerate(self._bank_buttons):
                    button.set_light(index == self._bank_index)

        else:
            if self._lock_button != None:
                self._lock_button.turn_off()
            if self._bank_up_button != None:
                self._bank_up_button.turn_off()
            if self._bank_down_button != None:
                self._bank_down_button.turn_off()
            if self._bank_buttons != None:
                for button in self._bank_buttons:
                    button.turn_off()

            if self._parameter_controls != None:
                self._release_parameters(self._parameter_controls)

    def _bank_up_value(self, value):
        raise self._bank_up_button != None or AssertionError
        raise value != None or AssertionError
        raise isinstance(value, int) or AssertionError
        if self.is_enabled():
            if not self._bank_up_button.is_momentary() or value is not 0:
                if self._device != None:
                    num_banks = self._number_of_parameter_banks()
                    if self._bank_down_button == None:
                        self._bank_name = ''
                        self._bank_index = (self._bank_index + 1) % num_banks if self._bank_index != None else 0
                        self.update()
                    elif self._bank_index == None or num_banks > self._bank_index + 1:
                        self._bank_name = ''
                        self._bank_index = self._bank_index + 1 if self._bank_index != None else 0
                        self.update()

    def _bank_down_value(self, value):
        if not self._bank_down_button != None:
            raise AssertionError
            raise value != None or AssertionError
            if not isinstance(value, int):
                raise AssertionError
                if self.is_enabled():
                    self._bank_name = (not self._bank_down_button.is_momentary() or value is not 0) and self._device != None and (self._bank_index == None or self._bank_index > 0) and ''
                    self._bank_index = self._bank_index - 1 if self._bank_index != None else max(0, self._number_of_parameter_banks() - 1)
                    self.update()

    def _lock_value(self, value):
        if not self._lock_button != None:
            raise AssertionError
            raise self._lock_callback != None or AssertionError
            raise value != None or AssertionError
            raise isinstance(value, int) or AssertionError
            (not self._lock_button.is_momentary() or value is not 0) and self._lock_callback()

    def _on_off_value(self, value):
        if not self._on_off_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                parameter = (not self._on_off_button.is_momentary() or value is not 0) and self._on_off_parameter()
                parameter.value = parameter != None and parameter.is_enabled and float(int(parameter.value == 0.0))

    def _bank_value(self, value, button):
        if not self._bank_buttons != None:
            raise AssertionError
            raise value != None or AssertionError
            raise button != None or AssertionError
            raise isinstance(value, int) or AssertionError
            raise isinstance(button, ButtonElement) or AssertionError
            if not list(self._bank_buttons).count(button) == 1:
                raise AssertionError
                if self.is_enabled() and self._device != None:
                    if not button.is_momentary() or value is not 0:
                        bank = list(self._bank_buttons).index(button)
                        self._bank_name = bank != self._bank_index and self._number_of_parameter_banks() > bank and ''
                        self._bank_index = bank
                        self.update()
                else:
                    self._show_msg_callback(self._device.name + ' Bank: ' + self._bank_name)

    def _is_banking_enabled(self):
        direct_banking = self._bank_buttons != None
        roundtrip_banking = self._bank_up_button != None
        increment_banking = self._bank_up_button != None and self._bank_down_button != None
        return direct_banking or roundtrip_banking or increment_banking

    def _assign_parameters(self):
        raise self.is_enabled() or AssertionError
        raise self._device != None or AssertionError
        raise self._parameter_controls != None or AssertionError
        self._bank_name, bank = self._current_bank_details()
        for control, parameter in zip(self._parameter_controls, bank):
            if control != None:
                if parameter != None:
                    control.connect_to(parameter)
                else:
                    control.release_parameter()

        self._release_parameters(self._parameter_controls[len(bank):])

    def _on_device_name_changed(self):
        if self._device_name_data_source != None:
            if self.is_enabled() and self._device != None:
                self._device_name_data_source.set_display_string(self._device.name)
            else:
                self._device_name_data_source.set_display_string('No Device')

    def _on_parameters_changed(self):
        self.update()

    def _on_off_parameter(self):
        result = None
        if self._device != None:
            for parameter in self._device.parameters:
                if str(parameter.name).startswith('Device On'):
                    result = parameter
                    break

        return result

    def _on_on_off_changed(self):
        if self.is_enabled() and self._on_off_button != None:
            turn_on = False
            if self._device != None:
                parameter = self._on_off_parameter()
                if parameter != None:
                    turn_on = parameter.value > 0.0
                turn_on and self._on_off_button.turn_on()
            else:
                self._on_off_button.turn_off()

    def _best_of_parameter_bank(self):
        return best_of_parameter_bank(self._device)

    def _parameter_banks(self):
        return parameter_banks(self._device)

    def _parameter_bank_names(self):
        return parameter_bank_names(self._device)

    def _device_parameters_to_map(self):
        return device_parameters_to_map(self._device)

    def _number_of_parameter_banks(self):
        return number_of_parameter_banks(self._device)

    def _current_bank_details(self):
        bank_name = self._bank_name
        bank = []
        best_of = self._best_of_parameter_bank()
        banks = self._parameter_banks()
        if banks:
            if self._bank_index != None and self._is_banking_enabled() or not best_of:
                index = self._bank_index if self._bank_index != None else 0
                bank = banks[index]
                bank_name = self._parameter_bank_names()[index]
            else:
                bank = best_of
                bank_name = 'Best of Parameters'
        return (bank_name, bank)

    def _on_device_bank_changed(self, device, bank):
        if device == self._device:
            self._bank_index = bank
            self.update()

    def _release_parameters(self, controls):
        if controls != None:
            for control in controls:
                if control != None:
                    control.release_parameter()
########NEW FILE########
__FILENAME__ = Disconnectable
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/Disconnectable.py
"""
Interface for items that adquire resources.
"""
from Util import find_if

class Disconnectable(object):
    """
    Represents an entity that holds connections to other objects that
    should be explicitly cleared to avoid object lifetime problems or
    leaking listeners.
    """

    def disconnect(self):
        pass


class CompoundDisconnectable(Disconnectable):
    """
    Compound disconnectable. Collects other disconnectables and
    disconnects them recursively.
    """

    def __init__(self, *a, **k):
        super(CompoundDisconnectable, self).__init__(*a, **k)
        self._registered_disconnectables = []

    def register_disconnectable(self, slot):
        if slot not in self._registered_disconnectables:
            self._registered_disconnectables.append(slot)
        return slot

    def unregister_disconnectable(self, slot):
        if slot in self._registered_disconnectables:
            self._registered_disconnectables.remove(slot)

    def disconnect_disconnectable(self, slot):
        if slot in self._registered_disconnectables:
            self._registered_disconnectables.remove(slot)
            slot.disconnect()

    def find_disconnectable(self, predicate):
        return find_if(predicate, self._registered_disconnectables)

    def has_disconnectable(self, slot):
        return slot in self._registered_disconnectables

    def disconnect(self):
        for slot in self._registered_disconnectables:
            slot.disconnect()

        self._registered_disconnectables = []
        super(CompoundDisconnectable, self).disconnect()


class disconnectable(object):
    """
    Context manager that will disconnect the given disconnectable when
    the context is exited.  It returns the original disconnectable.
    """

    def __init__(self, managed = None, *a, **k):
        super(disconnectable, self).__init__(*a, **k)
        self._managed = managed

    def __enter__(self):
        managed = self._managed
        return managed

    def __exit__(self, *a, **k):
        if self._managed is not None:
            self._managed.disconnect()
########NEW FILE########
__FILENAME__ = DisplayDataSource
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/DisplayDataSource.py
from functools import partial

def adjust_string_crop(original, length):
    return original[:length].ljust(length)


def adjust_string(original, length):
    """
    Brings the string to the given length by either removing
    characters or adding spaces. The algorithm is adopted from ede's
    old implementation for the Mackie.
    """
    if not length > 0:
        raise AssertionError
        resulting_string = original
        if len(resulting_string) > length:
            if resulting_string.endswith('dB'):
                unit_db = resulting_string.find('.') != -1
                resulting_string = len(resulting_string.strip()) > length and unit_db and resulting_string[:-2]
            if len(resulting_string) > length:
                for char in (' ', '_', 'i', 'o', 'u', 'e', 'a'):
                    offset = 0 if char == ' ' else 1
                    while len(resulting_string) > length and resulting_string.rfind(char, offset) > 0:
                        char_pos = resulting_string.rfind(char, offset)
                        resulting_string = resulting_string[:char_pos] + resulting_string[char_pos + 1:]

                resulting_string = resulting_string[:length]
        resulting_string = len(resulting_string) < length and resulting_string.ljust(length)
    return resulting_string


class DisplayDataSource(object):
    """
    Data object that is fed with a specific string and notifies a
    observer via its update_callback.
    """
    _separator = ''
    _adjust_string_fn = partial(adjust_string)

    def __init__(self, display_string = '', separator = None, adjust_string_fn = adjust_string, *a, **k):
        super(DisplayDataSource, self).__init__(*a, **k)
        if adjust_string_fn is not None:
            self._adjust_string_fn = partial(adjust_string_fn)
        if separator is not None:
            self._separator = separator
        self._display_string = display_string
        self._update_callback = None
        self._in_update = False

    def _get_separator(self):
        return self._separator

    def _set_separator(self, separator):
        if separator != self._separator:
            self._separator = separator
            self.update()

    separator = property(_get_separator, _set_separator)

    def set_update_callback(self, update_callback):
        if not (not update_callback or callable(update_callback)):
            raise AssertionError
            self._update_callback = update_callback
            update_callback and self.update()

    def set_display_string(self, new_string):
        if self._display_string != new_string:
            self._display_string = new_string
            self.update()

    def clear(self):
        self.set_display_string('')
        self.separator = ''

    def update(self):
        if not not self._in_update:
            raise AssertionError
            self._in_update = True
            self._update_callback != None and self._update_callback()
        self._in_update = False

    def display_string(self):
        return self._display_string

    def adjust_string(self, width):
        return self._adjust_string_fn(self.display_string(), width)
########NEW FILE########
__FILENAME__ = EncoderElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/EncoderElement.py
import Live
from SubjectSlot import SubjectEvent
from InputControlElement import InputControlElement, MIDI_CC_TYPE, InputSignal

def _not_implemented(value):
    raise NotImplementedError


_map_modes = map_modes = Live.MidiMap.MapMode
ENCODER_VALUE_NORMALIZER = {_map_modes.relative_smooth_two_compliment: lambda v: v if v <= 64 else v - 128,
 _map_modes.relative_smooth_signed_bit: lambda v: v if v <= 64 else 64 - v}

class EncoderElement(InputControlElement):
    """
    Class representing a continuous control on the controller.
    
    The normalized value notifies a delta in the range:
        (-encoder_sensitivity, +encoder_sensitvity)
    """
    __subject_events__ = (SubjectEvent(name='normalized_value', signal=InputSignal),)
    encoder_sensitivity = 1.0

    def __init__(self, msg_type, channel, identifier, map_mode, encoder_sensitivity = None, *a, **k):
        super(EncoderElement, self).__init__(msg_type, channel, identifier, *a, **k)
        if encoder_sensitivity is not None:
            self.encoder_sensitivity = encoder_sensitivity
        self.__map_mode = map_mode
        self.__value_normalizer = ENCODER_VALUE_NORMALIZER.get(map_mode, _not_implemented)

    def message_map_mode(self):
        raise self.message_type() is MIDI_CC_TYPE or AssertionError
        return self.__map_mode

    def relative_value_to_delta(self, value):
        raise value >= 0 and value < 128 or AssertionError
        return self.__value_normalizer(value)

    def notify_value(self, value):
        super(EncoderElement, self).notify_value(value)
        if self.normalized_value_listener_count():
            normalized = self.relative_value_to_delta(value) / 64.0 * self.encoder_sensitivity
            self.notify_normalized_value(normalized)
########NEW FILE########
__FILENAME__ = InputControlElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/InputControlElement.py
from __future__ import with_statement
import contextlib
from Dependency import depends
from SubjectSlot import SubjectEvent
from Signal import Signal
from NotifyingControlElement import NotifyingControlElement
from Util import in_range, const, nop
from Debug import debug_print
from Disconnectable import Disconnectable
import Task
MIDI_NOTE_TYPE = 0
MIDI_CC_TYPE = 1
MIDI_PB_TYPE = 2
MIDI_SYSEX_TYPE = 3
MIDI_INVALID_TYPE = 4
MIDI_MSG_TYPES = (MIDI_NOTE_TYPE,
 MIDI_CC_TYPE,
 MIDI_PB_TYPE,
 MIDI_SYSEX_TYPE,
 MIDI_INVALID_TYPE)
MIDI_NOTE_ON_STATUS = 144
MIDI_NOTE_OFF_STATUS = 128
MIDI_CC_STATUS = 176
MIDI_PB_STATUS = 224

class ParameterSlot(Disconnectable):
    """
    Maintains the connection between a parameter and
    InputControlElement. Keeps the invariant that whenever both
    parameter and control are set, the parameter is connected to the
    control.  Whenever any of them is changed, they are disconnected
    and reconnected to the new one, in a similar fashion to a
    SubjectSlot.
    """
    _parameter = None
    _control = None

    def __init__(self, parameter = None, control = None, *a, **k):
        super(ParameterSlot, self).__init__(*a, **k)
        self.parameter = parameter
        self.control = control

    def _get_control(self):
        return self._control

    def _set_control(self, control):
        if control != self._control:
            self.soft_disconnect()
            self._control = control
            self.connect()

    control = property(_get_control, _set_control)

    def _get_parameter(self):
        return self._parameter

    def _set_parameter(self, parameter):
        if parameter != self._parameter:
            self.soft_disconnect()
            self._parameter = parameter
            self.connect()

    parameter = property(_get_parameter, _set_parameter)

    def connect(self):
        if self._control != None and self._parameter != None:
            self._control.connect_to(self._parameter)

    def soft_disconnect(self):
        if self._control != None and self._parameter != None:
            self._control.release_parameter()

    def disconnect(self):
        self.parameter = None
        self.control = None
        super(ParameterSlot, self).disconnect()


class InputSignal(Signal):
    """
    Special signal type that makes sure that interaction with input
    works properly. Special input control elements that define
    value-dependent properties should use this kind of signal.
    """

    def __init__(self, sender = None, *a, **k):
        super(InputSignal, self).__init__(sender=sender, *a, **k)
        self._input_control = sender

    @contextlib.contextmanager
    def _listeners_update(self):
        try:
            control = self._input_control
            old_count = self.count
            old_wants_forwarding = control.script_wants_forwarding()
            yield
        finally:
            diff_count = self.count - old_count
            control._input_signal_listener_count += diff_count
            if old_wants_forwarding != control.script_wants_forwarding():
                self._input_control._request_rebuild()

    def connect(self, *a, **k):
        with self._listeners_update():
            super(InputSignal, self).connect(*a, **k)

    def disconnect(self, *a, **k):
        with self._listeners_update():
            super(InputSignal, self).disconnect(*a, **k)

    def disconnect_all(self, *a, **k):
        with self._listeners_update():
            super(InputSignal, self).disconnect_all(*a, **k)


class InputControlElement(NotifyingControlElement):
    """
    Base class for all classes representing control elements on a controller
    """

    class ProxiedInterface(NotifyingControlElement.ProxiedInterface):
        send_value = nop

    __subject_events__ = (SubjectEvent(name='value', signal=InputSignal, override=True),)
    _input_signal_listener_count = 0
    num_delayed_messages = 1
    send_depends_on_forwarding = True

    @depends(request_rebuild_midi_map=const(nop))
    def __init__(self, msg_type = None, channel = None, identifier = None, sysex_identifier = None, request_rebuild_midi_map = None, *a, **k):
        raise msg_type in MIDI_MSG_TYPES or AssertionError
        raise in_range(channel, 0, 16) or channel is None or AssertionError
        raise in_range(identifier, 0, 128) or identifier is None or AssertionError
        raise msg_type != MIDI_SYSEX_TYPE or channel == None or AssertionError
        raise msg_type != MIDI_SYSEX_TYPE or identifier == None or AssertionError
        raise msg_type == MIDI_SYSEX_TYPE or sysex_identifier == None or AssertionError
        super(InputControlElement, self).__init__(*a, **k)
        self._request_rebuild = request_rebuild_midi_map
        self._msg_type = msg_type
        self._msg_channel = channel
        self._msg_identifier = identifier
        self._msg_sysex_identifier = sysex_identifier
        self._original_channel = channel
        self._original_identifier = identifier
        self._needs_takeover = True
        self._is_mapped = True
        self._is_being_forwarded = True
        self._delayed_messages = []
        self._force_next_send = False
        self._mapping_feedback_delay = 0
        self._mapping_sensitivity = 1.0
        self._send_delayed_messages_task = self._tasks.add(Task.run(self._send_delayed_messages))
        self._send_delayed_messages_task.kill()
        self._parameter_to_map_to = None
        self._in_parameter_gesture = False
        self._last_sent_message = None
        self._report_input = False
        self._report_output = False

    def message_type(self):
        return self._msg_type

    def message_channel(self):
        return self._msg_channel

    def message_identifier(self):
        return self._msg_identifier

    def message_sysex_identifier(self):
        return self._msg_sysex_identifier

    def message_map_mode(self):
        raise NotImplementedError

    def _get_mapping_sensitivity(self):
        return self._mapping_sensitivity

    def _set_mapping_sensitivity(self, sensitivity):
        self._mapping_sensitivity = sensitivity

    mapping_sensitivity = property(_get_mapping_sensitivity, _set_mapping_sensitivity)

    def force_next_send(self):
        """
        Enforces sending the next value regardless of wether the
        control is mapped to the script.
        """
        self._force_next_send = True

    def set_channel(self, channel):
        if not self._msg_type != MIDI_SYSEX_TYPE:
            raise AssertionError
            raise in_range(channel, 0, 16) or channel == None or AssertionError
            self._msg_channel = self._msg_channel != channel and channel
            self._request_rebuild()

    def set_identifier(self, identifier):
        if not self._msg_type != MIDI_SYSEX_TYPE:
            raise AssertionError
            raise in_range(identifier, 0, 128) or identifier == None or AssertionError
            self._msg_identifier = self._msg_identifier != identifier and identifier
            self._request_rebuild()

    def set_needs_takeover(self, needs_takeover):
        raise self.message_type() != MIDI_NOTE_TYPE or AssertionError
        self._needs_takeover = needs_takeover

    def set_feedback_delay(self, delay):
        raise delay >= -1 or AssertionError
        self._mapping_feedback_delay = delay

    def needs_takeover(self):
        raise self.message_type() != MIDI_NOTE_TYPE or AssertionError
        return self._needs_takeover

    def use_default_message(self):
        if (self._msg_channel, self._msg_identifier) != (self._original_channel, self._original_identifier):
            self._msg_channel = self._original_channel
            self._msg_identifier = self._original_identifier
            self._request_rebuild()

    def _mapping_feedback_values(self):
        value_map = tuple()
        if self._mapping_feedback_delay != 0:
            if self._msg_type != MIDI_PB_TYPE:
                value_map = tuple(range(128))
            else:
                value_pairs = []
                for value in xrange(16384):
                    value_pairs.append((value >> 7 & 127, value & 127))

                value_map = tuple(value_pairs)
        return value_map

    def install_connections(self, install_translation, install_mapping, install_forwarding):
        self._send_delayed_messages_task.kill()
        self._is_mapped = False
        self._is_being_forwarded = False
        if self._msg_channel != self._original_channel or self._msg_identifier != self._original_identifier:
            install_translation(self._msg_type, self._original_identifier, self._original_channel, self._msg_identifier, self._msg_channel)
        if self._parameter_to_map_to != None:
            self._is_mapped = install_mapping(self, self._parameter_to_map_to, self._mapping_feedback_delay, self._mapping_feedback_values())
        if self.script_wants_forwarding():
            self._is_being_forwarded = install_forwarding(self)
            if self._is_being_forwarded and self.send_depends_on_forwarding:
                self._send_delayed_messages_task.restart()

    def script_wants_forwarding(self):
        """
        Returns wether the script wants to receive receive the values,
        otherwise, the control will be mapped to the track.
        
        Subclasses that overload this should _request_rebuild()
        whenever the property changes.
        """
        return self._input_signal_listener_count > 0 or self._report_input

    def begin_gesture(self):
        """
        Begins a modification on the input control element,
        meaning that we should consider the next flow of input data as
        a consistent gesture from the user.
        """
        if self._parameter_to_map_to and not self._in_parameter_gesture:
            self._in_parameter_gesture = True
            self._parameter_to_map_to.begin_gesture()

    def end_gesture(self):
        """
        Ends a modification of the input control element. See
        begin_gesture.
        """
        if self._parameter_to_map_to and self._in_parameter_gesture:
            self._in_parameter_gesture = False
            self._parameter_to_map_to.end_gesture()

    def connect_to(self, parameter):
        """ parameter is a Live.Device.DeviceParameter """
        if self._parameter_to_map_to != parameter:
            if parameter == None:
                self.release_parameter()
            else:
                self._parameter_to_map_to = parameter
                self._request_rebuild()

    def release_parameter(self):
        if self._parameter_to_map_to != None:
            self.end_gesture()
            self._parameter_to_map_to = None
            self._request_rebuild()

    def mapped_parameter(self):
        return self._parameter_to_map_to

    def _status_byte(self, channel):
        status_byte = channel
        if self._msg_type == MIDI_NOTE_TYPE:
            status_byte += MIDI_NOTE_ON_STATUS
        elif self._msg_type == MIDI_CC_TYPE:
            status_byte += MIDI_CC_STATUS
        elif self._msg_type == MIDI_PB_TYPE:
            status_byte += MIDI_PB_STATUS
        else:
            raise NotImplementedError
        return status_byte

    def identifier_bytes(self):
        """
        Returns a list with all the MIDI message prefixes that
        identify this control element.
        """
        if self._msg_type == MIDI_PB_TYPE:
            return ((self._status_byte(self._msg_channel),),)
        elif self._msg_type == MIDI_SYSEX_TYPE:
            return (self.message_sysex_identifier(),)
        elif self._msg_type == MIDI_NOTE_TYPE:
            return ((self._status_byte(self._msg_channel), self.message_identifier()), (self._status_byte(self._msg_channel) - 16, self.message_identifier()))
        else:
            return ((self._status_byte(self._msg_channel), self.message_identifier()),)

    def _send_delayed_messages(self):
        self.clear_send_cache()
        for value, channel in self._delayed_messages:
            self._do_send_value(value, channel=channel)

        self._delayed_messages[:] = []

    def send_value(self, value, force = False, channel = None):
        value = int(value)
        self._verify_value(value)
        if force or self._force_next_send:
            self._do_send_value(value, channel)
        elif self.send_depends_on_forwarding and not self._is_being_forwarded or self._send_delayed_messages_task.is_running:
            first = 1 - self.num_delayed_messages
            self._delayed_messages = self._delayed_messages[first:] + [(value, channel)]
        elif (value, channel) != self._last_sent_message:
            self._do_send_value(value, channel)
        self._force_next_send = False

    def _do_send_value(self, value, channel = None):
        data_byte1 = self._original_identifier
        data_byte2 = value
        status_byte = self._status_byte(channel or self._original_channel)
        if self._msg_type == MIDI_PB_TYPE:
            data_byte1 = value & 127
            data_byte2 = value >> 7 & 127
        if self.send_midi((status_byte, data_byte1, data_byte2)):
            self._last_sent_message = (value, channel)
            if self._report_output:
                is_input = True
                self._report_value(value, not is_input)

    def clear_send_cache(self):
        self._last_sent_message = None

    def reset(self):
        """ Send 0 to reset motorized faders and turn off LEDs """
        self.send_value(0)

    def receive_value(self, value):
        value = getattr(value, 'midi_value', value)
        self._verify_value(value)
        self._last_sent_message = None
        self.notify_value(value)
        if self._report_input:
            is_input = True
            self._report_value(value, is_input)

    def set_report_values(self, report_input, report_output):
        """
        Set boolean values report_input and report_output enabling
        debug information.
        """
        self._report_input = report_input
        self._report_output = report_output

    def _verify_value(self, value):
        upper_bound = self._msg_type < MIDI_SYSEX_TYPE and (16384 if self._msg_type == MIDI_PB_TYPE else 128)
        if not in_range(value, 0, upper_bound):
            raise AssertionError

    def _report_value(self, value, is_input):
        self._verify_value(value)
        message = str(self.__class__.__name__) + ' ('
        if self._msg_type == MIDI_NOTE_TYPE:
            message += 'Note ' + str(self._msg_identifier) + ', '
        elif self._msg_type == MIDI_CC_TYPE:
            message += 'CC ' + str(self._msg_identifier) + ', '
        else:
            message += 'PB '
        message += 'Chan. ' + str(self._msg_channel)
        message += ') '
        message += 'received value ' if is_input else 'sent value '
        message += str(value)
        debug_print(message)

    @property
    def _last_sent_value(self):
        return self._last_sent_message[0] if self._last_sent_message else -1
########NEW FILE########
__FILENAME__ = Layer
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/Layer.py
"""
Module implementing a way to resource-based access to controls in an
unified interface dynamic.
"""
from Util import nop
from itertools import repeat, izip
from Resource import ExclusiveResource, CompoundResource

class LayerError(Exception):
    pass


class UnhandledControlError(LayerError):
    pass


class ControlClient(object):
    """
    Client of the indivial controls that delivers the controls to the
    layer owner.
    """

    def __init__(self, layer = None, layer_client = None, *a, **k):
        super(ControlClient, self).__init__(*a, **k)
        raise layer_client or AssertionError
        raise layer or AssertionError
        self.layer_client = layer_client
        self.layer = layer

    def __eq__(self, other):
        return self.layer == getattr(other, 'layer', None) and self.layer_client == getattr(other, 'layer_client', None)

    def set_control_element(self, control, grabbed):
        layer = self.layer
        owner = self.layer_client
        raise owner or AssertionError
        if not control in layer._control_to_names:
            raise AssertionError, 'Control not in layer: %s' % (control,)
            names = layer._control_to_names[control]
            control = grabbed or None
        for name in names:
            try:
                handler = getattr(owner, 'set_' + name)
            except AttributeError:
                if name[0] != '_':
                    raise UnhandledControlError, 'Component %s has no handler for control %s' % (str(owner), name)
                else:
                    handler = nop

            handler(control)
            layer._name_to_controls[name] = control


class CompoundLayer(CompoundResource):
    """
    A compound resource takes two layers and makes them look like one,
    grabbing both of them.  Both can have different priorities
    thought.
    """

    def _get_priority(self):
        raise self.first.priority == self.second.priority or AssertionError
        return self.first.priority

    def _set_priority(self, priority):
        self.first.priority = priority
        self.second.priority = priority

    priority = property(_get_priority, _set_priority)

    def __getattr__(self, key):
        try:
            return getattr(self.first, key)
        except AttributeError:
            return getattr(self.second, key)


class Layer(ExclusiveResource):
    """
    A layer provides a convenient interface to control resources. In a
    layer, you can group several controls by name.  The layer itself
    is an exclusive resource.  When grabbing the layer, it will try to
    grab all controls and will forward them to its own owner when he
    receives them, and will take them from him when they are
    release. The layer with give and take away the controls from its
    client using methods of the form::
    
        client.set[control-name](control)
    
    Where [control-name] is the name the control was given in this
    layer.  This way, layers are a convenient way to provide controls
    to components indirectly, with automatic handling of competition
    for them.
    
    Note that [control-name] can not be any of the following reserved
    names: priority, grab, release, on_grab, on_release, owner,
    get_owner
    
    If [control-name] starts with an underscore (_) it is considered
    private.  It is grabbed but it is not delivered to the client.
    """

    def __init__(self, priority = None, **controls):
        super(Layer, self).__init__()
        self._priority = priority
        self._name_to_controls = dict(izip(controls.iterkeys(), repeat(None)))
        self._control_to_names = dict()
        for name, control in controls.iteritems():
            self._control_to_names.setdefault(control, []).append(name)

    def __add__(self, other):
        return CompoundLayer(self, other)

    def _get_priority(self):
        return self._priority

    def _set_priority(self, priority):
        if priority != self._priority:
            self._priority = priority
            if self.owner:
                self.grab(self.owner)

    priority = property(_get_priority, _set_priority)

    def __getattr__(self, name):
        """ Provides access to controls """
        try:
            return self._name_to_controls[name]
        except KeyError:
            raise AttributeError

    def grab(self, client, *a, **k):
        if client == self.owner:
            self.on_grab(client, *a, **k)
            return True
        return super(Layer, self).grab(client, *a, **k)

    def on_grab(self, client, *a, **k):
        """ Override from ExclusiveResource """
        for control in self._control_to_names.iterkeys():
            k.setdefault('priority', self._priority)
            control.resource.grab(ControlClient(layer_client=client, layer=self), *a, **k)

    def on_release(self, client):
        """ Override from ExclusiveResource """
        for control in self._control_to_names.iterkeys():
            control.resource.release(ControlClient(layer_client=client, layer=self))
########NEW FILE########
__FILENAME__ = LogicalDisplaySegment
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/LogicalDisplaySegment.py


class LogicalDisplaySegment(object):
    """
    Class representing a specific segment of a display on the controller
    """
    separator = ''

    def __init__(self, width = None, update_callback = None, *a, **k):
        super(LogicalDisplaySegment, self).__init__(*a, **k)
        raise width is not None or AssertionError
        raise callable(update_callback) or AssertionError
        self._update_callback = update_callback
        self._width = width
        self._position_identifier = ()
        self._data_source = None
        self._display_string = None

    def disconnect(self):
        self._update_callback = None
        self._position_identifier = None
        if self._data_source != None:
            self._data_source.set_update_callback(None)
            self._data_source = None

    def set_data_source(self, data_source):
        if self._data_source != None:
            self._data_source.set_update_callback(None)
        self._data_source = data_source
        if self._data_source != None:
            self._data_source.set_update_callback(self.update)
        self._display_string = self._get_display_string()

    def data_source(self):
        return self._data_source

    def set_position_identifier(self, position_identifier):
        """
        Sets position identifier as a tuple of HW related data.
        """
        self._position_identifier = position_identifier

    def position_identifier(self):
        return self._position_identifier

    def update(self):
        if self._update_callback:
            self._display_string = self._get_display_string()
            self._update_callback()

    def _get_display_string(self):
        separator = self._data_source != None and self._data_source.separator + self.separator
        width = self._width - len(separator)
        if not width >= 0:
            raise AssertionError
            return self._data_source.adjust_string(width) + separator
        else:
            return ' ' * self._width

    def display_string(self):
        if self._display_string is None:
            self._display_string = self._get_display_string()
        return self._display_string

    def __str__(self):
        return self.display_string()
########NEW FILE########
__FILENAME__ = MixerComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/MixerComponent.py
from CompoundComponent import CompoundComponent
from ChannelStripComponent import ChannelStripComponent
from TrackEQComponent import TrackEQComponent
from TrackFilterComponent import TrackFilterComponent
from ButtonElement import ButtonElement
from EncoderElement import EncoderElement

class MixerComponent(CompoundComponent):
    """ Class encompassing several channel strips to form a mixer """

    def __init__(self, num_tracks, num_returns = 0, with_eqs = False, with_filters = False):
        raise num_tracks >= 0 or AssertionError
        raise num_returns >= 0 or AssertionError
        CompoundComponent.__init__(self)
        self._track_offset = -1
        self._bank_up_button = None
        self._bank_down_button = None
        self._next_track_button = None
        self._prev_track_button = None
        self._prehear_volume_control = None
        self._crossfader_control = None
        self._channel_strips = []
        self._return_strips = []
        self._track_eqs = []
        self._track_filters = []
        self._offset_can_start_after_tracks = False
        for index in range(num_tracks):
            self._channel_strips.append(self._create_strip())
            self.register_components(self._channel_strips[index])
            if with_eqs:
                self._track_eqs.append(TrackEQComponent())
                self.register_components(self._track_eqs[index])
            if with_filters:
                self._track_filters.append(TrackFilterComponent())
                self.register_components(self._track_filters[index])

        for index in range(num_returns):
            self._return_strips.append(self._create_strip())
            self.register_components(self._return_strips[index])

        self._master_strip = self._create_strip()
        self.register_components(self._master_strip)
        self._master_strip.set_track(self.song().master_track)
        self._selected_strip = self._create_strip()
        self.register_components(self._selected_strip)
        self.on_selected_track_changed()
        self.set_track_offset(0)

    def disconnect(self):
        CompoundComponent.disconnect(self)
        if self._bank_up_button != None:
            self._bank_up_button.remove_value_listener(self._bank_up_value)
            self._bank_up_button = None
        if self._bank_down_button != None:
            self._bank_down_button.remove_value_listener(self._bank_down_value)
            self._bank_down_button = None
        if self._next_track_button != None:
            self._next_track_button.remove_value_listener(self._next_track_value)
            self._next_track_button = None
        if self._prev_track_button != None:
            self._prev_track_button.remove_value_listener(self._prev_track_value)
            self._prev_track_button = None
        if self._prehear_volume_control != None:
            self._prehear_volume_control.release_parameter()
            self._prehear_volume_control = None
        if self._crossfader_control != None:
            self._crossfader_control.release_parameter()
            self._crossfader_control = None

    def channel_strip(self, index):
        raise index in range(len(self._channel_strips)) or AssertionError
        return self._channel_strips[index]

    def return_strip(self, index):
        raise index in range(len(self._return_strips)) or AssertionError
        return self._return_strips[index]

    def track_eq(self, index):
        raise index in range(len(self._track_eqs)) or AssertionError
        return self._track_eqs[index]

    def track_filter(self, index):
        raise index in range(len(self._track_filters)) or AssertionError
        return self._track_filters[index]

    def master_strip(self):
        return self._master_strip

    def selected_strip(self):
        return self._selected_strip

    def set_prehear_volume_control(self, control):
        if not (control == None or isinstance(control, EncoderElement)):
            raise AssertionError
            self._prehear_volume_control != None and self._prehear_volume_control.release_parameter()
        self._prehear_volume_control = control
        self.update()

    def set_crossfader_control(self, control):
        if not (control == None or isinstance(control, EncoderElement)):
            raise AssertionError
            self._crossfader_control != None and self._crossfader_control.release_parameter()
        self._crossfader_control = control
        self.update()

    def set_bank_buttons(self, up_button, down_button):
        if not (up_button == None or isinstance(up_button, ButtonElement)):
            raise AssertionError
            if not (down_button == None or isinstance(down_button, ButtonElement)):
                raise AssertionError
                do_update = False
                if up_button is not self._bank_up_button:
                    do_update = True
                    if self._bank_up_button != None:
                        self._bank_up_button.remove_value_listener(self._bank_up_value)
                    self._bank_up_button = up_button
                    if self._bank_up_button != None:
                        self._bank_up_button.add_value_listener(self._bank_up_value)
                if down_button is not self._bank_down_button:
                    do_update = True
                    if self._bank_down_button != None:
                        self._bank_down_button.remove_value_listener(self._bank_down_value)
                    self._bank_down_button = down_button
                    self._bank_down_button != None and self._bank_down_button.add_value_listener(self._bank_down_value)
            do_update and self.on_track_list_changed()

    def set_select_buttons(self, next_button, prev_button):
        if not (next_button == None or isinstance(next_button, ButtonElement)):
            raise AssertionError
            if not (prev_button == None or isinstance(prev_button, ButtonElement)):
                raise AssertionError
                do_update = False
                if next_button is not self._next_track_button:
                    do_update = True
                    if self._next_track_button != None:
                        self._next_track_button.remove_value_listener(self._next_track_value)
                    self._next_track_button = next_button
                    if self._next_track_button != None:
                        self._next_track_button.add_value_listener(self._next_track_value)
                if prev_button is not self._prev_track_button:
                    do_update = True
                    if self._prev_track_button != None:
                        self._prev_track_button.remove_value_listener(self._prev_track_value)
                    self._prev_track_button = prev_button
                    self._prev_track_button != None and self._prev_track_button.add_value_listener(self._prev_track_value)
            do_update and self.on_selected_track_changed()

    def set_track_offset(self, new_offset):
        if not isinstance(new_offset, int):
            raise AssertionError
            raise new_offset >= 0 or AssertionError
            new_offset != self._track_offset and self._offset_can_start_after_tracks |= new_offset > len(self.tracks_to_use()) - 1
            self._track_offset = new_offset
            self._reassign_tracks()

    def on_enabled_changed(self):
        self.update()

    def on_track_list_changed(self):
        if not self._offset_can_start_after_tracks:
            self._track_offset = min(self._track_offset, len(self.tracks_to_use()) - 1)
        self._reassign_tracks()

    def on_selected_track_changed(self):
        selected_track = self.song().view.selected_track
        if self._selected_strip != None:
            self._selected_strip.set_track(selected_track)
        if self.is_enabled():
            if self._next_track_button != None:
                if selected_track != self.song().master_track:
                    self._next_track_button.turn_on()
                else:
                    self._next_track_button.turn_off()
            if self._prev_track_button != None:
                if selected_track != self.song().visible_tracks[0]:
                    self._prev_track_button.turn_on()
                else:
                    self._prev_track_button.turn_off()

    def tracks_to_use(self):
        return self.song().visible_tracks

    def update(self):
        if self._allow_updates:
            master_track = self.song().master_track
            if self.is_enabled():
                if self._prehear_volume_control != None:
                    self._prehear_volume_control.connect_to(master_track.mixer_device.cue_volume)
                if self._crossfader_control != None:
                    self._crossfader_control.connect_to(master_track.mixer_device.crossfader)
            else:
                if self._prehear_volume_control != None:
                    self._prehear_volume_control.release_parameter()
                if self._crossfader_control != None:
                    self._crossfader_control.release_parameter()
                if self._bank_up_button != None:
                    self._bank_up_button.turn_off()
                if self._bank_down_button != None:
                    self._bank_down_button.turn_off()
                if self._next_track_button != None:
                    self._next_track_button.turn_off()
                if self._prev_track_button != None:
                    self._prev_track_button.turn_off()
        else:
            self._update_requests += 1

    def _reassign_tracks(self):
        tracks = self.tracks_to_use()
        returns = self.song().return_tracks
        for index in range(len(self._channel_strips)):
            track_index = self._track_offset + index
            track = None
            if len(tracks) > track_index:
                track = tracks[track_index]
            self._channel_strips[index].set_track(track)
            if len(self._track_eqs) > index:
                self._track_eqs[index].set_track(track)
            if len(self._track_filters) > index:
                self._track_filters[index].set_track(track)

        for index in range(len(self._return_strips)):
            if len(returns) > index:
                self._return_strips[index].set_track(returns[index])
            else:
                self._return_strips[index].set_track(None)

        if self._bank_down_button != None:
            if self._track_offset > 0:
                self._bank_down_button.turn_on()
            else:
                self._bank_down_button.turn_off()
        if self._bank_up_button != None:
            if len(tracks) > self._track_offset + len(self._channel_strips):
                self._bank_up_button.turn_on()
            else:
                self._bank_up_button.turn_off()

    def _create_strip(self):
        return ChannelStripComponent()

    def _bank_up_value(self, value):
        if not isinstance(value, int):
            raise AssertionError
            if not self._bank_up_button != None:
                raise AssertionError
                if self.is_enabled():
                    new_offset = (value is not 0 or not self._bank_up_button.is_momentary()) and self._track_offset + len(self._channel_strips)
                    len(self.tracks_to_use()) > new_offset and self.set_track_offset(new_offset)

    def _bank_down_value(self, value):
        if not isinstance(value, int):
            raise AssertionError
            if not self._bank_down_button != None:
                raise AssertionError
                self.is_enabled() and (value is not 0 or not self._bank_down_button.is_momentary()) and self.set_track_offset(max(0, self._track_offset - len(self._channel_strips)))

    def _next_track_value(self, value):
        if not self._next_track_button != None:
            raise AssertionError
            raise value != None or AssertionError
            raise isinstance(value, int) or AssertionError
            selected_track = self.is_enabled() and (value is not 0 or not self._next_track_button.is_momentary()) and self.song().view.selected_track
            all_tracks = tuple(self.song().visible_tracks) + tuple(self.song().return_tracks) + (self.song().master_track,)
            if not selected_track in all_tracks:
                raise AssertionError
                if selected_track != all_tracks[-1]:
                    index = list(all_tracks).index(selected_track)
                    self.song().view.selected_track = all_tracks[index + 1]

    def _prev_track_value(self, value):
        if not self._prev_track_button != None:
            raise AssertionError
            raise value != None or AssertionError
            raise isinstance(value, int) or AssertionError
            selected_track = self.is_enabled() and (value is not 0 or not self._prev_track_button.is_momentary()) and self.song().view.selected_track
            all_tracks = tuple(self.song().visible_tracks) + tuple(self.song().return_tracks) + (self.song().master_track,)
            if not selected_track in all_tracks:
                raise AssertionError
                if selected_track != all_tracks[0]:
                    index = list(all_tracks).index(selected_track)
                    self.song().view.selected_track = all_tracks[index - 1]
########NEW FILE########
__FILENAME__ = ModesComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/ModesComponent.py
"""
Mode handling components.
"""
from itertools import imap
from functools import partial
from ControlSurfaceComponent import ControlSurfaceComponent
from CompoundComponent import CompoundComponent
from Resource import StackingResource
from Util import is_iterable, is_contextmanager, infinite_context_manager, NamedTuple
from SubjectSlot import subject_slot
from Layer import Layer
import Task
import Defaults

def tomode(thing):
    if thing == None:
        return Mode()
    if isinstance(thing, Mode):
        return thing
    if isinstance(thing, ControlSurfaceComponent):
        return ComponentMode(thing)
    if isinstance(thing, tuple) and len(thing) == 2:
        if isinstance(thing[0], ControlSurfaceComponent) and isinstance(thing[1], Layer):
            return LayerMode(*thing)
        elif callable(thing[0]) and callable(thing[1]):
            mode = Mode()
            mode.enter_mode, mode.leave_mode = thing
            return mode
    if callable(thing):
        mode = Mode()
        mode.enter_mode = thing
        return mode
    if is_iterable(thing):
        return CompoundMode(*thing)
    if is_contextmanager(thing):
        return ContextManagerMode(thing)
    return thing


class Mode(object):
    """
    Interface to be implemented by modes.  When a mode is enabled,
    enter_mode is called, and leave_mode when disabled.
    """

    def enter_mode(self):
        pass

    def leave_mode(self):
        pass

    def __enter__(self):
        self.enter_mode()

    def __exit__(self, *a):
        return self.leave_mode()


class ContextManagerMode(Mode):
    """
    Turns any context manager into a mode object.
    """

    def __init__(self, context_manager = None, *a, **k):
        super(ContextManagerMode, self).__init__(*a, **k)
        self._context_manager = context_manager

    def enter_mode(self):
        self._context_manager.__enter__()

    def leave_mode(self):
        self._context_manager.__exit__(None, None, None)

    def __exit__(self, exc_type, exc_value, traceback):
        return self._context_manager.__exit__(exc_type, exc_value, traceback)


def generator_mode(function):
    makecontext = infinite_context_manager(function)
    return lambda *a, **k: ContextManagerMode(makecontext(*a, **k))


class ComponentMode(Mode):
    """
    Enables a component while the mode is active.
    """

    def __init__(self, component = None, *a, **k):
        super(ComponentMode, self).__init__(*a, **k)
        raise component is not None or AssertionError
        self._component = component

    def enter_mode(self):
        self._component.set_enabled(True)

    def leave_mode(self):
        self._component.set_enabled(False)


class DisableMode(Mode):
    """
    Disables a component while the mode is active.
    """

    def __init__(self, component = None, *a, **k):
        super(DisableMode, self).__init__(*a, **k)
        raise component is not None or AssertionError
        self._component = component

    def enter_mode(self):
        self._component.set_enabled(False)

    def leave_mode(self):
        self._component.set_enabled(True)


class LayerMode(Mode):
    """
    Sets the layer of a component to a specific one.  When the mode is
    exited leaves the component without a layer.
    """

    def __init__(self, component = None, layer = None, *a, **k):
        super(LayerMode, self).__init__(*a, **k)
        raise component is not None or AssertionError
        self._component = component
        self._layer = layer

    def enter_mode(self):
        self._component.layer = self._layer

    def leave_mode(self):
        self._component.layer = None


class AddLayerMode(Mode):
    """
    Adds an extra layer to a component, independently of the layer
    associated to the component.
    """

    def __init__(self, component = None, layer = None, *a, **k):
        super(AddLayerMode, self).__init__(*a, **k)
        raise component is not None or AssertionError
        raise layer is not None or AssertionError
        self._component = component
        self._layer = layer

    def enter_mode(self):
        self._layer.grab(self._component)

    def leave_mode(self):
        self._layer.release(self._component)


class CompoundMode(Mode):
    """
    A compound mode wraps any number of modes into one. They are
    entered in the given order and left in reversed order.
    """

    def __init__(self, *modes, **k):
        super(CompoundMode, self).__init__(**k)
        self._modes = map(tomode, modes)

    def enter_mode(self):
        for mode in self._modes:
            mode.enter_mode()

    def leave_mode(self):
        for mode in reversed(self._modes):
            mode.leave_mode()


class MultiEntryMode(Mode):
    """
    Mode wrapper that allows registration in multiple modes
    components.  This wrapper can be entered multiple times and the
    enter method will be called only once.  It will be left when the
    number of times leave_mode is called matches the number of calls
    to enter_mode.
    """

    def __init__(self, mode = None, *a, **k):
        super(MultiEntryMode, self).__init__(*a, **k)
        self._mode = tomode(mode)
        self._entry_count = 0

    def enter_mode(self):
        if self._entry_count == 0:
            self._mode.enter_mode()
        self._entry_count += 1

    def leave_mode(self):
        if not self._entry_count > 0:
            raise AssertionError
            self._entry_count == 1 and self._mode.leave_mode()
        self._entry_count -= 1

    @property
    def is_entered(self):
        return self._entry_count > 0


class SetAttributeMode(Mode):
    """
    Changes an attribute of an object to a given value.  Restores it
    to the original value, unless the value has changed while the mode
    was active.
    """

    def __init__(self, obj = None, attribute = None, value = None, *a, **k):
        super(SetAttributeMode, self).__init__(*a, **k)
        self._obj = obj
        self._attribute = attribute
        self._old_value = None
        self._value = value

    def enter_mode(self):
        self._old_value = getattr(self._obj, self._attribute, None)
        setattr(self._obj, self._attribute, self._value)

    def leave_mode(self):
        if getattr(self._obj, self._attribute) == self._value:
            setattr(self._obj, self._attribute, self._old_value)


class ModeButtonBehaviour(object):
    """
    Strategy that determines how the mode button of a specific mode
    behaves. The protocol is a follows:
    
    1. When the button is pressed, the press_immediate is called.
    
    2. If the button is released shortly, the release_immediate is
       called.
    
    3. However, if MOMENTARY_DELAY is elapsed before release,
       press_delayed is called and release_immediate will never be
       called.
    
    4. release_delayed will be called when the button is released and
       more than MOMENTARY_DELAY time has passed since press.
    """

    def press_immediate(self, component, mode):
        pass

    def release_immediate(self, component, mode):
        pass

    def press_delayed(self, component, mode):
        pass

    def release_delayed(self, component, mode):
        pass

    def update_button(self, component, mode, selected_mode):
        """
        Updates the button light for 'mode'.
        """
        button = component.get_mode_button(mode)
        groups = component.get_mode_groups(mode)
        selected_groups = component.get_mode_groups(selected_mode)
        button.set_light(mode == selected_mode or bool(groups & selected_groups))


class LatchingBehaviour(ModeButtonBehaviour):
    """
    Behaviour that will jump back to the previous mode when the button
    is released after having been hold for some time.  If the button
    is quickly pressed, the selected mode will stay.
    """

    def press_immediate(self, component, mode):
        component.push_mode(mode)

    def release_immediate(self, component, mode):
        component.pop_unselected_modes()

    def release_delayed(self, component, mode):
        if len(component.active_modes) > 1:
            component.pop_mode(mode)


class ReenterBehaviour(LatchingBehaviour):
    """
    Like latching, but calls a callback when the mode is-reentered.
    """

    def __init__(self, on_reenter = None, *a, **k):
        super(ReenterBehaviour, self).__init__(*a, **k)
        if on_reenter is not None:
            self.on_reenter = on_reenter

    def press_immediate(self, component, mode):
        was_active = component.selected_mode == mode
        super(ReenterBehaviour, self).press_immediate(component, mode)
        if was_active:
            self.on_reenter()

    def on_reenter(self):
        pass


class CancellableBehaviour(ModeButtonBehaviour):
    """
    Acts a toggle for the mode -- when the button is pressed a second
    time, every mode in this mode group will be exited, going back to
    the last selected mode.  It also does mode latching.
    """
    _previous_mode = None

    def press_immediate(self, component, mode):
        active_modes = component.active_modes
        groups = component.get_mode_groups(mode)
        if not mode in active_modes:
            can_cancel_mode = any(imap(lambda other: groups & component.get_mode_groups(other), active_modes))
            if can_cancel_mode:
                groups and component.pop_groups(groups)
            else:
                component.pop_mode(mode)
            self.restore_previous_mode(component)
        else:
            self.remember_previous_mode(component)
            component.push_mode(mode)

    def remember_previous_mode(self, component):
        self._previous_mode = component.active_modes[0] if component.active_modes else None

    def restore_previous_mode(self, component):
        if len(component.active_modes) == 0 and self._previous_mode != None:
            component.push_mode(self._previous_mode)


class ImmediateBehaviour(ModeButtonBehaviour):
    """
    Just goes to the pressed mode immediatley.
    No latching or magic.
    """

    def press_immediate(self, component, mode):
        component.selected_mode = mode


class AlternativeBehaviour(CancellableBehaviour):
    """
    Relies in the alternative to be in the same group for cancellation
    to work properly. Also shows cancellable behaviour and the
    alternative is latched.
    """

    def __init__(self, alternative_mode = None, *a, **k):
        super(AlternativeBehaviour, self).__init__(*a, **k)
        self._alternative_mode = alternative_mode

    def _check_mode_groups(self, component, mode):
        mode_groups = component.get_mode_groups(mode)
        alt_group = component.get_mode_groups(self._alternative_mode)
        return mode_groups and mode_groups & alt_group

    def release_delayed(self, component, mode):
        raise self._check_mode_groups(component, mode) or AssertionError
        component.pop_groups(component.get_mode_groups(mode))
        self.restore_previous_mode(component)

    def press_delayed(self, component, mode):
        raise self._check_mode_groups(component, mode) or AssertionError
        self.remember_previous_mode(component)
        component.push_mode(self._alternative_mode)

    def release_immediate(self, component, mode):
        raise self._check_mode_groups(component, mode) or AssertionError
        super(AlternativeBehaviour, self).press_immediate(component, mode)

    def press_immediate(self, component, mode):
        raise self._check_mode_groups(component, mode) or AssertionError


class DynamicBehaviourMixin(ModeButtonBehaviour):
    """
    Chooses the mode to uses dynamically when the button is pressed.
    If no mode is returned, the default one is used instead.
    
    It can be safely used as a mixin in front of every other behviour.
    """

    def __init__(self, mode_chooser = None, *a, **k):
        super(DynamicBehaviourMixin, self).__init__(*a, **k)
        self._mode_chooser = mode_chooser
        self._chosen_mode = None

    def press_immediate(self, component, mode):
        self._chosen_mode = self._mode_chooser() or mode
        super(DynamicBehaviourMixin, self).press_immediate(component, self._chosen_mode)

    def release_delayed(self, component, mode):
        super(DynamicBehaviourMixin, self).release_delayed(component, self._chosen_mode)

    def press_delayed(self, component, mode):
        super(DynamicBehaviourMixin, self).press_delayed(component, self._chosen_mode)

    def release_immediate(self, component, mode):
        super(DynamicBehaviourMixin, self).release_immediate(component, self._chosen_mode)


class ExcludingBehaviourMixin(ModeButtonBehaviour):
    """
    Button behaviour that excludes the mode/s when the currently
    selected mode is in any of the excluded groups.
    """

    def __init__(self, excluded_groups = set(), *a, **k):
        super(ExcludingBehaviourMixin, self).__init__(*a, **k)
        self._excluded_groups = set(excluded_groups)

    def is_excluded(self, component, selected):
        return bool(component.get_mode_groups(selected) & self._excluded_groups)

    def press_immediate(self, component, mode):
        if not self.is_excluded(component, component.selected_mode):
            super(ExcludingBehaviourMixin, self).press_immediate(component, mode)

    def release_delayed(self, component, mode):
        if not self.is_excluded(component, component.selected_mode):
            super(ExcludingBehaviourMixin, self).release_delayed(component, mode)

    def press_delayed(self, component, mode):
        if not self.is_excluded(component, component.selected_mode):
            super(ExcludingBehaviourMixin, self).press_delayed(component, mode)

    def release_immediate(self, component, mode):
        if not self.is_excluded(component, component.selected_mode):
            super(ExcludingBehaviourMixin, self).release_immediate(component, mode)

    def update_button(self, component, mode, selected_mode):
        if not self.is_excluded(component, selected_mode):
            super(ExcludingBehaviourMixin, self).update_button(component, mode, selected_mode)
        else:
            component.get_mode_button(mode).set_light('DefaultButton.Disabled')


class _ModeEntry(NamedTuple):
    """
    Used by ModesComponent to store information about modes.
    """
    mode = None
    groups = set()
    toggle_value = False
    subject_slot = None
    momentary_task = None


class ModesComponent(CompoundComponent):
    """
    A ModesComponent handles the selection of different modes of the
    component. It improves the ModeSelectorComponent in several ways:
    
    - A mode is an object with two methods for entering and exiting
      the mode.  You do not need to know about all the modes
      registered.
    
    - Any object convertible by 'tomode' can be passed as mode.
    
    - Modes are identified by strings.
    
    - The component will dynamically generate methods of the form:
    
          set_[mode-name]_button(button)
    
      for setting the mode button.  Thanks to this, you can pass the mode
      buttons in a layer.
    
    The modes component behaves like a stack.  Several modes can be
    active at the same time, but the component will make sure that
    only the one at the top (aka 'selected_mode') will be entered at a
    given time.  This allows you to implement modes that can be
    'cancelled' or 'mode latch' (i.e. go to the previous mode under
    certain conditions).
    """
    __subject_events__ = ('selected_mode',)
    momentary_toggle = False
    default_behaviour = LatchingBehaviour()

    def __init__(self, *a, **k):
        super(ModesComponent, self).__init__(*a, **k)
        self._last_toggle_value = 0
        self._mode_toggle = None
        self._mode_toggle_task = self._tasks.add(Task.wait(Defaults.MOMENTARY_DELAY))
        self._mode_toggle_task.kill()
        self._mode_list = []
        self._mode_map = {}
        self._last_selected_mode = None
        self._mode_stack = StackingResource(self._do_enter_mode, self._do_leave_mode)
        self._shift_button = None

    def disconnect(self):
        self._mode_stack.release_all()
        super(ModesComponent, self).disconnect()

    def set_shift_button(self, button):
        raise not button or button.is_momentary() or AssertionError
        self._shift_button = button

    def _do_enter_mode(self, name):
        entry = self._mode_map[name]
        entry.mode.enter_mode()
        self._update_buttons(name)
        self.notify_selected_mode(name)

    def _do_leave_mode(self, name):
        self._mode_map[name].mode.leave_mode()
        if self._mode_stack.stack_size == 0:
            self._update_buttons(None)
            self.notify_selected_mode(None)

    def _get_selected_mode(self):
        """
        Mode that is currently the top of the mode stack. Setting the
        selected mode explictly will also cleanup the mode stack.
        """
        return self._mode_stack.owner or self._last_selected_mode

    def _set_selected_mode(self, mode):
        if not (mode in self._mode_map or mode is None):
            raise AssertionError
            if self.is_enabled():
                mode != None and self.push_mode(mode)
                self.pop_unselected_modes()
            else:
                self._mode_stack.release_all()
        else:
            self._last_selected_mode = mode

    selected_mode = property(_get_selected_mode, _set_selected_mode)

    @property
    def selected_groups(self):
        entry = self._mode_map.get(self.selected_mode, None)
        return entry.groups if entry else set()

    @property
    def active_modes(self):
        return self._mode_stack.clients

    def push_mode(self, mode):
        """
        Selects the current 'mode', leaving the rest of the modes in
        the mode stack.
        """
        self._mode_stack.grab(mode)

    def pop_mode(self, mode):
        """
        Takes 'mode' away from the mode stack.  If the mode was the
        currently selected one, the last pushed mode will be selected.
        """
        self._mode_stack.release(mode)

    def pop_groups(self, groups):
        """
        Pops every mode in groups.
        """
        if not isinstance(groups, set):
            groups = set(groups)
        for client in self._mode_stack.clients:
            if self.get_mode_groups(client) & groups:
                self._mode_stack.release(client)

    def pop_unselected_modes(self):
        """
        Pops from the mode stack all the modes that are not the
        currently selected one.
        """
        self._mode_stack.release_stacked()

    def on_enabled_changed(self):
        super(ModesComponent, self).on_enabled_changed()
        if not self.is_enabled():
            self._last_selected_mode = self.selected_mode
            self._mode_stack.release_all()
        elif self._last_selected_mode:
            self.push_mode(self._last_selected_mode)

    def update(self):
        self._update_buttons(self.selected_mode)

    def add_mode(self, name, mode_or_component, toggle_value = False, groups = set(), behaviour = None):
        """
        Adds a mode of the given name into the component.  The mode
        object should be a Mode or ControlSurfaceComponent instance.
        
        The 'toggle_value' is the light value the toggle_botton will
        be set to when the component is on this mode.
        
        If 'group' is not None, the mode will be put in the group
        identified by the passed object.  When several modes are grouped:
        
          * All the buttons in the group will light up when any of the
            modes withing the group is selected.
        
          * Any of the group buttons will cancel the current mode when
            the current mode belongs to the group.
        """
        if not name not in self._mode_map.keys():
            raise AssertionError
            if not isinstance(groups, set):
                groups = set(groups)
            mode = tomode(mode_or_component)
            task = self._tasks.add(Task.sequence(Task.wait(Defaults.MOMENTARY_DELAY), Task.run(lambda : self._get_mode_behaviour(name).press_delayed(self, name))))
            task.kill()
            slot = self.register_slot(listener=partial(self._on_mode_button_value, name), event='value', extra_kws=dict(identify_sender=True))
            self._mode_list.append(name)
            self._mode_map[name] = _ModeEntry(mode=mode, toggle_value=toggle_value, behaviour=behaviour, subject_slot=slot, momentary_task=task, groups=groups)
            button_setter = 'set_' + name + '_button'
            hasattr(self, button_setter) or setattr(self, button_setter, partial(self.set_mode_button, name))

    def _get_mode_behaviour(self, name):
        entry = self._mode_map.get(name, None)
        return entry and entry.behaviour or self.default_behaviour

    def get_mode(self, name):
        entry = self._mode_map.get(name, None)
        return entry and entry.mode

    def get_mode_groups(self, name):
        entry = self._mode_map.get(name, None)
        return entry.groups if entry else set()

    def set_toggle_button(self, button):
        if button and self.is_enabled():
            button.reset()
        self._mode_toggle = button
        self._on_toggle_value.subject = button
        self._update_buttons(self.selected_mode)

    def set_mode_button(self, name, button):
        if button and self.is_enabled():
            button.reset()
        self._mode_map[name].subject_slot.subject = button
        self._update_buttons(self.selected_mode)

    def get_mode_button(self, name):
        return self._mode_map[name].subject_slot.subject

    def _update_buttons(self, selected):
        if self.is_enabled():
            for name, entry in self._mode_map.iteritems():
                if entry.subject_slot.subject != None:
                    self._get_mode_behaviour(name).update_button(self, name, selected)

            if self._mode_toggle:
                entry = self._mode_map.get(selected)
                value = entry and entry.toggle_value
                self._mode_toggle.set_light(value)

    def _on_mode_button_value(self, name, value, sender):
        shift = self._shift_button and self._shift_button.is_pressed()
        if not shift and self.is_enabled():
            behaviour = self._get_mode_behaviour(name)
            if sender.is_momentary():
                entry = self._mode_map[name]
                task = entry.momentary_task
                if value:
                    behaviour.press_immediate(self, name)
                    task.restart()
                elif task.is_killed:
                    behaviour.release_delayed(self, name)
                else:
                    behaviour.release_immediate(self, name)
                    task.kill()
            else:
                behaviour.press_immediate(self, name)
                behaviour.release_immediate(self, name)

    @subject_slot('value')
    def _on_toggle_value(self, value):
        if self._shift_button:
            shift = self._shift_button.is_pressed()
            if not shift and self.is_enabled() and len(self._mode_list):
                is_press = value and not self._last_toggle_value
                is_release = not value and self._last_toggle_value
                can_latch = self._mode_toggle_task.is_killed and self.selected_mode != self._mode_list[0]
                (not self._mode_toggle.is_momentary() or is_press) and self.cycle_mode(1)
                self._mode_toggle_task.restart()
            elif is_release and (self.momentary_toggle or can_latch):
                self.cycle_mode(-1)
            self._last_toggle_value = value

    def cycle_mode(self, delta = 1):
        current_index = self._mode_list.index(self.selected_mode) if self.selected_mode else -delta
        current_index = (current_index + delta) % len(self._mode_list)
        self.selected_mode = self._mode_list[current_index]


class DisplayingModesComponent(ModesComponent):
    """
    A modes component that displays the selected option.
    """

    def __init__(self, *a, **k):
        super(DisplayingModesComponent, self).__init__(*a, **k)
        self._mode_data_sources = {}

    def add_mode(self, name, mode_or_component, data_source):
        """
        Adds a mode.  The mode will be displayed in the given data
        source. The display name of the data source is its value when
        added.
        """
        super(DisplayingModesComponent, self).add_mode(name, mode_or_component)
        self._mode_data_sources[name] = (data_source, data_source.display_string())

    def update(self):
        super(DisplayingModesComponent, self).update()
        self._update_data_sources(self.selected_mode)

    def _do_enter_mode(self, name):
        super(DisplayingModesComponent, self)._do_enter_mode(name)
        self._update_data_sources(name)

    def _update_data_sources(self, selected):
        if self.is_enabled():
            for name, (source, string) in self._mode_data_sources.iteritems():
                source.set_display_string('*' + string if name == selected else string)


class EnablingModesComponent(ModesComponent):
    """
    Adds the two modes 'enabled' and 'disabled'. The provided component will be
    enabled while the 'enabled' mode is active.
    """

    def __init__(self, component = None, toggle_value = False, *a, **k):
        super(EnablingModesComponent, self).__init__(*a, **k)
        component.set_enabled(False)
        self.add_mode('disabled', None)
        self.add_mode('enabled', component, toggle_value)
        self.selected_mode = 'disabled'
########NEW FILE########
__FILENAME__ = ModeSelectorComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/ModeSelectorComponent.py
from ControlSurfaceComponent import ControlSurfaceComponent
from ButtonElement import ButtonElement
from MomentaryModeObserver import MomentaryModeObserver

class ModeSelectorComponent(ControlSurfaceComponent):
    """ Class for switching between modes, handle several functions with few controls """

    def __init__(self, *a, **k):
        super(ModeSelectorComponent, self).__init__(*a, **k)
        self._modes_buttons = []
        self._mode_toggle = None
        self._mode_listeners = []
        self.__mode_index = -1
        self._modes_observers = {}
        self._modes_heap = []

    def _get_protected_mode_index(self):
        return self.__mode_index

    def _set_protected_mode_index(self, mode):
        raise isinstance(mode, int) or AssertionError
        self.__mode_index = mode
        for listener in self._mode_listeners:
            listener()

    _mode_index = property(_get_protected_mode_index, _set_protected_mode_index)

    def _get_public_mode_index(self):
        return self.__mode_index

    def _set_public_mode_index(self, mode):
        raise False or AssertionError

    mode_index = property(_get_public_mode_index, _set_public_mode_index)

    def disconnect(self):
        self._clean_heap()
        if self._mode_toggle != None:
            self._mode_toggle.remove_value_listener(self._toggle_value)
            self._mode_toggle = None
        self._modes_buttons = None
        self._mode_listeners = None
        super(ModeSelectorComponent, self).disconnect()

    def on_enabled_changed(self):
        self.update()

    def set_mode_toggle(self, button):
        if not (button == None or isinstance(button, ButtonElement)):
            raise AssertionError
            if self._mode_toggle != None:
                self._mode_toggle.remove_value_listener(self._toggle_value)
            self._mode_toggle = button
            self._mode_toggle != None and self._mode_toggle.add_value_listener(self._toggle_value)
        self.set_mode(0)

    def set_mode_buttons(self, buttons):
        raise buttons != None or AssertionError
        raise isinstance(buttons, tuple) or AssertionError
        raise len(buttons) - 1 in range(16) or AssertionError
        for button in buttons:
            raise isinstance(button, ButtonElement) or AssertionError
            identify_sender = True
            button.add_value_listener(self._mode_value, identify_sender)
            self._modes_buttons.append(button)

        self.set_mode(0)

    def set_mode(self, mode):
        self._clean_heap()
        self._modes_heap = [(mode, None, None)]
        if self._mode_index != mode:
            self._update_mode()

    def _update_mode(self):
        mode = self._modes_heap[-1][0]
        if not mode in range(self.number_of_modes()):
            raise AssertionError
            self._mode_index = self._mode_index != mode and mode
            self.update()

    def _clean_heap(self):
        for _, _, observer in self._modes_heap:
            if observer != None:
                observer.disconnect()

        self._modes_heap = []

    def number_of_modes(self):
        raise NotImplementedError

    def mode_index_has_listener(self, listener):
        return listener in self._mode_listeners

    def add_mode_index_listener(self, listener):
        raise listener not in self._mode_listeners or AssertionError
        self._mode_listeners.append(listener)

    def remove_mode_index_listener(self, listener):
        raise listener in self._mode_listeners or AssertionError
        self._mode_listeners.remove(listener)

    def update(self):
        raise NotImplementedError

    def _mode_value(self, value, sender):
        raise len(self._modes_buttons) > 0 or AssertionError
        raise isinstance(value, int) or AssertionError
        raise sender in self._modes_buttons or AssertionError
        new_mode = self._modes_buttons.index(sender)
        if sender.is_momentary():
            if value > 0:
                mode_observer = MomentaryModeObserver()
                mode_observer.set_mode_details(new_mode, self._controls_for_mode(new_mode), self._get_public_mode_index)
                self._modes_heap.append((new_mode, sender, mode_observer))
                self._update_mode()
            elif self._modes_heap[-1][1] == sender and not self._modes_heap[-1][2].is_mode_momentary():
                self.set_mode(new_mode)
            else:
                for mode, button, observer in self._modes_heap:
                    if button == sender:
                        self._modes_heap.remove((mode, button, observer))
                        break

                self._update_mode()
        else:
            self.set_mode(new_mode)

    def _toggle_value(self, value):
        if not self._mode_toggle != None:
            raise AssertionError
            raise isinstance(value, int) or AssertionError
            (value is not 0 or not self._mode_toggle.is_momentary()) and self.set_mode((self._mode_index + 1) % self.number_of_modes())

    def _controls_for_mode(self, mode):
        return None

    def _on_timer(self):
        for _, _, mode_observer in self._modes_heap:
            if mode_observer != None:
                mode_observer.on_timer()
########NEW FILE########
__FILENAME__ = MomentaryModeObserver
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/MomentaryModeObserver.py
import Defaults

class MomentaryModeObserver(object):
    """ Listens to the changes of a given set of controls and decides which mode to use """

    def __init__(self):
        object.__init__(self)
        self._controls = None
        self._mode_callback = None
        self._reset()

    def disconnect(self):
        self._reset()

    def set_mode_details(self, base_mode, controls, mode_callback = None):
        if not isinstance(base_mode, int):
            raise AssertionError
            raise isinstance(controls, (type(None), tuple)) or AssertionError
            raise mode_callback == None or callable(mode_callback) or AssertionError
            self._reset()
            self._controls = controls != None and controls
            for control in self._controls:
                control.add_value_listener(self._control_changed)

        self._base_mode = base_mode
        self._mode_callback = mode_callback

    def is_mode_momentary(self):
        return self._controls_changed or self._timer_count >= Defaults.MOMENTARY_DELAY_TICKS

    def on_timer(self):
        self._timer_count += 1

    def _control_changed(self, value):
        if self._mode_callback == None or self._mode_callback() == self._base_mode:
            self._controls_changed = True

    def _release_controls(self):
        if self._controls != None:
            for control in self._controls:
                control.remove_value_listener(self._control_changed)

            self._controls = None

    def _reset(self):
        self._base_mode = -1
        self._controls_changed = False
        self._mode_callback = None
        self._timer_count = 0
        self._release_controls()
########NEW FILE########
__FILENAME__ = NotifyingControlElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/NotifyingControlElement.py
from SubjectSlot import Subject, SubjectEvent
from ControlElement import ControlElement

class NotifyingControlElement(Subject, ControlElement):
    """
    Class representing control elements that can send values
    """
    __subject_events__ = (SubjectEvent(name='value', doc=' Called when the control element receives a MIDI value\n                             from the hardware '),)
########NEW FILE########
__FILENAME__ = PhysicalDisplayElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/PhysicalDisplayElement.py
from itertools import ifilter, izip, starmap, chain, imap
from functools import partial
from Resource import StackingResource, ProxyResource, ClientWrapper
from CompoundElement import CompoundElement
from ControlElement import ControlElement
from LogicalDisplaySegment import LogicalDisplaySegment
from DisplayDataSource import adjust_string
from Util import in_range, slicer, to_slice, slice_size, const, second, maybe, lazy_attribute, first, nop, group
import Task

class _DisplayCentralResource(StackingResource):
    """
    Resource to be used internallt by the PhysicalDisplayElement.  All
    sub-displays and the display itself will compete against this
    central resource.  The central resource will take into account
    wheter there is any free area in the display for a client, to
    decide wheter he gets it or not.
    """

    def __init__(self, root_display = None, *a, **k):
        super(_DisplayCentralResource, self).__init__(*a, **k)
        self._root_display = root_display

    def _actual_owners(self):
        remaining_indexes = set(self._root_display.display_indexes)

        def filter_client(((display, _), __)):
            result = remaining_indexes & display.display_indexes
            remaining_indexes.difference_update(display.display_indexes)
            return bool(result)

        return list(reversed(map(first, ifilter(filter_client, reversed(self._clients)))))


class DisplayError(Exception):
    pass


class DisplaySegmentationError(DisplayError):
    pass


class DisplayElement(ControlElement):
    """
    Base class for character-based displays.
    """

    class ProxiedInterface(ControlElement.ProxiedInterface):
        set_num_segments = nop
        set_data_sources = nop
        segment = const(LogicalDisplaySegment(1, nop))

    def __init__(self, width_in_chars = None, num_segments = 1, *a, **k):
        super(DisplayElement, self).__init__(*a, **k)
        raise width_in_chars is not None or AssertionError
        raise num_segments is not None or AssertionError
        self._width = width_in_chars
        self._logical_segments = []
        self.set_num_segments(num_segments)

    @property
    def display_string(self):
        return ''.join(imap(unicode, self._logical_segments))

    @property
    def width(self):
        return self._width

    @lazy_attribute
    def display_slice(self):
        return slicer(1)(nop)()[:]

    @lazy_attribute
    def display_indexes(self):
        """
        Indexes of the current display w.r.t. the parent display indexes.
        """
        return set(range(self._width))

    def disconnect(self):
        self._disconnect_segments()
        super(DisplayElement, self).disconnect()

    def _disconnect_segments(self):
        for segment in self._logical_segments:
            segment.disconnect()

    @property
    def num_segments(self):
        return len(self._logical_segments)

    def set_num_segments(self, num_segments):
        width = self._width
        if not in_range(num_segments, 1, width) or width % num_segments != 0:
            raise DisplaySegmentationError, 'Can not split display of size %d into %d segments' % (self.width, num_segments)
        if num_segments != len(self._logical_segments):
            self._disconnect_segments()
            self._width_per_segment = width / num_segments
            self._logical_segments = [ LogicalDisplaySegment(self._width_per_segment, self.update) for _ in xrange(num_segments) ]

    def set_data_sources(self, sources):
        """
        Given a sequences of data sources, divides the display into
        the number of segments neded to accomodate them and connects
        the logical segments to the data sources.
        """
        if not sources:
            self.set_num_segments(1)
            self.reset()
        else:
            self.set_num_segments(len(sources))
            for segment, source in zip(self._logical_segments, sources):
                segment.set_data_source(source)

    @property
    def segments(self):
        return tuple(self._logical_segments)

    def segment(self, index):
        return self._logical_segments[index]

    def reset(self):
        for segment in self._logical_segments:
            segment.set_data_source(None)

    def update(self):
        pass


class PhysicalDisplayElement(DisplayElement, CompoundElement):
    """
    A physical character based display control element.
    """
    _ascii_translations = {'0': 48,
     '1': 49,
     '2': 50,
     '3': 51,
     '4': 52,
     '5': 53,
     '6': 54,
     '7': 55,
     '8': 56,
     '9': 57,
     'A': 65,
     'B': 66,
     'C': 67,
     'D': 68,
     'E': 69,
     'F': 70,
     'G': 71,
     'H': 72,
     'I': 73,
     'J': 74,
     'K': 75,
     'L': 76,
     'M': 77,
     'N': 78,
     'O': 79,
     'P': 80,
     'Q': 81,
     'R': 82,
     'S': 83,
     'T': 84,
     'U': 85,
     'V': 86,
     'W': 87,
     'X': 88,
     'Y': 89,
     'Z': 90,
     'a': 97,
     'b': 98,
     'c': 99,
     'd': 100,
     'e': 101,
     'f': 102,
     'g': 103,
     'h': 104,
     'i': 105,
     'j': 106,
     'k': 107,
     'l': 108,
     'm': 109,
     'n': 110,
     'o': 111,
     'p': 112,
     'q': 113,
     'r': 114,
     's': 115,
     't': 116,
     'u': 117,
     'v': 118,
     'w': 119,
     'x': 120,
     'y': 121,
     'z': 122,
     '@': 64,
     ' ': 32,
     '!': 33,
     '"': 34,
     '.': 46,
     ',': 44,
     ':': 58,
     ';': 59,
     '?': 63,
     '<': 60,
     '>': 62,
     '[': 91,
     ']': 93,
     '_': 95,
     '-': 45,
     '|': 124,
     '&': 38,
     '^': 94,
     '~': 126,
     '`': 96,
     "'": 39,
     '%': 37,
     '(': 40,
     ')': 41,
     '/': 47,
     '\\': 92,
     '*': 42,
     '+': 43}

    def __init__(self, *a, **k):
        self._central_resource = _DisplayCentralResource(root_display=self, on_grab_callback=self._on_central_resource_grab, on_release_callback=self._on_central_resource_release)
        super(PhysicalDisplayElement, self).__init__(resource_type=self.nested_display_resource_factory(self), *a, **k)
        self._translation_table = self._ascii_translations
        self._message_header = None
        self._message_tail = None
        self._message_clear_all = None
        self._message_to_send = None
        self._last_sent_message = None
        self._block_messages = False
        self._send_message_task = self._tasks.add(Task.run(self._send_message))
        self._send_message_task.kill()

    def nested_display_resource_factory(self, display):
        wrapper = ClientWrapper(wrap=lambda c: (display, c), unwrap=partial(maybe(second)))
        return const(ProxyResource(proxied_resource=self._central_resource, client_wrapper=wrapper))

    def _on_central_resource_grab(self, (display, client)):
        client.set_control_element(display, True)
        self.update()

    def _on_central_resource_release(self, (display, client)):
        client.set_control_element(display, False)
        self.update()

    @property
    @slicer(1)
    def subdisplay(self, char_slice):
        char_slice = to_slice(char_slice)
        return SubDisplayElement(sub_display_slice=char_slice, parent_display=self)

    def set_message_parts(self, header, tail):
        """
        Takes message parts as tuples containing the sysex bytes for
        each part of the message.
        """
        self._message_header = header
        self._message_tail = tail

    @property
    def message_header(self):
        return self._message_header

    @property
    def message_tail(self):
        return self._message_tail

    def set_clear_all_message(self, message):
        self._message_clear_all = message

    def set_translation_table(self, translation_table):
        raise '?' in translation_table['?'] or AssertionError
        self._translation_table = translation_table

    def set_block_messages(self, block):
        if block != self._block_messages:
            self._block_messages = block
        self.clear_send_cache()

    def display_message(self, message):
        if not self._block_messages:
            message = adjust_string(message, self._width)
            self._message_to_send = self._message_header + tuple(self._translate_string(message)) + self._message_tail
            self._request_send_message()

    def update(self):
        if not self._message_header is not None:
            raise AssertionError
            self._message_to_send = len(self._logical_segments) > 0 and not self._block_messages and None
            self._request_send_message()

    def clear_send_cache(self):
        self._last_sent_message = None
        self._request_send_message()

    def reset(self):
        if not (self._message_clear_all is not None or self._message_header is not None):
            raise AssertionError
            super(PhysicalDisplayElement, self).reset()
            if not self._block_messages:
                self._message_to_send = self._message_clear_all != None and self._message_clear_all
            else:
                self._message_to_send = tuple(chain(self._message_header, self._translate_string(' ' * self._width), self._message_tail))
            self._request_send_message()

    def send_midi(self, midi_bytes):
        if midi_bytes != self._last_sent_message:
            ControlElement.send_midi(self, midi_bytes)
            self._last_sent_message = midi_bytes

    def _request_send_message(self):
        self._send_message_task.restart()

    def _send_message(self):
        if not self._block_messages:
            if self._message_to_send is None:
                self._message_to_send = self._build_message(map(first, self._central_resource.owners))
            self.send_midi(self._message_to_send)

    def _translate_char(self, char_to_translate):
        result = 63
        if char_to_translate in self._translation_table.keys():
            result = self._translation_table[char_to_translate]
        else:
            result = self._translation_table['?']
        return result

    def _translate_string(self, string):
        return map(self._translate_char, string)

    def _build_display_message(self, display):
        message_string = display.display_string
        segments = display._logical_segments
        width_per_segment = display._width_per_segment

        def wrap_segment_message(message, segment):
            return chain(segment.position_identifier(), self._translate_string(message))

        return chain(*starmap(wrap_segment_message, izip(group(message_string, width_per_segment), segments)))

    def _build_inner_message(self, displays):
        message = list(self._build_display_message(self))
        for display in displays:
            message[display.display_slice] = self._build_display_message(display)

        return message

    def _build_message(self, displays):
        return tuple(chain(self._message_header, self._build_inner_message(displays), self._message_tail))


class SubDisplayElement(DisplayElement):

    def __init__(self, sub_display_slice = slice(1), parent_display = None, *a, **k):
        super(SubDisplayElement, self).__init__(width_in_chars=slice_size(sub_display_slice, parent_display.width), resource_type=parent_display.nested_display_resource_factory(self), *a, **k)
        self._sub_display_slice = sub_display_slice
        self._parent_display = parent_display

    @lazy_attribute
    def display_slice(self):
        return self._sub_display_slice

    @lazy_attribute
    def display_indexes(self):
        return set(range(*self._sub_display_slice.indices(self._parent_display.width)))

    def _is_visible(self):
        return self in map(first, self.resource.proxied_object.owners)

    def update(self):
        if self._is_visible():
            self._parent_display.update()
########NEW FILE########
__FILENAME__ = Profile
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/Profile.py
from functools import wraps, partial
ENABLE_PROFILING = False
if ENABLE_PROFILING:
    import cProfile
    PROFILER = cProfile.Profile()

def profile(fn):
    """
    Decorator to mark a function to be profiled. Only mark top level functions
    """
    if ENABLE_PROFILING:

        @wraps(fn)
        def wrapper(self, *a, **k):
            if PROFILER:
                return PROFILER.runcall(partial(fn, self, *a, **k))
            else:
                print 'Can not profile (%s), it is probably reloaded' % fn.__name__
                return fn(*a, **k)

        return wrapper
    else:
        return fn


def dump(name = 'default'):
    raise ENABLE_PROFILING or AssertionError
    import pstats
    fname = name + '.profile'
    PROFILER.dump_stats(fname)

    def save_human_data(sort):
        s = pstats.Stats(fname, stream=open('%s.%s.txt' % (fname, sort), 'w'))
        s.sort_stats(sort)
        s.print_stats()

    save_human_data('time')
    save_human_data('cumulative')
########NEW FILE########
__FILENAME__ = Proxy
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/Proxy.py
from __future__ import with_statement
from _Framework.Util import BooleanContext

class ProxyBase(object):
    """
    Provides a general mechanism for building automatic proxy
    objects. The access is determined between the proxied_object, the
    proxied_interface and the proxy itself following the following rules:
    
    When getting an attribute:
    
       - If it is the proxy object, return that.
       - Else if it is in the proxied_object and in the proxied_interface,
         return that of the proxied_object.
       - Else if it is in the proxied_interface, return that.
       - Else, throw an attribute error.
    
    When setting an attribute, since it is more risky, the rules are stricter.
    
       - If the the attribute is present in the proxy_interface, but not
         in the proxy, set in the proxy_object.
       - Else if the attribute is not preent in the proxy_interface, set it
         in the proxy_object.
       - If the attribute is present in both the proxy_interface and
         the proxy_object, raise an AttributeError complaining about
         ambiguity.
    """
    _skip_wrapper_lookup = None

    def __init__(self, *a, **k):
        super(ProxyBase, self).__init__(*a, **k)
        self._skip_wrapper_lookup = BooleanContext()

    def proxy_hasattr(self, attr):
        """
        Returns wether the proxy, not the proxied, has an attribute.
        """
        with self._skip_wrapper_lookup():
            return hasattr(self, attr)

    def __getattr__(self, name):
        if not self._skip_wrapper_lookup:
            obj = self.proxied_object
            interface = self.proxied_interface
            if obj and hasattr(interface, name):
                return getattr(obj, name)
            return getattr(interface, name)
        raise AttributeError, 'Does not have attribute %s' % name

    def __setattr__(self, name, value):
        obj = self.proxied_object
        interface = self.proxied_interface
        if obj and hasattr(interface, name):
            if self.proxy_hasattr(name):
                raise AttributeError, 'Ambiguous set attribute: %s proxied: %s' % (name, obj)
            setattr(obj, name, value)
        else:
            if hasattr(interface, name):
                raise AttributeError, 'Ambiguous set attribute: %s proxied: %s' % (name, obj)
            self.__dict__[name] = value

    @property
    def proxied_object(self):
        return None

    @property
    def proxied_interface(self):
        obj = self.proxied_object
        return getattr(obj, 'proxied_interface', obj)


class Proxy(ProxyBase):
    proxied_object = None
    _proxied_interface = None

    @property
    def proxied_interface(self):
        return self._proxied_interface or super(Proxy, self).proxied_interface

    def __init__(self, proxied_object = None, proxied_interface = None, *a, **k):
        super(Proxy, self).__init__(*a, **k)
        self.proxied_object = proxied_object
        self._proxied_interface = proxied_interface
########NEW FILE########
__FILENAME__ = Resource
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/Resource.py
from functools import partial
from _Framework.Proxy import Proxy
from _Framework.Util import index_if, nop, first, NamedTuple

class Resource(object):

    def grab(self, client, *a, **k):
        raise NotImplemented

    def release(self, client):
        raise NotImplemented

    def get_owner(self):
        raise NotImplementedError

    owner = property(lambda self: self.get_owner())


class CompoundResource(Resource):
    """
    A resource that composes two resources, making sure that both
    grabs have to be successfull for the compound to be adquired.
    """

    def __init__(self, first_resource = None, second_resource = None, *a, **k):
        super(CompoundResource, self).__init__(*a, **k)
        self._first_resource = first_resource
        self._second_resource = second_resource

    def grab(self, client, *a, **k):
        if self._first_resource.grab(client, *a, **k):
            if self._second_resource.grab(client, *a, **k):
                pass
            else:
                self._first_resource.release(client)
        return self.owner == client

    def release(self, client):
        if not client:
            raise AssertionError
            client == self.owner and self._second_resource.release(client)
            self._first_resource.release(client)
            return True
        return False

    def get_owner(self):
        return self._first_resource.owner or self._second_resource.owner

    @property
    def first(self):
        return self._first_resource

    @property
    def second(self):
        return self._second_resource


def compose_resources(*resources):
    return reduce(CompoundResource, resources)


class ExclusiveResource(Resource):
    """
    A resource that can not be grabbed any client if it is owned by
    someone else already.
    """

    def __init__(self, on_grab_callback = None, on_release_callback = None, *a, **k):
        super(ExclusiveResource, self).__init__(*a, **k)
        self._owner = None
        if on_grab_callback:
            self.on_grab = on_grab_callback
        if on_release_callback:
            self.on_release = on_release_callback

    def grab(self, client, *a, **k):
        if not client is not None:
            raise AssertionError, 'Someone has to adquire resource'
            self._owner == None and self.on_grab(client, *a, **k)
            self._owner = client
        return self._owner == client

    def release(self, client):
        if not client:
            raise AssertionError
            self._owner = client == self._owner and None
            self.on_release(client)
            return True
        return False

    def get_owner(self):
        return self._owner

    def on_grab(self, client, *a, **k):
        raise NotImplemented, 'Override or pass callback'

    def on_release(self, client):
        raise NotImplemented, 'Override or pass callback'


class SharedResource(Resource):
    """
    A resource that has no owner and will always be grabbed.
    """

    def __init__(self, on_grab_callback = None, on_release_callback = None, *a, **k):
        super(SharedResource, self).__init__(*a, **k)
        if on_grab_callback:
            self.on_grab = on_grab_callback
        if on_release_callback:
            self.on_release = on_release_callback
        self._clients = set()

    def grab(self, client, *a, **k):
        raise client is not None or AssertionError, 'Someone has to adquire resource'
        self.on_grab(client, *a, **k)
        self._clients.add(client)
        return True

    def release(self, client):
        if not client:
            raise AssertionError
            client in self._clients and self.on_release(client)
            self._clients.remove(client)
            for client in self._clients:
                self.on_grab(client)

            return True
        return False

    def get_owner(self):
        raise False or AssertionError, 'Shared resource has no owner'

    def on_grab(self, client, *a, **k):
        raise NotImplemented, 'Override or pass callback'

    def on_release(self, client):
        raise NotImplemented, 'Override or pass callback'


class StackingResource(Resource):
    """
    A stacking resource is a special kind of resource that can preempt
    the current owner.  Resources are assigned to clients in order of
    arrival, this is, a new client attempting to grab will produce the
    former owner to be released.  However, when the current owner
    released ownership will be passed back to the last owner.
    
    This, clients are organised in a stack, where grabbing puts the
    client at the top, and releasing removes from wherever the client
    is in the stack.  Because ownership can change even a client does
    not release, a client should not use the resource based on the
    result of the grab() method but instead use whatever indirect API
    the concrete resource provides to assign ownership.
    
    Clients of a stacking resource can be prioritised to prevent
    preemption from a client with less priority. (For example, a modal
    dialog should not loose focus because of a normal window
    appearing.)
    """
    default_priority = 0

    def __init__(self, on_grab_callback = None, on_release_callback = None, *a, **k):
        super(StackingResource, self).__init__(*a, **k)
        self._clients = []
        self._owners = set()
        if on_grab_callback:
            self.on_grab = on_grab_callback
        if on_release_callback:
            self.on_release = on_release_callback

    def grab(self, client, priority = None):
        if not client is not None:
            raise AssertionError
            if priority is None:
                priority = self.default_priority
            old_owners = self._owners
            self._remove_client(client)
            self._add_client(client, priority)
            new_owners = self._actual_owners()
            new_owners != old_owners and self._on_release_set(set(old_owners) - set(new_owners))
            self._on_grab_set(new_owners)
            self._owners = new_owners
        return True

    def _on_release_set(self, clients):
        for client in clients:
            self.on_release(client)

    def _on_grab_set(self, clients):
        for client in clients:
            self.on_grab(client)

    def release(self, client):
        if not client is not None:
            raise AssertionError
            old_owners = self._owners
            result = self._remove_client(client)
            new_owners = self._actual_owners()
            self._owners = new_owners != old_owners and new_owners
            self._on_release_set(set(old_owners) - set(new_owners))
            self._on_grab_set(new_owners)
        return result

    def release_all(self):
        """
        Releases all stacked clients.
        """
        for client, _ in list(self._clients):
            self.release(client)

    def _add_client(self, client, priority):
        idx = index_if(lambda (_, p): p > priority, self._clients)
        self._clients.insert(idx, (client, priority))

    def _remove_client(self, client):
        idx = index_if(lambda (c, _): c == client, self._clients)
        if idx != len(self._clients):
            del self._clients[idx]
            return True

    def _actual_owners(self):
        return [self._clients[-1][0]] if self._clients else []

    @property
    def max_priority(self):
        return self._clients[-1][1] if self._clients else self.default_priority

    @property
    def stack_size(self):
        return len(self._clients)

    def get_owner(self):
        raise not self._owners or len(self._owners) == 1 or AssertionError
        for owner in self._owners:
            return owner

    @property
    def clients(self):
        return map(first, self._clients)

    @property
    def owners(self):
        return self._owners

    def on_grab(self, client):
        raise NotImplemented, 'Override or pass callback'

    def on_release(self, client):
        raise NotImplemented, 'Override or pass callback'

    def release_stacked(self):
        clients = self.clients
        owners = self.owners
        for client in clients:
            if client not in owners:
                self.release(client)


class PrioritizedResource(StackingResource):
    """
    A prioritized resource shares the resource among all the clients
    with the same priority.
    """

    def _actual_owners(self):
        max_priority = self.max_priority
        return [ client for client, priority in self._clients if priority == max_priority ]


class ClientWrapper(NamedTuple):
    wrap = partial(nop)
    unwrap = partial(nop)


class ProxyResource(Proxy):
    """
    A resource that forwards to another resource.  One may specify a
    'proxy_client' function that can wrap the client to adapt it to
    the proxied resource requirements.
    """

    def __init__(self, proxied_resource = None, client_wrapper = ClientWrapper(), *a, **k):
        raise proxied_resource or AssertionError
        super(ProxyResource, self).__init__(proxied_object=proxied_resource, *a, **k)
        self._client_wrapper = client_wrapper

    def grab(self, client, *a, **k):
        self.__getattr__('grab')(self._client_wrapper.wrap(client), *a, **k)

    def release(self, client, *a, **k):
        self.__getattr__('release')(self._client_wrapper.wrap(client), *a, **k)

    @property
    def owner(self):
        return self._client_wrapper.unwrap(self.__getattr__('owner'))

    @property
    def owners(self):
        return map(self._client_wrapper.unwrap, self.__getattr__('owners'))
########NEW FILE########
__FILENAME__ = SceneComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/SceneComponent.py
from CompoundComponent import CompoundComponent
from ClipSlotComponent import ClipSlotComponent
from Util import in_range, nop

class SceneComponent(CompoundComponent):
    """
    Class representing a scene in Live
    """
    clip_slot_component_type = ClipSlotComponent

    def __init__(self, num_slots = 0, tracks_to_use_callback = nop, *a, **k):
        raise num_slots >= 0 or AssertionError
        raise callable(tracks_to_use_callback) or AssertionError
        super(SceneComponent, self).__init__(*a, **k)
        self._scene = None
        self._clip_slots = []
        self._tracks_to_use_callback = tracks_to_use_callback
        for _ in range(num_slots):
            new_slot = self._create_clip_slot()
            self._clip_slots.append(new_slot)
            self.register_components(new_slot)

        self._launch_button = None
        self._triggered_value = 127
        self._track_offset = 0
        self._select_button = None
        self._delete_button = None

    def disconnect(self):
        super(SceneComponent, self).disconnect()
        if self._scene != None:
            self._scene.remove_is_triggered_listener(self._on_is_triggered_changed)
        if self._launch_button != None:
            self._launch_button.remove_value_listener(self._launch_value)
            self._launch_button = None

    def on_track_list_changed(self):
        self.update()

    def set_scene(self, scene):
        if scene != self._scene or type(self._scene) != type(scene):
            if self._scene != None:
                self._scene.remove_is_triggered_listener(self._on_is_triggered_changed)
            self._scene = scene
            if self._scene != None:
                self._scene.add_is_triggered_listener(self._on_is_triggered_changed)
            self.update()

    def set_launch_button(self, button):
        if button != self._launch_button:
            if self._launch_button != None:
                self._launch_button.remove_value_listener(self._launch_value)
            self._launch_button = button
            if self._launch_button != None:
                self._launch_button.add_value_listener(self._launch_value)
            self.update()

    def set_select_button(self, button):
        self._select_button = button

    def set_delete_button(self, button):
        self._delete_button = button

    def set_track_offset(self, offset):
        if not offset >= 0:
            raise AssertionError
            self._track_offset = offset != self._track_offset and offset
            self.update()

    def set_triggered_value(self, value):
        value = int(value)
        raise in_range(value, 0, 128) or AssertionError
        self._triggered_value = value

    def clip_slot(self, index):
        return self._clip_slots[index]

    def update(self):
        if self._allow_updates:
            if self._scene != None and self.is_enabled():
                clip_index = self._track_offset
                tracks = self.song().tracks
                clip_slots = self._scene.clip_slots
                if self._track_offset > 0:
                    real_offset = 0
                    visible_tracks = 0
                    while visible_tracks < self._track_offset and len(tracks) > real_offset:
                        if tracks[real_offset].is_visible:
                            visible_tracks += 1
                        real_offset += 1

                    clip_index = real_offset
                for slot in self._clip_slots:
                    while len(tracks) > clip_index and not tracks[clip_index].is_visible:
                        clip_index += 1

                    if len(clip_slots) > clip_index:
                        slot.set_clip_slot(clip_slots[clip_index])
                    else:
                        slot.set_clip_slot(None)
                    clip_index += 1

                self._on_is_triggered_changed()
            else:
                for slot in self._clip_slots:
                    slot.set_clip_slot(None)

                if self.is_enabled() and self._launch_button != None:
                    self._launch_button.turn_off()
        else:
            self._update_requests += 1

    def _launch_value(self, value):
        if self.is_enabled():
            if self._select_button and self._select_button.is_pressed() and value:
                self._do_select_scene(self._scene)
            elif self._scene != None:
                if self._delete_button and self._delete_button.is_pressed() and value:
                    self._do_delete_scene(self._scene)
                else:
                    self._do_launch_scene(value)

    def _do_select_scene(self, scene_for_overrides):
        if self._scene != None:
            view = self.song().view
            if view.selected_scene != self._scene:
                view.selected_scene = self._scene

    def _do_delete_scene(self, scene_for_overrides):
        try:
            if self._scene:
                song = self.song()
                song.delete_scene(list(song.scenes).index(self._scene))
        except RuntimeError:
            pass

    def _do_launch_scene(self, value):
        launched = False
        if self._launch_button.is_momentary():
            self._scene.set_fire_button_state(value != 0)
            launched = value != 0
        elif value != 0:
            self._scene.fire()
            launched = True
        if launched and self.song().select_on_launch:
            self.song().view.selected_scene = self._scene

    def _on_is_triggered_changed(self):
        if not self._scene != None:
            raise AssertionError
            if self.is_enabled() and self._launch_button != None:
                self._scene.is_triggered and self._launch_button.send_value(self._triggered_value)
            else:
                self._launch_button.turn_off()

    def _create_clip_slot(self):
        return self.clip_slot_component_type()
########NEW FILE########
__FILENAME__ = ScrollComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/ScrollComponent.py
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.SubjectSlot import subject_slot
from _Framework import Task
from _Framework import Defaults

class Scrollable(object):
    """
    Abstract interface for an object that can be scrolled in discreet
    steps in one dimension.
    """

    def can_scroll_up(self):
        return False

    def can_scroll_down(self):
        return False

    def scroll_up(self):
        pass

    def scroll_down(self):
        pass


class ScrollComponent(ControlSurfaceComponent, Scrollable):
    """
    A component that handles scrolling behavior over a Scrollable
    with a pair of buttons.
    """
    is_private = True
    scrolling_delay = Defaults.MOMENTARY_DELAY
    scrolling_step_delay = 0.1
    default_scrollable = Scrollable()
    default_pager = Scrollable()
    _scrollable = default_scrollable

    def __init__(self, scrollable = None, *a, **k):
        super(ScrollComponent, self).__init__(*a, **k)
        self._scroll_task_up = self._make_scroll_task(self._do_scroll_up)
        self._scroll_task_down = self._make_scroll_task(self._do_scroll_down)
        if scrollable != None:
            self.scrollable = scrollable

    def _make_scroll_task(self, scroll_step):
        task = self._tasks.add(Task.sequence(Task.wait(self.scrolling_delay), Task.loop(Task.wait(self.scrolling_step_delay), Task.run(scroll_step))))
        task.kill()
        return task

    def _get_scrollable(self):
        return self._scrollable

    def _set_scrollable(self, scrollable):
        self._scrollable = scrollable
        self.update()

    scrollable = property(_get_scrollable, _set_scrollable)

    def can_scroll_up(self):
        return self._scrollable.can_scroll_up()

    def can_scroll_down(self):
        return self._scrollable.can_scroll_down()

    def scroll_up(self):
        return self._scrollable.scroll_up()

    def scroll_down(self):
        return self._scrollable.scroll_down()

    def set_scroll_up_button(self, button):
        if button:
            button.reset()
        self._on_scroll_up_value.subject = button
        if not button or not button.is_pressed():
            self._scroll_task_up.kill()
        self._update_scroll_up_button()

    def set_scroll_down_button(self, button):
        if button:
            button.reset()
        self._on_scroll_down_value.subject = button
        if not button or not button.is_pressed():
            self._scroll_task_down.kill()
        self._update_scroll_down_button()

    def update(self):
        self._update_scroll_down_button()
        self._update_scroll_up_button()

    def _update_scroll_up_button(self):
        button = self._on_scroll_up_value.subject
        if self.is_enabled() and button:
            if button.is_momentary():
                is_pressed = button.is_pressed()
                can_scroll_up = self.can_scroll_up()
                can_scroll_up and button.set_light('Pressed' if is_pressed else 'Enabled')
            else:
                button.turn_off()

    def _update_scroll_down_button(self):
        button = self._on_scroll_down_value.subject
        if self.is_enabled() and button:
            if button.is_momentary():
                is_pressed = button.is_pressed()
                can_scroll_down = self.can_scroll_down()
                can_scroll_down and button.set_light('Pressed' if is_pressed else 'Enabled')
            else:
                button.turn_off()

    @subject_slot('value')
    def _on_scroll_up_value(self, value):
        self._on_scroll_value(value, self._on_scroll_up_value.subject, self._do_scroll_up, self._scroll_task_up)

    @subject_slot('value')
    def _on_scroll_down_value(self, value):
        self._on_scroll_value(value, self._on_scroll_down_value.subject, self._do_scroll_down, self._scroll_task_down)

    def _do_scroll_up(self):
        self.scroll_up()
        self._update_scroll_up_button()
        self._update_scroll_down_button()

    def _do_scroll_down(self):
        self.scroll_down()
        self._update_scroll_up_button()
        self._update_scroll_down_button()

    def _on_scroll_value(self, value, button, scroll_step, scroll_task):
        if self.is_enabled():
            is_momentary = button.is_momentary()
            if not not self._scroll_task_up.is_killed:
                is_scrolling = not self._scroll_task_down.is_killed
                if not is_scrolling or not is_momentary:
                    scroll_step()
                scroll_task.kill()
                is_momentary and value and scroll_task.restart()
            self._ensure_scroll_one_direction()
            self.update()

    def _ensure_scroll_one_direction(self):
        scroll_up_button = self._on_scroll_up_value.subject
        scroll_down_button = self._on_scroll_down_value.subject
        if scroll_up_button and scroll_up_button.is_pressed() and scroll_down_button and scroll_down_button.is_pressed():
            self._scroll_task_up.pause()
            self._scroll_task_down.pause()
        else:
            self._scroll_task_up.resume()
            self._scroll_task_down.resume()
########NEW FILE########
__FILENAME__ = SessionComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/SessionComponent.py
import Live
from CompoundComponent import CompoundComponent
from SceneComponent import SceneComponent
from SubjectSlot import subject_slot
from ScrollComponent import ScrollComponent
from Util import in_range, product

class SessionComponent(CompoundComponent):
    """
    Class encompassing several scene to cover a defined section of
    Live's session.  It controls the session ring and the set of tracks
    controlled by a given mixer.
    """
    __subject_events__ = ('offset',)
    _linked_session_instances = []
    _minimal_track_offset = -1
    _minimal_scene_offset = -1
    _highlighting_callback = None
    _session_component_ends_initialisation = True
    scene_component_type = SceneComponent

    def __init__(self, num_tracks = 0, num_scenes = 0, *a, **k):
        super(SessionComponent, self).__init__(*a, **k)
        raise num_tracks >= 0 or AssertionError
        if not num_scenes >= 0:
            raise AssertionError
            self._track_offset = -1
            self._scene_offset = -1
            self._num_tracks = num_tracks
            self._num_scenes = num_scenes
            self._vertical_banking, self._horizontal_banking = self.register_components(ScrollComponent(), ScrollComponent())
            self._vertical_banking.can_scroll_up = self._can_bank_up
            self._vertical_banking.can_scroll_down = self._can_bank_down
            self._vertical_banking.scroll_up = self._bank_up
            self._vertical_banking.scroll_down = self._bank_down
            self._horizontal_banking.can_scroll_up = self._can_bank_left
            self._horizontal_banking.can_scroll_down = self._can_bank_right
            self._horizontal_banking.scroll_up = self._bank_left
            self._horizontal_banking.scroll_down = self._bank_right
            self._track_banking_increment = 1
            self._stop_all_button = None
            self._next_scene_button = None
            self._prev_scene_button = None
            self._stop_track_clip_buttons = None
            self._stop_track_clip_value = 127
            self._stop_track_clip_slots = self.register_slot_manager()
            self._highlighting_callback = None
            self._show_highlight = num_tracks > 0 and num_scenes > 0
            self._mixer = None
            self._track_slots = self.register_slot_manager()
            self._selected_scene = self.register_component(self._create_scene())
            self._scenes = self.register_components(*[ self._create_scene() for _ in xrange(num_scenes) ])
            self._session_component_ends_initialisation and self._end_initialisation()

    def _end_initialisation(self):
        self.on_selected_scene_changed()
        self.set_offsets(0, 0)

    def _create_scene(self):
        return self.scene_component_type(num_slots=self._num_tracks, tracks_to_use_callback=self.tracks_to_use)

    def disconnect(self):
        if self._is_linked():
            self._unlink()
        super(CompoundComponent, self).disconnect()

    def set_highlighting_callback(self, callback):
        if not (not callback or callable(callback)):
            raise AssertionError
            self._highlighting_callback = self._highlighting_callback != callback and callback
            self._do_show_highlight()

    def scene(self, index):
        raise in_range(index, 0, len(self._scenes)) or AssertionError
        return self._scenes[index]

    def selected_scene(self):
        return self._selected_scene

    def set_scene_bank_buttons(self, down_button, up_button):
        self.set_scene_bank_up_button(up_button)
        self.set_scene_bank_down_button(down_button)

    def set_scene_bank_up_button(self, button):
        self._bank_up_button = button
        self._vertical_banking.set_scroll_up_button(button)

    def set_scene_bank_down_button(self, button):
        self._bank_down_button = button
        self._vertical_banking.set_scroll_down_button(button)

    def set_track_bank_buttons(self, right_button, left_button):
        self.set_track_bank_left_button(left_button)
        self.set_track_bank_right_button(right_button)

    def set_track_bank_left_button(self, button):
        self._bank_left_button = button
        self._horizontal_banking.set_scroll_up_button(button)

    def set_track_bank_right_button(self, button):
        self._bank_right_button = button
        self._horizontal_banking.set_scroll_down_button(button)

    def set_stop_all_clips_button(self, button):
        self._stop_all_button = button
        self._on_stop_all_value.subject = button
        self._update_stop_all_clips_button()

    def set_stop_track_clip_buttons(self, buttons):
        self._stop_track_clip_slots.disconnect()
        self._stop_track_clip_buttons = buttons
        if self._stop_track_clip_buttons != None:
            for index, button in enumerate(self._stop_track_clip_buttons):
                if button:
                    self._stop_track_clip_slots.register_slot(button, self._on_stop_track_value, 'value', extra_kws={'identify_sender': True})
                self._on_fired_slot_index_changed(index)

    def set_track_banking_increment(self, increment):
        raise increment > 0 or AssertionError
        self._track_banking_increment = increment

    def set_stop_track_clip_value(self, value):
        raise in_range(value, 0, 128) or AssertionError
        self._stop_track_clip_value = value

    def set_select_buttons(self, next_button, prev_button):
        self.set_select_next_button(next_button)
        self.set_select_prev_button(prev_button)

    def set_select_next_button(self, next_button):
        self._next_scene_button = next_button
        self._on_next_scene_value.subject = next_button
        self._update_select_buttons()

    def set_select_prev_button(self, prev_button):
        self._prev_scene_button = prev_button
        self._on_prev_scene_value.subject = prev_button
        self._update_select_buttons()

    def set_clip_launch_buttons(self, buttons):
        raise not buttons or buttons.width() == self._num_tracks and buttons.height() == self._num_scenes or AssertionError
        if buttons:
            for button, (x, y) in buttons.iterbuttons():
                scene = self.scene(y)
                slot = scene.clip_slot(x)
                slot.set_launch_button(button)

        else:
            for x, y in product(xrange(self._num_tracks), xrange(self._num_scenes)):
                scene = self.scene(y)
                slot = scene.clip_slot(x)
                slot.set_launch_button(None)

    def set_scene_launch_buttons(self, buttons):
        raise not buttons or buttons.width() == self._num_scenes and buttons.height() == 1 or AssertionError
        if buttons:
            for button, (x, _) in buttons.iterbuttons():
                scene = self.scene(x)
                scene.set_launch_button(button)

        else:
            for x in xrange(self._num_scenes):
                scene = self.scene(x)
                scene.set_launch_button(None)

    def set_mixer(self, mixer):
        """ Sets the MixerComponent to be controlled by this session """
        self._mixer = mixer
        if self._mixer != None:
            self._mixer.set_track_offset(self.track_offset())

    def set_offsets(self, track_offset, scene_offset):
        if not track_offset >= 0:
            raise AssertionError
            raise scene_offset >= 0 or AssertionError
            track_increment = 0
            scene_increment = 0
            self._is_linked() and SessionComponent._perform_offset_change(track_offset - self._track_offset, scene_offset - self._scene_offset)
        else:
            if len(self.tracks_to_use()) > track_offset:
                track_increment = track_offset - self._track_offset
            if len(self.song().scenes) > scene_offset:
                scene_increment = scene_offset - self._scene_offset
            self._change_offsets(track_increment, scene_increment)

    def set_show_highlight(self, show_highlight):
        if self._show_highlight != show_highlight:
            self._show_highlight = show_highlight
            self._do_show_highlight()

    def on_enabled_changed(self):
        self.update()
        self._do_show_highlight()

    def update(self):
        if self._allow_updates:
            self._update_select_buttons()
            self._update_stop_track_clip_buttons()
            self._update_stop_all_clips_button()
        else:
            self._update_requests += 1

    def _update_stop_track_clip_buttons(self):
        if self.is_enabled():
            for index in xrange(self._num_tracks):
                self._on_fired_slot_index_changed(index)

    def on_scene_list_changed(self):
        if not self._update_scene_offset():
            self._reassign_scenes()

    def on_track_list_changed(self):
        num_tracks = len(self.tracks_to_use())
        new_track_offset = self.track_offset()
        if new_track_offset >= num_tracks:
            new_track_offset = num_tracks - 1
            new_track_offset -= new_track_offset % self._track_banking_increment
        self._reassign_tracks()
        self.set_offsets(new_track_offset, self.scene_offset())

    def on_selected_scene_changed(self):
        self._update_scene_offset()
        if self._selected_scene != None:
            self._selected_scene.set_scene(self.song().view.selected_scene)

    def width(self):
        return self._num_tracks

    def height(self):
        return len(self._scenes)

    def track_offset(self):
        return self._track_offset

    def scene_offset(self):
        return self._scene_offset

    def tracks_to_use(self):
        list_of_tracks = None
        if self._mixer != None:
            list_of_tracks = self._mixer.tracks_to_use()
        else:
            list_of_tracks = self.song().visible_tracks
        return list_of_tracks

    def _get_minimal_track_offset(self):
        return SessionComponent._minimal_track_offset if self._is_linked() else self.track_offset()

    def _get_minimal_scene_offset(self):
        return SessionComponent._minimal_scene_offset if self._is_linked() else self.scene_offset()

    def _can_bank_down(self):
        return len(self.song().scenes) > self._get_minimal_scene_offset() + 1

    def _can_bank_up(self):
        return self._get_minimal_scene_offset() > 0

    def _can_bank_right(self):
        return len(self.tracks_to_use()) > self._get_minimal_track_offset() + 1

    def _can_bank_left(self):
        return self._get_minimal_track_offset() > 0

    def _bank_up(self):
        return self.set_offsets(self.track_offset(), max(0, self.scene_offset() - 1))

    def _bank_down(self):
        return self.set_offsets(self.track_offset(), self.scene_offset() + 1)

    def _bank_right(self):
        return self.set_offsets(self.track_offset() + self._track_banking_increment, self.scene_offset())

    def _bank_left(self):
        return self.set_offsets(max(self.track_offset() - self._track_banking_increment, 0), self.scene_offset())

    def _update_stop_all_clips_button(self):
        button = self._stop_all_button
        if button:
            button.set_light(button.is_pressed())

    def _update_select_buttons(self):
        selected_scene = self.song().view.selected_scene
        if self._next_scene_button != None:
            self._next_scene_button.set_light(selected_scene != self.song().scenes[-1])
        if self._prev_scene_button != None:
            self._prev_scene_button.set_light(selected_scene != self.song().scenes[0])

    def _update_scene_offset(self):
        offset_corrected = False
        num_scenes = len(self.song().scenes)
        if self.scene_offset() >= num_scenes:
            self.set_offsets(self.track_offset(), num_scenes - 1)
            offset_corrected = True
        return offset_corrected

    def _change_offsets(self, track_increment, scene_increment):
        if not track_increment != 0:
            offsets_changed = scene_increment != 0
            offsets_changed and self._track_offset += track_increment
            self._scene_offset += scene_increment
            raise self._track_offset >= 0 or AssertionError
            if not self._scene_offset >= 0:
                raise AssertionError
                if self._mixer != None:
                    self._mixer.set_track_offset(self.track_offset())
                self._reassign_tracks()
                self._reassign_scenes()
                self.notify_offset()
                self.width() > 0 and self.height() > 0 and self._do_show_highlight()

    def _reassign_scenes(self):
        scenes = self.song().scenes
        for index, scene in enumerate(self._scenes):
            scene_index = self._scene_offset + index
            if len(scenes) > scene_index:
                scene.set_scene(scenes[scene_index])
                scene.set_track_offset(self._track_offset)
            else:
                self._scenes[index].set_scene(None)

        if self._selected_scene != None:
            self._selected_scene.set_track_offset(self._track_offset)
        self._vertical_banking.update()

    def _reassign_tracks(self):
        self._track_slots.disconnect()
        tracks_to_use = self.tracks_to_use()
        for index in range(self._num_tracks):
            listener = lambda index = index: self._on_fired_slot_index_changed(index)
            if self._track_offset + index < len(tracks_to_use):
                track = tracks_to_use[self._track_offset + index]
                if track in self.song().tracks:
                    self._track_slots.register_slot(track, listener, 'fired_slot_index')
            listener()

        self._horizontal_banking.update()

    @subject_slot('value')
    def _on_stop_all_value(self, value):
        self._stop_all_value(value)

    def _stop_all_value(self, value):
        if self.is_enabled():
            if value is not 0 or not self._stop_all_button.is_momentary():
                self.song().stop_all_clips()
            self._update_stop_all_clips_button()

    @subject_slot('value')
    def _on_next_scene_value(self, value):
        if self.is_enabled():
            if value is not 0 or not self._next_scene_button.is_momentary():
                selected_scene = self.song().view.selected_scene
                all_scenes = self.song().scenes
                if selected_scene != all_scenes[-1]:
                    index = list(all_scenes).index(selected_scene)
                    self.song().view.selected_scene = all_scenes[index + 1]

    @subject_slot('value')
    def _on_prev_scene_value(self, value):
        if self.is_enabled():
            if value is not 0 or not self._prev_scene_button.is_momentary():
                selected_scene = self.song().view.selected_scene
                all_scenes = self.song().scenes
                if selected_scene != all_scenes[0]:
                    index = list(all_scenes).index(selected_scene)
                    self.song().view.selected_scene = all_scenes[index - 1]

    @subject_slot('value')
    def _on_stop_track_value(self, value, sender):
        if self.is_enabled():
            if value is not 0 or not sender.is_momentary():
                tracks = self.tracks_to_use()
                track_index = list(self._stop_track_clip_buttons).index(sender) + self.track_offset()
                if in_range(track_index, 0, len(tracks)) and tracks[track_index] in self.song().tracks:
                    tracks[track_index].stop_all_clips()

    def _do_show_highlight(self):
        if self._highlighting_callback != None:
            return_tracks = self.song().return_tracks
            if len(return_tracks) > 0:
                include_returns = return_tracks[0] in self.tracks_to_use()
                self._show_highlight and self._highlighting_callback(self._track_offset, self._scene_offset, self.width(), self.height(), include_returns)
            else:
                self._highlighting_callback(-1, -1, -1, -1, include_returns)

    def _on_fired_slot_index_changed(self, index):
        tracks_to_use = self.tracks_to_use()
        track_index = index + self.track_offset()
        if self.is_enabled() and self._stop_track_clip_buttons != None:
            if index < len(self._stop_track_clip_buttons):
                button = self._stop_track_clip_buttons[index]
                if button != None:
                    track_index < len(tracks_to_use) and tracks_to_use[track_index].clip_slots and tracks_to_use[track_index].fired_slot_index == -2 and button.send_value(self._stop_track_clip_value)
                else:
                    button.turn_off()

    def _is_linked(self):
        return self in SessionComponent._linked_session_instances

    def _link(self):
        raise not self._is_linked() or AssertionError
        SessionComponent._linked_session_instances.append(self)

    def _unlink(self):
        raise self._is_linked() or AssertionError
        SessionComponent._linked_session_instances.remove(self)

    @staticmethod
    def _perform_offset_change(track_increment, scene_increment):
        """ Performs the given offset changes on all linked instances """
        if not len(SessionComponent._linked_session_instances) > 0:
            raise AssertionError
            scenes = Live.Application.get_application().get_document().scenes
            instances_covering_session = 0
            found_negative_offset = False
            minimal_track_offset = -1
            minimal_scene_offset = -1
            for instance in SessionComponent._linked_session_instances:
                new_track_offset = instance.track_offset() + track_increment
                new_scene_offset = instance.scene_offset() + scene_increment
                if new_track_offset >= 0 and new_scene_offset >= 0:
                    if new_track_offset < len(instance.tracks_to_use()) and new_scene_offset < len(scenes):
                        instances_covering_session += 1
                        if minimal_track_offset < 0:
                            minimal_track_offset = new_track_offset
                        else:
                            minimal_track_offset = min(minimal_track_offset, new_track_offset)
                        if minimal_scene_offset < 0:
                            minimal_scene_offset = new_scene_offset
                        else:
                            minimal_scene_offset = min(minimal_scene_offset, new_scene_offset)
                else:
                    found_negative_offset = True
                    break

            SessionComponent._minimal_track_offset = not found_negative_offset and instances_covering_session > 0 and minimal_track_offset
            SessionComponent._minimal_scene_offset = minimal_scene_offset
            for instance in SessionComponent._linked_session_instances:
                instance._change_offsets(track_increment, scene_increment)
########NEW FILE########
__FILENAME__ = SessionZoomingComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/SessionZoomingComponent.py
from SubjectSlot import subject_slot
from CompoundComponent import CompoundComponent
from ScrollComponent import ScrollComponent
from Util import in_range

class SessionZoomingComponent(CompoundComponent):
    """
    Class using a matrix of buttons to choose blocks of clips in the
    session, as if you had zoomed out from session.
    """

    def __init__(self, session = None, *a, **k):
        super(SessionZoomingComponent, self).__init__(*a, **k)
        raise session or AssertionError
        self._buttons = None
        self._zoom_button = None
        self._scene_bank_buttons = None
        self._scene_bank_button_slots = self.register_slot_manager()
        self._scene_bank_index = 0
        self._is_zoomed_out = False
        self._empty_value = 0
        self._stopped_value = 100
        self._playing_value = 127
        self._selected_value = 64
        self._session, self._vertical_scroll, self._horizontal_scroll = self.register_components(session, ScrollComponent(), ScrollComponent())
        self._vertical_scroll.can_scroll_up = self._can_scroll_up
        self._vertical_scroll.can_scroll_down = self._can_scroll_down
        self._vertical_scroll.scroll_up = self._scroll_up
        self._vertical_scroll.scroll_down = self._scroll_down
        self._horizontal_scroll.can_scroll_up = self._can_scroll_left
        self._horizontal_scroll.can_scroll_down = self._can_scroll_right
        self._horizontal_scroll.scroll_up = self._scroll_left
        self._horizontal_scroll.scroll_down = self._scroll_right
        self.register_slot(self._session, self._on_session_offset_changes, 'offset')

    def on_scene_list_changed(self):
        self.update()

    def on_enabled_changed(self):
        super(SessionZoomingComponent, self).on_enabled_changed()
        self._session.set_show_highlight(self.is_enabled())

    def set_button_matrix(self, buttons):
        if buttons != self._buttons:
            self._buttons = buttons
            self._on_matrix_value.subject = self._buttons
        self.update()

    def set_zoom_button(self, button):
        if button != self._zoom_button:
            self._zoom_button = button
            self._on_zoom_value.subject = button
            self._is_zoomed_out = False
            self.update()

    def set_nav_buttons(self, up, down, left, right):
        self.set_nav_up_button(up)
        self.set_nav_down_button(down)
        self.set_nav_left_button(left)
        self.set_nav_right_button(right)
        self.update()

    def set_nav_up_button(self, button):
        self._vertical_scroll.set_scroll_up_button(button)

    def set_nav_down_button(self, button):
        self._vertical_scroll.set_scroll_down_button(button)

    def set_nav_left_button(self, button):
        self._horizontal_scroll.set_scroll_up_button(button)

    def set_nav_right_button(self, button):
        self._horizontal_scroll.set_scroll_down_button(button)

    def set_scene_bank_buttons(self, buttons):
        if self._scene_bank_buttons != buttons:
            self._scene_bank_button_slots.disconnect()
            self._scene_bank_buttons = buttons
            if self._scene_bank_buttons != None:
                for button in self._scene_bank_buttons:
                    self._scene_bank_button_slots.register_slot(button, self._on_scene_bank_value, 'value', extra_kws=dict(identify_sender=True))

            self.update()

    def set_empty_value(self, value):
        value = int(value)
        raise in_range(value, 0, 128) or AssertionError
        self._empty_value = value

    def set_playing_value(self, value):
        value = int(value)
        raise in_range(value, 0, 128) or AssertionError
        self._playing_value = value

    def set_stopped_value(self, value):
        value = int(value)
        raise in_range(value, 0, 128) or AssertionError
        self._stopped_value = value

    def set_selected_value(self, value):
        value = int(value)
        raise in_range(value, 0, 128) or AssertionError
        self._selected_value = value

    def _session_set_enabled(self, is_enabled):
        """
        Override to customize behaviour when session is disabled.
        """
        self._session.set_enabled(is_enabled)

    def update(self):
        if self._allow_updates:
            self._session_set_enabled(not self._is_zoomed_out)
            if self.is_enabled():
                if self._is_zoomed_out and self._buttons != None:
                    tracks = self._session.tracks_to_use()
                    scenes = self.song().scenes
                    slots_registry = [ None for index in range(len(scenes)) ]
                    width = self._session.width()
                    height = self._session.height()
                    for x in range(self._buttons.width()):
                        for y in range(self._buttons.height()):
                            value_to_send = self._empty_value
                            scene_bank_offset = self._scene_bank_index * self._buttons.height() * height
                            track_offset = x * width
                            scene_offset = y * height + scene_bank_offset
                            if track_offset in range(len(tracks)) and scene_offset in range(len(scenes)):
                                value_to_send = self._stopped_value
                                if self._session.track_offset() in range(width * (x - 1) + 1, width * (x + 1)) and self._session.scene_offset() - scene_bank_offset in range(height * (y - 1) + 1, height * (y + 1)):
                                    value_to_send = self._selected_value
                                else:
                                    playing = False
                                    for track in range(track_offset, track_offset + width):
                                        for scene in range(scene_offset, scene_offset + height):
                                            if track in range(len(tracks)) and scene in range(len(scenes)):
                                                if slots_registry[scene] == None:
                                                    slots_registry[scene] = scenes[scene].clip_slots
                                                slot = slots_registry[scene][track] if len(slots_registry[scene]) > track else None
                                                if slot != None and slot.has_clip and slot.clip.is_playing:
                                                    value_to_send = self._playing_value
                                                    playing = True
                                                    break

                                        if playing:
                                            break

                            self._buttons.send_value(x, y, value_to_send)

                if self._scene_bank_buttons != None:
                    for index in range(len(self._scene_bank_buttons)):
                        if self._is_zoomed_out and index == self._scene_bank_index:
                            self._scene_bank_buttons[index].turn_on()
                        else:
                            self._scene_bank_buttons[index].turn_off()

        else:
            self._update_requests += 1

    def _on_session_offset_changes(self):
        if self._is_zoomed_out:
            self._scene_bank_index = int(self._session.scene_offset() / self._session.height() / self._buttons.height())
        self.update()

    @subject_slot('value')
    def _on_zoom_value(self, value):
        if self.is_enabled():
            if self._zoom_button.is_momentary():
                self._is_zoomed_out = value > 0
            else:
                self._is_zoomed_out = not self._is_zoomed_out
            if self._is_zoomed_out and self._buttons:
                self._scene_bank_index = int(self._session.scene_offset() / self._session.height() / self._buttons.height())
            else:
                self._scene_bank_index = 0
            self._session_set_enabled(not self._is_zoomed_out)
            self.update()

    @subject_slot('value')
    def _on_matrix_value(self, value, x, y, is_momentary):
        if self.is_enabled() and self._is_zoomed_out:
            if value != 0 or not is_momentary:
                track_offset = x * self._session.width()
                scene_offset = (y + self._scene_bank_index * self._buttons.height()) * self._session.height()
                if track_offset in range(len(self._session.tracks_to_use())) and scene_offset in range(len(self.song().scenes)):
                    self._session.set_offsets(track_offset, scene_offset)

    def _on_scene_bank_value(self, value, sender):
        if self.is_enabled() and self._is_zoomed_out:
            if value != 0 or not sender.is_momentary():
                button_offset = list(self._scene_bank_buttons).index(sender)
                scene_offset = button_offset * self._buttons.height() * self._session.height()
                if scene_offset in range(len(self.song().scenes)):
                    self._scene_bank_index = button_offset
                    self.update()

    def _can_scroll_up(self):
        return self._session._can_bank_up()

    def _can_scroll_down(self):
        return self._session._can_bank_down()

    def _can_scroll_left(self):
        return self._session._can_bank_left()

    def _can_scroll_right(self):
        return self._session._can_bank_right()

    def _scroll_up(self):
        if self._is_zoomed_out:
            height = self._session.height()
            track_offset = self._session.track_offset()
            scene_offset = self._session.scene_offset()
            if scene_offset > 0:
                new_scene_offset = scene_offset
                if scene_offset % height > 0:
                    new_scene_offset -= scene_offset % height
                else:
                    new_scene_offset = max(0, scene_offset - height)
                self._session.set_offsets(track_offset, new_scene_offset)

    def _scroll_down(self):
        if self._is_zoomed_out:
            height = self._session.height()
            track_offset = self._session.track_offset()
            scene_offset = self._session.scene_offset()
            new_scene_offset = scene_offset + height - scene_offset % height
            self._session.set_offsets(track_offset, new_scene_offset)

    def _scroll_left(self):
        if self._is_zoomed_out:
            width = self._session.width()
            track_offset = self._session.track_offset()
            scene_offset = self._session.scene_offset()
            if track_offset > 0:
                new_track_offset = track_offset
                if track_offset % width > 0:
                    new_track_offset -= track_offset % width
                else:
                    new_track_offset = max(0, track_offset - width)
                self._session.set_offsets(new_track_offset, scene_offset)

    def _scroll_right(self):
        if self._is_zoomed_out:
            width = self._session.width()
            track_offset = self._session.track_offset()
            scene_offset = self._session.scene_offset()
            new_track_offset = track_offset + width - track_offset % width
            self._session.set_offsets(new_track_offset, scene_offset)
########NEW FILE########
__FILENAME__ = Signal
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/Signal.py
from Util import find_if, nop
from functools import partial

def default_combiner(results):
    for _ in results:
        pass


class Slot(object):

    def __init__(self, callback = None, *a, **k):
        super(Slot, self).__init__(*a, **k)
        self.callback = callback

    def __call__(self, *a, **k):
        return self.callback(*a, **k)

    def __eq__(self, other):
        return id(self) == id(other) or self.callback == other


class IdentifyingSlot(Slot):

    def __init__(self, sender = None, *a, **k):
        super(IdentifyingSlot, self).__init__(*a, **k)
        self.sender = sender

    def __call__(self, *a, **k):
        self.callback(*(a + (self.sender,)), **k)


class Signal(object):
    """
    A signal object implements the observer pattern.  It can be
    connected to any number of slots (i.e. callbacks). Whenever the
    signal is called, all the slots are called.
    
    The return value of this function will depend on the combiner.
    The combiner takes a generator of slot results and returns a
    value.  The slots whose results are not evaluated are not called.
    """

    def __init__(self, combiner = default_combiner, sender = None, *a, **k):
        super(Signal, self).__init__(*a, **k)
        self._slots = []
        self._combiner = combiner

    def connect(self, slot, in_front = False, sender = None):
        """
        Connects the signal to the slot. Does nothing if the slot is
        already connected. Returns the wrapper object that is used as
        a slot.
        
        If 'in_front' is True, the slot will be put first, meaning it
        will be called before previously registered slots (by default
        it is put last).
        
        If 'sender' is not None, it will be passed as last ordinal
        parameter to the slot when the signal is dispatched.
        """
        if not callable(slot):
            raise AssertionError
            if slot not in self._slots:
                slot = IdentifyingSlot(sender, slot) if sender is not None else Slot(slot)
                in_front and self._slots.insert(0, slot)
            else:
                self._slots.append(slot)
        else:
            slot = find_if(lambda x: x == slot, self._slots)
        return slot

    def disconnect(self, slot):
        if slot in self._slots:
            self._slots.remove(slot)

    def disconnect_all(self):
        self._slots = []

    @property
    def count(self):
        return len(self._slots)

    def is_connected(self, slot):
        return slot in self._slots

    def __call__(self, *a, **k):
        return self._combiner(_slot_notification_generator(self._slots, a, k))


def _slot_notification_generator(slots, args, kws):
    for slot in slots:
        yield slot(*args, **kws)


def short_circuit_combiner(slot_results):
    return find_if(nop, slot_results)


short_circuit_signal = partial(Signal, short_circuit_combiner)
########NEW FILE########
__FILENAME__ = SliderElement
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/SliderElement.py
import Live
from EncoderElement import EncoderElement
from InputControlElement import MIDI_NOTE_TYPE

class SliderElement(EncoderElement):
    """ Class representing a slider on the controller """

    def __init__(self, msg_type, channel, identifier):
        raise msg_type is not MIDI_NOTE_TYPE or AssertionError
        EncoderElement.__init__(self, msg_type, channel, identifier, map_mode=Live.MidiMap.MapMode.absolute)
########NEW FILE########
__FILENAME__ = SubjectSlot
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/SubjectSlot.py
"""
Family of classes for maintaining connections with optional subjects.
"""
from itertools import izip, repeat
from functools import partial, wraps
from Signal import Signal
from Util import instance_decorator, monkeypatch, monkeypatch_extend, NamedTuple, mixin
from Disconnectable import Disconnectable, CompoundDisconnectable

class SubjectSlotError(Exception):
    pass


class SubjectEvent(NamedTuple):
    """
    Description of a subject event
    """
    name = None
    doc = ''
    signal = Signal
    override = False


def subject_add_event(cls, event_name_or_event):
    if isinstance(event_name_or_event, str):
        event = SubjectEvent(name=event_name_or_event)
    else:
        event = event_name_or_event
    raise callable(event.signal) or AssertionError
    signal_attr = '_' + event.name + '_signal'

    def get_signal(self):
        try:
            return getattr(self, signal_attr)
        except AttributeError:
            signal = event.signal(sender=self)
            setattr(self, signal_attr, signal)
            return signal

    kwargs = dict({'doc': event.doc,
     'override': event.override})

    @monkeypatch(cls, (event.name + '_has_listener'), **kwargs)
    def has_method(self, slot):
        return get_signal(self).is_connected(slot)

    @monkeypatch(cls, ('add_' + event.name + '_listener'), **kwargs)
    def add_method(self, slot, identify_sender = False, *a, **k):
        sender = self if identify_sender else None
        return get_signal(self).connect(slot, sender=sender, *a, **k)

    @monkeypatch(cls, ('remove_' + event.name + '_listener'), **kwargs)
    def remove_method(self, slot):
        return get_signal(self).disconnect(slot)

    @monkeypatch(cls, ('notify_' + event.name), **kwargs)
    def notify_method(self, *a, **k):
        return get_signal(self)(*a, **k)

    @monkeypatch(cls, ('clear_' + event.name + '_listeners'), **kwargs)
    def clear_method(self):
        return get_signal(self).disconnect_all()

    @monkeypatch(cls, (event.name + '_listener_count'), **kwargs)
    def listener_count_method(self):
        return get_signal(self).count

    @monkeypatch_extend(cls)
    def disconnect(self):
        get_signal(self).disconnect_all()


def setup_subject(cls, listeners):
    for lst in listeners:
        subject_add_event(cls, lst)


class SubjectMeta(type):

    def __new__(cls, name, bases, dct):
        events = dct.get('__subject_events__', [])
        if events and 'disconnect' not in dct:
            dct['disconnect'] = lambda self: super(cls, self).disconnect()
        cls = super(SubjectMeta, cls).__new__(cls, name, bases, dct)
        raise not events or hasattr(cls, 'disconnect') or AssertionError
        setup_subject(cls, events)
        return cls


class Subject(Disconnectable):
    """
    Base class that installs the SubjectMeta metaclass
    """
    __metaclass__ = SubjectMeta


class SlotManager(CompoundDisconnectable):
    """
    Holds references to a number of slots. Disconnecting it clears all
    of them and unregisters them from the system.
    """

    def register_slot(self, *a, **k):
        slot = a[0] if a and isinstance(a[0], SubjectSlot) else SubjectSlot(*a, **k)
        self.register_disconnectable(slot)
        return slot

    def register_slot_manager(self, *a, **k):
        manager = a[0] if a and isinstance(a[0], SlotManager) else SlotManager(*a, **k)
        self.register_disconnectable(manager)
        return manager


class SubjectSlot(Disconnectable):
    """
    This class maintains the relationship between a subject and a
    listener callback. As soon as both are non-null, it connects the
    listener the given 'event' of the subject and release the connection
    when any of them change.
    
    The finalizer of the object also cleans up both parameters and so
    does the __exit__ override, being able to use it as a context
    manager with the 'with' clause.
    
    Note that 'event' is a string with canonical identifier for the
    listener, i.e., the subject should provide the methods:
    
      add_[event]_listener
      remove_[event]_listener
      [event]_has_listener
    
    Note that the connection can already be made manually before the
    subject and listener are fed to the slot.
    """
    _extra_kws = {}
    _extra_args = []

    def __init__(self, subject = None, listener = None, event = None, extra_kws = None, extra_args = None, *a, **k):
        super(SubjectSlot, self).__init__(*a, **k)
        if not event:
            raise AssertionError
            self._event = event
            if extra_kws is not None:
                self._extra_kws = extra_kws
            self._extra_args = extra_args is not None and extra_args
        self._subject = None
        self._listener = None
        self.subject = subject
        self.listener = listener

    def disconnect(self):
        """
        Disconnects the slot clearing its members.
        """
        self.subject = None
        self.listener = None
        super(SubjectSlot, self).disconnect()

    def _check_subject_interface(self, subject):
        if not callable(getattr(subject, 'add_' + self._event + '_listener', None)):
            raise SubjectSlotError('Subject %s missing "add" method for event: %s' % (subject, self._event))
        if not callable(getattr(subject, 'remove_' + self._event + '_listener', None)):
            raise SubjectSlotError('Subject %s missing "remove" method for event: %s' % (subject, self._event))
        if not callable(getattr(subject, self._event + '_has_listener', None)):
            raise SubjectSlotError('Subject %s missing "has" method for event: %s' % (subject, self._event))

    def connect(self):
        if not self.is_connected and self._subject != None and self._listener != None:
            add_method = getattr(self._subject, 'add_' + self._event + '_listener')
            all_args = tuple(self._extra_args) + (self._listener,)
            try:
                add_method(*all_args, **self._extra_kws)
            except RuntimeError:
                pass

    def soft_disconnect(self):
        """
        Disconnects the listener from the subject keeping their
        values.
        """
        if self.is_connected and self._subject != None and self._listener != None:
            all_args = tuple(self._extra_args) + (self._listener,)
            remove_method = getattr(self._subject, 'remove_' + self._event + '_listener')
            try:
                remove_method(*all_args)
            except RuntimeError:
                pass

    @property
    def is_connected(self):
        all_args = tuple(self._extra_args) + (self._listener,)
        connected = False
        try:
            connected = bool(self._subject != None and self._listener != None and getattr(self._subject, self._event + '_has_listener')(*all_args))
        except RuntimeError:
            pass

        return connected

    def _get_subject(self):
        return self._subject

    def _set_subject(self, subject):
        if subject != self._subject:
            if subject != None:
                self._check_subject_interface(subject)
            self.soft_disconnect()
            self._subject = subject
            self.connect()

    subject = property(_get_subject, _set_subject)

    def _get_listener(self):
        return self._listener

    def _set_listener(self, listener):
        if listener != self._listener:
            self.soft_disconnect()
            self._listener = listener
            self.connect()

    listener = property(_get_listener, _set_listener)


class CallableSlotMixin(object):
    """
    Use this Mixin to turn subject-slot like interfaces into a
    'callable'.  The call operator will be forwarded to the
    subjectslot.
    """

    def __init__(self, function = None, *a, **k):
        super(CallableSlotMixin, self).__init__(*a, **k)
        self.function = function

    def __call__(self, *a, **k):
        return self.function(*a, **k)


class SubjectSlotGroup(SlotManager):
    """
    A subject slot that connects a given listener to many subjects.
    """
    listener = None
    _extra_kws = None
    _extra_args = None

    def __init__(self, listener = None, event = None, extra_kws = None, extra_args = None, *a, **k):
        super(SubjectSlotGroup, self).__init__(*a, **k)
        self.listener = listener
        self._event = event
        if listener is not None:
            self.listener = listener
        if extra_kws is not None:
            self._extra_kws = extra_kws
        if extra_args is not None:
            self._extra_args = extra_args

    def replace_subjects(self, subjects, identifiers = repeat(None)):
        self.disconnect()
        for subject, identifier in izip(subjects, identifiers):
            self.add_subject(subject, identifier=identifier)

    def add_subject(self, subject, identifier = None):
        if identifier is None:
            identifier = subject
        listener = self._listener_for_subject(identifier)
        self.register_slot(subject, listener, self._event, self._extra_kws, self._extra_args)

    def remove_subject(self, subject):
        slot = self.find_disconnectable(lambda x: x.subject == subject)
        self.disconnect_disconnectable(slot)

    def has_subject(self, subject):
        return self.find_disconnectable(lambda x: x.subject == subject) != None

    def _listener_for_subject(self, identifier):
        return lambda *a, **k: self.listener and self.listener(*(a + (identifier,)), **k)


class MultiSubjectSlot(SlotManager, SubjectSlot):
    """
    A subject slot that takes a string describing the path to the event to listen to.
    It will make sure that any changes to the elements of this path notify the given
    listener and will follow the changing subjects.
    """

    def __init__(self, subject = None, listener = None, event = None, extra_kws = None, extra_args = None, *a, **k):
        self._original_listener = listener
        self._slot_subject = None
        self._nested_slot = None
        super(MultiSubjectSlot, self).__init__(event=event[0], listener=self._event_fired, subject=subject, extra_kws=extra_kws, extra_args=extra_args)
        if len(event) > 1:
            self._nested_slot = self.register_disconnectable(MultiSubjectSlot(event=event[1:], listener=listener, subject=subject, extra_kws=extra_kws, extra_args=extra_args))
            self._update_nested_subject()

    def _get_subject(self):
        return super(MultiSubjectSlot, self)._get_subject()

    def _set_subject(self, subject):
        try:
            super(MultiSubjectSlot, self)._set_subject(subject)
        except SubjectSlotError:
            if self._nested_slot == None:
                raise 
        finally:
            self._slot_subject = subject
            self._update_nested_subject()

    subject = property(_get_subject, _set_subject)

    def _event_fired(self, *a, **k):
        self._update_nested_subject()
        self._original_listener(*a, **k)

    def _update_nested_subject(self):
        if self._nested_slot != None:
            self._nested_slot.subject = getattr(self._slot_subject, self._event) if self._slot_subject != None else None


def subject_slot(events, *a, **k):

    @instance_decorator
    def decorator(self, method):
        raise isinstance(self, SlotManager) or AssertionError
        function = partial(method, self)
        event_list = events.split('.')
        num_events = len(event_list)
        event = event_list if num_events > 1 else events
        base_class = MultiSubjectSlot if num_events > 1 else SubjectSlot
        slot = wraps(method)(mixin(base_class, CallableSlotMixin)(event=event, extra_kws=k, extra_args=a, listener=function, function=function))
        self.register_slot(slot)
        return slot

    return decorator


class CallableSubjectSlotGroup(SubjectSlotGroup, CallableSlotMixin):
    pass


def subject_slot_group(event, *a, **k):

    @instance_decorator
    def decorator(self, method):
        raise isinstance(self, SlotManager) or AssertionError
        function = partial(method, self)
        slot = wraps(method)(CallableSubjectSlotGroup(event=event, extra_kws=k, extra_args=a, listener=function, function=function))
        self.register_slot_manager(slot)
        return slot

    return decorator
########NEW FILE########
__FILENAME__ = SwitchModeSelectorComponent
#Embedded file name: /Users/versonator/Hudson/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/SwitchModeSelectorComponent.py
from ModeSelectorComponent import ModeSelectorComponent
from ControlSurfaceComponent import ControlSurfaceComponent
from ButtonElement import ButtonElement

class SwitchModeSelectorComponent(ModeSelectorComponent):
    """ Class that handles modes by enabling and disabling components """

    def __init__(self):
        ModeSelectorComponent.__init__(self)
        self._components_per_mode = []

    def disconnect(self):
        ModeSelectorComponent.disconnect(self)
        self._components_per_mode = None

    def add_mode(self, components, button):
        if not components != None:
            raise AssertionError
            if not isinstance(components, tuple):
                raise AssertionError
                raise button == None or isinstance(button, ButtonElement) or AssertionError
                self._mode_index = len(self._modes_buttons) == 0 and 0
            for component in components:
                raise isinstance(component, ControlSurfaceComponent) or AssertionError

            identify_sender = button != None and True
            button.add_value_listener(self._mode_value, identify_sender)
            self._modes_buttons.append(button)
        self._components_per_mode.append(components)
        self.update()

    def number_of_modes(self):
        return len(self._components_per_mode)

    def update(self):
        if not (len(self._modes_buttons) == 0 or len(self._modes_buttons) == len(self._components_per_mode)):
            raise AssertionError
            if not len(self._components_per_mode) > self._mode_index:
                raise AssertionError
                index = 0
                active_components = None
                active_components = self.is_enabled() and self._components_per_mode[self._mode_index]
            for index in range(len(self._components_per_mode)):
                if self._components_per_mode[index] != active_components:
                    if len(self._modes_buttons) == len(self._components_per_mode):
                        self._modes_buttons[index].turn_off()
                    for component in self._components_per_mode[index]:
                        component.set_enabled(False)

            if active_components != None:
                for component in active_components:
                    component.set_enabled(True)

                len(self._modes_buttons) == len(self._components_per_mode) and self._modes_buttons[self._mode_index].turn_on()
########NEW FILE########
__FILENAME__ = SysexValueControl
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/SysexValueControl.py
from _Framework.InputControlElement import InputControlElement, MIDI_SYSEX_TYPE

class SysexValueControl(InputControlElement):
    """
    Sysex value control receives a sysex message, identified by a
    prefix.  The value can be requested with a value_enquiry MIDI
    message to the controller.
    """

    def __init__(self, message_prefix = None, value_enquiry = None, default_value = None, *a, **k):
        super(SysexValueControl, self).__init__(msg_type=MIDI_SYSEX_TYPE, sysex_identifier=message_prefix, *a, **k)
        self._value_enquiry = value_enquiry
        self._default_value = default_value

    def send_value(self, value_bytes):
        self.send_midi(self.message_sysex_identifier() + value_bytes + (247,))

    def enquire_value(self):
        raise self._value_enquiry != None or AssertionError
        self.send_midi(self._value_enquiry)

    def reset(self):
        if self._default_value != None:
            self.send_value(self._default_value)
########NEW FILE########
__FILENAME__ = Task
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/Task.py
"""
Task management.
"""
import functools
from Dependency import depends
from Util import remove_if, find_if, linear as linear_fn, print_message, const
import traceback

class TaskError(Exception):
    pass


KILLED = 0
RUNNING = 1
PAUSED = 2

class Task(object):

    def __init__(self, *a, **k):
        super(Task, self).__init__(*a, **k)
        self._state = RUNNING
        self._next = []
        self._task_manager = None

    def clear(self):
        pass

    def do_update(self, timer):
        pass

    def do_restart(self):
        pass

    def add_next(self, task):
        self._next.append(task)
        return task

    def update(self, timer):
        if self._state == RUNNING:
            self.do_update(timer)
        return self._state

    def pause(self):
        if self._state != KILLED:
            self._state = PAUSED
        return self

    def resume(self):
        if self._state != KILLED:
            self._state = RUNNING
        return self

    def toggle_pause(self):
        if self._state != KILLED:
            self._state = RUNNING if self._state == PAUSED else PAUSED
        return self

    def restart(self):
        self.do_restart()
        self._state = RUNNING
        if self._task_manager and self._task_manager.find(self) == None:
            manager = self._task_manager
            self._task_manager = None
            manager.add(self)
        return self

    def kill(self):
        self._state = KILLED
        if self._task_manager:
            for task in self._next:
                self._task_manager.add(task)

        return self

    @property
    def is_running(self):
        return self._state == RUNNING

    @property
    def is_paused(self):
        return self._state == PAUSED

    @property
    def is_killed(self):
        return self._state == KILLED

    @property
    def state(self):
        return self._state

    @property
    def parent_task(self):
        return self._task_manager

    def _set_parent(self, manager):
        if self._task_manager and manager:
            raise TaskError('Already attached to: ' + str(self._task_manager))
        self._task_manager = manager

    def _task_equivalent(self, other):
        return self == other


class WrapperTask(Task):

    def __init__(self, wrapped_task = None, *a, **k):
        super(WrapperTask, self).__init__(*a, **k)
        self.wrapped_task = wrapped_task

    def update(self, delta):
        super(WrapperTask, self).update(delta)
        self.wrapped_task.update(delta)

    def _set_parent(self, manager):
        super(WrapperTask, self)._set_parent(manager)
        self.wrapped_task._set_parent(manager)

    def _task_equivalent(self, other):
        return self.wrapped_task._task_equivalent(other)


class FuncTask(Task):

    def __init__(self, func = None, equivalent = None, *a, **k):
        raise func != None or AssertionError
        super(FuncTask, self).__init__(*a, **k)
        self._func = func
        self._equivalent = equivalent

    def _set_func(self, func):
        self._func = func

    def _get_func(self):
        return self._orig

    def do_update(self, timer):
        super(FuncTask, self).do_update(timer)
        action = self._func(timer)
        if not action or action == KILLED:
            self.kill()
        elif action == PAUSED:
            self.pause()

    def _task_equivalent(self, other):
        return self == other or self._func == other or self._equivalent == other

    func = property(_get_func, _set_func)


class GeneratorTask(Task):

    class Param(object):
        delta = 0

    def __init__(self, generator = None, equivalent = None, *a, **k):
        raise generator != None and callable(generator) or AssertionError
        super(GeneratorTask, self).__init__(*a, **k)
        self._param = GeneratorTask.Param()
        self._set_generator(generator)
        self._equivalent = equivalent

    def _set_generator(self, generator):
        self._orig = generator
        self._iter = generator(self._param)

    def _get_generator(self):
        return self._orig

    def do_update(self, delta):
        super(GeneratorTask, self).do_update(delta)
        self._param.delta = delta
        try:
            action = self._iter.next()
        except StopIteration:
            action = KILLED

        if not action or action == KILLED:
            self.kill()
        elif action == PAUSED:
            self.pause()

    def _task_equivalent(self, other):
        return self == other or self._orig == other or self._equivalent == other

    generator = property(_get_generator, _set_generator)


class TaskGroup(Task):
    auto_kill = True
    auto_remove = True
    loop = False

    def __init__(self, tasks = [], auto_kill = None, auto_remove = None, loop = None, *a, **k):
        super(TaskGroup, self).__init__(*a, **k)
        if auto_kill is not None:
            self.auto_kill = auto_kill
        if auto_remove is not None:
            self.auto_remove = auto_remove
        if loop is not None:
            self.loop = loop
        self._tasks = []
        for task in tasks:
            self.add(task)

    def clear(self):
        for t in self._tasks:
            t._set_parent(None)

        self._tasks = []
        super(TaskGroup, self).clear()

    @depends(log_message=const(print_message), traceback=const(traceback))
    def do_update(self, timer, log_message = None, traceback = None):
        super(TaskGroup, self).do_update(timer)
        for task in self._tasks:
            if not task.is_killed:
                try:
                    task.update(timer)
                except Exception:
                    task.kill()
                    log_message('Error when executing task')
                    traceback.print_exc()

        if self.auto_remove:
            self._tasks = remove_if(lambda t: t.is_killed, self._tasks)
        all_killed = len(filter(lambda t: t.is_killed, self._tasks)) == self.count
        if self.auto_kill and all_killed:
            self.kill()
        elif self.loop and all_killed:
            self.restart()

    def add(self, task):
        task = totask(task)
        task._set_parent(self)
        self._tasks.append(task)
        if self.is_killed:
            super(TaskGroup, self).restart()
        return task

    def remove(self, task):
        self._tasks.remove(task)
        task._set_parent(None)

    def find(self, task):
        return find_if(lambda t: t._task_equivalent(task), self._tasks)

    def restart(self):
        super(TaskGroup, self).restart()
        for x in self._tasks:
            x.restart()

    @property
    def count(self):
        return len(self._tasks)


class WaitTask(Task):
    duration = 1.0

    def __init__(self, duration = None, *a, **k):
        super(WaitTask, self).__init__(*a, **k)
        if duration is not None:
            self.duration = duration
        self.remaining = self.duration

    def do_update(self, delta):
        super(WaitTask, self).do_update(delta)
        self.remaining -= delta
        if self.remaining <= 0:
            self.kill()
            self.remaining = 0

    def do_restart(self):
        self.remaining = self.duration


class DelayTask(Task):
    duration = 1

    def __init__(self, duration = None, *a, **k):
        super(DelayTask, self).__init__(*a, **k)
        if duration is not None:
            self.duration = duration
        self.remaining = self.duration

    def do_restart(self):
        self.remaining = self.duration

    def do_update(self, delta):
        super(DelayTask, self).do_update(delta)
        self.remaining -= 1
        if self.remaining <= 0:
            self.kill()
            self.remaining = 0


class TimerTask(WaitTask):

    def do_update(self, timer):
        super(TimerTask, self).do_update(timer)
        if self.remaining == 0:
            self.on_finish()
        else:
            self.on_tick()

    def on_tick(self):
        pass

    def on_finish(self):
        pass


class FadeTask(Task):

    def __init__(self, func = lambda x: x, duration = 1.0, loop = False, init = False, *a, **k):
        super(FadeTask, self).__init__(*a, **k)
        self.func = func
        self.curr = 0.0
        self.loop = loop
        self.duration = duration
        if init:
            func(0.0)

    def do_update(self, delta):
        super(FadeTask, self).do_update(delta)
        self.func(self.curr / self.duration)
        self.curr += delta
        if self.curr >= self.duration:
            if self.loop:
                self.curr -= self.duration
            else:
                self.curr = self.duration
                self.kill()
                self.func(self.curr / self.duration)

    def do_restart(self):
        super(FadeTask, self).do_restart()
        self.curr = 0.0


class SequenceTask(Task):

    def __init__(self, tasks = [], *a, **k):
        super(SequenceTask, self).__init__(*a, **k)
        self._tasks = tasks
        self._iter = iter(tasks)
        self._current = None
        self._advance_sequence()

    def _advance_sequence(self):
        try:
            self._current = self._iter.next()
        except StopIteration:
            self.kill()

    def do_update(self, delta):
        super(SequenceTask, self).do_update(delta)
        if self._current is not None:
            self._current.update(delta)
            if self._current.is_killed:
                self._advance_sequence()

    def do_restart(self):
        for x in self._tasks:
            x.restart()

        self._iter = iter(self._tasks)
        self._advance_sequence()


def totask(task):
    if not isinstance(task, Task):
        if not callable(task):
            raise TaskError('You can add either tasks or callables. ' + str(task))
        task = FuncTask(func=task)
    return task


def generator(orig):
    equiv = [None]

    @functools.wraps(orig)
    def wrapper():
        return GeneratorTask(orig, equiv[0])

    equiv[0] = wrapper
    return wrapper


def sequence(*tasks):
    return SequenceTask(map(totask, tasks))


def parallel(*tasks):
    return TaskGroup(tasks=tasks, auto_remove=False)


def loop(*tasks):
    return TaskGroup(tasks=tasks, auto_remove=False, auto_kill=False, loop=True)


wait = WaitTask
fade = FadeTask
delay = DelayTask

def invfade(f, *a, **k):
    return fade((lambda x: f(1.0 - x)), *a, **k)


def linear(f, min, max, *a, **k):
    return fade((lambda x: f(linear_fn(min, max, x))), *a, **k)


try:
    import math

    def sinusoid(f, min = 0.0, max = 1.0, *a, **k):
        return fade((lambda x: f(min + (max - min) * math.sin(x * math.pi / 2.0))), *a, **k)


except ImportError as err:
    pass

def run(func, *a, **k):
    return FuncTask(lambda t: None if func(*a, **k) else None)


def repeat(task):
    task = totask(task)
    task.kill = task.restart
    return WrapperTask(task)
########NEW FILE########
__FILENAME__ = ToggleComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/ToggleComponent.py
from SubjectSlot import subject_slot
from ControlSurfaceComponent import ControlSurfaceComponent

class ToggleComponent(ControlSurfaceComponent):
    """
    Maps a toggle button to a boolean property of the Live model.
    """
    is_private = True
    is_momentary = False
    read_only = False

    def __init__(self, property_name = None, subject = None, is_momentary = False, model_transform = None, view_transform = None, read_only = False, *a, **k):
        if not property_name:
            raise AssertionError
            super(ToggleComponent, self).__init__(*a, **k)
            self._property_name = property_name
            self._property_slot = self.register_slot(subject, self._on_property_changed_in_model, property_name)
            self._property_button = None
            if is_momentary:
                self.is_momentary = is_momentary
            if model_transform:
                self.model_transform = model_transform
            if view_transform:
                self.view_transform = model_transform
            self.read_only = read_only and read_only

    def model_transform(self, value):
        return value

    def view_transform(self, value):
        return value

    def _get_subject(self):
        return self._property_slot.subject

    def _set_subject(self, model):
        self._property_slot.subject = model
        self.update()

    subject = property(_get_subject, _set_subject)

    def _get_value(self):
        return getattr(self.subject, self._property_name) if self.subject else None

    def _set_value(self, value):
        setattr(self.subject, self._property_name, value)

    value = property(_get_value, _set_value)

    def set_toggle_button(self, button):
        raise button is None or not self.is_momentary or button.is_momentary() or AssertionError
        self._on_button_value.subject = button
        self._update_button()

    def on_enabled_changed(self):
        self.update()

    def update(self):
        self._update_button()

    def _update_button(self):
        if self.is_enabled():
            button = self._on_button_value.subject
            if button:
                button.set_light(self.view_transform(self.value))

    def _on_property_changed_in_model(self):
        self._update_button()

    @subject_slot('value')
    def _on_button_value(self, value):
        if self.is_enabled() and not self.read_only:
            if self.is_momentary:
                if value:
                    self.value = self.model_transform(True)
                else:
                    self.value = self.model_transform(False)
            elif value:
                self.value = self.model_transform(not self.value)
########NEW FILE########
__FILENAME__ = TrackArmState
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/TrackArmState.py
from SubjectSlot import Subject, subject_slot, SlotManager

class TrackArmState(Subject, SlotManager):
    __subject_events__ = ('arm',)

    def __init__(self, track = None, *a, **k):
        super(TrackArmState, self).__init__(*a, **k)
        self.set_track(track)

    def set_track(self, track):
        self._track = track
        self._arm = track and track.can_be_armed and (track.arm or track.implicit_arm)
        subject = track if track and track.can_be_armed else None
        self._on_explicit_arm_changed.subject = subject
        self._on_implicit_arm_changed.subject = subject

    @subject_slot('arm')
    def _on_explicit_arm_changed(self):
        self._on_arm_changed()

    @subject_slot('implicit_arm')
    def _on_implicit_arm_changed(self):
        self._on_arm_changed()

    def _on_arm_changed(self):
        if not self._track.arm:
            new_state = self._track.implicit_arm
            self._arm = self._arm != new_state and new_state
            self.notify_arm()

    def _get_arm(self):
        return self._arm if self._track.can_be_armed else False

    def _set_arm(self, new_state):
        if self._track.can_be_armed:
            self._track.arm = new_state
            if not new_state:
                self._track.implicit_arm = False
        self._arm = new_state

    arm = property(_get_arm, _set_arm)
########NEW FILE########
__FILENAME__ = TrackEQComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/TrackEQComponent.py
import Live
from ControlSurfaceComponent import ControlSurfaceComponent
from EncoderElement import EncoderElement
from _Generic.Devices import get_parameter_by_name
EQ_DEVICES = {'Eq8': {'Gains': [ '%i Gain A' % (index + 1) for index in range(8) ]},
 'FilterEQ3': {'Gains': ['GainLo', 'GainMid', 'GainHi'],
               'Cuts': ['LowOn', 'MidOn', 'HighOn']}}

class TrackEQComponent(ControlSurfaceComponent):
    """ Class representing a track's EQ, it attaches to the last EQ device in the track """

    def __init__(self):
        ControlSurfaceComponent.__init__(self)
        self._track = None
        self._device = None
        self._gain_controls = None
        self._cut_buttons = None

    def disconnect(self):
        if self._gain_controls != None:
            for control in self._gain_controls:
                control.release_parameter()

            self._gain_controls = None
        if self._cut_buttons != None:
            for button in self._cut_buttons:
                button.remove_value_listener(self._cut_value)

        self._cut_buttons = None
        if self._track != None:
            self._track.remove_devices_listener(self._on_devices_changed)
            self._track = None
        self._device = None
        if self._device != None:
            device_dict = EQ_DEVICES[self._device.class_name]
            if 'Cuts' in device_dict.keys():
                cut_names = device_dict['Cuts']
                for cut_name in cut_names:
                    parameter = get_parameter_by_name(self._device, cut_name)
                    if parameter != None and parameter.value_has_listener(self._on_cut_changed):
                        parameter.remove_value_listener(self._on_cut_changed)

    def on_enabled_changed(self):
        self.update()

    def set_track(self, track):
        if not (track == None or isinstance(track, Live.Track.Track)):
            raise AssertionError
            if self._track != None:
                self._track.remove_devices_listener(self._on_devices_changed)
                if self._gain_controls != None and self._device != None:
                    for control in self._gain_controls:
                        control.release_parameter()

            self._track = track
            self._track != None and self._track.add_devices_listener(self._on_devices_changed)
        self._on_devices_changed()

    def set_cut_buttons(self, buttons):
        if not (buttons == None or isinstance(buttons, tuple)):
            raise AssertionError
            if buttons != self._cut_buttons and self._cut_buttons != None:
                for button in self._cut_buttons:
                    button.remove_value_listener(self._cut_value)

            self._cut_buttons = buttons
            if self._cut_buttons != None:
                for button in self._cut_buttons:
                    button.add_value_listener(self._cut_value, identify_sender=True)

            self.update()

    def set_gain_controls(self, controls):
        raise controls != None or AssertionError
        raise isinstance(controls, tuple) or AssertionError
        if self._device != None and self._gain_controls != None:
            for control in self._gain_controls:
                control.release_parameter()

        for control in controls:
            raise control != None or AssertionError
            raise isinstance(control, EncoderElement) or AssertionError

        self._gain_controls = controls
        self.update()

    def update(self):
        if self.is_enabled() and self._device != None:
            device_dict = EQ_DEVICES[self._device.class_name]
            if self._gain_controls != None:
                gain_names = device_dict['Gains']
                for index in range(len(self._gain_controls)):
                    self._gain_controls[index].release_parameter()
                    if len(gain_names) > index:
                        parameter = get_parameter_by_name(self._device, gain_names[index])
                        if parameter != None:
                            self._gain_controls[index].connect_to(parameter)

            if self._cut_buttons != None and 'Cuts' in device_dict.keys():
                cut_names = device_dict['Cuts']
                for index in range(len(self._cut_buttons)):
                    self._cut_buttons[index].turn_off()
                    if len(cut_names) > index:
                        parameter = get_parameter_by_name(self._device, cut_names[index])
                        if parameter != None:
                            if parameter.value == 0.0:
                                self._cut_buttons[index].turn_on()
                            if not parameter.value_has_listener(self._on_cut_changed):
                                parameter.add_value_listener(self._on_cut_changed)

        else:
            if self._cut_buttons != None:
                for button in self._cut_buttons:
                    if button != None:
                        button.turn_off()

            if self._gain_controls != None:
                for control in self._gain_controls:
                    control.release_parameter()

    def _cut_value(self, value, sender):
        if not sender in self._cut_buttons:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self.is_enabled() and self._device != None:
                    if not sender.is_momentary() or value is not 0:
                        device_dict = EQ_DEVICES[self._device.class_name]
                        if 'Cuts' in device_dict.keys():
                            cut_names = device_dict['Cuts']
                            index = list(self._cut_buttons).index(sender)
                            parameter = index in range(len(cut_names)) and get_parameter_by_name(self._device, cut_names[index])
                            parameter.value = parameter != None and parameter.is_enabled and float(int(parameter.value + 1) % 2)

    def _on_devices_changed(self):
        if self._device != None:
            device_dict = EQ_DEVICES[self._device.class_name]
            if 'Cuts' in device_dict.keys():
                cut_names = device_dict['Cuts']
                for cut_name in cut_names:
                    parameter = get_parameter_by_name(self._device, cut_name)
                    if parameter != None and parameter.value_has_listener(self._on_cut_changed):
                        parameter.remove_value_listener(self._on_cut_changed)

        self._device = None
        if self._track != None:
            for index in range(len(self._track.devices)):
                device = self._track.devices[-1 * (index + 1)]
                if device.class_name in EQ_DEVICES.keys():
                    self._device = device
                    break

        self.update()

    def _on_cut_changed(self):
        if not self._device != None:
            raise AssertionError
            raise 'Cuts' in EQ_DEVICES[self._device.class_name].keys() or AssertionError
            cut_names = self.is_enabled() and self._cut_buttons != None and EQ_DEVICES[self._device.class_name]['Cuts']
            for index in range(len(self._cut_buttons)):
                self._cut_buttons[index].turn_off()
                if len(cut_names) > index:
                    parameter = get_parameter_by_name(self._device, cut_names[index])
                    if parameter != None and parameter.value == 0.0:
                        self._cut_buttons[index].turn_on()
########NEW FILE########
__FILENAME__ = TrackFilterComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/TrackFilterComponent.py
import Live
from ControlSurfaceComponent import ControlSurfaceComponent
from EncoderElement import EncoderElement
from _Generic.Devices import get_parameter_by_name
FILTER_DEVICES = {'AutoFilter': {'Frequency': 'Frequency',
                'Resonance': 'Resonance'},
 'Operator': {'Frequency': 'Filter Freq',
              'Resonance': 'Filter Res'},
 'OriginalSimpler': {'Frequency': 'Filter Freq',
                     'Resonance': 'Filter Res'},
 'MultiSampler': {'Frequency': 'Filter Freq',
                  'Resonance': 'Filter Res'},
 'UltraAnalog': {'Frequency': 'F1 Freq',
                 'Resonance': 'F1 Resonance'},
 'StringStudio': {'Frequency': 'Filter Freq',
                  'Resonance': 'Filter Reso'}}

class TrackFilterComponent(ControlSurfaceComponent):
    """ Class representing a track's filter, attaches to the last filter in the track """

    def __init__(self):
        ControlSurfaceComponent.__init__(self)
        self._track = None
        self._device = None
        self._freq_control = None
        self._reso_control = None

    def disconnect(self):
        if self._freq_control != None:
            self._freq_control.release_parameter()
            self._freq_control = None
        if self._reso_control != None:
            self._reso_control.release_parameter()
            self._reso_control = None
        if self._track != None:
            self._track.remove_devices_listener(self._on_devices_changed)
            self._track = None
        self._device = None

    def on_enabled_changed(self):
        self.update()

    def set_track(self, track):
        if not (track == None or isinstance(track, Live.Track.Track)):
            raise AssertionError
            if self._track != None:
                self._track.remove_devices_listener(self._on_devices_changed)
                if self._device != None:
                    if self._freq_control != None:
                        self._freq_control.release_parameter()
                    if self._reso_control != None:
                        self._reso_control.release_parameter()
            self._track = track
            self._track != None and self._track.add_devices_listener(self._on_devices_changed)
        self._on_devices_changed()

    def set_filter_controls(self, freq, reso):
        if not isinstance(freq, EncoderElement):
            raise AssertionError
            if not isinstance(freq, EncoderElement):
                raise AssertionError
                if self._device != None:
                    self._freq_control != None and self._freq_control.release_parameter()
                self._reso_control != None and self._reso_control.release_parameter()
        self._freq_control = freq
        self._reso_control = reso
        self.update()

    def update(self):
        if self.is_enabled() and self._device != None:
            device_dict = FILTER_DEVICES[self._device.class_name]
            if self._freq_control != None:
                self._freq_control.release_parameter()
                parameter = get_parameter_by_name(self._device, device_dict['Frequency'])
                if parameter != None:
                    self._freq_control.connect_to(parameter)
            if self._reso_control != None:
                self._reso_control.release_parameter()
                parameter = get_parameter_by_name(self._device, device_dict['Resonance'])
                if parameter != None:
                    self._reso_control.connect_to(parameter)

    def _on_devices_changed(self):
        self._device = None
        if self._track != None:
            for index in range(len(self._track.devices)):
                device = self._track.devices[-1 * (index + 1)]
                if device.class_name in FILTER_DEVICES.keys():
                    self._device = device
                    break

        self.update()
########NEW FILE########
__FILENAME__ = TransportComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/TransportComponent.py
import Live
from functools import partial
from CompoundComponent import CompoundComponent
from ToggleComponent import ToggleComponent
from Util import const, in_range, clamp
from SubjectSlot import subject_slot
import Task
TEMPO_TOP = 200.0
TEMPO_BOTTOM = 60.0
TEMPO_FINE_RANGE = 2.56
SEEK_SPEED = 10.0

class TransportComponent(CompoundComponent):
    """
    Class encapsulating all functions in Live's transport section.
    """

    def __init__(self, *a, **k):
        super(TransportComponent, self).__init__(*a, **k)
        self._ffwd_button = None
        self._rwd_button = None
        self._tap_tempo_button = None
        self._tempo_control = None
        self._tempo_fine_control = None
        self._song_position_control = None
        self._rwd_task = Task.Task()
        self._ffwd_task = Task.Task()
        self._fine_tempo_needs_pickup = True
        self._prior_fine_tempo_value = -1
        self._end_undo_step_task = self._tasks.add(Task.sequence(Task.wait(1.5), Task.run(self.song().end_undo_step)))
        self._end_undo_step_task.kill()
        song = self.song()
        self._loop_toggle, self._punch_in_toggle, self._punch_out_toggle, self._record_toggle, self._play_toggle, self._stop_toggle, self._nudge_down_toggle, self._nudge_up_toggle, self._metronome_toggle, self._session_record_toggle, self.arrangement_overdub_toggle, self._overdub_toggle = self.register_components(ToggleComponent('loop', song), ToggleComponent('punch_in', song, is_momentary=True), ToggleComponent('punch_out', song, is_momentary=True), ToggleComponent('record_mode', song), ToggleComponent('is_playing', song, model_transform=const(True)), ToggleComponent('is_playing', song, model_transform=const(False), view_transform=const(False)), ToggleComponent('nudge_down', song, is_momentary=True), ToggleComponent('nudge_up', song, is_momentary=True), ToggleComponent('metronome', song), ToggleComponent('session_record', song), ToggleComponent('arrangement_overdub', song), ToggleComponent('overdub', song))

    def set_stop_button(self, button):
        self._stop_toggle.set_toggle_button(button)

    def set_play_button(self, button):
        self._play_toggle.set_toggle_button(button)

    def set_seek_buttons(self, ffwd_button, rwd_button):
        if self._ffwd_button != ffwd_button:
            self._ffwd_button = ffwd_button
            self._ffwd_value_slot.subject = ffwd_button
            self._ffwd_task.kill()
        if self._rwd_button != rwd_button:
            self._rwd_button = rwd_button
            self._rwd_value_slot.subject = rwd_button
            self._rwd_task.kill()

    def set_seek_forward_button(self, ffwd_button):
        if self._ffwd_button != ffwd_button:
            self._ffwd_button = ffwd_button
            self._ffwd_value_slot.subject = ffwd_button
            self._ffwd_task.kill()

    def set_seek_backward_button(self, rwd_button):
        if self._rwd_button != rwd_button:
            self._rwd_button = rwd_button
            self._rwd_value_slot.subject = rwd_button
            self._rwd_task.kill()

    def set_nudge_buttons(self, up_button, down_button):
        self._nudge_up_toggle.set_toggle_button(up_button)
        self._nudge_down_toggle.set_toggle_button(down_button)

    def set_nudge_up_button(self, up_button):
        self._nudge_up_toggle.set_toggle_button(up_button)

    def set_nudge_down_button(self, down_button):
        self._nudge_down_toggle.set_toggle_button(down_button)

    def set_record_button(self, button):
        self._record_toggle.set_toggle_button(button)

    def set_tap_tempo_button(self, button):
        if self._tap_tempo_button != button:
            self._tap_tempo_button = button
            self._tap_tempo_value.subject = button
            self._update_tap_tempo_button()

    def set_loop_button(self, button):
        self._loop_toggle.set_toggle_button(button)

    def set_punch_buttons(self, in_button, out_button):
        self._punch_in_toggle.set_toggle_button(in_button)
        self._punch_out_toggle.set_toggle_button(out_button)

    def set_punch_in_button(self, in_button):
        self._punch_in_toggle.set_toggle_button(in_button)

    def set_punch_out_button(self, out_button):
        self._punch_out_toggle.set_toggle_button(out_button)

    def set_metronome_button(self, button):
        self._metronome_toggle.set_toggle_button(button)

    def set_session_overdub_button(self, button):
        self._session_overdub_toggle.set_toggle_button(button)

    def set_arrangement_overdub_button(self, button):
        self._arrangement_overdub_toggle.set_toggle_button(button)

    def set_overdub_button(self, button):
        self._overdub_toggle.set_toggle_button(button)

    def set_tempo_control(self, control, fine_control = None):
        if not (not control or control.message_map_mode() is Live.MidiMap.MapMode.absolute):
            raise AssertionError
            if not (not fine_control or fine_control.message_map_mode() is Live.MidiMap.MapMode.absolute):
                raise AssertionError
                self._tempo_control = self._tempo_control != control and control
                self._tempo_value.subject = control
            self._tempo_fine_control = self._tempo_fine_control != fine_control and fine_control
            self._tempo_fine_value.subject = fine_control
            self._fine_tempo_needs_pickup = True
            self._prior_fine_tempo_value = -1

    def set_tempo_fine_control(self, fine_control):
        if not (not fine_control or fine_control.message_map_mode() is Live.MidiMap.MapMode.absolute):
            raise AssertionError
            self._tempo_fine_control = self._tempo_fine_control != fine_control and fine_control
            self._tempo_fine_value.subject = fine_control
            self._fine_tempo_needs_pickup = True
            self._prior_fine_tempo_value = -1

    def set_song_position_control(self, control):
        if self._song_position_control != control:
            self._song_position_control = control
            self._song_position_value.subject = control

    def update(self):
        if self.is_enabled():
            self._update_tap_tempo_button()

    @subject_slot('value')
    def _ffwd_value_slot(self, value):
        self._ffwd_value(value)

    def _ffwd_value(self, value):
        if self._ffwd_button.is_momentary():
            self._ffwd_task.kill()
            if value:
                self._ffwd_task = self._tasks.add(partial(self._move_current_song_time, SEEK_SPEED))
        elif self.is_enabled():
            self.song().current_song_time += 1

    @subject_slot('value')
    def _rwd_value_slot(self, value):
        self._rwd_value(value)

    def _rwd_value(self, value):
        if self._rwd_button.is_momentary():
            self._rwd_task.kill()
            if value:
                self._rwd_task = self._tasks.add(partial(self._move_current_song_time, -SEEK_SPEED))
        elif self.is_enabled():
            song = self.song()
            song.current_song_time = max(0.0, song.current_song_time - 1)

    def _move_current_song_time(self, speed, delta):
        song = self.song()
        song.current_song_time = max(0.0, song.current_song_time + speed * delta)
        return Task.RUNNING

    @subject_slot('value')
    def _tap_tempo_value(self, value):
        if self.is_enabled():
            if value or not self._tap_tempo_button.is_momentary():
                if not self._end_undo_step_task.is_running:
                    self.song().begin_undo_step()
                self._end_undo_step_task.restart()
                self.song().tap_tempo()
            self._update_tap_tempo_button()

    def _update_tap_tempo_button(self):
        if self.is_enabled() and self._tap_tempo_button:
            self._tap_tempo_button.set_light(self._tap_tempo_button.is_pressed())

    @subject_slot('value')
    def _tempo_value(self, value):
        if self.is_enabled():
            fraction = (TEMPO_TOP - TEMPO_BOTTOM) / 127.0
            self.song().tempo = fraction * value + TEMPO_BOTTOM

    @subject_slot('value')
    def _tempo_fine_value(self, value):
        if self.is_enabled():
            if self._fine_tempo_needs_pickup:
                if in_range(self._prior_fine_tempo_value, 0, 128):
                    range_max = max(value, self._prior_fine_tempo_value)
                    range_min = min(value, self._prior_fine_tempo_value)
                    if in_range(64, range_min, range_max + 1):
                        self._fine_tempo_needs_pickup = False
            else:
                raise in_range(self._prior_fine_tempo_value, 0, 128) or AssertionError
                difference = value - self._prior_fine_tempo_value
                ratio = 127.0 / TEMPO_FINE_RANGE
                new_tempo = clamp(self.song().tempo + difference / ratio, TEMPO_BOTTOM, TEMPO_TOP)
                self.song().tempo = new_tempo
        self._prior_fine_tempo_value = value

    @subject_slot('value')
    def _song_position_value(self, value):
        raise NotImplementedError
########NEW FILE########
__FILENAME__ = Util
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Framework/Util.py
"""
Various utilities.
"""
from contextlib import contextmanager
from functools import wraps, partial
from itertools import chain

def clamp(val, minv, maxv):
    return max(minv, min(val, maxv))


def linear(minv, maxv, val):
    return minv + (maxv - minv) * val


def nop(*a, **k):
    if a:
        return a[0]


def negate(value):
    return not value


def const(value):
    return lambda *a, **k: value


def in_range(value, lower_bound, upper_open_bound):
    return value >= lower_bound and value < upper_open_bound


def sign(value):
    return 1.0 if value >= 0.0 else -1.0


def to_slice(obj):
    return obj if isinstance(obj, slice) else (slice(obj, obj + 1) if obj != -1 else slice(obj, None))


def slice_size(slice, width):
    return len(range(width)[slice])


def maybe(fn):
    return lambda x: fn(x) if x is not None else None


def memoize(function):
    """
    Decorator to use automatic memoization on a given function, such
    that results are chached and, if called a second time, the
    function will return the cached value. Example::
    
        @memoize
        def fibonacci(n):
            print "Computing fibonacci of:", n
            if n == 0:
                return 0
            if n == 1:
                return 1
            return fibonacci(n-1) + fibonacci(n-2)
    
        fibonacci(5)
    
    If we removed the @memoize decorator, it would print O(2^n) lines
    instead showing a exponential degeneration due to the binary
    recursion.  However, already computed values will not recurse,
    thus this program will print on the console:
    
        Computing fibonacci of: 5
        Computing fibonacci of: 4
        Computing fibonacci of: 3
        Computing fibonacci of: 2
        Computing fibonacci of: 1
    
    Note that every computed value is cached in global state, so this
    can be inapropiate when the function domain is very big.
    """
    memoized = {}

    @wraps(function)
    def wrapper(*args):
        try:
            ret = memoized[args]
        except KeyError:
            ret = memoized[args] = function(*args)

        return ret

    return wrapper


@memoize
def mixin(one, *args):
    """
    Dynamically creates a class that inherits from all the classes
    passed as parameters. Example::
    
        class A(object):
            pass
        class B(object):
            pass
    
        a_and_b_instance = mixin(A, B)()
    
    Also, this statement holds for every A and B::
    
        assert mixin(A, B) == mixin(A, B)
    """
    if not args:
        return one
    two, rest = args[0], args[1:]

    class Mixin(one, two):

        def __init__(self, *args, **kws):
            super(Mixin, self).__init__(*args, **kws)

    if rest:
        return mixin(Mixin, *rest)
    return Mixin


def monkeypatch(target, name = None, override = False, doc = None):
    """
    Decorator that injects the decorated function into the 'target'
    class. If no name is given the decorated function name will be
    used for the injected method name. If the class already has a
    method with a given name it raises an error unless 'override' is
    set to True.
    
    Example::
        class MyClass(object):
            pass
    
        @monkeypatch(MyClass)
        def patched_method(self):
            print "Lalala"
    
        MyClass().patched_method()
    
    Output::
        Lalala
    """

    def patcher(func):
        patchname = func.__name__ if name is None else name
        if not override and hasattr(target, patchname):
            raise TypeError('Class %s already has method %s' % (target.__name__, patchname))
        setattr(target, patchname, func)
        func.__name__ = patchname
        if doc is not None:
            func.__doc__ = doc
        return func

    return patcher


def monkeypatch_extend(target, name = None):
    """
    Decorator that injects the decorated function as an extension of a
    method of the 'target' class. If no 'name' is passed, the
    decorated function name will be the name of the method.
    
    Example::
       class MyClass(object):
           def some_method(self):
               print "Original"
    
        @monkeypatch_extend(MyClass)
        def some_method(self):
            print "Patch"
    
        MyClass().some_method()
    
    Output::
        Original
        Patch
    
    Known issues: if you are extending a method of class Deriv,
    when the method is only defined in its super-class Base (i.e. not
    overriden by Deriv but is inherited from Base), can break the
    ability of the method to properly cooperate (i.e. propagate calls
    to super in a diamond-shaped hierarchy [1]).  If
    monkeypatch_extend in a metaclass, this can be worked around by
    injecting a cooperative definition of the method in Deriv's
    dictionary. An example of this can be seen in SubjectSlot.SubjectMeta
    
    [1] A definition of cooperative method http://sinusoid.es/jpblib/coop.html
    """

    def patcher(func):
        newfunc = func
        patchname = func.__name__ if name is None else name
        if hasattr(target, patchname):
            oldfunc = getattr(target, patchname)
            if not callable(oldfunc):
                raise TypeError('Can not extend non callable attribute')

            @wraps(oldfunc)
            def extended(*a, **k):
                ret = oldfunc(*a, **k)
                func(*a, **k)
                return ret

            newfunc = extended
        else:
            raise False or AssertionError, 'Must have something to extend'
        setattr(target, patchname, newfunc)
        return func

    return patcher


def instance_decorator(decorator):
    """
    Meta-decorator to define decorators that decorate a method in a
    concrete instance. The decorator method will be passed the
    object instance as first argument and the unbound decorated method
    as second argument. The decorator method will be called lazily the
    first time the method is accessed.
    
    For an example see @signal_slot in SubjectSlot module.
    """

    class Decorator(object):

        def __init__(self, func = nop, *args, **kws):
            self.__name__ = func.__name__
            self.__doc__ = func.__doc__
            self._func = func
            self._args = args
            self._kws = kws

        def __get__(self, obj, cls = None):
            if obj is None:
                return
            decorated = decorator(obj, self._func, *self._args, **self._kws)
            obj.__dict__[self.__name__] = decorated
            return decorated

    return Decorator


def forward_property(member):
    """
    Property that forwards access to a nested object. You can use it
    as a decorator, where the function will be used only to extract
    the name of the property. It is useful when exposing some property
    of a subobject...
    
    Example::
        class NestedClass(object):
            parameter = 0
    
        class SomeClass(object):
            def __init__(self, *a, **k):
                super(SomeClass, self).__init__(*a, **k)
                self._nested_object = NestedClass()
    
            @forward_property('_nested_object')
            def parameter(): pass
    
        print SomeClass().parameter
    
    Output::
        0
    """

    class Descriptor(object):

        def __init__(self, func_or_name):
            self._property_name = func_or_name.__name__ if callable(func_or_name) else func_or_name

        def __get__(self, obj, cls = None):
            return getattr(getattr(obj, member), self._property_name)

        def __set__(self, obj, value):
            return setattr(getattr(obj, member), self._property_name, value)

    return Descriptor


class lazy_attribute(object):
    """
    Decorator that will turn a method in a lazy attribute. The first
    time the attribute is accessed its value will be computed using
    the decorated method and then cached.
    
    Example::
        class MyClass(object):
    
            @lazy_attribute
            def my_attribute(self):
                print "Computing"
                return 0
    
        obj = MyClass()
        print obj.my_attribute
        print obj.my_attribute
    
    Output::
        Computing
        0
        0
    """

    def __init__(self, func, name = None):
        wraps(func)(self)
        self._func = func
        if name:
            self.__name__ = name

    def __get__(self, obj, cls = None):
        if obj is None:
            return self
        result = obj.__dict__[self.__name__] = self._func(obj)
        return result


def remove_if(predicate, lst):
    """
    Returns a new list with elements of the iterable 'lst' excepting
    those satisfying 'predicate'.
    """
    return [ elem for elem in lst if not predicate(elem) ]


def flatten(list):
    """
    Flattens a list of lists into a new list. It does not do that
    recursively, only one level.
    """
    return chain(*list)


def group(lst, n):
    """
    Returns a list of lists with elements from 'lst' grouped in blocks
    of 'n' elements.
    """
    return map(None, *[ lst[i::n] for i in range(n) ])


def find_if(predicate, seq):
    """
    Returns the first element in sequence 'seq' satisfying 'predicate'
    or 'None' if no such element exists.
    """
    for x in seq:
        if predicate(x):
            return x


def index_if(predicate, seq):
    """
    Returns the index of the first element in sequence 'seq'
    satisfying predicate. If no such element exists returns the length
    of the sequence.
    """
    idx = 0
    for x in seq:
        if predicate(x):
            return idx
        idx += 1

    return idx


def union(a, b):
    """
    Returns a new dictionary with all the entries in dictionaries 'a'
    and 'b'. In case of conflict the entry from 'b' is taken.
    """
    a = dict(a)
    a.update(b)
    return a


def product(iter_a, iter_b):
    """
    Generator that generates all possible tuples combining elements
    from sequence 'iter_a' and 'iter_b'.
    """
    for a in iter_a:
        for b in iter_b:
            yield (a, b)


def next(iter):
    """
    Equivalent to iter.next()
    """
    return iter.next()


def is_iterable(value):
    """
    Returns True if 'value' is iterable and False otherwise.
    """
    try:
        it = iter(value)
        return bool(it)
    except TypeError:
        return False


def recursive_map(fn, element, sequence_type = None):
    """
    Maps a tree-like data structure built by composing sequences of
    type iterable_type. if no iterable_type is given, it is assumed to
    be the type of the root element.
    
    Example::
        print recurse_map(lambda t: t + (0,),
                          [[(0,), (1,)], [(3,), (4,)]])
    
    Output::
        [[(0,0), (1,0)], [(3,0), (4,0)]]
    """
    if sequence_type is None:
        return recursive_map(fn, element, type(element))
    elif isinstance(element, sequence_type):
        return map(lambda x: recursive_map(fn, x, sequence_type), element)
    else:
        return fn(element)


def chain_from_iterable(iterables):
    """
    Alternate constructor for chain(). Gets chained inputs from a single iterable
    argument that is evaluated lazily.
    """
    for it in iterables:
        for element in it:
            yield element


def first(seq):
    return seq[0]


def second(seq):
    return seq[1]


def third(seq):
    return seq[2]


def compose(*funcs):
    """
    Returns the composition of all passed functions, similar to the
    mathematical dot.
    
    Example::
        f = lambda x: x + 2
        g = lambda x: x * 2
        h = compose(f, g)
        print h(3)
    
    Output::
       8 # (3 * 2) + 2
    """
    return lambda x: reduce(lambda x, f: f(x), funcs[::-1], x)


def is_contextmanager(value):
    return callable(getattr(value, '__enter__')) and callable(getattr(value, '__exit__'))


def infinite_context_manager(generator):
    """
    contextlib.contextmanager have the consumes the generator, so most
    of the time they can only be used one.  This variant will always
    re-instantiate the generator, such that the context manager can be
    reused.
    """
    make_context_manager = contextmanager(generator)

    class InfiniteContextManager(object):

        def __enter__(self):
            self._delegate = make_context_manager()
            self._delegate.__enter__()

        def __exit__(self, type, err, trace):
            self._delegate.__exit__(type, err, trace)
            del self._delegate

    return InfiniteContextManager


class BooleanContext(object):
    """
    This class represents an boolean variable with RAII setting within
    a scope.  It is useful to break recursions in an exception-safe
    way.  The boolean context can be used in nested fashion, as long
    as you request a new context manager for every 'with' statement
    using the call operator. Example::
    
      in_notification = BooleanContext()
    
      assert not in_notification
      with in_notification():
          assert in_notification
          with in_notification():
              assert in_notification
          assert in_notification
      assert not in_notification
    
    The 'default_value' parameter indicates the initial value. It will
    be negated when you enter the context.
    """
    default_value = False

    def __init__(self, default_value = None, *a, **k):
        super(BooleanContext, self).__init__(*a, **k)
        if default_value is not None:
            self.default_value = default_value
        self._current_value = self.default_value

    def __nonzero__(self):
        return bool(self._current_value)

    def __bool__(self):
        return bool(self._current_value)

    def __call__(self, update_value = None):
        """
        Makes a context manager for the boolean context
        """
        return self.Manager(self, update_value)

    @property
    def value(self):
        return self._current_value

    class Manager(object):

        def __init__(self, managed = None, update_value = None, *a, **k):
            super(BooleanContext.Manager, self).__init__(*a, **k)
            self._managed = managed
            self._update_value = update_value if update_value is not None else not managed.default_value

        def __enter__(self):
            managed = self._managed
            self._old_value = managed._current_value
            managed._current_value = self._update_value
            return self

        def __exit__(self, *a, **k):
            self._managed._current_value = self._old_value


def dict_diff(left, right):
    """
    Computes a dictionary with the elements that are in the right but
    not or different in the left.
    """
    dummy = object()
    return dict(filter(lambda (k, v): left.get(k, dummy) != v, right.iteritems()))


class NamedTuple(object):
    """
    Immutable object that acts like a dictionary whose members can
    also be set via attribute access.  Derivatives can give and
    override default values in the class definition, for example::
    
      class MyNamedTuple(NamedTuple):
          some_value = 3
    
      assert MyNamedTuple == NamedTuple(some_value = 3)
    """

    def __init__(self, *others, **k):
        super(NamedTuple, self).__init__()
        for other in others:
            diff = dict_diff(self._eq_dict, other._eq_dict)
            self._eq_dict.update(diff)
            self.__dict__.update(diff)

        self.__dict__.update(k)
        if '_eq_dict' in self.__dict__:
            self._eq_dict.update(k)

    def __setattr__(self, name, value):
        raise AttributeError, 'Named tuple is constant'

    def __delattr__(self, name):
        raise AttributeError, 'Named tuple is constant'

    def __getitem__(self, name):
        return self.__dict__[name]

    @lazy_attribute
    def _eq_dict(self):

        def public(objdict):
            return dict(filter(lambda (k, _): not k.startswith('_'), objdict.iteritems()))

        return reduce(lambda a, b: union(b, a), map(lambda c: public(c.__dict__), self.__class__.__mro__), public(self.__dict__))

    def __eq__(self, other):
        return isinstance(other, NamedTuple) and self._eq_dict == other._eq_dict

    def __getstate__(self):
        res = dict(self.__dict__)
        try:
            del res['_eq_dict']
        except KeyError:
            pass

        return res


class Slicer(object):
    """
    A slicer object can be used to easily write a multi-dimensional
    __getitem__ that use the normal slicing syntax.  An example of
    usage is implementing flexible matrix types, as this example shows
    (note that we create the Slicer object via the slicer decorator)::
    
      class Matrix(object):
    
          def __init__(self, rows=(,), *a, **k):
              super(Matrix, self).__init__(*a, **k)
              self._rows = rows
    
          @property
          @slicer(2)
          def submatrix(self, row_slice, col_slice):
              return Matrix([row[col_slice] for row in self._rows[row_slice]])
    
    Future improvements could include __setitem__ implementation.
    """

    def __init__(self, dimensions = 1, extractor = nop, keys = tuple(), *a, **k):
        super(Slicer, self).__init__(*a, **k)
        raise len(keys) < dimensions or AssertionError
        self._keys = keys
        self._dimensions = dimensions
        self._extractor = extractor

    def __getitem__(self, key):
        new = key if isinstance(key, tuple) else (key,)
        keys = self._keys + new
        if not len(keys) <= self._dimensions:
            raise AssertionError, 'Too many dimensions'
            return len(keys) == self._dimensions and self._extractor(*keys)
        else:
            return Slicer(dimensions=self._dimensions, extractor=self._extractor, keys=keys)

    def __call__(self):
        return self


get_slice = Slicer()

def slicer(dimensions):
    """
    Slicer decorator.  Returns a decorator that will decorate a
    function into a Slicer object of a given dimension.
    """

    def decorator(extractor):

        @wraps(extractor)
        def make_slicer(*a, **k):
            return Slicer(dimensions=dimensions, extractor=partial(extractor, *a, **k))

        return make_slicer

    return decorator


def print_message(*messages):
    print ' '.join(map(str, messages))


def trace_value(value, msg = 'Value: '):
    """
    Prints value and returns value. Useful when debugging the results
    of sub-expressions.
    """
    print msg, value
    return value


def count_calls(fn = nop):
    return wraps(fn)(CallCounter(fn))


class Bindable(object):
    """
    Utility base class for general bindable function objects.
    Specializations should define the bind()
    """
    _bound_instances = None

    def __get__(self, obj, cls = None):
        import weakref
        if self._bound_instances is None:
            self._bound_instances = weakref.WeakKeyDictionary()
        bound_dict = self._bound_instances.setdefault(obj, weakref.WeakKeyDictionary())
        try:
            bound = bound_dict[self]
        except KeyError:
            bound = self.bind(weakref.proxy(obj))
            bound_dict[self] = bound

        return bound

    def bind(self, bind_to_object):
        raise NotImplementedError


class CallCounter(Bindable):
    """
    Function object that counts the number of times it is called.
    """

    def __init__(self, fn = nop, current_self = None, *a, **k):
        super(CallCounter, self).__init__(*a, **k)
        wraps(fn)(self)
        self.fn = fn
        self.count = 0
        self.last_args = None
        self.current_self = current_self

    def bind(self, obj):
        return CallCounter(fn=self.fn, current_self=obj)

    def __call__(self, *a, **k):
        self.count += 1
        self.last_args = a
        if self.current_self is not None:
            return self.fn(self.current_self, *a, **k)
        else:
            return self.fn(*a, **k)
########NEW FILE########
__FILENAME__ = Devices
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Generic/Devices.py
from functools import partial
from _Framework.Util import group
RCK_BANK1 = ('Macro 1', 'Macro 2', 'Macro 3', 'Macro 4', 'Macro 5', 'Macro 6', 'Macro 7', 'Macro 8')
RCK_BANKS = (RCK_BANK1,)
RCK_BOBS = (RCK_BANK1,)
RCK_BNK_NAMES = ('Macros',)
ALG_BANK1 = ('OSC1 Level', 'OSC1 Octave', 'OSC1 Semi', 'OSC1 Shape', 'OSC2 Level', 'OSC2 Octave', 'OSC2 Semi', 'OSC2 Shape')
ALG_BANK2 = ('OSC1 Balance', 'F1 Freq', 'F1 Resonance', 'F1 Type', 'OSC2 Balance', 'F2 Freq', 'F2 Resonance', 'F2 Type')
ALG_BANK3 = ('FEG1 Attack', 'FEG1 Decay', 'FEG1 Sustain', 'FEG1 Rel', 'FEG2 Attack', 'FEG2 Decay', 'FEG2 Sustain', 'FEG2 Rel')
ALG_BANK4 = ('F1 On/Off', 'F1 Freq < LFO', 'F1 Freq < Env', 'F1 Res < LFO', 'F2 On/Off', 'F2 Freq < LFO', 'F2 Freq < Env', 'F2 Res < LFO')
ALG_BANK5 = ('AEG1 Attack', 'AEG1 Decay', 'AEG1 Sustain', 'AEG1 Rel', 'AEG2 Attack', 'AEG2 Decay', 'AEG2 Sustain', 'AEG2 Rel')
ALG_BANK6 = ('AMP1 Level', 'AMP1 Pan', 'LFO1 Shape', 'LFO1 Speed', 'AMP2 Level', 'AMP2 Pan', 'LFO2 Shape', 'LFO2 Speed')
ALG_BANK7 = ('Volume', 'Noise On/Off', 'Noise Level', 'Noise Color', 'Unison On/Off', 'Unison Detune', 'Vib On/Off', 'Vib Amount')
ALG_BOB = ('F1 Freq', 'F1 Resonance', 'OSC1 Shape', 'OSC1 Octave', 'OSC2 Shape', 'OSC2 Octave', 'OSC2 Detune', 'Volume')
ALG_BANKS = (ALG_BANK1,
 ALG_BANK2,
 ALG_BANK3,
 ALG_BANK4,
 ALG_BANK5,
 ALG_BANK6,
 ALG_BANK7)
ALG_BOBS = (ALG_BOB,)
ALG_BNK_NAMES = ('Oscillators', 'Filters', 'Filter Envelopes', 'Filter Modulation', 'Volume Envelopes', 'Mix', 'Output')
COL_BANK1 = ('Mallet On/Off', 'Mallet Volume', 'Mallet Noise Amount', 'Mallet Stiffness', 'Mallet Noise Color', '', '', '')
COL_BANK2 = ('Noise Volume', 'Noise Filter Type', 'Noise Filter Freq', 'Noise Filter Q', 'Noise Attack', 'Noise Decay', 'Noise Sustain', 'Noise Release')
COL_BANK3 = ('Res 1 Decay', 'Res 1 Material', 'Res 1 Type', 'Res 1 Quality', 'Res 1 Tune', 'Res 1 Fine Tune', 'Res 1 Pitch Env.', 'Res 1 Pitch Env. Time')
COL_BANK4 = ('Res 1 Listening L', 'Res 1 Listening R', 'Res 1 Hit', 'Res 1 Brightness', 'Res 1 Inharmonics', 'Res 1 Radius', 'Res 1 Opening', 'Res 1 Ratio')
COL_BANK5 = ('Res 2 Decay', 'Res 2 Material', 'Res 2 Type', 'Res 2 Quality', 'Res 2 Tune', 'Res 2 Fine Tune', 'Res 2 Pitch Env.', 'Res 2 Pitch Env. Time')
COL_BANK6 = ('Res 2 Listening L', 'Res 2 Listening R', 'Res 2 Hit', 'Res 2 Brightness', 'Res 2 Inharmonics', 'Res 2 Radius', 'Res 2 Opening', 'Res 2 Ratio')
COL_BOB = ('Res 1 Brightness', 'Res 1 Type', 'Mallet Stiffness', 'Mallet Noise Amount', 'Res 1 Inharmonics', 'Res 1 Decay', 'Res 1 Tune', 'Volume')
COL_BANKS = (COL_BANK1,
 COL_BANK2,
 COL_BANK3,
 COL_BANK4,
 COL_BANK5,
 COL_BANK6)
COL_BOBS = (COL_BOB,)
COL_BNK_NAMES = ('Mallet', 'Noise', 'Resonator 1, Set A', 'Resonator 1, Set B', 'Resonator 2, Set A', 'Resonator 2, Set B')
ELC_BANK1 = ('M Stiffness', 'M Force', 'Noise Pitch', 'Noise Decay', 'Noise Amount', 'F Tine Color', 'F Tine Decay', 'F Tine Vol')
ELC_BANK2 = ('F Tone Decay', 'F Tone Vol', 'F Release', 'Damp Tone', 'Damp Balance', 'Damp Amount', '', '')
ELC_BANK3 = ('P Symmetry', 'P Distance', 'P Amp In', 'P Amp Out', 'Pickup Model', '', '', '')
ELC_BANK4 = ('M Stiff < Vel', 'M Stiff < Key', 'M Force < Vel', 'M Force < Key', 'Noise < Key', 'F Tine < Key', 'P Amp < Key', '')
ELC_BANK5 = ('Volume', 'Voices', 'Semitone', 'Detune', 'KB Stretch', 'PB Range', '', '')
ELC_BOB = ('M Stiffness', 'M Force', 'Noise Amount', 'F Tine Vol', 'F Tone Vol', 'F Release', 'P Symmetry', 'Volume')
ELC_BANKS = (ELC_BANK1,
 ELC_BANK2,
 ELC_BANK3,
 ELC_BANK4,
 ELC_BANK5)
ELC_BOBS = (ELC_BOB,)
ELC_BNK_NAMES = ('Mallet and Tine', 'Tone and Damper', 'Pickup', 'Modulation', 'Global')
IMP_BANK1 = ('1 Start', '1 Transpose', '1 Stretch Factor', '1 Saturator Drive', '1 Filter Freq', '1 Filter Res', '1 Pan', '1 Volume')
IMP_BANK2 = ('2 Start', '2 Transpose', '2 Stretch Factor', '2 Saturator Drive', '2 Filter Freq', '2 Filter Res', '2 Pan', '2 Volume')
IMP_BANK3 = ('3 Start', '3 Transpose', '3 Stretch Factor', '3 Saturator Drive', '3 Filter Freq', '3 Filter Res', '3 Pan', '3 Volume')
IMP_BANK4 = ('4 Start', '4 Transpose', '4 Stretch Factor', '4 Saturator Drive', '4 Filter Freq', '4 Filter Res', '4 Pan', '4 Volume')
IMP_BANK5 = ('5 Start', '5 Transpose', '5 Stretch Factor', '5 Saturator Drive', '5 Filter Freq', '5 Filter Res', '5 Pan', '5 Volume')
IMP_BANK6 = ('6 Start', '6 Transpose', '6 Stretch Factor', '6 Saturator Drive', '6 Filter Freq', '6 Filter Res', '6 Pan', '6 Volume')
IMP_BANK7 = ('7 Start', '7 Transpose', '7 Stretch Factor', '7 Saturator Drive', '7 Filter Freq', '7 Filter Res', '7 Pan', '7 Volume')
IMP_BANK8 = ('8 Start', '8 Transpose', '8 Stretch Factor', '8 Saturator Drive', '8 Filter Freq', '8 Filter Res', '8 Pan', '8 Volume')
IMP_BOB = ('Global Time', 'Global Transpose', '1 Transpose', '2 Transpose', '3 Transpose', '4 Transpose', '5 Transpose', '6 Transpose')
IMP_BANKS = (IMP_BANK1,
 IMP_BANK2,
 IMP_BANK3,
 IMP_BANK4,
 IMP_BANK5,
 IMP_BANK6,
 IMP_BANK7,
 IMP_BANK8)
IMP_BOBS = (IMP_BOB,)
IMP_BNK_NAMES = ('Pad 1', 'Pad 2', 'Pad 3', 'Pad 4', 'Pad 5', 'Pad 6', 'Pad 7', 'Pad 8')
OPR_BANK1 = ('Ae Attack', 'Ae Decay', 'Ae Sustain', 'Ae Release', 'A Coarse', 'A Fine', 'Osc-A Lev < Vel', 'Osc-A Level')
OPR_BANK2 = ('Be Attack', 'Be Decay', 'Be Sustain', 'Be Release', 'B Coarse', 'B Fine', 'Osc-B Lev < Vel', 'Osc-B Level')
OPR_BANK3 = ('Ce Attack', 'Ce Decay', 'Ce Sustain', 'Ce Release', 'C Coarse', 'C Fine', 'Osc-C Lev < Vel', 'Osc-C Level')
OPR_BANK4 = ('De Attack', 'De Decay', 'De Sustain', 'De Release', 'D Coarse', 'D Fine', 'Osc-D Lev < Vel', 'Osc-D Level')
OPR_BANK5 = ('Le Attack', 'Le Decay', 'Le Sustain', 'Le Release', 'LFO Rate', 'LFO Amt', 'LFO Type', 'LFO R < K')
OPR_BANK6 = ('Fe Attack', 'Fe Decay', 'Fe Sustain', 'Fe Release', 'Filter Freq', 'Filter Res', 'Fe R < Vel', 'Fe Amount')
OPR_BANK7 = ('Pe Attack', 'Pe Decay', 'Pe Sustain', 'Pe Release', 'Pe Init', 'Glide Time', 'Pe Amount', 'Spread')
OPR_BANK8 = ('Time < Key', 'Panorama', 'Pan < Key', 'Pan < Rnd', 'Algorithm', 'Time', 'Tone', 'Volume')
OPR_BOB = ('Filter Freq', 'Filter Res', 'A Coarse', 'A Fine', 'B Coarse', 'B Fine', 'Osc-B Level', 'Volume')
OPR_BANKS = (OPR_BANK1,
 OPR_BANK2,
 OPR_BANK3,
 OPR_BANK4,
 OPR_BANK5,
 OPR_BANK6,
 OPR_BANK7,
 OPR_BANK8)
OPR_BOBS = (OPR_BOB,)
OPR_BNK_NAMES = ('Oscillator A', 'Oscillator B', 'Oscillator C', 'Oscillator D', 'LFO', 'Filter', 'Pitch Modulation', 'Routing')
SAM_BANK1 = ('Volume', 'Ve Attack', 'Ve Decay', 'Ve Sustain', 'Ve Release', 'Vol < Vel', 'Ve R < Vel', 'Time')
SAM_BANK2 = ('Filter Type', 'Filter Morph', 'Filter Freq', 'Filter Res', 'Filt < Vel', 'Filt < Key', 'Fe < Env', 'Shaper Amt')
SAM_BANK3 = ('Fe Attack', 'Fe Decay', 'Fe Sustain', 'Fe Release', 'Fe End', 'Fe Mode', 'Fe Loop', 'Fe Retrig')
SAM_BANK4 = ('L 1 Wave', 'L 1 Sync', 'L 1 Sync Rate', 'L 1 Rate', 'Vol < LFO', 'Filt < LFO', 'Pan < LFO', 'Pitch < LFO')
SAM_BANK5 = ('L 2 Wave', 'L 2 Sync', 'L 2 Sync Rate', 'L 2 Rate', 'L 2 R < Key', 'L 2 St Mode', 'L 2 Spin', 'L 2 Phase')
SAM_BANK6 = ('L 3 Wave', 'L 3 Sync', 'L 3 Sync Rate', 'L 3 Rate', 'L 3 R < Key', 'L 3 St Mode', 'L 3 Spin', 'L 3 Phase')
SAM_BANK7 = ('O Mode', 'O Volume', 'O Coarse', 'O Fine', 'Oe Attack', 'Oe Decay', 'Oe Sustain', 'Oe Release')
SAM_BANK8 = ('Transpose', 'Spread', 'Pe < Env', 'Pe Attack', 'Pe Peak', 'Pe Decay', 'Pe Sustain', 'Pe Release')
SAM_BOB = ('Filter Freq', 'Filter Res', 'Fe < Env', 'Fe Decay', 'Ve Attack', 'Ve Release', 'Transpose', 'Volume')
SAM_BANKS = (SAM_BANK1,
 SAM_BANK2,
 SAM_BANK3,
 SAM_BANK4,
 SAM_BANK5,
 SAM_BANK6,
 SAM_BANK7,
 SAM_BANK8)
SAM_BOBS = (SAM_BOB,)
SAM_BNK_NAMES = ('Volume', 'Filter', 'Filter Envelope', 'LFO 1', 'LFO 2', 'LFO 3', 'Oscillator', 'Pitch')
SIM_BANK1 = ('Ve Attack', 'Ve Decay', 'Ve Sustain', 'Ve Release', 'S Start', 'S Loop Length', 'S Length', 'S Loop Fade')
SIM_BANK2 = ('Fe Attack', 'Fe Decay', 'Fe Sustain', 'Fe Release', 'Filter Freq', 'Filter Res', 'Filt < Vel', 'Fe < Env')
SIM_BANK3 = ('L Attack', 'L Rate', 'L R < Key', 'L Wave', 'Vol < LFO', 'Filt < LFO', 'Pitch < LFO', 'Pan < LFO')
SIM_BANK4 = ('Pe Attack', 'Pe Decay', 'Pe Sustain', 'Pe Release', 'Glide Time', 'Spread', 'Pan', 'Volume')
SIM_BOB = ('Filter Freq', 'Filter Res', 'S Start', 'S Length', 'Ve Attack', 'Ve Release', 'Transpose', 'Volume')
SIM_BANKS = (SIM_BANK1,
 SIM_BANK2,
 SIM_BANK3,
 SIM_BANK4)
SIM_BOBS = (SIM_BOB,)
SIM_BNK_NAMES = ('Amplitude', 'Filter', 'LFO', 'Pitch Modifiers')
TNS_BANK1 = ('Excitator Type', 'String Decay', 'Str Inharmon', 'Str Damping', 'Exc ForceMassProt', 'Exc FricStiff', 'Exc Velocity', 'E Pos')
TNS_BANK2 = ('Damper On', 'Damper Mass', 'D Stiffness', 'D Velocity', 'Damp Pos', 'D Damping', 'D Pos < Vel', 'D Pos Abs')
TNS_BANK3 = ('Term On/Off', 'Term Mass', 'Term Fng Stiff', 'Term Fret Stiff', 'Pickup On/Off', 'Pickup Pos', 'T Mass < Vel', 'T Mass < Key')
TNS_BANK4 = ('Body On/Off', 'Body Type', 'Body Size', 'Body Decay', 'Body Low-Cut', 'Body High-Cut', 'Body Mix', 'Volume')
TNS_BANK5 = ('Vibrato On/Off', 'Vib Delay', 'Vib Fade-In', 'Vib Speed', 'Vib Amount', 'Vib < ModWh', 'Vib Error', 'Volume')
TNS_BANK6 = ('Filter On/Off', 'Filter Type', 'Filter Freq', 'Filter Reso', 'Freq < Env', 'Freq < LFO', 'Reso < Env', 'Reso < LFO')
TNS_BANK7 = ('FEG On/Off', 'FEG Attack', 'FEG Decay', 'FEG Sustain', 'FEG Release', 'LFO On/Off', 'LFO Shape', 'LFO Speed')
TNS_BANK8 = ('Unison On/Off', 'Uni Detune', 'Porta On/Off', 'Porta Time', 'Voices', 'Octave', 'Semitone', 'Volume')
TNS_BOB = ('Filter Freq', 'Filter Reso', 'Filter Type', 'Excitator Type', 'E Pos', 'String Decay', 'Str Damping', 'Volume')
TNS_BANKS = (TNS_BANK1,
 TNS_BANK2,
 TNS_BANK3,
 TNS_BANK4,
 TNS_BANK5,
 TNS_BANK6,
 TNS_BANK7,
 TNS_BANK8)
TNS_BOBS = (TNS_BOB,)
TNS_BNK_NAMES = ('Excitator and String', 'Damper', 'Termination and Pickup', 'Body', 'Vibrato', 'Filter', 'Envelope and LFO', 'Global')
ARP_BANK1 = ('Style', 'Groove', 'Offset', 'Synced Rate', 'Retrigger Mode', 'Ret. Interval', 'Repeats', 'Gate')
ARP_BANK2 = ('Tranpose Mode', 'Tranpose Key', 'Transp. Steps', 'Transp. Dist.', 'Velocity Decay', 'Velocity Target', 'Velocity On', 'Vel. Retrigger')
ARP_BOB = ('Synced Rate', 'Free Rate', 'Transp. Steps', 'Transp. Dist.', 'Gate', 'Tranpose Key', 'Velocity Decay', 'Velocity Target')
ARP_BANKS = (ARP_BANK1, ARP_BANK2)
ARP_BOBS = (ARP_BOB,)
ARP_BNK_NAMES = ('Style', 'Pitch/Velocity')
CRD_BANK1 = ('Shift1', 'Shift2', 'Shift3', 'Shift4', 'Shift5', 'Shift6', '', '')
CRD_BANK2 = ('Velocity1', 'Velocity2', 'Velocity3', 'Velocity4', 'Velocity5', 'Velocity6', '', '')
CRD_BOB = ('Shift1', 'Shift2', 'Shift3', 'Shift4', 'Shift5', 'Velocity5', 'Shift6', 'Velocity6')
CRD_BANKS = (CRD_BANK1, CRD_BANK2)
CRD_BOBS = (CRD_BOB,)
CRD_BNK_NAMES = ('Shift', 'Shift %')
NTL_BANK1 = ('Sync On', 'Time Length', 'Synced Length', 'Gate', 'On/Off-Balance', 'Decay Time', 'Decay Key Scale', '')
NTL_BANKS = (NTL_BANK1,)
NTL_BOBS = (NTL_BANK1,)
PIT_BANK1 = ('Pitch', 'Range', 'Lowest', '', '', '', '', '')
PIT_BANKS = (PIT_BANK1,)
PIT_BOBS = (PIT_BANK1,)
RND_BANK1 = ('Chance', 'Choices', 'Scale', 'Sign', '', '', '', '')
RND_BANKS = (RND_BANK1,)
RND_BOBS = (RND_BANK1,)
SCL_BANK1 = ('Base', 'Transpose', 'Range', 'Lowest', '', '', '', '')
SCL_BANKS = (SCL_BANK1,)
SCL_BOBS = (SCL_BANK1,)
VEL_BANK1 = ('Drive', 'Compand', 'Random', 'Mode', 'Out Hi', 'Out Low', 'Range', 'Lowest')
VEL_BANKS = (VEL_BANK1,)
VEL_BOBS = (VEL_BANK1,)
AMP_BANK1 = ('Amp Type', 'Bass', 'Middle', 'Treble', 'Presence', 'Gain', 'Volume', 'Dry/Wet')
AMP_BANK2 = ('Dual Mono', '', '', '', '', '', '', '')
AMP_BANKS = (AMP_BANK1, AMP_BANK2)
AMP_BOBS = (AMP_BANK1,)
AMP_BNK_NAMES = ('Global', 'Dual Mono')
AFL_BANK1 = ('Frequency', 'Resonance', 'Env. Attack', 'Env. Release', 'Env. Modulation', 'LFO Amount', 'LFO Frequency', 'LFO Phase')
AFL_BANK2 = ('Filter Type', 'LFO Quantize On', 'LFO Quantize Rate', 'LFO Stereo Mode', 'LFO Spin', 'LFO Sync', 'LFO Sync Rate', 'LFO Offset')
AFL_BANK3 = ('', '', '', '', '', 'Ext. In On', 'Ext. In Mix', 'Ext. In Gain')
AFL_BOB = ('Frequency', 'Resonance', 'Filter Type', 'Env. Modulation', 'LFO Amount', 'LFO Waveform', 'LFO Frequency', 'LFO Phase')
AFL_BANKS = (AFL_BANK1, AFL_BANK2, AFL_BANK3)
AFL_BOBS = (AFL_BOB,)
AFL_BNK_NAMES = ('Filter', 'Filter Extra', 'Side Chain')
APN_BANK1 = ('Frequency', 'Phase', 'Shape', 'Waveform', 'Sync Rate', 'Offset', 'Width (Random)', 'Amount')
APN_BANKS = (APN_BANK1,)
APN_BOBS = (APN_BANK1,)
BRP_BANK1 = ('Interval', 'Offset', 'Grid', 'Variation', 'Filter Freq', 'Filter Width', 'Volume', 'Decay')
BRP_BANK2 = ('Chance', 'Gate', 'Pitch', 'Pitch Decay', 'Filter Freq', 'Filter Width', 'Volume', 'Decay')
BRP_BOB = ('Grid', 'Interval', 'Offset', 'Gate', 'Pitch', 'Pitch Decay', 'Variation', 'Chance')
BRP_BANKS = (BRP_BANK1, BRP_BANK2)
BRP_BOBS = (BRP_BOB,)
BRP_BNK_NAMES = ('Repeat Rate', 'Gate/Pitch')
CAB_BANK1 = ('Cabinet Type', 'Microphone Position', 'Microphone Type', 'Dual Mono', '', '', '', 'Dry/Wet')
CAB_BANKS = (CAB_BANK1,)
CAB_BOBS = (CAB_BANK1,)
CHR_BANK1 = ('LFO Amount', 'LFO Rate', 'Delay 1 Time', 'Delay 1 HiPass', 'Delay 2 Time', 'Delay 2 Mode', 'Feedback', 'Dry/Wet')
CHR_BANKS = (CHR_BANK1,)
CHR_BOBS = (CHR_BANK1,)
CP3_BANK1 = ('Threshold', 'Ratio', 'Attack', 'Release', 'Auto Release On/Off', 'Env Mode', 'Knee', 'Model')
CP3_BANK2 = ('Threshold', 'Expansion Ratio', 'LookAhead', 'Side Listen', 'Ext. In Gain', 'Makeup', 'Dry/Wet', 'Output Gain')
CP3_BANK3 = ('EQ On', 'EQ Mode', 'EQ Freq', 'EQ Q', 'EQ Gain', 'Ext. In On', 'Ext. In Mix', 'Ext. In Gain')
CP3_BOB = ('Threshold', 'Ratio', 'Attack', 'Release', 'Model', 'Knee', 'Dry/Wet', 'Output Gain')
CP3_BANKS = (CP3_BANK1, CP3_BANK2, CP3_BANK3)
CP3_BOBS = (CP3_BOB,)
CP3_BNK_NAMES = ('Compression', 'Output', 'Side Chain')
CRP_BANK1 = ('Decay', 'Material', 'Mid Freq', 'Width', 'Bleed', 'Resonance Type', 'Gain', 'Dry Wet')
CRP_BANK2 = ('Listening L', 'Listening R', 'Hit', 'Brightness', 'Inharmonics', 'Radius', 'Opening', 'Ratio')
CRP_BANK3 = ('Resonance Type', 'Tune', 'Transpose', 'Fine', 'Spread', 'Resonator Quality', 'Note Off', 'Off Decay')
CRP_BOB = ('Brightness', 'Resonance Type', 'Material', 'Inharmonics', 'Decay', 'Ratio', 'Tune', 'Dry Wet')
CRP_BANKS = (CRP_BANK1, CRP_BANK2, CRP_BANK3)
CRP_BOBS = (CRP_BOB,)
CRP_BNK_NAMES = ('Amount', 'Body', 'Tune')
DTB_BANK1 = ('Drive', 'Bias', 'Envelope', 'Tone', 'Attack', 'Release', 'Output', 'Dry/Wet')
DTB_BANKS = (DTB_BANK1,)
DTB_BOBS = (DTB_BANK1,)
EQ8_BANK1 = ('1 Filter On A', '2 Filter On A', '3 Filter On A', '4 Filter On A', '5 Filter On A', '6 Filter On A', '7 Filter On A', '8 Filter On A')
EQ8_BANK2 = ('1 Frequency A', '2 Frequency A', '3 Frequency A', '4 Frequency A', '5 Frequency A', '6 Frequency A', '7 Frequency A', '8 Frequency A')
EQ8_BANK3 = ('1 Gain A', '2 Gain A', '3 Gain A', '4 Gain A', '5 Gain A', '6 Gain A', '7 Gain A', '8 Gain A')
EQ8_BANK4 = ('1 Resonance A', '2 Resonance A', '3 Resonance A', '4 Resonance A', '5 Resonance A', '6 Resonance A', '7 Resonance A', '8 Resonance A')
EQ8_BANK5 = ('1 Filter Type A', '2 Filter Type A', '3 Filter Type A', '4 Filter Type A', '5 Filter Type A', '6 Filter Type A', '7 Filter Type A', '8 Filter Type A')
EQ8_BANK6 = ('Adaptive Q', '', '', '', '', '', 'Scale', 'Output Gain')
EQ8_BANK7 = ('3 Gain A', '3 Frequency A', '3 Resonance A', '4 Gain A', '4 Frequency A', '4 Resonance A', '5 Gain A', '5 Frequency A')
EQ8_BOB = ('1 Frequency A', '1 Gain A', '2 Frequency A', '2 Gain A', '3 Frequency A', '3 Gain A', '4 Frequency A', '4 Gain A')
EQ8_BANKS = (EQ8_BANK1,
 EQ8_BANK2,
 EQ8_BANK3,
 EQ8_BANK4,
 EQ8_BANK5,
 EQ8_BANK6,
 EQ8_BANK7)
EQ8_BOBS = (EQ8_BOB,)
EQ8_BNK_NAMES = ('Band On/Off', 'Frequency', 'Gain', 'Resonance', 'Filter Type', 'Output', 'EQs 3-5')
EQ3_BANK1 = ('GainLo', 'GainMid', 'GainHi', 'FreqLo', 'LowOn', 'MidOn', 'HighOn', 'FreqHi')
EQ3_BANKS = (EQ3_BANK1,)
EQ3_BOBS = (EQ3_BANK1,)
ERO_BANK1 = ('Frequency', 'Width', 'Mode', 'Amount', '', '', '', '')
ERO_BANKS = (ERO_BANK1,)
ERO_BOBS = (ERO_BANK1,)
FLD_BANK1 = ('1 Filter Freq', '1 Filter Width', '1 Beat Delay', '1 Beat Swing', '1 Feedback', '1 Pan', '1 Volume', 'Dry')
FLD_BANK2 = ('2 Filter Freq', '2 Filter Width', '2 Beat Delay', '2 Beat Swing', '2 Feedback', '2 Pan', '2 Volume', 'Dry')
FLD_BANK3 = ('3 Filter Freq', '3 Filter Width', '3 Beat Delay', '3 Beat Swing', '3 Feedback', '3 Pan', '3 Volume', 'Dry')
FLD_BOB = ('2 Filter Freq', '2 Filter Width', '2 Beat Delay', '2 Feedback', '1 Volume', '3 Volume', '2 Volume', 'Dry')
FLD_BANKS = (FLD_BANK1, FLD_BANK2, FLD_BANK3)
FLD_BOBS = (FLD_BOB,)
FLD_BNK_NAMES = ('Input L Filter', 'Input L+R Filter', 'Input R Filter')
FLG_BANK1 = ('Hi Pass', 'Dry/Wet', 'Delay Time', 'Feedback', 'Env. Modulation', 'Env. Attack', 'Env. Release', '')
FLG_BANK2 = ('LFO Amount', 'Frequency', 'LFO Phase', 'Sync', 'LFO Offset', 'Sync Rate', 'LFO Width (Random)', 'LFO Waveform')
FLG_BOB = ('Hi Pass', 'Delay Time', 'Frequency', 'Sync Rate', 'LFO Amount', 'Env. Modulation', 'Feedback', 'Dry/Wet')
FLG_BANKS = (FLG_BANK1, FLG_BANK2)
FLG_BOBS = (FLG_BOB,)
FLG_BNK_NAMES = ('Frequency Controls', 'LFO / S&H')
FRS_BANK1 = ('Coarse', 'Fine', 'Mode', 'Ring Mod Frequency', 'Drive On/Off', 'Drive', 'Wide', 'Dry/Wet')
FRS_BANKS = (FRS_BANK1,)
FRS_BOBS = (FRS_BANK1,)
GTE_BANK1 = ('Threshold', 'Return', 'FlipMode', 'LookAhead', 'Attack', 'Hold', 'Release', 'Floor')
GTE_BANK2 = ('EQ On', 'EQ Mode', 'EQ Freq', 'EQ Q', 'EQ Gain', 'Ext. In On', 'Ext. In Mix', 'Ext. In Gain')
GTE_BANKS = (GTE_BANK1, GTE_BANK2)
GTE_BOBS = (GTE_BANK1,)
GTE_BNK_NAMES = ('Gate', 'Side Chain')
GLU_BANK1 = ('Threshold', 'Ratio', 'Attack', 'Release', 'Peak Clip In', 'Range', 'Dry/Wet', 'Makeup')
GLU_BANK2 = ('EQ On', 'EQ Mode', 'EQ Freq', 'EQ Q', 'EQ Gain', 'Ext. In On', 'Ext. In Mix', 'Ext. In Gain')
GLU_BOB = ('Threshold', 'Ratio', 'Attack', 'Release', 'Peak Clip In', 'Range', 'Makeup', 'Dry/Wet')
GLU_BANKS = (GLU_BANK1, GLU_BANK2)
GLU_BOBS = (GLU_BOB,)
GLU_BNK_NAMES = ('Compression', 'Side Chain')
GRD_BANK1 = ('Frequency', 'Pitch', 'Time Delay', 'Beat Swing', 'Random', 'Spray', 'Feedback', 'DryWet')
GRD_BANKS = (GRD_BANK1,)
GRD_BOBS = (GRD_BANK1,)
LPR_BANK1 = ('State', 'Speed', 'Reverse', 'Quantization', 'Monitor', 'Song Control', 'Tempo Control', 'Feedback')
LPR_BANKS = (LPR_BANK1,)
LPR_BOBS = (LPR_BANK1,)
MBD_BANK1 = ('Master Output', 'Amount', 'Time Scaling', 'Soft Knee On/Off', 'Peak/RMS Mode', 'Band Activator (High)', 'Band Activator (Mid)', 'Band Activator (Low)')
MBD_BANK2 = ('Input Gain (Low)', 'Below Threshold (Low)', 'Below Ratio (Low)', 'Above Threshold (Low)', 'Above Ratio (Low)', 'Attack Time (Low)', 'Release Time (Low)', 'Output Gain (Low)')
MBD_BANK3 = ('Input Gain (Mid)', 'Below Threshold (Mid)', 'Below Ratio (Mid)', 'Above Threshold (Mid)', 'Above Ratio (Mid)', 'Attack Time (Mid)', 'Release Time (Mid)', 'Output Gain (Mid)')
MBD_BANK4 = ('Input Gain (High)', 'Below Threshold (High)', 'Below Ratio (High)', 'Above Threshold (High)', 'Above Ratio (High)', 'Attack Time (High)', 'Release Time (High)', 'Output Gain (High)')
MBD_BANK5 = ('Low-Mid Crossover', 'Mid-High Crossover', '', '', '', '', '', '')
MBD_BANK6 = ('', '', '', '', '', 'Ext. In On', 'Ext. In Mix', 'Ext. In Gain')
MBD_BOB = ('Above Threshold (Low)', 'Above Ratio (Low)', 'Above Threshold (Mid)', 'Above Ratio (Mid)', 'Above Threshold (High)', 'Above Ratio (High)', 'Master Output', 'Amount')
MBD_BANKS = (MBD_BANK1,
 MBD_BANK2,
 MBD_BANK3,
 MBD_BANK4,
 MBD_BANK5,
 MBD_BANK6)
MBD_BOBS = (MBD_BOB,)
MBD_BNK_NAMES = ('Global', 'Low Band', 'Mid Band', 'High Band', 'Split Frequencies', 'Side Chain')
OVR_BANK1 = ('Filter Freq', 'Filter Width', 'Drive', 'Tone', 'Preserve Dynamics', '', '', 'Dry/Wet')
OVR_BANKS = (OVR_BANK1,)
OVR_BOBS = (OVR_BANK1,)
PHS_BANK1 = ('Poles', 'Color', 'Dry/Wet', 'Frequency', 'Env. Modulation', 'Env. Attack', 'Env. Release', 'Feedback')
PHS_BANK2 = ('LFO Amount', 'LFO Frequency', 'LFO Phase', 'LFO Sync', 'LFO Offset', 'LFO Sync Rate', 'LFO Spin', 'LFO Waveform')
PHS_BOB = ('Frequency', 'Feedback', 'Poles', 'Env. Modulation', 'Color', 'LFO Amount', 'LFO Frequency', 'Dry/Wet')
PHS_BANKS = (PHS_BANK1, PHS_BANK2)
PHS_BOBS = (PHS_BOB,)
PHS_BNK_NAMES = ('Frequency Controls', 'LFO / S&H')
PPG_BANK1 = ('Filter Freq', 'Filter Width', 'Time Delay', 'Beat Delay', 'Beat Swing', 'Delay Mode', 'Feedback', 'Dry/Wet')
PPG_BANKS = (PPG_BANK1,)
PPG_BOBS = (PPG_BANK1,)
RDX_BANK1 = ('Bit Depth', 'Sample Mode', 'Sample Hard', 'Sample Soft', 'Bit On', '', '', '')
RDX_BANKS = (RDX_BANK1,)
RDX_BOBS = (RDX_BANK1,)
RSN_BANK1 = ('Frequency', 'Width', 'Global Gain', 'Dry/Wet', 'Decay', 'I Note', 'Color', 'I Gain')
RSN_BANK2 = ('II Gain', 'III Gain', 'IV Gain', 'V Gain', 'II Pitch', 'III Pitch', 'IV Pitch', 'V Pitch')
RSN_BOB = ('Decay', 'I Note', 'II Pitch', 'III Pitch', 'IV Pitch', 'V Pitch', 'Global Gain', 'Dry/Wet')
RSN_BANKS = (RSN_BANK1, RSN_BANK2)
RSN_BOBS = (RSN_BOB,)
RSN_BNK_NAMES = ('General / Mode I', 'Modes II-IV')
RVB_BANK1 = ('In Filter Freq', 'In Filter Width', 'PreDelay', 'ER Spin On', 'ER Spin Rate', 'ER Spin Amount', 'ER Shape', 'DecayTime')
RVB_BANK2 = ('HiShelf Freq', 'LowShelf Freq', 'Chorus Rate', 'Density', 'HiShelf Gain', 'LowShelf Gain', 'Chorus Amount', 'Scale')
RVB_BANK3 = ('DecayTime', 'Freeze On', 'Room Size', 'Stereo Image', 'ER Level', 'Diffuse Level', 'Dry/Wet', 'Quality')
RVB_BOB = ('DecayTime', 'Room Size', 'PreDelay', 'In Filter Freq', 'ER Level', 'Diffuse Level', 'Stereo Image', 'Dry/Wet')
RVB_BANKS = (RVB_BANK1, RVB_BANK2, RVB_BANK3)
RVB_BOBS = (RVB_BOB,)
RVB_BNK_NAMES = ('Reflections', 'Diffusion Network', 'Global')
SAT_BANK1 = ('Drive', 'Base', 'Frequency', 'Width', 'Depth', 'Output', 'Dry/Wet', 'Type')
SAT_BANK2 = ('WS Drive', 'WS Lin', 'WS Curve', 'WS Damp', 'WS Depth', 'WS Period', 'Dry/Wet', '')
SAT_BOB = ('Drive', 'Type', 'Base', 'Frequency', 'Width', 'Depth', 'Output', 'Dry/Wet')
SAT_BANKS = (SAT_BANK1, SAT_BANK2)
SAT_BOBS = (SAT_BOB,)
SAT_BNK_NAMES = ('General Controls', 'Waveshaper Controls')
SMD_BANK1 = ('L Beat Delay', 'L Beat Swing', 'L Time Delay', 'R Beat Delay', 'R Beat Swing', 'R Time Delay', 'Feedback', 'Dry/Wet')
SMD_BANKS = (SMD_BANK1,)
SMD_BOBS = (SMD_BANK1,)
UTL_BANK1 = ('StereoSeparation', 'BlockDc', 'PhaseInvertL', 'PhaseInvertR', 'Signal Source', 'Panorama', 'Mute', 'Gain')
UTL_BANKS = (UTL_BANK1,)
UTL_BOBS = (UTL_BANK1,)
VDS_BANK1 = ('Tracing Freq.', 'Tracing Width', 'Tracing Drive', 'Crackle Density', 'Pinch Freq.', 'Pinch Width', 'Pinch Drive', 'Crackle Volume')
VDS_BANKS = (VDS_BANK1,)
VDS_BOBS = (VDS_BANK1,)
VOC_BANK1 = ('Formant Shift', 'Attack Time', 'Release Time', 'Mono/Stereo', 'Output Level', 'Gate Threshold', 'Envelope Depth', 'Dry/Wet')
VOC_BANK2 = ('Filter Bandwidth', 'Upper Filter Band', 'Lower Filter Band', 'Precise/Retro', 'Unvoiced Level', 'Unvoiced Sensitivity', 'Unvoiced Speed', 'Enhance')
VOC_BANK3 = ('Noise Rate', 'Noise Crackle', 'Upper Pitch Detection', 'Lower Pitch Detection', 'Oscillator Pitch', 'Oscillator Waveform', 'Ext. In Gain', '')
VOC_BOB = ('Formant Shift', 'Attack Time', 'Release Time', 'Unvoiced Level', 'Gate Threshold', 'Filter Bandwidth', 'Envelope Depth', 'Dry/Wet')
VOC_BANKS = (VOC_BANK1, VOC_BANK2, VOC_BANK3)
VOC_BOBS = (VOC_BOB,)
VOC_BNK_NAMES = ('Global', 'Filters/Voicing', 'Carrier')
DEVICE_DICT = {'AudioEffectGroupDevice': RCK_BANKS,
 'MidiEffectGroupDevice': RCK_BANKS,
 'InstrumentGroupDevice': RCK_BANKS,
 'DrumGroupDevice': RCK_BANKS,
 'InstrumentImpulse': IMP_BANKS,
 'Operator': OPR_BANKS,
 'UltraAnalog': ALG_BANKS,
 'OriginalSimpler': SIM_BANKS,
 'MultiSampler': SAM_BANKS,
 'MidiArpeggiator': ARP_BANKS,
 'LoungeLizard': ELC_BANKS,
 'StringStudio': TNS_BANKS,
 'Collision': COL_BANKS,
 'MidiChord': CRD_BANKS,
 'MidiNoteLength': NTL_BANKS,
 'MidiPitcher': PIT_BANKS,
 'MidiRandom': RND_BANKS,
 'MidiScale': SCL_BANKS,
 'MidiVelocity': VEL_BANKS,
 'AutoFilter': AFL_BANKS,
 'AutoPan': APN_BANKS,
 'BeatRepeat': BRP_BANKS,
 'Chorus': CHR_BANKS,
 'Compressor2': CP3_BANKS,
 'Corpus': CRP_BANKS,
 'Eq8': EQ8_BANKS,
 'FilterEQ3': EQ3_BANKS,
 'Erosion': ERO_BANKS,
 'FilterDelay': FLD_BANKS,
 'Flanger': FLG_BANKS,
 'FrequencyShifter': FRS_BANKS,
 'GrainDelay': GRD_BANKS,
 'Looper': LPR_BANKS,
 'MultibandDynamics': MBD_BANKS,
 'Overdrive': OVR_BANKS,
 'Phaser': PHS_BANKS,
 'Redux': RDX_BANKS,
 'Saturator': SAT_BANKS,
 'Resonator': RSN_BANKS,
 'CrossDelay': SMD_BANKS,
 'StereoGain': UTL_BANKS,
 'Tube': DTB_BANKS,
 'Reverb': RVB_BANKS,
 'Vinyl': VDS_BANKS,
 'Gate': GTE_BANKS,
 'PingPongDelay': PPG_BANKS,
 'Vocoder': VOC_BANKS,
 'Amp': AMP_BANKS,
 'Cabinet': CAB_BANKS,
 'GlueCompressor': GLU_BANKS}
DEVICE_BOB_DICT = {'AudioEffectGroupDevice': RCK_BOBS,
 'MidiEffectGroupDevice': RCK_BOBS,
 'InstrumentGroupDevice': RCK_BOBS,
 'DrumGroupDevice': RCK_BOBS,
 'InstrumentImpulse': IMP_BOBS,
 'Operator': OPR_BOBS,
 'UltraAnalog': ALG_BOBS,
 'OriginalSimpler': SIM_BOBS,
 'MultiSampler': SAM_BOBS,
 'MidiArpeggiator': ARP_BOBS,
 'LoungeLizard': ELC_BOBS,
 'StringStudio': TNS_BOBS,
 'Collision': COL_BOBS,
 'MidiChord': CRD_BOBS,
 'MidiNoteLength': NTL_BOBS,
 'MidiPitcher': PIT_BOBS,
 'MidiRandom': RND_BOBS,
 'MidiScale': SCL_BOBS,
 'MidiVelocity': VEL_BOBS,
 'AutoFilter': AFL_BOBS,
 'AutoPan': APN_BOBS,
 'BeatRepeat': BRP_BOBS,
 'Chorus': CHR_BOBS,
 'Compressor2': CP3_BOBS,
 'Corpus': CRP_BOBS,
 'Eq8': EQ8_BOBS,
 'FilterEQ3': EQ3_BOBS,
 'Erosion': ERO_BOBS,
 'FilterDelay': FLD_BOBS,
 'Flanger': FLG_BOBS,
 'FrequencyShifter': FRS_BOBS,
 'GrainDelay': GRD_BOBS,
 'Looper': LPR_BOBS,
 'MultibandDynamics': MBD_BOBS,
 'Overdrive': OVR_BOBS,
 'Phaser': PHS_BOBS,
 'Redux': RDX_BOBS,
 'Saturator': SAT_BOBS,
 'Resonator': RSN_BOBS,
 'CrossDelay': SMD_BOBS,
 'StereoGain': UTL_BOBS,
 'Tube': DTB_BOBS,
 'Reverb': RVB_BOBS,
 'Vinyl': VDS_BOBS,
 'Gate': GTE_BOBS,
 'PingPongDelay': PPG_BOBS,
 'Vocoder': VOC_BOBS,
 'Amp': AMP_BOBS,
 'Cabinet': CAB_BOBS,
 'GlueCompressor': GLU_BOBS}
BANK_NAME_DICT = {'AudioEffectGroupDevice': RCK_BNK_NAMES,
 'MidiEffectGroupDevice': RCK_BNK_NAMES,
 'InstrumentGroupDevice': RCK_BNK_NAMES,
 'DrumGroupDevice': RCK_BNK_NAMES,
 'InstrumentImpulse': IMP_BNK_NAMES,
 'Operator': OPR_BNK_NAMES,
 'UltraAnalog': ALG_BNK_NAMES,
 'OriginalSimpler': SIM_BNK_NAMES,
 'MultiSampler': SAM_BNK_NAMES,
 'MidiArpeggiator': ARP_BNK_NAMES,
 'LoungeLizard': ELC_BNK_NAMES,
 'StringStudio': TNS_BNK_NAMES,
 'Collision': COL_BNK_NAMES,
 'MidiChord': CRD_BNK_NAMES,
 'BeatRepeat': BRP_BNK_NAMES,
 'Compressor2': CP3_BNK_NAMES,
 'Corpus': CRP_BNK_NAMES,
 'Eq8': EQ8_BNK_NAMES,
 'FilterDelay': FLD_BNK_NAMES,
 'Flanger': FLG_BNK_NAMES,
 'Gate': GTE_BNK_NAMES,
 'MultibandDynamics': MBD_BNK_NAMES,
 'Phaser': PHS_BNK_NAMES,
 'Saturator': SAT_BNK_NAMES,
 'Resonator': RSN_BNK_NAMES,
 'Reverb': RVB_BNK_NAMES,
 'Vocoder': VOC_BNK_NAMES,
 'Amp': AMP_BNK_NAMES,
 'GlueCompressor': GLU_BNK_NAMES,
 'AutoFilter': AFL_BNK_NAMES}
MAX_DEVICES = ('MxDeviceInstrument', 'MxDeviceAudioEffect', 'MxDeviceMidiEffect')

def device_parameters_to_map(device):
    return tuple(device.parameters[1:])


def parameter_bank_names(device, bank_name_dict = BANK_NAME_DICT):
    """ Determine the bank names to use for a device """
    if device != None:
        if device.class_name in bank_name_dict.keys():
            return bank_name_dict[device.class_name]
        else:
            banks = number_of_parameter_banks(device)

            def _default_bank_name(bank_index):
                return 'Bank ' + str(bank_index + 1)

            if device.class_name in MAX_DEVICES and banks != 0:

                def _is_ascii(c):
                    return ord(c) < 128

                def _bank_name(bank_index):
                    try:
                        name = device.get_bank_name(bank_index)
                    except:
                        name = None

                    if name:
                        return str(filter(_is_ascii, name))
                    else:
                        return _default_bank_name(bank_index)

                return map(_bank_name, range(0, banks))
            else:
                return map(_default_bank_name, range(0, banks))
    return []


def parameter_banks(device, device_dict = DEVICE_DICT):
    """ Determine the parameters to use for a device """
    if device != None:
        if device.class_name in device_dict.keys():

            def names_to_params(bank):
                return map(partial(get_parameter_by_name, device), bank)

            return map(names_to_params, device_dict[device.class_name])
        else:
            if device.class_name in MAX_DEVICES:
                try:
                    banks = device.get_bank_count()
                except:
                    banks = 0

                if banks != 0:

                    def _bank_parameters(bank_index):
                        try:
                            parameter_indices = device.get_bank_parameters(bank_index)
                        except:
                            parameter_indices = []

                        if len(parameter_indices) != 8:
                            return [ None for i in range(0, 8) ]
                        else:
                            return [ (device.parameters[i] if i != -1 else None) for i in parameter_indices ]

                    return map(_bank_parameters, range(0, banks))
            return group(device_parameters_to_map(device), 8)
    return []


def best_of_parameter_bank(device, device_bob_dict = DEVICE_BOB_DICT):
    bobs = device and device.class_name in device_bob_dict and device_bob_dict[device.class_name]
    if not len(bobs) == 1:
        raise AssertionError
        return map(partial(get_parameter_by_name, device), bobs[0])
    if device.class_name in MAX_DEVICES:
        try:
            parameter_indices = device.get_bank_parameters(-1)
            return [ (device.parameters[i] if i != -1 else None) for i in parameter_indices ]
        except:
            return []

    return []


def number_of_parameter_banks(device, device_dict = DEVICE_DICT):
    """ Determine the amount of parameter banks the given device has """
    if device != None:
        if device.class_name in device_dict.keys():
            device_bank = device_dict[device.class_name]
            return len(device_bank)
        else:
            if device.class_name in MAX_DEVICES:
                try:
                    banks = device.get_bank_count()
                except:
                    banks = 0

                if banks != 0:
                    return banks
            param_count = len(device.parameters[1:])
            return param_count / 8 + (1 if param_count % 8 else 0)
    return 0


def get_parameter_by_name(device, name):
    """ Find the given device's parameter that belongs to the given name """
    for i in device.parameters:
        if i.original_name == name:
            return i
########NEW FILE########
__FILENAME__ = GenericScript
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Generic/GenericScript.py
from __future__ import with_statement
import Live
from _Framework.ControlSurface import ControlSurface
from _Framework.DeviceComponent import DeviceComponent
from _Framework.TransportComponent import TransportComponent
from _Framework.InputControlElement import *
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import EncoderElement
from SpecialMixerComponent import SpecialMixerComponent

class GenericScript(ControlSurface):
    """ A generic script class with predefined behaviour.
        It can be customised to use/not use certain controls on instantiation.
    """

    def __init__(self, c_instance, macro_map_mode, volume_map_mode, device_controls, transport_controls, volume_controls, trackarm_controls, bank_controls, descriptions = None, mixer_options = None):
        ControlSurface.__init__(self, c_instance)
        with self.component_guard():
            global_channel = 0
            if descriptions:
                if list(descriptions.keys()).count('INPUTPORT') > 0:
                    self._suggested_input_port = descriptions['INPUTPORT']
                if list(descriptions.keys()).count('OUTPUTPORT') > 0:
                    self._suggested_output_port = descriptions['OUTPUTPORT']
                if list(descriptions.keys()).count('CHANNEL') > 0:
                    global_channel = descriptions['CHANNEL']
                    if global_channel not in range(16):
                        global_channel = 0
                if list(descriptions.keys()).count('PAD_TRANSLATION') > 0:
                    self.set_pad_translations(descriptions['PAD_TRANSLATION'])
            self._init_mixer_component(volume_controls, trackarm_controls, mixer_options, global_channel, volume_map_mode)
            self._init_device_component(device_controls, bank_controls, global_channel, macro_map_mode)
            self._init_transport_component(transport_controls, global_channel)

    def handle_sysex(self, midi_bytes):
        pass

    def _init_mixer_component(self, volume_controls, trackarm_controls, mixer_options, global_channel, volume_map_mode):
        if volume_controls != None and trackarm_controls != None:
            num_strips = max(len(volume_controls), len(trackarm_controls))
            send_info = []
            momentary_buttons = False
            mixer = SpecialMixerComponent(num_strips)
            mixer.name = 'Mixer'
            mixer.master_strip().name = 'Master_Channel_Strip'
            mixer.selected_strip().name = 'Selected_Channel_Strip'
            if mixer_options != None:
                if 'MASTERVOLUME' in mixer_options.keys() and mixer_options['MASTERVOLUME'] in range(128):
                    encoder = EncoderElement(MIDI_CC_TYPE, global_channel, mixer_options['MASTERVOLUME'], volume_map_mode)
                    encoder.name = 'Master_Volume_Control'
                    mixer.master_strip().set_volume_control(encoder)
                if 'NUMSENDS' in mixer_options.keys() and mixer_options['NUMSENDS'] > 0:
                    for send in range(mixer_options['NUMSENDS']):
                        key = 'SEND' + str(send + 1)
                        raise key in mixer_options.keys() or AssertionError
                        send_info.append(mixer_options[key])

                momentary_buttons = 'NOTOGGLE' in mixer_options.keys()
                next_bank_button = None
                prev_bank_button = None
                if 'NEXTBANK' in mixer_options.keys() and mixer_options['NEXTBANK'] in range(128):
                    next_bank_button = ButtonElement(momentary_buttons, MIDI_CC_TYPE, global_channel, mixer_options['NEXTBANK'])
                    next_bank_button.name = 'Mixer_Next_Bank_Button'
                if 'PREVBANK' in mixer_options.keys() and mixer_options['PREVBANK'] in range(128):
                    prev_bank_button = ButtonElement(momentary_buttons, MIDI_CC_TYPE, global_channel, mixer_options['PREVBANK'])
                    prev_bank_button.name = 'Mixer_Previous_Bank_Button'
                mixer.set_bank_buttons(next_bank_button, prev_bank_button)
            for track in range(num_strips):
                strip = mixer.channel_strip(track)
                strip.name = 'Channel_Strip_' + str(track)
                if track in range(len(volume_controls)):
                    channel = global_channel
                    cc = volume_controls[track]
                    if isinstance(volume_controls[track], (tuple, list)):
                        cc = volume_controls[track][0]
                        if volume_controls[track][1] in range(16):
                            channel = volume_controls[track][1]
                    if cc in range(128) and channel in range(16):
                        encoder = EncoderElement(MIDI_CC_TYPE, channel, cc, volume_map_mode)
                        encoder.name = str(track) + '_Volume_Control'
                        strip.set_volume_control(encoder)
                if track in range(len(trackarm_controls)) and trackarm_controls[track] in range(128):
                    button = ButtonElement(momentary_buttons, MIDI_CC_TYPE, global_channel, trackarm_controls[track])
                    button.name = str(track) + '_Arm_Button'
                    strip.set_arm_button(button)
                send_controls = []
                for send in send_info:
                    encoder = None
                    if track in range(len(send)):
                        channel = global_channel
                        cc = send[track]
                        if isinstance(send[track], (tuple, list)):
                            cc = send[track][0]
                            if send[track][1] in range(16):
                                channel = send[track][1]
                        if cc in range(128) and channel in range(16):
                            encoder = EncoderElement(MIDI_CC_TYPE, channel, cc, volume_map_mode)
                            encoder.name = str(track) + '_Send_' + str(list(send_info).index(send)) + '_Control'
                    send_controls.append(encoder)

                strip.set_send_controls(tuple(send_controls))

    def _init_device_component(self, device_controls, bank_controls, global_channel, macro_map_mode):
        is_momentary = True
        if device_controls:
            device = DeviceComponent()
            device.name = 'Device_Component'
            if bank_controls:
                next_button = None
                prev_button = None
                if 'NEXTBANK' in bank_controls.keys() and bank_controls['NEXTBANK'] in range(128):
                    next_button = ButtonElement(is_momentary, MIDI_CC_TYPE, global_channel, bank_controls['NEXTBANK'])
                    next_button.name = 'Device_Next_Bank_Button'
                if 'PREVBANK' in bank_controls.keys() and bank_controls['PREVBANK'] in range(128):
                    prev_button = ButtonElement(is_momentary, MIDI_CC_TYPE, global_channel, bank_controls['PREVBANK'])
                    prev_button.name = 'Device_Previous_Bank_Button'
                device.set_bank_nav_buttons(prev_button, next_button)
                if 'TOGGLELOCK' in bank_controls.keys() and bank_controls['TOGGLELOCK'] in range(128):
                    lock_button = ButtonElement(is_momentary, MIDI_CC_TYPE, global_channel, bank_controls['TOGGLELOCK'])
                    lock_button.name = 'Device_Lock_Button'
                    device.set_lock_button(lock_button)
                bank_buttons = []
                for index in range(8):
                    key = 'BANK' + str(index + 1)
                    if key in bank_controls.keys():
                        control_info = bank_controls[key]
                        channel = global_channel
                        cc = -1
                        if isinstance(control_info, (tuple, list)):
                            cc = control_info[0]
                            if control_info[1] in range(16):
                                channel = control_info[1]
                        else:
                            cc = control_info
                        if cc in range(128) and channel in range(16):
                            button = ButtonElement(is_momentary, MIDI_CC_TYPE, channel, cc)
                            button.name = 'Device_Bank_' + str(index) + '_Button'
                            bank_buttons.append(button)

                if len(bank_buttons) > 0:
                    device.set_bank_buttons(tuple(bank_buttons))
            parameter_encoders = []
            for control_info in device_controls:
                channel = global_channel
                cc = -1
                if isinstance(control_info, (tuple, list)):
                    cc = control_info[0]
                    if control_info[1] in range(16):
                        channel = control_info[1]
                else:
                    cc = control_info
                if cc in range(128) and channel in range(16):
                    encoder = EncoderElement(MIDI_CC_TYPE, channel, cc, macro_map_mode)
                    encoder.name = 'Device_Parameter_' + str(list(device_controls).index(control_info)) + '_Control'
                    parameter_encoders.append(encoder)

            if len(parameter_encoders) > 0:
                device.set_parameter_controls(tuple(parameter_encoders))
            self.set_device_component(device)

    def _init_transport_component(self, transport_controls, global_channel):
        is_momentary = True
        if transport_controls:
            transport = TransportComponent()
            transport.name = 'Transport'
            if 'STOP' in transport_controls.keys() and transport_controls['STOP'] in range(128):
                stop_button = ButtonElement(is_momentary, MIDI_CC_TYPE, global_channel, transport_controls['STOP'])
                stop_button.name = 'Stop_Button'
                transport.set_stop_button(stop_button)
            if 'PLAY' in transport_controls.keys() and transport_controls['PLAY'] in range(128):
                play_button = ButtonElement(is_momentary, MIDI_CC_TYPE, global_channel, transport_controls['PLAY'])
                play_button.name = 'Play_Button'
                transport.set_play_button(play_button)
            if 'REC' in transport_controls.keys() and transport_controls['REC'] in range(128):
                rec_button = ButtonElement(is_momentary, MIDI_CC_TYPE, global_channel, transport_controls['REC'])
                rec_button.name = 'Record_Button'
                transport.set_record_button(rec_button)
            if 'LOOP' in transport_controls.keys() and transport_controls['LOOP'] in range(128):
                loop_button = ButtonElement(is_momentary, MIDI_CC_TYPE, global_channel, transport_controls['LOOP'])
                loop_button.name = 'Loop_Button'
                transport.set_loop_button(loop_button)
            ffwd_button = None
            rwd_button = None
            momentary_seek = 'NORELEASE' not in transport_controls.keys()
            if 'FFWD' in transport_controls.keys() and transport_controls['FFWD'] in range(128):
                ffwd_button = ButtonElement(momentary_seek, MIDI_CC_TYPE, global_channel, transport_controls['FFWD'])
                ffwd_button.name = 'FFwd_Button'
            if 'RWD' in transport_controls.keys() and transport_controls['RWD'] in range(128):
                rwd_button = ButtonElement(momentary_seek, MIDI_CC_TYPE, global_channel, transport_controls['RWD'])
                rwd_button.name = 'Rwd_Button'
            transport.set_seek_buttons(ffwd_button, rwd_button)
########NEW FILE########
__FILENAME__ = SelectChanStripComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Generic/SelectChanStripComponent.py
import Live
from _Framework.ChannelStripComponent import ChannelStripComponent

class SelectChanStripComponent(ChannelStripComponent):
    """ Subclass of channel strip component that selects tracks that it arms """

    def __init__(self):
        ChannelStripComponent.__init__(self)

    def _arm_value(self, value):
        if not self._arm_button != None:
            raise AssertionError
            if not value in range(128):
                raise AssertionError
                if self.is_enabled():
                    track_was_armed = False
                    if self._track != None and self._track.can_be_armed:
                        track_was_armed = self._track.arm
                    ChannelStripComponent._arm_value(self, value)
                    if self._track != None and self._track.can_be_armed:
                        self.song().view.selected_track = self._track.arm and not track_was_armed and self._track.view.select_instrument() and self._track
########NEW FILE########
__FILENAME__ = SpecialMixerComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Generic/SpecialMixerComponent.py
import Live
from _Framework.MixerComponent import MixerComponent
from SelectChanStripComponent import SelectChanStripComponent

class SpecialMixerComponent(MixerComponent):
    """ Class encompassing several selecting channel strips to form a mixer """

    def __init__(self, num_tracks, num_returns = 0, with_eqs = False, with_filters = False):
        MixerComponent.__init__(self, num_tracks, num_returns, with_eqs, with_filters)

    def _create_strip(self):
        return SelectChanStripComponent()
########NEW FILE########
__FILENAME__ = LomTypes
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_MxDCore/LomTypes.py
import Live
from _Tools import types
from _Framework.ControlSurface import ControlSurface
from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
from _Framework.ControlElement import ControlElement
from _Framework.Util import is_iterable
HIDDEN_TYPES = (Live.Browser.Browser, Live.Clip.AutomationEnvelope)
HIDDEN_PROPERTIES = ('begin_undo_step', 'end_undo_step', 'begin_gesture', 'end_gesture', 'automation_envelope')
ENUM_TYPES = (Live.Song.Quantization,
 Live.Song.RecordingQuantization,
 Live.Song.CaptureMode,
 Live.Clip.GridQuantization,
 Live.DeviceParameter.AutomationState)
TUPLE_TYPES = {'tracks': Live.Track.Track,
 'visible_tracks': Live.Track.Track,
 'return_tracks': Live.Track.Track,
 'clip_slots': Live.ClipSlot.ClipSlot,
 'scenes': Live.Scene.Scene,
 'parameters': Live.DeviceParameter.DeviceParameter,
 'sends': Live.DeviceParameter.DeviceParameter,
 'devices': Live.Device.Device,
 'cue_points': Live.Song.CuePoint,
 'chains': Live.Chain.Chain,
 'return_chains': Live.Chain.Chain,
 'drum_pads': Live.DrumPad.DrumPad,
 'visible_drum_pads': Live.DrumPad.DrumPad,
 'control_surfaces': ControlSurface,
 'components': ControlSurfaceComponent,
 'controls': ControlElement}
PROPERTY_TYPES = {'master_track': Live.Track.Track,
 'selected_track': Live.Track.Track,
 'selected_scene': Live.Scene.Scene,
 'volume': Live.DeviceParameter.DeviceParameter,
 'panning': Live.DeviceParameter.DeviceParameter,
 'crossfader': Live.DeviceParameter.DeviceParameter,
 'song_tempo': Live.DeviceParameter.DeviceParameter,
 'cue_volume': Live.DeviceParameter.DeviceParameter,
 'track_activator': Live.DeviceParameter.DeviceParameter,
 'chain_activator': Live.DeviceParameter.DeviceParameter,
 'clip': Live.Clip.Clip,
 'detail_clip': Live.Clip.Clip,
 'highlighted_clip_slot': Live.ClipSlot.ClipSlot,
 'selected_device': Live.Device.Device,
 'selected_parameter': Live.DeviceParameter.DeviceParameter,
 'selected_chain': Live.Chain.Chain,
 'selected_drum_pad': Live.DrumPad.DrumPad,
 'mixer_device': (Live.MixerDevice.MixerDevice, Live.ChainMixerDevice.ChainMixerDevice),
 'view': (Live.Application.Application.View,
          Live.Song.Song.View,
          Live.Track.Track.View,
          Live.Device.Device.View,
          Live.Clip.Clip.View)}
LIVE_APP = 'live_app'
LIVE_SET = 'live_set'
CONTROL_SURFACES = 'control_surfaces'
THIS_DEVICE = 'this_device'
ROOT_KEYS = (THIS_DEVICE,
 CONTROL_SURFACES,
 LIVE_APP,
 LIVE_SET)

class LomAttributeError(AttributeError):
    pass


class LomObjectError(AttributeError):
    pass


class LomNoteOperationWarning(Exception):
    pass


class LomNoteOperationError(AttributeError):
    pass


def is_class(class_object):
    return isinstance(class_object, types.ClassType) or hasattr(class_object, '__bases__')


def get_control_surfaces():
    result = []
    cs_list_key = 'control_surfaces'
    if isinstance(__builtins__, dict):
        if cs_list_key in __builtins__.keys():
            result = __builtins__[cs_list_key]
    elif hasattr(__builtins__, cs_list_key):
        result = getattr(__builtins__, cs_list_key)
    return tuple(result)


def get_root_prop(external_device, prop_key):
    root_properties = {LIVE_APP: Live.Application.get_application,
     LIVE_SET: lambda : Live.Application.get_application().get_document(),
     CONTROL_SURFACES: get_control_surfaces}
    raise prop_key in ROOT_KEYS or AssertionError
    return external_device if prop_key == THIS_DEVICE else root_properties[prop_key]()


def cs_base_classes():
    from _Framework.ControlSurface import ControlSurface
    from _Framework.ControlSurfaceComponent import ControlSurfaceComponent
    from _Framework.ControlElement import ControlElement
    return (ControlSurface, ControlSurfaceComponent, ControlElement)


def is_lom_object(lom_object, lom_classes):
    return isinstance(lom_object, tuple(lom_classes) + (type(None),)) or isinstance(lom_object, cs_base_classes()) or isinstance(lom_object, Live.Base.Vector)


def is_cplusplus_lom_object(lom_object):
    return isinstance(lom_object, Live.LomObject.LomObject)


def is_object_iterable(obj):
    return not isinstance(obj, basestring) and is_iterable(obj) and not isinstance(obj, cs_base_classes())


def verify_object_property(lom_object, property_name):
    if not hasattr(lom_object, property_name) or property_name in HIDDEN_PROPERTIES:
        raise LomAttributeError("'%s' object has no attribute '%s'" % (lom_object.__class__.__name__, property_name))
########NEW FILE########
__FILENAME__ = LomUtils
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_MxDCore/LomUtils.py
import sys
from _Tools import types
from MxDUtils import TupleWrapper
from LomTypes import TUPLE_TYPES, PROPERTY_TYPES, ENUM_TYPES, ROOT_KEYS, HIDDEN_TYPES, HIDDEN_PROPERTIES, LomObjectError, LomAttributeError, is_class, get_root_prop, is_lom_object, is_cplusplus_lom_object, is_object_iterable

class LomInformation(object):
    """ Class that extracts information from a given LOM object """

    def __init__(self, lom_object, *a, **k):
        super(LomInformation, self).__init__(*a, **k)
        self._lists_of_children = []
        self._children = []
        self._functions = []
        self._properties = []
        self._description = ''
        self._generate_object_info(lom_object)

    @property
    def description(self):
        return self._description

    @property
    def lists_of_children(self):
        return tuple(self._lists_of_children)

    @property
    def children(self):
        return tuple(self._children)

    @property
    def functions(self):
        return tuple(self._functions)

    @property
    def properties(self):
        return tuple(self._properties)

    def _generate_object_info(self, lom_object):
        if hasattr(lom_object, '__doc__') and isinstance(lom_object.__doc__, basestring) and len(lom_object.__doc__) > 0:
            self._description = 'description %s' % lom_object.__doc__.replace('\n', ' ').replace(',', '\\,')
        for prop_name in dir(lom_object):
            if not prop_name.startswith('_') and prop_name not in HIDDEN_PROPERTIES:
                self._generate_property_info(prop_name, lom_object)

    def _generate_property_info(self, prop_name, lom_object):
        try:
            real_prop = getattr(lom_object, prop_name)
            if not isinstance(real_prop, HIDDEN_TYPES) and not is_class(real_prop):
                prop_type = real_prop.__class__.__name__
                if prop_name in TUPLE_TYPES:
                    type_name = TUPLE_TYPES[prop_name].__name__
                    self._lists_of_children.append((prop_name, type_name))
                elif prop_name in PROPERTY_TYPES.keys():
                    type_name = (real_prop.__class__ if real_prop != None else PROPERTY_TYPES[prop_name]).__name__
                    self._children.append((prop_name, type_name))
                elif prop_name == 'canonical_parent':
                    if real_prop != None:
                        self._children.append((prop_name, prop_type))
                elif callable(real_prop):
                    if not prop_name.endswith('_listener'):
                        self._functions.append((prop_name,))
                elif prop_type not in ('type', 'Enum'):
                    info_type = 'int' if isinstance(real_prop, ENUM_TYPES) else prop_type
                    self._properties.append((prop_name, info_type))
        except (AssertionError, RuntimeError):
            pass


class LomIntrospection(object):

    def __init__(self, directory, exclude = [], *a, **k):
        super(LomIntrospection, self).__init__(*a, **k)
        self._lom_classes = []
        self._lom_modules = []
        self._excluded = exclude
        self._create_introspection_for_dir(directory)

    @property
    def lom_classes(self):
        return self._lom_classes

    def _is_relevant_class(self, class_object):
        return is_class(class_object) and hasattr(class_object, '__module__') and sys.modules.get(class_object.__module__) in self._lom_modules and class_object not in self._lom_classes and class_object not in self._excluded

    def _process_class(self, class_object):
        processed = False
        if self._is_relevant_class(class_object):
            self._lom_classes.append(class_object)
            processed = True
        return processed

    def _is_relevant_module(self, module_object):
        return isinstance(module_object, types.ModuleType) and module_object not in self._lom_modules

    def _process_module(self, module_object):
        processed = False
        if self._is_relevant_module(module_object):
            self._lom_modules.append(module_object)
            processed = True
        return processed

    def _create_introspection_for_module_or_class(self, attribute):
        self._process_class(attribute)
        for sub_attr_name in dir(attribute):
            try:
                sub_attribute = getattr(attribute, sub_attr_name)
                if self._process_class(sub_attribute):
                    for sub_sub_attr_name in dir(sub_attribute):
                        try:
                            self._process_class(getattr(sub_attribute, sub_sub_attr_name))
                        except:
                            pass

            except:
                pass

    def _create_introspection_for_dir(self, directory):
        for attr_name in list(dir(directory)):
            try:
                attribute = getattr(directory, attr_name)
                if attribute not in self._excluded:
                    if self._process_module(attribute) or is_class(attribute):
                        self._create_introspection_for_module_or_class(attribute)
            except:
                pass


class LomPathCalculator(object):

    def __init__(self, lom_object, external_device, *a, **k):
        super(LomPathCalculator, self).__init__(*a, **k)
        self._path_components = self._calculate_path(lom_object, external_device)

    @property
    def path_components(self):
        return self._path_components

    def _find_root_object_path(self, external_device, lom_object):
        component = None
        for key in ROOT_KEYS:
            root_prop = get_root_prop(external_device, key)
            if not is_object_iterable(root_prop):
                if lom_object == root_prop:
                    component = key
                    break
            elif lom_object in root_prop:
                index = list(root_prop).index(lom_object)
                component = u'%s %d' % (key, index)
                break

        return component

    def _find_property_object_path(self, lom_object, parent):
        component = None
        for key in PROPERTY_TYPES.keys():
            if isinstance(lom_object, PROPERTY_TYPES[key]):
                if hasattr(parent, key):
                    component = lom_object == getattr(parent, key) and key
                    break

        return component

    def _find_tuple_element_object_path(self, lom_object, parent):
        component = None
        for key in sorted(list(TUPLE_TYPES.keys())):
            if hasattr(parent, key):
                property = getattr(parent, key)
                if lom_object in property:
                    index = list(property).index(lom_object)
                    component = u'%s %d' % (key, index)
                    break

        return component

    def _prepend_path_component(self, component, components):
        return [component] + components if component != None else []

    def _calculate_path(self, lom_object, external_device_getter):
        components = []
        while lom_object != None:
            component = None
            parent = lom_object.canonical_parent
            if parent != None:
                component = self._find_property_object_path(lom_object, parent) or self._find_tuple_element_object_path(lom_object, parent)
                components = self._prepend_path_component(component, components)
                if components == []:
                    break
            else:
                component = self._find_root_object_path(external_device_getter, lom_object)
                components = self._prepend_path_component(component, components)
                break
            lom_object = parent

        return components


class LomPathResolver(object):

    def __init__(self, path_components, external_device, lom_classes, list_manager, *a, **k):
        super(LomPathResolver, self).__init__(*a, **k)
        self._external_device = external_device
        self._lom_classes = lom_classes
        self._list_manager = list_manager
        self._lom_object = self._calculate_object_from_path(path_components)

    @property
    def lom_object(self):
        return self._lom_object

    def _tuple_element_from_path(self, path_components):
        lom_object = None
        parent = None
        attribute = path_components[-1]
        if len(path_components) > 1:
            parent = self._calculate_object_from_path(path_components[:-1])
        if not (attribute in ('cs', 'control_surfaces') and parent == None):
            raise AssertionError
            lom_object = TupleWrapper.get_tuple_wrapper(parent, 'control_surfaces')
        elif parent != None and hasattr(parent, attribute):
            selector = self._list_manager.get_list_wrapper if is_cplusplus_lom_object(parent) else TupleWrapper.get_tuple_wrapper
            lom_object = selector(parent, attribute)
        return lom_object

    def _property_object_from_path(self, path_components):
        prev_component = path_components[0]
        lom_object = get_root_prop(self._external_device, path_components[0])
        for component in path_components[1:]:
            try:
                raise component.isdigit() and (is_object_iterable(lom_object) or AssertionError)
                if not prev_component in TUPLE_TYPES.keys():
                    raise AssertionError
                    lom_object = lom_object[int(component)]
                else:
                    lom_object = getattr(lom_object, component)
                    if isinstance(lom_object, HIDDEN_TYPES):
                        raise AttributeError
            except IndexError:
                raise LomAttributeError("invalid index of component '%s'" % prev_component)
            except AttributeError:
                raise LomAttributeError("invalid path component '%s'" % component)
            else:
                prev_component = component

        if not is_lom_object(lom_object, self._lom_classes):
            raise LomObjectError("component '%s' is not an object" % prev_component)
        return lom_object

    def _calculate_object_from_path(self, path_components):
        lom_object = None
        if not (len(path_components) > 0 and path_components[0] in ROOT_KEYS):
            raise AssertionError
            selector = self._tuple_element_from_path if path_components[-1] in TUPLE_TYPES.keys() else self._property_object_from_path
            lom_object = selector(path_components)
        return lom_object
########NEW FILE########
__FILENAME__ = MxDCore
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_MxDCore/MxDCore.py
import Live.Base
from functools import partial
import _Framework
from _Framework.Debug import debug_print
from MxDUtils import TupleWrapper, StringHandler
from LomUtils import LomInformation, LomIntrospection, LomPathCalculator, LomPathResolver
from LomTypes import ENUM_TYPES, PROPERTY_TYPES, CONTROL_SURFACES, ROOT_KEYS, LomNoteOperationWarning, LomNoteOperationError, LomAttributeError, LomObjectError, get_root_prop, is_lom_object, is_cplusplus_lom_object, is_object_iterable, verify_object_property

def get_current_max_device(device_id):
    raise MxDCore.instance != None and MxDCore.instance.manager != None or AssertionError
    return MxDCore.instance.manager.get_max_device(device_id)


PATH_KEY = 'CURRENT_PATH'
ID_KEY = 'CURRENT_LOM_ID'
TYPE_KEY = 'CURRENT_TYPE'
PROP_KEY = 'CURRENT_PROPERTY'
PROP_LISTENER_KEY = 'PROPERTY_LISTENER'
PATH_LISTENER_KEY = 'PATH_LISTENERS'
OPEN_OPERATIONS_KEY = 'OPEN_OPERATION'
NOTE_BUFFER_KEY = 'NOTE_BUFFER'
NOTE_OPERATION_KEY = 'NOTE_OPERATION'
NOTE_COUNT_KEY = 'NOTE_COUNT'
NOTE_REPLACE_KEY = 'NOTE_REPLACE'
NOTE_SET_KEY = 'NOTE_SET'
CONTAINS_CS_ID_KEY = 'CONTAINS_CS_ID_KEY'
LAST_SENT_ID_KEY = 'LAST_SENT_ID'

def concatenate_strings(string_list, string_format = '%s %s'):
    return unicode(reduce(lambda s1, s2: string_format % (s1, s2), string_list) if len(string_list) > 0 else '')


def parameter_to_bool(parameter):
    bool_value = False
    if isinstance(parameter, (int, type(False))):
        bool_value = parameter
    elif unicode(parameter) in (u'True', u'False'):
        bool_value = unicode(parameter) == u'True'
    return bool_value


def note_from_parameters(parameters):
    new_note = [parameters[0], parameters[1], parameters[2]]
    new_note.append(int(parameters[3]) if len(parameters) > 3 and isinstance(parameters[3], (int, float)) else 100)
    new_note.append(len(parameters) > 4 and parameter_to_bool(parameters[4]))
    return tuple(new_note)


class MxDCore(object):
    """ Central class for the Max-integration """
    instance = None

    def __init__(self):
        object.__init__(self)
        self.device_contexts = {}
        self.manager = None
        self.lom_classes = []
        self._call_handler = {'get_notes': self._object_get_notes_handler,
         'set_notes': self._object_set_notes_handler,
         'get_selected_notes': self._object_selected_notes_handler,
         'replace_selected_notes': self._object_replace_selected_notes_handler,
         'notes': self._object_notes_handler,
         'note': self._object_note_handler,
         'done': self._object_done_handler,
         'get_control_names': self._object_get_control_names_handler}
        excluded = (Live.Base, Live.Song.BeatTime, Live.Song.SmptTime) + ENUM_TYPES
        self.lom_classes += LomIntrospection(Live, exclude=excluded).lom_classes
        self.lom_classes += LomIntrospection(_Framework).lom_classes
        self.appointed_lom_ids = {0: None}

    def disconnect(self):
        for dev_id in self.device_contexts.keys():
            device_context = self.device_contexts[dev_id]
            if device_context[CONTAINS_CS_ID_KEY]:
                self.release_device_context(dev_id, -1, '')

        TupleWrapper.forget_tuple_wrapper_instances()
        self.manager.set_manager_callbacks(None, None, None, None)
        self.manager = None
        del self.appointed_lom_ids
        del self.lom_classes

    def set_manager(self, manager):
        self.manager = manager
        manager.set_manager_callbacks(self.update_observer_listener, self.install_observer_listener, self.uninstall_observer_listener, self.update_remote_timeable)

    def _get_lom_object_by_lom_id(self, referring_device_id, lom_id):
        if lom_id > 0:
            return self.manager.get_lom_object(referring_device_id, lom_id)
        return self.appointed_lom_ids[lom_id]

    def _lom_id_exists(self, referring_device_id, lom_id):
        if lom_id > 0:
            return self.manager.lom_id_exists(referring_device_id, lom_id)
        return lom_id in self.appointed_lom_ids

    def _get_lom_id_by_lom_object(self, lom_object):
        if is_cplusplus_lom_object(lom_object):
            return self.manager.get_lom_id(lom_object)
        for id, object in self.appointed_lom_ids.iteritems():
            if object == lom_object:
                return id

        id = -len(self.appointed_lom_ids)
        self.appointed_lom_ids[id] = lom_object
        return id

    def _get_lom_id_observers_and_remotes(self, lom_id):
        """returns a list of (device_id, object_id) tuples that observe the given lom_id"""
        raise lom_id != 0 or AssertionError
        observers = []
        remotes = []
        for device_id, device_context in self.device_contexts.iteritems():
            for object_id, _ in device_context.iteritems():
                if not isinstance(object_id, int):
                    continue
                type = self._get_current_type(device_id, object_id)
                if type == 'obs':
                    if self._get_current_lom_id(device_id, object_id) == int(lom_id):
                        observers.append((device_id, object_id))
                elif type == 'rmt':
                    if self._get_current_lom_id(device_id, object_id) == int(lom_id):
                        remotes.append((device_id, object_id))

        return (observers, remotes)

    def _get_object_path(self, device_id, lom_object):
        resolver = LomPathCalculator(lom_object, get_current_max_device(device_id))
        return concatenate_strings(resolver.path_components)

    def _is_integer(self, s):
        if s[0] in ('-', '+'):
            return s[1:].isdigit()
        return s.isdigit()

    def _set_current_lom_id(self, device_id, object_id, lom_id, type):
        """set the CURRENT_LOM_ID of obj/obs/rmt objects"""
        if not self.manager.set_current_lom_id(device_id, object_id, lom_id):
            self.device_contexts[device_id][object_id][ID_KEY] = lom_id
            self._set_current_type(device_id, object_id, type)
            if type == 'obs':
                self._observer_update_listener(device_id, object_id)
            elif type == 'rmt':
                self._remote_update_timeable(device_id, object_id, True)

    def _get_current_lom_id(self, device_id, object_id):
        """get the CURRENT_LOM_ID of obj/obs/rmt objects"""
        current_id = self.manager.get_current_lom_id(device_id, object_id)
        if current_id != 0:
            return current_id
        return self.device_contexts[device_id][object_id][ID_KEY]

    def _set_current_type(self, device_id, object_id, type):
        """set the CURRENT_TYPE of obj/obs/rmt objects"""
        if type == 'obj':
            old_type = self.device_contexts[device_id][object_id][TYPE_KEY]
            if old_type is None:
                self.device_contexts[device_id][object_id][TYPE_KEY] = type
        else:
            self.device_contexts[device_id][object_id][TYPE_KEY] = type

    def _get_current_type(self, device_id, object_id):
        """get the CURRENT_TYPE of obj/obs/rmt objects"""
        current_type = self.manager.get_type(device_id, object_id)
        if current_type != -1:
            return {0: 'obs',
             1: None,
             2: 'obj',
             3: 'obs',
             4: 'rmt'}[current_type]
        return self.device_contexts[device_id][object_id][TYPE_KEY]

    def _set_current_property(self, device_id, object_id, property_name):
        """set the name of the observed property"""
        if not self.manager.set_current_property(device_id, object_id, property_name):
            self.device_contexts[device_id][object_id][PROP_KEY] = property_name
            self._set_current_type(device_id, object_id, 'obs')
            self._observer_update_listener(device_id, object_id)

    def _get_current_property(self, device_id, object_id):
        """get the name of the observed property, or an empty string"""
        property_name = self.manager.get_current_property(device_id, object_id)
        if property_name != '':
            return property_name
        return self.device_contexts[device_id][object_id][PROP_KEY]

    def update_device_context(self, device_id, object_id):
        if device_id not in self.device_contexts.keys():
            self.device_contexts[device_id] = {CONTAINS_CS_ID_KEY: False}
        if object_id not in self.device_contexts[device_id].keys():
            self.device_contexts[device_id][object_id] = {PATH_KEY: [],
             ID_KEY: 0,
             TYPE_KEY: None,
             PROP_KEY: '',
             PROP_LISTENER_KEY: (None, None, None),
             PATH_LISTENER_KEY: {},
             OPEN_OPERATIONS_KEY: {},
             LAST_SENT_ID_KEY: None}

    def release_device_context(self, device_id, object_id, parameters):
        device_context = self.device_contexts[device_id]
        for key in device_context.keys():
            if isinstance(key, int):
                object_context = device_context[key]
                self._observer_uninstall_listener(device_id, key)
                if len(object_context[PATH_KEY]) > 0:
                    object_context[PATH_KEY] = []
                    self._install_path_listeners(device_id, key, self._path_listener_callback)

        del self.device_contexts[device_id]

    def prepare_control_surface_update(self, device_id, object_id, parameters):
        found_cs_references = False
        for dev_id in self.device_contexts.keys():
            device_context = self.device_contexts[dev_id]
            if device_context[CONTAINS_CS_ID_KEY]:
                found_cs_references = True
                self.release_device_context(dev_id, -1, parameters)
                self.manager.refresh_max_device(dev_id)

        if found_cs_references:
            TupleWrapper.forget_tuple_wrapper_instances()
            self.appointed_lom_ids = {0: None}

    def path_set_path(self, device_id, object_id, parameters):
        if not isinstance(parameters, (str, unicode)):
            raise AssertionError
            pure_path = parameters.strip().strip('"')
            path_components = pure_path.split(' ')
            len(pure_path) > 0 and path_components[0] not in ROOT_KEYS and self._raise(device_id, object_id, 'set path: invalid path')
        else:
            self.device_contexts[device_id][object_id][PATH_KEY] = []
            self.path_goto(device_id, object_id, parameters)

    def path_goto(self, device_id, object_id, parameters):
        raise isinstance(parameters, (str, unicode)) or AssertionError
        self._goto_path(device_id, object_id, parameters)
        device_context = self.device_contexts[device_id]
        object_context = device_context[object_id]
        result_object = self._object_from_path(device_id, object_id, object_context[PATH_KEY], must_exist=False)
        result_id = unicode(self._get_lom_id_by_lom_object(result_object))
        device_context[CONTAINS_CS_ID_KEY] |= CONTROL_SURFACES in object_context[PATH_KEY]
        result_path = unicode(concatenate_strings(object_context[PATH_KEY]))
        for msg_type, value in (('path_curr_path', result_path), ('path_orig_id', result_id), ('path_curr_id', result_id)):
            self.manager.send_message(device_id, object_id, msg_type, value)

        self._install_path_listeners(device_id, object_id, self._path_listener_callback)

    def path_get_id(self, device_id, object_id, parameters):
        device_context = self.device_contexts[device_id]
        object_context = device_context[object_id]
        lom_object = self._object_from_path(device_id, object_id, object_context[PATH_KEY], must_exist=False)
        result_id = unicode(self._get_lom_id_by_lom_object(lom_object))
        for msg_type, value in (('path_orig_id', result_id), ('path_curr_id', result_id)):
            self.manager.send_message(device_id, object_id, msg_type, value)

    def path_bang(self, device_id, object_id, parameters):
        self.path_get_id(device_id, object_id, parameters)

    def _get_path_and_object(self, device_id, object_id):
        device_context = self.device_contexts[device_id]
        object_context = device_context[object_id]
        current_path = object_context[PATH_KEY]
        current_object = self._object_from_path(device_id, object_id, current_path, must_exist=True)
        return (current_path, current_object)

    def _get_lom_object_properties(self, device_id, object_id, looking_for):
        current_path, current_object = self._get_path_and_object(device_id, object_id)
        if len(current_path) == 0:
            result = concatenate_strings(ROOT_KEYS)
        elif current_object != None:
            current_object = self._disambiguate_object(current_object)
            if is_object_iterable(current_object):
                result = '%d list elements, no %s' % (len(current_object), looking_for)
            else:
                lom_info = LomInformation(current_object)
                path_props = map(lambda info: info[0], lom_info.lists_of_children + lom_info.children)
                result = concatenate_strings(sorted(path_props))
        return result

    def path_get_props(self, device_id, object_id, parameters):
        result = self._get_lom_object_properties(device_id, object_id, 'properties') or 'No path properties'
        self.manager.send_message(device_id, object_id, 'path_props', result)

    def path_get_children(self, device_id, object_id, parameters):
        result = self._get_lom_object_properties(device_id, object_id, 'children') or 'No children'
        self.manager.send_message(device_id, object_id, 'path_children', result)

    def path_get_count(self, device_id, object_id, parameters):
        if not isinstance(parameters, (str, unicode)):
            raise AssertionError
            device_context = self.device_contexts[device_id]
            object_context = device_context[object_id]
            current_path = object_context[PATH_KEY]
            current_object = self._object_from_path(device_id, object_id, current_path, must_exist=True)
            property = None
            if len(current_path) == 0:
                if parameters in ROOT_KEYS:
                    property = get_root_prop(get_current_max_device(device_id), parameters)
            elif current_object != None:
                if hasattr(current_object, parameters):
                    property = getattr(current_object, parameters)
            count = property != None and unicode(len(property) if is_object_iterable(property) else -1)
            self.manager.send_message(device_id, object_id, 'path_count', concatenate_strings((parameters, count)))
        else:
            self._raise(device_id, object_id, 'getcount: invalid property name')

    def obj_set_id(self, device_id, object_id, parameter):
        if self._is_integer(parameter) and self._lom_id_exists(device_id, int(parameter)):
            self._set_current_lom_id(device_id, object_id, int(parameter), 'obj')
        else:
            self._raise(device_id, object_id, 'set id: invalid id')

    def obj_get_id(self, device_id, object_id, parameter):
        self.manager.send_message(device_id, object_id, 'obj_id', unicode(self._get_current_lom_id(device_id, object_id)))

    def obj_get_path(self, device_id, object_id, parameters):
        lom_object = self._get_current_lom_object(device_id, object_id)
        path = self._get_object_path(device_id, lom_object)
        if len(path) == 0 and lom_object != None:
            self._raise(device_id, object_id, 'get path: error calculating the path')
        else:
            self.manager.send_message(device_id, object_id, 'obj_path', unicode(path).strip())

    def obj_get_type(self, device_id, object_id, parameters):
        current_object = self._get_current_lom_object(device_id, object_id)
        object_type = 'unknown'
        if current_object != None:
            current_object = self._disambiguate_object(current_object)
            object_type = current_object.__class__.__name__
        self.manager.send_message(device_id, object_id, 'obj_type', unicode(object_type))

    def obj_get_info(self, device_id, object_id, parameters):
        current_object = self._get_current_lom_object(device_id, object_id)
        object_info = 'No object'
        if current_object != None:
            object_info = 'id %s\n' % unicode(self._get_lom_id_by_lom_object(current_object))
            current_object = self._disambiguate_object(current_object)
            lom_info = LomInformation(current_object)
            object_info += 'type %s\n' % unicode(current_object.__class__.__name__)
            object_info += '%s\n' % lom_info.description
            if not is_object_iterable(current_object):

                def accumulate_info(info_list, label):
                    result = ''
                    if len(info_list) > 0:
                        str_format = '%s %s %s\n' if len(info_list[0]) > 1 else '%s %s\n'
                        formatter = lambda info: str_format % ((label,) + info)
                        result = concatenate_strings(map(formatter, info_list), string_format='%s%s')
                    return result

                object_info += accumulate_info(lom_info.lists_of_children, 'children') + accumulate_info(lom_info.children, 'child') + accumulate_info(lom_info.properties, 'property') + accumulate_info(lom_info.functions, 'function')
            object_info += 'done'
        self.manager.send_message(device_id, object_id, 'obj_info', unicode(object_info))

    def obj_set_val(self, device_id, object_id, parameters):
        self.obj_set(device_id, object_id, parameters)

    def _set_property_value(self, lom_object, property_name, value):
        verify_object_property(lom_object, property_name)
        prop = getattr(lom_object, property_name)
        if property_name in PROPERTY_TYPES.keys():
            if not is_lom_object(value, self.lom_classes):
                raise LomAttributeError('set: no valid object id')
            if not isinstance(value, PROPERTY_TYPES[property_name]):
                raise LomAttributeError('set: type mismatch')
        elif isinstance(prop, (int, bool)):
            if unicode(value) in (u'True', u'False'):
                value = int(unicode(value) == u'True')
            elif not isinstance(value, int):
                raise LomAttributeError('set: invalid value')
        elif isinstance(prop, float):
            if not isinstance(value, (int, float)):
                raise LomAttributeError('set: type mismatch')
            value = float(value)
        elif isinstance(prop, (str, unicode)):
            if not isinstance(value, (str,
             unicode,
             int,
             float)):
                raise LomAttributeError('set: type mismatch')
            value = unicode(value)
        else:
            raise LomAttributeError('set: unsupported property type')
        setattr(lom_object, property_name, value)

    def obj_set(self, device_id, object_id, parameters):
        if not isinstance(parameters, (str, unicode)):
            raise AssertionError
            current_object = self._get_current_lom_object(device_id, object_id)
            parsed_params = current_object != None and self._parse(device_id, object_id, parameters)
            property_name = parsed_params[0]
            property_values = parsed_params[1:]
            value = property_values[0]
            try:
                self._set_property_value(current_object, property_name, value)
            except LomAttributeError as e:
                self._raise(device_id, object_id, e.message)

    def obj_get_val(self, device_id, object_id, parameters):
        self.obj_get(device_id, object_id, parameters)

    def obj_get(self, device_id, object_id, parameters):
        raise isinstance(parameters, (str, unicode)) or AssertionError
        current_object = self._get_current_lom_object(device_id, object_id)
        result_value = None
        if current_object != None:
            try:
                raise parameters.isdigit() and (is_object_iterable(current_object) or AssertionError)
                if not int(parameters) in range(len(current_object)):
                    raise AssertionError
                    result_value = current_object[int(parameters)]
                else:
                    verify_object_property(current_object, parameters)
                    result_value = getattr(current_object, parameters)
                    if isinstance(result_value, ENUM_TYPES):
                        result_value = int(result_value)
                result = self._str_representation_for_object(result_value)
                self.manager.send_message(device_id, object_id, 'obj_prop_val', result)
            except LomAttributeError as e:
                self._warn(device_id, object_id, e.message)

        else:
            self._warn(device_id, object_id, 'get: no valid object set')

    def obj_call(self, device_id, object_id, parameters):
        raise isinstance(parameters, (str, unicode)) or AssertionError
        current_object = self._get_current_lom_object(device_id, object_id)
        if current_object != None:
            try:
                param_comps = self._parse(device_id, object_id, parameters)
                func_name = str(param_comps[0])
                handler = self._call_handler[func_name] if func_name in self._call_handler.keys() else self._object_default_call_handler
                handler(device_id, object_id, current_object, param_comps)
            except AttributeError as e:
                self._raise(device_id, object_id, e.message)
            except RuntimeError as e:
                self._raise(device_id, object_id, u"%s: '%s'" % (e.message, parameters))
            except Exception as e:
                reason = 'Invalid ' + ('arguments' if isinstance(e, TypeError) else 'syntax')
                self._raise(device_id, object_id, u"%s: '%s'" % (reason, parameters))

        else:
            self._warn(device_id, object_id, u'call %s: no valid object set' % parameters)

    def obs_set_id(self, device_id, object_id, parameter):
        if self._is_integer(parameter) and self._lom_id_exists(device_id, int(parameter)):
            self.device_contexts[device_id][object_id][LAST_SENT_ID_KEY] = None
            self._set_current_lom_id(device_id, object_id, int(parameter), 'obs')
        else:
            self._raise(device_id, object_id, 'set id: invalid id')

    def obs_get_id(self, device_id, object_id, parameter):
        self.manager.send_message(device_id, object_id, 'obs_id', unicode(self._get_current_lom_id(device_id, object_id)))

    def obs_set_prop(self, device_id, object_id, parameter):
        raise isinstance(parameter, (str, unicode)) or AssertionError
        self._set_current_property(device_id, object_id, parameter)

    def obs_get_prop(self, device_id, object_id, parameter):
        self.manager.send_message(device_id, object_id, 'obs_prop', unicode(self._get_current_property(device_id, object_id)))

    def obs_get_type(self, device_id, object_id, parameter):
        current_object = self._get_current_lom_object(device_id, object_id)
        property_name = self._get_current_property(device_id, object_id)
        result = 'unknown'
        if current_object != None and property_name != '':
            if hasattr(current_object, property_name):
                result = getattr(current_object, property_name).__class__.__name__
            else:
                self._warn(device_id, object_id, 'gettype: no property with the name ' + property_name)
        self.manager.send_message(device_id, object_id, 'obs_type', unicode(result))

    def obs_bang(self, device_id, object_id, parameter):
        self._observer_property_callback(device_id, object_id)

    def rmt_set_id(self, device_id, object_id, parameter):
        if self._is_integer(parameter) and self._lom_id_exists(device_id, int(parameter)):
            new_id = int(parameter)
            lom_object = self._get_lom_object_by_lom_id(device_id, new_id)
            if isinstance(lom_object, (Live.DeviceParameter.DeviceParameter, type(None))):
                self._set_current_lom_id(device_id, object_id, new_id, 'rmt')
            else:
                self._raise(device_id, object_id, 'set id: only accepts objects of type DeviceParameter')
        else:
            self._raise(device_id, object_id, 'set id: invalid id')

    def _object_attr_path_iter(self, device_id, object_id, path_components):
        """Returns a generator of (object, attribute) tuples along the given path.
        It won't pack objects into a TupleWrapper."""
        if len(path_components) == 0:
            return
        raise path_components[0] in ROOT_KEYS or AssertionError
        cur_object = get_root_prop(get_current_max_device(device_id), path_components[0])
        for component in path_components[1:]:
            if cur_object == None:
                return
            yield (cur_object, component)
            if not (component.isdigit() and is_object_iterable(cur_object)):
                raise AssertionError
                index = int(component)
                if index >= 0 and index < len(cur_object):
                    cur_object = cur_object[index]
                else:
                    return
            else:
                try:
                    cur_object = getattr(cur_object, component)
                except Exception:
                    return

    def _object_from_path(self, device_id, object_id, path_components, must_exist):
        lom_object = None
        try:
            resolver = LomPathResolver(path_components, get_current_max_device(device_id), self.lom_classes, self.manager)
            lom_object = resolver.lom_object
        except (LomAttributeError, LomObjectError) as e:
            if must_exist or isinstance(e, LomObjectError):
                self._raise(device_id, object_id, e.message)

        return lom_object

    def _get_current_lom_object(self, device_id, object_id):
        """retrieving current lom object for object_ids of type obj/obs/rmt"""
        return self._get_lom_object_by_lom_id(device_id, self._get_current_lom_id(device_id, object_id))

    def _object_for_id(self, device_id):
        lom_object = None
        try:
            lom_object = partial(self._get_lom_object_by_lom_id, device_id)
        except:
            pass

        return lom_object

    def _str_representation_for_object(self, lom_object, mark_ids = True):
        result = ''
        lom_object = self._disambiguate_object(lom_object)
        if is_object_iterable(lom_object):
            result = concatenate_strings(map(self._str_representation_for_object, lom_object))
        elif is_lom_object(lom_object, self.lom_classes):
            result = ('id ' if mark_ids else '') + unicode(self._get_lom_id_by_lom_object(lom_object))
        elif isinstance(lom_object, (int, bool)):
            result = unicode(int(lom_object))
        else:
            result = StringHandler.prepare_outgoing(unicode(lom_object))
        return result

    def _install_path_listeners(self, device_id, object_id, listener_callback):
        device_context = self.device_contexts[device_id]
        object_context = device_context[object_id]
        path_components = object_context[PATH_KEY]
        new_listeners = {}
        self._uninstall_path_listeners(device_id, object_id)
        listener = partial(listener_callback, device_id, object_id)
        obj_attr_iter = self._object_attr_path_iter(device_id, object_id, path_components)
        for lom_object, attribute in obj_attr_iter:
            attribute = self._listenable_property_for(attribute)
            if not (lom_object != None and hasattr(lom_object, attribute + '_has_listener') and not getattr(lom_object, attribute + '_has_listener')(listener)):
                raise AssertionError
                getattr(lom_object, 'add_%s_listener' % attribute)(listener)
                new_listeners[lom_object, attribute] = listener

        object_context[PATH_LISTENER_KEY] = new_listeners

    def _uninstall_path_listeners(self, device_id, object_id):
        device_context = self.device_contexts[device_id]
        object_context = device_context[object_id]
        old_listeners = object_context[PATH_LISTENER_KEY]
        for (lom_object, attribute), listener in old_listeners.iteritems():
            if lom_object != None and getattr(lom_object, attribute + '_has_listener')(listener):
                getattr(lom_object, 'remove_%s_listener' % attribute)(listener)

    def _path_listener_callback(self, device_id, object_id):
        device_context = self.device_contexts[device_id]
        object_context = device_context[object_id]
        resulting_id = self._get_lom_id_by_lom_object(self._object_from_path(device_id, object_id, object_context[PATH_KEY], must_exist=False))
        self.manager.send_message(device_id, object_id, 'path_curr_id', unicode(resulting_id))
        self._install_path_listeners(device_id, object_id, self._path_listener_callback)

    def _goto_path(self, device_id, object_id, parameters):
        device_context = self.device_contexts[device_id]
        object_context = device_context[object_id]
        try:
            pure_path = parameters.strip().strip('"')
            path_components = []
            if len(pure_path) > 0:
                path_components = pure_path.strip().split(' ')
            for parameter in path_components:
                if parameter == 'up':
                    del object_context[PATH_KEY][-1]
                else:
                    if parameter in ROOT_KEYS:
                        object_context[PATH_KEY] = []
                    object_context[PATH_KEY].append(parameter)

        except:
            self._raise(device_id, object_id, 'goto: invalid path')
            return

    def _object_default_call_handler(self, device_id, object_id, lom_object, parameters):
        verify_object_property(lom_object, parameters[0])
        function = getattr(lom_object, parameters[0])
        result = function(*parameters[1:])
        result_str = self._str_representation_for_object(result)
        self.manager.send_message(device_id, object_id, 'obj_call_result', result_str)

    def _object_get_notes_handler(self, device_id, object_id, lom_object, parameters):
        raise isinstance(lom_object, Live.Clip.Clip) and lom_object.is_midi_clip or AssertionError
        raise parameters[0] == 'get_notes' or AssertionError
        notes = getattr(lom_object, 'get_notes')(parameters[1], parameters[2], parameters[3], parameters[4])
        self.manager.send_message(device_id, object_id, 'obj_call_result', self._create_notes_output(notes))

    def _object_selected_notes_handler(self, device_id, object_id, lom_object, parameters):
        raise isinstance(lom_object, Live.Clip.Clip) and lom_object.is_midi_clip or AssertionError
        notes = getattr(lom_object, 'get_selected_notes')()
        self.manager.send_message(device_id, object_id, 'obj_call_result', self._create_notes_output(notes))

    def _object_set_notes_handler(self, device_id, object_id, lom_object, parameters):
        self._start_note_operation(device_id, object_id, lom_object, parameters, NOTE_SET_KEY)

    def _object_replace_selected_notes_handler(self, device_id, object_id, lom_object, parameters):
        self._start_note_operation(device_id, object_id, lom_object, parameters, NOTE_REPLACE_KEY)

    def _object_notes_handler(self, device_id, object_id, lom_object, parameters):
        if not (isinstance(lom_object, Live.Clip.Clip) and lom_object.is_midi_clip):
            raise AssertionError
            raise isinstance(parameters[1], int) or AssertionError
            device_context = self.device_contexts[device_id][object_id]
            device_context[OPEN_OPERATIONS_KEY][NOTE_COUNT_KEY] = NOTE_OPERATION_KEY in device_context[OPEN_OPERATIONS_KEY].keys() and parameters[1]
        else:
            self._raise(device_id, object_id, 'no operation in progress')

    def _object_note_handler(self, device_id, object_id, lom_object, parameters):
        raise isinstance(lom_object, Live.Clip.Clip) and lom_object.is_midi_clip or AssertionError
        raise isinstance(parameters[1], (int, float)) or AssertionError
        raise isinstance(parameters[2], float) or AssertionError
        raise isinstance(parameters[3], float) or AssertionError
        device_context = self.device_contexts[device_id][object_id]
        operations = device_context[OPEN_OPERATIONS_KEY]
        try:
            if NOTE_OPERATION_KEY not in operations:
                raise LomNoteOperationError('no operation in progress')
            if NOTE_COUNT_KEY not in operations:
                raise LomNoteOperationError('no note count given')
            if not NOTE_BUFFER_KEY in operations:
                raise AssertionError
                raise len(operations[NOTE_BUFFER_KEY]) >= operations[NOTE_COUNT_KEY] and LomNoteOperationError('too many notes')
            operations[NOTE_BUFFER_KEY].append(note_from_parameters(parameters[1:]))
        except LomNoteOperationError as e:
            self._raise(device_id, object_id, e.message)
            self._stop_note_operation(device_id, object_id)

    def _selector_for_note_operation(self, note_operation):
        if note_operation not in (NOTE_REPLACE_KEY, NOTE_SET_KEY):
            raise LomNoteOperationWarning('invalid note operation')
        return 'set_notes' if note_operation == NOTE_SET_KEY else 'replace_selected_notes'

    def _object_done_handler(self, device_id, object_id, lom_object, parameters):
        if not (isinstance(lom_object, Live.Clip.Clip) and lom_object.is_midi_clip):
            raise AssertionError
            device_context = self.device_contexts[device_id][object_id]
            open_operations = device_context[OPEN_OPERATIONS_KEY]
            raise NOTE_OPERATION_KEY in open_operations and NOTE_COUNT_KEY in open_operations and (NOTE_BUFFER_KEY in open_operations or AssertionError)
            try:
                notes = tuple(open_operations[NOTE_BUFFER_KEY])
                if len(notes) != open_operations[NOTE_COUNT_KEY]:
                    raise LomNoteOperationWarning('wrong note count')
                operation = open_operations[NOTE_OPERATION_KEY]
                selector = self._selector_for_note_operation(operation)
                getattr(lom_object, selector)(notes)
            except LomNoteOperationWarning as w:
                self._warn(device_id, object_id, w.message)

            self._stop_note_operation(device_id, object_id)
        else:
            self._raise(device_id, object_id, 'no operation in progress')

    def _object_get_control_names_handler(self, device_id, object_id, lom_object, parameters):
        control_names = getattr(lom_object, 'get_control_names')()
        formatter = lambda name: 'control %s\n' % name
        result = 'control_names %d\n' % len(control_names) + concatenate_strings(map(formatter, control_names), string_format='%s%s') + 'done'
        self.manager.send_message(device_id, object_id, 'obj_call_result', result)

    def _create_notes_output(self, notes):
        element_format = lambda el: unicode(int(el) if isinstance(el, bool) else el)
        note_format = lambda note: u'note %s\n' % concatenate_strings(map(element_format, note))
        result = 'notes %d\n%sdone' % (len(notes), concatenate_strings(map(note_format, notes), string_format='%s%s'))
        return result

    def _start_note_operation(self, device_id, object_id, lom_object, parameters, operation):
        if not (isinstance(lom_object, Live.Clip.Clip) and lom_object.is_midi_clip):
            raise AssertionError
            device_context = self.device_contexts[device_id][object_id]
            raise NOTE_OPERATION_KEY not in device_context[OPEN_OPERATIONS_KEY].keys() and (NOTE_BUFFER_KEY not in device_context[OPEN_OPERATIONS_KEY].keys() or AssertionError)
            raise NOTE_BUFFER_KEY not in device_context[OPEN_OPERATIONS_KEY].keys() or AssertionError
            device_context[OPEN_OPERATIONS_KEY][NOTE_BUFFER_KEY] = []
            device_context[OPEN_OPERATIONS_KEY][NOTE_OPERATION_KEY] = operation
        else:
            self._raise(device_id, object_id, 'an operation is already in progress')

    def _stop_note_operation(self, device_id, object_id):
        device_context = self.device_contexts[device_id][object_id]
        for key in (NOTE_OPERATION_KEY, NOTE_BUFFER_KEY, NOTE_COUNT_KEY):
            try:
                del device_context[OPEN_OPERATIONS_KEY][key]
            except KeyError:
                pass

    def update_observer_listener(self, device_id, object_id):
        self.update_device_context(device_id, object_id)
        self._observer_update_listener(device_id, object_id)

    def install_observer_listener(self, device_id, object_id):
        self.update_device_context(device_id, object_id)
        self._observer_install_listener(device_id, object_id)

    def uninstall_observer_listener(self, device_id, object_id):
        self.update_device_context(device_id, object_id)
        self._observer_uninstall_listener(device_id, object_id)

    def update_lom_id_observers_and_remotes(self, lom_id):
        """updates observer and remote~ links for the given lom_id"""
        observers, remotes = self._get_lom_id_observers_and_remotes(lom_id)
        for device_id, object_id in observers:
            self._observer_update_listener(device_id, object_id)

        for device_id, object_id in remotes:
            self._remote_update_timeable(device_id, object_id, False)

    def _observer_update_listener(self, device_id, object_id):
        self._observer_uninstall_listener(device_id, object_id)
        self._observer_install_listener(device_id, object_id)

    def _observer_install_listener(self, device_id, object_id):
        if not self.device_contexts[device_id][object_id][PROP_LISTENER_KEY] == (None, None, None):
            raise AssertionError
            current_object = self._get_current_lom_object(device_id, object_id)
            property_name = self._get_current_property(device_id, object_id)
            property_name == u'id' and self._observer_id_callback(device_id, object_id)
        else:
            object_context = current_object != None and property_name != '' and self.device_contexts[device_id][object_id]
            listener_callback = partial(self._observer_property_callback, device_id, object_id)
            transl_prop_name = self._listenable_property_for(property_name)
            if hasattr(current_object, transl_prop_name + '_has_listener'):
                if not not getattr(current_object, transl_prop_name + '_has_listener')(listener_callback):
                    raise AssertionError
                    getattr(current_object, 'add_%s_listener' % transl_prop_name)(listener_callback)
                    object_context[PROP_LISTENER_KEY] = (listener_callback, current_object, property_name)
                    listener_callback()
                elif hasattr(current_object, transl_prop_name):
                    self._warn(device_id, object_id, 'property cannot be listened to')

    def _observer_uninstall_listener(self, device_id, object_id):
        device_context = self.device_contexts[device_id]
        object_context = device_context[object_id]
        self._uninstall_path_listeners(device_id, object_id)
        listener_callback, current_object, property_name = object_context[PROP_LISTENER_KEY]
        raise current_object != None and listener_callback != None and (property_name != '' or AssertionError)
        raise not isinstance(current_object, TupleWrapper) or AssertionError
        transl_prop_name = self._listenable_property_for(property_name)
        if not hasattr(current_object, transl_prop_name + '_has_listener'):
            raise AssertionError
            if getattr(current_object, transl_prop_name + '_has_listener')(listener_callback):
                getattr(current_object, 'remove_%s_listener' % transl_prop_name)(listener_callback)
        object_context[PROP_LISTENER_KEY] = (None, None, None)

    def _observer_property_message_type(self, prop):
        prop_type = None
        if isinstance(prop, (str, unicode)):
            prop_type = 'obs_string_val'
        elif isinstance(prop, (int, bool)):
            prop_type = 'obs_int_val'
        elif isinstance(prop, float):
            prop_type = 'obs_float_val'
        elif is_object_iterable(prop):
            prop_type = 'obs_list_val'
        elif is_lom_object(prop, self.lom_classes):
            prop_type = 'obs_id_val'
        return prop_type

    def _observer_property_callback(self, device_id, object_id, *args):
        current_object = self._get_current_lom_object(device_id, object_id)
        property_name = self._get_current_property(device_id, object_id)
        if len(args) > 0:
            formatter = lambda arg: unicode(int(arg) if isinstance(arg, bool) else arg)
            args_type = self._observer_property_message_type(args if len(args) > 1 else args[0])
            result = concatenate_strings(map(formatter, args))
            self.manager.send_message(device_id, object_id, args_type, result)
        elif not (current_object != None and property_name != '' and not isinstance(current_object, TupleWrapper)):
            raise AssertionError
            if hasattr(current_object, property_name):
                prop = getattr(current_object, property_name)
                prop_type = self._observer_property_message_type(prop)
                if prop_type == None:
                    self._warn(device_id, object_id, 'unsupported property type')
                else:
                    prop_value = self._str_representation_for_object(prop, mark_ids=False)
                    self.manager.send_message(device_id, object_id, prop_type, prop_value)
            elif hasattr(current_object, property_name + '_has_listener'):
                self.manager.send_message(device_id, object_id, 'obs_string_val', 'bang')
            else:
                self._warn(device_id, object_id, 'property should be listenable')

    def _observer_id_callback(self, device_id, object_id):
        if not self._get_current_property(device_id, object_id) == u'id':
            raise AssertionError
            object_context = self.device_contexts[device_id][object_id]
            current_object = self._get_current_lom_object(device_id, object_id)
            self._goto_path(device_id, object_id, self._get_object_path(device_id, current_object))
            self._install_path_listeners(device_id, object_id, self._observer_id_callback)
            current_id = 0 if current_object == None else self._get_current_lom_id(device_id, object_id)
            object_context[LAST_SENT_ID_KEY] = current_id != object_context[LAST_SENT_ID_KEY] and current_id
            self.manager.send_message(device_id, object_id, 'obs_id_val', unicode(current_id))

    def update_remote_timeable(self, device_id, object_id):
        self.update_device_context(device_id, object_id)
        self._remote_update_timeable(device_id, object_id, False)

    def reset_all_current_lom_ids(self, device_id):
        if device_id in self.device_contexts:
            device_context = self.device_contexts[device_id]
            for object_id, _ in device_context.iteritems():
                if isinstance(object_id, int):
                    type = self._get_current_type(device_id, object_id)
                    if type in ('obs', 'obj', 'rmt'):
                        self._set_current_lom_id(device_id, object_id, 0, type)

    def _remote_update_timeable(self, device_id, object_id, validate_change_allowed):
        current_object = self._get_current_lom_object(device_id, object_id)
        if isinstance(current_object, Live.DeviceParameter.DeviceParameter):
            self.manager.register_remote_timeable(device_id, object_id, current_object, validate_change_allowed)
        else:
            self.manager.unregister_remote_timeable(device_id, object_id, validate_change_allowed)

    def _disambiguate_object(self, object):
        result = object
        if object.__class__.__name__ in ('ListWrapper', 'TupleWrapper'):
            result = object.get_list()
        return result

    def _listenable_property_for(self, prop_name):
        return 'has_clip' if prop_name == 'clip' else prop_name

    def _parse(self, device_id, object_id, string):
        return StringHandler.parse(string, self._object_for_id(device_id))

    def _raise(self, device_id, object_id, message):
        debug_print('Error: ' + unicode(message))
        self.manager.print_message(device_id, object_id, 'error', unicode(message))

    def _warn(self, device_id, object_id, message):
        debug_print('Warning: ' + unicode(message))
        self.manager.print_message(device_id, object_id, 'warning', unicode(message))
########NEW FILE########
__FILENAME__ = MxDUtils
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_MxDCore/MxDUtils.py


class TupleWrapper(object):
    """ Wrapper class for the access to volatile lists and tuples in the Python API """
    _tuple_wrapper_registry = {}

    def forget_tuple_wrapper_instances():
        TupleWrapper._tuple_wrapper_registry = {}

    forget_tuple_wrapper_instances = staticmethod(forget_tuple_wrapper_instances)

    def get_tuple_wrapper(parent, attribute):
        if (parent, attribute) not in TupleWrapper._tuple_wrapper_registry:
            TupleWrapper._tuple_wrapper_registry[parent, attribute] = TupleWrapper(parent, attribute)
        return TupleWrapper._tuple_wrapper_registry[parent, attribute]

    get_tuple_wrapper = staticmethod(get_tuple_wrapper)

    def __init__(self, parent, attribute):
        raise isinstance(attribute, (str, unicode)) or AssertionError
        self._parent = parent
        self._attribute = attribute

    def get_list(self):
        result = ()
        parent = self._parent
        if parent == None:
            parent = __builtins__
        if isinstance(parent, dict):
            if self._attribute in parent.keys():
                result = parent[self._attribute]
        elif hasattr(parent, self._attribute):
            result = getattr(parent, self._attribute)
        return result


STATE_NEUTRAL = 'neutral'
STATE_QUOTED_STR = 'quoted'
STATE_UNQUOTED_STR = 'unquoted'
STATE_PENDING_NR = 'number'
STATE_PENDING_FLOAT = 'float'
QUOTE_ENTITY = u'&quot;'
QUOTE_SIMPLE = u'"'

class StringHandler(object):
    """ Class that can parse incoming strings and format outgoing strings """

    def prepare_incoming(string):
        raise isinstance(string, (str, unicode)) or AssertionError
        return string.replace(QUOTE_ENTITY, QUOTE_SIMPLE)

    prepare_incoming = staticmethod(prepare_incoming)

    def prepare_outgoing(string):
        if not isinstance(string, (str, unicode)):
            raise AssertionError
            result = string.replace(QUOTE_SIMPLE, QUOTE_ENTITY)
            result = result.find(' ') >= 0 and QUOTE_SIMPLE + result + QUOTE_SIMPLE
        return result

    prepare_outgoing = staticmethod(prepare_outgoing)

    def parse(string, id_callback):
        raise isinstance(string, (str, unicode)) or AssertionError
        return StringHandler(id_callback).parse_string(string)

    parse = staticmethod(parse)

    def __init__(self, id_callback):
        self._state = STATE_NEUTRAL
        self._sub_string = u''
        self._open_quote_index = -1
        self._id_callback = id_callback

    def parse_string(self, string):
        self._arguments = []
        self._sub_string = u''
        self._state = STATE_NEUTRAL
        self._open_quote_index = -1
        for index in range(len(string)):
            char = string[index]
            handle_selector = '_' + str(self._state) + '_handle_char'
            if hasattr(self, handle_selector):
                getattr(self, handle_selector)(char, index)
            else:
                debug_print('Unknown state ' + str(self._state))
                raise False or AssertionError

        finalize_selector = '_finalize_' + str(self._state)
        if len(self._sub_string) > 0 and hasattr(self, finalize_selector):
            getattr(self, finalize_selector)()
        return self._arguments

    def _neutral_handle_char(self, char, index):
        if char == '"':
            self._open_quote_index = index
            self._state = STATE_QUOTED_STR
        elif char != ' ':
            self._sub_string += char
            if unicode(char).isdigit():
                self._state = STATE_PENDING_NR
            else:
                self._state = STATE_UNQUOTED_STR

    def _number_handle_char(self, char, index):
        if char == ' ':
            if len(self._sub_string) > 0:
                self._finalize_number()
            else:
                self._state = STATE_NEUTRAL
        else:
            if char == '.':
                self._state = STATE_PENDING_FLOAT
            elif not unicode(char).isdigit():
                self._state = STATE_UNQUOTED_STR
            self._sub_string += char

    def _float_handle_char(self, char, index):
        if char == ' ':
            self._add_argument(float(self._sub_string))
        else:
            if char in ('.', 'e', 'E'):
                if char in self._sub_string:
                    self._state = STATE_UNQUOTED_STR
            elif not unicode(char).isdigit():
                self._state = STATE_UNQUOTED_STR
            self._sub_string += char

    def _unquoted_handle_char(self, char, index):
        if char == ' ':
            self._add_argument(self._sub_string)
        else:
            if unicode(char).isdigit():
                if self._sub_string == u'-':
                    self._state = STATE_PENDING_NR
                elif self._sub_string in (u'.', u'-.'):
                    self._state = STATE_PENDING_FLOAT
            self._sub_string += char

    def _quoted_handle_char(self, char, index):
        if char == '"':
            self._open_quote_index = -1
            self._add_argument(self._sub_string)
        else:
            self._sub_string += char

    def _finalize_quoted(self):
        raise RuntimeError('no match for quote at index %d found' % self._open_quote_index)

    def _finalize_unquoted(self):
        self._add_argument(self._sub_string)

    def _finalize_float(self):
        self._add_argument(float(self._sub_string))

    def _finalize_number(self):
        argument = int(self._sub_string)
        if cmp(unicode(self._arguments[-1]), u'id') == 0:
            self._arguments.pop()
            argument = self._id_callback(argument)
        self._add_argument(argument)

    def _add_argument(self, argument):
        if isinstance(argument, (str, unicode)):
            argument = StringHandler.prepare_incoming(argument)
        self._arguments.append(argument)
        self._sub_string = u''
        self._state = STATE_NEUTRAL
########NEW FILE########
__FILENAME__ = PySCAClipControl
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Serato/PySCAClipControl.py
import libInterprocessCommsAPIPython

class PySCAClipControl:
    writer = 0
    writer_events = 0
    reader = 0
    reader_events = 0
    writer_clip_control_atom = 0

    def __init__(self):
        pass

    def interface_module(self):
        """ Simple getter to the module to avoid import conflicts in the unit tests """
        return libInterprocessCommsAPIPython

    def PySCA_InitializeClipControl(self):
        self.writer = libInterprocessCommsAPIPython.SCARetrieveWriterObject(libInterprocessCommsAPIPython.kAbletonClipControlCommunicationPath)
        self.writer_events = libInterprocessCommsAPIPython.SCAGetEventQueue(self.writer, libInterprocessCommsAPIPython.SCAGetAtomRef(self.writer, libInterprocessCommsAPIPython.kAbletonClipAndDeviceEventQueue))
        self.writer_clip_control_atom = libInterprocessCommsAPIPython.SCAGetAtomRef(self.writer, libInterprocessCommsAPIPython.kAbletonClipControl)

    def PySCA_InitializeIncomingPath(self):
        self.reader = libInterprocessCommsAPIPython.SCARetrieveReaderObject(libInterprocessCommsAPIPython.kSeratoToAbletonCommunicationPath)
        self.reader_events = libInterprocessCommsAPIPython.SCAGetEventQueue(self.reader, libInterprocessCommsAPIPython.SCAGetAtomRef(self.reader, libInterprocessCommsAPIPython.kSeratoAbletonClipAndDeviceEventQueue))

    def PySCA_DeinitializeClipControl(self):
        self.writer_events = 0
        self.writer_clip_control_atom = 0
        if self.writer != 0:
            libInterprocessCommsAPIPython.SCAReleaseWriterObject(libInterprocessCommsAPIPython.kAbletonClipControlCommunicationPath)
        self.writer = 0
        self.reader_events = 0
        if self.reader != 0:
            libInterprocessCommsAPIPython.SCAReleaseReaderObject(libInterprocessCommsAPIPython.kSeratoToAbletonCommunicationPath)
        self.reader = 0
        libInterprocessCommsAPIPython.SCACleanUpAllObjects()

    def PySCA_HandleIncomingEvents(self):
        event_type = 0
        event_key1 = 0
        event_key2 = 0
        event_data_size = 0
        event_data = 0
        while self.PySCA_GetIncomingEvent(event_type, event_key1, event_key2, event_data_size, event_data) == 0:
            pass

    def PySCA_PeekIncomingEvent(self, event_type, event_key1, event_key2, data_size, data):
        if not reader or not reader_events:
            self.PySCA_InitializeIncomingPath()
        if reader == 0 or reader_events == 0 or libInterprocessCommsAPIPython.SCAValidateReaderObject(self.reader) != 0:
            return -1
        return libInterprocessCommsAPIPython.SCAEventsReadEvent(event_type, event_key1, event_key2, data_size, data, None)

    def PySCA_HasIncomingEvent(self):
        if not self.reader or not self.reader_events:
            self.PySCA_InitializeIncomingPath()
        if self.reader == 0 or self.reader_events == 0 or libInterprocessCommsAPIPython.SCAValidateReaderObject(self.reader) != 0:
            return False
        return libInterprocessCommsAPIPython.SCAEventsPeekEvent(self.reader_events).type > -1

    def PySCA_GetIncomingEvent(self):
        if not self.reader or not self.reader_events:
            self.PySCA_InitializeIncomingPath()
        if self.reader == 0 or self.reader_events == 0 or libInterprocessCommsAPIPython.SCAValidateReaderObject(self.reader) != 0:
            return -1
        return libInterprocessCommsAPIPython.SCAEventsReadEvent(self.reader_events)

    def PySCA_SetSelectedTrack(self, track_id):
        self.PySCA_SetShMemClipControlIntVariableState(track_id, libInterprocessCommsAPIPython.kAbletonActiveTrackIndex, libInterprocessCommsAPIPython.kAbletonEventActiveTrackChanged)

    def PySCA_SetSelectedScene(self, scene_id):
        self.PySCA_SetShMemClipControlIntVariableState(scene_id, libInterprocessCommsAPIPython.kAbletonActiveSceneIndex, libInterprocessCommsAPIPython.kAbletonEventActiveSceneChanged)

    def PySCA_SetClipPlayState(self, track_id, clip_id, playstate):
        self.PySCA_SetShMemClipIntVariableState(track_id, clip_id, playstate, libInterprocessCommsAPIPython.kAbletonTrack, libInterprocessCommsAPIPython.kAbletonClip, libInterprocessCommsAPIPython.kAbletonClipPlayState, libInterprocessCommsAPIPython.kAbletonEventClipStateChanged)

    def PySCA_SetClipLoadState(self, track_id, clip_id, playstate):
        self.PySCA_SetShMemClipIntVariableState(track_id, clip_id, playstate, libInterprocessCommsAPIPython.kAbletonTrack, libInterprocessCommsAPIPython.kAbletonClip, libInterprocessCommsAPIPython.kAbletonClipLoadState, libInterprocessCommsAPIPython.kAbletonEventClipStateChanged)

    def PySCA_SetClipLabel(self, track_id, clip_id, label):
        self.PySCA_SetShMemClipLabelVariableState(track_id, clip_id, label, 40, libInterprocessCommsAPIPython.kAbletonTrack, libInterprocessCommsAPIPython.kAbletonClip, libInterprocessCommsAPIPython.kAbletonClipLabel, libInterprocessCommsAPIPython.kAbletonEventClipChanged)

    def PySCA_SetClipColor(self, track_id, clip_id, color):
        self.PySCA_SetShMemClipIntVariableState(track_id, clip_id, color, libInterprocessCommsAPIPython.kAbletonTrack, libInterprocessCommsAPIPython.kAbletonClip, libInterprocessCommsAPIPython.kAbletonClipColor, libInterprocessCommsAPIPython.kAbletonEventClipChanged)

    def PySCA_SetClipFilename(self, track_id, clip_id, filename):
        self.PySCA_SetShMemClipLabelVariableState(track_id, clip_id, label, 255, libInterprocessCommsAPIPython.kAbletonTrack, libInterprocessCommsAPIPython.kAbletonClip, libInterprocessCommsAPIPython.kAbletonClipLabel, libInterprocessCommsAPIPython.kAbletonEventClipChanged)

    def PySCA_SetSceneLabel(self, scene_id, label):
        self.PySCA_SetShMemClipLabelVariableState(0, scene_id, label, 40, libInterprocessCommsAPIPython.kAbletonMasterTrack, libInterprocessCommsAPIPython.kAbletonClip, libInterprocessCommsAPIPython.kAbletonClipLabel, libInterprocessCommsAPIPython.kAbletonEventClipChanged)

    def PySCA_SetSceneColor(self, scene_id, color):
        self.PySCA_SetShMemClipIntVariableState(0, scene_id, color, libInterprocessCommsAPIPython.kAbletonMasterTrack, libInterprocessCommsAPIPython.kAbletonClip, libInterprocessCommsAPIPython.kAbletonClipColor, libInterprocessCommsAPIPython.kAbletonEventClipChanged)

    def PySCA_SetTrackColor(self, track_id, color):
        self.PySCA_SetShMemTrackIntVariableState(track_id, color, libInterprocessCommsAPIPython.kAbletonTrack, libInterprocessCommsAPIPython.kAbletonTrackColor, libInterprocessCommsAPIPython.kAbletonEventTrackChanged)

    def PySCA_SetTrackLabel(self, track_id, label):
        self.PySCA_SetShMemTrackLabelVariableState(track_id, label, 40, libInterprocessCommsAPIPython.kAbletonTrack, libInterprocessCommsAPIPython.kAbletonTrackName, libInterprocessCommsAPIPython.kAbletonEventTrackChanged)

    def PySCA_SetTrackNumber(self, track_id, track_num):
        self.PySCA_SetShMemTrackIntVariableState(track_id, track_num, libInterprocessCommsAPIPython.kAbletonTrack, libInterprocessCommsAPIPython.kAbletonTrackNumber, libInterprocessCommsAPIPython.kAbletonEventTrackChanged)

    def PySCA_SetTrackGainState(self, track_id, gain_value):
        self.PySCA_SetShMemTrackDoubleVariableState(track_id, gain_value, libInterprocessCommsAPIPython.kAbletonTrack, libInterprocessCommsAPIPython.kAbletonTrackLevelState, libInterprocessCommsAPIPython.kAbletonEventTrackGainChanged)

    def PySCA_SetMasterGainState(self, gain_value):
        self.PySCA_SetShMemTrackDoubleVariableState(0, gain_value, libInterprocessCommsAPIPython.kAbletonMasterTrack, libInterprocessCommsAPIPython.kAbletonTrackLevelState, libInterprocessCommsAPIPython.kAbletonEventTrackGainChanged)

    def PySCA_SetTrackSendAState(self, track_id, send_value):
        self.PySCA_SetShMemTrackDoubleVariableState(track_id, send_value, libInterprocessCommsAPIPython.kAbletonTrack, libInterprocessCommsAPIPython.kAbletonTrackSendAState, libInterprocessCommsAPIPython.kAbletonEventTrackSendsChanged)

    def PySCA_SetTrackSendBState(self, track_id, send_value):
        self.PySCA_SetShMemTrackDoubleVariableState(track_id, send_value, libInterprocessCommsAPIPython.kAbletonTrack, libInterprocessCommsAPIPython.kAbletonTrackSendBState, libInterprocessCommsAPIPython.kAbletonEventTrackSendsChanged)

    def PySCA_SetTrackLevel(self, track_id, level_value):
        self.PySCA_SetShMemTrackDoubleVariableState(track_id, level_value, libInterprocessCommsAPIPython.kAbletonTrack, libInterprocessCommsAPIPython.kAbletonTrackLevelMeterLevel, 0)

    def PySCA_SetMasterLevel(self, track_id, level_value):
        self.PySCA_SetShMemTrackDoubleVariableState(0, level_value, libInterprocessCommsAPIPython.kAbletonMasterTrack, libInterprocessCommsAPIPython.kAbletonTrackLevelMeterLevel, 0)

    def PySCA_SetTrackSoloState(self, track_id, solo_value):
        self.PySCA_SetShMemTrackIntVariableState(track_id, solo_value, libInterprocessCommsAPIPython.kAbletonTrack, libInterprocessCommsAPIPython.kAbletonTrackSoloState, libInterprocessCommsAPIPython.kAbletonEventTrackSoloStateChanged)

    def PySCA_SetTrackRecordState(self, track_id, record_value):
        self.PySCA_SetShMemTrackIntVariableState(track_id, record_value, libInterprocessCommsAPIPython.kAbletonTrack, libInterprocessCommsAPIPython.kAbletonTrackRecordState, libInterprocessCommsAPIPython.kAbletonEventTrackRecordStateChanged)

    def PySCA_SetTrackActiveState(self, track_id, active_value):
        self.PySCA_SetShMemTrackIntVariableState(track_id, active_value, libInterprocessCommsAPIPython.kAbletonTrack, libInterprocessCommsAPIPython.kAbletonTrackActiveState, libInterprocessCommsAPIPython.kAbletonEventTrackActiveStateChanged)

    def PySCA_SetDeviceActive(self, active_state):
        self.PySCA_SetShMemDeviceIndexVariableState(active_state, libInterprocessCommsAPIPython.kAbletonDeviceActive, libInterprocessCommsAPIPython.kAbletonEventDeviceActiveStateChanged)

    def PySCA_SetDeviceLabel(self, label):
        self.PySCA_SetShMemDeviceLabelVariableState(label, 40, libInterprocessCommsAPIPython.kAbletonDeviceName, libInterprocessCommsAPIPython.kAbletonEventDeviceLabelChanged)

    def PySCA_SetDeviceParamValue(self, param_id, param_value):
        self.PySCA_SetShMemDeviceParamDoubleVariableState(param_id, param_value, libInterprocessCommsAPIPython.kAbletonDevice, libInterprocessCommsAPIPython.kAbletonDeviceParamValue, libInterprocessCommsAPIPython.kAbletonEventDeviceParamValueChanged)

    def PySCA_SetDeviceParamLabel(self, param_id, label):
        self.PySCA_SetShMemDeviceParamLabelVariableState(param_id, label, 40, libInterprocessCommsAPIPython.kAbletonDevice, libInterprocessCommsAPIPython.kAbletonDeviceParamName, libInterprocessCommsAPIPython.kAbletonEventDeviceParamNameChanged)

    def PySCA_SetShMemClipControlIntVariableState(self, int_value, key_name, event_name):
        if self.writer and self.writer_events and self.writer_clip_control_atom:
            atom = libInterprocessCommsAPIPython.SCAGetAtomRefInsideContainer(self.writer, self.writer_clip_control_atom, key_name)
            libInterprocessCommsAPIPython.SCASetIntValue(self.writer, atom, int_value)
            if event_name:
                libInterprocessCommsAPIPython.SCAEventsWriteEvent(self.writer_events, event_name, 0, 0, 0, None)

    def PySCA_SetShMemTrackDoubleVariableState(self, track_id, double_value, track_key_name, key_name, event_name):
        if self.writer and self.writer_events and self.writer_clip_control_atom:
            atom = libInterprocessCommsAPIPython.SCAGetAtomRefInsideContainerTwoKey(self.writer, self.writer_clip_control_atom, track_key_name, track_id, key_name)
            libInterprocessCommsAPIPython.SCASetDoubleValue(self.writer, atom, double_value)
            if event_name:
                libInterprocessCommsAPIPython.SCAEventsWriteEvent(self.writer_events, event_name, track_id, 0, 0, None)

    def PySCA_SetShMemTrackIntVariableState(self, track_id, int_value, track_key_name, key_name, event_name):
        if self.writer and self.writer_events and self.writer_clip_control_atom:
            atom = libInterprocessCommsAPIPython.SCAGetAtomRefInsideContainerTwoKey(self.writer, self.writer_clip_control_atom, track_key_name, track_id, key_name)
            libInterprocessCommsAPIPython.SCASetIntValue(self.writer, atom, int_value)
            if event_name:
                libInterprocessCommsAPIPython.SCAEventsWriteEvent(self.writer_events, event_name, track_id, 0, 0, None)

    def PySCA_SetShMemTrackLabelVariableState(self, track_id, label, max_length, track_key_name, key_name, event_name):
        if self.writer and self.writer_events and self.writer_clip_control_atom:
            atom = libInterprocessCommsAPIPython.SCAGetAtomRefInsideContainerTwoKey(self.writer, self.writer_clip_control_atom, track_key_name, track_id, key_name)
            result = libInterprocessCommsAPIPython.SCASetDataValue(self.writer, atom, label, max_length)
            if event_name and result == 0:
                libInterprocessCommsAPIPython.SCAEventsWriteEvent(self.writer_events, event_name, track_id, 0, 0, None)

    def PySCA_SetShMemClipIntVariableState(self, track_id, clip_id, int_value, track_key_name, clip_key_name, key_name, event_name):
        if self.writer and self.writer_events and self.writer_clip_control_atom:
            track_atom = libInterprocessCommsAPIPython.SCAGetContainerAtomRefInsideContainer(self.writer, self.writer_clip_control_atom, track_key_name, track_id)
            atom = libInterprocessCommsAPIPython.SCAGetAtomRefInsideContainerTwoKey(self.writer, track_atom, clip_key_name, clip_id, key_name)
            libInterprocessCommsAPIPython.SCASetIntValue(self.writer, atom, int_value)
            if event_name:
                libInterprocessCommsAPIPython.SCAEventsWriteEvent(self.writer_events, event_name, track_id, clip_id, 0, None)

    def PySCA_SetShMemClipLabelVariableState(self, track_id, clip_id, label, max_length, track_key_name, clip_key_name, key_name, event_name):
        if self.writer and self.writer_events and self.writer_clip_control_atom:
            track_atom = libInterprocessCommsAPIPython.SCAGetContainerAtomRefInsideContainer(self.writer, self.writer_clip_control_atom, track_key_name, track_id)
            atom = libInterprocessCommsAPIPython.SCAGetAtomRefInsideContainerTwoKey(self.writer, track_atom, clip_key_name, clip_id, key_name)
            result = libInterprocessCommsAPIPython.SCASetDataValue(self.writer, atom, label, max_length)
            if event_name and result == 0:
                libInterprocessCommsAPIPython.SCAEventsWriteEvent(self.writer_events, event_name, track_id, clip_id, 0, None)

    def PySCA_SetShMemDeviceLabelVariableState(self, label, max_length, key_name, event_name):
        if self.writer and self.writer_events:
            atom = libInterprocessCommsAPIPython.SCAGetAtomRef(self.writer, key_name)
            result = libInterprocessCommsAPIPython.SCASetDataValue(self.writer, atom, label, max_length)
            if event_name and result == 0:
                libInterprocessCommsAPIPython.SCAEventsWriteEvent(self.writer_events, event_name, 0, 0, 0, None)

    def PySCA_SetShMemDeviceIndexVariableState(self, int_value, key_name, event_name):
        if self.writer and self.writer_events:
            atom = libInterprocessCommsAPIPython.SCAGetAtomRef(self.writer, key_name)
            libInterprocessCommsAPIPython.SCASetIntValue(self.writer, atom, int_value)
            if event_name:
                libInterprocessCommsAPIPython.SCAEventsWriteEvent(self.writer_events, event_name, 0, 0, 0, None)

    def PySCA_SetShMemDeviceParamDoubleVariableState(self, device_id, double_value, device_key_name, key_name, event_name):
        if self.writer and self.writer_events:
            atom = libInterprocessCommsAPIPython.SCAGetAtomRefTwoKey(self.writer, device_key_name, device_id, key_name)
            libInterprocessCommsAPIPython.SCASetDoubleValue(self.writer, atom, double_value)
            if event_name:
                libInterprocessCommsAPIPython.SCAEventsWriteEvent(self.writer_events, event_name, device_id, 0, 0, None)

    def PySCA_SetShMemDeviceParamLabelVariableState(self, device_id, label, max_length, device_key_name, key_name, event_name):
        if self.writer and self.writer_events:
            atom = libInterprocessCommsAPIPython.SCAGetAtomRefTwoKey(self.writer, device_key_name, device_id, key_name)
            result = libInterprocessCommsAPIPython.SCASetDataValue(self.writer, atom, label, max_length)
            if event_name and result == 0:
                libInterprocessCommsAPIPython.SCAEventsWriteEvent(self.writer_events, event_name, device_id, 0, 0, None)
########NEW FILE########
__FILENAME__ = Serato
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Serato/Serato.py
from __future__ import with_statement
import Live
import libInterprocessCommsAPIPython
from PySCAClipControl import PySCAClipControl
from _Framework.ControlSurface import ControlSurface
from _Framework.InputControlElement import *
from _Framework.SliderElement import SliderElement
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import EncoderElement
from _Framework.ButtonMatrixElement import ButtonMatrixElement
from _Framework.ClipSlotComponent import ClipSlotComponent
from _Framework.ChannelStripComponent import ChannelStripComponent
from SpecialMixerComponent import SpecialMixerComponent
from SpecialSessionComponent import SpecialSessionComponent
from SpecialDeviceComponent import SpecialDeviceComponent

def fixed_value(value):
    """ Small utility function to extract fixed float values from integers """
    return float(value) / 65536L


NUM_SCENES = 8
NUM_TRACKS = 8
NUM_PARAMS = 8
CLIP_EVENTS = (libInterprocessCommsAPIPython.kAbletonClipControlEventClipPlayedDown, libInterprocessCommsAPIPython.kAbletonClipControlEventClipPlayedReleased)
SCENE_EVENTS = (libInterprocessCommsAPIPython.kAbletonClipControlEventScenePlayedDown, libInterprocessCommsAPIPython.kAbletonClipControlEventScenePlayedReleased)

class Serato(ControlSurface):

    def __init__(self, c_instance):
        publish_in_cs_list = True
        ControlSurface.__init__(self, c_instance, not publish_in_cs_list)
        self._device_selection_follows_track_selection = True
        with self.component_guard():
            self._matrix = None
            self._session = None
            self._mixer = None
            self._device = None
            self._scene_launch_buttons = None
            self._track_arm_buttons = None
            self._track_solo_buttons = None
            self._track_mute_buttons = None
            self._track_stop_buttons = None
            self._track_select_buttons = None
            self._device_on_off_button = None
            self._shift_button = None
            self._serato_interface = PySCAClipControl()
            self._serato_interface.PySCA_InitializeClipControl()
            self._setup_session_control()
            self._setup_mixer_control()
            self._setup_device_control()
            self._session.set_mixer(self._mixer)
            self.set_highlighting_session_component(self._session)

    def disconnect(self):
        ControlSurface.disconnect(self)
        self._serato_interface.PySCA_DeinitializeClipControl()
        self._serato_interface = None

    def connect_script_instances(self, instanciated_scripts):
        """ Called by the Application as soon as all scripts are initialized.
            You can connect yourself to other running scripts here, as we do it
            connect the extension modules (MackieControlXTs).
        """
        for control_surface in self._control_surfaces():
            control_surface_session = control_surface.highlighting_session_component()
            if control_surface_session:
                self._session.sync_to(control_surface_session)
                self._on_track_list_changed()
                break

    def build_midi_map(self, midi_map_handle):
        pass

    def update_display(self):
        ControlSurface.update_display(self)
        while self._serato_interface.PySCA_HasIncomingEvent():
            new_event = self._serato_interface.PySCA_GetIncomingEvent()
            if not self._handle_session_event(new_event):
                if not self._handle_mixer_event(new_event):
                    if not self._handle_device_event(new_event):
                        print 'Unhandled Event: ' + str(new_event)

    def _setup_session_control(self):
        is_momentary = True
        self._session = SpecialSessionComponent(NUM_TRACKS, NUM_SCENES)
        self._session.set_serato_interface(self._serato_interface)
        self._matrix = ButtonMatrixElement()
        self._scene_launch_buttons = [ ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 0) for index in range(NUM_SCENES) ]
        self._track_stop_buttons = [ ButtonElement(not is_momentary, MIDI_NOTE_TYPE, 0, 0) for index in range(NUM_TRACKS) ]
        stop_all_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 0)
        self._session.set_stop_all_clips_button(stop_all_button)
        self._session.set_stop_track_clip_buttons(tuple(self._track_stop_buttons))
        for scene_index in range(NUM_SCENES):
            scene = self._session.scene(scene_index)
            button_row = []
            scene.set_launch_button(self._scene_launch_buttons[scene_index])
            scene.set_index(scene_index)
            scene.set_serato_interface(self._serato_interface)
            for track_index in range(NUM_TRACKS):
                button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 0)
                button_row.append(button)
                clip_slot = scene.clip_slot(track_index)
                clip_slot.set_launch_button(button)
                clip_slot.set_serato_interface(self._serato_interface)

            self._matrix.add_row(tuple(button_row))

    def _setup_mixer_control(self):
        is_momentary = True
        self._mixer = SpecialMixerComponent(NUM_TRACKS)
        self._mixer.set_serato_interface(self._serato_interface)
        self._mixer.master_strip().set_serato_interface(self._serato_interface)
        self._track_arm_buttons = []
        self._track_solo_buttons = []
        self._track_mute_buttons = []
        self._track_select_buttons = []
        self._shift_button = ButtonElement(is_momentary, MIDI_NOTE_TYPE, 0, 0)
        for track in range(NUM_TRACKS):
            strip = self._mixer.channel_strip(track)
            strip.set_serato_interface(self._serato_interface)
            self._track_arm_buttons.append(ButtonElement(not is_momentary, MIDI_NOTE_TYPE, 0, 0))
            self._track_solo_buttons.append(ButtonElement(not is_momentary, MIDI_NOTE_TYPE, 0, 0))
            self._track_mute_buttons.append(ButtonElement(not is_momentary, MIDI_NOTE_TYPE, 0, 0))
            self._track_select_buttons.append(ButtonElement(not is_momentary, MIDI_NOTE_TYPE, 0, 0))
            strip.set_arm_button(self._track_arm_buttons[-1])
            strip.set_solo_button(self._track_solo_buttons[-1])
            strip.set_mute_button(self._track_mute_buttons[-1])
            strip.set_select_button(self._track_select_buttons[-1])
            strip.set_shift_button(self._shift_button)

    def _setup_device_control(self):
        is_momentary = True
        self._device_on_off_button = ButtonElement(not is_momentary, MIDI_NOTE_TYPE, 0, 0)
        self._device = SpecialDeviceComponent()
        self._device.set_serato_interface(self._serato_interface)
        self._device.set_parameter_controls(tuple([ SliderElement(MIDI_CC_TYPE, 0, 0) for index in range(NUM_PARAMS) ]))
        self._device.set_on_off_button(self._device_on_off_button)
        self.set_device_component(self._device)

    def _handle_session_event(self, event):
        result = False
        if event.type in CLIP_EVENTS:
            value = 127 * int(event.type == libInterprocessCommsAPIPython.kAbletonClipControlEventClipPlayedDown)
            track_index = event.key1 - 1
            scene_index = event.key2 - 1
            if track_index in range(NUM_TRACKS) and scene_index in range(NUM_SCENES):
                self._matrix.get_button(track_index, scene_index).receive_value(value)
            result = True
        elif event.type in SCENE_EVENTS:
            value = 127 * int(event.type == libInterprocessCommsAPIPython.kAbletonClipControlEventScenePlayedDown)
            scene_index = event.key1 - 1
            if scene_index in range(NUM_SCENES):
                self._scene_launch_buttons[scene_index].receive_value(value)
            result = True
        elif event.type == libInterprocessCommsAPIPython.kAbletonClipControlMatrixSizeChanged:
            new_width = event.key1
            new_height = event.key2
            self._session.set_size(new_width, new_height)
            result = True
        elif event.type == libInterprocessCommsAPIPython.kAbletonClipControlMatrixOffsetChanged:
            x_increment = event.key1
            y_increment = event.key2
            self._session.move_by(x_increment, y_increment)
            result = True
        return result

    def _handle_mixer_event(self, event):
        result = True
        track_index = event.key1 - 1
        value = event.key2
        if event.type == libInterprocessCommsAPIPython.kAbletonClipControlEventTrackMasterGainChange:
            self._mixer.master_strip().set_track_volume(fixed_value(value))
        elif event.type == libInterprocessCommsAPIPython.kAbletonClipControlEventMasterTrackStopped:
            self.song().stop_all_clips()
        elif event.type == libInterprocessCommsAPIPython.kAbletonClipControlEventMasterTrackSelect:
            self.song().view.selected_track = self.song().master_track
        else:
            result = track_index in range(NUM_TRACKS) and self._handle_strip_event(event)
        return result

    def _handle_strip_event(self, event):
        result = True
        track_index = event.key1 - 1
        value = event.key2
        if value == 0:
            self._shift_button.receive_value(127)
        if event.type == libInterprocessCommsAPIPython.kAbletonClipControlEventTrackSolo:
            self._track_solo_buttons[track_index].receive_value(127)
        elif event.type == libInterprocessCommsAPIPython.kAbletonClipControlEventTrackRecord:
            self._track_arm_buttons[track_index].receive_value(127)
        elif event.type == libInterprocessCommsAPIPython.kAbletonClipControlEventTrackActive:
            self._track_mute_buttons[track_index].receive_value(127)
        elif event.type == libInterprocessCommsAPIPython.kAbletonClipControlEventTrackStopped:
            self._track_stop_buttons[track_index].receive_value(127)
        elif event.type == libInterprocessCommsAPIPython.kAbletonClipControlEventTrackSelect:
            self._track_select_buttons[track_index].receive_value(127)
        elif event.type == libInterprocessCommsAPIPython.kAbletonClipControlEventTrackGainChange:
            self._mixer.channel_strip(track_index).set_track_volume(fixed_value(value))
        elif event.type == libInterprocessCommsAPIPython.kAbletonClipControlEventTrackSendAChange:
            self._mixer.channel_strip(track_index).set_send(0, fixed_value(value))
        elif event.type == libInterprocessCommsAPIPython.kAbletonClipControlEventTrackSendBChange:
            self._mixer.channel_strip(track_index).set_send(1, fixed_value(value))
        else:
            result = False
        self._shift_button.receive_value(0)
        return result

    def _handle_device_event(self, event):
        result = True
        if event.type == libInterprocessCommsAPIPython.kAbletonClipControlEventDeviceValueChanged:
            self._device.set_parameter_value(event.key1 - 1, fixed_value(event.key2))
        elif event.type == libInterprocessCommsAPIPython.kAbletonClipControlEventDeviceActivate:
            self._device_on_off_button.receive_value(127)
        elif event.type == libInterprocessCommsAPIPython.kAbletonClipControlEventDeviceFocusMove:
            self._move_device_focus(event.key1)
        else:
            result = False
        return result

    def _move_device_focus(self, increment):
        if not self.application().view.is_view_visible('Detail') or not self.application().view.is_view_visible('Detail/DeviceChain'):
            self.application().view.show_view('Detail')
            self.application().view.show_view('Detail/DeviceChain')
        else:
            modifier_pressed = True
            direction = Live.Application.Application.View.NavDirection.left
            if increment > 0:
                direction = Live.Application.Application.View.NavDirection.right
            self.application().view.scroll_view(direction, 'Detail/DeviceChain', not modifier_pressed)
########NEW FILE########
__FILENAME__ = SpecialChanStripComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Serato/SpecialChanStripComponent.py
import Live
from _Framework.ChannelStripComponent import ChannelStripComponent

class SpecialChanStripComponent(ChannelStripComponent):

    def __init__(self):
        ChannelStripComponent.__init__(self)
        self._serato_interface = None
        self._index = -1

    def disconnect(self):
        self._remove_send_listeners()
        if self._track != None:
            self._track.remove_color_listener(self._on_track_color_changed)
            self._track.mixer_device.volume.remove_value_listener(self._on_volume_changed)
            self._track.remove_has_midi_output_listener(self._on_output_type_changed)
        ChannelStripComponent.disconnect(self)
        self._on_volume_changed()
        self._on_mute_changed()
        self._on_arm_changed()
        self._on_send_a_changed()
        self._on_send_b_changed()
        self._on_level_changed()
        self._on_track_name_changed()
        self._on_track_color_changed()
        self._update_track_index()
        self._serato_interface = None

    def set_track(self, track):
        self._remove_send_listeners()
        self._remove_level_listener()
        if self._track != None:
            self._track.remove_color_listener(self._on_track_color_changed)
            self._track.mixer_device.volume.remove_value_listener(self._on_volume_changed)
            self._track.remove_has_midi_output_listener(self._on_output_type_changed)
        ChannelStripComponent.set_track(self, track)
        if self._track != None:
            self._track.add_color_listener(self._on_track_color_changed)
            self._track.mixer_device.volume.add_value_listener(self._on_volume_changed)
            self._track.add_has_midi_output_listener(self._on_output_type_changed)
        self._add_send_listeners()
        self._on_volume_changed()
        self._on_output_type_changed()
        self._update_track_index()

    def set_index(self, index):
        raise index > -1 or AssertionError
        self._index = index
        self.update()
        self._on_send_a_changed()
        self._on_send_b_changed()
        self._on_volume_changed()
        self._on_output_type_changed()
        self._update_track_index()

    def set_serato_interface(self, serato_interface):
        raise serato_interface != None or AssertionError
        self._serato_interface = serato_interface
        self.update()
        self._on_send_a_changed()
        self._on_send_b_changed()
        self._on_volume_changed()
        self._update_track_index()

    def set_track_volume(self, volume):
        if not (0.0 <= volume and volume <= 1.0):
            raise AssertionError
            self._track.mixer_device.volume.value = self._track != None and self._track.mixer_device.volume.is_enabled and volume

    def set_send(self, index, amount):
        if not (0.0 <= amount and amount <= 1.0):
            raise AssertionError
            if self._track != None and len(self._track.mixer_device.sends) > index:
                self._track.mixer_device.sends[index].value = self._track.mixer_device.sends[index].is_enabled and amount

    def is_track_selected(self):
        return self._track == self.song().view.selected_track

    def update(self):
        if self._allow_updates:
            if self.is_enabled():
                self._on_mute_changed()
                self._on_solo_changed()
                self._on_arm_changed()
                self._on_track_name_changed()
                self._on_track_color_changed()
        else:
            self._update_requests += 1

    def _on_sends_changed(self):
        self._remove_send_listeners()
        self._add_send_listeners()

    def _on_mute_changed(self):
        if self._track != self.song().master_track and self._serato_interface != None and self._index > -1:
            value_to_send = 1
            if self._track != None:
                value_to_send = int(not self._track.mute)
            self._serato_interface.PySCA_SetTrackActiveState(self._index + 1, value_to_send)

    def _on_solo_changed(self):
        if self._track != self.song().master_track and self._serato_interface != None and self._index > -1:
            value_to_send = 0
            if self._track != None:
                value_to_send = int(self._track.solo)
            self._serato_interface.PySCA_SetTrackSoloState(self._index + 1, value_to_send)

    def _on_arm_changed(self):
        if (self._track in self.song().tracks or self._track == None) and self._serato_interface != None and self._index > -1:
            value_to_send = 0
            if self._track != None and self._track.can_be_armed:
                value_to_send = int(self._track.arm)
            self._serato_interface.PySCA_SetTrackRecordState(self._index + 1, value_to_send)

    def _on_track_name_changed(self):
        if self._serato_interface != None and self._index > -1:
            name = ''
            if self._track != None:
                name = self._track.name
            self._serato_interface.PySCA_SetTrackLabel(self._index + 1, name)

    def _on_track_color_changed(self):
        if self._serato_interface != None and self._index > -1:
            color = -1
            if self._track != None:
                color = self._track.color
            self._serato_interface.PySCA_SetTrackColor(self._index + 1, color)

    def _on_send_a_changed(self):
        if (self._track in self.song().tracks or self._track == None) and self._serato_interface != None and self._index > -1:
            value_to_send = 0.0
            if self._track != None and len(self._track.mixer_device.sends) > 0:
                value_to_send = self._track.mixer_device.sends[0].value
            self._serato_interface.PySCA_SetTrackSendAState(self._index + 1, value_to_send)

    def _on_send_b_changed(self):
        if (self._track in self.song().tracks or self._track == None) and self._serato_interface != None and self._index > -1:
            value_to_send = 0.0
            if self._track != None and len(self._track.mixer_device.sends) > 1:
                value_to_send = self._track.mixer_device.sends[1].value
            self._serato_interface.PySCA_SetTrackSendBState(self._index + 1, value_to_send)

    def _on_volume_changed(self):
        if self._serato_interface != None:
            if self._track == self.song().master_track:
                self._serato_interface.PySCA_SetMasterGainState(self._track.mixer_device.volume.value)
            elif self._index > -1:
                value_to_send = 0.0
                if self._track != None:
                    value_to_send = self._track.mixer_device.volume.value
                self._serato_interface.PySCA_SetTrackGainState(self._index + 1, value_to_send)

    def _on_output_type_changed(self):
        self._remove_level_listener()
        self._add_level_listener()
        self._on_level_changed()

    def _on_level_changed(self):
        if self._serato_interface != None:
            level = 0.0
            if self._track != None:
                if self._track.has_midi_output:
                    level = self._track.output_meter_level
                elif self._track.has_audio_output:
                    level = max(self._track.output_meter_left, self._track.output_meter_right)
            if self._track == self.song().master_track:
                self._serato_interface.PySCA_SetMasterLevel(-1, level)
            elif self._index > -1:
                self._serato_interface.PySCA_SetTrackLevel(self._index + 1, level)

    def _remove_send_listeners(self):
        if self._track != None:
            send_callbacks = (self._on_send_a_changed, self._on_send_b_changed)
            for index in range(2):
                if index < len(self._track.mixer_device.sends):
                    send = self._track.mixer_device.sends[index]
                    if send.value_has_listener(send_callbacks[index]):
                        send.remove_value_listener(send_callbacks[index])

    def _add_send_listeners(self):
        if self._track != None:
            send_callbacks = (self._on_send_a_changed, self._on_send_b_changed)
            for index in range(2):
                if index < len(self._track.mixer_device.sends):
                    self._track.mixer_device.sends[index].add_value_listener(send_callbacks[index])
                    send_callbacks[index]()

    def _remove_level_listener(self):
        if self._track != None:
            if self._track.has_audio_output:
                if self._track.output_meter_right_has_listener(self._on_level_changed):
                    self._track.remove_output_meter_right_listener(self._on_level_changed)
                if self._track.output_meter_left_has_listener(self._on_level_changed):
                    self._track.remove_output_meter_left_listener(self._on_level_changed)
            elif self._track.output_meter_level_has_listener(self._on_level_changed):
                self._track.remove_output_meter_level_listener(self._on_level_changed)

    def _add_level_listener(self):
        if self._track != None:
            if self._track.has_audio_output:
                if not self._track.output_meter_right_has_listener(self._on_level_changed):
                    self._track.add_output_meter_right_listener(self._on_level_changed)
                if not self._track.output_meter_left_has_listener(self._on_level_changed):
                    self._track.add_output_meter_left_listener(self._on_level_changed)
            elif not self._track.output_meter_level_has_listener(self._on_level_changed):
                self._track.add_output_meter_level_listener(self._on_level_changed)

    def _update_track_index(self):
        if self._serato_interface != None and self._index > -1:
            self._serato_interface.PySCA_SetTrackNumber(self._index + 1, self._identifier())

    def _encode_track_identifier(self, identifier):
        raise len(identifier) <= 4 or AssertionError
        result = 0
        for index in range(min(4, len(identifier))):
            raise identifier[index].isdigit() or identifier[index].isupper() or AssertionError
            byte = ord(identifier[index])
            result += byte << (3 - index) * 8

        return result

    def _identifier(self):
        track_id = ''
        tracks = self.song().tracks
        returns = self.song().return_tracks
        if self._track != None:
            if self._track in tracks:
                track_id = str(list(tracks).index(self._track) + 1)
            elif self._track in returns:
                track_id = str(chr(ord('A') + list(returns).index(self._track)))
            elif self._track == self.song().master_track:
                track_id = 'M'
        return self._encode_track_identifier(track_id)
########NEW FILE########
__FILENAME__ = SpecialClipSlotComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Serato/SpecialClipSlotComponent.py
import Live
import libInterprocessCommsAPIPython
from _Framework.ClipSlotComponent import ClipSlotComponent
from _Framework.InputControlElement import *
from _Framework.SubjectSlot import subject_slot
from PySCAClipControl import *

class SpecialClipSlotComponent(ClipSlotComponent):

    def __init__(self):
        ClipSlotComponent.__init__(self)
        self._scene_index = -1
        self._track_index = -1
        self._serato_interface = None

    def disconnect(self):
        if self._clip_slot != None and self.has_clip():
            self._clip_slot.clip.remove_name_listener(self._on_name_changed)
            self._clip_slot.clip.remove_color_listener(self._on_color_changed)
        ClipSlotComponent.disconnect(self)
        self._on_load_state_changed()
        self._on_name_changed()
        self._on_color_changed()
        self._serato_interface = None

    def set_serato_interface(self, serato_interface):
        if not serato_interface != None:
            raise AssertionError
            self._serato_interface = serato_interface
            self._clip_slot != None and self.update()
        self._on_load_state_changed()
        self._on_name_changed()
        self._on_color_changed()
        self.update()

    def set_clip_slot(self, clip_slot):
        if self._clip_slot != None and self.has_clip():
            self._clip_slot.clip.remove_name_listener(self._on_name_changed)
            self._clip_slot.clip.remove_color_listener(self._on_color_changed)
        ClipSlotComponent.set_clip_slot(self, clip_slot)
        if self._clip_slot != None and self.has_clip():
            self._clip_slot.clip.add_name_listener(self._on_name_changed)
            self._clip_slot.clip.add_color_listener(self._on_color_changed)
        self._on_load_state_changed()
        self._on_name_changed()
        self._on_color_changed()
        self.update()

    def set_indexes(self, scene_index, track_index):
        raise scene_index >= 0 or AssertionError
        raise track_index >= 0 or AssertionError
        self._scene_index = scene_index
        self._track_index = track_index
        self._on_load_state_changed()
        self._on_name_changed()
        self._on_color_changed()
        self.update()

    def update(self):
        self._has_fired_slot = False
        if self._allow_updates:
            if self.is_enabled() and self._serato_interface != None:
                value_to_send = libInterprocessCommsAPIPython.kAbletonClipIsStopped
                if self._clip_slot != None:
                    object_to_check = self._clip_slot
                    if self.has_clip():
                        object_to_check = self._clip_slot.clip
                    if object_to_check.is_triggered:
                        value_to_send = libInterprocessCommsAPIPython.kAbletonClipIsQueued
                        if object_to_check.will_record_on_start:
                            value_to_send = libInterprocessCommsAPIPython.kAbletonClipIsRecordingQueued
                    elif object_to_check.is_playing:
                        value_to_send = libInterprocessCommsAPIPython.kAbletonClipIsPlaying
                        if object_to_check.is_recording:
                            value_to_send = libInterprocessCommsAPIPython.kAbletonClipIsRecording
                if self._track_index > -1 and self._scene_index > -1:
                    self._serato_interface.PySCA_SetClipPlayState(self._track_index + 1, self._scene_index + 1, value_to_send)
        else:
            self._update_requests += 1

    @subject_slot('has_clip')
    def _on_clip_state_changed(self):
        if not self._clip_slot != None:
            raise AssertionError
            if self.has_clip():
                if not self._clip_slot.clip.name_has_listener(self._on_name_changed):
                    self._clip_slot.clip.add_name_listener(self._on_name_changed)
                if not self._clip_slot.clip.color_has_listener(self._on_color_changed):
                    self._clip_slot.clip.add_color_listener(self._on_color_changed)
                if not self._clip_slot.clip.playing_status_has_listener(self._on_playing_state_changed):
                    self._clip_slot.clip.add_playing_status_listener(self._on_playing_state_changed)
                self._clip_slot.clip.is_recording_has_listener(self._on_recording_state_changed) or self._clip_slot.clip.add_is_recording_listener(self._on_recording_state_changed)
        self._on_load_state_changed()
        self._on_color_changed()
        self._on_name_changed()
        self.update()

    def _on_name_changed(self):
        if self._serato_interface != None and -1 not in (self._track_index, self._scene_index):
            name = ''
            if self._clip_slot != None and self.has_clip():
                name = self._clip_slot.clip.name
            self._serato_interface.PySCA_SetClipLabel(self._track_index + 1, self._scene_index + 1, name)

    def _on_color_changed(self):
        if self._serato_interface != None and -1 not in (self._track_index, self._scene_index):
            if self._clip_slot != None and self.has_clip():
                self._serato_interface.PySCA_SetClipColor(self._track_index + 1, self._scene_index + 1, self._clip_slot.clip.color)

    def _on_load_state_changed(self):
        if self._serato_interface != None and -1 not in (self._track_index, self._scene_index):
            value_to_send = libInterprocessCommsAPIPython.kAbletonClipIsEmpty
            if self._clip_slot != None and self.has_clip():
                value_to_send = libInterprocessCommsAPIPython.kAbletonClipIsLoaded
            self._serato_interface.PySCA_SetClipLoadState(self._track_index + 1, self._scene_index + 1, value_to_send)
########NEW FILE########
__FILENAME__ = SpecialDeviceComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Serato/SpecialDeviceComponent.py
import Live
import libInterprocessCommsAPIPython
from PySCAClipControl import *
from _Framework.DeviceComponent import DeviceComponent

class SpecialDeviceComponent(DeviceComponent):

    def __init__(self):
        DeviceComponent.__init__(self)
        self._serato_interface = None
        self._parameter_listeners = []

    def disconnect(self):
        self._remove_parameter_listeners()
        self._on_device_name_changed()
        DeviceComponent.disconnect(self)
        self._serato_interface = None
        self._parameter_listeners = None

    def set_device(self, device):
        if not self._locked_to_device and device != self._device:
            self._remove_parameter_listeners()
        DeviceComponent.set_device(self, device)

    def set_serato_interface(self, serato_interface):
        raise serato_interface != 0 or AssertionError
        self._serato_interface = serato_interface
        self._on_device_name_changed()

    def set_parameter_value(self, parameter_index, value):
        if not parameter_index in range(len(self._parameter_controls)):
            raise AssertionError
            raise 0.0 <= value and value <= 1.0 or AssertionError
            parameter = self._parameter_controls[parameter_index].mapped_parameter()
            adapted_value = parameter != None and parameter.is_enabled and value * abs(parameter.max - parameter.min)
            parameter.value = adapted_value + parameter.min

    def update(self):
        if self.is_enabled() and self._device != None:
            self._device_bank_registry[self._device] = self._bank_index
            if self._parameter_controls != None:
                self._remove_parameter_listeners()
                self._assign_parameters()
                self._add_parameter_listeners()
        elif self._parameter_controls != None:
            for control in self._parameter_controls:
                control.release_parameter()

        self._on_on_off_changed()

    def _on_parameter_name_changed(self, index):
        if not self._parameter_controls != None:
            raise AssertionError
            if not index in range(len(self._parameter_controls)):
                raise AssertionError
                parameter = self._serato_interface != None and self._parameter_controls[index].mapped_parameter()
                name = ''
                name = parameter != None and parameter.name
            self._serato_interface.PySCA_SetDeviceParamLabel(index + 1, name)

    def _on_device_name_changed(self):
        if self._serato_interface != None:
            name = 'No Device'
            if self._device != None:
                name = self._device.name
            self._serato_interface.PySCA_SetDeviceLabel(name)

    def _on_parameter_changed(self, index):
        if not self._parameter_controls != None:
            raise AssertionError
            if not index in range(len(self._parameter_controls)):
                raise AssertionError
                parameter = self._serato_interface != None and self._parameter_controls[index].mapped_parameter()
                value_to_send = 0
                value_to_send = parameter != None and (parameter.value - parameter.min) / (parameter.max - parameter.min)
            self._serato_interface.PySCA_SetDeviceParamValue(index + 1, value_to_send)

    def _on_on_off_changed(self):
        if self.is_enabled() and self._serato_interface != None:
            state = 0
            if self._device != None:
                parameter = self._on_off_parameter()
                if parameter != None and parameter.value > 0.0:
                    state = 1
            self._serato_interface.PySCA_SetDeviceActive(state)

    def _add_parameter_listeners(self):
        if self._parameter_controls != None:
            for index in range(len(self._parameter_controls)):
                parameter = self._parameter_controls[index].mapped_parameter()
                value_listener = lambda index = index: self._on_parameter_changed(index)
                name_listener = lambda index = index: self._on_parameter_name_changed(index)
                if parameter != None:
                    if not parameter.value_has_listener(value_listener):
                        parameter.add_value_listener(value_listener)
                        self._parameter_listeners.append((parameter, value_listener))
                value_listener()
                name_listener()

    def _remove_parameter_listeners(self):
        if self._parameter_controls != None:
            for index in range(len(self._parameter_listeners)):
                pair = self._parameter_listeners[index]
                parameter = pair[0]
                if parameter != None:
                    value_listener = pair[1]
                    if parameter.value_has_listener(value_listener):
                        parameter.remove_value_listener(value_listener)
                if self._serato_interface != None:
                    self._serato_interface.PySCA_SetDeviceParamValue(index + 1, 0)
                    self._serato_interface.PySCA_SetDeviceParamLabel(index + 1, '')

            self._parameter_listeners = []
########NEW FILE########
__FILENAME__ = SpecialMixerComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Serato/SpecialMixerComponent.py
import Live
from _Framework.MixerComponent import MixerComponent
from SpecialChanStripComponent import SpecialChanStripComponent

class SpecialMixerComponent(MixerComponent):

    def __init__(self, num_tracks):
        self._tracks_to_use_callback = None
        self._serato_interface = None
        MixerComponent.__init__(self, num_tracks)
        for index in range(num_tracks):
            self._channel_strips[index].set_index(index)

    def disconnect(self):
        MixerComponent.disconnect(self)
        self._serato_interface = None
        self._tracks_to_use_callback = None

    def set_tracks_to_use_callback(self, callback):
        self._tracks_to_use_callback = callback

    def set_serato_interface(self, serato_interface):
        raise serato_interface != None or AssertionError
        self._serato_interface = serato_interface
        self.on_selected_track_changed()

    def tracks_to_use(self):
        tracks = tuple()
        if self._tracks_to_use_callback != None:
            tracks = self._tracks_to_use_callback()
        else:
            tracks = MixerComponent.tracks_to_use(self)
        return tracks

    def on_selected_track_changed(self):
        MixerComponent.on_selected_track_changed(self)
        if self._serato_interface != None:
            self._serato_interface.PySCA_SetSelectedTrack(self._selected_strip_index())

    def _selected_strip_index(self):
        result = -1
        if self._master_strip.is_track_selected():
            result = 0
        else:
            for index in range(len(self._channel_strips)):
                if self._channel_strips[index].is_track_selected():
                    result = index + 1
                    break

        return result

    def _create_strip(self):
        return SpecialChanStripComponent()

    def _reassign_tracks(self):
        MixerComponent._reassign_tracks(self)
        self.on_selected_track_changed()
########NEW FILE########
__FILENAME__ = SpecialSceneComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Serato/SpecialSceneComponent.py
import Live
from _Framework.SceneComponent import SceneComponent
from _Framework.InputControlElement import *
from _Framework.ButtonElement import ButtonElement
from SpecialClipSlotComponent import SpecialClipSlotComponent

class SpecialSceneComponent(SceneComponent):

    def __init__(self, num_tracks, tracks_to_use_callback):
        SceneComponent.__init__(self, num_tracks, tracks_to_use_callback)
        self._index = -1
        self._serato_interface = None
        self._last_name_sent = None

    def disconnect(self):
        if self._scene != None:
            self._scene.remove_name_listener(self._on_name_changed)
            self._scene.remove_color_listener(self._on_color_changed)
        SceneComponent.disconnect(self)
        self._serato_interface = None

    def set_serato_interface(self, serato_interface):
        if not serato_interface != None:
            raise AssertionError
            self._serato_interface = serato_interface
            self._scene != None and self._on_is_triggered_changed()
        self._on_name_changed()
        self._on_color_changed()

    def set_scene(self, scene):
        if self._scene != scene:
            if self._scene != None:
                self._scene.remove_name_listener(self._on_name_changed)
                self._scene.remove_color_listener(self._on_color_changed)
            SceneComponent.set_scene(self, scene)
            if self._scene != None:
                self._scene.add_name_listener(self._on_name_changed)
                self._scene.add_color_listener(self._on_color_changed)
            self._on_name_changed()
            self._on_color_changed()

    def set_index(self, index):
        if not index >= 0:
            raise AssertionError
            self._index = index
            for clip_index in range(len(self._clip_slots)):
                self._clip_slots[clip_index].set_indexes(self._index, clip_index)

            self._scene != None and self._on_is_triggered_changed()
        self._on_name_changed()
        self._on_color_changed()

    def is_selected(self):
        return self._scene == self.song().view.selected_scene

    def _create_clip_slot(self):
        return SpecialClipSlotComponent()

    def _on_is_triggered_changed(self):
        raise self._scene != None or AssertionError
        if self._scene.is_triggered:
            pass

    def _on_name_changed(self):
        if self._serato_interface != None and self._index > -1:
            name = ''
            if self._scene != None:
                name = self._scene.name
            if self._last_name_sent != name:
                self._serato_interface.PySCA_SetSceneLabel(self._index + 1, name)
                self._last_name_sent = name

    def _on_color_changed(self):
        if self._serato_interface != None and self._index > -1:
            value_to_send = 0
            if self._scene != None:
                value_to_send = self._scene.color
            self._serato_interface.PySCA_SetSceneColor(self._index + 1, value_to_send)
########NEW FILE########
__FILENAME__ = SpecialSessionComponent
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Serato/SpecialSessionComponent.py
import Live
from _Framework.SessionComponent import SessionComponent
from _Framework.InputControlElement import *
from _Framework.ButtonElement import ButtonElement
from _Framework.ClipSlotComponent import ClipSlotComponent
from SpecialSceneComponent import SpecialSceneComponent

class SpecialSessionComponent(SessionComponent):

    def __init__(self, num_tracks, num_scenes):
        self._visible_width = num_tracks
        self._visible_height = num_scenes
        self._synced_session = None
        self._serato_interface = None
        SessionComponent.__init__(self, num_tracks, num_scenes)

    def disconnect(self):
        SessionComponent.disconnect(self)
        if self._synced_session != None:
            self._synced_session.remove_offset_listener(self._on_control_surface_offset_changed)
            self._mixer.set_tracks_to_use_callback(None)
        self._serato_interface = None

    def set_serato_interface(self, serato_interface):
        raise serato_interface != None or AssertionError
        self._serato_interface = serato_interface
        self.on_selected_scene_changed()

    def on_selected_scene_changed(self):
        SessionComponent.on_selected_scene_changed(self)
        if self._serato_interface != None:
            self._serato_interface.PySCA_SetSelectedScene(self._selected_scene_index())

    def set_size(self, width, height):
        if not width in range(self._num_tracks + 1):
            raise AssertionError
            raise height in range(len(self._scenes) + 1) or AssertionError
            self._visible_width = width
            self._visible_height = height
            self._show_highlight = self._show_highlight and False
            self.set_show_highlight(True)

    def move_by(self, track_increment, scene_increment):
        track_offset = self._track_offset + track_increment
        scene_offset = self._scene_offset + scene_increment
        self.set_offsets(max(0, track_offset), max(0, scene_offset))

    def width(self):
        return self._visible_width

    def height(self):
        return self._visible_height

    def sync_to(self, other_session):
        if not isinstance(other_session, (type(None), SessionComponent)):
            raise AssertionError
            if other_session != self._synced_session:
                if self._synced_session != None:
                    self._synced_session.remove_offset_listener(self._on_control_surface_offset_changed)
                    self._mixer.set_tracks_to_use_callback(None)
                self._synced_session = other_session
                self._synced_session != None and self._synced_session.add_offset_listener(self._on_control_surface_offset_changed)
                self._mixer.set_tracks_to_use_callback(self._synced_session.tracks_to_use)
            self._do_show_highlight()

    def set_offsets(self, track_offset, scene_offset):
        if self._synced_session != None:
            self._synced_session.set_offsets(track_offset, scene_offset)
        else:
            SessionComponent.set_offsets(self, track_offset, scene_offset)

    def _on_control_surface_offset_changed(self):
        """
        Updates offsets in serato to be the same as in control surface
        Called whenever control surface offsets are changed.
        """
        SessionComponent.set_offsets(self, self._synced_session.track_offset(), self._synced_session.scene_offset())

    def _create_scene(self):
        return SpecialSceneComponent(self._num_tracks, self.tracks_to_use)

    def _reassign_scenes(self):
        SessionComponent._reassign_scenes(self)
        self.on_selected_scene_changed()

    def _selected_scene_index(self):
        result = -1
        for index in range(len(self._scenes)):
            if self._scenes[index].is_selected():
                result = index + 1
                break

        return result
########NEW FILE########
__FILENAME__ = ConfigParser
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Tools/ConfigParser.py
"""Configuration file parser.

A setup file consists of sections, lead by a "[section]" header,
and followed by "name: value" entries, with continuations and such in
the style of RFC 822.

The option values can contain format strings which refer to other values in
the same section, or values in a special [DEFAULT] section.

For example:

    something: %(dir)s/whatever

would resolve the "%(dir)s" to the value of dir.  All reference
expansions are done late, on demand.

Intrinsic defaults can be specified by passing them into the
ConfigParser constructor as a dictionary.

class:

ConfigParser -- responsible for parsing a list of
                configuration files, and managing the parsed database.

    methods:

    __init__(defaults=None)
        create the parser and specify a dictionary of intrinsic defaults.  The
        keys must be strings, the values must be appropriate for %()s string
        interpolation.  Note that `__name__' is always an intrinsic default;
        its value is the section's name.

    sections()
        return all the configuration section names, sans DEFAULT

    has_section(section)
        return whether the given section exists

    has_option(section, option)
        return whether the given option exists in the given section

    options(section)
        return list of configuration options for the named section

    read(filenames)
        read and parse the list of named configuration files, given by
        name.  A single filename is also allowed.  Non-existing files
        are ignored.  Return list of successfully read files.

    readfp(fp, filename=None)
        read and parse one configuration file, given as a file object.
        The filename defaults to fp.name; it is only used in error
        messages (if fp has no `name' attribute, the string `<???>' is used).

    get(section, option, raw=False, vars=None)
        return a string value for the named option.  All % interpolations are
        expanded in the return values, based on the defaults passed into the
        constructor and the DEFAULT section.  Additional substitutions may be
        provided using the `vars' argument, which must be a dictionary whose
        contents override any pre-existing defaults.

    getint(section, options)
        like get(), but convert value to an integer

    getfloat(section, options)
        like get(), but convert value to a float

    getboolean(section, options)
        like get(), but convert value to a boolean (currently case
        insensitively defined as 0, false, no, off for False, and 1, true,
        yes, on for True).  Returns False or True.

    items(section, raw=False, vars=None)
        return a list of tuples with (name, value) for each option
        in the section.

    remove_section(section)
        remove the given file section and all its options

    remove_option(section, option)
        remove the given option from the given section

    set(section, option, value)
        set the given option

    write(fp)
        write the configuration state in .ini format
"""
import re
__all__ = ['NoSectionError',
 'DuplicateSectionError',
 'NoOptionError',
 'InterpolationError',
 'InterpolationDepthError',
 'InterpolationSyntaxError',
 'ParsingError',
 'MissingSectionHeaderError',
 'ConfigParser',
 'SafeConfigParser',
 'RawConfigParser',
 'DEFAULTSECT',
 'MAX_INTERPOLATION_DEPTH']
DEFAULTSECT = 'DEFAULT'
MAX_INTERPOLATION_DEPTH = 10

class Error(Exception):
    """Base class for ConfigParser exceptions."""

    def __init__(self, msg = ''):
        self.message = msg
        Exception.__init__(self, msg)

    def __repr__(self):
        return self.message

    __str__ = __repr__


class NoSectionError(Error):
    """Raised when no section matches a requested option."""

    def __init__(self, section):
        Error.__init__(self, 'No section: %r' % (section,))
        self.section = section


class DuplicateSectionError(Error):
    """Raised when a section is multiply-created."""

    def __init__(self, section):
        Error.__init__(self, 'Section %r already exists' % section)
        self.section = section


class NoOptionError(Error):
    """A requested option was not found."""

    def __init__(self, option, section):
        Error.__init__(self, 'No option %r in section: %r' % (option, section))
        self.option = option
        self.section = section


class InterpolationError(Error):
    """Base class for interpolation-related exceptions."""

    def __init__(self, option, section, msg):
        Error.__init__(self, msg)
        self.option = option
        self.section = section


class InterpolationMissingOptionError(InterpolationError):
    """A string substitution required a setting which was not available."""

    def __init__(self, option, section, rawval, reference):
        msg = 'Bad value substitution:\n\tsection: [%s]\n\toption : %s\n\tkey    : %s\n\trawval : %s\n' % (section,
         option,
         reference,
         rawval)
        InterpolationError.__init__(self, option, section, msg)
        self.reference = reference


class InterpolationSyntaxError(InterpolationError):
    """Raised when the source text into which substitutions are made
    does not conform to the required syntax."""
    pass


class InterpolationDepthError(InterpolationError):
    """Raised when substitutions are nested too deeply."""

    def __init__(self, option, section, rawval):
        msg = 'Value interpolation too deeply recursive:\n\tsection: [%s]\n\toption : %s\n\trawval : %s\n' % (section, option, rawval)
        InterpolationError.__init__(self, option, section, msg)


class ParsingError(Error):
    """Raised when a configuration file does not follow legal syntax."""

    def __init__(self, filename):
        Error.__init__(self, 'File contains parsing errors: %s' % filename)
        self.filename = filename
        self.errors = []

    def append(self, lineno, line):
        self.errors.append((lineno, line))
        self.message += '\n\t[line %2d]: %s' % (lineno, line)


class MissingSectionHeaderError(ParsingError):
    """Raised when a key-value pair is found before any section header."""

    def __init__(self, filename, lineno, line):
        Error.__init__(self, 'File contains no section headers.\nfile: %s, line: %d\n%r' % (filename, lineno, line))
        self.filename = filename
        self.lineno = lineno
        self.line = line


class RawConfigParser():

    def __init__(self, defaults = None):
        self._sections = {}
        self._defaults = {}
        if defaults:
            for key, value in defaults.items():
                self._defaults[self.optionxform(key)] = value

    def defaults(self):
        return self._defaults

    def sections(self):
        """Return a list of section names, excluding [DEFAULT]"""
        return self._sections.keys()

    def add_section(self, section):
        """Create a new section in the configuration.
        
        Raise DuplicateSectionError if a section by the specified name
        already exists.
        """
        if section in self._sections:
            raise DuplicateSectionError(section)
        self._sections[section] = {}

    def has_section(self, section):
        """Indicate whether the named section is present in the configuration.
        
        The DEFAULT section is not acknowledged.
        """
        return section in self._sections

    def options(self, section):
        """Return a list of option names for the given section name."""
        try:
            opts = self._sections[section].copy()
        except KeyError:
            raise NoSectionError(section)

        opts.update(self._defaults)
        if '__name__' in opts:
            del opts['__name__']
        return opts.keys()

    def read(self, filenames):
        """Read and parse a filename or a list of filenames.
        
        Files that cannot be opened are silently ignored; this is
        designed so that you can specify a list of potential
        configuration file locations (e.g. current directory, user's
        home directory, systemwide directory), and all existing
        configuration files in the list will be read.  A single
        filename may also be given.
        
        Return list of successfully read files.
        """
        if isinstance(filenames, basestring):
            filenames = [filenames]
        read_ok = []
        for filename in filenames:
            try:
                fp = open(filename)
            except IOError:
                continue

            self._read(fp, filename)
            fp.close()
            read_ok.append(filename)

        return read_ok

    def readfp(self, fp, filename = None):
        """Like read() but the argument must be a file-like object.
        
        The `fp' argument must have a `readline' method.  Optional
        second argument is the `filename', which if not given, is
        taken from fp.name.  If fp has no `name' attribute, `<???>' is
        used.
        
        """
        if filename is None:
            try:
                filename = fp.name
            except AttributeError:
                filename = '<???>'

        self._read(fp, filename)

    def get(self, section, option):
        opt = self.optionxform(option)
        if section not in self._sections:
            if section != DEFAULTSECT:
                raise NoSectionError(section)
            if opt in self._defaults:
                return self._defaults[opt]
            else:
                raise NoOptionError(option, section)
        elif opt in self._sections[section]:
            return self._sections[section][opt]
        elif opt in self._defaults:
            return self._defaults[opt]
        else:
            raise NoOptionError(option, section)

    def items(self, section):
        try:
            d2 = self._sections[section]
        except KeyError:
            if section != DEFAULTSECT:
                raise NoSectionError(section)
            d2 = {}

        d = self._defaults.copy()
        d.update(d2)
        if '__name__' in d:
            del d['__name__']
        return d.items()

    def _get(self, section, conv, option):
        return conv(self.get(section, option))

    def getint(self, section, option):
        return self._get(section, int, option)

    def getfloat(self, section, option):
        return self._get(section, float, option)

    _boolean_states = {'1': True,
     'yes': True,
     'true': True,
     'on': True,
     '0': False,
     'no': False,
     'false': False,
     'off': False}

    def getboolean(self, section, option):
        v = self.get(section, option)
        if v.lower() not in self._boolean_states:
            raise ValueError, 'Not a boolean: %s' % v
        return self._boolean_states[v.lower()]

    def optionxform(self, optionstr):
        return optionstr.lower()

    def has_option(self, section, option):
        """Check for the existence of a given option in a given section."""
        if not section or section == DEFAULTSECT:
            option = self.optionxform(option)
            return option in self._defaults
        elif section not in self._sections:
            return False
        else:
            option = self.optionxform(option)
            return option in self._sections[section] or option in self._defaults

    def set(self, section, option, value):
        """Set an option."""
        if not section or section == DEFAULTSECT:
            sectdict = self._defaults
        else:
            try:
                sectdict = self._sections[section]
            except KeyError:
                raise NoSectionError(section)

        sectdict[self.optionxform(option)] = value

    def write(self, fp):
        """Write an .ini-format representation of the configuration state."""
        if self._defaults:
            fp.write('[%s]\n' % DEFAULTSECT)
            for key, value in self._defaults.items():
                fp.write('%s = %s\n' % (key, str(value).replace('\n', '\n\t')))

            fp.write('\n')
        for section in self._sections:
            fp.write('[%s]\n' % section)
            for key, value in self._sections[section].items():
                if key != '__name__':
                    fp.write('%s = %s\n' % (key, str(value).replace('\n', '\n\t')))

            fp.write('\n')

    def remove_option(self, section, option):
        """Remove an option."""
        if not section or section == DEFAULTSECT:
            sectdict = self._defaults
        else:
            try:
                sectdict = self._sections[section]
            except KeyError:
                raise NoSectionError(section)

        option = self.optionxform(option)
        existed = option in sectdict
        if existed:
            del sectdict[option]
        return existed

    def remove_section(self, section):
        """Remove a file section."""
        existed = section in self._sections
        if existed:
            del self._sections[section]
        return existed

    SECTCRE = re.compile('\\[(?P<header>[^]]+)\\]')
    OPTCRE = re.compile('(?P<option>[^:=\\s][^:=]*)\\s*(?P<vi>[:=])\\s*(?P<value>.*)$')

    def _read(self, fp, fpname):
        """Parse a sectioned setup file.
        
        The sections in setup file contains a title line at the top,
        indicated by a name in square brackets (`[]'), plus key/value
        options lines, indicated by `name: value' format lines.
        Continuations are represented by an embedded newline then
        leading whitespace.  Blank lines, lines beginning with a '#',
        and just about everything else are ignored.
        """
        cursect = None
        optname = None
        lineno = 0
        e = None
        while True:
            line = fp.readline()
            if not line:
                break
            lineno = lineno + 1
            if line.strip() == '' or line[0] in '#;':
                continue
            if line.split(None, 1)[0].lower() == 'rem' and line[0] in 'rR':
                continue
            if line[0].isspace() and cursect is not None and optname:
                value = line.strip()
                if value:
                    cursect[optname] = '%s\n%s' % (cursect[optname], value)
            else:
                mo = self.SECTCRE.match(line)
                if mo:
                    sectname = mo.group('header')
                    if sectname in self._sections:
                        cursect = self._sections[sectname]
                    elif sectname == DEFAULTSECT:
                        cursect = self._defaults
                    else:
                        cursect = {'__name__': sectname}
                        self._sections[sectname] = cursect
                    optname = None
                elif cursect is None:
                    raise MissingSectionHeaderError(fpname, lineno, line)
                else:
                    mo = self.OPTCRE.match(line)
                    if mo:
                        optname, vi, optval = mo.group('option', 'vi', 'value')
                        if vi in ('=', ':') and ';' in optval:
                            pos = optval.find(';')
                            if pos != -1 and optval[pos - 1].isspace():
                                optval = optval[:pos]
                        optval = optval.strip()
                        if optval == '""':
                            optval = ''
                        optname = self.optionxform(optname.rstrip())
                        cursect[optname] = optval
                    else:
                        if not e:
                            e = ParsingError(fpname)
                        e.append(lineno, repr(line))

        if e:
            raise e


class ConfigParser(RawConfigParser):

    def get(self, section, option, raw = False, vars = None):
        """Get an option value for a given section.
        
        All % interpolations are expanded in the return values, based on the
        defaults passed into the constructor, unless the optional argument
        `raw' is true.  Additional substitutions may be provided using the
        `vars' argument, which must be a dictionary whose contents overrides
        any pre-existing defaults.
        
        The section DEFAULT is special.
        """
        d = self._defaults.copy()
        try:
            d.update(self._sections[section])
        except KeyError:
            if section != DEFAULTSECT:
                raise NoSectionError(section)

        if vars:
            for key, value in vars.items():
                d[self.optionxform(key)] = value

        option = self.optionxform(option)
        try:
            value = d[option]
        except KeyError:
            raise NoOptionError(option, section)

        if raw:
            return value
        else:
            return self._interpolate(section, option, value, d)

    def items(self, section, raw = False, vars = None):
        """Return a list of tuples with (name, value) for each option
        in the section.
        
        All % interpolations are expanded in the return values, based on the
        defaults passed into the constructor, unless the optional argument
        `raw' is true.  Additional substitutions may be provided using the
        `vars' argument, which must be a dictionary whose contents overrides
        any pre-existing defaults.
        
        The section DEFAULT is special.
        """
        d = self._defaults.copy()
        try:
            d.update(self._sections[section])
        except KeyError:
            if section != DEFAULTSECT:
                raise NoSectionError(section)

        if vars:
            for key, value in vars.items():
                d[self.optionxform(key)] = value

        options = d.keys()
        if '__name__' in options:
            options.remove('__name__')
        if raw:
            return [ (option, d[option]) for option in options ]
        else:
            return [ (option, self._interpolate(section, option, d[option], d)) for option in options ]

    def _interpolate(self, section, option, rawval, vars):
        value = rawval
        depth = MAX_INTERPOLATION_DEPTH
        while depth:
            depth -= 1
            if '%(' in value:
                value = self._KEYCRE.sub(self._interpolation_replace, value)
                try:
                    value = value % vars
                except KeyError as e:
                    raise InterpolationMissingOptionError(option, section, rawval, e[0])

            else:
                break

        if '%(' in value:
            raise InterpolationDepthError(option, section, rawval)
        return value

    _KEYCRE = re.compile('%\\(([^)]*)\\)s|.')

    def _interpolation_replace(self, match):
        s = match.group(1)
        if s is None:
            return match.group()
        else:
            return '%%(%s)s' % self.optionxform(s)


class SafeConfigParser(ConfigParser):

    def _interpolate(self, section, option, rawval, vars):
        L = []
        self._interpolate_some(option, L, rawval, section, vars, 1)
        return ''.join(L)

    _interpvar_match = re.compile('%\\(([^)]+)\\)s').match

    def _interpolate_some(self, option, accum, rest, section, map, depth):
        if depth > MAX_INTERPOLATION_DEPTH:
            raise InterpolationDepthError(option, section, rest)
        while rest:
            p = rest.find('%')
            if p < 0:
                accum.append(rest)
                return
            if p > 0:
                accum.append(rest[:p])
                rest = rest[p:]
            c = rest[1:2]
            if c == '%':
                accum.append('%')
                rest = rest[2:]
            elif c == '(':
                m = self._interpvar_match(rest)
                if m is None:
                    raise InterpolationSyntaxError(option, section, 'bad interpolation variable reference %r' % rest)
                var = self.optionxform(m.group(1))
                rest = rest[m.end():]
                try:
                    v = map[var]
                except KeyError:
                    raise InterpolationMissingOptionError(option, section, rest, var)

                if '%' in v:
                    self._interpolate_some(option, accum, v, section, map, depth + 1)
                else:
                    accum.append(v)
            else:
                raise InterpolationSyntaxError(option, section, "'%%' must be followed by '%%' or '(', found: %r" % (rest,))

    def set(self, section, option, value):
        """Set an option.  Extend ConfigParser.set: check for string values."""
        if not isinstance(value, basestring):
            raise TypeError('option values must be strings')
        ConfigParser.set(self, section, option, value)
########NEW FILE########
__FILENAME__ = copy_reg
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Tools/copy_reg.py
"""Helper to provide extensibility for pickle/cPickle.

This is only useful to add pickle support for extension types defined in
C, not for instances of user-defined classes.
"""
from types import ClassType as _ClassType
__all__ = ['pickle',
 'constructor',
 'add_extension',
 'remove_extension',
 'clear_extension_cache']
dispatch_table = {}

def pickle(ob_type, pickle_function, constructor_ob = None):
    if type(ob_type) is _ClassType:
        raise TypeError('copy_reg is not intended for use with classes')
    if not callable(pickle_function):
        raise TypeError('reduction functions must be callable')
    dispatch_table[ob_type] = pickle_function
    if constructor_ob is not None:
        constructor(constructor_ob)


def constructor(object):
    if not callable(object):
        raise TypeError('constructors must be callable')


try:
    complex
except NameError:
    pass
else:

    def pickle_complex(c):
        return (complex, (c.real, c.imag))


    pickle(complex, pickle_complex, complex)

def _reconstructor(cls, base, state):
    if base is object:
        obj = object.__new__(cls)
    else:
        obj = base.__new__(cls, state)
        base.__init__(obj, state)
    return obj


_HEAPTYPE = 512

def _reduce_ex(self, proto):
    if not proto < 2:
        raise AssertionError
        for base in self.__class__.__mro__:
            if hasattr(base, '__flags__') and not base.__flags__ & _HEAPTYPE:
                break
        else:
            base = object

        if base is object:
            state = None
        else:
            if base is self.__class__:
                raise TypeError, "can't pickle %s objects" % base.__name__
            state = base(self)
        args = (self.__class__, base, state)
        try:
            getstate = self.__getstate__
        except AttributeError:
            if getattr(self, '__slots__', None):
                raise TypeError('a class that defines __slots__ without defining __getstate__ cannot be pickled')
            try:
                dict = self.__dict__
            except AttributeError:
                dict = None

        else:
            dict = getstate()

        return dict and (_reconstructor, args, dict)
    else:
        return (_reconstructor, args)


def __newobj__(cls, *args):
    return cls.__new__(cls, *args)


def _slotnames(cls):
    """Return a list of slot names for a given class.
    
    This needs to find slots defined by the class and its bases, so we
    can't simply return the __slots__ attribute.  We must walk down
    the Method Resolution Order and concatenate the __slots__ of each
    class found there.  (This assumes classes don't modify their
    __slots__ attribute to misrepresent their slots after the class is
    defined.)
    """
    names = cls.__dict__.get('__slotnames__')
    if names is not None:
        return names
    names = []
    if not hasattr(cls, '__slots__'):
        pass
    else:
        for c in cls.__mro__:
            if '__slots__' in c.__dict__:
                slots = c.__dict__['__slots__']
                if isinstance(slots, basestring):
                    slots = (slots,)
                for name in slots:
                    if name in ('__dict__', '__weakref__'):
                        continue
                    elif name.startswith('__') and not name.endswith('__'):
                        names.append('_%s%s' % (c.__name__, name))
                    else:
                        names.append(name)

    try:
        cls.__slotnames__ = names
    except:
        pass

    return names


_extension_registry = {}
_inverted_registry = {}
_extension_cache = {}

def add_extension(module, name, code):
    """Register an extension code."""
    code = int(code)
    if not 1 <= code <= 2147483647:
        raise ValueError, 'code out of range'
    key = (module, name)
    if _extension_registry.get(key) == code:
        if _inverted_registry.get(code) == key:
            return
    if key in _extension_registry:
        raise ValueError('key %s is already registered with code %s' % (key, _extension_registry[key]))
    if code in _inverted_registry:
        raise ValueError('code %s is already in use for key %s' % (code, _inverted_registry[code]))
    _extension_registry[key] = code
    _inverted_registry[code] = key


def remove_extension(module, name, code):
    """Unregister an extension code.  For testing only."""
    key = (module, name)
    if _extension_registry.get(key) != code or _inverted_registry.get(code) != key:
        raise ValueError('key %s is not registered with code %s' % (key, code))
    del _extension_registry[key]
    del _inverted_registry[code]
    if code in _extension_cache:
        del _extension_cache[code]


def clear_extension_cache():
    _extension_cache.clear()
########NEW FILE########
__FILENAME__ = re
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Tools/re.py
r"""Support for regular expressions (RE).

This module provides regular expression matching operations similar to
those found in Perl.  It supports both 8-bit and Unicode strings; both
the pattern and the strings being processed can contain null bytes and
characters outside the US ASCII range.

Regular expressions can contain both special and ordinary characters.
Most ordinary characters, like "A", "a", or "0", are the simplest
regular expressions; they simply match themselves.  You can
concatenate ordinary characters, so last matches the string 'last'.

The special characters are:
    "."      Matches any character except a newline.
    "^"      Matches the start of the string.
    "$"      Matches the end of the string.
    "*"      Matches 0 or more (greedy) repetitions of the preceding RE.
             Greedy means that it will match as many repetitions as possible.
    "+"      Matches 1 or more (greedy) repetitions of the preceding RE.
    "?"      Matches 0 or 1 (greedy) of the preceding RE.
    *?,+?,?? Non-greedy versions of the previous three special characters.
    {m,n}    Matches from m to n repetitions of the preceding RE.
    {m,n}?   Non-greedy version of the above.
    "\\"      Either escapes special characters or signals a special sequence.
    []       Indicates a set of characters.
             A "^" as the first character indicates a complementing set.
    "|"      A|B, creates an RE that will match either A or B.
    (...)    Matches the RE inside the parentheses.
             The contents can be retrieved or matched later in the string.
    (?iLmsux) Set the I, L, M, S, U, or X flag for the RE (see below).
    (?:...)  Non-grouping version of regular parentheses.
    (?P<name>...) The substring matched by the group is accessible by name.
    (?P=name)     Matches the text matched earlier by the group named name.
    (?#...)  A comment; ignored.
    (?=...)  Matches if ... matches next, but doesn't consume the string.
    (?!...)  Matches if ... doesn't match next.

The special sequences consist of "\\" and a character from the list
below.  If the ordinary character is not on the list, then the
resulting RE will match the second character.
    \number  Matches the contents of the group of the same number.
    \A       Matches only at the start of the string.
    \Z       Matches only at the end of the string.
    \b       Matches the empty string, but only at the start or end of a word.
    \B       Matches the empty string, but not at the start or end of a word.
    \d       Matches any decimal digit; equivalent to the set [0-9].
    \D       Matches any non-digit character; equivalent to the set [^0-9].
    \s       Matches any whitespace character; equivalent to [ \t\n\r\f\v].
    \S       Matches any non-whitespace character; equiv. to [^ \t\n\r\f\v].
    \w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_].
             With LOCALE, it will match the set [0-9_] plus characters defined
             as letters for the current locale.
    \W       Matches the complement of \w.
    \\       Matches a literal backslash.

This module exports the following functions:
    match    Match a regular expression pattern to the beginning of a string.
    search   Search a string for the presence of a pattern.
    sub      Substitute occurrences of a pattern found in a string.
    subn     Same as sub, but also return the number of substitutions made.
    split    Split a string by the occurrences of a pattern.
    findall  Find all occurrences of a pattern in a string.
    compile  Compile a pattern into a RegexObject.
    purge    Clear the regular expression cache.
    escape   Backslash all non-alphanumerics in a string.

Some of the functions in this module takes flags as optional parameters:
    I  IGNORECASE  Perform case-insensitive matching.
    L  LOCALE      Make \w, \W, \b, \B, dependent on the current locale.
    M  MULTILINE   "^" matches the beginning of lines as well as the string.
                   "$" matches the end of lines as well as the string.
    S  DOTALL      "." matches any character at all, including the newline.
    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.
    U  UNICODE     Make \w, \W, \b, \B, dependent on the Unicode locale.

This module also defines an exception 'error'.

"""
import sys
import sre_compile
import sre_parse
__all__ = ['match',
 'search',
 'sub',
 'subn',
 'split',
 'findall',
 'compile',
 'purge',
 'template',
 'escape',
 'I',
 'L',
 'M',
 'S',
 'X',
 'U',
 'IGNORECASE',
 'LOCALE',
 'MULTILINE',
 'DOTALL',
 'VERBOSE',
 'UNICODE',
 'error']
__version__ = '2.2.1'
I = IGNORECASE = sre_compile.SRE_FLAG_IGNORECASE
L = LOCALE = sre_compile.SRE_FLAG_LOCALE
U = UNICODE = sre_compile.SRE_FLAG_UNICODE
M = MULTILINE = sre_compile.SRE_FLAG_MULTILINE
S = DOTALL = sre_compile.SRE_FLAG_DOTALL
X = VERBOSE = sre_compile.SRE_FLAG_VERBOSE
T = TEMPLATE = sre_compile.SRE_FLAG_TEMPLATE
DEBUG = sre_compile.SRE_FLAG_DEBUG
error = sre_compile.error

def match(pattern, string, flags = 0):
    """Try to apply the pattern at the start of the string, returning
    a match object, or None if no match was found."""
    return _compile(pattern, flags).match(string)


def search(pattern, string, flags = 0):
    """Scan through string looking for a match to the pattern, returning
    a match object, or None if no match was found."""
    return _compile(pattern, flags).search(string)


def sub(pattern, repl, string, count = 0):
    """Return the string obtained by replacing the leftmost
    non-overlapping occurrences of the pattern in string by the
    replacement repl.  repl can be either a string or a callable;
    if a callable, it's passed the match object and must return
    a replacement string to be used."""
    return _compile(pattern, 0).sub(repl, string, count)


def subn(pattern, repl, string, count = 0):
    """Return a 2-tuple containing (new_string, number).
    new_string is the string obtained by replacing the leftmost
    non-overlapping occurrences of the pattern in the source
    string by the replacement repl.  number is the number of
    substitutions that were made. repl can be either a string or a
    callable; if a callable, it's passed the match object and must
    return a replacement string to be used."""
    return _compile(pattern, 0).subn(repl, string, count)


def split(pattern, string, maxsplit = 0):
    """Split the source string by the occurrences of the pattern,
    returning a list containing the resulting substrings."""
    return _compile(pattern, 0).split(string, maxsplit)


def findall(pattern, string, flags = 0):
    """Return a list of all non-overlapping matches in the string.
    
    If one or more groups are present in the pattern, return a
    list of groups; this will be a list of tuples if the pattern
    has more than one group.
    
    Empty matches are included in the result."""
    return _compile(pattern, flags).findall(string)


if sys.hexversion >= 33685504:
    __all__.append('finditer')

    def finditer(pattern, string, flags = 0):
        """Return an iterator over all non-overlapping matches in the
        string.  For each match, the iterator returns a match object.
        
        Empty matches are included in the result."""
        return _compile(pattern, flags).finditer(string)


def compile(pattern, flags = 0):
    """Compile a regular expression pattern, returning a pattern object."""
    return _compile(pattern, flags)


def purge():
    """Clear the regular expression cache"""
    _cache.clear()
    _cache_repl.clear()


def template(pattern, flags = 0):
    """Compile a template pattern, returning a pattern object"""
    return _compile(pattern, flags | T)


_alphanum = {}
for c in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890':
    _alphanum[c] = 1

del c

def escape(pattern):
    """Escape all non-alphanumeric characters in pattern."""
    s = list(pattern)
    alphanum = _alphanum
    for i in range(len(pattern)):
        c = pattern[i]
        if c not in alphanum:
            if c == '\x00':
                s[i] = '\\000'
            else:
                s[i] = '\\' + c

    return pattern[:0].join(s)


_cache = {}
_cache_repl = {}
_pattern_type = type(sre_compile.compile('', 0))
_MAXCACHE = 100

def _compile(*key):
    cachekey = (type(key[0]),) + key
    p = _cache.get(cachekey)
    if p is not None:
        return p
    pattern, flags = key
    if isinstance(pattern, _pattern_type):
        return pattern
    if not sre_compile.isstring(pattern):
        raise TypeError, 'first argument must be string or compiled pattern'
    try:
        p = sre_compile.compile(pattern, flags)
    except error as v:
        raise error, v

    if len(_cache) >= _MAXCACHE:
        _cache.clear()
    _cache[cachekey] = p
    return p


def _compile_repl(*key):
    p = _cache_repl.get(key)
    if p is not None:
        return p
    repl, pattern = key
    try:
        p = sre_parse.parse_template(repl, pattern)
    except error as v:
        raise error, v

    if len(_cache_repl) >= _MAXCACHE:
        _cache_repl.clear()
    _cache_repl[key] = p
    return p


def _expand(pattern, match, template):
    template = sre_parse.parse_template(template, pattern)
    return sre_parse.expand_template(template, match)


def _subx(pattern, template):
    template = _compile_repl(template, pattern)
    if not template[0] and len(template[1]) == 1:
        return template[1][0]

    def filter(match, template = template):
        return sre_parse.expand_template(template, match)

    return filter


import copy_reg

def _pickle(p):
    return (_compile, (p.pattern, p.flags))


copy_reg.pickle(_pattern_type, _pickle, _compile)

class Scanner:

    def __init__(self, lexicon, flags = 0):
        from sre_constants import BRANCH, SUBPATTERN
        self.lexicon = lexicon
        p = []
        s = sre_parse.Pattern()
        s.flags = flags
        for phrase, action in lexicon:
            p.append(sre_parse.SubPattern(s, [(SUBPATTERN, (len(p) + 1, sre_parse.parse(phrase, flags)))]))

        p = sre_parse.SubPattern(s, [(BRANCH, (None, p))])
        s.groups = len(p)
        self.scanner = sre_compile.compile(p)

    def scan(self, string):
        result = []
        append = result.append
        match = self.scanner.scanner(string).match
        i = 0
        while 1:
            m = match()
            if not m:
                break
            j = m.end()
            if i == j:
                break
            action = self.lexicon[m.lastindex - 1][1]
            if callable(action):
                self.match = m
                action = action(self, m.group())
            if action is not None:
                append(action)
            i = j

        return (result, string[i:])
########NEW FILE########
__FILENAME__ = sre_compile
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Tools/sre_compile.py
"""Internal support module for sre"""
import _sre, sys
from sre_constants import *
if not _sre.MAGIC == MAGIC:
    raise AssertionError, 'SRE module mismatch'
    MAXCODE = _sre.CODESIZE == 2 and 65535
else:
    MAXCODE = 4294967295L

def _identityfunction(x):
    return x


def set(seq):
    s = {}
    for elem in seq:
        s[elem] = 1

    return s


_LITERAL_CODES = set([LITERAL, NOT_LITERAL])
_REPEATING_CODES = set([REPEAT, MIN_REPEAT, MAX_REPEAT])
_SUCCESS_CODES = set([SUCCESS, FAILURE])
_ASSERT_CODES = set([ASSERT, ASSERT_NOT])

def _compile(code, pattern, flags):
    emit = code.append
    _len = len
    LITERAL_CODES = _LITERAL_CODES
    REPEATING_CODES = _REPEATING_CODES
    SUCCESS_CODES = _SUCCESS_CODES
    ASSERT_CODES = _ASSERT_CODES
    for op, av in pattern:
        if op in LITERAL_CODES:
            if flags & SRE_FLAG_IGNORECASE:
                emit(OPCODES[OP_IGNORE[op]])
                emit(_sre.getlower(av, flags))
            else:
                emit(OPCODES[op])
                emit(av)
        elif op is IN:
            if flags & SRE_FLAG_IGNORECASE:
                emit(OPCODES[OP_IGNORE[op]])

                def fixup(literal, flags = flags):
                    return _sre.getlower(literal, flags)

            else:
                emit(OPCODES[op])
                fixup = _identityfunction
            skip = _len(code)
            emit(0)
            _compile_charset(av, flags, code, fixup)
            code[skip] = _len(code) - skip
        elif op is ANY:
            if flags & SRE_FLAG_DOTALL:
                emit(OPCODES[ANY_ALL])
            else:
                emit(OPCODES[ANY])
        elif op in REPEATING_CODES:
            if flags & SRE_FLAG_TEMPLATE:
                raise error, 'internal: unsupported template operator'
                emit(OPCODES[REPEAT])
                skip = _len(code)
                emit(0)
                emit(av[0])
                emit(av[1])
                _compile(code, av[2], flags)
                emit(OPCODES[SUCCESS])
                code[skip] = _len(code) - skip
            elif _simple(av) and op is not REPEAT:
                if op is MAX_REPEAT:
                    emit(OPCODES[REPEAT_ONE])
                else:
                    emit(OPCODES[MIN_REPEAT_ONE])
                skip = _len(code)
                emit(0)
                emit(av[0])
                emit(av[1])
                _compile(code, av[2], flags)
                emit(OPCODES[SUCCESS])
                code[skip] = _len(code) - skip
            else:
                emit(OPCODES[REPEAT])
                skip = _len(code)
                emit(0)
                emit(av[0])
                emit(av[1])
                _compile(code, av[2], flags)
                code[skip] = _len(code) - skip
                if op is MAX_REPEAT:
                    emit(OPCODES[MAX_UNTIL])
                else:
                    emit(OPCODES[MIN_UNTIL])
        elif op is SUBPATTERN:
            if av[0]:
                emit(OPCODES[MARK])
                emit((av[0] - 1) * 2)
            _compile(code, av[1], flags)
            if av[0]:
                emit(OPCODES[MARK])
                emit((av[0] - 1) * 2 + 1)
        elif op in SUCCESS_CODES:
            emit(OPCODES[op])
        elif op in ASSERT_CODES:
            emit(OPCODES[op])
            skip = _len(code)
            emit(0)
            if av[0] >= 0:
                emit(0)
            else:
                lo, hi = av[1].getwidth()
                if lo != hi:
                    raise error, 'look-behind requires fixed-width pattern'
                emit(lo)
            _compile(code, av[1], flags)
            emit(OPCODES[SUCCESS])
            code[skip] = _len(code) - skip
        elif op is CALL:
            emit(OPCODES[op])
            skip = _len(code)
            emit(0)
            _compile(code, av, flags)
            emit(OPCODES[SUCCESS])
            code[skip] = _len(code) - skip
        elif op is AT:
            emit(OPCODES[op])
            if flags & SRE_FLAG_MULTILINE:
                av = AT_MULTILINE.get(av, av)
            if flags & SRE_FLAG_LOCALE:
                av = AT_LOCALE.get(av, av)
            elif flags & SRE_FLAG_UNICODE:
                av = AT_UNICODE.get(av, av)
            emit(ATCODES[av])
        elif op is BRANCH:
            emit(OPCODES[op])
            tail = []
            tailappend = tail.append
            for av in av[1]:
                skip = _len(code)
                emit(0)
                _compile(code, av, flags)
                emit(OPCODES[JUMP])
                tailappend(_len(code))
                emit(0)
                code[skip] = _len(code) - skip

            emit(0)
            for tail in tail:
                code[tail] = _len(code) - tail

        elif op is CATEGORY:
            emit(OPCODES[op])
            if flags & SRE_FLAG_LOCALE:
                av = CH_LOCALE[av]
            elif flags & SRE_FLAG_UNICODE:
                av = CH_UNICODE[av]
            emit(CHCODES[av])
        elif op is GROUPREF:
            if flags & SRE_FLAG_IGNORECASE:
                emit(OPCODES[OP_IGNORE[op]])
            else:
                emit(OPCODES[op])
            emit(av - 1)
        elif op is GROUPREF_EXISTS:
            emit(OPCODES[op])
            emit(av[0] - 1)
            skipyes = _len(code)
            emit(0)
            _compile(code, av[1], flags)
            if av[2]:
                emit(OPCODES[JUMP])
                skipno = _len(code)
                emit(0)
                code[skipyes] = _len(code) - skipyes + 1
                _compile(code, av[2], flags)
                code[skipno] = _len(code) - skipno
            else:
                code[skipyes] = _len(code) - skipyes + 1
        else:
            raise ValueError, ('unsupported operand type', op)


def _compile_charset(charset, flags, code, fixup = None):
    emit = code.append
    if fixup is None:
        fixup = _identityfunction
    for op, av in _optimize_charset(charset, fixup):
        emit(OPCODES[op])
        if op is NEGATE:
            pass
        elif op is LITERAL:
            emit(fixup(av))
        elif op is RANGE:
            emit(fixup(av[0]))
            emit(fixup(av[1]))
        elif op is CHARSET:
            code.extend(av)
        elif op is BIGCHARSET:
            code.extend(av)
        elif op is CATEGORY:
            if flags & SRE_FLAG_LOCALE:
                emit(CHCODES[CH_LOCALE[av]])
            elif flags & SRE_FLAG_UNICODE:
                emit(CHCODES[CH_UNICODE[av]])
            else:
                emit(CHCODES[av])
        else:
            raise error, 'internal: unsupported set operator'

    emit(OPCODES[FAILURE])


def _optimize_charset(charset, fixup):
    out = []
    outappend = out.append
    charmap = [0] * 256
    try:
        for op, av in charset:
            if op is NEGATE:
                outappend((op, av))
            elif op is LITERAL:
                charmap[fixup(av)] = 1
            elif op is RANGE:
                for i in range(fixup(av[0]), fixup(av[1]) + 1):
                    charmap[i] = 1

            elif op is CATEGORY:
                return charset

    except IndexError:
        return _optimize_unicode(charset, fixup)

    i = p = n = 0
    runs = []
    runsappend = runs.append
    for c in charmap:
        if c:
            if n == 0:
                p = i
            n = n + 1
        elif n:
            runsappend((p, n))
            n = 0
        i = i + 1

    if n:
        runsappend((p, n))
    if len(runs) <= 2:
        for p, n in runs:
            if n == 1:
                outappend((LITERAL, p))
            else:
                outappend((RANGE, (p, p + n - 1)))

        if len(out) < len(charset):
            return out
    else:
        data = _mk_bitmap(charmap)
        outappend((CHARSET, data))
        return out
    return charset


def _mk_bitmap(bits):
    data = []
    dataappend = data.append
    if _sre.CODESIZE == 2:
        start = (1, 0)
    else:
        start = (1L, 0L)
    m, v = start
    for c in bits:
        if c:
            v = v + m
        m = m + m
        if m > MAXCODE:
            dataappend(v)
            m, v = start

    return data


def _optimize_unicode(charset, fixup):
    try:
        import array
    except ImportError:
        return charset

    charmap = [0] * 65536
    negate = 0
    try:
        for op, av in charset:
            if op is NEGATE:
                negate = 1
            elif op is LITERAL:
                charmap[fixup(av)] = 1
            elif op is RANGE:
                for i in xrange(fixup(av[0]), fixup(av[1]) + 1):
                    charmap[i] = 1

            elif op is CATEGORY:
                return charset

    except IndexError:
        return charset

    if negate:
        if sys.maxunicode != 65535:
            return charset
        for i in xrange(65536):
            charmap[i] = not charmap[i]

    comps = {}
    mapping = [0] * 256
    block = 0
    data = []
    for i in xrange(256):
        chunk = tuple(charmap[i * 256:(i + 1) * 256])
        new = comps.setdefault(chunk, block)
        mapping[i] = new
        if new == block:
            block = block + 1
            data = data + _mk_bitmap(chunk)

    header = [block]
    if _sre.CODESIZE == 2:
        code = 'H'
    else:
        code = 'I'
    mapping = array.array('b', mapping).tostring()
    mapping = array.array(code, mapping)
    raise mapping.itemsize == _sre.CODESIZE or AssertionError
    header = header + mapping.tolist()
    data[0:0] = header
    return [(BIGCHARSET, data)]


def _simple(av):
    lo, hi = av[2].getwidth()
    if lo == 0 and hi == MAXREPEAT:
        raise error, 'nothing to repeat'
    return lo == hi == 1 and av[2][0][0] != SUBPATTERN


def _compile_info(code, pattern, flags):
    lo, hi = pattern.getwidth()
    if lo == 0:
        return
    prefix = []
    prefixappend = prefix.append
    prefix_skip = 0
    charset = []
    charsetappend = charset.append
    if not flags & SRE_FLAG_IGNORECASE:
        for op, av in pattern.data:
            if op is LITERAL:
                if len(prefix) == prefix_skip:
                    prefix_skip = prefix_skip + 1
                prefixappend(av)
            elif op is SUBPATTERN and len(av[1]) == 1:
                op, av = av[1][0]
                if op is LITERAL:
                    prefixappend(av)
                else:
                    break
            else:
                break

        if not prefix and pattern.data:
            op, av = pattern.data[0]
            if op is SUBPATTERN and av[1]:
                op, av = av[1][0]
                if op is LITERAL:
                    charsetappend((op, av))
                elif op is BRANCH:
                    c = []
                    cappend = c.append
                    for p in av[1]:
                        if not p:
                            break
                        op, av = p[0]
                        if op is LITERAL:
                            cappend((op, av))
                        else:
                            break
                    else:
                        charset = c

            elif op is BRANCH:
                c = []
                cappend = c.append
                for p in av[1]:
                    if not p:
                        break
                    op, av = p[0]
                    if op is LITERAL:
                        cappend((op, av))
                    else:
                        break
                else:
                    charset = c

            elif op is IN:
                charset = av
    emit = code.append
    emit(OPCODES[INFO])
    skip = len(code)
    emit(0)
    mask = 0
    if prefix:
        mask = SRE_INFO_PREFIX
        if len(prefix) == prefix_skip == len(pattern.data):
            mask = mask + SRE_INFO_LITERAL
    elif charset:
        mask = mask + SRE_INFO_CHARSET
    emit(mask)
    if lo < MAXCODE:
        emit(lo)
    else:
        emit(MAXCODE)
        prefix = prefix[:MAXCODE]
    if hi < MAXCODE:
        emit(hi)
    else:
        emit(0)
    if prefix:
        emit(len(prefix))
        emit(prefix_skip)
        code.extend(prefix)
        table = [-1] + [0] * len(prefix)
        for i in xrange(len(prefix)):
            table[i + 1] = table[i] + 1
            while table[i + 1] > 0 and prefix[i] != prefix[table[i + 1] - 1]:
                table[i + 1] = table[table[i + 1] - 1] + 1

        code.extend(table[1:])
    elif charset:
        _compile_charset(charset, flags, code)
    code[skip] = len(code) - skip


try:
    unicode
except NameError:
    STRING_TYPES = (type(''),)
else:
    STRING_TYPES = (type(''), type(unicode('')))

def isstring(obj):
    for tp in STRING_TYPES:
        if isinstance(obj, tp):
            return 1

    return 0


def _code(p, flags):
    flags = p.pattern.flags | flags
    code = []
    _compile_info(code, p, flags)
    _compile(code, p.data, flags)
    code.append(OPCODES[SUCCESS])
    return code


def compile(p, flags = 0):
    if isstring(p):
        import sre_parse
        pattern = p
        p = sre_parse.parse(p, flags)
    else:
        pattern = None
    code = _code(p, flags)
    if p.pattern.groups > 100:
        raise AssertionError('sorry, but this version only supports 100 named groups')
    groupindex = p.pattern.groupdict
    indexgroup = [None] * p.pattern.groups
    for k, i in groupindex.items():
        indexgroup[i] = k

    return _sre.compile(pattern, flags, code, p.pattern.groups - 1, groupindex, indexgroup)
########NEW FILE########
__FILENAME__ = sre_constants
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Tools/sre_constants.py
"""Internal support module for sre"""
MAGIC = 20031017
MAXREPEAT = 65535

class error(Exception):
    pass


FAILURE = 'failure'
SUCCESS = 'success'
ANY = 'any'
ANY_ALL = 'any_all'
ASSERT = 'assert'
ASSERT_NOT = 'assert_not'
AT = 'at'
BIGCHARSET = 'bigcharset'
BRANCH = 'branch'
CALL = 'call'
CATEGORY = 'category'
CHARSET = 'charset'
GROUPREF = 'groupref'
GROUPREF_IGNORE = 'groupref_ignore'
GROUPREF_EXISTS = 'groupref_exists'
IN = 'in'
IN_IGNORE = 'in_ignore'
INFO = 'info'
JUMP = 'jump'
LITERAL = 'literal'
LITERAL_IGNORE = 'literal_ignore'
MARK = 'mark'
MAX_REPEAT = 'max_repeat'
MAX_UNTIL = 'max_until'
MIN_REPEAT = 'min_repeat'
MIN_UNTIL = 'min_until'
NEGATE = 'negate'
NOT_LITERAL = 'not_literal'
NOT_LITERAL_IGNORE = 'not_literal_ignore'
RANGE = 'range'
REPEAT = 'repeat'
REPEAT_ONE = 'repeat_one'
SUBPATTERN = 'subpattern'
MIN_REPEAT_ONE = 'min_repeat_one'
AT_BEGINNING = 'at_beginning'
AT_BEGINNING_LINE = 'at_beginning_line'
AT_BEGINNING_STRING = 'at_beginning_string'
AT_BOUNDARY = 'at_boundary'
AT_NON_BOUNDARY = 'at_non_boundary'
AT_END = 'at_end'
AT_END_LINE = 'at_end_line'
AT_END_STRING = 'at_end_string'
AT_LOC_BOUNDARY = 'at_loc_boundary'
AT_LOC_NON_BOUNDARY = 'at_loc_non_boundary'
AT_UNI_BOUNDARY = 'at_uni_boundary'
AT_UNI_NON_BOUNDARY = 'at_uni_non_boundary'
CATEGORY_DIGIT = 'category_digit'
CATEGORY_NOT_DIGIT = 'category_not_digit'
CATEGORY_SPACE = 'category_space'
CATEGORY_NOT_SPACE = 'category_not_space'
CATEGORY_WORD = 'category_word'
CATEGORY_NOT_WORD = 'category_not_word'
CATEGORY_LINEBREAK = 'category_linebreak'
CATEGORY_NOT_LINEBREAK = 'category_not_linebreak'
CATEGORY_LOC_WORD = 'category_loc_word'
CATEGORY_LOC_NOT_WORD = 'category_loc_not_word'
CATEGORY_UNI_DIGIT = 'category_uni_digit'
CATEGORY_UNI_NOT_DIGIT = 'category_uni_not_digit'
CATEGORY_UNI_SPACE = 'category_uni_space'
CATEGORY_UNI_NOT_SPACE = 'category_uni_not_space'
CATEGORY_UNI_WORD = 'category_uni_word'
CATEGORY_UNI_NOT_WORD = 'category_uni_not_word'
CATEGORY_UNI_LINEBREAK = 'category_uni_linebreak'
CATEGORY_UNI_NOT_LINEBREAK = 'category_uni_not_linebreak'
OPCODES = [FAILURE,
 SUCCESS,
 ANY,
 ANY_ALL,
 ASSERT,
 ASSERT_NOT,
 AT,
 BRANCH,
 CALL,
 CATEGORY,
 CHARSET,
 BIGCHARSET,
 GROUPREF,
 GROUPREF_EXISTS,
 GROUPREF_IGNORE,
 IN,
 IN_IGNORE,
 INFO,
 JUMP,
 LITERAL,
 LITERAL_IGNORE,
 MARK,
 MAX_UNTIL,
 MIN_UNTIL,
 NOT_LITERAL,
 NOT_LITERAL_IGNORE,
 NEGATE,
 RANGE,
 REPEAT,
 REPEAT_ONE,
 SUBPATTERN,
 MIN_REPEAT_ONE]
ATCODES = [AT_BEGINNING,
 AT_BEGINNING_LINE,
 AT_BEGINNING_STRING,
 AT_BOUNDARY,
 AT_NON_BOUNDARY,
 AT_END,
 AT_END_LINE,
 AT_END_STRING,
 AT_LOC_BOUNDARY,
 AT_LOC_NON_BOUNDARY,
 AT_UNI_BOUNDARY,
 AT_UNI_NON_BOUNDARY]
CHCODES = [CATEGORY_DIGIT,
 CATEGORY_NOT_DIGIT,
 CATEGORY_SPACE,
 CATEGORY_NOT_SPACE,
 CATEGORY_WORD,
 CATEGORY_NOT_WORD,
 CATEGORY_LINEBREAK,
 CATEGORY_NOT_LINEBREAK,
 CATEGORY_LOC_WORD,
 CATEGORY_LOC_NOT_WORD,
 CATEGORY_UNI_DIGIT,
 CATEGORY_UNI_NOT_DIGIT,
 CATEGORY_UNI_SPACE,
 CATEGORY_UNI_NOT_SPACE,
 CATEGORY_UNI_WORD,
 CATEGORY_UNI_NOT_WORD,
 CATEGORY_UNI_LINEBREAK,
 CATEGORY_UNI_NOT_LINEBREAK]

def makedict(list):
    d = {}
    i = 0
    for item in list:
        d[item] = i
        i = i + 1

    return d


OPCODES = makedict(OPCODES)
ATCODES = makedict(ATCODES)
CHCODES = makedict(CHCODES)
OP_IGNORE = {GROUPREF: GROUPREF_IGNORE,
 IN: IN_IGNORE,
 LITERAL: LITERAL_IGNORE,
 NOT_LITERAL: NOT_LITERAL_IGNORE}
AT_MULTILINE = {AT_BEGINNING: AT_BEGINNING_LINE,
 AT_END: AT_END_LINE}
AT_LOCALE = {AT_BOUNDARY: AT_LOC_BOUNDARY,
 AT_NON_BOUNDARY: AT_LOC_NON_BOUNDARY}
AT_UNICODE = {AT_BOUNDARY: AT_UNI_BOUNDARY,
 AT_NON_BOUNDARY: AT_UNI_NON_BOUNDARY}
CH_LOCALE = {CATEGORY_DIGIT: CATEGORY_DIGIT,
 CATEGORY_NOT_DIGIT: CATEGORY_NOT_DIGIT,
 CATEGORY_SPACE: CATEGORY_SPACE,
 CATEGORY_NOT_SPACE: CATEGORY_NOT_SPACE,
 CATEGORY_WORD: CATEGORY_LOC_WORD,
 CATEGORY_NOT_WORD: CATEGORY_LOC_NOT_WORD,
 CATEGORY_LINEBREAK: CATEGORY_LINEBREAK,
 CATEGORY_NOT_LINEBREAK: CATEGORY_NOT_LINEBREAK}
CH_UNICODE = {CATEGORY_DIGIT: CATEGORY_UNI_DIGIT,
 CATEGORY_NOT_DIGIT: CATEGORY_UNI_NOT_DIGIT,
 CATEGORY_SPACE: CATEGORY_UNI_SPACE,
 CATEGORY_NOT_SPACE: CATEGORY_UNI_NOT_SPACE,
 CATEGORY_WORD: CATEGORY_UNI_WORD,
 CATEGORY_NOT_WORD: CATEGORY_UNI_NOT_WORD,
 CATEGORY_LINEBREAK: CATEGORY_UNI_LINEBREAK,
 CATEGORY_NOT_LINEBREAK: CATEGORY_UNI_NOT_LINEBREAK}
SRE_FLAG_TEMPLATE = 1
SRE_FLAG_IGNORECASE = 2
SRE_FLAG_LOCALE = 4
SRE_FLAG_MULTILINE = 8
SRE_FLAG_DOTALL = 16
SRE_FLAG_UNICODE = 32
SRE_FLAG_VERBOSE = 64
SRE_FLAG_DEBUG = 128
SRE_INFO_PREFIX = 1
SRE_INFO_LITERAL = 2
SRE_INFO_CHARSET = 4
if __name__ == '__main__':

    def dump(f, d, prefix):
        items = d.items()
        items.sort(key=lambda a: a[1])
        for k, v in items:
            f.write('#define %s_%s %s\n' % (prefix, k.upper(), v))


    f = open('sre_constants.h', 'w')
    f.write("/*\n * Secret Labs' Regular Expression Engine\n *\n * regular expression matching engine\n *\n * NOTE: This file is generated by sre_constants.py.  If you need\n * to change anything in here, edit sre_constants.py and run it.\n *\n * Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.\n *\n * See the _sre.c file for information on usage and redistribution.\n */\n\n")
    f.write('#define SRE_MAGIC %d\n' % MAGIC)
    dump(f, OPCODES, 'SRE_OP')
    dump(f, ATCODES, 'SRE')
    dump(f, CHCODES, 'SRE')
    f.write('#define SRE_FLAG_TEMPLATE %d\n' % SRE_FLAG_TEMPLATE)
    f.write('#define SRE_FLAG_IGNORECASE %d\n' % SRE_FLAG_IGNORECASE)
    f.write('#define SRE_FLAG_LOCALE %d\n' % SRE_FLAG_LOCALE)
    f.write('#define SRE_FLAG_MULTILINE %d\n' % SRE_FLAG_MULTILINE)
    f.write('#define SRE_FLAG_DOTALL %d\n' % SRE_FLAG_DOTALL)
    f.write('#define SRE_FLAG_UNICODE %d\n' % SRE_FLAG_UNICODE)
    f.write('#define SRE_FLAG_VERBOSE %d\n' % SRE_FLAG_VERBOSE)
    f.write('#define SRE_INFO_PREFIX %d\n' % SRE_INFO_PREFIX)
    f.write('#define SRE_INFO_LITERAL %d\n' % SRE_INFO_LITERAL)
    f.write('#define SRE_INFO_CHARSET %d\n' % SRE_INFO_CHARSET)
    f.close()
    print 'done'
########NEW FILE########
__FILENAME__ = sre_parse
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Tools/sre_parse.py
"""Internal support module for sre"""
import sys
from sre_constants import *

def set(seq):
    s = {}
    for elem in seq:
        s[elem] = 1

    return s


SPECIAL_CHARS = '.\\[{()*+?^$|'
REPEAT_CHARS = '*+?{'
DIGITS = set('0123456789')
OCTDIGITS = set('01234567')
HEXDIGITS = set('0123456789abcdefABCDEF')
WHITESPACE = set(' \t\n\r\x0b\x0c')
ESCAPES = {'\\a': (LITERAL, ord('\x07')),
 '\\b': (LITERAL, ord('\x08')),
 '\\f': (LITERAL, ord('\x0c')),
 '\\n': (LITERAL, ord('\n')),
 '\\r': (LITERAL, ord('\r')),
 '\\t': (LITERAL, ord('\t')),
 '\\v': (LITERAL, ord('\x0b')),
 '\\\\': (LITERAL, ord('\\'))}
CATEGORIES = {'\\A': (AT, AT_BEGINNING_STRING),
 '\\b': (AT, AT_BOUNDARY),
 '\\B': (AT, AT_NON_BOUNDARY),
 '\\d': (IN, [(CATEGORY, CATEGORY_DIGIT)]),
 '\\D': (IN, [(CATEGORY, CATEGORY_NOT_DIGIT)]),
 '\\s': (IN, [(CATEGORY, CATEGORY_SPACE)]),
 '\\S': (IN, [(CATEGORY, CATEGORY_NOT_SPACE)]),
 '\\w': (IN, [(CATEGORY, CATEGORY_WORD)]),
 '\\W': (IN, [(CATEGORY, CATEGORY_NOT_WORD)]),
 '\\Z': (AT, AT_END_STRING)}
FLAGS = {'i': SRE_FLAG_IGNORECASE,
 'L': SRE_FLAG_LOCALE,
 'm': SRE_FLAG_MULTILINE,
 's': SRE_FLAG_DOTALL,
 'x': SRE_FLAG_VERBOSE,
 't': SRE_FLAG_TEMPLATE,
 'u': SRE_FLAG_UNICODE}

class Pattern():

    def __init__(self):
        self.flags = 0
        self.open = []
        self.groups = 1
        self.groupdict = {}

    def opengroup(self, name = None):
        gid = self.groups
        self.groups = gid + 1
        if name is not None:
            ogid = self.groupdict.get(name, None)
            if ogid is not None:
                raise error, 'redefinition of group name %s as group %d; was group %d' % (repr(name), gid, ogid)
            self.groupdict[name] = gid
        self.open.append(gid)
        return gid

    def closegroup(self, gid):
        self.open.remove(gid)

    def checkgroup(self, gid):
        return gid < self.groups and gid not in self.open


class SubPattern():

    def __init__(self, pattern, data = None):
        self.pattern = pattern
        if data is None:
            data = []
        self.data = data
        self.width = None

    def dump(self, level = 0):
        nl = 1
        seqtypes = (type(()), type([]))
        for op, av in self.data:
            print level * '  ' + op,
            nl = 0
            if op == 'in':
                print
                nl = 1
                for op, a in av:
                    print (level + 1) * '  ' + op, a

            elif op == 'branch':
                print
                nl = 1
                i = 0
                for a in av[1]:
                    if i > 0:
                        print level * '  ' + 'or'
                    a.dump(level + 1)
                    nl = 1
                    i = i + 1

            elif type(av) in seqtypes:
                for a in av:
                    if isinstance(a, SubPattern):
                        if not nl:
                            print
                        a.dump(level + 1)
                        nl = 1
                    else:
                        print a,
                        nl = 0

            else:
                print av,
                nl = 0
            if not nl:
                print

    def __repr__(self):
        return repr(self.data)

    def __len__(self):
        return len(self.data)

    def __delitem__(self, index):
        del self.data[index]

    def __getitem__(self, index):
        return self.data[index]

    def __setitem__(self, index, code):
        self.data[index] = code

    def __getslice__(self, start, stop):
        return SubPattern(self.pattern, self.data[start:stop])

    def insert(self, index, code):
        self.data.insert(index, code)

    def append(self, code):
        self.data.append(code)

    def getwidth(self):
        if self.width:
            return self.width
        lo = hi = 0L
        UNITCODES = (ANY,
         RANGE,
         IN,
         LITERAL,
         NOT_LITERAL,
         CATEGORY)
        REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
        for op, av in self.data:
            if op is BRANCH:
                i = sys.maxint
                j = 0
                for av in av[1]:
                    l, h = av.getwidth()
                    i = min(i, l)
                    j = max(j, h)

                lo = lo + i
                hi = hi + j
            elif op is CALL:
                i, j = av.getwidth()
                lo = lo + i
                hi = hi + j
            elif op is SUBPATTERN:
                i, j = av[1].getwidth()
                lo = lo + i
                hi = hi + j
            elif op in REPEATCODES:
                i, j = av[2].getwidth()
                lo = lo + long(i) * av[0]
                hi = hi + long(j) * av[1]
            elif op in UNITCODES:
                lo = lo + 1
                hi = hi + 1
            elif op == SUCCESS:
                break

        self.width = (int(min(lo, sys.maxint)), int(min(hi, sys.maxint)))
        return self.width


class Tokenizer():

    def __init__(self, string):
        self.string = string
        self.index = 0
        self.__next()

    def __next(self):
        if self.index >= len(self.string):
            self.next = None
            return
        char = self.string[self.index]
        if char[0] == '\\':
            try:
                c = self.string[self.index + 1]
            except IndexError:
                raise error, 'bogus escape (end of line)'

            char = char + c
        self.index = self.index + len(char)
        self.next = char

    def match(self, char, skip = 1):
        if char == self.next:
            if skip:
                self.__next()
            return 1
        return 0

    def get(self):
        this = self.next
        self.__next()
        return this

    def tell(self):
        return (self.index, self.next)

    def seek(self, index):
        self.index, self.next = index


def isident(char):
    return 'a' <= char <= 'z' or 'A' <= char <= 'Z' or char == '_'


def isdigit(char):
    return '0' <= char <= '9'


def isname(name):
    if not isident(name[0]):
        return False
    for char in name[1:]:
        if not isident(char) and not isdigit(char):
            return False

    return True


def _class_escape(source, escape):
    code = ESCAPES.get(escape)
    if code:
        return code
    code = CATEGORIES.get(escape)
    if code:
        return code
    try:
        c = escape[1:2]
        if c == 'x':
            while source.next in HEXDIGITS and len(escape) < 4:
                escape = escape + source.get()

            escape = escape[2:]
            if len(escape) != 2:
                raise error, 'bogus escape: %s' % repr('\\' + escape)
            return (LITERAL, int(escape, 16) & 255)
        elif c in OCTDIGITS:
            while source.next in OCTDIGITS and len(escape) < 4:
                escape = escape + source.get()

            escape = escape[1:]
            return (LITERAL, int(escape, 8) & 255)
        elif c in DIGITS:
            raise error, 'bogus escape: %s' % repr(escape)
        if len(escape) == 2:
            return (LITERAL, ord(escape[1]))
    except ValueError:
        pass

    raise error, 'bogus escape: %s' % repr(escape)


def _escape(source, escape, state):
    code = CATEGORIES.get(escape)
    if code:
        return code
    code = ESCAPES.get(escape)
    if code:
        return code
    try:
        c = escape[1:2]
        if c == 'x':
            while source.next in HEXDIGITS and len(escape) < 4:
                escape = escape + source.get()

            if len(escape) != 4:
                raise ValueError
            return (LITERAL, int(escape[2:], 16) & 255)
        elif c == '0':
            while source.next in OCTDIGITS and len(escape) < 4:
                escape = escape + source.get()

            return (LITERAL, int(escape[1:], 8) & 255)
        elif c in DIGITS:
            if source.next in DIGITS:
                escape = escape + source.get()
                if escape[1] in OCTDIGITS and escape[2] in OCTDIGITS:
                    if source.next in OCTDIGITS:
                        escape = escape + source.get()
                        return (LITERAL, int(escape[1:], 8) & 255)
            group = int(escape[1:])
            if group < state.groups:
                if not state.checkgroup(group):
                    raise error, 'cannot refer to open group'
                return (GROUPREF, group)
            raise ValueError
        if len(escape) == 2:
            return (LITERAL, ord(escape[1]))
    except ValueError:
        pass

    raise error, 'bogus escape: %s' % repr(escape)


def _parse_sub(source, state, nested = 1):
    items = []
    itemsappend = items.append
    sourcematch = source.match
    while 1:
        itemsappend(_parse(source, state))
        if sourcematch('|'):
            continue
        if not nested:
            break
        if not source.next or sourcematch(')', 0):
            break
        else:
            raise error, 'pattern not properly closed'

    if len(items) == 1:
        return items[0]
    subpattern = SubPattern(state)
    subpatternappend = subpattern.append
    while 1:
        prefix = None
        for item in items:
            if not item:
                break
            if prefix is None:
                prefix = item[0]
            elif item[0] != prefix:
                break
        else:
            for item in items:
                del item[0]

            subpatternappend(prefix)
            continue

        break

    for item in items:
        if len(item) != 1 or item[0][0] != LITERAL:
            break
    else:
        set = []
        setappend = set.append
        for item in items:
            setappend(item[0])

        subpatternappend((IN, set))
        return subpattern

    subpattern.append((BRANCH, (None, items)))
    return subpattern


def _parse_sub_cond(source, state, condgroup):
    item_yes = _parse(source, state)
    if source.match('|'):
        item_no = _parse(source, state)
        if source.match('|'):
            raise error, 'conditional backref with more than two branches'
    else:
        item_no = None
    if source.next and not source.match(')', 0):
        raise error, 'pattern not properly closed'
    subpattern = SubPattern(state)
    subpattern.append((GROUPREF_EXISTS, (condgroup, item_yes, item_no)))
    return subpattern


_PATTERNENDERS = set('|)')
_ASSERTCHARS = set('=!<')
_LOOKBEHINDASSERTCHARS = set('=!')
_REPEATCODES = set([MIN_REPEAT, MAX_REPEAT])

def _parse(source, state):
    subpattern = SubPattern(state)
    subpatternappend = subpattern.append
    sourceget = source.get
    sourcematch = source.match
    _len = len
    PATTERNENDERS = _PATTERNENDERS
    ASSERTCHARS = _ASSERTCHARS
    LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
    REPEATCODES = _REPEATCODES
    while 1:
        if source.next in PATTERNENDERS:
            break
        this = sourceget()
        if this is None:
            break
        if state.flags & SRE_FLAG_VERBOSE:
            if this in WHITESPACE:
                continue
            if this == '#':
                while 1:
                    this = sourceget()
                    if this in (None, '\n'):
                        break

                continue
        if this and this[0] not in SPECIAL_CHARS:
            subpatternappend((LITERAL, ord(this)))
        elif this == '[':
            set = []
            setappend = set.append
            if sourcematch('^'):
                setappend((NEGATE, None))
            start = set[:]
            while 1:
                this = sourceget()
                if this == ']' and set != start:
                    break
                elif this and this[0] == '\\':
                    code1 = _class_escape(source, this)
                elif this:
                    code1 = (LITERAL, ord(this))
                else:
                    raise error, 'unexpected end of regular expression'
                if sourcematch('-'):
                    this = sourceget()
                    if this == ']':
                        if code1[0] is IN:
                            code1 = code1[1][0]
                        setappend(code1)
                        setappend((LITERAL, ord('-')))
                        break
                    elif this:
                        if this[0] == '\\':
                            code2 = _class_escape(source, this)
                        else:
                            code2 = (LITERAL, ord(this))
                        if code1[0] != LITERAL or code2[0] != LITERAL:
                            raise error, 'bad character range'
                        lo = code1[1]
                        hi = code2[1]
                        if hi < lo:
                            raise error, 'bad character range'
                        setappend((RANGE, (lo, hi)))
                    else:
                        raise error, 'unexpected end of regular expression'
                else:
                    if code1[0] is IN:
                        code1 = code1[1][0]
                    setappend(code1)

            if _len(set) == 1 and set[0][0] is LITERAL:
                subpatternappend(set[0])
            elif _len(set) == 2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
                subpatternappend((NOT_LITERAL, set[1][1]))
            else:
                subpatternappend((IN, set))
        elif this and this[0] in REPEAT_CHARS:
            if this == '?':
                min, max = (0, 1)
            elif this == '*':
                min, max = 0, MAXREPEAT
            elif this == '+':
                min, max = 1, MAXREPEAT
            elif this == '{':
                if source.next == '}':
                    subpatternappend((LITERAL, ord(this)))
                    continue
                here = source.tell()
                min, max = 0, MAXREPEAT
                lo = hi = ''
                while source.next in DIGITS:
                    lo = lo + source.get()

                if sourcematch(','):
                    while source.next in DIGITS:
                        hi = hi + sourceget()

                else:
                    hi = lo
                if not sourcematch('}'):
                    subpatternappend((LITERAL, ord(this)))
                    source.seek(here)
                    continue
                if lo:
                    min = int(lo)
                if hi:
                    max = int(hi)
                if max < min:
                    raise error, 'bad repeat interval'
            else:
                raise error, 'not supported'
            if subpattern:
                item = subpattern[-1:]
            else:
                item = None
            if not item or _len(item) == 1 and item[0][0] == AT:
                raise error, 'nothing to repeat'
            if item[0][0] in REPEATCODES:
                raise error, 'multiple repeat'
            if sourcematch('?'):
                subpattern[-1] = (MIN_REPEAT, (min, max, item))
            else:
                subpattern[-1] = (MAX_REPEAT, (min, max, item))
        elif this == '.':
            subpatternappend((ANY, None))
        elif this == '(':
            group = 1
            name = None
            condgroup = None
            if sourcematch('?'):
                group = 0
                if sourcematch('P'):
                    if sourcematch('<'):
                        name = ''
                        while 1:
                            char = sourceget()
                            if char is None:
                                raise error, 'unterminated name'
                            if char == '>':
                                break
                            name = name + char

                        group = 1
                        if not isname(name):
                            raise error, 'bad character in group name'
                    elif sourcematch('='):
                        name = ''
                        while 1:
                            char = sourceget()
                            if char is None:
                                raise error, 'unterminated name'
                            if char == ')':
                                break
                            name = name + char

                        if not isname(name):
                            raise error, 'bad character in group name'
                        gid = state.groupdict.get(name)
                        if gid is None:
                            raise error, 'unknown group name'
                        subpatternappend((GROUPREF, gid))
                        continue
                    else:
                        char = sourceget()
                        if char is None:
                            raise error, 'unexpected end of pattern'
                        raise error, 'unknown specifier: ?P%s' % char
                elif sourcematch(':'):
                    group = 2
                elif sourcematch('#'):
                    while 1:
                        if source.next is None or source.next == ')':
                            break
                        sourceget()

                    if not sourcematch(')'):
                        raise error, 'unbalanced parenthesis'
                    continue
                elif source.next in ASSERTCHARS:
                    char = sourceget()
                    dir = 1
                    if char == '<':
                        if source.next not in LOOKBEHINDASSERTCHARS:
                            raise error, 'syntax error'
                        dir = -1
                        char = sourceget()
                    p = _parse_sub(source, state)
                    if not sourcematch(')'):
                        raise error, 'unbalanced parenthesis'
                    if char == '=':
                        subpatternappend((ASSERT, (dir, p)))
                    else:
                        subpatternappend((ASSERT_NOT, (dir, p)))
                    continue
                elif sourcematch('('):
                    condname = ''
                    while 1:
                        char = sourceget()
                        if char is None:
                            raise error, 'unterminated name'
                        if char == ')':
                            break
                        condname = condname + char

                    group = 2
                    if isname(condname):
                        condgroup = state.groupdict.get(condname)
                        if condgroup is None:
                            raise error, 'unknown group name'
                    else:
                        try:
                            condgroup = int(condname)
                        except ValueError:
                            raise error, 'bad character in group name'

                else:
                    if source.next not in FLAGS:
                        raise error, 'unexpected end of pattern'
                    while source.next in FLAGS:
                        state.flags = state.flags | FLAGS[sourceget()]

            if group:
                if group == 2:
                    group = None
                else:
                    group = state.opengroup(name)
                if condgroup:
                    p = _parse_sub_cond(source, state, condgroup)
                else:
                    p = _parse_sub(source, state)
                if not sourcematch(')'):
                    raise error, 'unbalanced parenthesis'
                if group is not None:
                    state.closegroup(group)
                subpatternappend((SUBPATTERN, (group, p)))
            else:
                while 1:
                    char = sourceget()
                    if char is None:
                        raise error, 'unexpected end of pattern'
                    if char == ')':
                        break
                    raise error, 'unknown extension'

        elif this == '^':
            subpatternappend((AT, AT_BEGINNING))
        elif this == '$':
            subpattern.append((AT, AT_END))
        elif this and this[0] == '\\':
            code = _escape(source, this, state)
            subpatternappend(code)
        else:
            raise error, 'parser error'

    return subpattern


def parse(str, flags = 0, pattern = None):
    source = Tokenizer(str)
    if pattern is None:
        pattern = Pattern()
    pattern.flags = flags
    pattern.str = str
    p = _parse_sub(source, pattern, 0)
    tail = source.get()
    if tail == ')':
        raise error, 'unbalanced parenthesis'
    elif tail:
        raise error, 'bogus characters at end of regular expression'
    if flags & SRE_FLAG_DEBUG:
        p.dump()
    if not flags & SRE_FLAG_VERBOSE and p.pattern.flags & SRE_FLAG_VERBOSE:
        return parse(str, p.pattern.flags)
    return p


def parse_template(source, pattern):
    s = Tokenizer(source)
    sget = s.get
    p = []
    a = p.append

    def literal(literal, p = p, pappend = a):
        if p and p[-1][0] is LITERAL:
            p[-1] = (LITERAL, p[-1][1] + literal)
        else:
            pappend((LITERAL, literal))

    sep = source[:0]
    if type(sep) is type(''):
        makechar = chr
    else:
        makechar = unichr
    while 1:
        this = sget()
        if this is None:
            break
        if this and this[0] == '\\':
            c = this[1:2]
            if c == 'g':
                name = ''
                if s.match('<'):
                    while 1:
                        char = sget()
                        if char is None:
                            raise error, 'unterminated group name'
                        if char == '>':
                            break
                        name = name + char

                if not name:
                    raise error, 'bad group name'
                try:
                    index = int(name)
                    if index < 0:
                        raise error, 'negative group number'
                except ValueError:
                    if not isname(name):
                        raise error, 'bad character in group name'
                    try:
                        index = pattern.groupindex[name]
                    except KeyError:
                        raise IndexError, 'unknown group name'

                a((MARK, index))
            elif c == '0':
                if s.next in OCTDIGITS:
                    this = this + sget()
                    if s.next in OCTDIGITS:
                        this = this + sget()
                literal(makechar(int(this[1:], 8) & 255))
            elif c in DIGITS:
                isoctal = False
                if s.next in DIGITS:
                    this = this + sget()
                    if c in OCTDIGITS and this[2] in OCTDIGITS and s.next in OCTDIGITS:
                        this = this + sget()
                        isoctal = True
                        literal(makechar(int(this[1:], 8) & 255))
                if not isoctal:
                    a((MARK, int(this[1:])))
            else:
                try:
                    this = makechar(ESCAPES[this][1])
                except KeyError:
                    pass

                literal(this)
        else:
            literal(this)

    i = 0
    groups = []
    groupsappend = groups.append
    literals = [None] * len(p)
    for c, s in p:
        if c is MARK:
            groupsappend((i, s))
        else:
            literals[i] = s
        i = i + 1

    return (groups, literals)


def expand_template(template, match):
    g = match.group
    sep = match.string[:0]
    groups, literals = template
    literals = literals[:]
    try:
        for index, group in groups:
            literals[index] = s = g(group)
            if s is None:
                raise error, 'unmatched group'

    except IndexError:
        raise error, 'invalid group reference'

    return sep.join(literals)
########NEW FILE########
__FILENAME__ = types
#Embedded file name: /Users/versonator/Jenkins/live/Projects/AppLive/Resources/MIDI Remote Scripts/_Tools/types.py
"""Define names for all type symbols known in the standard interpreter.

Types that are part of optional modules (e.g. array) are not listed.
"""
import sys
NoneType = type(None)
TypeType = type
ObjectType = object
IntType = int
LongType = long
FloatType = float
BooleanType = bool
try:
    ComplexType = complex
except NameError:
    pass

StringType = str
try:
    UnicodeType = unicode
    StringTypes = (StringType, UnicodeType)
except NameError:
    StringTypes = (StringType,)

BufferType = buffer
TupleType = tuple
ListType = list
DictType = DictionaryType = dict

def _f():
    pass


FunctionType = type(_f)
LambdaType = type(lambda : None)
try:
    CodeType = type(_f.func_code)
except RuntimeError:
    pass

def _g():
    yield 1


GeneratorType = type(_g())

class _C:

    def _m(self):
        pass


ClassType = type(_C)
UnboundMethodType = type(_C._m)
_x = _C()
InstanceType = type(_x)
MethodType = type(_x._m)
BuiltinFunctionType = type(len)
BuiltinMethodType = type([].append)
ModuleType = type(sys)
FileType = file
XRangeType = xrange
try:
    raise TypeError
except TypeError:
    try:
        tb = sys.exc_info()[2]
        TracebackType = type(tb)
        FrameType = type(tb.tb_frame)
    except AttributeError:
        pass

    tb = None
    del tb

SliceType = slice
EllipsisType = type(Ellipsis)
DictProxyType = type(TypeType.__dict__)
NotImplementedType = type(NotImplemented)
try:
    import _types
except ImportError:
    pass
else:
    GetSetDescriptorType = type(_types.Helper.getter)
    MemberDescriptorType = type(_types.Helper.member)
    del _types

del sys
del _f
del _g
del _C
del _x
########NEW FILE########
