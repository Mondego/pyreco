__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Kotti documentation build configuration file, created by
# sphinx-quickstart on Fri Mar 18 23:14:47 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

#import os
#import sys

#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

#needs_sphinx = '1.0'
extensions = [
    'repoze.sphinx.autointerface',
    'sphinx.ext.autodoc',
    'sphinx.ext.graphviz',
    'sphinx.ext.inheritance_diagram',
    'sphinx.ext.intersphinx',
    'sphinx.ext.viewcode',
    ]

templates_path = ['_templates']
source_suffix = '.rst'
#source_encoding = 'utf-8-sig'
master_doc = 'index'
project = u'Kotti'
copyright = u'2012-2013, Kotti developers'
version = '0.10'
# The full version, including alpha/beta/rc tags.
release = version
#language = None
today_fmt = '%Y-%m-%d'
exclude_patterns = ['_build', '_themes']
#default_role = None
#add_function_parentheses = True
#add_module_names = True
#show_authors = False
pygments_style = 'sphinx'
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

import kotti_docs_theme

html_theme_path = [kotti_docs_theme.get_theme_dir()]
html_theme = 'kotti_docs_theme'
html_theme_options = {
    'github_user': 'Kotti',
    'github_repo': 'Kotti',
    'twitter_username': 'KottiCMS',
    'home_url': 'http://kotti.pylonsproject.org/',
    'mailing_list_url': 'http://groups.google.com/group/kotti',
    'irc_channel_url': 'irc://irc.freenode.net/#kotti',
}
# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None
# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None
#html_logo = None
#html_favicon = None
html_static_path = ['_static']
html_last_updated_fmt = '%Y-%m-%d'
#html_use_smartypants = True
#html_sidebars = {}
#html_additional_pages = {}
#html_domain_indices = True
#html_use_index = True
#html_split_index = False
#html_show_sourcelink = True
#html_show_sphinx = True
#html_show_copyright = True
#html_use_opensearch = ''
#html_file_suffix = None
htmlhelp_basename = 'Kottidoc'


# -- Options for LaTeX output --------------------------------------------------

#latex_paper_size = 'a4'
#latex_font_size = '10pt'
#latex_documents = [
#  ('index', 'Kotti.tex', u'Kotti Documentation',
#   u'Daniel Nouri', 'manual'),
#]
#latex_logo = None
#latex_use_parts = False
#latex_show_pagerefs = False
#latex_show_urls = False
#latex_preamble = ''
#latex_appendices = []
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
#man_pages = [
#    ('index', 'kotti', u'Kotti Documentation', [u'Daniel Nouri'], 1)
#]

# -- Options for inheritance diagrams ------------------------------------------
inheritance_graph_attrs = dict(rankdir='TB', nodesep=0.1,
                               ratio='auto', size=11.0)
inheritance_node_attrs = dict(height=0.7, margin='0.06, 0.03')

# -- Options for Intersphinx ---------------------------------------------------
intersphinx_mapping = {
    'colander': ('http://colander.readthedocs.org/en/latest/', None),
    'deform': ('http://deform.readthedocs.org/en/latest/', None),
    'fanstatic': ('http://www.fanstatic.org/en/latest/', None),
    'pyramid': ('http://pyramid.readthedocs.org/en/latest/', None),
    'sqlalchemy': ('http://sqlalchemy.readthedocs.org/en/latest/', None),
}

########NEW FILE########
__FILENAME__ = env
from alembic import context
import traceback
import transaction
from zope.sqlalchemy import mark_changed

from kotti import DBSession
from kotti import metadata


def run_migrations_online():
    if DBSession.bind is None:
        raise ValueError(
            "\nYou must run Kotti's migration using the 'kotti-migrate' script"
            "\nand not through 'alembic' directly."
            )

    transaction.begin()
    connection = DBSession.connection()

    context.configure(
        connection=connection,
        target_metadata=metadata,
        )

    try:
        context.run_migrations()
        mark_changed(DBSession())
    except:
        traceback.print_exc()
        transaction.abort()
    else:
        transaction.commit()
    finally:
        # connection.close()
        pass


try:  # Alembic's "if __name__ == '__main__'"
    offline_mode = context.is_offline_mode()
except (AttributeError, NameError):
    pass
else:
    if offline_mode:  # pragma: no cover
        raise ValueError(
            "\nNo support for Alembic's offline mode at this point."
            "\nYou may want to write your own env.py script to use "
            "\n'offline mode'."
            )
    run_migrations_online()

########NEW FILE########
__FILENAME__ = 57fecf5dbd62_initialize_workflow
"""Initialize workflow and publish all items.

Revision ID: 57fecf5dbd62
Revises: 9398ccf41c2
Create Date: 2012-08-06 17:53:55.352478

"""

# revision identifiers, used by Alembic.
revision = '57fecf5dbd62'
down_revision = '9398ccf41c2'


def upgrade():
    from kotti import DBSession
    from kotti import get_settings
    from kotti.resources import Document
    from kotti.workflow import get_workflow
    from kotti.workflow import reset_workflow

    is_default = get_settings()['kotti.use_workflow'] == 'kotti:workflow.zcml'
    if not is_default:
        return

    reset_workflow()
    for obj in DBSession.query(Document):
        workflow = get_workflow(obj)
        workflow.transition_to_state(obj, None, 'public')


def downgrade():
    pass

########NEW FILE########
__FILENAME__ = 9398ccf41c2_add_content_state_fo
"""Add 'Content.state' for workflow

Revision ID: 9398ccf41c2
Revises: None
Create Date: 2012-07-27 12:36:32.463710

"""

# revision identifiers, used by Alembic.
revision = '9398ccf41c2'
down_revision = None

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.add_column('contents', sa.Column('state', sa.String(50)))


def downgrade():
    op.drop_column('contents', 'state')

########NEW FILE########
__FILENAME__ = events
"""This module includes a simple events system that allows users to
subscribe to specific events, and more particularly to *object events*
of specific object types.

See also: :ref:`events`.

Inheritance Diagram
-------------------

.. inheritance-diagram:: kotti.events

"""

from collections import defaultdict
from datetime import datetime
try:  # pragma: no cover
    from collections import OrderedDict
    OrderedDict  # pyflakes
except ImportError:  # pragma: no cover
    from ordereddict import OrderedDict

import sqlalchemy.event
import venusian
from sqlalchemy.orm import mapper
from pyramid.threadlocal import get_current_request
from pyramid.security import authenticated_userid
from zope.deprecation.deprecation import deprecated

from kotti import DBSession
from kotti.resources import Node
from kotti.resources import Content
from kotti.resources import Tag
from kotti.resources import TagsToContents
from kotti.resources import LocalGroup
from kotti.security import list_groups
from kotti.security import list_groups_raw
from kotti.security import set_groups
from kotti.security import Principal
from kotti.security import get_principals


class ObjectEvent(object):
    """Event related to an object."""

    def __init__(self, object, request=None):
        """Constructor.

        :param object: The (content) object related to the event.  This is an
                       instance of :class:`kotti.resources.Node` or one its
                       descendants for content related events, but it can be
                       anything.
        :type object: arbitrary

        :param request: current request
        :type request: :class:`pyramid.request.Request`
        """

        self.object = object
        self.request = request


class ObjectInsert(ObjectEvent):
    """This event is emitted when an object is inserted into the DB."""


class ObjectUpdate(ObjectEvent):
    """This event is emitted when an object in the DB is updated."""


class ObjectDelete(ObjectEvent):
    """This event is emitted when an object is deleted from the DB."""


class ObjectAfterDelete(ObjectEvent):
    """This event is emitted after an object has been deleted from the DB.

    .. deprecated:: 0.9
    """
deprecated('ObjectAfterDelete',
           "The ObjectAfterDelete event is deprecated and will be no longer "
           "available starting with Kotti 0.10.")


class UserDeleted(ObjectEvent):
    """This event is emitted when an user object is deleted from the DB."""


class DispatcherDict(defaultdict, OrderedDict):
    """Base class for dispatchers"""

    def __init__(self, *args, **kwargs):
        defaultdict.__init__(self, list)
        OrderedDict.__init__(self, *args, **kwargs)


class Dispatcher(DispatcherDict):
    """Dispatches based on event type.

      >>> class BaseEvent(object): pass
      >>> class SubEvent(BaseEvent): pass
      >>> class UnrelatedEvent(object): pass
      >>> def base_listener(event):
      ...     print 'Called base listener'
      >>> def sub_listener(event):
      ...     print 'Called sub listener'
      >>> def unrelated_listener(event):
      ...     print 'Called unrelated listener'
      ...     return 1

      >>> dispatcher = Dispatcher()
      >>> dispatcher[BaseEvent].append(base_listener)
      >>> dispatcher[SubEvent].append(sub_listener)
      >>> dispatcher[UnrelatedEvent].append(unrelated_listener)

      >>> dispatcher(BaseEvent())
      Called base listener
      [None]
      >>> dispatcher(SubEvent())
      Called base listener
      Called sub listener
      [None, None]
      >>> dispatcher(UnrelatedEvent())
      Called unrelated listener
      [1]
    """
    def __call__(self, event):
        results = []
        for event_type, handlers in self.items():
            if isinstance(event, event_type):
                for handler in handlers:
                    results.append(handler(event))
        return results


class ObjectEventDispatcher(DispatcherDict):
    """Dispatches based on both event type and object type.

      >>> class BaseObject(object): pass
      >>> class SubObject(BaseObject): pass
      >>> def base_listener(event):
      ...     return 'base'
      >>> def subobj_insert_listener(event):
      ...     return 'sub'
      >>> def all_listener(event):
      ...     return 'all'

      >>> dispatcher = ObjectEventDispatcher()
      >>> dispatcher[(ObjectEvent, BaseObject)].append(base_listener)
      >>> dispatcher[(ObjectInsert, SubObject)].append(subobj_insert_listener)
      >>> dispatcher[(ObjectEvent, None)].append(all_listener)

      >>> dispatcher(ObjectEvent(BaseObject()))
      ['base', 'all']
      >>> dispatcher(ObjectInsert(BaseObject()))
      ['base', 'all']
      >>> dispatcher(ObjectEvent(SubObject()))
      ['base', 'all']
      >>> dispatcher(ObjectInsert(SubObject()))
      ['base', 'sub', 'all']
    """
    def __call__(self, event):
        results = []
        for (evtype, objtype), handlers in self.items():
            if (isinstance(event, evtype) and
                    (objtype is None or isinstance(event.object, objtype))):
                for handler in handlers:
                    results.append(handler(event))
        return results


def clear():
    listeners.clear()
    objectevent_listeners.clear()
    listeners[ObjectEvent].append(objectevent_listeners)

listeners = Dispatcher()
notify = listeners.__call__
objectevent_listeners = ObjectEventDispatcher()
clear()


def _after_delete(mapper, connection, target):
    """ Trigger the Kotti event :class:``ObjectAfterDelete``.

    :param mapper: SQLAlchemy mapper
    :type mapper: :class:`sqlalchemy.orm.mapper.Mapper`

    :param connection: SQLAlchemy connection
    :type connection: :class:`sqlalchemy.engine.base.Connection`

    :param target: SQLAlchemy declarative class that is used
    :type target: Class as returned by ``declarative_base()``
    """

    notify(ObjectAfterDelete(target, get_current_request()))


def _before_flush(session, flush_context, instances):
    """Trigger the following Kotti :class:``ObjectEvent`` events in
    this order:

    - :class:``ObjectUpdate``
    - :class:``ObjectInsert``
    - :class:``ObjectDelete``
    """
    req = get_current_request()

    for obj in session.dirty:
        if session.is_modified(obj, include_collections=False):  # XXX ?
            notify(ObjectUpdate(obj, req))
    for obj in session.new:
        notify(ObjectInsert(obj, req))
    for obj in session.deleted:
        notify(ObjectDelete(obj, req))


def set_owner(event):
    """Set ``owner`` of the object that triggered the event.

    :param event: event that trigerred this handler.
    :type event: :class:`ObjectInsert`
    """

    obj, request = event.object, event.request
    if request is not None and isinstance(obj, Node) and obj.owner is None:
        userid = authenticated_userid(request)
        if userid is not None:
            userid = unicode(userid)
            # Set owner metadata:
            obj.owner = userid
            # Add owner role for userid if it's not inherited already:
            if u'role:owner' not in list_groups(userid, obj):
                groups = list_groups_raw(userid, obj) | set([u'role:owner'])
                set_groups(userid, obj, groups)


def set_creation_date(event):
    """Set ``creation_date`` of the object that triggered the event.

    :param event: event that trigerred this handler.
    :type event: :class:`ObjectInsert`
    """

    obj = event.object
    if obj.creation_date is None:
        obj.creation_date = obj.modification_date = datetime.now()


def set_modification_date(event):
    """Update ``modification_date`` of the object that triggered the event.

    :param event: event that trigerred this handler.
    :type event: :class:`ObjectUpdate`
    """

    event.object.modification_date = datetime.now()


def delete_orphaned_tags(event):
    """Delete Tag instances / records when they are not associated with any
    content.

    :param event: event that trigerred this handler.
    :type event: :class:`ObjectAfterDelete`
    """

    DBSession.query(Tag).filter(~Tag.content_tags.any()).delete(
        synchronize_session=False)


def cleanup_user_groups(event):
    """Remove a deleted group from the groups of a user/group and remove
       all local group entries of it.

       :param event: event that trigerred this handler.
       :type event: :class:`UserDeleted`
       """
    name = event.object.name

    if name.startswith("group:"):
        principals = get_principals()
        users_groups = [p for p in principals if name in principals[p].groups]
        for user_or_group in users_groups:
            principals[user_or_group].groups.remove(name)

    DBSession.query(LocalGroup).filter(
        LocalGroup.principal_name == name).delete()


def reset_content_owner(event):
    """Reset the owner of the content from the deleted owner.

    :param event: event that trigerred this handler.
    :type event: :class:`UserDeleted`
    """

    contents = DBSession.query(Content).filter(
        Content.owner == event.object.name).all()
    for content in contents:
        content.owner = None


class subscribe(object):
    """Function decorator to attach the decorated function as a handler for a
    Kotti event.  Example::

        from kotti.events import ObjectInsert
        from kotti.events import subscribe
        from kotti.resurces import Document

        @subscribe()
        def on_all_events(event):
            # this will be executed on *every* event
            print "Some kind of event occured"

        @subscribe(ObjectInsert)
        def on_insert(event):
            # this will be executed on every object insert
            context = event.object
            request = event.request
            print "Object insert"

        @subscribe(ObjectInsert, Document)
        def on_document_insert(event):
            # this will only be executed on object inserts if the object is
            # is an instance of Document
            context = event.object
            request = event.request
            print "Document insert"

    """

    venusian = venusian  # needed for testing

    def __init__(self, evttype=object, objtype=None):
        """Constructor.

        :param evttype: Event to subscribe to.
        :type evttype: class:`ObjectEvent` or descendant

        :param objtype: Object type on which the handler will be called
        :type objtype: class:`kotti.resources.Node` or descendant.
        """

        self.evttype = evttype
        self.objtype = objtype

    def register(self, context, name, obj):
        if issubclass(self.evttype, ObjectEvent):
            objectevent_listeners[(self.evttype, self.objtype)].append(obj)
        else:
            listeners[self.evttype].append(obj)

    def __call__(self, wrapped):

        self.venusian.attach(wrapped, self.register, category='kotti')

        return wrapped


_WIRED_SQLALCHMEY = False


def wire_sqlalchemy():  # pragma: no cover
    """ Connect SQLAlchemy events to their respective handler function (that
    fires the corresponding Kotti event). """

    global _WIRED_SQLALCHMEY
    if _WIRED_SQLALCHMEY:
        return
    else:
        _WIRED_SQLALCHMEY = True
    sqlalchemy.event.listen(mapper, 'after_delete', _after_delete)
    sqlalchemy.event.listen(DBSession, 'before_flush', _before_flush)


def includeme(config):
    """ Pyramid includeme hook.

    :param config: app config
    :type config: :class:`pyramid.config.Configurator`
    """

    from kotti.workflow import initialize_workflow

    # Subscribe to SQLAlchemy events and map these to Kotti events
    wire_sqlalchemy()

    # Set content owner on content creation
    objectevent_listeners[
        (ObjectInsert, Content)].append(set_owner)

    # Set content creation date on content creation
    objectevent_listeners[
        (ObjectInsert, Content)].append(set_creation_date)

    # Set content modification date on content updates
    objectevent_listeners[
        (ObjectUpdate, Content)].append(set_modification_date)

    # Delete orphaned tags after a tag association has ben deleted
    objectevent_listeners[
        (ObjectAfterDelete, TagsToContents)].append(delete_orphaned_tags)

    # Initialze the workflow on content creation.
    objectevent_listeners[
        (ObjectInsert, Content)].append(initialize_workflow)

    # Perform some cleanup when a user or group is deleted
    objectevent_listeners[
        (UserDeleted, Principal)].append(cleanup_user_groups)

    # Remove the owner from content when the corresponding user is deleted
    objectevent_listeners[
        (UserDeleted, Principal)].append(reset_content_owner)

########NEW FILE########
__FILENAME__ = fanstatic
# -*- coding: utf-8 -*-

from __future__ import absolute_import

from fanstatic import Group
from fanstatic import Library
from fanstatic import Resource
from js.angular import angular
from js.bootstrap import bootstrap_js
from js.bootstrap import bootstrap_css
from js.html5shiv import html5shiv
from js.fineuploader import fineuploader
from js.jquery import jquery
from js.jquery_form import jquery_form
from js.jquery_tablednd import jquery_tablednd
from js.jqueryui import bootstrap as jqueryui_bootstrap_theme
from js.jqueryui_tagit import tagit as ui_tagit


# This is needed until ``kotti.views.form.deferred_tag_it_widget`` is converted
# to a class with a ``requirements`` attribute (that would be auto_needed by
# ``js.deform[_bootstrap]``).
tagit = Group([ui_tagit, jqueryui_bootstrap_theme])

# Kotti's resources
lib_kotti = Library("kotti", "static")
kotti_js = Resource(
    lib_kotti,
    "kotti.js",
    minified="kotti.min.js",
    bottom=True)
contents_view_js = Resource(
    lib_kotti,
    "contents.js",
    depends=[kotti_js, jquery_tablednd, ],
    minified="contents.min.js",
    bottom=True)
base_css = Resource(
    lib_kotti,
    "base.css",
    depends=[bootstrap_css],
    minified="base.min.css",
    dont_bundle=True)
edit_css = Resource(
    lib_kotti,
    "edit.css",
    depends=[base_css],
    minified="edit.min.css")
view_css = Resource(
    lib_kotti,
    "view.css",
    depends=[base_css],
    minified="view.min.css")

# Resources for content upload views
upload_js = Resource(
    lib_kotti,
    "upload.js",
    depends=[angular, fineuploader],
    # minified="upload.min.js", needs special minifying
    bottom=True)
upload_css = Resource(
    lib_kotti,
    "upload.css",
    depends=[base_css],
    minified="upload.min.css")
upload = Group([upload_js, upload_css])


class NeededGroup(object):
    """A collection of fanstatic resources that supports
       dynamic appending of resources after initialization"""

    def __init__(self, resources=[]):

        if not isinstance(resources, list):
            raise ValueError(
                "resources must be a list of fanstatic.Resource "
                "and/or fanstatic.Group objects")

        self.resources = []

        for resource in resources:
            self.add(resource)

    def add(self, resource):
        """resource may be a:

            - :class:`fanstatic.Resource` object or
            - :class:`fanstatic.Group` object"""

        if isinstance(resource, self.__class__):
            self.resources = self.resources + resource.resources
        elif isinstance(resource, (Resource, Group)):
            self.resources.append(resource)
        else:
            raise ValueError(
                "resource must be a NeededGroup,"
                "fanstatic.Resource or fanstatic.Group object")

    def need(self):  # pragma: no cover
        # this is tested in fanstatic itself; we should add browser tests
        # for `view_needed` and `edit_needed` (see below)
        Group(self.resources).need()

view_needed_css = NeededGroup([
    view_css,
    ])
view_needed_js = NeededGroup([
    jquery,
    bootstrap_js,
    html5shiv,
    ])
view_needed = NeededGroup([
    view_needed_css,
    view_needed_js,
    ])

edit_needed_css = NeededGroup([
    edit_css,
    jqueryui_bootstrap_theme,
    ])
edit_needed_js = NeededGroup([
    jquery,
    bootstrap_js,
    html5shiv,
    kotti_js,
    jquery_form,
    # deform_bootstrap_js,
    ])
edit_needed = NeededGroup([
    edit_needed_css,
    edit_needed_js,
    ])

########NEW FILE########
__FILENAME__ = interfaces
# -*- coding: utf-8 -*-
"""
"""

from zope.interface import Interface


class INode(Interface):
    """Marker interface for all nodes (and subclasses)"""


class IContent(INode):
    """Marker interface for all nodes of type Content
       (and subclasses thereof)"""


class IDocument(IContent):
    """Marker interface for all nodes of type Document
       (and subclasses thereof)"""


class IFile(IContent):
    """Marker interface for all nodes of type File
       (and subclasses thereof)"""


class IImage(IFile):
    """Marker interface for all nodes of type Image
       (and subclasses thereof)"""


class IDefaultWorkflow(Interface):
    """Marker interface for content classes that want to use the
       default workflow"""


class INavigationRoot(Interface):
    """Marker interface for content nodes / classes that want to be the root
       for the navigation.

       Considering a content tree like this::

        - /a
          - /a/a
          - /a/b (provides INavigationRoot)
            - /a/b/a
            - /a/b/b
            - /a/b/c
          - a/c

        The root item for the navigation will be ``/a/b`` for everey context in
        or below ``/a/b`` and ``/a`` for every other item.
        """

########NEW FILE########
__FILENAME__ = message
import hashlib
import time
import urllib

from html2text import HTML2Text
from pyramid.renderers import render
from pyramid_mailer.mailer import Mailer
from pyramid_mailer.message import Message
from zope.deprecation.deprecation import deprecate
from zope.deprecation.deprecation import deprecated

from kotti import get_settings


SET_PASSWORD_SUBJECT = u"Your registration for %(site_title)s"
SET_PASSWORD_BODY = u"""Hello, %(user_title)s!

You've just been invited to join %(site_title)s.  Click here to set
your password and log in: %(url)s.
"""

RESET_PASSWORD_SUBJECT = u"Reset your password for %(site_title)s."
RESET_PASSWORD_BODY = u"""Hello, %(user_title)s!

Click this link to reset your password at %(site_title)s: %(url)s.
"""

message_templates = {
    'set-password': dict(
        subject=SET_PASSWORD_SUBJECT, body=SET_PASSWORD_BODY),
    'reset-password': dict(
        subject=RESET_PASSWORD_SUBJECT, body=RESET_PASSWORD_BODY),
    }
deprecated(
    'message_templates',
    'message_templates is deprecated as of Kotti 0.6.4.  '
    'Use the ``email-set-password.pt`` and ``email-reset-password.pt`` '
    'templates instead.'
    )

_inject_mailer = []


def get_mailer():
    # Consider that we may have persistent settings
    if _inject_mailer:
        return _inject_mailer[0]
    return Mailer.from_settings(get_settings())  # pragma: no cover


def make_token(user, seconds=None):
    secret = get_settings()['kotti.secret2']
    if seconds is None:
        seconds = time.time()
    token = '%s:%s:%s' % (user.name, secret, seconds)
    return '%s:%s' % (hashlib.sha224(token).hexdigest(), seconds)


def validate_token(user, token, valid_hrs=24):
    """
      >>> from kotti.testing import setUp, tearDown
      >>> ignore = setUp()
      >>> class User(object):
      ...     pass
      >>> daniel = User()
      >>> daniel.name = u'daniel'
      >>> alice = User()
      >>> alice.name = u'alice'
      >>> token = make_token(daniel)
      >>> validate_token(daniel, token)
      True
      >>> validate_token(alice, token)
      False
      >>> validate_token(daniel, 'foo')
      False
      >>> token = make_token(daniel, seconds=time.time() - 100000)
      >>> validate_token(daniel, token)
      False
      >>> validate_token(daniel, token, valid_hrs=48)
      True
      >>> tearDown()
    """
    try:
        seconds = float(token.split(':')[1])
    except (IndexError, ValueError):
        return False
    if token == make_token(user, seconds):
        if time.time() - seconds < 60 * 60 * valid_hrs:
            return True
    return False


@deprecate('send_set_password is deprecated as of Kotti 0.6.4.  '
           'Use ``kotti.message.email_set_password`` instead.')
def send_set_password(user, request, templates='set-password', add_query=None):
    site_title = get_settings()['kotti.site_title']
    token = make_token(user)
    user.confirm_token = unicode(token)
    set_password_query = {'token': token, 'email': user.email}
    if add_query:
        set_password_query.update(add_query)
    url = '%s/@@set-password?%s' % (
        request.application_url,
        urllib.urlencode(set_password_query),
        )
    variables = dict(
        user_title=user.title,
        site_title=site_title,
        url=url,
        )

    if isinstance(templates, str):
        templates = message_templates[templates]
    message = Message(
        recipients=[u'"%s" <%s>' % (user.title, user.email)],  # XXX naive?
        subject=templates['subject'] % variables,
        body=templates['body'] % variables,
        )
    mailer = get_mailer()
    mailer.send(message)


def send_email(request, recipients, template_name, template_vars={}):
    """ General email sender.

    :param request: current request.
    :type request: :class:`pyramid.request.Request`

    :param recipients: list of email addresses. Each email should be a
                       string like: u'"John Doe" <joedoe@foo.com>'.
    :type recipients: list

    :param template_name: asset specification (e.g.
                          'mypackage:templates/email.pt')
    :type template_name: string

    :param template_vars: set of variables present on template.
    :type template_vars: dict
    """

    text = render(template_name, template_vars, request)
    subject, htmlbody = text.strip().split('\n', 1)
    subject = subject.replace('Subject:', '', 1).strip()
    html2text = HTML2Text()
    html2text.body_width = 0
    textbody = html2text.handle(htmlbody).strip()

    message = Message(
        recipients=recipients,
        subject=subject,
        body=textbody,
        html=htmlbody,
        )
    mailer = get_mailer()
    mailer.send(message)


def email_set_password(user, request,
                       template_name='kotti:templates/email-set-password.pt',
                       add_query=None):
    site_title = get_settings()['kotti.site_title']
    token = make_token(user)
    user.confirm_token = unicode(token)
    set_password_query = {'token': token, 'email': user.email}
    if add_query:
        set_password_query.update(add_query)
    url = '%s/@@set-password?%s' % (
        request.application_url,
        urllib.urlencode(set_password_query),
        )
    variables = dict(
        user_title=user.title,
        site_title=site_title,
        url=url,
        )
    recipients = [u'"%s" <%s>' % (user.title, user.email)]  # XXX naive?
    send_email(request, recipients, template_name, variables)

########NEW FILE########
__FILENAME__ = migrate
"""This module aims to make it easier to run the Alembic migration
scripts of Kotti and Kotti add-ons by providing a uniform access.

Commands herein will typically be called by the console script
``kotti-migrate`` (see the docstring of that command below).

Kotti stores the current revision of its migration in table
``kotti_alembic_versions``.  The convention here is
``<packagename>_alembic_versions``.  You should normally not need to
worry about the name of this table, as it is created and managed
automatically through this module.  If, however, you plan to use your
own alembic.ini configuration file for your add-on or application,
keep in mind to configure a table name as described above.  The table
name can be set using Alembic's ``version_table`` option.

Kotti has start-up code that will create the database from scratch if
it doesn't exist.  This code will also call this module's function
``stamp_heads`` to set the current revision of all migrations
registered with this module to the latest.  This assumes that when we
create the database from scratch (using ``metadata.create_all``), we
don't need to run any of the past migrations.

Unfortunately, this won't help in the situation where a user adds an
add-on with migrations to the Kotti site _after_ the database was
initialized for the first time.  In this case, users of the add-on
will need to run ``kotti-migrate stamp_head
--scripts=yourpackage:alembic``, or the add-on author will have to
write equivalent code somewhere in their populate hook.

Add-on authors can register their Alembic scripts with this module by
adding their Alembic 'script directory' location to the
``kotti.alembic_dirs`` setting.  An example::

  def kotti_configure(settings):
      # ...
      settings['kotti.alembic_dirs'] += ' kotti_contactform:alembic'

``kotti-migrate`` commands 'list_all', 'upgrade_all' and
'stamp_heads' will then include the add-on.
"""
from __future__ import absolute_import

import os
import pkg_resources

from alembic.config import Config
from alembic.environment import EnvironmentContext
from alembic.script import ScriptDirectory
from alembic.util import load_python_file
from zope.sqlalchemy import mark_changed

from kotti import conf_defaults
from kotti import get_settings
from kotti import DBSession
from kotti.util import command


KOTTI_SCRIPT_DIR = pkg_resources.resource_filename('kotti', 'alembic')
DEFAULT_LOCATION = 'kotti:alembic'


class ScriptDirectoryWithDefaultEnvPy(ScriptDirectory):
    @property
    def env_py_location(self):
        loc = super(ScriptDirectoryWithDefaultEnvPy, self).env_py_location
        if not os.path.exists(loc):
            loc = os.path.join(KOTTI_SCRIPT_DIR, 'env.py')
        return loc

    def run_env(self):
        dir_, filename = self.env_py_location.rsplit(os.path.sep, 1)
        load_python_file(dir_, filename)


class PackageEnvironment(object):
    def __init__(self, location):
        self.location = location
        self.config = self._make_config(location)
        self.script_dir = self._make_script_dir(self.config)

    @property
    def pkg_name(self):
        return self.location.split(':')[0]

    @property
    def version_table(self):
        return '{0}_alembic_version'.format(self.pkg_name)

    def run_env(self, fn, **kw):
        with EnvironmentContext(
            self.config,
            self.script_dir,
            fn=fn,
            version_table=self.version_table,
            **kw
            ):
            self.script_dir.run_env()

    def _make_config(self, location):
        cfg = Config()
        cfg.set_main_option("script_location", location)
        cfg.set_main_option("sqlalchemy.url", get_settings()['sqlalchemy.url'])
        return cfg

    def _make_script_dir(self, alembic_cfg):
        script_dir = ScriptDirectory.from_config(alembic_cfg)
        script_dir.__class__ = ScriptDirectoryWithDefaultEnvPy  # O_o
        return script_dir


def get_locations():
    conf_str = get_settings()['kotti.alembic_dirs']
    return [l.strip() for l in conf_str.split() if l.strip()]


def stamp_head(location=DEFAULT_LOCATION, revision=None):
    def do_stamp(rev, context, revision=revision):
        current = context._current_rev()
        if revision is None:
            revision = context.script.get_current_head()
        elif revision == 'None':
            revision = None
        context._update_current_rev(current, revision)
        mark_changed(DBSession())
        return []

    PackageEnvironment(location).run_env(do_stamp)


def stamp_heads():
    for location in get_locations():
        stamp_head(location)


def upgrade(location=DEFAULT_LOCATION):
    pkg_env = PackageEnvironment(location)

    revision = pkg_env.script_dir.get_current_head()
    print(u'Upgrading {0}:'.format(pkg_env.location))

    def upgrade(rev, context):
        if rev == revision:
            print(u'  - already up to date.')
            return []
        print(u'  - upgrading from {0} to {1}...'.format(
            rev, revision))
        return context.script._upgrade_revs(revision, rev)

    pkg_env.run_env(
        upgrade,
        starting_rev=None,
        destination_rev=revision,
        )
    print


def upgrade_all():
    for location in get_locations():
        upgrade(location)


def list_all():
    pkg_envs = [PackageEnvironment(l) for l in get_locations()]
    for pkg_env in pkg_envs:
        print(u'{0}:'.format(pkg_env.pkg_name))

        for script in pkg_env.script_dir.walk_revisions():
            print(u"  - {0} -> {1}: {2}".format(
                script.down_revision,
                script.revision,
                script.doc,
                ))

        def current_revision(rev, context):
            print(u"  - current revision: {0}".format(rev))
            return []
        pkg_env.run_env(current_revision)
        print


def kotti_migrate_command():
    __doc__ = """Migrate Kotti and Kotti add-ons.

    Usage:
      kotti-migrate <config_uri> list_all
      kotti-migrate <config_uri> upgrade [--scripts=<location>]
      kotti-migrate <config_uri> upgrade_all
      kotti-migrate <config_uri> stamp_head [--scripts=<location>] [--rev=<rev>]

    o 'list_all' prints a list of all available migrations of Kotti
      and registered add-ons.

    o 'upgrade' will run Kotti's upgrades to upgrade the database to
    the latest version.

      Use '--scripts=kotti_myaddon:alembic' to run the upgrades of the
      'kotti_myaddon' package instead.

    o 'upgrade_all' will run all upgrades of all packages registered
      with Kotti.

    o 'stamp_head' allows you to manually set the stamped version to
      the latest version inside the 'kotti_alembic_version' table,
      that is, without actually running any migrations.

      You may use this command for a different package by using the
      '--scripts' option.

    Options:
      -h --help     Show this screen.
    """
    # We need to turn off populators and root_factory when we run
    # migrations, because they would access the database, which may
    # not be possible prior to the migration.
    #
    # Unfortunately, we're not able to just set the 'kotti.populators'
    # setting to an empty list.  Since add-ons might add to this list
    # again later, when we call 'bootstrap' (and thus their
    # 'includeme' function).
    save_conf_defaults = conf_defaults.copy()

    os.environ['KOTTI_DISABLE_POPULATORS'] = '1'
    conf_defaults['kotti.root_factory'] = [lambda req: None]

    def callback(arguments):
        args = ()
        args_with_location = (arguments['--scripts'] or DEFAULT_LOCATION,)
        if arguments['list_all']:
            func = list_all
        elif arguments['upgrade']:
            func = upgrade
            args = args_with_location
        elif arguments['upgrade_all']:
            func = upgrade_all
        elif arguments['stamp_head']:
            func = stamp_head
            args = args_with_location + (arguments['--rev'],)
        func(*args)

    try:
        return command(callback, __doc__)
    finally:
        conf_defaults.clear()
        conf_defaults.update(save_conf_defaults)
        del os.environ['KOTTI_DISABLE_POPULATORS']

########NEW FILE########
__FILENAME__ = populate
"""
Populate contains two functions that are called on application startup
(if you haven't modified kotti.populators).
"""

from kotti import get_settings
from kotti.resources import DBSession
from kotti.resources import Node
from kotti.resources import Document
from kotti.security import get_principals
from kotti.security import SITE_ACL
from kotti.workflow import get_workflow


def populate_users():
    """
    Create the admin user with the password from the ``kotti.secret`` option
    if there is no user with name 'admin' yet.
    """

    principals = get_principals()
    if u'admin' not in principals:
        principals[u'admin'] = {
            'name': u'admin',
            'password': get_settings()['kotti.secret'],
            'title': u"Administrator",
            'groups': [u'role:admin'],
            }


def populate():
    """
    Create the root node (:class:`~kotti.resources.Document`) and the 'about'
    subnode in the nodes tree if there are no nodes yet.
    """

    if DBSession.query(Node).count() == 0:
        root = Document(**_ROOT_ATTRS)
        root.__acl__ = SITE_ACL
        DBSession.add(root)
        root['about'] = Document(**_ABOUT_ATTRS)

        wf = get_workflow(root)
        if wf is not None:
            DBSession.flush()  # Initializes workflow
            wf.transition_to_state(root, None, u'public')

    populate_users()

_ROOT_ATTRS = dict(
    name=u'',  # (at the time of writing) root must have empty name!
    title=u'Welcome to Kotti',
    description=u'Congratulations! You have successfully installed Kotti.',
    body=u"""
<h2>Log in</h2>
<p>
    You can <a class="btn btn-success" href="login">log in</a> to your site
    and start changing its contents.  If you haven't chosen a password for
    your admin account yet, it'll likely be <em>qwerty</em>.
</p>
<p>
    Once you're logged in, you'll see the grey editor bar below the top
    navigation bar.  It will allow you to switch between editing and viewing the
    current page as it will appear to your visitors.
</p>
<div class="row">
    <div class="col-md-4">
        <h2>Configure</h2>
        <p>
            Find out how to configure your Kotti's title and many other settings using a
            simple text file in your file system.
        </p>
        <p>
            <a class="btn btn-info"
               href="http://kotti.readthedocs.org/en/latest/developing/configuration.html">
               Configuration manual
            </a>
        </p>
    </div>
    <div class="col-md-4">
        <h2>Add-ons</h2>
        <p>
            A number of add-ons allow you to extend the functionality of your Kotti site.
        </p>
        <p>
            <a class="btn btn-info"
               href="http://pypi.python.org/pypi?%3Aaction=search&amp;term=kotti">
                Kotti add-ons
            </a>
        </p>
    </div>
    <div class="col-md-4">
        <h2>Documentation</h2>
        <p>
            Wonder what more you can do with Kotti?  What license it has?  Read the
            manual for more information.
        </p>
        <p>
            <a class="btn btn-info"
               href="http://kotti.readthedocs.org/en/latest/">
               Documentation
            </a>
        </p>
    </div>
</div>
""")

_ABOUT_ATTRS = dict(
    title=u'About',
    description=u'Our company is the leading manufacturer of foo widgets used in a wide variety of aviation and and industrial products.',
    body=u"""
<p>
  <img alt="five colorful Extra EA300 airplanes flying in formation"
   src="http://upload.wikimedia.org/wikipedia/commons/thumb/5/5d/Northern_Lights_Formation.jpg/640px-Northern_Lights_Formation.jpg"
   width="640" height="376" />
</p>

<p>
   Our worldwide headquarters:
</p>

<address>
  Foo World<br />
  123 Nowhere Street, Suite 777<br />
  Omak, WA   98841   USA<br />
  +1-509-555-0100<br />
  widgets@foowrld.example.com
</address>

<p><small style="font-size: smaller">
  <em>Photo credit:</em> "Northern Lights Formation" by FlugKerl2.
  <a href="http://commons.wikimedia.org/wiki/File:Northern_Lights_Formation.jpg">
  Copyright info</a>.
  Originally published in the
  <a href="http://en.wikipedia.org/wiki/Extra_EA-300"> Extra EA-300</a>
  article.
</small></p>
""")

########NEW FILE########
__FILENAME__ = resources
"""
The :mod:`~kotti.resources` module contains all the classes for Kotti's
persistance layer, which is based on SQLAlchemy.

Inheritance Diagram
-------------------

.. inheritance-diagram:: kotti.resources
"""

import os
from UserDict import DictMixin
from fnmatch import fnmatch
import warnings

from pyramid.threadlocal import get_current_registry
from pyramid.traversal import resource_path
from sqlalchemy import Boolean
from sqlalchemy import Column
from sqlalchemy import DateTime
from sqlalchemy import ForeignKey
from sqlalchemy import Integer
from sqlalchemy import LargeBinary
from sqlalchemy import String
from sqlalchemy import Unicode
from sqlalchemy import UnicodeText
from sqlalchemy import UniqueConstraint
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.ext.orderinglist import ordering_list
from sqlalchemy.orm import backref
from sqlalchemy.orm import deferred
from sqlalchemy.orm import object_mapper
from sqlalchemy.orm import relation
from sqlalchemy.orm.exc import NoResultFound
from sqlalchemy.sql import and_
from sqlalchemy.sql import select
from sqlalchemy.util import classproperty
from transaction import commit
from zope.deprecation.deprecation import deprecated
from zope.interface import implements

from kotti import Base
from kotti import DBSession
from kotti import get_settings
from kotti import metadata
from kotti.interfaces import INode
from kotti.interfaces import IContent
from kotti.interfaces import IDocument
from kotti.interfaces import IFile
from kotti.interfaces import IImage
from kotti.interfaces import IDefaultWorkflow
from kotti.migrate import stamp_heads
from kotti.security import PersistentACLMixin
from kotti.security import has_permission
from kotti.security import view_permitted
from kotti.sqla import ACLType
from kotti.sqla import JsonType
from kotti.sqla import MutationList
from kotti.sqla import NestedMutationDict
from kotti.util import Link
from kotti.util import LinkParent
from kotti.util import LinkRenderer
from kotti.util import _
from kotti.util import camel_case_to_name
from kotti.util import get_paste_items


class ContainerMixin(object, DictMixin):
    """Containers form the API of a Node that's used for subitem
    access and in traversal.
    """

    def __setitem__(self, key, node):
        key = node.name = unicode(key)
        self.children.append(node)

    def __delitem__(self, key):
        node = self[unicode(key)]
        self.children.remove(node)
        DBSession.delete(node)

    def keys(self):
        """
        :result: A list of children names.
        :rtype: list
        """

        return [child.name for child in self.children]

    def __getitem__(self, path):
        DBSession()._autoflush()

        if not hasattr(path, '__iter__'):
            path = (path,)
        path = [unicode(p) for p in path]

        # Optimization: don't query children if self._children already there:
        if '_children' in self.__dict__:
            first, rest = path[0], path[1:]
            try:
                [child] = filter(lambda ch: ch.name == path[0], self._children)
            except ValueError:
                raise KeyError(path)
            if rest:
                return child[rest]
            else:
                return child

        if len(path) == 1:
            try:
                return DBSession.query(Node).filter_by(
                    name=path[0], parent=self).one()
            except NoResultFound:
                raise KeyError(path)

        # We have a path with more than one element, so let's be a
        # little clever about fetching the requested node:
        nodes = Node.__table__
        conditions = [nodes.c.id == self.id]
        alias = nodes
        for name in path:
            alias, old_alias = nodes.alias(), alias
            conditions.append(alias.c.parent_id == old_alias.c.id)
            conditions.append(alias.c.name == name)
        expr = select([alias.c.id], and_(*conditions))
        row = DBSession.execute(expr).fetchone()
        if row is None:
            raise KeyError(path)
        return DBSession.query(Node).get(row.id)

    @hybrid_property
    def children(self):
        """Return *all* child nodes without considering permissions."""

        return self._children

    def children_with_permission(self, request, permission='view'):
        """
        Return only those children for which the user initiating
        the request has the asked permission.

        :param request: current request
        :type request: :class:`pyramid.request.Request`
        :param permission: The permission for which you want the allowed
                           children
        :type permission: str
        :result: List of child nodes
        :rtype: list
        """

        return [
            c for c in self.children
            if has_permission(permission, c, request)
        ]


class LocalGroup(Base):

    __tablename__ = 'local_groups'
    __table_args__ = (
        UniqueConstraint('node_id', 'principal_name', 'group_name'),
        )

    id = Column(Integer(), primary_key=True)
    node_id = Column(ForeignKey('nodes.id'))
    principal_name = Column(Unicode(100))
    group_name = Column(Unicode(100))

    def __init__(self, node, principal_name, group_name):
        self.node = node
        self.principal_name = principal_name
        self.group_name = group_name

    def copy(self, **kwargs):
        kwargs.setdefault('node', self.node)
        kwargs.setdefault('principal_name', self.principal_name)
        kwargs.setdefault('group_name', self.group_name)

        return self.__class__(**kwargs)


class Node(Base, ContainerMixin, PersistentACLMixin):
    """Basic node in the persistance hierarchy.
    """

    implements(INode)

    __table_args__ = (
        UniqueConstraint('parent_id', 'name'),
        )
    __mapper_args__ = dict(
        polymorphic_on='type',
        polymorphic_identity='node',
        with_polymorphic='*',
        )

    #: Primary key for the node in the DB
    #: (:class:`sqlalchemy.types.Integer`)
    id = Column(Integer(), primary_key=True)
    #: Lowercase class name of the node instance
    #: (:class:`sqlalchemy.types.String`)
    type = Column(String(30), nullable=False)
    #: ID of the node's parent
    #: (:class:`sqlalchemy.types.Integer`)
    parent_id = Column(ForeignKey('nodes.id'))
    #: Position of the node within its container / parent
    #: (:class:`sqlalchemy.types.Integer`)
    position = Column(Integer())
    _acl = Column(MutationList.as_mutable(ACLType))
    #: Name of the node as used in the URL
    #: (:class:`sqlalchemy.types.Unicode`)
    name = Column(Unicode(50), nullable=False)
    #: Title of the node, e.g. as shown in serach results
    #: (:class:`sqlalchemy.types.Unicode`)
    title = Column(Unicode(100))
    #: Annotations can be used to store arbitray data in a nested dictionary
    #: (:class:`kotti.sqla.NestedMustationDict`)
    annotations = Column(NestedMutationDict.as_mutable(JsonType))

    _children = relation(
        'Node',
        collection_class=ordering_list('position'),
        order_by=[position],
        backref=backref('parent', remote_side=[id]),
        cascade='all',
        )

    local_groups = relation(
        LocalGroup,
        backref=backref('node'),
        cascade='all',
        )

    def __init__(self, name=None, parent=None, title=u"", annotations=None,
                 **kwargs):
        """Constructor"""

        if annotations is None:
            annotations = {}
        self.name = name
        self.parent = parent
        self.title = title
        self.annotations = annotations

        super(Node, self).__init__(**kwargs)

    @property
    def __name__(self):
        return self.name

    @property
    def __parent__(self):
        return self.parent

    @__parent__.setter
    def __parent__(self, value):
        self.parent = value

    def __repr__(self):
        return '<%s %s at %s>' % (
            self.__class__.__name__, self.id, resource_path(self))

    def __eq__(self, other):
        return isinstance(other, Node) and self.id == other.id

    def __ne__(self, other):
        return not self == other

    copy_properties_blacklist = (
        'id', 'parent', 'parent_id', '_children', 'local_groups', '_tags')

    def copy(self, **kwargs):
        """
        :result: A copy of the current instance
        :rtype: :class:`~kotti.resources.Node`
        """

        children = list(self.children)
        copy = self.__class__()
        for prop in object_mapper(self).iterate_properties:
            if prop.key not in self.copy_properties_blacklist:
                setattr(copy, prop.key, getattr(self, prop.key))
        for key, value in kwargs.items():
            setattr(copy, key, value)
        for child in children:
            copy.children.append(child.copy())

        return copy


class TypeInfo(object):
    """TypeInfo instances contain information about the type of a node.

       You can pass arbitrary keyword arguments in the constructor, they
       will become instance attributes.  The most common are:

            -   name
            -   title
            -   add_view
            -   addable_to
            -   edit_links
            -   selectable_default_views
            -   uploadable_mimetypes
    """

    addable_to = ()
    selectable_default_views = ()
    uploadable_mimetypes = ()
    edit_links = ()
    action_links = ()  # BBB

    def __init__(self, **kwargs):
        if 'action_links' in kwargs:
            msg = ("'action_links' is deprecated as of Kotti 0.10.  "
                   "'edit_links' includes 'action_links' and should "
                   "be used instead.")

            edit_links = kwargs.get('edit_links')
            last_link = edit_links[-1] if edit_links else None
            if isinstance(last_link, LinkParent):
                last_link.children.extend(kwargs['action_links'])
                warnings.warn(msg, DeprecationWarning)
            else:
                raise ValueError(msg)

        self.__dict__.update(kwargs)

    def copy(self, **kwargs):
        """

        :result: a copy of the current TypeInfo instance
        :rtype: :class:`~kotti.resources.TypeInfo`
        """

        d = self.__dict__.copy()
        d.update(kwargs)

        return TypeInfo(**d)

    def addable(self, context, request):
        """

        :param context:
        :type context: Content or subclass thereof (or anything that has a
                       type_info attribute of type
                       :class:`~kotti.resources.TypeInfo`)

        :param request: current request
        :type request: :class:`pyramid.request.Request`

        :result: True if the type described in 'self' may be added to 'context',
                 False otherwise.
        :rtype: Boolean
        """

        if view_permitted(context, request, self.add_view):
            return context.type_info.name in self.addable_to
        else:
            return False

    def add_selectable_default_view(self, name, title):
        """Add a view to the list of default views selectable by the
        user in the UI.

        :param name: Name the view is registered with
        :type name: str

        :param title: Title for the view for display in the UI.
        :type title: unicode or TranslationString
        """
        self.selectable_default_views.append((name, title))

    def is_uploadable_mimetype(self, mimetype):
        """ Check if uploads of the given MIME type are allowed.

        :param mimetype: MIME type
        :type mimetype: str

        :result: Upload allowed (>0) or forbidden (0).  The greater the result,
                 the better is the match.  E.g. ``image/*`` (6) is a better
                 match for ``image/png`` than `*` (1).
        :rtype: int
        """

        match_score = 0

        for mt in self.uploadable_mimetypes:
            if fnmatch(mimetype, mt):
                if len(mt) > match_score:
                    match_score = len(mt)

        return match_score


class Tag(Base):
    """Basic tag implementation.  Instances of this class are just the tag
    itself and can be mapped to instances of :class:`~kotti.resources.Content`
    (or any of its descendants) via instances of
    :class:`~kotti.resources.TagsToContents`.
    """

    #: Primary key column in the DB
    #: (:class:`sqlalchemy.types.Integer`)
    id = Column(Integer, primary_key=True)

    #: Title of the tag
    #: :class:`sqlalchemy.types.Unicode`
    title = Column(Unicode(100), unique=True, nullable=False)

    def __repr__(self):
        return "<Tag ('%s')>" % self.title

    @property
    def items(self):
        """

        :result:
        :rtype: list
        """

        return [rel.item for rel in self.content_tags]


class TagsToContents(Base):
    """Tags to contents mapping
    """

    __tablename__ = 'tags_to_contents'

    #: Foreign key referencing :attr:`Tag.id`
    #: (:class:`sqlalchemy.types.Integer`)
    tag_id = Column(Integer, ForeignKey('tags.id'), primary_key=True)
    #: Foreign key referencing :attr:`Content.id`
    #: (:class:`sqlalchemy.types.Integer`)
    content_id = Column(Integer, ForeignKey('contents.id'), primary_key=True)
    #: Relation that adds a ``content_tags`` :func:`sqlalchemy.orm.backref`
    #: to :class:`~kotti.resources.Tag` instances to allow easy access to all
    #: content tagged with that tag.
    #: (:func:`sqlalchemy.orm.relationship`)
    tag = relation(Tag, backref=backref('content_tags', cascade='all'))
    #: Ordering position of the tag
    #: :class:`sqlalchemy.types.Integer`
    position = Column(Integer, nullable=False)
    #: title of the associated :class:`~kotti.resources.Tag` instance
    #: (:class:`sqlalchemy.ext.associationproxy.association_proxy`)
    title = association_proxy('tag', 'title')

    @classmethod
    def _tag_find_or_create(cls, title):
        """
        Find or create a tag with the given title.

        :param title: Title of the tag to find or create.
        :type title: unicode
        :result:
        :rtype: :class:`~kotti.resources.TagsToContents`
        """

        with DBSession.no_autoflush:
            tag = DBSession.query(Tag).filter_by(title=title).first()
        if tag is None:
            tag = Tag(title=title)
        return cls(tag=tag)


def _not_root(context, request):
    return not context is get_root()


default_type_info = TypeInfo(
    name=u'Content',
    title=u'type_info title missing',   # BBB
    add_view=None,
    addable_to=[],
    edit_links=[
        Link('contents', title=_(u'Contents')),
        Link('edit', title=_(u'Edit')),
        Link('share', title=_(u'Share')),
        LinkParent(title=_(u'Actions'), children=[
            Link('copy', title=_(u'Copy')),
            Link('cut', title=_(u'Cut'), predicate=_not_root),
            Link('paste', title=_(u'Paste'), predicate=get_paste_items),
            Link('rename', title=_(u'Rename'), predicate=_not_root),
            Link('delete', title=_(u'Delete'), predicate=_not_root),
            LinkRenderer('default-view-selector'),
            ]),
        ],
    selectable_default_views=[
        ("folder_view", _(u"Folder view")),
        ],
    )


class Content(Node):
    """Content adds some attributes to :class:`~kotti.resources.Node` that are
       useful for content objects in a CMS.
    """

    implements(IContent)

    @classproperty
    def __mapper_args__(cls):
        return dict(polymorphic_identity=camel_case_to_name(cls.__name__))

    #: Primary key column in the DB
    #: (:class:`sqlalchemy.types.Integer`)
    id = Column(Integer, ForeignKey('nodes.id'), primary_key=True)
    #: Name of the view that should be displayed to the user when
    #: visiting an URL without a explicit view name appended
    #: (:class:`sqlalchemy.types.String`)
    default_view = Column(String(50))
    #: Description of the content object.  In default Kotti this is
    #: used e.g. in the description tag in the HTML, in the search results
    #: and rendered below the title in most views.
    #: (:class:`sqlalchemy.types.Unicode`)
    description = Column(UnicodeText())
    #: Language code (ISO 639) of the content object
    #: (:class:`sqlalchemy.types.Unicode`)
    language = Column(Unicode(10))
    #: Owner (username) of the content object
    #: (:class:`sqlalchemy.types.Unicode`)
    owner = Column(Unicode(100))
    #: Workflow state of the content object
    #: (:class:`sqlalchemy.types.String`)
    state = Column(String(50))
    #: Date / time the content was created
    #: (:class:`sqlalchemy.types.DateTime`)
    creation_date = Column(DateTime())
    #: Date / time the content was last modified
    #: (:class:`sqlalchemy.types.DateTime`)
    modification_date = Column(DateTime())
    #: Shall the content be visible in the navigation?
    #: (:class:`sqlalchemy.types.Boolean`)
    in_navigation = Column(Boolean())
    _tags = relation(
        TagsToContents,
        backref=backref('item'),
        order_by=[TagsToContents.position],
        collection_class=ordering_list("position"),
        cascade='all, delete-orphan',
        )
    #: Tags assigned to the content object (list of str)
    tags = association_proxy(
        '_tags',
        'title',
        creator=TagsToContents._tag_find_or_create,
        )
    #: type_info is a class attribute (:class:`TypeInfo`)
    type_info = default_type_info

    def __init__(self, name=None, parent=None, title=u"", annotations=None,
                 default_view=None, description=u"", language=None,
                 owner=None, creation_date=None, modification_date=None,
                 in_navigation=True, tags=None, **kwargs):

        super(Content, self).__init__(
            name, parent, title, annotations, **kwargs)

        self.default_view = default_view
        self.description = description
        self.language = language
        self.owner = owner
        self.in_navigation = in_navigation
        # These are set by events if not defined at this point:
        self.creation_date = creation_date
        self.modification_date = modification_date
        self.tags = tags or []

    def copy(self, **kwargs):
        # Same as `Node.copy` with additional tag support.
        kwargs['tags'] = self.tags
        return super(Content, self).copy(**kwargs)


class Document(Content):
    """Document extends :class:`~kotti.resources.Content` with a body and its
       mime_type.  In addition Document and its descendants implement
       :class:`~kotti.interfaces.IDefaultWorkflow` and therefore
       are associated with the default workflow (at least in
       unmodified Kotti installations).
    """

    implements(IDocument, IDefaultWorkflow)

    #: Primary key column in the DB
    #: (:class:`sqlalchemy.types.Integer`)
    id = Column(Integer(), ForeignKey('contents.id'), primary_key=True)
    #: Body text of the Document
    #: (:class:`sqlalchemy.types.Unicode`)
    body = Column(UnicodeText())
    #: MIME type of the Document
    #: (:class:`sqlalchemy.types.String`)
    mime_type = Column(String(30))

    #: type_info is a class attribute
    #: (:class:`~kotti.resources.TypeInfo`)
    type_info = Content.type_info.copy(
        name=u'Document',
        title=_(u'Document'),
        add_view=u'add_document',
        addable_to=[u'Document'],
        )

    def __init__(self, body=u"", mime_type='text/html', **kwargs):

        super(Document, self).__init__(**kwargs)

        self.body = body
        self.mime_type = mime_type


class File(Content):
    """File adds some attributes to :class:`~kotti.resources.Content` that are
       useful for storing binary data.
    """

    implements(IFile)

    #: Primary key column in the DB
    #: (:class:`sqlalchemy.types.Integer`)
    id = Column(Integer(), ForeignKey('contents.id'), primary_key=True)
    #: The binary data itself
    #: (:class:`sqlalchemy.types.LargeBinary`)
    data = deferred(Column(LargeBinary()))
    #: The filename is used in the attachment view to give downloads
    #: the original filename it had when it was uploaded.
    #: (:class:`sqlalchemy.types.Unicode`)
    filename = Column(Unicode(100))
    #: MIME type of the file
    #: (:class:`sqlalchemy.types.String`)
    mimetype = Column(String(100))
    #: Size of the file in bytes
    #: (:class:`sqlalchemy.types.Integer`)
    size = Column(Integer())

    type_info = Content.type_info.copy(
        name=u'File',
        title=_(u'File'),
        add_view=u'add_file',
        addable_to=[u'Document'],
        selectable_default_views=[],
        uploadable_mimetypes=['*', ],
        )

    def __init__(self, data=None, filename=None, mimetype=None, size=None,
                 **kwargs):

        super(File, self).__init__(**kwargs)

        self.data = data
        self.filename = filename
        self.mimetype = mimetype
        self.size = size

    @classmethod
    def from_field_storage(cls, fs):
        """ Create and return an instance of this class from a file upload
            through a webbrowser.

        :param fs: FieldStorage instance as found in a
                   :class:`pyramid.request.Request`'s ``POST`` MultiDict.
        :type fs: :class:`cgi.FieldStorage`

        :result: The created instance.
        :rtype: :class:`kotti.resources.File`
        """

        data = fs.file.read()
        filename = fs.filename
        mimetype = fs.type
        size = len(data)

        if not cls.type_info.is_uploadable_mimetype(mimetype):
            raise ValueError("Unsupported MIME type: %s" % mimetype)

        return cls(data=data, filename=filename, mimetype=mimetype, size=size)


class Image(File):
    """Image doesn't add anything to :class:`~kotti.resources.File`, but images
       have different views, that e.g. support on the fly scaling.
    """

    implements(IImage)

    id = Column(Integer(), ForeignKey('files.id'), primary_key=True)

    type_info = File.type_info.copy(
        name=u'Image',
        title=_(u'Image'),
        add_view=u'add_image',
        addable_to=[u'Document'],
        selectable_default_views=[],
        uploadable_mimetypes=['image/*', ],
        )


def get_root(request=None):
    """Call the function defined by the ``kotti.root_factory`` setting and
       return its result.

    :param request: current request (optional)
    :type request: :class:`pyramid.request.Request`

    :result: a node in the node tree
    :rtype: :class:`~kotti.resources.Node` or descendant;
    """
    return get_settings()['kotti.root_factory'][0](request)


def default_get_root(request=None):
    """Default implementation for :func:`~kotti.resources.get_root`.

    :param request: Current request (optional)
    :type request: :class:`pyramid.request.Request`

    :result: Node in the object tree that has no parent.
    :rtype: :class:`~kotti.resources.Node` or descendant; in a fresh Kotti site
            with Kotti's :func:`default populator <kotti.populate.populate>`
            this will be an instance of :class:`~kotti.resources.Document`.
    """
    return DBSession.query(Node).filter(Node.parent_id == None).one()


def initialize_sql(engine, drop_all=False):
    DBSession.registry.clear()
    DBSession.configure(bind=engine)
    metadata.bind = engine

    if drop_all or os.environ.get('KOTTI_TEST_DB_STRING'):
        metadata.reflect()
        metadata.drop_all(engine)

    # Allow users of Kotti to cherry pick the tables that they want to use:
    settings = get_current_registry().settings
    tables = settings['kotti.use_tables'].strip() or None
    if tables:
        tables = [metadata.tables[name] for name in tables.split()]

    if engine.dialect.name == 'mysql':  # pragma: no cover
        from sqlalchemy.dialects.mysql.base import LONGBLOB
        File.__table__.c.data.type = LONGBLOB()

    # Allow migrations to set the 'head' stamp in case the database is
    # initialized freshly:
    if not engine.table_names():
        stamp_heads()

    metadata.create_all(engine, tables=tables)
    if os.environ.get('KOTTI_DISABLE_POPULATORS', '0') not in ('1', 'y'):
        for populate in get_settings()['kotti.populators']:
            populate()
    commit()

    return DBSession


# BBB
for iface in ("INode", "IContent", "IDocument", "IFile", "IImage",
              "IDefaultWorkflow"):
    deprecated(iface,
               "%s has been moved to kotti.interfaces as of Kotti 0.8. "
               "Import from there instead." % iface)

########NEW FILE########
__FILENAME__ = security
from __future__ import with_statement
from contextlib import contextmanager
from datetime import datetime
from UserDict import DictMixin

import bcrypt
from sqlalchemy import Boolean
from sqlalchemy import Column
from sqlalchemy import DateTime
from sqlalchemy import Integer
from sqlalchemy import Unicode
from sqlalchemy import func
from sqlalchemy.sql.expression import or_
from sqlalchemy.orm.exc import NoResultFound
from pyramid.location import lineage
from pyramid.security import authenticated_userid
from pyramid.security import has_permission as base_has_permission
from pyramid.security import view_execution_permitted

from kotti import get_settings
from kotti import DBSession
from kotti import Base
from kotti.sqla import JsonType
from kotti.util import _
from kotti.util import request_cache
from kotti.util import DontCache


def get_principals():
    return get_settings()['kotti.principals_factory'][0]()


@request_cache(lambda request: None)
def get_user(request):
    userid = authenticated_userid(request)
    return get_principals().get(userid)


def has_permission(permission, context, request):
    with authz_context(context, request):
        return base_has_permission(permission, context, request)


class Principal(Base):
    """A minimal 'Principal' implementation.

    The attributes on this object correspond to what one ought to
    implement to get full support by the system.  You're free to add
    additional attributes.

      - As convenience, when passing 'password' in the initializer, it
        is hashed using 'get_principals().hash_password'

      - The boolean 'active' attribute defines whether a principal may
        log in.  This allows the deactivation of accounts without
        deleting them.

      - The 'confirm_token' attribute is set whenever a user has
        forgotten their password.  This token is used to identify the
        receiver of the email.  This attribute should be set to
        'None' once confirmation has succeeded.
    """
    __tablename__ = 'principals'
    __mapper_args__ = dict(
        order_by='principals.name',
        )

    id = Column(Integer, primary_key=True)
    name = Column(Unicode(100), unique=True)
    password = Column(Unicode(100))
    active = Column(Boolean)
    confirm_token = Column(Unicode(100))
    title = Column(Unicode(100), nullable=False)
    email = Column(Unicode(100), unique=True)
    groups = Column(JsonType(), nullable=False)
    creation_date = Column(DateTime(), nullable=False)
    last_login_date = Column(DateTime())

    def __init__(self, name, password=None, active=True, confirm_token=None,
                 title=u"", email=None, groups=()):
        self.name = name
        if password is not None:
            password = get_principals().hash_password(password)
        self.password = password
        self.active = active
        self.confirm_token = confirm_token
        self.title = title
        self.email = email
        self.groups = groups
        self.creation_date = datetime.now()
        self.last_login_date = None

    def __repr__(self):  # pragma: no cover
        return '<Principal %r>' % self.name


class AbstractPrincipals(object):
    """This class serves as documentation and defines what methods are
    expected from a Principals database.

    Principals mostly provides dict-like access to the principal
    objects in the database.  In addition, there's the 'search' method
    which allows searching users and groups.

    'hash_password' is for initial hashing of a clear text password,
    while 'validate_password' is used by the login to see if the
    entered password matches the hashed password that's already in the
    database.

    Use the 'kotti.principals' settings variable to override Kotti's
    default Principals implementation with your own.
    """
    def __getitem__(self, name):
        """Return the Principal object with the id 'name'.
        """

    def __setitem__(self, name, principal):
        """Add a given Principal object to the database.

        'name' is expected to the the same as 'principal.name'.

        'principal' may also be a dict of attributes.
        """

    def __delitem__(self, name):
        """Remove the principal with the given name from the database.
        """

    def keys(self):
        """Return a list of principal ids that are in the database.
        """

    def search(self, **kwargs):
        """Return an iterable with principal objects that correspond
        to the search arguments passed in.

        This example would return all principals with the id 'bob':

          get_principals().search(name=u'bob')

        Here, we ask for all principals that have 'bob' in either
        their 'name' or their 'title'.  We pass '*bob*' instead of
        'bob' to indicate that we want case-insensitive substring
        matching:

          get_principals().search(name=u'*bob*', title=u'*bob*')

        This call should fail with AttributeError unless there's a
        'foo' attribute on principal objects that supports search:

          get_principals().search(name=u'bob', foo=u'bar')
        """

    def hash_password(self, password):
        """Return a hash of the given password.

        This is what's stored in the database as 'principal.password'.
        """

    def validate_password(self, clear, hashed):
        """Returns True if the clear text password matches the hash.
        """

ROLES = {
    u'role:viewer': Principal(u'role:viewer', title=_(u'Viewer')),
    u'role:editor': Principal(u'role:editor', title=_(u'Editor')),
    u'role:owner': Principal(u'role:owner', title=_(u'Owner')),
    u'role:admin': Principal(u'role:admin', title=_(u'Admin')),
    }
_DEFAULT_ROLES = ROLES.copy()

# These roles are visible in the sharing tab
SHARING_ROLES = [u'role:viewer', u'role:editor', u'role:owner']
USER_MANAGEMENT_ROLES = SHARING_ROLES + ['role:admin']
_DEFAULT_SHARING_ROLES = SHARING_ROLES[:]
_DEFAULT_USER_MANAGEMENT_ROLES = USER_MANAGEMENT_ROLES[:]

# This is the ACL that gets set on the site root on creation.  Note
# that this is only really useful if you're _not_ using workflow.  If
# you are, then you should look at the permissions in workflow.zcml.
SITE_ACL = [
    ['Allow', 'system.Everyone', ['view']],
    ['Allow', 'role:viewer', ['view']],
    ['Allow', 'role:editor', ['view', 'add', 'edit', 'state_change']],
    ['Allow', 'role:owner', ['view', 'add', 'edit', 'manage', 'state_change']],
    ]


def set_roles(roles_dict):
    ROLES.clear()
    ROLES.update(roles_dict)


def set_sharing_roles(role_names):
    SHARING_ROLES[:] = role_names


def set_user_management_roles(role_names):
    USER_MANAGEMENT_ROLES[:] = role_names


def reset_roles():
    ROLES.clear()
    ROLES.update(_DEFAULT_ROLES)


def reset_sharing_roles():
    SHARING_ROLES[:] = _DEFAULT_SHARING_ROLES


def reset_user_management_roles():
    USER_MANAGEMENT_ROLES[:] = _DEFAULT_USER_MANAGEMENT_ROLES


def reset():
    reset_roles()
    reset_sharing_roles()
    reset_user_management_roles()


class PersistentACLMixin(object):
    def _get_acl(self):
        if self._acl is None:
            raise AttributeError('__acl__')
        return self._acl

    def _set_acl(self, value):
        self._acl = value

    def _del_acl(self):
        self._acl = None

    __acl__ = property(_get_acl, _set_acl, _del_acl)


def _cachekey_list_groups_raw(name, context):
    context_id = context is not None and getattr(context, 'id', id(context))
    return (name, context_id)


@request_cache(_cachekey_list_groups_raw)
def list_groups_raw(name, context):
    """A set of group names in given ``context`` for ``name``.

    Only groups defined in context will be considered, therefore no
    global or inherited groups are returned.
    """
    from kotti.resources import LocalGroup
    from kotti.resources import Node

    if isinstance(context, Node):
        return set(
            r[0] for r in DBSession.query(LocalGroup.group_name).filter(
            LocalGroup.node_id == context.id).filter(
            LocalGroup.principal_name == name).all()
            )
    return set()


def list_groups(name, context=None):
    """List groups for principal with a given ``name``.

    The optional ``context`` argument may be passed to check the list
    of groups in a given context.
    """
    return list_groups_ext(name, context)[0]


def _cachekey_list_groups_ext(name, context=None, _seen=None, _inherited=None):
    if _seen is not None or _inherited is not None:
        raise DontCache
    else:
        context_id = getattr(context, 'id', id(context))
        return (name, context_id)


@request_cache(_cachekey_list_groups_ext)
def list_groups_ext(name, context=None, _seen=None, _inherited=None):
    name = unicode(name)
    groups = set()
    recursing = _inherited is not None
    _inherited = _inherited or set()

    # Add groups from principal db:
    principal = get_principals().get(name)
    if principal is not None:
        groups.update(principal.groups)
        if context is not None or (context is None and _seen is not None):
            _inherited.update(principal.groups)

    if _seen is None:
        _seen = set([name])

    # Add local groups:
    if context is not None:
        items = lineage(context)
        for idx, item in enumerate(items):
            group_names = [i for i in list_groups_raw(name, item)
                           if i not in _seen]
            groups.update(group_names)
            if recursing or idx != 0:
                _inherited.update(group_names)

    new_groups = groups - _seen
    _seen.update(new_groups)
    for group_name in new_groups:
        g, i = list_groups_ext(
            group_name, context, _seen=_seen, _inherited=_inherited)
        groups.update(g)
        _inherited.update(i)

    return list(groups), list(_inherited)


def set_groups(name, context, groups_to_set=()):
    """Set the list of groups for principal with given ``name`` and in
    given ``context``.
    """
    name = unicode(name)
    from kotti.resources import LocalGroup
    DBSession.query(LocalGroup).filter(
        LocalGroup.node_id == context.id).filter(
        LocalGroup.principal_name == name).delete()

    for group_name in groups_to_set:
        DBSession.add(LocalGroup(context, name, unicode(group_name)))


def list_groups_callback(name, request):
    if not is_user(name):
        return None  # Disallow logging in with groups
    if name in get_principals():
        context = request.environ.get(
            'authz_context', getattr(request, 'context', None))
        if context is None:
            # SA events don't have request.context available
            from kotti.resources import get_root
            context = get_root(request)
        return list_groups(name, context)


@contextmanager
def authz_context(context, request):
    before = request.environ.pop('authz_context', None)
    request.environ['authz_context'] = context
    try:
        yield
    finally:
        del request.environ['authz_context']
        if before is not None:
            request.environ['authz_context'] = before


@contextmanager
def request_method(request, method):
    before = request.method
    request.method = method
    try:
        yield
    finally:
        request.method = before


def view_permitted(context, request, name='', method='GET'):
    with authz_context(context, request):
        with request_method(request, method):
            return view_execution_permitted(context, request, name)


def principals_with_local_roles(context, inherit=True):
    """Return a list of principal names that have local roles in the
    context.
    """
    from resources import LocalGroup
    principals = set()
    items = [context]
    if inherit:
        items = lineage(context)
    for item in items:
        principals.update(
            r[0] for r in
            DBSession.query(LocalGroup.principal_name).filter(
                LocalGroup.node_id == item.id).group_by(
                LocalGroup.principal_name).all()
            if not r[0].startswith('role:')
            )
    return list(principals)


def map_principals_with_local_roles(context):
    principals = get_principals()
    value = []
    for principal_name in principals_with_local_roles(context):
        try:
            principal = principals[principal_name]
        except KeyError:
            continue
        else:
            all, inherited = list_groups_ext(principal_name, context)
            value.append((principal, (all, inherited)))
    return sorted(value, key=lambda t: t[0].name)


def is_user(principal):
    if not isinstance(principal, basestring):
        principal = principal.name
    return ':' not in principal


class Principals(DictMixin):
    """Kotti's default principal database.

    Look at 'AbstractPrincipals' for documentation.

    This is a default implementation that may be replaced by using the
    'kotti.principals' settings variable.
    """
    factory = Principal

    @request_cache(lambda self, name: name)
    def __getitem__(self, name):
        name = unicode(name)
        try:
            return DBSession.query(
                self.factory).filter(self.factory.name == name).one()
        except NoResultFound:
            raise KeyError(name)

    def __setitem__(self, name, principal):
        name = unicode(name)
        if isinstance(principal, dict):
            principal = self.factory(**principal)
        DBSession.add(principal)

    def __delitem__(self, name):
        name = unicode(name)
        try:
            principal = DBSession.query(
                self.factory).filter(self.factory.name == name).one()
            DBSession.delete(principal)
        except NoResultFound:
            raise KeyError(name)

    def iterkeys(self):
        for (principal_name,) in DBSession.query(self.factory.name):
            yield principal_name

    def keys(self):
        return list(self.iterkeys())

    def search(self, **kwargs):
        if not kwargs:
            return []

        filters = []
        for key, value in kwargs.items():
            col = getattr(self.factory, key)
            if '*' in value:
                value = value.replace('*', '%').lower()
                filters.append(func.lower(col).like(value))
            else:
                filters.append(col == value)

        query = DBSession.query(self.factory)
        query = query.filter(or_(*filters))
        return query

    log_rounds = 10

    def hash_password(self, password, hashed=None):
        if hashed is None:
            hashed = bcrypt.gensalt(self.log_rounds)
        return unicode(
            bcrypt.hashpw(password.encode('utf-8'), hashed.encode('utf-8')))

    def validate_password(self, clear, hashed):
        try:
            return self.hash_password(clear, hashed) == hashed
        except ValueError:
            return False


def principals_factory():
    return Principals()

########NEW FILE########
__FILENAME__ = sqla
# -*- coding: utf-8 -*-

"""
Inheritance Diagram
-------------------

.. inheritance-diagram:: kotti.sqla
"""

from pyramid.compat import json
from pyramid.security import ALL_PERMISSIONS
from pyramid.security import Allow
from sqlalchemy.types import TypeDecorator, TEXT
from sqlalchemy.ext.mutable import Mutable
from sqlalchemy.ext.declarative import declared_attr


def dump_default(obj):
    if isinstance(obj, MutationDict):
        return obj._d
    elif isinstance(obj, MutationList):
        return obj._d


class JsonType(TypeDecorator):
    """http://www.sqlalchemy.org/docs/core/types.html#marshal-json-strings
    """
    impl = TEXT

    def process_bind_param(self, value, dialect):
        if value is not None:
            value = json.dumps(value, default=dump_default)
        return value

    def process_result_value(self, value, dialect):
        if value is not None:
            value = json.loads(value)
        return value


class ACLType(JsonType):
    ALL_PERMISSIONS_SERIALIZED = '__ALL_PERMISSIONS__'
    DEFAULT_ACE = (Allow, 'role:admin', ALL_PERMISSIONS)

    def process_bind_param(self, value, dialect):
        if value is not None:
            value = [list(ace) for ace in value if ace != self.DEFAULT_ACE]
            for ace in value:
                if ace[2] == ALL_PERMISSIONS:
                    ace[2] = self.ALL_PERMISSIONS_SERIALIZED
        return super(ACLType, self).process_bind_param(value, dialect)

    def process_result_value(self, value, dialect):
        acl = super(ACLType, self).process_result_value(value, dialect)
        if acl is not None:
            for ace in acl:
                if ace[2] == self.ALL_PERMISSIONS_SERIALIZED:
                    ace[2] = ALL_PERMISSIONS
            return [self.DEFAULT_ACE] + [tuple(ace) for ace in acl]


class MutationDict(Mutable):
    """http://www.sqlalchemy.org/docs/orm/extensions/mutable.html
    """
    def __init__(self, data):
        self._d = data
        super(MutationDict, self).__init__()

    @classmethod
    def coerce(cls, key, value):
        if not isinstance(value, MutationDict):
            if isinstance(value, dict):
                return cls(value)
            return Mutable.coerce(key, value)
        else:
            return value


class MutationList(Mutable):
    def __init__(self, data):
        self._d = data
        super(MutationList, self).__init__()

    @classmethod
    def coerce(cls, key, value):
        if not isinstance(value, MutationList):
            if isinstance(value, list):
                return cls(value)
            return Mutable.coerce(key, value)
        else:
            return value

    def __radd__(self, other):
        return other + self._d


def _make_mutable_method_wrapper(wrapper_class, methodname, mutates):
    def replacer(self, *args, **kwargs):
        method = getattr(self._d, methodname)
        value = method(*args, **kwargs)
        if mutates:
            self.changed()
        return value
    replacer.__name__ = methodname
    return replacer


for wrapper_class in (MutationDict, MutationList):
    for methodname, mutates in (
            ('__iter__', False),
            ('__len__', False),
            ('__eq__', False),
            ('__add__', False),
            ('__getitem__', False),
            ('__getslice__', False),
            ('__repr__', False),
            ('get', False),
            ('keys', False),

            ('__setitem__', True),
            ('__delitem__', True),
            ('__setslice__', True),
            ('__delslice__', True),
            ('append', True),
            ('clear', True),
            ('extend', True),
            ('insert', True),
            ('pop', True),
            ('setdefault', True),
            ('update', True),
            ):
        setattr(
            wrapper_class, methodname,
            _make_mutable_method_wrapper(
                wrapper_class, methodname, mutates),
            )


class NestedMixin(object):
    __parent__ = None

    def __init__(self, *args, **kwargs):
        self.__parent__ = kwargs.pop('__parent__', None)
        super(NestedMixin, self).__init__(*args, **kwargs)

    def __getitem__(self, key):
        value = self._d.__getitem__(key)
        return self.try_wrap(value)

    def changed(self):
        if self.__parent__ is not None:
            self.__parent__.changed()
        else:
            super(NestedMixin, self).changed()

    def try_wrap(self, value):
        for typ, wrapper in MUTATION_WRAPPERS.items():
            if isinstance(value, typ):
                value = wrapper(value, __parent__=self)
                break
        return value

    def __eq__(self, other):
        return self._d == other


class NestedMutationDict(NestedMixin, MutationDict):
    def setdefault(self, key, default):
        if isinstance(default, list):
            default = NestedMutationList(default, __parent__=self)
        elif isinstance(default, dict):
            default = NestedMutationDict(default, __parent__=self)
        return super(NestedMutationDict, self).setdefault(key, default)


class NestedMutationList(NestedMixin, MutationList):
    pass


MUTATION_WRAPPERS = {
    dict: NestedMutationDict,
    list: NestedMutationList,
    }


class Base(object):
    @declared_attr
    def __tablename__(cls):
        from kotti.util import camel_case_to_name  # prevent circ import
        return '{0}s'.format(camel_case_to_name(cls.__name__))

########NEW FILE########
__FILENAME__ = testing
# -*- coding: utf-8 -*-

"""
Inheritance Diagram
-------------------

.. inheritance-diagram:: kotti.testing
"""

import os
from os.path import join, dirname
from unittest import TestCase
from pytest import mark

from pyramid import testing
from pyramid.events import NewResponse
from pyramid.security import ALL_PERMISSIONS
from zope.deprecation.deprecation import deprecate
import transaction


# re-enable deprecation warnings during test runs
# however, let the `ImportWarning` produced by Babel's
# `localedata.py` vs `localedata/` show up once...
from warnings import catch_warnings
with catch_warnings():
    from babel import localedata
    import compiler
    localedata, compiler    # make pyflakes happy... :p


# py.test markers (see http://pytest.org/latest/example/markers.html)
user = mark.user


BASE_URL = 'http://localhost:6543'


class Dummy(dict):
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)


class DummyRequest(testing.DummyRequest):
    is_xhr = False
    POST = dict()
    user = None
    referrer = None

    def is_response(self, ob):
        return (hasattr(ob, 'app_iter') and hasattr(ob, 'headerlist') and
                hasattr(ob, 'status'))


def asset(name):
    import kotti
    return open(join(dirname(kotti.__file__), 'tests', name), 'rb')


def includeme_login(config):
    config.add_view(
        login_view,
        name='login',
        renderer='kotti:templates/login.pt')


def includeme_layout(config):
    # override edit master layout with view master layout
    config.override_asset(
        to_override='kotti:templates/edit/master.pt',
        override_with='kotti:templates/view/master.pt')


def login_view(request):
    return {}


def dummy_search(search_term, request):
    return u"Not found. Sorry!"


def testing_db_url():
    return os.environ.get('KOTTI_TEST_DB_STRING', 'sqlite://')


def _initTestingDB():
    from sqlalchemy import create_engine
    from kotti import get_settings
    from kotti.resources import initialize_sql

    database_url = testing_db_url()
    get_settings()['sqlalchemy.url'] = database_url
    session = initialize_sql(create_engine(database_url), drop_all=True)
    return session


def _populator():
    from kotti import DBSession
    from kotti.resources import Document
    from kotti.populate import populate

    populate()
    for doc in DBSession.query(Document)[1:]:
        DBSession.delete(doc)
    transaction.commit()


def _turn_warnings_into_errors():  # pragma: no cover
    # turn all warnings into errors, but let the `ImportWarning`
    # produced by Babel's `localedata.py` vs `localedata/` show up once...
    from babel import localedata
    localedata  # make pyflakes happy... :p
    from warnings import filterwarnings
    filterwarnings("error")


def setUp(init_db=True, **kwargs):
    # _turn_warnings_into_errors()

    from kotti import _resolve_dotted
    from kotti import conf_defaults

    tearDown()
    settings = conf_defaults.copy()
    settings['kotti.secret'] = 'secret'
    settings['kotti.secret2'] = 'secret2'
    settings['kotti.populators'] = 'kotti.testing._populator'
    settings.update(kwargs.get('settings', {}))
    _resolve_dotted(settings)
    kwargs['settings'] = settings
    config = testing.setUp(**kwargs)
    config.add_default_renderers()

    if init_db:
        _initTestingDB()

    transaction.begin()
    return config


def tearDown():
    from kotti import events
    from kotti import security
    from kotti.message import _inject_mailer

    # These should arguable use the configurator, so they don't need
    # to be torn down separately:
    events.clear()
    security.reset()

    _inject_mailer[:] = []
    transaction.abort()
    testing.tearDown()


class UnitTestBase(TestCase):
    def setUp(self, **kwargs):
        self.config = setUp(**kwargs)

    def tearDown(self):
        tearDown()


class EventTestBase(TestCase):
    def setUp(self, **kwargs):
        super(EventTestBase, self).setUp(**kwargs)
        self.config.include('kotti.events')

# Functional ----


def _functional_includeme(config):
    from kotti import DBSession

    def expire(event):
        DBSession.flush()
        DBSession.expire_all()

    config.add_subscriber(expire, NewResponse)


def _zope_testbrowser_pyquery(self):
    from pyquery import PyQuery
    return PyQuery(
        self.contents.replace('xmlns="http://www.w3.org/1999/xhtml', ''))


def setUpFunctional(global_config=None, **settings):
    from kotti import main
    import wsgi_intercept.zope_testbrowser
    from webtest import TestApp

    tearDown()

    _settings = {
        'sqlalchemy.url': testing_db_url(),
        'kotti.secret': 'secret',
        'kotti.site_title': 'Website des Kottbusser Tors',  # for mailing
        'kotti.populators': 'kotti.testing._populator',
        'mail.default_sender': 'kotti@localhost',
        'pyramid.includes': 'kotti.testing._functional_includeme',
        }
    _settings.update(settings)

    host, port = BASE_URL.split(':')[-2:]
    app = main({}, **_settings)
    wsgi_intercept.add_wsgi_intercept(host[2:], int(port), lambda: app)
    Browser = wsgi_intercept.zope_testbrowser.WSGI_Browser
    Browser.pyquery = property(_zope_testbrowser_pyquery)

    return dict(
        Browser=Browser,
        browser=Browser(),
        test_app=TestApp(app),
        )


class FunctionalTestBase(TestCase):
    BASE_URL = BASE_URL

    def setUp(self, **kwargs):
        self.__dict__.update(setUpFunctional(**kwargs))

    def tearDown(self):
        tearDown()

    def login(self, login=u'admin', password=u'secret'):
        return self.test_app.post(
            '/@@login',
            {'login': login, 'password': password, 'submit': 'submit'},
            status=302,
            )

    @deprecate('login_testbrowser is deprecated as of Kotti 0.7.  Please use '
            'the `browser` funcarg in conjunction with the `@user` decorator.')
    def login_testbrowser(self, login=u'admin', password=u'secret'):
        browser = self.Browser()
        browser.open(BASE_URL + '/edit')
        browser.getControl("Username or email").value = login
        browser.getControl("Password").value = password
        browser.getControl(name="submit").click()
        return browser


class TestingRootFactory(dict):
    __name__ = ''  # root is required to have an empty name!
    __parent__ = None
    __acl__ = [('Allow', 'role:admin', ALL_PERMISSIONS)]

    def __init__(self, request):
        super(TestingRootFactory, self).__init__()


def dummy_view(context, request):
    return {}


def include_testing_view(config):
    config.add_view(
        dummy_view,
        context=TestingRootFactory,
        renderer='kotti:tests/testing_view.pt',
        )

    config.add_view(
        dummy_view,
        name='secured',
        permission='view',
        context=TestingRootFactory,
        renderer='kotti:tests/testing_view.pt',
        )


def setUpFunctionalStrippedDownApp(global_config=None, **settings):
    # An app that doesn't use Nodes at all
    _settings = {
        'kotti.base_includes': (
            'kotti kotti.views kotti.views.login kotti.views.users'),
        'kotti.use_tables': 'principals',
        'kotti.populators': 'kotti.populate.populate_users',
        'pyramid.includes': 'kotti.testing.include_testing_view',
        'kotti.root_factory': 'kotti.testing.TestingRootFactory',
        'kotti.site_title': 'My Stripped Down Kotti',
        }
    _settings.update(settings)

    return setUpFunctional(global_config, **_settings)


def registerDummyMailer():
    from pyramid_mailer.mailer import DummyMailer
    from kotti.message import _inject_mailer

    mailer = DummyMailer()
    _inject_mailer.append(mailer)
    return mailer


# set up deprecation warnings
from zope.deprecation.deprecation import deprecated
for item in UnitTestBase, EventTestBase, FunctionalTestBase, _initTestingDB:
    name = getattr(item, '__name__', item)
    deprecated(name, 'Unittest-style tests are deprecated as of Kotti 0.7. '
        'Please use pytest function arguments instead.')

########NEW FILE########
__FILENAME__ = conftest
# non-public test fixtures

from pytest import fixture


@fixture
def app(db_session, setup_app):
    from webtest import TestApp
    return TestApp(setup_app)


@fixture
def extra_principals(db_session):
    from kotti.security import get_principals
    P = get_principals()
    P[u'bob'] = dict(name=u'bob', title=u"Bob")
    P[u'frank'] = dict(name=u'frank', title=u"Frank")
    P[u'group:bobsgroup'] = dict(name=u'group:bobsgroup', title=u"Bob's Group")
    P[u'group:franksgroup'] = dict(name=u'group:franksgroup',
        title=u"Frank's Group")

########NEW FILE########
__FILENAME__ = test_app
# -*- coding: utf-8 -*-

import warnings

from mock import patch, Mock
from pytest import raises

from pyramid.interfaces import IAuthenticationPolicy
from pyramid.interfaces import IAuthorizationPolicy
from pyramid.interfaces import IView
from pyramid.interfaces import IViewClassifier
from pyramid.request import Request
from pyramid.threadlocal import get_current_registry
from sqlalchemy import select
from zope.interface import implementedBy
from zope.interface import providedBy

from kotti.testing import TestingRootFactory
from kotti.testing import testing_db_url


# filter deprecation warnings for code that is still tested...
from warnings import filterwarnings
filterwarnings('ignore', "^The 'kotti.includes' setting")


class TestApp:

    def required_settings(self):
        return {'sqlalchemy.url': testing_db_url(),
                'kotti.secret': 'dude'}

    def test_override_settings(self, db_session):
        from kotti import main
        from kotti import get_settings

        class MyType(object):
            pass

        def my_configurator(conf):
            conf['kotti.base_includes'] = ''
            conf['kotti.available_types'] = [MyType]

        settings = self.required_settings()
        settings['kotti.configurators'] = [my_configurator]
        with patch('kotti.resources.initialize_sql'):
            main({}, **settings)

        assert get_settings()['kotti.base_includes'] == []
        assert get_settings()['kotti.available_types'] == [MyType]

    def test_auth_policies_no_override(self, db_session):
        from kotti import main

        settings = self.required_settings()
        with patch('kotti.resources.initialize_sql'):
            main({}, **settings)

        registry = get_current_registry()
        assert registry.queryUtility(IAuthenticationPolicy) is not None
        assert registry.queryUtility(IAuthorizationPolicy) is not None

    def test_auth_policies_override(self, db_session):
        from kotti import main

        settings = self.required_settings()
        settings['kotti.authn_policy_factory'] = 'kotti.none_factory'
        settings['kotti.authz_policy_factory'] = 'kotti.none_factory'
        with patch('kotti.resources.initialize_sql'):
            main({}, **settings)

        registry = get_current_registry()
        assert registry.queryUtility(IAuthenticationPolicy) is None
        assert registry.queryUtility(IAuthorizationPolicy) is None

    def test_asset_overrides(self, db_session):
        from kotti import main

        settings = self.required_settings()
        settings['kotti.asset_overrides'] = 'pyramid:scaffold/'
        with patch('kotti.resources.initialize_sql'):
            main({}, **settings)

    def test_kotti_static_deprecated(self, allwarnings):
        with warnings.catch_warnings(record=True) as w:
            from kotti.static import edit_needed
            edit_needed  # pyflakes
            assert len(w) == 1
            assert issubclass(w[-1].category, DeprecationWarning)
            msg = str(w[-1].message)
            assert "The module kotti.static has been moved to kotti.fanstatic as of Kotti" in msg

    def test_kotti_static_needed_deprecation_warning(self, db_session):
        from kotti import main

        settings = self.required_settings()
        settings['kotti.static.view_needed'] = (' kotti.fanstatic.view_needed')
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter('always')
            with patch('kotti.resources.initialize_sql'):
                main({}, **settings)
            assert len(w) == 1
            assert issubclass(w[-1].category, DeprecationWarning)
            msg = str(w[-1].message)
            assert "The 'kotti.static.view_needed' setting has been deprecated" in msg

    def test_kotti_static_needed_merged_to_kotti_fanstatic_needed(self, db_session):
        from kotti import main

        settings = self.required_settings()
        settings['kotti.static.needed'] = 'kotti.fanstatic.edit_needed'

        with patch('kotti.resources.initialize_sql'):
            app = main({}, **settings)

        groups = app.registry.settings['kotti.fanstatic.view_needed']
        resource_names = [[r.relpath for r in group.resources] for group in groups]
        resource_names = [name for names in resource_names for name in names]
        assert 'view.css' in resource_names

        settings = self.required_settings()
        settings['kotti.fanstatic.view_needed'] = 'kotti.fanstatic.view_needed'
        settings['kotti.static.view_needed'] = ' kotti.fanstatic.edit_needed'
        with warnings.catch_warnings(record=True):
            with patch('kotti.resources.initialize_sql'):
                app = main({}, **settings)
        regsettings = app.registry.settings

        assert len(regsettings['kotti.fanstatic.view_needed']) == 2

        with raises(KeyError):
            regsettings['kotti.static.view_needed']

        groups = regsettings['kotti.fanstatic.view_needed']
        resource_names = [[r.relpath for r in group.resources] for group in groups]
        resource_names = [name for names in resource_names for name in names]
        assert 'edit.css' in resource_names

    def test_kotti_includes_deprecation_warning(self, db_session):
        from kotti import main

        settings = self.required_settings()
        settings['kotti.includes'] = ('kotti.testing.includeme_layout')
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter('always')
            with patch('kotti.resources.initialize_sql'):
                main({}, **settings)
            assert len(w) == 1
            assert issubclass(w[-1].category, DeprecationWarning)
            msg = str(w[-1].message)
            assert "The 'kotti.includes' setting has been deprecated" in msg

    def test_kotti_includes_merged_to_pyramid_includes(self, db_session):
        from kotti import main

        settings = self.required_settings()
        settings['kotti.includes'] = ('kotti.testing.includeme_login')

        with patch('kotti.resources.initialize_sql'):
            app = main({}, **settings)
        assert (app.registry.settings['pyramid.includes'].strip() ==
                'kotti.testing.includeme_login')

        settings = self.required_settings()
        settings['pyramid.includes'] = ('kotti.testing.includeme_layout')
        settings['kotti.includes'] = ('kotti.testing.includeme_login')
        with patch('kotti.resources.initialize_sql'):
            app = main({}, **settings)
        regsettings = app.registry.settings
        assert len(regsettings['pyramid.includes'].split()) == 2
        assert settings['kotti.includes'] in regsettings['pyramid.includes']

    def test_pyramid_includes_overrides_base_includes(self, root):
        from kotti import main

        settings = self.required_settings()
        settings['pyramid.includes'] = ('kotti.testing.includeme_login')
        with patch('kotti.resources.initialize_sql'):
            app = main({}, **settings)

        provides = [
            IViewClassifier,
            implementedBy(Request),
            providedBy(root),
            ]
        view = app.registry.adapters.lookup(provides, IView, name='login')
        assert view.__module__ == 'kotti.testing'

    def test_use_tables(self, db_session):
        from kotti import main

        settings = self.required_settings()
        settings['kotti.populators'] = ''
        settings['kotti.use_tables'] = 'principals'
        with patch('kotti.resources.initialize_sql'):
            main({}, **settings)

    def test_root_factory(self, db_session):
        from kotti import main
        from kotti.resources import get_root    # the `root` fixture doesn't work here

        settings = self.required_settings()
        settings['kotti.root_factory'] = (TestingRootFactory,)
        with patch('kotti.resources.initialize_sql'):
            app = main({}, **settings)
        assert isinstance(get_root(), TestingRootFactory)
        assert isinstance(app.root_factory(), TestingRootFactory)

    def test_render_master_edit_template_minimal_root(self, settings=None):
        from kotti import main

        settings = settings or self.required_settings()
        settings['kotti.root_factory'] = (TestingRootFactory,)
        settings['kotti.site_title'] = 'My Site'
        with patch('kotti.resources.initialize_sql'):
            app = main({}, **settings)

        request = Request.blank('/@@login')
        (status, headers, response) = request.call_application(app)
        assert status == '200 OK'

    def test_render_master_view_template_minimal_root(self, db_session):
        settings = self.required_settings()
        settings['pyramid.includes'] = ('kotti.testing.includeme_layout')
        return self.test_render_master_edit_template_minimal_root(settings)

    def test_setting_values_as_unicode(self, db_session):
        from kotti import get_settings
        from kotti import main

        settings = self.required_settings()
        settings['kotti.site_title'] = 'K\xc3\xb6tti'  # Ktti
        settings['kotti_foo.site_title'] = 'K\xc3\xb6tti'
        settings['foo.site_title'] = 'K\xc3\xb6tti'

        with patch('kotti.resources.initialize_sql'):
            main({}, **settings)
        assert get_settings()['kotti.site_title'] == u'K\xf6tti'
        assert get_settings()['kotti_foo.site_title'] == u'K\xf6tti'
        assert get_settings()['foo.site_title'] == 'K\xc3\xb6tti'

    def test_search_content(self, db_session):
        from kotti import main
        from kotti.views.util import search_content

        settings = self.required_settings()
        settings['kotti.search_content'] = 'kotti.testing.dummy_search'
        with patch('kotti.resources.initialize_sql'):
            main({}, **settings)
        assert search_content(u"Nuno") == u"Not found. Sorry!"

    def test_stamp_heads(self, db_session, connection):
        from kotti import main

        settings = self.required_settings()
        engine = connection.engine
        engine.table_names = Mock(return_value=[])
        with patch('kotti.engine_from_config', return_value=engine):
            with patch('kotti.resources.metadata'):
                main({}, **settings)

        res = db_session.execute(select(
            columns=['version_num'], from_obj=['kotti_alembic_version']))
        assert tuple(res)  # a version_num should exist


class TestGetVersion:
    def test_it(self):
        from kotti import get_version
        assert isinstance(get_version(), str)

########NEW FILE########
__FILENAME__ = test_cache
import datetime

from mock import patch
from mock import MagicMock
import pytest

from kotti.testing import Dummy
from kotti.views.cache import set_max_age


class TestSetMaxAge:
    def test_preserve_existing_headers(self):
        response = Dummy(headers={
            "cache-control": "max-age=17,s-max-age=42,foo,bar=42"})
        delta = datetime.timedelta(days=1)
        set_max_age(response, delta)

        assert "cache-control" in response.headers
        assert response.headers["cache-control"] == (
            "bar=42,foo,max-age=86400,s-max-age=42")


class TestSetCacheHeaders:
    def test_caching_policy_chooser(self):
        from kotti.views.cache import set_cache_headers

        with patch('kotti.views.cache.caching_policy_chooser') as chooser:
            chooser.return_value = 'Random policy'

            event = MagicMock()
            event.response.headers.get.return_value = None

            with pytest.raises(KeyError):
                set_cache_headers(event)

        chooser.assert_called_with(
            event.request.context, event.request, event.response)

    def test_caching_policy_chooser_raises(self):
        from kotti.views.cache import set_cache_headers

        def raiser(*args, **kw):
            raise Exception()

        with patch('kotti.views.cache.caching_policy_chooser') as chooser:
            chooser.side_effect = raiser

            event = MagicMock()
            event.response.headers.get.return_value = None

            with patch('kotti.views.cache.logger'):
                set_cache_headers(event)

        chooser.assert_called_with(
            event.request.context, event.request, event.response)

    def test_header_set_before(self):
        from kotti.views.cache import CACHE_POLICY_HEADER
        from kotti.views.cache import set_cache_headers

        event = MagicMock()
        event.response.headers = {CACHE_POLICY_HEADER: 'Random policy'}

        with patch('kotti.views.cache.caching_policy_chooser') as chooser:
            with pytest.raises(KeyError):
                set_cache_headers(event)

        assert chooser.call_count == 0

########NEW FILE########
__FILENAME__ = test_default_view_selection
# -*- coding: utf-8 -*-
import warnings

from pyramid.httpexceptions import HTTPFound

from kotti.interfaces import IContent
from kotti.testing import DummyRequest
from kotti.views.edit.default_views import DefaultViewSelection


class TestDefaultViewSelection:

    def test__is_valid_view(self, root, config):

        config.add_view(
            context=IContent,
            name='folder_view',
            permission='view',
            renderer='kotti:templates/view/folder.pt',
        )

        context = root
        request = DummyRequest()

        view = DefaultViewSelection(context, request)

        assert view._is_valid_view("folder_view") is True
        assert view._is_valid_view("foo") is False

    def test_default_views(self, root, config):
        config.add_view(
            context=IContent,
            name='folder_view',
            permission='view',
            renderer='kotti:templates/view/folder.pt',
            )

        context = root
        request = DummyRequest()

        view = DefaultViewSelection(context, request)

        sviews = view.default_view_selector()

        assert 'selectable_default_views' in sviews

        # the root should have at least the default view and the folder_view
        assert len(sviews['selectable_default_views']) > 1

        # the first view is always the default view
        assert sviews['selectable_default_views'][0]['is_current'] is True
        assert sviews['selectable_default_views'][0]['name'] == 'default'
        assert sviews['selectable_default_views'][0]['title'] == 'Default view'

        assert sviews['selectable_default_views'][1]['is_current'] is False

        # set the default view to folder_view view
        request = DummyRequest(GET={'view_name': 'folder_view'})
        view = DefaultViewSelection(context, request)

        assert type(view.set_default_view()) == HTTPFound
        assert context.default_view == 'folder_view'

        # set back to default
        request = DummyRequest(GET={'view_name': 'default'})
        view = DefaultViewSelection(context, request)

        assert type(view.set_default_view()) == HTTPFound
        assert context.default_view is None

        # try to set non existing view
        request = DummyRequest(GET={'view_name': 'nonexisting'})
        view = DefaultViewSelection(context, request)

        assert type(view.set_default_view()) == HTTPFound
        assert context.default_view is None

    def test_warning_for_non_registered_views(self, root):

        with warnings.catch_warnings(record=True) as w:

            DefaultViewSelection(root, DummyRequest()).default_view_selector()

            assert len(w) == 1
            assert issubclass(w[-1].category, UserWarning)
            assert str(w[-1].message) == "No view called 'folder_view' is registered for <Document 1 at />."

########NEW FILE########
__FILENAME__ = test_deprecated
# -*- coding: utf-8 -*-

import warnings


def assert_deprecations(w, *msgs):

    assert len(w) == len(msgs)

    for i in range(len(w)):
        assert issubclass(w[i].category, DeprecationWarning)
        assert msgs[i] in str(w[i].message)


class TestDeprecated09:

    def test_render_tree_navigation_moved(self, allwarnings):
        with warnings.catch_warnings(record=True) as w:

            from kotti.views.edit.actions import render_tree_navigation
            render_tree_navigation  # pyflakes

            assert_deprecations(
                w, "has been moved to kotti.views.navigation as of Kotti 0.9")

    def test_local_navigation_moved(self, allwarnings):
        with warnings.catch_warnings(record=True) as w:

            from kotti.views.slots import includeme_local_navigation
            from kotti.views.slots import local_navigation
            includeme_local_navigation  # pyflakes
            local_navigation  # pyflakes

            assert_deprecations(
                w, "deprecated as of Kotti 0.9", "deprecated as of Kotti 0.9")

########NEW FILE########
__FILENAME__ = test_events
import warnings

from mock import patch


class DummyVenusian(object):
    def __init__(self):
        self.attached = []

    def attach(self, wrapped, fn, category=None):
        self.attached.append((wrapped, fn, category))


class TestEvents:
    def test_owner(self, root, db_session, events, dummy_request):
        from kotti.resources import Content
        from kotti.security import list_groups
        from kotti.security import list_groups_raw
        from kotti.util import clear_cache

        with patch('kotti.events.authenticated_userid', return_value='bob'):
            child = root[u'child'] = Content()
            db_session.flush()
        assert child.owner == u'bob'
        assert list_groups(u'bob', child) == [u'role:owner']

        clear_cache()
        # The event listener does not set the role again for subitems:
        with patch('kotti.events.authenticated_userid', return_value='bob'):
            grandchild = child[u'grandchild'] = Content()
            db_session.flush()
        assert grandchild.owner == u'bob'
        assert list_groups(u'bob', grandchild) == [u'role:owner']
        assert len(list_groups_raw(u'bob', grandchild)) == 0

    def test_sqlalchemy_events(self, root, db_session, events):
        from kotti import events
        from kotti.resources import Content

        insert_events = []

        def insert(event):
            insert_events.append(event)

        update_events = []

        def update(event):
            update_events.append(event)

        delete_events = []

        def delete(event):
            delete_events.append(event)

        after_delete_events = []

        def after_delete(event):
            after_delete_events.append(event)

        def lengths():
            return (len(insert_events), len(update_events),
                    len(delete_events), len(after_delete_events))

        lis = events.objectevent_listeners
        lis[(events.ObjectInsert, None)].append(insert)
        lis[(events.ObjectUpdate, None)].append(update)
        lis[(events.ObjectDelete, None)].append(delete)
        with warnings.catch_warnings(record=True):
            lis[(events.ObjectAfterDelete, None)].append(after_delete)

        child = root[u'child'] = Content()
        db_session.flush()
        assert lengths() == (1, 0, 0, 0)
        assert insert_events[0].object == child

        child.title = u"Bar"
        db_session.flush()
        assert lengths() == (1, 1, 0, 0)
        assert update_events[0].object == child

        db_session.delete(child)
        db_session.flush()
        assert lengths() == (1, 1, 1, 1)
        assert delete_events[0].object == child
        assert after_delete_events[0].object == child

    def test_subscribe(self, root, db_session):

        from kotti.events import ObjectEvent
        from kotti.events import clear
        from kotti.events import listeners
        from kotti.events import objectevent_listeners
        from kotti.events import subscribe
        from kotti.resources import Document

        def handler(event):
            pass

        dec = subscribe()
        dec.venusian = DummyVenusian()
        decorated = dec(handler)
        dec.register(None, None, handler)
        assert dec.evttype is object
        assert dec.objtype is None
        assert decorated == handler
        assert (handler, dec.register, 'kotti') in dec.venusian.attached
        assert handler in listeners[object]
        assert handler not in objectevent_listeners[object]

        clear()

        dec = subscribe(ObjectEvent)
        dec.venusian = DummyVenusian()
        decorated = dec(handler)
        dec.register(None, None, handler)
        assert dec.evttype is ObjectEvent
        assert dec.objtype is None
        assert decorated == handler
        assert (handler, dec.register, 'kotti') in dec.venusian.attached
        assert handler not in listeners[ObjectEvent]
        assert handler in objectevent_listeners[(ObjectEvent, None)]

        clear()

        dec = subscribe(ObjectEvent, Document)
        dec.venusian = DummyVenusian()
        decorated = dec(handler)
        dec.register(None, None, handler)
        assert dec.evttype is ObjectEvent
        assert dec.objtype is Document
        assert decorated == handler
        assert (handler, dec.register, 'kotti') in dec.venusian.attached
        assert handler not in listeners[ObjectEvent]
        assert handler in objectevent_listeners[(ObjectEvent, Document)]

########NEW FILE########
__FILENAME__ = test_file
from StringIO import StringIO

from colander import null
from mock import MagicMock

from kotti.testing import DummyRequest


class TestFileViews:
    def setup_method(self, method):
        from kotti.resources import File
        self.file = File("file contents", u"myf\xfcle.png", u"image/png")

    def _test_common_headers(self, headers):
        for name in ('Content-Disposition', 'Content-Length', 'Content-Type'):
            assert type(headers[name]) == str
        assert headers["Content-Length"] == "13"
        assert headers["Content-Type"] == "image/png"

    def test_inline_view(self):
        from kotti.views.file import inline_view
        res = inline_view(self.file, None)
        headers = res.headers

        self._test_common_headers(headers)
        assert headers["Content-Disposition"] == 'inline;filename="myfle.png"'
        assert res.body == 'file contents'

    def test_attachment_view(self):
        from kotti.views.file import attachment_view
        res = attachment_view(self.file, None)
        headers = res.headers

        self._test_common_headers(headers)
        assert headers["Content-Disposition"] == (
            'attachment;filename="myfle.png"')
        assert res.body == 'file contents'


class TestFileEditForm:
    def make_one(self):
        from kotti.views.edit.content import FileEditForm
        return FileEditForm(MagicMock(), DummyRequest())

    def test_edit_with_file(self):
        view = self.make_one()
        view.edit(
            title=u'A title', description=u'A description',
            tags=[u"A tag"],
            file=dict(
                fp=StringIO('filecontents'),
                filename=u'myfile.png',
                mimetype=u'image/png',
                ),
            )
        assert view.context.title == u'A title'
        assert view.context.description == u'A description'
        assert view.context.data == 'filecontents'
        assert view.context.filename == u'myfile.png'
        assert view.context.mimetype == u'image/png'
        assert view.context.size == len('filecontents')
        assert view.context.tags == [u"A tag"]

    def test_edit_without_file(self):
        view = self.make_one()
        view.context.data = 'filecontents'
        view.context.filename = u'myfile.png'
        view.context.mimetype = u'image/png'
        view.context.size = 777
        view.edit(title=u'A title',
                  description=u'A description',
                  tags=[],
                  file=null)
        assert view.context.title == u'A title'
        assert view.context.description == u'A description'
        assert view.context.data == 'filecontents'
        assert view.context.filename == u'myfile.png'
        assert view.context.mimetype == u'image/png'
        assert view.context.size == 777


class TestFileAddForm:
    def make_one(self):
        from kotti.views.edit.content import FileAddForm
        return FileAddForm(MagicMock(), DummyRequest())

    def test_add(self):
        view = self.make_one()
        file = view.add(
            title=u'A title',
            description=u'A description',
            tags=[],
            file=dict(
                fp=StringIO('filecontents'),
                filename=u'myfile.png',
                mimetype=u'image/png',
                ),
            )

        assert file.title == u'A title'
        assert file.description == u'A description'
        assert file.tags == []
        assert file.data == 'filecontents'
        assert file.filename == u'myfile.png'
        assert file.mimetype == u'image/png'
        assert file.size == len('filecontents')


class TestFileUploadTempStore:
    def make_one(self):
        from kotti.views.form import FileUploadTempStore
        return FileUploadTempStore(DummyRequest())

    def test_keys(self):
        tmpstore = self.make_one()
        tmpstore.session['important'] = 3
        tmpstore.session['_secret'] = 4
        assert tmpstore.keys() == ['important']

    def test_delitem(self):
        tmpstore = self.make_one()
        tmpstore.session['important'] = 3
        del tmpstore['important']
        assert 'important' not in tmpstore.session

########NEW FILE########
__FILENAME__ = test_functional
from StringIO import StringIO
from mock import patch

from kotti.testing import BASE_URL
from kotti.testing import user


class TestLogin:
    def test_it(self, app):
        res = app.post('/@@login', dict(login='admin',
                password='secret', submit='submit'))
        assert res.status == '302 Found'
        res = res.follow()
        assert res.status == '200 OK'


class TestForbidden:
    def test_forbidden(self, app):
        app.get('/@@edit', headers={'Accept': '*/json'}, status=403)

    def test_forbidden_redirect(self, app):
        res = app.get('/@@edit', headers={'Accept': 'text/html'}, status=302)
        assert res.location.startswith('http://localhost/@@login?came_from=')

    def test_forbidden_redirect_when_authenticated(self, app):
        with patch('kotti.views.login.authenticated_userid', return_value='foo'):
            res = app.get('/@@edit', status=302)
        assert res.location == 'http://localhost/@@forbidden'


class TestUploadFile:

    def add_file(self, browser, contents='ABC'):
        file_ctrl = browser.getControl("File").mech_control
        file_ctrl.add_file(StringIO(contents), filename='my_image.gif')
        browser.getControl('save').click()

    @user('admin')
    def test_it(self, browser):
        browser.open(BASE_URL + '/@@add_file')
        self.add_file(browser)
        assert "Item was added" in browser.contents

    @user('admin')
    def test_view_uploaded_file(self, browser):
        browser.open(BASE_URL + '/@@add_file')
        self.add_file(browser)
        browser.getLink("View").click()
        browser.getLink("Download file").click()
        assert browser.contents == 'ABC'

    @user('admin')
    def test_tempstorage(self, browser):
        browser.open(BASE_URL + '/@@add_file')
        self.add_file(browser, contents='DEF')
        browser.getLink("Edit").click()
        browser.getControl("Title").value = ''  # the error
        assert "Your changes have been saved" not in browser.contents
        browser.getControl("Title").value = 'A title'
        browser.getControl('save').click()
        assert "Your changes have been saved" in browser.contents
        browser.getLink("View").click()
        browser.getLink("Download file").click()
        assert browser.contents == 'DEF'

    @user('admin')
    def test_edit_uploaded_file(self, browser):
        browser.open(BASE_URL + '/@@add_file')
        self.add_file(browser, contents='GHI')
        browser.getLink("Edit").click()
        browser.getControl('save').click()
        browser.getLink("Download file").click()
        assert browser.contents == 'GHI'

########NEW FILE########
__FILENAME__ = test_image


class TestImageScaleLoading:

    def test_it(self):

        from kotti.views.image import _load_image_scales, image_scales

        assert "daumennagel" not in image_scales

        _load_image_scales({"kotti.image_scales.daumennagel": "100x100"})

        assert image_scales["daumennagel"] == [100, 100]

########NEW FILE########
__FILENAME__ = test_message
from mock import patch

from kotti.testing import Dummy
from kotti.testing import DummyRequest


# filter deprecation warnings for code that is still tested...
from warnings import filterwarnings
filterwarnings('ignore', '^send_set_password is deprecated')


class TestSendEmail:
    def setup_method(self, method):
        get_mailer_patcher = patch('kotti.message.get_mailer')
        get_mailer = get_mailer_patcher.start()
        self.mailer = get_mailer.return_value

        self.patchers = (get_mailer_patcher, )

    def teardown_method(self, method):
        for patcher in self.patchers:
            patcher.stop()

    def test_send_email(self, dummy_request):
        from kotti.message import send_email

        send_email(dummy_request,
                   [u'"John Doe" <joedoe@foo.com>'],
                   'kotti:templates/email-reset-password.pt',
                   {'site_title': u'My site',
                    'user_title': u'John Doe',
                    'url': u'http://foo.com'}
                   )

        assert self.mailer.send.called
        message = self.mailer.send.call_args[0][0]
        assert [u'"John Doe" <joedoe@foo.com>'] == message.recipients
        assert 'Reset your password' in message.subject


class TestSendSetPassword:
    def setup_method(self, method):
        get_settings_patcher = patch('kotti.message.get_settings')
        self.get_settings = get_settings_patcher.start()
        self.get_settings.return_value = {
            'kotti.site_title': 'Awesome site',
            'kotti.secret2': '123',
            }

        get_mailer_patcher = patch('kotti.message.get_mailer')
        get_mailer = get_mailer_patcher.start()
        self.mailer = get_mailer.return_value

        self.patchers = (get_settings_patcher, get_mailer_patcher)

    def teardown_method(self, method):
        for patcher in self.patchers:
            patcher.stop()

    def test_email_set_password_basic(self, db_session):
        from kotti.message import email_set_password

        user = Dummy(name=u'joe', email='joe@bar.com', title=u'Joe')
        email_set_password(user, DummyRequest())

        assert hasattr(user, 'confirm_token')
        assert self.mailer.send.called
        message = self.mailer.send.call_args[0][0]
        assert 'Your registration' in message.subject
        assert 'Joe' in message.body
        assert 'Awesome site' in message.body

    def test_send_set_password_other_template(self):
        from kotti.message import send_set_password

        user = Dummy(name=u'joe', email='joe@bar.com', title=u'Joe')
        send_set_password(user, DummyRequest(), templates='reset-password')

        assert self.mailer.send.called
        message = self.mailer.send.call_args[0][0]
        assert 'Reset your password' in message.subject

    def test_send_set_password_other_template_entirely(self):
        from kotti.message import send_set_password

        user = Dummy(name=u'joe', email='joe@bar.com', title=u'Joe')
        send_set_password(user, DummyRequest(), templates=dict(
            subject=u"Hey there %(user_title)s",
            body=u"This is %(site_title)s speaking",
            ))

        assert self.mailer.send.called
        message = self.mailer.send.call_args[0][0]
        assert message.subject == 'Hey there Joe'
        assert message.body == 'This is Awesome site speaking'

    def test_email_set_password_add_query(self, db_session):
        from kotti.message import email_set_password

        user = Dummy(name=u'joe', email='joe@bar.com', title=u'Joe')
        email_set_password(
            user, DummyRequest(), add_query={'another': 'param'})

        assert self.mailer.send.called
        message = self.mailer.send.call_args[0][0]
        assert 'another=param' in message.body

    def test_send_set_password_add_query(self):
        from kotti.message import send_set_password

        user = Dummy(name=u'joe', email='joe@bar.com', title=u'Joe')
        send_set_password(user, DummyRequest(), add_query={'another': 'param'})

        assert self.mailer.send.called
        message = self.mailer.send.call_args[0][0]
        assert 'another=param' in message.body


class TestEmailSetPassword:
    def setup_method(self, method):
        get_settings_patcher = patch('kotti.message.get_settings')
        self.get_settings = get_settings_patcher.start()
        self.get_settings.return_value = {
            'kotti.site_title': 'Awesome site',
            'kotti.secret2': '123',
            }

        get_mailer_patcher = patch('kotti.message.get_mailer')
        get_mailer = get_mailer_patcher.start()
        self.mailer = get_mailer.return_value

        self.patchers = (get_settings_patcher, get_mailer_patcher)

    def teardown_method(self, method):
        for patcher in self.patchers:
            patcher.stop()

    def test_email_set_password_basic(self, db_session):
        from kotti.message import email_set_password

        user = Dummy(name=u'joe', email='joe@bar.com', title=u'Joe')
        email_set_password(user, DummyRequest())

        assert hasattr(user, 'confirm_token')
        assert self.mailer.send.called
        message = self.mailer.send.call_args[0][0]
        assert message.subject.startswith('Your registration')
        assert 'Joe' in message.body
        assert 'Joe' in message.html
        assert '<p' not in message.body
        assert '<p' in message.html
        assert 'Awesome site' in message.body

    def test_email_set_password_other_template(self, db_session):
        from kotti.message import email_set_password

        user = Dummy(name=u'joe', email='joe@bar.com', title=u'Joe')
        email_set_password(
            user, DummyRequest(),
            template_name='kotti:templates/email-reset-password.pt')

        assert self.mailer.send.called
        message = self.mailer.send.call_args[0][0]
        assert message.subject.startswith('Reset your password')

    def test_email_set_password_add_query(self, db_session):
        from kotti.message import email_set_password

        user = Dummy(name=u'joe', email='joe@bar.com', title=u'Joe')
        email_set_password(
            user, DummyRequest(), add_query={'another': 'param'})

        assert self.mailer.send.called
        message = self.mailer.send.call_args[0][0]
        assert 'another=param' in message.body

########NEW FILE########
__FILENAME__ = test_migrate
from alembic.migration import MigrationContext
from mock import patch


class TestScriptDirectoryWithDefaultEnvPy:
    def make(self):
        from kotti.migrate import ScriptDirectoryWithDefaultEnvPy
        from kotti.migrate import KOTTI_SCRIPT_DIR

        return ScriptDirectoryWithDefaultEnvPy(KOTTI_SCRIPT_DIR)

    def test_env_py_location(self):
        scripts = self.make()
        assert scripts.env_py_location.endswith('kotti/alembic/env.py')

    def test_env_py_location_default(self):
        # We allow add-ons to use Kotti's version of 'env.py' if they
        # don't come with their own.
        scripts = self.make()
        with patch('kotti.migrate.os.path.exists') as exists:
            exists.return_value = False
            assert scripts.env_py_location.endswith('kotti/alembic/env.py')

    def test_run_env(self):
        with patch('kotti.migrate.load_python_file') as lpf:
            self.make().run_env()
            assert lpf.call_count == 1
            assert lpf.call_args[0][0].endswith('kotti/alembic')
            assert lpf.call_args[0][1] == 'env.py'


class TestPackageEnvironment:
    def make(self):
        from kotti.migrate import PackageEnvironment
        from kotti.migrate import DEFAULT_LOCATION

        with patch('kotti.migrate.get_settings',
            return_value={'sqlalchemy.url': u'database_url'}):
            return PackageEnvironment(DEFAULT_LOCATION)

    def test_pkg_name(self, db_session, events):
        assert self.make().pkg_name == 'kotti'

    def test_version_table(self):
        assert self.make().version_table == 'kotti_alembic_version'

    def test_run_env(self):
        pkg_env = self.make()
        called = []

        def func(rev, context):
            # assert rev is None  # XXX
            assert isinstance(context, MigrationContext)
            assert context.script == pkg_env.script_dir
            called.append((rev, context))
            return []

        pkg_env.run_env(func)
        assert called

########NEW FILE########
__FILENAME__ = test_node
from warnings import catch_warnings

from pytest import raises
from pyramid.security import ALL_PERMISSIONS
from pyramid.security import Allow
from sqlalchemy.exc import IntegrityError
from sqlalchemy.exc import SQLAlchemyError


class TestNode:
    def test_root_acl(self, db_session, root):

        # The root object has a persistent ACL set:
        assert (
            root.__acl__[1:] == [
                ('Allow', 'role:owner', u'view'),
                ('Allow', 'role:owner', u'add'),
                ('Allow', 'role:owner', u'edit'),
                ('Allow', 'role:owner', u'delete'),
                ('Allow', 'role:owner', u'manage'),
                ('Allow', 'role:owner', u'state_change'),
                ('Allow', 'role:viewer', u'view'),
                ('Allow', 'role:editor', u'view'),
                ('Allow', 'role:editor', u'add'),
                ('Allow', 'role:editor', u'edit'),
                ('Allow', 'role:editor', u'delete'),
                ('Allow', 'role:editor', u'state_change'),
                ('Allow', 'system.Everyone', u'view'),
                ('Deny', 'system.Everyone', ALL_PERMISSIONS),
            ])

        # The first ACE is here to prevent lock-out:
        assert (
            root.__acl__[0] ==
            (Allow, 'role:admin', ALL_PERMISSIONS))

    def test_set_and_get_acl(self, db_session, root):

        # The __acl__ attribute of Nodes allows access to the mapped
        # '_acl' property:
        del root.__acl__
        with raises(AttributeError):
            root._get_acl()

        root.__acl__ = [('Allow', 'system.Authenticated', ['edit'])]
        assert (
            root.__acl__ == [('Allow', 'system.Authenticated', ['edit'])])

        root.__acl__ = [
            ('Allow', 'system.Authenticated', ['view']),
            ('Deny', 'system.Authenticated', ALL_PERMISSIONS),
            ]

        assert (
            root.__acl__ == [
                ('Allow', 'system.Authenticated', ['view']),
                ('Deny', 'system.Authenticated', ALL_PERMISSIONS),
                ])

        # We can append to the ACL, and it'll be persisted fine:
        root.__acl__.append(('Allow', 'system.Authenticated', ['edit']))
        assert (
            root.__acl__ == [
                ('Allow', 'system.Authenticated', ['view']),
                ('Deny', 'system.Authenticated', ALL_PERMISSIONS),
                ('Allow', 'system.Authenticated', ['edit']),
                ])

        db_session.flush()
        db_session.expire_all()

        assert (
            root.__acl__ == [
                ('Allow', 'role:admin', ALL_PERMISSIONS),
                ('Allow', 'system.Authenticated', ['view']),
                ('Deny', 'system.Authenticated', ALL_PERMISSIONS),
                ('Allow', 'system.Authenticated', ['edit']),
                ])

    def test_append_to_empty_acl(self, db_session, root):
        from kotti.resources import Node

        node = root['child'] = Node()
        node.__acl__ = []

        db_session.flush()
        db_session.expire_all()

        node.__acl__.append(('Allow', 'system.Authenticated', ['edit']))
        db_session.flush()
        db_session.expire_all()

        assert node.__acl__ == [
            ('Allow', 'role:admin', ALL_PERMISSIONS),
            ('Allow', 'system.Authenticated', ['edit']),
            ]

    def test_unique_constraint(self, db_session, root):
        from kotti.resources import Node

        # Try to add two children with the same name to the root node:
        db_session.add(Node(name=u'child1', parent=root))
        db_session.add(Node(name=u'child1', parent=root))
        with raises(IntegrityError):
            db_session.flush()

    def test_container_methods(self, db_session, root):
        from kotti.resources import Node

        # Test some of Node's container methods:
        assert root.keys() == []

        child1 = Node(name=u'child1', parent=root)
        db_session.add(child1)
        assert root.keys() == [u'child1']
        assert root[u'child1'] == child1

        del root[u'child1']
        assert root.keys() == []

        # When we delete a parent node, all its child nodes will be
        # released as well:
        root[u'child2'] = Node()
        root[u'child2'][u'subchild'] = Node()
        assert (
            db_session.query(Node).filter(
                Node.name == u'subchild').count() == 1)
        del root[u'child2']
        assert (
            db_session.query(Node).filter(
                Node.name == u'subchild').count() == 0)

        # We can pass a tuple as the key to more efficiently reach
        # down to child objects:
        root[u'child3'] = Node()
        subchild33 = Node(name=u'subchild33', parent=root[u'child3'])
        db_session.add(subchild33)
        del root.__dict__['_children']  # force a different code path
        assert root[u'child3', u'subchild33'] is root[u'child3'][u'subchild33']
        assert root[(u'child3', u'subchild33')] is subchild33
        assert root[(u'child3', u'subchild33')] is subchild33
        with raises(KeyError):
            root[u'child3', u'bad-name']
        root.children  # force a different code path
        with raises(KeyError):
            root[u'child3', u'bad-name']
        del root[u'child3']

        # Overwriting an existing Node is an error; first delete manually!
        child4 = Node(name=u'child4', parent=root)
        db_session.add(child4)
        assert root.keys() == [u'child4']

        child44 = Node(name=u'child4')
        db_session.add(child44)
        root[u'child4'] = child44
        with raises(SQLAlchemyError):
            db_session.flush()

    def test_node_copy_name(self, db_session, root):

        copy_of_root = root.copy(name=u'copy_of_root')
        assert copy_of_root.name == u'copy_of_root'
        assert root.name == u''

    def test_node_copy_variants(self, db_session, root):
        from kotti.resources import Node

        child1 = root['child1'] = Node()
        child1['grandchild'] = Node()
        child2 = root['child2'] = Node()

        # first way; circumventing the Container API
        child2.children.append(child1.copy())

        # second way; canonical way
        child2['child2'] = child1.copy()

        # third way; this is necessary in cases when copy() will
        # attempt to put the new node into the db already, e.g. when
        # the copy is already being back-referenced by some other
        # object in the db.
        child1.copy(parent=child2, name=u'child3')

        assert [child.name for child in child2.children] == [
            'child1', 'child2', 'child3']

    def test_node_copy_parent_id(self, db_session, root):
        from kotti.resources import Node

        child1 = root['child1'] = Node()
        grandchild1 = child1['grandchild1'] = Node()
        db_session.flush()
        grandchild2 = grandchild1.copy()
        assert grandchild2.parent_id is None
        assert grandchild2.parent is None

    def test_node_copy_with_local_groups(self, db_session, root):
        from kotti.resources import Node
        from kotti.resources import LocalGroup

        child1 = root['child1'] = Node()
        local_group1 = LocalGroup(child1, u'joe', u'role:admin')
        db_session.add(local_group1)
        db_session.flush()

        child2 = root['child2'] = child1.copy()
        db_session.flush()
        assert child2.local_groups == []

    def test_clear(self, db_session, root):
        from kotti.resources import Node

        child = root['child'] = Node()
        assert db_session.query(Node).filter(Node.name == u'child').all() == [
            child]
        root.clear()
        assert db_session.query(Node).filter(Node.name == u'child').all() == []

    def test_annotations_mutable(self, db_session, root):

        root.annotations['foo'] = u'bar'
        assert root in db_session.dirty
        del root.annotations['foo']

    def test_nested_annotations_mutable(self, db_session, root):

        root.annotations['foo'] = {}
        db_session.flush()
        db_session.expire_all()

        root.annotations['foo']['bar'] = u'baz'
        assert root in db_session.dirty
        db_session.flush()
        db_session.expire_all()

        assert root.annotations['foo']['bar'] == u'baz'

    def test_annotations_coerce_fail(self, db_session, root):

        with raises(ValueError):
            root.annotations = []


class TestLocalGroup:
    def test_copy(self, db_session, root):
        from kotti.resources import LocalGroup

        node, principal_name, group_name = root, 'p', 'g'
        lg = LocalGroup(node, principal_name, group_name)
        lg2 = lg.copy()
        assert lg2 is not lg
        assert lg.node is lg2.node
        assert lg.principal_name == lg2.principal_name
        assert lg.group_name == lg2.group_name


class TestTypeInfo:
    def test_add_selectable_default_view(self):
        from kotti.resources import TypeInfo

        type_info = TypeInfo(selectable_default_views=[])
        type_info.add_selectable_default_view('foo', u'Fannick')
        assert type_info.selectable_default_views == [
            ('foo', u'Fannick'),
            ]

    def test_action_links_deprecated(self, allwarnings):
        from kotti.resources import TypeInfo
        from kotti.util import LinkParent

        my_item = object()
        with catch_warnings(record=True) as wngs:
            # If there's a last LinkParent item, we'll assume that is
            # the action menu.
            TypeInfo(
                edit_links=[LinkParent('foo', [])],
                action_links=[my_item],
                )
            assert wngs[0].category == DeprecationWarning

        with raises(ValueError):
            # If there's no last LinkParent item, we'll raise an
            # error, since we can't do anything useful with the link.
            TypeInfo(
                edit_links=[],
                action_links=[my_item],
                )

########NEW FILE########
__FILENAME__ = test_node_views
from webob.multidict import MultiDict
from pytest import raises
from pyramid.exceptions import Forbidden

from kotti.testing import DummyRequest


class TestAddableTypes:
    def test_view_permitted_yes(self, config, root):
        from kotti.resources import Document

        config.testing_securitypolicy(permissive=True)
        config.include('kotti.views.edit.content')
        request = DummyRequest()
        assert Document.type_info.addable(root, request) is True

    def test_view_permitted_no(self, config, root):
        from kotti.resources import Document

        config.testing_securitypolicy(permissive=False)
        config.include('kotti.views.edit.content')
        request = DummyRequest()
        assert Document.type_info.addable(root, request) is False


class TestNodePaste:
    def test_get_non_existing_paste_item(self, root):
        from kotti.views.edit import get_paste_items

        request = DummyRequest()
        request.session['kotti.paste'] = ([1701], 'copy')
        item = get_paste_items(root, request)
        assert item == []

    def test_paste_non_existing_node(self, root):
        from kotti.views.edit.actions import NodeActions

        request = DummyRequest()

        for index, action in enumerate(['copy', 'cut']):
            request.session['kotti.paste'] = ([1701], 'copy')
            response = NodeActions(root, request).paste_nodes()
            assert response.status == '302 Found'
            assert len(request.session['_f_error']) == index + 1

    def test_paste_without_edit_permission(self, config, root):
        from kotti.views.edit.actions import NodeActions

        request = DummyRequest()
        request.params['paste'] = u'on'
        config.testing_securitypolicy(permissive=False)

        # We need to have the 'edit' permission on the original object
        # to be able to cut and paste:
        request.session['kotti.paste'] = ([1], 'cut')
        view = NodeActions(root, request)
        with raises(Forbidden):
            view.paste_nodes()

        # We don't need 'edit' permission if we're just copying:
        request.session['kotti.paste'] = ([1], 'copy')
        response = NodeActions(root, request).paste_nodes()
        assert response.status == '302 Found'


class TestNodeRename:
    def setUp(self):
        from pyramid.threadlocal import get_current_registry
        from kotti.url_normalizer import url_normalizer
        r = get_current_registry()
        settings = r.settings = {}
        settings['kotti.url_normalizer'] = [url_normalizer]
        settings['kotti.url_normalizer.map_non_ascii_characters'] = False

    def test_rename_to_empty_name(self, root):
        from kotti.resources import Document
        from kotti.views.edit.actions import NodeActions

        child = root['child'] = Document(title=u"Child")
        request = DummyRequest()
        request.params['rename'] = u'on'
        request.params['name'] = u''
        request.params['title'] = u'foo'
        NodeActions(child, request).rename_node()
        assert (request.session.pop_flash('error') ==
            [u'Name and title are required.'])

    def test_multi_rename(self, root):
        from kotti.resources import Document
        from kotti.views.edit.actions import NodeActions
        self.setUp()
        root['child1'] = Document(title=u"Child 1")
        root['child2'] = Document(title=u"Child 2")
        request = DummyRequest()
        request.POST = MultiDict()
        id1 = str(root['child1'].id)
        id2 = str(root['child2'].id)
        request.POST.add('children-to-rename', id1)
        request.POST.add('children-to-rename', id2)
        request.POST.add(id1 + '-name', u'')
        request.POST.add(id1 + '-title', u'Unhappy Child')
        request.POST.add(id2 + '-name', u'happy-child')
        request.POST.add(id2 + '-title', u'')
        request.POST.add('rename_nodes', u'rename_nodes')
        NodeActions(root, request).rename_nodes()
        assert request.session.pop_flash('error') ==\
            [u'Name and title are required.']

        request.POST.add(id1 + '-name', u'unhappy-child')
        request.POST.add(id1 + '-title', u'Unhappy Child')
        request.POST.add(id2 + '-name', u'happy-child')
        request.POST.add(id2 + '-title', u'Happy Child')
        request.POST.add('rename_nodes', u'rename_nodes')
        NodeActions(root, request).rename_nodes()
        assert request.session.pop_flash('success') ==\
            [u'Your changes have been saved.']


class TestNodeDelete:

    def test_multi_delete(self, root):
        from kotti.resources import Document
        from kotti.resources import File
        from kotti.views.edit.actions import NodeActions

        root['child1'] = Document(title=u"Child 1")
        root['child2'] = Document(title=u"Child 2")
        root['file1'] = File(title=u"File 1")

        request = DummyRequest()
        request.POST = MultiDict()
        id1 = str(root['child1'].id)
        id2 = str(root['child2'].id)
        id3 = str(root['file1'].id)
        request.POST.add('delete_nodes', u'delete_nodes')
        NodeActions(root, request).delete_nodes()
        assert request.session.pop_flash('info') ==\
            [u'Nothing was deleted.']

        request.POST.add('children-to-delete', id1)
        request.POST.add('children-to-delete', id2)
        request.POST.add('children-to-delete', id3)
        NodeActions(root, request).delete_nodes()
        assert request.session.pop_flash('success') ==\
            [u'${title} was deleted.', u'${title} was deleted.', u'${title} was deleted.']


class TestNodeMove:
    def test_move_up(self, root):
        from kotti.resources import Document
        from kotti.views.edit.actions import NodeActions

        root['child1'] = Document(title=u"Child 1")
        root['child2'] = Document(title=u"Child 2")
        assert root['child1'].position < root['child2'].position

        request = DummyRequest()
        request.session['kotti.selected-children'] = [str(root['child2'].id)]
        NodeActions(root, request).up()
        assert request.session.pop_flash('success') ==\
            [u'${title} was moved.']
        assert root['child1'].position > root['child2'].position

    def test_move_down(self, root):
        from kotti.resources import Document
        from kotti.views.edit.actions import NodeActions

        root['child1'] = Document(title=u"Child 1")
        root['child2'] = Document(title=u"Child 2")
        root['child3'] = Document(title=u"Child 3")
        assert root['child1'].position < root['child3'].position
        assert root['child2'].position < root['child3'].position

        request = DummyRequest()
        ids = [str(root['child1'].id), str(root['child2'].id)]
        request.session['kotti.selected-children'] = ids
        NodeActions(root, request).down()
        assert request.session.pop_flash('success') ==\
            [u'${title} was moved.', u'${title} was moved.']
        assert root['child1'].position > root['child3'].position
        assert root['child2'].position > root['child3'].position

    def test_move_child_position(self, root, db_session):

        import transaction

        from kotti.resources import Document
        from kotti.resources import get_root
        from kotti.views.edit.actions import move_child_position

        # Create some documents
        root['child1'] = Document(title=u"Child 1")
        root['child2'] = Document(title=u"Child 2")
        root['child3'] = Document(title=u"Child 3")
        root['child4'] = Document(title=u"Child 4")
        root['child5'] = Document(title=u"Child 5")

        assert [c.position for c in root._children] == [0, 1, 2, 3, 4]
        assert [c.name for c in root._children] == [
            u'child1', u'child2', u'child3', u'child4', u'child5']

        request = DummyRequest()

        # Move down
        request.POST = {'from': '0', 'to': '3'}
        result = move_child_position(root, request)
        transaction.commit()
        root = get_root()
        assert result['result'] == 'success'
        assert [c.position for c in root._children] == [0, 1, 2, 3, 4]
        assert [c.name for c in root._children] == [
        u'child2', u'child3', u'child4', u'child1', u'child5']

        # Move up
        request.POST = {'from': '4', 'to': '0'}
        move_child_position(root, request)
        transaction.commit()
        root = get_root()
        assert result['result'] == 'success'
        assert [c.position for c in root._children] == [0, 1, 2, 3, 4]
        assert [c.name for c in root._children] == [
        u'child5', u'child2', u'child3', u'child4', u'child1']

        # Invalid param value
        request.POST = {'from': 'a', 'to': '3'}
        result = move_child_position(root, request)
        assert result['result'] == 'error'

        request.POST = {'from': '0', 'to': '10'}
        result = move_child_position(root, request)
        assert result['result'] == 'error'

        request.POST = {'from': '10', 'to': '0'}
        result = move_child_position(root, request)
        assert result['result'] == 'error'

        # Missing param
        request.POST = {'from': 'a', }
        result = move_child_position(root, request)
        assert result['result'] == 'error'

        # we have to clean up, because we committed transactions
        del root['child1']
        del root['child2']
        del root['child3']
        del root['child4']
        del root['child5']
        transaction.commit()


class TestNodeShowHide:
    def test_show_hide(self, root):
        from kotti.resources import Document
        from kotti.views.edit.actions import NodeActions

        root['child1'] = Document(title=u"Child 1")
        assert root['child1'].in_navigation is True

        request = DummyRequest()
        request.session['kotti.selected-children'] = [str(root['child1'].id)]
        NodeActions(root, request).hide()
        assert request.session.pop_flash('success') ==\
            [u'${title} is no longer visible in the navigation.']
        assert root['child1'].in_navigation is False

        request.session['kotti.selected-children'] = [str(root['child1'].id)]
        NodeActions(root, request).show()
        assert request.session.pop_flash('success') ==\
            [u'${title} is now visible in the navigation.']
        assert root['child1'].in_navigation is True


class TestNodeShare:
    def test_roles(self, root):
        from kotti.views.users import share_node
        from kotti.security import SHARING_ROLES

        # The 'share_node' view will return a list of available roles
        # as defined in 'kotti.security.SHARING_ROLES'
        request = DummyRequest()
        assert (
            [r.name for r in share_node(root, request)['available_roles']] ==
            SHARING_ROLES)

    def test_search(self, extra_principals, root):
        from kotti.security import get_principals
        from kotti.security import set_groups
        from kotti.views.users import share_node

        request = DummyRequest()
        P = get_principals()

        # Search for "Bob", which will return both the user and the
        # group, both of which have no roles:
        request.params['search'] = u''
        request.params['query'] = u'Bob'
        entries = share_node(root, request)['entries']
        assert len(entries) == 2
        assert entries[0][0] == P['bob']
        assert entries[0][1] == ([], [])
        assert entries[1][0] == P['group:bobsgroup']
        assert entries[1][1] == ([], [])

        # We make Bob an Editor in this context, and Bob's Group
        # becomes global Admin:
        set_groups(u'bob', root, [u'role:editor'])
        P[u'group:bobsgroup'].groups = [u'role:admin']
        entries = share_node(root, request)['entries']
        assert len(entries) == 2
        assert entries[0][0] == P['bob']
        assert entries[0][1] == ([u'role:editor'], [])
        assert entries[1][0] == P['group:bobsgroup']
        assert entries[1][1] == ([u'role:admin'], [u'role:admin'])

        # A search that doesn't return any items will still include
        # entries with existing local roles:
        request.params['query'] = u'Weeee'
        entries = share_node(root, request)['entries']
        assert len(entries) == 1
        assert entries[0][0] == P[u'bob']
        assert entries[0][1] == ([u'role:editor'], [])
        assert (request.session.pop_flash('info') ==
            [u'No users or groups were found.'])

        # It does not, however, include entries that have local group
        # assignments only:
        set_groups(u'frank', root, [u'group:franksgroup'])
        request.params['query'] = u'Weeee'
        entries = share_node(root, request)['entries']
        assert len(entries) == 1
        assert entries[0][0] == P['bob']

    def test_apply(self, extra_principals, root):
        from kotti.security import list_groups
        from kotti.security import set_groups
        from kotti.views.users import share_node

        request = DummyRequest()

        request.params['apply'] = u''
        share_node(root, request)
        assert (request.session.pop_flash('info') == [u'No changes were made.'])
        assert list_groups('bob', root) == []
        set_groups('bob', root, ['role:special'])

        request.params['role::bob::role:owner'] = u'1'
        request.params['role::bob::role:editor'] = u'1'
        request.params['orig-role::bob::role:owner'] = u''
        request.params['orig-role::bob::role:editor'] = u''

        share_node(root, request)
        assert (request.session.pop_flash('success') ==
            [u'Your changes have been saved.'])
        assert (
            set(list_groups('bob', root)) ==
            set(['role:owner', 'role:editor', 'role:special'])
            )

        # We cannot set a role that's not displayed, even if we forged
        # the request:
        request.params['role::bob::role:admin'] = u'1'
        request.params['orig-role::bob::role:admin'] = u''
        with raises(Forbidden):
            share_node(root, request)
        assert (
            set(list_groups('bob', root)) ==
            set(['role:owner', 'role:editor', 'role:special'])
            )

########NEW FILE########
__FILENAME__ = test_principals
class TestMassageGroups:

    def test_massage_groups_in(self):
        from kotti.views.users import _massage_groups_in

        appstruct = {'groups': ['user-group', ],
                     'roles': ['role:editor', ]}
        _massage_groups_in(appstruct)
        assert appstruct['groups'] == ['role:editor', 'group:user-group']
        assert 'roles' not in appstruct

        appstruct = {}
        _massage_groups_in(appstruct)
        assert appstruct['groups'] == []
        assert 'roles' not in appstruct

    def test_massage_groups_out(self):
        from kotti.views.users import _massage_groups_out

        appstruct = {'groups': ['group:user-group', 'role:editor']}
        _massage_groups_out(appstruct)
        assert appstruct['groups'] == ['user-group']
        assert appstruct['roles'] == ['role:editor']

        appstruct = {'groups': []}
        _massage_groups_out(appstruct)
        assert appstruct['groups'] == []
        assert appstruct['roles'] == []

########NEW FILE########
__FILENAME__ = test_register
from kotti.testing import DummyRequest
from mock import patch
from mock import call


class TestRegister:

    def test_register_form(self, root):
        from kotti.views.login import register

        request = DummyRequest()
        res = register(root, request)
        assert(res['form'][:5] == '<form')

    def test_register_submit_empty(self, root):
        from kotti.views.login import register

        request = DummyRequest()
        request.POST['register'] = u'register'
        res = register(root, request)
        assert 'There was a problem with your submission' in res['form']

    def test_register_submit(self, root):
        from kotti.views.login import register
        from pyramid.httpexceptions import HTTPFound

        request = DummyRequest()
        request.POST['title'] = u'Test User'
        request.POST['name'] = u'test'
        request.POST['email'] = u'test@example.com'
        request.POST['register'] = u'register',

        with patch('kotti.views.login.UserAddFormView') as form:
            with patch('kotti.views.login.get_principals'):
                res = register(root, request)
                form.assert_has_calls([call().add_user_success({
                    'name': u'test',
                    'roles': u'',
                    'title': u'Test User',
                    'send_email': True,
                    'groups': u'',
                    'email': u'test@example.com'})]
                )
        assert(isinstance(res, HTTPFound))

    def test_register_event(self, root):
        from kotti.views.login import register
        request = DummyRequest()
        request.POST['title'] = u'Test User'
        request.POST['name'] = u'test'
        request.POST['email'] = u'test@example.com'
        request.POST['register'] = u'register',

        with patch('kotti.views.login.UserAddFormView'):
            with patch('kotti.views.login.get_principals'):
                with patch('kotti.views.login.notify') as notify:
                    register(root, request)
        assert(notify.call_count == 1)

    def test_register_submit_groups_and_roles(self, root):
        from kotti.views.login import register
        from pyramid.httpexceptions import HTTPFound

        request = DummyRequest()
        request.POST['title'] = u'Test User'
        request.POST['name'] = u'test'
        request.POST['email'] = u'test@example.com'
        request.POST['register'] = u'register',

        with patch('kotti.views.login.UserAddFormView') as form:
            with patch('kotti.views.login.get_principals'):
                with patch('kotti.views.login.get_settings') as get_settings:
                    get_settings.return_value = {
                        'kotti.register.group': 'mygroup',
                        'kotti.register.role': 'myrole',
                        }

                    res = register(root, request)

        form.assert_has_calls([
            call().add_user_success({
                'name': u'test',
                'roles': set([u'role:myrole']),
                'title': u'Test User',
                'send_email': True,
                'groups': [u'mygroup'],
                'email': u'test@example.com',
                })])
        assert(isinstance(res, HTTPFound))


class TestNotRegister:
    def test_it(self, app):
        res = app.post('/register', status=404)
        assert res.status == '404 Not Found'

########NEW FILE########
__FILENAME__ = test_search
from kotti.testing import DummyRequest


def create_contents(root):
    from kotti.resources import Content, File
    doc1 = root['doc1'] = Content(title=u'First Document')
    doc11 = root['doc1']['doc11'] = Content(title=u'Second Document')
    doc12 = root['doc1']['doc12'] = Content(title=u'Third Document')
    file1 = root['doc1']['file1'] = File(title=u'First File',
                                         description=u'this is a file')
    return doc1, doc11, doc12, file1


def create_contents_with_tags(root=None):
    from kotti.resources import get_root
    from kotti.resources import Content, File
    if root is None:
        root = get_root()

    animals = root['animals'] = Content(title=u'Animals')
    cat = root['animals']['cat'] = Content(title=u'Cat')
    dog = root['animals']['dog'] = Content(title=u'Dog')
    monkey = root['animals']['monkey'] = Content(title=u'Monkey')
    gorilla = root['animals']['gorilla'] = Content(title=u'Gorilla')
    monkey_file = root['animals']['monkey_file'] = File(title=u'Monkey File',
        description=u'A Rhesus Macaque and a Green Monkey walk into a bar...')

    root[u'animals'][u'cat'].tags = [u'Animals', u'Cat']
    root[u'animals'][u'dog'].tags = [u'Animals', u'Dog']
    root[u'animals'][u'monkey'].tags = [u'Animals', u'Monkey', u'Primate']
    root[u'animals'][u'monkey_file'].tags = [u'Animals', u'Monkey', u'Primate']
    root[u'animals'][u'gorilla'].tags = [u'Animals', u'Gorilla', u'Primate']

    return animals, cat, dog, monkey, gorilla, monkey_file


class TestSearch:

    def test_search_empty_content(self, db_session):
        from kotti.views.util import search_content
        request = DummyRequest()
        results = search_content(u'teststring', request)
        assert results == []

    def test_search_content(self, root):
        from kotti.views.util import search_content
        from kotti import DBSession
        from kotti.resources import Tag

        request = DummyRequest()
        doc1, doc11, doc12, file1 = create_contents(root)
        results = search_content(u'First Document', request)
        assert len(results) == 1
        assert results[0]['name'] == u'doc1'
        assert results[0]['title'] == u'First Document'
        results = search_content(u'Document', request)
        # The frontpage contains 'Documentation' in its body!
        assert len(results) == 4
        assert results[1]['name'] == u'doc11'
        assert results[1]['title'] == u'Second Document'
        assert results[1]['path'] == '/doc1/doc11/'
        assert results[1]['path'][-1] == '/'

        animals, cat, dog, \
            monkey, gorilla, monkey_file = create_contents_with_tags()

        tags = DBSession.query(Tag).all()
        assert len(tags) == 6
        results = search_content(u'Animals', request)
        assert len(results) == 6
        results = search_content(u'Cat', request)
        assert len(results) == 1
        results = search_content(u'Primate', request)
        assert len(results) == 3

        # Tags were included in general search by modifying the pre-existing
        # approach, wherein searching first worked on title and description,
        # then on body, so that the search order became:
        #
        #     first on title + description
        #         then on tags
        #             then on body
        #
        # So we test here to assure search results come back in that order.
        # Searching on 'Animals', we should find all 6 content items, and the
        # first item should be the Animals folder, found with a title hit, and
        # the other items were found via tags.
        #
        # Note: this ordering is done to have some method, but it does not
        #       necessarily constitute a specification.
        #
        results = search_content(u'Animals', request)
        assert len(results) == 6
        assert results[0]['name'] == 'animals'

    def test_search_file_description(self, root):
        from kotti.views.util import search_content
        request = DummyRequest()
        doc1, doc11, doc12, file1 = create_contents(root)
        results = search_content(u'this is a file', request)
        assert len(results) == 1
        assert results[0]['name'] == 'file1'
        assert results[0]['title'] == 'First File'
        assert results[0]['path'] == '/doc1/file1/'

    def test_search_content_without_permission(self, config, root):
        from kotti.views.util import search_content
        request = DummyRequest()
        create_contents(root)
        config.testing_securitypolicy(permissive=False)
        results = search_content(u'Document', request)
        assert len(results) == 0

########NEW FILE########
__FILENAME__ = test_security
from mock import patch
from pytest import raises
from pyramid.authentication import CallbackAuthenticationPolicy

from kotti.testing import DummyRequest


class TestGroups:
    def test_root_default(self, db_session, root):
        from kotti.security import list_groups
        from kotti.security import list_groups_raw

        assert list_groups('admin', root) == ['role:admin']
        assert list_groups_raw(u'admin', root) == set([])

    def test_empty(self, db_session, root):
        from kotti.security import list_groups

        assert list_groups('bob', root) == []

    def test_simple(self, db_session, root):
        from kotti.security import list_groups
        from kotti.security import list_groups_raw
        from kotti.security import set_groups

        set_groups('bob', root, ['role:editor'])
        assert list_groups('bob', root) == ['role:editor']
        assert list_groups_raw(u'bob', root) == set(['role:editor'])

    def test_not_a_node(self):
        from kotti.security import list_groups_raw

        assert list_groups_raw(u'bob', object()) == set()

    def test_overwrite_and_delete(self, db_session, root):
        from kotti.resources import get_root
        from kotti.security import list_groups
        from kotti.security import list_groups_raw
        from kotti.security import set_groups

        set_groups('bob', root, ['role:editor'])
        assert list_groups('bob', root) == ['role:editor']
        assert list_groups_raw(u'bob', root) == set(['role:editor'])

        set_groups('bob', root, ['role:admin'])
        assert list_groups('bob', root) == ['role:admin']
        assert list_groups_raw(u'bob', root) == set(['role:admin'])

        set_groups('bob', root)
        assert list_groups('bob', root) == []
        assert get_root() is root

    def test_inherit(self, db_session, root):
        from kotti.resources import Node
        from kotti.security import list_groups
        from kotti.security import list_groups_raw
        from kotti.security import set_groups

        child = root[u'child'] = Node()
        db_session.flush()

        assert list_groups('bob', child) == []
        set_groups('bob', root, ['role:editor'])
        assert list_groups('bob', child) == ['role:editor']

        # Groups from the child are added:
        set_groups('bob', child, ['group:somegroup'])
        assert (
            set(list_groups('bob', child)) ==
            set(['group:somegroup', 'role:editor'])
            )

        # We can ask to list only those groups that are defined locally:
        assert list_groups_raw(u'bob', child) == set(['group:somegroup'])

    @staticmethod
    def add_some_groups(db_session, root):
        from kotti.resources import Node
        from kotti.security import set_groups

        child = root[u'child'] = Node()
        grandchild = child[u'grandchild'] = Node()
        db_session.flush()

        # root:
        #   bob               -> group:bobsgroup
        #   frank             -> group:franksgroup
        #   group:franksgroup -> role:editor
        # child:
        #   group:bobsgroup   -> group:franksgroup
        # grandchild:
        #   group:franksgroup -> role:admin
        #   group:franksgroup -> group:bobsgroup

        # bob and frank are a site-wide members of their respective groups:
        set_groups('bob', root, ['group:bobsgroup'])
        set_groups('frank', root, ['group:franksgroup'])

        # franksgroup has a site-wide editor role:
        set_groups('group:franksgroup', root, ['role:editor'])

        # bobsgroup is part of franksgroup on the child level:
        set_groups('group:bobsgroup', child, ['group:franksgroup'])

        # franksgroup has the admin role on the grandchild.
        # and finally, to test recursion, we make franksgroup part of
        # bobsgroup on the grandchild level:
        set_groups('group:franksgroup', grandchild,
                   ['role:owner', 'group:bobsgroup'])

    def test_nested_groups(self, db_session, root):
        from kotti.security import list_groups
        from kotti.security import list_groups_ext

        self.add_some_groups(db_session, root)
        child = root[u'child']
        grandchild = child[u'grandchild']

        # Check bob's groups on every level:
        assert list_groups('bob', root) == ['group:bobsgroup']
        assert (set(list_groups('bob', child)) ==
            set(['group:bobsgroup', 'group:franksgroup', 'role:editor']))
        assert (set(list_groups('bob', grandchild)) ==
            set(['group:bobsgroup', 'group:franksgroup', 'role:editor',
                 'role:owner']))

        # Check group:franksgroup groups on every level:
        assert (set(list_groups('frank', root)) ==
            set(['group:franksgroup', 'role:editor']))
        assert (set(list_groups('frank', child)) ==
            set(['group:franksgroup', 'role:editor']))
        assert (set(list_groups('frank', grandchild)) ==
            set(['group:franksgroup', 'role:editor', 'role:owner',
                 'group:bobsgroup']))

        # Sometimes it's useful to know which of the groups were
        # inherited, that's what 'list_groups_ext' is for:
        groups, inherited = list_groups_ext('bob', root)
        assert groups == ['group:bobsgroup']
        assert inherited == []

        groups, inherited = list_groups_ext('bob', child)
        assert (set(groups) ==
            set(['group:bobsgroup', 'group:franksgroup', 'role:editor']))
        assert (set(inherited) ==
            set(['group:bobsgroup', 'group:franksgroup', 'role:editor']))

        groups, inherited = list_groups_ext('group:bobsgroup', child)
        assert set(groups) == set(['group:franksgroup', 'role:editor'])
        assert inherited == ['role:editor']

        groups, inherited = list_groups_ext('group:franksgroup', grandchild)
        assert (set(groups) ==
            set(['group:bobsgroup', 'role:owner', 'role:editor']))
        assert inherited == ['role:editor']

    def test_works_with_auth(self, db_session, root):
        from kotti.resources import Node
        from kotti.security import get_principals
        from kotti.security import list_groups_callback
        from kotti.security import set_groups

        child = root[u'child'] = Node()
        db_session.flush()

        request = DummyRequest()
        auth = CallbackAuthenticationPolicy()
        auth.unauthenticated_userid = lambda *args: 'bob'
        auth.callback = list_groups_callback

        request.context = root
        assert (  # user doesn't exist yet
            auth.effective_principals(request) ==
            ['system.Everyone']
            )

        get_principals()[u'bob'] = dict(name=u'bob')
        assert (
            auth.effective_principals(request) ==
            ['system.Everyone', 'system.Authenticated', 'bob']
            )

        # Define that bob belongs to bobsgroup on the root level:
        set_groups('bob', root, ['group:bobsgroup'])
        request.context = child
        assert (
            set(auth.effective_principals(request)) == set([
                'system.Everyone', 'system.Authenticated',
                'bob', 'group:bobsgroup'
                ])
            )

        # define that bob belongs to franksgroup in the user db:
        get_principals()[u'bob'].groups = [u'group:franksgroup']
        set_groups('group:franksgroup', child, ['group:anothergroup'])
        assert (
            set(auth.effective_principals(request)) == set([
                'system.Everyone', 'system.Authenticated',
                'bob', 'group:bobsgroup', 'group:franksgroup',
                'group:anothergroup',
                ])
            )

        # And lastly test that circular group defintions are not a
        # problem here either:
        get_principals()[u'group:franksgroup'] = dict(
            name=u'group:franksgroup',
            title=u"Frank's group",
            groups=[u'group:funnygroup', u'group:bobsgroup'],
            )
        assert (
            set(auth.effective_principals(request)) == set([
                'system.Everyone', 'system.Authenticated',
                'bob', 'group:bobsgroup', 'group:franksgroup',
                'group:anothergroup', 'group:funnygroup',
                ])
            )

    def test_list_groups_callback_with_groups(self, db_session):
        from kotti.security import list_groups_callback
        from kotti.security import get_principals

        # Although group definitions are also in the user database,
        # we're not allowed to authenticate with a group id:
        get_principals()[u'bob'] = dict(name=u'bob')
        get_principals()[u'group:bobsgroup'] = dict(name=u'group:bobsgroup')

        request = DummyRequest()
        assert list_groups_callback(u'bob', request) == []
        assert list_groups_callback(u'group:bobsgroup', request) is None

    def test_principals_with_local_roles(self, db_session, root):
        from kotti.resources import Node
        from kotti.security import map_principals_with_local_roles
        from kotti.security import principals_with_local_roles
        from kotti.security import set_groups

        child = root[u'child'] = Node()
        db_session.flush()

        assert principals_with_local_roles(root) == []
        assert principals_with_local_roles(child) == []
        assert map_principals_with_local_roles(root) == []
        assert map_principals_with_local_roles(child) == []

        set_groups('group:bobsgroup', child, ['role:editor'])
        set_groups('bob', root, ['group:bobsgroup'])
        set_groups('group:franksgroup', root, ['role:editor'])

        assert (
            set(principals_with_local_roles(child)) ==
            set(['bob', 'group:bobsgroup', 'group:franksgroup'])
            )
        assert (
            set(principals_with_local_roles(child, inherit=False)) ==
            set(['group:bobsgroup'])
            )
        assert (
            set(principals_with_local_roles(root)) ==
            set(['bob', 'group:franksgroup'])
            )

    def test_copy_local_groups(self, db_session, root):
        from kotti.security import principals_with_local_roles
        from kotti.security import set_groups

        self.test_principals_with_local_roles(db_session, root)
        child = root[u'child']
        assert (
            set(principals_with_local_roles(child)) ==
            set(['bob', 'group:bobsgroup', 'group:franksgroup'])
            )

        # We make a copy of 'child', and we expect the local roles set
        # on 'child' to not be copied over:
        child2 = root['child2'] = child.copy()
        db_session.flush()
        assert (
            set(principals_with_local_roles(child2)) ==
            set([u'bob', u'group:franksgroup']))
        assert len(principals_with_local_roles(child)) == 3

        # When we now change the local roles of 'child', the copy is
        # unaffected:
        set_groups('group:bobsgroup', child, [])
        assert len(principals_with_local_roles(child)) == 2
        assert len(principals_with_local_roles(child2)) == 2

    def test_map_principals_with_local_roles(self, db_session, root):
        from kotti.security import get_principals
        from kotti.security import map_principals_with_local_roles

        self.test_principals_with_local_roles(db_session, root)
        child = root[u'child']
        P = get_principals()

        # No users are defined in P, thus we get the empty list:
        assert map_principals_with_local_roles(root) == []

        P['bob'] = {'name': u'bob'}
        P['group:bobsgroup'] = {'name': u'group:bobsgroup'}

        value = map_principals_with_local_roles(root)
        assert len(value) == 1
        bob, (bob_all, bob_inherited) = value[0]
        assert bob_all == ['group:bobsgroup']
        assert bob_inherited == []

        value = map_principals_with_local_roles(child)
        assert len(value) == 2
        bob, (bob_all, bob_inherited) = value[0]
        bobsgroup, (bobsgroup_all, bobsgroup_inherited) = value[1]
        assert (set(bob_all) == set(['group:bobsgroup', 'role:editor']))
        assert (set(bob_inherited) == set(['group:bobsgroup', 'role:editor']))
        assert bobsgroup_all == ['role:editor']
        assert bobsgroup_inherited == []

    def test_local_roles_db_cascade(self, db_session, root):
        from kotti.resources import LocalGroup
        from kotti.resources import Node
        from kotti.security import set_groups

        child = root[u'child'] = Node()
        db_session.flush()

        # We set a local group on child and delete child.  We then
        # expect the LocalGroup entry to have been deleted from the
        # database:
        assert db_session.query(LocalGroup).count() == 0
        set_groups('group:bobsgroup', child, ['role:editor'])
        assert db_session.query(LocalGroup).count() == 1
        del root[u'child']
        db_session.flush()
        assert db_session.query(LocalGroup).count() == 0


class TestPrincipals:
    def get_principals(self):
        from kotti.security import get_principals
        return get_principals()

    def make_bob(self):
        users = self.get_principals()
        users[u'bob'] = dict(
            name=u'bob',
            password=u'secret',
            email=u'bob@dabolina.com',
            title=u'Bob Dabolina',
            groups=[u'group:bobsgroup'],
            )
        return users[u'bob']

    def _assert_is_bob(self, bob):
        assert bob.name == u'bob'
        assert bob.title == u'Bob Dabolina'
        assert bob.groups == [u'group:bobsgroup']

    def test_hash_password_non_ascii(self, db_session):
        self.get_principals().hash_password(u'\xd6TEst')

    def test_default_admin(self, db_session):
        admin = self.get_principals()[u'admin']
        assert self.get_principals().validate_password(
            u'secret', admin.password)
        assert admin.groups == [u'role:admin']

    def test_users_empty(self, db_session):
        users = self.get_principals()
        with raises(KeyError):
            users[u'bob']
        with raises(KeyError):
            del users[u'bob']
        assert users.keys() == [u'admin']

    def test_users_add_and_remove(self, db_session):
        self.make_bob()
        users = self.get_principals()
        self._assert_is_bob(users[u'bob'])
        assert set(users.keys()) == set([u'admin', u'bob'])

        del users['bob']
        with raises(KeyError):
            users[u'bob']
        with raises(KeyError):
            del users[u'bob']

    def test_users_search(self, db_session):
        users = self.get_principals()
        assert list(users.search(name=u"*Bob*")) == []
        self.make_bob()
        [bob] = list(users.search(name=u"bob"))
        self._assert_is_bob(bob)
        [bob] = list(users.search(name=u"*Bob*"))
        self._assert_is_bob(bob)
        [bob] = list(users.search(name=u"*Bob*", title=u"*Frank*"))
        self._assert_is_bob(bob)
        with raises(AttributeError):
            users.search(name=u"bob", foo=u"bar")
        assert list(users.search()) == []

    def test_groups_from_users(self, db_session, root):
        from kotti.resources import Node
        from kotti.security import list_groups
        from kotti.security import set_groups

        self.make_bob()
        child = root[u'child'] = Node()
        db_session.flush()

        assert list_groups('bob', root) == ['group:bobsgroup']

        set_groups('group:bobsgroup', root, ['role:editor'])
        set_groups('role:editor', child, ['group:foogroup'])

        assert (set(list_groups('bob', root)) ==
            set(['group:bobsgroup', 'role:editor']))
        assert (set(list_groups('bob', child)) ==
            set(['group:bobsgroup', 'role:editor', 'group:foogroup']))

    def test_is_user(self, db_session):
        from kotti.security import is_user

        bob = self.make_bob()
        assert is_user(bob) is True
        bob.name = u'group:bobsgroup'
        assert is_user(bob) is False

    def test_hash_and_validate_password(self, db_session):
        password = u"secret"
        principals = self.get_principals()
        hashed = principals.hash_password(password)
        assert principals.validate_password(password, hashed)
        assert principals.validate_password(u"foo", hashed) is False

    def test_bobs_hashed_password(self, db_session):
        bob = self.make_bob()
        principals = self.get_principals()
        assert principals.validate_password(u"secret", bob.password)

        # When we set the 'password' attribute directly, we have to do
        # the hashing ourselves.  This won't work:
        bob.password = u'anothersecret'
        assert principals.validate_password(
            u"anothersecret", bob.password) is False

        # This will:
        bob.password = principals.hash_password(u"anothersecret")
        assert principals.validate_password(u"anothersecret", bob.password)

    def test_active(self, db_session):
        bob = self.make_bob()
        assert bob.active is True
        bob.active = False
        assert bob.active is False

    def test_reset_password(self, db_session):
        from kotti.views.login import login

        request = DummyRequest()
        self.make_bob()
        request.params['reset-password'] = u'on'
        request.params['login'] = u'bob'
        request.params['password'] = u'secret'
        with patch(
            'kotti.views.login.email_set_password') as email_set_password:
            login(None, request)
        assert (request.session.pop_flash('success') == [
            u"You should be receiving an email with a link to reset your "
            u"password. Doing so will activate your account."])
        assert email_set_password.call_count == 1

    def test_reset_password_inactive_user(self, db_session):
        from kotti.views.login import login

        request = DummyRequest()
        self.make_bob().active = False
        request.params['reset-password'] = u'on'
        request.params['login'] = u'bob'
        request.params['password'] = u'secret'
        with patch(
            'kotti.views.login.email_set_password') as email_set_password:
            login(None, request)
        assert (request.session.pop_flash('error') ==
            [u"That username or email is not known by this system."])
        assert email_set_password.call_count == 0

    def test_login(self, db_session):
        from kotti.views.login import login
        request = DummyRequest()

        # No login attempt:
        result = login(None, request)
        assert isinstance(result, dict)
        assert request.session.pop_flash('success') == []
        assert request.session.pop_flash('error') == []

        # Attempt to log in before Bob exists:
        request.params['submit'] = u'on'
        request.params['login'] = u'bob'
        request.params['password'] = u'secret'
        result = login(None, request)
        assert isinstance(result, dict)
        assert request.session.pop_flash('success') == []
        assert (request.session.pop_flash('error') == [u'Login failed.'])

        # Make Bob and do it again:
        bob = self.make_bob()
        assert bob.last_login_date is None
        result = login(None, request)
        assert result.status == '302 Found'
        assert (
            [request.session.pop_flash('success')[0].interpolate()] ==
            [u'Welcome, Bob Dabolina!'])
        last_login_date = bob.last_login_date
        assert last_login_date is not None
        assert request.session.pop_flash('error') == []

        # Log in with email:
        request.params['login'] = u'bob@dabolina.com'
        result = login(None, request)
        assert result.status == '302 Found'
        assert (
            [request.session.pop_flash('success')[0].interpolate()] ==
            [u'Welcome, Bob Dabolina!'])
        assert last_login_date < bob.last_login_date

        # Deactive Bob, logging in is no longer possible:
        bob.active = False
        result = login(None, request)
        assert isinstance(result, dict)
        assert (request.session.pop_flash('error') == [u'Login failed.'])

        # If Bob has a 'confirm_token' set, logging in is still possible:
        bob.active = True
        bob.confirm_token = u'token'
        result = login(None, request)
        assert result.status == '302 Found'
        assert (
            [request.session.pop_flash('success')[0].interpolate()] ==
            [u'Welcome, Bob Dabolina!'])

    def test_login_with_email_remembers(self, db_session):
        from kotti.views.login import login
        request = DummyRequest()

        self.make_bob()
        request.params['submit'] = u'on'
        request.params['login'] = u'bob@dabolina.com'
        request.params['password'] = u'secret'
        with patch('kotti.views.login.remember') as remember:
            login(None, request)
            remember.assert_called_with(request, u'bob')


class TestAuthzContextManager:
    def test_basic(self):
        from kotti.security import authz_context

        context, request = object(), DummyRequest()
        with authz_context(context, request):
            assert request.environ['authz_context'] == context
        assert 'authz_context' not in request.environ

    def test_set_before(self):
        from kotti.security import authz_context

        context, context2, request = object(), object(), DummyRequest()
        request.environ['authz_context'] = context2
        with authz_context(context, request):
            assert request.environ['authz_context'] == context
        assert request.environ['authz_context'] == context2

    def test_with_exception(self):
        from kotti.security import authz_context

        context, context2, request = object(), object(), DummyRequest()
        request.environ['authz_context'] = context2
        try:
            with authz_context(context, request):
                assert request.environ['authz_context'] == context
                raise ValueError
        except ValueError:
            assert request.environ['authz_context'] == context2


class TestViewPermitted:
    @patch('kotti.security.view_execution_permitted')
    def test_with_post_request(self, view_execution_permitted):
        from kotti.security import view_permitted

        context, request = object(), DummyRequest()
        request.method = 'POST'
        calls = []

        def view_execution_permitted_mock(context, request, name):
            calls.append((context, request, name))
            assert request.method == 'GET'

        view_execution_permitted.side_effect = view_execution_permitted_mock
        view_permitted(context, request)
        assert len(calls) == 1
        assert request.method == 'POST'


class TestHasPermission:
    def test_basic(self):
        from kotti.security import has_permission

        permission, context, request = object(), object(), DummyRequest()
        args = []

        def has_permission_fake(permission, context, request):
            args.append((permission, context, request))
            assert request.environ['authz_context'] == context

        with patch('kotti.security.base_has_permission',
                   new=has_permission_fake):
            has_permission(permission, context, request)

        assert args == [(permission, context, request)]


class TestRolesSetters:
    def test_set_roles(self):
        from kotti.security import ROLES
        from kotti.security import set_roles
        from kotti.security import reset_roles

        before = ROLES.copy()
        set_roles({'role:admin': ROLES['role:admin']})
        assert ROLES == {'role:admin': ROLES['role:admin']}
        reset_roles()
        assert ROLES == before

    def test_set_sharing_roles(self):
        from kotti.security import SHARING_ROLES
        from kotti.security import set_sharing_roles
        from kotti.security import reset_sharing_roles

        before = SHARING_ROLES[:]
        set_sharing_roles(['role:admin'])
        assert SHARING_ROLES == ['role:admin']
        reset_sharing_roles()
        assert SHARING_ROLES == before

    def test_set_user_management_roles(self):
        from kotti.security import USER_MANAGEMENT_ROLES
        from kotti.security import set_user_management_roles
        from kotti.security import reset_user_management_roles

        before = USER_MANAGEMENT_ROLES[:]
        set_user_management_roles(['role:admin'])
        assert USER_MANAGEMENT_ROLES == ['role:admin']
        reset_user_management_roles()
        assert USER_MANAGEMENT_ROLES == before

########NEW FILE########
__FILENAME__ = test_security_views
import colander
import pytest
from mock import patch
from mock import Mock
from pytest import raises

from kotti.testing import DummyRequest


class TestUserManagement:
    def test_roles(self, root):
        from kotti.security import USER_MANAGEMENT_ROLES
        from kotti.views.users import UsersManage

        request = DummyRequest()
        assert ([r.name
                 for r in UsersManage(root, request)()['available_roles']] ==
                USER_MANAGEMENT_ROLES)

    def test_search(self, extra_principals, root):
        from kotti.security import get_principals
        from kotti.views.users import UsersManage

        request = DummyRequest()
        P = get_principals()

        request.params['search'] = u''
        request.params['query'] = u'Joe'
        entries = UsersManage(root, request)()['entries']
        assert len(entries) == 0
        assert (request.session.pop_flash('info') ==
            [u'No users or groups were found.'])
        request.params['query'] = u'Bob'
        entries = UsersManage(root, request)()['entries']
        assert entries[0][0] == P['bob']
        assert entries[0][1] == ([], [])
        assert entries[1][0] == P['group:bobsgroup']
        assert entries[1][1] == ([], [])

        P[u'bob'].groups = [u'group:bobsgroup']
        P[u'group:bobsgroup'].groups = [u'role:admin']
        entries = UsersManage(root, request)()['entries']
        assert (entries[0][1] ==
            (['group:bobsgroup', 'role:admin'], ['role:admin']))
        assert entries[1][1] == (['role:admin'], [])

    def test_apply(self, extra_principals, root):
        from kotti.security import get_principals
        from kotti.security import list_groups
        from kotti.views.users import UsersManage

        request = DummyRequest()

        bob = get_principals()[u'bob']

        request.params['apply'] = u''
        UsersManage(root, request)()
        assert (request.session.pop_flash('info') == [u'No changes were made.'])
        assert list_groups('bob') == []
        bob.groups = [u'role:special']

        request.params['role::bob::role:owner'] = u'1'
        request.params['role::bob::role:editor'] = u'1'
        request.params['orig-role::bob::role:owner'] = u''
        request.params['orig-role::bob::role:editor'] = u''

        UsersManage(root, request)()
        assert (request.session.pop_flash('success') ==
            [u'Your changes have been saved.'])
        assert (
            set(list_groups('bob')) ==
            set(['role:owner', 'role:editor', 'role:special'])
            )

    def test_group_validator(self, db_session):
        from kotti.views.users import group_validator
        with raises(colander.Invalid):
            group_validator(None, u'this-group-never-exists')


class TestUserDelete:
    def test_user_delete(self, events, extra_principals, root):
        from kotti.security import get_principals
        from kotti.views.users import user_delete

        request = DummyRequest()
        bob = get_principals()[u'bob']

        request.params['name'] = u''
        user_delete(root, request)
        assert request.session.pop_flash('error') == [u'No name was given.']
        assert u'bob' in get_principals().keys()

        request.params['name'] = u'bob'
        result = user_delete(root, request)
        assert u'api' in result
        api = result[u'api']
        assert api.principal == bob
        assert api.principal_type == u'User'
        assert u'bob' in get_principals().keys()

        request.params['name'] = u'john'
        request.params['delete'] = u'delete'
        user_delete(root, request)
        assert request.session.pop_flash('error') == [u"User was not found."]
        assert u'bob' in get_principals().keys()

        request.params['name'] = u'bob'
        request.params['delete'] = u'delete'
        user_delete(root, request)
        with pytest.raises(KeyError):
            get_principals()[u'bob']

    def test_deleted_group_removed_in_usergroups(self, events, extra_principals, root):
        from kotti.security import get_principals
        from kotti.views.users import user_delete

        request = DummyRequest()
        bob = get_principals()[u'bob']
        bob.groups = [u'group:bobsgroup']
        assert bob.groups == [u'group:bobsgroup']

        request.params['name'] = u'group:bobsgroup'
        request.params['delete'] = u'delete'
        user_delete(root, request)
        with pytest.raises(KeyError):
            get_principals()[u'group:bobsgroup']
        assert bob.groups == []

    def test_deleted_group_removed_from_localgroups(self, events, extra_principals, root):
        from kotti.security import set_groups
        from kotti.resources import LocalGroup
        from kotti.views.users import user_delete

        request = DummyRequest()
        set_groups(u'group:bobsgroup', root, ['role:admin'])
        local_group = LocalGroup.query.first()
        assert local_group.principal_name == u'group:bobsgroup'
        assert local_group.node == root

        request.params['name'] = u'group:bobsgroup'
        request.params['delete'] = u'delete'
        user_delete(root, request)
        assert LocalGroup.query.first() == None

    def test_reset_owner_to_none(self, events, extra_principals, root):
        from kotti.resources import Content
        from kotti.views.users import user_delete

        request = DummyRequest()

        root[u'content_1'] = Content()
        root[u'content_1'].owner = u'bob'
        assert root[u'content_1'].owner == u'bob'

        request.params['name'] = u'bob'
        request.params['delete'] = u'delete'
        user_delete(root, request)
        assert root[u'content_1'].owner == None


class TestSetPassword:
    def setup_method(self, method):
        Form_patcher = patch('kotti.views.login.Form')
        self.Form_mock = Form_patcher.start()

        _find_user_patcher = patch('kotti.views.login._find_user')
        self._find_user_mock = _find_user_patcher.start()
        self.user = self._find_user_mock.return_value

        validate_token_patcher = patch('kotti.views.login.validate_token')
        self.validate_token_mock = validate_token_patcher.start()

        self.patchers = (
            Form_patcher, _find_user_patcher, validate_token_patcher)

    def teardown_method(self, method):
        for patcher in self.patchers:
            patcher.stop()

    def form_values(self, values):
        self.Form_mock.return_value.validate.return_value = values

    def test_success(self, root):
        from kotti.security import get_principals
        from kotti.views.login import set_password

        self.form_values({
            'token': 'mytoken',
            'email': 'myemail',
            'password': 'mypassword',
            'continue_to': '',
            })
        self.user.confirm_token = 'mytoken'
        self.user.password = 'old_password'
        context, request = root, DummyRequest(post={'submit': 'submit'})
        self.user.last_login_date = None
        res = set_password(context, request)

        assert self.user.confirm_token is None
        assert self.user.last_login_date is not None
        assert get_principals().validate_password(
            'mypassword', self.user.password)
        assert res.status == '302 Found'

    def test_wrong_token(self, root):
        from kotti.security import get_principals
        from kotti.views.login import set_password

        self.form_values({
            'token': 'wrongtoken',
            'email': 'myemail',
            'password': 'mypassword',
            'continue_to': '',
            })
        self.user.confirm_token = 'mytoken'
        self.user.password = 'old_password'
        context, request = root, DummyRequest(post={'submit': 'submit'})
        res = set_password(context, request)

        assert self.user.confirm_token == 'mytoken'
        assert not get_principals().validate_password(
            'mypassword', self.user.password)
        assert not request.is_response(res)

    def test_inactive_user(self, root):
        from kotti.security import get_principals
        from kotti.views.login import set_password

        self.form_values({
            'token': 'mytoken',
            'email': 'myemail',
            'password': 'mypassword',
            'continue_to': '',
            })
        self.user.confirm_token = 'mytoken'
        self.user.password = 'old_password'
        context, request = root, DummyRequest(post={'submit': 'submit'})
        self.user.active = False
        self.user.last_login_date = None
        res = set_password(context, request)

        assert self.user.confirm_token == 'mytoken'
        assert self.user.last_login_date is None
        assert not get_principals().validate_password(
            'mypassword', self.user.password)
        assert not request.is_response(res)

    def test_success_continue(self, root):
        from kotti.views.login import set_password

        self.form_values({
            'token': 'mytoken',
            'email': 'myemail',
            'password': 'mypassword',
            'continue_to': 'http://example.com/here#there',
            })
        self.user.confirm_token = 'mytoken'
        context, request = root, DummyRequest(
            post={'submit': 'submit'})
        res = set_password(context, request)

        assert res.status == '302 Found'
        assert res.location == 'http://example.com/here#there'


class TestUserManageForm:

    def test_schema_factory(self, root):
        from kotti.views.users import UserManageFormView

        request = DummyRequest()
        view = UserManageFormView(root, request)

        schema = view.schema_factory()
        assert 'name' not in schema
        assert 'password' in schema

    def test_form(self, root):
        from kotti.views.users import UserManageFormView

        request = DummyRequest()
        form = UserManageFormView(root, request)()
        assert ('input type="password"' in form['form'])

    def test_hashed_password_save(self, root):
        from kotti.views.users import UserManageFormView

        user = Mock()
        request = DummyRequest()
        view = UserManageFormView(user, request)
        appstruct = {'password': u'foo'}
        view.save_success(appstruct)
        assert user.password.startswith(u'$2a$10$')

    def test_hashed_password_empty(self, root):
        from kotti.views.users import UserManageFormView

        user = Mock(password=u'before')
        request = DummyRequest()
        view = UserManageFormView(user, request)
        appstruct = {'password': u''}
        view.save_success(appstruct)
        assert user.password == u"before"

########NEW FILE########
__FILENAME__ = test_sqla
from mock import MagicMock
from pyramid.security import ALL_PERMISSIONS


class TestNestedMutationDict:
    def test_dictwrapper_comparison(self):
        from kotti.sqla import NestedMutationDict

        assert NestedMutationDict({}) == NestedMutationDict({})
        assert (
            NestedMutationDict({'a': 'ok'}) == NestedMutationDict({'a': 'ok'}))

    def test_listwrapper_comparison(self):
        from kotti.sqla import NestedMutationList

        assert NestedMutationList({}) == NestedMutationList({})
        assert (
            NestedMutationList(['ok']) == NestedMutationList(['ok']))

    def test_dictwrapper_changed(self):
        from kotti.sqla import NestedMutationDict

        data = {}
        wrapper = NestedMutationDict(data)
        changed = wrapper.changed = MagicMock()

        wrapper['name'] = 'andy'
        assert data == {'name': 'andy'}
        assert wrapper == {'name': 'andy'}
        assert wrapper['name'] == 'andy'
        assert changed.call_count == 1

        wrapper['age'] = 77
        assert data == {'name': 'andy', 'age': 77}
        assert wrapper['age'] == 77
        assert wrapper['name'] == 'andy'
        assert changed.call_count == 2

        wrapper['age'] += 1
        assert data == {'name': 'andy', 'age': 78}
        assert wrapper['age'] == 78
        assert changed.call_count == 3

    def test_listwrapper_changed(self):
        from kotti.sqla import NestedMutationList

        data = []
        wrapper = NestedMutationList(data)
        changed = wrapper.changed = MagicMock()

        wrapper.append(5)
        assert data == [5]
        assert wrapper == [5]
        assert wrapper[0] == 5
        assert changed.call_count == 1

        wrapper.insert(0, 33)
        assert data == [33, 5]
        assert wrapper[0] == 33
        assert changed.call_count == 2

        del wrapper[0]
        assert data == [5]
        assert wrapper[0] == 5
        assert changed.call_count == 3

    def test_dictwrapper_wraps(self):
        from kotti.sqla import NestedMutationDict
        from kotti.sqla import NestedMutationList

        wrapper = NestedMutationDict(
            {'name': 'andy', 'age': 77, 'children': []})
        changed = wrapper.changed = MagicMock()

        wrapper['name'] = 'randy'
        assert changed.call_count == 1

        assert isinstance(wrapper['children'], NestedMutationList)
        wrapper['children'].append({'name': 'sandy', 'age': 33})
        assert changed.call_count == 2
        assert len(wrapper['children']), 1
        assert isinstance(wrapper['children'][0], NestedMutationDict)

    def test_listwrapper_wraps(self):
        from kotti.sqla import NestedMutationDict
        from kotti.sqla import NestedMutationList

        wrapper = NestedMutationList(
            [{'name': 'andy', 'age': 77, 'children': []}])
        changed = wrapper.changed = MagicMock()

        assert isinstance(wrapper[0], NestedMutationDict)
        assert isinstance(wrapper[0]['children'], NestedMutationList)
        assert changed.call_count == 0

    def test_setdefault_dict(self):
        from kotti.sqla import NestedMutationDict
        mdict = NestedMutationDict({})
        assert isinstance(mdict.setdefault('bar', {}), NestedMutationDict)

    def test_setdefault_list(self):
        from kotti.sqla import NestedMutationDict
        from kotti.sqla import NestedMutationList
        mdict = NestedMutationDict({})
        assert isinstance(mdict.setdefault('bar', []), NestedMutationList)

    def test_setdefault_parent(self):
        from kotti.sqla import NestedMutationDict
        mdict = NestedMutationDict({})
        assert mdict.setdefault('bar', []).__parent__ is mdict


class TestJsonType:
    def make(self):
        from kotti.sqla import JsonType
        return JsonType()

    def test_process_bind_param_no_value(self):
        value = self.make().process_bind_param(None, None)
        assert value is None

    def test_process_bind_param_with_value(self):
        value = self.make().process_bind_param([{'foo': 'bar'}], None)
        assert value == '[{"foo": "bar"}]'

    def test_process_bind_param_with_mutationlist(self):
        from kotti.sqla import MutationList

        value = self.make().process_bind_param(
            MutationList([{'foo': 'bar'}]), None)

        assert value == '[{"foo": "bar"}]'

    def test_process_result_value_no_value(self):
        value = self.make().process_result_value(None, None)
        assert value is None

    def test_process_result_value_with_value(self):
        value = self.make().process_result_value('[{"foo": "bar"}]', None)
        assert value == [{"foo": "bar"}]


class TestACLType:
    def make(self):
        from kotti.sqla import ACLType
        return ACLType()

    def test_process_bind_param_no_value(self):
        value = self.make().process_bind_param(None, None)
        assert value is None

    def test_process_bind_param_with_value(self):
        value = self.make().process_bind_param(
            [('Allow', 'role:admin', 'edit')], None)
        assert value == '[["Allow", "role:admin", "edit"]]'

    def test_process_bind_param_with_default_permissions(self):
        acl = [('Allow', 'role:admin', ALL_PERMISSIONS)]
        value = self.make().process_bind_param(acl, None)
        assert value == '[]'

    def test_process_bind_param_with_empty_list(self):
        value = self.make().process_bind_param([], None)
        assert value == '[]'

    def test_process_bind_param_with_default_permissions_and_others(self):
        acl = [
            ('Allow', 'role:admin', ALL_PERMISSIONS),
            ('Deny', 'role:admin', 'edit'),
            ]
        value = self.make().process_bind_param(acl, None)
        assert value == '[["Deny", "role:admin", "edit"]]'
        assert self.make().process_result_value(value, None) == acl

    def test_process_result_value_no_value(self):
        value = self.make().process_result_value(None, None)
        assert value is None

    def test_process_result_value_with_value(self):
        acl = self.make().process_result_value(
            '[["Allow", "role:admin", "edit"]]', None)
        assert acl == [
            ('Allow', 'role:admin', ALL_PERMISSIONS),
            ('Allow', 'role:admin', 'edit'),
            ]


class TestMutationList:
    def test_radd(self):
        from kotti.sqla import MutationList
        mlist = MutationList(['foo'])
        assert ['bar'] + mlist == ['bar', 'foo']

########NEW FILE########
__FILENAME__ = test_static
from pytest import raises


class TestStatic:

    def test_NeededGroup(self):

        from js.deform import deform_js
        from kotti.fanstatic import kotti_js
        from kotti.fanstatic import NeededGroup

        def NeededGroupFactory(resources):
            return NeededGroup(resources)

        with raises(ValueError):
            NeededGroupFactory("foo")
        with raises(ValueError):
            NeededGroupFactory(["foo", "bar"])

        needed = NeededGroup([deform_js, ])

        assert needed.resources == [deform_js, ]

        needed.add(kotti_js)

        assert needed.resources == [deform_js, kotti_js]

        def needed_group_adder(resource):
            needed.add(resource)

        with raises(ValueError):
            needed_group_adder(42)

########NEW FILE########
__FILENAME__ = test_tags
import colander
from mock import Mock

from kotti.testing import DummyRequest


class DummyContext(object):
    view_name = u'view_name'
    tags = [u'tag 1', u'tag 2', u'tag 3']


class TestTags:
    def test_empty(self, root):
        assert root.tags == []

    def test_tags(self, db_session):
        from kotti.resources import Tag
        new_tag = Tag(title=u"test tag")
        assert str(new_tag) == "<Tag ('test tag')>"

    def test_add(self, root):
        from kotti.resources import Tag, TagsToContents

        root.tags = [u'tag 1', u'tag 2']
        result = Tag.query.filter(TagsToContents.item == root).all()
        assert result[0].items == [root]
        assert root.tags == [u'tag 1', u'tag 2']
        assert len(Tag.query.all()) == 2

    def test_edit(self, root):
        root.tags = [u'tag 1', u'tag_2']
        assert root._tags[0].tag.title == u'tag 1'
        root.tags = [u'edited tag', u'tag_2']
        assert root._tags[0].tag.title == u'edited tag'

    def test_association_proxy(self, root):
        from kotti.resources import Tag, TagsToContents, Content

        root[u'content_1'] = Content()
        root[u'content_1'].tags = [u'tag 1', u'tag 2']
        assert root[u'content_1'].tags == [u'tag 1', u'tag 2']
        assert type(root[u'content_1']._tags[0]) == TagsToContents
        assert type(root[u'content_1']._tags[0].tag) == Tag
        assert root[u'content_1']._tags[0].tag.title == u'tag 1'
        assert root[u'content_1']._tags[0].position == 0
        assert root[u'content_1']._tags[1].tag.title == u'tag 2'
        assert root[u'content_1']._tags[1].position == 1
        assert len(root[u'content_1']._tags) == 2

        root[u'content_2'] = Content()
        root[u'content_2'].tags = [u'tag 1', u'tag 3']
        assert len(root[u'content_2']._tags) == 2
        assert root[u'content_2']._tags[0].tag.title == u'tag 1'
        assert root[u'content_2']._tags[0].position == 0
        assert root[u'content_2']._tags[1].tag.title == u'tag 3'
        assert root[u'content_2']._tags[1].position == 1
        assert len(Tag.query.all()) == 3

    def test_delete_tag_doesnt_touch_content(self, root, db_session):
        from kotti.resources import Tag, Content

        root[u'content_1'] = Content()
        root[u'content_1'].tags = [u'my tag']

        assert Content.query.filter_by(name=u'content_1').count() == 1
        db_session.delete(Tag.query.filter_by(title=u'my tag').one())
        assert Content.query.filter_by(name=u'content_1').count() == 1

    def test_delete_content_deletes_orphaned_tags(self, root, events):
        from kotti.resources import Tag, Content

        root[u'content_1'] = Content()
        root[u'content_2'] = Content()
        root[u'content_1'].tags = [u'tag 1', u'tag 2']
        root[u'content_2'].tags = [u'tag 2']
        assert Tag.query.count() == 2
        del root[u'content_1']
        assert Tag.query.one().title == u'tag 2'

    def test_delete_tag_assignment_doesnt_touch_content(self, root, db_session):
        from kotti.resources import Tag, TagsToContents, Content

        root[u'content_1'] = Content()
        root[u'content_1'].tags = [u'my tag']

        assert Tag.query.count() == 1
        assert Content.query.filter_by(name=u'content_1').count() == 1
        db_session.delete(TagsToContents.query.one())
        assert Content.query.filter_by(name=u'content_1').count() == 1

    def test_delete_tag_assignment_delete_tag(self, root, events, db_session):
        from kotti.resources import Tag, TagsToContents, Content

        root[u'content_1'] = Content()
        root[u'content_1'].tags = [u'my tag']

        assert Tag.query.count() == 1
        db_session.delete(TagsToContents.query.one())
        assert Tag.query.count() == 0

    def test_copy_content_copy_tags(self, root, db_session):
        from kotti.resources import Tag, TagsToContents, Content

        root[u'content_1'] = Content()
        root[u'content_1'].tags = [u'my tag']
        assert Tag.query.count() == 1
        assert TagsToContents.query.count() == 1

        root[u'content_2'] = root[u'content_1'].copy()
        db_session.flush()
        assert root[u'content_1'].tags == [u'my tag']
        assert root[u'content_2'].tags == [u'my tag']
        assert Tag.query.count() == 1
        assert TagsToContents.query.count() == 2

    def test_cut_and_paste_content_copy_tags(self, root):
        from kotti.resources import Tag, TagsToContents, Content
        from kotti.views.edit.actions import NodeActions

        root[u'folder_1'] = Content()
        root[u'content_1'] = Content()
        root[u'content_1'].tags = [u'my tag']
        assert Tag.query.count() == 1
        assert TagsToContents.query.count() == 1

        request = DummyRequest()
        request.params['paste'] = u'on'
        request.session['kotti.paste'] = ([root[u'content_1'].id], 'cut')
        NodeActions(root[u'folder_1'], request).paste_nodes()
        assert root[u'folder_1'][u'content_1'].tags == [u'my tag']
        assert Tag.query.count() == 1
        assert TagsToContents.query.count() == 1

    def test_copy_and_paste_content_copy_tags(self, root, events):
        from kotti.resources import Tag, TagsToContents, Content
        from kotti.views.edit.actions import NodeActions

        root[u'folder_1'] = Content()
        root[u'content_1'] = Content()
        root[u'content_1'].tags = [u'my tag']
        assert Tag.query.count() == 1
        assert TagsToContents.query.count() == 1

        request = DummyRequest()
        request.params['paste'] = u'on'
        request.session['kotti.paste'] = ([root[u'content_1'].id], 'copy')
        NodeActions(root[u'folder_1'], request).paste_nodes()
        assert root[u'content_1'].tags == [u'my tag']
        assert root[u'folder_1'][u'content_1'].tags == [u'my tag']
        assert Tag.query.count() == 1
        assert TagsToContents.query.count() == 2

    def test_delete_content_delete_tags_and_assignments(self, root, events):
        from kotti.resources import Tag, TagsToContents, Content
        from kotti.views.edit.actions import NodeActions

        root[u'folder_1'] = Content()
        root[u'folder_1'].tags = [u'first tag']
        root[u'folder_1'][u'content_1'] = Content()
        root[u'folder_1'][u'content_1'].tags = [u'second tag']
        root[u'folder_1'][u'content_2'] = Content()
        root[u'folder_1'][u'content_2'].tags = [u'third tag']
        assert Tag.query.count() == 3
        assert TagsToContents.query.count() == 3

        request = DummyRequest()
        request.POST['delete'] = 'on'
        NodeActions(root[u'folder_1'], request).delete_node()
        assert Tag.query.count() == 0
        assert TagsToContents.query.count() == 0

    def test_get_content_items_from_tag(self, root):
        from kotti.resources import Tag, Content

        root[u'folder_1'] = Content()
        root[u'folder_1'].tags = [u'first tag', u'second tag']
        root[u'folder_1'][u'content_1'] = Content()
        root[u'folder_1'][u'content_1'].tags = [u'third tag']
        root[u'folder_1'][u'content_2'] = Content()
        root[u'folder_1'][u'content_2'].tags = [u'first tag', u'third tag']
        first_tag = Tag.query.filter(Tag.title == u'first tag').one()
        assert [rel.name for rel in first_tag.items] == [
            u'folder_1', u'content_2']
        second_tag = Tag.query.filter(Tag.title == u'second tag').one()
        assert [rel.name for rel in second_tag.items] == [u'folder_1']
        third_tag = Tag.query.filter(Tag.title == u'third tag').one()
        assert [rel.name for rel in third_tag.items] == [
            u'content_1', u'content_2']

    def test_get_content_items_for_tag_title(self, root):
        from kotti.resources import Tag, TagsToContents, Content
        from kotti.views.util import content_with_tags

        root[u'folder_1'] = Content()
        root[u'folder_1'].tags = [u'first tag', u'second tag']
        root[u'folder_1'][u'content_1'] = Content()
        root[u'folder_1'][u'content_1'].tags = [u'third tag']
        root[u'folder_1'][u'content_2'] = Content()
        root[u'folder_1'][u'content_2'].tags = [u'first tag', u'third tag']

        result = Content.query.join(TagsToContents).join(Tag).filter(
            Tag.title == u'first tag').all()
        assert [res.name for res in result] == [u'folder_1', u'content_2']
        result = Content.query.join(TagsToContents).join(Tag).filter(
            Tag.title == u'second tag').all()
        assert [res.name for res in result] == [u'folder_1']
        result = Content.query.join(TagsToContents).join(Tag).filter(
            Tag.title == u'third tag').all()
        assert [res.name for res in result] == [u'content_1', u'content_2']

        # The same tests again, using content_with_tags():
        #
        #     About expected sort order:
        #
        #         In the first set of tests below, where we search by single
        #         tags, the query in the content_with_tags() function returns
        #         results in hierarchical order, from root.
        #
        # content_with_tags() is written to take a list of tags, but in the
        # default Kotti, presently, after some consideration about specialized
        # add-ons for searching, we do not support multiple tags searching, in
        # part to avoid establishing a specification.
        #
        result = content_with_tags([u'first tag'])
        assert [res.name for res in result] == [u'folder_1', u'content_2']
        result = content_with_tags([u'second tag'])
        assert [res.name for res in result] == [u'folder_1']
        result = content_with_tags([u'third tag'])
        assert [res.name for res in result] == [u'content_1', u'content_2']


class TestCommaSeparatedListWidget:
    def make_one(self):
        from kotti.views.form import CommaSeparatedListWidget
        return CommaSeparatedListWidget(template='')

    def test_widget_serialize_none(self):
        field = Mock()
        widget = self.make_one()
        widget.serialize(field, None)
        field.renderer.assert_called_with(
            widget.template, field=field, cstruct=[])

    def test_widget_serialize_null(self):
        field = Mock()
        widget = self.make_one()
        widget.serialize(field, colander.null)
        field.renderer.assert_called_with(
            widget.template, field=field, cstruct=[])

    def test_widget_serialize(self):
        field = Mock()
        widget = self.make_one()
        widget.serialize(field, ['yes'])
        field.renderer.assert_called_with(
            widget.template, field=field, cstruct=['yes'])

    def test_widget_deserialize_null(self):
        assert (self.make_one().deserialize(None, colander.null) ==
                colander.null)

    def test_widget_deserialize(self):
        assert self.make_one().deserialize(None, 'foo,bar') == ['foo', 'bar']

########NEW FILE########
__FILENAME__ = test_upload
# -*- coding: utf-8 -*-

import json

from mechanize._mechanize import LinkNotFoundError
from pytest import raises

from kotti.testing import BASE_URL
from kotti.testing import user
from kotti.views.edit.upload import UploadView


def test_upload_anonymous(root, dummy_request, browser):

    view = UploadView(root, dummy_request)

    assert view.factories == []

    link = browser.getLink

    browser.open('%s/' % BASE_URL)

    # There must be no Upload Link for anonymous users
    with raises(LinkNotFoundError):
        link('Upload Content').click()

    # Upload views must redirect to login for anonymous users
    browser.open('%s/upload' % BASE_URL)
    assert browser.url.startswith('%s/@@login' % BASE_URL)

    browser.open('%s/content_types' % BASE_URL)
    assert browser.url.startswith('%s/@@login' % BASE_URL)

    # import pdb; pdb.set_trace()


@user('admin')
def test_upload_authenticated_wo_mimetype(root, dummy_request, browser):

    # cannot call content_types without mimetype
    with raises(KeyError):
        browser.open('%s/content_types' % BASE_URL)


@user('admin')
def test_upload_authenticated_text(root, dummy_request, browser):

    # get possible content types for text/plain
    browser.open('%s/content_types?mimetype=text/plain' % BASE_URL)
    j = json.loads(browser.contents)
    assert 'content_types' in j

    # only files are allowed
    types = j['content_types']
    assert len(types) == 1
    assert types[0]['name'] == u'File'


@user('admin')
def test_upload_authenticated_image(root, dummy_request, browser):

    link = browser.getLink

    # get possible content types for image/png
    browser.open('%s/content_types?mimetype=image/png' % BASE_URL)
    j = json.loads(browser.contents)
    assert 'content_types' in j

    # images and files are allowed
    types = j['content_types']
    assert len(types) == 2

    # images must be first
    assert types[0]['name'] == u'Image'
    assert types[1]['name'] == u'File'

    # Open the upload 'form'
    browser.open('%s/' % BASE_URL)
    link('Upload Content').click()
    assert 'Select file(s) to upload' in browser.contents

########NEW FILE########
__FILENAME__ = test_util
from mock import Mock
from mock import patch


class TestRequestCache(object):

    @property
    def cache_decorator(self):
        from kotti.util import request_cache
        return request_cache

    def test_it(self, dummy_request):
        from kotti.util import clear_cache

        called = []

        @self.cache_decorator(lambda a, b: (a, b))
        def my_fun(a, b):
            called.append((a, b))

        my_fun(1, 2)
        my_fun(1, 2)
        assert len(called) == 1
        my_fun(2, 1)
        assert len(called) == 2

        clear_cache()
        my_fun(1, 2)
        assert len(called) == 3

    def test_dont_cache(self, dummy_request):
        from kotti.util import DontCache
        called = []

        def dont_cache(a, b):
            raise DontCache

        @self.cache_decorator(dont_cache)
        def my_fun(a, b):
            called.append((a, b))

        my_fun(1, 2)
        my_fun(1, 2)
        assert len(called) == 2


class TestLRUCache(TestRequestCache):

    @property
    def cache_decorator(self):
        from kotti.util import lru_cache
        return lru_cache


class TestTitleToName:
    def setUp(self):
        from pyramid.threadlocal import get_current_registry
        from kotti.url_normalizer import url_normalizer
        r = get_current_registry()
        settings = r.settings = {}
        settings['kotti.url_normalizer'] = [url_normalizer]
        settings['kotti.url_normalizer.map_non_ascii_characters'] = False

    def test_max_length(self):
        self.setUp()
        from kotti.util import title_to_name
        assert len(title_to_name(u'a' * 50)) == 40

    def test_normal(self):
        self.setUp()
        from kotti.util import title_to_name
        assert title_to_name(u'Foo Bar') == u'foo-bar'

    def test_disambiguate_name(self):
        from kotti.util import disambiguate_name
        assert disambiguate_name(u'foo') == u'foo-1'
        assert disambiguate_name(u'foo-3') == u'foo-4'


class TestCommand:
    def test_it(self):
        from kotti.util import command

        func = Mock()
        closer = Mock()
        with patch('kotti.util.docopt') as docopt:
            with patch('kotti.util.bootstrap') as bootstrap:
                docopt.return_value = {'<config_uri>': 'uri'}
                bootstrap.return_value = {'closer': closer}
                assert command(func, 'doc') == 0
                func.assert_called_with({'<config_uri>': 'uri'})
                docopt.assert_called_with('doc')
                bootstrap.assert_called_with('uri')
                assert closer.call_count == 1


class TestTemplateStructure:
    def test_getattr(self):
        from kotti.util import TemplateStructure

        item = TemplateStructure(u'123')
        assert item.split('2') == [u'1', u'3']

########NEW FILE########
__FILENAME__ = test_util_views
import time

from mock import patch
from mock import MagicMock
from pyramid.request import Response
from pytest import raises

from kotti.testing import Dummy
from kotti.testing import DummyRequest


# filter deprecation warnings for code that is still tested...
from warnings import filterwarnings
filterwarnings('ignore', '^kotti.views.slots.register is deprecated')


def create_contents(root):
    from kotti.resources import Content

    # root -> a --> aa
    #         |
    #         \ --> ab
    #         |
    #         \ --> ac --> aca
    #               |
    #               \ --> acb

    a = root['a'] = Content()
    aa = root['a']['aa'] = Content()
    ab = root['a']['ab'] = Content()
    ac = root['a']['ac'] = Content()
    aca = ac['aca'] = Content()
    acb = ac['acb'] = Content()
    return a, aa, ab, ac, aca, acb


class TestTemplateAPI:
    def make(self, context=None, request=None, id=1, **kwargs):
        from kotti.resources import get_root
        from kotti.views.util import TemplateAPI

        if context is None:
            context = get_root()
        if request is None:
            request = DummyRequest()
        return TemplateAPI(context, request, **kwargs)

    def test_page_title(self, db_session):
        api = self.make()
        api.context.title = u"Hello, world!"
        assert api.page_title == u"Hello, world! - Hello, world!"

        api = self.make()
        api.context.title = u"Hello, world!"
        api.site_title = u"Wasnhierlos"
        assert api.page_title == u"Hello, world! - Wasnhierlos"

    def test_site_title(self, db_session):
        with patch('kotti.views.util.get_settings',
                   return_value={'kotti.site_title': u'This is it.'}):
            api = self.make()
            assert api.site_title == u'This is it.'

    def test_list_children(self, db_session):
        api = self.make()  # the default context is root
        root = api.context
        assert len(api.list_children(root)) == 0

        # Now try it on a little graph:
        a, aa, ab, ac, aca, acb = create_contents(root)
        with patch('kotti.views.util.has_permission', return_value=True):
            assert api.list_children() == [a]
            assert api.list_children(root) == [a]
            assert api.list_children(a) == [aa, ab, ac]
            assert api.list_children(aca) == []

        # Try permissions
        with patch('kotti.views.util.has_permission') as has_permission:
            has_permission.return_value = False
            assert api.list_children(root) == []
            has_permission.assert_called_once_with('view', a, api.request)

        with patch('kotti.views.util.has_permission') as has_permission:
            has_permission.return_value = False
            assert api.list_children(root, permission='edit') == []
            has_permission.assert_called_once_with('edit', a, api.request)

    def test_root(self, db_session):
        api = self.make()
        root = api.context
        a, aa, ab, ac, aca, acb = create_contents(root)
        assert self.make().root == root
        assert self.make(acb).root == root

    def test_navigation_root(self, db_session):
        from zope.interface import alsoProvides
        from kotti.interfaces import INavigationRoot

        api = self.make()
        root = api.context
        a, aa, ab, ac, aca, acb = create_contents(root)
        assert self.make().navigation_root == root
        assert self.make(acb).navigation_root == root

        alsoProvides(a, INavigationRoot)
        assert self.make(acb).navigation_root == a

    def test_breadcrumbs(self, db_session):
        api = self.make()
        root = api.context
        a, aa, ab, ac, aca, acb = create_contents(root)
        api.context = acb
        breadcrumbs = [b for b in api.breadcrumbs]
        assert breadcrumbs == [root, a, ac, acb]

    def test_breadcrumbs_with_navigation_root(self, db_session):
        from zope.interface import alsoProvides
        from kotti.interfaces import INavigationRoot

        api = self.make()
        root = api.context
        a, aa, ab, ac, aca, acb = create_contents(root)
        api.context = acb
        alsoProvides(a, INavigationRoot)
        breadcrumbs = [b for b in api.breadcrumbs]
        assert breadcrumbs == [a, ac, acb]

    def test_has_permission(self, db_session):
        with patch('kotti.views.util.has_permission') as has_permission:
            api = self.make()
            api.has_permission('drink')
            has_permission.assert_called_with('drink', api.root, api.request)

    def test_edit_links(self, config, db_session):
        from kotti.views.edit import actions, content, default_views
        from kotti.views import users
        from kotti.util import Link

        api = self.make()
        config.include(actions)
        config.include(content)
        config.include(default_views)
        config.include(users)

        assert (api.edit_links[:3] == [
            Link('contents', u'Contents'),
            Link('edit', u'Edit'),
            Link('share', u'Share'),
            ])

        # Edit links are controlled through
        # 'root.type_info.edit_links' and the permissions that guard
        # these:
        class MyLink(Link):
            permit = True

            def permitted(self, context, request):
                return self.permit

        open_link = MyLink('open')
        secure_link = MyLink('secure')
        secure_link.permit = False

        root = api.root
        root.type_info = root.type_info.copy(
            edit_links=[open_link, secure_link])
        api = self.make()
        assert api.edit_links == [open_link]

    def test_find_edit_view_not_permitted(self, db_session):
        with patch('kotti.views.util.view_permitted', return_value=False):
            api = self.make()
            api.request.view_name = u'edit'
            assert api.find_edit_view(api.context) == u''

    def test_find_edit_view(self, db_session):
        with patch('kotti.views.util.view_permitted', return_value=True):
            api = self.make()
            api.request.view_name = u'share'
            assert api.find_edit_view(api.context) == u'share'

    def test_macro(self, db_session):
        with patch('kotti.views.util.get_renderer') as get_renderer:
            get_renderer().implementation().macros = MagicMock()
            api = self.make()
            macro = api.macro('mypackage:mytemplate.pt')
            get_renderer.assert_called_with('mypackage:mytemplate.pt')
            assert get_renderer().implementation().macros['main'] == macro

    def test_macro_bare_with_master(self, db_session):
        # getting EDIT_MASTER when bare=True will return BARE_MASTER
        with patch('kotti.views.util.get_renderer') as get_renderer:
            get_renderer().implementation().macros = MagicMock()
            api = self.make(bare=True)
            macro = api.macro(api.EDIT_MASTER)
            get_renderer.assert_called_with(api.BARE_MASTER)
            assert get_renderer().implementation().macros['main'] == macro

    def test_macro_bare_without_master(self, db_session):
        # getting other templates when bare=True
        with patch('kotti.views.util.get_renderer') as get_renderer:
            get_renderer().implementation().macros = MagicMock()
            api = self.make(bare=True)
            macro = api.macro('mypackage:mytemplate.pt')
            get_renderer.assert_called_with('mypackage:mytemplate.pt')
            assert get_renderer().implementation().macros['main'] == macro

    def test_url_without_context(self, db_session):
        context, request = object(), MagicMock()
        api = self.make(context=context, request=request)
        api.url()
        request.resource_url.assert_called_with(context)

    def test_url_with_context(self, db_session):
        context, request = object(), MagicMock()
        api = self.make(request=request)
        api.url(context)
        request.resource_url.assert_called_with(context)

    def test_url_with_context_and_elements(self, db_session):
        context, request = object(), MagicMock()
        api = self.make(request=request)
        api.url(context, 'first', second='second')
        request.resource_url.assert_called_with(
            context, 'first', second='second')

    def test_bare(self, db_session):
        # By default, no "bare" templates are used:
        api = self.make()
        assert api.bare is None

        # We can ask for "bare" templates explicitely:
        api = self.make(bare=True)
        assert api.bare is True

        # An XHR request will always result in bare master templates:
        request = DummyRequest()
        request.is_xhr = True
        api = self.make(request=request)
        assert api.bare is True

        # unless overridden:
        api = self.make(request=request, bare=False)
        assert api.bare is False

    def test_assign_to_slots(self, config, db_session, events):
        from kotti.views.slots import assign_slot

        def foo(context, request):
            greeting = request.POST['greeting']
            return Response(u"{0} world!".format(greeting))
        config.add_view(foo, name='foo')
        assign_slot('foo', 'left', params=dict(greeting=u"Y\u0153"))

        api = self.make()
        assert api.slots.left == [u"Y\u0153 world!"]

    def test_assign_to_slot_predicate_mismatch(self, config, db_session,
                                               events):
        from kotti.views.slots import assign_slot

        def special(context, request):
            return Response(u"Hello world!")
        assign_slot('special', 'right')

        config.add_view(special, name='special', request_method="GET")
        api = self.make()
        assert api.slots.right == []

        config.add_view(special, name='special')
        api = self.make()
        assert api.slots.right == [u"Hello world!"]

    def test_assign_slot_bad_name(self):
        from kotti.views.slots import assign_slot

        with raises(KeyError):
            assign_slot('viewname', 'noslotlikethis')

    def test_slot_request_has_attributes(self, config, db_session, events):
        from kotti.views.slots import assign_slot

        def my_viewlet(request):
            assert hasattr(request, 'registry')
            assert hasattr(request, 'context')
            assert hasattr(request, 'user')
            return Response(u"Hello world!")
        assign_slot('my-viewlet', 'right')

        config.add_view(my_viewlet, name='my-viewlet')
        api = self.make()
        assert api.slots.right == [u"Hello world!"]

    def test_slot_request_has_parameters(self, config, db_session):
        from kotti.views.slots import assign_slot

        def foo(context, request):
            bar = request.POST['bar']
            return Response(u"{0} world!".format(bar))
        config.add_view(foo, name='foo')
        assign_slot('foo', 'left', params=dict(greeting=u"Y\u0153"))

        request = DummyRequest()
        request.params['bar'] = u'Hello'
        api = self.make(request=request)
        assert api.slots.left == [u"Hello world!"]

    def test_slot_view_know_slot(self, config, db_session):
        from kotti.views.slots import assign_slot

        def foo(context, request):
            slot = request.kotti_slot
            return Response(u"I'm in slot {0}.".format(slot))
        config.add_view(foo, name='foo')
        assign_slot('foo', 'beforebodyend')
        assign_slot('foo', 'right')

        request = DummyRequest()
        api = self.make(request=request)
        assert api.slots.beforebodyend == [u"I'm in slot beforebodyend."]
        assert api.slots.right == [u"I'm in slot right."]

    # def test_deprecated_slots(self, db_session):
    #     from kotti.views.slots import register, RenderAboveContent

    #     def render_something(context, request):
    #         return u"Hello, %s!" % context.title
    #     register(RenderAboveContent, None, render_something)

    #     api = self.make()
    #     assert (api.slots.abovecontent == [u'Hello, %s!' % api.context.title])

    #     # Slot renderers may also return lists:
    #     def render_a_list(context, request):
    #         return [u"a", u"list"]
    #     register(RenderAboveContent, None, render_a_list)
    #     api = self.make()
    #     assert (
    #         api.slots.abovecontent ==
    #         [u'Hello, %s!' % api.context.title, u'a', u'list']
    #         )

    #     with raises(AttributeError):
    #         api.slots.foobar

    def test_slots_only_rendered_when_accessed(self, config, events):
        from kotti.views.slots import assign_slot

        called = []

        def foo(context, request):
            called.append(True)
            return Response(u"")

        config.add_view(foo, name='foo')
        assign_slot('foo', 'abovecontent')

        api = self.make()
        api.slots.belowcontent
        assert called == []

        api.slots.abovecontent
        assert len(called) == 1
        api.slots.abovecontent
        assert len(called) == 1

    def test_format_datetime(self, db_session):
        import datetime
        from babel.dates import format_datetime
        from babel.core import UnknownLocaleError
        api = self.make()
        first = datetime.datetime(2012, 1, 1, 0)
        assert (
            api.format_datetime(first) ==
            format_datetime(first, format='medium', locale='en'))
        assert (
            api.format_datetime(time.mktime(first.timetuple())) ==
            format_datetime(first, format='medium', locale='en'))
        assert (
            api.format_datetime(first, format='short') ==
            format_datetime(first, format='short', locale='en'))
        api.locale_name = 'unknown'
        with raises(UnknownLocaleError):
            api.format_datetime(first)

    def test_format_date(self, db_session):
        import datetime
        from babel.dates import format_date
        from babel.core import UnknownLocaleError
        api = self.make()
        first = datetime.date(2012, 1, 1)
        assert (
            api.format_date(first) ==
            format_date(first, format='medium', locale='en'))
        assert (
            api.format_date(first, format='short') ==
            format_date(first, format='short', locale='en'))
        api.locale_name = 'unknown'
        with raises(UnknownLocaleError):
            api.format_date(first)

    def test_format_time(self, db_session):
        import datetime
        from babel.dates import format_time
        from babel.core import UnknownLocaleError
        api = self.make()
        first = datetime.time(23, 59)
        assert (
            api.format_time(first) ==
            format_time(first, format='medium', locale='en'))
        assert (
            api.format_time(first, format='short') ==
            format_time(first, format='short', locale='en'))
        api.locale_name = 'unknown'
        with raises(UnknownLocaleError):
            api.format_time(first)

    def test_render_view(self, config, db_session):
        def first_view(context, request):
            return Response(u'first')

        def second_view(context, request):
            return Response(u'second')

        config.add_view(first_view, name='')
        config.add_view(second_view, name='second')
        api = self.make()
        assert api.render_view().__unicode__() == u'first'
        assert api.render_view('second').__unicode__() == u'second'
        assert api.render_view(
            context=api.context, request=api.request).__unicode__() == u'first'

    def test_render_template(self, config, db_session):
        renderer = MagicMock()
        config.testing_add_renderer('my-rendererer', renderer)
        api = self.make()
        api.render_template('my-rendererer', some='variable')
        assert renderer.call_args[0][0] == {'some': 'variable'}

    def test_get_type(self, db_session):
        from kotti.resources import Document
        api = self.make()
        assert api.get_type('Document') == Document
        assert api.get_type('NoExist') is None

    def test_avatar_url(self, db_session):
        api = self.make()
        user = Dummy(email='daniel.nouri@gmail.com')
        result = api.avatar_url(user)
        assert result.startswith('https://secure.gravatar.com/avatar/'
                                 'd3aeefdd7afe103ab70875172135cab7')

    def test_avatar_url_request_user(self, db_session):
        api = self.make()
        api.request.user = Dummy(email='daniel.nouri@gmail.com')
        result = api.avatar_url()
        assert result.startswith('https://secure.gravatar.com/avatar/'
                                 'd3aeefdd7afe103ab70875172135cab7')


class TestViewUtil:
    def test_add_renderer_globals_json(self):
        from kotti.views.util import add_renderer_globals

        event = {'renderer_name': 'json'}
        add_renderer_globals(event)
        assert event.keys() == ['renderer_name']

    def test_add_renderer_globals_request_has_template_api(self):
        from kotti.views.util import add_renderer_globals

        request = DummyRequest()
        request.template_api = template_api = object()
        event = {'request': request, 'renderer_name': 'foo'}
        add_renderer_globals(event)
        assert event['api'] is template_api

    def test_add_renderer_globals(self, db_session):
        from kotti.views.util import add_renderer_globals

        request = DummyRequest()
        event = {
            'request': request,
            'context': object(),
            'renderer_name': 'foo', }
        add_renderer_globals(event)
        assert 'api' in event


class TestLocalNavigationSlot:
    def test_it(self, config, root):
        config.testing_add_renderer('kotti:templates/view/nav-local.pt')
        from zope.interface import alsoProvides
        from kotti.interfaces import INavigationRoot
        from kotti.views.navigation import local_navigation
        a, aa, ab, ac, aca, acb = create_contents(root)

        ret = local_navigation(ac, DummyRequest())
        assert ret == dict(parent=ac, children=[aca, acb])

        ret = local_navigation(acb, DummyRequest())
        assert ret == dict(parent=ac, children=[aca, acb])

        assert local_navigation(a.__parent__, DummyRequest())['parent'] is None

        alsoProvides(ac, INavigationRoot)
        assert local_navigation(ac, DummyRequest())['parent'] is None

    def test_no_permission(self, config, root):
        config.testing_add_renderer('kotti:templates/view/nav-local.pt')
        from kotti.views.navigation import local_navigation
        a, aa, ab, ac, aca, acb = create_contents(root)

        with patch('kotti.views.navigation.has_permission', return_value=True):
            assert local_navigation(ac, DummyRequest())['parent'] is not None

        with patch('kotti.views.navigation.has_permission', return_value=False):
            assert local_navigation(ac, DummyRequest())['parent'] is None

    def test_in_navigation(self, config, root):
        config.testing_add_renderer('kotti:templates/view/nav-local.pt')
        from kotti.views.navigation import local_navigation
        a, aa, ab, ac, aca, acb = create_contents(root)

        assert local_navigation(a, DummyRequest())['parent'] is not None
        aa.in_navigation = False
        ab.in_navigation = False
        ac.in_navigation = False
        assert local_navigation(a, DummyRequest())['parent'] is None


class TestNodesTree:
    def test_it(self, root):
        from kotti.views.util import nodes_tree

        a, aa, ab, ac, aca, acb = create_contents(root)
        aa.in_navigation = False  # nodes_tree doesn't care
        tree = nodes_tree(DummyRequest())
        assert tree.id == a.__parent__.id
        assert [ch.name for ch in tree.children] == [a.name]
        assert [ch.id for ch in tree.children[0].children] == [
            aa.id, ab.id, ac.id]

    def test_ordering(self, root):
        from kotti.views.util import nodes_tree

        a, aa, ab, ac, aca, acb = create_contents(root)
        a.children.insert(1, a.children.pop(0))
        tree = nodes_tree(DummyRequest())
        assert [ch.position for ch in tree.children[0].children] == [
            0, 1, 2]
        assert [ch.id for ch in tree.children[0].children] == [
            ab.id, aa.id, ac.id]

    def test_tolist(self, root):
        from kotti.views.util import nodes_tree

        a, aa, ab, ac, aca, acb = create_contents(root)
        tree = nodes_tree(DummyRequest(), context=a)
        assert [ch for ch in tree.tolist()] == [a, aa, ab, ac, aca, acb]

        tree = nodes_tree(DummyRequest(), context=ac)
        assert [ch for ch in tree.tolist()] == [ac, aca, acb]

########NEW FILE########
__FILENAME__ = test_views_form
import colander
from mock import patch
from mock import MagicMock

from kotti.testing import Dummy
from kotti.testing import DummyRequest


class TestBaseFormView:
    def make(self):
        from kotti.views.form import BaseFormView
        return BaseFormView(Dummy(), DummyRequest())

    def test_init(self):
        from kotti.views.form import BaseFormView
        view = BaseFormView(Dummy(), DummyRequest(), more='args')
        assert view.more == 'args'

    def test_schema_factory_bind(self):
        view = self.make()
        schema = MagicMock()
        view.schema_factory = lambda: schema
        view.__call__()
        assert view.schema == schema.bind.return_value
        schema.bind.assert_called_with(request=view.request)

    def test_use_csrf_token(self):
        view = self.make()
        schema = view.schema = MagicMock()
        view.__call__()
        assert schema.children.append.called
        assert schema.children.append.call_args[0][0].name == 'csrf_token'

    def test_use_csrf_token_not(self):
        view = self.make()
        view.use_csrf_token = False
        schema = view.schema = MagicMock()
        view.__call__()
        assert not schema.children.append.called


class TestGetAppstruct:
    def call(self, *args, **kwargs):
        from kotti.views.form import get_appstruct
        return get_appstruct(*args, **kwargs)

    def test_schema_has_more_children_than_attrs(self):
        context = Dummy(first='firstvalue')
        schema = Dummy(children=[Dummy(name='first'), Dummy(name='second')])
        assert self.call(context, schema) == {'first': 'firstvalue'}

    def test_schema_has_fewer_children_than_attrs(self):
        context = Dummy(first='firstvalue', second='secondvalue')
        schema = Dummy(children=[Dummy(name='first')])
        assert self.call(context, schema) == {'first': 'firstvalue'}

    def test_none_converted_to_null(self):
        context = Dummy(first=None)
        schema = Dummy(children=[Dummy(name='first')])
        assert self.call(context, schema) == {'first': colander.null}


class TestEditFormView:
    def make(self):
        from kotti.views.form import EditFormView
        return EditFormView(
            Dummy(), DummyRequest(), success_url='http://localhost')

    def test_before(self):
        view = self.make()
        view.context.three = 3
        view.schema = Dummy()
        view.schema.children = [Dummy(name='three')]
        form = Dummy()
        view.before(form)
        assert form.appstruct == {'three': 3}

    def test_save_success_calls_edit(self):
        view = self.make()
        view.edit = MagicMock()
        view.save_success({'three': 3})
        view.edit.assert_called_with(three=3)

    def test_save_success_redirects(self):
        view = self.make()
        result = view.save_success({'three': 3})
        assert result.status == '302 Found'
        assert result.location == view.success_url

    def test_save_success_redirects_to_resource_url(self):
        view = self.make()
        view.success_url = None
        view.request.resource_url = lambda context: context.__class__.__name__
        result = view.save_success({'three': 3})
        assert result.status == '302 Found'
        assert result.location == 'Dummy'


class TestAddFormView:
    def make(self):
        from kotti.views.form import AddFormView
        return AddFormView(Dummy(), DummyRequest())

    def test_save_success_calls_add(self):
        view = self.make()
        view.add = MagicMock()
        view.find_name = lambda appstruct: 'somename'
        view.request.resource_url = lambda context: u''
        view.save_success({'three': 3})
        view.add.assert_called_with(three=3)
        assert view.add.return_value == view.context['somename']

    def test_save_success_redirects(self):
        view = self.make()
        view.add = MagicMock()
        view.find_name = lambda appstruct: 'somename'
        view.request.resource_url = lambda context: u'MagicMock'
        result = view.save_success({'three': 3})
        assert result.status == '302 Found'
        assert result.location == 'MagicMock'

    def test_save_success_redirects_custom_url(self):
        view = self.make()
        view.add = MagicMock()
        view.success_url = 'there'
        view.find_name = lambda appstruct: 'somename'
        result = view.save_success({'three': 3})
        assert result.status == '302 Found'
        assert result.location == 'there'

    @patch('kotti.views.form.title_to_name')
    def test_find_name_uses_title_to_name(self, title_to_name):
        view = self.make()
        title_to_name.return_value = 'cafe'
        assert view.find_name({'title': 'Bar'}) == 'cafe'
        title_to_name.assert_called_with('Bar', blacklist=[])

########NEW FILE########
__FILENAME__ = test_workflow
from mock import patch
from pyramid.security import ALL_PERMISSIONS

from kotti.testing import Dummy


class TestWorkflow:

    def test_workflow_callback(self):
        from kotti.workflow import workflow_callback

        context = Dummy(__acl__=[])
        info = Dummy()
        info.transition = {"to_state": "next_state"}
        info.workflow = Dummy()
        info.workflow.initial_state = 'bar'
        info.workflow._state_data = {
            "next_state": {
                "role:me": "myfirstpermission mysecondpermission",
                "role:you": " \t yourpermission ",
                },
            }
        workflow_callback(context, info)

        assert sorted(context.__acl__) == [
            ('Allow', 'role:me', 'myfirstpermission'),
            ('Allow', 'role:me', 'mysecondpermission'),
            ('Allow', 'role:you', 'yourpermission'),
            ('Deny', 'system.Everyone', ALL_PERMISSIONS),
            ]

    def test_workflow_callback_with_inheritance(self):
        from kotti.workflow import workflow_callback

        context = Dummy(__acl__=[])
        info = Dummy()
        info.transition = {"to_state": "next_state"}
        info.workflow = Dummy()
        info.workflow.initial_state = 'bar'
        info.workflow._state_data = {
            "next_state": {
                "role:me": "myfirstpermission mysecondpermission",
                "role:you": " \t yourpermission ",
                "inherit": "true",
                },
            }
        workflow_callback(context, info)

        assert sorted(context.__acl__) == [
            ('Allow', 'role:me', 'myfirstpermission'),
            ('Allow', 'role:me', 'mysecondpermission'),
            ('Allow', 'role:you', 'yourpermission'),
            ]

    def test_workflow_callback_event(self):
        from kotti.events import listeners
        from kotti.events import ObjectEvent
        from kotti.workflow import workflow_callback
        from kotti.workflow import WorkflowTransition

        events = []
        my_listener = lambda event: events.append(event)
        listeners[WorkflowTransition].append(my_listener)

        context = Dummy()
        info = Dummy()
        info.transition = {"to_state": "next_state"}
        info.workflow = Dummy()
        info.workflow.initial_state = 'bar'
        info.workflow._state_data = {"next_state": {}}
        workflow_callback(context, info)

        assert len(events) == 1
        [event] = events
        assert event.object is context
        assert event.info is info
        assert isinstance(event, ObjectEvent)


@patch('kotti.workflow.transaction.commit')
class TestResetWorkflow:
    def call(self, *args, **kwargs):
        from kotti.workflow import reset_workflow
        return reset_workflow(*args, **kwargs)

    def test_workflow_reset_calls(self, commit):
        objs = [Dummy(), Dummy()]

        with patch('kotti.workflow.get_workflow') as get_workflow:
            wf = get_workflow.return_value
            self.call(objs)
            assert wf.reset.call_count == 2
            assert wf.reset.call_args_list[0][0][0] is objs[0]
            assert wf.reset.call_args_list[1][0][0] is objs[1]

    def test_reset_purge_existing(self, commit):
        dummy = Dummy(state='partying')
        self.call([dummy], purge_existing=True)
        assert dummy.state is None

    def test_reset_no_purge(self, commit):
        dummy = Dummy(state='partying')
        self.call([dummy], purge_existing=False)
        assert dummy.state == 'partying'


@patch('kotti.workflow.transaction.commit')
class TestResetWorkflowCommand:
    def test_it(self, commit):
        from kotti.workflow import reset_workflow_command

        with patch('kotti.workflow.command') as command:
            with patch('kotti.workflow.reset_workflow') as reset_workflow:
                reset_workflow_command()
                func, doc = command.call_args[0]
                func({'--purge-existing': True})
                reset_workflow.assert_called_with(purge_existing=True)


class TestDefaultWorkflow:
    def make_document(self, root):
        from kotti import DBSession
        from kotti.resources import Document

        content = root['document'] = Document()
        DBSession.flush()
        DBSession.refresh(content)
        return content

    def test_workflow_root(self, root, workflow):
        from kotti.workflow import get_workflow

        wf = get_workflow(root)
        assert wf.name == u'simple'
        assert root.state == u'public'

    def test_workflow_new_content(self, root, workflow, events):
        from kotti.workflow import get_workflow

        content = self.make_document(root)
        wf = get_workflow(content)
        assert wf.name == u'simple'
        assert content.state == u'private'
        assert content.__acl__[0] == (
            'Allow', 'role:admin', ALL_PERMISSIONS)
        assert content.__acl__[-1] == (
            'Deny', 'system.Everyone', ALL_PERMISSIONS)

    def test_workflow_transition(self, root, workflow, events):
        from kotti.workflow import get_workflow
        content = self.make_document(root)
        wf = get_workflow(content)
        wf.transition_to_state(content, None, u'public')
        assert content.state == u'public'

    def test_reset_workflow(self, root, workflow, events):
        from kotti.workflow import get_workflow
        from kotti.workflow import reset_workflow

        content = self.make_document(root)
        wf = get_workflow(content)
        wf.transition_to_state(content, None, u'public')
        assert content.state == u'public'
        save_acl = content.__acl__
        content.__acl__ = []
        with patch('kotti.workflow.transaction.commit'):
            reset_workflow()
        assert content.state == u'public'
        assert len(content.__acl__) == len(save_acl)

    def test_reset_workflow_purge_existing(self, root, workflow, events):
        from kotti.workflow import get_workflow
        from kotti.workflow import reset_workflow

        content = self.make_document(root)
        wf = get_workflow(content)
        wf.transition_to_state(content, None, u'public')
        assert content.state == u'public'
        with patch('kotti.workflow.transaction.commit'):
            reset_workflow(purge_existing=True)
        assert content.state == u'private'


class TestContentExtensibleWithWorkflow:

    def test_add_wf_interface_to_content(self, workflow):
        from zope import interface
        from kotti.resources import Content
        from kotti.workflow import get_workflow
        from kotti.interfaces import IDefaultWorkflow

        content = Content()
        assert get_workflow(content) == None
        assert content.state == None

        interface.directlyProvides(content, IDefaultWorkflow)
        wf = get_workflow(content)
        wf.transition_to_state(content, None, u'public')
        assert content.state == u'public'

########NEW FILE########
__FILENAME__ = url_normalizer
# encoding=utf-8
from kotti import get_settings
from kotti.url_normalizer import url_normalizer


class URLNormalizerTests:

    def test_normalizer(self):
        assert url_normalizer(u'simpleandsafe') == u'simpleandsafe'
        assert url_normalizer(u' Whitespace and capital Letters  ') == \
            u'whitespace-and-capital-letters'
        assert url_normalizer(u">here's another!") == u'heres-another'
        assert url_normalizer(u">>>here'!--s yet another!!!") == \
            u"here-s-yet-another"
        assert url_normalizer(u"Doe, Joe") == u"doe-joe"
        assert url_normalizer(u"umlut.doc") == u"umlut.doc"
        assert url_normalizer(u"ZA GL JA") == u"za-gl-ja"
        assert url_normalizer(u"za gl ja") == u"za-gl-ja"
        assert url_normalizer(u'quote-this') == u'quote-this'
        assert url_normalizer(u"quote 'this'!") == u"quote-this"
        assert url_normalizer(u"I'm not a FILE.txt") == u"im-not-a-file.txt"
        assert url_normalizer(u"I'm a big file.TXT") == u"im-a-big-file.txt"
        assert url_normalizer(u"rest `n` peace") == u"rest-n-peace"
        assert (len(url_normalizer(u"aa" * 2000))) == 255
        assert url_normalizer(u"short-hello-version", max_length=10) == u"short"

    def test_normalizer_map_non_ascii_characters(self):
        get_settings()['kotti.url_normalizer.map_non_ascii_characters'] = True
        assert url_normalizer(u'simpleandsafe') == u'simpleandsafe'
        assert url_normalizer(u' Whitespace and capital Letters  ') == \
            u'whitespace-and-capital-letters'
        assert url_normalizer(u">here's another!") == u'heres-another'
        assert url_normalizer(u">>>here'!--s yet another!!!") == \
            u"here-s-yet-another"
        assert url_normalizer(u"Doe, Joe") == u"doe-joe"
        assert url_normalizer(u"umlut.doc") == u"umlaut.doc"
        assert url_normalizer(u"ZA GL JA") == u"zazolc-gesla-jazn"
        assert url_normalizer(u"za gl ja") == u"zazolc-gesla-jazn"
        assert url_normalizer(u'quote-this') == u'quote-this'
        assert url_normalizer(u"quote 'this'!") == u"quote-this"
        assert url_normalizer(u"I'm not a FILE.txt") == u"im-not-a-file.txt"
        assert url_normalizer(u"I'm a big file.TXT") == u"im-a-big-file.txt"
        assert url_normalizer(u"rest `n` peace") == u"rest-n-peace"
        assert (len(url_normalizer(u"aa" * 2000))) == 255
        assert url_normalizer(u"short-hello-version", max_length=10) == u"short"

########NEW FILE########
__FILENAME__ = url_normalizer
import re
from unidecode import unidecode

from kotti import get_settings


# Define and compile static regexes
FILENAME_REGEX = re.compile(r"^(.+)\.(\w{,4})$", re.U)
IGNORE_REGEX = re.compile(r"['\"]", re.U)
URL_DANGEROUS_CHARS_REGEX = re.compile(r"[!#$%&()*+,/:;<=>?@\\^{|}\[\]~`]+", re.U)
MULTIPLE_DASHES_REGEX = re.compile(r"\-+", re.U)
EXTRA_DASHES_REGEX = re.compile(r"(^\-+)|(\-+$)", re.U)
# Define static constraints
MAX_LENGTH = 50
MAX_URL_LENGTH = 255


def crop_name(base, maxLength=MAX_LENGTH):
    baseLength = len(base)

    index = baseLength
    while index > maxLength:
        index = base.rfind('-', 0, index)

    if index == -1 and baseLength > maxLength:
        base = base[:maxLength]

    elif index > 0:
        base = base[:index]

    return base


def url_normalizer(text, locale=None, max_length=MAX_URL_LENGTH):

    key = 'kotti.url_normalizer.map_non_ascii_characters'
    map_non_ascii = get_settings()[key]
    if map_non_ascii:
        text = unidecode(text)

    # lowercase text
    base = text.lower()
    ext = ''

    m = FILENAME_REGEX.match(base)
    if m is not None:
        base = m.groups()[0]
        ext = m.groups()[1]

    base = base.replace(u' ', '-')
    base = IGNORE_REGEX.sub(u'', base)
    base = URL_DANGEROUS_CHARS_REGEX.sub(u'-', base)
    base = EXTRA_DASHES_REGEX.sub(u'', base)
    base = MULTIPLE_DASHES_REGEX.sub(u'-', base)

    base = crop_name(base, maxLength=max_length)

    if ext != '':
        base = base + u'.' + ext

    return base

########NEW FILE########
__FILENAME__ = util
# -*- coding: utf-8 -*-

"""
Inheritance Diagram
-------------------

.. inheritance-diagram:: kotti.util
"""

import re
import urllib

from docopt import docopt
from pyramid.i18n import get_localizer
from pyramid.i18n import get_locale_name
from pyramid.i18n import make_localizer
from pyramid.i18n import TranslationStringFactory
from pyramid.interfaces import ITranslationDirectories
from pyramid.location import inside
from pyramid.paster import bootstrap
from pyramid.renderers import render
from pyramid.threadlocal import get_current_registry
from pyramid.threadlocal import get_current_request
from pyramid.url import resource_url
from pyramid.view import render_view_to_response
from repoze.lru import LRUCache
from zope.deprecation import deprecated

from kotti import DBSession

_ = TranslationStringFactory('Kotti')


def get_localizer_for_locale_name(locale_name):
    registry = get_current_registry()
    tdirs = registry.queryUtility(ITranslationDirectories, default=[])
    return make_localizer(locale_name, tdirs)


def translate(*args, **kwargs):
    request = get_current_request()
    if request is None:
        localizer = get_localizer_for_locale_name('en')
    else:
        localizer = get_localizer(request)
    return localizer.translate(*args, **kwargs)


def get_paste_items(context, request):
    from kotti.resources import Node

    items = []
    info = request.session.get('kotti.paste')
    if info:
        ids, action = info
        for id in ids:
            item = DBSession.query(Node).get(id)
            if item is None or not item.type_info.addable(context, request):
                continue
            if action == 'cut' and inside(context, item):
                continue
            if context == item:
                continue
            items.append(item)
    return items


def render_view(context, request, name='', secure=True):
    from kotti.security import authz_context

    with authz_context(context, request):
        response = render_view_to_response(context, request, name, secure)
    if response is not None:
        return response.ubody


class TemplateStructure(object):
    def __init__(self, html):
        self.html = html

    def __html__(self):
        return self.html
    __unicode__ = __html__

    def __getattr__(self, key):
        return getattr(self.html, key)


class LinkBase(object):
    def __call__(self, context, request):
        return TemplateStructure(
            render(
                self.template,
                dict(link=self, context=context, request=request),
                request,
                )
            )

    def selected(self, context, request):
        return urllib.unquote(request.url).startswith(
            self.url(context, request))

    def permitted(self, context, request):
        from kotti.security import view_permitted
        return view_permitted(context, request, self.name)

    def visible(self, context, request):
        permitted = self.permitted(context, request)
        if permitted:
            if self.predicate is not None:
                return self.predicate(context, request)
            else:
                return True
        return False

    @property
    def path(self):  # BBB
        return self.name
    path = deprecated(
        path,
        "The 'path' attribute has been deprecated as of Kotti 0.10.  Please "
        "use 'name' instead.",
        )


class LinkRenderer(LinkBase):
    """A menu link that renders a view to render the link.
    """
    def __init__(self, name, predicate=None):
        self.name = name
        self.predicate = predicate

    def __call__(self, context, request):
        return TemplateStructure(render_view(context, request, name=self.name))

    def selected(self, context, request):
        return False


class LinkParent(LinkBase):
    """A menu link that renders sublinks in a dropdown.
    """
    template = 'kotti:templates/edit/el-parent.pt'

    def __init__(self, title, children):
        self.title = title
        self.children = children

    def visible(self, context, request):
        return any([ch.visible(context, request) for ch in self.children])

    def selected(self, context, request):
        return any([ch.selected(context, request) for ch in self.children])

    def get_visible_children(self, context, request):
        return [ch for ch in self.children if ch.visible(context, request)]


class Link(LinkBase):
    template = 'kotti:templates/edit/el-link.pt'

    def __init__(self, name, title=None, predicate=None):
        self.name = name
        if title is None:
            title = name.replace('-', ' ').replace('_', ' ').title()
        self.title = title
        self.predicate = predicate

    def url(self, context, request):
        return resource_url(context, request) + '@@' + self.name

    def selected(self, context, request):
        return urllib.unquote(request.url).startswith(
            self.url(context, request))

    def __eq__(self, other):
        return isinstance(other, Link) and repr(self) == repr(other)

    def __repr__(self):
        return "Link(%r, %r)" % (self.name, self.title)


class ActionButton(Link):
    def __init__(self, path, title=None, no_children=False, css_class=u"btn"):
        super(ActionButton, self).__init__(path, title)
        self.no_children = no_children
        self.css_class = css_class


class DontCache(Exception):
    pass

_CACHE_ATTR = 'kotti_cache'


def request_container():
    request = get_current_request()
    if request is None:
        return None
    cache = getattr(request, _CACHE_ATTR, None)
    if cache is None:
        cache = {}
        setattr(request, _CACHE_ATTR, cache)
    return cache


def cache(compute_key, container_factory):
    marker = object()

    def decorator(func):
        def replacement(*args, **kwargs):
            cache = container_factory()
            if cache is None:
                return func(*args, **kwargs)
            try:
                key = compute_key(*args, **kwargs)
            except DontCache:
                return func(*args, **kwargs)
            key = '%s.%s:%s' % (func.__module__, func.__name__, key)
            cached_value = cache.get(key, marker)
            if cached_value is marker:
                cached_value = cache[key] = func(*args, **kwargs)
            else:
                pass
            return cached_value
        replacement.__doc__ = func.__doc__
        return replacement
    return decorator


def request_cache(compute_key):
    return cache(compute_key, request_container)


class LRUCacheSetItem(LRUCache):
    __setitem__ = LRUCache.put

_lru_cache = LRUCacheSetItem(1000)


def lru_cache(compute_key):
    return cache(compute_key, lambda: _lru_cache)


def clear_cache():  # only useful for tests really
    request = get_current_request()
    if request is not None:
        setattr(request, _CACHE_ATTR, None)
    _lru_cache.clear()


def extract_from_settings(prefix, settings=None):
    """
      >>> settings = {
      ...     'kotti_twitter.foo_bar': '1', 'kotti.spam_eggs': '2'}
      >>> print extract_from_settings('kotti_twitter.', settings)
      {'foo_bar': '1'}
    """
    from kotti import get_settings
    settings = settings if settings is not None else get_settings()
    extracted = {}
    for key, value in settings.items():
        if key.startswith(prefix):
            extracted[key[len(prefix):]] = value
    return extracted


def disambiguate_name(name):
    parts = name.split(u'-')
    if len(parts) > 1:
        try:
            index = int(parts[-1])
        except ValueError:
            parts.append(u'1')
        else:
            parts[-1] = unicode(index + 1)
    else:
        parts.append(u'1')
    return u'-'.join(parts)


def title_to_name(title, blacklist=()):
    request = get_current_request()
    if request is not None:
        locale_name = get_locale_name(request)
    else:
        locale_name = 'en'
    from kotti import get_settings
    urlnormalizer = get_settings()['kotti.url_normalizer'][0]
    name = unicode(urlnormalizer(title, locale_name, max_length=40))
    while name in blacklist:
        name = disambiguate_name(name)
    return name


def camel_case_to_name(text):
    """
      >>> camel_case_to_name('FooBar')
      'foo_bar'
      >>> camel_case_to_name('TXTFile')
      'txt_file'
      >>> camel_case_to_name ('MyTXTFile')
      'my_txt_file'
      >>> camel_case_to_name('froBOZ')
      'fro_boz'
      >>> camel_case_to_name('f')
      'f'
    """
    return re.sub(
        r'((?<=[a-z])[A-Z]|(?<!\A)[A-Z](?=[a-z]))', r'_\1', text).lower()


def command(func, doc):
    args = docopt(doc)
    pyramid_env = bootstrap(args['<config_uri>'])
    try:
        func(args)
    finally:
        pyramid_env['closer']()
    return 0


from kotti.sqla import JsonType
from kotti.sqla import MutationDict
from kotti.sqla import MutationList
from kotti.sqla import NestedMixin
from kotti.sqla import NestedMutationDict
from kotti.sqla import NestedMutationList


for cls in (JsonType, MutationDict, MutationList, NestedMixin,
            NestedMutationDict, NestedMutationList):
    name = cls.__name__
    deprecated(
        name,
        "kotti.util.{0} has been moved to the kotti.sqla "
        "module as of Kotti 0.6.0.  Use kotti.sqla.{0} instead".format(name)
        )


ViewLink = Link
deprecated(
    'ViewLink',
    "kotti.util.ViewLink has been renamed to Link as of Kotti 0.10."
    )

########NEW FILE########
__FILENAME__ = cache
import datetime
from logging import getLogger

from pyramid.events import subscriber
from pyramid.events import NewResponse
from pyramid.response import FileResponse
from sqlalchemy.orm.exc import DetachedInstanceError

from kotti import get_settings
from kotti.security import get_user

CACHE_POLICY_HEADER = 'x-caching-policy'

logger = getLogger(__name__)


def set_max_age(response, delta, cache_ctrl=None):
    """Sets max-age and expires headers based on the timedelta `delta`.

    If `cache_ctrl` is not None, I'll add items found therein to the
    Cache-Control header.

    Will overwrite existing values and preserve non overwritten ones.
    """
    if cache_ctrl is None:
        cache_ctrl = {}

    seconds = delta.seconds + delta.days * 24 * 60 * 60
    if seconds < 0:
        seconds = 0
    now = datetime.datetime.utcnow()

    cache_ctrl.setdefault('max-age', seconds)

    # Preserve an existing cache-control header:
    existing = response.headers.get('cache-control')
    if existing:
        for e in [e.strip() for e in existing.split(',')]:
            kv = e.split('=')
            if len(kv) == 2:
                cache_ctrl.setdefault(kv[0], kv[1])
            else:
                cache_ctrl.setdefault(kv[0], None)

    # Render the cache-control header:
    cache_control_header = []
    for key, value in sorted(cache_ctrl.items()):
        if value is None:
            cache_control_header.append(key)
        else:
            cache_control_header.append('%s=%s' % (key, value))
    cache_control_header = ','.join(cache_control_header)
    response.headers['cache-control'] = cache_control_header

    response.headers['expires'] = (now + delta).strftime(
        "%a, %d %b %Y %H:%M:%S GMT")


# This is our mapping of caching policies (X-Caching-Policy) to
# functions that set the response headers accordingly:
caching_policies = {
    'Cache HTML':
    lambda response: set_max_age(response, datetime.timedelta(days=-1),
                                 cache_ctrl={'s-maxage': '3600'}),

    'Cache Media Content':
    lambda response: set_max_age(response, datetime.timedelta(hours=4)),

    'Cache Resource':
    lambda response: set_max_age(response, datetime.timedelta(days=32),
                                 cache_ctrl={'public': None}),

    'No Cache':
    lambda response: set_max_age(response, datetime.timedelta(days=-1)),
}


def _safe_get_user(request):
    try:
        return get_user(request)
    except DetachedInstanceError:  # XXX need to understand what's happening
        return not None


def default_caching_policy_chooser(context, request, response):
    if request.method != 'GET' or response.status_int != 200:
        return None
    elif isinstance(response, FileResponse):
        return 'Cache Resource'
    elif _safe_get_user(request) is not None:
        return 'No Cache'
    elif response.headers['content-type'].startswith('text/html'):
        return 'Cache HTML'
    else:
        return 'Cache Media Content'


def caching_policy_chooser(context, request, response):
    return get_settings()['kotti.caching_policy_chooser'][0](
        context, request, response)


@subscriber(NewResponse)
def set_cache_headers(event):
    request, response = event.request, event.response
    context = event.request.context

    # If no caching policy was previously set (by setting the
    # CACHE_POLICY_HEADER header), we'll choose one at this point:
    caching_policy = response.headers.get(CACHE_POLICY_HEADER)
    if caching_policy is None:
        try:
            caching_policy = caching_policy_chooser(context, request, response)
        except:
            # We don't want to screw up the response if the
            # caching_policy_chooser raises an exception.
            logger.exception("{0} raised an exception.".format(
                caching_policy_chooser))
    if caching_policy is not None:
        response.headers[CACHE_POLICY_HEADER] = caching_policy

    # And here we'll set the headers for the caching policy:
    if caching_policy:
        caching_policies[caching_policy](response)


def includeme(config):
    config.scan(__name__)

########NEW FILE########
__FILENAME__ = actions
"""
Action views
"""

from pyramid.httpexceptions import HTTPFound
from pyramid.url import resource_url
from pyramid.view import view_config
from pyramid.exceptions import Forbidden
from pyramid.security import has_permission
from pyramid.view import view_defaults
from zope.deprecation import deprecated

from kotti import DBSession
from kotti import get_settings
from kotti.fanstatic import contents_view_js
from kotti.interfaces import IContent
from kotti.resources import Node
from kotti.util import _
from kotti.util import ActionButton
from kotti.util import title_to_name
from kotti.views.edit import _state_info
from kotti.views.edit import _states
from kotti.views.edit import get_paste_items
from kotti.views.form import EditFormView
from kotti.views.navigation import render_tree_navigation
from kotti.views.util import nodes_tree
from kotti.workflow import get_workflow


@view_defaults(permission='edit')
class NodeActions(object):
    """Actions related to content nodes."""

    def __init__(self, context, request):
        self.context = context
        self.request = request
        self.flash = self.request.session.flash

    def _selected_children(self, add_context=True):
        """
        Get the selected children of the given context. This are either
        the selected nodes of the contents view or the context itself.

        :result: List with select children.
        :rtype: list
        """
        ids = self.request.session.pop('kotti.selected-children')
        if ids is None and add_context:
            ids = [self.context.id]
        return ids

    def _all_children(self, context, permission='view'):
        """
        Get recursive all children of the given context.

        :result: List with all children of a given context.
        :rtype: list
        """
        tree = nodes_tree(self.request,
                          context=context,
                          permission=permission)
        return tree.tolist()[1:]

    def back(self, view=None):
        """
        Redirect to the given view of the context, the referrer of the request
        or the default_view of the context.

        :rtype: pyramid.httpexceptions.HTTPFound
        """
        url = self.request.resource_url(self.context)
        if view is not None:
            url += view
        elif self.request.referrer:
            url = self.request.referrer
        return HTTPFound(location=url)

    @view_config(name='workflow-change',
                 permission='state_change')
    def workflow_change(self):
        """
        Handle workflow change requests from workflow dropdown.

        :result: Redirect response to the referrer of the request.
        :rtype: pyramid.httpexceptions.HTTPFound
        """
        new_state = self.request.params['new_state']
        wf = get_workflow(self.context)
        wf.transition_to_state(self.context, self.request, new_state)
        self.flash(EditFormView.success_message, 'success')
        return self.back()

    @view_config(name='copy')
    def copy_node(self):
        """
        Copy nodes view. Copy the current node or the selected nodes in the
        contents view and save the result in the session of the request.

        :result: Redirect response to the referrer of the request.
        :rtype: pyramid.httpexceptions.HTTPFound
        """
        ids = self._selected_children()
        self.request.session['kotti.paste'] = (ids, 'copy')
        for id in ids:
            item = DBSession.query(Node).get(id)
            self.flash(_(u'${title} was copied.',
                         mapping=dict(title=item.title)), 'success')
        if not self.request.is_xhr:
            return self.back()

    @view_config(name='cut')
    def cut_nodes(self):
        """
        Cut nodes view. Cut the current node or the selected nodes in the
        contents view and save the result in the session of the request.

        :result: Redirect response to the referrer of the request.
        :rtype: pyramid.httpexceptions.HTTPFound
        """
        ids = self._selected_children()
        self.request.session['kotti.paste'] = (ids, 'cut')
        for id in ids:
            item = DBSession.query(Node).get(id)
            self.flash(_(u'${title} was cut.', mapping=dict(title=item.title)),
                       'success')
        if not self.request.is_xhr:
            return self.back()

    @view_config(name='paste')
    def paste_nodes(self):
        """
        Paste nodes view. Paste formerly copied or cutted nodes into the
        current context. Note that a cutted node can not be pasted into itself.

        :result: Redirect response to the referrer of the request.
        :rtype: pyramid.httpexceptions.HTTPFound
        """
        ids, action = self.request.session['kotti.paste']
        for count, id in enumerate(ids):
            item = DBSession.query(Node).get(id)
            if item is not None:
                if action == 'cut':
                    if not has_permission('edit', item, self.request):
                        raise Forbidden()
                    item.__parent__.children.remove(item)
                    item.name = title_to_name(item.name, blacklist=self.context.keys())
                    self.context.children.append(item)
                    if count is len(ids) - 1:
                        del self.request.session['kotti.paste']
                elif action == 'copy':
                    copy = item.copy()
                    name = copy.name
                    if not name:  # for root
                        name = copy.title
                    name = title_to_name(name, blacklist=self.context.keys())
                    copy.name = name
                    self.context.children.append(copy)
                self.flash(_(u'${title} was pasted.',
                             mapping=dict(title=item.title)), 'success')
            else:
                self.flash(_(u'Could not paste node. It no longer exists.'),
                           'error')
        if not self.request.is_xhr:
            return self.back()

    def move(self, move):
        """
        Do the real work to move the selected nodes up or down. Called
        by the up and the down view.

        :result: Redirect response to the referrer of the request.
        :rtype: pyramid.httpexceptions.HTTPFound
        """
        ids = self._selected_children()
        if move == 1:
            ids.reverse()
        for id in ids:
            child = DBSession.query(Node).get(id)
            index = self.context.children.index(child)
            self.context.children.pop(index)
            self.context.children.insert(index + move, child)
            self.flash(_(u'${title} was moved.',
                         mapping=dict(title=child.title)), 'success')
        if not self.request.is_xhr:
            return self.back()

    @view_config(name='up')
    def up(self):
        """
        Move up nodes view. Move the selected nodes up by 1 position
        and get back to the referrer of the request.

        :result: Redirect response to the referrer of the request.
        :rtype: pyramid.httpexceptions.HTTPFound
        """
        return self.move(-1)

    @view_config(name='down')
    def down(self):
        """
        Move down nodes view. Move the selected nodes down by 1 position
        and get back to the referrer of the request.

        :result: Redirect response to the referrer of the request.
        :rtype: pyramid.httpexceptions.HTTPFound
        """
        return self.move(1)

    def set_visibility(self, show):
        """
        Do the real work to set the visibility of nodes in the menu. Called
        by the show and the hide view.

        :result: Redirect response to the referrer of the request.
        :rtype: pyramid.httpexceptions.HTTPFound
        """
        ids = self._selected_children()
        for id in ids:
            child = DBSession.query(Node).get(id)
            if child.in_navigation != show:
                child.in_navigation = show
                mapping = dict(title=child.title)
                if show:
                    msg = _(u'${title} is now visible in the navigation.',
                            mapping=mapping)
                else:
                    msg = _(u'${title} is no longer visible in the navigation.',
                            mapping=mapping)
                self.flash(msg, 'success')
        if not self.request.is_xhr:
            return self.back()

    @view_config(name='show')
    def show(self):
        """
        Show nodes view.  Switch the in_navigation attribute of selected nodes
        to ``True`` and get back to the referrer of the request.

        :result: Redirect response to the referrer of the request.
        :rtype: pyramid.httpexceptions.HTTPFound
        """
        return self.set_visibility(True)

    @view_config(name='hide')
    def hide(self):
        """
        Hide nodes view. Switch the in_navigation attribute of selected nodes
        to ``False`` and get back to the referrer of the request.

        :result: Redirect response to the referrer of the request.
        :rtype: pyramid.httpexceptions.HTTPFound
        """
        return self.set_visibility(False)

    @view_config(name='delete',
                 permission='delete',
                 renderer='kotti:templates/edit/delete.pt')
    def delete_node(self):
        """
        Delete node view. Renders either a view to delete the current node
        or handle the deletion of the current node and get back to the
        default view of the node.

        :result: Either a redirect response or a dictionary passed to the
                 template for rendering.
        :rtype: pyramid.httpexceptions.HTTPFound or dict
        """
        if 'delete' in self.request.POST:
            parent = self.context.__parent__
            self.flash(_(u'${title} was deleted.',
                         mapping=dict(title=self.context.title)), 'success')
            del parent[self.context.name]
            location = resource_url(parent, self.request)
            return HTTPFound(location=location)
        return {}

    @view_config(name='delete_nodes',
                 permission='delete',
                 renderer='kotti:templates/edit/delete-nodes.pt')
    def delete_nodes(self):
        """
        Delete nodes view. Renders either a view to delete multiple nodes or
        delete the selected nodes and get back to the referrer of the request.

        :result: Either a redirect response or a dictionary passed to the
                 template for rendering.
        :rtype: pyramid.httpexceptions.HTTPFound or dict
        """
        if 'delete_nodes' in self.request.POST:
            ids = self.request.POST.getall('children-to-delete')
            if not ids:
                self.flash(_(u"Nothing was deleted."), 'info')
            for id in ids:
                item = DBSession.query(Node).get(id)
                self.flash(_(u'${title} was deleted.',
                             mapping=dict(title=item.title)), 'success')
                del self.context[item.name]
            return self.back('@@contents')

        if 'cancel' in self.request.POST:
            self.flash(_(u'No changes were made.'), 'info')
            return self.back('@@contents')

        ids = self._selected_children(add_context=False)
        items = []
        if ids is not None:
            items = DBSession.query(Node).filter(Node.id.in_(ids)).\
                order_by(Node.position).all()
        return {'items': items,
                'states': _states(self.context, self.request)}

    @view_config(name='rename',
                 renderer='kotti:templates/edit/rename.pt')
    def rename_node(self):
        """
        Rename node view. Renders either a view to change the title and
        name for the current node or handle the changes and get back to the
        default view of the node.

        :result: Either a redirect response or a dictionary passed to the
                 template for rendering.
        :rtype: pyramid.httpexceptions.HTTPFound or dict
        """
        if 'rename' in self.request.POST:
            name = self.request.POST['name']
            title = self.request.POST['title']
            if not name or not title:
                self.flash(_(u'Name and title are required.'), 'error')
            else:
                self.context.name = name.replace('/', '')
                self.context.title = title
                self.flash(_(u'Item was renamed.'), 'success')
                return self.back('')
        return {}

    @view_config(name='rename_nodes',
                 renderer='kotti:templates/edit/rename-nodes.pt')
    def rename_nodes(self):
        """
        Rename nodes view. Renders either a view to change the titles and
        names for multiple nodes or handle the changes and get back to the
        referrer of the request.

        :result: Either a redirect response or a dictionary passed to the
                 template for rendering.
        :rtype: pyramid.httpexceptions.HTTPFound or dict
        """
        if 'rename_nodes' in self.request.POST:
            ids = self.request.POST.getall('children-to-rename')
            for id in ids:
                item = DBSession.query(Node).get(id)
                name = self.request.POST[id + '-name']
                title = self.request.POST[id + '-title']
                if not name or not title:
                    self.flash(_(u'Name and title are required.'), 'error')
                    location = resource_url(self.context, self.request,
                                            '@@rename_nodes')
                    return HTTPFound(location=location)
                else:
                    item.name = title_to_name(name,
                                              blacklist=self.context.keys())
                    item.title = title
            self.flash(_(u'Your changes have been saved.'), 'success')
            return self.back('@@contents')

        if 'cancel' in self.request.POST:
            self.flash(_(u'No changes were made.'), 'info')
            return self.back('@@contents')

        ids = self._selected_children(add_context=False)
        items = []
        if ids is not None:
            items = DBSession.query(Node).filter(Node.id.in_(ids)).all()
        return {'items': items}

    @view_config(name='change_state',
                 renderer='kotti:templates/edit/change-state.pt')
    def change_state(self):
        """
        Change state view. Renders either a view to handle workflow changes
        for multiple nodes or handle the selected workflow changes and get
        back to the referrer of the request.

        :result: Either a redirect response or a dictionary passed to the
                 template for rendering.
        :rtype: pyramid.httpexceptions.HTTPFound or dict
        """
        if 'change_state' in self.request.POST:
            ids = self.request.POST.getall('children-to-change-state')
            to_state = self.request.POST.get('to-state', u'no-change')
            include_children = self.request.POST.get('include-children', None)
            if to_state != u'no-change':
                items = DBSession.query(Node).filter(Node.id.in_(ids)).all()
                for item in items:
                    wf = get_workflow(item)
                    if wf is not None:
                        wf.transition_to_state(item, self.request, to_state)
                    if include_children:
                        childs = self._all_children(item,
                                                    permission='state_change')
                        for child in childs:
                            wf = get_workflow(child)
                            if wf is not None:
                                wf.transition_to_state(child,
                                                       self.request,
                                                       to_state, )
                self.flash(_(u'Your changes have been saved.'), 'success')
            else:
                self.flash(_(u'No changes were made.'), 'info')
            return self.back('@@contents')

        if 'cancel' in self.request.POST:
            self.flash(_(u'No changes were made.'), 'info')
            return self.back('@@contents')

        ids = self._selected_children(add_context=False)
        items = transitions = []
        if ids is not None:
            wf = get_workflow(self.context)
            if wf is not None:
                items = DBSession.query(Node).filter(Node.id.in_(ids)).all()
                for item in items:
                        trans_info = wf.get_transitions(item, self.request)
                        for tran_info in trans_info:
                            if tran_info not in transitions:
                                transitions.append(tran_info)
        return {'items': items,
                'states': _states(self.context, self.request),
                'transitions': transitions, }


def contents_buttons(context, request):
    """
    Build the action buttons for the contents view based on the current
    state and the persmissions of the user.

    :result: List of ActionButtons.
    :rtype: list
    """
    buttons = []
    if get_paste_items(context, request):
        buttons.append(ActionButton('paste', title=_(u'Paste'),
                                    no_children=True))
    if context.children:
        buttons.append(ActionButton('copy', title=_(u'Copy')))
        buttons.append(ActionButton('cut', title=_(u'Cut')))
        buttons.append(ActionButton('rename_nodes', title=_(u'Rename'),
                                    css_class=u'btn btn-warning'))
        buttons.append(ActionButton('delete_nodes', title=_(u'Delete'),
                                    css_class=u'btn btn-danger'))
        if get_workflow(context) is not None:
            buttons.append(ActionButton('change_state',
                                        title=_(u'Change State')))
        buttons.append(ActionButton('up', title=_(u'Move up')))
        buttons.append(ActionButton('down', title=_(u'Move down')))
        buttons.append(ActionButton('show', title=_(u'Show')))
        buttons.append(ActionButton('hide', title=_(u'Hide')))
    return [button for button in buttons if button.permitted(context, request)]


@view_config(name='add-dropdown', permission='add',
             renderer='kotti:templates/add-dropdown.pt')
def content_type_factories(context, request):
    """
    Renders the drop down menu for Add button in editor bar.

    :result: Dictionary passed to the template for rendering.
    :rtype: pyramid.httpexceptions.HTTPFound or dict
    """
    all_types = get_settings()['kotti.available_types']
    factories = []
    for factory in all_types:
        if factory.type_info.addable(context, request):
            factories.append(factory)
    return {'factories': factories}


@view_config(context=IContent, name='contents', permission='view',
             renderer='kotti:templates/edit/contents.pt')
def contents(context, request):
    """
    Contents view. Renders either the contents view or handle the action
    button actions of the view.

    :result: Either a redirect response or a dictionary passed to the
             template for rendering.
    :rtype: pyramid.httpexceptions.HTTPFound or dict
    """
    contents_view_js.need()
    buttons = contents_buttons(context, request)
    for button in buttons:
        if button.name in request.POST:
            children = request.POST.getall('children')
            if not children and button.name != u'paste':
                request.session.flash(
                    _(u'You have to select items to perform an action.'),
                    'info')
                location = resource_url(context, request) + '@@contents'
                return HTTPFound(location=location)
            request.session['kotti.selected-children'] = children
            location = button.url(context, request)
            return HTTPFound(location, request=request)

    return {'children': context.children_with_permission(request),
            'buttons': buttons,
            }


@view_config(name='move-child-position', permission='edit',
             request_method="POST", renderer="json")
def move_child_position(context, request):
    """ Move the child from one position to another.

    :param context: "Container" node in which the child changes its position.
    :type context: :class:kotti.resources.Node or descendant

    :param request: Current request (of method POST).  Must contain "from" and
                    "to" params that contain the 0-based old (i.e. the current
                    index of the child to be moved) and new position (its new
                    index) values.
    :type request:
    :result: JSON serializable bject with a single attribute ("result") that is
             either "success" or "error".
    :rtype: dict
    """

    data = request.POST

    if ('from' in data) and ('to' in data):

        max_pos = len(context.children) - 1

        try:
            oldPosition = int(data['from'])
            newPosition = int(data['to'])
            if not ((0 <= oldPosition <= max_pos) and
                    (0 <= newPosition <= max_pos)):
                raise ValueError
        except ValueError:
            return {'result': 'error'}

        # sqlalchemy.ext.orderinglist takes care of the "right" sequence
        # numbers (immediately consecutive, starting with 0) for us.
        context.children.insert(newPosition,
                                context.children.pop(oldPosition))
        result = 'success'
    else:
        result = 'error'

    return {'result': result}


@view_config(name='workflow-dropdown', permission='view',
             renderer='kotti:templates/workflow-dropdown.pt')
def workflow(context, request):
    """
    Renders the drop down menu for workflow actions.

    :result: Dictionary passed to the template for rendering.
    :rtype: dict
    """
    wf = get_workflow(context)
    if wf is not None:
        state_info = _state_info(context, request)
        curr_state = [i for i in state_info if i['current']][0]
        trans_info = wf.get_transitions(context, request)
        return {
            'states': _states(context, request),
            'transitions': trans_info,
            'current_state': curr_state,
        }

    return {
        'current_state': None
    }


@view_config(name='actions-dropdown', permission='edit',
             renderer='kotti:templates/actions-dropdown.pt')
def actions(context, request):
    """
    Renders the drop down menu for Actions button in editor bar.

    :result: Dictionary passed to the template for rendering.
    :rtype: dict
    """
    actions = []
    if hasattr(context, 'type_info'):
        actions = [a for a in context.type_info.action_links
                   if a.visible(context, request)]
    return {'actions': actions}


def includeme(config):
    import warnings
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        config.scan(__name__)


# BBB starts here --- --- --- --- --- ---

render_tree_navigation = render_tree_navigation

deprecated(
    'render_tree_navigation',
    'render_tree_navigation has been moved to kotti.views.navigation as of '
    'Kotti 0.9.  Import from there instead.'
)

########NEW FILE########
__FILENAME__ = content
"""
Content edit views
"""

import random
from StringIO import StringIO
import colander
from colander import SchemaNode
from colander import null
from deform import FileData
from deform.widget import FileUploadWidget
from deform.widget import RichTextWidget
from deform.widget import TextAreaWidget

from kotti.resources import Document
from kotti.resources import File
from kotti.resources import Image
from kotti.util import _
from kotti.views.form import get_appstruct
from kotti.views.form import AddFormView
from kotti.views.form import EditFormView
from kotti.views.form import FileUploadTempStore
from kotti.views.form import ObjectType
from kotti.views.form import deferred_tag_it_widget
from kotti.views.form import validate_file_size_limit


class ContentSchema(colander.MappingSchema):
    title = colander.SchemaNode(
        colander.String(),
        title=_(u'Title'),
        )
    description = colander.SchemaNode(
        colander.String(),
        title=_('Description'),
        widget=TextAreaWidget(cols=40, rows=5),
        missing=u"",
        )
    tags = colander.SchemaNode(
        ObjectType(),
        title=_('Tags'),
        widget=deferred_tag_it_widget,
        missing=[],
        )


class DocumentSchema(ContentSchema):
    body = colander.SchemaNode(
        colander.String(),
        title=_(u'Body'),
        widget=RichTextWidget(
            # theme='advanced', width=790, height=500
        ),
        missing=u"",
        )


def FileSchema(tmpstore, title_missing=None):
    class FileSchema(ContentSchema):
        file = SchemaNode(
            FileData(),
            title=_(u'File'),
            widget=FileUploadWidget(tmpstore),
            validator=validate_file_size_limit,
            )

    def set_title_missing(node, kw):
        if title_missing is not None:
            node['title'].missing = title_missing

    return FileSchema(after_bind=set_title_missing)


class DocumentEditForm(EditFormView):
    schema_factory = DocumentSchema


class DocumentAddForm(AddFormView):
    schema_factory = DocumentSchema
    add = Document
    item_type = _(u"Document")


class FileEditForm(EditFormView):
    def before(self, form):
        form.appstruct = get_appstruct(self.context, self.schema)
        if self.context.data is not None:
            form.appstruct.update({'file': {
                'fp': StringIO(self.context.data),
                'filename': self.context.name,
                'mimetype': self.context.mimetype,
                'uid': str(random.randint(1000000000, 9999999999)),
            }})

    def schema_factory(self):
        tmpstore = FileUploadTempStore(self.request)
        return FileSchema(tmpstore)

    def edit(self, **appstruct):
        title = appstruct['title']
        self.context.title = title
        self.context.description = appstruct['description']
        self.context.tags = appstruct['tags']
        if appstruct['file']:
            buf = appstruct['file']['fp'].read()
            self.context.data = buf
            self.context.filename = appstruct['file']['filename']
            self.context.mimetype = appstruct['file']['mimetype']
            self.context.size = len(buf)


class FileAddForm(AddFormView):
    item_type = _(u"File")
    item_class = File  # specific to this class

    def schema_factory(self):
        tmpstore = FileUploadTempStore(self.request)
        return FileSchema(tmpstore, title_missing=null)

    def save_success(self, appstruct):
        if not appstruct['title']:
            appstruct['title'] = appstruct['file']['filename']
        return super(FileAddForm, self).save_success(appstruct)

    def add(self, **appstruct):
        buf = appstruct['file']['fp'].read()
        filename = appstruct['file']['filename']
        return self.item_class(
            title=appstruct['title'] or filename,
            description=appstruct['description'],
            tags=appstruct['tags'],
            data=buf,
            filename=filename,
            mimetype=appstruct['file']['mimetype'],
            size=len(buf),
            )


class ImageEditForm(FileEditForm):
    pass


class ImageAddForm(FileAddForm):
    item_type = _(u"Image")
    item_class = Image


def includeme(config):
    config.add_view(
        DocumentEditForm,
        context=Document,
        name='edit',
        permission='edit',
        renderer='kotti:templates/edit/node.pt',
        )

    config.add_view(
        DocumentAddForm,
        name=Document.type_info.add_view,
        permission='add',
        renderer='kotti:templates/edit/node.pt',
        )

    config.add_view(
        FileEditForm,
        context=File,
        name='edit',
        permission='edit',
        renderer='kotti:templates/edit/node.pt',
        )

    config.add_view(
        FileAddForm,
        name=File.type_info.add_view,
        permission='add',
        renderer='kotti:templates/edit/node.pt',
        )

    config.add_view(
        ImageEditForm,
        context=Image,
        name='edit',
        permission='edit',
        renderer='kotti:templates/edit/node.pt',
        )

    config.add_view(
        ImageAddForm,
        name=Image.type_info.add_view,
        permission='add',
        renderer='kotti:templates/edit/node.pt',
        )

########NEW FILE########
__FILENAME__ = default_views
"""
:summary: Default view selctor views
"""

import warnings

from pyramid.compat import map_
from pyramid.httpexceptions import HTTPFound
from pyramid.interfaces import IView
from pyramid.interfaces import IViewClassifier
from pyramid.threadlocal import get_current_registry
from pyramid.view import view_config
from pyramid.view import view_defaults
from zope.interface import providedBy

from kotti.util import _


@view_defaults(permission='edit')
class DefaultViewSelection(object):

    def __init__(self, context, request):

        self.context = context
        self.request = request

    def _get_view(self, view_name):  # pragma: no cover
        """This code is copied from pyramid.view.
           We trust it and don't test.

           Returns True if a view with name view_name is registered for context.
        """
        provides = [IViewClassifier] + map_(
            providedBy,
            (self.request, self.context)
        )

        try:
            reg = self.request.registry
        except AttributeError:
            reg = get_current_registry()

        return reg.adapters.lookup(provides, IView, name=view_name)

    def _is_valid_view(self, view_name):
        """Return True if a view with name view_name is registered for context.
        """

        return self._get_view(view_name) is not None

    @view_config(name='default-view-selector',
                 renderer='kotti:templates/default-view-selector.pt')
    def default_view_selector(self):
        """
        :summary: Submenu for selection of the node's default view.
        :result: Dictionary with a selectable_default_views list.
        :rtype: dict
        """

        sviews = []

        for v in self.context.type_info.selectable_default_views:
            name, title = v
            if self._is_valid_view(name):
                sviews.append({
                    "name": name,
                    "title": title,
                    "is_current": name == self.context.default_view,
                })
            else:
                warnings.warn("No view called %r is registered for %r." %
                    (name, self.context))

        return {
            "selectable_default_views": [
                {
                    "name": "default",
                    "title": _("Default view"),
                    "is_current": self.context.default_view is None,
                }
            ] + sviews,
        }

    @view_config(name='set-default-view')
    def set_default_view(self):
        """
        :summary: Set the node's default view and redirect to it.
        :result: Redirect to the context URL.
        :rtype: pyramid.httpexceptions.HTTPFound
        """

        if 'view_name' in self.request.GET:

            view_name = self.request.GET['view_name']

            if view_name == "default":
                self.context.default_view = None
                self.request.session.flash(
                    _("Default view has been reset to default."),
                    'success'
                )
            else:
                if self._is_valid_view(view_name):
                    self.context.default_view = view_name
                    self.request.session.flash(
                        _("Default view has been set."),
                        'success'
                    )
                else:
                    self.request.session.flash(
                        _("Default view could not be set."),
                        'error'
                    )

        return HTTPFound(
            location=self.request.resource_url(self.context)
        )


def includeme(config):
    config.scan('.default_views')

########NEW FILE########
__FILENAME__ = upload
# -*- coding: utf-8 -*-

"""
Created on 2013-02-23
"""

import json
from cgi import FieldStorage
from logging import getLogger

from pyramid.response import Response
from pyramid.view import view_defaults
from pyramid.view import view_config

# from kotti import get_settings
from kotti.fanstatic import upload
from kotti.util import title_to_name
from kotti.views.edit.actions import content_type_factories

log = getLogger(__name__)


@view_defaults(name="upload", context="kotti.resources.Content",
               permission="edit")
class UploadView(object):

    def __init__(self, context, request):
        """ Constructor.

        :param context: Container of the nodes that will be created from
                        uploads.
        :type context: :class:`kotti.resources.Content` or descendants.

        :param request: Current request.
        :type request: :class:`pyramid.request.Request`
        """

        self.context = context
        self.request = request
        self.factories = content_type_factories(context, request)['factories']

    @view_config(request_method="GET",
                 renderer="kotti:templates/edit/upload.pt")
    def form(self):
        """ The upload form.

        :result: Data that is needed to render the form (such as allowed child
                 types).
        :rtype: dict
        """

        upload.need()

        return {}

    def possible_factories(self, mimetype):
        """ Return a list of factories for content types that are allowed in the
            context *and* for the given mimetype.

            The result is sorted by length of the matching
            ``uploadable_mimetype`` so that the more specific match comes
            before the more generic match.

            E.g.: when requesting the appropriate content types for
                  ``image/png`` the result order will be [Image, File], because
                  Image matches with its uploadable_mimetype ``image/*`` whereas
                  Files matches 'only' with ``*``.  If there was another content
                  type that would deal with PNGs specificly (and therefore had
                  an uploadable_mimetype ``image/png``) that one would be the
                  first, followed by Imgage and File.

        :param mimetype: MIME type
        :type mimetype: str

        :result: List of content factories.
        :rtype: list
        """

        factories = []
        for factory in self.factories:
            match_score = factory.type_info.is_uploadable_mimetype(mimetype)
            if match_score:
                factories.append((match_score, factory))

        return [f[1] for f in sorted(
            factories, key=lambda factory: -factory[0])]

    @view_config(name="content_types", request_method="GET",
                 accept="application/json", renderer="json")
    def content_types(self):
        """ Return a list of content type names and title for those types that
            can be created from files of the MIME type given as GET parameter.

        :result: JSON object with a single attribute ``content_types``.  This
                 is a list objects with name and title attributes.
        :rtype: dict
        """

        mimetype = self.request.GET['mimetype']

        result = {"content_types": [{
            'name': f.type_info.name,
            'title': f.type_info.title,
        } for f in self.possible_factories(mimetype)]}

        return result

    def factory_by_name(self, content_type_name):
        """ Return a factory (i.e. content class) by its name.

        :param content_type_name: type_info.name of the class.
        :type content_type_name: str

        :result: Content factory
        :rtype: :class:`kotti.resources.Content` or subclass thereof.
        """

        for f in self.factories:
            if f.type_info.name == content_type_name:
                return f

        raise KeyError("Content of that type is not allowed in this context.")

    # def upload_constraints(self):

    #     return {
    #         'max_file_size': get_settings()['kotti.max_file_size'],
    #     }

    @view_config(request_method="POST", xhr=True, accept="application/json")
    def process_upload(self):
        """ Process a single upload.
            Also see: https://github.com/valums/file-uploader/blob/master/server/readme.md

        :result: Status object with URL of the created item (on success) or
                 error message on failure.
        :rtype: dict
        """

        fs = self.request.POST['qqfile']
        # We can fail hard, as somebody is trying to cheat on us if that fails.
        assert isinstance(fs, FieldStorage)

        try:
            factory = self.factory_by_name(self.request.POST['content_type'])
        except KeyError, e:
            result = {
                'success': False,
                'error': e.message,
            }
        else:
            name = title_to_name(fs.filename, blacklist=self.context.keys())
            self.context[name] = node = factory.from_field_storage(fs)
            node.title = fs.filename

            result = {
                "success": True,
                "url": self.request.resource_url(node),
            }

        # FineUploader expects JSON with Content-Type 'text/plain'
        response = Response(json.dumps(result))
        response.content_type = 'text/plain'

        return response


def includeme(config):
    config.scan(__name__)

########NEW FILE########
__FILENAME__ = file
from kotti.resources import File

from pyramid.response import Response
from pyramid.view import view_config
from zope.deprecation.deprecation import deprecated


@view_config(name='view', context=File, permission='view',
             renderer='kotti:templates/view/file.pt')
def view(context, request):
    return {}


@view_config(name='inline-view', context=File,
             permission='view')
def inline_view(context, request, disposition='inline'):
    res = Response(
        headerlist=[
            ('Content-Disposition', '%s;filename="%s"' % (
                disposition, context.filename.encode('ascii', 'ignore'))),
            ('Content-Type', str(context.mimetype)),
            ]
        )
    res.body = context.data
    return res


@view_config(name='attachment-view', context=File,
             permission='view')
def attachment_view(context, request):
    return inline_view(context, request, 'attachment')


def includeme(config):
    config.scan(__name__)


# BBB
from .edit.content import FileAddForm as AddFileFormView
from .edit.content import ImageAddForm as AddImageFormView
from .edit.content import FileEditForm as EditFileFormView
from .edit.content import ImageEditForm as EditImageFormView

for cls in (
    AddFileFormView, AddImageFormView, EditFileFormView, EditImageFormView,
    ):
    deprecated(cls, """\
%s has been renamed (e.g. 'FileAddForm' became 'AddFileFormView') and moved to
kottiv.views.edit.content as of Kotti 0.8.""" % cls.__name__)

########NEW FILE########
__FILENAME__ = form
"""
Form related base views from which you can inherit.

Inheritance Diagram
-------------------

.. inheritance-diagram:: kotti.views.form
"""

from StringIO import StringIO
from UserDict import DictMixin

import colander
import deform
from pyramid.decorator import reify
from pyramid.httpexceptions import HTTPFound
from pyramid_deform import CSRFSchema
from pyramid_deform import FormView

from kotti import get_settings
from kotti.fanstatic import tagit
from kotti.resources import Tag
from kotti.util import _
from kotti.util import translate
from kotti.util import title_to_name


def get_appstruct(context, schema):
    appstruct = {}
    for field in schema.children:
        if hasattr(context, field.name):
            val = getattr(context, field.name)
            if val is None:
                val = colander.null
            appstruct[field.name] = val
    return appstruct


class ObjectType(colander.SchemaType):
    """ A type leaving the value untouched.
    """
    def serialize(self, node, value):
        return value

    def deserialize(self, node, value):
        return value


@colander.deferred
def deferred_tag_it_widget(node, kw):
    tagit.need()
    all_tags = Tag.query.all()
    available_tags = [tag.title.encode('utf-8') for tag in all_tags]
    widget = CommaSeparatedListWidget(template='tag_it',
                                      available_tags=available_tags)
    return widget


class Form(deform.Form):
    """
    A deform Form that allows 'appstruct' to be set on the instance.
    """

    def render(self, appstruct=None, readonly=False):
        if appstruct is None:
            appstruct = getattr(self, 'appstruct', colander.null)
        return super(Form, self).render(appstruct, readonly=readonly)


class BaseFormView(FormView):
    """
    A basic view for forms with save and cancel buttons.
    """

    form_class = Form
    buttons = (
        deform.Button('save', _(u'Save')),
        deform.Button('cancel', _(u'Cancel')))
    success_message = _(u"Your changes have been saved.")
    success_url = None
    schema_factory = None
    use_csrf_token = True
    add_template_vars = ()

    def __init__(self, context, request, **kwargs):
        self.context = context
        self.request = request
        self.__dict__.update(kwargs)

    def __call__(self):
        if self.schema_factory is not None:
            self.schema = self.schema_factory()
        if self.use_csrf_token and 'csrf_token' not in self.schema:
            self.schema.children.append(CSRFSchema()['csrf_token'])
        result = super(BaseFormView, self).__call__()
        if isinstance(result, dict):
            result.update(self.more_template_vars())
        return result

    def cancel_success(self, appstruct):
        location = self.request.resource_url(self.context)
        return HTTPFound(location=location)
    cancel_failure = cancel_success

    def more_template_vars(self):
        result = {}
        for name in self.add_template_vars:
            result[name] = getattr(self, name)
        return result


class EditFormView(BaseFormView):
    """
    A base form for content editing purposes.

    Set `self.schema_factory` to the context's schema.  Values of
    fields in this schema will be set as attributes on the context.
    An example::

        import colander
        from deform.widget import RichTextWidget

        from kotti.edit.content import ContentSchema
        from kotti.edit.content import EditFormView

        class DocumentSchema(ContentSchema):
            body = colander.SchemaNode(
                colander.String(),
                title=u'Body',
                widget=RichTextWidget(),
                missing=u'',
                )

        class DocumentEditForm(EditFormView):
            schema_factory = DocumentSchema
    """

    add_template_vars = ('first_heading',)

    def before(self, form):
        form.appstruct = get_appstruct(self.context, self.schema)

    def save_success(self, appstruct):
        appstruct.pop('csrf_token', None)
        self.edit(**appstruct)
        self.request.session.flash(self.success_message, 'success')
        location = self.success_url or self.request.resource_url(self.context)
        return HTTPFound(location=location)

    def edit(self, **appstruct):
        for key, value in appstruct.items():
            setattr(self.context, key, value)

    @reify
    def first_heading(self):
        return _(u'Edit ${title}',
                 mapping=dict(title=self.context.title)
                 )


class AddFormView(BaseFormView):
    """
    A base form for content adding purposes.

    Set `self.schema_factory` as with EditFormView.  Also set
    `item_type` to your model class.  An example::

        class DocumentAddForm(AddFormView):
            schema_factory = DocumentSchema
            add = Document
            item_type = u'Document'
    """

    success_message = _(u"Item was added.")
    item_type = None
    add_template_vars = ('first_heading',)

    def save_success(self, appstruct):
        appstruct.pop('csrf_token', None)
        name = self.find_name(appstruct)
        new_item = self.context[name] = self.add(**appstruct)
        self.request.session.flash(self.success_message, 'success')
        location = self.success_url or self.request.resource_url(new_item)
        return HTTPFound(location=location)

    def find_name(self, appstruct):
        name = appstruct.get('name')
        if name is None:
            name = title_to_name(
                appstruct['title'], blacklist=self.context.keys())
        return name

    @reify
    def first_heading(self):
        context_title = getattr(self.request.context, 'title', None)
        type_title = self.item_type or self.add.type_info.title
        if context_title:
            return _(u'Add ${type} to ${title}.',
                     mapping=dict(type=translate(type_title),
                                  title=context_title))
        else:
            return _(u'Add ${type}.', mapping=dict(type=translate(type_title)))


class CommaSeparatedListWidget(deform.widget.Widget):
    def serialize(self, field, cstruct, readonly=False):
        if cstruct in (colander.null, None):
            cstruct = []
        return field.renderer(self.template, field=field, cstruct=cstruct)

    def deserialize(self, field, pstruct):
        if pstruct is colander.null:
            return colander.null
        return [item.strip() for item in pstruct.split(',') if item]


class FileUploadTempStore(DictMixin):
    """
    A temporary storage for file file uploads

    File uploads are stored in the session so that you don't need
    to upload your file again if validation of another schema node
    fails.
    """

    def __init__(self, request):
        self.session = request.session

    def keys(self):
        return [k for k in self.session.keys() if not k.startswith('_')]

    def __setitem__(self, name, value):
        value = value.copy()
        fp = value.pop('fp')
        value['file_contents'] = fp.read()
        fp.seek(0)
        self.session[name] = value

    def __getitem__(self, name):
        value = self.session[name].copy()
        value['fp'] = StringIO(value.pop('file_contents'))
        return value

    def __delitem__(self, name):
        del self.session[name]

    def preview_url(self, name):
        return None


def validate_file_size_limit(node, value):
    """
    File size limit validator.

    You can configure the maximum size by setting the kotti.max_file_size
    option to the maximum number of bytes that you want to allow.
    """

    value['fp'].seek(0, 2)
    size = value['fp'].tell()
    value['fp'].seek(0)
    max_size = get_settings()['kotti.max_file_size']
    if size > int(max_size) * 1024 * 1024:
        msg = _('Maximum file size: ${size}MB', mapping={'size': max_size})
        raise colander.Invalid(node, msg)

########NEW FILE########
__FILENAME__ = image
"""
Views for image content objects.
"""

import PIL
from plone.scale.scale import scaleImage
from pyramid.response import Response
from pyramid.view import view_config
from pyramid.view import view_defaults

from kotti.interfaces import IImage
from kotti.util import extract_from_settings

PIL.ImageFile.MAXBLOCK = 33554432

#: Default image scales
image_scales = {
    'span1': [60, 120],
    'span2': [160, 320],
    'span3': [260, 520],
    'span4': [360, 720],
    'span5': [460, 920],
    'span6': [560, 1120],
    'span7': [660, 1320],
    'span8': [760, 1520],
    'span9': [860, 1720],
    'span10': [960, 1920],
    'span11': [1060, 2120],
    'span12': [1160, 2320],
    }


@view_defaults(context=IImage, permission='view')
class ImageView(object):
    """The ImageView class is registered for the :class:`IImage` context."""

    def __init__(self, context, request):

        self.context = context
        self.request = request

    @view_config(name='view',
                 renderer='kotti:templates/view/image.pt')
    def view(self):
        """
        :result: Empty dictionary to be handed to the image.pt template for rendering.
        :rtype: dict
        """

        return {}

    @view_config(name="image",)
    def image(self, subpath=None):
        """Return the image in a specific scale, either inline
        (default) or as attachment.

        :param subpath: [<image_scale>]/download] (optional).
                        When 'download' is the last element in subpath,
                        the image is served with a 'Content-Disposition: attachment'
                        header.  <image_scale> has to be one of the predefined
                        image_scales - either from the defaults in this module
                        or one set with a kotti.image_scales.<scale_name> in your
                        app config ini file.
        :type subpath: str

        :result: complete response object
        :rtype: pyramid.response.Response
        """

        if subpath is None:
            subpath = self.request.subpath

        width, height = (None, None)
        subpath = list(subpath)

        if (len(subpath) > 0) and (subpath[-1] == "download"):
            disposition = "attachment"
            subpath.pop()
        else:
            disposition = "inline"

        if len(subpath) == 1:
            scale = subpath[0]
            if scale in image_scales:
                # /path/to/image/scale/thumb
                width, height = image_scales[scale]

        if width and height:
            image, format, size = scaleImage(self.context.data,
                                             width=width,
                                             height=height,
                                             direction="thumb")
        else:
            image = self.context.data

        res = Response(
            headerlist=[('Content-Disposition', '%s;filename="%s"' % (
                disposition,
                self.context.filename.encode('ascii', 'ignore'))),
                ('Content-Length', str(len(image))),
                ('Content-Type', str(self.context.mimetype)),
            ],
            body=image,
            )

        return res


def _load_image_scales(settings):
    image_scale_strings = extract_from_settings(
        'kotti.image_scales.', settings)

    for k in image_scale_strings.keys():
        image_scales[k] = [int(x) for x in image_scale_strings[k].split("x")]


def includeme(config):
    _load_image_scales(config.registry.settings)

    config.scan(__name__)

########NEW FILE########
__FILENAME__ = login
# -*- coding: utf-8 -*-

"""
Login / logout and forbidden views and forms.
"""

from datetime import datetime

import colander
from deform import Button
from deform import Form
from deform import ValidationFailure
from deform.widget import CheckedPasswordWidget
from deform.widget import HiddenWidget
from formencode.validators import Email
from pyramid.encode import urlencode
from pyramid.httpexceptions import HTTPForbidden
from pyramid.httpexceptions import HTTPFound
from pyramid.security import authenticated_userid
from pyramid.security import forget
from pyramid.security import remember
from pyramid.url import resource_url
from pyramid.view import view_config
from pyramid.settings import asbool

from kotti import get_settings
from kotti.message import email_set_password
from kotti.message import validate_token
from kotti.security import get_principals
from kotti.util import _
from kotti.views.util import template_api
from kotti.views.users import deferred_email_validator
from kotti.views.users import name_pattern_validator
from kotti.views.users import name_new_validator
from kotti.views.users import UserAddFormView
from kotti.events import ObjectEvent
from kotti.events import notify


def _find_user(login):
    principals = get_principals()
    principal = principals.get(login)
    if principal is not None:
        return principal
    else:
        try:
            Email().to_python(login)
        except Exception:
            pass
        else:
            for p in principals.search(email=login):
                return p


class UserSelfRegistered(ObjectEvent):
    """ This event is emitted just after user self registered. Intended use
        is to allow addons to do some preparation for such user - create custom
        contents, nodes etc.
        Event handler object parameter is a Principal object
    """


class RegisterSchema(colander.Schema):
    title = colander.SchemaNode(
        colander.String(),
        title=_(u'Full name'))
    name = colander.SchemaNode(
        colander.String(),
        title=_(u'Username'),
        validator=colander.All(name_pattern_validator, name_new_validator)
    )
    email = colander.SchemaNode(
        colander.String(),
        title=_(u'Email'),
        validator=deferred_email_validator,
    )


@view_config(name='register', renderer='kotti:templates/edit/simpleform.pt',
    custom_predicates=(lambda info, request:
        asbool(request.registry.settings['kotti.register']),))
def register(context, request):
    schema = RegisterSchema().bind(request=request)
    form = Form(schema, buttons=(Button('register', _(u'Register')),))
    rendered_form = None

    if 'register' in request.POST:
        try:
            appstruct = form.validate(request.POST.items())
        except ValidationFailure, e:
            request.session.flash(_(u"There was an error."), 'error')
            rendered_form = e.render()
        else:
            settings = get_settings()

            appstruct['groups'] = u''
            appstruct['roles'] = u''

            register_groups = settings['kotti.register.group']
            if register_groups:
                appstruct['groups'] = [register_groups]

            register_roles = settings['kotti.register.role']
            if register_roles:
                appstruct['roles'] = set(['role:' + register_roles])

            appstruct['send_email'] = True
            form = UserAddFormView(context, request)
            form.add_user_success(appstruct)
            success_msg = _(
                'Congratulations! You are successfully registered. '
                'You should be receiving an email with a link to set your '
                'password. Doing so will activate your account.'
                )
            request.session.flash(success_msg, 'success')
            name = appstruct['name']
            notify(UserSelfRegistered(get_principals()[name], request))
            return HTTPFound(location=request.application_url)

    if rendered_form is None:
        rendered_form = form.render(request.params)

    api = template_api(
        context, request,
        page_title=_(u"Register - ${title}",
            mapping=dict(title=context.title)),
    )

    return {
        'api': api,
        'form': rendered_form,
        }


@view_config(name='login', renderer='kotti:templates/login.pt')
def login(context, request):
    """
    Login view.  Renders either the login or password forgot form templates or
    handles their form submission and redirects to came_from on success.

    :result: Either a redirect response or a dictionary passed to the template
             for rendering
    :rtype: pyramid.httpexceptions.HTTPFound or dict
    """

    principals = get_principals()

    came_from = request.params.get(
        'came_from', request.resource_url(context))
    login, password = u'', u''

    if 'submit' in request.POST:
        login = request.params['login'].lower()
        password = request.params['password']
        user = _find_user(login)

        if (user is not None and user.active and
                principals.validate_password(password, user.password)):
            headers = remember(request, user.name)
            request.session.flash(
                _(u"Welcome, ${user}!",
                  mapping=dict(user=user.title or user.name)), 'success')
            user.last_login_date = datetime.now()
            return HTTPFound(location=came_from, headers=headers)
        request.session.flash(_(u"Login failed."), 'error')

    if 'reset-password' in request.POST:
        login = request.params['login']
        user = _find_user(login)
        if user is not None and user.active:
            email_set_password(
                user, request,
                template_name='kotti:templates/email-reset-password.pt')
            request.session.flash(_(
                u"You should be receiving an email with a link to reset your "
                u"password. Doing so will activate your account."), 'success')
        else:
            request.session.flash(
                _(u"That username or email is not known by this system."), 'error')

    return {
        'url': request.application_url + '/@@login',
        'came_from': came_from,
        'login': login,
        'password': password,
        'register': asbool(get_settings()['kotti.register']),
        }


@view_config(name='logout')
def logout(context, request):
    """
    Logout view.  Always redirects the user to where he came from.

    :result: Redirect to came_from
    :rtype: pyramid.httpexceptions.HTTPFound
    """

    headers = forget(request)
    request.session.flash(_(u"You have been logged out."))
    location = request.params.get('came_from', request.application_url)
    return HTTPFound(location=location, headers=headers)


class SetPasswordSchema(colander.MappingSchema):
    """
    Schema for the set password form
    """

    #: colander.String
    password = colander.SchemaNode(
        colander.String(),
        title=_(u'Password'),
        validator=colander.Length(min=5),
        widget=CheckedPasswordWidget(),
        )
    #: colander.String
    token = colander.SchemaNode(
        colander.String(),
        widget=HiddenWidget(),
        )
    #: colander.String
    email = colander.SchemaNode(
        colander.String(),
        title=_(u'Email'),
        widget=HiddenWidget(),
        )
    #: colander.String
    continue_to = colander.SchemaNode(
        colander.String(),
        widget=HiddenWidget(),
        missing=colander.null,
        )


@view_config(name='set-password', renderer='kotti:templates/edit/simpleform.pt')
def set_password(context, request,
                 success_msg=_(u"You have reset your password.")):
    """
    Set password view.  Displays the set password form and handles its form
    submission.

    :param success_msg: Message to display on successful submission handling
    :type success_msg: str or TranslationString

    :result: Redirect response or dictionary passed to the template for
             rendering.
    :rtype: pyramid.httpexceptions.HTTPFound or dict
    """

    form = Form(SetPasswordSchema(), buttons=(Button('submit', _(u'Submit')),))
    rendered_form = None

    if 'submit' in request.POST:
        try:
            appstruct = form.validate(request.POST.items())
        except ValidationFailure, e:
            request.session.flash(_(u"There was an error."), 'error')
            rendered_form = e.render()
        else:
            token = appstruct['token']
            email = appstruct['email']
            user = _find_user(email)
            if (user is not None and
                    validate_token(user, token) and
                    token == user.confirm_token and
                    user.active):
                password = appstruct['password']
                user.password = get_principals().hash_password(password)
                user.confirm_token = None
                headers = remember(request, user.name)
                user.last_login_date = datetime.now()

                location = (appstruct['continue_to'] or
                            resource_url(context, request))
                request.session.flash(success_msg, 'success')
                return HTTPFound(location=location, headers=headers)
            else:
                request.session.flash(
                    _(u"Your password reset token may have expired."), 'error')

    if rendered_form is None:
        rendered_form = form.render(request.params)

    api = template_api(
        context, request,
        page_title=_(u"Reset your password - ${title}.",
                     mapping=dict(title=context.title)),
        )

    return {
        'api': api,
        'form': rendered_form,
        }


@view_config(context=HTTPForbidden, accept='text/html',)
def forbidden_redirect(context, request):
    """
    Forbidden redirect view.  Redirects to the login form for anonymous users or
    to the forbidden view for authenticated users.

    :result: Redirect to one of the above.
    :rtype: pyramid.httpexceptions.HTTPFound
    """

    if authenticated_userid(request):
        location = request.application_url + '/@@forbidden'
    else:
        location = request.application_url + '/@@login?' + urlencode(
            {'came_from': request.url})
    return HTTPFound(location=location)


@view_config(context=HTTPForbidden)
def forbidden_view(request):
    """
    Forbidden view.  Raises 403 for requests not originating from a web browser
    like device.

    :result: 403
    :rtype: pyramid.httpexceptions.HTTPForbidden
    """

    return request.exception


@view_config(name='forbidden', renderer='kotti:templates/forbidden.pt')
def forbidden_view_html(request):
    """
    Forbidden view for browsers.

    :result: empty dictionary passed to the template for rendering
    :rtype: dict
    """

    return {}


def includeme(config):
    config.scan(__name__)

########NEW FILE########
__FILENAME__ = navigation
# -*- coding: utf-8 -*-

"""
This module contains navigation related views.
"""

from pyramid.view import view_config

from kotti.interfaces import INavigationRoot
from kotti.resources import get_root
from kotti.security import has_permission


@view_config(name='render_tree_navigation', permission='view',
             renderer='kotti:templates/edit/nav-tree.pt')
@view_config(name='navigate', permission='view',
             renderer='kotti:templates/edit/nav-tree-view.pt')
def render_tree_navigation(context, request):
    """ Renders the navigation view.

    :result: Dictionary passed to the template for rendering.
    :rtype: dict
    """

    # Import is needed in function scope to resolve circular imports caused by
    # compatibility imports in slots.py.
    from kotti.views.util import nodes_tree

    tree = nodes_tree(request)

    return {
        'tree': {
            'children': [tree],
        },
    }


@view_config(name='local-navigation',
             renderer='kotti:templates/view/nav-local.pt')
def local_navigation(context, request):

    def ch(node):
        return [child for child in node.values()
                if child.in_navigation and
                has_permission('view', child, request)]

    parent = context
    children = ch(context)
    if not children and context.__parent__ is not None:
        parent = context.__parent__
        children = ch(parent)
    if len(children) and parent != get_root() and not \
            INavigationRoot.providedBy(parent):
        return dict(parent=parent, children=children)
    return dict(parent=None)


def includeme_local_navigation(config):
    # Import is needed in function scope to resolve circular imports caused by
    # compatibility imports in slots.py.
    from kotti.views.slots import assign_slot
    config.scan(__name__)
    assign_slot('local-navigation', 'right')


def includeme(config):
    config.scan(__name__)

########NEW FILE########
__FILENAME__ = slots
"""This module allows add-ons to assign views to slots defined in
the overall page.  In other systems, these are called portlets or
viewlets.

A simple example that'll include the output of the 'hello_world' view
in in the left column of every page::

  from kotti.views.slots import assign_slot
  assign_slot('hello_world', 'left')

It is also possible to pass parameters to the view::

  assign_slot('last_tweets', 'right', params=dict(user='foo'))

In the view you can get the slot in that the view is rendered from
the request::

    @view_config(name='last_tweets')
    def view(request, context):
        slot = request.kotti_slot
        # ...

If no view can be found for the given request and slot, the slot
remains empty.  If you want to force your slot not to be rendered,
raise :class:`pyramid.exceptions.PredicateMismatch` inside your view::

    from pyramid.exceptions import PredicateMismatch

    @view_config(name='last_tweets')
    def view(request, context):
        if some_condition:
            raise PredicateMismatch()
        return {...}

Usually you'll want to call :func:`kotti.views.slots.assign_slot`
inside an ``includeme`` function and not on a module level, to allow
users of your package to include your slot assignments through the
``pyramid.includes`` configuration setting.
"""

import urllib

from pyramid.exceptions import PredicateMismatch
from pyramid.request import Request
from pyramid.view import render_view

from kotti.events import ObjectEvent
from kotti.events import objectevent_listeners

REQUEST_ATTRS_TO_COPY = ('context', 'registry', 'user', 'cookies')


def _encode(params):
    if not params:
        return u''
    return urllib.urlencode(
        dict((k, v.encode('utf-8')) for k, v in params.items()))


def _render_view_on_slot_event(view_name, event, params):
    context = event.object
    request = event.request

    view_request = Request.blank(
        "{0}/{1}".format(request.path.rstrip('/'), view_name),
        base_url=request.application_url,
        POST=_encode(params))

    post_items = request.POST.items()
    if post_items:
        view_request.POST.extend(post_items)

    # This is quite brittle:
    for name in REQUEST_ATTRS_TO_COPY:
        setattr(view_request, name, getattr(request, name))
    setattr(view_request, 'kotti_slot', event.name)

    try:
        result = render_view(context, view_request, view_name)
    except PredicateMismatch:
        return None
    else:
        return result.decode('utf-8')


def assign_slot(view_name, slot, params=None):
    """Assign view to slot.

    :param view_name: Name of the view to assign.
    :type view_name: str

    :param slot: Name of the slot to assign to.  Possible values are: left,
                 right, abovecontent, belowcontent, inhead, beforebodyend,
                 edit_inhead
    :type slot: str

    :param params: Optionally allows to pass POST parameters to the view.
    :type params: dict
    """

    event = [e for e in slot_events if e.name == slot]
    if not event:
        raise KeyError("Unknown slot '{0}'".format(slot))
    objectevent_listeners[(event[0], None)].append(
        lambda ev: _render_view_on_slot_event(view_name, ev, params))


class RenderLeftSlot(ObjectEvent):
    name = u'left'


class RenderRightSlot(ObjectEvent):
    name = u'right'


class RenderAboveContent(ObjectEvent):
    name = u'abovecontent'


class RenderBelowContent(ObjectEvent):
    name = u'belowcontent'


class RenderInHead(ObjectEvent):
    name = u'inhead'


class RenderBeforeBodyEnd(ObjectEvent):
    name = u'beforebodyend'


class RenderEditInHead(ObjectEvent):
    name = u'edit_inhead'

slot_events = [
    RenderLeftSlot, RenderRightSlot, RenderAboveContent, RenderBelowContent,
    RenderInHead, RenderBeforeBodyEnd, RenderEditInHead, ]


# BBB starts here --- --- --- --- --- ---

from zope.deprecation import deprecated

# The remainder of this file will be removed in Kotti 0.11 or 1.1, whichever
# will be the version number we chose.

from kotti.views.navigation import local_navigation
from kotti.views.navigation import includeme_local_navigation

local_navigation = local_navigation
includeme_local_navigation = includeme_local_navigation

deprecated(
    'local_navigation',
    'deprecated as of Kotti 0.9.  Use '
    'kotti.views.navigation.local_navigation instead.'
)
deprecated(
    'includeme_local_navigation',
    'deprecated as of Kotti 0.9.  Use '
    'kotti.views.navigation.includeme_local_navigation instead.'
)

########NEW FILE########
__FILENAME__ = users
"""User management screens
"""

import re
from urllib import urlencode

import colander
from deform import Button
from deform.widget import AutocompleteInputWidget
from deform.widget import CheckboxChoiceWidget
from deform.widget import CheckedPasswordWidget
from deform.widget import SequenceWidget
from pyramid.exceptions import Forbidden
from pyramid.httpexceptions import HTTPFound
from pyramid.view import view_config
from pyramid_deform import FormView

from kotti.events import UserDeleted
from kotti.events import notify
from kotti.message import email_set_password
from kotti.resources import get_root
from kotti.security import ROLES
from kotti.security import SHARING_ROLES
from kotti.security import USER_MANAGEMENT_ROLES
from kotti.security import get_principals
from kotti.security import list_groups_ext
from kotti.security import list_groups_raw
from kotti.security import map_principals_with_local_roles
from kotti.security import set_groups
from kotti.util import _
from kotti.views.form import AddFormView
from kotti.views.form import EditFormView
from kotti.views.site_setup import CONTROL_PANEL_LINKS
from kotti.views.util import is_root
from kotti.views.util import template_api


def roles_form_handler(context, request, available_role_names, groups_lister):
    changed = []

    if 'apply' in request.POST:
        p_to_r = {}
        for name in request.params:
            if name.startswith('orig-role::'):
                # orig-role::* is hidden checkboxes that allow us to
                # see what checkboxes were in the form originally
                token, principal_name, role_name = unicode(name).split(u'::')
                if role_name not in available_role_names:
                    raise Forbidden()
                new_value = bool(request.params.get(
                    'role::%s::%s' % (principal_name, role_name)))
                if principal_name not in p_to_r:
                    p_to_r[principal_name] = set()
                if new_value:
                    p_to_r[principal_name].add(role_name)

        for principal_name, new_role_names in p_to_r.items():
            # We have to be careful with roles that aren't mutable here:
            orig_role_names = set(
                groups_lister(principal_name, context))
            orig_sharing_role_names = set(
                r for r in orig_role_names if r in available_role_names)
            if new_role_names != orig_sharing_role_names:
                final_role_names = orig_role_names - set(available_role_names)
                final_role_names |= new_role_names
                changed.append((principal_name, context, final_role_names))

        if changed:
            request.session.flash(
                _(u'Your changes have been saved.'), 'success')
        else:
            request.session.flash(_(u'No changes were made.'), 'info')

    return changed


def search_principals(request, context=None, ignore=None, extra=()):
    flash = request.session.flash
    principals = get_principals()

    if ignore is None:
        ignore = set()

    entries = []
    for principal_name in extra:
        if principal_name not in ignore:
            p = principals[principal_name]
            entries.append((p, list_groups_ext(principal_name, context)))
            ignore.add(principal_name)

    if 'search' in request.POST:
        query = '*%s*' % request.params['query']
        found = False
        for p in principals.search(name=query, title=query, email=query):
            found = True
            if p.name not in ignore:
                entries.append((p, list_groups_ext(p.name, context)))
        if not found:
            flash(_(u'No users or groups were found.'), 'info')

    return entries


@view_config(name='share', permission='manage',
             renderer='kotti:templates/edit/share.pt')
def share_node(context, request):
    # Allow roles_form_handler to do processing on 'apply':
    changed = roles_form_handler(
        context, request, SHARING_ROLES, list_groups_raw)
    if changed:
        for (principal_name, context, groups) in changed:
            set_groups(principal_name, context, groups)
        return HTTPFound(location=request.url)

    existing = map_principals_with_local_roles(context)

    def with_roles(entry):
        all_groups = entry[1][0]
        return [g for g in all_groups if g.startswith('role:')]

    existing = filter(with_roles, existing)
    seen = set([entry[0].name for entry in existing])

    # Allow search to take place and add some entries:
    entries = existing + search_principals(request, context, ignore=seen)
    available_roles = [ROLES[role_name] for role_name in SHARING_ROLES]

    return {
        'entries': entries,
        'available_roles': available_roles,
        }


def name_pattern_validator(node, value):
    """
      >>> name_pattern_validator(None, u'bob')
      >>> name_pattern_validator(None, u'b ob')
      Traceback (most recent call last):
      Invalid: <unprintable Invalid object>
      >>> name_pattern_validator(None, u'b:ob')
      Traceback (most recent call last):
      Invalid: <unprintable Invalid object>
    """
    valid_pattern = re.compile(r"^[a-zA-Z0-9_\-\.]+$")
    if not valid_pattern.match(value):
        raise colander.Invalid(node, _(u"Invalid value"))


def name_new_validator(node, value):
    if get_principals().get(value.lower()) is not None:
        raise colander.Invalid(
            node, _(u"A user with that name already exists."))


@colander.deferred
def deferred_email_validator(node, kw):
    def raise_invalid_email(node, value):
        raise colander.Invalid(
            node, _(u"A user with that email already exists."))
    request = kw['request']
    if request.POST:
        email = request.params.get('email')
        name = request.params.get('name')
        if not name and request.user:
            name = request.user.name
        if email and name:
            principals = get_principals()
            if any(p for p in principals.search(email=email)
                   if p.name.lower() != name.lower()):
                # verify duplicated email except myself when update info
                return raise_invalid_email


def roleset_validator(node, value):
    oneof = colander.OneOf(USER_MANAGEMENT_ROLES)
    [oneof(node, item) for item in value]


def group_validator(node, value):
    principals = get_principals()
    if principals.get('group:' + value) is None:
        raise colander.Invalid(node, _(u"No such group: ${group}",
                                       mapping=dict(group=value)))


class Groups(colander.SequenceSchema):
    group = colander.SchemaNode(
        colander.String(),
        title=_(u'Group'),
        validator=group_validator,
        missing=None,
        widget=AutocompleteInputWidget(),
        )


class PrincipalBasic(colander.MappingSchema):
    title = colander.SchemaNode(colander.String(), title=_(u'Title'))
    email = colander.SchemaNode(
        colander.String(),
        title=_(u'Email'),
        validator=deferred_email_validator,
    )


class PrincipalFull(PrincipalBasic):
    name = colander.SchemaNode(
        colander.String(),
        title=_(u'Name'),
        validator=colander.All(name_pattern_validator, name_new_validator),
        )
    password = colander.SchemaNode(
        colander.String(),
        title=_(u'Password'),
        validator=colander.Length(min=5),
        missing=None,
        widget=CheckedPasswordWidget(),
        )
    active = colander.SchemaNode(
        colander.Boolean(),
        title=_(u'Active'),
        description=_(u"Untick this to deactivate the account."),
        )
    roles = colander.SchemaNode(
        colander.Set(),
        validator=roleset_validator,
        missing=[],
        title=_(u"Global roles"),
        widget=CheckboxChoiceWidget(),
        )
    groups = Groups(
        title=_(u'Groups'),
        missing=[],
        # XXX min_len doesn't really do what we want here.  We'd like
        # the close buttons to appear nevertheless (maybe the now
        # deprecated render_initial_item did exactly that).
        widget=SequenceWidget(min_len=1),
        )


def principal_schema(base=PrincipalFull()):
    principals = get_principals()
    schema = base.clone()
    has_groups = True
    try:
        schema['groups']
    except KeyError:
        has_groups = False
    if has_groups:
        all_groups = []
        for p in principals.search(name=u'group:*'):
            value = p.name.split(u'group:')[1]
            label = u"%s, %s" % (p.title, value)
            all_groups.append(dict(value=value, label=label))
        schema['groups']['group'].widget.values = all_groups
        schema['roles'].widget.values = [
            (n, ROLES[n].title) for n in USER_MANAGEMENT_ROLES]
    return schema


def user_schema(base=PrincipalFull()):
    schema = principal_schema(base)
    has_password = True
    try:
        schema['password']
    except KeyError:
        has_password = False
    if has_password:
        schema['password'].description = _(
            u"Leave this empty and tick the 'Send password registration' "
            u"box below to have the user set their own password.")
    schema['title'].title = _(u"Full name")
    return schema


def group_schema(base=PrincipalFull()):
    schema = principal_schema(base)
    del schema['password']
    schema['email'].missing = None
    return schema


def _massage_groups_in(appstruct):
    """Manipulate appstruct received from form so that it's suitable
    for saving on the Principal.

    What we do for groups is we prefix them with 'group:'.  And the
    'roles' in the form are really groups too, so we add to 'groups'.

    The value in the form is 'name', not 'group:name', so we'll
    need to append that before we save.
    """
    groups = appstruct.get('groups', [])
    all_groups = list(appstruct.get('roles', [])) + [
        u'group:%s' % g for g in groups if g]
    if 'roles' in appstruct:
        del appstruct['roles']
    appstruct['groups'] = all_groups


def _massage_groups_out(appstruct):
    """Opposite of '_massage_groups_in': remove 'groups:' prefix and
    split 'groups' into 'roles' and 'groups'.
    """
    d = appstruct
    groups = [g.split(u'group:')[1] for g in d.get('groups', u'')
              if g and g.startswith(u'group:')]
    roles = [r for r in d.get('groups', u'') if r and r.startswith(u'role:')]
    d['groups'] = groups
    d['roles'] = roles
    return d


class UserAddFormView(AddFormView):
    item_type = _(u'User')
    form_options = (('formid', 'deform_user_add'), )
    buttons = (Button('add_user', _(u'Add User')),
               Button('cancel', _(u'Cancel')))

    def schema_factory(self):
        schema = user_schema()
        del schema['active']
        schema.add(colander.SchemaNode(
            colander.Boolean(),
            name=u'send_email',
            title=_(u'Send password registration link.'),
            default=True,
            ))
        return schema

    def add_user_success(self, appstruct):
        appstruct.pop('csrf_token', None)
        _massage_groups_in(appstruct)
        name = appstruct['name'] = appstruct['name'].lower()
        appstruct['email'] = appstruct['email'] and appstruct['email'].lower()
        send_email = appstruct.pop('send_email', False)
        get_principals()[name] = appstruct
        if send_email:
            email_set_password(get_principals()[name], self.request)
        self.request.session.flash(
            _(u'${title} was added.',
              mapping=dict(title=appstruct['title'])), 'success')
        location = self.request.url.split('?')[0] + '?' + urlencode(
            {'extra': name})
        return HTTPFound(location=location)


class GroupAddFormView(UserAddFormView):
    item_type = _(u"Group")
    form_options = (('formid', 'deform_group_add'), )
    buttons = (Button('add_group', _(u'Add Group')),
               Button('cancel', _(u'Cancel')))

    def schema_factory(self):
        schema = group_schema()
        del schema['active']
        return schema

    def add_group_success(self, appstruct):
        appstruct['name'] = u'group:%s' % appstruct['name'].lower()
        return self.add_user_success(appstruct)


@view_config(name='setup-users', permission='admin',
             custom_predicates=(is_root,),
             renderer='kotti:templates/site-setup/users.pt')
class UsersManage(FormView):

    UserAddFormView = UserAddFormView
    GroupAddFormView = GroupAddFormView

    def __init__(self, context, request):
        self.context = context
        self.request = request

    def __call__(self):
        api = template_api(self.context, self.request,
                           cp_links=CONTROL_PANEL_LINKS)

        api.page_title = _(u"User Management")

        principals = get_principals()

        def groups_lister(principal_name, context):
            return principals[principal_name].groups

        # Handling the user/roles matrix:
        changed = roles_form_handler(
            self.context, self.request, USER_MANAGEMENT_ROLES, groups_lister)
        if changed:
            changed_names = []
            for (principal_name, context, groups) in changed:
                principal = principals[principal_name]
                principal.groups = list(groups)
                changed_names.append(principal_name)
            location = self.request.url.split('?')[0] + '?' + urlencode(
                {'extra': ','.join(changed_names)})
            return HTTPFound(location=location)

        extra = self.request.params.get('extra') or ()
        if extra:
            extra = extra.split(',')
        search_entries = search_principals(self.request, extra=extra)
        available_roles = [ROLES[role_name]
                           for role_name in USER_MANAGEMENT_ROLES]

        # Add forms:
        user_addform = self.UserAddFormView(self.context, self.request)()
        if self.request.is_response(user_addform):
            return user_addform

        group_addform = self.GroupAddFormView(self.context, self.request)()
        if self.request.is_response(group_addform):
            return group_addform

        if self.request.params.get('add_user'):
            active_tab = 'add_user'
        elif self.request.params.get('add_group'):
            active_tab = 'add_group'
        else:
            active_tab = 'search'
        return {
            'api': api,
            'entries': search_entries,
            'available_roles': available_roles,
            'user_addform': user_addform['form'],
            'group_addform': group_addform['form'],
            'active_tab': active_tab,
        }


class UserEditFormView(EditFormView):
    @property
    def success_url(self):
        return self.request.url

    def schema_factory(self):
        return user_schema(PrincipalBasic())


class UserManageFormView(UserEditFormView):

    buttons = (Button('save', _(u'Save')),
               Button('cancel', _(u'Cancel')),
               Button('delete', _(u'Delete'), css_class='btn btn-danger'))

    def schema_factory(self):
        schema = user_schema()
        del schema['name']
        return schema

    def before(self, form):
        context = self.context.__dict__.copy()
        context['password'] = u''
        form.appstruct = _massage_groups_out(context)

    def save_success(self, appstruct):
        if appstruct.get('password'):
            hashed = get_principals().hash_password(appstruct['password'])
            appstruct['password'] = hashed
        else:
            appstruct.pop('password', None)
        _massage_groups_in(appstruct)
        return super(UserEditFormView, self).save_success(appstruct)

    def cancel_success(self, appstruct):
        self.request.session.flash(_(u'No changes were made.'), 'info')
        location = "%s/@@setup-users" % self.request.application_url
        return HTTPFound(location=location)
    cancel_failure = cancel_success

    def delete_success(self, appstruct):
        location = "%s/@@delete-user?name=%s" % (
            self.request.application_url, self.request.params['name'])
        return HTTPFound(location=location)


class GroupManageFormView(UserManageFormView):
    def schema_factory(self):
        schema = group_schema()
        del schema['name']
        del schema['active']
        return schema


@view_config(name='setup-user', permission='admin',
             custom_predicates=(is_root, ),
             renderer='kotti:templates/site-setup/user.pt')
class UserManage(FormView):

    GroupManageFormView = GroupManageFormView
    UserManageFormView = UserManageFormView

    def __init__(self, context, request):
        self.context = context
        self.request = request

    def __call__(self):
        user_or_group = self.request.params['name']
        principal = get_principals()[user_or_group]

        is_group = user_or_group.startswith("group:")
        principal_type = _(u"Group") if is_group else _(u"User")

        api = template_api(
            self.context, self.request,
            page_title=_(u"Edit ${principal_type} ${title}",
                         mapping=dict(principal_type=principal_type,
                                      title=self.context.title)),
            cp_links=CONTROL_PANEL_LINKS,
            principal=principal)

        form_view = self.GroupManageFormView if is_group \
            else self.UserManageFormView
        form = form_view(principal, self.request)()
        if self.request.is_response(form):
            return form

        return {
            'api': api,
            'form': form['form'],
            }


@view_config(name='delete-user', permission='admin',
             custom_predicates=(is_root,),
             renderer='kotti:templates/site-setup/delete-user.pt')
def user_delete(context, request):
    principals = get_principals()

    if 'name' in request.params and request.params['name']:
        user_or_group = request.params['name']
        principal = principals.search(name=user_or_group).first()
        if principal is None:
            request.session.flash(_(u'User was not found.'), 'error')
        else:
            is_group = user_or_group.startswith("group:")
            principal_type = _(u"Group") if is_group else _(u"User")

            # We already coming from the confirmation page.
            if 'delete' in request.POST:
                principals.__delitem__(principal.name)
                notify(UserDeleted(principal, request))
                request.session.flash(
                    _(u'${principal_type} ${title} was deleted.',
                      mapping=dict(principal_type=principal_type,
                                   title=principal.title)), 'info')
                location = "%s/@@setup-users" % request.application_url
                return HTTPFound(location=location)

            api = template_api(
                context, request,
                page_title=_(u"Delete ${principal_type} ${title}",
                             mapping=dict(principal_type=principal_type,
                                          title=principal.title)),
                principal_type=principal_type,
                principal=principal)
            return {'api': api, }
    else:
        request.session.flash(_(u'No name was given.'), 'error')

    return {'api': template_api(context, request), }


class PreferencesFormView(UserEditFormView):

    def cancel_success(self, appstruct):
        location = self.request.resource_url(get_root())
        return HTTPFound(location=location)
    cancel_failure = cancel_success


@view_config(name='prefs', custom_predicates=(is_root, ),
             renderer='kotti:templates/edit/simpleform.pt')
class Preferences(FormView):

    PreferencesFormView = PreferencesFormView

    def __init__(self, context, request):
        self.context = context
        self.request = request

    def __call__(self):
        user = self.request.user
        if user is None:
            raise Forbidden()

        api = template_api(self.context, self.request)
        api.page_title = _(u"My preferences - ${title}",
                           mapping=dict(title=api.site_title))

        form = self.PreferencesFormView(user, self.request)()

        if self.request.is_response(form):
            return form

        return {
            'api': api,
            'form': form['form'],
            'macro': api.macro('kotti:templates/site-setup/master.pt'),
            }


def includeme(config):
    config.scan(__name__)

########NEW FILE########
__FILENAME__ = util
import hashlib
import urllib
from collections import defaultdict
from datetime import datetime

from babel.dates import format_date
from babel.dates import format_datetime
from babel.dates import format_time
from pyramid.decorator import reify
from pyramid.i18n import get_locale_name
from pyramid.location import inside
from pyramid.location import lineage
from pyramid.renderers import get_renderer
from pyramid.renderers import render
from sqlalchemy import and_
from sqlalchemy import not_
from sqlalchemy import or_
from zope.deprecation.deprecation import deprecate
from zope.deprecation import deprecated

from kotti import DBSession
from kotti import get_settings
from kotti.events import objectevent_listeners
from kotti.interfaces import INavigationRoot
from kotti.resources import Content
from kotti.resources import Document
from kotti.resources import Tag
from kotti.resources import TagsToContents
from kotti.security import has_permission
from kotti.security import view_permitted
from kotti.util import render_view
from kotti.util import TemplateStructure
from kotti.views.site_setup import CONTROL_PANEL_LINKS
from kotti.views.slots import slot_events


def template_api(context, request, **kwargs):
    return get_settings()['kotti.templates.api'][0](
        context, request, **kwargs)


def add_renderer_globals(event):
    if event['renderer_name'] != 'json':
        request = event['request']
        api = getattr(request, 'template_api', None)
        if api is None and request is not None:
            api = template_api(event['context'], event['request'])
        event['api'] = api


def is_root(context, request):
    return context is request.root


class Slots(object):
    def __init__(self, context, request):
        self.context = context
        self.request = request

    def __getattr__(self, name):
        for event_type in slot_events:
            if event_type.name == name:
                break
        else:
            raise AttributeError(name)
        value = []
        event = event_type(self.context, self.request)
        for snippet in objectevent_listeners(event):
            if snippet is not None:
                if isinstance(snippet, list):
                    value.extend(snippet)
                else:
                    value.append(snippet)
        setattr(self, name, value)
        return value


class TemplateAPI(object):
    """This implements the 'api' object that's passed to all
    templates.

    Use dict-access as a shortcut to retrieve template macros from
    templates.
    """
    # Instead of overriding these, consider using the
    # 'kotti.overrides' variable.
    BARE_MASTER = 'kotti:templates/master-bare.pt'
    VIEW_MASTER = 'kotti:templates/view/master.pt'
    EDIT_MASTER = 'kotti:templates/edit/master.pt'
    SITE_SETUP_MASTER = 'kotti:templates/site-setup/master.pt'

    body_css_class = ''

    def __init__(self, context, request, bare=None, **kwargs):
        self.context, self.request = context, request

        if getattr(request, 'template_api', None) is None:
            request.template_api = self

        self.S = get_settings()
        if request.is_xhr and bare is None:
            bare = True  # use bare template that renders just the content area
        self.bare = bare
        self.slots = Slots(context, request)
        self.__dict__.update(kwargs)

    @reify
    def edit_needed(self):
        if 'kotti.fanstatic.edit_needed' in self.S:
            return [r.need() for r in self.S['kotti.fanstatic.edit_needed']]

    @reify
    def view_needed(self):
        if 'kotti.fanstatic.view_needed' in self.S:
            return [r.need() for r in self.S['kotti.fanstatic.view_needed']]

    def macro(self, asset_spec, macro_name='main'):
        if self.bare and asset_spec in (
                self.VIEW_MASTER, self.EDIT_MASTER, self.SITE_SETUP_MASTER):
            asset_spec = self.BARE_MASTER
        return get_renderer(asset_spec).implementation().macros[macro_name]

    @reify
    def site_title(self):
        """
        The site title.

        :result: Value of ``kotti.site_title`` (if specified) or the root
        item's ``title`` attribute.
        :rtype: unicode
        """
        value = get_settings().get('kotti.site_title')
        if not value:
            value = self.root.title
        return value

    @reify
    def page_title(self):
        """
        Title for the current page as used in the ``<head>`` section of the
        default ``master.pt`` template.

        :result: '[Human readable view title ]``context.title`` -
                 :meth:`~TemplateAPI.site_title`''
        :rtype: unicode
        """

        view_title = self.request.view_name.replace('_', ' ').title()
        if view_title:
            view_title += u' '
        view_title += self.context.title
        return u'%s - %s' % (view_title, self.site_title)

    def url(self, context=None, *elements, **kwargs):
        """
        URL construction helper. Just a convenience wrapper for
        :func:`pyramid.request.resource_url` with the same signature.  If
        ``context`` is ``None`` the current context is passed to
        ``resource_url``.
        """

        if context is None:
            context = self.context
        return self.request.resource_url(context, *elements, **kwargs)

    @reify
    def root(self):
        """
        The site root.

        :result: The root object of the site.
        :rtype: :class:`kotti.resources.Node`
        """
        return self.lineage[-1]

    @reify
    def navigation_root(self):
        """
        The root node for the navigation.

        :result: Nearest node in the :meth:`lineage` that provides
                 :class:`kotti.interfaces.INavigationRoot` or :meth:`root` if
                 no node provides that interface.
        :rtype: :class:`kotti.resources.Node`
        """
        for o in self.lineage:
            if INavigationRoot.providedBy(o):
                return o
        return self.root

    @reify
    def lineage(self):
        """
        Lineage from current context to the root node.

        :result: List of nodes.
        :rtype: list of :class:`kotti.resources.Node`
        """
        return list(lineage(self.context))

    @reify
    def breadcrumbs(self):
        """
        List of nodes from the :meth:`navigation_root` to the context.

        :result: List of nodes.
        :rtype: list of :class:`kotti.resources.Node`
        """
        breadcrumbs = self.lineage
        if self.root != self.navigation_root:
            index = breadcrumbs.index(self.navigation_root)
            breadcrumbs = breadcrumbs[:index + 1]
        return reversed(breadcrumbs)

    def has_permission(self, permission, context=None):
        """ Convenience wrapper for :func:`pyramid.security.has_permission`
        with the same signature.  If ``context`` is ``None`` the current
        context is passed to ``has_permission``."""
        if context is None:
            context = self.context
        return has_permission(permission, context, self.request)

    def render_view(self, name='', context=None, request=None, secure=True,
                    bare=True):
        if context is None:
            context = self.context
        if request is None:
            request = self.request

        before = self.bare
        try:
            self.bare = bare
            html = render_view(context, request, name, secure)
        finally:
            self.bare = before
        return TemplateStructure(html)

    def render_template(self, renderer, **kwargs):
        return TemplateStructure(render(renderer, kwargs, self.request))

    def list_children(self, context=None, permission='view'):
        if context is None:
            context = self.context
        children = []
        if hasattr(context, 'values'):
            for child in context.values():
                if (not permission or
                        has_permission(permission, child, self.request)):
                    children.append(child)
        return children

    inside = staticmethod(inside)

    def avatar_url(self, user=None, size="14", default_image='identicon'):
        if user is None:
            user = self.request.user
        email = user.email
        if not email:
            email = user.name
        h = hashlib.md5(email).hexdigest()
        query = {'default': default_image, 'size': str(size)}
        url = 'https://secure.gravatar.com/avatar/%s?%s' % (
            h, urllib.urlencode(query))
        return url

    @reify
    def locale_name(self):
        return get_locale_name(self.request)

    def format_date(self, d, format=None):
        if format is None:
            format = self.S['kotti.date_format']
        return format_date(d, format=format, locale=self.locale_name)

    def format_datetime(self, dt, format=None):
        if format is None:
            format = self.S['kotti.datetime_format']
        if not isinstance(dt, datetime):
            dt = datetime.fromtimestamp(dt)
        return format_datetime(dt, format=format, locale=self.locale_name)

    def format_time(self, t, format=None):
        if format is None:
            format = self.S['kotti.time_format']
        return format_time(t, format=format, locale=self.locale_name)

    def get_type(self, name):
        for class_ in get_settings()['kotti.available_types']:
            if class_.type_info.name == name:
                return class_

    def find_edit_view(self, item):
        view_name = self.request.view_name
        if not view_permitted(item, self.request, view_name):
            view_name = u'edit'
        if not view_permitted(item, self.request, view_name):
            view_name = u''
        return view_name

    @reify
    def edit_links(self):
        if not hasattr(self.context, 'type_info'):
            return []
        return [l for l in self.context.type_info.edit_links
                if l.visible(self.context, self.request)]

    @reify
    def site_setup_links(self):
        return [l for l in CONTROL_PANEL_LINKS
                if l.visible(self.root, self.request)]


@deprecate("'ensure_view_selector' is deprecated as of Kotti 0.8. "
           "There is no replacement.")
def ensure_view_selector(func):  # pragma: no cover
    return func


class NodesTree(object):
    def __init__(self, node, request, item_mapping, item_to_children,
                 permission):
        self._node = node
        self._request = request
        self._item_mapping = item_mapping
        self._item_to_children = item_to_children
        self._permission = permission

    @property
    def __parent__(self):
        if self.parent_id:
            return self._item_mapping[self.parent_id]

    @property
    def children(self):
        return [
            NodesTree(
                child,
                self._request,
                self._item_mapping,
                self._item_to_children,
                self._permission,
            )
            for child in self._item_to_children[self.id]
            if has_permission(self._permission, child, self._request)
        ]

    def _flatten(self, item):
        yield item._node
        for ch in item.children:
            for item in self._flatten(ch):
                yield item

    def tolist(self):
        return list(self._flatten(self))

    def __getattr__(self, name):
        return getattr(self._node, name)


def nodes_tree(request, context=None, permission='view'):
    item_mapping = {}
    item_to_children = defaultdict(lambda: [])
    for node in DBSession.query(Content).with_polymorphic(Content):
        item_mapping[node.id] = node
        if has_permission('view', node, request):
            item_to_children[node.parent_id].append(node)

    for children in item_to_children.values():
        children.sort(key=lambda ch: ch.position)

    if context is None:
        node = item_to_children[None][0]
    else:
        node = context

    return NodesTree(
        node,
        request,
        item_mapping,
        item_to_children,
        permission,
    )


def search_content(search_term, request=None):
    return get_settings()['kotti.search_content'][0](search_term, request)


def default_search_content(search_term, request=None):

    searchstring = u'%%%s%%' % search_term

    # generic_filter can be applied to all Node (and subclassed) objects
    generic_filter = or_(Content.name.like(searchstring),
                         Content.title.like(searchstring),
                         Content.description.like(searchstring))

    results = DBSession.query(Content).filter(generic_filter).\
        order_by(Content.title.asc()).all()

    # specific result contain objects matching additional criteria
    # but must not match the generic criteria (because these objects
    # are already in the generic_results)
    document_results = DBSession.query(Document).filter(
        and_(Document.body.like(searchstring),
             not_(generic_filter)))

    for results_set in [content_with_tags([searchstring]),
                        document_results.all()]:
        [results.append(c) for c in results_set if not c in results]

    result_dicts = []

    for result in results:
        if has_permission('view', result, request):
            result_dicts.append(dict(
                name=result.name,
                title=result.title,
                description=result.description,
                path=request.resource_path(result)))

    return result_dicts


def content_with_tags(tag_terms):

    return DBSession.query(Content).join(TagsToContents).join(Tag).filter(
        or_(*[Tag.title.like(tag_term) for tag_term in tag_terms])).all()


def search_content_for_tags(tags, request=None):

    result_dicts = []

    for result in content_with_tags(tags):
        if has_permission('view', result, request):
            result_dicts.append(dict(
                name=result.name,
                title=result.title,
                description=result.description,
                path=request.resource_path(result)))

    return result_dicts


from kotti.util import (
    get_localizer_for_locale_name,
    translate,
    )

for obj in (render_view, get_localizer_for_locale_name, translate,
            TemplateStructure):
    name = obj.__name__
    deprecated(
        name,
        "kotti.views.util.{0} has been moved to the kotti.util module "
        "as of Kotti 0.10.  Use kotti.util.{0} instead".format(name))

########NEW FILE########
__FILENAME__ = view
import warnings

from pyramid.exceptions import NotFound
from pyramid.view import render_view_to_response
from pyramid.view import view_config

from kotti.interfaces import IContent

from kotti.views.util import search_content
from kotti.views.util import search_content_for_tags


@view_config(context=IContent)
def view_content_default(context, request):
    """This view is always registered as the default view for any Content.

    Its job is to delegate to a view of which the name may be defined
    per instance.  If a instance level view is not defined for
    'context' (in 'context.defaultview'), we will fall back to a view
    with the name 'view'.
    """

    view_name = context.default_view or 'view'
    response = render_view_to_response(context, request, name=view_name)
    if response is None:  # pragma: no coverage
        warnings.warn("Failed to look up default view called %r for %r." %
                      (view_name, context))
        raise NotFound()
    return response


def view_node(context, request):  # pragma: no coverage
    return {}  # BBB


@view_config(name='search-results', permission='view',
             renderer='kotti:templates/view/search-results.pt')
def search_results(context, request):
    results = []
    if u'search-term' in request.POST:
        search_term = request.POST[u'search-term']
        results = search_content(search_term, request)
    return {'results': results}


@view_config(name='search-tag', permission='view',
             renderer='kotti:templates/view/search-results.pt')
def search_results_for_tag(context, request):
    results = []
    if u'tag' in request.GET:
        # Single tag searching only, is allowed in default Kotti. Add-ons can
        # utilize search_content_for_tags(tags) to enable multiple tags
        # searching, but here it is called with a single tag.
        tags = [request.GET[u'tag'].strip()]
        results = search_content_for_tags(tags, request)
    return {'results': results}


@view_config(name='search', permission='view',
             renderer='kotti:templates/view/search.pt')
@view_config(name='folder_view', context=IContent, permission='view',
             renderer='kotti:templates/view/folder.pt')
@view_config(name='view', context=IContent, permission='view',
             renderer='kotti:templates/view/document.pt')
def view(context, request):
    return {}


def includeme(config):
    config.scan(__name__)

########NEW FILE########
__FILENAME__ = workflow
from pyramid.security import DENY_ALL
from repoze.workflow import get_workflow as base_get_workflow
import transaction

from kotti import TRUE_VALUES
from kotti import DBSession
from kotti.events import notify
from kotti.events import ObjectEvent
from kotti.resources import Content
from kotti.util import command


class WorkflowTransition(ObjectEvent):
    def __init__(self, object, info, **kwargs):
        super(WorkflowTransition, self).__init__(object, **kwargs)
        self.info = info


def get_workflow(context, name='security'):
    return base_get_workflow(context, name, context=context)


def reset_workflow(objs=None, purge_existing=False):
    if objs is None:
        objs = DBSession.query(Content)
    for obj in objs:
        if purge_existing:
            obj.state = None
        workflow = get_workflow(obj)
        if workflow is not None:
            workflow.reset(obj)
    transaction.commit()


def initialize_workflow(event):
    wf = get_workflow(event.object)
    if wf is not None:
        wf.initialize(event.object)


def workflow_callback(context, info):
    wf = info.workflow
    to_state = info.transition.get('to_state')

    if to_state is None:
        if context.state:
            to_state = context.state
        else:
            to_state = wf.initial_state

    state_data = wf._state_data[to_state].copy()
    acl = []

    # This could definitely be cached...
    for key, value in state_data.items():
        if key.startswith('role:') or key == 'system.Everyone':
            for perm in value.split():
                acl.append(("Allow", key, perm))

    if state_data.get('inherit', '0').lower() not in TRUE_VALUES:
        acl.append(DENY_ALL)

    context.__acl__ = acl

    if info.transition:
        notify(WorkflowTransition(context, info))


def reset_workflow_command():
    __doc__ = """Reset the workflow of all content objects in the database.

    This is useful when you want to migrate an existing database to
    use a different workflow.  When run, this script will reset all
    your content objects to use the new workflow, while trying to
    preserve workflow state information.

    For this command to work, all currently persisted states must map
    directly to a state in the new workflow.  As an example, if
    there's a 'public' object in the database, the new workflow must
    define 'public' also.

    If this is not the case, you may choose to reset all your content
    objects to the new workflow's *initial state* by passing the
    '--purge-existing' option.

    Usage:
      kotti-reset-workflow <config_uri> [--purge-existing]

    Options:
      -h --help          Show this screen.
      --purge-existing   Reset all objects to new workflow's initial state.
    """
    return command(
        lambda args: reset_workflow(purge_existing=args['--purge-existing']),
        __doc__,
        )

########NEW FILE########
