__FILENAME__ = conf
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Err documentation build configuration file, created by
# sphinx-quickstart on Fri Sep 13 17:24:59 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
sys.path.append(os.path.abspath('_themes'))
sys.path.append(os.path.abspath('_themes/err'))
sys.path.append(os.path.abspath('../'))

__import__('errbot.config-template')
sys.modules['config'] = sys.modules['errbot.config-template']
from errbot.version import VERSION

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'Err'
copyright = '2013, Guillaume Binet, Tali Davidovich Petrover and Nick Groenen'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = VERSION
# The full version, including alpha/beta/rc tags.
release = VERSION

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = [
    '_build',
    'error_pages/*',
    'errbot.backends.campfire.rst',  # Broken on Python 3
    'errbot.backends.graphic.rst',  # Quite a pain to build, not worth it
    '_gh-pages',
]

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
#pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'err'

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
html_domain_indices = True

# If false, no index is generated.
html_use_index = True

# If true, the index is split into individual pages for each letter.
html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Errdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Err.tex', 'Err Documentation',
   'Guillaume Binet, Tali Davidovich Petrover and Nick Groenen', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'err', 'Err Documentation',
     ['Guillaume Binet, Tali Davidovich Petrover and Nick Groenen'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Err', 'Err Documentation',
   'Guillaume Binet, Tali Davidovich Petrover and Nick Groenen', 'Err', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = 'Err'
epub_author = 'Guillaume Binet, Tali Davidovich Petrover and Nick Groenen'
epub_publisher = 'Guillaume Binet, Tali Davidovich Petrover and Nick Groenen'
epub_copyright = '2013, Guillaume Binet, Tali Davidovich Petrover and Nick Groenen'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# A sequence of (type, uri, title) tuples for the guide element of content.opf.
#epub_guide = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

# Fix unsupported image types using the PIL.
#epub_fix_images = False

# Scale large images.
#epub_max_image_width = 0

# If 'no', URL addresses will not be shown.
#epub_show_urls = 'inline'

# If false, no index is generated.
#epub_use_index = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = config-template
../../errbot/config-template.py
########NEW FILE########
__FILENAME__ = pygments_style
from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace, Punctuation, Other, Literal


class ErrStyle(Style):
    """
    A Pygments style based on the "friendly" theme
    """

    background_color = "#ffffcc"
    default_style = ""

    styles = {
        Whitespace:                "#3e4349",
        Comment:                   "#3f6b5b",
        # Comment.Preproc:           "noitalic #007020",
        # Comment.Special:           "noitalic bg:#fff0f0",

        Keyword:                   "bold #f06f00",
        # Keyword.Pseudo:            "nobold",
        # Keyword.Type:              "nobold #902000",

        Operator:                  "#3e4349",
        # Operator.Word:             "bold #007020",

        Name:                      "#3e4349",
        Name.Builtin:              "#007020",
        Name.Function:             "bold #3e4349",
        Name.Class:                "bold #3e4349",
        # Name.Namespace:            "bold #f07e2a",
        # Name.Exception:            "#007020",
        Name.Variable:             "underline #8a2be2",
        Name.Constant:             "underline #b91f49",
        # Name.Label:                "bold #002070",
        Name.Entity:               "bold #330000",
        # Name.Attribute:            "#4070a0",
        Name.Tag:                  "bold #f06f00",
        Name.Decorator:            "bold italic #3e4349",

        # String:                    "#3e4349",
        String:                    "#9a5151",
        # String.Doc:                "italic #3f65b5",
        String.Doc:                "italic #3f6b5b",
        # String.Doc:                "italic #9a7851",
        # String.Doc:                "italic #9a5151",
        # String.Interpol:           "italic #70a0d0",
        # String.Escape:             "bold #4070a0",
        # String.Regex:              "#235388",
        # String.Symbol:             "#517918",
        # String.Other:              "#c65d09",
        Number:                    "underline #9a5151",

        Generic:                   "#3e4349",
        Generic.Heading:           "bold #1014ad",
        Generic.Subheading:        "bold #1014ad",
        Generic.Deleted:           "bg:#c8f2ea #2020ff",
        Generic.Inserted:          "#3e4349",
        # Generic.Error:             "#FF0000",
        # Generic.Emph:              "italic",
        # Generic.Strong:            "bold",
        # Generic.Prompt:            "bold #c65d09",
        # Generic.Output:            "#888",
        # Generic.Traceback:         "#04D",

        # Error:                     "border:#FF0000"
    }

########NEW FILE########
__FILENAME__ = base
import inspect
import logging
import difflib
import traceback
from collections import deque, defaultdict
from xml.etree import cElementTree as ET
from xml.etree.cElementTree import ParseError

from errbot import botcmd, PY2
from errbot.utils import get_sender_username, xhtml2txt, parse_jid, split_string_after
from errbot.templating import tenv
from config import BOT_ADMINS, BOT_ASYNC, BOT_PREFIX, BOT_IDENTITY, CHATROOM_FN

try:
    from config import ACCESS_CONTROLS_DEFAULT
except ImportError:
    ACCESS_CONTROLS_DEFAULT = {}

try:
    from config import ACCESS_CONTROLS
except ImportError:
    ACCESS_CONTROLS = {}

try:
    from config import HIDE_RESTRICTED_COMMANDS
except ImportError:
    HIDE_RESTRICTED_COMMANDS = False

try:
    from config import HIDE_RESTRICTED_ACCESS
except ImportError:
    HIDE_RESTRICTED_ACCESS = False

try:
    from config import BOT_PREFIX_OPTIONAL_ON_CHAT
except ImportError:
    BOT_PREFIX_OPTIONAL_ON_CHAT = False

try:
    from config import BOT_ALT_PREFIXES
except ImportError:
    BOT_ALT_PREFIXES = ()

try:
    from config import BOT_ALT_PREFIX_SEPARATORS
except ImportError:
    BOT_ALT_PREFIX_SEPARATORS = ()

try:
    from config import BOT_ALT_PREFIX_CASEINSENSITIVE
except ImportError:
    BOT_ALT_PREFIX_CASEINSENSITIVE = False

try:
    from config import DIVERT_TO_PRIVATE
except ImportError:
    DIVERT_TO_PRIVATE = ()
    logging.warning("DIVERT_TO_PRIVATE is missing in config")
    pass

try:
    from config import MESSAGE_SIZE_LIMIT
except ImportError:
    MESSAGE_SIZE_LIMIT = 10000  # Corresponds with what HipChat accepts

if BOT_ASYNC:
    from errbot.bundled.threadpool import ThreadPool, WorkRequest


class ACLViolation(Exception):
    """Exceptions raised when user is not allowed to execute given command due to ACLs"""
    pass


class Identifier(object):
    """
    This class is the parent and the basic contract of all the ways the backends are identifying a person on their system
    """

    def __init__(self, jid=None, node='', domain='', resource=''):
        if jid:
            self.node, self.domain, self.resource = parse_jid(jid)
        else:
            self.node = node
            self.domain = domain
            self.resource = resource

    def getNode(self):
        return self.node

    def getDomain(self):
        return self.domain

    def bareMatch(self, other):
        return other.getStripped() == self.getStripped()

    def getStripped(self):
        if self.domain:
            return self.node + '@' + self.domain
        return self.node # if the backend has no domain notion

    def getResource(self):
        return self.resource

    def __str__(self):
        answer = self.getStripped()
        if self.resource:
            answer += '/' + self.resource
        return answer

    def __unicode__(self):
        return str(self.__str__())


class Presence(object):
    """
        An universal class representing protocol agnostic concept
        of presence.
    """
    def __init__(self, nick, room, real_id=None):
        self.nick = nick
        self.room = room
        self.real_id = real_id

    def get_room(self):
        return self.room

    def get_nick(self):
        return self.nick

    def get_real_name(self):
        return self.real_id


class Message(object):
    fr = Identifier('unknown@localhost')

    def __init__(self, body, typ='chat', html=None):
        # it is either unicode or assume it is utf-8
        if isinstance(body, str):
            self.body = body
        else:
            self.body = body.decode('utf-8')
        self.html = html
        self.typ = typ
        self.delayed = False
        self.mucknick = None

    def setTo(self, to):
        if isinstance(to, Identifier):
            self.to = to
        else:
            self.to = Identifier(to)  # assume a parseable string

    def getTo(self):
        return self.to

    def setType(self, typ):
        self.typ = typ

    def getType(self):
        return self.typ

    def getFrom(self):
        return self.fr

    def setFrom(self, fr):
        if isinstance(fr, Identifier):
            self.fr = fr
        else:
            self.fr = Identifier(fr)  # assume a parseable string

    def getBody(self):
        return self.body

    def getHTML(self):
        return self.html

    def setHTML(self, html):
        self.html = html

    def setDelayed(self, delayed):
        self.delayed = delayed

    def isDelayed(self):
        return self.delayed

    def setMuckNick(self, nick):
        self.mucknick = nick

    def getMuckNick(self):
        return self.mucknick

    def __str__(self):
        return self.body


class Connection(object):
    def send_message(self, mess):
        raise NotImplementedError("It should be implemented specifically for your backend")


def build_text_html_message_pair(source):
    node = None
    text_plain = None

    try:
        node = ET.XML(source)
        text_plain = xhtml2txt(source)
    except ParseError as ee:
        if source.strip():  # avoids keep alive pollution
            logging.debug('Could not parse [%s] as XHTML-IM, assume pure text Parsing error = [%s]' % (source, ee))
            text_plain = source
    return text_plain, node


def build_message(text, message_class, conversion_function=None):
    """Builds an xhtml message without attributes.
    If input is not valid xhtml-im fallback to normal."""
    message = None  # keeps the compiler happy
    try:
        text = text.replace('', '*')  # there is a weird chr IRC is sending that we need to filter out
        if PY2:
            ET.XML(text.encode('utf-8'))  # test if is it xml
        else:
            ET.XML(text)

        edulcorated_html = conversion_function(text) if conversion_function else text
        try:
            text_plain, node = build_text_html_message_pair(edulcorated_html)
            message = message_class(body=text_plain)
            message.setHTML(node)
        except ET.ParseError as ee:
            logging.error('Error translating to hipchat [%s] Parsing error = [%s]' % (edulcorated_html, ee))
    except ET.ParseError as ee:
        if text.strip():  # avoids keep alive pollution
            logging.debug('Determined that [%s] is not XHTML-IM (%s)' % (text, ee))
        message = message_class(body=text)
    return message


class Backend(object):
    # Implements the basic Bot logic (logic independent from the backend) and leave to you to implement the missing parts

    cmd_history = defaultdict(lambda: deque(maxlen=10)) #this will be a per user history

    MSG_ERROR_OCCURRED = 'Sorry for your inconvenience. '\
                         'An unexpected error occurred.'
    MESSAGE_SIZE_LIMIT = MESSAGE_SIZE_LIMIT
    MSG_UNKNOWN_COMMAND = 'Unknown command: "%(command)s". '\
                          'Type "' + BOT_PREFIX + 'help" for available commands.'
    MSG_HELP_TAIL = 'Type help <command name> to get more info '\
                    'about that specific command.'
    MSG_HELP_UNDEFINED_COMMAND = 'That command is not defined.'

    def __init__(self, *args, **kwargs):
        """ Those arguments will be directly those put in BOT_IDENTITY
        """
        if BOT_ASYNC:
            self.thread_pool = ThreadPool(3)
            logging.debug('created the thread pool' + str(self.thread_pool))
        self.commands = {}  # the dynamically populated list of commands available on the bot
        self.re_commands = {}  # the dynamically populated list of regex-based commands available on the bot

        if BOT_ALT_PREFIX_CASEINSENSITIVE:
            self.bot_alt_prefixes = tuple(prefix.lower() for prefix in BOT_ALT_PREFIXES)
        else:
            self.bot_alt_prefixes = BOT_ALT_PREFIXES

    def send_message(self, mess):
        """Send a message"""
        self.connect().send_message(mess)

    def send_simple_reply(self, mess, text, private=False):
        """Send a simple response to a message"""
        self.send_message(self.build_reply(mess, text, private))

    def build_reply(self, mess, text=None, private=False):
        """Build a message for responding to another message.
        Message is NOT sent"""
        response = self.build_message(text)
        msg_type = mess.getType()

        response.setFrom(self.jid)
        if msg_type == 'groupchat' and not private:
            # getStripped() returns the full bot@conference.domain.tld/chat_username
            # but in case of a groupchat, we should only try to send to the MUC address
            # itself (bot@conference.domain.tld)
            response.setTo(mess.getFrom().getStripped().split('/')[0])
        elif str(mess.getTo()) == BOT_IDENTITY['username']:
            # This is a direct private message, not initiated through a MUC. Use
            # getStripped() to remove the resource so that the response goes to the
            # client with the highest priority
            response.setTo(mess.getFrom().getStripped())
        else:
            # This is a private message that was initiated through a MUC. Don't use
            # getStripped() here to retain the resource, else the XMPP server doesn't
            # know which user we're actually responding to.
            response.setTo(mess.getFrom())
        response.setType('chat' if private else msg_type)
        return response

    def callback_message(self, conn, mess):
        """
        Needs to return False if we want to stop further treatment
        """
        # Prepare to handle either private chats or group chats
        type = mess.getType()
        jid = mess.getFrom()
        text = mess.getBody()
        username = get_sender_username(mess)
        user_cmd_history = self.cmd_history[username]

        if mess.isDelayed():
            logging.debug("Message from history, ignore it")
            return False

        if type not in ("groupchat", "chat"):
            logging.debug("unhandled message type %s" % mess)
            return False

        # Ignore messages from ourselves. Because it isn't always possible to get the
        # real JID from a MUC participant (including ourself), matching the JID against
        # ourselves isn't enough (see https://github.com/gbin/err/issues/90 for
        # background discussion on this). Matching against CHATROOM_FN isn't technically
        # correct in all cases because a MUC could give us another nickname, but it
        # covers 99% of the MUC cases, so it should suffice for the time being.
        if (jid.bareMatch(Identifier(self.jid)) or
            type == "groupchat" and mess.getMuckNick() == CHATROOM_FN):
            logging.debug("Ignoring message from self")
            return False

        logging.debug("*** jid = %s" % jid)
        logging.debug("*** username = %s" % username)
        logging.debug("*** type = %s" % type)
        logging.debug("*** text = %s" % text)

        # If a message format is not supported (eg. encrypted),
        # txt will be None
        if not text:
            return False

        surpress_cmd_not_found = False

        prefixed = False  # Keeps track whether text was prefixed with a bot prefix
        only_check_re_command = False  # Becomes true if text is determed to not be a regular command
        tomatch = text.lower() if BOT_ALT_PREFIX_CASEINSENSITIVE else text
        if len(BOT_ALT_PREFIXES) > 0 and tomatch.startswith(self.bot_alt_prefixes):
            # Yay! We were called by one of our alternate prefixes. Now we just have to find out
            # which one... (And find the longest matching, in case you have 'err' and 'errbot' and
            # someone uses 'errbot', which also matches 'err' but would leave 'bot' to be taken as
            # part of the called command in that case)
            prefixed = True
            longest = 0
            for prefix in self.bot_alt_prefixes:
                l = len(prefix)
                if tomatch.startswith(prefix) and l > longest:
                    longest = l
            logging.debug("Called with alternate prefix '{}'".format(text[:longest]))
            text = text[longest:]

            # Now also remove the separator from the text
            for sep in BOT_ALT_PREFIX_SEPARATORS:
                # While unlikely, one may have separators consisting of
                # more than one character
                l = len(sep)
                if text[:l] == sep:
                    text = text[l:]
        elif type == "chat" and BOT_PREFIX_OPTIONAL_ON_CHAT:
            logging.debug("Assuming '%s' to be a command because BOT_PREFIX_OPTIONAL_ON_CHAT is True" % text)
            # In order to keep noise down we surpress messages about the command
            # not being found, because it's possible a plugin will trigger on what
            # was said with trigger_message.
            surpress_cmd_not_found = True
        elif not text.startswith(BOT_PREFIX):
            only_check_re_command = True
        if text.startswith(BOT_PREFIX):
            text = text[len(BOT_PREFIX):]
            prefixed = True

        text = text.strip()
        text_split = text.split(' ')
        cmd = None
        command = None
        args = ''
        if not only_check_re_command:
            if len(text_split) > 1:
                command = (text_split[0] + '_' + text_split[1]).lower()
                if command in self.commands:
                    cmd = command
                    args = ' '.join(text_split[2:])

            if not cmd:
                command = text_split[0].lower()
                args = ' '.join(text_split[1:])
                if command in self.commands:
                    cmd = command
                    if len(text_split) > 1:
                        args = ' '.join(text_split[1:])

            if command == BOT_PREFIX:  # we did "!!" so recall the last command
                if len(user_cmd_history):
                    cmd, args = user_cmd_history[-1]
                else:
                    return False  # no command in history
            elif command.isdigit():  # we did "!#" so we recall the specified command
                index = int(command)
                if len(user_cmd_history) >= index:
                    cmd, args = user_cmd_history[-index]
                else:
                    return False  # no command in history

        # Try to match one of the regex commands if the regular commands produced no match
        matched_on_re_command = False
        if not cmd:
            if prefixed:
                commands = self.re_commands
            else:
                commands = {k: self.re_commands[k] for k in self.re_commands
                           if not self.re_commands[k]._err_command_prefix_required}

            for name,func in commands.items():
                match = func._err_command_re_pattern.search(text)
                if match:
                    logging.debug("Matching '{}' against '{}' produced a match"
                                  .format(text, func._err_command_re_pattern.pattern))
                    matched_on_re_command = True
                    self._process_command(mess, name, text, match)
                else:
                    logging.debug("Matching '{}' against '{}' produced no match"
                                  .format(text, func._err_command_re_pattern.pattern))
        if matched_on_re_command:
            return True

        if cmd:
            self._process_command(mess, cmd, args, match=None)
        elif not only_check_re_command:
            logging.debug("Command not found")
            if surpress_cmd_not_found:
                logging.debug("Surpressing command not found feedback")
            else:
                reply = self.unknown_command(mess, command, args)
                if reply is None:
                    reply = self.MSG_UNKNOWN_COMMAND % {'command': command}
                if reply:
                    self.send_simple_reply(mess, reply)
        return True

    def _process_command(self, mess, cmd, args, match):
        """Process and execute a bot command"""
        logging.info("Processing command {} with parameters '{}'".format(cmd, args))

        jid = mess.getFrom()
        username = get_sender_username(mess)
        user_cmd_history = self.cmd_history[username]

        if (cmd, args) in user_cmd_history:
            user_cmd_history.remove((cmd, args))  # Avoids duplicate history items

        try:
            self.check_command_access(mess, cmd)
        except ACLViolation as e:
            if not HIDE_RESTRICTED_ACCESS:
                self.send_simple_reply(mess, str(e))
            return

        f = self.re_commands[cmd] if match else self.commands[cmd]

        if f._err_command_admin_only and BOT_ASYNC:
            self.thread_pool.wait()  # If it is an admin command, wait that the queue is completely depleted so we don't have strange concurrency issues on load/unload/updates etc ...

        if f._err_command_historize:
            user_cmd_history.append((cmd, args))  # add it to the history only if it is authorized to be so

        # Don't check for None here as None can be a valid argument to split.
        # '' was chosen as default argument because this isn't a valid argument to split()
        if not match and f._err_command_split_args_with != '':
            args = args.split(f._err_command_split_args_with)
        if BOT_ASYNC:
            wr = WorkRequest(self._execute_and_send,
                [], {'cmd': cmd, 'args': args, 'match': match, 'mess': mess, 'jid': jid,
                     'template_name': f._err_command_template})
            self.thread_pool.putRequest(wr)
            if f._err_command_admin_only:
                self.thread_pool.wait()  # Again wait for the completion before accepting a new command that could generate weird concurrency issues
        else:
            self._execute_and_send(cmd=cmd, args=args, match=match, mess=mess, jid=jid,
                                   template_name=f._err_command_template)

    def _execute_and_send(self, cmd, args, match, mess, jid, template_name=None):
        """Execute a bot command and send output back to the caller

        cmd: The command that was given to the bot (after being expanded)
        args: Arguments given along with cmd
        match: A re.MatchObject if command is coming from a regex-based command, else None
        mess: The message object
        jid: The jid of the person executing the command
        template_name: The name of the template which should be used to render
            html-im output, if any

        """

        def process_reply(reply):
            # integrated templating
            if template_name:
                reply = tenv().get_template(template_name + '.html').render(**reply)

            # Reply should be all text at this point (See https://github.com/gbin/err/issues/96)
            return str(reply)

        def send_reply(reply):
            for part in split_string_after(reply, self.MESSAGE_SIZE_LIMIT):
                self.send_simple_reply(mess, part, cmd in DIVERT_TO_PRIVATE)

        commands = self.re_commands if match else self.commands
        try:
            if inspect.isgeneratorfunction(commands[cmd]):
                replies = commands[cmd](mess, match) if match else commands[cmd](mess, args)
                for reply in replies:
                    if reply: send_reply(process_reply(reply))
            else:
                reply = commands[cmd](mess, match) if match else commands[cmd](mess, args)
                if reply: send_reply(process_reply(reply))
        except Exception as e:
            tb = traceback.format_exc()
            logging.exception('An error happened while processing '
                              'a message ("%s") from %s: %s"' %
                              (mess.getBody(), jid, tb))
            send_reply(self.MSG_ERROR_OCCURRED + ':\n %s' % e)

    def check_command_access(self, mess, cmd):
        """
        Check command against ACL rules

        Raises ACLViolation() if the command may not be executed in the given context
        """
        usr = str(get_jid_from_message(mess))
        typ = mess.getType()

        if cmd not in ACCESS_CONTROLS:
            ACCESS_CONTROLS[cmd] = ACCESS_CONTROLS_DEFAULT

        if 'allowusers' in ACCESS_CONTROLS[cmd] and usr not in ACCESS_CONTROLS[cmd]['allowusers']:
            raise ACLViolation("You're not allowed to access this command from this user")
        if 'denyusers' in ACCESS_CONTROLS[cmd] and usr in ACCESS_CONTROLS[cmd]['denyusers']:
            raise ACLViolation("You're not allowed to access this command from this user")
        if typ == 'groupchat':
            stripped = mess.getFrom().getStripped()
            if 'allowmuc' in ACCESS_CONTROLS[cmd] and ACCESS_CONTROLS[cmd]['allowmuc'] is False:
                raise ACLViolation("You're not allowed to access this command from a chatroom")
            if 'allowrooms' in ACCESS_CONTROLS[cmd] and stripped not in ACCESS_CONTROLS[cmd]['allowrooms']:
                raise ACLViolation("You're not allowed to access this command from this room")
            if 'denyrooms' in ACCESS_CONTROLS[cmd] and stripped in ACCESS_CONTROLS[cmd]['denyrooms']:
                raise ACLViolation("You're not allowed to access this command from this room")
        else:
            if 'allowprivate' in ACCESS_CONTROLS[cmd] and ACCESS_CONTROLS[cmd]['allowprivate'] is False:
                raise ACLViolation("You're not allowed to access this command via private message to me")

        f = self.commands[cmd] if cmd in self.commands else self.re_commands[cmd]

        if f._err_command_admin_only:
            if typ == 'groupchat':
                raise ACLViolation("You cannot administer the bot from a chatroom, message the bot directly")
            if usr not in BOT_ADMINS:
                raise ACLViolation("This command requires bot-admin privileges")

    def unknown_command(self, mess, cmd, args):
        """ Override the default unknown command behavior
        """
        full_cmd = cmd + ' ' + args.split(' ')[0] if args else None
        if full_cmd:
            part1 = 'Command "%s" / "%s" not found.' % (cmd, full_cmd)
        else:
            part1 = 'Command "%s" not found.' % cmd
        ununderscore_keys = [m.replace('_', ' ') for m in self.commands.keys()]
        matches = difflib.get_close_matches(cmd, ununderscore_keys)
        if full_cmd:
            matches.extend(difflib.get_close_matches(full_cmd, ununderscore_keys))
        matches = set(matches)
        if matches:
            return part1 + '\n\nDid you mean "' + BOT_PREFIX + ('" or "' + BOT_PREFIX).join(matches) + '" ?'
        else:
            return part1

    def inject_commands_from(self, instance_to_inject):
        classname = instance_to_inject.__class__.__name__
        for name, value in inspect.getmembers(instance_to_inject, inspect.ismethod):
            if getattr(value, '_err_command', False):
                commands = self.re_commands if getattr(value, '_err_re_command') else self.commands
                name = getattr(value, '_err_command_name')

                if name in commands:
                    f = commands[name]
                    new_name = (classname + '-' + name).lower()
                    self.warn_admins('%s.%s clashes with %s.%s so it has been renamed %s' % (classname, name, type(f.__self__).__name__, f.__name__, new_name ))
                    name = new_name
                commands[name] = value

                if getattr(value, '_err_re_command'):
                    logging.debug('Adding regex command : %s -> %s' % (name, value.__name__))
                    self.re_commands = commands
                else:
                    logging.debug('Adding command : %s -> %s' % (name, value.__name__))
                    self.commands = commands

    def remove_commands_from(self, instance_to_inject):
        for name, value in inspect.getmembers(instance_to_inject, inspect.ismethod):
            if getattr(value, '_err_command', False):
                name = getattr(value, '_err_command_name')
                if getattr(value, '_err_re_command') and name in self.re_commands:
                    del (self.re_commands[name])
                elif not getattr(value, '_err_re_command') and name in self.commands:
                    del (self.commands[name])

    def warn_admins(self, warning):
        for admin in BOT_ADMINS:
            self.send(admin, warning)

    def top_of_help_message(self):
        """Returns a string that forms the top of the help message

        Override this method in derived class if you
        want to add additional help text at the
        beginning of the help message.
        """
        return ""

    def bottom_of_help_message(self):
        """Returns a string that forms the bottom of the help message

        Override this method in derived class if you
        want to add additional help text at the end
        of the help message.
        """
        return ""

    @botcmd
    def help(self, mess, args):
        """   Returns a help string listing available options.

        Automatically assigned to the "help" command."""
        if not args:
            if self.__doc__:
                description = self.__doc__.strip()
            else:
                description = 'Available commands:'

            usage = '\n'.join(sorted([
            BOT_PREFIX + '%s: %s' % (name, (command.__doc__ or
                                            '(undocumented)').strip().split('\n', 1)[0])
            for (name, command) in self.commands.iteritems()\
            if name != 'help'\
            and not command._err_command_hidden
            ]))
            usage = '\n\n' + '\n\n'.join(filter(None, [usage, self.MSG_HELP_TAIL]))
        else:
            description = ''
            if args in self.commands:
                usage = (self.commands[args].__doc__ or
                         'undocumented').strip()
            else:
                usage = self.MSG_HELP_UNDEFINED_COMMAND

        top = self.top_of_help_message()
        bottom = self.bottom_of_help_message()
        return ''.join(filter(None, [top, description, usage, bottom]))

    def send(self, user, text, in_reply_to=None, message_type='chat'):
        """Sends a simple message to the specified user."""
        mess = self.build_message(text)
        if hasattr(user, 'getStripped'):
            mess.setTo(user.getStripped())
        else:
            mess.setTo(user)

        if in_reply_to:
            mess.setType(in_reply_to.getType())
            mess.setFrom(in_reply_to.getTo().getStripped())
        else:
            mess.setType(message_type)
            mess.setFrom(self.jid)

        self.send_message(mess)


    ###### HERE ARE THE SPECIFICS TO IMPLEMENT PER BACKEND

    def build_message(self, text):
        raise NotImplementedError("It should be implemented specifically for your backend")

    def serve_forever(self):
        raise NotImplementedError("It should be implemented specifically for your backend")

    def connect(self):
        """Connects the bot to server or returns current connection
        """
        raise NotImplementedError("It should be implemented specifically for your backend")

    def join_room(self, room, username=None, password=None):
        raise NotImplementedError("It should be implemented specifically for your backend")

    def shutdown(self):
        pass

    def connect_callback(self):
        pass

    def disconnect_callback(self):
        pass

    def callback_contact_online(self, conn, pres):
        pass

    def callback_contact_offline(self, conn, pres):
        pass

    def callback_user_joined_chat(self, conn, pres):
        pass

    def callback_user_left_chat(self, conn, pres):
        pass

    @property
    def mode(self):
        raise NotImplementedError("It should be implemented specifically for your backend")


def get_jid_from_message(mess):
    if mess.getType() == 'chat':
        # strip the resource for direct chats
        return str(mess.getFrom().getStripped())
    fr = mess.getFrom()
    jid = Identifier(node=fr.node, domain=fr.domain, resource=fr.resource)
    return jid

########NEW FILE########
__FILENAME__ = campfire
import logging
import sys

try:
    import pyfire
except ImportError:
    logging.exception("Could not start the campfire backend")
    logging.fatal("""
    If you intend to use the campfire backend please install pyfire:
    pip install pyfire
    """)
    sys.exit(-1)

from errbot.backends.base import Message, Connection, build_message
from errbot.errBot import ErrBot
from threading import Condition
from config import CHATROOM_PRESENCE


class CampfireConnection(Connection, pyfire.Campfire):
    rooms = {}  # keep track of joined room so we can send messages directly to them

    def send_message(self, mess):
        # we only reply to rooms in reality in campfire so we need to find one or a default one at least
        room_name = mess.getTo().getDomain()
        if not room_name:
            room_name = mess.getFrom().getDomain()
        if room_name in self.rooms:
            room = self.rooms[room_name][0]
            room.speak(mess.getBody())  # Basic text support for the moment
        else:
            logging.info("Attempted to send a message to a not connected room yet Room %s : %s" % (room_name, mess.getBody()))

    def join_room(self, name, msg_callback, error_callback):
        room = self.get_room_by_name(name)
        room.join()
        stream = room.get_stream(error_callback=error_callback)
        stream.attach(msg_callback).start()
        self.rooms[name] = (room, stream)


ENCODING_INPUT = sys.stdin.encoding


class CampfireBackend(ErrBot):
    exit_lock = Condition()

    def __init__(self, subdomain, username, password, ssl=True):
        super(CampfireBackend, self).__init__()

        self.conn = None
        self.subdomain = subdomain
        self.username = username
        self.password = password
        self.ssl = ssl

    def serve_forever(self):
        self.exit_lock.acquire()
        self.connect()  # be sure we are "connected" before the first command
        self.connect_callback()  # notify that the connection occured
        try:
            logging.info("Campfire connected.")
            self.exit_lock.wait()
        except KeyboardInterrupt as ki:
            pass
        finally:
            self.exit_lock.release()
            self.disconnect_callback()
            self.shutdown()

    def connect(self):
        if not self.conn:
            if not CHATROOM_PRESENCE:
                raise Exception('Your bot needs to join at least one room, please set CHATROOM_PRESENCE in your config')
            self.conn = CampfireConnection(self.subdomain, self.username, self.password, self.ssl)
            self.jid = self.username + '@' + self.conn.get_room_by_name(CHATROOM_PRESENCE[0]).name  + '/' + self.username
            # put us by default in the first room
            # resource emulates the XMPP behavior in chatrooms
        return self.conn

    def build_message(self, text):
        return Message(text, typ='groupchat')  # it is always a groupchat in campfire

    def shutdown(self):
        super(CampfireBackend, self).shutdown()

    def msg_callback(self, message):
        logging.debug('Incoming message [%s]' % message)
        user = ""
        if message.user:
            user = message.user.name
        if message.is_text():
            msg = Message(message.body, typ='groupchat')  # it is always a groupchat in campfire
            msg.setFrom(user + '@' + message.room.get_data()['name'] + '/' + user)
            msg.setTo(self.jid)  # assume it is for me
            self.callback_message(self.conn, msg)

    def error_callback(self, error, room):
        logging.error("Stream STOPPED due to ERROR: %s in room %s" % (error, room))
        self.exit_lock.acquire()
        self.exit_lock.notify()
        self.exit_lock.release()

    def join_room(self, room, username=None, password=None):
        self.conn.join_room(room, self.msg_callback, self.error_callback)

    def build_message(self, text):
        return build_message(text, Message)

    def send_simple_reply(self, mess, text, private=False):
        """Total hack to avoid stripping of rooms"""
        self.send_message(self.build_reply(mess, text, True))

    @property
    def mode(self):
        return 'campfire'

########NEW FILE########
__FILENAME__ = graphic
import logging
import sys
from errbot.utils import mess_2_embeddablehtml

try:
    from PySide import QtCore, QtGui, QtWebKit
    from PySide.QtGui import QCompleter
    from PySide.QtCore import Qt, QUrl, QObject
except ImportError:
    logging.exception("Could not start the graphical backend")
    logging.fatal("""
    If you intend to use the graphical backend please install PySide:
    -> On debian-like systems
    sudo apt-get install python-software-properties
    sudo apt-get update
    sudo apt-get install python-pyside
    -> On Gentoo
    sudo emerge -av dev-python/pyside
    -> Generic
    pip install PySide
    """)
    sys.exit(-1)

import os
import config
from config import BOT_DATA_DIR, BOT_PREFIX
import errbot
from errbot.backends.base import Connection, Message, build_text_html_message_pair
from errbot.errBot import ErrBot


class CommandBox(QtGui.QPlainTextEdit, object):
    newCommand = QtCore.Signal(str)

    def reset_history(self):
        self.history_index = len(self.history)

    def __init__(self, history, commands):
        self.history_index = 0
        self.history = history
        self.reset_history()
        super(CommandBox, self).__init__()

        #Autocompleter
        self.completer = QCompleter([BOT_PREFIX + name for name in commands], self)
        self.completer.setCaseSensitivity(Qt.CaseInsensitive)
        self.completer.setWidget(self)
        self.completer.activated.connect(self.onAutoComplete)
        self.autocompleteStart = None

    def onAutoComplete(self, text):
        #Select the text from autocompleteStart until the current cursor
        cursor = self.textCursor()
        cursor.setPosition(0, cursor.KeepAnchor)
        #Replace it with the selected text
        cursor.insertText(text)
        self.autocompleteStart = None

    #noinspection PyStringFormat
    def keyPressEvent(self, *args, **kwargs):
        event = args[0]
        key = event.key()
        ctrl = event.modifiers() == QtCore.Qt.ControlModifier

        # don't disturb the completer behavior
        if self.completer.popup().isVisible() and key in (Qt.Key_Enter, Qt.Key_Return, Qt.Key_Tab, Qt.Key_Backtab):
            event.ignore()
            return

        if self.autocompleteStart is not None and not event.text().isalnum() and \
                not (key == Qt.Key_Backspace and self.textCursor().position() > self.autocompleteStart):
            self.completer.popup().hide()
            self.autocompleteStart = None

        if key == Qt.Key_Space and ctrl:
            #Pop-up the autocompleteList
            rect = self.cursorRect(self.textCursor())
            rect.setSize(QtCore.QSize(100, 150))
            self.autocompleteStart = self.textCursor().position()
            self.completer.complete(rect)  # The popup is positioned in the next if block

        if self.autocompleteStart:
            prefix = self.toPlainText()
            cur = self.textCursor()
            cur.setPosition(self.autocompleteStart)

            self.completer.setCompletionPrefix(prefix)
            #Select the first one of the matches
            self.completer.popup().setCurrentIndex(self.completer.completionModel().index(0, 0))

        if key == Qt.Key_Up and ctrl:
            if self.history_index > 0:
                self.history_index -= 1
                self.setPlainText(BOT_PREFIX + '%s %s' % self.history[self.history_index])
                key.ignore()
                return
        elif key == Qt.Key_Down and ctrl:
            if self.history_index < len(self.history) - 1:
                self.history_index += 1
                self.setPlainText(BOT_PREFIX + '%s %s' % self.history[self.history_index])
                key.ignore()
                return
        elif key == QtCore.Qt.Key_Return and ctrl:
            self.newCommand.emit(self.toPlainText())
            self.reset_history()
        super(CommandBox, self).keyPressEvent(*args, **kwargs)


class ConnectionMock(Connection, QtCore.QObject):
    newAnswer = QtCore.Signal(str, bool)

    def send_message(self, mess):
        self.send(mess)

    def send(self, mess):
        if hasattr(mess, 'getBody') and mess.getBody() and not mess.getBody().isspace():
            content, is_html = mess_2_embeddablehtml(mess)
            self.newAnswer.emit(content, is_html)


import re

urlfinder = re.compile(r'http([^\.\s]+\.[^\.\s]*)+[^\.\s]{2,}')


def linkify(text):
    def replacewithlink(matchobj):
        url = matchobj.group(0)
        text = str(url)

        imglink = ''
        for a in ['png', '.gif', '.jpg', '.jpeg', '.svg']:
            if text.lower().endswith(a):
                imglink = '<br /><img src="' + url + '" />'
                break
        return '<a href="' + url + '" target="_blank" rel="nofollow">' + text + '<img class="imglink" src="/images/linkout.png"></a>' + imglink

    return urlfinder.sub(replacewithlink, text)


def htmlify(text, is_html, receiving):
    tag = 'div' if is_html else 'pre'
    if not is_html:
        text = linkify(text)
    style = 'background-color : rgba(251,247,243,0.5); border-color:rgba(251,227,223,0.5);' if receiving else 'background-color : rgba(243,247,251,0.5); border-color: rgba(223,227,251,0.5);'
    return '<%s style="margin:0px; padding:20px; border-style:solid; border-width: 0px 0px 1px 0px; %s"> %s </%s>' % (tag, style, text, tag)

INIT_PAGE = """<html><head><link rel="stylesheet" type="text/css" href="%s/style/style.css" /></head>
<body style=" background-image: url('%s'); background-repeat: no-repeat; background-position:center center; background-attachment:fixed; background-size: contain; margin:0;">"""


class ChatApplication(QtGui.QApplication):
    def __init__(self, *args, **kwargs):
        backend = kwargs.pop('backend')
        super().__init__(*args, **kwargs)
        self.mainW = QtGui.QWidget()
        self.mainW.setWindowTitle('Err...')

        icon_path = os.path.join(os.path.dirname(errbot.__file__), 'err.svg')
        bg_path = os.path.join(os.path.dirname(errbot.__file__), 'err-bg.svg')
        self.mainW.setWindowIcon(QtGui.QIcon(icon_path))
        vbox = QtGui.QVBoxLayout()
        help_label = QtGui.QLabel("CTRL+Space to autocomplete -- CTRL+Enter to send your message")
        self.input = CommandBox(backend.cmd_history, backend.commands)
        self.output = QtWebKit.QWebView()

        # init webpage
        self.buffer = INIT_PAGE % (BOT_DATA_DIR, bg_path)
        self.output.setHtml(self.buffer)

        # layout
        vbox.addWidget(self.output)
        vbox.addWidget(self.input)
        vbox.addWidget(help_label)
        self.mainW.setLayout(vbox)

        # setup web view to open liks in external browser
        self.output.page().setLinkDelegationPolicy(QtWebKit.QWebPage.DelegateAllLinks)

        # connect signals/slots
        self.output.page().mainFrame().contentsSizeChanged.connect(self.scroll_output_to_bottom)
        self.output.page().linkClicked.connect(QtGui.QDesktopServices.openUrl)
        self.input.newCommand.connect(lambda text: backend.send_command(text))
        backend.conn.newAnswer.connect(self.new_message)

        self.mainW.show()

    def new_message(self, text, is_html, receiving=True):
        self.buffer += htmlify(text, is_html, receiving)
        self.output.setHtml(self.buffer)

    def scroll_output_to_bottom(self):
        self.output.page().mainFrame().scroll(0, self.output.page().mainFrame().scrollBarMaximum(QtCore.Qt.Vertical))


class GraphicBackend(ErrBot):
    def __init__(self, *args, **kwargs):
        self.conn = None
        super().__init__(*args, **kwargs)


    def send_command(self, text):
        self.app.new_message(text, False)
        msg = Message(text)
        msg.setFrom(config.BOT_ADMINS[0])  # assume this is the admin talking
        msg.setTo(self.jid)  # To me only
        self.callback_message(self.conn, msg)
        self.app.input.clear()


    def build_message(self, text):
        txt, node = build_text_html_message_pair(text)
        msg = Message(txt, html=node) if node else Message(txt)
        msg.setFrom(self.jid)
        return msg  # rebuild a pure html snippet to include directly in the console html

    def serve_forever(self):
        self.jid = 'Err@localhost'
        self.connect()  # be sure we are "connected" before the first command
        self.connect_callback()  # notify that the connection occured

        # create window and components
        self.app = ChatApplication(sys.argv, backend=self)
        try:
            self.app.exec_()
        finally:
            self.disconnect_callback()
            self.shutdown()
            exit(0)

    def connect(self):
        if not self.conn:
            self.conn = ConnectionMock()
        return self.conn

    def join_room(self, room, username=None, password=None):
        pass  # just ignore that

    @property
    def mode(self):
        return 'graphic'

########NEW FILE########
__FILENAME__ = hipchat
import json
import logging
from urllib.parse import urlencode
from urllib.request import urlopen, Request

from config import CHATROOM_FN
from errbot.backends.xmpp import XMPPBackend, XMPPConnection
from errbot.utils import utf8, REMOVE_EOL, mess_2_embeddablehtml
import re

HIPCHAT_MESSAGE_URL = 'https://api.hipchat.com/v1/rooms/message'

HIPCHAT_FORCE_PRE = re.compile(r'<body>', re.I)
HIPCHAT_FORCE_SLASH_PRE = re.compile(r'</body>', re.I)
HIPCHAT_EOLS = re.compile(r'</p>|</li>', re.I)
HIPCHAT_BOLS = re.compile(r'<p [^>]+>|<li [^>]+>', re.I)


def xhtml2hipchat(xhtml):
    # Hipchat has a really limited html support
    retarded_hipchat_html_plain = REMOVE_EOL.sub('', xhtml)  # Ignore formatting
    retarded_hipchat_html_plain = HIPCHAT_EOLS.sub('<br/>', retarded_hipchat_html_plain)  # readd the \n where they probably fit best
    retarded_hipchat_html_plain = HIPCHAT_BOLS.sub('', retarded_hipchat_html_plain)  # zap every tag left
    retarded_hipchat_html_plain = HIPCHAT_FORCE_PRE.sub('<body><pre>', retarded_hipchat_html_plain)  # fixor pre
    retarded_hipchat_html_plain = HIPCHAT_FORCE_SLASH_PRE.sub('</pre></body>', retarded_hipchat_html_plain)  # fixor /pre
    return retarded_hipchat_html_plain


class HipchatClient(XMPPConnection):
    def __init__(self, *args, **kwargs):
        self.token = kwargs.pop('token')
        self.debug = kwargs.pop('debug')
        super(HipchatClient, self).__init__(*args, **kwargs)

    def send_api_message(self, room_id, fr, message, message_format='html'):
        base = {'format': 'json', 'auth_token': self.token}
        red_data = {'room_id': room_id, 'from': fr, 'message': utf8(message), 'message_format': message_format}
        req = Request(url=HIPCHAT_MESSAGE_URL + '?' + urlencode(base), data=urlencode(red_data))
        return json.load(urlopen(req))

    def send_message(self, mess):
        if self.token and mess.getType() == 'groupchat':

            logging.debug('Message intercepted for Hipchat API')
            content, _ = mess_2_embeddablehtml(mess)
            room_jid = mess.getTo()
            self.send_api_message(room_jid.getNode().split('_')[1], CHATROOM_FN, content)
        else:
            super(HipchatClient, self).send_message(mess)

# It is just a different mode for the moment
class HipchatBackend(XMPPBackend):
    def __init__(self, username, password, token=None):
        self.api_token = token
        self.password = password
        super(HipchatBackend, self).__init__(username, password)

    def create_connection(self):
        return HipchatClient(self.jid, password=self.password, debug=[], token=self.api_token)

    @property
    def mode(self):
        return 'hipchat'

########NEW FILE########
__FILENAME__ = irc
from __future__ import absolute_import
import logging
import sys
import config
from errbot.backends.base import Message, build_message, build_text_html_message_pair
from errbot.errBot import ErrBot
from errbot.utils import RateLimited

try:
    import irc.connection
    from irc.bot import SingleServerIRCBot
except ImportError as _:
    logging.exception("Could not start the IRC backend")
    logging.fatal("""
    If you intend to use the IRC backend please install the python irc package:
    -> On debian-like systems
    sudo apt-get install python-software-properties
    sudo apt-get update
    sudo apt-get install python-irc
    -> On Gentoo
    sudo emerge -av dev-python/irc
    -> Generic
    pip install irc
    """)
    sys.exit(-1)


class IRCConnection(SingleServerIRCBot):
    def __init__(self, callback, nickname, server, port=6667, ssl=False, password=None):
        self.use_ssl = ssl
        self.callback = callback
        super().__init__([(server, port, password)], nickname, nickname)

    def _dispatcher(self, c, e):
        super()._dispatcher(c, e)

    def connect(self, *args, **kwargs):
        if self.use_ssl:
            import ssl
            ssl_factory = irc.connection.Factory(wrapper=ssl.wrap_socket)
            self.connection.connect(*args, connect_factory=ssl_factory, **kwargs)
        else:
            self.connection.connect(*args, **kwargs)

    def on_welcome(self, c, e):
        logging.info("IRC welcome %s" % e)
        self.callback.connect_callback()

    def on_pubmsg(self, c, e):
        msg = Message(e.arguments[0])
        msg.setFrom(e.target)
        msg.setTo(self.callback.jid)
        msg.setMuckNick(e.source.split('!')[0])  # FIXME find the real nick in the channel
        msg.setType('groupchat')
        self.callback.callback_message(self, msg)

    def on_privmsg(self, c, e):
        msg = Message(e.arguments[0])
        msg.setFrom(e.source.split('!')[0])
        msg.setTo(e.target)
        msg.setType('chat')
        self.callback.callback_message(self, msg)

    def send_message(self, mess):
        msg_func = self.send_private_message if mess.typ == 'chat' else self.send_public_message
        if mess.typ == 'chat' and mess.getTo().resource:  # if this is a response in private of a public message take the recipient in the resource instead of the incoming chatroom
            to = mess.getTo().resource
        else:
            to = mess.getTo().node
        for line in build_text_html_message_pair(mess.getBody())[0].split('\n'):
            msg_func(to, line)

    @RateLimited(config.__dict__.get('IRC_PRIVATE_RATE', 1))
    def send_private_message(self, to, line):
        self.connection.privmsg(to, line)

    @RateLimited(config.__dict__.get('IRC_CHANNEL_RATE', 1))
    def send_public_message(self, to, line):
        self.connection.privmsg(to, line)


class IRCBackend(ErrBot):
    def __init__(self, nickname, server, port=6667, password=None, ssl=False):
        self.jid = nickname + '@' + server
        super(IRCBackend, self).__init__()
        self.conn = IRCConnection(self, nickname, server, port, ssl, password)

    def serve_forever(self):
        try:
            self.conn.start()
        finally:
            logging.debug("Trigger disconnect callback")
            self.disconnect_callback()
            logging.debug("Trigger shutdown")
            self.shutdown()

    def connect(self):
        return self.conn

    def build_message(self, text):
        return build_message(text, Message)

    def shutdown(self):
        super().shutdown()

    def join_room(self, room, username=None, password=None):
        self.conn.connection.join(room)

    @property
    def mode(self):
        return 'irc'

########NEW FILE########
__FILENAME__ = null
import logging
from time import sleep
from errbot.backends.base import Message
from errbot.errBot import ErrBot


class ConnectionMock():
    def send(self, mess):
        pass

    def send_message(self, mess):
        pass


class NullBackend(ErrBot):
    conn = ConnectionMock()
    running = True

    def serve_forever(self):
        self.jid = 'Err@localhost'  # whatever
        self.connect()  # be sure we are "connected" before the first command
        self.connect_callback()  # notify that the connection occured
        try:
            while self.running:
                sleep(1)

        except EOFError as eof:
            pass
        except KeyboardInterrupt as ki:
            pass
        finally:
            logging.debug("Trigger disconnect callback")
            self.disconnect_callback()
            logging.debug("Trigger shutdown")
            self.shutdown()

    def connect(self):
        if not self.conn:
            self.conn = ConnectionMock()
        return self.conn

    def build_message(self, text):
        text, html = self.build_text_html_message_pair(text)
        return Message(text, html=html)

    def join_room(self, room, username=None, password=None):
        pass  # just ignore that

    def shutdown(self):
        if self.running:
            self.running = False
            super(NullBackend, self).shutdown()  # only once (hackish)

    @property
    def mode(self):
        return 'null'

########NEW FILE########
__FILENAME__ = test
from queue import Queue
import logging
from os.path import sep, abspath
import sys
from tempfile import mkdtemp
from threading import Thread
import unittest
from errbot.main import main

__import__('errbot.config-template')
config_module = sys.modules['errbot.config-template']
sys.modules['config'] = config_module

tempdir = mkdtemp()
config_module.BOT_DATA_DIR = tempdir
config_module.BOT_LOG_FILE = tempdir + sep + 'log.txt'
config_module.BOT_EXTRA_PLUGIN_DIR = []
config_module.BOT_LOG_LEVEL = logging.DEBUG

from errbot.backends.base import Message, build_message
from errbot.errBot import ErrBot
from errbot.builtins.wsview import reset_app

incoming_stanza_queue = Queue()
outgoing_message_queue = Queue()

QUIT_MESSAGE = '$STOP$'

STZ_MSG = 1
STZ_PRE = 2
STZ_IQ = 3

class ConnectionMock():
    def send(self, mess):
        outgoing_message_queue.put(mess.getBody())

    def send_message(self, mess):
        self.send(mess)


class TestBackend(ErrBot):
    conn = ConnectionMock()

    def serve_forever(self):
        import config

        self.jid = 'Err@localhost'  # whatever
        self.connect()  # be sure we are "connected" before the first command
        self.connect_callback()  # notify that the connection occured
        self.sender = config.BOT_ADMINS[0]  # By default, assume this is the admin talking
        try:
            while True:
                stanza_type, entry = incoming_stanza_queue.get()
                if entry == QUIT_MESSAGE:
                    logging.info("Stop magic message received, quitting...")
                    break
                if stanza_type is STZ_MSG:
                    msg = Message(entry)
                    msg.setFrom(self.sender)
                    msg.setTo(self.jid)  # To me only
                    self.callback_message(self.conn, msg)
                elif stanza_type is STZ_PRE:
                    logging.info("Presence stanza received.")
                elif stanza_type is STZ_IQ:
                    logging.info("IQ stanza received.")
                else:
                    logging.error("Unknown stanza type.")

        except EOFError as _:
            pass
        except KeyboardInterrupt as _:
            pass
        finally:
            logging.debug("Trigger disconnect callback")
            self.disconnect_callback()
            logging.debug("Trigger shutdown")
            self.shutdown()

    def connect(self):
        if not self.conn:
            self.conn = ConnectionMock()
        return self.conn

    def build_message(self, text):
        return build_message(text, Message)

    def shutdown(self):
        super(TestBackend, self).shutdown()

    def join_room(self, room, username=None, password=None):
        pass  # just ignore that

    @property
    def mode(self):
        return 'text'


def popMessage(timeout=5, block=True):
    return outgoing_message_queue.get(timeout=timeout, block=block)

def pushMessage(msg):
    incoming_stanza_queue.put((STZ_MSG, msg), timeout=5)

def pushPresence(stanza):
    pass

#def pushIQ(stanza):
#    pass

def zapQueues():
    while not incoming_stanza_queue.empty():
        msg = incoming_stanza_queue.get(block=False)
        logging.error('Message left in the incoming queue during a test : %s' % msg)

    while not outgoing_message_queue.empty():
        msg = outgoing_message_queue.get(block=False)
        logging.error('Message left in the outgoing queue during a test : %s' % msg)


class FullStackTest(unittest.TestCase):
    """ This class starts a full bot with a test backend so you can add unit tests on an almost complete bot
    """
    bot_thread = None

    def setUp(self, extra_test_file=None, loglevel=logging.DEBUG):
        # reset logging to console
        logging.basicConfig(format='%(levelname)s:%(message)s')
        console = logging.StreamHandler()
        file = logging.FileHandler(config_module.BOT_LOG_FILE, encoding='utf-8')
        logger = logging.getLogger('')
        logger.setLevel(loglevel)
        logger.addHandler(file)
        if extra_test_file:
            import config
            config.BOT_EXTRA_PLUGIN_DIR = sep.join(abspath(extra_test_file).split(sep)[:-2])
        self.bot_thread = Thread(target=main, name='Test Bot Thread', args=(TestBackend, logger))
        self.bot_thread.setDaemon(True)
        self.bot_thread.start()

    def tearDown(self):
        pushMessage(QUIT_MESSAGE)
        self.bot_thread.join()
        reset_app()  # empty the bottle ... hips!
        logging.info("Main bot thread quits")
        zapQueues()

    def assertCommand(self, command, response, timeout=5):
        pushMessage(command)
        self.assertIn(response, popMessage(), timeout)

    def assertCommandFound(self, command, timeout=5):
        pushMessage(command)
        self.assertNotIn('not found', popMessage(), timeout)

########NEW FILE########
__FILENAME__ = text
import logging
import sys
import config
from errbot.backends.base import Message, build_message
from errbot.errBot import ErrBot


class ConnectionMock(object):
    def send(self, mess):
        print(mess.getBody())

    def send_message(self, mess):
        self.send(mess)


ENCODING_INPUT = sys.stdin.encoding


class TextBackend(ErrBot):
    conn = ConnectionMock()

    def serve_forever(self):
        self.jid = 'Err@localhost'  # whatever
        self.connect()  # be sure we are "connected" before the first command
        self.connect_callback()  # notify that the connection occured
        try:
            while True:
                entry = input("Talk to  me >>")
                msg = Message(entry)
                msg.setFrom(config.BOT_ADMINS[0])  # assume this is the admin talking
                msg.setTo(self.jid)  # To me only
                self.callback_message(self.conn, msg)
        except EOFError as eof:
            pass
        except KeyboardInterrupt as ki:
            pass
        finally:
            logging.debug("Trigger disconnect callback")
            self.disconnect_callback()
            logging.debug("Trigger shutdown")
            self.shutdown()

    def connect(self):
        if not self.conn:
            self.conn = ConnectionMock()
        return self.conn

    def build_message(self, text):
        return build_message(text, Message)

    def shutdown(self):
        super(TextBackend, self).shutdown()

    def join_room(self, room, username=None, password=None):
        pass  # just ignore that

    @property
    def mode(self):
        return 'text'

########NEW FILE########
__FILENAME__ = xmpp
import logging
import sys
import os.path

from errbot.backends.base import Message, Presence, build_message, Connection
from errbot.errBot import ErrBot
from threading import Thread
from time import sleep

try:
    from sleekxmpp import ClientXMPP
    from sleekxmpp.xmlstream import resolver, cert
except ImportError as _:
    logging.exception("Could not start the XMPP backend")
    logging.fatal("""
    If you intend to use the XMPP backend please install the python sleekxmpp package:
    -> On debian-like systems
    sudo apt-get install python-software-properties
    sudo apt-get update
    sudo apt-get install python-sleekxmpp
    -> On Gentoo
    sudo layman -a laurentb
    sudo emerge -av dev-python/sleekxmpp
    -> Generic
    pip install sleekxmpp
    """)
    sys.exit(-1)


try:
    from config import XMPP_FEATURE_MECHANISMS
except ImportError:
    XMPP_FEATURE_MECHANISMS = {}
try:
    from config import XMPP_KEEPALIVE_INTERVAL
except ImportError:
    XMPP_KEEPALIVE_INTERVAL = None
try:
    from config import XMPP_CA_CERT_FILE
except ImportError:
    XMPP_CA_CERT_FILE = "/etc/ssl/certs/ca-certificates.crt"

if XMPP_CA_CERT_FILE is not None and not os.path.exists(XMPP_CA_CERT_FILE):
    logging.fatal("The CA certificate path set by XMPP_CA_CERT_FILE does not exist. "
                  "Please set XMPP_CA_CERT_FILE to a valid file, or disable certificate"
                  "validation by setting it to None (not recommended!).")
    sys.exit(-1)
try:
    from config import CHATROOM_PRESENCE
except ImportError:
    CHATROOM_PRESENCE = ()


def verify_gtalk_cert(xmpp_client):
    """
        Hack specific for google apps domains with SRV entries.
        It needs to fid the SSL certificate of google and not the one for your domain
    """

    hosts = resolver.get_SRV(xmpp_client.boundjid.server, 5222,
                             xmpp_client.dns_service,
                             resolver=resolver.default_resolver())
    it_is_google = False
    for host, _ in hosts:
        if host.lower().find('google.com') > -1:
            it_is_google = True

    if it_is_google:
        raw_cert = xmpp_client.socket.getpeercert(binary_form=True)
        try:
            if cert.verify('talk.google.com', raw_cert):
                logging.info('google cert found for %s', xmpp_client.boundjid.server)
                return
        except cert.CertificateError:
            pass

    logging.error("invalid cert received for %s", xmpp_client.boundjid.server)


class XMPPConnection(Connection):
    def __init__(self, jid, password):
        self.connected = False
        self.client = ClientXMPP(jid, password, plugin_config={'feature_mechanisms': XMPP_FEATURE_MECHANISMS})
        self.client.register_plugin('xep_0030')  # Service Discovery
        self.client.register_plugin('xep_0045')  # Multi-User Chat
        self.client.register_plugin('xep_0004')  # Multi-User Chat backward compability (necessary for join room)
        self.client.register_plugin('xep_0199')  # XMPP Ping
        self.client.register_plugin('xep_0203')  # XMPP Delayed messages
        self.client.register_plugin('xep_0249')  # XMPP direct MUC invites

        if XMPP_KEEPALIVE_INTERVAL is not None:
            self.client.whitespace_keepalive = True  # Just in case SleekXMPP's default changes to False in the future
            self.client.whitespace_keepalive_interval = XMPP_KEEPALIVE_INTERVAL

        self.client.ca_certs = XMPP_CA_CERT_FILE  # Used for TLS certificate validation

        self.client.add_event_handler("session_start", self.session_start)
        self.client.add_event_handler("ssl_invalid_cert", self.ssl_invalid_cert)

    def send_message(self, mess):
        self.client.send_message(mto=mess.getTo(),
                                 mbody=mess.getBody(),
                                 mtype=mess.getType(),
                                 mhtml=mess.getHTML())

    def session_start(self, _):
        self.client.send_presence()
        self.client.get_roster()

    def ssl_invalid_cert(self, _):
        # Special quirk for google domains
        verify_gtalk_cert(self.client)

    def connect(self):
        if not self.connected:
            self.client.connect()
            self.connected = True
        return self

    def disconnect(self):
        self.client.disconnect(wait=True)
        self.connected = False

    def serve_forever(self):
        self.client.process(block=True)

    def add_event_handler(self, name, cb):
        self.client.add_event_handler(name, cb)

    def del_event_handler(self, name, cb):
        self.client.del_event_handler(name, cb)

    def join_room(self, room, username, password):
        """Attempt to join the given MUC"""
        muc = self.client.plugin['xep_0045']
        muc.joinMUC(room,
                    username,
                    password=password,
                    wait=True)
        # Room configuration can only be done once a MUC presence stanza
        # has been received from the server. This HAS to take place in a
        # separate thread because of how SleekXMPP processes these stanzas.
        t = Thread(target=self.configure_room, args=[room])
        t.setDaemon(True)
        t.start()

    def configure_room(self, room):
        """
        Configure the given MUC

        Currently this simply sets the default room configuration as
        received by the server. May be extended in the future to set
        a custom room configuration instead.
        """
        muc = self.client.plugin['xep_0045']
        affiliation = None
        while affiliation is None:
            sleep(0.5)
            affiliation = muc.getJidProperty(
                room=room,
                nick=muc.ourNicks[room],
                jidProperty='affiliation'
            )

        if affiliation == "owner":
            logging.debug("Configuring room {} because we have owner affiliation".format(room))
            form = muc.getRoomConfig(room)
            muc.configureRoom(room, form)
        else:
            logging.debug("Not configuring room {} because we don't have owner affiliation (affiliation={})"
                          .format(room, affiliation))

    def invite_in_room(self, room, jids_to_invite):
        muc = self.client.plugin['xep_0045']
        for jid in jids_to_invite:
            logging.debug("Inviting %s to %s..." % (jid, room))
            muc.invite(room, jid)


class XMPPBackend(ErrBot):
    def __init__(self, username, password, *args, **kwargs):
        super(XMPPBackend, self).__init__(*args, **kwargs)
        self.jid = username
        self.password = password
        self.conn = self.create_connection()
        self.conn.add_event_handler("message", self.incoming_message)
        self.conn.add_event_handler("session_start", self.connected)
        self.conn.add_event_handler("disconnected", self.disconnected)
        # presence related handlers
        self.conn.add_event_handler("got_online", self.contact_online)
        self.conn.add_event_handler("got_offline", self.contact_offline)
        # NOTE: for now we will register the handlers this way
        e_muc_online = "muc::{}::got_online"
        e_muc_offline = "muc::{}::got_offline"
        for room in CHATROOM_PRESENCE:
            # using string or first element of (room, passwd) tuple
            room = room if isinstance(room, str) else room[0]
            self.conn.add_event_handler(e_muc_online.format(room),
                                        self.user_joined_chat)
            self.conn.add_event_handler(e_muc_offline.format(room),
                                        self.user_left_chat)

    def create_connection(self):
        return XMPPConnection(self.jid, self.password)

    def incoming_message(self, xmppmsg):
        """Callback for message events"""
        msg = Message(xmppmsg['body'])
        if 'html' in xmppmsg.keys():
            msg.setHTML(xmppmsg['html'])
        msg.setFrom(xmppmsg['from'].full)
        msg.setTo(xmppmsg['to'].full)
        msg.setType(xmppmsg['type'])
        msg.setMuckNick(xmppmsg['mucnick'])
        msg.setDelayed(bool(xmppmsg['delay']._get_attr('stamp')))  # this is a bug in sleekxmpp it should be ['from']
        self.callback_message(self.conn, msg)

    def contact_online(self, stanza):
        pass

    def contact_offline(self, stanza):
        pass

    def user_joined_chat(self, stanza):
        pass

    def user_left_chat(self, stanza):
        pass

    def connected(self, data):
        """Callback for connection events"""
        self.connect_callback()

    def disconnected(self, data):
        """Callback for disconnection events"""
        self.disconnect_callback()

    def serve_forever(self):
        self.connect()  # be sure we are "connected" before the first command

        try:
            self.conn.serve_forever()
        finally:
            logging.debug("Trigger disconnect callback")
            self.disconnect_callback()
            logging.debug("Trigger shutdown")
            self.shutdown()

    def connect(self):
        return self.conn.connect()

    def build_message(self, text):
        return build_message(text, Message)

    def join_room(self, room, username=None, password=None):
        self.conn.join_room(room, username, password)

    def invite_in_room(self, room, jids_to_invite):
        self.conn.invite_in_room(room, jids_to_invite)

    @property
    def mode(self):
        return 'xmpp'

########NEW FILE########
__FILENAME__ = botplugin
import logging
import os
from threading import Timer, current_thread
from errbot.utils import PLUGINS_SUBDIR, recurse_check_structure
from errbot.storage import StoreMixin, StoreNotOpenError
from errbot import holder



class BotPluginBase(StoreMixin):
    """
     This class handle the basic needs of bot plugins like loading, unloading and creating a storage
     It is the main contract between the plugins and the bot
    """

    def __init__(self):
        self.plugin_dir = holder.bot.plugin_dir
        self.is_activated = False
        self.current_pollers = []
        self.current_timers = []
        super(BotPluginBase, self).__init__()

    def activate(self):
        """
            Override if you want to do something at initialization phase (don't forget to super(Gnagna, self).activate())
        """
        from config import BOT_DATA_DIR

        classname = self.__class__.__name__
        logging.debug('Init storage for %s' % classname)
        filename = BOT_DATA_DIR + os.sep + PLUGINS_SUBDIR + os.sep + classname + '.db'
        logging.debug('Loading %s' % filename)
        self.open_storage(filename)
        holder.bot.inject_commands_from(self)
        self.is_activated = True

    def deactivate(self):
        """
            Override if you want to do something at tear down phase (don't forget to super(Gnagna, self).deactivate())
        """
        if self.current_pollers:
            logging.debug('You still have active pollers at deactivation stage, I cleaned them up for you.')
            self.current_pollers = []
            for timer in self.current_timers:
                timer.cancel()

        try:
            self.close_storage()
        except StoreNotOpenError:
            pass
        holder.bot.remove_commands_from(self)
        self.is_activated = False

    def start_poller(self, interval, method, args=None, kwargs=None):
        if not kwargs:
            kwargs = {}
        if not args:
            args = []

        logging.debug('Programming the polling of %s every %i seconds with args %s and kwargs %s' % (method.__name__, interval, str(args), str(kwargs)))
        #noinspection PyBroadException
        try:
            self.current_pollers.append((method, args, kwargs))
            self.program_next_poll(interval, method, args, kwargs)
        except Exception as _:
            logging.exception('failed')

    def stop_poller(self, method, args=None, kwargs=None):
        if not kwargs:
            kwargs = {}
        if not args:
            args = []
        logging.debug('Stop polling of %s with args %s and kwargs %s' % (method, args, kwargs))
        self.current_pollers.remove((method, args, kwargs))

    def program_next_poll(self, interval, method, args, kwargs):
        t = Timer(interval=interval, function=self.poller, kwargs={'interval': interval, 'method': method, 'args': args, 'kwargs': kwargs})
        self.current_timers.append(t)  # save the timer to be able to kill it
        t.setName('Poller thread for %s' % type(method.__self__).__name__)
        t.setDaemon(True)  # so it is not locking on exit
        t.start()

    def poller(self, interval, method, args, kwargs):
        previous_timer = current_thread()
        if previous_timer in self.current_timers:
            logging.debug('Previous timer found and removed')
            self.current_timers.remove(previous_timer)

        if (method, args, kwargs) in self.current_pollers:
            #noinspection PyBroadException
            try:
                method(*args, **kwargs)
            except Exception as _:
                logging.exception('A poller crashed')
            self.program_next_poll(interval, method, args, kwargs)


class BotPlugin(BotPluginBase):
    @property
    def min_err_version(self):
        """ If your plugin has a minimum version of err it needs to be on in order to run, please override accordingly this method.
        returning a string with the dotted minimum version. it MUST be in a 3 dotted numbers format or None
        for example: "1.2.2"
        """
        return None

    @property
    def max_err_version(self):
        """ If your plugin has a maximal version of err it needs to be on in order to run, please override accordingly this method.
        returning a string with the dotted maximal version. it MUST be in a 3 dotted numbers format or None
        for example: "1.2.2"
        """
        return None

    def get_configuration_template(self):
        """ If your plugin needs a configuration, override this method and return a configuration template.
        for example a dictionary like:
        return {'LOGIN' : 'example@example.com', 'PASSWORD' : 'password'}
        Note : if this method returns None, the plugin won't be configured
        """
        return None

    def check_configuration(self, configuration):
        """ By default, this method will do only a BASIC check. You need to override it if you want to do more complex checks.
        It will be called before the configure callback. Note if the config_template is None, it will never be called
        It means recusively:
        1. in case of a dictionary, it will check if all the entries and from the same type are there and not more
        2. in case of an array or tuple, it will assume array members of the same type of first element of the template (no mix typed is supported)

        In case of validation error it should raise a errbot.utils.ValidationException

        """
        recurse_check_structure(self.get_configuration_template(), configuration)  # default behavior

    def configure(self, configuration):
        """ By default, it will just store the current configuation in the self.config field of your plugin
        If this plugin has no configuration yet, the framework will call this function anyway with None
        This method will be called before activation so don't expect to be activated at that point
        """
        self.config = configuration

    def activate(self):
        """
            Override if you want to do something at initialization phase (don't forget to super(Gnagna, self).activate())
        """
        super(BotPlugin, self).activate()

    def deactivate(self):
        """
            Override if you want to do something at tear down phase (don't forget to super(Gnagna, self).deactivate())
        """
        super(BotPlugin, self).deactivate()

    def callback_connect(self):
        """
            Override to get a notified when the bot is connected
        """
        pass

    def callback_message(self, conn, mess):
        """
            Override to get a notified on *ANY* message.
            If you are interested only by chatting message you can filter for example mess.getType() in ('groupchat', 'chat')
        """
        pass

    def callback_botmessage(self, mess):
        """
            Override to get a notified on messages from the bot itself (emitted from your plugin sisters and brothers for example).
        """
        pass

    def callback_contact_online(self, conn, pres):
        """
            Override to get a notification when a contact becomes online.
        """
        pass

    def callback_contact_offline(self, conn, pres):
        """
            Override to get notified when a contact becomes offline.
        """
        pass

    def callback_user_joined_chat(self, conn, pres):
        """
            Override to get notified when any user joins a chatroom or an equivalent.
        """
        pass

    def callback_user_left_chat(self, conn, pres):
        """
            Override to get notified when any user leaves a chatroom or an equivalent.
        """
        pass

    # Proxyfy some useful tools from the motherbot
    # this is basically the contract between the plugins and the main bot

    def warn_admins(self, warning):
        """
            Sends a warning to the administrators of the bot
        """
        return holder.bot.warn_admins(warning)

    def send(self, user, text, in_reply_to=None, message_type='chat'):
        """
            Sends asynchronously a message a room or a user.
             if it is a room message_type needs to by 'groupchat' and user the room.
        """
        return holder.bot.send(user, text, in_reply_to, message_type)

    def bare_send(self, xmppy_msg):
        """
            A bypass to send directly a crafted xmppy message.
              Usefull to extend to bot in not forseen ways.
        """
        c = holder.bot.connect()
        if c:
            return c.send(xmppy_msg)
        logging.warning('Ignored a message as the bot is not connected yet')
        return None  # the bot is not connected yet

    def join_room(self, room, username=None, password=None):
        """
            Make the bot join a room
        """
        return holder.bot.join_room(room, username, password)

    def invite_in_room(self, room, jids_to_invite):
        """
            Make the bot invite a list of jids to a room
        """
        return holder.bot.invite_in_room(room, jids_to_invite)


    def get_installed_plugin_repos(self):
        """
            Get the current installed plugin repos in a dictionary of name / url
        """
        return holder.bot.get_installed_plugin_repos()

    def start_poller(self, interval, method, args=None, kwargs=None):
        """
            Start to poll a method at specific interval in seconds.
            Note : it will call the method with the initial interval delay for the first time
            Also, you can program
            for example : self.program_poller(self,30, fetch_stuff)
            where you have def fetch_stuff(self) in your plugin
        """
        super(BotPlugin, self).start_poller(interval, method, args, kwargs)

    def stop_poller(self, method=None, args=None, kwargs=None):
        """
            stop poller(s).
            if the method equals None -> it stops all the pollers
            you need to regive the same parameters as the original start_poller to match a specific poller to stop
        """
        super(BotPlugin, self).stop_poller(method, args, kwargs)
########NEW FILE########
__FILENAME__ = chatRoom
import logging
from errbot import BotPlugin, PY3, botcmd
from errbot.version import VERSION
from errbot.holder import bot
from uuid import uuid4

__author__ = 'gbin'
from config import CHATROOM_PRESENCE, CHATROOM_FN, CHATROOM_RELAY, REVERSE_CHATROOM_RELAY

# 2to3 hack
# thanks to https://github.com/oxplot/fysom/issues/1
# which in turn references http://www.rfk.id.au/blog/entry/preparing-pyenchant-for-python-3/
if PY3:
    basestring = (str, bytes)


class ChatRoom(BotPlugin):
    min_err_version = VERSION  # don't copy paste that for your plugin, it is just because it is a bundled plugin !
    max_err_version = VERSION

    connected = False

    def callback_connect(self):
        logging.info('Callback_connect')
        if not self.connected:
            self.connected = True
            for room in CHATROOM_PRESENCE:
                if isinstance(room, basestring):
                    logging.info('Join room ' + room +' as user '+ CHATROOM_FN)
                    self.join_room(room, CHATROOM_FN)
                else:
                    logging.info('Join room ' + room[0] +' as user '+ CHATROOM_FN)
                    self.join_room(room[0], username=CHATROOM_FN, password=room[1])

    def deactivate(self):
        self.connected = False
        super(ChatRoom, self).deactivate()

    @botcmd
    def room_create(self, mess, args):
        """ Create an adhoc chatroom for Google talk and invite the listed persons.
            If no person is listed, only the requestor is invited.

            Examples:
            !root create
            !root create gbin@gootz.net toto@gootz.net
        """
        room_name = "private-chat-%s@groupchat.google.com" % uuid4()
        self.join_room(room_name)
        to_invite = (mess.getFrom().getStripped(),) if not args else (jid.strip() for jid in args.split())
        self.invite_in_room(room_name, to_invite)
        return "Room created (%s)" % room_name


    def callback_message(self, conn, mess):
        if bot.mode != 'campfire':  # no relay support in campfire
            try:
                mess_type = mess.getType()
                if mess_type == 'chat':
                    username = mess.getFrom().node
                    if username in CHATROOM_RELAY:
                        logging.debug('Message to relay from %s.' % username)
                        body = mess.getBody()
                        rooms = CHATROOM_RELAY[username]
                        for room in rooms:
                            self.send(room, body, message_type='groupchat')
                elif mess_type == 'groupchat':
                    fr = mess.getFrom()
                    chat_room = fr.node + '@' + fr.domain if fr.domain else fr.node  # some backends has no domain notion
                    if chat_room in REVERSE_CHATROOM_RELAY:
                        users_to_relay_to = REVERSE_CHATROOM_RELAY[chat_room]
                        logging.debug('Message to relay to %s.' % users_to_relay_to)
                        body = '[%s] %s' % (fr.resource, mess.getBody())
                        for user in users_to_relay_to:
                            self.send(user, body)
            except Exception as e:
                logging.exception('crashed in callback_message %s' % e)

########NEW FILE########
__FILENAME__ = vcheck
import logging
from errbot import BotPlugin
from errbot.version import VERSION
from urllib.request import urlopen
from errbot.utils import version2array

HOME = 'http://gbin.github.io/err/version'

installed_version = version2array(VERSION)


class VersionChecker(BotPlugin):
    min_err_version = VERSION  # don't copy paste that for your plugin, it is just because it is a bundled plugin !
    max_err_version = VERSION

    connected = False
    actived = False

    def activate(self):
        self.actived = True
        self.version_check()  # once at startup anyway
        self.start_poller(3600 * 24, self.version_check)  # once every 24H
        super(VersionChecker, self).activate()

    def deactivate(self):
        self.actived = False
        super(VersionChecker, self).deactivate()

    def version_check(self):
        if not self.actived:
            logging.debug('Version check disabled')
            return
        logging.debug('Checking version')
        #noinspection PyBroadException
        try:
            current_version_txt = urlopen(HOME).read().decode("utf-8").strip()
            current_version = version2array(current_version_txt)
            if installed_version < current_version:
                logging.debug('A new version %s has been found, notify the admins !' % current_version)
                self.warn_admins(
                    'Version {0} of err is available. http://pypi.python.org/pypi/err/{0}. You can disable this check '
                    'by doing !unload VersionChecker followed by !blacklist VersionChecker'.format(current_version_txt)
                )
        except Exception as e:
            logging.exception('Could not version check')

    def callback_connect(self):
        if not self.connected:
            self.connected = True

########NEW FILE########
__FILENAME__ = webserver
import sys
import logging
import os
from json import loads
from random import random
from threading import Thread
from errbot import holder, PY3
from errbot import botcmd
from errbot import BotPlugin
from errbot.version import VERSION
from errbot.builtins.wsview import bottle_app
from errbot.decorators import webhook
from errbot.bundled.rocket import Rocket
from webtest import TestApp
from config import BOT_DATA_DIR

if PY3:
    from urllib.request import unquote
else:
    from urllib2 import unquote

try:
    from OpenSSL import crypto
    has_crypto = True
except ImportError:
    has_crypto = False

TEST_REPORT = """*** Test Report
URL : %s
Detected your post as : %s
Status code : %i
"""

def make_ssl_certificate(key_path, cert_path):
    """
    Generate a self-signed certificate

    The generated key will be written out to key_path, with the corresponding
    certificate itself being written to cert_path.
    """
    cert = crypto.X509()
    cert.set_serial_number(int(random() * sys.maxsize))
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(60 * 60 * 24 * 365)

    subject = cert.get_subject()
    subject.CN = '*'
    subject.O = 'Self-Signed Certificate for Err'

    issuer = cert.get_issuer()
    issuer.CN = 'Self-proclaimed Authority'
    issuer.O = 'Self-Signed'

    pkey = crypto.PKey()
    pkey.generate_key(crypto.TYPE_RSA, 4096)
    cert.set_pubkey(pkey)
    cert.sign(pkey, 'sha256')

    f = open(cert_path, 'w')
    f.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert).decode('utf-8'))
    f.close()

    f = open(key_path, 'w')
    f.write(crypto.dump_privatekey(crypto.FILETYPE_PEM, pkey).decode('utf-8'))
    f.close()


class Webserver(BotPlugin):
    min_err_version = VERSION  # don't copy paste that for your plugin, it is just because it is a bundled plugin !
    max_err_version = VERSION

    def __init__(self):
        self.webserver = None
        self.webchat_mode = False
        self.ssl_context = None
        self.test_app = TestApp(bottle_app)
        super(Webserver, self).__init__()

    def get_configuration_template(self):
        return {'HOST': '0.0.0.0',
                'PORT': 3141,
                'SSL': {'enabled': False,
                        'host': '0.0.0.0',
                        'port': 3142,
                        'certificate': "",
                        'key': ""}}

    def check_configuration(self, configuration):
        # it is a pain, just assume a default config if SSL is absent or set to None
        if configuration.get('SSL', None) is None:
            configuration['SSL'] = {'enabled': False, 'host': '0.0.0.0', 'port': 3142, 'certificate': "", 'key': ""}
        super(Webserver, self).check_configuration(configuration)

    def activate(self):
        if not self.config:
            logging.info('Webserver is not configured. Forbid activation')
            return

        host = self.config['HOST']
        port = self.config['PORT']
        ssl = self.config['SSL']
        interfaces = [(host, port)]
        if ssl['enabled']:
            interfaces.append((ssl['host'], ssl['port'], ssl['key'], ssl['certificate']))
        logging.info('Firing up the Rocket')
        self.webserver = Rocket(interfaces=interfaces,
                                app_info={'wsgi_app': bottle_app}, )
        self.webserver.start(background=True)
        logging.debug('Liftoff!')

        super(Webserver, self).activate()
        logging.info('Webserver activated')

    def deactivate(self):
        if self.webserver is not None:
            logging.debug('Sending signal to stop the webserver')
            self.webserver.stop()
        super(Webserver, self).deactivate()

    #noinspection PyUnusedLocal
    @botcmd(template='webstatus')
    def webstatus(self, mess, args):
        """
        Gives a quick status of what is mapped in the internal webserver
        """
        return {'rules': (((route.rule, route.name) for route in bottle_app.routes))}

    @webhook
    def echo(self, incoming_request):
        """
        A simple test webhook
        """
        logging.debug("Your incoming request is :" + str(incoming_request))
        return str(incoming_request)

    @botcmd(split_args_with=' ')
    def webhook_test(self, _, args):
        """
            Test your webhooks from within err.

        The syntax is :
        !webhook test [relative_url] [post content]

        It triggers the notification and generate also a little test report.
        """
        url = args[0] if PY3 else args[0].encode()  # PY2 needs a str not unicode
        content = ' '.join(args[1:])

        # try to guess the content-type of what has been passed
        try:
            # try if it is plain json
            loads(content)
            contenttype = 'application/json'
        except ValueError:
            # try if it is a form
            splitted = content.split('=')
            #noinspection PyBroadException
            try:
                payload = '='.join(splitted[1:])
                loads(unquote(payload))
                contenttype = 'application/x-www-form-urlencoded'
            except Exception as _:
                contenttype = 'text/plain'  # dunno what it is

        logging.debug('Detected your post as : %s' % contenttype)

        response = self.test_app.post(url, params=content, content_type=contenttype)
        return TEST_REPORT % (url, contenttype, response.status_code)

    @botcmd(admin_only=True)
    def generate_certificate(self, mess, args):
        """
        Generate a self-signed SSL certificate for the Webserver
        """
        if not has_crypto:
            yield ("It looks like pyOpenSSL isn't installed. Please install this "
                   "package using for example `pip install pyOpenSSL`, then try again")
            return

        yield ("Generating a new private key and certificate. This could take a "
               "while if your system is slow or low on entropy")
        key_path = os.sep.join((BOT_DATA_DIR, "webserver_key.pem"))
        cert_path = os.sep.join((BOT_DATA_DIR, "webserver_certificate.pem"))
        make_ssl_certificate(key_path=key_path, cert_path=cert_path)
        yield "Certificate successfully generated and saved in {}".format(BOT_DATA_DIR)

        suggested_config = self.config
        suggested_config['SSL']['enabled'] = True
        suggested_config['SSL']['host'] = suggested_config['HOST']
        suggested_config['SSL']['port'] = suggested_config['PORT'] + 1
        suggested_config['SSL']['key'] = key_path
        suggested_config['SSL']['certificate'] = cert_path
        yield ("To enable SSL with this certificate, the following config "
               "is recommended:")
        yield "{!r}".format(suggested_config)

########NEW FILE########
__FILENAME__ = wsview
from inspect import getmembers, ismethod
from json import loads
import logging

from bottle import Bottle, request
# noinspection PyUnresolvedReferences
from bottle import jinja2_view as view
# noinspection PyUnresolvedReferences
from bottle import jinja2_template as template
from errbot.plugin_manager import get_all_active_plugin_objects


class DynamicBottle(Bottle):
    def del_route(self, route_name):
        deleted_route = None
        for route in self.routes[:]:
            if route.name == route_name:
                self.routes.remove(route)
                deleted_route = route
                break
        if not deleted_route:
            raise ValueError('Cannot find the route %s to delete' % route_name)
        del (self.router.rules[deleted_route.rule])


bottle_app = DynamicBottle()

route = bottle_app.route  # make that the default

def try_decode_json(request):
    data = request.body.read().decode()
    try:
        return loads(data)
    except Exception as _:
        return None


def reset_app():
    """Zap everything here, useful for unit tests
    """
    global bottle_app
    bottle_app = DynamicBottle()

class WebView(object):
    def __init__(self, func, form_param):
        self.func = func
        self.form_param = form_param
        self.method_filter = lambda object: ismethod(object) and self.func.__name__ == object.__name__

    def __call__(self, *args, **kwargs):
        name_to_find = self.func.__name__
        logging.debug('All active plugin objects %s ' % get_all_active_plugin_objects())
        for obj in get_all_active_plugin_objects():  # horrible hack to find back the bound method from the unbound function the decorator was able to give us
            matching_members = getmembers(obj, self.method_filter)
            logging.debug('Matching members %s -> %s' % (obj, matching_members))
            if matching_members:
                name, func = matching_members[0]
                if self.form_param:
                    content = request.forms.get(self.form_param)
                    if content is None:
                        raise Exception("Received a request on a webhook with a form_param defined, "
                                        "but that key ({}) is missing from the request.".format(self.form_param))
                    try:
                        content = loads(content)
                    except ValueError:
                        logging.debug('The form parameter is not JSON, return it as a string')
                    response = func(content, **kwargs)
                else:
                    data = try_decode_json(request)
                    if not data:
                        if hasattr(request, 'forms'):
                            data = dict(request.forms)  # form encoded
                        else:
                            data = request.body.read().decode()
                    response = func(data, **kwargs)
                return response if response else ''  # assume None as an OK response (simplifies the client side)

        raise Exception('Problem finding back the correct Handler for func %s' % name_to_find)



########NEW FILE########
__FILENAME__ = exrex
#!/usr/bin/env python

# This file is part of exrex.
#
# exrex is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# exrex is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with exrex. If not, see < http://www.gnu.org/licenses/ >.
#
# (C) 2012- by Adam Tauber, <asciimoo@gmail.com>

from re import sre_parse
from itertools import product, chain, tee

__all__ = ('generate', 'CATEGORIES', 'count', 'parse')

CATEGORIES = {'category_space': sorted(sre_parse.WHITESPACE),
              'category_digit': sorted(sre_parse.DIGITS),
              'category_any': [chr(x) for x in range(32, 123)]}


def comb(g, i):
    for c in g:
        g2, i = tee(i)
        for c2 in g2:
            yield c + c2


def mappend(g, c):
    for cc in g:
        yield cc + c


def _in(d):
    ret = []
    for i in d:
        if i[0] == 'range':
            ret.extend(map(chr, range(i[1][0], i[1][1] + 1)))
        elif i[0] == 'literal':
            ret.append(chr(i[1]))
        elif i[0] == 'category':
            subs = CATEGORIES.get(i[1], [''])
            ret.extend(subs)
    return ret


def prods(orig, ran, items):
    for o in orig:
        for r in ran:
            for s in product(items, repeat=r):
                yield o + ''.join(s)


def _gen(d, limit=20, count=False):
    """docstring for _p"""
    ret = ['']
    params = []
    strings = 0
    for i in d:
        if i[0] == 'in':
            subs = _in(i[1])
            if count:
                strings = (strings or 1) * len(subs)
            ret = comb(ret, subs)
        elif i[0] == 'literal':
            ret = mappend(ret, chr(i[1]))
        elif i[0] == 'category':
            subs = CATEGORIES.get(i[1], [''])
            if count:
                strings = (strings or 1) * len(subs)
            ret = comb(ret, subs)
        elif i[0] == 'any':
            subs = CATEGORIES['category_any']
            if count:
                strings = (strings or 1) * len(subs)
            ret = comb(ret, subs)
        elif i[0] == 'max_repeat':
            chars = filter(None, _gen(list(i[1][2]), limit))
            if i[1][1] + 1 - i[1][0] > limit:
                ran = range(i[1][0], i[1][0] + limit)
            else:
                ran = range(i[1][0], i[1][1] + 1)
            if count:
                for i in ran:
                    strings += pow(len(chars), i)
            ret = prods(ret, ran, chars)
        elif i[0] == 'branch':
            subs = chain.from_iterable(_gen(list(x), limit) for x in i[1][1])
            if count:
                strings = (strings or 1) * len(subs)
            ret = comb(ret, subs)
        elif i[0] == 'subpattern':
            l = i[1:]
            subs = list(chain.from_iterable(_gen(list(x[1]), limit) for x in l))
            if count:
                strings = (strings or 1) * len(subs)
            ret = comb(ret, subs)
        else:
            print('[!] cannot handle expression "%r"' % i)

    if count:
        return strings

    return ret


def parse(s):
    """Regular expression parser

    :param s: Regular expression
    :type s: str
    :rtype: list
    """
    r = sre_parse.parse(s)
    return list(r)


def generate(s, limit=20):
    """Creates a generator that generates all matching strings to a given regular expression

    :param s: Regular expression
    :type s: str
    :param limit: Range limit
    :type limit: int
    :returns: string generator object
    """
    return _gen(parse(s), limit)


def count(s, limit=20):
    """Counts all matching strings to a given regular expression

    :param s: Regular expression
    :type s: str
    :param limit: Range limit
    :type limit: int
    :rtype: int
    :returns: number of matching strings
    """
    return _gen(parse(s), limit, count=True)


def argparser():
    import argparse
    from sys import stdout

    argp = argparse.ArgumentParser(description='exrex - regular expression string generator')
    argp.add_argument('-o', '--output', help='Output file - default is STDOUT', metavar='FILE', default=stdout, type=argparse.FileType('w'))
    argp.add_argument('-l', '--limit', help='Max limit for range size - default is 20', default=20, action='store', type=int, metavar='N')
    argp.add_argument('-c', '--count', help='Count matching strings', default=False, action='store_true')
    argp.add_argument('-d', '--delimiter', help='Delimiter - default is \\n', default='\n')
    argp.add_argument('-v', '--verbose', action='store_true', help='Verbose mode', default=False)
    argp.add_argument('regex', metavar='REGEX', help='REGEX string')
    return vars(argp.parse_args())

########NEW FILE########
__FILENAME__ = rocket
# -*- coding: utf-8 -*-

# This file is part of the Rocket Web Server
# Copyright (c) 2011 Timothy Farrell

# Import System Modules
import sys
import errno
import socket
import logging
import platform

# Define Constants
VERSION = '1.2.4'
SERVER_NAME = socket.gethostname()
SERVER_SOFTWARE = 'Rocket %s' % VERSION
HTTP_SERVER_SOFTWARE = '%s Python/%s' % (SERVER_SOFTWARE, sys.version.split(' ')[0])
BUF_SIZE = 16384
SOCKET_TIMEOUT = 1 # in secs
THREAD_STOP_CHECK_INTERVAL = 1 # in secs, How often should threads check for a server stop message?
IS_JYTHON = platform.system() == 'Java' # Handle special cases for Jython
IGNORE_ERRORS_ON_CLOSE = set([errno.ECONNABORTED, errno.ECONNRESET])
DEFAULT_LISTEN_QUEUE_SIZE = 5
DEFAULT_MIN_THREADS = 10
DEFAULT_MAX_THREADS = 0
DEFAULTS = dict(LISTEN_QUEUE_SIZE = DEFAULT_LISTEN_QUEUE_SIZE,
                MIN_THREADS = DEFAULT_MIN_THREADS,
                MAX_THREADS = DEFAULT_MAX_THREADS)

PY3K = sys.version_info[0] > 2

class NullHandler(logging.Handler):
    "A Logging handler to prevent library errors."
    def emit(self, record):
        pass

if PY3K:
    def b(val):
        """ Convert string/unicode/bytes literals into bytes.  This allows for
        the same code to run on Python 2.x and 3.x. """
        if isinstance(val, str):
            return val.encode()
        else:
            return val

    def u(val, encoding="us-ascii"):
        """ Convert bytes into string/unicode.  This allows for the
        same code to run on Python 2.x and 3.x. """
        if isinstance(val, bytes):
            return val.decode(encoding)
        else:
            return val

else:
    def b(val):
        """ Convert string/unicode/bytes literals into bytes.  This allows for
        the same code to run on Python 2.x and 3.x. """
        if isinstance(val, unicode):
            return val.encode()
        else:
            return val

    def u(val, encoding="us-ascii"):
        """ Convert bytes into string/unicode.  This allows for the
        same code to run on Python 2.x and 3.x. """
        if isinstance(val, str):
            return val.decode(encoding)
        else:
            return val

# Import Package Modules
# package imports removed in monolithic build

__all__ = ['VERSION', 'SERVER_SOFTWARE', 'HTTP_SERVER_SOFTWARE', 'BUF_SIZE',
           'IS_JYTHON', 'IGNORE_ERRORS_ON_CLOSE', 'DEFAULTS', 'PY3K', 'b', 'u',
           'Rocket', 'CherryPyWSGIServer', 'SERVER_NAME', 'NullHandler']

# Monolithic build...end of module: rocket/__init__.py
# Monolithic build...start of module: rocket/connection.py

# Import System Modules
import sys
import time
import socket
try:
    import ssl
    has_ssl = True
except ImportError:
    has_ssl = False
# Import Package Modules
# package imports removed in monolithic build
# TODO - This part is still very experimental.
#from .filelike import FileLikeSocket

class Connection(object):
    __slots__ = [
        'setblocking',
        'sendall',
        'shutdown',
        'makefile',
        'fileno',
        'client_addr',
        'client_port',
        'server_port',
        'socket',
        'start_time',
        'ssl',
        'secure',
        'recv',
        'send',
        'read',
        'write'
    ]

    def __init__(self, sock_tuple, port, secure=False):
        self.client_addr, self.client_port = sock_tuple[1]
        self.server_port = port
        self.socket = sock_tuple[0]
        self.start_time = time.time()
        self.ssl = has_ssl and isinstance(self.socket, ssl.SSLSocket)
        self.secure = secure

        if IS_JYTHON:
            # In Jython we must set TCP_NODELAY here since it does not
            # inherit from the listening socket.
            # See: http://bugs.jython.org/issue1309
            self.socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

        self.socket.settimeout(SOCKET_TIMEOUT)

        self.sendall = self.socket.sendall
        self.shutdown = self.socket.shutdown
        self.fileno = self.socket.fileno
        self.setblocking = self.socket.setblocking
        self.recv = self.socket.recv
        self.send = self.socket.send
        self.makefile = self.socket.makefile

# FIXME - this is not ready for prime-time yet.
#    def makefile(self, buf_size=BUF_SIZE):
#        return FileLikeSocket(self, buf_size)

    def close(self):
        if hasattr(self.socket, '_sock'):
            try:
                self.socket._sock.close()
            except socket.error:
                info = sys.exc_info()
                if info[1].args[0] != socket.EBADF:
                    raise info[1]
                else:
                    pass
        self.socket.close()


# Monolithic build...end of module: rocket/connection.py
# Monolithic build...start of module: rocket/filelike.py

# Import System Modules
import socket
try:
    from io import StringIO
except ImportError:
    try:
        from cStringIO import StringIO
    except ImportError:
        from StringIO import StringIO
# Import Package Modules
# package imports removed in monolithic build

class FileLikeSocket(object):
    def __init__(self, conn, buf_size=BUF_SIZE):
        self.conn = conn
        self.buf_size = buf_size
        self.buffer = StringIO()
        self.content_length = None

        if self.conn.socket.gettimeout() == 0.0:
            self.read = self.non_blocking_read
        else:
            self.read = self.blocking_read

    def __iter__(self):
        return self

    def recv(self, size):
        while True:
            try:
                return self.conn.recv(size)
            except socket.error:
                exc = sys.exc_info()
                e = exc[1]
                # FIXME - Don't raise socket_errors_nonblocking or socket_error_eintr
                if (e.args[0] not in set()):
                    raise

    def next(self):
        data = self.readline()
        if data == '':
            raise StopIteration
        return data

    def non_blocking_read(self, size=None):
        # Shamelessly adapted from Cherrypy!
        bufr = self.buffer
        bufr.seek(0, 2)
        if size is None:
            while True:
                data = self.recv(self.buf_size)
                if not data:
                    break
                bufr.write(data)

            self.buffer = StringIO()

            return bufr.getvalue()
        else:
            buf_len = self.buffer.tell()
            if buf_len >= size:
                bufr.seek(0)
                data = bufr.read(size)
                self.buffer = StringIO(bufr.read())
                return data

            self.buffer = StringIO()
            while True:
                remaining = size - buf_len
                data = self.recv(remaining)

                if not data:
                    break

                n = len(data)
                if n == size and not buf_len:
                    return data

                if n == remaining:
                    bufr.write(data)
                    del data
                    break

                bufr.write(data)
                buf_len += n
                del data

            return bufr.getvalue()

    def blocking_read(self, length=None):
        if length is None:
            if self.content_length is not None:
                length = self.content_length
            else:
                length = 1

        try:
            data = self.conn.recv(length)
        except:
            data = b('')

        return data

    def readline(self):
        data = b("")
        char = self.read(1)
        while char != b('\n') and char is not b(''):
            line = repr(char)
            data += char
            char = self.read(1)
        data += char
        return data

    def readlines(self, hint="ignored"):
        return list(self)

    def close(self):
        self.conn = None
        self.content_length = None

# Monolithic build...end of module: rocket/filelike.py
# Monolithic build...start of module: rocket/futures.py

# Import System Modules
import time
try:
    from concurrent.futures import Future, ThreadPoolExecutor
    from concurrent.futures.thread import _WorkItem
    has_futures = True
except ImportError:
    has_futures = False

    class Future:
        pass

    class ThreadPoolExecutor:
        pass

    class _WorkItem:
        pass


class WSGIFuture(Future):
    def __init__(self, f_dict, *args, **kwargs):
        Future.__init__(self, *args, **kwargs)

        self.timeout = None

        self._mem_dict = f_dict
        self._lifespan = 30
        self._name = None
        self._start_time = time.time()

    def set_running_or_notify_cancel(self):
        if time.time() - self._start_time >= self._lifespan:
            self.cancel()
        else:
            return super(WSGIFuture, self).set_running_or_notify_cancel()


    def remember(self, name, lifespan=None):
        self._lifespan = lifespan or self._lifespan

        if name in self._mem_dict:
            raise NameError('Cannot remember future by name "%s".  ' % name + \
                            'A future already exists with that name.' )
        self._name = name
        self._mem_dict[name] = self

        return self

    def forget(self):
        if self._name in self._mem_dict and self._mem_dict[self._name] is self:
            del self._mem_dict[self._name]
            self._name = None

class _WorkItem(object):
    def __init__(self, future, fn, args, kwargs):
        self.future = future
        self.fn = fn
        self.args = args
        self.kwargs = kwargs

    def run(self):
        if not self.future.set_running_or_notify_cancel():
            return

        try:
            result = self.fn(*self.args, **self.kwargs)
        except BaseException:
            e = sys.exc_info()[1]
            self.future.set_exception(e)
        else:
            self.future.set_result(result)

class WSGIExecutor(ThreadPoolExecutor):
    multithread = True
    multiprocess = False

    def __init__(self, *args, **kwargs):
        ThreadPoolExecutor.__init__(self, *args, **kwargs)

        self.futures = dict()

    def submit(self, fn, *args, **kwargs):
        if self._shutdown_lock.acquire():
            if self._shutdown:
                self._shutdown_lock.release()
                raise RuntimeError('Cannot schedule new futures after shutdown')

            f = WSGIFuture(self.futures)
            w = _WorkItem(f, fn, args, kwargs)

            self._work_queue.put(w)
            self._adjust_thread_count()
            self._shutdown_lock.release()
            return f
        else:
            return False

class FuturesMiddleware(object):
    "Futures middleware that adds a Futures Executor to the environment"
    def __init__(self, app, threads=5):
        self.app = app
        self.executor = WSGIExecutor(threads)

    def __call__(self, environ, start_response):
        environ["wsgiorg.executor"] = self.executor
        environ["wsgiorg.futures"] = self.executor.futures
        return self.app(environ, start_response)

# Monolithic build...end of module: rocket/futures.py
# Monolithic build...start of module: rocket/listener.py

# Import System Modules
import os
import socket
import logging
import traceback
from threading import Thread

try:
    import ssl
    from ssl import SSLError
    has_ssl = True
except ImportError:
    has_ssl = False
    class SSLError(socket.error):
        pass
# Import Package Modules
# package imports removed in monolithic build

class Listener(Thread):
    """The Listener class is a class responsible for accepting connections
    and queuing them to be processed by a worker thread."""

    def __init__(self, interface, queue_size, active_queue, *args, **kwargs):
        Thread.__init__(self, *args, **kwargs)

        # Instance variables
        self.active_queue = active_queue
        self.interface = interface
        self.addr = interface[0]
        self.port = interface[1]
        self.secure = len(interface) == 4 and \
                      os.path.exists(interface[2]) and \
                      os.path.exists(interface[3])
        self.thread = None
        self.ready = False

        # Error Log
        self.err_log = logging.getLogger('Rocket.Errors.Port%i' % self.port)
        self.err_log.addHandler(NullHandler())

        # Build the socket
        listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        if not listener:
            self.err_log.error("Failed to get socket.")
            return

        if self.secure:
            if not has_ssl:
                self.err_log.error("ssl module required to serve HTTPS.")
                return
            elif not os.path.exists(interface[2]):
                data = (interface[2], interface[0], interface[1])
                self.err_log.error("Cannot find key file "
                          "'%s'.  Cannot bind to %s:%s" % data)
                return
            elif not os.path.exists(interface[3]):
                data = (interface[3], interface[0], interface[1])
                self.err_log.error("Cannot find certificate file "
                          "'%s'.  Cannot bind to %s:%s" % data)
                return

        # Set socket options
        try:
            listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        except:
            msg = "Cannot share socket.  Using %s:%i exclusively."
            self.err_log.warning(msg % (self.addr, self.port))

        try:
            if not IS_JYTHON:
                listener.setsockopt(socket.IPPROTO_TCP,
                                    socket.TCP_NODELAY,
                                    1)
        except:
            msg = "Cannot set TCP_NODELAY, things might run a little slower"
            self.err_log.warning(msg)

        try:
            listener.bind((self.addr, self.port))
        except:
            msg = "Socket %s:%i in use by other process and it won't share."
            self.err_log.error(msg % (self.addr, self.port))
        else:
            # We want socket operations to timeout periodically so we can
            # check if the server is shutting down
            listener.settimeout(THREAD_STOP_CHECK_INTERVAL)
            # Listen for new connections allowing queue_size number of
            # connections to wait before rejecting a connection.
            listener.listen(queue_size)

            self.listener = listener

            self.ready = True

    def wrap_socket(self, sock):
        try:
            sock = ssl.wrap_socket(sock,
                                   keyfile = self.interface[2],
                                   certfile = self.interface[3],
                                   server_side = True,
                                   ssl_version = ssl.PROTOCOL_SSLv23)
        except SSLError:
            # Generally this happens when an HTTP request is received on a
            # secure socket. We don't do anything because it will be detected
            # by Worker and dealt with appropriately.
            pass
        
        return sock

    def start(self):
        if not self.ready:
            self.err_log.warning('Listener started when not ready.')
            return
            
        if self.thread is not None and self.thread.isAlive():
            self.err_log.warning('Listener already running.')
            return
            
        self.thread = Thread(target=self.listen, name="Port" + str(self.port))
        
        self.thread.start()
    
    def isAlive(self):
        if self.thread is None:
            return False
        
        return self.thread.isAlive()

    def join(self):
        if self.thread is None:
            return
            
        self.ready = False
        
        self.thread.join()
        
        del self.thread
        self.thread = None
        self.ready = True
    
    def listen(self):
        if __debug__:
            self.err_log.debug('Entering main loop.')
        while True:
            try:
                sock, addr = self.listener.accept()

                if self.secure:
                    sock = self.wrap_socket(sock)

                self.active_queue.put(((sock, addr),
                                       self.interface[1],
                                       self.secure))

            except socket.timeout:
                # socket.timeout will be raised every THREAD_STOP_CHECK_INTERVAL
                # seconds.  When that happens, we check if it's time to die.

                if not self.ready:
                    if __debug__:
                        self.err_log.debug('Listener exiting.')
                    self.listener.shutdown(socket.SHUT_RDWR)
                    return
                else:
                    continue
            except:
                self.err_log.error(str(traceback.format_exc()))

# Monolithic build...end of module: rocket/listener.py
# Monolithic build...start of module: rocket/main.py

# Import System Modules
import sys
import time
import socket
import logging
import traceback
from threading import Lock
try:
    from queue import Queue
except ImportError:
    from Queue import Queue

# Import Package Modules
# package imports removed in monolithic build





# Setup Logging
log = logging.getLogger('Rocket')
log.addHandler(NullHandler())

class Rocket(object):
    """The Rocket class is responsible for handling threads and accepting and
    dispatching connections."""

    def __init__(self,
                 interfaces = ('127.0.0.1', 8000),
                 method = 'wsgi',
                 app_info = None,
                 min_threads = None,
                 max_threads = None,
                 queue_size = None,
                 timeout = 600,
                 handle_signals = True):

        self.handle_signals = handle_signals
        self.startstop_lock = Lock()
        self.timeout = timeout

        if not isinstance(interfaces, list):
            self.interfaces = [interfaces]
        else:
            self.interfaces = interfaces

        if min_threads is None:
            min_threads = DEFAULTS['MIN_THREADS']

        if max_threads is None:
            max_threads = DEFAULTS['MAX_THREADS']

        if not queue_size:
            if hasattr(socket, 'SOMAXCONN'):
                queue_size = socket.SOMAXCONN
            else:
                queue_size = DEFAULTS['LISTEN_QUEUE_SIZE']

        if max_threads and queue_size > max_threads:
            queue_size = max_threads

        if isinstance(app_info, dict):
            app_info['server_software'] = SERVER_SOFTWARE

        self.monitor_queue = Queue()
        self.active_queue = Queue()

        self._threadpool = ThreadPool(get_method(method),
                                      app_info = app_info,
                                      active_queue = self.active_queue,
                                      monitor_queue = self.monitor_queue,
                                      min_threads = min_threads,
                                      max_threads = max_threads)

        # Build our socket listeners
        self.listeners = [Listener(i, queue_size, self.active_queue) for i in self.interfaces]
        for ndx in range(len(self.listeners)-1, 0, -1):
            if not self.listeners[ndx].ready:
                del self.listeners[ndx]

        if not self.listeners:
            log.critical("No interfaces to listen on...closing.")
            sys.exit(1)

    def _sigterm(self, signum, frame):
        log.info('Received SIGTERM')
        self.stop()

    def _sighup(self, signum, frame):
        log.info('Received SIGHUP')
        self.restart()

    def start(self, background=False):
        log.info('Starting %s' % SERVER_SOFTWARE)

        self.startstop_lock.acquire()

        try:
            # Set up our shutdown signals
            if self.handle_signals:
                try:
                    import signal
                    signal.signal(signal.SIGTERM, self._sigterm)
                    signal.signal(signal.SIGUSR1, self._sighup)
                except:
                    log.debug('This platform does not support signals.')

            # Start our worker threads
            self._threadpool.start()

            # Start our monitor thread
            self._monitor = Monitor(self.monitor_queue,
                                    self.active_queue,
                                    self.timeout,
                                    self._threadpool)
            self._monitor.setDaemon(True)
            self._monitor.start()

            # I know that EXPR and A or B is bad but I'm keeping it for Py2.4
            # compatibility.
            str_extract = lambda l: (l.addr, l.port, l.secure and '*' or '')

            msg = 'Listening on sockets: '
            msg += ', '.join(['%s:%i%s' % str_extract(l) for l in self.listeners])
            log.info(msg)

            for l in self.listeners:
                l.start()

        finally:
            self.startstop_lock.release()

        if background:
            return

        while self._monitor.isAlive():
            try:
                time.sleep(THREAD_STOP_CHECK_INTERVAL)
            except KeyboardInterrupt:
                # Capture a keyboard interrupt when running from a console
                break
            except:
                if self._monitor.isAlive():
                    log.error(str(traceback.format_exc()))
                    continue

        return self.stop()

    def stop(self, stoplogging = False):
        log.info('Stopping %s' % SERVER_SOFTWARE)

        self.startstop_lock.acquire()
        
        try:
            # Stop listeners
            for l in self.listeners:
                l.ready = False

            # Encourage a context switch
            time.sleep(0.01)

            for l in self.listeners:
                if l.isAlive():
                    l.join()

            # Stop Monitor
            self._monitor.stop()
            if self._monitor.isAlive():
                self._monitor.join()

            # Stop Worker threads
            self._threadpool.stop()

            if stoplogging:
                logging.shutdown()
                msg = "Calling logging.shutdown() is now the responsibility of \
                       the application developer.  Please update your \
                       applications to no longer call rocket.stop(True)"
                try:
                    import warnings
                    raise warnings.DeprecationWarning(msg)
                except ImportError:
                    raise RuntimeError(msg)

        finally:
            self.startstop_lock.release()

    def restart(self):
        self.stop()
        self.start()

def CherryPyWSGIServer(bind_addr,
                       wsgi_app,
                       numthreads = 10,
                       server_name = None,
                       max = -1,
                       request_queue_size = 5,
                       timeout = 10,
                       shutdown_timeout = 5):
    """ A Cherrypy wsgiserver-compatible wrapper. """
    max_threads = max
    if max_threads < 0:
        max_threads = 0
    return Rocket(bind_addr, 'wsgi', {'wsgi_app': wsgi_app},
                  min_threads = numthreads,
                  max_threads = max_threads,
                  queue_size = request_queue_size,
                  timeout = timeout)

# Monolithic build...end of module: rocket/main.py
# Monolithic build...start of module: rocket/monitor.py

# Import System Modules
import time
import logging
import select
from threading import Thread

# Import Package Modules
# package imports removed in monolithic build

class Monitor(Thread):
    # Monitor worker class.

    def __init__(self,
                 monitor_queue,
                 active_queue,
                 timeout,
                 threadpool,
                 *args,
                 **kwargs):

        Thread.__init__(self, *args, **kwargs)

        self._threadpool = threadpool

        # Instance Variables
        self.monitor_queue = monitor_queue
        self.active_queue = active_queue
        self.timeout = timeout

        self.log = logging.getLogger('Rocket.Monitor')
        self.log.addHandler(NullHandler())

        self.connections = set()
        self.active = False

    def run(self):
        self.active = True
        conn_list = list()
        list_changed = False

        # We need to make sure the queue is empty before we start
        while not self.monitor_queue.empty():
            self.monitor_queue.get()

        if __debug__:
            self.log.debug('Entering monitor loop.')

        # Enter thread main loop
        while self.active:

            # Move the queued connections to the selection pool
            while not self.monitor_queue.empty():
                if __debug__:
                    self.log.debug('In "receive timed-out connections" loop.')

                c = self.monitor_queue.get()

                if c is None:
                    # A non-client is a signal to die
                    if __debug__:
                        self.log.debug('Received a death threat.')
                    self.stop()
                    break

                self.log.debug('Received a timed out connection.')

                if __debug__:
                    assert(c not in self.connections)

                if IS_JYTHON:
                    # Jython requires a socket to be in Non-blocking mode in
                    # order to select on it.
                    c.setblocking(False)

                if __debug__:
                    self.log.debug('Adding connection to monitor list.')

                self.connections.add(c)
                list_changed = True

            # Wait on those connections
            if list_changed:
                conn_list = list(self.connections)
                list_changed = False

            try:
                if len(conn_list):
                    readable = select.select(conn_list,
                                             [],
                                             [],
                                             THREAD_STOP_CHECK_INTERVAL)[0]
                else:
                    time.sleep(THREAD_STOP_CHECK_INTERVAL)
                    readable = []

                if not self.active:
                    break

                # If we have any readable connections, put them back
                for r in readable:
                    if __debug__:
                        self.log.debug('Restoring readable connection')

                    if IS_JYTHON:
                        # Jython requires a socket to be in Non-blocking mode in
                        # order to select on it, but the rest of the code requires
                        # that it be in blocking mode.
                        r.setblocking(True)

                    r.start_time = time.time()
                    self.active_queue.put(r)

                    self.connections.remove(r)
                    list_changed = True

            except:
                if self.active:
                    raise
                else:
                    break

            # If we have any stale connections, kill them off.
            if self.timeout:
                now = time.time()
                stale = set()
                for c in self.connections:
                    if (now - c.start_time) >= self.timeout:
                        stale.add(c)

                for c in stale:
                    if __debug__:
                        # "EXPR and A or B" kept for Py2.4 compatibility
                        data = (c.client_addr, c.server_port, c.ssl and '*' or '')
                        self.log.debug('Flushing stale connection: %s:%i%s' % data)

                    self.connections.remove(c)
                    list_changed = True

                    try:
                        c.close()
                    finally:
                        del c

            # Dynamically resize the threadpool to adapt to our changing needs.
            self._threadpool.dynamic_resize()


    def stop(self):
        self.active = False

        if __debug__:
            self.log.debug('Flushing waiting connections')

        while self.connections:
            c = self.connections.pop()
            try:
                c.close()
            finally:
                del c

        if __debug__:
            self.log.debug('Flushing queued connections')

        while not self.monitor_queue.empty():
            c = self.monitor_queue.get()

            if c is None:
                continue

            try:
                c.close()
            finally:
                del c

        # Place a None sentry value to cause the monitor to die.
        self.monitor_queue.put(None)

# Monolithic build...end of module: rocket/monitor.py
# Monolithic build...start of module: rocket/threadpool.py

# Import System Modules
import logging
# Import Package Modules
# package imports removed in monolithic build


# Setup Logging
log = logging.getLogger('Rocket.Errors.ThreadPool')
log.addHandler(NullHandler())

class ThreadPool:
    """The ThreadPool class is a container class for all the worker threads. It
    manages the number of actively running threads."""

    def __init__(self,
                 method,
                 app_info,
                 active_queue,
                 monitor_queue,
                 min_threads=DEFAULTS['MIN_THREADS'],
                 max_threads=DEFAULTS['MAX_THREADS'],
                 ):

        if __debug__:
            log.debug("Initializing ThreadPool.")

        self.check_for_dead_threads = 0
        self.active_queue = active_queue

        self.worker_class = method
        self.min_threads = min_threads
        self.max_threads = max_threads
        self.monitor_queue = monitor_queue
        self.stop_server = False
        self.alive = False

        # TODO - Optimize this based on some real-world usage data
        self.grow_threshold = int(max_threads/10) + 2

        if not isinstance(app_info, dict):
            app_info = dict()

        if has_futures and app_info.get('futures'):
            app_info['executor'] = WSGIExecutor(max([DEFAULTS['MIN_THREADS'],
                                                     2]))

        app_info.update(max_threads=max_threads,
                        min_threads=min_threads)

        self.min_threads = min_threads
        self.app_info = app_info

        self.threads = set()

    def start(self):
        self.stop_server = False
        if __debug__:
            log.debug("Starting threads.")

        self.grow(self.min_threads)

        self.alive = True

    def stop(self):
        self.alive = False

        if __debug__:
            log.debug("Stopping threads.")

        self.stop_server = True

        # Prompt the threads to die
        self.shrink(len(self.threads))

        # Stop futures initially
        if has_futures and self.app_info.get('futures'):
            if __debug__:
                log.debug("Future executor is present.  Python will not "
                          "exit until all jobs have finished.")
            self.app_info['executor'].shutdown(wait=False)

        # Give them the gun
        #active_threads = [t for t in self.threads if t.isAlive()]
        #while active_threads:
        #    t = active_threads.pop()
        #    t.kill()

        # Wait until they pull the trigger
        for t in self.threads:
            if t.isAlive():
                t.join()

        # Clean up the mess
        self.bring_out_your_dead()

    def bring_out_your_dead(self):
        # Remove dead threads from the pool

        dead_threads = [t for t in self.threads if not t.isAlive()]
        for t in dead_threads:
            if __debug__:
                log.debug("Removing dead thread: %s." % t.getName())
            try:
                # Py2.4 complains here so we put it in a try block
                self.threads.remove(t)
            except:
                pass
        self.check_for_dead_threads -= len(dead_threads)

    def grow(self, amount=None):
        if self.stop_server:
            return

        if not amount:
            amount = self.max_threads

        if self.alive and self.max_threads > 0:
            # Don't grow any further if we've reached max_threads
            amount = min([amount, self.max_threads - len(self.threads)])

        if __debug__:
            log.debug("Growing by %i." % amount)

        for x in range(amount):
            worker = self.worker_class(self.app_info,
                                       self.active_queue,
                                       self.monitor_queue)

            worker.setDaemon(True)
            self.threads.add(worker)
            worker.start()

    def shrink(self, amount=1):
        if __debug__:
            log.debug("Shrinking by %i." % amount)

        self.check_for_dead_threads += amount

        for x in range(amount):
            self.active_queue.put(None)

    def dynamic_resize(self):
        if (self.max_threads > self.min_threads or self.max_threads == 0):
            if self.check_for_dead_threads > 0:
                self.bring_out_your_dead()

            queueSize = self.active_queue.qsize()
            threadCount = len(self.threads)

            if __debug__:
                log.debug("Examining ThreadPool. %i threads and %i Q'd conxions"
                          % (threadCount, queueSize))

            if queueSize == 0 and threadCount > self.min_threads:
                self.shrink()

            elif queueSize > self.grow_threshold:

                self.grow(queueSize)

# Monolithic build...end of module: rocket/threadpool.py
# Monolithic build...start of module: rocket/worker.py

# Import System Modules
import re
import sys
import socket
import logging
import traceback
from wsgiref.headers import Headers
from threading import Thread
from datetime import datetime

try:
    from urllib import unquote
except ImportError:
    from urllib.parse import unquote

try:
    from io import StringIO
except ImportError:
    try:
        from cStringIO import StringIO
    except ImportError:
        from StringIO import StringIO

try:
    from ssl import SSLError
except ImportError:
    class SSLError(socket.error):
        pass
# Import Package Modules
# package imports removed in monolithic build


# Define Constants
re_SLASH = re.compile('%2F', re.IGNORECASE)
re_REQUEST_LINE = re.compile(r"""^
(?P<method>OPTIONS|GET|HEAD|POST|PUT|DELETE|TRACE|CONNECT)   # Request Method
\                                                            # (single space)
(
    (?P<scheme>[^:/]+)                                       # Scheme
    (://)  #
    (?P<host>[^/]+)                                          # Host
)? #
(?P<path>(\*|/[^ \?]*))                                      # Path
(\? (?P<query_string>[^ ]+))?                                # Query String
\                                                            # (single space)
(?P<protocol>HTTPS?/1\.[01])                                 # Protocol
$
""", re.X)
LOG_LINE = '%(client_ip)s - "%(request_line)s" - %(status)s %(size)s'
RESPONSE = '''\
HTTP/1.1 %s
Content-Length: %i
Content-Type: %s

%s
'''
if IS_JYTHON:
    HTTP_METHODS = set(['OPTIONS', 'GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'TRACE', 'CONNECT'])

class Worker(Thread):
    """The Worker class is a base class responsible for receiving connections
    and (a subclass) will run an application to process the the connection """

    def __init__(self,
                 app_info,
                 active_queue,
                 monitor_queue,
                 *args,
                 **kwargs):

        Thread.__init__(self, *args, **kwargs)

        # Instance Variables
        self.app_info = app_info
        self.active_queue = active_queue
        self.monitor_queue = monitor_queue

        self.size = 0
        self.status = "200 OK"
        self.closeConnection = True
        self.request_line = ""

        # Request Log
        self.req_log = logging.getLogger('Rocket.Requests')
        self.req_log.addHandler(NullHandler())

        # Error Log
        self.err_log = logging.getLogger('Rocket.Errors.'+self.getName())
        self.err_log.addHandler(NullHandler())

    def _handleError(self, typ, val, tb):
        if typ == SSLError:
            if 'timed out' in val.args[0]:
                typ = SocketTimeout
        if typ == SocketTimeout:
            if __debug__:
                self.err_log.debug('Socket timed out')
            self.monitor_queue.put(self.conn)
            return True
        if typ == SocketClosed:
            self.closeConnection = True
            if __debug__:
                self.err_log.debug('Client closed socket')
            return False
        if typ == BadRequest:
            self.closeConnection = True
            if __debug__:
                self.err_log.debug('Client sent a bad request')
            return True
        if typ == socket.error:
            self.closeConnection = True
            if val.args[0] in IGNORE_ERRORS_ON_CLOSE:
                if __debug__:
                    self.err_log.debug('Ignorable socket Error received...'
                                       'closing connection.')
                return False
            else:
                self.status = "999 Utter Server Failure"
                tb_fmt = traceback.format_exception(typ, val, tb)
                self.err_log.error('Unhandled Error when serving '
                                   'connection:\n' + '\n'.join(tb_fmt))
                return False

        self.closeConnection = True
        tb_fmt = traceback.format_exception(typ, val, tb)
        self.err_log.error('\n'.join(tb_fmt))
        self.send_response('500 Server Error')
        return False

    def run(self):
        if __debug__:
            self.err_log.debug('Entering main loop.')

        # Enter thread main loop
        while True:
            conn = self.active_queue.get()

            if not conn:
                # A non-client is a signal to die
                if __debug__:
                    self.err_log.debug('Received a death threat.')
                return conn

            if isinstance(conn, tuple):
                conn = Connection(*conn)

            self.conn = conn

            if conn.ssl != conn.secure:
                self.err_log.info('Received HTTP connection on HTTPS port.')
                self.send_response('400 Bad Request')
                self.closeConnection = True
                conn.close()
                continue
            else:
                if __debug__:
                    self.err_log.debug('Received a connection.')
                self.closeConnection = False

            # Enter connection serve loop
            while True:
                if __debug__:
                    self.err_log.debug('Serving a request')
                try:
                    self.run_app(conn)
                    log_info = dict(client_ip = conn.client_addr,
                                    time = datetime.now().strftime('%c'),
                                    status = self.status.split(' ')[0],
                                    size = self.size,
                                    request_line = self.request_line)
                    self.req_log.info(LOG_LINE % log_info)
                except:
                    exc = sys.exc_info()
                    handled = self._handleError(*exc)
                    if handled:
                        break
                    else:
                        if self.request_line:
                            log_info = dict(client_ip = conn.client_addr,
                                            time = datetime.now().strftime('%c'),
                                            status = self.status.split(' ')[0],
                                            size = self.size,
                                            request_line = self.request_line + ' - not stopping')
                            self.req_log.info(LOG_LINE % log_info)

                if self.closeConnection:
                    try:
                        conn.close()
                    except:
                        self.err_log.error(str(traceback.format_exc()))

                    break

    def run_app(self, conn):
        # Must be overridden with a method reads the request from the socket
        # and sends a response.
        self.closeConnection = True
        raise NotImplementedError('Overload this method!')

    def send_response(self, status):
        stat_msg = status.split(' ', 1)[1]
        msg = RESPONSE % (status,
                          len(stat_msg),
                          'text/plain',
                          stat_msg)
        try:
            self.conn.sendall(b(msg))
        except socket.error:
            self.closeConnection = True
            self.err_log.error('Tried to send "%s" to client but received socket'
                           ' error' % status)

    #def kill(self):
    #    if self.isAlive() and hasattr(self, 'conn'):
    #        try:
    #            self.conn.shutdown(socket.SHUT_RDWR)
    #        except socket.error:
    #            info = sys.exc_info()
    #            if info[1].args[0] != socket.EBADF:
    #                self.err_log.debug('Error on shutdown: '+str(info))

    def read_request_line(self, sock_file):
        self.request_line = ''
        try:
            # Grab the request line
            d = sock_file.readline()
            if PY3K:
                d = d.decode('ISO-8859-1')

            if d == '\r\n':
                # Allow an extra NEWLINE at the beginning per HTTP 1.1 spec
                if __debug__:
                    self.err_log.debug('Client sent newline')

                d = sock_file.readline()
                if PY3K:
                    d = d.decode('ISO-8859-1')
        except socket.timeout:
            raise SocketTimeout("Socket timed out before request.")

        d = d.strip()

        if not d:
            if __debug__:
                self.err_log.debug('Client did not send a recognizable request.')
            raise SocketClosed('Client closed socket.')

        self.request_line = d

        # NOTE: I've replaced the traditional method of procedurally breaking
        # apart the request line with a (rather unsightly) regular expression.
        # However, Java's regexp support sucks so bad that it actually takes
        # longer in Jython to process the regexp than procedurally. So I've
        # left the old code here for Jython's sake...for now.
        if IS_JYTHON:
            return self._read_request_line_jython(d)

        match = re_REQUEST_LINE.match(d)

        if not match:
            self.send_response('400 Bad Request')
            raise BadRequest

        req = match.groupdict()
        for k,v in req.items():
            if not v:
                req[k] = ""
            if k == 'path':
                req['path'] = r'%2F'.join([unquote(x) for x in re_SLASH.split(v)])

        return req

    def _read_request_line_jython(self, d):
        d = d.strip()
        try:
            method, uri, proto = d.split(' ')
            if not proto.startswith('HTTP') or \
               proto[-3:] not in ('1.0', '1.1') or \
               method not in HTTP_METHODS:
                self.send_response('400 Bad Request')
                raise BadRequest
        except ValueError:
            self.send_response('400 Bad Request')
            raise BadRequest

        req = dict(method=method, protocol = proto)
        scheme = ''
        host = ''
        if uri == '*' or uri.startswith('/'):
            path = uri
        elif '://' in uri:
            scheme, rest = uri.split('://')
            host, path = rest.split('/', 1)
            path = '/' + path
        else:
            self.send_response('400 Bad Request')
            raise BadRequest

        query_string = ''
        if '?' in path:
            path, query_string = path.split('?', 1)

        path = r'%2F'.join([unquote(x) for x in re_SLASH.split(path)])

        req.update(path=path,
                   query_string=query_string,
                   scheme=scheme.lower(),
                   host=host)
        return req


    def read_headers(self, sock_file):
        try:
            headers = dict()
            l = sock_file.readline()
    
            lname = None
            lval = None
            while True:
                if PY3K:
                    try:
                        l = str(l, 'ISO-8859-1')
                    except UnicodeDecodeError:
                        self.err_log.warning('Client sent invalid header: ' + repr(l))
    
                if l == '\r\n':
                    break
    
                if l[0] in ' \t' and lname:
                    # Some headers take more than one line
                    lval += ',' + l.strip()
                else:
                    # HTTP header values are latin-1 encoded
                    l = l.split(':', 1)
                    # HTTP header names are us-ascii encoded
    
                    lname = l[0].strip().upper().replace('-', '_')
                    lval = l[-1].strip()
                headers[str(lname)] = str(lval)
    
                l = sock_file.readline()
        except socket.timeout:
            raise SocketTimeout("Socket timed out before request.")

        return headers

class SocketTimeout(Exception):
    "Exception for when a socket times out between requests."
    pass

class BadRequest(Exception):
    "Exception for when a client sends an incomprehensible request."
    pass

class SocketClosed(Exception):
    "Exception for when a socket is closed by the client."
    pass

class ChunkedReader(object):
    def __init__(self, sock_file):
        self.stream = sock_file
        self.chunk_size = 0

    def _read_header(self):
        chunk_len = ""
        try:
            while "" == chunk_len:
                chunk_len = self.stream.readline().strip()
            return int(chunk_len, 16)
        except ValueError:
            return 0

    def read(self, size):
        data = b('')
        chunk_size = self.chunk_size
        while size:
            if not chunk_size:
                chunk_size = self._read_header()

            if size < chunk_size:
                data += self.stream.read(size)
                chunk_size -= size
                break
            else:
                if not chunk_size:
                    break
                data += self.stream.read(chunk_size)
                size -= chunk_size
                chunk_size = 0

        self.chunk_size = chunk_size
        return data

    def readline(self):
        data = b('')
        c = self.read(1)
        while c and c != b('\n'):
            data += c
            c = self.read(1)
        data += c
        return data

    def readlines(self):
        yield self.readline()

def get_method(method):


    methods = dict(wsgi=WSGIWorker,
                   fs=FileSystemWorker)
    return methods[method.lower()]

# Monolithic build...end of module: rocket/worker.py
# Monolithic build...start of module: rocket/methods/__init__.py

# Monolithic build...end of module: rocket/methods/__init__.py
# Monolithic build...start of module: rocket/methods/fs.py

# Import System Modules
import os
import time
import mimetypes
from email.utils import formatdate
from wsgiref.headers import Headers
from wsgiref.util import FileWrapper
# Import Package Modules
# package imports removed in monolithic build


# Define Constants
CHUNK_SIZE = 2**16 # 64 Kilobyte chunks
HEADER_RESPONSE = '''HTTP/1.1 %s\r\n%s'''
INDEX_HEADER = '''\
<html>
<head><title>Directory Index: %(path)s</title>
<style> .parent { margin-bottom: 1em; }</style>
</head>
<body><h1>Directory Index: %(path)s</h1>
<table>
<tr><th>Directories</th></tr>
'''
INDEX_ROW = '''<tr><td><div class="%(cls)s"><a href="/%(link)s">%(name)s</a></div></td></tr>'''
INDEX_FOOTER = '''</table></body></html>\r\n'''

class LimitingFileWrapper(FileWrapper):
    def __init__(self, limit=None, *args, **kwargs):
        self.limit = limit
        FileWrapper.__init__(self, *args, **kwargs)

    def read(self, amt):
        if amt > self.limit:
            amt = self.limit
        self.limit -= amt
        return FileWrapper.read(self, amt)

class FileSystemWorker(Worker):
    def __init__(self, *args, **kwargs):
        """Builds some instance variables that will last the life of the
        thread."""

        Worker.__init__(self, *args, **kwargs)

        self.root = os.path.abspath(self.app_info['document_root'])
        self.display_index = self.app_info['display_index']

    def serve_file(self, filepath, headers):
        filestat = os.stat(filepath)
        self.size = filestat.st_size
        modtime = time.strftime("%a, %d %b %Y %H:%M:%S GMT",
                                time.gmtime(filestat.st_mtime))
        self.headers.add_header('Last-Modified', modtime)
        if headers.get('if_modified_since') == modtime:
            # The browser cache is up-to-date, send a 304.
            self.status = "304 Not Modified"
            self.data = []
            return

        ct = mimetypes.guess_type(filepath)[0]
        self.content_type = ct if ct else 'text/plain'
        try:
            f = open(filepath, 'rb')
            self.headers['Pragma'] = 'cache'
            self.headers['Cache-Control'] = 'private'
            self.headers['Content-Length'] = str(self.size)
            if self.etag:
                self.headers.add_header('Etag', self.etag)
            if self.expires:
                self.headers.add_header('Expires', self.expires)

            try:
                # Implement 206 partial file support.
                start, end = headers['range'].split('-')
                start = 0 if not start.isdigit() else int(start)
                end = self.size if not end.isdigit() else int(end)
                if self.size < end or start < 0:
                    self.status = "214 Unsatisfiable Range Requested"
                    self.data = FileWrapper(f, CHUNK_SIZE)
                else:
                    f.seek(start)
                    self.data = LimitingFileWrapper(f, CHUNK_SIZE, limit=end)
                    self.status = "206 Partial Content"
            except:
                self.data = FileWrapper(f, CHUNK_SIZE)
        except IOError:
            self.status = "403 Forbidden"

    def serve_dir(self, pth, rpth):
        def rel_path(path):
            return os.path.normpath(path[len(self.root):] if path.startswith(self.root) else path)

        if not self.display_index:
            self.status = '404 File Not Found'
            return b('')
        else:
            self.content_type = 'text/html'

            dir_contents = [os.path.join(pth, x) for x in os.listdir(os.path.normpath(pth))]
            dir_contents.sort()

            dirs = [rel_path(x)+'/' for x in dir_contents if os.path.isdir(x)]
            files = [rel_path(x) for x in dir_contents if os.path.isfile(x)]

            self.data = [INDEX_HEADER % dict(path='/'+rpth)]
            if rpth:
                self.data += [INDEX_ROW % dict(name='(parent directory)', cls='dir parent', link='/'.join(rpth[:-1].split('/')[:-1]))]
            self.data += [INDEX_ROW % dict(name=os.path.basename(x[:-1]), link=os.path.join(rpth, os.path.basename(x[:-1])).replace('\\', '/'), cls='dir') for x in dirs]
            self.data += ['<tr><th>Files</th></tr>']
            self.data += [INDEX_ROW % dict(name=os.path.basename(x), link=os.path.join(rpth, os.path.basename(x)).replace('\\', '/'), cls='file') for x in files]
            self.data += [INDEX_FOOTER]
            self.headers['Content-Length'] = self.size = str(sum([len(x) for x in self.data]))
            self.status = '200 OK'

    def run_app(self, conn):
        self.status = "200 OK"
        self.size = 0
        self.expires = None
        self.etag = None
        self.content_type = 'text/plain'
        self.content_length = None

        if __debug__:
            self.err_log.debug('Getting sock_file')
            
        # Build our file-like object
        sock_file = conn.makefile('rb',BUF_SIZE)
        request = self.read_request_line(sock_file)
        if request['method'].upper() not in ('GET', ):
            self.status = "501 Not Implemented"

        try:
            # Get our file path
            headers = dict([(str(k.lower()), v) for k, v in self.read_headers(sock_file).items()])
            rpath = request.get('path', '').lstrip('/')
            filepath = os.path.join(self.root, rpath)
            filepath = os.path.abspath(filepath)
            if __debug__:
                self.err_log.debug('Request for path: %s' % filepath)
                
            self.closeConnection = headers.get('connection', 'close').lower() == 'close'
            self.headers = Headers([('Date', formatdate(usegmt=True)),
                                    ('Server', HTTP_SERVER_SOFTWARE),
                                    ('Connection', headers.get('connection', 'close')),
                                   ])

            if not filepath.lower().startswith(self.root.lower()):
                # File must be within our root directory
                self.status = "400 Bad Request"
                self.closeConnection = True
            elif not os.path.exists(filepath):
                self.status = "404 File Not Found"
                self.closeConnection = True
            elif os.path.isdir(filepath):
                self.serve_dir(filepath, rpath)
            elif os.path.isfile(filepath):
                self.serve_file(filepath, headers)
            else:
                # It exists but it's not a file or a directory????
                # What is it then?
                self.status = "501 Not Implemented"
                self.closeConnection = True

            h = self.headers
            statcode, statstr = self.status.split(' ', 1)
            statcode = int(statcode)
            if statcode >= 400:
                h.add_header('Content-Type', self.content_type)
                self.data = [statstr]

            # Build our output headers
            header_data = HEADER_RESPONSE % (self.status, str(h))

            # Send the headers
            if __debug__:
                self.err_log.debug('Sending Headers: %s' % repr(header_data))
            self.conn.sendall(b(header_data))

            for data in self.data:
                self.conn.sendall(b(data))

            if hasattr(self.data, 'close'):
                self.data.close()

        finally:
            if __debug__:
                self.err_log.debug('Finally closing sock_file')
            sock_file.close()

# Monolithic build...end of module: rocket/methods/fs.py
# Monolithic build...start of module: rocket/methods/wsgi.py

# Import System Modules
import sys
import socket
from wsgiref.headers import Headers
from wsgiref.util import FileWrapper

# Import Package Modules
# package imports removed in monolithic build



if PY3K:
    from email.utils import formatdate
else:
    # Caps Utils for Py2.4 compatibility
    from email.Utils import formatdate

# Define Constants
NEWLINE = b('\r\n')
HEADER_RESPONSE = '''HTTP/1.1 %s\r\n%s'''
BASE_ENV = {'SERVER_NAME': SERVER_NAME,
            'SCRIPT_NAME': '',  # Direct call WSGI does not need a name
            'wsgi.errors': sys.stderr,
            'wsgi.version': (1, 0),
            'wsgi.multiprocess': False,
            'wsgi.run_once': False,
            'wsgi.file_wrapper': FileWrapper
            }

class WSGIWorker(Worker):
    def __init__(self, *args, **kwargs):
        """Builds some instance variables that will last the life of the
        thread."""
        Worker.__init__(self, *args, **kwargs)

        if isinstance(self.app_info, dict):
            multithreaded = self.app_info.get('max_threads') != 1
        else:
            multithreaded = False
        self.base_environ = dict({'SERVER_SOFTWARE': self.app_info['server_software'],
                                  'wsgi.multithread': multithreaded,
                                  })
        self.base_environ.update(BASE_ENV)

        # Grab our application
        self.app = self.app_info.get('wsgi_app')

        if not hasattr(self.app, "__call__"):
            raise TypeError("The wsgi_app specified (%s) is not a valid WSGI application." % repr(self.app))

        # Enable futures
        if has_futures and self.app_info.get('futures'):
            executor = self.app_info['executor']
            self.base_environ.update({"wsgiorg.executor": executor,
                                      "wsgiorg.futures": executor.futures})

    def build_environ(self, sock_file, conn):
        """ Build the execution environment. """
        # Grab the request line
        request = self.read_request_line(sock_file)

        # Copy the Base Environment
        environ = self.base_environ.copy()

        # Grab the headers
        for k, v in self.read_headers(sock_file).items():
            environ[str('HTTP_'+k)] = v

        # Add CGI Variables
        environ['REQUEST_METHOD'] = request['method']
        environ['PATH_INFO'] = request['path']
        environ['SERVER_PROTOCOL'] = request['protocol']
        environ['SERVER_PORT'] = str(conn.server_port)
        environ['REMOTE_PORT'] = str(conn.client_port)
        environ['REMOTE_ADDR'] = str(conn.client_addr)
        environ['QUERY_STRING'] = request['query_string']
        if 'HTTP_CONTENT_LENGTH' in environ:
            environ['CONTENT_LENGTH'] = environ['HTTP_CONTENT_LENGTH']
        if 'HTTP_CONTENT_TYPE' in environ:
            environ['CONTENT_TYPE'] = environ['HTTP_CONTENT_TYPE']

        # Save the request method for later
        self.request_method = environ['REQUEST_METHOD']

        # Add Dynamic WSGI Variables
        if conn.ssl:
            environ['wsgi.url_scheme'] = 'https'
            environ['HTTPS'] = 'on'
        else:
            environ['wsgi.url_scheme'] = 'http'

        if environ.get('HTTP_TRANSFER_ENCODING', '') == 'chunked':
            environ['wsgi.input'] = ChunkedReader(sock_file)
        else:
            environ['wsgi.input'] = sock_file

        return environ

    def send_headers(self, data, sections):
        h_set = self.header_set

        # Does the app want us to send output chunked?
        self.chunked = h_set.get('transfer-encoding', '').lower() == 'chunked'

        # Add a Date header if it's not there already
        if not 'date' in h_set:
            h_set['Date'] = formatdate(usegmt=True)

        # Add a Server header if it's not there already
        if not 'server' in h_set:
            h_set['Server'] = HTTP_SERVER_SOFTWARE

        if 'content-length' in h_set:
            self.size = int(h_set['content-length'])
        else:
            s = int(self.status.split(' ')[0])
            if s < 200 or s not in (204, 205, 304):
                if not self.chunked:
                    if sections == 1:
                        # Add a Content-Length header if it's not there already
                        h_set['Content-Length'] = str(len(data))
                        self.size = len(data)
                    else:
                        # If they sent us more than one section, we blow chunks
                        h_set['Transfer-Encoding'] = 'Chunked'
                        self.chunked = True
                        if __debug__:
                            self.err_log.debug('Adding header...'
                                               'Transfer-Encoding: Chunked')

        if 'connection' not in h_set:
            # If the application did not provide a connection header, fill it in
            client_conn = self.environ.get('HTTP_CONNECTION', '').lower()
            if self.environ['SERVER_PROTOCOL'] == 'HTTP/1.1':
                # HTTP = 1.1 defaults to keep-alive connections
                if client_conn:
                    h_set['Connection'] = client_conn
                else:
                    h_set['Connection'] = 'keep-alive'
            else:
                # HTTP < 1.1 supports keep-alive but it's quirky so we don't support it
                h_set['Connection'] = 'close'

        # Close our connection if we need to.
        self.closeConnection = h_set.get('connection', '').lower() == 'close'

        # Build our output headers
        header_data = HEADER_RESPONSE % (self.status, str(h_set))

        # Send the headers
        if __debug__:
            self.err_log.debug('Sending Headers: %s' % repr(header_data))
        self.conn.sendall(b(header_data))
        self.headers_sent = True

    def write_warning(self, data, sections=None):
        self.err_log.warning('WSGI app called write method directly.  This is '
                             'deprecated behavior.  Please update your app.')
        return self.write(data, sections)

    def write(self, data, sections=None):
        """ Write the data to the output socket. """

        if self.error[0]:
            self.status = self.error[0]
            data = b(self.error[1])

        if not self.headers_sent:
            self.send_headers(data, sections)

        if self.request_method != 'HEAD':
            try:
                if self.chunked:
                    self.conn.sendall(b('%x\r\n%s\r\n' % (len(data), data)))
                else:
                    self.conn.sendall(data)
            except socket.error:
                # But some clients will close the connection before that
                # resulting in a socket error.
                self.closeConnection = True

    def start_response(self, status, response_headers, exc_info=None):
        """ Store the HTTP status and headers to be sent when self.write is
        called. """
        if exc_info:
            try:
                if self.headers_sent:
                    # Re-raise original exception if headers sent
                    # because this violates WSGI specification.
                    raise
            finally:
                exc_info = None
        elif self.header_set:
            raise AssertionError("Headers already set!")

        if PY3K and not isinstance(status, str):
            self.status = str(status, 'ISO-8859-1')
        else:
            self.status = status
        # Make sure headers are bytes objects
        try:
            self.header_set = Headers(response_headers)
        except UnicodeDecodeError:
            self.error = ('500 Internal Server Error',
                          'HTTP Headers should be bytes')
            self.err_log.error('Received HTTP Headers from client that contain'
                               ' invalid characters for Latin-1 encoding.')

        return self.write_warning

    def run_app(self, conn):
        self.size = 0
        self.header_set = Headers([])
        self.headers_sent = False
        self.error = (None, None)
        self.chunked = False
        sections = None
        output = None

        if __debug__:
            self.err_log.debug('Getting sock_file')

        # Build our file-like object
        if PY3K:
            sock_file = conn.makefile(mode='rb', buffering=BUF_SIZE)
        else:
            sock_file = conn.makefile(BUF_SIZE)

        try:
            # Read the headers and build our WSGI environment
            self.environ = environ = self.build_environ(sock_file, conn)

            # Handle 100 Continue
            if environ.get('HTTP_EXPECT', '') == '100-continue':
                res = environ['SERVER_PROTOCOL'] + ' 100 Continue\r\n\r\n'
                conn.sendall(b(res))

            # Send it to our WSGI application
            output = self.app(environ, self.start_response)

            if not hasattr(output, '__len__') and not hasattr(output, '__iter__'):
                self.error = ('500 Internal Server Error',
                              'WSGI applications must return a list or '
                              'generator type.')

            if hasattr(output, '__len__'):
                sections = len(output)

            for data in output:
                # Don't send headers until body appears
                if data:
                    self.write(data, sections)

            if self.chunked:
                # If chunked, send our final chunk length
                self.conn.sendall(b('0\r\n\r\n'))
            elif not self.headers_sent:
                # Send headers if the body was empty
                self.send_headers('', sections)

        # Don't capture exceptions here.  The Worker class handles
        # them appropriately.
        finally:
            if __debug__:
                self.err_log.debug('Finally closing output and sock_file')

            if hasattr(output,'close'):
                output.close()

            sock_file.close()

# Monolithic build...end of module: rocket/methods/wsgi.py

########NEW FILE########
__FILENAME__ = threadpool
# -*- coding: UTF-8 -*-
"""Easy to use object-oriented thread pool framework.

A thread pool is an object that maintains a pool of worker threads to perform
time consuming operations in parallel. It assigns jobs to the threads
by putting them in a work request queue, where they are picked up by the
next available thread. This then performs the requested operation in the
background and puts the results in another queue.

The thread pool object can then collect the results from all threads from
this queue as soon as they become available or after all threads have
finished their work. It's also possible, to define callbacks to handle
each result as it comes in.

The basic concept and some code was taken from the book "Python in a Nutshell,
2nd edition" by Alex Martelli, O'Reilly 2006, ISBN 0-596-10046-9, from section
14.5 "Threaded Program Architecture". I wrapped the main program logic in the
ThreadPool class, added the WorkRequest class and the callback system and
tweaked the code here and there. Kudos also to Florent Aide for the exception
handling mechanism.

Basic usage::

    >> pool = ThreadPool(poolsize)
    >> requests = makeRequests(some_callable, list_of_args, callback)
    >> [pool.putRequest(req) for req in requests]
    >> pool.wait()

See the end of the module code for a brief, annotated usage example.

Website : http://chrisarndt.de/projects/threadpool/

"""
import logging

__docformat__ = "restructuredtext en"

__all__ = [
    'makeRequests',
    'NoResultsPending',
    'NoWorkersAvailable',
    'ThreadPool',
    'WorkRequest',
    'WorkerThread'
]

__author__ = "Christopher Arndt"
__version__ = '1.2.7'
__revision__ = "$Revision: 416 $"
__date__ = "$Date: 2009-10-07 05:41:27 +0200 (Wed, 07 Oct 2009) $"
__license__ = "MIT license"


# standard library modules
import sys
import threading
from queue import Queue, Empty
import traceback


# exceptions
class NoResultsPending(Exception):
    """All work requests have been processed."""
    pass


class NoWorkersAvailable(Exception):
    """No worker threads available to process remaining requests."""
    pass


# internal module helper functions
#noinspection PyUnusedLocal
def _handle_thread_exception(request, exc_info):
    """Default exception handler callback function.

    This just prints the exception info via ``traceback.print_exception``.

    """
    traceback.print_exception(*exc_info)


# utility functions
def makeRequests(callable_, args_list, callback=None,
                 exc_callback=_handle_thread_exception):
    """Create several work requests for same callable with different arguments.

    Convenience function for creating several work requests for the same
    callable where each invocation of the callable receives different values
    for its arguments.

    ``args_list`` contains the parameters for each invocation of callable.
    Each item in ``args_list`` should be either a 2-item tuple of the list of
    positional arguments and a dictionary of keyword arguments or a single,
    non-tuple argument.

    See docstring for ``WorkRequest`` for info on ``callback`` and
    ``exc_callback``.

    """
    requests = []
    for item in args_list:
        if isinstance(item, tuple):
            requests.append(
                WorkRequest(callable_, item[0], item[1], callback=callback,
                            exc_callback=exc_callback)
            )
        else:
            requests.append(
                WorkRequest(callable_, [item], None, callback=callback,
                            exc_callback=exc_callback)
            )
    return requests


# classes
class WorkerThread(threading.Thread):
    """Background thread connected to the requests/results queues.

    A worker thread sits in the background and picks up work requests from
    one queue and puts the results in another until it is dismissed.

    """

    def __init__(self, requests_queue, results_queue, poll_timeout=5, **kwds):
        """Set up thread in daemonic mode and start it immediatedly.

        ``requests_queue`` and ``results_queue`` are instances of
        ``Queue.Queue`` passed by the ``ThreadPool`` class when it creates a new
        worker thread.

        """
        threading.Thread.__init__(self, **kwds)
        self.setDaemon(1)
        self._requests_queue = requests_queue
        self._results_queue = results_queue
        self._poll_timeout = poll_timeout
        self._dismissed = threading.Event()
        self.start()

    def run(self):
        """Repeatedly process the job queue until told to exit."""
        while True:
            if self._dismissed.isSet():
                # we are dismissed, break out of loop
                break
                # get next work request. If we don't get a new request from the
            # queue after self._poll_timout seconds, we jump to the start of
            # the while loop again, to give the thread a chance to exit.
            try:
                request = self._requests_queue.get(True, self._poll_timeout)
            except Empty:
                continue
            else:
                if self._dismissed.isSet():
                    # we are dismissed, put back request in queue and exit loop
                    self._requests_queue.put(request)
                    break
                #noinspection PyBroadException
                try:
                    result = request.callable(*request.args, **request.kwds)
                    self._results_queue.put((request, result))
                except Exception as _:
                    logging.exception('Command failed')
                    request.exception = True
                    self._results_queue.put((request, sys.exc_info()))

    def dismiss(self):
        """Sets a flag to tell the thread to exit when done with current job."""
        self._dismissed.set()


class WorkRequest:
    """A request to execute a callable for putting in the request queue later.

    See the module function ``makeRequests`` for the common case
    where you want to build several ``WorkRequest`` objects for the same
    callable but with different arguments for each call.

    """

    def __init__(self, callable_, args=None, kwds=None, requestID=None,
                 callback=None, exc_callback=_handle_thread_exception):
        """Create a work request for a callable and attach callbacks.

        A work request consists of the a callable to be executed by a
        worker thread, a list of positional arguments, a dictionary
        of keyword arguments.

        A ``callback`` function can be specified, that is called when the
        results of the request are picked up from the result queue. It must
        accept two anonymous arguments, the ``WorkRequest`` object and the
        results of the callable, in that order. If you want to pass additional
        information to the callback, just stick it on the request object.

        You can also give custom callback for when an exception occurs with
        the ``exc_callback`` keyword parameter. It should also accept two
        anonymous arguments, the ``WorkRequest`` and a tuple with the exception
        details as returned by ``sys.exc_info()``. The default implementation
        of this callback just prints the exception info via
        ``traceback.print_exception``. If you want no exception handler
        callback, just pass in ``None``.

        ``requestID``, if given, must be hashable since it is used by
        ``ThreadPool`` object to store the results of that work request in a
        dictionary. It defaults to the return value of ``id(self)``.

        """
        if requestID is None:
            self.requestID = id(self)
        else:
            try:
                self.requestID = hash(requestID)
            except TypeError:
                raise TypeError("requestID must be hashable.")
        self.exception = False
        self.callback = callback
        self.exc_callback = exc_callback
        self.callable = callable_
        self.args = args or []
        self.kwds = kwds or {}

    def __str__(self):
        return "<WorkRequest id=%s args=%r kwargs=%r exception=%s>" %\
               (self.requestID, self.args, self.kwds, self.exception)


class ThreadPool:
    """A thread pool, distributing work requests and collecting results.

    See the module docstring for more information.

    """

    def __init__(self, num_workers, q_size=0, resq_size=0, poll_timeout=5):
        """Set up the thread pool and start num_workers worker threads.

        ``num_workers`` is the number of worker threads to start initially.

        If ``q_size > 0`` the size of the work *request queue* is limited and
        the thread pool blocks when the queue is full and it tries to put
        more work requests in it (see ``putRequest`` method), unless you also
        use a positive ``timeout`` value for ``putRequest``.

        If ``resq_size > 0`` the size of the *results queue* is limited and the
        worker threads will block when the queue is full and they try to put
        new results in it.

        .. warning:
            If you set both ``q_size`` and ``resq_size`` to ``!= 0`` there is
            the possibilty of a deadlock, when the results queue is not pulled
            regularly and too many jobs are put in the work requests queue.
            To prevent this, always set ``timeout > 0`` when calling
            ``ThreadPool.putRequest()`` and catch ``Queue.Full`` exceptions.

        """
        self._requests_queue = Queue(q_size)
        self._results_queue = Queue(resq_size)
        self.workers = []
        self.dismissedWorkers = []
        self.workRequests = {}
        self.createWorkers(num_workers, poll_timeout)

    def createWorkers(self, num_workers, poll_timeout=5):
        """Add num_workers worker threads to the pool.

        ``poll_timout`` sets the interval in seconds (int or float) for how
        ofte threads should check whether they are dismissed, while waiting for
        requests.

        """
        for i in range(num_workers):
            self.workers.append(WorkerThread(self._requests_queue,
                                             self._results_queue, poll_timeout=poll_timeout, name='ThreadPool worker %i' % i))

    def dismissWorkers(self, num_workers, do_join=False):
        """Tell num_workers worker threads to quit after their current task."""
        dismiss_list = []
        for i in range(min(num_workers, len(self.workers))):
            worker = self.workers.pop()
            worker.dismiss()
            dismiss_list.append(worker)

        if do_join:
            for worker in dismiss_list:
                worker.join()
        else:
            self.dismissedWorkers.extend(dismiss_list)

    def joinAllDismissedWorkers(self):
        """Perform Thread.join() on all worker threads that have been dismissed.
        """
        for worker in self.dismissedWorkers:
            worker.join()
        self.dismissedWorkers = []

    def putRequest(self, request, block=True, timeout=None):
        """Put work request into work queue and save its id for later."""
        assert isinstance(request, WorkRequest)
        # don't reuse old work requests
        assert not getattr(request, 'exception', None)
        self._requests_queue.put(request, block, timeout)
        self.workRequests[request.requestID] = request

    def poll(self, block=False):
        """Process any new results in the queue."""
        while True:
            # still results pending?
            if not self.workRequests:
                raise NoResultsPending
            # are there still workers to process remaining requests?
            elif block and not self.workers:
                raise NoWorkersAvailable
            try:
                # get back next results
                request, result = self._results_queue.get(block=block)
                # has an exception occured?
                if request.exception and request.exc_callback:
                    request.exc_callback(request, result)
                    # hand results to callback, if any
                if request.callback and not (request.exception and request.exc_callback):
                    request.callback(request, result)
                del self.workRequests[request.requestID]
            except Empty:
                break

    def wait(self):
        """Wait for results, blocking until all have arrived."""
        while 1:
            try:
                self.poll(True)
            except NoResultsPending:
                break

########NEW FILE########
__FILENAME__ = config-template
##########################################################################
#                                                                        #
#  This is the config-template for Err. This file should be copied and   #
#  renamed to config.py, then modified as you see fit to run Err the way #
#  you like it.                                                          #
#                                                                        #
#  As this is a regular Python file, note that you can do variable       #
#  assignments and the likes as usual. This can be useful for example if #
#  you use the same values in multiple places.                           #
#                                                                        #
#  Note: Various config options require a tuple to be specified, even    #
#  when you are configuring only a single value. An example of this is   #
#  the BOT_ADMINS option. Make sure you use a valid tuple here, even if  #
#  you are only configuring a single item, else you will get errors.     #
#  (So don't forget the trailing ',' in these cases)                     #
#                                                                        #
##########################################################################

import logging

##########################################################################
# Core Err configuration                                                 #
##########################################################################

# The location where all of Err's data should be stored. Make sure to set
# this to a directory that is writable by the user running the bot.
BOT_DATA_DIR = '/var/lib/err'

# Set this to a directory on your system where you want to load extra
# plugins from, which is useful mostly if you want to develop a plugin
# locally before publishing it. Note that you can specify only a single
# directory, however you are free to create subdirectories with multiple
# plugins inside this directory.
BOT_EXTRA_PLUGIN_DIR = None 

# The location of the log file. If you set this to None, then logging will
# happen to console only.
BOT_LOG_FILE = '/var/log/err/err.log'

# The verbosity level of logging that is done to the above logfile, and to
# the console. This takes the standard Python logging levels, DEBUG, INFO,
# WARN, ERROR. For more info, see http://docs.python.org/library/logging.html
#
# If you encounter any issues with Err, please set your log level to
# logging.DEBUG and attach a log with your bug report to aid the developers
# in debugging the issue.
BOT_LOG_LEVEL = logging.INFO

# Enable logging to sentry (find out more about sentry at www.getsentry.com).
# This is optional and disabled by default.
BOT_LOG_SENTRY = False
SENTRY_DSN = ''
SENTRY_LOGLEVEL = BOT_LOG_LEVEL

# Execute commands in asynchronous mode. In this mode, Err will spawn 3 
# seperate threads to handle commands, instead of blocking on each 
# single command.
BOT_ASYNC = True

##########################################################################
# Account and chatroom (MUC) configuration                               #
##########################################################################

# The identity, or credentials, used to connect to a server
BOT_IDENTITY = {
    # XMPP (Jabber) mode
    'username': 'err@localhost',  # The JID of the user you have created for the bot
    'password': 'changeme',       # The corresponding password for this user

    ## HipChat mode (Comment the above if using this mode)
    # 'username' : '12345_123456@chat.hipchat.com',
    # 'password' : 'changeme',
    ## Group admins can create/view tokens on the settings page after logging
    ## in on HipChat's website
    # 'token' : 'ed4b74d62833267d98aa99f312ff04',

    ## Campfire mode (Comment the others above if using this mode)
    # 'subdomain': 'yatta',
    # 'username' : 'errbot',
    # 'password' : 'changeme',


    ## IRC mode (Comment the others above if using this mode)
    # 'nickname' : 'err-chatbot',
    # 'password' : None,             # optional
    # 'server' : 'irc.freenode.net',
    # 'port': 6667,                  # optional
    # 'ssl': False,                  # optional
}

# Set the admins of your bot. Only these users will have access
# to the admin-only commands.
#
# Note: With campfire this should be the full name of a person, like so: 
# BOT_ADMINS = ('Guillaume Binet',)
#
BOT_ADMINS = ('gbin@localhost',)

# Chatrooms your bot should join on startup. For the IRC backend you 
# should include the # sign here. For XMPP rooms that are password
# protected, you can specify another tuple here instead of a string,
# using the format (RoomName, Password).
CHATROOM_PRESENCE = ('err@conference.server.tld',)

# The FullName, or nickname, your bot should use. What you set here will
# be the nickname that Err shows in chatrooms. Note that some XMPP
# implementations, notably HipChat, are very picky about what name you
# use. In the case of HipChat, make sure this matches exactly with the
# name you gave the user.
CHATROOM_FN = 'Err'

##########################################################################
# Prefix configuration                                                   #
##########################################################################

# Command prefix, the prefix that is expected in front of commands directed
# at the bot.
#
# Note: When writing plugins,you should always use the default '!'.
# If the prefix is changed from the default, the help strings will be
# automatically adjusted for you.
#
BOT_PREFIX = '!'

# Uncomment the following and set it to True if you want the prefix to be
# optional for normal chat.
# (Meaning messages sent directly to the bot as opposed to within a MUC)
#BOT_PREFIX_OPTIONAL_ON_CHAT = False

# You might wish to have your bot respond by being called with certain
# names, rather than the BOT_PREFIX above. This option allows you to
# specify alternative prefixes the bot will respond to in addition to
# the prefix above.
#BOT_ALT_PREFIXES = ('Err',)

# If you use alternative prefixes, you might want to allow users to insert
# separators like , and ; between the prefix and the command itself. This
# allows users to refer to your bot like this (Assuming 'Err' is in your
# BOT_ALT_PREFIXES):
# "Err, status" or "Err: status"
#
# Note: There's no need to add spaces to the separators here
#
#BOT_ALT_PREFIX_SEPARATORS = (':', ',', ';')

# Continuing on this theme, you might want to permit your users to be
# lazy and not require correct capitalization, so they can do 'Err',
# 'err' or even 'ERR'.
#BOT_ALT_PREFIX_CASEINSENSITIVE = True

##########################################################################
# Access controls and message diversion                                  #
##########################################################################

# Access controls, allowing commands to be restricted to specific users/rooms.
# Available filters (you can omit a filter or set it to None to disable it):
#   allowusers: Allow command from these users only
#   denyusers: Deny command from these users
#   allowrooms: Allow command only in these rooms (and direct messages)
#   denyrooms: Deny command in these rooms
#   allowprivate: Allow command from direct messages to the bot
#   allowmuc: Allow command inside rooms
# Rules listed in ACCESS_CONTROLS_DEFAULT are applied when a command cannot 
# be found inside ACCESS_CONTROLS
#
# Example:
#ACCESS_CONTROLS_DEFAULT = {} # Allow everyone access by default
#ACCESS_CONTROLS = {'status': {'allowrooms': ('someroom@conference.localhost',)},
#                   'about': {'denyusers': ('baduser@localhost',), 'allowrooms': ('room1@conference.localhost', 'room2@conference.localhost')},
#                   'uptime': {'allowusers': BOT_ADMINS},
#                   'help': {'allowmuc': False},
#                  }

# Uncomment and set this to True to hide the restricted commands from
# the help output.
#HIDE_RESTRICTED_COMMANDS = False

# Uncomment and set this to True to ignore commands from users that have no
# access for these instead of replying with error message.
#HIDE_RESTRICTED_ACCESS = False

# A list of commands which should be responded to in private, even if
# the command was given in a MUC. For example:
# DIVERT_TO_PRIVATE = ('help', 'about', 'status')
DIVERT_TO_PRIVATE = ()

# Chat relay
# Can be used to relay one to one message from specific users to the bot
# to MUCs. This can be useful with XMPP notifiers like for example  the
# standard Altassian Jira which don't have native support for MUC.
# For example: CHATROOM_RELAY = {'gbin@localhost' : (_TEST_ROOM,)}
CHATROOM_RELAY = {}

# Reverse chat relay
# This feature forwards whatever is said to a specific user.
# It can be useful if you client like gtalk doesn't support MUC correctly
# For example: REVERSE_CHATROOM_RELAY = {_TEST_ROOM : ('gbin@localhost',)}
REVERSE_CHATROOM_RELAY = {}

##########################################################################
# Miscellaneous configuration options                                    #
##########################################################################

# Define the maximum length a single message may be. If a plugin tries to
# send a message longer than this length, it will be broken up into multiple
# shorter messages that do fit.
#MESSAGE_SIZE_LIMIT = 10000

# XMPP TLS certificate verification. In order to validate offered certificates,
# you must supply a path to a file containing certificate authorities. By
# default, "/etc/ssl/certs/ca-certificates.crt" is used, which on most Linux
# systems holds the default system trusted CA certificates. You might need to
# change this depending on your environment. Setting this to None disables
# certificate validation, which can be useful if you have a self-signed
# certificate for example.
#XMPP_CA_CERT_FILE = "/etc/ssl/certs/ca-certificates.crt"

# Influence the security methods used on connection with XMPP-based
# backends. You can use this to work around authentication issues with
# some buggy XMPP servers.
#
# The default is to try anything:
#XMPP_FEATURE_MECHANISMS = {}
# To use only unencrypted plain auth:
#XMPP_FEATURE_MECHANISMS =  {'use_mech': 'PLAIN', 'unencrypted_plain': True, 'encrypted_plain': False}

# Modify the default keep-alive interval. By default, Err will send
# some whitespace to the XMPP server every 300 seconds to keep the TCP
# connection alive. On some servers, or when running Err from behind
# a NAT router, the default might not be fast enough and you will need
# to set it to a lower value. 
#
# It has been reported that HipChat also times out without setting this
# to a lower value (60 seems to work well with HipChat)
#
# If you're having issues with your bot getting constantly disconnected,
# try to gradually lower this value until it no longer happens.
#XMPP_KEEPALIVE_INTERVAL = 300

# Message rate limiting for the IRC backend.
# Rate limiter for regular channel messages, set to None to disable limits.
#IRC_CHANNEL_RATE = 1
# Rate limiter for private messages, set to None to disable limits.
#IRC_PRIVATE_RATE = 1

########NEW FILE########
__FILENAME__ = config-travisci
# config for travisci
# Don't use this for sensible defaults
import logging
BOT_DATA_DIR = '/tmp'
BOT_EXTRA_PLUGIN_DIR = None
BOT_LOG_FILE = '/tmp/err.log'
BOT_LOG_LEVEL = logging.DEBUG
BOT_LOG_SENTRY = False
SENTRY_DSN = ''
SENTRY_LOGLEVEL = BOT_LOG_LEVEL
BOT_ASYNC = True
BOT_IDENTITY = {
    'username': 'err@localhost',
    'password': 'changeme',
}

BOT_ADMINS = ('gbin@localhost',)
CHATROOM_PRESENCE = ()
CHATROOM_FN = 'Err'
BOT_PREFIX = '!'
DIVERT_TO_PRIVATE = ()
CHATROOM_RELAY = {}
REVERSE_CHATROOM_RELAY = {}


########NEW FILE########
__FILENAME__ = decorators
import re
import logging
from errbot import PY2
from errbot.builtins.wsview import bottle_app, WebView

def botcmd(*args, **kwargs):
    """
    Decorator for bot command functions

    :param hidden: Prevents the command from being shown by the built-in help command when `True`.
    :param name: The name to give to the command. Defaults to name of the function itself.
    :param split_args_with: Automatically split arguments on the given separator.
        Behaviour of this argument is identical to :func:`str.split()`
    :param admin_only: Only allow the command to be executed by admins when `True`.
    :param historize: Store the command in the history list (`!history`). This is enabled
        by default.
    :param template: The template to use when using XHTML-IM output

    This decorator should be applied to methods of :class:`~errbot.botplugin.BotPlugin`
    classes to turn them into commands that can be given to the bot. These methods are
    expected to have a signature like the following::

        @botcmd
        def some_command(self, msg, args):
            pass

    The given `msg` will be the full message object that was received, which includes data
    like sender, receiver, the plain-text and html body (if applicable), etc. `args` will
    be a string or list (depending on your value of `split_args_with`) of parameters that
    were given to the command by the user.
    """

    def decorate(func, hidden=False, name=None, split_args_with='', admin_only=False, historize=True, template=None):
        if not hasattr(func, '_err_command'):  # don't override generated functions
            setattr(func, '_err_command', True)
            setattr(func, '_err_re_command', False)
            setattr(func, '_err_command_hidden', hidden)
            setattr(func, '_err_command_name', name or func.__name__)
            setattr(func, '_err_command_split_args_with', split_args_with)
            setattr(func, '_err_command_admin_only', admin_only)
            setattr(func, '_err_command_historize', historize)
            setattr(func, '_err_command_template', template)
        return func

    if len(args):
        return decorate(args[0], **kwargs)
    else:
        return lambda func: decorate(func, **kwargs)


def re_botcmd(*args, **kwargs):
    """
    Decorator for regex-based bot command functions

    :param pattern: The regular expression a message should match against in order to
        trigger the command.
    :param flags: The `flags` parameter which should be passed to :func:`re.compile()`. This
        allows the expression's behaviour to be modified, such as making it case-insensitive
        for example.
    :param prefixed: Requires user input to start with a bot prefix in order for the pattern
        to be applied when `True` (the default).
    :param hidden: Prevents the command from being shown by the built-in help command when `True`.
    :param name: The name to give to the command. Defaults to name of the function itself.
    :param admin_only: Only allow the command to be executed by admins when `True`.
    :param historize: Store the command in the history list (`!history`). This is enabled
        by default.
    :param template: The template to use when using XHTML-IM output

    This decorator should be applied to methods of :class:`~errbot.botplugin.BotPlugin`
    classes to turn them into commands that can be given to the bot. These methods are
    expected to have a signature like the following::

        @re_botcmd(pattern=r'^some command$')
        def some_command(self, msg, match):
            pass

    The given `msg` will be the full message object that was received, which includes data
    like sender, receiver, the plain-text and html body (if applicable), etc. `match` will
    be a :class:`re.MatchObject` containing the result of applying the regular expression on the
    user's input.
    """

    def decorate(func, pattern, flags=0, prefixed=True, hidden=False, name=None, admin_only=False, historize=True, template=None):
        if not hasattr(func, '_err_command'):  # don't override generated functions
            setattr(func, '_err_command', True)
            setattr(func, '_err_re_command', True)
            setattr(func, '_err_command_re_pattern', re.compile(pattern, flags=flags))
            setattr(func, '_err_command_prefix_required', prefixed)
            setattr(func, '_err_command_hidden', hidden)
            setattr(func, '_err_command_name', name or func.__name__)
            setattr(func, '_err_command_admin_only', admin_only)
            setattr(func, '_err_command_historize', historize)
            setattr(func, '_err_command_template', template)
        return func

    if len(args):
        return decorate(args[0], **kwargs)
    else:
        return lambda func: decorate(func, **kwargs)


def webhook(*args, **kwargs):
    """
    Decorator for webhooks

    :param uri_rule: A regular expression against which the called URL should
        match in order for the webhook to trigger. If left undefined then the URL
        `/<method_name>/` will be used instead.
    :param methods: A tuple of allowed HTTP methods. By default, only GET and POST
        are allowed.
    :param form_param: The key who's contents will be passed to your method's `payload`
        parameter. This is used for example when using the `application/x-www-form-urlencoded`
        mimetype.

    This decorator should be applied to methods of :class:`~errbot.botplugin.BotPlugin`
    classes to turn them into webhooks which can be reached on Err's built-in webserver.
    The bundled *Webserver* plugin needs to be configured before these URL's become reachable.

    Methods with this decorator are expected to have a signature like the following::

        @webhook
        def a_webhook(self, payload):
            pass
    """

    def decorate(func, uri_rule, methods=('POST', 'GET'), form_param=None):
        logging.info("webhooks:  Bind %s to %s" % (uri_rule, func.__name__))

        for verb in methods:
            bottle_app.route(uri_rule, verb, callback=WebView(func, form_param), name=func.__name__ + '_' + verb)
        return func

    if isinstance(args[0], str) or (PY2 and isinstance(args[0], basestring)):
        return lambda method: decorate(method, args[0], **kwargs)
    return decorate(args[0], '/' + args[0].__name__ + '/', **kwargs)

########NEW FILE########
__FILENAME__ = errBot
# -*- coding: utf-8 -*-

#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
from ast import literal_eval
from datetime import datetime
import inspect
import gc
import logging
import os

import shutil
import subprocess

from tarfile import TarFile
from urllib.request import urlopen
from pprint import pformat

from errbot import botcmd, PY2
from errbot.backends.base import Backend, HIDE_RESTRICTED_COMMANDS

from errbot.plugin_manager import (
    get_all_active_plugin_names, deactivate_all_plugins, update_plugin_places, get_all_active_plugin_objects,
    get_all_plugins, global_restart, get_all_plugin_names, activate_plugin_with_version_check, deactivate_plugin_by_name,
    get_plugin_obj_by_name, PluginConfigurationException, check_dependencies, reload_plugin_by_name
)

from errbot.storage import StoreMixin
from errbot.utils import PLUGINS_SUBDIR, human_name_for_git_url, tail, format_timedelta, which, get_sender_username
from errbot.repos import KNOWN_PUBLIC_REPOS
from errbot.version import VERSION

def get_class_that_defined_method(meth):
    for cls in inspect.getmro(type(meth.__self__)):
        if meth.__name__ in cls.__dict__:
            return cls
    return None

CONFIGS = b'configs' if PY2 else 'configs'
REPOS = b'repos' if PY2 else 'repos'
BL_PLUGINS = b'bl_plugins' if PY2 else 'bl_plugins'

class ErrBot(Backend, StoreMixin):
    __errdoc__ = """ Commands related to the bot administration """
    MSG_ERROR_OCCURRED = 'Computer says nooo. See logs for details.'
    MSG_UNKNOWN_COMMAND = 'Unknown command: "%(command)s". '
    startup_time = datetime.now()

    def __init__(self, *args, **kwargs):
        from config import BOT_DATA_DIR, BOT_PREFIX

        self.plugin_dir = BOT_DATA_DIR + os.sep + PLUGINS_SUBDIR

        self.open_storage(BOT_DATA_DIR + os.sep + 'core.db')
        self.prefix = BOT_PREFIX
        # be sure we have a configs entry for the plugin configurations
        if CONFIGS not in self:
            self[CONFIGS] = {}
        super(ErrBot, self).__init__(*args, **kwargs)

    # Repo management
    def get_installed_plugin_repos(self):
        return self.get(REPOS, {})

    def add_plugin_repo(self, name, url):
        if PY2:
            name = name.encode('utf-8')
            url = url.encode('utf-8')
        repos = self.get_installed_plugin_repos()
        repos[name] = url
        self[REPOS] = repos

    # plugin blacklisting management
    def get_blacklisted_plugin(self):
        return self.get(BL_PLUGINS, [])

    def is_plugin_blacklisted(self, name):
        return name in self.get_blacklisted_plugin()

    def blacklist_plugin(self, name):
        if self.is_plugin_blacklisted(name):
            logging.warning('Plugin %s is already blacklisted' % name)
            return 'Plugin %s is already blacklisted' % name
        self[BL_PLUGINS] = self.get_blacklisted_plugin() + [name]
        logging.info('Plugin %s is now blacklisted' % name)
        return 'Plugin %s is now blacklisted' % name

    def unblacklist_plugin(self, name):
        if not self.is_plugin_blacklisted(name):
            logging.warning('Plugin %s is not blacklisted' % name)
            return 'Plugin %s is not blacklisted' % name
        l = self.get_blacklisted_plugin()
        l.remove(name)
        self[BL_PLUGINS] = l
        logging.info('Plugin %s removed from blacklist' % name)
        return 'Plugin %s removed from blacklist' % name

    # configurations management
    def get_plugin_configuration(self, name):
        configs = self[CONFIGS]
        if name not in configs:
            return None
        return configs[name]

    def set_plugin_configuration(self, name, obj):
        configs = self[CONFIGS]
        configs[name] = obj
        self[CONFIGS] = configs

    # this will load the plugins the admin has setup at runtime
    def update_dynamic_plugins(self):
        all_candidates, errors = update_plugin_places([self.plugin_dir + os.sep + d for d in self.get(REPOS, {}).keys()])
        self.all_candidates = all_candidates
        return errors

    def send_message(self, mess):
        super(ErrBot, self).send_message(mess)
        # Act only in the backend tells us that this message is OK to broadcast
        for bot in get_all_active_plugin_objects():
            #noinspection PyBroadException
            try:
                bot.callback_botmessage(mess)
            except Exception as _:
                logging.exception("Crash in a callback_botmessage handler")

    def callback_message(self, conn, mess):
        if super(ErrBot, self).callback_message(conn, mess):
            # Act only in the backend tells us that this message is OK to broadcast
            for bot in get_all_active_plugin_objects():
                #noinspection PyBroadException
                try:
                    logging.debug('Callback %s' % bot)
                    bot.callback_message(conn, mess)
                except Exception as _:
                    logging.exception("Crash in a callback_message handler")

    def callback_contact_online(self, conn, pres):
        for bot in get_all_active_plugin_objects():
            #noinspection PyBroadException
            try:
                logging.debug('Callback %s' % bot)
                bot.callback_contact_online(conn, pres)
            except Exception as _:
                logging.exception('Crash in the callback_contact_online handler.')

    def callback_contact_offline(self, conn, pres):
        for bot in get_all_active_plugin_objects():
            #noinspection PyBroadException
            try:
                logging.debug('Callback %s' % bot)
                bot.callback_contact_offline(conn, pres)
            except Exception as _:
                logging.exception('Crash in the callback_contact_offline handler.')

    def callback_user_joined_chat(self, conn, pres):
        for bot in get_all_active_plugin_objects():
            #noinspection PyBroadException
            try:
                logging.debug('Callback %s' % bot)
                bot.callback_user_joined_chat(conn, pres)
            except Exception as _:
                logging.exception('Crash in the callback_user_joined_chat handler.')

    def callback_user_left_chat(self, conn, pres):
        for bot in get_all_active_plugin_objects():
            #noinspection PyBroadException
            try:
                logging.debug('Callback %s' % bot)
                bot.callback_user_left_chat(conn, pres)
            except Exception as _:
                logging.exception('Crash in the callback_user_left_chat handler.')

    def activate_non_started_plugins(self):
        logging.info('Activating all the plugins...')
        configs = self[CONFIGS]
        errors = ''
        for pluginInfo in get_all_plugins():
            try:
                if self.is_plugin_blacklisted(pluginInfo.name):
                    errors += ('Notice: %s is blacklisted, use ' + self.prefix + 'load %s to unblacklist it\n') % (pluginInfo.name, pluginInfo.name)
                    continue
                if hasattr(pluginInfo, 'is_activated') and not pluginInfo.is_activated:
                    logging.info('Activate plugin: %s' % pluginInfo.name)
                    activate_plugin_with_version_check(pluginInfo.name, configs.get(pluginInfo.name, None))
            except Exception as e:
                logging.exception("Error loading %s" % pluginInfo.name)
                errors += 'Error: %s failed to start : %s\n' % (pluginInfo.name, e)
        if errors:
            self.warn_admins(errors)
        return errors

    def signal_connect_to_all_plugins(self):
        for bot in get_all_active_plugin_objects():
            if hasattr(bot, 'callback_connect'):
                #noinspection PyBroadException
                try:
                    logging.debug('Callback %s' % bot)
                    bot.callback_connect()
                except Exception as _:
                    logging.exception("callback_connect failed for %s" % bot)

    def connect_callback(self):
        logging.info('Activate internal commands')
        loading_errors = self.activate_non_started_plugins()
        logging.info(loading_errors)
        logging.info('Notifying connection to all the plugins...')
        self.signal_connect_to_all_plugins()
        logging.info('Plugin activation done.')
        self.inject_commands_from(self)

    def disconnect_callback(self):
        self.remove_commands_from(self)
        logging.info('Disconnect callback, deactivating all the plugins.')
        deactivate_all_plugins()

    def shutdown(self):
        logging.info('Shutdown.')
        self.close_storage()
        logging.info('Bye.')

    @staticmethod
    def formatted_plugin_list(active_only=True):
        """
        Return a formatted, plain-text list of loaded plugins.

        When active_only=True, this will only return plugins which
        are actually active. Otherwise, it will also include inactive
        (blacklisted) plugins.
        """
        if active_only:
            all_plugins = get_all_active_plugin_names()
        else:
            all_plugins = get_all_plugin_names()
        return "\n".join((" " + plugin for plugin in all_plugins))

    #noinspection PyUnusedLocal
    @botcmd(template='status')
    def status(self, mess, args):
        """ If I am alive I should be able to respond to this one
        """
        all_blacklisted = self.get_blacklisted_plugin()
        all_loaded = get_all_active_plugin_names()
        all_attempted = sorted([p.name for p in self.all_candidates])
        plugins_statuses = []
        for name in all_attempted:
            if name in all_blacklisted:
                if name in all_loaded:
                    plugins_statuses.append(('BL', name))
                else:
                    plugins_statuses.append(('BU', name))
            elif name in all_loaded:
                plugins_statuses.append(('L', name))
            elif get_plugin_obj_by_name(name) is not None and get_plugin_obj_by_name(name).get_configuration_template() is not None and self.get_plugin_configuration(name) is None:
                plugins_statuses.append(('C', name))
            else:
                plugins_statuses.append(('U', name))

        #noinspection PyBroadException
        try:
            from posix import getloadavg

            loads = getloadavg()
        except Exception as _:
            loads = None
        return {'plugins_statuses': plugins_statuses, 'loads': loads, 'gc': gc.get_count()}

    #noinspection PyUnusedLocal
    @botcmd
    def echo(self, mess, args):
        """ A simple echo command. Useful for encoding tests etc ...
        """
        return args

    #noinspection PyUnusedLocal
    @botcmd
    def uptime(self, mess, args):
        """ Return the uptime of the bot
        """
        return "I've been up for %s %s (since %s)" % (args, format_timedelta(datetime.now() - self.startup_time), datetime.strftime(self.startup_time, '%A, %b %d at %H:%M'))

    #noinspection PyUnusedLocal
    @botcmd(admin_only=True)
    def export_configs(self, mess, args):
        """ Returns all the configs in form of a string you can backup
        """
        return repr(self.get(CONFIGS, {}))

    #noinspection PyUnusedLocal
    @botcmd(admin_only=True)
    def import_configs(self, mess, args):
        """ Restore the configs from an export from !export configs
        It will merge with preexisting configurations.
        """
        orig = self.get(CONFIGS, {})
        added = literal_eval(args)
        if type(added) is not dict:
            raise Exception('Weird, it should be a dictionary')
        self[CONFIGS] = dict(list(orig.items()) + list(added.items()))
        return "Import is done correctly, there are %i config entries now." % len(self[CONFIGS])

    #noinspection PyUnusedLocal
    @botcmd(admin_only=True)
    def zap_configs(self, mess, args):
        """ WARNING : Deletes all the configuration of all the plugins
        """
        self[CONFIGS] = {}
        return "Done"

    #noinspection PyUnusedLocal
    @botcmd(admin_only=True)
    def repos_export(self, mess, args):
        """ Returns all the repos in form of a string you can backup
        """
        return str(self.get_installed_plugin_repos())

    #noinspection PyUnusedLocal
    @botcmd(admin_only=True)
    def restart(self, mess, args):
        """ restart the bot """
        self.send(mess.getFrom(), "Deactivating all the plugins...")
        deactivate_all_plugins()
        self.send(mess.getFrom(), "Restarting")
        self.shutdown()
        global_restart()
        return "I'm restarting..."

    def activate_plugin(self, name):
        try:
            if name in get_all_active_plugin_names():
                return "Plugin already in active list"
            if name not in get_all_plugin_names():
                return "I don't know this %s plugin" % name
            activate_plugin_with_version_check(name, self.get_plugin_configuration(name))
        except Exception as e:
            logging.exception("Error loading %s" % name)
            return '%s failed to start : %s\n' % (name, e)
        get_plugin_obj_by_name(name).callback_connect()
        return "Plugin %s activated" % name

    def deactivate_plugin(self, name):
        if name not in get_all_active_plugin_names():
            return "Plugin %s not in active list" % name
        deactivate_plugin_by_name(name)
        return "Plugin %s deactivated" % name

    #noinspection PyUnusedLocal
    @botcmd(admin_only=True)
    def blacklist(self, mess, args):
        """Blacklist a plugin so that it will not be loaded automatically during bot startup"""
        if args not in get_all_plugin_names():
            return ("{} isn't a valid plugin name. The current plugins are:\n"
                    "{}".format(args, self.formatted_plugin_list(active_only=False)))
        return self.blacklist_plugin(args)

    #noinspection PyUnusedLocal
    @botcmd(admin_only=True)
    def unblacklist(self, mess, args):
        """Remove a plugin from the blacklist"""
        if args not in get_all_plugin_names():
            return ("{} isn't a valid plugin name. The current plugins are:\n"
                    "{}".format(args, self.formatted_plugin_list(active_only=False)))
        return self.unblacklist_plugin(args)

    #noinspection PyUnusedLocal
    @botcmd(admin_only=True)
    def load(self, mess, args):
        """load a plugin"""
        args = args.strip()
        if not args:
            return ("Please tell me which of the following plugins to reload:\n"
                    "{}".format(self.formatted_plugin_list(active_only=False)))
        if args not in get_all_plugin_names():
            return ("{} isn't a valid plugin name. The current plugins are:\n"
                    "{}".format(args, self.formatted_plugin_list(active_only=False)))
        if args in get_all_active_plugin_names():
            return "{} is already loaded".format(args)

        reload_plugin_by_name(args)
        r = self.activate_plugin(args)
        return r

    #noinspection PyUnusedLocal
    @botcmd(admin_only=True)
    def unload(self, mess, args):
        """unload a plugin"""
        args = args.strip()
        if not args:
            return ("Please tell me which of the following plugins to reload:\n"
                    "{}".format(self.formatted_plugin_list(active_only=False)))
        if args not in get_all_plugin_names():
            return ("{} isn't a valid plugin name. The current plugins are:\n"
                    "{}".format(args, self.formatted_plugin_list(active_only=False)))
        if args not in get_all_active_plugin_names():
            return "{} is not currently loaded".format(args)

        return self.deactivate_plugin(args)

    #noinspection PyUnusedLocal
    @botcmd(admin_only=True)
    def reload(self, mess, args):
        """reload a plugin"""
        args = args.strip()
        if not args:
            yield ("Please tell me which of the following plugins to reload:\n"
                    "{}".format(self.formatted_plugin_list(active_only=False)))
            return
        if args not in get_all_plugin_names():
            yield ("{} isn't a valid plugin name. The current plugins are:\n"
                    "{}".format(args, self.formatted_plugin_list(active_only=False)))
            return

        yield self.deactivate_plugin(args)  # Not needed but keeps the feedback to user consistent
        reload_plugin_by_name(args)
        yield self.activate_plugin(args)

    @botcmd(admin_only=True)
    def repos_install(self, mess, args):
        """ install a plugin repository from the given source or a known public repo (see !repos to find those).
        for example from a known repo : !install err-codebot
        for example a git url : git@github.com:gbin/plugin.git
        or an url towards a tar.gz archive : http://www.gootz.net/plugin-latest.tar.gz
        """
        if not args.strip():
            return "You should have an urls/git repo argument"
        if args in KNOWN_PUBLIC_REPOS:
            args = KNOWN_PUBLIC_REPOS[args][0]  # replace it by the url
        git_path = which('git')

        if not git_path:
            return 'git command not found: You need to have git installed on your system to by able to install git based plugins.'

        if args.endswith('tar.gz'):
            tar = TarFile(fileobj=urlopen(args))
            tar.extractall(path=self.plugin_dir)
            human_name = args.split('/')[-1][:-7]
        else:
            human_name = human_name_for_git_url(args)
            p = subprocess.Popen([git_path, 'clone', args, human_name], cwd=self.plugin_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            feedback = p.stdout.read().decode('utf-8')
            error_feedback = p.stderr.read().decode('utf-8')
            if p.wait():
                return "Could not load this plugin : \n%s\n---\n%s" % (feedback, error_feedback)
        self.add_plugin_repo(human_name, args)
        errors = self.update_dynamic_plugins()
        if errors:
            self.send(mess.getFrom(), 'Some plugins are generating errors:\n' + '\n'.join(errors), message_type=mess.getType())
        else:
            self.send(mess.getFrom(), "A new plugin repository named %s has been installed correctly from %s. Refreshing the plugins commands..." % (human_name, args), message_type=mess.getType())
        self.activate_non_started_plugins()
        return "Plugin reload done."

    @botcmd(admin_only=True)
    def repos_uninstall(self, mess, args):
        """ uninstall a plugin repository by name.
        """
        if not args.strip():
            return "You should have a repo name as argument"
        repos = self.get(REPOS, {})
        if args not in repos:
            return "This repo is not installed check with " + self.prefix + "repos the list of installed ones"

        plugin_path = self.plugin_dir + os.sep + args
        for plugin in get_all_plugins():
            if plugin.path.startswith(plugin_path) and hasattr(plugin, 'is_activated') and plugin.is_activated:
                self.send(mess.getFrom(), '/me is unloading plugin %s' % plugin.name)
                self.deactivate_plugin(plugin.name)

        shutil.rmtree(plugin_path)
        repos.pop(args)
        self[REPOS] = repos

        return 'Plugins unloaded and repo %s removed' % args

    #noinspection PyUnusedLocal
    @botcmd(template='repos')
    def repos(self, mess, args):
        """ list the current active plugin repositories
        """
        installed_repos = self.get_installed_plugin_repos()
        all_names = sorted(set([name for name in KNOWN_PUBLIC_REPOS] + [name for name in installed_repos]))
        max_width = max([len(name) for name in all_names])
        return {'repos': [
        (repo_name in installed_repos, repo_name in KNOWN_PUBLIC_REPOS, repo_name.ljust(max_width), KNOWN_PUBLIC_REPOS[repo_name][1]
        if repo_name in KNOWN_PUBLIC_REPOS else installed_repos[repo_name])
        for repo_name in all_names]}

    def get_doc(self, command):
        """Get command documentation
        """
        if not command.__doc__:
            return '(undocumented)'
        if self.prefix == '!':
            return command.__doc__
        return command.__doc__.replace('!', self.prefix)

    def get_command_classes(self):
        return (get_class_that_defined_method(command) for command in self.commands.values())

    @botcmd
    def help(self, mess, args):
        """   Returns a help string listing available options.

        Automatically assigned to the "help" command."""
        usage = ''
        if not args:
            description = 'Available help:\n'
            command_classes = sorted(set(self.get_command_classes()), key = lambda c:c.__name__)
            usage = '\n'.join(self.prefix + 'help %s: %s' % (clazz.__name__, clazz.__errdoc__ or '(undocumented)') for clazz in command_classes)
        elif args == 'full':
            description = 'Available commands:'

            clazz_commands = {}
            for (name, command) in self.commands.items():
                clazz = get_class_that_defined_method(command)
                commands = clazz_commands.get(clazz, [])
                if not HIDE_RESTRICTED_COMMANDS or self.check_command_access(mess, name)[0]:
                    commands.append((name, command))
                    clazz_commands[clazz] = commands

            for clazz in sorted(set(clazz_commands), key = lambda c:c.__name__):
                usage += '\n\n%s: %s\n' % (clazz.__name__, clazz.__errdoc__ or '')
                usage += '\n'.join(sorted([
                '\t' + self.prefix + '%s: %s' % (name.replace('_', ' ', 1),
                                                 (self.get_doc(command).strip()).split('\n', 1)[0])
                for (name, command) in clazz_commands[clazz] 
                    if name != 'help' 
                    and not command._err_command_hidden 
                    and (not HIDE_RESTRICTED_COMMANDS or self.check_command_access(mess, name)[0])
                ]))
            usage += '\n\n'
        elif args in (clazz.__name__ for clazz in self.get_command_classes()):
            # filter out the commands related to this class
            commands = [(name, command) for (name, command) in self.commands.items() if get_class_that_defined_method(command).__name__ == args]
            description = 'Available commands for %s:\n\n' % args
            usage += '\n'.join(sorted([
            '\t' + self.prefix + '%s: %s' % (name.replace('_', ' ', 1),
                                             (self.get_doc(command).strip()).split('\n', 1)[0])
            for (name, command) in commands 
                if not command._err_command_hidden  
                and (not HIDE_RESTRICTED_COMMANDS or self.check_command_access(mess, name)[0])
            ]))
        else:
            return super(ErrBot, self).help(mess, '_'.join(args.strip().split(' ')))

        top = self.top_of_help_message()
        bottom = self.bottom_of_help_message()
        return ''.join(filter(None, [top, description, usage, bottom]))

    #noinspection PyUnusedLocal
    @botcmd(historize=False)
    def history(self, mess, args):
        """display the command history"""
        answer = []
        user_cmd_history = self.cmd_history[get_sender_username(mess)]
        l = len(user_cmd_history)
        for i in range(0, l):
            c = user_cmd_history[i]
            answer.append('%2i:%s%s %s' % (l - i, self.prefix, c[0], c[1]))
        return '\n'.join(answer)

    #noinspection PyUnusedLocal
    @botcmd
    def about(self, mess, args):
        """   Returns some information about this err instance"""

        result = 'Err version %s \n\n' % VERSION
        result += 'Authors: Mondial Telecom, Guillaume BINET, Tali PETROVER, Ben VAN DAELE, Paul LABEDAN and others.\n\n'
        return result

    #noinspection PyUnusedLocal
    @botcmd
    def apropos(self, mess, args):
        """   Returns a help string listing available options.

        Automatically assigned to the "help" command."""
        if not args:
            return 'Usage: ' + self.prefix + 'apropos search_term'

        description = 'Available commands:\n'

        clazz_commands = {}
        for (name, command) in self.commands.items():
            clazz = get_class_that_defined_method(command)
            clazz = str.__module__ + '.' + clazz.__name__  # makes the fuul qualified name
            commands = clazz_commands.get(clazz, [])
            if not HIDE_RESTRICTED_COMMANDS or self.check_command_access(mess, name)[0]:
                commands.append((name, command))
                clazz_commands[clazz] = commands

        usage = ''
        for clazz in sorted(clazz_commands):
            usage += '\n'.join(sorted([
            '\t' + self.prefix + '%s: %s' % (name.replace('_', ' ', 1), (command.__doc__ or '(undocumented)').strip().split('\n', 1)[0])
            for (name, command) in clazz_commands[clazz] if
            args is not None and command.__doc__ is not None and args.lower() in command.__doc__.lower() and name != 'help' and not command._err_command_hidden
            ]))
        usage += '\n\n'

        top = self.top_of_help_message()
        bottom = self.bottom_of_help_message()
        return ''.join(filter(None, [top, description, usage, bottom])).strip()

    @botcmd(split_args_with=' ', admin_only=True)
    def repos_update(self, mess, args):
        """ update the bot and/or plugins
        use : !repos update all
        to update everything
        or : !repos update core
        to update only the core
        or : !repos update repo_name repo_name ...
        to update selectively some repos
        """
        git_path = which('git')
        if not git_path:
            return 'git command not found: You need to have git installed on your system to by able to update git based plugins.'

        directories = set()
        repos = self.get(REPOS, {})
        core_to_update = 'all' in args or 'core' in args
        if core_to_update:
            directories.add(os.path.dirname(__file__))

        if 'all' in args:
            directories.update([self.plugin_dir + os.sep + name for name in repos])
        else:
            directories.update([self.plugin_dir + os.sep + name for name in set(args).intersection(set(repos))])

        for d in directories:
            self.send(mess.getFrom(), "I am updating %s ..." % d, message_type=mess.getType())
            p = subprocess.Popen([git_path, 'pull'], cwd=d, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            feedback = p.stdout.read().decode('utf-8') + '\n' + '-' * 50 + '\n'
            err = p.stderr.read().strip().decode('utf-8')
            if err:
                feedback += err + '\n' + '-' * 50 + '\n'
            dep_err = check_dependencies(d)
            if dep_err:
                feedback += dep_err + '\n'
            if p.wait():
                self.send(mess.getFrom(), "Update of %s failed...\n\n%s\n\n resuming..." % (d, feedback), message_type=mess.getType())
            else:
                self.send(mess.getFrom(), "Update of %s succeeded...\n\n%s\n\n" % (d, feedback), message_type=mess.getType())
                if not core_to_update:
                    for plugin in get_all_plugins():
                        if plugin.path.startswith(d) and hasattr(plugin, 'is_activated') and plugin.is_activated:
                            name = plugin.name
                            self.send(mess.getFrom(), '/me is reloading plugin %s' % name)
                            reload_plugin_by_name(plugin.name)
                            self.activate_plugin(plugin.name)
                            self.send(mess.getFrom(), '%s reloaded and reactivated' % name)
        if core_to_update:
            self.restart(mess, '')
            return "You have updated the core, I need to restart."
        return "Done."

    #noinspection PyUnusedLocal
    @botcmd(split_args_with=' ', admin_only=True)
    def config(self, mess, args):
        """ configure or get the configuration / configuration template for a specific plugin
        ie.
        !config ExampleBot
        could return a template if it is not configured:
        {'LOGIN': 'example@example.com', 'PASSWORD': 'password', 'DIRECTORY': '/toto'}
        Copy paste, adapt so can configure the plugin :
        !config ExampleBot {'LOGIN': 'my@email.com', 'PASSWORD': 'myrealpassword', 'DIRECTORY': '/tmp'}
        It will then reload the plugin with this config.
        You can at any moment retreive the current values:
        !config ExampleBot
        should return :
        {'LOGIN': 'my@email.com', 'PASSWORD': 'myrealpassword', 'DIRECTORY': '/tmp'}
        """
        plugin_name = args[0]
        if self.is_plugin_blacklisted(plugin_name):
            return 'Load this plugin first with ' + self.prefix + 'load %s' % plugin_name
        obj = get_plugin_obj_by_name(plugin_name)
        if obj is None:
            return 'Unknown plugin or the plugin could not load %s' % plugin_name
        template_obj = obj.get_configuration_template()
        if template_obj is None:
            return 'This plugin is not configurable.'

        if len(args) == 1:
            current_config = self.get_plugin_configuration(plugin_name)
            response = ("Default configuration for this plugin (you can copy and paste "
                        "this directly as a command):\n{prefix}config {plugin_name} \n{config}").format(
                        prefix=self.prefix, plugin_name=plugin_name, config=pformat(template_obj))
            if current_config:
                response += "\n\nCurrent configuration:\n{prefix}config {plugin_name} \n{config}".format(
                            prefix=self.prefix, plugin_name=plugin_name, config=pformat(current_config))
            return response

        #noinspection PyBroadException
        try:
            real_config_obj = literal_eval(' '.join(args[1:]))
        except Exception as _:
            logging.exception('Invalid expression for the configuration of the plugin')
            return 'Syntax error in the given configuration'
        if type(real_config_obj) != type(template_obj):
            return 'It looks fishy, your config type is not the same as the template !'

        self.set_plugin_configuration(plugin_name, real_config_obj)
        self.deactivate_plugin(plugin_name)
        try:
            self.activate_plugin(plugin_name)
        except PluginConfigurationException as ce:
            logging.debug('Invalid configuration for the plugin, reverting the plugin to unconfigured')
            self.set_plugin_configuration(plugin_name, None)
            return 'Incorrect plugin configuration: %s' % ce
        return 'Plugin configuration done.'

    #noinspection PyUnusedLocal
    @botcmd
    def log_tail(self, mess, args):
        """ Display a tail of the log of n lines or 40 by default
        use : !log tail 10
        """
        #admin_only(mess) # uncomment if paranoid.
        n = 40
        if args.isdigit():
            n = int(args)
        from config import BOT_LOG_FILE

        if BOT_LOG_FILE:
            with open(BOT_LOG_FILE, 'r') as f:
                return tail(f, n)
        return 'No log is configured, please define BOT_LOG_FILE in config.py'

########NEW FILE########
__FILENAME__ = holder
# This class just hold the global singletons for the bot outside of the plugin framework to avoid spurrious modules reloads
plugin_manager = None
bot = None

########NEW FILE########
__FILENAME__ = main
from os import path, makedirs, sep, getcwd
import logging


def main(bot_class, logger):
    # from here the environment is supposed to be set (daemon / non daemon,
    # config.py in the python path )

    from config import BOT_IDENTITY, BOT_LOG_LEVEL, BOT_DATA_DIR, BOT_LOG_FILE, BOT_LOG_SENTRY
    from errbot.utils import PLUGINS_SUBDIR
    from errbot import holder

    if BOT_LOG_FILE:
        hdlr = logging.FileHandler(BOT_LOG_FILE)
        hdlr.setFormatter(logging.Formatter('%(asctime)s %(levelname)s %(message)s'))
        logger.addHandler(hdlr)
    logger.setLevel(BOT_LOG_LEVEL)

    if BOT_LOG_SENTRY:
        try:
            from raven.handlers.logging import SentryHandler
        except ImportError as _:
            logging.exception("""You have BOT_LOG_SENTRY enabled, but I couldn't import modules needed for Sentry integration.
            Did you install raven? (See http://raven.readthedocs.org/en/latest/install/index.html for installation instructions)

            """)
            exit(-1)
        from config import SENTRY_DSN, SENTRY_LOGLEVEL

        sentryhandler = SentryHandler(SENTRY_DSN, level=SENTRY_LOGLEVEL)
        logger.addHandler(sentryhandler)

    # make the plugins subdir to store the plugin shelves
    d = BOT_DATA_DIR + sep + str(PLUGINS_SUBDIR)
    if not path.exists(d):
        makedirs(d, mode=0o755)

    holder.bot = bot_class(**BOT_IDENTITY)
    errors = holder.bot.update_dynamic_plugins()
    if errors:
        logging.error('Some plugins failed to load:\n' + '\n'.join(errors))
    logging.debug('serve from %s' % holder.bot)
    holder.bot.serve_forever()

########NEW FILE########
__FILENAME__ = pid
import fcntl
import os


class PidFile(object):
    """Context manager that locks a pid file.  Implemented as class
    not generator because daemon.py is calling .__exit__() with no parameters
    instead of the None, None, None specified by PEP-343."""
    # pylint: disable=R0903

    def __init__(self, path):
        self.path = path
        self.pidfile = None

    def __enter__(self):
        self.pidfile = open(self.path, "a+")
        try:
            fcntl.flock(self.pidfile.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
        except IOError:
            raise SystemExit("Already running according to " + self.path)
        self.pidfile.seek(0)
        self.pidfile.truncate()
        self.pidfile.write(str(os.getpid()))
        self.pidfile.flush()
        self.pidfile.seek(0)
        return self.pidfile

    #noinspection PyUnusedLocal
    def __exit__(self, exc_type=None, exc_value=None, exc_tb=None):
        try:
            self.pidfile.close()
        except IOError as err:
            # ok if file was just closed elsewhere
            if err.errno != 9:
                raise
        os.remove(self.path)
########NEW FILE########
__FILENAME__ = plugin_manager
from configparser import NoSectionError
from itertools import chain
import logging
import sys
import os
from errbot import PY2
from errbot.botplugin import BotPlugin
from errbot.utils import version2array, PY3
from errbot.templating import remove_plugin_templates_path, add_plugin_templates_path
from errbot.version import VERSION
from yapsy.PluginManager import PluginManager
from imp import reload

# hardcoded directory for the system plugins
from errbot import holder

BUILTIN = str(os.path.dirname(os.path.abspath(__file__))) + os.sep + 'builtins'
if PY2:  # keys needs to be byte strings en shelves under python 2
    BUILTIN = BUILTIN.encode()


class IncompatiblePluginException(Exception):
    pass


class PluginConfigurationException(Exception):
    pass


def get_builtins(extra):
    # adds the extra plugin dir from the setup for developers convenience
    if extra:
        if isinstance(extra, list):
            return [BUILTIN] + extra
        return [BUILTIN, extra]
    else:
        return [BUILTIN]


def init_plugin_manager():
    global simplePluginManager

    if not holder.plugin_manager:
        logging.info('init plugin manager')
        simplePluginManager = PluginManager(categories_filter={"bots": BotPlugin})
        simplePluginManager.setPluginInfoExtension('plug')
        holder.plugin_manager = simplePluginManager
    else:
        simplePluginManager = holder.plugin_manager


init_plugin_manager()


def get_plugin_by_name(name):
    pta_item = simplePluginManager.getPluginByName(name, 'bots')
    if pta_item is None:
        return None
    return pta_item


def get_plugin_obj_by_name(name):
    plugin = get_plugin_by_name(name)
    return None if plugin is None else plugin.plugin_object


def populate_doc(plugin):
    plugin_type = type(plugin.plugin_object)
    plugin_type.__errdoc__ = plugin_type.__doc__ if plugin_type.__doc__ else plugin.description


def activate_plugin_with_version_check(name, config):
    pta_item = simplePluginManager.getPluginByName(name, 'bots')
    if pta_item is None:
        logging.warning('Could not activate %s' % name)
        return None

    try:
        python_version = pta_item.details.get("Python", "Version")
    except NoSectionError:
        logging.warning('Plugin %s has no section [Python]. Assuming this plugin is runnning only under python 2.' % name)
        python_version = '2'

    if python_version not in ('2', '2+', '3'):
        logging.warning('Plugin %s has an invalid Version specified in section [Python]. The Version can only be 2, 2+ and 3' % name)
        return None

    if python_version == '2' and PY3:
        logging.error('\nPlugin %s is made for python 2 only and you are running err under python 3.\n\n'
                      'If the plugin can be run on python 2 and 3 please add this section to its .plug descriptor :\n[Python]\nVersion=2+\n\n'
                      'Or if the plugin is Python 3 only:\n[Python]\nVersion=3\n\n' % name)
        return None

    if python_version == '3' and PY2:
        logging.error('\nPlugin %s is made for python 3 and you are running err under python 2.')
        return None

    obj = pta_item.plugin_object
    min_version, max_version = obj.min_err_version, obj.max_err_version
    logging.info('Activating %s with min_err_version = %s and max_version = %s' % (name, min_version, max_version))
    current_version = version2array(VERSION)
    if min_version and version2array(min_version) > current_version:
        raise IncompatiblePluginException('The plugin %s asks for err with a minimal version of %s while err is version %s' % (name, min_version, VERSION))

    if max_version and version2array(max_version) < current_version:
        raise IncompatiblePluginException('The plugin %s asks for err with a maximal version of %s while err is version %s' % (name, max_version, VERSION))

    try:
        if obj.get_configuration_template() is not None and config is not None:
            logging.debug('Checking configuration for %s...' % name)
            obj.check_configuration(config)
            logging.debug('Configuration for %s checked OK.' % name)
        obj.configure(config)  # even if it is None we pass it on
    except Exception as e:
        logging.exception('Something is wrong with the configuration of the plugin %s' % name)
        obj.config = None
        raise PluginConfigurationException(str(e))
    add_plugin_templates_path(pta_item.path)
    populate_doc(pta_item)
    try:
        return simplePluginManager.activatePluginByName(name, "bots")
    except Exception as _:
        pta_item.activated = False  # Yapsy doesn't revert this in case of error
        remove_plugin_templates_path(pta_item.path)
        logging.error("Plugin %s failed at activation stage, deactivating it..." % name)
        simplePluginManager.deactivatePluginByName(name, "bots")
        raise


def deactivate_plugin_by_name(name):
    pta_item = simplePluginManager.getPluginByName(name, 'bots')
    remove_plugin_templates_path(pta_item.path)
    try:
        return simplePluginManager.deactivatePluginByName(name, "bots")
    except Exception as _:
        add_plugin_templates_path(pta_item.path)
        raise


def reload_plugin_by_name(name):
    """
    Completely reload the given plugin, including reloading of the module's code
    """
    if name in get_all_active_plugin_names():
        deactivate_plugin_by_name(name)

    plugin = get_plugin_by_name(name)
    logging.critical(dir(plugin))
    module = __import__(plugin.path.split(os.sep)[-1])
    reload(module)

    class_name = type(plugin.plugin_object).__name__
    new_class = getattr(module, class_name)
    plugin.plugin_object.__class__ = new_class



def update_plugin_places(list):
    from config import BOT_EXTRA_PLUGIN_DIR
    builtins = get_builtins(BOT_EXTRA_PLUGIN_DIR)
    for entry in chain(builtins, list):
        if entry not in sys.path:
            sys.path.append(entry)  # so the plugins can relatively import their submodules

    errors = [check_dependencies(path) for path in list]
    errors = [error for error in errors if error is not None]
    simplePluginManager.setPluginPlaces(chain(builtins, list))
    all_candidates = []

    def add_candidate(candidate):
        all_candidates.append(candidate)

    simplePluginManager.locatePlugins()
    #noinspection PyBroadException
    try:
        simplePluginManager.loadPlugins(add_candidate)
    except Exception as _:
        logging.exception("Error while loading plugins")

    return all_candidates, errors


def get_all_plugins():
    logging.debug("All plugins: %s" % simplePluginManager.getAllPlugins())
    return simplePluginManager.getAllPlugins()


def get_all_active_plugin_objects():
    return [plug.plugin_object for plug in get_all_plugins() if hasattr(plug, 'is_activated') and plug.is_activated]


def get_all_active_plugin_names():
    return [p.name for p in get_all_plugins() if hasattr(p, 'is_activated') and p.is_activated]


def get_all_plugin_names():
    return [p.name for p in get_all_plugins()]


def deactivate_all_plugins():
    for name in get_all_active_plugin_names():
        simplePluginManager.deactivatePluginByName(name, "bots")


def global_restart():
    python = sys.executable
    os.execl(python, python, *sys.argv)


def check_dependencies(path):
    #noinspection PyBroadException
    try:
        from pkg_resources import get_distribution

        req_path = path + os.sep + 'requirements.txt'
        if not os.path.isfile(req_path):
            logging.debug('%s has no requirements.txt file' % path)
            return None
        missing_pkg = []
        with open(req_path) as f:
            for line in f:
                stripped = line.strip()
                #noinspection PyBroadException
                try:
                    get_distribution(stripped)
                except Exception as _:
                    missing_pkg.append(stripped)
        if missing_pkg:
            return ('You need those dependencies for %s: ' % path) + ','.join(missing_pkg)
        return None
    except Exception as _:
        return 'You need to have setuptools installed for the dependency check of the plugins'

########NEW FILE########
__FILENAME__ = repos
# This is a list of known public repos for err
# Feel free to make a pull request to add yours !

KNOWN_PUBLIC_REPOS = {
    'err-timemachine': ('https://github.com/gbin/err-timemachine.git', 'Log, index and search in message history'),
    'err-gitbot': ('https://github.com/gbin/err-gitbot.git', 'a plugin that watchs your git repositories and shout in chatroom the last commits'),
    'err-dictbot': ('https://github.com/gbin/err-dictbot.git', 'a plugin that gives you the definition of a word'),
    'err-pollbot': ('https://github.com/gbin/err-pollbot.git', 'a voting plugin'),
    'err-imagebot': ('https://github.com/gbin/err-imagebot.git', 'query google image, stockphotos, xkcd, dilbert, posters ... '),
    'err-stalkerbot': ('https://github.com/gbin/err-stalkerbot.git', 'a bot that tell you the last time he saw somebody'),
    'err-codebot': ('https://github.com/gbin/err-codebot.git', 'can make the bot execute code snippet in C, CPP and Python'),
    'err-tv': ('https://github.com/gbin/err-tv.git', 'a plugin that gives you all you need to know about your favorite tv show, next airdate, status etc ...'),
    'err-weatherbot': ('https://github.com/atalyad/err-weatherbot.git', 'query the local weather'),
    'err-coderwall': ('https://github.com/gbin/err-coderwall.git', 'query users on coderwall'),
    'err-nettools': ('https://github.com/gbin/err-nettools.git', 'various network query utilities'),
    'err-time': ('https://github.com/gbin/err-time.git', 'gives the current time at a given place'),
    'err-elizabot': ('https://github.com/gbin/err-elizabot.git', 'a classic electronic shrink'),
    'err-calcbot': ('https://github.com/gbin/err-calcbot.git', 'a smart calculator, unit converter and math solver'),
    'err-pypi': ('https://github.com/gbin/err-pypi.git', 'some commands to query pypi'),
    'err-reviewboard': ('https://github.com/glenbot/err-reviewboard.git', 'Err bot that displays the latest reviews from review board'),
    'err-topgunbot': ('https://github.com/krismolendyke/err-topgunbot.git', 'An Err chatbot serving up supersonic TOP GUN lines.'),
    'err-diehardbot': ('https://github.com/krismolendyke/err-diehardbot.git', 'An Err chatbot serving up Die Hard lines during the time of miracles..'),
    'err-devops_borat': ('https://github.com/gbin/err-devops_borat.git', 'random funny quotes about software development'),
    'err-social': ('https://github.com/gbin/err-social.git', 'For the moment a Google plus bridge'),
    'err-rssfeed': ('https://github.com/atalyad/err-rssfeed.git', 'register to rss feeds and get updates in the chat.'),
    'err-translate': ('https://github.com/benvd/err-translate.git', 'Google Translate plugin for the err bot'),
    'err-tourney': ('https://github.com/gbin/err-tourney.git', 'a ranking and tournament system for err'),
    'err-music': ('https://github.com/benvd/err-music.git', 'Query lyrics, compositors etc etc ...'),
    'err-mailwatch': ('https://github.com/zoni/err-mailwatch.git', 'Watch IMAP servers for new mails'),
    'err-dnsutils': ('https://github.com/zoni/err-dnsutils.git', 'Run common DNS utils: host, dig, nslookup'),
    'err-insult': ('https://github.com/xnaveira/err-insult.git', 'Hubot insult plugin clone for Err bot'),
    'err-markovbot': ('https://github.com/MaxWagner/err-markovbot.git', 'Markov chain bot that supports db generation from url, file or string'),
    'err-faustbot': ('https://github.com/Scaatis/err-faustbot.git', "Output a random line of Goethe's \"Faust\" in sentence context (in German)."),
    'err-sedbot': ('https://github.com/gbin/err-sedbot.git', "errbot plugin for executing simple sed substitute commands"),
    'err-dnsnative': ('https://github.com/daenney/err-dnsnative.git', "Provides common DNS utilities functionality using Python libraries"),
}

########NEW FILE########
__FILENAME__ = storage
from collections import MutableMapping
import logging
import shelve

from errbot import PY2


class StoreException(Exception):
    pass


class StoreAlreadyOpenError(StoreException):
    pass


class StoreNotOpenError(StoreException):
    pass


class StoreMixin(MutableMapping):
    """
     This class handle the basic needs of bot plugins and core like loading, unloading and creating a storage
    """

    def open_storage(self, path):
        if hasattr(self, 'shelf') and self.shelf is not None:
            raise StoreAlreadyOpenError("Storage appears to be opened already")
        logging.info("Try to open db file %s" % path)
        self.shelf = shelve.DbfilenameShelf(path, protocol=2)
        logging.debug('Opened shelf of %s' % self.__class__.__name__)

    def close_storage(self):
        if not hasattr(self, 'shelf') or self.shelf is None:
            raise StoreNotOpenError("Storage does not appear to have been opened yet")
        self.shelf.close()
        self.shelf = None
        logging.debug('Closed shelf of %s' % self.__class__.__name__)

    # those are the minimal things to behave like a dictionary with the UserDict.DictMixin
    def __getitem__(self, key):
        return self.shelf.__getitem__(key)

    def __setitem__(self, key, item):
        answer = self.shelf.__setitem__(key, item)
        self.shelf.sync()
        return answer

    def __delitem__(self, key):
        answer = self.shelf.__delitem__(key)
        self.shelf.sync()
        return answer

    def keys(self):
        keys = self.shelf.keys()
        if PY2:
            keys = [key.decode('utf-8') for key in keys]
        return keys

    def __len__(self):
        return len(self.shelf)

    def __iter__(self):
        for i in self.shelf:
            yield i

########NEW FILE########
__FILENAME__ = templating
import logging
import os
from jinja2 import Environment, FileSystemLoader
from bottle import TEMPLATE_PATH

def make_templates_path(root):
    return root + os.sep + 'templates'

system_templates_path = make_templates_path(os.path.dirname(__file__))
template_path = [system_templates_path]
TEMPLATE_PATH.insert(0, system_templates_path)  # for views
env = Environment(loader=FileSystemLoader(template_path))


def tenv():
    return env


def make_templates_from_plugin_path(plugin_path):
    return make_templates_path(os.sep.join(plugin_path.split(os.sep)[:-1]))


def add_plugin_templates_path(path):
    global env
    tmpl_path = make_templates_from_plugin_path(path)
    if os.path.exists(tmpl_path):
        logging.debug("Templates directory found for this plugin [%s]" % tmpl_path)
        template_path.append(tmpl_path)  # for webhooks
        TEMPLATE_PATH.insert(0, tmpl_path)  # for webviews
        env = Environment(loader=FileSystemLoader(template_path))  # ditch and recreate a new templating environment
        return
    logging.debug("No templates directory found for this plugin [Looking for %s]" % tmpl_path)


def remove_plugin_templates_path(path):
    global env
    tmpl_path = make_templates_from_plugin_path(path)
    if tmpl_path in template_path:
        template_path.remove(tmpl_path)  # for webhooks
        TEMPLATE_PATH.remove(tmpl_path)  # for webviews
        env = Environment(loader=FileSystemLoader(template_path))  # ditch and recreate a new templating environment
########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
import logging
import inspect
import os
import re
from html import entities
import sys
import time
from xml.etree.ElementTree import tostring

PY3 = sys.version_info[0] == 3
PY2 = not PY3

PLUGINS_SUBDIR = b'plugins' if PY2 else 'plugins'


def get_sender_username(mess):
    """Extract the sender's user name from a message"""
    type = mess.getType()
    jid = mess.getFrom()
    if type == "groupchat":
        username = jid.getResource()
    elif type == "chat":
        username = jid.getNode()
    else:
        username = ""
    return username


def format_timedelta(timedelta):
    total_seconds = timedelta.seconds + (86400 * timedelta.days)
    hours, remainder = divmod(total_seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    if hours == 0 and minutes == 0:
        return '%i seconds' % seconds
    elif not hours:
        return '%i minutes' % minutes
    elif not minutes:
        return '%i hours' % hours
    else:
        return '%i hours and %i minutes' % (hours, minutes)


BAR_WIDTH = 15.0


def drawbar(value, max):
    if max:
        value_in_chr = int(round((value * BAR_WIDTH / max)))
    else:
        value_in_chr = 0
    return '[' + '' * value_in_chr + '' * int(round(BAR_WIDTH - value_in_chr)) + ']'


# Introspect to know from which plugin a command is implemented
def get_class_for_method(meth):
    for cls in inspect.getmro(type(meth.__self__)):
        if meth.__name__ in cls.__dict__:
            return cls
    return None


def human_name_for_git_url(url):
    # try to humanize the last part of the git url as much as we can
    if url.find('/') > 0:
        s = url.split('/')
    else:
        s = url.split(':')
    last_part = str(s[-1]) if s[-1] else str(s[-2])
    return last_part[:-4] if last_part.endswith('.git') else last_part


def tail(f, window=20):
    return ''.join(f.readlines()[-window:])


def which(program):
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None

INVALID_VERSION_EXCEPTION = 'version %s in not in format "x.y.z" or "x.y.z-{beta,alpha,rc1,rc2...}" for example "1.2.2"'


def version2array(version):
    vsplit = version.split('-')

    if len(vsplit) == 2:
        main, sub = vsplit
        if sub == 'alpha':
            sub_int = -1
        elif sub == 'beta':
            sub_int = 0
        elif sub.startswith('rc'):
            sub_int = int(sub[2:])
        else:
            raise ValueError(INVALID_VERSION_EXCEPTION % version)

    elif len(vsplit) == 1:
        main = vsplit[0]
        sub_int = sys.maxsize
    else:
        raise ValueError(INVALID_VERSION_EXCEPTION % version)


    response = [int(el) for el in main.split('.')]
    response.append(sub_int)

    if len(response) != 4:
        raise ValueError(INVALID_VERSION_EXCEPTION % version)

    return response


class ValidationException(Exception):
    pass


def recurse_check_structure(sample, to_check):
    sample_type = type(sample)
    to_check_type = type(to_check)

    if PY2 and to_check_type.__name__ == 'str':  # __name__ to avoid beeing touched by 3to2
        #noinspection PyUnresolvedReferences
        to_check_type = unicode
        to_check = to_check.decode()

    # Skip this check if the sample is None because it will always be something
    # other than NoneType when changed from the default. Raising ValidationException
    # would make no sense then because it would defeat the whole purpose of having
    # that key in the sample when it could only ever be None.
    if sample is not None and sample_type != to_check_type:
        raise ValidationException('%s [%s] is not the same type as %s [%s]' % (sample, sample_type, to_check, to_check_type))

    if sample_type in (list, tuple):
        for element in to_check:
            recurse_check_structure(sample[0], element)
        return

    if sample_type == dict:
        for key in sample:
            if key not in to_check:
                raise ValidationException("%s doesn't contain the key %s" % (to_check, key))
        for key in to_check:
            if key not in sample:
                raise ValidationException("%s contains an unknown key %s" % (to_check, key))
        for key in sample:
            recurse_check_structure(sample[key], to_check[key])
        return


def unescape_xml(text):
    """
    Removes HTML or XML character references and entities from a text string.
    @param text The HTML (or XML) source text.
    @return The plain text, as a Unicode string, if necessary.
    """

    def fixup(m):
        text = m.group(0)
        if text[:2] == "&#":
            # character reference
            try:
                if text[:3] == "&#x":
                    return chr(int(text[3:-1], 16))
                else:
                    return chr(int(text[2:-1]))
            except ValueError:
                pass
        else:
            # named entity
            try:
                text = chr(entities.name2codepoint[text[1:-1]])
            except KeyError:
                pass
        return text  # leave as is

    return re.sub("&#?\w+;", fixup, text)


REMOVE_EOL = re.compile(r'\n')
REINSERT_EOLS = re.compile(r'</p>|</li>|<br/>', re.I)
ZAP_TAGS = re.compile(r'<[^>]+>')


def xhtml2txt(xhtml):
    text_plain = REMOVE_EOL.sub('', xhtml)  # Ignore formatting TODO exclude pre
    text_plain = REINSERT_EOLS.sub('\n', text_plain)  # readd the \n where they probably fit best
    text_plain = ZAP_TAGS.sub('', text_plain)  # zap every tag left
    return unescape_xml(text_plain).strip()


def utf8(key):
    if type(key) == str:
        return key.encode()  # it defaults to utf-8
    return key


def mess_2_embeddablehtml(mess):
    html_content = mess.getHTML()
    if html_content is not None:
        body = html_content.find('{http://jabber.org/protocol/xhtml-im}body')
        result = ''
        for child in body.getchildren():
            result += tostring(child).decode().replace('ns0:', '')
        return result, True
    else:
        return mess.getBody(), False

def parse_jid(jid):
    if jid.find('@') != -1:
        split_jid = jid.split('@')
        node, domain = '@'.join(split_jid[:-1]), split_jid[-1]
        if domain.find('/') != -1:
            domain, resource = domain.split('/')[0:2]  # hack for IRC where you can have several slashes here
        else:
            resource = None
    else:
        node = jid
        domain = None
        resource = None

    return node, domain, resource


def RateLimited(minInterval):
    def decorate(func):
        lastTimeCalled = [0.0]

        def rateLimitedFunction(*args, **kargs):
            elapsed = time.time() - lastTimeCalled[0]
            logging.debug('Elapsed %f since last call' % elapsed)
            leftToWait = minInterval - elapsed
            if leftToWait > 0:
                logging.debug('Wait %f due to rate limiting...' % leftToWait)
                time.sleep(leftToWait)
            ret = func(*args, **kargs)
            lastTimeCalled[0] = time.time()
            return ret

        return rateLimitedFunction

    return decorate


def split_string_after(str_, n):
    """Yield chunks of length `n` from the given string"""
    for start in range(0, len(str_), n):
        yield str_[start:start+n]

########NEW FILE########
__FILENAME__ = version
# just the current version of err
# it is used for deployment on pypi AND for version checking at plugin load time
VERSION = '2.0.0'

########NEW FILE########
__FILENAME__ = run_tests
#!/usr/bin/env python
import sys
import os
from glob import glob

TRAVIS_INCOMPATIBLE = ('webhooks_tests.py',)

# Set nose verbosity level to verbose by default
os.environ['NOSE_VERBOSE'] = os.environ.get('NOSE_VERBOSE', "2")

try:
    import nose
except ImportError:
    sys.stderr.write("Tests require the 'nose' package which you are currently missing.\nYou can install nose with `pip install nose`.\n")
    sys.exit(1)

# Webhooks tests fail when run together with the other tests, but pass correctly
# when run in isolation. We work around this issue by running each set of tests
# separately. It's an ugly hack, but it works.
segments = ('tests', '*.py')
testsuites = glob(os.sep.join(segments))
testresults = []

for testsuite in testsuites:
    if os.environ.get("TRAVIS", "False") == "true" and os.path.basename(testsuite) in TRAVIS_INCOMPATIBLE:
        print("Incompatible test {} skipped".format(testsuite))
        continue
    print("\nRunning tests from {}\n".format(testsuite))
    testresults.append(nose.run(defaultTest=testsuite))

if False in testresults:
    print("\nSome tests failed to pass!")
    exit(-99)   # a test did not pass
else:
    print("\nAll tests have successfully passed")
    exit(0)  # no error

########NEW FILE########
__FILENAME__ = err
#!/usr/bin/env python

#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

import logging
from os import path, sep, getcwd, access, W_OK
from platform import system


#noinspection PyUnusedLocal
def debug(sig, frame):
    """Interrupt running process, and provide a python prompt for
    interactive debugging."""
    d = {'_frame': frame}         # Allow access to frame object.
    d.update(frame.f_globals)  # Unless shadowed by global
    d.update(frame.f_locals)

    i = code.InteractiveConsole(d)
    message = "Signal received : entering python shell.\nTraceback:\n"
    message += ''.join(traceback.format_stack(frame))
    i.interact(message)

ON_WINDOWS = system() == 'Windows'

import sys
import argparse

if not ON_WINDOWS:
    from daemonize import Daemonize
    from pwd import getpwnam
    from grp import getgrnam
    import code
    import traceback
    import signal

    signal.signal(signal.SIGUSR1, debug)  # Register handler for debugging

logging.basicConfig(format='%(levelname)s:%(name)s:%(message)s')
logger = logging.getLogger('')
logging.getLogger('yapsy').setLevel(logging.INFO)  # this one is way too verbose in debug
logging.getLogger('Rocket.Errors.ThreadPool').setLevel(logging.INFO)  # this one is way too verbose in debug
logger.setLevel(logging.INFO)



def check_config(config_path, mode):
    __import__('errbot.config-template')  # - is on purpose, it should not be imported normally ;)
    template = sys.modules['errbot.config-template']
    config_fullpath = config_path + sep + 'config.py'

    if not path.exists(config_fullpath):
        logging.error('I cannot find the file config.py in the directory %s \n(You can change this directory with the -c parameter see --help)' % config_path)
        logging.info('You can use the template %s as a base and copy it to %s. \nYou can then customize it.' % (path.dirname(template.__file__) + sep + 'config-template.py', config_path + sep))
        exit(-1)

    #noinspection PyBroadException
    try:
        try:
            # gives the opportunity to have one config per mode to simplify the debugging
            config = __import__('config_' + mode)
            sys.modules['config'] = config
        except ImportError as ie:
            if not str(ie).startswith('No module named'):
                logging.exception('Error while trying to load %s' % 'config_' + mode)
            import config

        diffs = [item for item in set(dir(template)) - set(dir(config)) if not item.startswith('_')]
        if diffs:
            logging.error('You are missing configs defined from the template :')
            for diff in diffs:
                logging.error('Missing config : %s' % diff)
            exit(-1)
    except Exception as _:
        logging.exception('I could not import your config from %s, please check the error below...' % config_fullpath)
        exit(-1)
    logging.info('Config check passed...')


if __name__ == "__main__":

    execution_dir = getcwd()

    # By default insert the execution path (useful to be able to execute err from the source tree directly without installing it
    sys.path.insert(0, execution_dir)

    parser = argparse.ArgumentParser(description='The main entry point of the XMPP bot err.')
    parser.add_argument('-c', '--config', default=None, help='Specify the directory where your config.py is (default: current working directory)')
    backend_group = parser.add_mutually_exclusive_group()
    backend_group.add_argument('-X', '--xmpp', action='store_true', help='XMPP backend [DEFAULT]')
    backend_group.add_argument('-H', '--hipchat', action='store_true', help='Hipchat backend')
    backend_group.add_argument('-C', '--campfire', action='store_true', help='campfire backend')
    backend_group.add_argument('-I', '--irc', action='store_true', help='IRC backend')
    backend_group.add_argument('-T', '--text', action='store_true', help='locale text debug backend')
    backend_group.add_argument('-G', '--graphic', action='store_true', help='local graphical debug mode backend')
    backend_group.add_argument('-N', '--null', action='store_true', help='no backend')

    if not ON_WINDOWS:
        option_group = parser.add_argument_group('arguments to run it as a Daemon')
        option_group.add_argument('-d', '--daemon', action='store_true', help='Detach the process from the console')
        option_group.add_argument('-p', '--pidfile', default=None, help='Specify the pid file for the daemon (default: current bot data directory)')

    args = vars(parser.parse_args())  # create a dictionary of args
    config_path = args['config']
    # setup the environment to be able to import the config.py
    if config_path:
        sys.path.insert(0, config_path)  # appends the current config in order to find config.py
    else:
        config_path = execution_dir
    filtered_mode = [mname for mname in ('text', 'graphic', 'campfire', 'hipchat', 'irc', 'xmpp', 'null') if args[mname]]
    mode = filtered_mode[0] if filtered_mode else 'xmpp'  # default value

    check_config(config_path, mode)  # check if everything is ok before attempting to start

    def text():
        from errbot.backends.text import TextBackend
        return TextBackend

    def graphic():
        from errbot.backends.graphic import GraphicBackend
        return GraphicBackend

    def campfire():
        from errbot.backends.campfire import CampfireBackend
        return CampfireBackend

    def hipchat():
        #from errbot.backends.jabber import JabberBot
        #return JabberBot
        from errbot.backends.hipchat import HipchatBackend
        return HipchatBackend

    def irc():
        from errbot.backends.irc import IRCBackend
        return IRCBackend

    def xmpp():
        from errbot.backends.xmpp import XMPPBackend
        return XMPPBackend


    def null():
        from errbot.backends.null import NullBackend
        return NullBackend

    bot_class = locals()[mode]()
    # Check if at least we can start to log something before trying to start
    # the bot (esp. daemonize it).
    from config import BOT_DATA_DIR
    logging.info("Checking for '%s'..." % BOT_DATA_DIR)
    if not path.exists(BOT_DATA_DIR):
        raise Exception("The data directory '%s' for the bot does not exist" % BOT_DATA_DIR)
    if not access(BOT_DATA_DIR, W_OK):
        raise Exception("The data directory '%s' should be writable for the bot" % BOT_DATA_DIR)

    if (not ON_WINDOWS) and args['daemon']:
        if args['text']:
            raise Exception('You cannot run in text and daemon mode at the same time')

        if args['pidfile']:
            pid = args['pidfile']
        else:
            pid = BOT_DATA_DIR + sep + 'err.pid'

        from errbot.pid import PidFile

        pidfile = PidFile(pid)

        #noinspection PyBroadException
        try:
            def action():
                from errbot.main import main
                main(bot_class, logger)
            daemon = Daemonize(app="err", pid=pid, action=action)
            daemon.start()
        except Exception as _:
            logging.exception('Failed to daemonize the process')
        exit(0)
    from errbot.main import main
    main(bot_class, logger)
    logging.info('Process exiting')

########NEW FILE########
__FILENAME__ = base_backend_tests
# coding=utf-8
import sys
import logging
from tempfile import mkdtemp
from os.path import sep

__import__('errbot.config-template')
config_module = sys.modules['errbot.config-template']
sys.modules['config'] = config_module

tempdir = mkdtemp()
config_module.BOT_DATA_DIR = tempdir
config_module.BOT_LOG_FILE = tempdir + sep + 'log.txt'
config_module.BOT_EXTRA_PLUGIN_DIR = []
config_module.BOT_LOG_LEVEL = logging.DEBUG

import unittest
import os
import re
from queue import Queue, Empty
from mock import patch
from errbot.backends.base import Identifier, Backend, Message
from errbot.backends.base import build_message, build_text_html_message_pair
from errbot import botcmd, re_botcmd, templating
from errbot.utils import mess_2_embeddablehtml

LONG_TEXT_STRING = "This is a relatively long line of output, but I am repeated multiple times.\n"

class DummyBackend(Backend):
    outgoing_message_queue = Queue()
    jid = 'err@localhost/err'

    def build_message(self, text):
        return build_message(text, Message)

    def send_message(self, mess):
        self.outgoing_message_queue.put(mess)

    def pop_message(self, timeout=3, block=True):
        return self.outgoing_message_queue.get(timeout=timeout, block=block)

    @botcmd
    def command(self, mess, args):
        return "Regular command"

    @re_botcmd(pattern=r'^regex command with prefix$', prefixed=True)
    def regex_command_with_prefix(self, mess, match):
        return "Regex command"

    @re_botcmd(pattern=r'^regex command without prefix$', prefixed=False)
    def regex_command_without_prefix(self, mess, match):
        return "Regex command"

    @re_botcmd(pattern=r'regex command with capture group: (?P<capture>.*)', prefixed=False)
    def regex_command_with_capture_group(self, mess, match):
        return match.group('capture')

    @re_botcmd(pattern=r'matched by two commands')
    def double_regex_command_one(self, mess, match):
        return "one"

    @re_botcmd(pattern=r'matched by two commands', flags=re.IGNORECASE)
    def double_regex_command_two(self, mess, match):
        return "two"

    @botcmd
    def return_args_as_str(self, mess, args):
        return "".join(args)

    @botcmd(template='args_as_html')
    def return_args_as_html(self, mess, args):
        return {'args': args}

    @botcmd
    def raises_exception(self, mess, args):
        raise Exception("Kaboom!")

    @botcmd
    def yield_args_as_str(self, mess, args):
        for arg in args:
            yield arg

    @botcmd(template='args_as_html')
    def yield_args_as_html(self, mess, args):
        for arg in args:
            yield {'args': [arg]}

    @botcmd
    def yields_str_then_raises_exception(self, mess, args):
        yield "foobar"
        raise Exception("Kaboom!")

    @botcmd
    def return_long_output(self, mess, args):
        return LONG_TEXT_STRING * 3

    @botcmd
    def yield_long_output(self, mess, args):
        for i in range(2):
            yield LONG_TEXT_STRING * 3

    @property
    def mode(self):
        return "Dummy"

    def __init__(self):
        super(DummyBackend, self).__init__()
        self.inject_commands_from(self)


class TestBase(unittest.TestCase):
    def setUp(self):
        self.dummy = DummyBackend()

    def test_identifier_parsing(self):
        id1 = Identifier(jid="gbin@gootz.net/toto")
        self.assertEqual(id1.getNode(), "gbin")
        self.assertEqual(id1.getDomain(), "gootz.net")
        self.assertEqual(id1.getResource(), "toto")

        id2 = Identifier(jid="gbin@gootz.net")
        self.assertEqual(id2.getNode(), "gbin")
        self.assertEqual(id2.getDomain(), "gootz.net")
        self.assertIsNone(id2.getResource())

    def test_identifier_matching(self):
        id1 = Identifier(jid="gbin@gootz.net/toto")
        id2 = Identifier(jid="gbin@gootz.net/titi")
        id3 = Identifier(jid="gbin@giitz.net/titi")
        self.assertTrue(id1.bareMatch(id2))
        self.assertFalse(id2.bareMatch(id3))

    def test_identifier_stripping(self):
        id1 = Identifier(jid="gbin@gootz.net/toto")
        self.assertEqual(id1.getStripped(), "gbin@gootz.net")

    def test_identifier_str_rep(self):
        self.assertEqual(str(Identifier(jid="gbin@gootz.net/toto")), "gbin@gootz.net/toto")
        self.assertEqual(str(Identifier(jid="gbin@gootz.net")), "gbin@gootz.net")

    def test_identifier_unicode_rep(self):
        self.assertEqual(str(Identifier(jid="gbin@gootz.net/")), "gbin@gootz.net/")

    def test_xhtmlparsing_and_textify(self):
        text_plain, node = build_text_html_message_pair("<html><body>Message</body></html>")
        self.assertEqual(text_plain, "Message")
        self.assertEqual(node.tag, "html")
        self.assertEqual(node.getchildren()[0].tag, "body")
        self.assertEqual(node.getchildren()[0].text, 'Message')

    def test_identifier_double_at_parsing(self):
        id1 = Identifier(jid="gbin@titi.net@gootz.net/toto")
        self.assertEqual(id1.getNode(), "gbin@titi.net")
        self.assertEqual(id1.getDomain(), "gootz.net")
        self.assertEqual(id1.getResource(), "toto")

    def test_buildreply(self):
        dummy = self.dummy

        m = dummy.build_message("Content")
        m.setFrom("from@fromdomain.net/fromresource")
        m.setTo("to@todomain.net/toresource")
        resp = dummy.build_reply(m, "Response")

        self.assertEqual(str(resp.getTo()), "from@fromdomain.net/fromresource")
        self.assertEqual(str(resp.getFrom()), "err@localhost/err")
        self.assertEqual(str(resp.getBody()), "Response")


class TestExecuteAndSend(unittest.TestCase):
    def setUp(self):
        self.dummy = DummyBackend()
        self.example_message = self.dummy.build_message("some_message")
        self.example_message.setFrom("noterr@localhost/resource")
        self.example_message.setTo("err@localhost/resource")

        assets_path = os.path.dirname(__file__) + os.sep + "assets"
        templating.template_path.append(templating.make_templates_path(assets_path))
        templating.env = templating.Environment(loader=templating.FileSystemLoader(templating.template_path))

    def test_commands_can_return_string(self):
        dummy = self.dummy
        m = self.example_message

        dummy._execute_and_send(cmd='return_args_as_str', args=['foo', 'bar'], match=None, mess=m, jid='noterr@localhost', template_name=dummy.return_args_as_str._err_command_template)
        self.assertEqual("foobar", dummy.pop_message().getBody())

    def test_commands_can_return_html(self):
        dummy = self.dummy
        m = self.example_message

        dummy._execute_and_send(cmd='return_args_as_html', args=['foo', 'bar'], match=None, mess=m, jid='noterr@localhost', template_name=dummy.return_args_as_html._err_command_template)
        response = dummy.pop_message()
        self.assertEqual("foobar", response.getBody())
        self.assertEqual('<strong xmlns:ns0="http://jabber.org/protocol/xhtml-im">foo</strong>'
                         '<em xmlns:ns0="http://jabber.org/protocol/xhtml-im">bar</em>\n\n',
                         mess_2_embeddablehtml(response)[0])

    def test_exception_is_caught_and_shows_error_message(self):
        dummy = self.dummy
        m = self.example_message

        dummy._execute_and_send(cmd='raises_exception', args=[], match=None, mess=m, jid='noterr@localhost', template_name=dummy.raises_exception._err_command_template)
        self.assertIn(dummy.MSG_ERROR_OCCURRED, dummy.pop_message().getBody())

        dummy._execute_and_send(cmd='yields_str_then_raises_exception', args=[], match=None, mess=m, jid='noterr@localhost', template_name=dummy.yields_str_then_raises_exception._err_command_template)
        self.assertEqual("foobar", dummy.pop_message().getBody())
        self.assertIn(dummy.MSG_ERROR_OCCURRED, dummy.pop_message().getBody())

    def test_commands_can_yield_strings(self):
        dummy = self.dummy
        m = self.example_message

        dummy._execute_and_send(cmd='yield_args_as_str', args=['foo', 'bar'], match=None, mess=m, jid='noterr@localhost', template_name=dummy.yield_args_as_str._err_command_template)
        self.assertEqual("foo", dummy.pop_message().getBody())
        self.assertEqual("bar", dummy.pop_message().getBody())

    def test_commands_can_yield_html(self):
        dummy = self.dummy
        m = self.example_message

        dummy._execute_and_send(cmd='yield_args_as_html', args=['foo', 'bar'], match=None, mess=m, jid='noterr@localhost', template_name=dummy.yield_args_as_html._err_command_template)
        response1 = dummy.pop_message()
        response2 = dummy.pop_message()
        self.assertEqual("foo", response1.getBody())
        self.assertEqual('<strong xmlns:ns0="http://jabber.org/protocol/xhtml-im">foo</strong>\n\n',
                         mess_2_embeddablehtml(response1)[0])
        self.assertEqual("bar", response2.getBody())
        self.assertEqual('<strong xmlns:ns0="http://jabber.org/protocol/xhtml-im">bar</strong>\n\n',
                         mess_2_embeddablehtml(response2)[0])

    def test_output_longer_than_max_message_size_is_split_into_multiple_messages_when_returned(self):
        dummy = self.dummy
        m = self.example_message
        self.dummy.MESSAGE_SIZE_LIMIT = len(LONG_TEXT_STRING)

        dummy._execute_and_send(cmd='return_long_output', args=['foo', 'bar'], match=None, mess=m, jid='noterr@localhost', template_name=dummy.return_long_output._err_command_template)
        for i in range(3):  # return_long_output outputs a string that's 3x longer than the size limit
            self.assertEqual(LONG_TEXT_STRING, dummy.pop_message().getBody())
        self.assertRaises(Empty, dummy.pop_message, *[], **{'block': False})

    def test_output_longer_than_max_message_size_is_split_into_multiple_messages_when_yielded(self):
        dummy = self.dummy
        m = self.example_message
        self.dummy.MESSAGE_SIZE_LIMIT = len(LONG_TEXT_STRING)

        dummy._execute_and_send(cmd='yield_long_output', args=['foo', 'bar'], match=None, mess=m, jid='noterr@localhost', template_name=dummy.yield_long_output._err_command_template)
        for i in range(6):  # yields_long_output yields 2 strings that are 3x longer than the size limit
            self.assertEqual(LONG_TEXT_STRING, dummy.pop_message().getBody())
        self.assertRaises(Empty, dummy.pop_message, *[], **{'block': False})


class BotCmds(unittest.TestCase):
    def setUp(self):
        self.dummy = DummyBackend()

    def makemessage(self, message, from_="noterr@localhost/resource", to="noterr@localhost/resource", type="chat"):
        m = self.dummy.build_message(message)
        m.setFrom(from_)
        m.setTo(to)
        m.setType(type)
        return m

    def test_inject_skips_methods_without_botcmd_decorator(self):
        self.assertTrue('build_message' not in self.dummy.commands)

    def test_inject_and_remove_botcmd(self):
        self.assertTrue('command' in self.dummy.commands)
        self.dummy.remove_commands_from(self.dummy)
        self.assertFalse(len(self.dummy.commands))

    def test_inject_and_remove_re_botcmd(self):
        self.assertTrue('regex_command_with_prefix' in self.dummy.re_commands)
        self.dummy.remove_commands_from(self.dummy)
        self.assertFalse(len(self.dummy.re_commands))

    def test_callback_message(self):
        self.dummy.callback_message(None, self.makemessage("!return_args_as_str one two"))
        self.assertEquals("one two", self.dummy.pop_message().getBody())

    @patch('errbot.backends.base.BOT_PREFIX_OPTIONAL_ON_CHAT', new=True)
    def test_callback_message_with_prefix_optional(self):
        m = self.makemessage("return_args_as_str one two")
        self.dummy.callback_message(None, m)
        self.assertEquals("one two", self.dummy.pop_message().getBody())

        # Groupchat should still require the prefix
        m.setType("groupchat")
        self.dummy.callback_message(None, m)
        self.assertRaises(Empty, self.dummy.pop_message, *[], **{'block': False})

        m = self.makemessage("!return_args_as_str one two", type="groupchat")
        self.dummy.callback_message(None, m)
        self.assertEquals("one two", self.dummy.pop_message().getBody())

    @patch('errbot.backends.base.BOT_ALT_PREFIXES', new=('Err',))
    @patch('errbot.backends.base.BOT_ALT_PREFIX_SEPARATORS', new=(',', ';'))
    def test_callback_message_with_bot_alt_prefixes(self):
        self.dummy = DummyBackend()
        self.dummy.callback_message(None, self.makemessage("Err return_args_as_str one two"))
        self.assertEquals("one two", self.dummy.pop_message().getBody())
        self.dummy.callback_message(None, self.makemessage("Err, return_args_as_str one two"))
        self.assertEquals("one two", self.dummy.pop_message().getBody())

    def test_callback_message_with_re_botcmd(self):
        self.dummy.callback_message(None, self.makemessage("!regex command with prefix"))
        self.assertEquals("Regex command", self.dummy.pop_message().getBody())
        self.dummy.callback_message(None, self.makemessage("regex command without prefix"))
        self.assertEquals("Regex command", self.dummy.pop_message().getBody())
        self.dummy.callback_message(None, self.makemessage("!regex command with capture group: Captured text"))
        self.assertEquals("Captured text", self.dummy.pop_message().getBody())
        self.dummy.callback_message(None, self.makemessage("regex command with capture group: Captured text"))
        self.assertEquals("Captured text", self.dummy.pop_message().getBody())
        self.dummy.callback_message(None, self.makemessage("This command also allows extra text in front - regex command with capture group: Captured text"))
        self.assertEquals("Captured text", self.dummy.pop_message().getBody())

    @patch('errbot.backends.base.BOT_ALT_PREFIXES', new=('Err',))
    @patch('errbot.backends.base.BOT_ALT_PREFIX_SEPARATORS', new=(',', ';'))
    def test_callback_message_with_re_botcmd_and_alt_prefixes(self):
        self.dummy = DummyBackend()
        self.dummy.callback_message(None, self.makemessage("!regex command with prefix"))
        self.assertEquals("Regex command", self.dummy.pop_message().getBody())
        self.dummy.callback_message(None, self.makemessage("Err regex command with prefix"))
        self.assertEquals("Regex command", self.dummy.pop_message().getBody())
        self.dummy.callback_message(None, self.makemessage("Err, regex command with prefix"))
        self.assertEquals("Regex command", self.dummy.pop_message().getBody())
        self.dummy.callback_message(None, self.makemessage("regex command without prefix"))
        self.assertEquals("Regex command", self.dummy.pop_message().getBody())
        self.dummy.callback_message(None, self.makemessage("!regex command with capture group: Captured text"))
        self.assertEquals("Captured text", self.dummy.pop_message().getBody())
        self.dummy.callback_message(None, self.makemessage("regex command with capture group: Captured text"))
        self.assertEquals("Captured text", self.dummy.pop_message().getBody())
        self.dummy.callback_message(None, self.makemessage("This command also allows extra text in front - regex command with capture group: Captured text"))
        self.assertEquals("Captured text", self.dummy.pop_message().getBody())
        self.dummy.callback_message(None, self.makemessage("Err, regex command with capture group: Captured text"))
        self.assertEquals("Captured text", self.dummy.pop_message().getBody())
        self.dummy.callback_message(None, self.makemessage("Err This command also allows extra text in front - regex command with capture group: Captured text"))
        self.assertEquals("Captured text", self.dummy.pop_message().getBody())

    def test_regex_commands_can_overlap(self):
        self.dummy.callback_message(None, self.makemessage("!matched by two commands"))
        response = (self.dummy.pop_message().getBody(), self.dummy.pop_message().getBody())
        self.assertTrue(response == ("one", "two") or response == ("two", "one"))

    def test_regex_commands_allow_passing_re_flags(self):
        self.dummy.callback_message(None, self.makemessage("!MaTcHeD By TwO cOmMaNdS"))
        self.assertEquals("two", self.dummy.pop_message().getBody())
        self.assertRaises(Empty, self.dummy.pop_message, **{'timeout': 1})

    def test_access_controls(self):
        tests = [
            dict(
                message=self.makemessage("!command"),
                acl={},
                acl_default={},
                expected_response="Regular command"
            ),
            dict(
                message=self.makemessage("!regex command with prefix"),
                acl={},
                acl_default={},
                expected_response="Regex command"
            ),
            dict(
                message=self.makemessage("!command"),
                acl={},
                acl_default={'allowmuc': False, 'allowprivate': False},
                expected_response="You're not allowed to access this command via private message to me"
            ),
            dict(
                message=self.makemessage("regex command without prefix"),
                acl={},
                acl_default={'allowmuc': False, 'allowprivate': False},
                expected_response="You're not allowed to access this command via private message to me"
            ),
            dict(
                message=self.makemessage("!command"),
                acl={},
                acl_default={'allowmuc': True, 'allowprivate': False},
                expected_response="You're not allowed to access this command via private message to me"
            ),
            dict(
                message=self.makemessage("!command"),
                acl={},
                acl_default={'allowmuc': False, 'allowprivate': True},
                expected_response="Regular command"
            ),
            dict(
                message=self.makemessage("!command"),
                acl={'command': {'allowprivate': True}},
                acl_default={'allowmuc': False, 'allowprivate': False},
                expected_response="Regular command"
            ),
            dict(
                message=self.makemessage("!command", type="groupchat", from_="room@localhost/err"),
                acl={'command': {'allowrooms': ('room@localhost',)}},
                acl_default={},
                expected_response="Regular command"
            ),
            dict(
                message=self.makemessage("!command", type="groupchat", from_="room@localhost/err"),
                acl={'command': {'allowrooms': ('anotherroom@localhost',)}},
                acl_default={},
                expected_response="You're not allowed to access this command from this room",
            ),
            dict(
                message=self.makemessage("!command", type="groupchat", from_="room@localhost/err"),
                acl={'command': {'denyrooms': ('room@localhost',)}},
                acl_default={},
                expected_response="You're not allowed to access this command from this room",
            ),
            dict(
                message=self.makemessage("!command", type="groupchat", from_="room@localhost/err"),
                acl={'command': {'denyrooms': ('anotherroom@localhost',)}},
                acl_default={},
                expected_response="Regular command"
            ),
        ]

        for test in tests:
            with patch.multiple(
                'errbot.backends.base',
                ACCESS_CONTROLS_DEFAULT=test['acl_default'],
                ACCESS_CONTROLS=test['acl']
            ):
                logger = logging.getLogger(__name__)
                logger.info("** message: {}".format(test['message'].getBody()))
                logger.info("** acl: {!r}".format(test['acl']))
                logger.info("** acl_default: {!r}".format(test['acl_default']))
                self.dummy.callback_message(None, test['message'])
                self.assertEqual(
                    test['expected_response'],
                    self.dummy.pop_message().getBody()
                )

########NEW FILE########
__FILENAME__ = commands_tests
# coding=utf-8
from ast import literal_eval

# create a mock configuration
from errbot.backends.test import FullStackTest, pushMessage, popMessage
from queue import Empty

class TestCommands(FullStackTest):

    def test_root_help(self):
        pushMessage('!help')
        self.assertIn('Available help', popMessage())

    def test_help(self):
        pushMessage('!help ErrBot')
        response = popMessage()
        self.assertIn('Available commands for ErrBot', response)
        self.assertIn('!about', response)

        pushMessage('!help beurk')
        self.assertEqual('That command is not defined.', popMessage())

    def test_about(self):
        pushMessage('!about')
        self.assertIn('Err version', popMessage())

    def test_uptime(self):
        pushMessage('!uptime')
        self.assertIn('I\'ve been up for', popMessage())

    def test_status(self):
        pushMessage('!status')
        self.assertIn('Yes I am alive', popMessage())

    def test_config_cycle(self):
        # test the full configuration cycle help, get set and export, import
        pushMessage('!zap configs')
        self.assertIn('Done', popMessage())

        pushMessage('!config Webserver')
        m = popMessage()
        self.assertIn('Default configuration for this plugin (you can copy and paste this directly as a command)', m)
        self.assertNotIn('Current configuration', m)

        pushMessage("!config Webserver {'HOST': 'localhost', 'PORT': 3141, 'SSL':  None}")
        self.assertIn('Plugin configuration done.', popMessage())

        pushMessage('!config Webserver')
        m = popMessage()
        self.assertIn('Current configuration', m)
        self.assertIn('localhost', m)

        pushMessage('!export configs')
        configs = popMessage()
        self.assertIn('localhost', configs)
        obj = literal_eval(configs)  # be sure it is parseable
        obj['Webserver']['HOST'] = 'localhost'

        pushMessage('!import configs ' + repr(obj))
        self.assertIn('Import is done correctly', popMessage())

        pushMessage('!config Webserver')
        self.assertIn('localhost', popMessage())

    def test_apropos(self):
        pushMessage('!apropos about')
        self.assertIn('!about: Returns some', popMessage())

    def test_logtail(self):
        pushMessage('!log tail')
        self.assertIn('DEBUG', popMessage())

    def test_history(self):
        from errbot.holder import bot

        pushMessage('!uptime')
        popMessage()
        pushMessage('!history')
        self.assertIn('uptime', popMessage())

        orig_sender = bot.sender
        try:
            # Pretend to be someone else. History should be empty
            bot.sender = 'non_default_person@localhost'
            pushMessage('!history')
            self.assertRaises(Empty, popMessage, block=False)
            pushMessage('!echo should be seperate history')
            popMessage()
            pushMessage('!history')
            self.assertIn('should be seperate history', popMessage())
        finally:
            bot.sender = orig_sender
        # Pretend to be the original person again. History should still contain uptime
        pushMessage('!history')
        self.assertIn('uptime', popMessage())

    def test_plugin_cycle(self):
        pushMessage('!repos install git://github.com/gbin/err-helloworld.git')
        self.assertIn('err-helloworld', popMessage())
        self.assertIn('reload', popMessage())

        pushMessage('!repos export')  # should appear in the export
        self.assertEqual("{'err-helloworld': 'git://github.com/gbin/err-helloworld.git'}", popMessage())

        pushMessage('!help hello')  # should appear in the help
        self.assertEqual("this command says hello", popMessage())

        pushMessage('!hello')  # should respond
        self.assertEqual('Hello World !', popMessage())

        pushMessage('!reload HelloWorld')
        self.assertEqual('Plugin HelloWorld deactivated', popMessage())
        self.assertEqual('Plugin HelloWorld activated', popMessage())

        pushMessage('!hello')  # should still respond
        self.assertEqual('Hello World !', popMessage())

        pushMessage('!blacklist HelloWorld')
        self.assertEqual('Plugin HelloWorld is now blacklisted', popMessage())
        pushMessage('!unload HelloWorld')
        self.assertEqual('Plugin HelloWorld deactivated', popMessage())

        pushMessage('!hello')  # should not respond
        self.assertIn('Command "hello" not found', popMessage())

        pushMessage('!unblacklist HelloWorld')
        self.assertEqual('Plugin HelloWorld removed from blacklist', popMessage())
        pushMessage('!load HelloWorld')
        self.assertEqual('Plugin HelloWorld activated', popMessage())

        pushMessage('!hello')  # should respond back
        self.assertEqual('Hello World !', popMessage())

        pushMessage('!repos uninstall err-helloworld')
        self.assertEqual('/me is unloading plugin HelloWorld', popMessage())
        self.assertEqual('Plugins unloaded and repo err-helloworld removed', popMessage())

        pushMessage('!hello')  # should not respond
        self.assertIn('Command "hello" not found', popMessage())

    def test_encoding_preservation(self):
        pushMessage('!echo ')
        self.assertEquals('', popMessage())

    def test_webserver_webhook_test(self):
        self.assertCommand("!webhook test /echo/ toto", 'Status code : 200')

    def test_load_reload_and_unload(self):
        for command in ('load', 'reload', 'unload'):
            pushMessage("!{}".format(command))
            m = popMessage()
            self.assertIn('Please tell me which of the following plugins to reload', m)
            self.assertIn('ChatRoom', m)

            pushMessage('!{} nosuchplugin'.format(command))
            m = popMessage()
            self.assertIn("nosuchplugin isn't a valid plugin name. The current plugins are", m)
            self.assertIn('ChatRoom', m)

        pushMessage('!reload ChatRoom')
        self.assertEqual('Plugin ChatRoom deactivated', popMessage())
        self.assertEqual('Plugin ChatRoom activated', popMessage())

        pushMessage("!status")
        self.assertIn("[L] ChatRoom", popMessage())

        pushMessage('!unload ChatRoom')
        self.assertEqual('Plugin ChatRoom deactivated', popMessage())

        pushMessage("!status")
        self.assertIn("[U] ChatRoom", popMessage())

        pushMessage('!unload ChatRoom')
        self.assertEqual('ChatRoom is not currently loaded', popMessage())

        pushMessage('!load ChatRoom')
        self.assertEqual('Plugin ChatRoom activated', popMessage())

        pushMessage("!status")
        self.assertIn("[L] ChatRoom", popMessage())

        pushMessage('!load ChatRoom')
        self.assertEqual('ChatRoom is already loaded', popMessage())

        pushMessage('!unload ChatRoom')
        self.assertEqual('Plugin ChatRoom deactivated', popMessage())
        pushMessage('!reload ChatRoom')
        self.assertEqual('Plugin ChatRoom not in active list', popMessage())
        self.assertEqual('Plugin ChatRoom activated', popMessage())

        pushMessage('!blacklist ChatRoom')
        self.assertEqual("Plugin ChatRoom is now blacklisted", popMessage())

        pushMessage("!status")
        self.assertIn("[B,L] ChatRoom", popMessage())

        # Needed else configuration for this plugin gets saved which screws up
        # other tests
        pushMessage('!unblacklist ChatRoom')
        popMessage()

    def test_unblacklist_and_blacklist(self):
        pushMessage('!unblacklist nosuchplugin')
        m = popMessage()
        self.assertIn("nosuchplugin isn't a valid plugin name. The current plugins are", m)
        self.assertIn('ChatRoom', m)

        pushMessage('!blacklist nosuchplugin')
        m = popMessage()
        self.assertIn("nosuchplugin isn't a valid plugin name. The current plugins are", m)
        self.assertIn('ChatRoom', m)

        pushMessage('!blacklist ChatRoom')
        self.assertEqual("Plugin ChatRoom is now blacklisted", popMessage())

        pushMessage('!blacklist ChatRoom')
        self.assertEqual("Plugin ChatRoom is already blacklisted", popMessage())

        pushMessage("!status")
        self.assertIn("[B,L] ChatRoom", popMessage())

        pushMessage('!unblacklist ChatRoom')
        self.assertEqual('Plugin ChatRoom removed from blacklist', popMessage())

        pushMessage('!unblacklist ChatRoom')
        self.assertEqual('Plugin ChatRoom is not blacklisted', popMessage())

        pushMessage("!status")
        self.assertIn("[L] ChatRoom", popMessage())


########NEW FILE########
__FILENAME__ = plugin_management_tests
import os
import unittest
from errbot.plugin_manager import check_dependencies, get_builtins, BUILTIN


class TestPluginManagement(unittest.TestCase):
    def test_check_dependencies(self):
        response = check_dependencies(str(os.path.dirname(__file__)) + os.path.sep + 'assets')
        self.assertIn('impossible_requirement', response)

    def test_builtin(self):
        self.assertEquals(get_builtins(None), [BUILTIN])
        self.assertEquals(get_builtins('toto'), [BUILTIN, 'toto'])
        self.assertEquals(get_builtins(['titi', 'tutu']), [BUILTIN, 'titi', 'tutu'])

########NEW FILE########
__FILENAME__ = utils_tests
# coding=utf-8
from datetime import timedelta
import unittest
from nose.tools import raises
from errbot.utils import *
from errbot.storage import StoreMixin

vc = lambda v1, v2: version2array(v1) < version2array(v2)


def test_version_check():
    yield vc, '2.0.0', '2.0.1'
    yield vc, '2.0.0', '2.1.0'
    yield vc, '2.0.0', '3.0.0'
    yield vc, '2.0.0-alpha', '2.0.0-beta'
    yield vc, '2.0.0-beta', '2.0.0-rc1'
    yield vc, '2.0.0-rc1', '2.0.0-rc2'
    yield vc, '2.0.0-rc2', '2.0.0-rc3'
    yield vc, '2.0.0-rc2', '2.0.0'
    yield vc, '2.0.0-beta', '2.0.1'


def test_version_check_negative():
    raises(ValueError)(version2array)('1.2.3.4',)
    raises(ValueError)(version2array)('1.2',)
    raises(ValueError)(version2array)('1.2.-beta',)
    raises(ValueError)(version2array)('1.2.3-toto',)
    raises(ValueError)(version2array)('1.2.3-rc',)

class TestUtils(unittest.TestCase):
    def test_formattimedelta(self):
        td = timedelta(0, 60 * 60 + 13 * 60)
        self.assertEqual('1 hours and 13 minutes', format_timedelta(td))

    def test_drawbar(self):
        self.assertEqual(drawbar(5, 10), '[]')
        self.assertEqual(drawbar(0, 10), '[]')
        self.assertEqual(drawbar(10, 10), '[]')

    def unescape_test(self):
        self.assertEqual(unescape_xml('&#32;'), ' ')

    def test_storage(self):
        class MyPersistentClass(StoreMixin):
            pass

        from config import BOT_DATA_DIR
        key = b'test' if PY2 else 'test'

        persistent_object = MyPersistentClass()
        persistent_object.open_storage(BOT_DATA_DIR + os.path.sep + 'test.db')
        persistent_object[key] = ' value'
        self.assertEquals(persistent_object[key], ' value')
        self.assertIn(key, persistent_object)
        del persistent_object[key]
        self.assertNotIn(key, persistent_object)
        self.assertEquals(len(persistent_object), 0)

    @raises(SystemExit)
    def test_pid(self):
        from platform import system
        from config import BOT_DATA_DIR

        if system() != 'Windows':
            pid_path = BOT_DATA_DIR + os.path.sep + 'err_test.pid'

            from errbot.pid import PidFile

            pidfile1 = PidFile(pid_path)
            pidfile2 = PidFile(pid_path)

            with pidfile1:
                logging.debug('ok locked the pid')
                with pidfile2:
                    logging.fatal('Should never execute')

    def test_recurse_check_structure_valid(self):
        sample = dict(string="Foobar", list=["Foo", "Bar"], dict={'foo': "Bar"}, none=None, true=True, false=False)
        to_check = dict(string="Foobar", list=["Foo", "Bar", "Bas"], dict={'foo': "Bar"}, none=None, true=True, false=False)
        recurse_check_structure(sample, to_check)

    @raises(ValidationException)
    def test_recurse_check_structure_missingitem(self):
        sample = dict(string="Foobar", list=["Foo", "Bar"], dict={'foo': "Bar"}, none=None, true=True, false=False)
        to_check = dict(string="Foobar", list=["Foo", "Bar"], dict={'foo': "Bar"}, none=None, true=True)
        recurse_check_structure(sample, to_check)

    @raises(ValidationException)
    def test_recurse_check_structure_extrasubitem(self):
        sample = dict(string="Foobar", list=["Foo", "Bar"], dict={'foo': "Bar"}, none=None, true=True, false=False)
        to_check = dict(string="Foobar", list=["Foo", "Bar", "Bas"], dict={'foo': "Bar", 'Bar': "Foo"}, none=None, true=True, false=False)
        recurse_check_structure(sample, to_check)

    @raises(ValidationException)
    def test_recurse_check_structure_missingsubitem(self):
        sample = dict(string="Foobar", list=["Foo", "Bar"], dict={'foo': "Bar"}, none=None, true=True, false=False)
        to_check = dict(string="Foobar", list=["Foo", "Bar", "Bas"], dict={}, none=None, true=True, false=False)
        recurse_check_structure(sample, to_check)

    @raises(ValidationException)
    def test_recurse_check_structure_wrongtype_1(self):
        sample = dict(string="Foobar", list=["Foo", "Bar"], dict={'foo': "Bar"}, none=None, true=True, false=False)
        to_check = dict(string=None, list=["Foo", "Bar"], dict={'foo': "Bar"}, none=None, true=True, false=False)
        recurse_check_structure(sample, to_check)

    @raises(ValidationException)
    def test_recurse_check_structure_wrongtype_2(self):
        sample = dict(string="Foobar", list=["Foo", "Bar"], dict={'foo': "Bar"}, none=None, true=True, false=False)
        to_check = dict(string="Foobar", list={'foo': "Bar"}, dict={'foo': "Bar"}, none=None, true=True, false=False)
        recurse_check_structure(sample, to_check)

    @raises(ValidationException)
    def test_recurse_check_structure_wrongtype_3(self):
        sample = dict(string="Foobar", list=["Foo", "Bar"], dict={'foo': "Bar"}, none=None, true=True, false=False)
        to_check = dict(string="Foobar", list=["Foo", "Bar"], dict=["Foo", "Bar"], none=None, true=True, false=False)
        recurse_check_structure(sample, to_check)

    def test_split_string_after_returns_original_string_when_chunksize_equals_string_size(self):
        str_ = 'foobar2000' * 2
        splitter = split_string_after(str_, len(str_))
        split = [chunk for chunk in splitter]
        self.assertEqual([str_], split)

    def test_split_string_after_returns_original_string_when_chunksize_equals_string_size_plus_one(self):
        str_ = 'foobar2000' * 2
        splitter = split_string_after(str_, len(str_) + 1)
        split = [chunk for chunk in splitter]
        self.assertEqual([str_], split)

    def test_split_string_after_returns_two_chunks_when_chunksize_equals_string_size_minus_one(self):
        str_ = 'foobar2000' * 2
        splitter = split_string_after(str_, len(str_) - 1)
        split = [chunk for chunk in splitter]
        self.assertEqual(['foobar2000foobar200', '0'], split)

    def test_split_string_after_returns_two_chunks_when_chunksize_equals_half_length_of_string(self):
        str_ = 'foobar2000' * 2
        splitter = split_string_after(str_, int(len(str_) / 2))
        split = [chunk for chunk in splitter]
        self.assertEqual(['foobar2000', 'foobar2000'], split)

########NEW FILE########
__FILENAME__ = webtest
import logging
from errbot import BotPlugin, botcmd
from errbot.builtins.webserver import webhook


class WebTest(BotPlugin):

    @webhook
    def webhook1(self, payload):
        logging.debug(str(payload))
        return str(payload)

    @webhook(r'/custom_webhook/')
    def webhook2(self, payload):
        logging.debug(str(payload))
        return str(payload)

    @webhook(r'/form/', form_param='form')
    def webhook3(self, payload):
        logging.debug(str(payload))
        return str(payload)

    @webhook(r'/custom_form/', form_param='form')
    def webhook4(self, payload):
        logging.debug(str(payload))
        return str(payload)

########NEW FILE########
__FILENAME__ = webhooks_tests
import requests
import socket
import os
import logging
import json
from errbot.backends.test import FullStackTest, pushMessage, popMessage
from errbot import PY2
from time import sleep
from config import BOT_DATA_DIR

PYTHONOBJECT = ['foo', {'bar': ('baz', None, 1.0, 2)}]
JSONOBJECT = json.dumps(PYTHONOBJECT)

def webserver_ready(host, port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        s.connect((host, port))
        s.shutdown(socket.SHUT_RDWR)
        s.close()
        return True
    except:
        return False


class TestWebhooks(FullStackTest):

    def setUp(self, extra_test_file=None):
        plugin_dir = os.path.dirname(os.path.realpath(__file__)) + os.sep + 'webhooks_tests'
        super(TestWebhooks, TestWebhooks).setUp(self, extra_test_file=plugin_dir)

        pushMessage("!config Webserver {'HOST': 'localhost', 'PORT': 3141, 'SSL':  None}")
        popMessage()
        while not webserver_ready('localhost', 3141):
            logging.debug("Webserver not ready yet, sleeping 0.1 second")
            sleep(0.1)

    def test_webserver_plugin_ok(self):
        pushMessage("!webstatus")
        self.assertIn("echo", popMessage())

    def test_not_configured_url_returns_404(self):
        self.assertEquals(requests.post('http://localhost:3141/randomness_blah', "{'toto': 'titui'}").status_code, 404)

    def test_json_is_automatically_decoded(self):
        self.assertEquals(requests.post('http://localhost:3141/webhook1/', JSONOBJECT).text, repr(json.loads(JSONOBJECT)))

    def test_json_on_custom_url_is_automatically_decoded(self):
        self.assertEquals(requests.post('http://localhost:3141/custom_webhook/', JSONOBJECT).text, repr(json.loads(JSONOBJECT)))

    def test_post_form_data_on_webhook_without_form_param_is_automatically_decoded(self):
        self.assertEquals(requests.post('http://localhost:3141/webhook1/', data=JSONOBJECT).text, repr(json.loads(JSONOBJECT)))

    def test_post_form_data_on_webhook_with_custom_url_and_without_form_param_is_automatically_decoded(self):
        self.assertEquals(requests.post('http://localhost:3141/custom_webhook/', data=JSONOBJECT).text, repr(json.loads(JSONOBJECT)))

    def test_webhooks_with_form_parameter_decode_json_automatically(self):
        form = {'form': JSONOBJECT}
        self.assertEquals(requests.post('http://localhost:3141/form/', data=form).text, repr(json.loads(JSONOBJECT)))

    def test_webhooks_with_form_parameter_on_custom_url_decode_json_automatically(self):
        form = {'form': JSONOBJECT}
        self.assertEquals(requests.post('http://localhost:3141/custom_form/', data=form).text, repr(json.loads(JSONOBJECT)))

    def test_generate_certificate_creates_usable_cert(self):
        key_path = os.sep.join((BOT_DATA_DIR, "webserver_key.pem"))
        cert_path = os.sep.join((BOT_DATA_DIR, "webserver_certificate.pem"))

        pushMessage("!generate_certificate")
        self.assertTrue("Generating" in popMessage(timeout=1))

        # Generating a certificate could be slow on weak hardware, so keep a safe
        # timeout on the first popMessage()
        self.assertTrue("successfully generated" in popMessage(timeout=60))
        self.assertTrue("is recommended" in popMessage(timeout=1))
        self.assertTrue(key_path in popMessage(timeout=1))

        pushMessage("!config Webserver {'HOST': 'localhost', 'PORT': 3141, 'SSL': {'certificate': '%s', 'key': '%s', 'host': 'localhost', 'port': 3142, 'enabled': True}}" % (cert_path, key_path))
        popMessage()

        while not webserver_ready('localhost', 3142):
            logging.debug("Webserver not ready yet, sleeping 0.1 second")
            sleep(0.1)

        self.assertEquals(
            requests.post('https://localhost:3142/webhook1/', JSONOBJECT, verify=False).text,
            repr(json.loads(JSONOBJECT))
        )

########NEW FILE########
