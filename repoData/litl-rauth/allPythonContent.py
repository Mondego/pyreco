__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# rauth documentation build configuration file, created by
# sphinx-quickstart on Thu Mar 15 12:17:26 2012.
#
# This file is execfile()d with the current directory set to its containing dir
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import rauth

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration ----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'rauth'
copyright = u'2013, Litl'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = rauth.__version__.rsplit('.', 1)[0]
# The full version, including alpha/beta/rc tags.
release = rauth.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output --------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {'github_fork': 'litl/rauth', 'index_logo': False}


# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'flask'


# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'rauthdoc'


# -- Options for LaTeX output -------------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    #'papersize': 'letterpaper',

    # The font size ('10pt', '11pt' or '12pt').
    #'pointsize': '10pt',

    # Additional stuff for the LaTeX preamble.
    #'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual])
latex_documents = [
    ('index', 'rauth.tex', u'Rauth Documentation',
        u'Max Countryman', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output -------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'rauth', u'Rauth Documentation',
     [u'Max Countryman'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -----------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    ('index',
     'rauth',
     u'rauth Documentation',
     u'Max Countryman',
     'Rauth',
     'A simple Python OAuth 1.0/a, OAuth 2.0, and Ofly consumer library built on top of Requests.',
     'Miscellaneous')
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = facebook
'''
    facebook
    --------

    A simple Flask demo app that shows how to login with Facebook via rauth.

    Please note: you must do `from facebook import db; db.create_all()` from
    the interpreter before running this example!
    
    Due to Facebook's stringent domain validation, requests using this app 
    must originate from 127.0.0.1:5000.
'''

from flask import Flask, flash, request, redirect, render_template, url_for
from flask.ext.sqlalchemy import SQLAlchemy

from rauth.service import OAuth2Service


# Flask config
SQLALCHEMY_DATABASE_URI = 'sqlite:///facebook.db'
SECRET_KEY = '\xfb\x12\xdf\xa1@i\xd6>V\xc0\xbb\x8fp\x16#Z\x0b\x81\xeb\x16'
DEBUG = True
FB_CLIENT_ID = '440483442642551'
FB_CLIENT_SECRET = 'cd54f1ace848fa2a7ac89a31ed9c1b61'

# Flask setup
app = Flask(__name__)
app.config.from_object(__name__)
db = SQLAlchemy(app)

# rauth OAuth 2.0 service wrapper
graph_url = 'https://graph.facebook.com/'
facebook = OAuth2Service(name='facebook',
                         authorize_url='https://www.facebook.com/dialog/oauth',
                         access_token_url=graph_url + 'oauth/access_token',
                         client_id=app.config['FB_CLIENT_ID'],
                         client_secret=app.config['FB_CLIENT_SECRET'],
                         base_url=graph_url)


# models
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True)
    fb_id = db.Column(db.String(120))

    def __init__(self, username, fb_id):
        self.username = username
        self.fb_id = fb_id

    def __repr__(self):
        return '<User %r>' % self.username

    @staticmethod
    def get_or_create(username, fb_id):
        user = User.query.filter_by(username=username).first()
        if user is None:
            user = User(username, fb_id)
            db.session.add(user)
            db.session.commit()
        return user


# views
@app.route('/')
def index():
    return render_template('login.html')


@app.route('/facebook/login')
def login():
    redirect_uri = url_for('authorized', _external=True)
    params = {'redirect_uri': redirect_uri}
    return redirect(facebook.get_authorize_url(**params))


@app.route('/facebook/authorized')
def authorized():
    # check to make sure the user authorized the request
    if not 'code' in request.args:
        flash('You did not authorize the request')
        return redirect(url_for('index'))

    # make a request for the access token credentials using code
    redirect_uri = url_for('authorized', _external=True)
    data = dict(code=request.args['code'], redirect_uri=redirect_uri)

    session = facebook.get_auth_session(data=data)

    # the "me" response
    me = session.get('me').json()

    User.get_or_create(me['username'], me['id'])

    flash('Logged in as ' + me['name'])
    return redirect(url_for('index'))


if __name__ == '__main__':
    db.create_all()
    app.run()

########NEW FILE########
__FILENAME__ = github-cli
from rauth.service import OAuth2Service

# Get a real consumer key & secret from:
# https://github.com/settings/applications/new
github = OAuth2Service(
    client_id='8ae4946cc5a9af76f6d7',
    client_secret='48aeb2b3c9226ae2b698eef4d7e6310473ccafa7',
    name='github',
    authorize_url='https://github.com/login/oauth/authorize',
    access_token_url='https://github.com/login/oauth/access_token',
    base_url='https://api.github.com/')

print 'Visit this URL in your browser: ' + github.get_authorize_url()

# This is a bit cumbersome, but you need to copy the code=something (just the
# `something` part) out of the URL that's redirected to AFTER you login and
# authorize the demo application
code = raw_input('Enter code parameter (code=something) from URL: ')

# create a dictionary for the data we'll post on the get_access_token request
data = dict(code=code, redirect_uri='https://github.com/litl/rauth/')

# retrieve the authenticated session
session = github.get_auth_session(data=data)

# make a request using the authenticated session
user = session.get('user').json()

print 'currently logged in as: ' + user['login']

########NEW FILE########
__FILENAME__ = linkedin-updates-cli
from rauth.service import OAuth1Service

linkedin = OAuth1Service(
    consumer_key='tjm826j6uzio',
    consumer_secret='1XbHsC7UxtC6EzqW',
    name='linkedin',
    request_token_url='https://api.linkedin.com/uas/oauth/requestToken',
    authorize_url='https://api.linkedin.com/uas/oauth/authorize',
    access_token_url='https://api.linkedin.com/uas/oauth/accessToken',
    base_url='http://api.linkedin.com/v1/')

request_token, request_token_secret = linkedin.get_request_token()

authorize_url = linkedin.get_authorize_url(request_token)

print 'Visit this URL in your browser: ' + authorize_url
pin = raw_input('Enter PIN from browser: ')

session = linkedin.get_auth_session(request_token,
                                    request_token_secret,
                                    data={'oauth_verifier': pin},
                                    header_auth=True)

r = session.get('people/~/network/updates',
                params={'type': 'SHAR', 'format': 'json'},
                header_auth=True)

updates = r.json()

for i, update in enumerate(updates['values'], 1):
    if 'currentShare' not in update['updateContent']['person']:
        print '{0}. {1}'.format(i, update['updateKey'])
        continue
    current_share = update['updateContent']['person']['currentShare']
    person = current_share['author']['firstName'].encode('utf-8') + ' '
    person += current_share['author']['lastName'].encode('utf-8')
    comment = current_share.get('comment', '').encode('utf-8')
    if not comment:
        comment = current_share['content']['description'].encode('utf-8')
    print '{0}. {1} - {2}'.format(i, person, comment)

########NEW FILE########
__FILENAME__ = twitter-timeline-cli
from rauth import OAuth1Service
 
try:
    read_input = raw_input
except NameError:
    read_input = input
 
# Get a real consumer key & secret from https://dev.twitter.com/apps/new
twitter = OAuth1Service(
    name='twitter',
    consumer_key='J8MoJG4bQ9gcmGh8H7XhMg',
    consumer_secret='7WAscbSy65GmiVOvMU5EBYn5z80fhQkcFWSLMJJu4',
    request_token_url='https://api.twitter.com/oauth/request_token',
    access_token_url='https://api.twitter.com/oauth/access_token',
    authorize_url='https://api.twitter.com/oauth/authorize',
    base_url='https://api.twitter.com/1.1/')
 
request_token, request_token_secret = twitter.get_request_token()
 
authorize_url = twitter.get_authorize_url(request_token)
 
print('Visit this URL in your browser: {url}'.format(url=authorize_url))
pin = read_input('Enter PIN from browser: ')
 
session = twitter.get_auth_session(request_token,
                                   request_token_secret,
                                   method='POST',
                                   data={'oauth_verifier': pin})
 
params = {'include_rts': 1,  # Include retweets
          'count': 10}       # 10 tweets
 
r = session.get('statuses/home_timeline.json', params=params, verify=True)
 
for i, tweet in enumerate(r.json(), 1):
    handle = tweet['user']['screen_name']
    text = tweet['text']
    print(u'{0}. @{1} - {2}'.format(i, handle, text))

########NEW FILE########
__FILENAME__ = compat
# -*- coding: utf-8 -*-
'''
    rauth.compat
    ------------

    A module providing tools for cross-version compatibility.
'''
import sys


if sys.version_info < (3, 0):  # pragma: no cover
    from urllib import quote, urlencode
    from urlparse import parse_qsl, urlsplit, urlunsplit, urljoin

    def is_basestring(astring):
        return isinstance(astring, basestring)  # NOQA

    def iteritems(adict):
        return adict.iteritems()

else:  # pragma: no cover
    from urllib.parse import (quote, urlencode, parse_qsl, urlsplit,
                              urlunsplit, urljoin)

    # placate pyflakes
    (quote, urlencode, parse_qsl, urlsplit, urlunsplit, urljoin)

    def is_basestring(astring):
        return isinstance(astring, (str, bytes))

    def iteritems(adict):
        return adict.items()

########NEW FILE########
__FILENAME__ = oauth
# -*- coding: utf-8 -*-
'''
    rauth.oauth
    -----------

    A module providing various OAuth related containers.
'''

import base64
import hmac

from hashlib import sha1

from rauth.compat import is_basestring, quote, urlencode, urlsplit, urlunsplit
from rauth.utils import FORM_URLENCODED


class SignatureMethod(object):
    '''
    A base class for signature methods providing a set of common methods.
    '''

    def _ensure_unicode(self, s):
        if not isinstance(s, bytes):
            return s.encode('utf-8')
        return s.decode('utf-8')  # pragma: no cover

    def _escape(self, s):
        '''
        Escapes a string, ensuring it is encoded as a UTF-8 octet.

        :param s: A string to be encoded.
        :type s: str
        '''
        return quote(self._ensure_unicode(s), safe='~').encode('utf-8')

    def _remove_qs(self, url):
        '''
        Removes a query string from a URL before signing.

        :param url: The URL to strip.
        :type url: str
        '''
        scheme, netloc, path, query, fragment = urlsplit(url)

        return urlunsplit((scheme, netloc, path, '', fragment))

    def _normalize_request_parameters(self, oauth_params, req_kwargs):
        '''
        This process normalizes the request parameters as detailed in the OAuth
        1.0 spec.

        Additionally we apply a `Content-Type` header to the request of the
        `FORM_URLENCODE` type if the `Content-Type` was previously set, i.e. if
        this is a `POST` or `PUT` request. This ensures the correct header is
        set as per spec.

        Finally we sort the parameters in preparation for signing and return
        a URL encoded string of all normalized parameters.

        :param oauth_params: OAuth params to sign with.
        :type oauth_params: dict
        :param req_kwargs: Request kwargs to normalize.
        :type req_kwargs: dict
        '''
        normalized = []

        params = req_kwargs.get('params', {})
        data = req_kwargs.get('data', {})
        headers = req_kwargs.get('headers', {})

        # process request parameters
        for k, v in params.items():
            normalized += [(k, v)]

        # process request data
        if 'Content-Type' in headers and \
                headers['Content-Type'] == FORM_URLENCODED:
            for k, v in data.items():
                normalized += [(k, v)]

        # extract values from our list of tuples
        all_normalized = []
        for t in normalized:
            k, v = t
            if is_basestring(v) and not isinstance(v, bytes):
                v = v.encode('utf-8')
            all_normalized += [(k, v)]

        # add in the params from oauth_params for signing
        for k, v in oauth_params.items():
            if (k, v) in all_normalized:  # pragma: no cover
                continue
            all_normalized += [(k, v)]

        # sort the params as per the OAuth 1.0/a spec
        all_normalized.sort()

        # finally encode the params as a string
        return urlencode(all_normalized, True).replace('+', '%20')


class HmacSha1Signature(SignatureMethod):
    '''
    HMAC-SHA1 Signature Method.

    This is a signature method, as per the OAuth 1.0/a specs. As the name
    might suggest, this method signs parameters with HMAC using SHA1.
    '''
    NAME = 'HMAC-SHA1'

    def sign(self,
             consumer_secret,
             access_token_secret,
             method,
             url,
             oauth_params,
             req_kwargs):
        '''Sign request parameters.

        :param consumer_secret: Consumer secret.
        :type consumer_secret: str
        :param access_token_secret: Access token secret.
        :type access_token_secret: str
        :param method: The method of this particular request.
        :type method: str
        :param url: The URL of this particular request.
        :type url: str
        :param oauth_params: OAuth parameters.
        :type oauth_params: dict
        :param req_kwargs: Keyworded args that will be sent to the request
            method.
        :type req_kwargs: dict
        '''
        url = self._remove_qs(url)

        oauth_params = \
            self._normalize_request_parameters(oauth_params, req_kwargs)
        parameters = map(self._escape, [method, url, oauth_params])

        key = self._escape(consumer_secret) + b'&'
        if access_token_secret is not None:
            key += self._escape(access_token_secret)

        # build a Signature Base String
        signature_base_string = b'&'.join(parameters)

        # hash the string with HMAC-SHA1
        hashed = hmac.new(key, signature_base_string, sha1)

        # return the signature
        return base64.b64encode(hashed.digest()).decode()


class RsaSha1Signature(SignatureMethod):
    '''
    RSA-SHA1 Signature Method.

    This is a signature method, as per the OAuth 1.0/a specs. As the name
    might suggest, this method signs parameters with RSA using SHA1.
    '''
    NAME = 'RSA-SHA1'

    def __init__(self):
        try:
            from Crypto.PublicKey import RSA as r
            from Crypto.Hash import SHA as s
            from Crypto.Signature import PKCS1_v1_5 as p
            self.RSA, self.SHA, self.PKCS1_v1_5 = r, s, p
        except ImportError:  # pragma: no cover
            raise NotImplementedError("PyCrypto is required for " + self.NAME)

    def sign(self,
             consumer_secret,
             access_token_secret,
             method,
             url,
             oauth_params,
             req_kwargs):
        '''Sign request parameters.

        :param consumer_secret: RSA private key.
        :type consumer_secret: str or RSA._RSAobj
        :param access_token_secret: Unused.
        :type access_token_secret: str
        :param method: The method of this particular request.
        :type method: str
        :param url: The URL of this particular request.
        :type url: str
        :param oauth_params: OAuth parameters.
        :type oauth_params: dict
        :param req_kwargs: Keyworded args that will be sent to the request
            method.
        :type req_kwargs: dict
        '''
        url = self._remove_qs(url)

        oauth_params = \
            self._normalize_request_parameters(oauth_params, req_kwargs)
        parameters = map(self._escape, [method, url, oauth_params])

        # build a Signature Base String
        signature_base_string = b'&'.join(parameters)

        # resolve the key
        if is_basestring(consumer_secret):
            consumer_secret = self.RSA.importKey(consumer_secret)
        if not isinstance(consumer_secret, self.RSA._RSAobj):
            raise ValueError("invalid consumer_secret")

        # hash the string with RSA-SHA1
        s = self.PKCS1_v1_5.new(consumer_secret)
        # PyCrypto SHA.new requires an encoded byte string
        h = self.SHA.new(signature_base_string)
        hashed = s.sign(h)

        # return the signature
        return base64.b64encode(hashed).decode()


class PlaintextSignature(SignatureMethod):
    '''PLAINTEXT Signature Method. (Not implemented)'''
    NAME = 'PLAINTEXT'

    def __init__(self):
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = service
# -*- coding: utf-8 -*-
'''
    rauth.service
    -------------

    Provides OAuth 1.0/a, 2.0 and Ofly service containers.
'''

from rauth.compat import urlencode
from rauth.session import OAuth1Session, OAuth2Session, OflySession
from rauth.utils import ENTITY_METHODS, parse_utf8_qsl

PROCESS_TOKEN_ERROR = ('Decoder failed to handle {key} with data as returned '
                       'by provider. A different decoder may be needed. '
                       'Provider returned: {raw}')


def process_token_request(r, decoder, *args):
    try:
        data = decoder(r.content)
        return tuple(data[key] for key in args)
    except KeyError as e:  # pragma: no cover
        bad_key = e.args[0]
        raise KeyError(PROCESS_TOKEN_ERROR.format(key=bad_key, raw=r.content))


class Service(object):
    __attrs__ = ['name', 'base_url', 'authorize_url']

    def __init__(self, name, base_url, authorize_url):
        #: The service name, e.g. 'twitter'.
        self.name = name

        #: The base URL used for making API requests.
        self.base_url = base_url

        #: The authorization URL.
        self.authorize_url = authorize_url

    def __getstate__(self):
        return dict((attr, getattr(self, attr, None)) for
                    attr in self.__attrs__)

    def __setstate__(self, state):
        for attr, value in state.items():
            setattr(self, attr, value)


class OAuth1Service(Service):
    '''
    An OAuth 1.0/a Service container.

    This class provides a wrapper around a specialized Requests'
    :class:`~requests.sessions.Session` object. Primarily this wrapper is used
    to produce authenticated session objects. These may be used to make
    requests against OAuth 1.0/a endpoints.

    You might intialize :class:`OAuth1Service` something like
    this::

        service = OAuth1Service(
                   name='example',
                   consumer_key='123',
                   consumer_secret='456',
                   request_token_url='http://example.com/request_token',
                   access_token_url='http://example.com/access_token',
                   authorize_url='http://example.com/authorize',
                   base_url='http://example.com/api')

    Now the request token should be retrieved::

        request_token, request_token_secret = service.get_request_token()

    .. admonition:: Differing Request Token Formats

        Some services provide different formatting when returning tokens. For
        this reason the service wrapper provides a special method
        :meth:`get_raw_request_token`. This will return the unparsed response.
        At this point it's up to you to extract the necessary data.

    It's time to access the authorize URI and direct the client to authorize
    requests on their behalf. This URI is retrieved as follows::

        authorize_url = service.get_authorize_url(request_token)

    Once the client has authorized the request it is now possible to retrieve
    an access token. Do so as follows::

        session = service.get_auth_session(request_token, request_token_secret)

    .. admonition:: Differing Access Token Formats

        Some services provide different formatting when returning tokens. For
        this reason the service wrapper provides a special method
        :meth:`get_raw_access_token`. This will return the unparsed response.
        At this point it's up to you to extract the necessary data.

    Finally we have an authenticated session and are ready to make requests
    against OAuth 1.0/a endpoints. Because Rauth is a wrapper around
    Requests, the same API you would use with Requests is exposed and
    expected::

        r = session.get('some/resource/', params={'format': 'json'})
        print r.json()

    :param consumer_key: Client consumer key, required for signing.
    :type consumer_key: str
    :param consumer_secret: Client consumer secret, required for signing.
    :type consumer_secret: str
    :param name: The service name, defaults to `None`.
    :type name: str
    :param request_token_url: Request token endpoint, defaults to `None`.
    :type request_token_url: str
    :param access_token_url: Access token endpoint, defaults to `None`.
    :type access_token_url: str
    :param authorize_url: Authorize endpoint, defaults to `None`.
    :type authorize_url: str
    :param base_url: A base URL from which to construct requests, defaults to
        `None`.
    :type base_url: str
    :param session_obj: Object used to construct sessions with, defaults to
        :class:`rauth.OAuth1Session <OAuth1Session>`
    :type session_obj: :class:`Session`
    :param signature_obj: Object used to construct signatures with, defaults
         to :class:`rauth.oauth.HmacSha1Signature <HmacSha1Signature>`
    :type signature_obj: :class:`SignatureMethod`
    '''
    __attrs__ = Service.__attrs__ + ['consumer_key',
                                     'consumer_secret',
                                     'request_token_url',
                                     'access_token_url',
                                     'session_obj']

    def __init__(self,
                 consumer_key,
                 consumer_secret,
                 name=None,
                 request_token_url=None,
                 access_token_url=None,
                 authorize_url=None,
                 base_url=None,
                 session_obj=None,
                 signature_obj=None):

        #: Client credentials.
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret

        #: Authorization endpoints.
        self.request_token_url = request_token_url
        self.access_token_url = access_token_url

        #: Object used to construct sessions with.
        self.session_obj = session_obj or OAuth1Session

        #: Object used to construct signatures with.
        self.signature_obj = signature_obj

        #: Request and access token responses.
        self.request_token_response = None
        self.access_token_response = None

        super(OAuth1Service, self).__init__(name,
                                            base_url,
                                            authorize_url)

    def get_session(self, token=None, signature=None):
        '''
        If provided a `token` parameter, tries to retrieve a stored
        `rauth.OAuth1Session` instance. Otherwise generates a new session
        instance with the :class:`rauth.OAuth1Service.consumer_key` and
        :class:`rauth.OAuth1Service.consumer_secret` stored on the
        `rauth.OAuth1Service` instance.

        :param token: A tuple of strings with which to memoize the session
            object instance.
        :type token: tuple
        '''
        if token is not None:
            access_token, access_token_secret = token
            session = self.session_obj(self.consumer_key,
                                       self.consumer_secret,
                                       access_token,
                                       access_token_secret,
                                       signature or self.signature_obj,
                                       service=self)
        else:  # pragma: no cover
            session = self.session_obj(self.consumer_key,
                                       self.consumer_secret,
                                       signature=signature
                                       or self.signature_obj,
                                       service=self)
        return session

    def get_raw_request_token(self, method='GET', **kwargs):
        '''
        Returns a Requests' response over the
        :attr:`rauth.OAuth1Service.request_token_url`.

        Use this if your endpoint if you need the full `Response` object.

        :param method: A string representation of the HTTP method to be used,
            defaults to `GET`.
        :type method: str
        :param \*\*kwargs: Optional arguments. Same as Requests.
        :type \*\*kwargs: dict
        '''
        # ensure we've set the request_token_url
        if self.request_token_url is None:
            raise TypeError('request_token_url must not be None')

        session = self.get_session()
        self.request_token_response = session.request(method,
                                                      self.request_token_url,
                                                      **kwargs)
        return self.request_token_response

    def get_request_token(self,
                          method='GET',
                          decoder=parse_utf8_qsl,
                          key_token='oauth_token',
                          key_token_secret='oauth_token_secret',
                          **kwargs):
        '''
        Return a request token pair.

        :param method: A string representation of the HTTP method to be used,
            defaults to `GET`.
        :type method: str
        :param decoder: A function used to parse the Response content. Should
            return a dictionary.
        :type decoder: func
        :param key_token: The key the access token will be decoded by, defaults
            to 'oauth_token'.
        :type string:
        :param key_token_secret: The key the access token will be decoded by,
            defaults to 'oauth_token_secret'.
        :type string:
        :param \*\*kwargs: Optional arguments. Same as Requests.
        :type \*\*kwargs: dict
        '''
        r = self.get_raw_request_token(method=method, **kwargs)
        request_token, request_token_secret = \
            process_token_request(r, decoder, key_token, key_token_secret)
        return request_token, request_token_secret

    def get_authorize_url(self, request_token, **params):
        '''
        Returns a formatted authorize URL.

        :param request_token: The request token as returned by
            :class:`get_request_token`.
        :type request_token: str
        :param \*\*params: Additional keyworded arguments to be added to the
            request querystring.
        :type \*\*params: dict
        '''
        params.update({'oauth_token': request_token})
        return self.authorize_url + '?' + urlencode(params)

    def get_raw_access_token(self,
                             request_token,
                             request_token_secret,
                             method='GET',
                             **kwargs):
        '''
        Returns a Requests' response over the
        :attr:`rauth.OAuth1Service.access_token_url`.

        Use this if your endpoint if you need the full `Response` object.

        :param request_token: The request token as returned by
            :meth:`get_request_token`.
        :type request_token: str
        :param request_token_secret: The request token secret as returned by
            :meth:`get_request_token`.
        :type request_token_secret: str
        :param method: A string representation of the HTTP method to be
            used, defaults to `GET`.
        :type method: str
        :param \*\*kwargs: Optional arguments. Same as Requests.
        :type \*\*kwargs: dict
        '''
        # ensure we've set the access_token_url
        if self.access_token_url is None:
            raise TypeError('access_token_url must not be None')

        session = self.get_session((request_token, request_token_secret))
        self.access_token_response = session.request(method,
                                                     self.access_token_url,
                                                     **kwargs)
        return self.access_token_response

    def get_access_token(self,
                         request_token,
                         request_token_secret,
                         method='GET',
                         decoder=parse_utf8_qsl,
                         key_token='oauth_token',
                         key_token_secret='oauth_token_secret',
                         **kwargs):
        '''
        Returns an access token pair.

        :param request_token: The request token as returned by
            :meth:`get_request_token`.
        :type request_token: str
        :param request_token_secret: The request token secret as returned by
            :meth:`get_request_token`.
        :type request_token_secret: str
        :param method: A string representation of the HTTP method to be
            used, defaults to `GET`.
        :type method: str
        :param decoder: A function used to parse the Response content. Should
            return a dictionary.
        :type decoder: func
        :param key_token: The key the access token will be decoded by, defaults
            to 'oauth_token'.
        :type string:
        :param key_token_secret: The key the access token will be decoded by,
            defaults to 'oauth_token_secret'.
        :type string:
        :param \*\*kwargs: Optional arguments. Same as Requests.
        :type \*\*kwargs: dict
        '''
        r = self.get_raw_access_token(request_token,
                                      request_token_secret,
                                      method=method,
                                      **kwargs)

        access_token, access_token_secret = \
            process_token_request(r, decoder, key_token, key_token_secret)
        return access_token, access_token_secret

    def get_auth_session(self,
                         request_token,
                         request_token_secret,
                         method='GET',
                         **kwargs):
        '''
        Gets an access token, intializes a new authenticated session with the
        access token. Returns an instance of :attr:`session_obj`.

        :param request_token: The request token as returned by
            :meth:`get_request_token`.
        :type request_token: str
        :param request_token_secret: The request token secret as returned by
            :meth:`get_request_token`.
        :type request_token_secret: str
        :param method: A string representation of the HTTP method to be
            used, defaults to `GET`.
        :type method: str
        :param \*\*kwargs: Optional arguments. Same as Requests.
        :type \*\*kwargs: dict
        '''
        token = self.get_access_token(request_token,
                                      request_token_secret,
                                      method=method,
                                      **kwargs)
        session = self.get_session(token)

        if self.request_token_response:
            session.request_token_response = self.request_token_response
        if self.access_token_response:
            session.access_token_response = self.access_token_response

        return session


class OAuth2Service(Service):
    '''
    An OAuth 2.0 Service container.

    This class provides a wrapper around a specialized Requests'
    :class:`~requests.session.Session` object. Primarily this wrapper is used
    for producing authenticated session objects which are used to make requests
    against OAuth 2.0 endpoints.

    You might intialize :class:`OAuth2Service` something like this::

        service = OAuth2Service(
                   name='example',
                   client_id='123',
                   client_secret='456',
                   access_token_url='https://example.com/token',
                   authorize_url='https://example.com/authorize',
                   base_url='https://example.com/api/')

    Given the simplicity of OAuth 2.0 now this object `service` can be used to
    retrieve an authenticated session in two simple steps::

        # the return URL is used to validate the request
        params = {'redirect_uri': 'http://example.com/',
                  'response_type': 'code'}
        url = service.get_authorize_url(**params)

        # once the above URL is consumed by a client we can ask for an access
        # token. note that the code is retrieved from the redirect URL above,
        # as set by the provider
        data = {'code': 'foobar',
                'grant_type': 'authorization_code',
                'redirect_uri': 'http://example.com/'}

        session = service.get_auth_session(data=data)

    Now that we have retrieved a session, we may make requests against the
    OAuth 2.0 provider's endpoints. As much as possible the Requests' API
    is preserved and you may make requests using the same parameters you would
    using Requests::

        r = session.get('foo', params={'format': 'json'})
        print r.json()

    :param client_id: Client id.
    :type client_id: str
    :param client_secret: Client secret.
    :type client_secret: str
    :param name: The service name, defaults to `None`.
    :type name: str
    :param access_token_url: Access token endpoint, defaults to `None`.
    :type access_token_url: str
    :param authorize_url: Authorize endpoint, defaults to `None`.
    :type authorize_url: str
    :param base_url: A base URL from which to construct requests, defaults to
        `None`.
    :type base_url: str
    :param session_obj: Object used to construct sessions with, defaults to
        :class:`OAuth2Session`
    :type session_obj: :class:`rauth.Session`
    '''
    __attrs__ = Service.__attrs__ + ['client_id',
                                     'client_secret',
                                     'access_token_url',
                                     'session_obj']

    def __init__(self,
                 client_id,
                 client_secret,
                 name=None,
                 access_token_url=None,
                 authorize_url=None,
                 base_url=None,
                 session_obj=None):

        #: Client credentials.
        self.client_id = client_id
        self.client_secret = client_secret

        #: The provider's access token URL.
        self.access_token_url = access_token_url

        #: Object used to construct sessions with.
        self.session_obj = session_obj or OAuth2Session

        #: Access token response.
        self.access_token_response = None

        super(OAuth2Service, self).__init__(name,
                                            base_url,
                                            authorize_url)

    def get_session(self, token=None):
        '''
        If provided, the `token` parameter is used to initialize an
        authenticated session, otherwise an unauthenticated session object is
        generated. Returns an instance of :attr:`session_obj`..

        :param token: A token with which to initilize the session.
        :type token: str
        '''
        if token is not None:
            session = self.session_obj(self.client_id,
                                       self.client_secret,
                                       token,
                                       service=self)
        else:  # pragma: no cover
            session = self.session_obj(self.client_id,
                                       self.client_secret,
                                       service=self)
        return session

    def get_authorize_url(self, **params):
        '''
        Returns a formatted authorize URL.

        :param \*\*params: Additional keyworded arguments to be added to the
            URL querystring.
        :type \*\*params: dict
        '''

        params.update({'client_id': self.client_id})
        return self.authorize_url + '?' + urlencode(params)

    def get_raw_access_token(self, method='POST', **kwargs):
        '''
        Returns a Requests' response over the
        :attr:`OAuth2Service.access_token_url`.

        Use this if your endpoint if you need the full `Response` object.

        :param method: A string representation of the HTTP method to be used,
            defaults to `POST`.
        :type method: str
        :param \*\*kwargs: Optional arguments. Same as Requests.
        :type \*\*kwargs: dict
        '''
        key = 'params'
        if method in ENTITY_METHODS:
            key = 'data'

        kwargs.setdefault(key, {})
        kwargs[key].update({'client_id': self.client_id,
                            'client_secret': self.client_secret})

        session = self.get_session()
        self.access_token_response = session.request(method,
                                                     self.access_token_url,
                                                     **kwargs)
        return self.access_token_response

    def get_access_token(self,
                         method='POST',
                         decoder=parse_utf8_qsl,
                         key='access_token',
                         **kwargs):
        '''
        Returns an access token.

        :param method: A string representation of the HTTP method to be used,
            defaults to `POST`.
        :type method: str
        :param decoder: A function used to parse the Response content. Should
            return a dictionary.
        :type decoder: func
        :param key: The key the access token will be decoded by, defaults to
            'access_token'.
        :type string:
        :param \*\*kwargs: Optional arguments. Same as Requests.
        :type \*\*kwargs: dict
        '''
        r = self.get_raw_access_token(method, **kwargs)
        access_token, = process_token_request(r, decoder, key)
        return access_token

    def get_auth_session(self, method='POST', **kwargs):
        '''
        Gets an access token, intializes a new authenticated session with the
        access token. Returns an instance of :attr:`session_obj`.

        :param method: A string representation of the HTTP method to be used,
            defaults to `POST`.
        :type method: str
        :param \*\*kwargs: Optional arguments. Same as Requests.
        :type \*\*kwargs: dict
        '''
        session = self.get_session(self.get_access_token(method, **kwargs))

        if self.access_token_response:
            session.access_token_response = self.access_token_response

        return session


class OflyService(Service):
    '''
    An Ofly Service container.

    This class wraps an Ofly service i.e., Shutterfly. The process
    is similar to that of OAuth 1.0 but simplified.

    You might intialize :class:`OflyService` something like this::

        service = OflyService(name='example',
                              app_id='123',
                              app_secret='456',
                              authorize_url='http://example.com/authorize')

    A signed authorize URL is then produced via calling
    `service.get_authorize_url`. Once this has been visited by the client and
    assuming the client authorizes the request.

    Normal API calls can now be made using a session instance. Retrieve the
    authenticated session like so::

        session = service.get_auth_session('foo')

        # now we can make regular Requests' calls
        r = session.get('bar')

    :param app_id: The oFlyAppId, i.e. "application ID".
    :type app_id: str
    :param app_secret: The oFlyAppSecret, i.e. "shared secret".
    :type app_secret: str
    :param name: The service name, defaults to `None`.
    :type name: str
    :param authorize_url: Authorize endpoint, defaults to `None`.
    :type authorize_url: str
    :param base_url: A base URL from which to construct requests, defaults to
        `None`.
    :type base_url: str
    :param user_id: The oflyUserid, defaults to `None`. Note: this is required
        for Ofly requests, retrieved via authorize URL.
    :type user_id: str
    :param session_obj: Object used to construct sessions with, defaults to
        `rauth.OflySession`
    :type session_obj: :class:`rauth.Session`
    '''
    __attrs__ = Service.__attrs__ + ['app_id',
                                     'app_secret',
                                     'user_id',
                                     'session_obj']

    def __init__(self,
                 app_id,
                 app_secret,
                 name=None,
                 authorize_url=None,
                 base_url=None,
                 user_id=None,
                 session_obj=None):
        #: Client credentials.
        self.app_id = app_id
        self.app_secret = app_secret

        #: The oflyUserid.
        self.user_id = user_id

        #: Object used to construct sessions with.
        self.session_obj = session_obj or OflySession

        super(OflyService, self).__init__(name,
                                          base_url,
                                          authorize_url)

    def get_session(self, token):
        '''
        The token parameter should be `oFlyUserid`. This is used to initialize
        an authenticated session instance. Returns an instance of
        :attr:`session_obj`.

        :param token: A token with which to initialize the session with, e.g.
            :attr:`OflyService.user_id`.
        :type token: str
        '''
        return self.session_obj(self.app_id,
                                self.app_secret,
                                token,
                                service=self)

    def get_authorize_url(self, **params):
        '''
        Returns a formatted authorize URL.

        :param \*\*params: Additional keyworded arguments to be added to the
            request querystring.
        :type \*\*params: dict
        '''
        params = self.session_obj.sign(self.authorize_url,
                                       self.app_id,
                                       self.app_secret,
                                       **params)
        return self.authorize_url + '?' + params

    def get_auth_session(self, user_id, **kwargs):
        '''
        Intializes a new authenticated session with `user_id` as oFlyUserid.
        Returns an instance of :attr:`session_obj`.

        :param user_id: The oflyUserid, defaults to `None`.
        :type user_id: str
        :param \*\*kwargs: Optional arguments. Same as Requests.
        :type \*\*kwargs: dict
        '''
        return self.get_session(user_id)

########NEW FILE########
__FILENAME__ = session
# -*- coding: utf-8 -*-
'''
    rauth.session
    -------------

    Specially wrapped Requests' :class:`~request.sessions.Session` objects.
'''

from copy import deepcopy
from datetime import datetime
from hashlib import sha1, md5
from random import SystemRandom
from time import time

from rauth.compat import parse_qsl, urljoin, urlsplit, is_basestring
from rauth.oauth import HmacSha1Signature
from rauth.utils import (absolute_url, CaseInsensitiveDict,
                         OAuth1Auth, OAuth2Auth,
                         ENTITY_METHODS, FORM_URLENCODED,
                         get_sorted_params, OPTIONAL_OAUTH_PARAMS)

from requests.sessions import Session

OAUTH1_DEFAULT_TIMEOUT = OAUTH2_DEFAULT_TIMEOUT = OFLY_DEFAULT_TIMEOUT = 300.0

random = SystemRandom().random


class RauthSession(Session):
    __attrs__ = Session.__attrs__ + ['service']

    def __init__(self, service):
        #: A back reference to a service wrapper, if we're using one.
        self.service = service

        super(RauthSession, self).__init__()

    def _set_url(self, url):
        if self.service is not None and self.service.base_url is not None and \
                not absolute_url(url):
            return urljoin(self.service.base_url, url)
        return url


class OAuth1Session(RauthSession):
    '''
    A specialized :class:`~requests.sessions.Session` object, wrapping OAuth
    1.0/a logic.

    This object is utilized by the :class:`OAuth1Service` wrapper but can
    be used independently of that infrastructure. Essentially this is a loose
    wrapping around the standard Requests codepath. State may be tracked at
    this layer, especially if the instance is kept around and tracked via some
    unique identifier, e.g. access tokens. Things like request cookies will be
    preserved between requests and in fact all functionality provided by
    a Requests' :class:`~requests.sessions.Session` object should be exposed
    here.

    If you were to use this object by itself you could do so by instantiating
    it like this::

        session = OAuth1Session('123',
                                '456',
                                access_token='321',
                                access_token_secret='654')

    You now have a session object which can be used to make requests exactly as
    you would with a normal Requests' :class:`~requests.sessions.Session`
    instance. This anticipates that the standard OAuth 1.0/a flow will be
    modeled outside of the scope of this class. In other words, if the fully
    qualified flow is useful to you then this object probably need not be used
    directly, instead consider using :class:`OAuth1Service`.

    Once the session object is setup, you may start making requests::

        r = session.get('http://example/com/api/resource',
                        params={'format': 'json'})
        print r.json()

    :param consumer_key: Client consumer key.
    :type consumer_key: str
    :param consumer_secret: Client consumer secret.
    :type consumer_secret: str
    :param access_token: Access token, defaults to `None`.
    :type access_token: str
    :param access_token_secret: Access token secret, defaults to `None`.
    :type access_token_secret: str
    :param signature: A signature producing object, defaults to
        :class:`rauth.oauth.HmacSha1Signature`.
    :type signature: :class:`rauth.oauth.Signature`
    :param service: A back reference to the service wrapper, defaults to
        `None`.
    :type service: :class:`rauth.Service`
    '''
    __attrs__ = RauthSession.__attrs__ + ['consumer_key',
                                          'consumer_secret',
                                          'access_token',
                                          'access_token_secret',
                                          'signature']

    VERSION = '1.0'

    def __init__(self,
                 consumer_key,
                 consumer_secret,
                 access_token=None,
                 access_token_secret=None,
                 signature=None,
                 service=None):

        #: Client credentials.
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret

        #: Access token credentials.
        self.access_token = access_token
        self.access_token_secret = access_token_secret

        #: Signing method.
        signature = signature or HmacSha1Signature
        self.signature = signature()

        super(OAuth1Session, self).__init__(service)

    def request(self,
                method,
                url,
                header_auth=False,
                realm='',
                **req_kwargs):
        '''
        A loose wrapper around Requests' :class:`~requests.sessions.Session`
        which injects OAuth 1.0/a parameters.

        :param method: A string representation of the HTTP method to be used.
        :type method: str
        :param url: The resource to be requested.
        :type url: str
        :param header_auth: Authentication via header, defaults to `False.`
        :type header_auth: bool
        :param realm: The auth header realm, defaults to ``""``.
        :type realm: str
        :param \*\*req_kwargs: Keyworded args to be passed down to Requests.
        :type \*\*req_kwargs: dict
        '''
        req_kwargs.setdefault('headers', {})
        req_kwargs['headers'] = CaseInsensitiveDict(req_kwargs['headers'])

        url = self._set_url(url)

        entity_method = method.upper() in ENTITY_METHODS
        if entity_method:
            req_kwargs['headers'].setdefault('Content-Type', FORM_URLENCODED)

        form_urlencoded = \
            req_kwargs['headers'].get('Content-Type') == FORM_URLENCODED

        # inline string conversion
        if is_basestring(req_kwargs.get('params')):
            req_kwargs['params'] = dict(parse_qsl(req_kwargs['params']))

        if is_basestring(req_kwargs.get('data')) and form_urlencoded:
            req_kwargs['data'] = dict(parse_qsl(req_kwargs['data']))

        req_kwargs.setdefault('timeout', OAUTH1_DEFAULT_TIMEOUT)

        oauth_params = self._get_oauth_params(req_kwargs)

        # ensure we always create new instances of dictionary elements
        for key, value in req_kwargs.items():
            if isinstance(value, dict):
                req_kwargs[key] = deepcopy(value)

        # sign the request
        oauth_params['oauth_signature'] = \
            self.signature.sign(self.consumer_secret,
                                self.access_token_secret,
                                method,
                                url,
                                oauth_params,
                                req_kwargs)

        if header_auth and 'oauth_signature' not in \
                req_kwargs['headers'].get('Authorization', ''):
            req_kwargs['auth'] = OAuth1Auth(oauth_params, realm)
        elif entity_method and 'oauth_signature' not in \
                (req_kwargs.get('data') or {}):
            req_kwargs['data'] = req_kwargs.get('data') or {}

            # If we have a urlencoded entity-body we should pass the OAuth
            # parameters on this body. However, if we do not, then we need to
            # pass these over the request URI, i.e. on params.
            #
            # See:
            #
            #   http://tools.ietf.org/html/rfc5849#section-3.5.2
            #
            # and:
            #
            #   http://tools.ietf.org/html/rfc5849#section-3.5.3
            if form_urlencoded:
                req_kwargs['data'].update(oauth_params)
            else:
                req_kwargs.setdefault('params', {})
                req_kwargs['params'].update(oauth_params)
        elif 'oauth_signature' not in url:
            req_kwargs.setdefault('params', {})
            req_kwargs['params'].update(oauth_params)

        return super(OAuth1Session, self).request(method, url, **req_kwargs)

    def _parse_optional_params(self, oauth_params, req_kwargs):
        '''
        Parses and sets optional OAuth parameters on a request.

        :param oauth_param: The OAuth parameter to parse.
        :type oauth_param: str
        :param req_kwargs: The keyworded arguments passed to the request
            method.
        :type req_kwargs: dict
        '''
        params = req_kwargs.get('params', {})
        data = req_kwargs.get('data') or {}

        for oauth_param in OPTIONAL_OAUTH_PARAMS:
            if oauth_param in params:
                oauth_params[oauth_param] = params.pop(oauth_param)
            if oauth_param in data:
                oauth_params[oauth_param] = data.pop(oauth_param)

            if params:
                req_kwargs['params'] = params

            if data:
                req_kwargs['data'] = data

    def _get_oauth_params(self, req_kwargs):
        '''Prepares OAuth params for signing.'''
        oauth_params = {}

        oauth_params['oauth_consumer_key'] = self.consumer_key
        oauth_params['oauth_nonce'] = sha1(
            str(random()).encode('ascii')).hexdigest()
        oauth_params['oauth_signature_method'] = self.signature.NAME
        oauth_params['oauth_timestamp'] = int(time())

        if self.access_token is not None:
            oauth_params['oauth_token'] = self.access_token

        oauth_params['oauth_version'] = self.VERSION

        self._parse_optional_params(oauth_params, req_kwargs)

        return oauth_params


class OAuth2Session(RauthSession):
    '''
    A specialized :class:`~requests.sessions.Session` object, wrapping OAuth
    2.0 logic.

    This object is utilized by the :class:`OAuth2Service` wrapper but can
    be used independently of that infrastructure. Essentially this is a loose
    wrapping around the standard Requests codepath. State may be tracked at
    this layer, especially if the instance is kept around and tracked via some
    unique identifier, e.g. access token. Things like request cookies will be
    preserved between requests and in fact all functionality provided by
    a Requests' :class:`~requests.sessions.Session` object should be exposed
    here.

    If you were to use this object by itself you could do so by instantiating
    it like this::

        session = OAuth2Session('123', '456', access_token='321')

    You now have a session object which can be used to make requests exactly as
    you would with a normal Requests :class:`~requests.sessions.Session`
    instance. This anticipates that the standard OAuth 2.0 flow will be modeled
    outside of the scope of this class. In other words, if the fully qualified
    flow is useful to you then this object probably need not be used directly,
    instead consider using :class:`OAuth2Service`.

    Once the session object is setup, you may start making requests::

        r = session.get('https://example/com/api/resource',
                        params={'format': 'json'})
        print r.json()

    :param client_id: Client id, defaults to `None`.
    :type client_id: str
    :param client_secret: Client secret, defaults to `None`
    :type client_secret: str
    :param access_token: Access token, defaults to `None`.
    :type access_token: str
    :param access_token_key: The name of the access token key, defaults to
        `'access_token'`.
    :type access_token_key: str
    :param service: A back reference to the service wrapper, defaults to
        `None`.
    :type service: :class:`rauth.Service`
    :param access_token_key: The name of the access token key, defaults to
        `'access_token'`.
    :type access_token_key: str
    '''
    __attrs__ = RauthSession.__attrs__ + ['client_id',
                                          'client_secret',
                                          'access_token']

    def __init__(self,
                 client_id=None,
                 client_secret=None,
                 access_token=None,
                 service=None,
                 access_token_key=None):

        #: Client credentials.
        self.client_id = client_id
        self.client_secret = client_secret

        #: Access token.
        self.access_token = access_token

        #: Access token key, e.g. 'access_token'.
        self.access_token_key = access_token_key or 'access_token'

        super(OAuth2Session, self).__init__(service)

    def request(self, method, url, bearer_auth=True, **req_kwargs):
        '''
        A loose wrapper around Requests' :class:`~requests.sessions.Session`
        which injects OAuth 2.0 parameters.

        :param method: A string representation of the HTTP method to be used.
        :type method: str
        :param url: The resource to be requested.
        :type url: str
        :param bearer_auth: Whether to use Bearer Authentication or not,
            defaults to `True`.
        :type bearer_auth: bool
        :param \*\*req_kwargs: Keyworded args to be passed down to Requests.
        :type \*\*req_kwargs: dict
        '''
        req_kwargs.setdefault('params', {})

        url = self._set_url(url)

        if is_basestring(req_kwargs['params']):
            req_kwargs['params'] = dict(parse_qsl(req_kwargs['params']))

        if bearer_auth and self.access_token is not None:
            req_kwargs['auth'] = OAuth2Auth(self.access_token)
        else:
            req_kwargs['params'].update({self.access_token_key:
                                         self.access_token})

        req_kwargs.setdefault('timeout', OAUTH2_DEFAULT_TIMEOUT)

        return super(OAuth2Session, self).request(method, url, **req_kwargs)


class OflySession(RauthSession):
    '''
    A specialized :class:`~requests.sessions.Session` object, wrapping Ofly
    logic.

    This object is utilized by the :class:`OflyService` wrapper
    but can be used independently of that infrastructure. Essentially this is a
    loose wrapping around the standard Requests codepath. State may be tracked
    at this layer, especially if the instance is kept around and tracked via
    some unique identifier. Things like request cookies will be preserved
    between requests and in fact all functionality provided by a Requests'
    :class:`~requests.sessions.Session` object should be exposed here.

    If you were to use this object by itself you could do so by instantiating
    it like this::

        session = OflySession('123', '456')

    You now have a session object which can be used to make requests exactly as
    you would with a normal Requests :class:`~requests.sessions.Session`
    instance. This anticipates that the standard Ofly flow will be modeled
    outside of the scope of this class. In other words, if the fully qualified
    flow is useful to you then this object probably need not be used directly,
    instead consider using :class:`OflyService`.

    Once the session object is setup, you may start making requests::

        r = session.get('https://example/com/api/resource',
                        params={'format': 'json'})
        print r.json()

    :param app_id: The oFlyAppId, i.e. "application ID".
    :type app_id: str
    :param app_secret: The oFlyAppSecret, i.e. "shared secret".
    :type app_secret: str
    :param service: A back reference to the service wrapper, defaults to
        `None`.
    :type service: :class:`rauth.Service`
    '''
    __attrs__ = RauthSession.__attrs__ + ['app_id',
                                          'app_secret',
                                          'user_id']

    def __init__(self,
                 app_id,
                 app_secret,
                 user_id=None,
                 service=None):

        #: Client credentials.
        self.app_id = app_id
        self.app_secret = app_secret

        #: oFlyUserid
        self.user_id = user_id

        super(OflySession, self).__init__(service)

    def request(self,
                method,
                url,
                user_id=None,
                hash_meth='sha1',
                **req_kwargs):
        '''
        A loose wrapper around Requests' :class:`~requests.sessions.Session`
        which injects Ofly parameters.

        :param method: A string representation of the HTTP method to be used.
        :type method: str
        :param url: The resource to be requested.
        :type url: str
        :param hash_meth: The hash method to use for signing, defaults to
            "sha1".
        :type hash_meth: str
        :param user_id: The oflyUserid, defaults to `None`.
        :type user_id: str
        :param \*\*req_kwargs: Keyworded args to be passed down to Requests.
        :type \*\*req_kwargs: dict
        '''
        req_kwargs.setdefault('params', {})
        req_kwargs.setdefault('timeout', OFLY_DEFAULT_TIMEOUT)

        url = self._set_url(url)

        user_id = user_id or self.user_id
        assert user_id is not None, \
            'An oflyUserid must be provided as `user_id`.'

        if is_basestring(req_kwargs['params']):
            req_kwargs['params'] = dict(parse_qsl(req_kwargs['params']))

        req_kwargs['params'].update({'oflyUserid': user_id})

        params = OflySession.sign(url,
                                  self.app_id,
                                  self.app_secret,
                                  hash_meth=hash_meth,
                                  **req_kwargs['params'])

        # NOTE: Requests can't seem to handle unicode objects, instead we can
        # encode a string here.
        req_kwargs['params'] = params
        if not isinstance(req_kwargs['params'], bytes):
            req_kwargs['params'] = req_kwargs['params'].encode('utf-8')

        return super(OflySession, self).request(method, url, **req_kwargs)

    @staticmethod
    def sign(url, app_id, app_secret, hash_meth='sha1', **params):
        '''
        A signature method which generates the necessary Ofly parameters.

        :param app_id: The oFlyAppId, i.e. "application ID".
        :type app_id: str
        :param app_secret: The oFlyAppSecret, i.e. "shared secret".
        :type app_secret: str
        :param hash_meth: The hash method to use for signing, defaults to
            "sha1".
        :type hash_meth: str
        :param \*\*params: Additional parameters.
        :type \*\*\params: dict
        '''
        hash_meth_str = hash_meth
        if hash_meth == 'sha1':
            hash_meth = sha1
        elif hash_meth == 'md5':
            hash_meth = md5
        else:
            raise TypeError('hash_meth must be one of "sha1", "md5"')

        now = datetime.utcnow()
        milliseconds = now.microsecond // 1000

        time_format = '%Y-%m-%dT%H:%M:%S.{0}Z'.format(milliseconds)
        ofly_params = {'oflyAppId': app_id,
                       'oflyHashMeth': hash_meth_str.upper(),
                       'oflyTimestamp': now.strftime(time_format)}

        url_path = urlsplit(url).path

        signature_base_string = app_secret + url_path + '?'
        if len(params):
            signature_base_string += get_sorted_params(params) + '&'
        signature_base_string += get_sorted_params(ofly_params)

        if not isinstance(signature_base_string, bytes):
            signature_base_string = signature_base_string.encode('utf-8')

        ofly_params['oflyApiSig'] = \
            hash_meth(signature_base_string).hexdigest()

        all_params = dict(tuple(ofly_params.items()) + tuple(params.items()))

        return get_sorted_params(all_params)

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
'''
    rauth.utils
    -----------

    General utilities.
'''

from rauth.compat import quote, parse_qsl, is_basestring

from requests.structures import CaseInsensitiveDict as cidict
from requests.auth import AuthBase

FORM_URLENCODED = 'application/x-www-form-urlencoded'
ENTITY_METHODS = ('POST', 'PUT', 'PATCH')
OPTIONAL_OAUTH_PARAMS = ('oauth_callback', 'oauth_verifier', 'oauth_version')


def absolute_url(url):
    return url.startswith(('http://', 'https://'))


def parse_utf8_qsl(s):
    d = dict(parse_qsl(s))

    for k, v in d.items():  # pragma: no cover
        if not isinstance(k, bytes) and not isinstance(v, bytes):
            # skip this iteration if we have no keys or values to update
            continue
        d.pop(k)
        if isinstance(k, bytes):
            k = k.decode('utf-8')
        if isinstance(v, bytes):
            v = v.decode('utf-8')
        d[k] = v
    return d


def get_sorted_params(params):
    def sorting_gen():
        for k in sorted(params.keys()):
            yield '='.join((k, params[k]))
    return '&'.join(sorting_gen())


class CaseInsensitiveDict(cidict):
    def __init__(self, d=None):
        lowered_d = {}

        if d is not None:
            if isinstance(d, dict):
                lowered_d = self._get_lowered_d(d)
            elif isinstance(d, list):
                return self.__init__(dict(d))

        return super(CaseInsensitiveDict, self).__init__(lowered_d)

    def _get_lowered_d(self, d):
        lowered_d = {}
        for key in d:
            if is_basestring(key):
                lowered_d[key.lower()] = d[key]
            else:  # pragma: no cover
                lowered_d[key] = d[key]
        return lowered_d

    def setdefault(self, key, default):
        if is_basestring(key):
            key = key.lower()

        super(CaseInsensitiveDict, self).setdefault(key, default)

    def update(self, d):
        super(CaseInsensitiveDict, self).update(self._get_lowered_d(d))


class OAuth2Auth(AuthBase):
    ''' Attaches OAuth 2 Authentication to a given Request object. '''
    def __init__(self, access_token):
        self.access_token = access_token

    def __call__(self, r):
        r.headers['Authorization'] = 'Bearer ' + self.access_token
        return r


class OAuth1Auth(AuthBase):
    ''' Attaches OAuth 1 Authentication to a given Request object. '''
    def __init__(self, oauth_params, realm=None):
        self.oauth_params = oauth_params
        self.realm = realm or ''

    def _get_auth_header(self):
        ''' Constructs and returns an authentication header. '''
        realm = 'realm="{realm}"'.format(realm=self.realm)
        params = ['{k}="{v}"'.format(k=k, v=quote(str(v)))
                  for k, v in self.oauth_params.items()]
        return 'OAuth ' + ','.join([realm] + params)

    def __call__(self, r):
        r.headers['Authorization'] = self._get_auth_header()
        return r

########NEW FILE########
__FILENAME__ = __about__
__title__ = 'rauth'
__version_info__ = ('0', '7', '0')
__version__ = '.'.join(__version_info__)
__author__ = 'Max Countryman'
__license__ = 'MIT'
__copyright__ = 'Copyright 2013 litl'

########NEW FILE########
__FILENAME__ = base
# -*- coding: utf-8 -*-
'''
    rauth.base
    ----------

    Test suite common infrastructure.
'''

import json

import requests
import unittest

from copy import deepcopy


if not hasattr(unittest.TestCase, 'assertIsNotNone'):
    try:
        import unittest2 as unittest
    except ImportError:
        raise RuntimeError('unittest2 is required to run the rauth test suite')

from inspect import stack, isfunction

from mock import Mock
from nose.tools import nottest


class RauthTestCase(unittest.TestCase):
    def setUp(self):
        response = Mock()
        response.content = json.dumps({'status': 'ok'})
        response.headers = {'Content-Type': 'application/json'}
        response.ok = True
        response.status_code = requests.codes.ok
        self.response = response


def _new_func(func_name, func, f):
    def decorated(cls):
        return func(cls, *deepcopy(f()))
    decorated.__name__ = func_name
    return decorated


def parameterize(iterable):
    '''
    Based on nose-parameterized, distilled for "brute force" usage. Also
    modified to display more informative function names, i.e. actual input.
    Useful for debugging purposes.
    '''
    def decorated(func):
        frame = stack()[1]
        frame_locals = frame[0].f_locals

        base_name = func.__name__
        for f in iterable:
            if not isfunction(f):
                raise TypeError('Arguments should be wrapped in a function.')
            name_suffix = ' --> ' + '(' + str(f()[-1]) + ')'
            name = base_name + name_suffix
            new_func = _new_func(name, func, f)
            frame_locals[name] = new_func
        return nottest(func)
    return decorated

########NEW FILE########
__FILENAME__ = test_oauth
# -*- coding: utf-8 -*-
'''
    rauth.test_oauth
    ------------------

    Test suite for rauth.oauth.
'''

from base import RauthTestCase
from rauth.oauth import (HmacSha1Signature, RsaSha1Signature,
                         PlaintextSignature)
from rauth.utils import FORM_URLENCODED

# HACK: give a more informative error message if we're missing deps here
try:
    from Crypto.PublicKey import RSA
except ImportError:
    raise RuntimeError('PyCrypto is required to run the rauth test suite')

try:
    stringtype = unicode  # python 2
except NameError:
    stringtype = str  # python 3

assert RSA


class OAuthTestHmacSha1Case(RauthTestCase):
    consumer_secret = '456'
    access_token_secret = '654'
    method = 'GET'
    url = 'http://example.com/'
    oauth_params = {}
    req_kwargs = {'params': {'foo': 'bar'}}

    def test_hmacsha1_signature(self):
        oauth_signature = HmacSha1Signature().sign(self.consumer_secret,
                                                   self.access_token_secret,
                                                   self.method,
                                                   self.url,
                                                   self.oauth_params,
                                                   self.req_kwargs)
        self.assertIsNotNone(oauth_signature)
        self.assertIsInstance(oauth_signature, stringtype)
        self.assertEqual(oauth_signature, 'cYzjVXCOk62KoYmJ+iCvcAcgfp8=')

    def test_normalize_request_parameters_params(self):
        # params as a dict
        normalized = HmacSha1Signature()\
            ._normalize_request_parameters(self.oauth_params, self.req_kwargs)
        self.assertEqual('foo=bar',  normalized)

        # params as a dict with URL encodable chars
        normalized = HmacSha1Signature()\
            ._normalize_request_parameters(self.oauth_params,
                                           {'params': {'foo+bar': 'baz'}})
        self.assertEqual('foo%2Bbar=baz',  normalized)
        self.assertNotIn('+', normalized)

        # params and dict as dicts
        req_kwargs = {'params': {'a': 'b'},
                      'data': {'foo': 'bar'},
                      'headers': {'Content-Type': FORM_URLENCODED}}

        normalized = HmacSha1Signature()\
            ._normalize_request_parameters({}, req_kwargs)
        self.assertEqual('a=b&foo=bar',  normalized)

    def test_normalize_request_parameters_data(self):
        # data as a dict
        req_kwargs = {'data': {'foo': 'bar'},
                      'headers': {'Content-Type': FORM_URLENCODED}}
        normalized = HmacSha1Signature()\
            ._normalize_request_parameters(self.oauth_params, req_kwargs)
        self.assertEqual('foo=bar',  normalized)

        # data as a dict with URL encodable chars
        req_kwargs = {'data': {'foo+bar': 'baz'},
                      'headers': {'Content-Type': FORM_URLENCODED}}
        normalized = HmacSha1Signature()\
            ._normalize_request_parameters({}, req_kwargs)
        self.assertEqual('foo%2Bbar=baz',  normalized)
        self.assertNotIn('+', normalized)

        normalized = HmacSha1Signature()\
            ._normalize_request_parameters(self.oauth_params, req_kwargs)
        self.assertEqual('foo%2Bbar=baz',  normalized)
        self.assertNotIn('+', normalized)

    def test_normalize_request_parameters_whitespace(self):
        req_kwargs = {'data': {'foo': 'bar baz'},
                      'headers': {'Content-Type': FORM_URLENCODED}}
        normalized = HmacSha1Signature()\
            ._normalize_request_parameters(self.oauth_params, req_kwargs)
        self.assertEqual('foo=bar%20baz', normalized)

    def test_sign_utf8_encoded_string(self):
        # in the event a string is already UTF-8
        req_kwargs = {u'params': {u'foo': u'bar'}}
        sig = HmacSha1Signature().sign(self.consumer_secret,
                                       self.access_token_secret,
                                       u'GET',
                                       self.url,
                                       self.oauth_params,
                                       req_kwargs)
        self.assertEqual('cYzjVXCOk62KoYmJ+iCvcAcgfp8=',  sig)

    def test_sign_with_data(self):
        # in the event a string is already UTF-8
        req_kwargs = {'data': {'foo': 'bar'}}
        method = 'POST'
        sig = HmacSha1Signature().sign(self.consumer_secret,
                                       self.access_token_secret,
                                       method,
                                       self.url,
                                       self.oauth_params,
                                       req_kwargs)
        self.assertEqual('JzmJUmqjdNYBJsJWbtQKXnc0W8w=',  sig)

    def test_remove_query_string(self):
        # can't sign the URL with the query string so
        url = 'http://example.com/?foo=bar'
        signable_url = HmacSha1Signature()._remove_qs(url)
        self.assertEqual('http://example.com/', signable_url)

    def test_normalize_request_parameters_data_not_urlencoded(self):
        # not sending the 'application/x-www-form-urlencoded' header
        # therefore the data will not be included in the signature
        req_kwargs = {'data': {'foo': 'bar'}}
        normalized = HmacSha1Signature()\
            ._normalize_request_parameters(self.oauth_params, req_kwargs)
        self.assertEqual('',  normalized)

        req_kwargs = {'params': {'a': 'b'}, 'data': {'foo': 'bar'}}
        normalized = HmacSha1Signature()\
            ._normalize_request_parameters({}, req_kwargs)
        self.assertEqual('a=b',  normalized)

    def test_normalize_request_parameters_data_not_alphanumeric(self):
        # data is not alphanumeric (for example: Japanese)
        try:
            from urllib import unquote
        except ImportError:
            from urllib.parse import unquote

        # unicode
        req_kwargs = {u'params': {u'foo': u''}}
        normalized = HmacSha1Signature()\
            ._normalize_request_parameters({}, req_kwargs)

        key, value = normalized.split('=')
        decoded_value = unquote(value)
        self.assertEqual('', unquote(decoded_value))

        # str
        req_kwargs = {'params': {'foo': ''}}
        normalized = HmacSha1Signature()\
            ._normalize_request_parameters({}, req_kwargs)

        key, value = normalized.split('=')
        decoded_value = unquote(value)
        self.assertEqual('', unquote(decoded_value))


class OAuthTestRsaSha1Case(RauthTestCase):
    private_key = '''-----BEGIN RSA PRIVATE KEY-----
        MIICXQIBAAKBgQDf0jdU+07T1B9erQBNS46JmvO7vsNfdNXkoEx4UwLwqsmv1wKs
        RvCXBVyNYnnHYVQjSDRgyviNLYSP01DXqmwKlhSN9sbjiCeswXlG2B4BdFdO687J
        9ZOmeyZsb6OFlXWediqkfvDaArSPM884YB2A8rqJd2y8Hd4tSG2Ns2o7WwIDAQAB
        AoGBAMJ8FO54LMfuU4/d/hwsImA5z759BaGFkXLHQ4tufmiHzxdHWqA+SELCOujz
        /+ObFBRQYosU86MhQUYElgPAp31u6MfmNc7nPvtuy1rSYVYD05oUqeyKBCycZa9r
        F9+5ASNdvYF/vvAj5gQ2aOZPGsTf80hrUIDt2ebJn1yq3R1BAkEA49qUpQbKHDdJ
        I9CZiiptySClyxyR3++oPw1UR9vfTz0qkzExYeS59TROX+sVpcpp/LFeTV8HeDVl
        nUEv3xtEYQJBAPt4HDw21gRqL0W3V7xQIrCBnzttBA83y3hUpn1wRelJnnVsAUwv
        KtxFZPSTprDFf3eTJP5vWEYcM4CME7L0GTsCQDAg1HMDOx+4oc9Z2YSwr53jMoHz
        l/B4O86Nrza6f7HKFrsekfK+kHT1xnRGQL1TQw3oHSY0o2xFwx/zS/xRUyECQQDA
        k/ojjucVWHA9Vqwk9cWrIIleDB2YveTfkQwzciDICG4GhKD1xAVxzN8EgnKcW5ND
        cndZNtIGVyCF6EBJwq/zAkBjcXFUJMXXYiIzIpKJD2ZEMms2PXBkB0OxG+Yr0r4G
        /w3QafaS0cyRCu0z0fY52+wcn5VrHk97sLQhLMQv07ij
        -----END RSA PRIVATE KEY-----'''
    method = 'GET'
    url = 'http://example.com/'
    oauth_params = {}
    req_kwargs = {'params': {'foo': 'bar'}}

    def test_rsasha1_signature(self):
        oauth_signature = RsaSha1Signature().sign(self.private_key,
                                                  None,
                                                  self.method,
                                                  self.url,
                                                  self.oauth_params,
                                                  self.req_kwargs)
        self.assertIsNotNone(oauth_signature)
        self.assertIsInstance(oauth_signature, stringtype)
        self.assertEqual(oauth_signature,
                         'MEnbOKBw0lWi5NvGyrABQ6tPygWiNOjGz47y8d+SQfXYrzsvK'
                         'kzcMgt2VGBRgKsKSdFho36TuCuP75Qe1uou6/rhHrZoSppQ+6'
                         'vdPSKkriGzSK3azqBacg9ZIIVy/atHPTm6BAvo+0v4ysiI9ci'
                         '7hJbRkXL0NJVz/p0ZQKO/Jds=')

    def test_rsasha1_badargument(self):
        self.assertRaises(ValueError, RsaSha1Signature().sign,
                          None, None,
                          self.method,
                          self.url,
                          self.oauth_params,
                          self.req_kwargs)


class OAuthTestPlaintextCase(RauthTestCase):
    def test_plaintext_notimplemented(self):
        self.assertRaises(NotImplementedError, PlaintextSignature)

########NEW FILE########
__FILENAME__ = test_service
# -*- coding: utf-8 -*-
'''
    rauth.test_service
    ------------------

    Test suite for rauth.service.
'''

from base import parameterize

from copy import deepcopy
from datetime import datetime

import json
import pickle


class MutableDatetime(datetime):
    def __new__(cls, *args, **kwargs):
        return datetime.__new__(datetime, *args, **kwargs)


class FakeHexdigest(object):
    def __init__(self, *args):
        pass

    def hexdigest(self):
        return 'foo'


class HttpMixin(object):
    http_url = 'http://example.com/'

    def assert_ok(self, r):
        self.assertEqual(json.loads(r.content), {'status': 'ok'})

    def test_get(self):
        r = self.session.get(self.http_url)
        self.assert_ok(r)

    def test_options(self):
        r = self.session.options(self.http_url)
        self.assert_ok(r)

    def test_head(self):
        r = self.session.head(self.http_url)
        self.assert_ok(r)

    def test_post(self):
        r = self.session.post(self.http_url)
        self.assert_ok(r)

    def test_put(self):
        r = self.session.put(self.http_url)
        self.assert_ok(r)

    def test_patch(self):
        r = self.session.patch(self.http_url)
        self.assert_ok(r)

    def test_delete(self):
        r = self.session.delete(self.http_url)
        self.assert_ok(r)


def input_product_gen():
    all_params = [{},
                  '',
                  {'foo': 'bar'},
                  {'foo': 'bar baz'},
                  {'foo': 'bar=baz&a=b'},
                  {u'foo': u'bar'},
                  {'f': 'br'},
                  {u'f': u'br'},
                  'foo=bar',
                  'foo=bar baz',
                  'foo=bar&a=b',
                  u'foo=bar',
                  'f=br',
                  u'f=br']

    all_data = deepcopy(all_params)

    all_headers = [{},
                   {'x-foo-bar': 'baz'},
                   {u'x-foo-bar': u'baz'},
                   {'x-foo-bar': 'bz'},
                   {u'x-foo-bar': u'bz'},
                   {'x-foo-bar': 'baz foo'},
                   {u'x-foo-bar': u'baz foo'},
                   {'x-foo-bar': 'bz foo'},
                   {u'x-foo-bar': u'bz foo'},
                   {'Content-Type': 'application/x-www-form-urlencoded'},
                   {'Content-Type': 'application/json'}]

    for p in all_params:
        method = 'GET'
        for d in all_data:
            if d:
                method = 'POST'
            for h in all_headers:
                kwargs = {}

                kwargs['params'] = p
                kwargs['data'] = d
                kwargs['headers'] = h

                yield lambda m=method, k=kwargs: (m, k)


class RequestMixin(object):
    @parameterize(input_product_gen())
    def test_request(self, method, kwargs):
        r = self.session.request(method, 'foo', **kwargs)
        self.assert_ok(r)


class ServiceMixin(object):
    def test_serialize(self):
        saved = pickle.loads(pickle.dumps(self.service))
        for attr in self.service.__attrs__:
            self.assertEqual(getattr(saved, attr), getattr(self.service, attr))

########NEW FILE########
__FILENAME__ = test_service_oauth1
# -*- coding: utf-8 -*-
'''
    rauth.test_service_oauth1
    -------------------------

    Test suite for rauth.service.OAuth1Service.
'''

from base import RauthTestCase
from test_service import HttpMixin, RequestMixin, ServiceMixin

from rauth.compat import parse_qsl, quote, is_basestring, iteritems
from rauth.service import OAuth1Service
from rauth.session import OAUTH1_DEFAULT_TIMEOUT, OAuth1Session
from rauth.utils import CaseInsensitiveDict, ENTITY_METHODS, FORM_URLENCODED

from copy import deepcopy
from hashlib import sha1

from mock import patch

import rauth

import requests

import json
import pickle


class OAuth1ServiceTestCase(RauthTestCase, RequestMixin, ServiceMixin,
                            HttpMixin):
    consumer_key = '000'
    consumer_secret = '111'

    access_token = '123'
    access_token_secret = '456'

    def setUp(self):
        RauthTestCase.setUp(self)

        self.request_token_url = 'http://example.com/request'
        self.access_token_url = 'http://example.com/access'
        self.authorize_url = 'http://example.com/authorize'
        self.base_url = 'http://example.com/api/'

        self.service = OAuth1Service(self.consumer_key,
                                     self.consumer_secret,
                                     name='service',
                                     request_token_url=self.request_token_url,
                                     access_token_url=self.access_token_url,
                                     authorize_url=self.authorize_url,
                                     base_url=self.base_url)

        self.session = self.service.get_session(('123', '456'))

        # patches
        self.session.request = self.fake_request
        self.service.get_session = self.fake_get_session

    def fake_get_auth_header(self, oauth_params, realm=None):
        auth_header = 'OAuth realm="{realm}"'.format(realm=realm)
        params = ''
        for k, v in iteritems(oauth_params):
            params += ',{key}="{value}"'.format(key=k, value=quote(str(v)))
        auth_header += params
        return auth_header

    @patch.object(rauth.session.HmacSha1Signature, 'sign')
    @patch.object(rauth.session, 'time')
    @patch.object(rauth.session, 'random')
    @patch.object(requests.Session, 'request')
    def fake_request(self,
                     method,
                     url,
                     mock_request,
                     mock_random,
                     mock_time,
                     mock_sig,
                     header_auth=False,
                     realm='',
                     **kwargs):
        fake_random = 1
        fake_time = 1
        fake_sig = 'foo'
        fake_sig_meth = 'HMAC-SHA1'
        fake_nonce = sha1(str(fake_random).encode('ascii')).hexdigest()

        mock_request.return_value = self.response
        mock_random.return_value = fake_random
        mock_time.return_value = fake_time
        mock_sig.return_value = fake_sig

        method = method
        url = self.session._set_url(url)

        service = OAuth1Service(self.consumer_key,
                                self.consumer_secret,
                                name='service',
                                request_token_url=self.request_token_url,
                                access_token_url=self.access_token_url,
                                authorize_url=self.authorize_url,
                                base_url=self.base_url)

        session = service.get_session((self.access_token,
                                       self.access_token_secret))

        r = session.request(method,
                            url,
                            header_auth=header_auth,
                            realm=realm,
                            **deepcopy(kwargs))

        kwargs.setdefault('headers', {})
        kwargs['headers'] = CaseInsensitiveDict(kwargs['headers'])

        entity_method = method.upper() in ENTITY_METHODS
        if entity_method:
            kwargs['headers'].setdefault('Content-Type', FORM_URLENCODED)

        form_urlencoded = \
            kwargs['headers'].get('Content-Type') == FORM_URLENCODED

        if is_basestring(kwargs.get('params')):
            kwargs['params'] = dict(parse_qsl(kwargs['params']))

        if is_basestring(kwargs.get('data')) and form_urlencoded:
            kwargs['data'] = dict(parse_qsl(kwargs['data']))

        oauth_params = {'oauth_consumer_key': session.consumer_key,
                        'oauth_nonce': fake_nonce,
                        'oauth_signature_method': fake_sig_meth,
                        'oauth_timestamp': fake_time,
                        'oauth_token': self.access_token,
                        'oauth_version': session.VERSION,
                        'oauth_signature': fake_sig}

        if header_auth:
            auth = mock_request.call_args[1]['auth']
            auth_header = self.fake_get_auth_header(oauth_params, realm=realm)
            self.assertEqual(auth(requests.Request()).headers['Authorization'],
                             auth_header)
            kwargs['auth'] = auth
        elif entity_method:
            kwargs['data'] = kwargs.get('data') or {}

            if form_urlencoded:
                kwargs['data'].update(oauth_params)
            else:
                kwargs.setdefault('params', {})
                kwargs['params'].update(oauth_params)
        else:
            kwargs.setdefault('params', {})
            kwargs['params'].update(**oauth_params)

        mock_request.assert_called_with(method,
                                        url,
                                        timeout=OAUTH1_DEFAULT_TIMEOUT,
                                        **kwargs)
        return r

    def fake_get_session(self, token=None, signature=None):
        return self.session

    def test_get_session(self):
        s = self.service.get_session()
        self.assertIsInstance(s, OAuth1Session)

    def test_get_raw_request_token(self):
        resp = 'oauth_token=foo&oauth_token_secret=bar'
        self.response.content = resp
        r = self.service.get_raw_request_token()
        self.assertEqual(r.content, resp)

    def test_get_raw_request_token_missing_request_token_url(self):
        self.service.request_token_url = None
        resp = 'oauth_token=foo&oauth_token_secret=bar'
        self.response.content = resp
        with self.assertRaises(TypeError) as e:
            self.service.get_raw_request_token()
        self.assertEqual(str(e.exception),
                         'request_token_url must not be None')

    def test_get_request_token(self):
        self.response.content = 'oauth_token=foo&oauth_token_secret=bar'
        request_token, request_token_secret = self.service.get_request_token()
        self.assertEqual(request_token, 'foo')
        self.assertEqual(request_token_secret, 'bar')

    def test_get_request_token_with_json_decoder(self):
        self.response.content = json.dumps({'oauth_token': 'foo',
                                            'oauth_token_secret': 'bar'})
        request_token, request_token_secret = \
            self.service.get_request_token(decoder=json.loads)
        self.assertEqual(request_token, 'foo')
        self.assertEqual(request_token_secret, 'bar')

    def test_get_authorize_url(self):
        self.response.content = 'oauth_token=foo&oauth_token_secret=bar'
        request_token, request_token_secret = self.service.get_request_token()

        url = self.service.get_authorize_url(request_token)
        expected_fmt = 'http://example.com/authorize?oauth_token={0}'
        self.assertEqual(url, expected_fmt.format(request_token))

    def test_get_authorize_url_with_url_encoded_characters(self):
        token = 'uDV8XWNLSJjzMUSVfbG1gYHWMjY%3D'
        token_secret = 'e%2Bt9QCndiw1%2BtJbhy5UYVMAPTPo%3D'
        response_fmt = 'oauth_token={0}&oauth_token_secret={1}'
        self.response.content = response_fmt.format(token, token_secret)
        request_token, request_token_secret = self.service.get_request_token()

        url = self.service.get_authorize_url(request_token)
        expected_fmt = 'http://example.com/authorize?oauth_token={0}'
        self.assertEqual(url, expected_fmt.format(token))

    def test_get_raw_access_token(self):
        self.response.content = 'oauth_token=foo&oauth_token_secret=bar'
        request_token, request_token_secret = self.service.get_request_token()

        resp = 'oauth_token=foo&oauth_token_secret=bar'
        self.response.content = resp
        r = self.service.get_raw_access_token(request_token,
                                              request_token_secret)
        self.assertEqual(r.content, resp)

    def test_get_raw_access_token_missing_access_token_url(self):
        self.response.content = 'oauth_token=foo&oauth_token_secret=bar'
        request_token, request_token_secret = self.service.get_request_token()

        self.service.access_token_url = None
        self.response.content = 'oauth_token=foo&oauth_token_secret=bar'

        with self.assertRaises(TypeError) as e:
            self.service.get_raw_access_token(request_token,
                                              request_token_secret)
        self.assertEqual(str(e.exception),
                         'access_token_url must not be None')

    def test_get_access_token(self):
        self.response.content = 'oauth_token=foo&oauth_token_secret=bar'
        request_token, request_token_secret = self.service.get_request_token()

        self.response.content = 'oauth_token=foo&oauth_token_secret=bar'
        access_token, access_token_secret = \
            self.service.get_access_token(request_token,
                                          request_token_secret)
        self.assertEqual(access_token, 'foo')
        self.assertEqual(access_token_secret, 'bar')

    def test_get_access_token_with_json_decoder(self):
        self.response.content = 'oauth_token=foo&oauth_token_secret=bar'
        request_token, request_token_secret = self.service.get_request_token()

        self.response.content = json.dumps({'oauth_token': 'foo',
                                            'oauth_token_secret': 'bar'})
        access_token, access_token_secret = \
            self.service.get_access_token(request_token,
                                          request_token_secret,
                                          decoder=json.loads)
        self.assertEqual(access_token, 'foo')
        self.assertEqual(access_token_secret, 'bar')

    def test_request_with_optional_params_oauth_callback(self):
        params = {'oauth_callback': 'http://example.com/callback'}
        r = self.session.request('GET', 'http://example.com/', params=params)
        self.assert_ok(r)

    def test_request_with_optional_params_oauth_verifier(self):
        params = {'oauth_verifier': 'foo'}
        r = self.session.request('GET', 'http://example.com/', params=params)
        self.assert_ok(r)

    def test_request_with_optional_params_oauth_version(self):
        params = {'oauth_verifier': 'foo'}
        r = self.session.request('GET', 'http://example.com/', params=params)
        self.assert_ok(r)

    def test_request_with_optional_params_as_string(self):
        params = 'oauth_callback=http://example.com/callback'
        r = self.session.request('GET', 'http://example.com/', params=params)
        self.assert_ok(r)

    def test_request_with_optional_data_as_string(self):
        data = 'oauth_callback=http://example.com/callback'
        r = self.session.request('POST', 'http://example.com/', data=data)
        self.assert_ok(r)

    def test_request_with_optional_params_with_data(self):
        data = {'oauth_callback': 'http://example.com/callback'}
        r = self.session.request('POST', 'http://example.com/', data=data)
        self.assert_ok(r)

    def test_request_with_header_auth(self):
        r = self.session.request('GET',
                                 'http://example.com/',
                                 header_auth=True)
        self.assert_ok(r)

    def test_request_with_header_auth_with_realm(self):
        r = self.session.request('GET',
                                 'http://example.com/',
                                 header_auth=True,
                                 realm='http://example.com/foo/')
        self.assert_ok(r)

    def test_get_auth_session(self):
        resp = 'oauth_token=foo&oauth_token_secret=bar'
        self.response.content = resp
        s = self.service.get_auth_session('foo', 'bar')
        self.assertIsInstance(s, OAuth1Session)

    def test_get_auth_session_with_request_token_response(self):
        resp = 'oauth_token=foo&oauth_token_secret=bar'
        self.response.content = resp
        self.service.request_token_response = 'ok'
        s = self.service.get_auth_session('foo', 'bar')
        self.assertEqual(s.request_token_response, 'ok')

    def test_pickle_session(self):
        session = pickle.loads(pickle.dumps(self.session))

        # Add the fake request back to the session
        session.request = self.fake_request
        r = session.request('GET', 'http://example.com/', header_auth=True)
        self.assert_ok(r)

########NEW FILE########
__FILENAME__ = test_service_oauth2
# -*- coding: utf-8 -*-
'''
    rauth.test_service_oauth2
    -------------------------

    Test suite for rauth.service.OAuth2Service.
'''

from base import RauthTestCase
from test_service import HttpMixin, RequestMixin, ServiceMixin

from rauth.service import OAuth2Service
from rauth.session import OAUTH2_DEFAULT_TIMEOUT, OAuth2Session
from rauth.compat import parse_qsl, is_basestring

from copy import deepcopy
from mock import patch

import requests

import json
import pickle


class OAuth2ServiceTestCase(RauthTestCase, RequestMixin, ServiceMixin,
                            HttpMixin):
    client_id = '000'
    client_secret = '111'
    access_token = '123'

    def setUp(self):
        RauthTestCase.setUp(self)

        self.access_token_url = 'https://example.com/access'
        self.authorize_url = 'https://example.com/authorize'
        self.base_url = 'https://example/api/'

        self.service = OAuth2Service(self.client_id,
                                     self.client_secret,
                                     access_token_url=self.access_token_url,
                                     authorize_url=self.authorize_url,
                                     base_url=self.base_url)

        self.session = self.service.get_session(self.access_token)

        # patches
        self.session.request = self.fake_request
        self.service.get_session = self.fake_get_session

    @patch.object(requests.Session, 'request')
    def fake_request(self,
                     method,
                     url,
                     mock_request,
                     bearer_auth=False,
                     **kwargs):
        mock_request.return_value = self.response

        url = self.session._set_url(url)

        service = OAuth2Service(self.client_id,
                                self.client_secret,
                                access_token_url=self.access_token_url,
                                authorize_url=self.authorize_url,
                                base_url=self.base_url)

        session = service.get_session(self.access_token)
        r = session.request(method,
                            url,
                            bearer_auth=bearer_auth,
                            **deepcopy(kwargs))

        kwargs.setdefault('params', {})

        if is_basestring(kwargs.get('params', {})):
            kwargs['params'] = dict(parse_qsl(kwargs['params']))

        if bearer_auth and self.access_token is not None:
            auth = mock_request.call_args[1]['auth']
            self.assertEqual(auth.access_token, self.access_token)
            kwargs['auth'] = auth
        else:
            kwargs['params'].update({'access_token':
                                     self.access_token})

        mock_request.assert_called_with(method,
                                        url,
                                        timeout=OAUTH2_DEFAULT_TIMEOUT,
                                        **kwargs)
        return r

    def fake_get_session(self, token=None):
        return self.session

    def test_get_session(self):
        s = self.service.get_session()
        self.assertIsInstance(s, OAuth2Session)

    def test_get_authorize_url(self):
        url = self.service.get_authorize_url()
        expected_fmt = 'https://example.com/authorize?client_id={0}'
        self.assertEqual(url, expected_fmt.format(self.service.client_id))

    def test_get_raw_access_token(self):
        resp = 'access_token=123&expires_in=3600&refresh_token=456'
        self.response.content = resp
        r = self.service.get_raw_access_token()
        self.assertEqual(r.content, resp)

    def test_get_raw_access_token_with_params(self):
        resp = 'access_token=123&expires_in=3600&refresh_token=456'
        self.response.content = resp
        r = self.service.get_raw_access_token(params={'a': 'b'})
        self.assertEqual(r.content, resp)

    def test_get_access_token(self):
        self.response.content = \
            'access_token=123&expires_in=3600&refresh_token=456'
        access_token = self.service.get_access_token()
        self.assertEqual(access_token, '123')

    def test_get_access_token_with_json_decoder(self):
        self.response.content = json.dumps({'access_token': '123',
                                            'expires_in': '3600',
                                            'refresh_token': '456'})
        access_token = self.service.get_access_token(decoder=json.loads)
        self.assertEqual(access_token, '123')

    def test_request_with_bearer_auth(self):
        r = self.session.request('GET',
                                 'http://example.com/',
                                 bearer_auth=True)
        self.assert_ok(r)

    def test_get_auth_session(self):
        self.response.content = \
            'access_token=123&expires_in=3600&refresh_token=456'
        s = self.service.get_auth_session()
        self.assertIsInstance(s, OAuth2Session)

    def test_get_auth_session_with_access_token_response(self):
        self.response.content = \
            'access_token=123&expires_in=3600&refresh_token=456'
        s = self.service.get_auth_session()
        self.assertIsNotNone(s.access_token_response)

    def test_pickle_session(self):
        session = pickle.loads(pickle.dumps(self.session))

        # Add the fake request back to the session
        session.request = self.fake_request
        r = session.request('GET', 'http://example.com/', bearer_auth=True)
        self.assert_ok(r)

########NEW FILE########
__FILENAME__ = test_service_ofly
# -*- coding: utf-8 -*-
'''
    rauth.test_service_ofly
    -----------------------

    Test suite for rauth.service.OflyService.
'''

from base import RauthTestCase
from test_service import (FakeHexdigest, HttpMixin, MutableDatetime,
                          RequestMixin, ServiceMixin)

from rauth.compat import parse_qsl, urlsplit, is_basestring
from rauth.service import OflyService
from rauth.session import OFLY_DEFAULT_TIMEOUT, OflySession

from copy import deepcopy
from datetime import datetime
from functools import wraps

from mock import patch

import requests

import pickle


class OflyServiceTestCase(RauthTestCase, RequestMixin, ServiceMixin,
                          HttpMixin):
    app_id = '000'
    app_secret = '111'

    user_id = '123'

    def setUp(self):
        RauthTestCase.setUp(self)

        self.authorize_url = 'http://example.com/authorize'
        self.base_url = 'http://example.com/api/'

        self.service = OflyService(self.app_id,
                                   self.app_secret,
                                   name='service',
                                   authorize_url=self.authorize_url,
                                   base_url=self.base_url)

        self.session = self.service.get_session(self.user_id)

        # patch
        self.session.request = self.fake_request
        self.service.get_session = self.fake_get_session

    def fake_get_sorted_params(self, params):
        def sorting_gen():
            for k in sorted(params.keys()):
                yield '='.join((k, params[k]))
        return '&'.join(sorting_gen())

    def fake_sign(app_id, user_id):
        def wrap(func):
            @wraps(func)
            @patch('rauth.session.datetime', MutableDatetime)
            @patch('rauth.session.md5', FakeHexdigest)
            @patch('rauth.session.sha1', FakeHexdigest)
            def decorated(*args, **kwargs):
                hash_meth = kwargs.get('hash_meth', 'sha1').upper()
                ofly_params = {'oflyAppId': app_id,
                               'oflyHashMeth': hash_meth,
                               'oflyTimestamp': '1900-01-01T00:00:00.0Z',
                               'oflyApiSig': 'foo',
                               'oflyUserid': user_id}

                MutableDatetime.utcnow = \
                    classmethod(lambda cls: datetime(1900, 1, 1))
                return func(ofly_params=ofly_params, *args, **kwargs)
            return decorated
        return wrap

    @patch.object(requests.Session, 'request')
    @fake_sign(app_id, user_id)
    def fake_request(self,
                     method,
                     url,
                     mock_request,
                     ofly_params,
                     user_id=None,
                     hash_meth='sha1',
                     **kwargs):
        mock_request.return_value = self.response

        user_id = user_id or self.service.user_id

        service = OflyService(self.app_id,
                              self.app_secret,
                              name='service',
                              authorize_url=self.authorize_url,
                              base_url=self.base_url)

        session = service.get_session(self.user_id)

        r = session.request(method,
                            url,
                            user_id=user_id,
                            hash_meth=hash_meth,
                            **deepcopy(kwargs))

        url = self.session._set_url(url)

        kwargs.setdefault('params', {})
        if is_basestring(kwargs['params']):
            kwargs['params'] = dict(parse_qsl(kwargs['params']))

        url_path = urlsplit(url).path

        signature_base_string = self.service.app_secret + url_path + '?'

        if len(kwargs['params']):
            signature_base_string += \
                self.fake_get_sorted_params(kwargs['params']) + '&'

        signature_base_string += self.fake_get_sorted_params(ofly_params)

        all_params = dict(tuple(ofly_params.items())
                          + tuple(kwargs['params'].items()))

        kwargs['params'] = self.fake_get_sorted_params(all_params)
        if not isinstance(kwargs['params'], bytes):
            kwargs['params'] = kwargs['params'].encode('utf-8')

        mock_request.assert_called_with(method,
                                        url,
                                        timeout=OFLY_DEFAULT_TIMEOUT,
                                        **kwargs)
        return r

    def fake_get_session(self, token):
        return self.session

    def test_get_session(self):
        s = self.service.get_session('foo')
        self.assertIsInstance(s, OflySession)

    @fake_sign(app_id, user_id)
    def test_get_authorize_url(self, ofly_params):
        expected_url = 'http://example.com/authorize?'
        ofly_params.pop('oflyUserid')
        params = self.fake_get_sorted_params(ofly_params)
        url = self.service.get_authorize_url()
        self.assertEqual(url, expected_url + params)

    def test_request_with_md5(self):
        r = self.session.request('GET',
                                 'http://example.com/',
                                 user_id=self.user_id,
                                 hash_meth='md5')
        self.assert_ok(r)

    def test_request_with_bad_hash_meth(self):
        with self.assertRaises(TypeError) as e:
            self.session.request('GET',
                                 'http://example.com/',
                                 user_id=self.user_id,
                                 hash_meth='foo')
        self.assertEqual(str(e.exception),
                         'hash_meth must be one of "sha1", "md5"')

    def test_get_auth_session(self):
        s = self.service.get_auth_session('foo')
        self.assertIsInstance(s, OflySession)

    def test_pickle_session(self):
        session = pickle.loads(pickle.dumps(self.session))

        # Add the fake request back to the session
        session.request = self.fake_request
        r = self.session.request('GET',
                                 'http://example.com/',
                                 user_id=self.user_id,
                                 hash_meth='md5')
        self.assert_ok(r)

########NEW FILE########
__FILENAME__ = test_session
# -*- coding: utf-8 -*-
'''
    rauth.test_session
    ------------------

    Test suite for rauth.session.
'''

from base import RauthTestCase
from rauth.session import OAuth1Session, OAuth2Session, OflySession

from mock import patch

import requests

import json


class RequestMixin(object):
    def assert_ok(self, r):
        self.assertEqual(json.loads(r.content), {'status': 'ok'})

    @patch.object(requests.Session, 'request')
    def test_request(self, mock_request, **kwargs):
        mock_request.return_value = self.response
        self.assert_ok(self.session.request('GET',
                                            'http://example.com/',
                                            **kwargs))


class OAuth1SessionTestCase(RauthTestCase, RequestMixin):
    def setUp(self):
        RauthTestCase.setUp(self)

        self.session = OAuth1Session('123', '345')

    @patch.object(requests.Session, 'request')
    def test_request_with_optional_params(self, mock_request):
        mock_request.return_value = self.response
        params = {'oauth_callback': 'http://example.com/callback'}
        r = self.session.request('GET', 'http://example.com/', params=params)
        self.assert_ok(r)

    @patch.object(requests.Session, 'request')
    def test_request_with_optional_params_as_string(self, mock_request):
        mock_request.return_value = self.response
        params = 'oauth_callback=http://example.com/callback'
        r = self.session.request('GET', 'http://example.com/', params=params)
        self.assert_ok(r)

    @patch.object(requests.Session, 'request')
    def test_request_with_optional_data_as_string(self, mock_request):
        mock_request.return_value = self.response
        data = 'oauth_callback=http://example.com/callback'
        r = self.session.request('POST', 'http://example.com/', data=data)
        self.assert_ok(r)

    @patch.object(requests.Session, 'request')
    def test_request_with_optional_params_with_data(self, mock_request):
        mock_request.return_value = self.response
        data = {'oauth_callback': 'http://example.com/callback'}
        r = self.session.request('POST', 'http://example.com/', data=data)
        self.assert_ok(r)

    @patch.object(requests.Session, 'request')
    def test_request_with_header_auth(self, mock_request):
        mock_request.return_value = self.response
        r = self.session.request('GET',
                                 'http://example.com/',
                                 header_auth=True)
        self.assert_ok(r)

    @patch.object(requests.Session, 'request')
    def test_request_with_not_alphanumeric_data_as_string(self, mock_request):
        mock_request.return_value = self.response
        data = 'foo='
        r = self.session.request('POST', 'http://example.com/', data=data)
        self.assert_ok(r)

    @patch.object(requests.Session, 'request')
    def test_request_with_not_alphanumeric_data_as_dict(self, mock_request):
        mock_request.return_value = self.response
        data = {'foo': ''}
        r = self.session.request('POST', 'http://example.com/', data=data)
        self.assert_ok(r)


class OAuth2SessionTestCase(RauthTestCase, RequestMixin):
    def setUp(self):
        RauthTestCase.setUp(self)

        self.session = OAuth2Session('123', '345')
        self.session_no_creds = OAuth2Session()

    def test_with_credentials(self):
        assert self.session.client_id == '123'
        assert self.session.client_secret == '345'

    def test_without_credentials(self):
        assert self.session_no_creds.client_id is None
        assert self.session_no_creds.client_secret is None


class OflySessionTestCase(RauthTestCase, RequestMixin):
    def setUp(self):
        RauthTestCase.setUp(self)

        self.session = OflySession('123', '345')

    def test_request(self):
        return super(OflySessionTestCase, self).test_request(user_id='123')

    @patch.object(requests.Session, 'request')
    def test_request_with_header_auth(self, mock_request):
        mock_request.return_value = self.response
        r = self.session.request('GET',
                                 'http://example.com/',
                                 user_id='123',
                                 header_auth=True)
        self.assert_ok(r)

    @patch.object(requests.Session, 'request')
    def test_request_with_md5(self, mock_request):
        mock_request.return_value = self.response
        r = self.session.request('GET',
                                 'http://example.com/',
                                 user_id='123',
                                 hash_meth='md5')
        self.assert_ok(r)

    @patch.object(requests.Session, 'request')
    def test_request_with_bad_hash_meth(self, mock_request):
        mock_request.return_value = self.response
        with self.assertRaises(TypeError) as e:
            self.session.request('GET',
                                 'http://example.com/',
                                 user_id='123',
                                 hash_meth='foo')
        self.assertEqual(str(e.exception),
                         'hash_meth must be one of "sha1", "md5"')

########NEW FILE########
__FILENAME__ = test_utils
# -*- coding: utf-8 -*-
'''
    rauth.test_utils
    ----------------

    Test suite for rauth.utils.
'''

from base import RauthTestCase
from rauth.utils import (absolute_url, CaseInsensitiveDict,
                         parse_utf8_qsl, OAuth1Auth, OAuth2Auth)
from requests import Request


class UtilsTestCase(RauthTestCase):
    def test_absolute_url(self):
        self.assertTrue(absolute_url('http://example.com/'))

    def test_absolute_url_https(self):
        self.assertTrue(absolute_url('https://example.com/'))

    def test_not_absolute_url(self):
        self.assertFalse(absolute_url('/some/resource'))

    def test_parse_utf8_qsl(self):
        d = parse_utf8_qsl('f=bar&rauth=ber')
        self.assertEqual(d, {u'rauth': u'\xfcber', u'f\xfc': u'bar'})

    def test_both_kv_unicode(self):
        d = parse_utf8_qsl(u'f=bar&rauth=ber')
        self.assertEqual(d, {u'rauth': u'\xfcber', u'f\xfc': u'bar'})

    def test_rauth_case_insensitive_dict(self):
        d = CaseInsensitiveDict()
        d.setdefault('Content-Type', 'foo')

        d.update({'content-type': 'bar'})

        self.assertEqual(1, len(d.keys()))
        self.assertIn('content-type', d.keys())
        self.assertEqual({'content-type': 'bar'}, d)

        d.update({'CONTENT-TYPE': 'baz'})

        self.assertEqual(1, len(d.keys()))
        self.assertIn('content-type', d.keys())
        self.assertEqual({'content-type': 'baz'}, d)

    def test_rauth_case_insensitive_dict_list_of_tuples(self):
        d = CaseInsensitiveDict([('Content-Type', 'foo')])
        self.assertEqual(d, {'content-type': 'foo'})

    def test_oauth1_auth(self):
        oauth_params = dict(hello='world', foo='bar')

        auth = OAuth1Auth(oauth_params, None)
        r = auth(Request())
        self.assertTrue(r.headers['Authorization'] in
                        ('OAuth realm="",hello="world",foo="bar"',
                         'OAuth realm="",foo="bar",hello="world"'))

        auth = OAuth1Auth(oauth_params, 'example')
        r = auth(Request())
        self.assertTrue(r.headers['Authorization'] in
                        ('OAuth realm="example",hello="world",foo="bar"',
                         'OAuth realm="example",foo="bar",hello="world"'))

    def test_oauth2_auth(self):
        access_token = 'abcdefg'
        auth = OAuth2Auth(access_token)
        r = auth(Request())
        self.assertEqual(r.headers['Authorization'],
                         'Bearer ' + access_token)

########NEW FILE########
